tbl;

    interface IWbemProviderInit
    {
        CONST_VTBL struct IWbemProviderInitVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemProviderInit_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemProviderInit_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemProviderInit_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemProviderInit_Initialize(This,wszUser,lFlags,wszNamespace,wszLocale,pNamespace,pCtx,pInitSink)	\
    (This)->lpVtbl -> Initialize(This,wszUser,lFlags,wszNamespace,wszLocale,pNamespace,pCtx,pInitSink)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemProviderInit_Initialize_Proxy( 
    IWbemProviderInit * This,
    /* [string][unique][in] */ LPWSTR wszUser,
    /* [in] */ LONG lFlags,
    /* [string][in] */ LPWSTR wszNamespace,
    /* [string][unique][in] */ LPWSTR wszLocale,
    /* [in] */ IWbemServices *pNamespace,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemProviderInitSink *pInitSink);


void __RPC_STUB IWbemProviderInit_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemProviderInit_INTERFACE_DEFINED__ */


#ifndef __IWbemHiPerfProvider_INTERFACE_DEFINED__
#define __IWbemHiPerfProvider_INTERFACE_DEFINED__

/* interface IWbemHiPerfProvider */
/* [uuid][object][restricted][local] */ 


EXTERN_C const IID IID_IWbemHiPerfProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49353c93-516b-11d1-aea6-00c04fb68820")
    IWbemHiPerfProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryInstances( 
            /* [in] */ IWbemServices *pNamespace,
            /* [string][in] */ WCHAR *wszClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateRefresher( 
            /* [in] */ IWbemServices *pNamespace,
            /* [in] */ long lFlags,
            /* [out] */ IWbemRefresher **ppRefresher) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateRefreshableObject( 
            /* [in] */ IWbemServices *pNamespace,
            /* [in] */ IWbemObjectAccess *pTemplate,
            /* [in] */ IWbemRefresher *pRefresher,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pContext,
            /* [out] */ IWbemObjectAccess **ppRefreshable,
            /* [out] */ long *plId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopRefreshing( 
            /* [in] */ IWbemRefresher *pRefresher,
            /* [in] */ long lId,
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateRefreshableEnum( 
            /* [in] */ IWbemServices *pNamespace,
            /* [string][in] */ LPCWSTR wszClass,
            /* [in] */ IWbemRefresher *pRefresher,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pContext,
            /* [in] */ IWbemHiPerfEnum *pHiPerfEnum,
            /* [out] */ long *plId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjects( 
            /* [in] */ IWbemServices *pNamespace,
            /* [in] */ long lNumObjects,
            /* [size_is][out][in] */ IWbemObjectAccess **apObj,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemHiPerfProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemHiPerfProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemHiPerfProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemHiPerfProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryInstances )( 
            IWbemHiPerfProvider * This,
            /* [in] */ IWbemServices *pNamespace,
            /* [string][in] */ WCHAR *wszClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pSink);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRefresher )( 
            IWbemHiPerfProvider * This,
            /* [in] */ IWbemServices *pNamespace,
            /* [in] */ long lFlags,
            /* [out] */ IWbemRefresher **ppRefresher);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRefreshableObject )( 
            IWbemHiPerfProvider * This,
            /* [in] */ IWbemServices *pNamespace,
            /* [in] */ IWbemObjectAccess *pTemplate,
            /* [in] */ IWbemRefresher *pRefresher,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pContext,
            /* [out] */ IWbemObjectAccess **ppRefreshable,
            /* [out] */ long *plId);
        
        HRESULT ( STDMETHODCALLTYPE *StopRefreshing )( 
            IWbemHiPerfProvider * This,
            /* [in] */ IWbemRefresher *pRefresher,
            /* [in] */ long lId,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRefreshableEnum )( 
            IWbemHiPerfProvider * This,
            /* [in] */ IWbemServices *pNamespace,
            /* [string][in] */ LPCWSTR wszClass,
            /* [in] */ IWbemRefresher *pRefresher,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pContext,
            /* [in] */ IWbemHiPerfEnum *pHiPerfEnum,
            /* [out] */ long *plId);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjects )( 
            IWbemHiPerfProvider * This,
            /* [in] */ IWbemServices *pNamespace,
            /* [in] */ long lNumObjects,
            /* [size_is][out][in] */ IWbemObjectAccess **apObj,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pContext);
        
        END_INTERFACE
    } IWbemHiPerfProviderVtbl;

    interface IWbemHiPerfProvider
    {
        CONST_VTBL struct IWbemHiPerfProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemHiPerfProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemHiPerfProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemHiPerfProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemHiPerfProvider_QueryInstances(This,pNamespace,wszClass,lFlags,pCtx,pSink)	\
    (This)->lpVtbl -> QueryInstances(This,pNamespace,wszClass,lFlags,pCtx,pSink)

#define IWbemHiPerfProvider_CreateRefresher(This,pNamespace,lFlags,ppRefresher)	\
    (This)->lpVtbl -> CreateRefresher(This,pNamespace,lFlags,ppRefresher)

#define IWbemHiPerfProvider_CreateRefreshableObject(This,pNamespace,pTemplate,pRefresher,lFlags,pContext,ppRefreshable,plId)	\
    (This)->lpVtbl -> CreateRefreshableObject(This,pNamespace,pTemplate,pRefresher,lFlags,pContext,ppRefreshable,plId)

#define IWbemHiPerfProvider_StopRefreshing(This,pRefresher,lId,lFlags)	\
    (This)->lpVtbl -> StopRefreshing(This,pRefresher,lId,lFlags)

#define IWbemHiPerfProvider_CreateRefreshableEnum(This,pNamespace,wszClass,pRefresher,lFlags,pContext,pHiPerfEnum,plId)	\
    (This)->lpVtbl -> CreateRefreshableEnum(This,pNamespace,wszClass,pRefresher,lFlags,pContext,pHiPerfEnum,plId)

#define IWbemHiPerfProvider_GetObjects(This,pNamespace,lNumObjects,apObj,lFlags,pContext)	\
    (This)->lpVtbl -> GetObjects(This,pNamespace,lNumObjects,apObj,lFlags,pContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemHiPerfProvider_QueryInstances_Proxy( 
    IWbemHiPerfProvider * This,
    /* [in] */ IWbemServices *pNamespace,
    /* [string][in] */ WCHAR *wszClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pSink);


void __RPC_STUB IWbemHiPerfProvider_QueryInstances_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemHiPerfProvider_CreateRefresher_Proxy( 
    IWbemHiPerfProvider * This,
    /* [in] */ IWbemServices *pNamespace,
    /* [in] */ long lFlags,
    /* [out] */ IWbemRefresher **ppRefresher);


void __RPC_STUB IWbemHiPerfProvider_CreateRefresher_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemHiPerfProvider_CreateRefreshableObject_Proxy( 
    IWbemHiPerfProvider * This,
    /* [in] */ IWbemServices *pNamespace,
    /* [in] */ IWbemObjectAccess *pTemplate,
    /* [in] */ IWbemRefresher *pRefresher,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pContext,
    /* [out] */ IWbemObjectAccess **ppRefreshable,
    /* [out] */ long *plId);


void __RPC_STUB IWbemHiPerfProvider_CreateRefreshableObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemHiPerfProvider_StopRefreshing_Proxy( 
    IWbemHiPerfProvider * This,
    /* [in] */ IWbemRefresher *pRefresher,
    /* [in] */ long lId,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemHiPerfProvider_StopRefreshing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemHiPerfProvider_CreateRefreshableEnum_Proxy( 
    IWbemHiPerfProvider * This,
    /* [in] */ IWbemServices *pNamespace,
    /* [string][in] */ LPCWSTR wszClass,
    /* [in] */ IWbemRefresher *pRefresher,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pContext,
    /* [in] */ IWbemHiPerfEnum *pHiPerfEnum,
    /* [out] */ long *plId);


void __RPC_STUB IWbemHiPerfProvider_CreateRefreshableEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemHiPerfProvider_GetObjects_Proxy( 
    IWbemHiPerfProvider * This,
    /* [in] */ IWbemServices *pNamespace,
    /* [in] */ long lNumObjects,
    /* [size_is][out][in] */ IWbemObjectAccess **apObj,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pContext);


void __RPC_STUB IWbemHiPerfProvider_GetObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemHiPerfProvider_INTERFACE_DEFINED__ */


#ifndef __IWbemDecoupledRegistrar_INTERFACE_DEFINED__
#define __IWbemDecoupledRegistrar_INTERFACE_DEFINED__

/* interface IWbemDecoupledRegistrar */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IWbemDecoupledRegistrar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1005cbcf-e64f-4646-bcd3-3a089d8a84b4")
    IWbemDecoupledRegistrar : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Register( 
            /* [in] */ long a_Flags,
            /* [in] */ IWbemContext *a_Context,
            /* [in] */ LPCWSTR a_User,
            /* [in] */ LPCWSTR a_Locale,
            /* [in] */ LPCWSTR a_Scope,
            /* [in] */ LPCWSTR a_Registration,
            /* [in] */ IUnknown *a_Unknown) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnRegister( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemDecoupledRegistrarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemDecoupledRegistrar * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemDecoupledRegistrar * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemDecoupledRegistrar * This);
        
        HRESULT ( STDMETHODCALLTYPE *Register )( 
            IWbemDecoupledRegistrar * This,
            /* [in] */ long a_Flags,
            /* [in] */ IWbemContext *a_Context,
            /* [in] */ LPCWSTR a_User,
            /* [in] */ LPCWSTR a_Locale,
            /* [in] */ LPCWSTR a_Scope,
            /* [in] */ LPCWSTR a_Registration,
            /* [in] */ IUnknown *a_Unknown);
        
        HRESULT ( STDMETHODCALLTYPE *UnRegister )( 
            IWbemDecoupledRegistrar * This);
        
        END_INTERFACE
    } IWbemDecoupledRegistrarVtbl;

    interface IWbemDecoupledRegistrar
    {
        CONST_VTBL struct IWbemDecoupledRegistrarVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemDecoupledRegistrar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemDecoupledRegistrar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemDecoupledRegistrar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemDecoupledRegistrar_Register(This,a_Flags,a_Context,a_User,a_Locale,a_Scope,a_Registration,a_Unknown)	\
    (This)->lpVtbl -> Register(This,a_Flags,a_Context,a_User,a_Locale,a_Scope,a_Registration,a_Unknown)

#define IWbemDecoupledRegistrar_UnRegister(This)	\
    (This)->lpVtbl -> UnRegister(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemDecoupledRegistrar_Register_Proxy( 
    IWbemDecoupledRegistrar * This,
    /* [in] */ long a_Flags,
    /* [in] */ IWbemContext *a_Context,
    /* [in] */ LPCWSTR a_User,
    /* [in] */ LPCWSTR a_Locale,
    /* [in] */ LPCWSTR a_Scope,
    /* [in] */ LPCWSTR a_Registration,
    /* [in] */ IUnknown *a_Unknown);


void __RPC_STUB IWbemDecoupledRegistrar_Register_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemDecoupledRegistrar_UnRegister_Proxy( 
    IWbemDecoupledRegistrar * This);


void __RPC_STUB IWbemDecoupledRegistrar_UnRegister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemDecoupledRegistrar_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_WbemAdministrativeLocator;

#ifdef __cplusplus

class DECLSPEC_UUID("cb8555cc-9128-11d1-ad9b-00c04fd8fdff")
WbemAdministrativeLocator;
#endif

EXTERN_C const CLSID CLSID_WbemAuthenticatedLocator;

#ifdef __cplusplus

class DECLSPEC_UUID("cd184336-9128-11d1-ad9b-00c04fd8fdff")
WbemAuthenticatedLocator;
#endif

EXTERN_C const CLSID CLSID_WbemUnauthenticatedLocator;

#ifdef __cplusplus

class DECLSPEC_UUID("443E7B79-DE31-11d2-B340-00104BCC4B4A")
WbemUnauthenticatedLocator;
#endif

EXTERN_C const CLSID CLSID_WbemDecoupledRegistrar;

#ifdef __cplusplus

class DECLSPEC_UUID("4cfc7932-0f9d-4bef-9c32-8ea2a6b56fcb")
WbemDecoupledRegistrar;
#endif

EXTERN_C const CLSID CLSID_WbemDecoupledBasicEventProvider;

#ifdef __cplusplus

class DECLSPEC_UUID("f5f75737-2843-4f22-933d-c76a97cda62f")
WbemDecoupledBasicEventProvider;
#endif
#endif /* __WbemProviders_v1_LIBRARY_DEFINED__ */

#ifndef __IWbemProviderIdentity_INTERFACE_DEFINED__
#define __IWbemProviderIdentity_INTERFACE_DEFINED__

/* interface IWbemProviderIdentity */
/* [uuid][object][restricted] */ 


EXTERN_C const IID IID_IWbemProviderIdentity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("631f7d97-d993-11d2-b339-00105a1f4aaf")
    IWbemProviderIdentity : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetRegistrationObject( 
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pProvReg) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemProviderIdentityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemProviderIdentity * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemProviderIdentity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemProviderIdentity * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetRegistrationObject )( 
            IWbemProviderIdentity * This,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pProvReg);
        
        END_INTERFACE
    } IWbemProviderIdentityVtbl;

    interface IWbemProviderIdentity
    {
        CONST_VTBL struct IWbemProviderIdentityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemProviderIdentity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemProviderIdentity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemProviderIdentity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemProviderIdentity_SetRegistrationObject(This,lFlags,pProvReg)	\
    (This)->lpVtbl -> SetRegistrationObject(This,lFlags,pProvReg)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemProviderIdentity_SetRegistrationObject_Proxy( 
    IWbemProviderIdentity * This,
    /* [in] */ long lFlags,
    /* [in] */ IWbemClassObject *pProvReg);


void __RPC_STUB IWbemProviderIdentity_SetRegistrationObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemProviderIdentity_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wbemprov_0164 */
/* [local] */ 

typedef 
enum tag_WBEM_EXTRA_RETURN_CODES
    {	WBEM_S_INITIALIZED	= 0,
	WBEM_S_LIMITED_SERVICE	= 0x43001,
	WBEM_S_INDIRECTLY_UPDATED	= WBEM_S_LIMITED_SERVICE + 1,
	WBEM_S_SUBJECT_TO_SDS	= WBEM_S_INDIRECTLY_UPDATED + 1,
	WBEM_E_RETRY_LATER	= 0x80043001,
	WBEM_E_RESOURCE_CONTENTION	= WBEM_E_RETRY_LATER + 1
    } 	WBEM_EXTRA_RETURN_CODES;

typedef 
enum tag_WBEM_PROVIDER_FLAGS
    {	WBEM_FLAG_OWNER_UPDATE	= 0x10000
    } 	WBEM_PROVIDER_FLAGS;



extern RPC_IF_HANDLE __MIDL_itf_wbemprov_0164_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemprov_0164_v0_0_s_ifspec;

#ifndef __IWbemDecoupledBasicEventProvider_INTERFACE_DEFINED__
#define __IWbemDecoupledBasicEventProvider_INTERFACE_DEFINED__

/* interface IWbemDecoupledBasicEventProvider */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IWbemDecoupledBasicEventProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("86336d20-ca11-4786-9ef1-bc8a946b42fc")
    IWbemDecoupledBasicEventProvider : public IWbemDecoupledRegistrar
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSink( 
            /* [in] */ long a_Flags,
            /* [in] */ IWbemContext *a_Context,
            /* [out] */ IWbemObjectSink **a_Sink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetService( 
            /* [in] */ long a_Flags,
            /* [in] */ IWbemContext *a_Context,
            /* [out] */ IWbemServices **a_Service) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemDecoupledBasicEventProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemDecoupledBasicEventProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemDecoupledBasicEventProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemDecoupledBasicEventProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Register )( 
            IWbemDecoupledBasicEventProvider * This,
            /* [in] */ long a_Flags,
            /* [in] */ IWbemContext *a_Context,
            /* [in] */ LPCWSTR a_User,
            /* [in] */ LPCWSTR a_Locale,
            /* [in] */ LPCWSTR a_Scope,
            /* [in] */ LPCWSTR a_Registration,
            /* [in] */ IUnknown *a_Unknown);
        
        HRESULT ( STDMETHODCALLTYPE *UnRegister )( 
            IWbemDecoupledBasicEventProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSink )( 
            IWbemDecoupledBasicEventProvider * This,
            /* [in] */ long a_Flags,
            /* [in] */ IWbemContext *a_Context,
            /* [out] */ IWbemObjectSink **a_Sink);
        
        HRESULT ( STDMETHODCALLTYPE *GetService )( 
            IWbemDecoupledBasicEventProvider * This,
            /* [in] */ long a_Flags,
            /* [in] */ IWbemContext *a_Context,
            /* [out] */ IWbemServices **a_Service);
        
        END_INTERFACE
    } IWbemDecoupledBasicEventProviderVtbl;

    interface IWbemDecoupledBasicEventProvider
    {
        CONST_VTBL struct IWbemDecoupledBasicEventProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemDecoupledBasicEventProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemDecoupledBasicEventProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemDecoupledBasicEventProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemDecoupledBasicEventProvider_Register(This,a_Flags,a_Context,a_User,a_Locale,a_Scope,a_Registration,a_Unknown)	\
    (This)->lpVtbl -> Register(This,a_Flags,a_Context,a_User,a_Locale,a_Scope,a_Registration,a_Unknown)

#define IWbemDecoupledBasicEventProvider_UnRegister(This)	\
    (This)->lpVtbl -> UnRegister(This)


#define IWbemDecoupledBasicEventProvider_GetSink(This,a_Flags,a_Context,a_Sink)	\
    (This)->lpVtbl -> GetSink(This,a_Flags,a_Context,a_Sink)

#define IWbemDecoupledBasicEventProvider_GetService(This,a_Flags,a_Context,a_Service)	\
    (This)->lpVtbl -> GetService(This,a_Flags,a_Context,a_Service)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemDecoupledBasicEventProvider_GetSink_Proxy( 
    IWbemDecoupledBasicEventProvider * This,
    /* [in] */ long a_Flags,
    /* [in] */ IWbemContext *a_Context,
    /* [out] */ IWbemObjectSink **a_Sink);


void __RPC_STUB IWbemDecoupledBasicEventProvider_GetSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemDecoupledBasicEventProvider_GetService_Proxy( 
    IWbemDecoupledBasicEventProvider * This,
    /* [in] */ long a_Flags,
    /* [in] */ IWbemContext *a_Context,
    /* [out] */ IWbemServices **a_Service);


void __RPC_STUB IWbemDecoupledBasicEventProvider_GetService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemDecoupledBasicEventProvider_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wminet_utils\dlldatax.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#if !defined(AFX_DLLDATAX_H__376FCAE7_AAA9_465A_9024_EB65C84A5235__INCLUDED_)
#define AFX_DLLDATAX_H__376FCAE7_AAA9_465A_9024_EB65C84A5235__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__376FCAE7_AAA9_465A_9024_EB65C84A5235__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\upgdreg\upgdreg.cpp ===
/*
    ------------------------------------------------------------------------------------------------------------------------
   | Copyright (C) 2002 Microsoft Corporation
   | 
   | Module Name:
   | UPGDREG.CPP
   |
   | History:
   | 4/17/2002	marioh	created.
   |
   | Description:
   | Used for the purpose of registering WMINet_Utils via COPYURT. Self-registration code will be removed from WMINet_Utils
   | and therefore requires alternate form of registration. The following CLSIDs are changed in the registry:
   |
   |	{A8F03BE3-EDB7-4972-821F-AF6F8EA34884}		CLSID_WmiSecurityHelper
   |	{D2EAA715-DAC7-4771-AF5C-931611A1853C}		CLSID_WmiSinkDemultiplexor
   |
   | Each CLSID key will contain the following structure:
   |
   |	HKEY_CLASSES_ROOT\CLSID\<clsid>
   |									\InProcServer32		= <default, REG_SZ>			=  %windir%\system(32)\mscoree.dll
   |									\InProcServer32     = <ThreadingModel,REG_SZ>	= Both
   |									\Server				= (default, REG_SZ) wminet_utils.dll
   |									\ProgID				= (default, REG_SZ)
   |									\VersionIndependentProgID = (default, REG_SZ)
   |
   | %windir% is expanded. system32 or system depending on if on NT+ or Win9x.
   |
   | Note: If WMINet_Utils.DLL ever adds additional CLSIDs, they will have to be reflected in this app for COPYURT to work.
   | Note: Intentionally ANSI so to work on Win9x platforms as well.
    ------------------------------------------------------------------------------------------------------------------------
*/

#include <stdio.h>
#include <windows.h>

//
// Global string definitions
// 
CHAR* pDLLName					= "WMINet_Utils.dll" ;

CHAR* pProgIDWmiSec				= "WMINet_Utils.WmiSecurityHelper.1";
CHAR* pProgIDWmiPlex			= "WMINet_Utils.WmiSinkDemultiplexor.1";

CHAR* pVProgIDWmiSec			= "WMINet_Utils.WmiSecurityHelper";
CHAR* pVProgIDWmiPlex			= "WMINet_Utils.WmiSinkDemultiplexor";

CHAR* CLSID_WmiSecurityHelper	= "{A8F03BE3-EDB7-4972-821F-AF6F8EA34884}" ;
CHAR* CLSID_WmiSinkDemultiplexor= "{D2EAA715-DAC7-4771-AF5C-931611A1853C}" ;
CHAR* pThreadingModel			= "Both" ;

//
// Func. prototypes.
//
HRESULT UpgradeRTMClsId ( CHAR*, CHAR*, CHAR*, CHAR* ) ;


//
// Auto close for registry handles
//
class CloseRegKey
{
private:
	HKEY m_hKey ;
public:
	CloseRegKey ( ) { m_hKey = 0 ; } ;
	CloseRegKey ( HKEY key ) : m_hKey (0) { m_hKey = key; } ;
	~CloseRegKey ( ) { if ( m_hKey != 0 ) CloseRegKey ( m_hKey ) ; } ;
};



/*
    ------------------------------------------------------------------------------------------------------------------------
   | VOID main ( VOID )
    ------------------------------------------------------------------------------------------------------------------------
*/
VOID __cdecl main ( VOID )
{
	if ( FAILED ( UpgradeRTMClsId ( CLSID_WmiSecurityHelper, pProgIDWmiSec, pVProgIDWmiSec, "WmiSecurityHelper Class" ) ) )
	{
		printf ( "Failed to upgrade %s", CLSID_WmiSecurityHelper ) ;
	}
	else if ( FAILED ( UpgradeRTMClsId ( CLSID_WmiSinkDemultiplexor, pProgIDWmiPlex, pVProgIDWmiPlex, "WmiSinkDemultiplexor Class" ) ) )
	{
		printf ( "Failed to upgrade %s", CLSID_WmiSinkDemultiplexor ) ;
	}
}


/*
    ------------------------------------------------------------------------------------------------------------------------
   | HRESULT UpgradeRTMClsId ( CHAR* szClsId, CHAR* szProgId, CHAR* szVProgId )
   |
   | Upgrades the specified CLSID to following registry structure:
   |
   | HKEY_CLASSES_ROOT\CLSID\<clsid>
   |								\InProcServer32		= <default, REG_SZ>			=  %windir%\system(32)\mscoree.dll
   |								\InProcServer32     = <ThreadingModel,REG_SZ>	= Both
   |								\Server				= (default, REG_SZ) wminet_utils.dll
   |
   | Always overwrites without checking existence of previous key.
   |
   | Return:
   |				S_OK		-> Successfull registry write
   |		E_UNEXPECTED		-> Failed registry write
   |
    ------------------------------------------------------------------------------------------------------------------------
*/
HRESULT UpgradeRTMClsId ( CHAR* szClsId, CHAR* szProgId, CHAR* szVProgId, CHAR* szClsidName )
{
	HRESULT hRes = E_UNEXPECTED ;
	CHAR	szInProcKeyName[1024] ;
	CHAR	szServerKeyName[1024] ;
	CHAR	szClsidKeyName[1024] ;
	CHAR	szProgIDName[1024] ;
	CHAR    szVProgIDName[1024] ;
	HKEY	hInProcServer ;
	HKEY	hServer ;
	HKEY	hProgID ;
	HKEY	hVersionIndProgID ;
	HKEY	hClsid ;

	//
	// Create full paths in registry
	// 
	strcpy ( szInProcKeyName, "CLSID\\" ) ;
	strcat ( szInProcKeyName, szClsId ) ;
	strcpy ( szClsidKeyName, szInProcKeyName ) ;
	strcpy ( szServerKeyName, szInProcKeyName ) ;
	strcpy ( szProgIDName, szInProcKeyName ) ;
	strcpy ( szVProgIDName, szInProcKeyName ) ;
	strcat ( szInProcKeyName, "\\InProcServer32" ) ;
	strcat ( szServerKeyName, "\\Server" ) ;
	strcat ( szProgIDName, "\\ProgID" ) ;
	strcat ( szVProgIDName, "\\VersionIndependentProgID" ) ;
	
	//
	// Create the CLSID key
	//
	if ( RegCreateKeyEx ( HKEY_CLASSES_ROOT, szClsidKeyName, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hClsid, NULL ) == ERROR_SUCCESS )
	{
		CloseRegKey closeClsidKey ( hClsid ) ;
		//
		// Set default value to szClsidName
		//
		if ( RegSetValueExA ( hClsid, NULL, 0, REG_SZ, (BYTE*) szClsidName, (DWORD) strlen ( szClsidName )+1 ) != ERROR_SUCCESS )
		{
			return hRes ;
		}
	}
	else
	{
		return hRes ;
	}

	//
	// Create the InProcServer32 key
	//
	if ( RegCreateKeyEx ( HKEY_CLASSES_ROOT, szInProcKeyName, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hInProcServer, NULL ) == ERROR_SUCCESS )
	{
		CloseRegKey closeInProcKey ( hInProcServer ) ;

		//
		// Set the default value to the path to mscoree.dll
		// Note: Must be carefull. On W9X boxes, the system path is 'system'
		// and not system32
		//
		CHAR szSysDir[MAX_PATH+128] ;

		GetSystemDirectoryA ( szSysDir, MAX_PATH+1 ) ;
		strcat ( szSysDir, "\\mscoree.dll" ) ;

		//
		// Now write the default value
		//
		if ( RegSetValueExA ( hInProcServer, NULL, 0, REG_SZ, (BYTE*) szSysDir, (DWORD) strlen ( szSysDir )+1 ) == ERROR_SUCCESS )
		{
			//
			// Now write the ThreadingModel value to Both
			//
			if ( RegSetValueExA ( hInProcServer, "ThreadingModel", 0, REG_SZ, (BYTE*) pThreadingModel, (DWORD) strlen ( pThreadingModel )+1 ) == ERROR_SUCCESS )
			{
				//
				// Next, the Server key is created
				//
				if ( RegCreateKeyEx ( HKEY_CLASSES_ROOT, szServerKeyName, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hServer, NULL ) == ERROR_SUCCESS )
				{
					CloseRegKey closeServerKey ( hServer ) ;

					//
					// Write the default value to WMINet_Utils.DLL
					// 
					if ( RegSetValueExA ( hServer, NULL, 0, REG_SZ, (BYTE*) pDLLName, (DWORD)strlen ( pDLLName )+1 ) == ERROR_SUCCESS )
					{
						//
						// Create the ProgID key
						//
						if ( RegCreateKeyEx ( HKEY_CLASSES_ROOT, szProgIDName, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hProgID, NULL ) == ERROR_SUCCESS )
						{
							CloseRegKey closeProgIdKey ( hProgID ) ;

							//
							// Write the default value to szProgId
							// 
							if ( RegSetValueExA ( hProgID, NULL, 0, REG_SZ, (BYTE*) szProgId, (DWORD)strlen ( szProgId )+1 ) == ERROR_SUCCESS )
							{
								//
								// Create the Version independent ProgID key
								//
								if ( RegCreateKeyEx ( HKEY_CLASSES_ROOT, szVProgIDName, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hVersionIndProgID, NULL ) == ERROR_SUCCESS )
								{
									CloseRegKey closeVProgIdKey ( hVersionIndProgID ) ;

									//
									// Write the default value to szVProgId
									// 
									if ( RegSetValueExA ( hVersionIndProgID, NULL, 0, REG_SZ, (BYTE*) szVProgId, (DWORD)strlen ( szVProgId )+1 ) == ERROR_SUCCESS )
									{
										hRes = S_OK ;
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return hRes ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\psdk_inc\wbemtran.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0341 */
/* Compiler settings for wbemtran.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wbemtran_h__
#define __wbemtran_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWbemTransport_FWD_DEFINED__
#define __IWbemTransport_FWD_DEFINED__
typedef interface IWbemTransport IWbemTransport;
#endif 	/* __IWbemTransport_FWD_DEFINED__ */


#ifndef __IWbemLevel1Login_FWD_DEFINED__
#define __IWbemLevel1Login_FWD_DEFINED__
typedef interface IWbemLevel1Login IWbemLevel1Login;
#endif 	/* __IWbemLevel1Login_FWD_DEFINED__ */


#ifndef __IWbemConnectorLogin_FWD_DEFINED__
#define __IWbemConnectorLogin_FWD_DEFINED__
typedef interface IWbemConnectorLogin IWbemConnectorLogin;
#endif 	/* __IWbemConnectorLogin_FWD_DEFINED__ */


#ifndef __IWbemAddressResolution_FWD_DEFINED__
#define __IWbemAddressResolution_FWD_DEFINED__
typedef interface IWbemAddressResolution IWbemAddressResolution;
#endif 	/* __IWbemAddressResolution_FWD_DEFINED__ */


#ifndef __WbemLevel1Login_FWD_DEFINED__
#define __WbemLevel1Login_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemLevel1Login WbemLevel1Login;
#else
typedef struct WbemLevel1Login WbemLevel1Login;
#endif /* __cplusplus */

#endif 	/* __WbemLevel1Login_FWD_DEFINED__ */


#ifndef __WbemLocalAddrRes_FWD_DEFINED__
#define __WbemLocalAddrRes_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemLocalAddrRes WbemLocalAddrRes;
#else
typedef struct WbemLocalAddrRes WbemLocalAddrRes;
#endif /* __cplusplus */

#endif 	/* __WbemLocalAddrRes_FWD_DEFINED__ */


#ifndef __WbemUninitializedClassObject_FWD_DEFINED__
#define __WbemUninitializedClassObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemUninitializedClassObject WbemUninitializedClassObject;
#else
typedef struct WbemUninitializedClassObject WbemUninitializedClassObject;
#endif /* __cplusplus */

#endif 	/* __WbemUninitializedClassObject_FWD_DEFINED__ */


#ifndef __IWbemClientTransport_FWD_DEFINED__
#define __IWbemClientTransport_FWD_DEFINED__
typedef interface IWbemClientTransport IWbemClientTransport;
#endif 	/* __IWbemClientTransport_FWD_DEFINED__ */


#ifndef __IWbemClientConnectionTransport_FWD_DEFINED__
#define __IWbemClientConnectionTransport_FWD_DEFINED__
typedef interface IWbemClientConnectionTransport IWbemClientConnectionTransport;
#endif 	/* __IWbemClientConnectionTransport_FWD_DEFINED__ */


#ifndef __WbemDCOMTransport_FWD_DEFINED__
#define __WbemDCOMTransport_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemDCOMTransport WbemDCOMTransport;
#else
typedef struct WbemDCOMTransport WbemDCOMTransport;
#endif /* __cplusplus */

#endif 	/* __WbemDCOMTransport_FWD_DEFINED__ */


#ifndef __IWbemLevel1Login_FWD_DEFINED__
#define __IWbemLevel1Login_FWD_DEFINED__
typedef interface IWbemLevel1Login IWbemLevel1Login;
#endif 	/* __IWbemLevel1Login_FWD_DEFINED__ */


#ifndef __IWbemConnectorLogin_FWD_DEFINED__
#define __IWbemConnectorLogin_FWD_DEFINED__
typedef interface IWbemConnectorLogin IWbemConnectorLogin;
#endif 	/* __IWbemConnectorLogin_FWD_DEFINED__ */


#ifndef __IWbemAddressResolution_FWD_DEFINED__
#define __IWbemAddressResolution_FWD_DEFINED__
typedef interface IWbemAddressResolution IWbemAddressResolution;
#endif 	/* __IWbemAddressResolution_FWD_DEFINED__ */


#ifndef __IWbemTransport_FWD_DEFINED__
#define __IWbemTransport_FWD_DEFINED__
typedef interface IWbemTransport IWbemTransport;
#endif 	/* __IWbemTransport_FWD_DEFINED__ */


#ifndef __IWbemConstructClassObject_FWD_DEFINED__
#define __IWbemConstructClassObject_FWD_DEFINED__
typedef interface IWbemConstructClassObject IWbemConstructClassObject;
#endif 	/* __IWbemConstructClassObject_FWD_DEFINED__ */


#ifndef __IWbemClientTransport_FWD_DEFINED__
#define __IWbemClientTransport_FWD_DEFINED__
typedef interface IWbemClientTransport IWbemClientTransport;
#endif 	/* __IWbemClientTransport_FWD_DEFINED__ */


#ifndef __IWbemClientConnectionTransport_FWD_DEFINED__
#define __IWbemClientConnectionTransport_FWD_DEFINED__
typedef interface IWbemClientConnectionTransport IWbemClientConnectionTransport;
#endif 	/* __IWbemClientConnectionTransport_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"
#include "oaidl.h"
#include "wbemcli.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 


#ifndef __WbemTransports_v1_LIBRARY_DEFINED__
#define __WbemTransports_v1_LIBRARY_DEFINED__

/* library WbemTransports_v1 */
/* [uuid] */ 





typedef 
enum tag_WBEM_LOGIN_TYPE
    {	WBEM_FLAG_INPROC_LOGIN	= 0,
	WBEM_FLAG_LOCAL_LOGIN	= 1,
	WBEM_FLAG_REMOTE_LOGIN	= 2,
	WBEM_AUTHENTICATION_METHOD_MASK	= 0xf,
	WBEM_FLAG_USE_MULTIPLE_CHALLENGES	= 0x10
    } 	WBEM_LOGIN_TYPE;

typedef /* [length_is][size_is] */ BYTE *WBEM_128BITS;




EXTERN_C const IID LIBID_WbemTransports_v1;

#ifndef __IWbemTransport_INTERFACE_DEFINED__
#define __IWbemTransport_INTERFACE_DEFINED__

/* interface IWbemTransport */
/* [uuid][object][local][restricted] */ 


EXTERN_C const IID IID_IWbemTransport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("553fe584-2156-11d0-b6ae-00aa003240c7")
    IWbemTransport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemTransportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemTransport * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemTransport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemTransport * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IWbemTransport * This);
        
        END_INTERFACE
    } IWbemTransportVtbl;

    interface IWbemTransport
    {
        CONST_VTBL struct IWbemTransportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemTransport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemTransport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemTransport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemTransport_Initialize(This)	\
    (This)->lpVtbl -> Initialize(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemTransport_Initialize_Proxy( 
    IWbemTransport * This);


void __RPC_STUB IWbemTransport_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemTransport_INTERFACE_DEFINED__ */


#ifndef __IWbemLevel1Login_INTERFACE_DEFINED__
#define __IWbemLevel1Login_INTERFACE_DEFINED__

/* interface IWbemLevel1Login */
/* [unique][uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemLevel1Login;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F309AD18-D86A-11d0-A075-00C04FB68820")
    IWbemLevel1Login : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EstablishPosition( 
            /* [string][unique][in] */ LPWSTR wszClientMachineName,
            /* [in] */ DWORD dwProcessId,
            /* [out] */ DWORD *phAuthEventHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestChallenge( 
            /* [string][unique][in] */ LPWSTR wszNetworkResource,
            /* [string][unique][in] */ LPWSTR wszUser,
            /* [out] */ WBEM_128BITS Nonce) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WBEMLogin( 
            /* [string][unique][in] */ LPWSTR wszPreferredLocale,
            /* [unique][in] */ WBEM_128BITS AccessToken,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IWbemServices **ppNamespace) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NTLMLogin( 
            /* [string][unique][in] */ LPWSTR wszNetworkResource,
            /* [string][unique][in] */ LPWSTR wszPreferredLocale,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IWbemServices **ppNamespace) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemLevel1LoginVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemLevel1Login * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemLevel1Login * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemLevel1Login * This);
        
        HRESULT ( STDMETHODCALLTYPE *EstablishPosition )( 
            IWbemLevel1Login * This,
            /* [string][unique][in] */ LPWSTR wszClientMachineName,
            /* [in] */ DWORD dwProcessId,
            /* [out] */ DWORD *phAuthEventHandle);
        
        HRESULT ( STDMETHODCALLTYPE *RequestChallenge )( 
            IWbemLevel1Login * This,
            /* [string][unique][in] */ LPWSTR wszNetworkResource,
            /* [string][unique][in] */ LPWSTR wszUser,
            /* [out] */ WBEM_128BITS Nonce);
        
        HRESULT ( STDMETHODCALLTYPE *WBEMLogin )( 
            IWbemLevel1Login * This,
            /* [string][unique][in] */ LPWSTR wszPreferredLocale,
            /* [unique][in] */ WBEM_128BITS AccessToken,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IWbemServices **ppNamespace);
        
        HRESULT ( STDMETHODCALLTYPE *NTLMLogin )( 
            IWbemLevel1Login * This,
            /* [string][unique][in] */ LPWSTR wszNetworkResource,
            /* [string][unique][in] */ LPWSTR wszPreferredLocale,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IWbemServices **ppNamespace);
        
        END_INTERFACE
    } IWbemLevel1LoginVtbl;

    interface IWbemLevel1Login
    {
        CONST_VTBL struct IWbemLevel1LoginVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemLevel1Login_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemLevel1Login_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemLevel1Login_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemLevel1Login_EstablishPosition(This,wszClientMachineName,dwProcessId,phAuthEventHandle)	\
    (This)->lpVtbl -> EstablishPosition(This,wszClientMachineName,dwProcessId,phAuthEventHandle)

#define IWbemLevel1Login_RequestChallenge(This,wszNetworkResource,wszUser,Nonce)	\
    (This)->lpVtbl -> RequestChallenge(This,wszNetworkResource,wszUser,Nonce)

#define IWbemLevel1Login_WBEMLogin(This,wszPreferredLocale,AccessToken,lFlags,pCtx,ppNamespace)	\
    (This)->lpVtbl -> WBEMLogin(This,wszPreferredLocale,AccessToken,lFlags,pCtx,ppNamespace)

#define IWbemLevel1Login_NTLMLogin(This,wszNetworkResource,wszPreferredLocale,lFlags,pCtx,ppNamespace)	\
    (This)->lpVtbl -> NTLMLogin(This,wszNetworkResource,wszPreferredLocale,lFlags,pCtx,ppNamespace)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemLevel1Login_EstablishPosition_Proxy( 
    IWbemLevel1Login * This,
    /* [string][unique][in] */ LPWSTR wszClientMachineName,
    /* [in] */ DWORD dwProcessId,
    /* [out] */ DWORD *phAuthEventHandle);


void __RPC_STUB IWbemLevel1Login_EstablishPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemLevel1Login_RequestChallenge_Proxy( 
    IWbemLevel1Login * This,
    /* [string][unique][in] */ LPWSTR wszNetworkResource,
    /* [string][unique][in] */ LPWSTR wszUser,
    /* [out] */ WBEM_128BITS Nonce);


void __RPC_STUB IWbemLevel1Login_RequestChallenge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemLevel1Login_WBEMLogin_Proxy( 
    IWbemLevel1Login * This,
    /* [string][unique][in] */ LPWSTR wszPreferredLocale,
    /* [unique][in] */ WBEM_128BITS AccessToken,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [out] */ IWbemServices **ppNamespace);


void __RPC_STUB IWbemLevel1Login_WBEMLogin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemLevel1Login_NTLMLogin_Proxy( 
    IWbemLevel1Login * This,
    /* [string][unique][in] */ LPWSTR wszNetworkResource,
    /* [string][unique][in] */ LPWSTR wszPreferredLocale,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [out] */ IWbemServices **ppNamespace);


void __RPC_STUB IWbemLevel1Login_NTLMLogin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemLevel1Login_INTERFACE_DEFINED__ */


#ifndef __IWbemConnectorLogin_INTERFACE_DEFINED__
#define __IWbemConnectorLogin_INTERFACE_DEFINED__

/* interface IWbemConnectorLogin */
/* [unique][uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemConnectorLogin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d8ec9cb1-b135-4f10-8b1b-c7188bb0d186")
    IWbemConnectorLogin : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ConnectorLogin( 
            /* [string][unique][in] */ LPWSTR wszNetworkResource,
            /* [string][unique][in] */ LPWSTR wszPreferredLocale,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **pInterface) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemConnectorLoginVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemConnectorLogin * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemConnectorLogin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemConnectorLogin * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectorLogin )( 
            IWbemConnectorLogin * This,
            /* [string][unique][in] */ LPWSTR wszNetworkResource,
            /* [string][unique][in] */ LPWSTR wszPreferredLocale,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **pInterface);
        
        END_INTERFACE
    } IWbemConnectorLoginVtbl;

    interface IWbemConnectorLogin
    {
        CONST_VTBL struct IWbemConnectorLoginVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemConnectorLogin_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemConnectorLogin_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemConnectorLogin_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemConnectorLogin_ConnectorLogin(This,wszNetworkResource,wszPreferredLocale,lFlags,pCtx,riid,pInterface)	\
    (This)->lpVtbl -> ConnectorLogin(This,wszNetworkResource,wszPreferredLocale,lFlags,pCtx,riid,pInterface)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemConnectorLogin_ConnectorLogin_Proxy( 
    IWbemConnectorLogin * This,
    /* [string][unique][in] */ LPWSTR wszNetworkResource,
    /* [string][unique][in] */ LPWSTR wszPreferredLocale,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **pInterface);


void __RPC_STUB IWbemConnectorLogin_ConnectorLogin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemConnectorLogin_INTERFACE_DEFINED__ */


#ifndef __IWbemAddressResolution_INTERFACE_DEFINED__
#define __IWbemAddressResolution_INTERFACE_DEFINED__

/* interface IWbemAddressResolution */
/* [unique][restricted][uuid][local][object] */ 


EXTERN_C const IID IID_IWbemAddressResolution;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F7CE2E12-8C90-11d1-9E7B-00C04FC324A8")
    IWbemAddressResolution : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Resolve( 
            /* [in] */ LPWSTR wszNamespacePath,
            /* [out] */ LPWSTR wszAddressType,
            /* [out] */ DWORD *pdwAddressLength,
            /* [size_is][size_is][out] */ BYTE **pabBinaryAddress) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemAddressResolutionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemAddressResolution * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemAddressResolution * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemAddressResolution * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resolve )( 
            IWbemAddressResolution * This,
            /* [in] */ LPWSTR wszNamespacePath,
            /* [out] */ LPWSTR wszAddressType,
            /* [out] */ DWORD *pdwAddressLength,
            /* [size_is][size_is][out] */ BYTE **pabBinaryAddress);
        
        END_INTERFACE
    } IWbemAddressResolutionVtbl;

    interface IWbemAddressResolution
    {
        CONST_VTBL struct IWbemAddressResolutionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemAddressResolution_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemAddressResolution_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemAddressResolution_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemAddressResolution_Resolve(This,wszNamespacePath,wszAddressType,pdwAddressLength,pabBinaryAddress)	\
    (This)->lpVtbl -> Resolve(This,wszNamespacePath,wszAddressType,pdwAddressLength,pabBinaryAddress)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemAddressResolution_Resolve_Proxy( 
    IWbemAddressResolution * This,
    /* [in] */ LPWSTR wszNamespacePath,
    /* [out] */ LPWSTR wszAddressType,
    /* [out] */ DWORD *pdwAddressLength,
    /* [size_is][size_is][out] */ BYTE **pabBinaryAddress);


void __RPC_STUB IWbemAddressResolution_Resolve_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemAddressResolution_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_WbemLevel1Login;

#ifdef __cplusplus

class DECLSPEC_UUID("8BC3F05E-D86B-11d0-A075-00C04FB68820")
WbemLevel1Login;
#endif

EXTERN_C const CLSID CLSID_WbemLocalAddrRes;

#ifdef __cplusplus

class DECLSPEC_UUID("A1044801-8F7E-11d1-9E7C-00C04FC324A8")
WbemLocalAddrRes;
#endif

EXTERN_C const CLSID CLSID_WbemUninitializedClassObject;

#ifdef __cplusplus

class DECLSPEC_UUID("7a0227f6-7108-11d1-ad90-00c04fd8fdff")
WbemUninitializedClassObject;
#endif

#ifndef __IWbemClientTransport_INTERFACE_DEFINED__
#define __IWbemClientTransport_INTERFACE_DEFINED__

/* interface IWbemClientTransport */
/* [unique][restricted][uuid][local][object] */ 


EXTERN_C const IID IID_IWbemClientTransport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F7CE2E11-8C90-11d1-9E7B-00C04FC324A8")
    IWbemClientTransport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ConnectServer( 
            /* [in] */ BSTR strAddressType,
            /* [in] */ DWORD dwBinaryAddressLength,
            /* [size_is][in] */ BYTE *abBinaryAddress,
            /* [in] */ BSTR strNetworkResource,
            /* [in] */ BSTR strUser,
            /* [in] */ BSTR strPassword,
            /* [in] */ BSTR strLocale,
            /* [in] */ long lSecurityFlags,
            /* [in] */ BSTR strAuthority,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IWbemServices **ppNamespace) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemClientTransportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemClientTransport * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemClientTransport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemClientTransport * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectServer )( 
            IWbemClientTransport * This,
            /* [in] */ BSTR strAddressType,
            /* [in] */ DWORD dwBinaryAddressLength,
            /* [size_is][in] */ BYTE *abBinaryAddress,
            /* [in] */ BSTR strNetworkResource,
            /* [in] */ BSTR strUser,
            /* [in] */ BSTR strPassword,
            /* [in] */ BSTR strLocale,
            /* [in] */ long lSecurityFlags,
            /* [in] */ BSTR strAuthority,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IWbemServices **ppNamespace);
        
        END_INTERFACE
    } IWbemClientTransportVtbl;

    interface IWbemClientTransport
    {
        CONST_VTBL struct IWbemClientTransportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemClientTransport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemClientTransport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemClientTransport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemClientTransport_ConnectServer(This,strAddressType,dwBinaryAddressLength,abBinaryAddress,strNetworkResource,strUser,strPassword,strLocale,lSecurityFlags,strAuthority,pCtx,ppNamespace)	\
    (This)->lpVtbl -> ConnectServer(This,strAddressType,dwBinaryAddressLength,abBinaryAddress,strNetworkResource,strUser,strPassword,strLocale,lSecurityFlags,strAuthority,pCtx,ppNamespace)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemClientTransport_ConnectServer_Proxy( 
    IWbemClientTransport * This,
    /* [in] */ BSTR strAddressType,
    /* [in] */ DWORD dwBinaryAddressLength,
    /* [size_is][in] */ BYTE *abBinaryAddress,
    /* [in] */ BSTR strNetworkResource,
    /* [in] */ BSTR strUser,
    /* [in] */ BSTR strPassword,
    /* [in] */ BSTR strLocale,
    /* [in] */ long lSecurityFlags,
    /* [in] */ BSTR strAuthority,
    /* [in] */ IWbemContext *pCtx,
    /* [out] */ IWbemServices **ppNamespace);


void __RPC_STUB IWbemClientTransport_ConnectServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemClientTransport_INTERFACE_DEFINED__ */


#ifndef __IWbemClientConnectionTransport_INTERFACE_DEFINED__
#define __IWbemClientConnectionTransport_INTERFACE_DEFINED__

/* interface IWbemClientConnectionTransport */
/* [unique][restricted][uuid][local][object] */ 


EXTERN_C const IID IID_IWbemClientConnectionTransport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a889c72a-fcc1-4a9e-af61-ed071333fb5b")
    IWbemClientConnectionTransport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ BSTR strAddressType,
            /* [in] */ DWORD dwBinaryAddressLength,
            /* [size_is][in] */ BYTE *abBinaryAddress,
            /* [in] */ const BSTR strObject,
            /* [in] */ const BSTR strUser,
            /* [in] */ const BSTR strPassword,
            /* [in] */ const BSTR strLocale,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **pInterface,
            /* [out] */ IWbemCallResult **pCallRes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenAsync( 
            /* [in] */ BSTR strAddressType,
            /* [in] */ DWORD dwBinaryAddressLength,
            /* [size_is][in] */ BYTE *abBinaryAddress,
            /* [in] */ const BSTR strObject,
            /* [in] */ const BSTR strUser,
            /* [in] */ const BSTR strPassword,
            /* [in] */ const BSTR strLocale,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ REFIID riid,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( 
            /* [in] */ long lFlags,
            /* [in] */ IWbemObjectSink *pHandler) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemClientConnectionTransportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemClientConnectionTransport * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemClientConnectionTransport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemClientConnectionTransport * This);
        
        HRESULT ( STDMETHODCALLTYPE *Open )( 
            IWbemClientConnectionTransport * This,
            /* [in] */ BSTR strAddressType,
            /* [in] */ DWORD dwBinaryAddressLength,
            /* [size_is][in] */ BYTE *abBinaryAddress,
            /* [in] */ const BSTR strObject,
            /* [in] */ const BSTR strUser,
            /* [in] */ const BSTR strPassword,
            /* [in] */ const BSTR strLocale,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **pInterface,
            /* [out] */ IWbemCallResult **pCallRes);
        
        HRESULT ( STDMETHODCALLTYPE *OpenAsync )( 
            IWbemClientConnectionTransport * This,
            /* [in] */ BSTR strAddressType,
            /* [in] */ DWORD dwBinaryAddressLength,
            /* [size_is][in] */ BYTE *abBinaryAddress,
            /* [in] */ const BSTR strObject,
            /* [in] */ const BSTR strUser,
            /* [in] */ const BSTR strPassword,
            /* [in] */ const BSTR strLocale,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ REFIID riid,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IWbemClientConnectionTransport * This,
            /* [in] */ long lFlags,
            /* [in] */ IWbemObjectSink *pHandler);
        
        END_INTERFACE
    } IWbemClientConnectionTransportVtbl;

    interface IWbemClientConnectionTransport
    {
        CONST_VTBL struct IWbemClientConnectionTransportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemClientConnectionTransport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemClientConnectionTransport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemClientConnectionTransport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemClientConnectionTransport_Open(This,strAddressType,dwBinaryAddressLength,abBinaryAddress,strObject,strUser,strPassword,strLocale,lFlags,pCtx,riid,pInterface,pCallRes)	\
    (This)->lpVtbl -> Open(This,strAddressType,dwBinaryAddressLength,abBinaryAddress,strObject,strUser,strPassword,strLocale,lFlags,pCtx,riid,pInterface,pCallRes)

#define IWbemClientConnectionTransport_OpenAsync(This,strAddressType,dwBinaryAddressLength,abBinaryAddress,strObject,strUser,strPassword,strLocale,lFlags,pCtx,riid,pResponseHandler)	\
    (This)->lpVtbl -> OpenAsync(This,strAddressType,dwBinaryAddressLength,abBinaryAddress,strObject,strUser,strPassword,strLocale,lFlags,pCtx,riid,pResponseHandler)

#define IWbemClientConnectionTransport_Cancel(This,lFlags,pHandler)	\
    (This)->lpVtbl -> Cancel(This,lFlags,pHandler)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemClientConnectionTransport_Open_Proxy( 
    IWbemClientConnectionTransport * This,
    /* [in] */ BSTR strAddressType,
    /* [in] */ DWORD dwBinaryAddressLength,
    /* [size_is][in] */ BYTE *abBinaryAddress,
    /* [in] */ const BSTR strObject,
    /* [in] */ const BSTR strUser,
    /* [in] */ const BSTR strPassword,
    /* [in] */ const BSTR strLocale,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **pInterface,
    /* [out] */ IWbemCallResult **pCallRes);


void __RPC_STUB IWbemClientConnectionTransport_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClientConnectionTransport_OpenAsync_Proxy( 
    IWbemClientConnectionTransport * This,
    /* [in] */ BSTR strAddressType,
    /* [in] */ DWORD dwBinaryAddressLength,
    /* [size_is][in] */ BYTE *abBinaryAddress,
    /* [in] */ const BSTR strObject,
    /* [in] */ const BSTR strUser,
    /* [in] */ const BSTR strPassword,
    /* [in] */ const BSTR strLocale,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ REFIID riid,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemClientConnectionTransport_OpenAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClientConnectionTransport_Cancel_Proxy( 
    IWbemClientConnectionTransport * This,
    /* [in] */ long lFlags,
    /* [in] */ IWbemObjectSink *pHandler);


void __RPC_STUB IWbemClientConnectionTransport_Cancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemClientConnectionTransport_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_WbemDCOMTransport;

#ifdef __cplusplus

class DECLSPEC_UUID("F7CE2E13-8C90-11d1-9E7B-00C04FC324A8")
WbemDCOMTransport;
#endif
#endif /* __WbemTransports_v1_LIBRARY_DEFINED__ */

#ifndef __IWbemConstructClassObject_INTERFACE_DEFINED__
#define __IWbemConstructClassObject_INTERFACE_DEFINED__

/* interface IWbemConstructClassObject */
/* [uuid][object][local][restricted] */ 


EXTERN_C const IID IID_IWbemConstructClassObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9ef76194-70d5-11d1-ad90-00c04fd8fdff")
    IWbemConstructClassObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetInheritanceChain( 
            /* [in] */ long lNumAntecedents,
            /* [string][size_is][in] */ LPWSTR *awszAntecedents) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPropertyOrigin( 
            /* [string][in] */ LPCWSTR wszPropertyName,
            /* [in] */ long lOriginIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMethodOrigin( 
            /* [string][in] */ LPCWSTR wszMethodName,
            /* [in] */ long lOriginIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetServerNamespace( 
            /* [string][in] */ LPCWSTR wszServer,
            /* [string][in] */ LPCWSTR wszNamespace) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemConstructClassObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemConstructClassObject * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemConstructClassObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemConstructClassObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetInheritanceChain )( 
            IWbemConstructClassObject * This,
            /* [in] */ long lNumAntecedents,
            /* [string][size_is][in] */ LPWSTR *awszAntecedents);
        
        HRESULT ( STDMETHODCALLTYPE *SetPropertyOrigin )( 
            IWbemConstructClassObject * This,
            /* [string][in] */ LPCWSTR wszPropertyName,
            /* [in] */ long lOriginIndex);
        
        HRESULT ( STDMETHODCALLTYPE *SetMethodOrigin )( 
            IWbemConstructClassObject * This,
            /* [string][in] */ LPCWSTR wszMethodName,
            /* [in] */ long lOriginIndex);
        
        HRESULT ( STDMETHODCALLTYPE *SetServerNamespace )( 
            IWbemConstructClassObject * This,
            /* [string][in] */ LPCWSTR wszServer,
            /* [string][in] */ LPCWSTR wszNamespace);
        
        END_INTERFACE
    } IWbemConstructClassObjectVtbl;

    interface IWbemConstructClassObject
    {
        CONST_VTBL struct IWbemConstructClassObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemConstructClassObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemConstructClassObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemConstructClassObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemConstructClassObject_SetInheritanceChain(This,lNumAntecedents,awszAntecedents)	\
    (This)->lpVtbl -> SetInheritanceChain(This,lNumAntecedents,awszAntecedents)

#define IWbemConstructClassObject_SetPropertyOrigin(This,wszPropertyName,lOriginIndex)	\
    (This)->lpVtbl -> SetPropertyOrigin(This,wszPropertyName,lOriginIndex)

#define IWbemConstructClassObject_SetMethodOrigin(This,wszMethodName,lOriginIndex)	\
    (This)->lpVtbl -> SetMethodOrigin(This,wszMethodName,lOriginIndex)

#define IWbemConstructClassObject_SetServerNamespace(This,wszServer,wszNamespace)	\
    (This)->lpVtbl -> SetServerNamespace(This,wszServer,wszNamespace)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemConstructClassObject_SetInheritanceChain_Proxy( 
    IWbemConstructClassObject * This,
    /* [in] */ long lNumAntecedents,
    /* [string][size_is][in] */ LPWSTR *awszAntecedents);


void __RPC_STUB IWbemConstructClassObject_SetInheritanceChain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemConstructClassObject_SetPropertyOrigin_Proxy( 
    IWbemConstructClassObject * This,
    /* [string][in] */ LPCWSTR wszPropertyName,
    /* [in] */ long lOriginIndex);


void __RPC_STUB IWbemConstructClassObject_SetPropertyOrigin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemConstructClassObject_SetMethodOrigin_Proxy( 
    IWbemConstructClassObject * This,
    /* [string][in] */ LPCWSTR wszMethodName,
    /* [in] */ long lOriginIndex);


void __RPC_STUB IWbemConstructClassObject_SetMethodOrigin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemConstructClassObject_SetServerNamespace_Proxy( 
    IWbemConstructClassObject * This,
    /* [string][in] */ LPCWSTR wszServer,
    /* [string][in] */ LPCWSTR wszNamespace);


void __RPC_STUB IWbemConstructClassObject_SetServerNamespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemConstructClassObject_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\tlbimptocsharp\tlbimptocsharp.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;


[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		
[assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]

namespace TlbImpToCSharp
{
    using System;
    using System.IO;
    using System.Text.RegularExpressions;
    using System.Collections;

    public class App
    {
        public static int Main(string[] args)
        {

            if(args.Length != 1 && args.Length != 2)
            {
                Console.WriteLine("USAGE: TlbImpToCSharp <il_file.il> [idl_file.idl]");
                return 1;
            }

            string interfaceDefinition = "public interface";
            string structDefinition = "public struct";
            string classDefinition = "public class";
            string enumDefinition = "public enum";
            bool defineInternal = true;
            if(defineInternal)
            {
                interfaceDefinition = "internal interface";
                structDefinition = "internal struct";
                classDefinition = "internal class";
                enumDefinition = "internal enum";
            }

            StreamReader reader = File.OpenText(args[0]);
            string str = reader.ReadToEnd();

            Console.Error.WriteLine("Union Hack");
            str = Regex.Replace(str, @"\.class public explicit ansi sealed", ".class public sequential ansi sealed");
            str = Regex.Replace(str, @"\.pack 8.*?\.size 8", ".field public unsigned int64 unionhack", RegexOptions.Singleline);


            str = Regex.Replace(str, "\\.assembly.*(\\.namespace)", "$1", RegexOptions.Singleline);
            Console.Error.WriteLine("Removing Header Info");

            ArrayList listClass = new ArrayList();
            ArrayList listBaseClass = new ArrayList();

            string namespaceName = Regex.Match(str, @"namespace (\w*)").Groups[1].Value;
            Console.Error.WriteLine("Namespace = {0}", namespaceName);

            Console.Error.WriteLine("Finding Base Classes");
            foreach(Match match in Regex.Matches(str, "\\.class(.*?)\\{.*?// end of class[^\r]", RegexOptions.Singleline))
            {
                string strClassDef = match.Groups[1].Value;
                foreach(Match match2 in Regex.Matches(strClassDef, @".*interface .*?(\w*)\W*implements ([\w\.]*)", RegexOptions.Singleline))
                {
                    string strClass = match2.Groups[1].Value;
                    string strImplements = match2.Groups[2].Value;
                    int lastDot = strImplements.LastIndexOf(".");
                    if(lastDot >= 0)
                        strImplements = strImplements.Substring(lastDot+1, strImplements.Length-lastDot-1);
                    Console.Error.WriteLine("  "+strClass + " implements " + strImplements);
                    listClass.Add(strClass);
                    listBaseClass.Add(strImplements);
                }
            }

            Console.Error.WriteLine("Finding Base Class members");
            ArrayList listClassMethods = new ArrayList();
            for(int i=0;i<listClass.Count;i++)
            {
                string strClass = (string)listClass[i];
                string strBaseClass = (string)listBaseClass[i];
                Console.Error.WriteLine("  "+strClass+" - "+strBaseClass);
                string bodyBase = Regex.Matches(str, "\\.class.*? "+strBaseClass+"(.*?)// end of class", RegexOptions.Singleline)[0].Groups[1].Value;
//                Console.WriteLine(strClass);
                ArrayList listBodies = new ArrayList();
                foreach(Match match in Regex.Matches(bodyBase, "\\.method.*?// end of method[^\r]*", RegexOptions.Singleline))
                {
                    listBodies.Add(match.Value);
                }
                listClassMethods.Add(listBodies);
            }
            Console.Error.WriteLine("Removing Base Class members");
            for(int i=0;i<listClass.Count;i++)
            {
                string strClass = (string)listClass[i];
                string strBaseClass = (string)listBaseClass[i];
                ArrayList listBodies = (ArrayList)listClassMethods[i];
                Console.Error.WriteLine("  "+strClass+" - "+strBaseClass);
                foreach(string strBody in listBodies)
                {
                    string strBody2 = strBody;
                    strBody2 = Regex.Replace(strBody2, "(end of method )"+strBaseClass, "$1"+strClass);
                    strBody2 = Regex.Escape(strBody2);
                    //                    Regex regex = new Regex("( "+strClass+" .*?)"+strBody2+"(.*?// end of class)", RegexOptions.Compiled|RegexOptions.Singleline);
                    Regex regex = new Regex("("+strBody2+")", RegexOptions.Singleline);
                    //                    str = regex.Replace(str, "#if BASEMEMBER\r\n$1\r\n#endif\r\n");
//                    str = regex.Replace(str, "");
                    //                    str = Regex.Replace(str, "(\\.class.*? "+strClass+".*?)"+strBody2+"(.*?// end of class)", "$1$2", RegexOptions.Singleline);
                }
            }

            // Replace namespace
            str = Regex.Replace(str, "\\.namespace", "using System;\r\nusing System.Runtime.InteropServices;\r\nusing System.Runtime.CompilerServices;\r\n\r\nnamespace", RegexOptions.Singleline);
            Console.Error.Write(".");

            // Fix enums
            str = Regex.Replace(str, "\\.class public auto ansi sealed (\\w*).*?System\\.Enum", enumDefinition+" $1", RegexOptions.Singleline);
            Console.Error.Write(".");
            str = Regex.Replace(str, "\\.field public specialname rtspecialname int32 value__", "");
            Console.Error.Write(".");
            str = Regex.Replace(str, "\\.field public static literal valuetype [^ ]* (\\w*) = int32\\((.*)\\)", "$1 = unchecked((int)$2),");
            Console.Error.Write(".");

            // Fix structs
            str = Regex.Replace(str, "\\.class public sequential ansi sealed (\\w*).*?System\\.ValueType", structDefinition+" $1", RegexOptions.Singleline);
            Console.Error.Write(".");
            str = Regex.Replace(str, "\\.field public ([^\r]*)", " public $1;");
            Console.Error.Write(".");


            // HACK: Remove remaining classes
//          str = Regex.Replace(str, "\\.class (?!interface).*?// end of class[^\r]*", "", RegexOptions.Singleline);

            // Move custom attributes outside of class for remaining interfaces and co-classes
            str = Regex.Replace(str, "(\\.class.*?\\{)(.*?)(\\.method)", "$2$1$3", RegexOptions.Singleline);
            Console.Error.Write(".");

            // Fix co-classes
            str = Regex.Replace(str, "\\.class public auto ansi import (\\w*).*?extends \\[mscorlib\\]System\\.Object\\W*?\\{", "public XYZZYCLASS $1 {", RegexOptions.Singleline);
            str = Regex.Replace(str, "\\.class public auto ansi import (\\w*).*?extends \\[mscorlib\\]System\\.Object.*?implements ", "public XYZZYCLASS $1 : ", RegexOptions.Singleline);
            Console.Error.Write(".");
            str = Regex.Replace(str, "\\.override[^\r]*", "override");
            Console.Error.Write(".");

            str = Regex.Replace(str, "\\.method public specialname rtspecialname.*?instance void \\.ctor\\(\\) runtime managed internalcall.*?// end of method [^\r]*", "", RegexOptions.Singleline);
            Console.Error.Write(".");

            string pattern = ".custom instance void [mscorlib]System.Runtime.InteropServices.DispIdAttribute::.ctor(int32) = ( ";
            pattern = Regex.Escape(pattern) + "(..) (..) (..) (..) (..) (..) (..) (..) \\)[^\r]*";
            Console.Error.Write(".");
            string replace = "[DispIdAttribute(0x$6$5$4$3)]";
            str = Regex.Replace(str, pattern, replace);
            Console.Error.Write(".");

            str = Regex.Replace(str, "(\\.method.*?)\\{(.*?)}[^\r]*", "$2 $1", RegexOptions.Singleline);
            Console.Error.Write(".");

            str = Regex.Replace(str, " runtime managed internalcall", ";", RegexOptions.Singleline);
            Console.Error.Write(".");
            str = Regex.Replace(str, " runtime managed preservesig internalcall", ";", RegexOptions.Singleline);
            Console.Error.Write(".");

            str = Regex.Replace(str, "\\.method public virtual abstract instance void", "[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)] void", RegexOptions.Singleline);
            Console.Error.Write(".");
            str = Regex.Replace(str, "\\.method public virtual abstract instance int32", "[PreserveSig][MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)] int32", RegexOptions.Singleline);
            Console.Error.Write(".");

            // For coclasses
            str = Regex.Replace(str, "\\.method public virtual instance void", "[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)] public void", RegexOptions.Singleline);
            Console.Error.Write(".");
            str = Regex.Replace(str, "\\.method public virtual instance int32", "[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)] public int32", RegexOptions.Singleline);
            Console.Error.Write(".");

            pattern = Regex.Escape(".custom instance void [mscorlib]System.Runtime.InteropServices.ComSubstitutableInterfaceAttribute::.ctor() = ( 01 00 00 00 )");
            str = Regex.Replace(str, pattern, "[ComSubstitutableInterfaceAttribute]");
            Console.Error.Write(".");

            pattern = Regex.Escape(".custom instance void [mscorlib]System.Runtime.InteropServices.ComConversionLossAttribute::.ctor()");
            str = Regex.Replace(str, pattern, "/*[ComConversionLossAttribute]*/");
            Console.Error.Write(".");

            pattern = Regex.Escape(".custom instance void [mscorlib]System.Runtime.InteropServices.TypeLibTypeAttribute::.ctor(int16) = ( 01 00 ") + "(..) (..)[^\r]*";
            str = Regex.Replace(str, pattern, "[TypeLibTypeAttribute(0x$2$1)]");
            Console.Error.Write(".");

            pattern = Regex.Escape(".custom instance void [mscorlib]System.Runtime.InteropServices.InterfaceTypeAttribute::.ctor(int16) = ( 01 00 ") + "(..) (..)[^\r]*";
            str = Regex.Replace(str, pattern, "[InterfaceTypeAttribute(0x$2$1)]");
            Console.Error.Write(".");

            pattern = Regex.Escape(".custom instance void [mscorlib]System.Runtime.InteropServices.ClassInterfaceAttribute::.ctor(int16) = ( 01 00 ") + "(..) (..)[^\r]*";
            str = Regex.Replace(str, pattern, "[ClassInterfaceAttribute((short)0x$2$1)]");
            Console.Error.Write(".");

            pattern = Regex.Escape(".custom instance void [mscorlib]System.Runtime.InteropServices.GuidAttribute::.ctor(string) = ( ");
            pattern += ".*?// \\.\\.\\$([^\r]*).*?// ([^\r]*).*?// ([^\\.]*)[^\r]*";
            str = Regex.Replace(str, pattern, "[GuidAttribute(\"$1$2$3\")]", RegexOptions.Singleline);
            Console.Error.Write(".");
            
            str = Regex.Replace(str, "unsigned int8", "Byte");
            Console.Error.Write(".");
            str = Regex.Replace(str, "unsigned int32", "UInt32");
            Console.Error.Write(".");
            str = Regex.Replace(str, "unsigned int64", "UInt64");
            Console.Error.Write(".");

            str = Regex.Replace(str, "native int", "IntPtr");
            Console.Error.Write(".");

            str = Regex.Replace(str, "'clsid'", "clsid");
            Console.Error.Write(".");
            

            str = Regex.Replace(str, Regex.Escape("[in]"), "[In]");
            Console.Error.Write(".");
            str = Regex.Replace(str, Regex.Escape("[out]"), "[Out]");
            Console.Error.Write(".");
            str = Regex.Replace(str, Regex.Escape("int32"), "Int32");
            Console.Error.Write(".");
            str = Regex.Replace(str, Regex.Escape("int64"), "Int64");
            Console.Error.Write(".");
            str = Regex.Replace(str, "int8", "SByte");
            Console.Error.Write(".");
            str = Regex.Replace(str, "float64", "double");
            Console.Error.Write(".");

            str = Regex.Replace(str, Regex.Escape(".class interface public abstract auto ansi import"), "[ComImport]\r\n"+interfaceDefinition);
            Console.Error.Write(".");
            
            str = Regex.Replace(str, "class ", "");
            Console.Error.Write(".");
            str = Regex.Replace(str, "valuetype \\[.*?\\]", "");
            Console.Error.Write(".");
            str = Regex.Replace(str, "valuetype ", "");
            Console.Error.Write(".");

            str = Regex.Replace(str, "(\\[In\\]\\[Out\\]) (.*?)&", "$1 ref $2");
            Console.Error.Write(".");
            str = Regex.Replace(str, "(\\[Out\\]) (.*?)&", "$1 out $2");
            Console.Error.Write(".");
            str = Regex.Replace(str, "(\\[In\\]) (.*?)&", "$1 ref $2");
            Console.Error.Write(".");

            str = Regex.Replace(str, "implements", "//:");
            Console.Error.Write(".");

            
//          str = Regex.Replace(str, "(.*])(.*)"+Regex.Escape("marshal( lpwstr)"), "$1[MarshalAs(UnmanagedType.LPWStr)] $2");
            Console.Error.WriteLine("\r\nFixing up MarshalAs attributes");
            str = Regex.Replace(str, "(\\[.*[^\\[]\\])(.*)"+Regex.Escape("marshal( interface)"), "$1[MarshalAs(UnmanagedType.Interface)] $2");
            Console.Error.Write(".");
            str = Regex.Replace(str, "(\\[.*[^\\[]\\])(.*)"+Regex.Escape("marshal( lpwstr)"), "$1[MarshalAs(UnmanagedType.LPWStr)] $2");
            Console.Error.Write(".");
            str = Regex.Replace(str, "(\\[.*[^\\[]\\])(.*)"+Regex.Escape("marshal( safearray bstr)"), "$1[MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_BSTR)] $2");
            Console.Error.Write(".");
            str = Regex.Replace(str, "(\\[.*[^\\[]\\])(.*)"+Regex.Escape("marshal( bstr)"), "$1[MarshalAs(UnmanagedType.BStr)] $2");
            Console.Error.Write(".");
            str = Regex.Replace(str, "(\\[.*[^\\[]\\])(.*)"+Regex.Escape("marshal( iunknown)"), "$1[MarshalAs(UnmanagedType.IUnknown)] $2");
            Console.Error.Write(".");
            str = Regex.Replace(str, "(\\[.*[^\\[]\\])(.*)"+Regex.Escape("marshal( error)"), "$1[MarshalAs(UnmanagedType.Error)] $2");
            Console.Error.Write(".");


            str = Regex.Replace(str, "(public  )"+Regex.Escape("marshal( interface)"), "[MarshalAs(UnmanagedType.Interface)] $1");
            Console.Error.Write(".");
            str = Regex.Replace(str, "(public  )"+Regex.Escape("marshal( lpwstr)"), "[MarshalAs(UnmanagedType.LPWStr)] $1");
            Console.Error.Write(".");
            str = Regex.Replace(str, "(public  )"+Regex.Escape("marshal( error)"), "[MarshalAs(UnmanagedType.Error)] $1");
            Console.Error.Write(".");
            
            Console.Error.WriteLine("\r\ncleanup");

            str = Regex.Replace(str, "XYZZYCLASS", "class");
            Console.Error.Write(".");

            // On override functions, add a body
            str = Regex.Replace(str, "(override.*?\\));", "$1 {}", RegexOptions.Singleline);
            Console.Error.Write(".");

            // Swap override (acutally remove it)
            str = Regex.Replace(str, "(override).*?(\\[MethodImpl.*?])", "$2  ", RegexOptions.Singleline);
            Console.Error.Write(".");
            

//          str = Regex.Replace(str, "\\.class (?=interface).*?// end of class[^\r]*", "aaaaa", RegexOptions.Singleline);
            //          str = Regex.Replace(str, "(?<one>\\.method[^\\{]*)[^}]*} // end of method[^\r]*", "${one}", RegexOptions.Singleline );

            // Fix CoClasses
            str = Regex.Replace(str, "(public class .*?)(:[^\\{]*)\r", "$1 /*$2*/\r");
            Console.Error.Write(".");

            str = Regex.Replace(str, "(public class .*?\\{)", "$1\r\n#if XXX\r\n", RegexOptions.Singleline);
            Console.Error.Write(".");

            str = Regex.Replace(str, "(#if .*?)(\r[^\r]*// end of)", "$1\r\n#endif$2", RegexOptions.Singleline);
            Console.Error.Write(".");

//          str = Regex.Replace(str, "(\\[TypeLibTypeAttribute.*?\\])([^\r]*\r[^\r]*)(\\[ClassInterfaceAttribute.*?\\])([^\r]*\r[^\r]*public class)", "/*$1*/$2/*$3*/$4", RegexOptions.Singleline);
            str = Regex.Replace(str, "public class", "[ComImport]\r\n"+classDefinition, RegexOptions.Singleline);
            Console.Error.Write(".");
            Console.Error.WriteLine();

            Console.Error.WriteLine("Replacing Namespace - {0}", namespaceName);
            str = Regex.Replace(str, namespaceName+@"\.", "");

            Console.Error.WriteLine("Replacing extra lines");
            str = Regex.Replace(str, "\n(\\ )+\r", "\n\r", RegexOptions.Singleline);
            str = Regex.Replace(str, "\r\n(\r\n)+", "\r\n\r\n", RegexOptions.Singleline);

            str = Regex.Replace(str, "#if XXX\r\n\r\n#endif\r\n", "", RegexOptions.Singleline);


            // IDL Fixups
            if(args.Length == 2)
            {
                StreamReader reader2 = File.OpenText(args[1]);
                string strIDL = reader2.ReadToEnd();
                Console.Error.WriteLine(strIDL);

            }

            Console.WriteLine(str);

            return 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wminet_utils\eventregistrar.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// EventRegistrar.cpp : Implementation of CEventRegistrar
#include "stdafx.h"
#include "WMINet_Utils.h"
#include "EventRegistrar.h"

/////////////////////////////////////////////////////////////////////////////
// CEventRegistrar


STDMETHODIMP CEventRegistrar::CreateNewEvent(BSTR strName, VARIANT varParent, IDispatch **evt)
{
	HRESULT hr;

	int len = SysStringLen(m_bstrNamespace);

	if(varParent.vt == VT_BSTR)
		len += SysStringLen(varParent.bstrVal);

	// Allocate temp buffer with enough space for additional moniker arguments
	LPWSTR wszT = new WCHAR[len + 100];
	if(NULL == wszT)
		return E_OUTOFMEMORY;

	// Create moniker to __ExtrinsicEvent class in this namespace
	if(varParent.vt == VT_BSTR)
		swprintf(wszT, L"WinMgmts:%s:%s", (LPCWSTR)m_bstrNamespace, (LPCWSTR)varParent.bstrVal);
	else
		swprintf(wszT, L"WinMgmts:%s:__ExtrinsicEvent", (LPCWSTR)m_bstrNamespace);

	// See if the Win32PseudoProvider instance already exists
	ISWbemObject *pObj = NULL;
	if(SUCCEEDED(hr = GetSWbemObjectFromMoniker(wszT, &pObj)))
	{
		ISWbemObject *pNewClass = NULL;
		if(SUCCEEDED(hr = pObj->SpawnDerivedClass_(0, &pNewClass)))
		{
			ISWbemObjectPath *pPath = NULL;
			if(SUCCEEDED(hr = pNewClass->get_Path_(&pPath)))
			{
				if(SUCCEEDED(hr = pPath->put_Class(strName)))
					hr = pNewClass->QueryInterface(IID_IDispatch, (void**)evt);
				pPath->Release();
			}
			pNewClass->Release();
		}
		pObj->Release();
	}

	delete [] wszT;
	
	return hr;
}

//  throw _com_error(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

HRESULT CEventRegistrar::TestFunc(BSTR bstrNamespace, BSTR bstrApp, BSTR bstrEvent)
{
    HRESULT hr = S_OK;
    try
    {
		if(NULL == m_pScrCtl)
		{
			if(FAILED(hr = m_pScrCtl.CreateInstance(__uuidof(ScriptControl))))
				throw _com_error(hr);

			// Set script engine language to JScript
			m_pScrCtl->Language = L"jscript";

			HINSTANCE hInst = _Module.GetModuleInstance();
			HRSRC hrc = FindResource(hInst, MAKEINTRESOURCE(IDR_SCRIPTREGIT), "SCRIPTFILE");
			DWORD dwSize = SizeofResource(hInst, hrc);
			HGLOBAL handle = LoadResource(hInst, hrc);

			LPSTR psz = new char[dwSize+1];
			if(NULL == psz)
			{
				m_pScrCtl = NULL;
				throw(E_OUTOFMEMORY);
			}

			psz[dwSize] = 0;
			memcpy(psz, LockResource(handle), dwSize);
//			_bstr_t bstrCode((LPCSTR)LockResource(handle));
			_bstr_t bstrCode(psz);

			delete [] psz;

			m_pScrCtl->AddCode(bstrCode);
		}

		_bstr_t bstrCmd(L"RegIt(\"");

		_bstr_t bstrNamespace2;
		WCHAR szT[2];
		szT[1] = 0;
		for(unsigned int i=0;i<SysStringLen(bstrNamespace);i++)
		{
			szT[0] = bstrNamespace[i];
			if(szT[0] == L'\\')
				bstrNamespace2 += szT;
			bstrNamespace2 += szT;
		}

		bstrCmd += bstrNamespace2;
		bstrCmd += "\", \"";
		bstrCmd += bstrApp;
		bstrCmd += "\", \"";
		bstrCmd += bstrEvent;
		bstrCmd += "\");";

        hr = m_pScrCtl->Eval(bstrCmd);
    }
    catch (_com_error &e )
    {
		hr = e.Error();
    }
	return hr;
}


BOOL CEventRegistrar::CompareNewEvent(ISWbemObject *pSWbemObject)
{
	HRESULT hr;

	ISWbemObjectPath *pPath = NULL;
	if(FAILED(hr = pSWbemObject->get_Path_(&pPath)))
		return FALSE;

	BSTR bstrClass = NULL;
	hr = pPath->get_Class(&bstrClass);
	pPath->Release();
	if(FAILED(hr))
		return FALSE;

	int len = SysStringLen(m_bstrNamespace) + SysStringLen(bstrClass);

	// Allocate temp buffer with enough space for additional moniker arguments
	LPWSTR wszT = new WCHAR[len + 100];
	if(NULL == wszT)
		return FALSE;

	// Create moniker to class in this namespace
	swprintf(wszT, L"WinMgmts:%s:%s", (LPCWSTR)m_bstrNamespace, (LPCWSTR)bstrClass);

	// See if the class already exists
	BOOL bExists = FALSE;
	ISWbemObject *pObj = NULL;
	if(SUCCEEDED(hr = GetSWbemObjectFromMoniker(wszT, &pObj)))
	{
		// Compare
		IDispatch *pDisp = NULL;
		if(SUCCEEDED(hr = pObj->QueryInterface(IID_IDispatch, (void**)&pDisp)))
		{
			VARIANT_BOOL vb = VARIANT_FALSE;
			if(SUCCEEDED(hr = pSWbemObject->CompareTo_(pDisp, 0x12, &vb)))
				bExists = (vb == VARIANT_TRUE);

			pDisp->Release();
		}
		pObj->Release();
	}
	
	delete [] wszT;

	SysFreeString(bstrClass);

	return bExists;
}


STDMETHODIMP CEventRegistrar::CommitNewEvent(IDispatch *evt)
{
	HRESULT hr;
	ISWbemObject *pSWbemObject;
	if(SUCCEEDED(hr = evt->QueryInterface(IID_ISWbemObject, (void**)&pSWbemObject)))
	{
		if(CompareNewEvent(pSWbemObject) == FALSE)
		{
			ISWbemObjectPath *pPath = NULL;
			if(SUCCEEDED(hr = pSWbemObject->Put_(0, NULL, &pPath)))
			{
				BSTR bstrClass = NULL;
				if(SUCCEEDED(hr = pPath->get_Class(&bstrClass)))
				{
					hr = TestFunc(m_bstrNamespace, m_bstrApp, bstrClass);
					SysFreeString(bstrClass);
				}
				pPath->Release();
			}
		}
		pSWbemObject->Release();
	}
	return hr;
}

STDMETHODIMP CEventRegistrar::GetEventInstance(BSTR strName, IDispatch **evt)
{
	HRESULT hr;

	int len = SysStringLen(m_bstrNamespace) + SysStringLen(strName);

	// Allocate temp buffer with enough space for additional moniker arguments
	LPWSTR wszT = new WCHAR[len + 100];
	if(NULL == wszT)
		return E_OUTOFMEMORY;

	// Create moniker to event class in this namespace
	swprintf(wszT, L"WinMgmts:%s:%s", (LPCWSTR)m_bstrNamespace, (LPCWSTR)strName);

	// Get class definition for event
	ISWbemObject *pObj = NULL;
	if(SUCCEEDED(hr = GetSWbemObjectFromMoniker(wszT, &pObj)))
	{
		// Create an instance of this event
		ISWbemObject *pInst = NULL;
		if(SUCCEEDED(hr = pObj->SpawnInstance_(0, &pInst)))
		{
			hr = pInst->QueryInterface(IID_IDispatch, (void**)evt);
			pInst->Release();
		}
		pObj->Release();
	}
	
	return hr;
}

STDMETHODIMP CEventRegistrar::IWbemFromSWbem(IDispatch *sevt, IWbemClassObject **evt)
{
	ISWbemObject *pSWbemObject;
	sevt->QueryInterface(IID_ISWbemObject, (void**)&pSWbemObject);
	GetIWbemClassObject(pSWbemObject, evt);
	pSWbemObject->Release();

	return S_OK;
}

STDMETHODIMP CEventRegistrar::Init(BSTR bstrNamespace, BSTR bstrApp)
{
	HRESULT hr;
#ifdef USE_PSEUDOPROVIDER
	if(FAILED(hr = EnsurePseudoProviderRegistered(bstrNamespace)))
		return hr;
#endif

	if(FAILED(hr = EnsureAppProviderInstanceRegistered(bstrNamespace, bstrApp)))
		return hr;

	if(NULL == (m_bstrNamespace = SysAllocString(bstrNamespace)))
		return E_OUTOFMEMORY;

	if(NULL == (m_bstrApp = SysAllocString(bstrApp)))
		return E_OUTOFMEMORY; // m_bstrNamespace will be freed in constructor

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wminet_utils\eventregistrar.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// EventRegistrar.h : Declaration of the CEventRegistrar

#ifndef __EVENTREGISTRAR_H_
#define __EVENTREGISTRAR_H_

#include "resource.h"       // main symbols
#include "Helpers.h"


#import <msscript.ocx>
using namespace MSScriptControl;

/////////////////////////////////////////////////////////////////////////////
// CEventRegistrar
class ATL_NO_VTABLE CEventRegistrar : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CEventRegistrar, &CLSID_EventRegistrar>,
	public IDispatchImpl<IEventRegistrar, &IID_IEventRegistrar, &LIBID_WMINet_UtilsLib>
{
public:
	CEventRegistrar()
	{
		m_bstrNamespace = NULL;
		m_bstrApp = NULL;

		m_pScrCtl = NULL;
	}
	
	~CEventRegistrar()
	{
		if(NULL != m_bstrNamespace)
			SysFreeString(m_bstrNamespace);
		if(NULL != m_bstrApp)
			SysFreeString(m_bstrApp);
	}


protected:
	BSTR m_bstrNamespace;
	BSTR m_bstrApp;

	IScriptControlPtr m_pScrCtl;

	BOOL CompareNewEvent(ISWbemObject *pSWbemObject);

	HRESULT TestFunc(BSTR bstrNamespace, BSTR bstrApp, BSTR bstrEvent);

	HRESULT EnsureAppProviderInstanceRegistered(BSTR bstrNamespace, BSTR bstrApp)
	{
		HRESULT hr = S_OK;

		int len = SysStringLen(bstrNamespace) + SysStringLen(bstrApp);

		// Allocate temp buffer with enough space for additional moniker arguments
		LPWSTR wszT = new WCHAR[len + 100];
		if(NULL == wszT)
			return E_OUTOFMEMORY;


		// TODO: Move these bstrs to member variables

		// Allocate BSTR for 'Name' property
		BSTR bstrName = SysAllocString(L"Name");
		if(NULL == bstrName)
		{
			delete [] wszT;
			return E_OUTOFMEMORY;
		}

		BSTR bstrClsId = SysAllocString(L"ClsId");
		if(NULL == bstrClsId)
		{
			SysFreeString(bstrName);
			delete [] wszT;
			return E_OUTOFMEMORY;
		}

		BSTR bstrProvClsId = SysAllocString(L"{54D8502C-527D-43f7-A506-A9DA075E229C}");
		if(NULL == bstrProvClsId)
		{
			SysFreeString(bstrName);
			SysFreeString(bstrClsId);
			delete [] wszT;
			return E_OUTOFMEMORY;
		}


		// Create moniker to Win32PseudoProvider class in this namespace
		swprintf(wszT, L"WinMgmts:%s:__Win32Provider.Name=\"%s\"", (LPCWSTR)bstrNamespace, (LPCWSTR)bstrApp);

		// See if the Win32PseudoProvider instance already exists
		ISWbemObject *pObj = NULL;
		if(SUCCEEDED(GetSWbemObjectFromMoniker(wszT, &pObj)))
			pObj->Release(); // Win32PseudoProvider instance already exists
		else
		{
			// Get Win32PseudoProvider class definition
			ISWbemObject *pClassObj = NULL;
			swprintf(wszT, L"WinMgmts:%s:__Win32Provider", (LPCWSTR)bstrNamespace);
			if(SUCCEEDED(hr = GetSWbemObjectFromMoniker(wszT, &pClassObj)))
			{
				// Create a new instance of Win32PseudoProvider 
				ISWbemObject *pInst = NULL;
				if(SUCCEEDED(hr = pClassObj->SpawnInstance_(0, &pInst)))
				{
					// Get the 'properties' collection
					ISWbemPropertySet *pProps = NULL;
					if(SUCCEEDED(hr = pInst->get_Properties_(&pProps)))
					{
						// Get the 'Name' property
						ISWbemProperty *pProp = NULL;
						if(SUCCEEDED(hr = pProps->Item(bstrName, 0, &pProp)))
						{
							// Set the Name property to the App name
							VARIANT var;
							VariantInit(&var);
							var.vt = VT_BSTR;
							var.bstrVal = bstrApp; // TODO: I FORGET! Do I need to allocate this for put_Value(...)?
							hr = pProp->put_Value(&var);
							pProp->Release();
						}

						// Get the 'ClsId' property
						if(SUCCEEDED(hr = pProps->Item(bstrClsId, 0, &pProp)))
						{
							// Set the ClsId property to {54D8502C-527D-43f7-A506-A9DA075E229C}
							VARIANT var;
							VariantInit(&var);
							var.vt = VT_BSTR;
							var.bstrVal = bstrProvClsId; // TODO: I FORGET! Do I need to allocate this for put_Value(...)?
							hr = pProp->put_Value(&var);
							pProp->Release();
						}

						pProps->Release();
					}

					// Commit the Win32PseudoProvider instance
					if(SUCCEEDED(hr))
					{
						ISWbemObjectPath *pPath = NULL;
						if(SUCCEEDED(hr = pInst->Put_(0, NULL, &pPath)))
							pPath->Release();
					}
					pInst->Release();
				}
				pClassObj->Release();
			}
		}

		// Cleanup
		delete [] wszT;
		SysFreeString(bstrName);
		SysFreeString(bstrClsId);
		SysFreeString(bstrProvClsId);

		return hr;
	}

#ifdef USE_PSEUDOPROVIDER
	HRESULT EnsurePseudoProviderRegistered(BSTR bstrNamespace)
	{
		HRESULT hr = S_OK;

		int len = SysStringLen(bstrNamespace);

		// Allocate temp buffer with enough space for additional moniker arguments
		LPWSTR wszT = new WCHAR[len + 100];
		if(NULL == wszT)
			return E_OUTOFMEMORY;

		// Create moniker to Win32PseudoProvider class in this namespace
		swprintf(wszT, L"WinMgmts:%s:Win32ManagedCodeProvider", (LPCWSTR)bstrNamespace);

		// See if the Win32PseudoProvider class already exists
		ISWbemObject *pObj = NULL;
		if(SUCCEEDED(GetSWbemObjectFromMoniker(wszT, &pObj)))
			pObj->Release(); // Win32PseudoProvider class already exists
		else
		{
			// Get Win32PseudoProvider class definition from root\default
			ISWbemObject *pClassObj = NULL;
			if(SUCCEEDED(hr = GetSWbemObjectFromMoniker(L"WinMgmts:root\\default:Win32ManagedCodeProvider", &pClassObj)))
			{
				// Get MOF definition for Win32PseudoProvider class
				BSTR bstrMof = NULL;
				if(SUCCEEDED(hr = pClassObj->GetObjectText_(0, &bstrMof)))
				{
					// Put it in the new namespace
					hr = Compile(bstrMof, bstrNamespace, NULL, NULL, NULL, 0, 0, 0, NULL);
					SysFreeString(bstrMof);
				}
				pClassObj->Release();
			}
		}

		delete [] wszT;

		return hr;
	}
#endif

public:

DECLARE_REGISTRY_RESOURCEID(IDR_EVENTREGISTRAR)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CEventRegistrar)
	COM_INTERFACE_ENTRY(IEventRegistrar)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IEventRegistrar
public:
	STDMETHOD(CommitNewEvent)(/*[in]*/ IDispatch *evt);
	STDMETHOD(CreateNewEvent)(/*[in]*/ BSTR strName, /*[in, optional]*/ VARIANT varParent, /*[out, retval]*/ IDispatch **evt);
	STDMETHOD(GetEventInstance)(/*[in]*/ BSTR strName, /*[out, retval]*/ IDispatch **evt);
	STDMETHOD(IWbemFromSWbem)(/*[in]*/ IDispatch *sevt, /*[out, retval]*/ IWbemClassObject **evt);
	STDMETHOD(Init)(/*[in]*/ BSTR strNamespace, /*[in]*/ BSTR strApp);

};

#endif //__EVENTREGISTRAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wminet_utils\eventsource2.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// EventSource2.cpp : Implementation of CEventSource2

#include "stdafx.h"
#include "WMINet_Utils.h"
#include "EventSource2.h"

#include "Helpers.h"

// CEventSource2

/////////////////////////////////////////////////////////////////////////////
// CEventSource
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wminet_utils\eventsource.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// EventSource.cpp : Implementation of CEventSource
#include "stdafx.h"
#include "WMINet_Utils.h"
#include "EventSource.h"

#include "Helpers.h"

/////////////////////////////////////////////////////////////////////////////
// CEventSource

STDMETHODIMP CEventSource::Fire(IWbemClassObject *evt)
{
	if(NULL == m_pEventSink)
		return S_OK;

#if 0
	IWbemClassObject *pEvent;
	ISWbemObject *pSWbemObject;
	evt->QueryInterface(IID_ISWbemObject, (void**)&pSWbemObject);
	GetIWbemClassObject(pSWbemObject, &pEvent);

	// TODO: Release IWbemClassIbject?
	m_pEventSink->Indicate(1, &pEvent);
#endif

	m_pEventSink->Indicate(1, &evt);
	return S_OK;
}

STDMETHODIMP CEventSource::GetEventInstance(BSTR strName, IDispatch **evt)
{
	HRESULT hr;

	int len = SysStringLen(m_bstrNamespace) + SysStringLen(strName);

	// Allocate temp buffer with enough space for additional moniker arguments
	LPWSTR wszT = new WCHAR[len + 100];
	if(NULL == wszT)
		return E_OUTOFMEMORY;

	// Create moniker to event class in this namespace
	swprintf(wszT, L"WinMgmts:%s:%s", (LPCWSTR)m_bstrNamespace, (LPCWSTR)strName);

	// Get class definition for event
	ISWbemObject *pObj = NULL;
	if(SUCCEEDED(hr = GetSWbemObjectFromMoniker(wszT, &pObj)))
	{
		// Create an instance of this event
		ISWbemObject *pInst = NULL;
		if(SUCCEEDED(hr = pObj->SpawnInstance_(0, &pInst)))
		{
			hr = pInst->QueryInterface(IID_IDispatch, (void**)evt);
			pInst->Release();
		}
		pObj->Release();
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wminet_utils\eventsource.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// EventSource.h : Declaration of the CEventSource

#ifndef __EVENTSOURCE_H_
#define __EVENTSOURCE_H_

#include "resource.h"       // main symbols
//#import "C:\Nova\idl\wbemprov.tlb" raw_interfaces_only, raw_native_types, named_guids 

#include "EventSourceStatusSink.h"

/////////////////////////////////////////////////////////////////////////////
// CEventSource
class ATL_NO_VTABLE CEventSource : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CEventSource, &CLSID_EventSource>,
	public IDispatchImpl<IEventSource, &IID_IEventSource, &LIBID_WMINet_UtilsLib>,
	public IWbemProviderInit,
	public IWbemEventProvider,
	public IWbemEventProviderQuerySink,
	public IWbemEventProviderSecurity,
	public IPrivateInit
{
public:
	CEventSource()
	{
		m_pDecoupledRegistrar = NULL;
		m_pStatusSink = NULL;

		m_pEventSink = NULL;
		m_pNamespace = NULL;
		m_bstrNamespace = NULL;
		m_bstrApp = NULL;
	}

	~CEventSource()
	{
		if(m_pDecoupledRegistrar)
		{
			// TODO: Only UnRegister if registered
			m_pDecoupledRegistrar->UnRegister();
//			MessageBox(NULL, "Destructor UnRegistered", "UnRegistered", 0);
			m_pDecoupledRegistrar->Release();
		}

		if(m_pStatusSink)
			m_pStatusSink->Release();

		if(m_pEventSink)
			m_pEventSink->Release();

		if(m_pNamespace)
			m_pNamespace->Release();

		if(NULL != m_bstrNamespace)
			SysFreeString(m_bstrNamespace);

		if(NULL != m_bstrApp)
			SysFreeString(m_bstrApp);
	}

	HRESULT Init(BSTR bstrNamespace, BSTR bstrApp, IEventSourceStatusSink *pSink)
	{
		// TODO: Verify all return paths do proper cleanup.
		// If we return a failure, can we rely on local variables to be cleaned up in destructor?
//		if(!pSink)
//			return E_INVALIDARG;

		if(NULL == (m_bstrNamespace = SysAllocString(bstrNamespace)))
			return E_OUTOFMEMORY;

		if(NULL == (m_bstrApp = SysAllocString(bstrApp)))
			return E_OUTOFMEMORY; // m_bstrNamespace will be freed in constructor

		m_pStatusSink = pSink;
		if(m_pStatusSink)
			m_pStatusSink->AddRef();
		
		HRESULT hr;
		IUnknown *pUnk = NULL;

		if(FAILED(hr = CoCreateInstance(CLSID_WbemDecoupledRegistrar ,NULL , CLSCTX_INPROC_SERVER, IID_IWbemDecoupledRegistrar, (void**)&m_pDecoupledRegistrar)))
			return hr;

		if(FAILED(hr = QueryInterface(IID_IUnknown, (void**)&pUnk)))
			return hr;

		if(hr = m_pDecoupledRegistrar->Register(0, NULL, NULL, NULL, m_bstrNamespace, m_bstrApp, pUnk))
			return hr;

//		MessageBox(NULL, "Registered", "Registered", 0);

		// To use 'DecoupledBasicEventProvider'
//		if(FAILED(hr = CoCreateInstance(CLSID_WbemDecoupledBasicEventProvider ,NULL , CLSCTX_INPROC_SERVER, IID_IWbemDecoupledBasicEventProvider, (void**)&m_pDecoupledProvider)))
//		if(FAILED(hr = m_pDecoupledProvider->GetService(0, NULL, &m_pNamespace)))
//			return hr;
//		if(FAILED(hr = m_pDecoupledProvider->GetSink(0, NULL, &m_pEventSink)))
//			return hr;

		pUnk->Release();
		return hr;
	}

protected:
//	IWbemDecoupledBasicEventProvider *m_pDecoupledProvider;
	IWbemDecoupledRegistrar *m_pDecoupledRegistrar;
	IWbemObjectSink*         m_pEventSink;
	IWbemServices*           m_pNamespace;
	BSTR m_bstrNamespace;
	BSTR m_bstrApp;

	IEventSourceStatusSink *m_pStatusSink;
public:

DECLARE_REGISTRY_RESOURCEID(IDR_EVENTSOURCE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CEventSource)
	COM_INTERFACE_ENTRY(IEventSource)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IWbemProviderInit)
	COM_INTERFACE_ENTRY(IWbemEventProvider)
	COM_INTERFACE_ENTRY(IWbemEventProviderQuerySink)
	COM_INTERFACE_ENTRY(IWbemEventProviderSecurity)
	COM_INTERFACE_ENTRY(IPrivateInit)
END_COM_MAP()

// IPrivateInit
	STDMETHOD(Test)()
	{
		return S_OK;
	}

// IEventSource
public:
	STDMETHOD(Fire)(/*[in]*/ IWbemClassObject *evt);
	STDMETHOD(GetEventInstance)(/*[in]*/ BSTR strName, /*[out, retval]*/ IDispatch **evt);
	STDMETHOD(Close)()
	{
		if(m_pDecoupledRegistrar)
		{
			m_pDecoupledRegistrar->UnRegister();
//			MessageBox(NULL, "Close UnRegistered", "UnRegistered", 0);
			m_pDecoupledRegistrar->Release();
			m_pDecoupledRegistrar = NULL;
		}
		return S_OK;
	}

	
// IWbemEventProvider
	STDMETHOD(ProvideEvents)(IWbemObjectSink * pEventSink, LONG lFlags)
	{
		if(m_pEventSink)
			m_pEventSink->Release();
		if(pEventSink)
			pEventSink->AddRef();
		m_pEventSink = pEventSink;

		if(m_pStatusSink)
		{
			CEventSourceStatusSink *pSink = (CEventSourceStatusSink *)m_pStatusSink;
			pSink->Fire_ProvideEvents(lFlags);
		}
		return S_OK;
	}
// IWbemEventProviderQuerySink
	STDMETHOD(NewQuery)(ULONG dwId, LPWSTR wszQueryLanguage, LPWSTR wszQuery)
	{
//		Fire_NewQuery(dwId, wszQuery, wszQueryLanguage);

		if(m_pStatusSink)
		{
			CEventSourceStatusSink *pSink = (CEventSourceStatusSink *)m_pStatusSink;
			pSink->Fire_NewQuery(dwId, wszQuery, wszQueryLanguage);
		}

		return S_OK;
	}
	STDMETHOD(CancelQuery)(ULONG dwId)
	{
//		Fire_CancelQuery(dwId);

		if(m_pStatusSink)
		{
			CEventSourceStatusSink *pSink = (CEventSourceStatusSink *)m_pStatusSink;
			pSink->Fire_CancelQuery(dwId);
		}
		return S_OK;
	}
// IWbemEventProviderSecurity
	STDMETHOD(AccessCheck)(WBEM_CWSTR wszQueryLanguage, WBEM_CWSTR wszQuery, long lSidLength, const BYTE *pSid)
	{
		return S_OK;
	}


// IWbemProviderInit
	HRESULT STDMETHODCALLTYPE Initialize(
             /* [in] */ LPWSTR pszUser,
             /* [in] */ LONG lFlags,
             /* [in] */ LPWSTR pszNamespace,
             /* [in] */ LPWSTR pszLocale,
             /* [in] */ IWbemServices *pNamespace,
             /* [in] */ IWbemContext *pCtx,
             /* [in] */ IWbemProviderInitSink *pInitSink
                        )
	{
		if(pNamespace)
	        pNamespace->AddRef();
	    m_pNamespace = pNamespace;

	    //Let CIMOM know you are initialized
	    //==================================
	    
	    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
	    return WBEM_S_NO_ERROR;
	}

};

#endif //__EVENTSOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\generateautomationtests\generateautomationtests.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#define longbuild

using System;
using System.IO;
using System.Reflection;
using System.Text;
using System.CodeDom;
using System.CodeDom.Compiler;
using Microsoft.CSharp;
using Microsoft.VisualBasic;
using Microsoft.JScript;
using System.Collections;
using System.Collections.Specialized;
using System.Management;
using System.Management.Instrumentation;
using System.ComponentModel;

[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		
[assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]

public class MyClass : IDisposable
{
    public void Close()
    {
        Console.WriteLine("Close");

    }
    public void Dispose()
    {
        Console.WriteLine("Dispose");
        Close();
    }
}

public class SupportedType
{
    public Type type;
    public CodeExpression initializer;

    public static readonly SupportedType[] All;
    private static Hashtable typeToTypeMap = new Hashtable();

    public static SupportedType[] GetSupportedTypes(params Type[] types)
    {
        SupportedType[] supportedTypes = new SupportedType[types.Length];
        for(int i=0;i<types.Length;i++)
            supportedTypes[i] = (SupportedType)typeToTypeMap[types[i]];
        return supportedTypes;
    }

    public static CodeTypeDeclaration jscriptHackType;

    static SupportedType()
    {
#if xxx
-3;
3;
-333;
333;
-45678;
45678;
-1234567890;
1234567890;
'A';
(float)(1.0/17.0);
1.0/17.0;
true;
"Hello";
Convert.ToDateTime("5/19/1971 9:23pm");
new TimeSpan(23, 11, 7, 2, 42);
#endif

        jscriptHackType = new CodeTypeDeclaration("JScriptHackConvert");
        CodeMemberMethod hackMethod = new CodeMemberMethod();
        hackMethod.Name = "Hack";
        hackMethod.Attributes = MemberAttributes.Public | MemberAttributes.Static;
        hackMethod.ReturnType = new CodeTypeReference(typeof(IConvertible));
        hackMethod.Parameters.Add(new CodeParameterDeclarationExpression(typeof(object), "obj"));
        CodeCastExpression hackCast = new CodeCastExpression(typeof(IConvertible), new CodeVariableReferenceExpression("obj"));
        hackMethod.Statements.Add(new CodeMethodReturnStatement(hackCast));
        jscriptHackType.Members.Add(hackMethod);

        CodeTypeReference jscriptHackTypeReference = new CodeTypeReference(jscriptHackType.Name);
        CodeTypeReferenceExpression jscriptHackTypeExpression = new CodeTypeReferenceExpression(jscriptHackTypeReference);

        CodePrimitiveExpression Null = new CodePrimitiveExpression(null);
        CodeExpression[] arg1null = new CodeExpression[] {Null};
        CodePrimitiveExpression i8 = new CodePrimitiveExpression((int)-3);
        CodePrimitiveExpression u16 = new CodePrimitiveExpression((int)333);
        CodePrimitiveExpression u32 = new CodePrimitiveExpression((int)4567);
        CodePrimitiveExpression u64 = new CodePrimitiveExpression((long)1234567890);

        CodeExpression initSByte = new CodeMethodInvokeExpression(new CodeCastExpression(typeof(IConvertible), i8), "ToSByte", arg1null);
        CodeExpression initUInt16 = new CodeMethodInvokeExpression(new CodeCastExpression(typeof(IConvertible), u16), "ToUInt16", arg1null);
        CodeExpression initUInt32 = new CodeMethodInvokeExpression(new CodeCastExpression(typeof(IConvertible), u32), "ToUInt32", arg1null);
        CodeExpression initUInt64 = new CodeMethodInvokeExpression(new CodeCastExpression(typeof(IConvertible), u64), "ToUInt64", arg1null);

        // JSCript Hack
        initSByte = new CodeMethodInvokeExpression(new CodeMethodInvokeExpression(jscriptHackTypeExpression, hackMethod.Name, new CodeExpression[] {i8}), "ToSByte", arg1null);
        initUInt16 = new CodeMethodInvokeExpression(new CodeMethodInvokeExpression(jscriptHackTypeExpression, hackMethod.Name, new CodeExpression[] {u16}), "ToUInt16", arg1null);
        initUInt32 = new CodeMethodInvokeExpression(new CodeMethodInvokeExpression(jscriptHackTypeExpression, hackMethod.Name, new CodeExpression[] {u32}), "ToUInt32", arg1null);
        initUInt64 = new CodeMethodInvokeExpression(new CodeMethodInvokeExpression(jscriptHackTypeExpression, hackMethod.Name, new CodeExpression[] {u64}), "ToUInt64", arg1null);

        ArrayList all = new ArrayList();
        SupportedType type;

        type = new SupportedType();
        type.type = typeof(sbyte);
        type.initializer = initSByte;
        all.Add(type);

        type = new SupportedType();
        type.type = typeof(byte);
        type.initializer = new CodePrimitiveExpression((byte)3);
        all.Add(type);

        type = new SupportedType();
        type.type = typeof(short);
        type.initializer = new CodePrimitiveExpression((short)-333);
        all.Add(type);

        type = new SupportedType();
        type.type = typeof(ushort);
        type.initializer = initUInt16;
        all.Add(type);

        type = new SupportedType();
        type.type = typeof(int);
        type.initializer = new CodePrimitiveExpression((int)-4567);
        all.Add(type);

        type = new SupportedType();
        type.type = typeof(uint);
        type.initializer = initUInt32;
        all.Add(type);

        type = new SupportedType();
        type.type = typeof(long);
        type.initializer = new CodePrimitiveExpression((long)-1234567890);
        all.Add(type);

        type = new SupportedType();
        type.type = typeof(ulong);
        type.initializer = initUInt64;
        all.Add(type);

        type = new SupportedType();
        type.type = typeof(char);
        type.initializer = new CodePrimitiveExpression((char)'A');
        all.Add(type);

        type = new SupportedType();
        type.type = typeof(float);
        type.initializer = new CodePrimitiveExpression((float)(1.0/17.0));
        all.Add(type);

        type = new SupportedType();
        type.type = typeof(double);
        type.initializer = new CodePrimitiveExpression((double)(1.0/17.0));
        all.Add(type);

        type = new SupportedType();
        type.type = typeof(bool);
        type.initializer = new CodePrimitiveExpression((bool)true);
        all.Add(type);

        type = new SupportedType();
        type.type = typeof(string);
        type.initializer = new CodePrimitiveExpression((string)"Hello");
        all.Add(type);

        type = new SupportedType();
        type.type = typeof(DateTime);

        // JScriptHack
//        CodeExpression[] argDateTimeString = new CodeExpression[] {new CodePrimitiveExpression("5/19/1971 9:23pm")};
//        type.initializer = new CodeMethodInvokeExpression(new CodeTypeReferenceExpression(typeof(Convert)), "ToDateTime", argDateTimeString);
        type.initializer = new CodeMethodInvokeExpression(
                                new CodeMethodInvokeExpression(
                                        jscriptHackTypeExpression,
                                        hackMethod.Name,
                                        new CodeExpression[] {new CodePrimitiveExpression("5/19/1971 9:23pm")} ),
                                "ToDateTime",
                                arg1null );


        all.Add(type);

        type = new SupportedType();
        type.type = typeof(TimeSpan);
        CodeExpression[] argTimeSpanCTOR = new CodeExpression[] {   new CodePrimitiveExpression(23),
                                                                    new CodePrimitiveExpression(11),
                                                                    new CodePrimitiveExpression(7),
                                                                    new CodePrimitiveExpression(2),
                                                                    new CodePrimitiveExpression(42) };
        type.initializer = new CodeObjectCreateExpression(typeof(TimeSpan), argTimeSpanCTOR);
        all.Add(type);

        All = (SupportedType[])all.ToArray(typeof(SupportedType));

        // Fill in hashtable
        foreach(SupportedType supportedType in All)
        {
            typeToTypeMap.Add(supportedType.type, supportedType);
        }

        CodeTypeReferenceExpression provType = new CodeTypeReferenceExpression(typeof(InstrumentationType));

        CodeFieldReferenceExpression provTypeEvent = new CodeFieldReferenceExpression(provType, "Event");
        CodeAttributeArgument attrArgEvent = new CodeAttributeArgument(provTypeEvent);
        attrProvEvent = new CodeAttributeDeclaration(typeof(InstrumentationClassAttribute).Name, new CodeAttributeArgument[] {attrArgEvent});

        CodeFieldReferenceExpression provTypeAbstract = new CodeFieldReferenceExpression(provType, "Abstract");
        CodeAttributeArgument attrArgAbstract = new CodeAttributeArgument(provTypeAbstract);
        attrProvAbstract = new CodeAttributeDeclaration(typeof(InstrumentationClassAttribute).Name, new CodeAttributeArgument[] {attrArgAbstract});

        CodeFieldReferenceExpression provTypeInstance = new CodeFieldReferenceExpression(provType, "Instance");
        CodeAttributeArgument attrArgInstance = new CodeAttributeArgument(provTypeInstance);
        attrProvInstance = new CodeAttributeDeclaration(typeof(InstrumentationClassAttribute).Name, new CodeAttributeArgument[] {attrArgInstance});
    }
    public static CodeAttributeDeclaration attrProvEvent;
    public static CodeAttributeDeclaration attrProvInstance;
    public static CodeAttributeDeclaration attrProvAbstract;
}

public class AssemblyGenerator
{
    static readonly CodeNamespaceImport nsSystem = new CodeNamespaceImport("System");
    static readonly CodeNamespaceImport nsSystem_Reflection = new CodeNamespaceImport("System.Reflection");
    static readonly CodeNamespaceImport nsSystem_ComponentModel = new CodeNamespaceImport("System.ComponentModel");
    static readonly CodeNamespaceImport nsSystem_Management = new CodeNamespaceImport("System.Management");
    static readonly CodeNamespaceImport nsSystem_Management_Instrumentation = new CodeNamespaceImport("System.Management.Instrumentation");
    static readonly CodeNamespaceImport nsMicrosoft_VisualBasic = new CodeNamespaceImport("Microsoft.VisualBasic");

    public static CodeNamespace GenNamespaceForInstrumentation(string name, bool isVBHack)
    {
        CodeNamespace codeNamespace = new CodeNamespace(name);
        codeNamespace.Imports.Add(nsSystem);
        codeNamespace.Imports.Add(nsSystem_Reflection);
        codeNamespace.Imports.Add(nsSystem_ComponentModel);
        codeNamespace.Imports.Add(nsSystem_Management_Instrumentation);
        // HACK FOR VB to get ChrW()
        if(isVBHack)
            codeNamespace.Imports.Add(nsMicrosoft_VisualBasic);
        return codeNamespace;
    }

    public static CodeCompileUnit GenInstrumentedModule()
    {
        CodeCompileUnit unit = new CodeCompileUnit();
        unit.ReferencedAssemblies.Add("System.dll");
        unit.ReferencedAssemblies.Add("..\\System.Management2.dll");
        unit.ReferencedAssemblies.Add("System.Configuration.Install.dll");
        return unit;
    }
    public static CodeCompileUnit GenInstrumentedAssembly(string namespaceName)
    {
        CodeCompileUnit unit = GenInstrumentedModule();

        // TODO: Add comment
        // Make sure each build gets a unique version #
        CodeAttributeDeclaration assemblyAttr = new CodeAttributeDeclaration(typeof(AssemblyVersionAttribute).FullName, new CodeAttributeArgument[] {new CodeAttributeArgument(new CodePrimitiveExpression("1.0.*"))});
        unit.AssemblyCustomAttributes.Add(assemblyAttr);

        // TODO: Add comment
        // Events/Instances in this assembly will go into the 'namespaceName' namespace
        CodeAttributeDeclaration instrumentedAttr = new CodeAttributeDeclaration(typeof(InstrumentedAttribute).FullName, new CodeAttributeArgument[] {new CodeAttributeArgument(new CodePrimitiveExpression(namespaceName))});
        unit.AssemblyCustomAttributes.Add(instrumentedAttr);

        // TODO: Add comment
        // Default installer for instrumentation
        //[RunInstaller(true)]
        //public class MyInstaller : DefaultManagementProjectInstaller {}
        CodeNamespace codeNamespaceInstaller = new CodeNamespace("InstrumentedAppInstaller");
        CodeTypeDeclaration typeMyInstaller = new CodeTypeDeclaration("MyInstaller");
        typeMyInstaller.BaseTypes.Add(typeof(DefaultManagementProjectInstaller));
        CodeAttributeDeclaration runInstallerAttribute = new CodeAttributeDeclaration(typeof(RunInstallerAttribute).FullName, new CodeAttributeArgument[] {new CodeAttributeArgument(new CodePrimitiveExpression(true))});
        typeMyInstaller.CustomAttributes.Add(runInstallerAttribute);
        codeNamespaceInstaller.Types.Add(typeMyInstaller);
        unit.Namespaces.Add(codeNamespaceInstaller);

        return unit;
    }

    public static CodeTypeDeclaration GenMainClass(CodeStatementCollection statements)
    {
        //NOTE: User must set type Name
        CodeTypeDeclaration app = new CodeTypeDeclaration();
        CodeMemberMethod main = new CodeMemberMethod();
        main.Name = "Main";
        main.Attributes = MemberAttributes.Public | MemberAttributes.Static;
        main.Statements.AddRange(statements);
        app.Members.Add(main);
        return app;
    }

}

class App
{
    static CodeMemberField GenerateInstrumentedField(SupportedType typeField, string namePrefix)
    {
        CodeMemberField member = new CodeMemberField(typeField.type, namePrefix/*+typeField.type.Name*/);
        member.Attributes = MemberAttributes.Public;
        member.UserData.Add("wmimember", typeField);
        return member;
    }

    static CodeTypeMember [] GenerateInstrumentedProperty(SupportedType typeProperty, string namePrefix)
    {
        string name = namePrefix/*+typeProperty.type.Name*/;
        string hiddenFieldName = "_"+name;

        CodePropertySetValueReferenceExpression valueExp = new CodePropertySetValueReferenceExpression();

        CodeMemberField hiddenField = new CodeMemberField(typeProperty.type, hiddenFieldName);
        hiddenField.Attributes = MemberAttributes.Private;

        CodeFieldReferenceExpression hiddenFieldExp = new CodeFieldReferenceExpression(null, hiddenField.Name);

        CodeMemberProperty property = new CodeMemberProperty();
        property.Name = name;
        property.Type = new CodeTypeReference(typeProperty.type);
        property.Attributes = MemberAttributes.Public;
        property.UserData.Add("wmimember", typeProperty);
        property.HasGet = true;
        property.HasSet = true;
        property.GetStatements.Add(new CodeMethodReturnStatement(hiddenFieldExp));
        property.SetStatements.Add(new CodeAssignStatement(hiddenFieldExp, valueExp));

        CodeTypeMember [] members = new CodeTypeMember[2];
        members[0] = hiddenField;
        members[1] = property;

        return members;
    }

    static CodeTypeDeclaration GenerateBigType(string name, CodeTypeDeclaration baseType, SupportedType[] fieldTypes, SupportedType[] propTypes, CodeAttributeDeclaration attr)
    {
        CodeTypeDeclaration typeDeclaration = new CodeTypeDeclaration();
        typeDeclaration.Name = name;

        string trailer = "";
        if(null != baseType && baseType.UserData.Contains("memberTrailer"))
        {
            trailer = (string)baseType.UserData["memberTrailer"];
        }
        if(null != fieldTypes)
        {
            for(int i=0;i<fieldTypes.Length;i++)
                typeDeclaration.Members.Add(GenerateInstrumentedField(fieldTypes[i], "f"+i.ToString()+trailer));
        }
        if(null != propTypes)
        {
            for(int i=0;i<propTypes.Length;i++)
                typeDeclaration.Members.AddRange(GenerateInstrumentedProperty(propTypes[i], "p"+i.ToString()+trailer));
        }
        if(null != baseType)
        {
            typeDeclaration.BaseTypes.Add(baseType.Name);
            typeDeclaration.UserData.Add("wmiBaseType", baseType);
        }
        trailer += "x";
        typeDeclaration.UserData.Add("memberTrailer", trailer);

        if(null != attr)
            typeDeclaration.CustomAttributes.Add(attr);
        return typeDeclaration;
    }

    static void AppendWMIMembers(CodeTypeDeclaration type, CodeTypeMemberCollection members)
    {
        foreach(CodeTypeMember member in type.Members)
        {
            SupportedType wmimember = (SupportedType)member.UserData["wmimember"];
            if(null != wmimember)
                members.Add(member);
        }
        CodeTypeDeclaration wmiBaseType = (CodeTypeDeclaration)type.UserData["wmiBaseType"];
        if(null != wmiBaseType)
            AppendWMIMembers(wmiBaseType, members);
    }

    static CodeTypeMemberCollection GetWMIMembers(CodeTypeDeclaration type)
    {
        CodeTypeMemberCollection members = new CodeTypeMemberCollection();
        AppendWMIMembers(type, members);
        return members;
    }

    static CodeStatementCollection TestCreateInstance(CodeTypeDeclaration evtTypeDef, string variableName)
    {
        CodeVariableReferenceExpression evtVar = new CodeVariableReferenceExpression(variableName);
        CodeTypeReference evtTypeRef = new CodeTypeReference(evtTypeDef.Name);

        CodeStatementCollection statements = new CodeStatementCollection();

        statements.Add(new CodeVariableDeclarationStatement(evtTypeRef, evtVar.VariableName, new CodeObjectCreateExpression(evtTypeRef, new CodeExpression[] {})));

        foreach(CodeTypeMember member in GetWMIMembers(evtTypeDef))
        {
            SupportedType wmimember = (SupportedType)member.UserData["wmimember"];
            CodeMemberField field = member as CodeMemberField;
            CodeMemberProperty prop = member as CodeMemberProperty;

            if(null != field)
                statements.Add(new CodeAssignStatement(new CodeFieldReferenceExpression(evtVar, field.Name), wmimember.initializer));
            else if(null != prop)
                statements.Add(new CodeAssignStatement(new CodePropertyReferenceExpression(evtVar, prop.Name), wmimember.initializer));
        }
        return statements;
    }

    static CodeTypeDeclarationCollection GenerateLeaf(string name, SupportedType[] fieldTypes, SupportedType[] propTypes, bool isEvent, bool isType2)
    {
        CodeTypeDeclarationCollection instrumentedTypes = new CodeTypeDeclarationCollection();

        CodeTypeDeclaration  type = GenerateBigType(name+"A", null, fieldTypes, propTypes, isEvent ? SupportedType.attrProvEvent:SupportedType.attrProvAbstract);
        if(isType2)
            type.BaseTypes.Add(isEvent?typeof(System.Management.Instrumentation.Event):typeof(System.Management.Instrumentation.Instance));
        instrumentedTypes.Add(type);
        return instrumentedTypes;
    }

    static CodeTypeDeclarationCollection GenerateSmallTree(string name, SupportedType[] fieldTypes, SupportedType[] propTypes, bool isEvent, bool isType2)
    {
        CodeTypeDeclarationCollection instrumentedTypes = new CodeTypeDeclarationCollection();

        CodeTypeDeclaration type, typeD1, typeD2;

        type = GenerateBigType(name+"A", null, fieldTypes, propTypes, isEvent ? SupportedType.attrProvEvent:SupportedType.attrProvAbstract);
        if(isType2)
            type.BaseTypes.Add(isEvent?typeof(System.Management.Instrumentation.Event):typeof(System.Management.Instrumentation.Instance));

        typeD1 = GenerateBigType(name+"AA", type, fieldTypes, propTypes, isEvent ? SupportedType.attrProvEvent:SupportedType.attrProvInstance);
        typeD2 = GenerateBigType(name+"AB", type, fieldTypes, propTypes, isEvent ? SupportedType.attrProvEvent:SupportedType.attrProvInstance);
        instrumentedTypes.Add(type);
        instrumentedTypes.Add(typeD1);
        instrumentedTypes.Add(typeD2);

        return instrumentedTypes;
    }

    static CodeTypeDeclarationCollection GenerateLongTree(string name, SupportedType[] fieldTypes, SupportedType[] propTypes, bool isEvent, bool isType2)
    {
        CodeTypeDeclarationCollection instrumentedTypes = new CodeTypeDeclarationCollection();

        CodeTypeDeclaration type, typeD, typeDD, typeDDD, typeDDDD, typeDDDDD, typeDDDDDD;

        type = GenerateBigType(name+"A", null, fieldTypes, propTypes, isEvent ? SupportedType.attrProvEvent:SupportedType.attrProvAbstract);
        if(isType2)
            type.BaseTypes.Add(isEvent?typeof(System.Management.Instrumentation.Event):typeof(System.Management.Instrumentation.Instance));

        typeD = GenerateBigType(name+"AA", type, fieldTypes, propTypes, isEvent ? SupportedType.attrProvEvent:SupportedType.attrProvAbstract);
        typeDD = GenerateBigType(name+"AAA", typeD, fieldTypes, propTypes, isEvent ? SupportedType.attrProvEvent:SupportedType.attrProvAbstract);
        typeDDD = GenerateBigType(name+"AAAA", typeDD, fieldTypes, propTypes, isEvent ? SupportedType.attrProvEvent:SupportedType.attrProvAbstract);
        typeDDDD = GenerateBigType(name+"AAAAA", typeDDD, fieldTypes, propTypes, isEvent ? SupportedType.attrProvEvent:SupportedType.attrProvAbstract);
        typeDDDDD = GenerateBigType(name+"AAAAAA", typeDDDD, fieldTypes, propTypes, isEvent ? SupportedType.attrProvEvent:SupportedType.attrProvAbstract);
        typeDDDDDD = GenerateBigType(name+"AAAAAAA", typeDDDDD, fieldTypes, propTypes, isEvent ? SupportedType.attrProvEvent:SupportedType.attrProvInstance);
        instrumentedTypes.Add(type);
        instrumentedTypes.Add(typeD);
        instrumentedTypes.Add(typeDD);
        instrumentedTypes.Add(typeDDD);
        instrumentedTypes.Add(typeDDDD);
        instrumentedTypes.Add(typeDDDDD);
        instrumentedTypes.Add(typeDDDDDD);

        return instrumentedTypes;
    }

    static CodeTypeDeclarationCollection GenerateMedTree(string name, SupportedType[] fieldTypes, SupportedType[] propTypes, bool isEvent, bool isType2)
    {
        CodeTypeDeclarationCollection instrumentedTypes = new CodeTypeDeclarationCollection();

        CodeTypeDeclaration type, typeD1, typeD2, typeD1a, typeD1b;

        type = GenerateBigType(name+"A", null, fieldTypes, propTypes, isEvent ? SupportedType.attrProvEvent:SupportedType.attrProvAbstract);
        if(isType2)
            type.BaseTypes.Add(isEvent?typeof(System.Management.Instrumentation.Event):typeof(System.Management.Instrumentation.Instance));

        typeD1 = GenerateBigType(name+"AA", type, fieldTypes, propTypes, isEvent ? SupportedType.attrProvEvent:SupportedType.attrProvAbstract);
        typeD1a = GenerateBigType(name+"AAA", typeD1, fieldTypes, propTypes, isEvent ? SupportedType.attrProvEvent:SupportedType.attrProvInstance);
        typeD1b = GenerateBigType(name+"AAB", typeD1, fieldTypes, propTypes, isEvent ? SupportedType.attrProvEvent:SupportedType.attrProvInstance);
        typeD2 = GenerateBigType(name+"AB", type, fieldTypes, propTypes, isEvent ? SupportedType.attrProvEvent:SupportedType.attrProvInstance);
        instrumentedTypes.Add(type);
        instrumentedTypes.Add(typeD1);
        instrumentedTypes.Add(typeD1a);
        instrumentedTypes.Add(typeD1b);
        instrumentedTypes.Add(typeD2);

        return instrumentedTypes;
    }

    static CodeTypeDeclarationCollection GenerateTree(string name, SupportedType[] fieldTypes, SupportedType[] propTypes, bool isEvent, bool isType2)
    {
        CodeTypeDeclarationCollection instrumentedTypes = new CodeTypeDeclarationCollection();

        CodeTypeDeclaration type, typeD1, typeD2, typeD1a, typeD1b;

        type = GenerateBigType(name+"A", null, fieldTypes, propTypes, isEvent ? SupportedType.attrProvEvent:SupportedType.attrProvAbstract);
        if(isType2)
            type.BaseTypes.Add(isEvent?typeof(System.Management.Instrumentation.Event):typeof(System.Management.Instrumentation.Instance));

        typeD1 = GenerateBigType(name+"AA", type, fieldTypes, propTypes, isEvent ? SupportedType.attrProvEvent:SupportedType.attrProvAbstract);
        typeD1a = GenerateBigType(name+"AAA", typeD1, fieldTypes, propTypes, isEvent ? SupportedType.attrProvEvent:SupportedType.attrProvInstance);
        typeD1b = GenerateBigType(name+"AAB", typeD1, fieldTypes, propTypes, isEvent ? SupportedType.attrProvEvent:SupportedType.attrProvInstance);
        typeD2 = GenerateBigType(name+"AB", type, fieldTypes, propTypes, isEvent ? SupportedType.attrProvEvent:SupportedType.attrProvInstance);
        instrumentedTypes.Add(type);
        instrumentedTypes.Add(typeD1);
        instrumentedTypes.Add(typeD1a);
        instrumentedTypes.Add(typeD1b);
        instrumentedTypes.Add(typeD2);

        type = GenerateBigType(name+"B", null, fieldTypes, propTypes, isEvent ? SupportedType.attrProvEvent:SupportedType.attrProvAbstract);
        if(isType2)
            type.BaseTypes.Add(isEvent?typeof(System.Management.Instrumentation.Event):typeof(System.Management.Instrumentation.Instance));

        typeD1 = GenerateBigType(name+"BA", type, fieldTypes, propTypes, isEvent ? SupportedType.attrProvEvent:SupportedType.attrProvInstance);
        typeD2 = GenerateBigType(name+"BB", type, fieldTypes, propTypes, isEvent ? SupportedType.attrProvEvent:SupportedType.attrProvInstance);
        instrumentedTypes.Add(type);
        instrumentedTypes.Add(typeD1);
        instrumentedTypes.Add(typeD2);

        type = GenerateBigType(name+"C", null, fieldTypes, propTypes, isEvent ? SupportedType.attrProvEvent:SupportedType.attrProvInstance);
        if(isType2)
            type.BaseTypes.Add(isEvent?typeof(System.Management.Instrumentation.Event):typeof(System.Management.Instrumentation.Instance));

        instrumentedTypes.Add(type);

        return instrumentedTypes;
    }

    static CodeTypeDeclarationCollection GenerateMultiTree(string name, SupportedType[] supportedTypes, bool isEvent, bool isType2)
    {
        CodeTypeDeclarationCollection types = new CodeTypeDeclarationCollection();
        types.AddRange(GenerateTree(name+"F_", supportedTypes, null, isEvent, isType2));
        types.AddRange(GenerateTree(name+"_P", null, supportedTypes, isEvent, isType2));
        types.AddRange(GenerateTree(name+"FP", supportedTypes, supportedTypes, isEvent, isType2));
        return types;
    }

    static CodeTypeDeclarationCollection GenerateForest(string name, bool isEvent, bool isType2)
    {
        CodeTypeDeclarationCollection types = new CodeTypeDeclarationCollection();

        SupportedType[] tinyTypes = SupportedType.GetSupportedTypes(typeof(string));
        SupportedType[] smallTypes = SupportedType.GetSupportedTypes(typeof(string), typeof(string));
        SupportedType[] mediumTypes = SupportedType.GetSupportedTypes(typeof(string), typeof(string), typeof(int), typeof(int));
        types.AddRange(GenerateMultiTree(name+"T", tinyTypes, isEvent, isType2));
        types.AddRange(GenerateMultiTree(name+"S", smallTypes, isEvent, isType2));
        types.AddRange(GenerateMultiTree(name+"M", mediumTypes, isEvent, isType2));
        types.AddRange(GenerateMultiTree(name+"B", SupportedType.All, isEvent, isType2));

        return types;
    }

    static CodeTypeDeclarationCollection GenAllIntrumentedTypeDefs(string name)
    {
        CodeTypeDeclarationCollection instrumentedTypes = new CodeTypeDeclarationCollection();
        instrumentedTypes.AddRange(GenerateForest(name+"E1", true, false));
        instrumentedTypes.AddRange(GenerateForest(name+"I1", false, false));
        instrumentedTypes.AddRange(GenerateForest(name+"E2", true, true));
        instrumentedTypes.AddRange(GenerateForest(name+"I2", false, true));

        return instrumentedTypes;
    }

    static CodeStatementCollection GenTestCases(CodeTypeDeclarationCollection types)
    {
        CodeStatementCollection statements = new CodeStatementCollection();
        foreach(CodeTypeDeclaration typeDef in types)
        {
            statements.AddRange(TestCreateInstance(typeDef, typeDef.Name.ToLower()));
        }
        return statements;
    }

    static void GenSample(string name, TestAppConfig appConfig, SuiteConfig suiteConfig, CodeTypeDeclarationCollection instrumentedTypes, bool isLibrary)
    {
        CodeDomProvider provider = appConfig.provider;
        CodeGeneratorOptions options = appConfig.options;

        CodeStatementCollection testStatements = GenTestCases(instrumentedTypes);

        CodeTypeDeclaration mainClass = AssemblyGenerator.GenMainClass(testStatements);
        mainClass.Name = name+"App";

        CodeNamespace codeNamespace = AssemblyGenerator.GenNamespaceForInstrumentation(name+"App", provider is VBCodeProvider);
        codeNamespace.Types.Add(SupportedType.jscriptHackType);
        codeNamespace.Types.AddRange(instrumentedTypes);
        codeNamespace.Types.Add(mainClass);

        CodeCompileUnit unit = AssemblyGenerator.GenInstrumentedAssembly("root\\TestAppZ");
        unit.Namespaces.Add(codeNamespace);

//        CodeCompileUnit unitMod = AssemblyGenerator.GenInstrumentedModule();

        string fileName = name+"."+provider.FileExtension;
        string assemblyName = name+"."+(isLibrary?"dll":"exe");
        string target = (isLibrary?" /target:library":"");

#if SUBDIRSFORLANG
        string subDir = Path.Combine(Environment.CurrentDirectory, provider.FileExtension);
        Directory.CreateDirectory(subDir);
        string oldDir = Environment.CurrentDirectory;
        Environment.CurrentDirectory = subDir;
#endif

        Console.WriteLine("Generating "+fileName);

        using(StreamWriter writer = new StreamWriter(fileName, false, Encoding.ASCII))
        {
            provider.CreateGenerator().GenerateCodeFromCompileUnit(unit, writer, options);
        }
#if xxx
        string fileNameMod = name+"Mod."+provider.FileExtension;
        string moduleName = name+"Mod."+"mod";
        using(StreamWriter writer = new StreamWriter(fileNameMod, false, Encoding.ASCII))
        {
            provider.CreateGenerator().GenerateCodeFromCompileUnit(unitMod, writer, options);
        }
#endif

#if SUBDIRSFORLANG
        Environment.CurrentDirectory = oldDir;
#endif

#if SUBDIRSFORLANG
        suiteConfig.commands1.Add("cd " + provider.FileExtension);
#endif
        suiteConfig.commands1.Add("echo Building "+fileName);
        suiteConfig.commands1.Add(appConfig.GetComplerCommand(unit) + target + " /out:" + assemblyName + " " + fileName);
        //        suiteConfig.commands1.Add(appConfig.GetComplerCommand(unit) + " /target:module /out:" + moduleName + " " + fileNameMod);
#if SUBDIRSFORLANG
        suiteConfig.commands1.Add("cd ..");
#endif


#if SUBDIRSFORLANG
        suiteConfig.commands2.Add("cd " + provider.FileExtension);
#endif
        suiteConfig.commands2.Add("echo InstallUtil "+assemblyName);
        suiteConfig.commands2.Add("InstallUtil /LogToConsole=false " + assemblyName);
#if SUBDIRSFORLANG
        suiteConfig.commands2.Add("cd ..");
#endif
    }
    
    public class TestAppConfig
    {
        public TestAppConfig(CodeDomProvider provider, CodeGeneratorOptions options)
        {
            this.provider = provider;
            this.options = options;
        }
        public CodeDomProvider provider;
        public CodeGeneratorOptions options;
        public string GetComplerCommand(CodeCompileUnit unit)
        {
            string cmd;
            if(provider is CSharpCodeProvider)
                cmd = "csc";
            else if(provider is VBCodeProvider)
                cmd = "vbc";
            else if(provider is JScriptCodeProvider)
                cmd = "jsc";
            else
                throw new Exception();
            cmd += " /nologo";
            foreach(string str in unit.ReferencedAssemblies)
            {
                cmd += " /R:"+str;
            }
            return cmd;
        }
    }

    public class SuiteConfig
    {
        public StringCollection commands1 = new StringCollection();
        public StringCollection commands2 = new StringCollection();
        public StringCollection commands3 = new StringCollection();
    }

    public delegate CodeTypeDeclarationCollection genFunc(string name, SupportedType[] fieldTypes, SupportedType[] propTypes, bool isEvent, bool isType2);


    public static void Gen1(string name, TestAppConfig appConfig, SuiteConfig suiteConfig, string typeName, SupportedType[] types, genFunc func, bool isLibrary)
    {
        string ending=isLibrary?"L":"E";

        GenSample(name+"E1"+typeName+"F_"+ending, appConfig, suiteConfig, func(name+"E1"+typeName+"F_"+ending, types, null, true, false), isLibrary);
        GenSample(name+"E1"+typeName+"_P"+ending, appConfig, suiteConfig, func(name+"E1"+typeName+"_P"+ending, null, types, true, false), isLibrary);
        GenSample(name+"E1"+typeName+"FP"+ending, appConfig, suiteConfig, func(name+"E1"+typeName+"FP"+ending, types, types, true, false), isLibrary);
        GenSample(name+"E2"+typeName+"F_"+ending, appConfig, suiteConfig, func(name+"E2"+typeName+"F_"+ending, types, null, true, true), isLibrary);
        GenSample(name+"E2"+typeName+"_P"+ending, appConfig, suiteConfig, func(name+"E2"+typeName+"_P"+ending, null, types, true, true), isLibrary);
        GenSample(name+"E2"+typeName+"FP"+ending, appConfig, suiteConfig, func(name+"E2"+typeName+"FP"+ending, types, types, true, true), isLibrary);
        GenSample(name+"I1"+typeName+"F_"+ending, appConfig, suiteConfig, func(name+"I1"+typeName+"F_"+ending, types, null, false, false), isLibrary);
        GenSample(name+"I1"+typeName+"_P"+ending, appConfig, suiteConfig, func(name+"I1"+typeName+"_P"+ending, null, types, false, false), isLibrary);
        GenSample(name+"I1"+typeName+"FP"+ending, appConfig, suiteConfig, func(name+"I1"+typeName+"FP"+ending, types, types, false, false), isLibrary);
        GenSample(name+"I2"+typeName+"F_"+ending, appConfig, suiteConfig, func(name+"I2"+typeName+"F_"+ending, types, null, false, true), isLibrary);
        GenSample(name+"I2"+typeName+"_P"+ending, appConfig, suiteConfig, func(name+"I2"+typeName+"_P"+ending, null, types, false, true), isLibrary);
        GenSample(name+"I2"+typeName+"FP"+ending, appConfig, suiteConfig, func(name+"I2"+typeName+"FP"+ending, types, types, false, true), isLibrary);
    }

    public static void GenTrees(string name, TestAppConfig appConfig, SuiteConfig suiteConfig, genFunc f1)
    {
        SupportedType[] tinyTypes = SupportedType.GetSupportedTypes(typeof(string));
        SupportedType[] smallTypes = SupportedType.GetSupportedTypes(typeof(string), typeof(string));
        SupportedType[] mediumTypes = SupportedType.GetSupportedTypes(typeof(string), typeof(string), typeof(int), typeof(int));

        Gen1(name, appConfig, suiteConfig, "T", tinyTypes, f1, true);
        Gen1(name, appConfig, suiteConfig, "T", tinyTypes, f1, false);
#if longbuild
        Gen1(name, appConfig, suiteConfig, "S", smallTypes, f1, true);
        Gen1(name, appConfig, suiteConfig, "S", smallTypes, f1, false);
        Gen1(name, appConfig, suiteConfig, "M", mediumTypes, f1, true);
        Gen1(name, appConfig, suiteConfig, "M", mediumTypes, f1, false);
        Gen1(name, appConfig, suiteConfig, "B", SupportedType.All, f1, true);
        Gen1(name, appConfig, suiteConfig, "B", SupportedType.All, f1, false);
#endif
    }

    public static void GenSamples(TestAppConfig appConfig, SuiteConfig suiteConfig)
    {
        string name = appConfig.provider.FileExtension;

        GenSample(name+"99L", appConfig, suiteConfig, GenAllIntrumentedTypeDefs(name+"99L"), true);
        GenSample(name+"99E", appConfig, suiteConfig, GenAllIntrumentedTypeDefs(name+"99E"), false);


#if longbuild
        GenTrees(name + "10", appConfig, suiteConfig, new genFunc(GenerateLeaf));
        GenTrees(name + "21", appConfig, suiteConfig, new genFunc(GenerateSmallTree));
        GenTrees(name + "22", appConfig, suiteConfig, new genFunc(GenerateMedTree));
        GenTrees(name + "23", appConfig, suiteConfig, new genFunc(GenerateLongTree));
#endif
        GenTrees(name + "29", appConfig, suiteConfig, new genFunc(GenerateTree));


//        GenSample(name+"20", appConfig, suiteConfig, GenerateTree(name+"20", tinyTypes, null, true, false));
    }

    static void Test()
    {
        ManagementClass newClass = new ManagementClass("root", "", null);
        newClass.SystemProperties ["__CLASS"].Value = "xyz";

        ManagementClass paramsIn = new ManagementClass("root:__PARAMETERS");
        paramsIn.Properties.Add("param1", CimType.String, false);
        paramsIn.Properties["param1"].Qualifiers.Add("IN", true);
        paramsIn.Properties["param1"].Qualifiers.Add("ID", 0);
        paramsIn.Properties.Add("param2", CimType.String, false);
        paramsIn.Properties["param2"].Qualifiers.Add("IN", true);
        paramsIn.Properties["param2"].Qualifiers.Add("ID", 1);

        ManagementClass paramsOut = new ManagementClass("root:__PARAMETERS");
        paramsOut.Properties.Add("param1", CimType.String, false);
        paramsOut.Properties["param1"].Qualifiers.Add("OUT", true);
        paramsOut.Properties["param1"].Qualifiers.Add("ID", 0);
        paramsOut.Properties.Add("ReturnValue", CimType.String, false);
        paramsOut.Properties["ReturnValue"].Qualifiers.Add("OUT", true);


        newClass.Methods.Add("F1", paramsIn, paramsOut);
        Console.WriteLine(newClass.GetText(TextFormat.Mof));

    }
    static void Main(string[] args)
	{
        Test();
        return;

        TestAppConfig[] appConfigs = new TestAppConfig[] {new TestAppConfig(new CSharpCodeProvider(), new CodeGeneratorOptions()),
                                                       new TestAppConfig(new VBCodeProvider(), new CodeGeneratorOptions()),
                                                       new TestAppConfig(new JScriptCodeProvider(), new CodeGeneratorOptions()) };
        

        SuiteConfig suiteConfig = new SuiteConfig();
        suiteConfig.commands1.Add("@echo off");

        string dir = Path.Combine(Environment.CurrentDirectory, "TestApps");
        Directory.CreateDirectory(dir);
        Environment.CurrentDirectory = dir;

        foreach(TestAppConfig appConfig in appConfigs)
        {
            GenSamples(appConfig, suiteConfig);
        }

        Environment.CurrentDirectory = dir;
        using(StreamWriter writer = new StreamWriter("makeall.bat", false, Encoding.ASCII))
        {
            foreach(string command in suiteConfig.commands1)
                writer.WriteLine(command);
            foreach(string command in suiteConfig.commands2)
                writer.WriteLine(command);
            foreach(string command in suiteConfig.commands3)
                writer.WriteLine(command);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wminet_utils\eventsource2.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// EventSource2.h : Declaration of the CEventSource2

#pragma once
#include "resource.h"       // main symbols



// CEventSource2

class ATL_NO_VTABLE CEventSource2 : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CEventSource2, &CLSID_EventSource2>,
	public IWbemProviderInit,
	public IWbemEventProvider,
	public IWbemEventProviderQuerySink,
	public IWbemEventProviderSecurity,
	public IEventSource2
{
public:
	CEventSource2()
	{
		m_pDecoupledRegistrar = NULL;
		m_pStatusSink = NULL;

		m_pEventSink = NULL;
		m_pNamespace = NULL;
		m_bstrNamespace = NULL;
		m_bstrApp = NULL;
	}

	~CEventSource2()
	{
		if(m_pDecoupledRegistrar)
		{
			// TODO: Only UnRegister if registered
			m_pDecoupledRegistrar->UnRegister();
			m_pDecoupledRegistrar->Release();
		}

		if(m_pStatusSink)
			m_pStatusSink->Release();

		if(m_pEventSink)
			m_pEventSink->Release();

		if(m_pNamespace)
			m_pNamespace->Release();

		if(NULL != m_bstrNamespace)
			SysFreeString(m_bstrNamespace);

		if(NULL != m_bstrApp)
			SysFreeString(m_bstrApp);
	}
	HRESULT Init(BSTR bstrNamespace, BSTR bstrApp, IEventSourceStatusSink *pSink)
    {
		return Init(bstrNamespace, bstrApp);
    }

	STDMETHOD(Init)(BSTR bstrNamespace, BSTR bstrApp)
	{
		IEventSourceStatusSink *pSink = NULL;
		// TODO: Verify all return paths do proper cleanup.
		// If we return a failure, can we rely on local variables to be cleaned up in destructor?
//		if(!pSink)
//			return E_INVALIDARG;

		if(NULL == (m_bstrNamespace = SysAllocString(bstrNamespace)))
			return E_OUTOFMEMORY;

		if(NULL == (m_bstrApp = SysAllocString(bstrApp)))
			return E_OUTOFMEMORY; // m_bstrNamespace will be freed in constructor

		m_pStatusSink = pSink;
		if(m_pStatusSink)
			m_pStatusSink->AddRef();
		
		HRESULT hr;
		IUnknown *pUnk = NULL;

		if(FAILED(hr = CoCreateInstance(CLSID_WbemDecoupledRegistrar ,NULL , CLSCTX_INPROC_SERVER, IID_IWbemDecoupledRegistrar, (void**)&m_pDecoupledRegistrar)))
			return hr;

		if(FAILED(hr = QueryInterface(IID_IUnknown, (void**)&pUnk)))
			return hr;

		if(hr = m_pDecoupledRegistrar->Register(0, NULL, NULL, NULL, m_bstrNamespace, m_bstrApp, pUnk))
			return hr;


		// To use 'DecoupledBasicEventProvider'
//		if(FAILED(hr = CoCreateInstance(CLSID_WbemDecoupledBasicEventProvider ,NULL , CLSCTX_INPROC_SERVER, IID_IWbemDecoupledBasicEventProvider, (void**)&m_pDecoupledProvider)))
//		if(FAILED(hr = m_pDecoupledProvider->GetService(0, NULL, &m_pNamespace)))
//			return hr;
//		if(FAILED(hr = m_pDecoupledProvider->GetSink(0, NULL, &m_pEventSink)))
//			return hr;

		pUnk->Release();
		return hr;
	}


DECLARE_REGISTRY_RESOURCEID(IDR_EVENTSOURCE2)


BEGIN_COM_MAP(CEventSource2)
	COM_INTERFACE_ENTRY(IEventSource2)
	COM_INTERFACE_ENTRY(IWbemProviderInit)
	COM_INTERFACE_ENTRY(IWbemEventProvider)
	COM_INTERFACE_ENTRY(IWbemEventProviderQuerySink)
	COM_INTERFACE_ENTRY(IWbemEventProviderSecurity)
//	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()


	DECLARE_PROTECT_FINAL_CONSTRUCT()
	DECLARE_GET_CONTROLLING_UNKNOWN()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

protected:
//	IWbemDecoupledBasicEventProvider *m_pDecoupledProvider;
	IWbemDecoupledRegistrar *m_pDecoupledRegistrar;
	IWbemObjectSink*         m_pEventSink;
	IWbemServices*           m_pNamespace;
	BSTR m_bstrNamespace;
	BSTR m_bstrApp;

	IEventSourceStatusSink *m_pStatusSink;
public:
	STDMETHOD(Fire)(/*[in]*/ IWbemClassObject *evt)
	{
		if(NULL == m_pEventSink)
			return S_OK;

		HRESULT hr = m_pEventSink->Indicate(1, &evt);
		return hr;
	}
	STDMETHOD(Close)()
	{
		if(m_pDecoupledRegistrar)
		{
			m_pDecoupledRegistrar->UnRegister();
			m_pDecoupledRegistrar->Release();
			m_pDecoupledRegistrar = NULL;
		}
		return S_OK;
	}

	
// IWbemEventProvider
	STDMETHOD(ProvideEvents)(IWbemObjectSink * pEventSink, LONG lFlags)
	{
		if(m_pEventSink)
			m_pEventSink->Release();
		if(pEventSink)
			pEventSink->AddRef();
		m_pEventSink = pEventSink;

		if(m_pStatusSink)
		{
//			CEventSourceStatusSink *pSink = (CEventSourceStatusSink *)m_pStatusSink;
//			pSink->Fire_ProvideEvents(lFlags);
		}
		return S_OK;
	}
// IWbemEventProviderQuerySink
	STDMETHOD(NewQuery)(ULONG dwId, LPWSTR wszQueryLanguage, LPWSTR wszQuery)
	{
//		Fire_NewQuery(dwId, wszQuery, wszQueryLanguage);

		if(m_pStatusSink)
		{
//			CEventSourceStatusSink *pSink = (CEventSourceStatusSink *)m_pStatusSink;
//			pSink->Fire_NewQuery(dwId, wszQuery, wszQueryLanguage);
		}

		return S_OK;
	}
	STDMETHOD(CancelQuery)(ULONG dwId)
	{
//		Fire_CancelQuery(dwId);

		if(m_pStatusSink)
		{
//			CEventSourceStatusSink *pSink = (CEventSourceStatusSink *)m_pStatusSink;
//			pSink->Fire_CancelQuery(dwId);
		}
		return S_OK;
	}
// IWbemEventProviderSecurity
	STDMETHOD(AccessCheck)(WBEM_CWSTR wszQueryLanguage, WBEM_CWSTR wszQuery, long lSidLength, const BYTE *pSid)
	{
		return S_OK;
	}


// IWbemProviderInit
	HRESULT STDMETHODCALLTYPE Initialize(
             /* [in] */ LPWSTR pszUser,
             /* [in] */ LONG lFlags,
             /* [in] */ LPWSTR pszNamespace,
             /* [in] */ LPWSTR pszLocale,
             /* [in] */ IWbemServices *pNamespace,
             /* [in] */ IWbemContext *pCtx,
             /* [in] */ IWbemProviderInitSink *pInitSink
                        )
	{
		if(pNamespace)
	        pNamespace->AddRef();
	    m_pNamespace = pNamespace;

	    //Let CIMOM know you are initialized
	    //==================================
	    
	    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
	    return WBEM_S_NO_ERROR;
	}
};

//OBJECT_ENTRY_AUTO(__uuidof(EventSource2), CEventSource2)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wminet_utils\eventsourcestatussink.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// EventSourceStatusSink.h : Declaration of the CEventSourceStatusSink

#ifndef __EVENTSOURCESTATUSSINK_H_
#define __EVENTSOURCESTATUSSINK_H_

#include "resource.h"       // main symbols
#include "WMINetUtilsCP.h"

/////////////////////////////////////////////////////////////////////////////
// CEventSourceStatusSink
class ATL_NO_VTABLE CEventSourceStatusSink : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CEventSourceStatusSink, &CLSID_EventSourceStatusSink>,
	public IConnectionPointContainerImpl<CEventSourceStatusSink>,
	public IDispatchImpl<IEventSourceStatusSink, &IID_IEventSourceStatusSink, &LIBID_WMINet_UtilsLib>,
	public CProxy_IEventSourceStatusSinkEvents< CEventSourceStatusSink >
{
public:
	CEventSourceStatusSink()
	{
	}
	~CEventSourceStatusSink()
	{
		return;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_EVENTSOURCESTATUSSINK)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CEventSourceStatusSink)
	COM_INTERFACE_ENTRY(IEventSourceStatusSink)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()
BEGIN_CONNECTION_POINT_MAP(CEventSourceStatusSink)
CONNECTION_POINT_ENTRY(DIID__IEventSourceStatusSinkEvents)
END_CONNECTION_POINT_MAP()


// IEventSourceStatusSink
public:
	STDMETHODIMP Fire_Ping(void);
};

#endif //__EVENTSOURCESTATUSSINK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wminet_utils\eventsourcestatussink.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// EventSourceStatusSink.cpp : Implementation of CEventSourceStatusSink
#include "stdafx.h"
#include "WMINet_Utils.h"
#include "EventSourceStatusSink.h"

/////////////////////////////////////////////////////////////////////////////
// CEventSourceStatusSink


STDMETHODIMP CEventSourceStatusSink::Fire_Ping(void)
{
	CProxy_IEventSourceStatusSinkEvents< CEventSourceStatusSink >::Fire_Ping();

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wminet_utils\helpers.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#pragma once

HRESULT GetIWbemClassObject(ISWbemObject *pSWbemObj, IWbemClassObject **ppIWbemObj);

HRESULT Compile(BSTR strMof, BSTR strServerAndNamespace, BSTR strUser, BSTR strPassword, BSTR strAuthority, LONG options, LONG classflags, LONG instanceflags, BSTR *status);

HRESULT GetSWbemObjectFromMoniker(LPCWSTR wszMoniker, ISWbemObject **ppObj);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wminet_utils\mofcompiler.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// MofCompiler.cpp : Implementation of CMofCompiler
#include "stdafx.h"
#include "WMINet_Utils.h"
#include "MofCompiler.h"
#include "Helpers.h"

/////////////////////////////////////////////////////////////////////////////
// CMofCompiler

STDMETHODIMP CMofCompiler::Compile(BSTR strMof, BSTR strServerAndNamespace, BSTR strUser, BSTR strPassword, BSTR strAuthority, LONG options, LONG classflags, LONG instanceflags, BSTR *status)
{
	return ::Compile(strMof, strServerAndNamespace, strUser, strPassword, strAuthority, options, classflags, instanceflags, status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wminet_utils\helpers.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdafx.h"

#include "Helpers.h"

#pragma comment(lib, "wbemuuid.lib")


/////////////////////////////////////////////////////////////////////////////

HRESULT GetObjectFromMoniker(LPCWSTR wszMoniker, IUnknown **ppUnk)
{
	HRESULT hr;
	IBindCtx *pbindctx;
	if (FAILED(hr = CreateBindCtx(0, &pbindctx)))
		return hr;
		
	ULONG cbEaten;
	IMoniker *pmoniker;
	hr = MkParseDisplayName(pbindctx, wszMoniker, &cbEaten, &pmoniker);
	pbindctx->Release();
	if (FAILED(hr))
		return hr;

	hr = BindMoniker(pmoniker, 0, IID_IUnknown, (void **)ppUnk);
	pmoniker->Release();

	return hr;
}

HRESULT GetSWbemObjectFromMoniker(LPCWSTR wszMoniker, ISWbemObject **ppObj)
{
	IUnknown *pUnk = NULL;
	HRESULT hr = GetObjectFromMoniker(wszMoniker, &pUnk);
	if(FAILED(hr))
		return hr;

	hr = pUnk->QueryInterface(IID_ISWbemObject, (void**)ppObj);
	pUnk->Release();

	return hr;
}

/////////////////////////////////////////////////////////////////////////////

const IID IID_ISWbemObject = {0x76A6415A,0xCB41,0x11d1,{0x8B,0x02,0x00,0x60,0x08,0x06,0xD9,0xB6}};

const IID IID_ISWbemInternalObject = {0x9AF56A1A,0x37C1,0x11d2,{0x8B,0x3C,0x00,0x60,0x08,0x06,0xD9,0xB6}};

MIDL_INTERFACE("9AF56A1A-37C1-11d2-8B3C-00600806D9B6")
ISWbemInternalObject : public IUnknown
{
public:
	virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetIWbemClassObject( 
		/* [retval][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject) = 0;
	virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetSite( 
		/* [in] */ ISWbemInternalObject __RPC_FAR *pSObject,
		/* [in] */ BSTR propertyName,
		/* [in] */ long index) = 0;
	virtual /* [id] */ HRESULT STDMETHODCALLTYPE UpdateSite( void) = 0;
};

HRESULT GetIWbemClassObject(ISWbemObject *pSWbemObj, IWbemClassObject **ppIWbemObj)
{
	HRESULT hr = S_OK;
	ISWbemInternalObject *pInternal = NULL;
	__try
	{
		if(FAILED(hr = pSWbemObj->QueryInterface(IID_ISWbemInternalObject, (void**)&pInternal)))
			__leave;
		
		hr = pInternal->GetIWbemClassObject(ppIWbemObj);
	}
	__finally
	{
		if(pInternal)
			pInternal->Release();
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////////////

// szOut must be MAX_PATH
void AtoWFile(LPCSTR szIn, LPWSTR szOut)
{
	int len = lstrlenA(szIn);
	if ( len <= MAX_PATH )
	{
		_bstr_t str(szIn);
		memcpy(szOut, (LPCWSTR)str, len*sizeof(WCHAR));
		szOut[len] = 0;
	}
}

HRESULT Compile(BSTR strMof, BSTR strServerAndNamespace, BSTR strUser, BSTR strPassword, BSTR strAuthority, LONG options, LONG classflags, LONG instanceflags, BSTR *status)
{
	IMofCompiler *pCompiler = NULL;
	HANDLE hFile = INVALID_HANDLE_VALUE;
	HRESULT hr = E_FAIL;
	PBYTE pData = NULL;
	char szTempFile[MAX_PATH] = "\0";
	__try
	{
		if(FAILED(hr = CoCreateInstance(CLSID_MofCompiler, 0, CLSCTX_INPROC_SERVER, IID_IMofCompiler, (LPVOID *) &pCompiler)))
			__leave;

		char szTempDir[MAX_PATH] = "\0";
		GetTempPathA(MAX_PATH, szTempDir);
		GetTempFileNameA(szTempDir, "MOF", 0, szTempFile);

		WCHAR wszTempFile[MAX_PATH];
		AtoWFile(szTempFile, wszTempFile);

		int len = SysStringLen(strMof);
		if(NULL == (pData = new BYTE[len*sizeof(WCHAR)*2 + 2]))
		{
			hr = E_FAIL;
			__leave;
		}

		pData[0] = 0xFF;
		pData[1] = 0xFE;

		PWCHAR pwData = (PWCHAR)pData;

		int i;
		int cur = 1;
		for(i=0;i<len;i++)
		{
			if(strMof[i] == L'\r' || strMof[i] == L'\n')
			{
				pwData[cur++] = L'\r';
				pwData[cur++] = L'\n';
			}
			else
				pwData[cur++] = strMof[i];
		}

		if(INVALID_HANDLE_VALUE == (hFile = CreateFileA(szTempFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)))
		{
			hr = E_FAIL;// TODO: Should look at GetLastError();
			__leave;
		}
		DWORD dwWritten = 0;
		WriteFile(hFile, pData, cur*sizeof(WCHAR), &dwWritten, NULL);
		CloseHandle(hFile);

		if(dwWritten != cur*sizeof(WCHAR))
		{
			hr = E_FAIL;
			__leave;
		}

		WBEM_COMPILE_STATUS_INFO info;
		ZeroMemory(&info, sizeof(info));

		if(FAILED(hr = pCompiler->CompileFile(wszTempFile, strServerAndNamespace, NULL, NULL, NULL, 0, 0, 0, &info)))
			__leave;

	}
	__finally
	{
		if(pCompiler)
			pCompiler->Release();

		if(pData)
			delete [] pData;

		if(INVALID_HANDLE_VALUE != hFile)
		{
			// We will already have closed hFile, but we need to delete the file
			DeleteFileA(szTempFile);
		}
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wminet_utils\stdafx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wminet_utils\resource.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WMINet_Utils.rc
//
#define IDS_PROJNAME                    100
#define IDR_WMISECURITYHELPER           101
#define IDR_WMIOBJECTSINK               106
#define IDR_WMISINKDEMULTIPLEXOR        107
#define IDR_EVENTSOURCE                 111
#define IDR_MOFCOMPILER                 112
#define IDR_UTILS                       113
#define IDR_EVENTREGISTRAR              114
#define IDR_EVENTSOURCESTATUSSINK       115
#define IDR_EVENTSOURCE2                116
#define IDR_SCRIPTREGIT                 201


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         200
#define _APS_NEXT_SYMED_VALUE           117
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wminet_utils\mofcompiler.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// MofCompiler.h : Declaration of the CMofCompiler

#ifndef __MOFCOMPILER_H_
#define __MOFCOMPILER_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMofCompiler
class ATL_NO_VTABLE CMofCompiler : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMofCompiler, &CLSID_SMofCompiler>,
	public IDispatchImpl<ISMofCompiler, &IID_ISMofCompiler, &LIBID_WMINet_UtilsLib>
{
public:
	CMofCompiler()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_MOFCOMPILER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMofCompiler)
	COM_INTERFACE_ENTRY(ISMofCompiler)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IMofCompiler
public:
	STDMETHOD(Compile)(/*[in]*/ BSTR strMof, /*[in]*/ BSTR strServerAndNamespace, /*[in]*/ BSTR strUser, /*[in]*/ BSTR strPassword, /*[in]*/ BSTR strAuthority, /*[in]*/ LONG options, /*[in]*/ LONG classflags, /*[in]*/ LONG instanceflags, /*[out, retval]*/ BSTR *status);
};

#endif //__MOFCOMPILER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wminet_utils\stdafx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__6B36A91A_E62A_4F29_9DA2_AA35BA04E2A1__INCLUDED_)
#define AFX_STDAFX_H__6B36A91A_E62A_4F29_9DA2_AA35BA04E2A1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <comdef.h>

#include <stdio.h>

#include <wbemcli.h>
#include <wbemdisp.h>
#include <wbemprov.h>
#include <strsafe.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__6B36A91A_E62A_4F29_9DA2_AA35BA04E2A1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wminet_utils\utils.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Utils.cpp : Implementation of CUtils
#include "stdafx.h"
#include "WMINet_Utils.h"
#include "Utils.h"
#include "EventSource.h"
#include "EventRegistrar.h"

#include "Helpers.h"

/////////////////////////////////////////////////////////////////////////////
// CUtils

STDMETHODIMP CUtils::GetEventSource(BSTR strNamespace, BSTR strApp, IEventSourceStatusSink *pSink, IDispatch **src)
{
	HRESULT hr;
	IEventSource *pISrc = NULL;
	if(FAILED(hr = CEventSource::CreateInstance(&pISrc)))
		return hr;

	CEventSource *pSrc = (CEventSource *)pISrc;
	if(SUCCEEDED(hr = pSrc->Init(strNamespace, strApp, pSink)))
		pISrc->QueryInterface(IID_IDispatch, (void**)src);

	pISrc->Release();
	return hr;
}

STDMETHODIMP CUtils::GetEventRegistrar(BSTR strNamespace, BSTR strApp, IDispatch **registrar)
{
	HRESULT hr;
	IEventRegistrar *pISrc = NULL;
	if(FAILED(hr = CEventRegistrar::CreateInstance(&pISrc)))
		return hr;

	CEventRegistrar *pSrc = (CEventRegistrar *)pISrc;
	if(SUCCEEDED(hr = pSrc->Init(strNamespace, strApp)))
		pISrc->QueryInterface(IID_IDispatch, (void**)registrar);

	pISrc->Release();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wminet_utils\utils.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Utils.h : Declaration of the CUtils

#ifndef __UTILS_H_
#define __UTILS_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CUtils
class ATL_NO_VTABLE CUtils : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CUtils, &CLSID_Utils>,
	public IUtils
{
public:
	CUtils()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_UTILS)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CUtils)
	COM_INTERFACE_ENTRY(IUtils)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	DECLARE_GET_CONTROLLING_UNKNOWN()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;
// IUtils
public:
	STDMETHOD(GetEventRegistrar)(/*[in]*/ BSTR strNamespace, /*[in]*/ BSTR strApp, /*[out, retval]*/ IDispatch **registrar);
	STDMETHOD(GetEventSource)(/*[in]*/ BSTR strNamespace, /*[in]*/ BSTR strApp, /*[in]*/ IEventSourceStatusSink *pSink, /*[out, retval]*/ IDispatch **src);

	STDMETHOD(Smuggle)(/*[in]*/ IWbemClassObject *obj, /*[out]*/ DWORD *dwLow, /*[out]*/ DWORD *dwHigh)
	{
		*dwLow = (DWORD)obj;
		return S_OK;
	}
	STDMETHOD(UnSmuggle)(/*[in]*/ DWORD dwLow, /*[in]*/ DWORD dwHigh, /*[out,retval]*/ IWbemClassObject **obj)
	{
		*obj = (IWbemClassObject*)dwLow;
		return S_OK;
	}

};

#endif //__UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wmisec\dlldatax.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#if !defined(AFX_DLLDATAX_H__376FCAE7_AAA9_465A_9024_EB65C84A5235__INCLUDED_)
#define AFX_DLLDATAX_H__376FCAE7_AAA9_465A_9024_EB65C84A5235__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__376FCAE7_AAA9_465A_9024_EB65C84A5235__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wminet_utils\wmisecurityhelper.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

// WmiSecurityHelper.h : Declaration of the CWmiSecurityHelper

#ifndef __WMISECURITYHELPER_H_
#define __WMISECURITYHELPER_H_

#include "resource.h"       // main symbols

#define WMISEC_AUTH_LEVEL_UNCHANGED	0xFFFFFFFF

/////////////////////////////////////////////////////////////////////////////
// CWmiSecurityHelper
class ATL_NO_VTABLE CWmiSecurityHelper : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CWmiSecurityHelper, &CLSID_WmiSecurityHelper>,
	public IWmiSecurityHelper
{
private:
	bool		m_bIsNT;
	bool		m_bIsKerberosAvailable;
	DWORD		m_dwNTMajorVersion;

	DWORD		GetCapabilities (BSTR bsUser);

	bool		IsNT () const { return m_bIsNT; }

	DWORD		GetNTMajorVersion () const { return m_dwNTMajorVersion; } 

	bool		IsKerberosAvailable() const { return m_bIsKerberosAvailable; }

	bool		CanUseDefaultInfo (IUnknown *pUnk);

	void		GetCurrValue(
					IUnknown * pFrom,
					DWORD & dwAuthenticationArg, 
					DWORD & dwAuthorizationArg);

	void		GetAuthenticationLevel(
					IUnknown * pFrom,
					DWORD & dwAuthenticationLevel);

	HRESULT		SetInterfaceSecurity(
					IUnknown * pInterface, 
					CComBSTR bsAuthority, 
					CComBSTR bsUser, 
					CComBSTR bsPassword,
					DWORD dwAuthLevel, 
					DWORD dwImpLevel, 
					DWORD dwCapabilities,
					bool bGetInfoFirst);

	HRESULT		SetProxyBlanket(
					IUnknown                 *pInterface,
					DWORD                     dwAuthnSvc,
					DWORD                     dwAuthzSvc,
					CComBSTR                  &bsServerPrincName,
					DWORD                     dwAuthLevel,
					DWORD                     dwImpLevel,
					RPC_AUTH_IDENTITY_HANDLE  pAuthInfo,
					DWORD                     dwCapabilities);

	static void	FreeAuthIdentity( COAUTHIDENTITY* pAuthIdentity );
	bool		AllocAuthIdentity( 
					CComBSTR & bsUser, 
					CComBSTR & bsPassword, 
					CComBSTR & bsDomain, 
					COAUTHIDENTITY** ppAuthIdent );
	bool		DetermineLoginType(
					CComBSTR & bsAuthArg, 
					CComBSTR & bsUserArg,
					CComBSTR & bsPrincipalArg,
					CComBSTR & bsAuthority,
					CComBSTR & bsUser);
	bool		DetermineLoginType(
					CComBSTR & bsAuthArg, 
					CComBSTR & bsUserArg,
					CComBSTR & bsAuthority,
					CComBSTR & bsUser);
	static bool DoesContainCredentials( COAUTHIDENTITY* pAuthIdentity );
	static bool DuplicateToken (HANDLE hOrigToken, HANDLE & hDupToken,
					SECURITY_IMPERSONATION_LEVEL &secImpLevel);
	static TOKEN_PRIVILEGES *AdjustPrivileges (HANDLE hToken);

public:
	CWmiSecurityHelper()
	{
		m_pUnkMarshaler = NULL;

		OSVERSIONINFO	osVersionInfo;
		osVersionInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
		GetVersionEx (&osVersionInfo);

		m_bIsNT = (VER_PLATFORM_WIN32_NT == osVersionInfo.dwPlatformId);
		m_dwNTMajorVersion = osVersionInfo.dwMajorVersion;
		// IMPORTANT!! This will need to be chanted if Kerberos is ever ported to 98
		m_bIsKerberosAvailable = m_bIsNT && (m_dwNTMajorVersion >= 5) ;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_WMISECURITYHELPER)
DECLARE_NOT_AGGREGATABLE(CWmiSecurityHelper)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CWmiSecurityHelper)
	COM_INTERFACE_ENTRY(IWmiSecurityHelper)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

// IWmiSecurityHelper
public:
	STDMETHOD(ResetSecurity)(/*[in]*/ HANDLE hToken);
	STDMETHOD(SetSecurity)(/*[out]*/ boolean *pNeedToReset, /*[out]*/HANDLE *pHandle);
	STDMETHOD(BlessIWbemServices)(/*[in]*/IWbemServices *pIWbemServices, 
		 /*[in]*/ BSTR strUser, /*[in]*/ BSTR strPassword,
		/*[in]*/ BSTR strAuthority, /*[in]*/ DWORD impersonationLevel, /*[in]*/ DWORD authenticationLevel);
	STDMETHOD(BlessIEnumWbemClassObject)(/*[in]*/ IEnumWbemClassObject *pIEnumWbemClassObject, 
		 /*[in]*/ BSTR strUser, /*[in]*/ BSTR strPassword,
		/*[in]*/ BSTR strAuthority, /*[in]*/ DWORD impersonationLevel, /*[in]*/ DWORD authenticationLevel);
	STDMETHOD(BlessIWbemCallResult)(/*[in]*/ IWbemCallResult *pIWbemCallResult, 
		 /*[in]*/ BSTR strUser, /*[in]*/ BSTR strPassword,
		/*[in]*/ BSTR strAuthority, /*[in]*/ DWORD impersonationLevel, /*[in]*/ DWORD authenticationLevel);

private:
	HRESULT SetImpersonate (IUnknown *pIUnknown);
};

#endif //__WMISECURITYHELPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wminet_utils\wmisinkdemultiplexor.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// WmiSinkDemultiplexor.cpp : Implementation of CWmiSinkDemultiplexor
#include "stdafx.h"
#include "wbemcli.h"
#include "WMINet_Utils.h"
#include "WmiSinkDemultiplexor.h"

/////////////////////////////////////////////////////////////////////////////
// CWmiSinkDemultiplexor


STDMETHODIMP CWmiSinkDemultiplexor::GetDemultiplexedStub(IUnknown *pObject, IUnknown **ppObject)
{
	HRESULT hr = E_FAIL;
	
	// TODO - thread safety!

	// Only call this once!
#if 0
	if (pObject && ppObject && !m_pIWbemObjectSink)
#else
	if (pObject && ppObject)
#endif
	{
		// Try and QI for the IWmiEventSource interface
		CComPtr<IWmiEventSource> pIWmiEventSource;

		if (SUCCEEDED(pObject->QueryInterface(IID_IWmiEventSource, (LPVOID*) &pIWmiEventSource)))
		{
			// We got it - make a new object sink for it
#if 0
			m_pIWbemObjectSink = new InternalWbemObjectSink (pIWmiEventSource);

			if (m_pIWbemObjectSink)
			{
				m_pIWbemObjectSink->AddRef();

				// Lazily construct the unsecured apartment
				CComPtr<IUnsecuredApartment> pIUnsecuredApartment;

				if (SUCCEEDED(CoCreateInstance(CLSID_UnsecuredApartment, 0,  CLSCTX_ALL,
									 IID_IUnsecuredApartment, (LPVOID *) &pIUnsecuredApartment)))
				{
					CComPtr<IUnknown>	pIUnknownIn;

					if (SUCCEEDED(m_pIWbemObjectSink->QueryInterface (IID_IUnknown, (LPVOID*) &pIUnknownIn)))
					{
						CComPtr<IUnknown>	pIUnknown;

						if (SUCCEEDED (hr = pIUnsecuredApartment->CreateObjectStub(pIUnknownIn, &pIUnknown)))
						{
							// Ensure we QI for IWbemObjectSink
							hr = pIUnknown->QueryInterface (IID_IWbemObjectSink, (LPVOID*) ppObject);
						}
					}
				}
			}
#else
			InternalWbemObjectSink *pInternalWbemObjectSink = new InternalWbemObjectSink (pIWmiEventSource);

			if (pInternalWbemObjectSink)
			{
				CComPtr<IUnknown>		pIUnknownIn;

				if (SUCCEEDED(pInternalWbemObjectSink->QueryInterface (IID_IUnknown, (LPVOID*) &pIUnknownIn)))
				{
					CComPtr<IUnsecuredApartment> pIUnsecuredApartment;

					if (SUCCEEDED(CoCreateInstance(CLSID_UnsecuredApartment, 0,  CLSCTX_ALL,
										 IID_IUnsecuredApartment, (LPVOID *) &pIUnsecuredApartment)))
					{
						CComPtr<IUnknown>	pIUnknownOut;

						if (SUCCEEDED (hr = pIUnsecuredApartment->CreateObjectStub(pIUnknownIn, &pIUnknownOut)))
						{
							// Ensure we QI for IWbemObjectSink
							hr = pIUnknownOut->QueryInterface (IID_IWbemObjectSink, (LPVOID*) ppObject);
						}
					}
				}
			}
#endif
				
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wminet_utils\wmisinkdemultiplexor.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

// WmiSinkDemultiplexor.h : Declaration of the CWmiSinkDemultiplexor

#ifndef __WMISINKDEMULTIPLEXOR_H_
#define __WMISINKDEMULTIPLEXOR_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CWmiSinkDemultiplexor
class ATL_NO_VTABLE CWmiSinkDemultiplexor : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CWmiSinkDemultiplexor, &CLSID_WmiSinkDemultiplexor>,
	public IWmiSinkDemultiplexor
{
private:

	/*
	 * The internal IWbemObjectSink implementation we use to
	 * confer with WMI.
	 */
	class InternalWbemObjectSink : IWbemObjectSink 
	{
	private:
		CComPtr<IWmiEventSource>		m_pIWmiEventSource; 

	protected:
		long            m_cRef;         //Object reference count

	public:
		InternalWbemObjectSink (CComPtr<IWmiEventSource> & pIWmiEventSource) :
						m_cRef(0),
						m_pIWmiEventSource(pIWmiEventSource) {}

		~InternalWbemObjectSink () {}

		//Non-delegating object IUnknown
		STDMETHODIMP         QueryInterface(REFIID riid, LPVOID *ppv)
		{
			*ppv=NULL;

			if (IID_IUnknown==riid)
				*ppv = reinterpret_cast<IUnknown*>(this);
			else if (IID_IWbemObjectSink==riid)
				*ppv = (IWbemObjectSink *)this;
			else if (IID_IDispatch==riid)
				*ppv = (IDispatch *)this;

			if (NULL!=*ppv)
			{
				((LPUNKNOWN)*ppv)->AddRef();
				return NOERROR;
			}

			return ResultFromScode(E_NOINTERFACE);
		}

		STDMETHODIMP_(ULONG) AddRef(void)
		{
		    InterlockedIncrement(&m_cRef);
		    return m_cRef;
		}

		STDMETHODIMP_(ULONG) Release(void)
		{
		    long lRef = InterlockedDecrement(&m_cRef);
			
			if (0L!=lRef)
				return lRef;

			delete this;
			return 0;

		}

		// IWbemObjectSink methods

        HRESULT STDMETHODCALLTYPE Indicate( 
            /* [in] */ long lObjectCount,
            /* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjArray)
		{
			HRESULT hr = WBEM_E_FAILED;

			if (m_pIWmiEventSource)
			{
				hr = S_OK; 

				for (long i = 0; (i < lObjectCount) && SUCCEEDED(hr); i++)
					hr = m_pIWmiEventSource->Indicate (apObjArray[i]);
			}

			return hr;
		}
        
        HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject __RPC_FAR *pObjParam)
		{
			HRESULT hr = WBEM_E_FAILED;

			return (m_pIWmiEventSource) ?
				m_pIWmiEventSource->SetStatus (lFlags, hResult, strParam, pObjParam) : WBEM_E_FAILED;
		}
	};

#if 0
	InternalWbemObjectSink		*m_pIWbemObjectSink;
#endif
	CComPtr<IWbemObjectSink>	m_pStub;

public:
	CWmiSinkDemultiplexor()
	{
		m_pUnkMarshaler = NULL;
#if 0
		m_pIWbemObjectSink = NULL;
#endif
	}

DECLARE_REGISTRY_RESOURCEID(IDR_WMISINKDEMULTIPLEXOR)
DECLARE_NOT_AGGREGATABLE(CWmiSinkDemultiplexor)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CWmiSinkDemultiplexor)
	COM_INTERFACE_ENTRY(IWmiSinkDemultiplexor)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();

#if 0
		if (m_pIWbemObjectSink)
		{
			m_pIWbemObjectSink->Release ();
			m_pIWbemObjectSink = NULL;
		}
#endif
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

// IWmiSinkDemultiplexor
public:
	STDMETHOD(GetDemultiplexedStub)(/*[in]*/ IUnknown *pObject, /*[out]*/ IUnknown **ppObject);
};

#endif //__WMISINKDEMULTIPLEXOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wmisec\stdafx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wminet_utils\wminetutilscp.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _WMINETUTILSCP_H_
#define _WMINETUTILSCP_H_

template <class T>
class CProxy_IEventSourceEvents : public IConnectionPointImpl<T, &DIID__IEventSourceEvents, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	HRESULT Fire_NewQuery(ULONG dwId, LPWSTR strQuery, LPWSTR strQueryLanguage)
	{
		CComVariant avars[3];
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
        HRESULT hr = E_FAIL;
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				VARIANT vTemp;
				vTemp.vt = VT_UI4;
				vTemp.uintVal = dwId;

				avars[2] = vTemp;
				avars[1] = strQuery;
				avars[0] = strQueryLanguage;
				DISPPARAMS disp = { avars, NULL, 3, 0 };
				hr = pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		return SUCCEEDED(hr) ? varResult.scode : hr;
	
	}

	HRESULT Fire_CancelQuery(ULONG dwId)
	{
		CComVariant var;
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
        HRESULT hr = E_FAIL;
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				var.vt = VT_UI4;
				var.uintVal = dwId;
				DISPPARAMS disp = { &var, NULL, 1, 0 };
				hr = pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		return SUCCEEDED(hr) ? varResult.scode : hr;
	}
};



template <class T>
class CProxy_IEventSourceStatusSinkEvents : public IConnectionPointImpl<T, &DIID__IEventSourceStatusSinkEvents, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	HRESULT Fire_NewQuery(ULONG dwId, LPWSTR strQuery, LPWSTR strQueryLanguage)
	{
		CComVariant avar[3];
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
        HRESULT hr = E_FAIL;
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				VARIANT vTemp;
				vTemp.vt = VT_UI4;
				vTemp.uintVal = dwId;

				avar[2] = vTemp;
				avar[1] = strQuery;
				avar[0] = strQueryLanguage;
				DISPPARAMS disp = { avar, NULL, 3, 0 };
				hr = pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		return SUCCEEDED(hr) ? varResult.scode : hr;
	}

	HRESULT Fire_CancelQuery(ULONG dwId)
	{
		CComVariant var;
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
        HRESULT hr = E_FAIL;
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				VARIANT vTemp;
				var.vt = VT_UI4;
				var.uintVal = dwId;
				DISPPARAMS disp = { &var, NULL, 1, 0 };
				hr = pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		return SUCCEEDED(hr) ? varResult.scode : hr;
	}

	HRESULT Fire_ProvideEvents(LONG lFlags)
	{
		CComVariant var;
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
        HRESULT hr = E_FAIL;

		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
                var = lFlags;
				DISPPARAMS disp = { &var, NULL, 1, 0 };
				hr = pDispatch->Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		return SUCCEEDED(hr) ? varResult.scode : hr;
	}

	HRESULT Fire_Ping()
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
        HRESULT hr = E_FAIL;
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				hr = pDispatch->Invoke(0x4, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		return SUCCEEDED(hr) ? varResult.scode : hr;
	}
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wminet_utils\wmisecurityhelper.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// WmiSecurityHelper.cpp : Implementation of CWmiSecurityHelper
#include "stdafx.h"
#include "wbemcli.h"
#include "WMINet_Utils.h"
#include "WmiSecurityHelper.h"

#ifndef RPC_C_AUTHZ_DEFAULT
#define RPC_C_AUTHZ_DEFAULT 0xffffffff
#endif 

#ifndef EOAC_STATIC_CLOAKING
#define EOAC_STATIC_CLOAKING	0x20
#endif

#ifndef EOAC_DYNAMIC_CLOAKING
#define EOAC_DYNAMIC_CLOAKING	0x40
#endif 

#ifndef COLE_DEFAULT_AUTHINFO
#define	COLE_DEFAULT_AUTHINFO	( ( void * )-1 )
#endif 


/////////////////////////////////////////////////////////////////////////////
// CWmiSecurityHelper

STDMETHODIMP CWmiSecurityHelper::BlessIWbemServices(
	IWbemServices *pIWbemServices,
	BSTR strUser, 
	BSTR strPassword, 
	BSTR strAuthority, 
	DWORD impLevel, 
	DWORD authnLevel)
{
	HRESULT hr = E_FAIL;

	if (pIWbemServices)
	{
		// See if we get one
		CComBSTR bsUser (strUser);
		CComBSTR bsPassword (strPassword);
		CComBSTR bsAuthority (strAuthority);
	
		hr = SetInterfaceSecurity (pIWbemServices, bsAuthority, bsUser, bsPassword,
				authnLevel, impLevel, GetCapabilities (bsUser),
				CanUseDefaultInfo (pIWbemServices));
	}

	return hr;
}

STDMETHODIMP CWmiSecurityHelper::BlessIEnumWbemClassObject(
	IEnumWbemClassObject *pIEnumWbemClassObject, 
	BSTR strUser, 
	BSTR strPassword, 
	BSTR strAuthority, 
	DWORD impLevel, 
	DWORD authnLevel)
{
	HRESULT hr = E_FAIL;

	if (pIEnumWbemClassObject)
	{
		// See if we get one
		CComBSTR bsUser (strUser);
		CComBSTR bsPassword (strPassword);
		CComBSTR bsAuthority (strAuthority);
	
		hr = SetInterfaceSecurity (pIEnumWbemClassObject, bsAuthority, bsUser, bsPassword,
				authnLevel, impLevel, GetCapabilities (bsUser),
				CanUseDefaultInfo (pIEnumWbemClassObject));
	}

	return hr;
}


STDMETHODIMP CWmiSecurityHelper::BlessIWbemCallResult(
	IWbemCallResult *pIWbemCallResult, 
	BSTR strUser, 
	BSTR strPassword, 
	BSTR strAuthority, 
	DWORD impLevel, 
	DWORD authnLevel)
{
	HRESULT hr = E_FAIL;

	if (pIWbemCallResult)
	{
		// See if we get one
		CComBSTR bsUser (strUser);
		CComBSTR bsPassword (strPassword);
		CComBSTR bsAuthority (strAuthority);
	
		hr = SetInterfaceSecurity (pIWbemCallResult, bsAuthority, bsUser, bsPassword,
				authnLevel, impLevel, GetCapabilities (bsUser),
				CanUseDefaultInfo (pIWbemCallResult));
	}

	return hr;
}

DWORD CWmiSecurityHelper::GetCapabilities (BSTR bsUser)
{
	DWORD dwCapabilities = EOAC_NONE;
	bool bUsingExplicitUserName = (bsUser && (0 < wcslen(bsUser)));
	
	if (IsNT () && (4 < GetNTMajorVersion ()) && !bUsingExplicitUserName)
		dwCapabilities |= EOAC_STATIC_CLOAKING;

	return dwCapabilities ;
}


bool CWmiSecurityHelper::CanUseDefaultInfo (IUnknown *pUnk)
{
	bool result = false; 

	if (IsNT() && (4 < GetNTMajorVersion ()))
	{
		HANDLE hToken = NULL;

		if (OpenThreadToken (GetCurrentThread (), TOKEN_QUERY, true, &hToken))
		{
			// Certainly a candidate to use default settings for
			// authorization and authentication service on the blanket.
			// Check if we are delegating.

			DWORD dwBytesReturned = 0;
			SECURITY_IMPERSONATION_LEVEL impLevel;

			if (GetTokenInformation(hToken, TokenImpersonationLevel, &impLevel,
							sizeof(SECURITY_IMPERSONATION_LEVEL), &dwBytesReturned) &&
									(SecurityDelegation == impLevel))
			{
				// Looks promising - now check for whether we are using kerberos
				
				if (pUnk)
				{
					CComQIPtr<IClientSecurity> pIClientSecurity(pUnk);
				
					if (pIClientSecurity)
					{
						DWORD dwAuthnSvc, dwAuthzSvc, dwImp, dwAuth, dwCapabilities;

						if (SUCCEEDED (pIClientSecurity->QueryBlanket(pUnk, &dwAuthnSvc, &dwAuthzSvc, 
												NULL,
												&dwAuth, &dwImp,
												NULL, &dwCapabilities)))
						{
							if (RPC_C_AUTHN_WINNT != dwAuthnSvc) 
								result = true;
						}
					}
				}
			}

			CloseHandle (hToken);
		}
	}

	return result;
}

HRESULT CWmiSecurityHelper::SetInterfaceSecurity(
			IUnknown * pInterface, 
			CComBSTR bsAuthority, 
			CComBSTR bsUser, 
			CComBSTR bsPassword,
            DWORD dwAuthLevel, 
			DWORD dwImpLevel, 
			DWORD dwCapabilities,
			bool bGetInfoFirst)
{
    
    HRESULT hr = E_FAIL;
    DWORD dwAuthenticationArg = RPC_C_AUTHN_WINNT;
    DWORD dwAuthorizationArg = RPC_C_AUTHZ_NONE;
	
#if 0
    if(!IsDcomEnabled())        // For the anon pipes clients, dont even bother
        return S_OK;
#endif

    //if(bGetInfoFirst)
        GetCurrValue(pInterface, dwAuthenticationArg, dwAuthorizationArg);

    // If we are doing trivial case, just pass in a null authenication structure which is used
    // if the current logged in user's credentials are OK.

    if((0 == bsAuthority.Length()) && 
        (0 == bsUser.Length()) && 
        (0 == bsPassword.Length()))
    {
		CComBSTR bsDummy;

		hr = SetProxyBlanket(pInterface, dwAuthenticationArg, dwAuthorizationArg, bsDummy,
            dwAuthLevel, dwImpLevel, 
            NULL,
            dwCapabilities);
    }
	else
	{
		// If user, or Authority was passed in, the we need to create an authority argument for the login
		CComBSTR bsAuthArg, bsUserArg, bsPrincipalArg;
    
		if (DetermineLoginType(bsAuthArg, bsUserArg, bsPrincipalArg, bsAuthority, bsUser))
		{
			COAUTHIDENTITY*  pAuthIdent = NULL;
    
			// We will only need this structure if we are not cloaking and we want at least
			// connect level authorization
			bool okToProceed = true;

			if ( !( dwCapabilities & (EOAC_STATIC_CLOAKING | EOAC_DYNAMIC_CLOAKING) )
				&& ((dwAuthLevel >= RPC_C_AUTHN_LEVEL_CONNECT) ||
				    (dwAuthLevel == RPC_C_AUTHN_LEVEL_DEFAULT))   )
			{
				okToProceed = AllocAuthIdentity( bsUserArg, bsPassword, bsAuthArg, &pAuthIdent );
			}

			if (okToProceed)
			{
				hr = SetProxyBlanket(pInterface, 
					//(0 == bsPrincipalArg.Length()) ? 16 : dwAuthenticationArg, 
					dwAuthenticationArg, 
					dwAuthorizationArg, 
					bsPrincipalArg,
					dwAuthLevel, dwImpLevel, 
					pAuthIdent,
					dwCapabilities);
			}

			if (pAuthIdent)
				FreeAuthIdentity( pAuthIdent );
		}
	}

	return hr;
}

bool CWmiSecurityHelper::DetermineLoginType(
			CComBSTR & bsAuthArg, 
			CComBSTR & bsUserArg,
			CComBSTR & bsPrincipalArg,
            CComBSTR & bsAuthority,
			CComBSTR & bsUser)
{
    bool result = false;

    if((0 == bsAuthority.Length()) || (0 != _wcsnicmp(bsAuthority, L"KERBEROS:",9)))
        result = DetermineLoginType(bsAuthArg, bsUserArg, bsAuthority, bsUser);
	else
	{
		if(IsKerberosAvailable ())
		{
			bsPrincipalArg = (bsAuthority.m_str) + 9;
			CComBSTR bsTempArg;
			result = DetermineLoginType(bsAuthArg, bsUserArg, bsTempArg, bsUser);
		}
	}

	return result;
}

bool CWmiSecurityHelper::DetermineLoginType(
		CComBSTR & bsAuthArg, 
		CComBSTR & bsUserArg,
		CComBSTR & bsAuthority,
		CComBSTR & bsUser)
{
    // Determine the connection type by examining the Authority string
	bool result = false;

    if(0 == bsAuthority.Length() || (0 == _wcsnicmp(bsAuthority, L"NTLMDOMAIN:",11)))
	{    
		result = true;

		// The ntlm case is more complex.  There are four cases
		// 1)  Authority = NTLMDOMAIN:name" and User = "User"
		// 2)  Authority = NULL and User = "User"
		// 3)  Authority = "NTLMDOMAIN:" User = "domain\user"
		// 4)  Authority = NULL and User = "domain\user"

		// first step is to determine if there is a backslash in the user name somewhere between the
		// second and second to last character

		WCHAR * pSlashInUser = NULL;
		DWORD iDomLen = 0;

		if (0 < bsUser.Length ())
		{
			WCHAR * pEnd = bsUser + bsUser.Length() - 1;
			for(pSlashInUser = bsUser; pSlashInUser <= pEnd; pSlashInUser++)
			{
				if(*pSlashInUser == L'\\')      // dont think forward slash is allowed!
					break;

				iDomLen++;
			}

			if(pSlashInUser > pEnd)
				pSlashInUser = NULL;
		}

		if (11 < bsAuthority.Length()) 
		{
			if(!pSlashInUser)
			{
				bsAuthArg = bsAuthority.m_str + 11;

				if (0 < bsUser.Length()) 
					bsUserArg = bsUser;

			}
			else
				result = false;		// Can't have domain in Authority and in User
		}
		else if(pSlashInUser)
		{
			WCHAR cTemp[MAX_PATH];
			if ( iDomLen < MAX_PATH )
			{
				wcsncpy(cTemp, bsUser, MAX_PATH);
				cTemp[iDomLen] = 0;
			}
			else
			{
				return false ;
			}

			bsAuthArg = cTemp;

			if(0 < wcslen(pSlashInUser+1))
				bsUserArg = pSlashInUser+1;
		}
		else
		{
			if (0 < bsUser.Length()) 
				bsUserArg = bsUser;
		}
	}

    return result;
}

void CWmiSecurityHelper::FreeAuthIdentity( COAUTHIDENTITY* pAuthIdentity )
{
    // Make sure we have a pointer, then walk the structure members and
    // cleanup.

    if ( NULL != pAuthIdentity )
    {

		if (pAuthIdentity->User)
            CoTaskMemFree( pAuthIdentity->User );
        
        if (pAuthIdentity->Password)
            CoTaskMemFree( pAuthIdentity->Password );
        
        if (pAuthIdentity->Domain)
            CoTaskMemFree( pAuthIdentity->Domain );
        
        CoTaskMemFree( pAuthIdentity );
	}
}

bool CWmiSecurityHelper::AllocAuthIdentity( 
	CComBSTR & bsUser, 
	CComBSTR & bsPassword, 
	CComBSTR & bsDomain, 
	COAUTHIDENTITY** ppAuthIdent )
{
	bool result = false;

    if (ppAuthIdent)
    {
		// Handle an allocation failure
		COAUTHIDENTITY*  pAuthIdent = (COAUTHIDENTITY*) CoTaskMemAlloc( sizeof(COAUTHIDENTITY) );

		if (pAuthIdent)
		{
			result = true;
			memset((void *)pAuthIdent,0,sizeof(COAUTHIDENTITY));

			if(IsNT())
			{
				pAuthIdent->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
	
				if (bsUser.m_str)
				{
					pAuthIdent->User = (LPWSTR) CoTaskMemAlloc( ( bsUser.Length() + 1 ) * sizeof( WCHAR ) );
					pAuthIdent->UserLength = bsUser.Length ();

					if (pAuthIdent->User)
					{
						// BANNED FUNCTION REPLACEMENT
                        StringCchCopyW ( pAuthIdent->User, pAuthIdent->UserLength+1, bsUser.m_str ) ;
						//wcscpy (pAuthIdent->User, bsUser.m_str);
					}
					else
						result = false;
				}

				if (result && bsDomain.m_str)
				{
					pAuthIdent->Domain = (LPWSTR) CoTaskMemAlloc( ( bsDomain.Length() + 1 ) * sizeof( WCHAR ) );
					pAuthIdent->DomainLength = bsDomain.Length();

					if (pAuthIdent->Domain)
					{
						// BANNED FUNCTION REPLACEMENT
						StringCchCopyW ( pAuthIdent->Domain, pAuthIdent->DomainLength+1, bsDomain.m_str ) ;
						//wcscpy (pAuthIdent->Domain, bsDomain.m_str);
					}
					else
						result = false;
				}

				if (result && bsPassword.m_str)
				{
					pAuthIdent->Password = (LPWSTR) CoTaskMemAlloc( (bsPassword.Length() + 1) * sizeof( WCHAR ) );
					pAuthIdent->PasswordLength = bsPassword.Length();
					
					if (pAuthIdent->Password)
					{
						// BANNED FUNCTION REPLACEMENT
						StringCchCopyW ( pAuthIdent->Password, pAuthIdent->PasswordLength+1, bsPassword.m_str ) ;
						//wcscpy (pAuthIdent->Password, bsPassword.m_str);
					}
					else
						result = false;
				}
			}
			else
			{
				pAuthIdent->Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
				size_t  nBufferLength;

				if (bsUser.m_str)
				{
					nBufferLength = wcstombs( NULL, bsUser, 0 ) + 1;
					pAuthIdent->User = (LPWSTR) CoTaskMemAlloc( nBufferLength );
					pAuthIdent->UserLength = bsUser.Length ();
					
					if (pAuthIdent->User)
						wcstombs( (LPSTR) pAuthIdent->User, bsUser.m_str, nBufferLength );
					else
						result = false;
				}

				if (result && bsDomain.m_str)
				{
					nBufferLength = wcstombs( NULL, bsDomain, 0 ) + 1;
					pAuthIdent->Domain = (LPWSTR) CoTaskMemAlloc( nBufferLength );
					pAuthIdent->DomainLength = bsDomain.Length();

					if (pAuthIdent->Domain)
						wcstombs( (LPSTR) pAuthIdent->Domain, bsDomain.m_str, nBufferLength );
					else
						result = false;
				}

				if (bsPassword.m_str)
				{
					// How many characters do we need?
					nBufferLength = wcstombs( NULL, bsPassword, 0 ) + 1;
					pAuthIdent->Password = (LPWSTR) CoTaskMemAlloc( nBufferLength );
					pAuthIdent->PasswordLength = bsPassword.Length();

					if (pAuthIdent->Password)
						wcstombs( (LPSTR) pAuthIdent->Password, bsPassword.m_str, nBufferLength );
					else
						result = false;
				}
			}

			if (result)
				*ppAuthIdent = pAuthIdent;
			else
				FreeAuthIdentity (pAuthIdent);
		}
	}

    return result;
}

HRESULT CWmiSecurityHelper::SetProxyBlanket(
    IUnknown                 *pInterface,
    DWORD                     dwAuthnSvc,
    DWORD                     dwAuthzSvc,
    CComBSTR                  &bsServerPrincName,
    DWORD                     dwAuthLevel,
    DWORD                     dwImpLevel,
    RPC_AUTH_IDENTITY_HANDLE  pAuthInfo,
    DWORD                     dwCapabilities)
{
	HRESULT hr = E_FAIL;
	IUnknown * pUnk = NULL;

	if (SUCCEEDED(pInterface->QueryInterface(IID_IUnknown, (void **) &pUnk)))
	{
		CComQIPtr<IClientSecurity> pIClientSecurity(pInterface);
    
		if (pIClientSecurity)
		{
			/*
			 * Can't set pAuthInfo if cloaking requested, as cloaking implies
			 * that the current proxy identity in the impersonated thread (rather
			 * than the credentials supplied explicitly by the RPC_AUTH_IDENTITY_HANDLE)
			 * is to be used.
			 * See MSDN info on CoSetProxyBlanket for more details.
			 */
			if (dwCapabilities & (EOAC_STATIC_CLOAKING | EOAC_DYNAMIC_CLOAKING))
			{
				pAuthInfo = NULL;
			}

			if (WMISEC_AUTH_LEVEL_UNCHANGED == dwAuthLevel)
			{
				GetAuthenticationLevel (pInterface, dwAuthLevel);
			}

			if (SUCCEEDED(hr = pIClientSecurity->SetBlanket(
							pInterface, 
							dwAuthnSvc, 
							dwAuthzSvc, 
							bsServerPrincName,
							dwAuthLevel, 
							dwImpLevel, 
							pAuthInfo, 
							dwCapabilities)))
			{
				// If we are not explicitly told to ignore the IUnknown, then we should
				// check the auth identity structure.  This performs a heuristic which
				// assumes a COAUTHIDENTITY structure.  If the structure is not one, we're
				// wrapped with a try/catch in case we AV (this should be benign since
				// we're not writing to memory).

				if ( DoesContainCredentials( (COAUTHIDENTITY*) pAuthInfo ) )
				{
					CComPtr<IClientSecurity>	pIClientSecurity2;

					if (SUCCEEDED(hr = pUnk->QueryInterface(IID_IClientSecurity, (void **) &pIClientSecurity2)))
					{
						hr = pIClientSecurity2->SetBlanket(
							pUnk, 
							dwAuthnSvc, 
							dwAuthzSvc, 
							bsServerPrincName,
							dwAuthLevel, 
							dwImpLevel, 
							pAuthInfo, 
							dwCapabilities);
					}
					else if (hr == 0x80004002)
						hr = S_OK;
				}
			}
		}

	    pUnk->Release();
	}

    return hr;
}

bool CWmiSecurityHelper::DoesContainCredentials( COAUTHIDENTITY* pAuthIdentity )
{
    try
    {
        if ( NULL != pAuthIdentity && COLE_DEFAULT_AUTHINFO != pAuthIdentity)
        {
            return ( pAuthIdentity->UserLength != 0 || pAuthIdentity->PasswordLength != 0 );
        }

        return false;
    }
    catch(...)
    {
        return false;
    }

}

void CWmiSecurityHelper::GetCurrValue(
		IUnknown * pInterface,
		DWORD & dwAuthenticationArg, 
		DWORD & dwAuthorizationArg)
{
	if(pInterface)
	{
		if (IsNT() && (4 < GetNTMajorVersion ()))
		{
			// Win2k or later we just use the DEFAULT constants - much safer!
			dwAuthenticationArg = RPC_C_AUTHN_DEFAULT;
			dwAuthorizationArg = RPC_C_AUTHZ_DEFAULT;
		}
		else
		{
			CComQIPtr<IClientSecurity> pIClientSecurity (pInterface);

			if(pIClientSecurity)
			{
				DWORD dwAuthnSvc, dwAuthzSvc;

				if (SUCCEEDED(pIClientSecurity->QueryBlanket(
									pInterface, &dwAuthnSvc, &dwAuthzSvc, 
									NULL, NULL, NULL, NULL, NULL)))
				{
					dwAuthenticationArg = dwAuthnSvc;
					dwAuthorizationArg = dwAuthzSvc;
				}
			}
		}
	}
}

void CWmiSecurityHelper::GetAuthenticationLevel(
		IUnknown * pInterface,
		DWORD & dwAuthLevel)
{
	if(pInterface)
	{
		CComQIPtr<IClientSecurity> pIClientSecurity (pInterface);

		if(pIClientSecurity)
		{
			/*
			 * Yes I know we shouldn't need to ask for dwAuthnSvc,
			 * but on Whistler passing a NULL for this into 
			 * QueryBlanket causes an AV. Until we know why, or that
			 * gets fixed, this has to stay!
			 */
			DWORD dwAuthnSvc;
			DWORD dwAuthenticationLevel;

			if (SUCCEEDED(pIClientSecurity->QueryBlanket(
								pInterface, &dwAuthnSvc, NULL,  
								NULL, &dwAuthenticationLevel, 
								NULL, NULL, NULL)))
				dwAuthLevel = dwAuthenticationLevel;
		}
	}
}

STDMETHODIMP CWmiSecurityHelper::SetSecurity(boolean *pNeedToReset, HANDLE *pCurrentThreadToken)
{
	TOKEN_PRIVILEGES *tp = NULL;
	HRESULT hr = E_FAIL;

	if ((NULL != pNeedToReset) && (NULL != pCurrentThreadToken))
	{
		*pNeedToReset = false;
		*pCurrentThreadToken = NULL;

		// This is a NO-OP for Win9x
		if (IsNT())
		{
			if (4 >= GetNTMajorVersion ())
			{
				HANDLE threadToken;

				if (OpenThreadToken (GetCurrentThread(), TOKEN_QUERY|TOKEN_IMPERSONATE,
										true, &threadToken))
				{
					/*
					 * We are being called on an impersonated thread. Unfortunately
					 * in NT4.0 this means our impersonation token credentials will NOT
					 * be passed to WMI (only the process token credentials will be passed). 
					 * Rather than fool the user into thinking that they will, bail out
					 * now.
					 */
					CloseHandle (threadToken);
				}

				/*
				 * For NT 4.0 we have to enable the privileges on the process token.
				 */
				HANDLE hProcessToken = NULL;
				HANDLE hProcess = GetCurrentProcess ();

				if (OpenProcessToken (
						hProcess, 
						TOKEN_QUERY|TOKEN_ADJUST_PRIVILEGES,
						&hProcessToken))
				{

					tp = AdjustPrivileges (hProcessToken);
					if (tp != NULL)
					{
						if (AdjustTokenPrivileges (hProcessToken, FALSE, tp, 0, NULL, NULL))
						{
							hr = S_OK;
						}
					}
					delete tp;
					CloseHandle (hProcessToken);
				}

				CloseHandle (hProcess);
			}
			else
			{
				// For NT5.0 or later we set a new thread token
				HANDLE hToken;
				SECURITY_IMPERSONATION_LEVEL secImpLevel = SecurityImpersonation;
				boolean gotToken = false;

				if (gotToken = OpenThreadToken (
									GetCurrentThread(), 
									TOKEN_QUERY|TOKEN_DUPLICATE|TOKEN_IMPERSONATE,
									true,
									&hToken))
				{
					// Already have a thread token - save it and get its' imp Level
					*pCurrentThreadToken = hToken;
					DWORD dwReturnLength = 0;

					BOOL thisRes = GetTokenInformation (
											hToken,
											TokenImpersonationLevel, 
											&secImpLevel,
											sizeof(SECURITY_IMPERSONATION_LEVEL),
											&dwReturnLength);
					if ( !thisRes )
					{
						CloseHandle ( hToken ) ;
						gotToken = false ;
					}
				}
				else
				{
					// No thread token - use process token as our source token
					HANDLE hProcess = GetCurrentProcess ();
					gotToken = OpenProcessToken (hProcess, TOKEN_QUERY|TOKEN_DUPLICATE, &hToken);
				}

				if (gotToken)
				{
					/* 
					 * Getting here means we have a valid token (process or thread).
					 * First we check whether we need to alter the privileges
					 */

					if (NULL != (tp = AdjustPrivileges(hToken)))
					{
						/* 
						 * We do - duplicate it before setting the adjusted privileges.
						 */
						HANDLE hDupToken;

						if (DuplicateToken (hToken, hDupToken, secImpLevel))
						{
							if (AdjustTokenPrivileges(hDupToken, FALSE, tp, 0, NULL, NULL))
							{
								// Set this token into the current thread
								if (SetThreadToken (NULL, hDupToken))
								{
									*pNeedToReset = true;
									hr = S_OK;
									// TODO - do we need to resecure the proxy at this point?
								}
							}
							CloseHandle (hDupToken);
						}

						delete [] tp;
						tp = NULL;
					}

					// If we have duplicated the process token we can close the original now
					// as we don't need it to restore it. If we have duplicated the thread token
					// then we must hang on to it as we will need to restore it later in
					// ResetSecurity.
					if (!(*pCurrentThreadToken))
						CloseHandle (hToken);
				}
			}
		}
		else
			hr = S_OK;	// Win9x
	}

	return hr;
}

TOKEN_PRIVILEGES *CWmiSecurityHelper::AdjustPrivileges (HANDLE hToken)
{
	TOKEN_USER	TokenUser;
	DWORD		adjustedCount	= 0;
	DWORD		dwSize			= sizeof (TOKEN_USER);
	TOKEN_PRIVILEGES * tp		= NULL;
	DWORD		dwRequiredSize	= 0;
	DWORD		dwLastError		= 0;
	
	// Get privilege info
	bool gotInfo = false;

	ZeroMemory(&TokenUser, sizeof(TOKEN_USER));
	if (0 ==  GetTokenInformation (	hToken,
									TokenPrivileges, 
									&TokenUser,
									dwSize,
									&dwRequiredSize))
	{
		dwSize = dwRequiredSize;
		dwRequiredSize = 0;

		tp = (TOKEN_PRIVILEGES *) new BYTE [dwSize];

		if (tp)
		{
			if (!GetTokenInformation (hToken, TokenPrivileges, 
							(LPVOID) tp, dwSize, &dwRequiredSize))
				dwLastError = GetLastError ();
			else
				gotInfo = true;
		}
	}

	if (gotInfo)
	{
		// Enable the bally lot of them
		for (DWORD i = 0; i < tp->PrivilegeCount; i++)
		{
			DWORD dwAttrib = tp->Privileges[i].Attributes;

			if (0 == (dwAttrib & SE_PRIVILEGE_ENABLED))
			{
				tp->Privileges[i].Attributes |= SE_PRIVILEGE_ENABLED;
				adjustedCount++;
			}
		}
	}

	// If we didn't make any changes, clean up now. Otherwise tp will be deleted by the caller
	if (0 == adjustedCount)
	{
		if (tp)
		{
			delete [] tp;
			tp = NULL;
		}
	}

	return tp;
}

bool CWmiSecurityHelper::DuplicateToken(
	HANDLE hToken, 
	HANDLE &hDupToken,
	SECURITY_IMPERSONATION_LEVEL &secImpLevel)
{
	// DuplicateTokenEx won't exist on Win9x, so we need
	// this palaver to get at it
	BOOL (STDAPICALLTYPE *pfnDuplicateTokenEx) (
		HANDLE, 
		DWORD, 
		LPSECURITY_ATTRIBUTES,
		SECURITY_IMPERSONATION_LEVEL, 
		TOKEN_TYPE,
		PHANDLE
	) = NULL; 

	static HINSTANCE hAdvApi32 = NULL;
	static TCHAR	 dllName [] = _T("\\AdvApi32.dll");
	TCHAR			 szBuffer[MAX_PATH + sizeof(TCHAR)];

	if (NULL == hAdvApi32)
	{
		UINT uSize = GetSystemDirectory(szBuffer, MAX_PATH);

		if (uSize + (sizeof(dllName) / sizeof(TCHAR)) + 1 <= MAX_PATH)
		{
			// BANNED FUNCTION REPLACEMENT
			StringCchCat ( szBuffer, MAX_PATH+1, dllName ) ;
			//lstrcat(szBuffer, dllName);
			hAdvApi32 = LoadLibraryEx(szBuffer, NULL, 0);
		}
	}	
	if (NULL != hAdvApi32)
	{
		(FARPROC&) pfnDuplicateTokenEx = GetProcAddress(hAdvApi32, "DuplicateTokenEx");

		if (NULL != pfnDuplicateTokenEx)
			return pfnDuplicateTokenEx(
						hToken, 
						TOKEN_QUERY|TOKEN_ADJUST_PRIVILEGES|TOKEN_IMPERSONATE,
						NULL,
						secImpLevel,
						TokenImpersonation,
						&hDupToken) ? true : false;
	}
	return false;
}

STDMETHODIMP CWmiSecurityHelper::ResetSecurity(HANDLE hToken)
{
	//
	// [RAID: 124490, marioh]
	// Check return from SetThreadToken
	//
	BOOL bRet = FALSE ;
	if (IsNT())
	{
		/* 
		 * Set the supplied token (which may be NULL) into
		 * the current thread.
		 */
		bRet = SetThreadToken (NULL, hToken);

		if (hToken)
			CloseHandle (hToken);
	}
	return (bRet==TRUE) ? S_OK : E_UNEXPECTED ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wmisec\resource.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wmisec.rc
//
#define IDS_PROJNAME                    100
#define IDR_WMISECURITYHELPER           101
#define IDR_WMIOBJECTSINK               106
#define IDR_WMISINKDEMULTIPLEXOR        107

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           108
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wminet_utils\wminet_utils.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// WMINet_Utils.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for WMINet_Utils.idl by adding the following 
//      files to the Outputs.
//          WMINet_Utils_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f WMINet_Utilsps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "wbemcli.h"
#include "WMINet_Utils.h"
#include "dlldatax.h"

#include "WMINet_Utils_i.c"
#include "WmiSecurityHelper.h"
#include "WmiSinkDemultiplexor.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_WmiSecurityHelper, CWmiSecurityHelper)
OBJECT_ENTRY(CLSID_WmiSinkDemultiplexor, CWmiSinkDemultiplexor)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Universal COM function caller
extern "C" __declspec(naked) void __stdcall UFunc()
{
#ifdef _M_IX86
    __asm
    {
        pop eax
        pop edx
        push eax
        mov eax,dword ptr [esp+4]
        mov ecx,dword ptr [eax]
        jmp dword ptr [ecx+ edx*4]
    }
#endif
}

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_WMINet_UtilsLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
//
// [RAID: 122632, marioh]
// Remove self registration code for SBS support
//

//#ifdef _MERGE_PROXYSTUB
//    HRESULT hRes = PrxDllRegisterServer();
//    if (FAILED(hRes))
//        return hRes;
//#endif
//    // registers object, typelib and all interfaces in typelib
//    return _Module.RegisterServer(TRUE);
	return S_OK ;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
//
// [RAID: 122632, marioh]
// Remove self registration code for SBS support
//

//#ifdef _MERGE_PROXYSTUB
//    PrxDllUnregisterServer();
//#endif
//    return _Module.UnregisterServer(TRUE);
	return S_OK ;
}

bool unicodeOS()
{
    OSVERSIONINFOA OsVersionInfoA;
    OsVersionInfoA.dwOSVersionInfoSize = sizeof (OSVERSIONINFOA) ;
    GetVersionExA(&OsVersionInfoA);
    return (OsVersionInfoA.dwPlatformId == VER_PLATFORM_WIN32_NT);
};

HRESULT SetClientSecurity ( HKEY a_Key) 
{
    if (!unicodeOS())
        return ERROR_SUCCESS;

    HRESULT t_Result = S_OK ;

    SID_IDENTIFIER_AUTHORITY t_NtAuthoritySid = SECURITY_NT_AUTHORITY ;

    PSID t_Administrator_Sid = NULL ;
    ACCESS_ALLOWED_ACE *t_Administrator_ACE = NULL ;
    DWORD t_Administrator_ACESize = 0 ;

    BOOL t_BoolResult = AllocateAndInitializeSid (

        & t_NtAuthoritySid ,
        2 ,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS,
        0,
        0,
        0,
        0,
        0,
        0,
        & t_Administrator_Sid
    );

    if ( t_BoolResult )
    {
        DWORD t_SidLength = ::GetLengthSid ( t_Administrator_Sid );
        t_Administrator_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
        t_Administrator_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_Administrator_ACESize ] ;
        if ( t_Administrator_ACE )
        {
            if ( CopySid ( t_SidLength, (PSID) & t_Administrator_ACE->SidStart, t_Administrator_Sid ) != 0 )
			{
				t_Administrator_ACE->Mask = 0x1F01FF;
				t_Administrator_ACE->Header.AceType = 0 ;
				t_Administrator_ACE->Header.AceFlags = 3 ;
				t_Administrator_ACE->Header.AceSize = (WORD)t_Administrator_ACESize ;
			}
			else
			{
				t_Result = WBEM_E_FAILED ;
			}
        }
        else
        {
            t_Result = WBEM_E_OUT_OF_MEMORY ;
        }
    }
    else
    {
        DWORD t_LastError = ::GetLastError();

        t_Result = WBEM_E_OUT_OF_MEMORY ;
    }

    PSID t_System_Sid = NULL ;
    ACCESS_ALLOWED_ACE *t_System_ACE = NULL ;
    DWORD t_System_ACESize = 0 ;

    t_BoolResult = AllocateAndInitializeSid (

        & t_NtAuthoritySid ,
        1 ,
        SECURITY_LOCAL_SYSTEM_RID,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        & t_System_Sid
    );

    if ( t_BoolResult )
    {
        DWORD t_SidLength = ::GetLengthSid ( t_System_Sid );
        t_System_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
        t_System_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_System_ACESize ] ;
        if ( t_System_ACE )
        {
            if ( CopySid ( t_SidLength, (PSID) & t_System_ACE->SidStart, t_System_Sid ) != 0 )
			{
				t_System_ACE->Mask = 0x1F01FF;
				t_System_ACE->Header.AceType = 0 ;
				t_System_ACE->Header.AceFlags = 3 ;
				t_System_ACE->Header.AceSize = (WORD)t_System_ACESize ;
			}
			else
			{
				t_Result = WBEM_E_FAILED ;
			}
        }
        else
        {
            t_Result = WBEM_E_OUT_OF_MEMORY ;
        }
    }
    else
    {
        DWORD t_LastError = ::GetLastError();

        t_Result = WBEM_E_OUT_OF_MEMORY ;
    }


    SID_IDENTIFIER_AUTHORITY t_WorldAuthoritySid = SECURITY_WORLD_SID_AUTHORITY ;

    PSID t_Everyone_Sid = NULL ;
    ACCESS_ALLOWED_ACE *t_Everyone_ACE = NULL ;
    DWORD t_Everyone_ACESize = 0 ;
    
    t_BoolResult = AllocateAndInitializeSid (

        & t_WorldAuthoritySid ,
        1 ,
        SECURITY_WORLD_RID ,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        & t_Everyone_Sid
    );

    if ( t_BoolResult )
    {
        DWORD t_SidLength = ::GetLengthSid ( t_Everyone_Sid );
        t_Everyone_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
        t_Everyone_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_Everyone_ACESize ] ;
        if ( t_Everyone_ACE )
        {
            if ( CopySid ( t_SidLength, (PSID) & t_Everyone_ACE->SidStart, t_Everyone_Sid ) != 0 )
			{
				t_Everyone_ACE->Mask = KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS | KEY_SET_VALUE | READ_CONTROL | KEY_QUERY_VALUE ; // JeffCoop: added KEY_SET_VALUE | READ_CONTROL | KEY_QUERY_VALUE
				t_Everyone_ACE->Header.AceType = 0 ;
				t_Everyone_ACE->Header.AceFlags = 0 ; // JeffCoop: was '3' ;
				t_Everyone_ACE->Header.AceSize = (WORD)t_Everyone_ACESize ;
			}
			else
			{
				t_Result = WBEM_E_FAILED ;
			}
        }
        else
        {
            t_Result = WBEM_E_OUT_OF_MEMORY ;
        }
    }
    else
    {
        DWORD t_LastError = ::GetLastError();

        t_Result = WBEM_E_OUT_OF_MEMORY ;
    }


    SID_IDENTIFIER_AUTHORITY t_OwnerAuthoritySid = SECURITY_CREATOR_SID_AUTHORITY;
    PSID t_Owner_Sid = NULL ;
    ACCESS_ALLOWED_ACE *t_Owner_ACE = NULL ;
    DWORD t_Owner_ACESize = 0 ;
    
    t_BoolResult = AllocateAndInitializeSid (

        & t_OwnerAuthoritySid ,
        1 ,
        SECURITY_CREATOR_OWNER_RID ,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        & t_Owner_Sid
    );

    if ( t_BoolResult )
    {
        DWORD t_SidLength = ::GetLengthSid ( t_Owner_Sid );
        t_Owner_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
        t_Owner_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_Owner_ACESize ] ;
        if ( t_Owner_ACE )
        {
            if ( CopySid ( t_SidLength, (PSID) & t_Owner_ACE->SidStart, t_Owner_Sid ) != 0 )
			{
				t_Owner_ACE->Mask = KEY_ALL_ACCESS ;
				t_Owner_ACE->Header.AceType = ACCESS_ALLOWED_ACE_TYPE ;
				t_Owner_ACE->Header.AceFlags = OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | NO_PROPAGATE_INHERIT_ACE | INHERIT_ONLY_ACE ; // JeffCoop: added NO_PROPAGATE_INHERIT_ACE | INHERIT_ONLY_ACE
				t_Owner_ACE->Header.AceSize = (WORD)t_Owner_ACESize ;
			}
			else
			{
				t_Result = WBEM_E_FAILED ;
			}
        }
        else
        {
            t_Result = WBEM_E_OUT_OF_MEMORY ;
        }
    }
    else
    {
        DWORD t_LastError = ::GetLastError();

        t_Result = WBEM_E_OUT_OF_MEMORY ;
    }

    // Now we need to set permissions on the registry: Everyone read; Admins full.
    // We have the sid for admins from the above code.  Now get the sid for "Everyone"

    DWORD t_TotalAclSize = sizeof(ACL) + t_Administrator_ACESize + t_Owner_ACESize + t_Everyone_ACESize + t_System_ACESize;
    PACL t_Dacl = (PACL) new BYTE [ t_TotalAclSize ] ;
    if ( t_Dacl )
    {
        if ( :: InitializeAcl ( t_Dacl, t_TotalAclSize, ACL_REVISION ) )
        {
            DWORD t_AceIndex = 0 ;

            if ( t_Everyone_ACESize && :: AddAce ( t_Dacl , ACL_REVISION, t_AceIndex , t_Everyone_ACE , t_Everyone_ACESize ) )
            {
                t_AceIndex ++ ;
            }

            if ( t_Owner_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_Owner_ACE , t_Owner_ACESize ) )
            {
                t_AceIndex ++ ;
            }
            
            if ( t_Administrator_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_Administrator_ACE , t_Administrator_ACESize ) )
            {
                t_AceIndex ++ ;
            }

            if ( t_Administrator_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_System_ACE , t_System_ACESize ) )
            {
                t_AceIndex ++ ;
            }


            SECURITY_INFORMATION t_SecurityInfo = 0L;

            t_SecurityInfo |= DACL_SECURITY_INFORMATION;

            SECURITY_DESCRIPTOR t_SecurityDescriptor ;
            t_BoolResult = InitializeSecurityDescriptor ( & t_SecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) ;
            if ( t_BoolResult )
            {
                t_BoolResult = SetSecurityDescriptorDacl (

                  & t_SecurityDescriptor ,
                  TRUE ,
                  t_Dacl ,
                  FALSE
                ) ;

                if ( t_BoolResult )
                {
                    LONG t_SetStatus = RegSetKeySecurity (

                      a_Key ,
                      t_SecurityInfo ,
                      & t_SecurityDescriptor
                    ) ;

                    if ( t_SetStatus != ERROR_SUCCESS )
                    {
                        DWORD t_LastError = GetLastError () ;

                        t_Result = WBEM_E_ACCESS_DENIED ;
                    }
                }
                else
                {
                    t_Result = WBEM_E_CRITICAL_ERROR ;  
                }
            }
            else
            {
                t_Result = WBEM_E_CRITICAL_ERROR ;  
            }
        }

        delete [] ( ( BYTE * ) t_Dacl ) ;
    }
    else
    {
        t_Result = WBEM_E_OUT_OF_MEMORY ;
    }

    if ( t_Administrator_ACE )
    {
        delete [] ( ( BYTE * ) t_Administrator_ACE ) ;
    }

    if (t_Owner_ACE) delete [] ((BYTE *)t_Owner_ACE);
    if (t_Owner_Sid) FreeSid (t_Owner_Sid);

    if ( t_Everyone_ACE )
    {
        delete [] ( ( BYTE * ) t_Everyone_ACE ) ;
    }

    if ( t_System_ACE )
    {
        delete [] ( ( BYTE * ) t_System_ACE ) ;
    }

    if ( t_System_Sid )
    {
        FreeSid ( t_System_Sid ) ;
    }

    if ( t_Administrator_Sid )
    {
        FreeSid ( t_Administrator_Sid ) ;
    }
    


    if ( t_Everyone_Sid )
    {
        FreeSid ( t_Everyone_Sid ) ;
    }

    return t_Result ;
}

LPCSTR s_Strings_Reg_HomeClient = "Software\\Microsoft\\Wbem\\Transports\\Decoupled\\Client" ;

// Exported function that safely makes sure the 'Client' key has the correct security
STDAPI VerifyClientKey()
{
    HKEY key;
    DWORD t_Disposition = 0 ;

    LONG t_RegResult = /*OS::*/RegCreateKeyEx (
        HKEY_LOCAL_MACHINE ,
        s_Strings_Reg_HomeClient ,
        0 ,
        NULL ,
        0 ,
        KEY_ALL_ACCESS,
        NULL ,
        & key ,
        & t_Disposition                     
    ) ;
    if (t_RegResult!=ERROR_SUCCESS)
        return t_RegResult;

    SetClientSecurity(key);
    RegCloseKey(key);
    
    return t_RegResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wmisec\wmisinkdemultiplexor.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

// WmiSinkDemultiplexor.h : Declaration of the CWmiSinkDemultiplexor

#ifndef __WMISINKDEMULTIPLEXOR_H_
#define __WMISINKDEMULTIPLEXOR_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CWmiSinkDemultiplexor
class ATL_NO_VTABLE CWmiSinkDemultiplexor : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CWmiSinkDemultiplexor, &CLSID_WmiSinkDemultiplexor>,
	public IWmiSinkDemultiplexor
{
private:

	/*
	 * The internal IWbemObjectSink implementation we use to
	 * confer with WMI.
	 */
	class InternalWbemObjectSink : IWbemObjectSink 
	{
	private:
		CComPtr<IWmiEventSource>		m_pIWmiEventSource; 

	protected:
		long            m_cRef;         //Object reference count

	public:
		InternalWbemObjectSink (CComPtr<IWmiEventSource> & pIWmiEventSource) :
						m_cRef(0),
						m_pIWmiEventSource(pIWmiEventSource) {}

		~InternalWbemObjectSink () {}

		//Non-delegating object IUnknown
		STDMETHODIMP         QueryInterface(REFIID riid, LPVOID *ppv)
		{
			*ppv=NULL;

			if (IID_IUnknown==riid)
				*ppv = reinterpret_cast<IUnknown*>(this);
			else if (IID_IWbemObjectSink==riid)
				*ppv = (IWbemObjectSink *)this;
			else if (IID_IDispatch==riid)
				*ppv = (IDispatch *)this;

			if (NULL!=*ppv)
			{
				((LPUNKNOWN)*ppv)->AddRef();
				return NOERROR;
			}

			return ResultFromScode(E_NOINTERFACE);
		}

		STDMETHODIMP_(ULONG) AddRef(void)
		{
		    InterlockedIncrement(&m_cRef);
		    return m_cRef;
		}

		STDMETHODIMP_(ULONG) Release(void)
		{
		    long lRef = InterlockedDecrement(&m_cRef);
			
			if (0L!=lRef)
				return lRef;

			delete this;
			return 0;

		}

		// IWbemObjectSink methods

        HRESULT STDMETHODCALLTYPE Indicate( 
            /* [in] */ long lObjectCount,
            /* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjArray)
		{
			HRESULT hr = WBEM_E_FAILED;

			if (m_pIWmiEventSource)
			{
				hr = S_OK; 

				for (long i = 0; (i < lObjectCount) && SUCCEEDED(hr); i++)
					hr = m_pIWmiEventSource->Indicate (apObjArray[i]);
			}

			return hr;
		}
        
        HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject __RPC_FAR *pObjParam)
		{
			HRESULT hr = WBEM_E_FAILED;

			return (m_pIWmiEventSource) ?
				m_pIWmiEventSource->SetStatus (lFlags, hResult, strParam, pObjParam) : WBEM_E_FAILED;
		}
	};

#if 0
	InternalWbemObjectSink		*m_pIWbemObjectSink;
#endif
	CComPtr<IWbemObjectSink>	m_pStub;

public:
	CWmiSinkDemultiplexor()
	{
		m_pUnkMarshaler = NULL;
#if 0
		m_pIWbemObjectSink = NULL;
#endif
	}

DECLARE_REGISTRY_RESOURCEID(IDR_WMISINKDEMULTIPLEXOR)
DECLARE_NOT_AGGREGATABLE(CWmiSinkDemultiplexor)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CWmiSinkDemultiplexor)
	COM_INTERFACE_ENTRY(IWmiSinkDemultiplexor)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();

#if 0
		if (m_pIWbemObjectSink)
		{
			m_pIWbemObjectSink->Release ();
			m_pIWbemObjectSink = NULL;
		}
#endif
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

// IWmiSinkDemultiplexor
public:
	STDMETHOD(GetDemultiplexedStub)(/*[in]*/ IUnknown *pObject, /*[out]*/ IUnknown **ppObject);
};

#endif //__WMISINKDEMULTIPLEXOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wmisec\wmisec.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// wmisec.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for wmisec.idl by adding the following 
//      files to the Outputs.
//          wmisec_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f wmisecps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "wbemcli.h"
#include "wmisec.h"
#include "dlldatax.h"

#include "wmisec_i.c"
#include "WmiSecurityHelper.h"
#include "WmiSinkDemultiplexor.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_WmiSecurityHelper, CWmiSecurityHelper)
OBJECT_ENTRY(CLSID_WmiSinkDemultiplexor, CWmiSinkDemultiplexor)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_WMISECLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wmisec\stdafx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__0A2E870A_7FCF_4DA2_8F0B_07C51D372257__INCLUDED_)
#define AFX_STDAFX_H__0A2E870A_7FCF_4DA2_8F0B_07C51D372257__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__0A2E870A_7FCF_4DA2_8F0B_07C51D372257__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wmisec\wmisecurityhelper.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// WmiSecurityHelper.cpp : Implementation of CWmiSecurityHelper
#include "stdafx.h"
#include "wbemcli.h"
#include "Wmisec.h"
#include "WmiSecurityHelper.h"

#ifndef RPC_C_AUTHZ_DEFAULT
#define RPC_C_AUTHZ_DEFAULT 0xffffffff
#endif 

#ifndef EOAC_STATIC_CLOAKING
#define EOAC_STATIC_CLOAKING	0x20
#endif

#ifndef EOAC_DYNAMIC_CLOAKING
#define EOAC_DYNAMIC_CLOAKING	0x40
#endif 

#ifndef COLE_DEFAULT_AUTHINFO
#define	COLE_DEFAULT_AUTHINFO	( ( void * )-1 )
#endif 

#ifdef LOG_DEBUG
static HANDLE logFile = NULL;

static void CreateLogFile ()
{
	logFile = CreateFile ("c:\\temp\\sec.txt", GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, 
				FILE_ATTRIBUTE_NORMAL, NULL);
	SetFilePointer (logFile, 0, NULL, FILE_END);
}

static CloseLogFile ()
{
	CloseHandle (logFile);
}
	
static void Logit (LPWSTR msg) 
{
	DWORD nBytes = 0;
	if (msg)
		WriteFile (logFile, msg, wcslen(msg)*2, &nBytes, NULL);
	else
		WriteFile (logFile, L"<null>", 12, &nBytes, NULL);
}

static void Logit (DWORD d) 
{
	DWORD nBytes = 0;
	WCHAR buf [20];
	_itow (d, buf, 10);

	WriteFile (logFile, buf, wcslen(buf)*2, &nBytes, NULL);
}

static void LogCoAuthIdentity (COAUTHIDENTITY *pAuthIdent)
{
	if (pAuthIdent)
	{
		Logit(L"User(");
		Logit(pAuthIdent->User);
		Logit(L") [");
		Logit(pAuthIdent->UserLength);
		Logit(L"] Password(");
		Logit(pAuthIdent->Password);
		Logit(L") [");
		Logit(pAuthIdent->PasswordLength);
		Logit(L"] Domain(");
		Logit(pAuthIdent->Domain);
		Logit(L") [");
		Logit(pAuthIdent->DomainLength);
		Logit(L"]\r\n");
	}
	else
		Logit(L"<null>");
}

static void LogAuthIdentity (RPC_AUTH_IDENTITY_HANDLE pAuthInfo)
{
	if (pAuthInfo)
	{
		try {
			COAUTHIDENTITY *pAuthId = (COAUTHIDENTITY*)pAuthInfo;
			LogCoAuthIdentity (pAuthId);
		} catch (...) {}
	}
	else
		Logit(L"<null>");
}

static void LogBlanket(IClientSecurity *pIClientSecurity, IUnknown *pInterface)
{
	DWORD logAuthnSvc, logAuthzSvc, logAuthnLevel, logImpLevel, logCapabilities;
	OLECHAR *logServerPrincName = NULL;
	RPC_AUTH_IDENTITY_HANDLE *logAuthInfo = NULL;

	if (SUCCEEDED(pIClientSecurity->QueryBlanket (pInterface, &logAuthnSvc,
			&logAuthzSvc, &logServerPrincName, &logAuthnLevel, &logImpLevel, (void**)&logAuthInfo, &logCapabilities)))
	{
		Logit(L"\r\n\r\nBlanket Settings:\r\n");
		Logit(L"================\r\n");
		
		Logit(L" AuthnSvc: ");
		Logit(logAuthnSvc);
		
		Logit(L"\r\n AuthzSvc: ");
		Logit(logAuthzSvc);
		
		Logit(L"\r\n Server Principal Name: ");
		Logit(logServerPrincName);
		
		Logit(L"\r\n AuthnLevel: ");
		Logit(logAuthnLevel);

		Logit(L"\r\n ImpLevel: ");
		Logit(logImpLevel);
		
		Logit(L"\r\n AuthInfo: ");
		LogAuthIdentity(logAuthInfo);
		
		Logit(L"\r\n Capabilities: ");
		Logit(logCapabilities);

		if (logServerPrincName)
			CoTaskMemFree (logServerPrincName);
	}
}

#else
#define Logit(x)
#define LogBlanket(x,y)
#define LogAuthIdentity(x)
#define LogCoAuthIdentity(x)
#define CreateLogFile()
#define CloseLogFile()
#endif

/////////////////////////////////////////////////////////////////////////////
// CWmiSecurityHelper

STDMETHODIMP CWmiSecurityHelper::BlessIWbemServices(
	IWbemServices **ppIWbemServices, 
	BSTR strUser, 
	BSTR strPassword, 
	BSTR strAuthority, 
	DWORD impLevel, 
	DWORD authnLevel)
{
	HRESULT hr = E_FAIL;

	CreateLogFile();
	Logit (L"\r\n\r\n>>Received BlessIWbemServices request<<\r\n\r\n");
	Logit (L" User: ");
	Logit (strUser);
	Logit (L"\r\n Password: ");
	Logit (strPassword);
	Logit (L"\r\n Authority: ");
	Logit (strAuthority);
	Logit (L"\r\n Impersonation: ");
	Logit (impLevel);
	Logit (L"\r\n Authentication: ");
	Logit (authnLevel);
	Logit (L"\r\n\r\n");
	
	if (ppIWbemServices && *ppIWbemServices)
	{
		// See if we get one
		CComBSTR bsUser (strUser);
		CComBSTR bsPassword (strPassword);
		CComBSTR bsAuthority (strAuthority);
	
		hr = SetInterfaceSecurity (*ppIWbemServices, bsAuthority, bsUser, bsPassword,
				authnLevel, impLevel, GetCapabilities (bsUser),
				CanUseDefaultInfo (*ppIWbemServices));
	}

	CloseLogFile ();
	return hr;
}

STDMETHODIMP CWmiSecurityHelper::BlessIEnumWbemClassObject(
	IEnumWbemClassObject **ppIEnumWbemClassObject, 
	BSTR strUser, 
	BSTR strPassword, 
	BSTR strAuthority, 
	DWORD impLevel, 
	DWORD authnLevel)
{
	HRESULT hr = E_FAIL;

	CreateLogFile();
	Logit (L"\r\n\r\n>>Received BlessIEnumWbemClassObject request<<\r\n\r\n");
	Logit (L" User: ");
	Logit (strUser);
	Logit (L"\r\n Password: ");
	Logit (strPassword);
	Logit (L"\r\n Authority: ");
	Logit (strAuthority);
	Logit (L"\r\n Impersonation: ");
	Logit (impLevel);
	Logit (L"\r\n Authentication: ");
	Logit (authnLevel);
	Logit (L"\r\n\r\n");

	if (ppIEnumWbemClassObject && *ppIEnumWbemClassObject)
	{
		// See if we get one
		CComBSTR bsUser (strUser);
		CComBSTR bsPassword (strPassword);
		CComBSTR bsAuthority (strAuthority);
	
		hr = SetInterfaceSecurity (*ppIEnumWbemClassObject, bsAuthority, bsUser, bsPassword,
				authnLevel, impLevel, GetCapabilities (bsUser),
				CanUseDefaultInfo (*ppIEnumWbemClassObject));
	}

	CloseLogFile();
	return hr;
}


STDMETHODIMP CWmiSecurityHelper::BlessIWbemCallResult(
	IWbemCallResult **ppIWbemCallResult, 
	BSTR strUser, 
	BSTR strPassword, 
	BSTR strAuthority, 
	DWORD impLevel, 
	DWORD authnLevel)
{
	HRESULT hr = E_FAIL;
	CreateLogFile();
	Logit (L"\r\n\r\n>>Received BlessIWbemCallResult request<<\r\n\r\n");
	Logit (L" User: ");
	Logit (strUser);
	Logit (L"\r\n Password: ");
	Logit (strPassword);
	Logit (L"\r\n Authority: ");
	Logit (strAuthority);
	Logit (L"\r\n Impersonation: ");
	Logit (impLevel);
	Logit (L"\r\n Authentication: ");
	Logit (authnLevel);
	Logit (L"\r\n\r\n");

	if (ppIWbemCallResult && *ppIWbemCallResult)
	{
		// See if we get one
		CComBSTR bsUser (strUser);
		CComBSTR bsPassword (strPassword);
		CComBSTR bsAuthority (strAuthority);
	
		hr = SetInterfaceSecurity (*ppIWbemCallResult, bsAuthority, bsUser, bsPassword,
				authnLevel, impLevel, GetCapabilities (bsUser),
				CanUseDefaultInfo (*ppIWbemCallResult));
	}

	CloseLogFile();
	return hr;
}

DWORD CWmiSecurityHelper::GetCapabilities (BSTR bsUser)
{
	DWORD dwCapabilities = EOAC_NONE;
	bool bUsingExplicitUserName = (bsUser && (0 < wcslen(bsUser)));
	
	if (IsNT () && (4 < GetNTMajorVersion ()) && !bUsingExplicitUserName)
		dwCapabilities |= EOAC_STATIC_CLOAKING;

	return dwCapabilities ;
}


bool CWmiSecurityHelper::CanUseDefaultInfo (IUnknown *pUnk)
{
	bool result = false; 

	if (IsNT() && (4 < GetNTMajorVersion ()))
	{
		HANDLE hToken = NULL;

		if (OpenThreadToken (GetCurrentThread (), TOKEN_QUERY, true, &hToken))
		{
			// Certainly a candidate to use default settings for
			// authorization and authentication service on the blanket.
			// Check if we are delegating.

			DWORD dwBytesReturned = 0;
			SECURITY_IMPERSONATION_LEVEL impLevel;

			if (GetTokenInformation(hToken, TokenImpersonationLevel, &impLevel,
							sizeof(SECURITY_IMPERSONATION_LEVEL), &dwBytesReturned) &&
									(SecurityDelegation == impLevel))
			{
				// Looks promising - now check for whether we are using kerberos
				
				if (pUnk)
				{
					CComQIPtr<IClientSecurity> pIClientSecurity(pUnk);
				
					if (pIClientSecurity)
					{
						DWORD dwAuthnSvc, dwAuthzSvc, dwImp, dwAuth, dwCapabilities;

						if (SUCCEEDED (pIClientSecurity->QueryBlanket(pUnk, &dwAuthnSvc, &dwAuthzSvc, 
												NULL,
												&dwAuth, &dwImp,
												NULL, &dwCapabilities)))
						{
							if (RPC_C_AUTHN_WINNT != dwAuthnSvc) 
								result = true;
						}
					}
				}
			}

			CloseHandle (hToken);
		}
	}

	return result;
}

HRESULT CWmiSecurityHelper::SetInterfaceSecurity(
			IUnknown * pInterface, 
			CComBSTR bsAuthority, 
			CComBSTR bsUser, 
			CComBSTR bsPassword,
            DWORD dwAuthLevel, 
			DWORD dwImpLevel, 
			DWORD dwCapabilities,
			bool bGetInfoFirst)
{
    
    HRESULT hr = E_FAIL;
    DWORD dwAuthenticationArg = RPC_C_AUTHN_WINNT;
    DWORD dwAuthorizationArg = RPC_C_AUTHZ_NONE;
	
#if 0
    if(!IsDcomEnabled())        // For the anon pipes clients, dont even bother
        return S_OK;
#endif

    //if(bGetInfoFirst)
        GetCurrValue(pInterface, dwAuthenticationArg, dwAuthorizationArg);

    // If we are doing trivial case, just pass in a null authenication structure which is used
    // if the current logged in user's credentials are OK.

    if((0 == bsAuthority.Length()) && 
        (0 == bsUser.Length()) && 
        (0 == bsPassword.Length()))
    {
		CComBSTR bsDummy;

		hr = SetProxyBlanket(pInterface, dwAuthenticationArg, dwAuthorizationArg, bsDummy,
            dwAuthLevel, dwImpLevel, 
            NULL,
            dwCapabilities);
    }
	else
	{
		// If user, or Authority was passed in, the we need to create an authority argument for the login
		CComBSTR bsAuthArg, bsUserArg, bsPrincipalArg;
    
		if (DetermineLoginType(bsAuthArg, bsUserArg, bsPrincipalArg, bsAuthority, bsUser))
		{
			Logit(L"\r\nPrincipal set to ");
			Logit(bsPrincipalArg);

			COAUTHIDENTITY*  pAuthIdent = NULL;
    
			// We will only need this structure if we are not cloaking and we want at least
			// connect level authorization
			bool okToProceed = true;

			if ( !( dwCapabilities & (EOAC_STATIC_CLOAKING | EOAC_DYNAMIC_CLOAKING) )
				&& (dwAuthLevel >= RPC_C_AUTHN_LEVEL_CONNECT) )
			{
				okToProceed = AllocAuthIdentity( bsUserArg, bsPassword, bsAuthArg, &pAuthIdent );
				Logit(L"\r\nCOAUTHIDENTITY is ");
				LogCoAuthIdentity(pAuthIdent);
			}

			if (okToProceed)
			{
				hr = SetProxyBlanket(pInterface, 
					//(0 == bsPrincipalArg.Length()) ? 16 : dwAuthenticationArg, 
					dwAuthenticationArg, 
					dwAuthorizationArg, 
					bsPrincipalArg,
					dwAuthLevel, dwImpLevel, 
					pAuthIdent,
					dwCapabilities);
			}

			if (pAuthIdent)
				FreeAuthIdentity( pAuthIdent );
		}
	}

	return hr;
}

bool CWmiSecurityHelper::DetermineLoginType(
			CComBSTR & bsAuthArg, 
			CComBSTR & bsUserArg,
			CComBSTR & bsPrincipalArg,
            CComBSTR & bsAuthority,
			CComBSTR & bsUser)
{
    bool result = false;

    if((0 == bsAuthority.Length()) || (0 != _wcsnicmp(bsAuthority, L"KERBEROS:",9)))
        result = DetermineLoginType(bsAuthArg, bsUserArg, bsAuthority, bsUser);
	else
	{
		if(IsKerberosAvailable ())
		{
			bsPrincipalArg = (bsAuthority.m_str) + 9;
			CComBSTR bsTempArg;
			result = DetermineLoginType(bsAuthArg, bsUserArg, bsTempArg, bsUser);
		}
	}

	return result;
}

bool CWmiSecurityHelper::DetermineLoginType(
		CComBSTR & bsAuthArg, 
		CComBSTR & bsUserArg,
		CComBSTR & bsAuthority,
		CComBSTR & bsUser)
{
    // Determine the connection type by examining the Authority string
	bool result = false;

    if(0 == bsAuthority.Length() || (0 == _wcsnicmp(bsAuthority, L"NTLMDOMAIN:",11)))
	{    
		result = true;

		// The ntlm case is more complex.  There are four cases
		// 1)  Authority = NTLMDOMAIN:name" and User = "User"
		// 2)  Authority = NULL and User = "User"
		// 3)  Authority = "NTLMDOMAIN:" User = "domain\user"
		// 4)  Authority = NULL and User = "domain\user"

		// first step is to determine if there is a backslash in the user name somewhere between the
		// second and second to last character

		WCHAR * pSlashInUser = NULL;
		DWORD iDomLen = 0;

		if (0 < bsUser.Length ())
		{
			WCHAR * pEnd = bsUser + bsUser.Length() - 1;
			for(pSlashInUser = bsUser; pSlashInUser <= pEnd; pSlashInUser++)
			{
				if(*pSlashInUser == L'\\')      // dont think forward slash is allowed!
					break;

				iDomLen++;
			}

			if(pSlashInUser > pEnd)
				pSlashInUser = NULL;
		}

		if (11 < bsAuthority.Length()) 
		{
			if(!pSlashInUser)
			{
				bsAuthArg = bsAuthority.m_str + 11;

				if (0 < bsUser.Length()) 
					bsUserArg = bsUser;

			}
			else
				result = false;		// Can't have domain in Authority and in User
		}
		else if(pSlashInUser)
		{
			WCHAR cTemp[MAX_PATH];
			wcsncpy(cTemp, bsUser, iDomLen);
			cTemp[iDomLen] = 0;

			bsAuthArg = cTemp;

			if(0 < wcslen(pSlashInUser+1))
				bsUserArg = pSlashInUser+1;
		}
		else
		{
			if (0 < bsUser.Length()) 
				bsUserArg = bsUser;
		}
	}

    return result;
}

void CWmiSecurityHelper::FreeAuthIdentity( COAUTHIDENTITY* pAuthIdentity )
{
    // Make sure we have a pointer, then walk the structure members and
    // cleanup.

    if ( NULL != pAuthIdentity )
    {

		if (pAuthIdentity->User)
            CoTaskMemFree( pAuthIdentity->User );
        
        if (pAuthIdentity->Password)
            CoTaskMemFree( pAuthIdentity->Password );
        
        if (pAuthIdentity->Domain)
            CoTaskMemFree( pAuthIdentity->Domain );
        
        CoTaskMemFree( pAuthIdentity );
	}
}

bool CWmiSecurityHelper::AllocAuthIdentity( 
	CComBSTR & bsUser, 
	CComBSTR & bsPassword, 
	CComBSTR & bsDomain, 
	COAUTHIDENTITY** ppAuthIdent )
{
	bool result = false;

    if (ppAuthIdent)
    {
		// Handle an allocation failure
		COAUTHIDENTITY*  pAuthIdent = (COAUTHIDENTITY*) CoTaskMemAlloc( sizeof(COAUTHIDENTITY) );

		if (pAuthIdent)
		{
			result = true;
			memset((void *)pAuthIdent,0,sizeof(COAUTHIDENTITY));

			if(IsNT())
			{
				pAuthIdent->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
	
				if (bsUser.m_str)
				{
					pAuthIdent->User = (LPWSTR) CoTaskMemAlloc( ( bsUser.Length() + 1 ) * sizeof( WCHAR ) );
					pAuthIdent->UserLength = bsUser.Length ();

					if (pAuthIdent->User)
						wcscpy (pAuthIdent->User, bsUser.m_str);
					else
						result = false;
				}

				if (result && bsDomain.m_str)
				{
					pAuthIdent->Domain = (LPWSTR) CoTaskMemAlloc( ( bsDomain.Length() + 1 ) * sizeof( WCHAR ) );
					pAuthIdent->DomainLength = bsDomain.Length();

					if (pAuthIdent->Domain)
						wcscpy (pAuthIdent->Domain, bsDomain.m_str);
					else
						result = false;
				}

				if (result && bsPassword.m_str)
				{
					pAuthIdent->Password = (LPWSTR) CoTaskMemAlloc( (bsPassword.Length() + 1) * sizeof( WCHAR ) );
					pAuthIdent->PasswordLength = bsPassword.Length();
					
					if (pAuthIdent->Password)
						wcscpy (pAuthIdent->Password, bsPassword.m_str);
					else
						result = false;
				}
			}
			else
			{
				pAuthIdent->Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
				size_t  nBufferLength;

				if (bsUser.m_str)
				{
					nBufferLength = wcstombs( NULL, bsUser, 0 ) + 1;
					pAuthIdent->User = (LPWSTR) CoTaskMemAlloc( nBufferLength );
					pAuthIdent->UserLength = bsUser.Length ();
					
					if (pAuthIdent->User)
						wcstombs( (LPSTR) pAuthIdent->User, bsUser.m_str, nBufferLength );
					else
						result = false;
				}

				if (result && bsDomain.m_str)
				{
					nBufferLength = wcstombs( NULL, bsDomain, 0 ) + 1;
					pAuthIdent->Domain = (LPWSTR) CoTaskMemAlloc( nBufferLength );
					pAuthIdent->DomainLength = bsDomain.Length();

					if (pAuthIdent->Domain)
						wcstombs( (LPSTR) pAuthIdent->Domain, bsDomain.m_str, nBufferLength );
					else
						result = false;
				}

				if (bsPassword.m_str)
				{
					// How many characters do we need?
					nBufferLength = wcstombs( NULL, bsPassword, 0 ) + 1;
					pAuthIdent->Password = (LPWSTR) CoTaskMemAlloc( nBufferLength );
					pAuthIdent->PasswordLength = bsPassword.Length();

					if (pAuthIdent->Password)
						wcstombs( (LPSTR) pAuthIdent->Password, bsPassword.m_str, nBufferLength );
					else
						result = false;
				}
			}

			if (result)
				*ppAuthIdent = pAuthIdent;
			else
				FreeAuthIdentity (pAuthIdent);
		}
	}

    return result;
}

HRESULT CWmiSecurityHelper::SetProxyBlanket(
    IUnknown                 *pInterface,
    DWORD                     dwAuthnSvc,
    DWORD                     dwAuthzSvc,
    CComBSTR                  &bsServerPrincName,
    DWORD                     dwAuthLevel,
    DWORD                     dwImpLevel,
    RPC_AUTH_IDENTITY_HANDLE  pAuthInfo,
    DWORD                     dwCapabilities)
{
	HRESULT hr = E_FAIL;
	IUnknown * pUnk = NULL;

	if (SUCCEEDED(pInterface->QueryInterface(IID_IUnknown, (void **) &pUnk)))
	{
		CComQIPtr<IClientSecurity> pIClientSecurity(pInterface);
    
		if (pIClientSecurity)
		{
			/*
			 * Can't set pAuthInfo if cloaking requested, as cloaking implies
			 * that the current proxy identity in the impersonated thread (rather
			 * than the credentials supplied explicitly by the RPC_AUTH_IDENTITY_HANDLE)
			 * is to be used.
			 * See MSDN info on CoSetProxyBlanket for more details.
			 */
			if (dwCapabilities & (EOAC_STATIC_CLOAKING | EOAC_DYNAMIC_CLOAKING))
			{
				Logit(L"\r\nUsing cloaking");
				pAuthInfo = NULL;
			}

			if (WMISEC_AUTH_LEVEL_UNCHANGED == dwAuthLevel)
			{
				Logit(L"\r\nNot changing authentication level");
				GetAuthenticationLevel (pInterface, dwAuthLevel);
			}

			Logit(L"\r\n\r\nBlanket settings to be used:");
			Logit(L"\r\n Authentication: ");
			Logit(dwAuthnSvc);
			Logit(L"\r\n Authorization: ");
			Logit(dwAuthzSvc);
			Logit(L"\r\n Server Principal Name: ");
			Logit(bsServerPrincName);
			Logit(L"\r\n Authentication Level: ");
			Logit(dwAuthLevel);
			Logit(L"\r\n Impersonation Level: ");
			Logit(dwImpLevel);
			Logit(L"\r\n Capabilities: ");
			Logit(dwCapabilities);

			if (pAuthInfo)
			{
				LogAuthIdentity(pAuthInfo);
			}
			else
			{
				Logit(L"\r\n Credentials: [none]");
			}
        
			if (SUCCEEDED(hr = pIClientSecurity->SetBlanket(
							pInterface, 
							dwAuthnSvc, 
							dwAuthzSvc, 
							bsServerPrincName,
							dwAuthLevel, 
							dwImpLevel, 
							pAuthInfo, 
							dwCapabilities)))
			{
				Logit(L"\r\nSuccessfully set blanket on interface");
				LogBlanket(pIClientSecurity, pInterface);

				// If we are not explicitly told to ignore the IUnknown, then we should
				// check the auth identity structure.  This performs a heuristic which
				// assumes a COAUTHIDENTITY structure.  If the structure is not one, we're
				// wrapped with a try/catch in case we AV (this should be benign since
				// we're not writing to memory).

				if ( DoesContainCredentials( (COAUTHIDENTITY*) pAuthInfo ) )
				{
					CComPtr<IClientSecurity>	pIClientSecurity2;

					if (SUCCEEDED(hr = pUnk->QueryInterface(IID_IClientSecurity, (void **) &pIClientSecurity2)))
					{
						hr = pIClientSecurity2->SetBlanket(
							pUnk, 
							dwAuthnSvc, 
							dwAuthzSvc, 
							bsServerPrincName,
							dwAuthLevel, 
							dwImpLevel, 
							pAuthInfo, 
							dwCapabilities);
#ifdef LOG_DEBUG
						if (SUCCEEDED(hr))
						{
							Logit(L"\r\nSuccessfully set blanket on IUnknown");
							LogBlanket(pIClientSecurity, pUnk);
						}
						else
						{
							Logit(L"\r\nFAILED to set blanket on IUnknown");
						}
#endif
					}
					else if (hr == 0x80004002)
						hr = S_OK;
				}
			}
		}

	    pUnk->Release();
	}
	else
	{
		Logit(L"\r\nFAILED to set blanket on interface");
	}

    return hr;
}

bool CWmiSecurityHelper::DoesContainCredentials( COAUTHIDENTITY* pAuthIdentity )
{
    try
    {
        if ( NULL != pAuthIdentity && COLE_DEFAULT_AUTHINFO != pAuthIdentity)
        {
            return ( pAuthIdentity->UserLength != 0 || pAuthIdentity->PasswordLength != 0 );
        }

        return false;
    }
    catch(...)
    {
        return false;
    }

}

void CWmiSecurityHelper::GetCurrValue(
		IUnknown * pInterface,
		DWORD & dwAuthenticationArg, 
		DWORD & dwAuthorizationArg)
{
	if(pInterface)
	{
		if (IsNT() && (4 < GetNTMajorVersion ()))
		{
			// Win2k or later we just use the DEFAULT constants - much safer!
			dwAuthenticationArg = RPC_C_AUTHN_DEFAULT;
			dwAuthorizationArg = RPC_C_AUTHZ_DEFAULT;
		}
		else
		{
			CComQIPtr<IClientSecurity> pIClientSecurity (pInterface);

			if(pIClientSecurity)
			{
				DWORD dwAuthnSvc, dwAuthzSvc;

				if (SUCCEEDED(pIClientSecurity->QueryBlanket(
									pInterface, &dwAuthnSvc, &dwAuthzSvc, 
									NULL, NULL, NULL, NULL, NULL)))
				{
					dwAuthenticationArg = dwAuthnSvc;
					dwAuthorizationArg = dwAuthzSvc;
				}
			}
		}

		Logit(L"Authentication service is ");
		Logit(dwAuthenticationArg);
		Logit(L"");
		Logit(L"Authorization service is ");
		Logit(dwAuthorizationArg);
		Logit(L"");
				
	}
}

void CWmiSecurityHelper::GetAuthenticationLevel(
		IUnknown * pInterface,
		DWORD & dwAuthLevel)
{
	if(pInterface)
	{
		CComQIPtr<IClientSecurity> pIClientSecurity (pInterface);

		if(pIClientSecurity)
		{
			/*
			 * Yes I know we shouldn't need to ask for dwAuthnSvc,
			 * but on Whistler passing a NULL for this into 
			 * QueryBlanket causes an AV. Until we know why, or that
			 * gets fixed, this has to stay!
			 */
			DWORD dwAuthnSvc;
			DWORD dwAuthenticationLevel;

			if (SUCCEEDED(pIClientSecurity->QueryBlanket(
								pInterface, &dwAuthnSvc, NULL,  
								NULL, &dwAuthenticationLevel, 
								NULL, NULL, NULL)))
				dwAuthLevel = dwAuthenticationLevel;
		}

		Logit(L"Authentication level is ");
		Logit(dwAuthLevel);
		Logit(L"");
				
	}
}

STDMETHODIMP CWmiSecurityHelper::SetSecurity(boolean *pNeedToReset, HANDLE *pCurrentThreadToken)
{
	HRESULT hr = E_FAIL;
	CreateLogFile();
	Logit (L"\r\n\r\n>>Received SetSecurity request<<\r\n\r\n");

	if ((NULL != pNeedToReset) && (NULL != pCurrentThreadToken))
	{
		*pNeedToReset = false;
		*pCurrentThreadToken = NULL;

		// This is a NO-OP for Win9x
		if (IsNT())
		{
			if (4 >= GetNTMajorVersion ())
			{
				HANDLE threadToken;

				if (OpenThreadToken (GetCurrentThread(), TOKEN_QUERY|TOKEN_IMPERSONATE,
										true, &threadToken))
				{
					/*
					 * We are being called on an impersonated thread. Unfortunately
					 * in NT4.0 this means our impersonation token credentials will NOT
					 * be passed to WMI (only the process token credentials will be passed). 
					 * Rather than fool the user into thinking that they will, bail out
					 * now.
					 */
					Logit(L"Being called on Impersonated NT 4.0 thread!\r\n");
					CloseHandle (threadToken);
				}

				/*
				 * For NT 4.0 we have to enable the privileges on the process token.
				 */
				HANDLE hProcessToken = NULL;
				HANDLE hProcess = GetCurrentProcess ();

				if (OpenProcessToken (
						hProcess, 
						TOKEN_QUERY|TOKEN_ADJUST_PRIVILEGES,
						&hProcessToken))
				{
					Logit(L"Adjusting privileges on NT4 process token\r\n");
					if (AdjustPrivileges (hProcessToken))
						hr = S_OK;

					CloseHandle (hProcessToken);
				}

				CloseHandle (hProcess);
			}
			else
			{
				// For NT5.0 or later we set a new thread token
				HANDLE hToken;
				SECURITY_IMPERSONATION_LEVEL secImpLevel = SecurityImpersonation;
				boolean gotToken = false;

				if (gotToken = OpenThreadToken (
									GetCurrentThread(), 
									TOKEN_QUERY|TOKEN_DUPLICATE|TOKEN_IMPERSONATE,
									true,
									&hToken))
				{
					// Already have a thread token - save it and get its' imp Level
					*pCurrentThreadToken = hToken;
					DWORD dwReturnLength = 0;

					Logit(L"Duplicating NT5 thread token\r\n");
					BOOL thisRes = GetTokenInformation (
											hToken,
											TokenImpersonationLevel, 
											&secImpLevel,
											sizeof(SECURITY_IMPERSONATION_LEVEL),
											&dwReturnLength);
				}
				else
				{
					// No thread token - use process token as our source token
					HANDLE hProcess = GetCurrentProcess ();
					Logit(L"Duplicating NT5 process token\r\n");
					gotToken = OpenProcessToken (hProcess, TOKEN_QUERY|TOKEN_DUPLICATE, &hToken);
				}

				if (gotToken)
				{
					/* 
					 * Getting here means we have a valid token (process or thread).
					 * First we check whether we need to alter the privileges
					 */
					TOKEN_PRIVILEGES *tp = NULL;

					if (NULL != (tp = AdjustPrivileges(hToken)))
					{
						/* 
						 * We do - duplicate it before setting the adjusted privileges.
						 */
						HANDLE hDupToken;

						if (DuplicateToken (hToken, hDupToken, secImpLevel))
						{
							if (AdjustTokenPrivileges(hDupToken, FALSE, tp, 0, NULL, NULL))
							{
								// Set this token into the current thread
								if (SetThreadToken (NULL, hDupToken))
								{
									Logit(L"Succesfully set thread token\r\n");
									*pNeedToReset = true;
									hr = S_OK;
									// TODO - do we need to resecure the proxy at this point?
								}
								else
								{
									Logit(L"Setting new thread token FAILED!\r\n");
								}

								CloseHandle (hDupToken);
							}
							else
							{
								Logit(L"AdjustTokenPrivileges FAILED!\r\n");
							}
						}
						else
						{
							Logit(L"Token duplication FAILED!\r\n");
						}

						delete [] tp;
						tp = NULL;
					}
					else
					{
						Logit(L"No privilege adjustment made\r\n");
					}

					// If we have duplicated the process token we can close the original now
					// as we don't need it to restore it. If we have duplicated the thread token
					// then we must hang on to it as we will need to restore it later in
					// ResetSecurity.
					if (!(*pCurrentThreadToken))
						CloseHandle (hToken);
				}
			}
		}
		else
			hr = S_OK;	// Win9x
	}

	CloseLogFile();
	return hr;
}

TOKEN_PRIVILEGES *CWmiSecurityHelper::AdjustPrivileges (HANDLE hToken)
{
	DWORD adjustedCount = 0;
	DWORD dwSize = sizeof (TOKEN_PRIVILEGES);
	TOKEN_PRIVILEGES *tp = (TOKEN_PRIVILEGES *) new BYTE [dwSize];
	DWORD dwRequiredSize = 0;
	DWORD dwLastError = 0;
	
	// Get privilege info
	bool gotInfo = false;

	if (0 ==  GetTokenInformation (hToken, TokenPrivileges, 
						(LPVOID) tp, dwSize, &dwRequiredSize))
	{
		dwSize = dwRequiredSize;
		dwRequiredSize = 0;

		// Reallocate
		delete [] tp;
		tp = (TOKEN_PRIVILEGES *) new BYTE [dwSize];

		if (tp)
		{
			if (!GetTokenInformation (hToken, TokenPrivileges, 
							(LPVOID) tp, dwSize, &dwRequiredSize))
				dwLastError = GetLastError ();
			else
				gotInfo = true;
		}
	}
	else
		gotInfo = true;

	if (gotInfo)
	{
		// Enable the bally lot of them
		for (DWORD i = 0; i < tp->PrivilegeCount; i++)
		{
			DWORD dwAttrib = tp->Privileges[i].Attributes;

			if (0 == (dwAttrib & SE_PRIVILEGE_ENABLED))
			{
				tp->Privileges[i].Attributes |= SE_PRIVILEGE_ENABLED;
				adjustedCount++;
			}
		}

		Logit(L"Enabled ");
		Logit(adjustedCount);
		Logit(L"	privileges\r\n");
	}

	// If we didn't make any changes, clean up now. Otherwise tp will be deleted by the caller
	if (0 == adjustedCount)
	{
		if (tp)
		{
			delete [] tp;
			tp = NULL;
		}
	}

	return tp;
}

bool CWmiSecurityHelper::DuplicateToken(
	HANDLE hToken, 
	HANDLE &hDupToken,
	SECURITY_IMPERSONATION_LEVEL &secImpLevel)
{
	bool result = false;

	// DuplicateTokenEx won't exist on Win9x, so we need
	// this palaver to get at it
	BOOL (STDAPICALLTYPE *pfnDuplicateTokenEx) (
		HANDLE, 
		DWORD, 
		LPSECURITY_ATTRIBUTES,
		SECURITY_IMPERSONATION_LEVEL, 
		TOKEN_TYPE,
		PHANDLE
	) = NULL; 

	TCHAR	dllName [] = _T("\\advapi32.dll");
	LPTSTR  pszSysDir = new TCHAR[ MAX_PATH + _tcslen (dllName) ];

	if (pszSysDir)
	{
		UINT    uSize = GetSystemDirectory(pszSysDir, MAX_PATH);
		
		if(uSize > MAX_PATH) {
			delete[] pszSysDir;
			pszSysDir = new TCHAR[ uSize + _tcslen (dllName) ];
        	
			if (pszSysDir)
				uSize = GetSystemDirectory(pszSysDir, uSize);
		}

		if (pszSysDir)
		{
			lstrcat (pszSysDir, dllName);
			HINSTANCE hAdvapi = LoadLibraryEx (pszSysDir, NULL, 0);
			
			if (hAdvapi)
			{
				(FARPROC&) pfnDuplicateTokenEx = GetProcAddress(hAdvapi, "DuplicateTokenEx");

				if (pfnDuplicateTokenEx && 
					pfnDuplicateTokenEx (
						hToken, 
						TOKEN_QUERY|TOKEN_ADJUST_PRIVILEGES|TOKEN_IMPERSONATE,
						NULL,
						secImpLevel,
						TokenImpersonation,
						&hDupToken))
				{
					result = true;
				}

				FreeLibrary (hAdvapi);
			}

			delete [] pszSysDir;
		}
	}
				
	return result;
}

STDMETHODIMP CWmiSecurityHelper::ResetSecurity(HANDLE hToken)
{
	CreateLogFile();
	Logit (L"\r\n\r\n>>Received ResetSecurity request<<\r\n\r\n");

	if (IsNT())
	{
		/* 
		 * Set the supplied token (which may be NULL) into
		 * the current thread.
		 */
		if (FALSE == SetThreadToken (NULL, hToken))
		{
			Logit(L"Failure to reset thread token");
		}
		else
		{
			Logit(L"Successfully set thread token");
		}

		if (hToken)
			CloseHandle (hToken);
	}

	CloseLogFile();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wmisec\wmisecurityhelper.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

// WmiSecurityHelper.h : Declaration of the CWmiSecurityHelper

#ifndef __WMISECURITYHELPER_H_
#define __WMISECURITYHELPER_H_

#include "resource.h"       // main symbols

#define WMISEC_AUTH_LEVEL_UNCHANGED	0xFFFFFFFF

/////////////////////////////////////////////////////////////////////////////
// CWmiSecurityHelper
class ATL_NO_VTABLE CWmiSecurityHelper : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CWmiSecurityHelper, &CLSID_WmiSecurityHelper>,
	public IWmiSecurityHelper
{
private:
	bool		m_bIsNT;
	bool		m_bIsKerberosAvailable;
	DWORD		m_dwNTMajorVersion;

	DWORD		GetCapabilities (BSTR bsUser);

	bool		IsNT () const { return m_bIsNT; }

	DWORD		GetNTMajorVersion () const { return m_dwNTMajorVersion; } 

	bool		IsKerberosAvailable() const { return m_bIsKerberosAvailable; }

	bool		CanUseDefaultInfo (IUnknown *pUnk);

	void		GetCurrValue(
					IUnknown * pFrom,
					DWORD & dwAuthenticationArg, 
					DWORD & dwAuthorizationArg);

	void		GetAuthenticationLevel(
					IUnknown * pFrom,
					DWORD & dwAuthenticationLevel);

	HRESULT		SetInterfaceSecurity(
					IUnknown * pInterface, 
					CComBSTR bsAuthority, 
					CComBSTR bsUser, 
					CComBSTR bsPassword,
					DWORD dwAuthLevel, 
					DWORD dwImpLevel, 
					DWORD dwCapabilities,
					bool bGetInfoFirst);

	HRESULT		SetProxyBlanket(
					IUnknown                 *pInterface,
					DWORD                     dwAuthnSvc,
					DWORD                     dwAuthzSvc,
					CComBSTR                  &bsServerPrincName,
					DWORD                     dwAuthLevel,
					DWORD                     dwImpLevel,
					RPC_AUTH_IDENTITY_HANDLE  pAuthInfo,
					DWORD                     dwCapabilities);

	static void	FreeAuthIdentity( COAUTHIDENTITY* pAuthIdentity );
	bool		AllocAuthIdentity( 
					CComBSTR & bsUser, 
					CComBSTR & bsPassword, 
					CComBSTR & bsDomain, 
					COAUTHIDENTITY** ppAuthIdent );
	bool		DetermineLoginType(
					CComBSTR & bsAuthArg, 
					CComBSTR & bsUserArg,
					CComBSTR & bsPrincipalArg,
					CComBSTR & bsAuthority,
					CComBSTR & bsUser);
	bool		DetermineLoginType(
					CComBSTR & bsAuthArg, 
					CComBSTR & bsUserArg,
					CComBSTR & bsAuthority,
					CComBSTR & bsUser);
	static bool DoesContainCredentials( COAUTHIDENTITY* pAuthIdentity );
	static bool DuplicateToken (HANDLE hOrigToken, HANDLE & hDupToken,
					SECURITY_IMPERSONATION_LEVEL &secImpLevel);
	static TOKEN_PRIVILEGES *AdjustPrivileges (HANDLE hToken);

public:
	CWmiSecurityHelper()
	{
		m_pUnkMarshaler = NULL;

		OSVERSIONINFO	osVersionInfo;
		osVersionInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
		GetVersionEx (&osVersionInfo);

		m_bIsNT = (VER_PLATFORM_WIN32_NT == osVersionInfo.dwPlatformId);
		m_dwNTMajorVersion = osVersionInfo.dwMajorVersion;
		// IMPORTANT!! This will need to be chanted if Kerberos is ever ported to 98
		m_bIsKerberosAvailable = m_bIsNT && (m_dwNTMajorVersion >= 5) ;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_WMISECURITYHELPER)
DECLARE_NOT_AGGREGATABLE(CWmiSecurityHelper)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CWmiSecurityHelper)
	COM_INTERFACE_ENTRY(IWmiSecurityHelper)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

// IWmiSecurityHelper
public:
	STDMETHOD(ResetSecurity)(/*[in]*/ HANDLE hToken);
	STDMETHOD(SetSecurity)(/*[out]*/ boolean *pNeedToReset, /*[out]*/HANDLE *pHandle);
	STDMETHOD(BlessIWbemServices)(/*[in,out]*/ IWbemServices **ppIWbemServices, 
		 /*[in]*/ BSTR strUser, /*[in]*/ BSTR strPassword,
		/*[in]*/ BSTR strAuthority, /*[in]*/ DWORD impersonationLevel, /*[in]*/ DWORD authenticationLevel);
	STDMETHOD(BlessIEnumWbemClassObject)(/*[in,out]*/ IEnumWbemClassObject **ppIEnumWbemClassObject, 
		 /*[in]*/ BSTR strUser, /*[in]*/ BSTR strPassword,
		/*[in]*/ BSTR strAuthority, /*[in]*/ DWORD impersonationLevel, /*[in]*/ DWORD authenticationLevel);
	STDMETHOD(BlessIWbemCallResult)(/*[in,out]*/ IWbemCallResult **ppIWbemCallResult, 
		 /*[in]*/ BSTR strUser, /*[in]*/ BSTR strPassword,
		/*[in]*/ BSTR strAuthority, /*[in]*/ DWORD impersonationLevel, /*[in]*/ DWORD authenticationLevel);

private:
	HRESULT SetImpersonate (IUnknown *pIUnknown);
};

#endif //__WMISECURITYHELPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wmisec\wmisinkdemultiplexor.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// WmiSinkDemultiplexor.cpp : Implementation of CWmiSinkDemultiplexor
#include "stdafx.h"
#include "wbemcli.h"
#include "Wmisec.h"
#include "WmiSinkDemultiplexor.h"

/////////////////////////////////////////////////////////////////////////////
// CWmiSinkDemultiplexor


STDMETHODIMP CWmiSinkDemultiplexor::GetDemultiplexedStub(IUnknown *pObject, IUnknown **ppObject)
{
	HRESULT hr = E_FAIL;
	
	// TODO - thread safety!

	// Only call this once!
#if 0
	if (pObject && ppObject && !m_pIWbemObjectSink)
#else
	if (pObject && ppObject)
#endif
	{
		// Try and QI for the IWmiEventSource interface
		CComPtr<IWmiEventSource> pIWmiEventSource;

		if (SUCCEEDED(pObject->QueryInterface(IID_IWmiEventSource, (LPVOID*) &pIWmiEventSource)))
		{
			// We got it - make a new object sink for it
#if 0
			m_pIWbemObjectSink = new InternalWbemObjectSink (pIWmiEventSource);

			if (m_pIWbemObjectSink)
			{
				m_pIWbemObjectSink->AddRef();

				// Lazily construct the unsecured apartment
				CComPtr<IUnsecuredApartment> pIUnsecuredApartment;

				if (SUCCEEDED(CoCreateInstance(CLSID_UnsecuredApartment, 0,  CLSCTX_ALL,
									 IID_IUnsecuredApartment, (LPVOID *) &pIUnsecuredApartment)))
				{
					CComPtr<IUnknown>	pIUnknownIn;

					if (SUCCEEDED(m_pIWbemObjectSink->QueryInterface (IID_IUnknown, (LPVOID*) &pIUnknownIn)))
					{
						CComPtr<IUnknown>	pIUnknown;

						if (SUCCEEDED (hr = pIUnsecuredApartment->CreateObjectStub(pIUnknownIn, &pIUnknown)))
						{
							// Ensure we QI for IWbemObjectSink
							hr = pIUnknown->QueryInterface (IID_IWbemObjectSink, (LPVOID*) ppObject);
						}
					}
				}
			}
#else
			InternalWbemObjectSink *pInternalWbemObjectSink = new InternalWbemObjectSink (pIWmiEventSource);

			if (pInternalWbemObjectSink)
			{
				CComPtr<IUnknown>		pIUnknownIn;

				if (SUCCEEDED(pInternalWbemObjectSink->QueryInterface (IID_IUnknown, (LPVOID*) &pIUnknownIn)))
				{
					CComPtr<IUnsecuredApartment> pIUnsecuredApartment;

					if (SUCCEEDED(CoCreateInstance(CLSID_UnsecuredApartment, 0,  CLSCTX_ALL,
										 IID_IUnsecuredApartment, (LPVOID *) &pIUnsecuredApartment)))
					{
						CComPtr<IUnknown>	pIUnknownOut;

						if (SUCCEEDED (hr = pIUnsecuredApartment->CreateObjectStub(pIUnknownIn, &pIUnknownOut)))
						{
							// Ensure we QI for IWbemObjectSink
							hr = pIUnknownOut->QueryInterface (IID_IWbemObjectSink, (LPVOID*) ppObject);
						}
					}
				}
			}
#endif
				
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\utils\wmisec\wbemcli.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0334 */
/* Compiler settings for wbemcli.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wbemcli_h__
#define __wbemcli_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWbemClassObject_FWD_DEFINED__
#define __IWbemClassObject_FWD_DEFINED__
typedef interface IWbemClassObject IWbemClassObject;
#endif 	/* __IWbemClassObject_FWD_DEFINED__ */


#ifndef __IWbemClassObjectEx_FWD_DEFINED__
#define __IWbemClassObjectEx_FWD_DEFINED__
typedef interface IWbemClassObjectEx IWbemClassObjectEx;
#endif 	/* __IWbemClassObjectEx_FWD_DEFINED__ */


#ifndef __IWbemObjectAccess_FWD_DEFINED__
#define __IWbemObjectAccess_FWD_DEFINED__
typedef interface IWbemObjectAccess IWbemObjectAccess;
#endif 	/* __IWbemObjectAccess_FWD_DEFINED__ */


#ifndef __IWbemQualifierSet_FWD_DEFINED__
#define __IWbemQualifierSet_FWD_DEFINED__
typedef interface IWbemQualifierSet IWbemQualifierSet;
#endif 	/* __IWbemQualifierSet_FWD_DEFINED__ */


#ifndef __IWbemServices_FWD_DEFINED__
#define __IWbemServices_FWD_DEFINED__
typedef interface IWbemServices IWbemServices;
#endif 	/* __IWbemServices_FWD_DEFINED__ */


#ifndef __IWbemServicesEx_FWD_DEFINED__
#define __IWbemServicesEx_FWD_DEFINED__
typedef interface IWbemServicesEx IWbemServicesEx;
#endif 	/* __IWbemServicesEx_FWD_DEFINED__ */


#ifndef __IWbemLocator_FWD_DEFINED__
#define __IWbemLocator_FWD_DEFINED__
typedef interface IWbemLocator IWbemLocator;
#endif 	/* __IWbemLocator_FWD_DEFINED__ */


#ifndef __IWbemConnection_FWD_DEFINED__
#define __IWbemConnection_FWD_DEFINED__
typedef interface IWbemConnection IWbemConnection;
#endif 	/* __IWbemConnection_FWD_DEFINED__ */


#ifndef __IWbemObjectSink_FWD_DEFINED__
#define __IWbemObjectSink_FWD_DEFINED__
typedef interface IWbemObjectSink IWbemObjectSink;
#endif 	/* __IWbemObjectSink_FWD_DEFINED__ */


#ifndef __IEnumWbemClassObject_FWD_DEFINED__
#define __IEnumWbemClassObject_FWD_DEFINED__
typedef interface IEnumWbemClassObject IEnumWbemClassObject;
#endif 	/* __IEnumWbemClassObject_FWD_DEFINED__ */


#ifndef __IWbemCallResult_FWD_DEFINED__
#define __IWbemCallResult_FWD_DEFINED__
typedef interface IWbemCallResult IWbemCallResult;
#endif 	/* __IWbemCallResult_FWD_DEFINED__ */


#ifndef __IWbemCallResultEx_FWD_DEFINED__
#define __IWbemCallResultEx_FWD_DEFINED__
typedef interface IWbemCallResultEx IWbemCallResultEx;
#endif 	/* __IWbemCallResultEx_FWD_DEFINED__ */


#ifndef __IWbemContext_FWD_DEFINED__
#define __IWbemContext_FWD_DEFINED__
typedef interface IWbemContext IWbemContext;
#endif 	/* __IWbemContext_FWD_DEFINED__ */


#ifndef __IUnsecuredApartment_FWD_DEFINED__
#define __IUnsecuredApartment_FWD_DEFINED__
typedef interface IUnsecuredApartment IUnsecuredApartment;
#endif 	/* __IUnsecuredApartment_FWD_DEFINED__ */


#ifndef __IWbemStatusCodeText_FWD_DEFINED__
#define __IWbemStatusCodeText_FWD_DEFINED__
typedef interface IWbemStatusCodeText IWbemStatusCodeText;
#endif 	/* __IWbemStatusCodeText_FWD_DEFINED__ */


#ifndef __IWbemBackupRestore_FWD_DEFINED__
#define __IWbemBackupRestore_FWD_DEFINED__
typedef interface IWbemBackupRestore IWbemBackupRestore;
#endif 	/* __IWbemBackupRestore_FWD_DEFINED__ */


#ifndef __IWbemRefresher_FWD_DEFINED__
#define __IWbemRefresher_FWD_DEFINED__
typedef interface IWbemRefresher IWbemRefresher;
#endif 	/* __IWbemRefresher_FWD_DEFINED__ */


#ifndef __IWbemHiPerfEnum_FWD_DEFINED__
#define __IWbemHiPerfEnum_FWD_DEFINED__
typedef interface IWbemHiPerfEnum IWbemHiPerfEnum;
#endif 	/* __IWbemHiPerfEnum_FWD_DEFINED__ */


#ifndef __IWbemConfigureRefresher_FWD_DEFINED__
#define __IWbemConfigureRefresher_FWD_DEFINED__
typedef interface IWbemConfigureRefresher IWbemConfigureRefresher;
#endif 	/* __IWbemConfigureRefresher_FWD_DEFINED__ */


#ifndef __IWbemSecureObjectSink_FWD_DEFINED__
#define __IWbemSecureObjectSink_FWD_DEFINED__
typedef interface IWbemSecureObjectSink IWbemSecureObjectSink;
#endif 	/* __IWbemSecureObjectSink_FWD_DEFINED__ */


#ifndef __IWbemEventSink_FWD_DEFINED__
#define __IWbemEventSink_FWD_DEFINED__
typedef interface IWbemEventSink IWbemEventSink;
#endif 	/* __IWbemEventSink_FWD_DEFINED__ */


#ifndef __IWbemObjectSinkEx_FWD_DEFINED__
#define __IWbemObjectSinkEx_FWD_DEFINED__
typedef interface IWbemObjectSinkEx IWbemObjectSinkEx;
#endif 	/* __IWbemObjectSinkEx_FWD_DEFINED__ */


#ifndef __WbemLocator_FWD_DEFINED__
#define __WbemLocator_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemLocator WbemLocator;
#else
typedef struct WbemLocator WbemLocator;
#endif /* __cplusplus */

#endif 	/* __WbemLocator_FWD_DEFINED__ */


#ifndef __WbemConnection_FWD_DEFINED__
#define __WbemConnection_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemConnection WbemConnection;
#else
typedef struct WbemConnection WbemConnection;
#endif /* __cplusplus */

#endif 	/* __WbemConnection_FWD_DEFINED__ */


#ifndef __WbemContext_FWD_DEFINED__
#define __WbemContext_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemContext WbemContext;
#else
typedef struct WbemContext WbemContext;
#endif /* __cplusplus */

#endif 	/* __WbemContext_FWD_DEFINED__ */


#ifndef __UnsecuredApartment_FWD_DEFINED__
#define __UnsecuredApartment_FWD_DEFINED__

#ifdef __cplusplus
typedef class UnsecuredApartment UnsecuredApartment;
#else
typedef struct UnsecuredApartment UnsecuredApartment;
#endif /* __cplusplus */

#endif 	/* __UnsecuredApartment_FWD_DEFINED__ */


#ifndef __WbemClassObject_FWD_DEFINED__
#define __WbemClassObject_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemClassObject WbemClassObject;
#else
typedef struct WbemClassObject WbemClassObject;
#endif /* __cplusplus */

#endif 	/* __WbemClassObject_FWD_DEFINED__ */


#ifndef __MofCompiler_FWD_DEFINED__
#define __MofCompiler_FWD_DEFINED__

#ifdef __cplusplus
typedef class MofCompiler MofCompiler;
#else
typedef struct MofCompiler MofCompiler;
#endif /* __cplusplus */

#endif 	/* __MofCompiler_FWD_DEFINED__ */


#ifndef __WbemStatusCodeText_FWD_DEFINED__
#define __WbemStatusCodeText_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemStatusCodeText WbemStatusCodeText;
#else
typedef struct WbemStatusCodeText WbemStatusCodeText;
#endif /* __cplusplus */

#endif 	/* __WbemStatusCodeText_FWD_DEFINED__ */


#ifndef __WbemBackupRestore_FWD_DEFINED__
#define __WbemBackupRestore_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemBackupRestore WbemBackupRestore;
#else
typedef struct WbemBackupRestore WbemBackupRestore;
#endif /* __cplusplus */

#endif 	/* __WbemBackupRestore_FWD_DEFINED__ */


#ifndef __WbemRefresher_FWD_DEFINED__
#define __WbemRefresher_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemRefresher WbemRefresher;
#else
typedef struct WbemRefresher WbemRefresher;
#endif /* __cplusplus */

#endif 	/* __WbemRefresher_FWD_DEFINED__ */


#ifndef __WbemObjectTextSrc_FWD_DEFINED__
#define __WbemObjectTextSrc_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemObjectTextSrc WbemObjectTextSrc;
#else
typedef struct WbemObjectTextSrc WbemObjectTextSrc;
#endif /* __cplusplus */

#endif 	/* __WbemObjectTextSrc_FWD_DEFINED__ */


#ifndef __IWbemClassObject_FWD_DEFINED__
#define __IWbemClassObject_FWD_DEFINED__
typedef interface IWbemClassObject IWbemClassObject;
#endif 	/* __IWbemClassObject_FWD_DEFINED__ */


#ifndef __IWbemClassObjectEx_FWD_DEFINED__
#define __IWbemClassObjectEx_FWD_DEFINED__
typedef interface IWbemClassObjectEx IWbemClassObjectEx;
#endif 	/* __IWbemClassObjectEx_FWD_DEFINED__ */


#ifndef __IWbemQualifierSet_FWD_DEFINED__
#define __IWbemQualifierSet_FWD_DEFINED__
typedef interface IWbemQualifierSet IWbemQualifierSet;
#endif 	/* __IWbemQualifierSet_FWD_DEFINED__ */


#ifndef __IWbemLocator_FWD_DEFINED__
#define __IWbemLocator_FWD_DEFINED__
typedef interface IWbemLocator IWbemLocator;
#endif 	/* __IWbemLocator_FWD_DEFINED__ */


#ifndef __IWbemConnection_FWD_DEFINED__
#define __IWbemConnection_FWD_DEFINED__
typedef interface IWbemConnection IWbemConnection;
#endif 	/* __IWbemConnection_FWD_DEFINED__ */


#ifndef __IWbemObjectSink_FWD_DEFINED__
#define __IWbemObjectSink_FWD_DEFINED__
typedef interface IWbemObjectSink IWbemObjectSink;
#endif 	/* __IWbemObjectSink_FWD_DEFINED__ */


#ifndef __IEnumWbemClassObject_FWD_DEFINED__
#define __IEnumWbemClassObject_FWD_DEFINED__
typedef interface IEnumWbemClassObject IEnumWbemClassObject;
#endif 	/* __IEnumWbemClassObject_FWD_DEFINED__ */


#ifndef __IWbemContext_FWD_DEFINED__
#define __IWbemContext_FWD_DEFINED__
typedef interface IWbemContext IWbemContext;
#endif 	/* __IWbemContext_FWD_DEFINED__ */


#ifndef __IWbemCallResult_FWD_DEFINED__
#define __IWbemCallResult_FWD_DEFINED__
typedef interface IWbemCallResult IWbemCallResult;
#endif 	/* __IWbemCallResult_FWD_DEFINED__ */


#ifndef __IWbemServices_FWD_DEFINED__
#define __IWbemServices_FWD_DEFINED__
typedef interface IWbemServices IWbemServices;
#endif 	/* __IWbemServices_FWD_DEFINED__ */


#ifndef __IWbemServicesEx_FWD_DEFINED__
#define __IWbemServicesEx_FWD_DEFINED__
typedef interface IWbemServicesEx IWbemServicesEx;
#endif 	/* __IWbemServicesEx_FWD_DEFINED__ */


#ifndef __IWbemComBinding_FWD_DEFINED__
#define __IWbemComBinding_FWD_DEFINED__
typedef interface IWbemComBinding IWbemComBinding;
#endif 	/* __IWbemComBinding_FWD_DEFINED__ */


#ifndef __IWbemInitComBinding_FWD_DEFINED__
#define __IWbemInitComBinding_FWD_DEFINED__
typedef interface IWbemInitComBinding IWbemInitComBinding;
#endif 	/* __IWbemInitComBinding_FWD_DEFINED__ */


#ifndef __IWbemCallResultEx_FWD_DEFINED__
#define __IWbemCallResultEx_FWD_DEFINED__
typedef interface IWbemCallResultEx IWbemCallResultEx;
#endif 	/* __IWbemCallResultEx_FWD_DEFINED__ */


#ifndef __IWbemRawSdAccessor_FWD_DEFINED__
#define __IWbemRawSdAccessor_FWD_DEFINED__
typedef interface IWbemRawSdAccessor IWbemRawSdAccessor;
#endif 	/* __IWbemRawSdAccessor_FWD_DEFINED__ */


#ifndef __IWbemObjectSinkEx_FWD_DEFINED__
#define __IWbemObjectSinkEx_FWD_DEFINED__
typedef interface IWbemObjectSinkEx IWbemObjectSinkEx;
#endif 	/* __IWbemObjectSinkEx_FWD_DEFINED__ */


#ifndef __IWbemShutdown_FWD_DEFINED__
#define __IWbemShutdown_FWD_DEFINED__
typedef interface IWbemShutdown IWbemShutdown;
#endif 	/* __IWbemShutdown_FWD_DEFINED__ */


#ifndef __IWbemCallStatus_FWD_DEFINED__
#define __IWbemCallStatus_FWD_DEFINED__
typedef interface IWbemCallStatus IWbemCallStatus;
#endif 	/* __IWbemCallStatus_FWD_DEFINED__ */


#ifndef __IWbemObjectTextSrc_FWD_DEFINED__
#define __IWbemObjectTextSrc_FWD_DEFINED__
typedef interface IWbemObjectTextSrc IWbemObjectTextSrc;
#endif 	/* __IWbemObjectTextSrc_FWD_DEFINED__ */


#ifndef __IWbemObjectAccess_FWD_DEFINED__
#define __IWbemObjectAccess_FWD_DEFINED__
typedef interface IWbemObjectAccess IWbemObjectAccess;
#endif 	/* __IWbemObjectAccess_FWD_DEFINED__ */


#ifndef __IWbemTransaction_FWD_DEFINED__
#define __IWbemTransaction_FWD_DEFINED__
typedef interface IWbemTransaction IWbemTransaction;
#endif 	/* __IWbemTransaction_FWD_DEFINED__ */


#ifndef __IMofCompiler_FWD_DEFINED__
#define __IMofCompiler_FWD_DEFINED__
typedef interface IMofCompiler IMofCompiler;
#endif 	/* __IMofCompiler_FWD_DEFINED__ */


#ifndef __IUnsecuredApartment_FWD_DEFINED__
#define __IUnsecuredApartment_FWD_DEFINED__
typedef interface IUnsecuredApartment IUnsecuredApartment;
#endif 	/* __IUnsecuredApartment_FWD_DEFINED__ */


#ifndef __IWbemStatusCodeText_FWD_DEFINED__
#define __IWbemStatusCodeText_FWD_DEFINED__
typedef interface IWbemStatusCodeText IWbemStatusCodeText;
#endif 	/* __IWbemStatusCodeText_FWD_DEFINED__ */


#ifndef __IWbemBackupRestore_FWD_DEFINED__
#define __IWbemBackupRestore_FWD_DEFINED__
typedef interface IWbemBackupRestore IWbemBackupRestore;
#endif 	/* __IWbemBackupRestore_FWD_DEFINED__ */


#ifndef __IWbemRefresher_FWD_DEFINED__
#define __IWbemRefresher_FWD_DEFINED__
typedef interface IWbemRefresher IWbemRefresher;
#endif 	/* __IWbemRefresher_FWD_DEFINED__ */


#ifndef __IWbemHiPerfEnum_FWD_DEFINED__
#define __IWbemHiPerfEnum_FWD_DEFINED__
typedef interface IWbemHiPerfEnum IWbemHiPerfEnum;
#endif 	/* __IWbemHiPerfEnum_FWD_DEFINED__ */


#ifndef __IWbemConfigureRefresher_FWD_DEFINED__
#define __IWbemConfigureRefresher_FWD_DEFINED__
typedef interface IWbemConfigureRefresher IWbemConfigureRefresher;
#endif 	/* __IWbemConfigureRefresher_FWD_DEFINED__ */


#ifndef __IWbemSecureObjectSink_FWD_DEFINED__
#define __IWbemSecureObjectSink_FWD_DEFINED__
typedef interface IWbemSecureObjectSink IWbemSecureObjectSink;
#endif 	/* __IWbemSecureObjectSink_FWD_DEFINED__ */


#ifndef __IWbemEventSink_FWD_DEFINED__
#define __IWbemEventSink_FWD_DEFINED__
typedef interface IWbemEventSink IWbemEventSink;
#endif 	/* __IWbemEventSink_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 


#ifndef __WbemClient_v1_LIBRARY_DEFINED__
#define __WbemClient_v1_LIBRARY_DEFINED__

/* library WbemClient_v1 */
/* [uuid] */ 























typedef /* [v1_enum] */ 
enum tag_WBEM_GENUS_TYPE
    {	WBEM_GENUS_CLASS	= 1,
	WBEM_GENUS_INSTANCE	= 2
    } 	WBEM_GENUS_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_CHANGE_FLAG_TYPE
    {	WBEM_FLAG_CREATE_OR_UPDATE	= 0,
	WBEM_FLAG_UPDATE_ONLY	= 0x1,
	WBEM_FLAG_CREATE_ONLY	= 0x2,
	WBEM_FLAG_UPDATE_COMPATIBLE	= 0,
	WBEM_FLAG_UPDATE_SAFE_MODE	= 0x20,
	WBEM_FLAG_UPDATE_FORCE_MODE	= 0x40,
	WBEM_MASK_UPDATE_MODE	= 0x60,
	WBEM_FLAG_ADVISORY	= 0x10000
    } 	WBEM_CHANGE_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_GENERIC_FLAG_TYPE
    {	WBEM_FLAG_RETURN_IMMEDIATELY	= 0x10,
	WBEM_FLAG_RETURN_WBEM_COMPLETE	= 0,
	WBEM_FLAG_BIDIRECTIONAL	= 0,
	WBEM_FLAG_FORWARD_ONLY	= 0x20,
	WBEM_FLAG_NO_ERROR_OBJECT	= 0x40,
	WBEM_FLAG_RETURN_ERROR_OBJECT	= 0,
	WBEM_FLAG_SEND_STATUS	= 0x80,
	WBEM_FLAG_DONT_SEND_STATUS	= 0,
	WBEM_FLAG_ENSURE_LOCATABLE	= 0x100,
	WBEM_FLAG_DIRECT_READ	= 0x200,
	WBEM_FLAG_SEND_ONLY_SELECTED	= 0,
	WBEM_RETURN_WHEN_COMPLETE	= 0,
	WBEM_RETURN_IMMEDIATELY	= 0x10,
	WBEM_MASK_RESERVED_FLAGS	= 0x1f000,
	WBEM_FLAG_USE_AMENDED_QUALIFIERS	= 0x20000,
	WBEM_FLAG_USE_SECURITY_DESCRIPTOR	= 0x40000,
	WBEM_FLAG_REMOVE_CHILD_SECURITY	= 0x80000,
	WBEM_FLAG_STRONG_VALIDATION	= 0x100000
    } 	WBEM_GENERIC_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_NOTIFICATION_FLAG_TYPE
    {	WBEM_FLAG_MONITOR	= 0x800
    } 	WBEM_NOTIFICATION_FLAG_TYPE;

typedef 
enum tag_WBEM_STATUS_TYPE
    {	WBEM_STATUS_COMPLETE	= 0,
	WBEM_STATUS_REQUIREMENTS	= 1,
	WBEM_STATUS_PROGRESS	= 2
    } 	WBEM_STATUS_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_TIMEOUT_TYPE
    {	WBEM_NO_WAIT	= 0,
	WBEM_INFINITE	= 0xffffffff
    } 	WBEM_TIMEOUT_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_CONDITION_FLAG_TYPE
    {	WBEM_FLAG_ALWAYS	= 0,
	WBEM_FLAG_ONLY_IF_TRUE	= 0x1,
	WBEM_FLAG_ONLY_IF_FALSE	= 0x2,
	WBEM_FLAG_ONLY_IF_IDENTICAL	= 0x3,
	WBEM_MASK_PRIMARY_CONDITION	= 0x3,
	WBEM_FLAG_KEYS_ONLY	= 0x4,
	WBEM_FLAG_REFS_ONLY	= 0x8,
	WBEM_FLAG_LOCAL_ONLY	= 0x10,
	WBEM_FLAG_PROPAGATED_ONLY	= 0x20,
	WBEM_FLAG_SYSTEM_ONLY	= 0x30,
	WBEM_FLAG_NONSYSTEM_ONLY	= 0x40,
	WBEM_MASK_CONDITION_ORIGIN	= 0x70,
	WBEM_FLAG_CLASS_OVERRIDES_ONLY	= 0x100,
	WBEM_FLAG_CLASS_LOCAL_AND_OVERRIDES	= 0x200,
	WBEM_MASK_CLASS_CONDITION	= 0x300
    } 	WBEM_CONDITION_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_FLAVOR_TYPE
    {	WBEM_FLAVOR_DONT_PROPAGATE	= 0,
	WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE	= 0x1,
	WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS	= 0x2,
	WBEM_FLAVOR_MASK_PROPAGATION	= 0xf,
	WBEM_FLAVOR_OVERRIDABLE	= 0,
	WBEM_FLAVOR_NOT_OVERRIDABLE	= 0x10,
	WBEM_FLAVOR_MASK_PERMISSIONS	= 0x10,
	WBEM_FLAVOR_ORIGIN_LOCAL	= 0,
	WBEM_FLAVOR_ORIGIN_PROPAGATED	= 0x20,
	WBEM_FLAVOR_ORIGIN_SYSTEM	= 0x40,
	WBEM_FLAVOR_MASK_ORIGIN	= 0x60,
	WBEM_FLAVOR_NOT_AMENDED	= 0,
	WBEM_FLAVOR_AMENDED	= 0x80,
	WBEM_FLAVOR_MASK_AMENDED	= 0x80
    } 	WBEM_FLAVOR_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_QUERY_FLAG_TYPE
    {	WBEM_FLAG_DEEP	= 0,
	WBEM_FLAG_SHALLOW	= 1,
	WBEM_FLAG_PROTOTYPE	= 2
    } 	WBEM_QUERY_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_SECURITY_FLAGS
    {	WBEM_ENABLE	= 1,
	WBEM_METHOD_EXECUTE	= 2,
	WBEM_FULL_WRITE_REP	= 4,
	WBEM_PARTIAL_WRITE_REP	= 8,
	WBEM_WRITE_PROVIDER	= 0x10,
	WBEM_REMOTE_ACCESS	= 0x20,
	WBEM_RIGHT_SUBSCRIBE	= 0x40
    } 	WBEM_SECURITY_FLAGS;

typedef /* [v1_enum] */ 
enum tag_WBEM_LIMITATION_FLAG_TYPE
    {	WBEM_FLAG_EXCLUDE_OBJECT_QUALIFIERS	= 0x10,
	WBEM_FLAG_EXCLUDE_PROPERTY_QUALIFIERS	= 0x20
    } 	WBEM_LIMITATION_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_TEXT_FLAG_TYPE
    {	WBEM_FLAG_NO_FLAVORS	= 0x1
    } 	WBEM_TEXT_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_COMPARISON_FLAG
    {	WBEM_COMPARISON_INCLUDE_ALL	= 0,
	WBEM_FLAG_IGNORE_QUALIFIERS	= 0x1,
	WBEM_FLAG_IGNORE_OBJECT_SOURCE	= 0x2,
	WBEM_FLAG_IGNORE_DEFAULT_VALUES	= 0x4,
	WBEM_FLAG_IGNORE_CLASS	= 0x8,
	WBEM_FLAG_IGNORE_CASE	= 0x10,
	WBEM_FLAG_IGNORE_FLAVOR	= 0x20
    } 	WBEM_COMPARISON_FLAG;

typedef /* [v1_enum] */ 
enum tag_WBEM_LOCKING
    {	WBEM_FLAG_ALLOW_READ	= 0x1
    } 	WBEM_LOCKING_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_CONNECT
    {	WBEM_FLAG_CREDENTIALS_SPECIFIED	= 0x1,
	WBEM_FLAG_CONNECT_SETUP_MODE	= 0x2,
	WBEM_FLAG_CONNECT_CIM_COMPLIANCE_MODE	= 0x4,
	WBEM_FLAG_OPEN_COLLECTION	= 0x10,
	WBEM_FLAG_OPEN_SCOPE	= 0x20,
	WBEM_FLAG_OPEN_NESTED_ONLY	= 0x40,
	WBEM_FLAG_OPEN_NAMESPACE	= 0x80,
	WBEM_FLAG_OPEN_VECTOR	= 0x100,
	WBEM_FLAG_OPEN_ALLOW_NS_TRAVERSAL	= 0x200,
	WBEM_FLAG_OPEN_ALLOW_MACHINE_TRAVERSAL	= 0x400
    } 	WBEM_CONNECT_FLAG_TYPE;

typedef /* [v1_enum] */ 
enum tag_WBEM_GET_FLAGS
    {	WBEM_FLAG_GET_DEFAULT	= 0,
	WBEM_FLAG_SPAWN_INSTANCE	= 0x1
    } 	WBEM_GET_FLAGS;

typedef /* [v1_enum] */ 
enum tag_WBEM_PUT_FLAGS
    {	WBEM_FLAG_USE_CURRENT_TIME	= 0x1
    } 	WBEM_PUT_FLAGS;

typedef /* [v1_enum] */ 
enum tag_WBEM_PUTEX_FLAGS
    {	WBEM_FLAG_PUTEX_APPEND	= 0,
	WBEM_FLAG_PUTEX_INSERTAT	= 0x1,
	WBEM_MASK_PUTEX_OPERATION	= 0x1
    } 	WBEM_PUTEX_FLAGS;

typedef /* [v1_enum] */ 
enum tag_WBEM_DELETEEX_FLAGS
    {	WBEM_FLAG_PUTEX_DELETE	= 0,
	WBEM_FLAG_PUTEX_DELETE_FIRST_MATCH	= 0x1,
	WBEM_FLAG_DELETE_ALL_MATCHES	= 0x2,
	WBEM_MASK_DELETEEX_OPERATION	= 0x2
    } 	WBEM_DELETEEX_FLAGS;

typedef /* [v1_enum] */ 
enum tag_WBEM_MULTI_FLAG
    {	WBEM_MULTI_FLAG_NO_OP	= 0,
	WBEM_MULTI_FLAG_ARRAY_ALL	= 0x1,
	WBEM_MULTI_FLAG_ARRAY_SUBRANGE	= 0x2
    } 	WBEM_MULTI_FLAG;

typedef /* [v1_enum] */ 
enum tag_CIMTYPE_ENUMERATION
    {	CIM_ILLEGAL	= 0xfff,
	CIM_EMPTY	= 0,
	CIM_SINT8	= 16,
	CIM_UINT8	= 17,
	CIM_SINT16	= 2,
	CIM_UINT16	= 18,
	CIM_SINT32	= 3,
	CIM_UINT32	= 19,
	CIM_SINT64	= 20,
	CIM_UINT64	= 21,
	CIM_REAL32	= 4,
	CIM_REAL64	= 5,
	CIM_BOOLEAN	= 11,
	CIM_STRING	= 8,
	CIM_DATETIME	= 101,
	CIM_REFERENCE	= 102,
	CIM_CHAR16	= 103,
	CIM_OBJECT	= 13,
	CIM_IUNKNOWN	= 104,
	CIM_FLAG_ARRAY	= 0x2000
    } 	CIMTYPE_ENUMERATION;

typedef /* [v1_enum] */ 
enum tag_WBEM_BACKUP_RESTORE_FLAGS
    {	WBEM_FLAG_BACKUP_RESTORE_DEFAULT	= 0,
	WBEM_FLAG_BACKUP_RESTORE_FORCE_SHUTDOWN	= 1
    } 	WBEM_BACKUP_RESTORE_FLAGS;

typedef /* [v1_enum] */ 
enum tag_WBEM_REFRESHER_FLAGS
    {	WBEM_FLAG_REFRESH_AUTO_RECONNECT	= 0,
	WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT	= 1
    } 	WBEM_REFRESHER_FLAGS;

typedef 
enum tag_WBEM_SHUTDOWN_FLAGS
    {	WBEM_SHUTDOWN_UNLOAD_COMPONENT	= 1,
	WBEM_SHUTDOWN_WMI	= 2,
	WBEM_SHUTDOWN_OS	= 3
    } 	WBEM_SHUTDOWN_FLAGS;

typedef long CIMTYPE;

typedef /* [v1_enum] */ 
enum tag_WBEMSTATUS_FORMAT
    {	WBEMSTATUS_FORMAT_NEWLINE	= 0,
	WBEMSTATUS_FORMAT_NO_NEWLINE	= 1
    } 	WBEMSTATUS_FORMAT;

typedef /* [v1_enum] */ 
enum tag_WBEMSTATUS
    {	WBEM_NO_ERROR	= 0,
	WBEM_S_NO_ERROR	= 0,
	WBEM_S_SAME	= 0,
	WBEM_S_FALSE	= 1,
	WBEM_S_ALREADY_EXISTS	= 0x40001,
	WBEM_S_RESET_TO_DEFAULT	= 0x40002,
	WBEM_S_DIFFERENT	= 0x40003,
	WBEM_S_TIMEDOUT	= 0x40004,
	WBEM_S_NO_MORE_DATA	= 0x40005,
	WBEM_S_OPERATION_CANCELLED	= 0x40006,
	WBEM_S_PENDING	= 0x40007,
	WBEM_S_DUPLICATE_OBJECTS	= 0x40008,
	WBEM_S_ACCESS_DENIED	= 0x40009,
	WBEM_S_PARTIAL_RESULTS	= 0x40010,
	WBEM_S_NO_POSTHOOK	= 0x40011,
	WBEM_S_POSTHOOK_WITH_BOTH	= 0x40012,
	WBEM_S_POSTHOOK_WITH_NEW	= 0x40013,
	WBEM_S_POSTHOOK_WITH_STATUS	= 0x40014,
	WBEM_S_POSTHOOK_WITH_OLD	= 0x40015,
	WBEM_S_REDO_PREHOOK_WITH_ORIGINAL_OBJECT	= 0x40016,
	WBEM_E_FAILED	= 0x80041001,
	WBEM_E_NOT_FOUND	= 0x80041002,
	WBEM_E_ACCESS_DENIED	= 0x80041003,
	WBEM_E_PROVIDER_FAILURE	= 0x80041004,
	WBEM_E_TYPE_MISMATCH	= 0x80041005,
	WBEM_E_OUT_OF_MEMORY	= 0x80041006,
	WBEM_E_INVALID_CONTEXT	= 0x80041007,
	WBEM_E_INVALID_PARAMETER	= 0x80041008,
	WBEM_E_NOT_AVAILABLE	= 0x80041009,
	WBEM_E_CRITICAL_ERROR	= 0x8004100a,
	WBEM_E_INVALID_STREAM	= 0x8004100b,
	WBEM_E_NOT_SUPPORTED	= 0x8004100c,
	WBEM_E_INVALID_SUPERCLASS	= 0x8004100d,
	WBEM_E_INVALID_NAMESPACE	= 0x8004100e,
	WBEM_E_INVALID_OBJECT	= 0x8004100f,
	WBEM_E_INVALID_CLASS	= 0x80041010,
	WBEM_E_PROVIDER_NOT_FOUND	= 0x80041011,
	WBEM_E_INVALID_PROVIDER_REGISTRATION	= 0x80041012,
	WBEM_E_PROVIDER_LOAD_FAILURE	= 0x80041013,
	WBEM_E_INITIALIZATION_FAILURE	= 0x80041014,
	WBEM_E_TRANSPORT_FAILURE	= 0x80041015,
	WBEM_E_INVALID_OPERATION	= 0x80041016,
	WBEM_E_INVALID_QUERY	= 0x80041017,
	WBEM_E_INVALID_QUERY_TYPE	= 0x80041018,
	WBEM_E_ALREADY_EXISTS	= 0x80041019,
	WBEM_E_OVERRIDE_NOT_ALLOWED	= 0x8004101a,
	WBEM_E_PROPAGATED_QUALIFIER	= 0x8004101b,
	WBEM_E_PROPAGATED_PROPERTY	= 0x8004101c,
	WBEM_E_UNEXPECTED	= 0x8004101d,
	WBEM_E_ILLEGAL_OPERATION	= 0x8004101e,
	WBEM_E_CANNOT_BE_KEY	= 0x8004101f,
	WBEM_E_INCOMPLETE_CLASS	= 0x80041020,
	WBEM_E_INVALID_SYNTAX	= 0x80041021,
	WBEM_E_NONDECORATED_OBJECT	= 0x80041022,
	WBEM_E_READ_ONLY	= 0x80041023,
	WBEM_E_PROVIDER_NOT_CAPABLE	= 0x80041024,
	WBEM_E_CLASS_HAS_CHILDREN	= 0x80041025,
	WBEM_E_CLASS_HAS_INSTANCES	= 0x80041026,
	WBEM_E_QUERY_NOT_IMPLEMENTED	= 0x80041027,
	WBEM_E_ILLEGAL_NULL	= 0x80041028,
	WBEM_E_INVALID_QUALIFIER_TYPE	= 0x80041029,
	WBEM_E_INVALID_PROPERTY_TYPE	= 0x8004102a,
	WBEM_E_VALUE_OUT_OF_RANGE	= 0x8004102b,
	WBEM_E_CANNOT_BE_SINGLETON	= 0x8004102c,
	WBEM_E_INVALID_CIM_TYPE	= 0x8004102d,
	WBEM_E_INVALID_METHOD	= 0x8004102e,
	WBEM_E_INVALID_METHOD_PARAMETERS	= 0x8004102f,
	WBEM_E_SYSTEM_PROPERTY	= 0x80041030,
	WBEM_E_INVALID_PROPERTY	= 0x80041031,
	WBEM_E_CALL_CANCELLED	= 0x80041032,
	WBEM_E_SHUTTING_DOWN	= 0x80041033,
	WBEM_E_PROPAGATED_METHOD	= 0x80041034,
	WBEM_E_UNSUPPORTED_PARAMETER	= 0x80041035,
	WBEM_E_MISSING_PARAMETER_ID	= 0x80041036,
	WBEM_E_INVALID_PARAMETER_ID	= 0x80041037,
	WBEM_E_NONCONSECUTIVE_PARAMETER_IDS	= 0x80041038,
	WBEM_E_PARAMETER_ID_ON_RETVAL	= 0x80041039,
	WBEM_E_INVALID_OBJECT_PATH	= 0x8004103a,
	WBEM_E_OUT_OF_DISK_SPACE	= 0x8004103b,
	WBEM_E_BUFFER_TOO_SMALL	= 0x8004103c,
	WBEM_E_UNSUPPORTED_PUT_EXTENSION	= 0x8004103d,
	WBEM_E_UNKNOWN_OBJECT_TYPE	= 0x8004103e,
	WBEM_E_UNKNOWN_PACKET_TYPE	= 0x8004103f,
	WBEM_E_MARSHAL_VERSION_MISMATCH	= 0x80041040,
	WBEM_E_MARSHAL_INVALID_SIGNATURE	= 0x80041041,
	WBEM_E_INVALID_QUALIFIER	= 0x80041042,
	WBEM_E_INVALID_DUPLICATE_PARAMETER	= 0x80041043,
	WBEM_E_TOO_MUCH_DATA	= 0x80041044,
	WBEM_E_SERVER_TOO_BUSY	= 0x80041045,
	WBEM_E_INVALID_FLAVOR	= 0x80041046,
	WBEM_E_CIRCULAR_REFERENCE	= 0x80041047,
	WBEM_E_UNSUPPORTED_CLASS_UPDATE	= 0x80041048,
	WBEM_E_CANNOT_CHANGE_KEY_INHERITANCE	= 0x80041049,
	WBEM_E_CANNOT_CHANGE_INDEX_INHERITANCE	= 0x80041050,
	WBEM_E_TOO_MANY_PROPERTIES	= 0x80041051,
	WBEM_E_UPDATE_TYPE_MISMATCH	= 0x80041052,
	WBEM_E_UPDATE_OVERRIDE_NOT_ALLOWED	= 0x80041053,
	WBEM_E_UPDATE_PROPAGATED_METHOD	= 0x80041054,
	WBEM_E_METHOD_NOT_IMPLEMENTED	= 0x80041055,
	WBEM_E_METHOD_DISABLED	= 0x80041056,
	WBEM_E_REFRESHER_BUSY	= 0x80041057,
	WBEM_E_UNPARSABLE_QUERY	= 0x80041058,
	WBEM_E_NOT_EVENT_CLASS	= 0x80041059,
	WBEM_E_MISSING_GROUP_WITHIN	= 0x8004105a,
	WBEM_E_MISSING_AGGREGATION_LIST	= 0x8004105b,
	WBEM_E_PROPERTY_NOT_AN_OBJECT	= 0x8004105c,
	WBEM_E_AGGREGATING_BY_OBJECT	= 0x8004105d,
	WBEM_E_UNINTERPRETABLE_PROVIDER_QUERY	= 0x8004105f,
	WBEM_E_BACKUP_RESTORE_WINMGMT_RUNNING	= 0x80041060,
	WBEM_E_QUEUE_OVERFLOW	= 0x80041061,
	WBEM_E_PRIVILEGE_NOT_HELD	= 0x80041062,
	WBEM_E_INVALID_OPERATOR	= 0x80041063,
	WBEM_E_LOCAL_CREDENTIALS	= 0x80041064,
	WBEM_E_CANNOT_BE_ABSTRACT	= 0x80041065,
	WBEM_E_AMENDED_OBJECT	= 0x80041066,
	WBEM_E_CLIENT_TOO_SLOW	= 0x80041067,
	WBEM_E_NULL_SECURITY_DESCRIPTOR	= 0x80041068,
	WBEM_E_TIMED_OUT	= 0x80041069,
	WBEM_E_INVALID_ASSOCIATION	= 0x8004106a,
	WBEM_E_AMBIGUOUS_OPERATION	= 0x8004106b,
	WBEM_E_QUOTA_VIOLATION	= 0x8004106c,
	WBEM_E_TRANSACTION_CONFLICT	= 0x8004106d,
	WBEM_E_FORCED_ROLLBACK	= 0x8004106e,
	WBEM_E_UNSUPPORTED_LOCALE	= 0x8004106f,
	WBEM_E_HANDLE_OUT_OF_DATE	= 0x80041070,
	WBEM_E_CONNECTION_FAILED	= 0x80041071,
	WBEM_E_INVALID_HANDLE_REQUEST	= 0x80041072,
	WBEM_E_PROPERTY_NAME_TOO_WIDE	= 0x80041073,
	WBEM_E_CLASS_NAME_TOO_WIDE	= 0x80041074,
	WBEM_E_METHOD_NAME_TOO_WIDE	= 0x80041075,
	WBEM_E_QUALIFIER_NAME_TOO_WIDE	= 0x80041076,
	WBEM_E_RERUN_COMMAND	= 0x80041077,
	WBEM_E_DATABASE_VER_MISMATCH	= 0x80041078,
	WBEM_E_VETO_PUT	= 0x80041078,
	WBEM_E_VETO_DELETE	= 0x80041079,
	WBEM_E_INVALID_LOCALE	= 0x80041080,
	WBEM_E_PROVIDER_SUSPENDED	= 0x80041081,
	WBEM_E_SYNCHRONIZATION_REQUIRED	= 0x80041082,
	WBEM_E_NO_SCHEMA	= 0x80041083,
	WBEMESS_E_REGISTRATION_TOO_BROAD	= 0x80042001,
	WBEMESS_E_REGISTRATION_TOO_PRECISE	= 0x80042002
    } 	WBEMSTATUS;


EXTERN_C const IID LIBID_WbemClient_v1;

#ifndef __IWbemClassObject_INTERFACE_DEFINED__
#define __IWbemClassObject_INTERFACE_DEFINED__

/* interface IWbemClassObject */
/* [uuid][object][restricted][local] */ 


EXTERN_C const IID IID_IWbemClassObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dc12a681-737f-11cf-884d-00aa004b2e24")
    IWbemClassObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetQualifierSet( 
            /* [out] */ IWbemQualifierSet **ppQualSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ CIMTYPE *pType,
            /* [unique][in][out] */ long *plFlavor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Put( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pVal,
            /* [in] */ CIMTYPE Type) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [string][in] */ LPCWSTR wszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNames( 
            /* [string][in] */ LPCWSTR wszQualifierName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pQualifierVal,
            /* [out] */ SAFEARRAY * *pNames) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginEnumeration( 
            /* [in] */ long lEnumFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR *strName,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ CIMTYPE *pType,
            /* [unique][in][out] */ long *plFlavor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndEnumeration( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyQualifierSet( 
            /* [string][in] */ LPCWSTR wszProperty,
            /* [out] */ IWbemQualifierSet **ppQualSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IWbemClassObject **ppCopy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectText( 
            /* [in] */ long lFlags,
            /* [out] */ BSTR *pstrObjectText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SpawnDerivedClass( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppNewClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SpawnInstance( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppNewInstance) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompareTo( 
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pCompareTo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyOrigin( 
            /* [string][in] */ LPCWSTR wszName,
            /* [out] */ BSTR *pstrClassName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InheritsFrom( 
            /* [in] */ LPCWSTR strAncestor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMethod( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppInSignature,
            /* [out] */ IWbemClassObject **ppOutSignature) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutMethod( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pInSignature,
            /* [in] */ IWbemClassObject *pOutSignature) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteMethod( 
            /* [string][in] */ LPCWSTR wszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginMethodEnumeration( 
            /* [in] */ long lEnumFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NextMethod( 
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR *pstrName,
            /* [unique][in][out] */ IWbemClassObject **ppInSignature,
            /* [unique][in][out] */ IWbemClassObject **ppOutSignature) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndMethodEnumeration( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMethodQualifierSet( 
            /* [string][in] */ LPCWSTR wszMethod,
            /* [out] */ IWbemQualifierSet **ppQualSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMethodOrigin( 
            /* [string][in] */ LPCWSTR wszMethodName,
            /* [out] */ BSTR *pstrClassName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemClassObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemClassObject * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemClassObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemClassObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetQualifierSet )( 
            IWbemClassObject * This,
            /* [out] */ IWbemQualifierSet **ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE *Get )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ CIMTYPE *pType,
            /* [unique][in][out] */ long *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE *Put )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pVal,
            /* [in] */ CIMTYPE Type);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetNames )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszQualifierName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pQualifierVal,
            /* [out] */ SAFEARRAY * *pNames);
        
        HRESULT ( STDMETHODCALLTYPE *BeginEnumeration )( 
            IWbemClassObject * This,
            /* [in] */ long lEnumFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IWbemClassObject * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR *strName,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ CIMTYPE *pType,
            /* [unique][in][out] */ long *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE *EndEnumeration )( 
            IWbemClassObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyQualifierSet )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszProperty,
            /* [out] */ IWbemQualifierSet **ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IWbemClassObject * This,
            /* [out] */ IWbemClassObject **ppCopy);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectText )( 
            IWbemClassObject * This,
            /* [in] */ long lFlags,
            /* [out] */ BSTR *pstrObjectText);
        
        HRESULT ( STDMETHODCALLTYPE *SpawnDerivedClass )( 
            IWbemClassObject * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppNewClass);
        
        HRESULT ( STDMETHODCALLTYPE *SpawnInstance )( 
            IWbemClassObject * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppNewInstance);
        
        HRESULT ( STDMETHODCALLTYPE *CompareTo )( 
            IWbemClassObject * This,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pCompareTo);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyOrigin )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [out] */ BSTR *pstrClassName);
        
        HRESULT ( STDMETHODCALLTYPE *InheritsFrom )( 
            IWbemClassObject * This,
            /* [in] */ LPCWSTR strAncestor);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethod )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppInSignature,
            /* [out] */ IWbemClassObject **ppOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE *PutMethod )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pInSignature,
            /* [in] */ IWbemClassObject *pOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteMethod )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszName);
        
        HRESULT ( STDMETHODCALLTYPE *BeginMethodEnumeration )( 
            IWbemClassObject * This,
            /* [in] */ long lEnumFlags);
        
        HRESULT ( STDMETHODCALLTYPE *NextMethod )( 
            IWbemClassObject * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR *pstrName,
            /* [unique][in][out] */ IWbemClassObject **ppInSignature,
            /* [unique][in][out] */ IWbemClassObject **ppOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE *EndMethodEnumeration )( 
            IWbemClassObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethodQualifierSet )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszMethod,
            /* [out] */ IWbemQualifierSet **ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethodOrigin )( 
            IWbemClassObject * This,
            /* [string][in] */ LPCWSTR wszMethodName,
            /* [out] */ BSTR *pstrClassName);
        
        END_INTERFACE
    } IWbemClassObjectVtbl;

    interface IWbemClassObject
    {
        CONST_VTBL struct IWbemClassObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemClassObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemClassObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemClassObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemClassObject_GetQualifierSet(This,ppQualSet)	\
    (This)->lpVtbl -> GetQualifierSet(This,ppQualSet)

#define IWbemClassObject_Get(This,wszName,lFlags,pVal,pType,plFlavor)	\
    (This)->lpVtbl -> Get(This,wszName,lFlags,pVal,pType,plFlavor)

#define IWbemClassObject_Put(This,wszName,lFlags,pVal,Type)	\
    (This)->lpVtbl -> Put(This,wszName,lFlags,pVal,Type)

#define IWbemClassObject_Delete(This,wszName)	\
    (This)->lpVtbl -> Delete(This,wszName)

#define IWbemClassObject_GetNames(This,wszQualifierName,lFlags,pQualifierVal,pNames)	\
    (This)->lpVtbl -> GetNames(This,wszQualifierName,lFlags,pQualifierVal,pNames)

#define IWbemClassObject_BeginEnumeration(This,lEnumFlags)	\
    (This)->lpVtbl -> BeginEnumeration(This,lEnumFlags)

#define IWbemClassObject_Next(This,lFlags,strName,pVal,pType,plFlavor)	\
    (This)->lpVtbl -> Next(This,lFlags,strName,pVal,pType,plFlavor)

#define IWbemClassObject_EndEnumeration(This)	\
    (This)->lpVtbl -> EndEnumeration(This)

#define IWbemClassObject_GetPropertyQualifierSet(This,wszProperty,ppQualSet)	\
    (This)->lpVtbl -> GetPropertyQualifierSet(This,wszProperty,ppQualSet)

#define IWbemClassObject_Clone(This,ppCopy)	\
    (This)->lpVtbl -> Clone(This,ppCopy)

#define IWbemClassObject_GetObjectText(This,lFlags,pstrObjectText)	\
    (This)->lpVtbl -> GetObjectText(This,lFlags,pstrObjectText)

#define IWbemClassObject_SpawnDerivedClass(This,lFlags,ppNewClass)	\
    (This)->lpVtbl -> SpawnDerivedClass(This,lFlags,ppNewClass)

#define IWbemClassObject_SpawnInstance(This,lFlags,ppNewInstance)	\
    (This)->lpVtbl -> SpawnInstance(This,lFlags,ppNewInstance)

#define IWbemClassObject_CompareTo(This,lFlags,pCompareTo)	\
    (This)->lpVtbl -> CompareTo(This,lFlags,pCompareTo)

#define IWbemClassObject_GetPropertyOrigin(This,wszName,pstrClassName)	\
    (This)->lpVtbl -> GetPropertyOrigin(This,wszName,pstrClassName)

#define IWbemClassObject_InheritsFrom(This,strAncestor)	\
    (This)->lpVtbl -> InheritsFrom(This,strAncestor)

#define IWbemClassObject_GetMethod(This,wszName,lFlags,ppInSignature,ppOutSignature)	\
    (This)->lpVtbl -> GetMethod(This,wszName,lFlags,ppInSignature,ppOutSignature)

#define IWbemClassObject_PutMethod(This,wszName,lFlags,pInSignature,pOutSignature)	\
    (This)->lpVtbl -> PutMethod(This,wszName,lFlags,pInSignature,pOutSignature)

#define IWbemClassObject_DeleteMethod(This,wszName)	\
    (This)->lpVtbl -> DeleteMethod(This,wszName)

#define IWbemClassObject_BeginMethodEnumeration(This,lEnumFlags)	\
    (This)->lpVtbl -> BeginMethodEnumeration(This,lEnumFlags)

#define IWbemClassObject_NextMethod(This,lFlags,pstrName,ppInSignature,ppOutSignature)	\
    (This)->lpVtbl -> NextMethod(This,lFlags,pstrName,ppInSignature,ppOutSignature)

#define IWbemClassObject_EndMethodEnumeration(This)	\
    (This)->lpVtbl -> EndMethodEnumeration(This)

#define IWbemClassObject_GetMethodQualifierSet(This,wszMethod,ppQualSet)	\
    (This)->lpVtbl -> GetMethodQualifierSet(This,wszMethod,ppQualSet)

#define IWbemClassObject_GetMethodOrigin(This,wszMethodName,pstrClassName)	\
    (This)->lpVtbl -> GetMethodOrigin(This,wszMethodName,pstrClassName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemClassObject_GetQualifierSet_Proxy( 
    IWbemClassObject * This,
    /* [out] */ IWbemQualifierSet **ppQualSet);


void __RPC_STUB IWbemClassObject_GetQualifierSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_Get_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ VARIANT *pVal,
    /* [unique][in][out] */ CIMTYPE *pType,
    /* [unique][in][out] */ long *plFlavor);


void __RPC_STUB IWbemClassObject_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_Put_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [in] */ VARIANT *pVal,
    /* [in] */ CIMTYPE Type);


void __RPC_STUB IWbemClassObject_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_Delete_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszName);


void __RPC_STUB IWbemClassObject_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetNames_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszQualifierName,
    /* [in] */ long lFlags,
    /* [in] */ VARIANT *pQualifierVal,
    /* [out] */ SAFEARRAY * *pNames);


void __RPC_STUB IWbemClassObject_GetNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_BeginEnumeration_Proxy( 
    IWbemClassObject * This,
    /* [in] */ long lEnumFlags);


void __RPC_STUB IWbemClassObject_BeginEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_Next_Proxy( 
    IWbemClassObject * This,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ BSTR *strName,
    /* [unique][in][out] */ VARIANT *pVal,
    /* [unique][in][out] */ CIMTYPE *pType,
    /* [unique][in][out] */ long *plFlavor);


void __RPC_STUB IWbemClassObject_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_EndEnumeration_Proxy( 
    IWbemClassObject * This);


void __RPC_STUB IWbemClassObject_EndEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetPropertyQualifierSet_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszProperty,
    /* [out] */ IWbemQualifierSet **ppQualSet);


void __RPC_STUB IWbemClassObject_GetPropertyQualifierSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_Clone_Proxy( 
    IWbemClassObject * This,
    /* [out] */ IWbemClassObject **ppCopy);


void __RPC_STUB IWbemClassObject_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetObjectText_Proxy( 
    IWbemClassObject * This,
    /* [in] */ long lFlags,
    /* [out] */ BSTR *pstrObjectText);


void __RPC_STUB IWbemClassObject_GetObjectText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_SpawnDerivedClass_Proxy( 
    IWbemClassObject * This,
    /* [in] */ long lFlags,
    /* [out] */ IWbemClassObject **ppNewClass);


void __RPC_STUB IWbemClassObject_SpawnDerivedClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_SpawnInstance_Proxy( 
    IWbemClassObject * This,
    /* [in] */ long lFlags,
    /* [out] */ IWbemClassObject **ppNewInstance);


void __RPC_STUB IWbemClassObject_SpawnInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_CompareTo_Proxy( 
    IWbemClassObject * This,
    /* [in] */ long lFlags,
    /* [in] */ IWbemClassObject *pCompareTo);


void __RPC_STUB IWbemClassObject_CompareTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetPropertyOrigin_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [out] */ BSTR *pstrClassName);


void __RPC_STUB IWbemClassObject_GetPropertyOrigin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_InheritsFrom_Proxy( 
    IWbemClassObject * This,
    /* [in] */ LPCWSTR strAncestor);


void __RPC_STUB IWbemClassObject_InheritsFrom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetMethod_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [out] */ IWbemClassObject **ppInSignature,
    /* [out] */ IWbemClassObject **ppOutSignature);


void __RPC_STUB IWbemClassObject_GetMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_PutMethod_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemClassObject *pInSignature,
    /* [in] */ IWbemClassObject *pOutSignature);


void __RPC_STUB IWbemClassObject_PutMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_DeleteMethod_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszName);


void __RPC_STUB IWbemClassObject_DeleteMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_BeginMethodEnumeration_Proxy( 
    IWbemClassObject * This,
    /* [in] */ long lEnumFlags);


void __RPC_STUB IWbemClassObject_BeginMethodEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_NextMethod_Proxy( 
    IWbemClassObject * This,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ BSTR *pstrName,
    /* [unique][in][out] */ IWbemClassObject **ppInSignature,
    /* [unique][in][out] */ IWbemClassObject **ppOutSignature);


void __RPC_STUB IWbemClassObject_NextMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_EndMethodEnumeration_Proxy( 
    IWbemClassObject * This);


void __RPC_STUB IWbemClassObject_EndMethodEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetMethodQualifierSet_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszMethod,
    /* [out] */ IWbemQualifierSet **ppQualSet);


void __RPC_STUB IWbemClassObject_GetMethodQualifierSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObject_GetMethodOrigin_Proxy( 
    IWbemClassObject * This,
    /* [string][in] */ LPCWSTR wszMethodName,
    /* [out] */ BSTR *pstrClassName);


void __RPC_STUB IWbemClassObject_GetMethodOrigin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemClassObject_INTERFACE_DEFINED__ */


#ifndef __IWbemClassObjectEx_INTERFACE_DEFINED__
#define __IWbemClassObjectEx_INTERFACE_DEFINED__

/* interface IWbemClassObjectEx */
/* [uuid][local][restricted][object] */ 


EXTERN_C const IID IID_IWbemClassObjectEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0E130F89-81D9-4386-B3BE-092651D04588")
    IWbemClassObjectEx : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PutEx( 
            /* [in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pvFilter,
            /* [in] */ VARIANT *pvInVals) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteEx( 
            /* [in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pvFilter,
            /* [in] */ VARIANT *pvInVals) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEx( 
            /* [in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pvFilter,
            /* [in] */ VARIANT *pvInVals,
            /* [unique][in][out] */ CIMTYPE *pCimType,
            /* [unique][in][out] */ long *plFlavor) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemClassObjectExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemClassObjectEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemClassObjectEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemClassObjectEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *PutEx )( 
            IWbemClassObjectEx * This,
            /* [in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pvFilter,
            /* [in] */ VARIANT *pvInVals);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteEx )( 
            IWbemClassObjectEx * This,
            /* [in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pvFilter,
            /* [in] */ VARIANT *pvInVals);
        
        HRESULT ( STDMETHODCALLTYPE *GetEx )( 
            IWbemClassObjectEx * This,
            /* [in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pvFilter,
            /* [in] */ VARIANT *pvInVals,
            /* [unique][in][out] */ CIMTYPE *pCimType,
            /* [unique][in][out] */ long *plFlavor);
        
        END_INTERFACE
    } IWbemClassObjectExVtbl;

    interface IWbemClassObjectEx
    {
        CONST_VTBL struct IWbemClassObjectExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemClassObjectEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemClassObjectEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemClassObjectEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemClassObjectEx_PutEx(This,wszName,lFlags,pvFilter,pvInVals)	\
    (This)->lpVtbl -> PutEx(This,wszName,lFlags,pvFilter,pvInVals)

#define IWbemClassObjectEx_DeleteEx(This,wszName,lFlags,pvFilter,pvInVals)	\
    (This)->lpVtbl -> DeleteEx(This,wszName,lFlags,pvFilter,pvInVals)

#define IWbemClassObjectEx_GetEx(This,wszName,lFlags,pvFilter,pvInVals,pCimType,plFlavor)	\
    (This)->lpVtbl -> GetEx(This,wszName,lFlags,pvFilter,pvInVals,pCimType,plFlavor)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemClassObjectEx_PutEx_Proxy( 
    IWbemClassObjectEx * This,
    /* [in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [in] */ VARIANT *pvFilter,
    /* [in] */ VARIANT *pvInVals);


void __RPC_STUB IWbemClassObjectEx_PutEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObjectEx_DeleteEx_Proxy( 
    IWbemClassObjectEx * This,
    /* [in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [in] */ VARIANT *pvFilter,
    /* [in] */ VARIANT *pvInVals);


void __RPC_STUB IWbemClassObjectEx_DeleteEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemClassObjectEx_GetEx_Proxy( 
    IWbemClassObjectEx * This,
    /* [in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [in] */ VARIANT *pvFilter,
    /* [in] */ VARIANT *pvInVals,
    /* [unique][in][out] */ CIMTYPE *pCimType,
    /* [unique][in][out] */ long *plFlavor);


void __RPC_STUB IWbemClassObjectEx_GetEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemClassObjectEx_INTERFACE_DEFINED__ */


#ifndef __IWbemObjectAccess_INTERFACE_DEFINED__
#define __IWbemObjectAccess_INTERFACE_DEFINED__

/* interface IWbemObjectAccess */
/* [uuid][object][restricted][local] */ 


EXTERN_C const IID IID_IWbemObjectAccess;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49353c9a-516b-11d1-aea6-00c04fb68820")
    IWbemObjectAccess : public IWbemClassObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropertyHandle( 
            /* [string][in] */ LPCWSTR wszPropertyName,
            /* [out] */ CIMTYPE *pType,
            /* [out] */ long *plHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WritePropertyValue( 
            /* [in] */ long lHandle,
            /* [in] */ long lNumBytes,
            /* [size_is][in] */ const byte *aData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadPropertyValue( 
            /* [in] */ long lHandle,
            /* [in] */ long lBufferSize,
            /* [out] */ long *plNumBytes,
            /* [length_is][size_is][out] */ byte *aData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadDWORD( 
            /* [in] */ long lHandle,
            /* [out] */ DWORD *pdw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteDWORD( 
            /* [in] */ long lHandle,
            /* [in] */ DWORD dw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadQWORD( 
            /* [in] */ long lHandle,
            /* [out] */ unsigned __int64 *pqw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteQWORD( 
            /* [in] */ long lHandle,
            /* [in] */ unsigned __int64 pw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyInfoByHandle( 
            /* [in] */ long lHandle,
            /* [out] */ BSTR *pstrName,
            /* [out] */ CIMTYPE *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Lock( 
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unlock( 
            /* [in] */ long lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemObjectAccessVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemObjectAccess * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemObjectAccess * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemObjectAccess * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetQualifierSet )( 
            IWbemObjectAccess * This,
            /* [out] */ IWbemQualifierSet **ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE *Get )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ CIMTYPE *pType,
            /* [unique][in][out] */ long *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE *Put )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pVal,
            /* [in] */ CIMTYPE Type);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetNames )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszQualifierName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pQualifierVal,
            /* [out] */ SAFEARRAY * *pNames);
        
        HRESULT ( STDMETHODCALLTYPE *BeginEnumeration )( 
            IWbemObjectAccess * This,
            /* [in] */ long lEnumFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IWbemObjectAccess * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR *strName,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ CIMTYPE *pType,
            /* [unique][in][out] */ long *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE *EndEnumeration )( 
            IWbemObjectAccess * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyQualifierSet )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszProperty,
            /* [out] */ IWbemQualifierSet **ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IWbemObjectAccess * This,
            /* [out] */ IWbemClassObject **ppCopy);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectText )( 
            IWbemObjectAccess * This,
            /* [in] */ long lFlags,
            /* [out] */ BSTR *pstrObjectText);
        
        HRESULT ( STDMETHODCALLTYPE *SpawnDerivedClass )( 
            IWbemObjectAccess * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppNewClass);
        
        HRESULT ( STDMETHODCALLTYPE *SpawnInstance )( 
            IWbemObjectAccess * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppNewInstance);
        
        HRESULT ( STDMETHODCALLTYPE *CompareTo )( 
            IWbemObjectAccess * This,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pCompareTo);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyOrigin )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [out] */ BSTR *pstrClassName);
        
        HRESULT ( STDMETHODCALLTYPE *InheritsFrom )( 
            IWbemObjectAccess * This,
            /* [in] */ LPCWSTR strAncestor);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethod )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject **ppInSignature,
            /* [out] */ IWbemClassObject **ppOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE *PutMethod )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pInSignature,
            /* [in] */ IWbemClassObject *pOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteMethod )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszName);
        
        HRESULT ( STDMETHODCALLTYPE *BeginMethodEnumeration )( 
            IWbemObjectAccess * This,
            /* [in] */ long lEnumFlags);
        
        HRESULT ( STDMETHODCALLTYPE *NextMethod )( 
            IWbemObjectAccess * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR *pstrName,
            /* [unique][in][out] */ IWbemClassObject **ppInSignature,
            /* [unique][in][out] */ IWbemClassObject **ppOutSignature);
        
        HRESULT ( STDMETHODCALLTYPE *EndMethodEnumeration )( 
            IWbemObjectAccess * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethodQualifierSet )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszMethod,
            /* [out] */ IWbemQualifierSet **ppQualSet);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethodOrigin )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszMethodName,
            /* [out] */ BSTR *pstrClassName);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyHandle )( 
            IWbemObjectAccess * This,
            /* [string][in] */ LPCWSTR wszPropertyName,
            /* [out] */ CIMTYPE *pType,
            /* [out] */ long *plHandle);
        
        HRESULT ( STDMETHODCALLTYPE *WritePropertyValue )( 
            IWbemObjectAccess * This,
            /* [in] */ long lHandle,
            /* [in] */ long lNumBytes,
            /* [size_is][in] */ const byte *aData);
        
        HRESULT ( STDMETHODCALLTYPE *ReadPropertyValue )( 
            IWbemObjectAccess * This,
            /* [in] */ long lHandle,
            /* [in] */ long lBufferSize,
            /* [out] */ long *plNumBytes,
            /* [length_is][size_is][out] */ byte *aData);
        
        HRESULT ( STDMETHODCALLTYPE *ReadDWORD )( 
            IWbemObjectAccess * This,
            /* [in] */ long lHandle,
            /* [out] */ DWORD *pdw);
        
        HRESULT ( STDMETHODCALLTYPE *WriteDWORD )( 
            IWbemObjectAccess * This,
            /* [in] */ long lHandle,
            /* [in] */ DWORD dw);
        
        HRESULT ( STDMETHODCALLTYPE *ReadQWORD )( 
            IWbemObjectAccess * This,
            /* [in] */ long lHandle,
            /* [out] */ unsigned __int64 *pqw);
        
        HRESULT ( STDMETHODCALLTYPE *WriteQWORD )( 
            IWbemObjectAccess * This,
            /* [in] */ long lHandle,
            /* [in] */ unsigned __int64 pw);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyInfoByHandle )( 
            IWbemObjectAccess * This,
            /* [in] */ long lHandle,
            /* [out] */ BSTR *pstrName,
            /* [out] */ CIMTYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *Lock )( 
            IWbemObjectAccess * This,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Unlock )( 
            IWbemObjectAccess * This,
            /* [in] */ long lFlags);
        
        END_INTERFACE
    } IWbemObjectAccessVtbl;

    interface IWbemObjectAccess
    {
        CONST_VTBL struct IWbemObjectAccessVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemObjectAccess_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemObjectAccess_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemObjectAccess_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemObjectAccess_GetQualifierSet(This,ppQualSet)	\
    (This)->lpVtbl -> GetQualifierSet(This,ppQualSet)

#define IWbemObjectAccess_Get(This,wszName,lFlags,pVal,pType,plFlavor)	\
    (This)->lpVtbl -> Get(This,wszName,lFlags,pVal,pType,plFlavor)

#define IWbemObjectAccess_Put(This,wszName,lFlags,pVal,Type)	\
    (This)->lpVtbl -> Put(This,wszName,lFlags,pVal,Type)

#define IWbemObjectAccess_Delete(This,wszName)	\
    (This)->lpVtbl -> Delete(This,wszName)

#define IWbemObjectAccess_GetNames(This,wszQualifierName,lFlags,pQualifierVal,pNames)	\
    (This)->lpVtbl -> GetNames(This,wszQualifierName,lFlags,pQualifierVal,pNames)

#define IWbemObjectAccess_BeginEnumeration(This,lEnumFlags)	\
    (This)->lpVtbl -> BeginEnumeration(This,lEnumFlags)

#define IWbemObjectAccess_Next(This,lFlags,strName,pVal,pType,plFlavor)	\
    (This)->lpVtbl -> Next(This,lFlags,strName,pVal,pType,plFlavor)

#define IWbemObjectAccess_EndEnumeration(This)	\
    (This)->lpVtbl -> EndEnumeration(This)

#define IWbemObjectAccess_GetPropertyQualifierSet(This,wszProperty,ppQualSet)	\
    (This)->lpVtbl -> GetPropertyQualifierSet(This,wszProperty,ppQualSet)

#define IWbemObjectAccess_Clone(This,ppCopy)	\
    (This)->lpVtbl -> Clone(This,ppCopy)

#define IWbemObjectAccess_GetObjectText(This,lFlags,pstrObjectText)	\
    (This)->lpVtbl -> GetObjectText(This,lFlags,pstrObjectText)

#define IWbemObjectAccess_SpawnDerivedClass(This,lFlags,ppNewClass)	\
    (This)->lpVtbl -> SpawnDerivedClass(This,lFlags,ppNewClass)

#define IWbemObjectAccess_SpawnInstance(This,lFlags,ppNewInstance)	\
    (This)->lpVtbl -> SpawnInstance(This,lFlags,ppNewInstance)

#define IWbemObjectAccess_CompareTo(This,lFlags,pCompareTo)	\
    (This)->lpVtbl -> CompareTo(This,lFlags,pCompareTo)

#define IWbemObjectAccess_GetPropertyOrigin(This,wszName,pstrClassName)	\
    (This)->lpVtbl -> GetPropertyOrigin(This,wszName,pstrClassName)

#define IWbemObjectAccess_InheritsFrom(This,strAncestor)	\
    (This)->lpVtbl -> InheritsFrom(This,strAncestor)

#define IWbemObjectAccess_GetMethod(This,wszName,lFlags,ppInSignature,ppOutSignature)	\
    (This)->lpVtbl -> GetMethod(This,wszName,lFlags,ppInSignature,ppOutSignature)

#define IWbemObjectAccess_PutMethod(This,wszName,lFlags,pInSignature,pOutSignature)	\
    (This)->lpVtbl -> PutMethod(This,wszName,lFlags,pInSignature,pOutSignature)

#define IWbemObjectAccess_DeleteMethod(This,wszName)	\
    (This)->lpVtbl -> DeleteMethod(This,wszName)

#define IWbemObjectAccess_BeginMethodEnumeration(This,lEnumFlags)	\
    (This)->lpVtbl -> BeginMethodEnumeration(This,lEnumFlags)

#define IWbemObjectAccess_NextMethod(This,lFlags,pstrName,ppInSignature,ppOutSignature)	\
    (This)->lpVtbl -> NextMethod(This,lFlags,pstrName,ppInSignature,ppOutSignature)

#define IWbemObjectAccess_EndMethodEnumeration(This)	\
    (This)->lpVtbl -> EndMethodEnumeration(This)

#define IWbemObjectAccess_GetMethodQualifierSet(This,wszMethod,ppQualSet)	\
    (This)->lpVtbl -> GetMethodQualifierSet(This,wszMethod,ppQualSet)

#define IWbemObjectAccess_GetMethodOrigin(This,wszMethodName,pstrClassName)	\
    (This)->lpVtbl -> GetMethodOrigin(This,wszMethodName,pstrClassName)


#define IWbemObjectAccess_GetPropertyHandle(This,wszPropertyName,pType,plHandle)	\
    (This)->lpVtbl -> GetPropertyHandle(This,wszPropertyName,pType,plHandle)

#define IWbemObjectAccess_WritePropertyValue(This,lHandle,lNumBytes,aData)	\
    (This)->lpVtbl -> WritePropertyValue(This,lHandle,lNumBytes,aData)

#define IWbemObjectAccess_ReadPropertyValue(This,lHandle,lBufferSize,plNumBytes,aData)	\
    (This)->lpVtbl -> ReadPropertyValue(This,lHandle,lBufferSize,plNumBytes,aData)

#define IWbemObjectAccess_ReadDWORD(This,lHandle,pdw)	\
    (This)->lpVtbl -> ReadDWORD(This,lHandle,pdw)

#define IWbemObjectAccess_WriteDWORD(This,lHandle,dw)	\
    (This)->lpVtbl -> WriteDWORD(This,lHandle,dw)

#define IWbemObjectAccess_ReadQWORD(This,lHandle,pqw)	\
    (This)->lpVtbl -> ReadQWORD(This,lHandle,pqw)

#define IWbemObjectAccess_WriteQWORD(This,lHandle,pw)	\
    (This)->lpVtbl -> WriteQWORD(This,lHandle,pw)

#define IWbemObjectAccess_GetPropertyInfoByHandle(This,lHandle,pstrName,pType)	\
    (This)->lpVtbl -> GetPropertyInfoByHandle(This,lHandle,pstrName,pType)

#define IWbemObjectAccess_Lock(This,lFlags)	\
    (This)->lpVtbl -> Lock(This,lFlags)

#define IWbemObjectAccess_Unlock(This,lFlags)	\
    (This)->lpVtbl -> Unlock(This,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemObjectAccess_GetPropertyHandle_Proxy( 
    IWbemObjectAccess * This,
    /* [string][in] */ LPCWSTR wszPropertyName,
    /* [out] */ CIMTYPE *pType,
    /* [out] */ long *plHandle);


void __RPC_STUB IWbemObjectAccess_GetPropertyHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_WritePropertyValue_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lHandle,
    /* [in] */ long lNumBytes,
    /* [size_is][in] */ const byte *aData);


void __RPC_STUB IWbemObjectAccess_WritePropertyValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_ReadPropertyValue_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lHandle,
    /* [in] */ long lBufferSize,
    /* [out] */ long *plNumBytes,
    /* [length_is][size_is][out] */ byte *aData);


void __RPC_STUB IWbemObjectAccess_ReadPropertyValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_ReadDWORD_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lHandle,
    /* [out] */ DWORD *pdw);


void __RPC_STUB IWbemObjectAccess_ReadDWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_WriteDWORD_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lHandle,
    /* [in] */ DWORD dw);


void __RPC_STUB IWbemObjectAccess_WriteDWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_ReadQWORD_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lHandle,
    /* [out] */ unsigned __int64 *pqw);


void __RPC_STUB IWbemObjectAccess_ReadQWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_WriteQWORD_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lHandle,
    /* [in] */ unsigned __int64 pw);


void __RPC_STUB IWbemObjectAccess_WriteQWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_GetPropertyInfoByHandle_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lHandle,
    /* [out] */ BSTR *pstrName,
    /* [out] */ CIMTYPE *pType);


void __RPC_STUB IWbemObjectAccess_GetPropertyInfoByHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_Lock_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemObjectAccess_Lock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_Unlock_Proxy( 
    IWbemObjectAccess * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemObjectAccess_Unlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemObjectAccess_INTERFACE_DEFINED__ */


#ifndef __IWbemQualifierSet_INTERFACE_DEFINED__
#define __IWbemQualifierSet_INTERFACE_DEFINED__

/* interface IWbemQualifierSet */
/* [uuid][local][restricted][object] */ 


EXTERN_C const IID IID_IWbemQualifierSet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dc12a680-737f-11cf-884d-00aa004b2e24")
    IWbemQualifierSet : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ long *plFlavor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Put( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ VARIANT *pVal,
            /* [in] */ long lFlavor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [string][in] */ LPCWSTR wszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNames( 
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY * *pNames) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginEnumeration( 
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR *pstrName,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ long *plFlavor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndEnumeration( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemQualifierSetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemQualifierSet * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemQualifierSet * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemQualifierSet * This);
        
        HRESULT ( STDMETHODCALLTYPE *Get )( 
            IWbemQualifierSet * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ long *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE *Put )( 
            IWbemQualifierSet * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ VARIANT *pVal,
            /* [in] */ long lFlavor);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IWbemQualifierSet * This,
            /* [string][in] */ LPCWSTR wszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetNames )( 
            IWbemQualifierSet * This,
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY * *pNames);
        
        HRESULT ( STDMETHODCALLTYPE *BeginEnumeration )( 
            IWbemQualifierSet * This,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IWbemQualifierSet * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR *pstrName,
            /* [unique][in][out] */ VARIANT *pVal,
            /* [unique][in][out] */ long *plFlavor);
        
        HRESULT ( STDMETHODCALLTYPE *EndEnumeration )( 
            IWbemQualifierSet * This);
        
        END_INTERFACE
    } IWbemQualifierSetVtbl;

    interface IWbemQualifierSet
    {
        CONST_VTBL struct IWbemQualifierSetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemQualifierSet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemQualifierSet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemQualifierSet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemQualifierSet_Get(This,wszName,lFlags,pVal,plFlavor)	\
    (This)->lpVtbl -> Get(This,wszName,lFlags,pVal,plFlavor)

#define IWbemQualifierSet_Put(This,wszName,pVal,lFlavor)	\
    (This)->lpVtbl -> Put(This,wszName,pVal,lFlavor)

#define IWbemQualifierSet_Delete(This,wszName)	\
    (This)->lpVtbl -> Delete(This,wszName)

#define IWbemQualifierSet_GetNames(This,lFlags,pNames)	\
    (This)->lpVtbl -> GetNames(This,lFlags,pNames)

#define IWbemQualifierSet_BeginEnumeration(This,lFlags)	\
    (This)->lpVtbl -> BeginEnumeration(This,lFlags)

#define IWbemQualifierSet_Next(This,lFlags,pstrName,pVal,plFlavor)	\
    (This)->lpVtbl -> Next(This,lFlags,pstrName,pVal,plFlavor)

#define IWbemQualifierSet_EndEnumeration(This)	\
    (This)->lpVtbl -> EndEnumeration(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemQualifierSet_Get_Proxy( 
    IWbemQualifierSet * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ VARIANT *pVal,
    /* [unique][in][out] */ long *plFlavor);


void __RPC_STUB IWbemQualifierSet_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_Put_Proxy( 
    IWbemQualifierSet * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ VARIANT *pVal,
    /* [in] */ long lFlavor);


void __RPC_STUB IWbemQualifierSet_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_Delete_Proxy( 
    IWbemQualifierSet * This,
    /* [string][in] */ LPCWSTR wszName);


void __RPC_STUB IWbemQualifierSet_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_GetNames_Proxy( 
    IWbemQualifierSet * This,
    /* [in] */ long lFlags,
    /* [out] */ SAFEARRAY * *pNames);


void __RPC_STUB IWbemQualifierSet_GetNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_BeginEnumeration_Proxy( 
    IWbemQualifierSet * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemQualifierSet_BeginEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_Next_Proxy( 
    IWbemQualifierSet * This,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ BSTR *pstrName,
    /* [unique][in][out] */ VARIANT *pVal,
    /* [unique][in][out] */ long *plFlavor);


void __RPC_STUB IWbemQualifierSet_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemQualifierSet_EndEnumeration_Proxy( 
    IWbemQualifierSet * This);


void __RPC_STUB IWbemQualifierSet_EndEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemQualifierSet_INTERFACE_DEFINED__ */


#ifndef __IWbemServices_INTERFACE_DEFINED__
#define __IWbemServices_INTERFACE_DEFINED__

/* interface IWbemServices */
/* [unique][uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9556dc99-828c-11cf-a37e-00aa003240c7")
    IWbemServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemServices **ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink **ppResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemClassObject **ppObject,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR strFilter,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR strFilter,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemClassObject *pInParams,
            /* [unique][in][out] */ IWbemClassObject **ppOutParams,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemClassObject *pInParams,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *OpenNamespace )( 
            IWbemServices * This,
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemServices **ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *CancelAsyncCall )( 
            IWbemServices * This,
            /* [in] */ IWbemObjectSink *pSink);
        
        HRESULT ( STDMETHODCALLTYPE *QueryObjectSink )( 
            IWbemServices * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink **ppResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            IWbemServices * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemClassObject **ppObject,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectAsync )( 
            IWbemServices * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *PutClass )( 
            IWbemServices * This,
            /* [in] */ IWbemClassObject *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *PutClassAsync )( 
            IWbemServices * This,
            /* [in] */ IWbemClassObject *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteClass )( 
            IWbemServices * This,
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteClassAsync )( 
            IWbemServices * This,
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *CreateClassEnum )( 
            IWbemServices * This,
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CreateClassEnumAsync )( 
            IWbemServices * This,
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *PutInstance )( 
            IWbemServices * This,
            /* [in] */ IWbemClassObject *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *PutInstanceAsync )( 
            IWbemServices * This,
            /* [in] */ IWbemClassObject *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteInstance )( 
            IWbemServices * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteInstanceAsync )( 
            IWbemServices * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *CreateInstanceEnum )( 
            IWbemServices * This,
            /* [in] */ const BSTR strFilter,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CreateInstanceEnumAsync )( 
            IWbemServices * This,
            /* [in] */ const BSTR strFilter,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *ExecQuery )( 
            IWbemServices * This,
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *ExecQueryAsync )( 
            IWbemServices * This,
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *ExecNotificationQuery )( 
            IWbemServices * This,
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *ExecNotificationQueryAsync )( 
            IWbemServices * This,
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *ExecMethod )( 
            IWbemServices * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemClassObject *pInParams,
            /* [unique][in][out] */ IWbemClassObject **ppOutParams,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *ExecMethodAsync )( 
            IWbemServices * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemClassObject *pInParams,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        END_INTERFACE
    } IWbemServicesVtbl;

    interface IWbemServices
    {
        CONST_VTBL struct IWbemServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemServices_OpenNamespace(This,strNamespace,lFlags,pCtx,ppWorkingNamespace,ppResult)	\
    (This)->lpVtbl -> OpenNamespace(This,strNamespace,lFlags,pCtx,ppWorkingNamespace,ppResult)

#define IWbemServices_CancelAsyncCall(This,pSink)	\
    (This)->lpVtbl -> CancelAsyncCall(This,pSink)

#define IWbemServices_QueryObjectSink(This,lFlags,ppResponseHandler)	\
    (This)->lpVtbl -> QueryObjectSink(This,lFlags,ppResponseHandler)

#define IWbemServices_GetObject(This,strObjectPath,lFlags,pCtx,ppObject,ppCallResult)	\
    (This)->lpVtbl -> GetObject(This,strObjectPath,lFlags,pCtx,ppObject,ppCallResult)

#define IWbemServices_GetObjectAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> GetObjectAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)

#define IWbemServices_PutClass(This,pObject,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> PutClass(This,pObject,lFlags,pCtx,ppCallResult)

#define IWbemServices_PutClassAsync(This,pObject,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> PutClassAsync(This,pObject,lFlags,pCtx,pResponseHandler)

#define IWbemServices_DeleteClass(This,strClass,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> DeleteClass(This,strClass,lFlags,pCtx,ppCallResult)

#define IWbemServices_DeleteClassAsync(This,strClass,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> DeleteClassAsync(This,strClass,lFlags,pCtx,pResponseHandler)

#define IWbemServices_CreateClassEnum(This,strSuperclass,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> CreateClassEnum(This,strSuperclass,lFlags,pCtx,ppEnum)

#define IWbemServices_CreateClassEnumAsync(This,strSuperclass,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> CreateClassEnumAsync(This,strSuperclass,lFlags,pCtx,pResponseHandler)

#define IWbemServices_PutInstance(This,pInst,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> PutInstance(This,pInst,lFlags,pCtx,ppCallResult)

#define IWbemServices_PutInstanceAsync(This,pInst,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> PutInstanceAsync(This,pInst,lFlags,pCtx,pResponseHandler)

#define IWbemServices_DeleteInstance(This,strObjectPath,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> DeleteInstance(This,strObjectPath,lFlags,pCtx,ppCallResult)

#define IWbemServices_DeleteInstanceAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> DeleteInstanceAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)

#define IWbemServices_CreateInstanceEnum(This,strFilter,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> CreateInstanceEnum(This,strFilter,lFlags,pCtx,ppEnum)

#define IWbemServices_CreateInstanceEnumAsync(This,strFilter,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> CreateInstanceEnumAsync(This,strFilter,lFlags,pCtx,pResponseHandler)

#define IWbemServices_ExecQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> ExecQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)

#define IWbemServices_ExecQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> ExecQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)

#define IWbemServices_ExecNotificationQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> ExecNotificationQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)

#define IWbemServices_ExecNotificationQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> ExecNotificationQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)

#define IWbemServices_ExecMethod(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,ppOutParams,ppCallResult)	\
    (This)->lpVtbl -> ExecMethod(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,ppOutParams,ppCallResult)

#define IWbemServices_ExecMethodAsync(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,pResponseHandler)	\
    (This)->lpVtbl -> ExecMethodAsync(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,pResponseHandler)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemServices_OpenNamespace_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strNamespace,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemServices **ppWorkingNamespace,
    /* [unique][in][out] */ IWbemCallResult **ppResult);


void __RPC_STUB IWbemServices_OpenNamespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_CancelAsyncCall_Proxy( 
    IWbemServices * This,
    /* [in] */ IWbemObjectSink *pSink);


void __RPC_STUB IWbemServices_CancelAsyncCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_QueryObjectSink_Proxy( 
    IWbemServices * This,
    /* [in] */ long lFlags,
    /* [out] */ IWbemObjectSink **ppResponseHandler);


void __RPC_STUB IWbemServices_QueryObjectSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_GetObject_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemClassObject **ppObject,
    /* [unique][in][out] */ IWbemCallResult **ppCallResult);


void __RPC_STUB IWbemServices_GetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_GetObjectAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_GetObjectAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_PutClass_Proxy( 
    IWbemServices * This,
    /* [in] */ IWbemClassObject *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemCallResult **ppCallResult);


void __RPC_STUB IWbemServices_PutClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_PutClassAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ IWbemClassObject *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_PutClassAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_DeleteClass_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemCallResult **ppCallResult);


void __RPC_STUB IWbemServices_DeleteClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_DeleteClassAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strClass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_DeleteClassAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_CreateClassEnum_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strSuperclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [out] */ IEnumWbemClassObject **ppEnum);


void __RPC_STUB IWbemServices_CreateClassEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_CreateClassEnumAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strSuperclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_CreateClassEnumAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_PutInstance_Proxy( 
    IWbemServices * This,
    /* [in] */ IWbemClassObject *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemCallResult **ppCallResult);


void __RPC_STUB IWbemServices_PutInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_PutInstanceAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ IWbemClassObject *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_PutInstanceAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_DeleteInstance_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemCallResult **ppCallResult);


void __RPC_STUB IWbemServices_DeleteInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_DeleteInstanceAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_DeleteInstanceAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_CreateInstanceEnum_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strFilter,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [out] */ IEnumWbemClassObject **ppEnum);


void __RPC_STUB IWbemServices_CreateInstanceEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_CreateInstanceEnumAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strFilter,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_CreateInstanceEnumAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecQuery_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [out] */ IEnumWbemClassObject **ppEnum);


void __RPC_STUB IWbemServices_ExecQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecQueryAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_ExecQueryAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecNotificationQuery_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [out] */ IEnumWbemClassObject **ppEnum);


void __RPC_STUB IWbemServices_ExecNotificationQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecNotificationQueryAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strQueryLanguage,
    /* [in] */ const BSTR strQuery,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_ExecNotificationQueryAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecMethod_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemClassObject *pInParams,
    /* [unique][in][out] */ IWbemClassObject **ppOutParams,
    /* [unique][in][out] */ IWbemCallResult **ppCallResult);


void __RPC_STUB IWbemServices_ExecMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServices_ExecMethodAsync_Proxy( 
    IWbemServices * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ const BSTR strMethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemClassObject *pInParams,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServices_ExecMethodAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemServices_INTERFACE_DEFINED__ */


#ifndef __IWbemServicesEx_INTERFACE_DEFINED__
#define __IWbemServicesEx_INTERFACE_DEFINED__

/* interface IWbemServicesEx */
/* [unique][uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemServicesEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6D54E7AD-7583-4d53-BC14-CE2678F73DB3")
    IWbemServicesEx : public IWbemServices
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ const BSTR strScope,
            /* [in] */ const BSTR strSelector,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemServicesEx **ppScope,
            /* [unique][in][out] */ IWbemCallResultEx **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenAsync( 
            /* [in] */ const BSTR strScope,
            /* [in] */ const BSTR strSelector,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSinkEx *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RefreshObject( 
            /* [out][in] */ IWbemClassObject **pTarget,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RefreshObjectAsync( 
            /* [out][in] */ IWbemClassObject **pTarget,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSinkEx *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenameObject( 
            /* [in] */ const BSTR strOldObjectPath,
            /* [in] */ const BSTR strNewObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenameObjectAsync( 
            /* [in] */ const BSTR strOldObjectPath,
            /* [in] */ const BSTR strNewObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteObject( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteObjectAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutObject( 
            /* [in] */ IWbemClassObject *pObj,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutObjectAsync( 
            /* [in] */ IWbemClassObject *pObj,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemServicesExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemServicesEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemServicesEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemServicesEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *OpenNamespace )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemServices **ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *CancelAsyncCall )( 
            IWbemServicesEx * This,
            /* [in] */ IWbemObjectSink *pSink);
        
        HRESULT ( STDMETHODCALLTYPE *QueryObjectSink )( 
            IWbemServicesEx * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink **ppResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemClassObject **ppObject,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectAsync )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *PutClass )( 
            IWbemServicesEx * This,
            /* [in] */ IWbemClassObject *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *PutClassAsync )( 
            IWbemServicesEx * This,
            /* [in] */ IWbemClassObject *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteClass )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteClassAsync )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *CreateClassEnum )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CreateClassEnumAsync )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *PutInstance )( 
            IWbemServicesEx * This,
            /* [in] */ IWbemClassObject *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *PutInstanceAsync )( 
            IWbemServicesEx * This,
            /* [in] */ IWbemClassObject *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteInstance )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteInstanceAsync )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *CreateInstanceEnum )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strFilter,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CreateInstanceEnumAsync )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strFilter,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *ExecQuery )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *ExecQueryAsync )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *ExecNotificationQuery )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IEnumWbemClassObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *ExecNotificationQueryAsync )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *ExecMethod )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemClassObject *pInParams,
            /* [unique][in][out] */ IWbemClassObject **ppOutParams,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *ExecMethodAsync )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemClassObject *pInParams,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *Open )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strScope,
            /* [in] */ const BSTR strSelector,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemServicesEx **ppScope,
            /* [unique][in][out] */ IWbemCallResultEx **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *OpenAsync )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strScope,
            /* [in] */ const BSTR strSelector,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSinkEx *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *AddAsync )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAsync )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *RefreshObject )( 
            IWbemServicesEx * This,
            /* [out][in] */ IWbemClassObject **pTarget,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *RefreshObjectAsync )( 
            IWbemServicesEx * This,
            /* [out][in] */ IWbemClassObject **pTarget,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSinkEx *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *RenameObject )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strOldObjectPath,
            /* [in] */ const BSTR strNewObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResultEx **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *RenameObjectAsync )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strOldObjectPath,
            /* [in] */ const BSTR strNewObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteObject )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteObjectAsync )( 
            IWbemServicesEx * This,
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *PutObject )( 
            IWbemServicesEx * This,
            /* [in] */ IWbemClassObject *pObj,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [unique][in][out] */ IWbemCallResult **ppCallResult);
        
        HRESULT ( STDMETHODCALLTYPE *PutObjectAsync )( 
            IWbemServicesEx * This,
            /* [in] */ IWbemClassObject *pObj,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler);
        
        END_INTERFACE
    } IWbemServicesExVtbl;

    interface IWbemServicesEx
    {
        CONST_VTBL struct IWbemServicesExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemServicesEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemServicesEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemServicesEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemServicesEx_OpenNamespace(This,strNamespace,lFlags,pCtx,ppWorkingNamespace,ppResult)	\
    (This)->lpVtbl -> OpenNamespace(This,strNamespace,lFlags,pCtx,ppWorkingNamespace,ppResult)

#define IWbemServicesEx_CancelAsyncCall(This,pSink)	\
    (This)->lpVtbl -> CancelAsyncCall(This,pSink)

#define IWbemServicesEx_QueryObjectSink(This,lFlags,ppResponseHandler)	\
    (This)->lpVtbl -> QueryObjectSink(This,lFlags,ppResponseHandler)

#define IWbemServicesEx_GetObject(This,strObjectPath,lFlags,pCtx,ppObject,ppCallResult)	\
    (This)->lpVtbl -> GetObject(This,strObjectPath,lFlags,pCtx,ppObject,ppCallResult)

#define IWbemServicesEx_GetObjectAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> GetObjectAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)

#define IWbemServicesEx_PutClass(This,pObject,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> PutClass(This,pObject,lFlags,pCtx,ppCallResult)

#define IWbemServicesEx_PutClassAsync(This,pObject,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> PutClassAsync(This,pObject,lFlags,pCtx,pResponseHandler)

#define IWbemServicesEx_DeleteClass(This,strClass,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> DeleteClass(This,strClass,lFlags,pCtx,ppCallResult)

#define IWbemServicesEx_DeleteClassAsync(This,strClass,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> DeleteClassAsync(This,strClass,lFlags,pCtx,pResponseHandler)

#define IWbemServicesEx_CreateClassEnum(This,strSuperclass,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> CreateClassEnum(This,strSuperclass,lFlags,pCtx,ppEnum)

#define IWbemServicesEx_CreateClassEnumAsync(This,strSuperclass,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> CreateClassEnumAsync(This,strSuperclass,lFlags,pCtx,pResponseHandler)

#define IWbemServicesEx_PutInstance(This,pInst,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> PutInstance(This,pInst,lFlags,pCtx,ppCallResult)

#define IWbemServicesEx_PutInstanceAsync(This,pInst,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> PutInstanceAsync(This,pInst,lFlags,pCtx,pResponseHandler)

#define IWbemServicesEx_DeleteInstance(This,strObjectPath,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> DeleteInstance(This,strObjectPath,lFlags,pCtx,ppCallResult)

#define IWbemServicesEx_DeleteInstanceAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> DeleteInstanceAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)

#define IWbemServicesEx_CreateInstanceEnum(This,strFilter,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> CreateInstanceEnum(This,strFilter,lFlags,pCtx,ppEnum)

#define IWbemServicesEx_CreateInstanceEnumAsync(This,strFilter,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> CreateInstanceEnumAsync(This,strFilter,lFlags,pCtx,pResponseHandler)

#define IWbemServicesEx_ExecQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> ExecQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)

#define IWbemServicesEx_ExecQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> ExecQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)

#define IWbemServicesEx_ExecNotificationQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> ExecNotificationQuery(This,strQueryLanguage,strQuery,lFlags,pCtx,ppEnum)

#define IWbemServicesEx_ExecNotificationQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> ExecNotificationQueryAsync(This,strQueryLanguage,strQuery,lFlags,pCtx,pResponseHandler)

#define IWbemServicesEx_ExecMethod(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,ppOutParams,ppCallResult)	\
    (This)->lpVtbl -> ExecMethod(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,ppOutParams,ppCallResult)

#define IWbemServicesEx_ExecMethodAsync(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,pResponseHandler)	\
    (This)->lpVtbl -> ExecMethodAsync(This,strObjectPath,strMethodName,lFlags,pCtx,pInParams,pResponseHandler)


#define IWbemServicesEx_Open(This,strScope,strSelector,lFlags,pCtx,ppScope,ppResult)	\
    (This)->lpVtbl -> Open(This,strScope,strSelector,lFlags,pCtx,ppScope,ppResult)

#define IWbemServicesEx_OpenAsync(This,strScope,strSelector,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> OpenAsync(This,strScope,strSelector,lFlags,pCtx,pResponseHandler)

#define IWbemServicesEx_Add(This,strObjectPath,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> Add(This,strObjectPath,lFlags,pCtx,ppCallResult)

#define IWbemServicesEx_AddAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> AddAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)

#define IWbemServicesEx_Remove(This,strObjectPath,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> Remove(This,strObjectPath,lFlags,pCtx,ppCallResult)

#define IWbemServicesEx_RemoveAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> RemoveAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)

#define IWbemServicesEx_RefreshObject(This,pTarget,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> RefreshObject(This,pTarget,lFlags,pCtx,ppCallResult)

#define IWbemServicesEx_RefreshObjectAsync(This,pTarget,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> RefreshObjectAsync(This,pTarget,lFlags,pCtx,pResponseHandler)

#define IWbemServicesEx_RenameObject(This,strOldObjectPath,strNewObjectPath,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> RenameObject(This,strOldObjectPath,strNewObjectPath,lFlags,pCtx,ppCallResult)

#define IWbemServicesEx_RenameObjectAsync(This,strOldObjectPath,strNewObjectPath,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> RenameObjectAsync(This,strOldObjectPath,strNewObjectPath,lFlags,pCtx,pResponseHandler)

#define IWbemServicesEx_DeleteObject(This,strObjectPath,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> DeleteObject(This,strObjectPath,lFlags,pCtx,ppCallResult)

#define IWbemServicesEx_DeleteObjectAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> DeleteObjectAsync(This,strObjectPath,lFlags,pCtx,pResponseHandler)

#define IWbemServicesEx_PutObject(This,pObj,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> PutObject(This,pObj,lFlags,pCtx,ppCallResult)

#define IWbemServicesEx_PutObjectAsync(This,pObj,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> PutObjectAsync(This,pObj,lFlags,pCtx,pResponseHandler)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemServicesEx_Open_Proxy( 
    IWbemServicesEx * This,
    /* [in] */ const BSTR strScope,
    /* [in] */ const BSTR strSelector,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemServicesEx **ppScope,
    /* [unique][in][out] */ IWbemCallResultEx **ppResult);


void __RPC_STUB IWbemServicesEx_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServicesEx_OpenAsync_Proxy( 
    IWbemServicesEx * This,
    /* [in] */ const BSTR strScope,
    /* [in] */ const BSTR strSelector,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSinkEx *pResponseHandler);


void __RPC_STUB IWbemServicesEx_OpenAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServicesEx_Add_Proxy( 
    IWbemServicesEx * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemCallResultEx **ppCallResult);


void __RPC_STUB IWbemServicesEx_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServicesEx_AddAsync_Proxy( 
    IWbemServicesEx * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServicesEx_AddAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServicesEx_Remove_Proxy( 
    IWbemServicesEx * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemCallResultEx **ppCallResult);


void __RPC_STUB IWbemServicesEx_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServicesEx_RemoveAsync_Proxy( 
    IWbemServicesEx * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServicesEx_RemoveAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServicesEx_RefreshObject_Proxy( 
    IWbemServicesEx * This,
    /* [out][in] */ IWbemClassObject **pTarget,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemCallResultEx **ppCallResult);


void __RPC_STUB IWbemServicesEx_RefreshObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServicesEx_RefreshObjectAsync_Proxy( 
    IWbemServicesEx * This,
    /* [out][in] */ IWbemClassObject **pTarget,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSinkEx *pResponseHandler);


void __RPC_STUB IWbemServicesEx_RefreshObjectAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServicesEx_RenameObject_Proxy( 
    IWbemServicesEx * This,
    /* [in] */ const BSTR strOldObjectPath,
    /* [in] */ const BSTR strNewObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemCallResultEx **ppCallResult);


void __RPC_STUB IWbemServicesEx_RenameObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServicesEx_RenameObjectAsync_Proxy( 
    IWbemServicesEx * This,
    /* [in] */ const BSTR strOldObjectPath,
    /* [in] */ const BSTR strNewObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServicesEx_RenameObjectAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServicesEx_DeleteObject_Proxy( 
    IWbemServicesEx * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemCallResult **ppCallResult);


void __RPC_STUB IWbemServicesEx_DeleteObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServicesEx_DeleteObjectAsync_Proxy( 
    IWbemServicesEx * This,
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServicesEx_DeleteObjectAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServicesEx_PutObject_Proxy( 
    IWbemServicesEx * This,
    /* [in] */ IWbemClassObject *pObj,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [unique][in][out] */ IWbemCallResult **ppCallResult);


void __RPC_STUB IWbemServicesEx_PutObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemServicesEx_PutObjectAsync_Proxy( 
    IWbemServicesEx * This,
    /* [in] */ IWbemClassObject *pObj,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemObjectSink *pResponseHandler);


void __RPC_STUB IWbemServicesEx_PutObjectAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemServicesEx_INTERFACE_DEFINED__ */


#ifndef __IWbemLocator_INTERFACE_DEFINED__
#define __IWbemLocator_INTERFACE_DEFINED__

/* interface IWbemLocator */
/* [unique][uuid][local][restricted][object] */ 


EXTERN_C const IID IID_IWbemLocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dc12a687-737f-11cf-884d-00aa004b2e24")
    IWbemLocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ConnectServer( 
            /* [in] */ const BSTR strNetworkResource,
            /* [in] */ const BSTR strUser,
            /* [in] */ const BSTR strPassword,
            /* [in] */ const BSTR strLocale,
            /* [in] */ long lSecurityFlags,
            /* [in] */ const BSTR strAuthority,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IWbemServices **ppNamespace) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemLocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemLocator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemLocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemLocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConnectServer )( 
            IWbemLocator * This,
            /* [in] */ const BSTR strNetworkResource,
            /* [in] */ const BSTR strUser,
            /* [in] */ const BSTR strPassword,
            /* [in] */ const BSTR strLocale,
            /* [in] */ long lSecurityFlags,
            /* [in] */ const BSTR strAuthority,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IWbemServices **ppNamespace);
        
        END_INTERFACE
    } IWbemLocatorVtbl;

    interface IWbemLocator
    {
        CONST_VTBL struct IWbemLocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemLocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemLocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemLocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemLocator_ConnectServer(This,strNetworkResource,strUser,strPassword,strLocale,lSecurityFlags,strAuthority,pCtx,ppNamespace)	\
    (This)->lpVtbl -> ConnectServer(This,strNetworkResource,strUser,strPassword,strLocale,lSecurityFlags,strAuthority,pCtx,ppNamespace)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemLocator_ConnectServer_Proxy( 
    IWbemLocator * This,
    /* [in] */ const BSTR strNetworkResource,
    /* [in] */ const BSTR strUser,
    /* [in] */ const BSTR strPassword,
    /* [in] */ const BSTR strLocale,
    /* [in] */ long lSecurityFlags,
    /* [in] */ const BSTR strAuthority,
    /* [in] */ IWbemContext *pCtx,
    /* [out] */ IWbemServices **ppNamespace);


void __RPC_STUB IWbemLocator_ConnectServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemLocator_INTERFACE_DEFINED__ */


#ifndef __IWbemConnection_INTERFACE_DEFINED__
#define __IWbemConnection_INTERFACE_DEFINED__

/* interface IWbemConnection */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IWbemConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("180d6598-e042-4b71-b0a2-6e2d16daf293")
    IWbemConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ const BSTR strObject,
            /* [in] */ const BSTR strUser,
            /* [in] */ const BSTR strPassword,
            /* [in] */ const BSTR strLocale,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **pInterface,
            /* [out] */ IWbemCallResultEx **pCallRes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenAsync( 
            /* [in] */ const BSTR strObject,
            /* [in] */ const BSTR strUser,
            /* [in] */ const BSTR strPassword,
            /* [in] */ const BSTR strLocale,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ REFIID riid,
            /* [in] */ IWbemObjectSinkEx *pResponseHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( 
            /* [in] */ long lFlags,
            /* [in] */ IWbemObjectSinkEx *pHandler) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Open )( 
            IWbemConnection * This,
            /* [in] */ const BSTR strObject,
            /* [in] */ const BSTR strUser,
            /* [in] */ const BSTR strPassword,
            /* [in] */ const BSTR strLocale,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **pInterface,
            /* [out] */ IWbemCallResultEx **pCallRes);
        
        HRESULT ( STDMETHODCALLTYPE *OpenAsync )( 
            IWbemConnection * This,
            /* [in] */ const BSTR strObject,
            /* [in] */ const BSTR strUser,
            /* [in] */ const BSTR strPassword,
            /* [in] */ const BSTR strLocale,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ REFIID riid,
            /* [in] */ IWbemObjectSinkEx *pResponseHandler);
        
        HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IWbemConnection * This,
            /* [in] */ long lFlags,
            /* [in] */ IWbemObjectSinkEx *pHandler);
        
        END_INTERFACE
    } IWbemConnectionVtbl;

    interface IWbemConnection
    {
        CONST_VTBL struct IWbemConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemConnection_Open(This,strObject,strUser,strPassword,strLocale,lFlags,pCtx,riid,pInterface,pCallRes)	\
    (This)->lpVtbl -> Open(This,strObject,strUser,strPassword,strLocale,lFlags,pCtx,riid,pInterface,pCallRes)

#define IWbemConnection_OpenAsync(This,strObject,strUser,strPassword,strLocale,lFlags,pCtx,riid,pResponseHandler)	\
    (This)->lpVtbl -> OpenAsync(This,strObject,strUser,strPassword,strLocale,lFlags,pCtx,riid,pResponseHandler)

#define IWbemConnection_Cancel(This,lFlags,pHandler)	\
    (This)->lpVtbl -> Cancel(This,lFlags,pHandler)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemConnection_Open_Proxy( 
    IWbemConnection * This,
    /* [in] */ const BSTR strObject,
    /* [in] */ const BSTR strUser,
    /* [in] */ const BSTR strPassword,
    /* [in] */ const BSTR strLocale,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **pInterface,
    /* [out] */ IWbemCallResultEx **pCallRes);


void __RPC_STUB IWbemConnection_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemConnection_OpenAsync_Proxy( 
    IWbemConnection * This,
    /* [in] */ const BSTR strObject,
    /* [in] */ const BSTR strUser,
    /* [in] */ const BSTR strPassword,
    /* [in] */ const BSTR strLocale,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ REFIID riid,
    /* [in] */ IWbemObjectSinkEx *pResponseHandler);


void __RPC_STUB IWbemConnection_OpenAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemConnection_Cancel_Proxy( 
    IWbemConnection * This,
    /* [in] */ long lFlags,
    /* [in] */ IWbemObjectSinkEx *pHandler);


void __RPC_STUB IWbemConnection_Cancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemConnection_INTERFACE_DEFINED__ */


#ifndef __IWbemObjectSink_INTERFACE_DEFINED__
#define __IWbemObjectSink_INTERFACE_DEFINED__

/* interface IWbemObjectSink */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemObjectSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7c857801-7381-11cf-884d-00aa004b2e24")
    IWbemObjectSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Indicate( 
            /* [in] */ long lObjectCount,
            /* [size_is][in] */ IWbemClassObject **apObjArray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject *pObjParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemObjectSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemObjectSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemObjectSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemObjectSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *Indicate )( 
            IWbemObjectSink * This,
            /* [in] */ long lObjectCount,
            /* [size_is][in] */ IWbemClassObject **apObjArray);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            IWbemObjectSink * This,
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject *pObjParam);
        
        END_INTERFACE
    } IWbemObjectSinkVtbl;

    interface IWbemObjectSink
    {
        CONST_VTBL struct IWbemObjectSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemObjectSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemObjectSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemObjectSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemObjectSink_Indicate(This,lObjectCount,apObjArray)	\
    (This)->lpVtbl -> Indicate(This,lObjectCount,apObjArray)

#define IWbemObjectSink_SetStatus(This,lFlags,hResult,strParam,pObjParam)	\
    (This)->lpVtbl -> SetStatus(This,lFlags,hResult,strParam,pObjParam)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemObjectSink_Indicate_Proxy( 
    IWbemObjectSink * This,
    /* [in] */ long lObjectCount,
    /* [size_is][in] */ IWbemClassObject **apObjArray);


void __RPC_STUB IWbemObjectSink_Indicate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectSink_SetStatus_Proxy( 
    IWbemObjectSink * This,
    /* [in] */ long lFlags,
    /* [in] */ HRESULT hResult,
    /* [in] */ BSTR strParam,
    /* [in] */ IWbemClassObject *pObjParam);


void __RPC_STUB IWbemObjectSink_SetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemObjectSink_INTERFACE_DEFINED__ */


#ifndef __IEnumWbemClassObject_INTERFACE_DEFINED__
#define __IEnumWbemClassObject_INTERFACE_DEFINED__

/* interface IEnumWbemClassObject */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IEnumWbemClassObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("027947e1-d731-11ce-a357-000000000001")
    IEnumWbemClassObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lTimeout,
            /* [in] */ ULONG uCount,
            /* [length_is][size_is][out] */ IWbemClassObject **apObjects,
            /* [out] */ ULONG *puReturned) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NextAsync( 
            /* [in] */ ULONG uCount,
            /* [in] */ IWbemObjectSink *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumWbemClassObject **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ long lTimeout,
            /* [in] */ ULONG nCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumWbemClassObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumWbemClassObject * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumWbemClassObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumWbemClassObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumWbemClassObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumWbemClassObject * This,
            /* [in] */ long lTimeout,
            /* [in] */ ULONG uCount,
            /* [length_is][size_is][out] */ IWbemClassObject **apObjects,
            /* [out] */ ULONG *puReturned);
        
        HRESULT ( STDMETHODCALLTYPE *NextAsync )( 
            IEnumWbemClassObject * This,
            /* [in] */ ULONG uCount,
            /* [in] */ IWbemObjectSink *pSink);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumWbemClassObject * This,
            /* [out] */ IEnumWbemClassObject **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumWbemClassObject * This,
            /* [in] */ long lTimeout,
            /* [in] */ ULONG nCount);
        
        END_INTERFACE
    } IEnumWbemClassObjectVtbl;

    interface IEnumWbemClassObject
    {
        CONST_VTBL struct IEnumWbemClassObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumWbemClassObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumWbemClassObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumWbemClassObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumWbemClassObject_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumWbemClassObject_Next(This,lTimeout,uCount,apObjects,puReturned)	\
    (This)->lpVtbl -> Next(This,lTimeout,uCount,apObjects,puReturned)

#define IEnumWbemClassObject_NextAsync(This,uCount,pSink)	\
    (This)->lpVtbl -> NextAsync(This,uCount,pSink)

#define IEnumWbemClassObject_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumWbemClassObject_Skip(This,lTimeout,nCount)	\
    (This)->lpVtbl -> Skip(This,lTimeout,nCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_Reset_Proxy( 
    IEnumWbemClassObject * This);


void __RPC_STUB IEnumWbemClassObject_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_Next_Proxy( 
    IEnumWbemClassObject * This,
    /* [in] */ long lTimeout,
    /* [in] */ ULONG uCount,
    /* [length_is][size_is][out] */ IWbemClassObject **apObjects,
    /* [out] */ ULONG *puReturned);


void __RPC_STUB IEnumWbemClassObject_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_NextAsync_Proxy( 
    IEnumWbemClassObject * This,
    /* [in] */ ULONG uCount,
    /* [in] */ IWbemObjectSink *pSink);


void __RPC_STUB IEnumWbemClassObject_NextAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_Clone_Proxy( 
    IEnumWbemClassObject * This,
    /* [out] */ IEnumWbemClassObject **ppEnum);


void __RPC_STUB IEnumWbemClassObject_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_Skip_Proxy( 
    IEnumWbemClassObject * This,
    /* [in] */ long lTimeout,
    /* [in] */ ULONG nCount);


void __RPC_STUB IEnumWbemClassObject_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumWbemClassObject_INTERFACE_DEFINED__ */


#ifndef __IWbemCallResult_INTERFACE_DEFINED__
#define __IWbemCallResult_INTERFACE_DEFINED__

/* interface IWbemCallResult */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemCallResult;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("44aca675-e8fc-11d0-a07c-00c04fb68820")
    IWbemCallResult : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetResultObject( 
            /* [in] */ long lTimeout,
            /* [out] */ IWbemClassObject **ppResultObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResultString( 
            /* [in] */ long lTimeout,
            /* [out] */ BSTR *pstrResultString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResultServices( 
            /* [in] */ long lTimeout,
            /* [out] */ IWbemServices **ppServices) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCallStatus( 
            /* [in] */ long lTimeout,
            /* [out] */ long *plStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemCallResultVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemCallResult * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemCallResult * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemCallResult * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetResultObject )( 
            IWbemCallResult * This,
            /* [in] */ long lTimeout,
            /* [out] */ IWbemClassObject **ppResultObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetResultString )( 
            IWbemCallResult * This,
            /* [in] */ long lTimeout,
            /* [out] */ BSTR *pstrResultString);
        
        HRESULT ( STDMETHODCALLTYPE *GetResultServices )( 
            IWbemCallResult * This,
            /* [in] */ long lTimeout,
            /* [out] */ IWbemServices **ppServices);
        
        HRESULT ( STDMETHODCALLTYPE *GetCallStatus )( 
            IWbemCallResult * This,
            /* [in] */ long lTimeout,
            /* [out] */ long *plStatus);
        
        END_INTERFACE
    } IWbemCallResultVtbl;

    interface IWbemCallResult
    {
        CONST_VTBL struct IWbemCallResultVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemCallResult_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemCallResult_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemCallResult_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemCallResult_GetResultObject(This,lTimeout,ppResultObject)	\
    (This)->lpVtbl -> GetResultObject(This,lTimeout,ppResultObject)

#define IWbemCallResult_GetResultString(This,lTimeout,pstrResultString)	\
    (This)->lpVtbl -> GetResultString(This,lTimeout,pstrResultString)

#define IWbemCallResult_GetResultServices(This,lTimeout,ppServices)	\
    (This)->lpVtbl -> GetResultServices(This,lTimeout,ppServices)

#define IWbemCallResult_GetCallStatus(This,lTimeout,plStatus)	\
    (This)->lpVtbl -> GetCallStatus(This,lTimeout,plStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemCallResult_GetResultObject_Proxy( 
    IWbemCallResult * This,
    /* [in] */ long lTimeout,
    /* [out] */ IWbemClassObject **ppResultObject);


void __RPC_STUB IWbemCallResult_GetResultObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemCallResult_GetResultString_Proxy( 
    IWbemCallResult * This,
    /* [in] */ long lTimeout,
    /* [out] */ BSTR *pstrResultString);


void __RPC_STUB IWbemCallResult_GetResultString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemCallResult_GetResultServices_Proxy( 
    IWbemCallResult * This,
    /* [in] */ long lTimeout,
    /* [out] */ IWbemServices **ppServices);


void __RPC_STUB IWbemCallResult_GetResultServices_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemCallResult_GetCallStatus_Proxy( 
    IWbemCallResult * This,
    /* [in] */ long lTimeout,
    /* [out] */ long *plStatus);


void __RPC_STUB IWbemCallResult_GetCallStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemCallResult_INTERFACE_DEFINED__ */


#ifndef __IWbemCallResultEx_INTERFACE_DEFINED__
#define __IWbemCallResultEx_INTERFACE_DEFINED__

/* interface IWbemCallResultEx */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemCallResultEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c1e2d758-cabd-11d3-a11b-00105a1f515a")
    IWbemCallResultEx : public IWbemCallResult
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetResult( 
            /* [in] */ long lTimeout,
            /* [in] */ long lFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemCallResultExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemCallResultEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemCallResultEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemCallResultEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetResultObject )( 
            IWbemCallResultEx * This,
            /* [in] */ long lTimeout,
            /* [out] */ IWbemClassObject **ppResultObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetResultString )( 
            IWbemCallResultEx * This,
            /* [in] */ long lTimeout,
            /* [out] */ BSTR *pstrResultString);
        
        HRESULT ( STDMETHODCALLTYPE *GetResultServices )( 
            IWbemCallResultEx * This,
            /* [in] */ long lTimeout,
            /* [out] */ IWbemServices **ppServices);
        
        HRESULT ( STDMETHODCALLTYPE *GetCallStatus )( 
            IWbemCallResultEx * This,
            /* [in] */ long lTimeout,
            /* [out] */ long *plStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetResult )( 
            IWbemCallResultEx * This,
            /* [in] */ long lTimeout,
            /* [in] */ long lFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvResult);
        
        END_INTERFACE
    } IWbemCallResultExVtbl;

    interface IWbemCallResultEx
    {
        CONST_VTBL struct IWbemCallResultExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemCallResultEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemCallResultEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemCallResultEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemCallResultEx_GetResultObject(This,lTimeout,ppResultObject)	\
    (This)->lpVtbl -> GetResultObject(This,lTimeout,ppResultObject)

#define IWbemCallResultEx_GetResultString(This,lTimeout,pstrResultString)	\
    (This)->lpVtbl -> GetResultString(This,lTimeout,pstrResultString)

#define IWbemCallResultEx_GetResultServices(This,lTimeout,ppServices)	\
    (This)->lpVtbl -> GetResultServices(This,lTimeout,ppServices)

#define IWbemCallResultEx_GetCallStatus(This,lTimeout,plStatus)	\
    (This)->lpVtbl -> GetCallStatus(This,lTimeout,plStatus)


#define IWbemCallResultEx_GetResult(This,lTimeout,lFlags,riid,ppvResult)	\
    (This)->lpVtbl -> GetResult(This,lTimeout,lFlags,riid,ppvResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemCallResultEx_GetResult_Proxy( 
    IWbemCallResultEx * This,
    /* [in] */ long lTimeout,
    /* [in] */ long lFlags,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppvResult);


void __RPC_STUB IWbemCallResultEx_GetResult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemCallResultEx_INTERFACE_DEFINED__ */


#ifndef __IWbemContext_INTERFACE_DEFINED__
#define __IWbemContext_INTERFACE_DEFINED__

/* interface IWbemContext */
/* [uuid][local][restricted][object] */ 


EXTERN_C const IID IID_IWbemContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("44aca674-e8fc-11d0-a07c-00c04fb68820")
    IWbemContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IWbemContext **ppNewCopy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNames( 
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY * *pNames) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginEnumeration( 
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lFlags,
            /* [out] */ BSTR *pstrName,
            /* [out] */ VARIANT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndEnumeration( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [out] */ VARIANT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteValue( 
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteAll( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IWbemContext * This,
            /* [out] */ IWbemContext **ppNewCopy);
        
        HRESULT ( STDMETHODCALLTYPE *GetNames )( 
            IWbemContext * This,
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY * *pNames);
        
        HRESULT ( STDMETHODCALLTYPE *BeginEnumeration )( 
            IWbemContext * This,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IWbemContext * This,
            /* [in] */ long lFlags,
            /* [out] */ BSTR *pstrName,
            /* [out] */ VARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *EndEnumeration )( 
            IWbemContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            IWbemContext * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IWbemContext * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags,
            /* [out] */ VARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteValue )( 
            IWbemContext * This,
            /* [string][in] */ LPCWSTR wszName,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteAll )( 
            IWbemContext * This);
        
        END_INTERFACE
    } IWbemContextVtbl;

    interface IWbemContext
    {
        CONST_VTBL struct IWbemContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemContext_Clone(This,ppNewCopy)	\
    (This)->lpVtbl -> Clone(This,ppNewCopy)

#define IWbemContext_GetNames(This,lFlags,pNames)	\
    (This)->lpVtbl -> GetNames(This,lFlags,pNames)

#define IWbemContext_BeginEnumeration(This,lFlags)	\
    (This)->lpVtbl -> BeginEnumeration(This,lFlags)

#define IWbemContext_Next(This,lFlags,pstrName,pValue)	\
    (This)->lpVtbl -> Next(This,lFlags,pstrName,pValue)

#define IWbemContext_EndEnumeration(This)	\
    (This)->lpVtbl -> EndEnumeration(This)

#define IWbemContext_SetValue(This,wszName,lFlags,pValue)	\
    (This)->lpVtbl -> SetValue(This,wszName,lFlags,pValue)

#define IWbemContext_GetValue(This,wszName,lFlags,pValue)	\
    (This)->lpVtbl -> GetValue(This,wszName,lFlags,pValue)

#define IWbemContext_DeleteValue(This,wszName,lFlags)	\
    (This)->lpVtbl -> DeleteValue(This,wszName,lFlags)

#define IWbemContext_DeleteAll(This)	\
    (This)->lpVtbl -> DeleteAll(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemContext_Clone_Proxy( 
    IWbemContext * This,
    /* [out] */ IWbemContext **ppNewCopy);


void __RPC_STUB IWbemContext_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_GetNames_Proxy( 
    IWbemContext * This,
    /* [in] */ long lFlags,
    /* [out] */ SAFEARRAY * *pNames);


void __RPC_STUB IWbemContext_GetNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_BeginEnumeration_Proxy( 
    IWbemContext * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemContext_BeginEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_Next_Proxy( 
    IWbemContext * This,
    /* [in] */ long lFlags,
    /* [out] */ BSTR *pstrName,
    /* [out] */ VARIANT *pValue);


void __RPC_STUB IWbemContext_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_EndEnumeration_Proxy( 
    IWbemContext * This);


void __RPC_STUB IWbemContext_EndEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_SetValue_Proxy( 
    IWbemContext * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [in] */ VARIANT *pValue);


void __RPC_STUB IWbemContext_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_GetValue_Proxy( 
    IWbemContext * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags,
    /* [out] */ VARIANT *pValue);


void __RPC_STUB IWbemContext_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_DeleteValue_Proxy( 
    IWbemContext * This,
    /* [string][in] */ LPCWSTR wszName,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemContext_DeleteValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemContext_DeleteAll_Proxy( 
    IWbemContext * This);


void __RPC_STUB IWbemContext_DeleteAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemContext_INTERFACE_DEFINED__ */


#ifndef __IUnsecuredApartment_INTERFACE_DEFINED__
#define __IUnsecuredApartment_INTERFACE_DEFINED__

/* interface IUnsecuredApartment */
/* [object][uuid][restricted] */ 


EXTERN_C const IID IID_IUnsecuredApartment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1cfaba8c-1523-11d1-ad79-00c04fd8fdff")
    IUnsecuredApartment : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateObjectStub( 
            /* [in] */ IUnknown *pObject,
            /* [out] */ IUnknown **ppStub) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUnsecuredApartmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUnsecuredApartment * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUnsecuredApartment * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUnsecuredApartment * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateObjectStub )( 
            IUnsecuredApartment * This,
            /* [in] */ IUnknown *pObject,
            /* [out] */ IUnknown **ppStub);
        
        END_INTERFACE
    } IUnsecuredApartmentVtbl;

    interface IUnsecuredApartment
    {
        CONST_VTBL struct IUnsecuredApartmentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUnsecuredApartment_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUnsecuredApartment_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUnsecuredApartment_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUnsecuredApartment_CreateObjectStub(This,pObject,ppStub)	\
    (This)->lpVtbl -> CreateObjectStub(This,pObject,ppStub)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUnsecuredApartment_CreateObjectStub_Proxy( 
    IUnsecuredApartment * This,
    /* [in] */ IUnknown *pObject,
    /* [out] */ IUnknown **ppStub);


void __RPC_STUB IUnsecuredApartment_CreateObjectStub_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUnsecuredApartment_INTERFACE_DEFINED__ */


#ifndef __IWbemStatusCodeText_INTERFACE_DEFINED__
#define __IWbemStatusCodeText_INTERFACE_DEFINED__

/* interface IWbemStatusCodeText */
/* [uuid][object][local] */ 


EXTERN_C const IID IID_IWbemStatusCodeText;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("eb87e1bc-3233-11d2-aec9-00c04fb68820")
    IWbemStatusCodeText : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetErrorCodeText( 
            /* [in] */ HRESULT hRes,
            /* [in] */ LCID LocaleId,
            /* [in] */ long lFlags,
            /* [out] */ BSTR *MessageText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFacilityCodeText( 
            /* [in] */ HRESULT hRes,
            /* [in] */ LCID LocaleId,
            /* [in] */ long lFlags,
            /* [out] */ BSTR *MessageText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemStatusCodeTextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemStatusCodeText * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemStatusCodeText * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemStatusCodeText * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorCodeText )( 
            IWbemStatusCodeText * This,
            /* [in] */ HRESULT hRes,
            /* [in] */ LCID LocaleId,
            /* [in] */ long lFlags,
            /* [out] */ BSTR *MessageText);
        
        HRESULT ( STDMETHODCALLTYPE *GetFacilityCodeText )( 
            IWbemStatusCodeText * This,
            /* [in] */ HRESULT hRes,
            /* [in] */ LCID LocaleId,
            /* [in] */ long lFlags,
            /* [out] */ BSTR *MessageText);
        
        END_INTERFACE
    } IWbemStatusCodeTextVtbl;

    interface IWbemStatusCodeText
    {
        CONST_VTBL struct IWbemStatusCodeTextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemStatusCodeText_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemStatusCodeText_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemStatusCodeText_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemStatusCodeText_GetErrorCodeText(This,hRes,LocaleId,lFlags,MessageText)	\
    (This)->lpVtbl -> GetErrorCodeText(This,hRes,LocaleId,lFlags,MessageText)

#define IWbemStatusCodeText_GetFacilityCodeText(This,hRes,LocaleId,lFlags,MessageText)	\
    (This)->lpVtbl -> GetFacilityCodeText(This,hRes,LocaleId,lFlags,MessageText)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemStatusCodeText_GetErrorCodeText_Proxy( 
    IWbemStatusCodeText * This,
    /* [in] */ HRESULT hRes,
    /* [in] */ LCID LocaleId,
    /* [in] */ long lFlags,
    /* [out] */ BSTR *MessageText);


void __RPC_STUB IWbemStatusCodeText_GetErrorCodeText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemStatusCodeText_GetFacilityCodeText_Proxy( 
    IWbemStatusCodeText * This,
    /* [in] */ HRESULT hRes,
    /* [in] */ LCID LocaleId,
    /* [in] */ long lFlags,
    /* [out] */ BSTR *MessageText);


void __RPC_STUB IWbemStatusCodeText_GetFacilityCodeText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemStatusCodeText_INTERFACE_DEFINED__ */


#ifndef __IWbemBackupRestore_INTERFACE_DEFINED__
#define __IWbemBackupRestore_INTERFACE_DEFINED__

/* interface IWbemBackupRestore */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemBackupRestore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C49E32C7-BC8B-11d2-85D4-00105A1F8304")
    IWbemBackupRestore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Backup( 
            /* [string][in] */ LPCWSTR strBackupToFile,
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Restore( 
            /* [string][in] */ LPCWSTR strRestoreFromFile,
            /* [in] */ long lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemBackupRestoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemBackupRestore * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemBackupRestore * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemBackupRestore * This);
        
        HRESULT ( STDMETHODCALLTYPE *Backup )( 
            IWbemBackupRestore * This,
            /* [string][in] */ LPCWSTR strBackupToFile,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Restore )( 
            IWbemBackupRestore * This,
            /* [string][in] */ LPCWSTR strRestoreFromFile,
            /* [in] */ long lFlags);
        
        END_INTERFACE
    } IWbemBackupRestoreVtbl;

    interface IWbemBackupRestore
    {
        CONST_VTBL struct IWbemBackupRestoreVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemBackupRestore_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemBackupRestore_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemBackupRestore_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemBackupRestore_Backup(This,strBackupToFile,lFlags)	\
    (This)->lpVtbl -> Backup(This,strBackupToFile,lFlags)

#define IWbemBackupRestore_Restore(This,strRestoreFromFile,lFlags)	\
    (This)->lpVtbl -> Restore(This,strRestoreFromFile,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemBackupRestore_Backup_Proxy( 
    IWbemBackupRestore * This,
    /* [string][in] */ LPCWSTR strBackupToFile,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemBackupRestore_Backup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemBackupRestore_Restore_Proxy( 
    IWbemBackupRestore * This,
    /* [string][in] */ LPCWSTR strRestoreFromFile,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemBackupRestore_Restore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemBackupRestore_INTERFACE_DEFINED__ */


#ifndef __IWbemRefresher_INTERFACE_DEFINED__
#define __IWbemRefresher_INTERFACE_DEFINED__

/* interface IWbemRefresher */
/* [uuid][object][restricted][local] */ 


EXTERN_C const IID IID_IWbemRefresher;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49353c99-516b-11d1-aea6-00c04fb68820")
    IWbemRefresher : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Refresh( 
            /* [in] */ long lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemRefresherVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemRefresher * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemRefresher * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemRefresher * This);
        
        HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IWbemRefresher * This,
            /* [in] */ long lFlags);
        
        END_INTERFACE
    } IWbemRefresherVtbl;

    interface IWbemRefresher
    {
        CONST_VTBL struct IWbemRefresherVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemRefresher_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemRefresher_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemRefresher_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemRefresher_Refresh(This,lFlags)	\
    (This)->lpVtbl -> Refresh(This,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemRefresher_Refresh_Proxy( 
    IWbemRefresher * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemRefresher_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemRefresher_INTERFACE_DEFINED__ */


#ifndef __IWbemHiPerfEnum_INTERFACE_DEFINED__
#define __IWbemHiPerfEnum_INTERFACE_DEFINED__

/* interface IWbemHiPerfEnum */
/* [uuid][object][restricted][local] */ 


EXTERN_C const IID IID_IWbemHiPerfEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2705C288-79AE-11d2-B348-00105A1F8177")
    IWbemHiPerfEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddObjects( 
            /* [in] */ long lFlags,
            /* [in] */ ULONG uNumObjects,
            /* [size_is][in] */ long *apIds,
            /* [size_is][in] */ IWbemObjectAccess **apObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveObjects( 
            /* [in] */ long lFlags,
            /* [in] */ ULONG uNumObjects,
            /* [size_is][in] */ long *apIds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjects( 
            /* [in] */ long lFlags,
            /* [in] */ ULONG uNumObjects,
            /* [length_is][size_is][out] */ IWbemObjectAccess **apObj,
            /* [out] */ ULONG *puReturned) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAll( 
            /* [in] */ long lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemHiPerfEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemHiPerfEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemHiPerfEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemHiPerfEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddObjects )( 
            IWbemHiPerfEnum * This,
            /* [in] */ long lFlags,
            /* [in] */ ULONG uNumObjects,
            /* [size_is][in] */ long *apIds,
            /* [size_is][in] */ IWbemObjectAccess **apObj);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveObjects )( 
            IWbemHiPerfEnum * This,
            /* [in] */ long lFlags,
            /* [in] */ ULONG uNumObjects,
            /* [size_is][in] */ long *apIds);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjects )( 
            IWbemHiPerfEnum * This,
            /* [in] */ long lFlags,
            /* [in] */ ULONG uNumObjects,
            /* [length_is][size_is][out] */ IWbemObjectAccess **apObj,
            /* [out] */ ULONG *puReturned);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAll )( 
            IWbemHiPerfEnum * This,
            /* [in] */ long lFlags);
        
        END_INTERFACE
    } IWbemHiPerfEnumVtbl;

    interface IWbemHiPerfEnum
    {
        CONST_VTBL struct IWbemHiPerfEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemHiPerfEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemHiPerfEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemHiPerfEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemHiPerfEnum_AddObjects(This,lFlags,uNumObjects,apIds,apObj)	\
    (This)->lpVtbl -> AddObjects(This,lFlags,uNumObjects,apIds,apObj)

#define IWbemHiPerfEnum_RemoveObjects(This,lFlags,uNumObjects,apIds)	\
    (This)->lpVtbl -> RemoveObjects(This,lFlags,uNumObjects,apIds)

#define IWbemHiPerfEnum_GetObjects(This,lFlags,uNumObjects,apObj,puReturned)	\
    (This)->lpVtbl -> GetObjects(This,lFlags,uNumObjects,apObj,puReturned)

#define IWbemHiPerfEnum_RemoveAll(This,lFlags)	\
    (This)->lpVtbl -> RemoveAll(This,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemHiPerfEnum_AddObjects_Proxy( 
    IWbemHiPerfEnum * This,
    /* [in] */ long lFlags,
    /* [in] */ ULONG uNumObjects,
    /* [size_is][in] */ long *apIds,
    /* [size_is][in] */ IWbemObjectAccess **apObj);


void __RPC_STUB IWbemHiPerfEnum_AddObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemHiPerfEnum_RemoveObjects_Proxy( 
    IWbemHiPerfEnum * This,
    /* [in] */ long lFlags,
    /* [in] */ ULONG uNumObjects,
    /* [size_is][in] */ long *apIds);


void __RPC_STUB IWbemHiPerfEnum_RemoveObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemHiPerfEnum_GetObjects_Proxy( 
    IWbemHiPerfEnum * This,
    /* [in] */ long lFlags,
    /* [in] */ ULONG uNumObjects,
    /* [length_is][size_is][out] */ IWbemObjectAccess **apObj,
    /* [out] */ ULONG *puReturned);


void __RPC_STUB IWbemHiPerfEnum_GetObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemHiPerfEnum_RemoveAll_Proxy( 
    IWbemHiPerfEnum * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemHiPerfEnum_RemoveAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemHiPerfEnum_INTERFACE_DEFINED__ */


#ifndef __IWbemConfigureRefresher_INTERFACE_DEFINED__
#define __IWbemConfigureRefresher_INTERFACE_DEFINED__

/* interface IWbemConfigureRefresher */
/* [uuid][object][restricted][local] */ 


EXTERN_C const IID IID_IWbemConfigureRefresher;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49353c92-516b-11d1-aea6-00c04fb68820")
    IWbemConfigureRefresher : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddObjectByPath( 
            /* [in] */ IWbemServices *pNamespace,
            /* [string][in] */ LPCWSTR wszPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pContext,
            /* [out] */ IWbemClassObject **ppRefreshable,
            /* [unique][in][out] */ long *plId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddObjectByTemplate( 
            /* [in] */ IWbemServices *pNamespace,
            /* [in] */ IWbemClassObject *pTemplate,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pContext,
            /* [out] */ IWbemClassObject **ppRefreshable,
            /* [unique][in][out] */ long *plId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRefresher( 
            /* [in] */ IWbemRefresher *pRefresher,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ long *plId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ long lId,
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddEnum( 
            /* [in] */ IWbemServices *pNamespace,
            /* [string][in] */ LPCWSTR wszClassName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pContext,
            /* [out] */ IWbemHiPerfEnum **ppEnum,
            /* [unique][in][out] */ long *plId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemConfigureRefresherVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemConfigureRefresher * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemConfigureRefresher * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemConfigureRefresher * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddObjectByPath )( 
            IWbemConfigureRefresher * This,
            /* [in] */ IWbemServices *pNamespace,
            /* [string][in] */ LPCWSTR wszPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pContext,
            /* [out] */ IWbemClassObject **ppRefreshable,
            /* [unique][in][out] */ long *plId);
        
        HRESULT ( STDMETHODCALLTYPE *AddObjectByTemplate )( 
            IWbemConfigureRefresher * This,
            /* [in] */ IWbemServices *pNamespace,
            /* [in] */ IWbemClassObject *pTemplate,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pContext,
            /* [out] */ IWbemClassObject **ppRefreshable,
            /* [unique][in][out] */ long *plId);
        
        HRESULT ( STDMETHODCALLTYPE *AddRefresher )( 
            IWbemConfigureRefresher * This,
            /* [in] */ IWbemRefresher *pRefresher,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ long *plId);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IWbemConfigureRefresher * This,
            /* [in] */ long lId,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE *AddEnum )( 
            IWbemConfigureRefresher * This,
            /* [in] */ IWbemServices *pNamespace,
            /* [string][in] */ LPCWSTR wszClassName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pContext,
            /* [out] */ IWbemHiPerfEnum **ppEnum,
            /* [unique][in][out] */ long *plId);
        
        END_INTERFACE
    } IWbemConfigureRefresherVtbl;

    interface IWbemConfigureRefresher
    {
        CONST_VTBL struct IWbemConfigureRefresherVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemConfigureRefresher_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemConfigureRefresher_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemConfigureRefresher_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemConfigureRefresher_AddObjectByPath(This,pNamespace,wszPath,lFlags,pContext,ppRefreshable,plId)	\
    (This)->lpVtbl -> AddObjectByPath(This,pNamespace,wszPath,lFlags,pContext,ppRefreshable,plId)

#define IWbemConfigureRefresher_AddObjectByTemplate(This,pNamespace,pTemplate,lFlags,pContext,ppRefreshable,plId)	\
    (This)->lpVtbl -> AddObjectByTemplate(This,pNamespace,pTemplate,lFlags,pContext,ppRefreshable,plId)

#define IWbemConfigureRefresher_AddRefresher(This,pRefresher,lFlags,plId)	\
    (This)->lpVtbl -> AddRefresher(This,pRefresher,lFlags,plId)

#define IWbemConfigureRefresher_Remove(This,lId,lFlags)	\
    (This)->lpVtbl -> Remove(This,lId,lFlags)

#define IWbemConfigureRefresher_AddEnum(This,pNamespace,wszClassName,lFlags,pContext,ppEnum,plId)	\
    (This)->lpVtbl -> AddEnum(This,pNamespace,wszClassName,lFlags,pContext,ppEnum,plId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemConfigureRefresher_AddObjectByPath_Proxy( 
    IWbemConfigureRefresher * This,
    /* [in] */ IWbemServices *pNamespace,
    /* [string][in] */ LPCWSTR wszPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pContext,
    /* [out] */ IWbemClassObject **ppRefreshable,
    /* [unique][in][out] */ long *plId);


void __RPC_STUB IWbemConfigureRefresher_AddObjectByPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemConfigureRefresher_AddObjectByTemplate_Proxy( 
    IWbemConfigureRefresher * This,
    /* [in] */ IWbemServices *pNamespace,
    /* [in] */ IWbemClassObject *pTemplate,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pContext,
    /* [out] */ IWbemClassObject **ppRefreshable,
    /* [unique][in][out] */ long *plId);


void __RPC_STUB IWbemConfigureRefresher_AddObjectByTemplate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemConfigureRefresher_AddRefresher_Proxy( 
    IWbemConfigureRefresher * This,
    /* [in] */ IWbemRefresher *pRefresher,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ long *plId);


void __RPC_STUB IWbemConfigureRefresher_AddRefresher_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemConfigureRefresher_Remove_Proxy( 
    IWbemConfigureRefresher * This,
    /* [in] */ long lId,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemConfigureRefresher_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemConfigureRefresher_AddEnum_Proxy( 
    IWbemConfigureRefresher * This,
    /* [in] */ IWbemServices *pNamespace,
    /* [string][in] */ LPCWSTR wszClassName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pContext,
    /* [out] */ IWbemHiPerfEnum **ppEnum,
    /* [unique][in][out] */ long *plId);


void __RPC_STUB IWbemConfigureRefresher_AddEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemConfigureRefresher_INTERFACE_DEFINED__ */


#ifndef __IWbemSecureObjectSink_INTERFACE_DEFINED__
#define __IWbemSecureObjectSink_INTERFACE_DEFINED__

/* interface IWbemSecureObjectSink */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemSecureObjectSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("75abd540-f492-4161-86a5-37fc8898f69e")
    IWbemSecureObjectSink : public IWbemObjectSink
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IndicateWithSD( 
            /* [in] */ long lNumObjects,
            /* [size_is][in] */ IUnknown **apObjects,
            /* [in] */ long lSDLength,
            /* [size_is][in] */ BYTE *pSD) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemSecureObjectSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemSecureObjectSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemSecureObjectSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemSecureObjectSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *Indicate )( 
            IWbemSecureObjectSink * This,
            /* [in] */ long lObjectCount,
            /* [size_is][in] */ IWbemClassObject **apObjArray);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            IWbemSecureObjectSink * This,
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject *pObjParam);
        
        HRESULT ( STDMETHODCALLTYPE *IndicateWithSD )( 
            IWbemSecureObjectSink * This,
            /* [in] */ long lNumObjects,
            /* [size_is][in] */ IUnknown **apObjects,
            /* [in] */ long lSDLength,
            /* [size_is][in] */ BYTE *pSD);
        
        END_INTERFACE
    } IWbemSecureObjectSinkVtbl;

    interface IWbemSecureObjectSink
    {
        CONST_VTBL struct IWbemSecureObjectSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemSecureObjectSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemSecureObjectSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemSecureObjectSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemSecureObjectSink_Indicate(This,lObjectCount,apObjArray)	\
    (This)->lpVtbl -> Indicate(This,lObjectCount,apObjArray)

#define IWbemSecureObjectSink_SetStatus(This,lFlags,hResult,strParam,pObjParam)	\
    (This)->lpVtbl -> SetStatus(This,lFlags,hResult,strParam,pObjParam)


#define IWbemSecureObjectSink_IndicateWithSD(This,lNumObjects,apObjects,lSDLength,pSD)	\
    (This)->lpVtbl -> IndicateWithSD(This,lNumObjects,apObjects,lSDLength,pSD)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemSecureObjectSink_IndicateWithSD_Proxy( 
    IWbemSecureObjectSink * This,
    /* [in] */ long lNumObjects,
    /* [size_is][in] */ IUnknown **apObjects,
    /* [in] */ long lSDLength,
    /* [size_is][in] */ BYTE *pSD);


void __RPC_STUB IWbemSecureObjectSink_IndicateWithSD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemSecureObjectSink_INTERFACE_DEFINED__ */


#ifndef __IWbemEventSink_INTERFACE_DEFINED__
#define __IWbemEventSink_INTERFACE_DEFINED__

/* interface IWbemEventSink */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemEventSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3ae0080a-7e3a-4366-bf89-0feedc931659")
    IWbemEventSink : public IWbemSecureObjectSink
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetSinkSecurity( 
            /* [in] */ long lSDLength,
            /* [size_is][in] */ BYTE *pSD) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsActive( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRestrictedSink( 
            /* [in] */ long lNumQueries,
            /* [string][size_is][in] */ const LPCWSTR *awszQueries,
            /* [in] */ IUnknown *pCallback,
            /* [out] */ IWbemEventSink **ppSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBatchingParameters( 
            /* [in] */ LONG lFlags,
            /* [in] */ DWORD dwMaxBufferSize,
            /* [in] */ DWORD dwMaxSendLatency) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemEventSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemEventSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemEventSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *Indicate )( 
            IWbemEventSink * This,
            /* [in] */ long lObjectCount,
            /* [size_is][in] */ IWbemClassObject **apObjArray);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            IWbemEventSink * This,
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject *pObjParam);
        
        HRESULT ( STDMETHODCALLTYPE *IndicateWithSD )( 
            IWbemEventSink * This,
            /* [in] */ long lNumObjects,
            /* [size_is][in] */ IUnknown **apObjects,
            /* [in] */ long lSDLength,
            /* [size_is][in] */ BYTE *pSD);
        
        HRESULT ( STDMETHODCALLTYPE *SetSinkSecurity )( 
            IWbemEventSink * This,
            /* [in] */ long lSDLength,
            /* [size_is][in] */ BYTE *pSD);
        
        HRESULT ( STDMETHODCALLTYPE *IsActive )( 
            IWbemEventSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRestrictedSink )( 
            IWbemEventSink * This,
            /* [in] */ long lNumQueries,
            /* [string][size_is][in] */ const LPCWSTR *awszQueries,
            /* [in] */ IUnknown *pCallback,
            /* [out] */ IWbemEventSink **ppSink);
        
        HRESULT ( STDMETHODCALLTYPE *SetBatchingParameters )( 
            IWbemEventSink * This,
            /* [in] */ LONG lFlags,
            /* [in] */ DWORD dwMaxBufferSize,
            /* [in] */ DWORD dwMaxSendLatency);
        
        END_INTERFACE
    } IWbemEventSinkVtbl;

    interface IWbemEventSink
    {
        CONST_VTBL struct IWbemEventSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemEventSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemEventSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemEventSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemEventSink_Indicate(This,lObjectCount,apObjArray)	\
    (This)->lpVtbl -> Indicate(This,lObjectCount,apObjArray)

#define IWbemEventSink_SetStatus(This,lFlags,hResult,strParam,pObjParam)	\
    (This)->lpVtbl -> SetStatus(This,lFlags,hResult,strParam,pObjParam)


#define IWbemEventSink_IndicateWithSD(This,lNumObjects,apObjects,lSDLength,pSD)	\
    (This)->lpVtbl -> IndicateWithSD(This,lNumObjects,apObjects,lSDLength,pSD)


#define IWbemEventSink_SetSinkSecurity(This,lSDLength,pSD)	\
    (This)->lpVtbl -> SetSinkSecurity(This,lSDLength,pSD)

#define IWbemEventSink_IsActive(This)	\
    (This)->lpVtbl -> IsActive(This)

#define IWbemEventSink_GetRestrictedSink(This,lNumQueries,awszQueries,pCallback,ppSink)	\
    (This)->lpVtbl -> GetRestrictedSink(This,lNumQueries,awszQueries,pCallback,ppSink)

#define IWbemEventSink_SetBatchingParameters(This,lFlags,dwMaxBufferSize,dwMaxSendLatency)	\
    (This)->lpVtbl -> SetBatchingParameters(This,lFlags,dwMaxBufferSize,dwMaxSendLatency)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemEventSink_SetSinkSecurity_Proxy( 
    IWbemEventSink * This,
    /* [in] */ long lSDLength,
    /* [size_is][in] */ BYTE *pSD);


void __RPC_STUB IWbemEventSink_SetSinkSecurity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemEventSink_IsActive_Proxy( 
    IWbemEventSink * This);


void __RPC_STUB IWbemEventSink_IsActive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemEventSink_GetRestrictedSink_Proxy( 
    IWbemEventSink * This,
    /* [in] */ long lNumQueries,
    /* [string][size_is][in] */ const LPCWSTR *awszQueries,
    /* [in] */ IUnknown *pCallback,
    /* [out] */ IWbemEventSink **ppSink);


void __RPC_STUB IWbemEventSink_GetRestrictedSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemEventSink_SetBatchingParameters_Proxy( 
    IWbemEventSink * This,
    /* [in] */ LONG lFlags,
    /* [in] */ DWORD dwMaxBufferSize,
    /* [in] */ DWORD dwMaxSendLatency);


void __RPC_STUB IWbemEventSink_SetBatchingParameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemEventSink_INTERFACE_DEFINED__ */


#ifndef __IWbemObjectSinkEx_INTERFACE_DEFINED__
#define __IWbemObjectSinkEx_INTERFACE_DEFINED__

/* interface IWbemObjectSinkEx */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemObjectSinkEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dd0be256-50dc-48a8-9866-b559f279d0f6")
    IWbemObjectSinkEx : public IWbemObjectSink
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ long lFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ void *pComObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemObjectSinkExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemObjectSinkEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemObjectSinkEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemObjectSinkEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *Indicate )( 
            IWbemObjectSinkEx * This,
            /* [in] */ long lObjectCount,
            /* [size_is][in] */ IWbemClassObject **apObjArray);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            IWbemObjectSinkEx * This,
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject *pObjParam);
        
        HRESULT ( STDMETHODCALLTYPE *Set )( 
            IWbemObjectSinkEx * This,
            /* [in] */ long lFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ void *pComObject);
        
        END_INTERFACE
    } IWbemObjectSinkExVtbl;

    interface IWbemObjectSinkEx
    {
        CONST_VTBL struct IWbemObjectSinkExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemObjectSinkEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemObjectSinkEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemObjectSinkEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemObjectSinkEx_Indicate(This,lObjectCount,apObjArray)	\
    (This)->lpVtbl -> Indicate(This,lObjectCount,apObjArray)

#define IWbemObjectSinkEx_SetStatus(This,lFlags,hResult,strParam,pObjParam)	\
    (This)->lpVtbl -> SetStatus(This,lFlags,hResult,strParam,pObjParam)


#define IWbemObjectSinkEx_Set(This,lFlags,riid,pComObject)	\
    (This)->lpVtbl -> Set(This,lFlags,riid,pComObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemObjectSinkEx_Set_Proxy( 
    IWbemObjectSinkEx * This,
    /* [in] */ long lFlags,
    /* [in] */ REFIID riid,
    /* [iid_is][in] */ void *pComObject);


void __RPC_STUB IWbemObjectSinkEx_Set_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemObjectSinkEx_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_WbemLocator;

#ifdef __cplusplus

class DECLSPEC_UUID("4590f811-1d3a-11d0-891f-00aa004b2e24")
WbemLocator;
#endif

EXTERN_C const CLSID CLSID_WbemConnection;

#ifdef __cplusplus

class DECLSPEC_UUID("4c6055d8-84b9-4111-a7d3-6623894eedb3")
WbemConnection;
#endif

EXTERN_C const CLSID CLSID_WbemContext;

#ifdef __cplusplus

class DECLSPEC_UUID("674B6698-EE92-11d0-AD71-00C04FD8FDFF")
WbemContext;
#endif

EXTERN_C const CLSID CLSID_UnsecuredApartment;

#ifdef __cplusplus

class DECLSPEC_UUID("49bd2028-1523-11d1-ad79-00c04fd8fdff")
UnsecuredApartment;
#endif

EXTERN_C const CLSID CLSID_WbemClassObject;

#ifdef __cplusplus

class DECLSPEC_UUID("9A653086-174F-11d2-B5F9-00104B703EFD")
WbemClassObject;
#endif

EXTERN_C const CLSID CLSID_MofCompiler;

#ifdef __cplusplus

class DECLSPEC_UUID("6daf9757-2e37-11d2-aec9-00c04fb68820")
MofCompiler;
#endif

EXTERN_C const CLSID CLSID_WbemStatusCodeText;

#ifdef __cplusplus

class DECLSPEC_UUID("eb87e1bd-3233-11d2-aec9-00c04fb68820")
WbemStatusCodeText;
#endif

EXTERN_C const CLSID CLSID_WbemBackupRestore;

#ifdef __cplusplus

class DECLSPEC_UUID("C49E32C6-BC8B-11d2-85D4-00105A1F8304")
WbemBackupRestore;
#endif

EXTERN_C const CLSID CLSID_WbemRefresher;

#ifdef __cplusplus

class DECLSPEC_UUID("c71566f2-561e-11d1-ad87-00c04fd8fdff")
WbemRefresher;
#endif

EXTERN_C const CLSID CLSID_WbemObjectTextSrc;

#ifdef __cplusplus

class DECLSPEC_UUID("8D1C559D-84F0-4bb3-A7D5-56A7435A9BA6")
WbemObjectTextSrc;
#endif
#endif /* __WbemClient_v1_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_wbemcli_0000 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0000_v0_0_s_ifspec;

/* interface __MIDL_itf_wbemcli_0108 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0108_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0108_v0_0_s_ifspec;

#ifndef __IWbemComBinding_INTERFACE_DEFINED__
#define __IWbemComBinding_INTERFACE_DEFINED__

/* interface IWbemComBinding */
/* [unique][uuid][local][restricted][object] */ 


EXTERN_C const IID IID_IWbemComBinding;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("974CAB5F-D7FD-4c52-958F-E3D94D6CB505")
    IWbemComBinding : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCLSIDArrayForIID( 
            /* [in] */ IWbemServicesEx *pSvcEx,
            /* [in] */ IWbemClassObject *pObject,
            /* [in] */ REFIID riid,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ SAFEARRAY * *pArray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BindComObject( 
            /* [in] */ IWbemServicesEx *pSvcEx,
            /* [in] */ IWbemClassObject *pObject,
            /* [in] */ CLSID ClsId,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ long lFlags,
            /* [in] */ IUnknown *pUnkOuter,
            /* [in] */ DWORD dwClsCntxt,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID *pInterface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCLSIDArrayForNames( 
            /* [in] */ IWbemServicesEx *pSvcEx,
            /* [in] */ IWbemClassObject *pObject,
            /* [size_is][in] */ LPCWSTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY * *pArray) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemComBindingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemComBinding * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemComBinding * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemComBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCLSIDArrayForIID )( 
            IWbemComBinding * This,
            /* [in] */ IWbemServicesEx *pSvcEx,
            /* [in] */ IWbemClassObject *pObject,
            /* [in] */ REFIID riid,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ SAFEARRAY * *pArray);
        
        HRESULT ( STDMETHODCALLTYPE *BindComObject )( 
            IWbemComBinding * This,
            /* [in] */ IWbemServicesEx *pSvcEx,
            /* [in] */ IWbemClassObject *pObject,
            /* [in] */ CLSID ClsId,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ long lFlags,
            /* [in] */ IUnknown *pUnkOuter,
            /* [in] */ DWORD dwClsCntxt,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID *pInterface);
        
        HRESULT ( STDMETHODCALLTYPE *GetCLSIDArrayForNames )( 
            IWbemComBinding * This,
            /* [in] */ IWbemServicesEx *pSvcEx,
            /* [in] */ IWbemClassObject *pObject,
            /* [size_is][in] */ LPCWSTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY * *pArray);
        
        END_INTERFACE
    } IWbemComBindingVtbl;

    interface IWbemComBinding
    {
        CONST_VTBL struct IWbemComBindingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemComBinding_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemComBinding_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemComBinding_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemComBinding_GetCLSIDArrayForIID(This,pSvcEx,pObject,riid,lFlags,pCtx,pArray)	\
    (This)->lpVtbl -> GetCLSIDArrayForIID(This,pSvcEx,pObject,riid,lFlags,pCtx,pArray)

#define IWbemComBinding_BindComObject(This,pSvcEx,pObject,ClsId,pCtx,lFlags,pUnkOuter,dwClsCntxt,riid,pInterface)	\
    (This)->lpVtbl -> BindComObject(This,pSvcEx,pObject,ClsId,pCtx,lFlags,pUnkOuter,dwClsCntxt,riid,pInterface)

#define IWbemComBinding_GetCLSIDArrayForNames(This,pSvcEx,pObject,rgszNames,cNames,lcid,pCtx,lFlags,pArray)	\
    (This)->lpVtbl -> GetCLSIDArrayForNames(This,pSvcEx,pObject,rgszNames,cNames,lcid,pCtx,lFlags,pArray)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemComBinding_GetCLSIDArrayForIID_Proxy( 
    IWbemComBinding * This,
    /* [in] */ IWbemServicesEx *pSvcEx,
    /* [in] */ IWbemClassObject *pObject,
    /* [in] */ REFIID riid,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext *pCtx,
    /* [out] */ SAFEARRAY * *pArray);


void __RPC_STUB IWbemComBinding_GetCLSIDArrayForIID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemComBinding_BindComObject_Proxy( 
    IWbemComBinding * This,
    /* [in] */ IWbemServicesEx *pSvcEx,
    /* [in] */ IWbemClassObject *pObject,
    /* [in] */ CLSID ClsId,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ long lFlags,
    /* [in] */ IUnknown *pUnkOuter,
    /* [in] */ DWORD dwClsCntxt,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ LPVOID *pInterface);


void __RPC_STUB IWbemComBinding_BindComObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemComBinding_GetCLSIDArrayForNames_Proxy( 
    IWbemComBinding * This,
    /* [in] */ IWbemServicesEx *pSvcEx,
    /* [in] */ IWbemClassObject *pObject,
    /* [size_is][in] */ LPCWSTR *rgszNames,
    /* [in] */ UINT cNames,
    /* [in] */ LCID lcid,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ long lFlags,
    /* [out] */ SAFEARRAY * *pArray);


void __RPC_STUB IWbemComBinding_GetCLSIDArrayForNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemComBinding_INTERFACE_DEFINED__ */


#ifndef __IWbemInitComBinding_INTERFACE_DEFINED__
#define __IWbemInitComBinding_INTERFACE_DEFINED__

/* interface IWbemInitComBinding */
/* [unique][uuid][local][restricted][object] */ 


EXTERN_C const IID IID_IWbemInitComBinding;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B4AF2F3C-5FE3-405e-8A9F-D275E3079F6D")
    IWbemInitComBinding : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ ULONG ulFlags,
            /* [in] */ IWbemServicesEx *pSvcEx,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemClassObject *pObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemInitComBindingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemInitComBinding * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemInitComBinding * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemInitComBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IWbemInitComBinding * This,
            /* [in] */ ULONG ulFlags,
            /* [in] */ IWbemServicesEx *pSvcEx,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemClassObject *pObject);
        
        END_INTERFACE
    } IWbemInitComBindingVtbl;

    interface IWbemInitComBinding
    {
        CONST_VTBL struct IWbemInitComBindingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemInitComBinding_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemInitComBinding_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemInitComBinding_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemInitComBinding_Initialize(This,ulFlags,pSvcEx,pCtx,pObject)	\
    (This)->lpVtbl -> Initialize(This,ulFlags,pSvcEx,pCtx,pObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemInitComBinding_Initialize_Proxy( 
    IWbemInitComBinding * This,
    /* [in] */ ULONG ulFlags,
    /* [in] */ IWbemServicesEx *pSvcEx,
    /* [in] */ IWbemContext *pCtx,
    /* [in] */ IWbemClassObject *pObject);


void __RPC_STUB IWbemInitComBinding_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemInitComBinding_INTERFACE_DEFINED__ */


#ifndef __IWbemRawSdAccessor_INTERFACE_DEFINED__
#define __IWbemRawSdAccessor_INTERFACE_DEFINED__

/* interface IWbemRawSdAccessor */
/* [uuid][restricted][object] */ 


EXTERN_C const IID IID_IWbemRawSdAccessor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c1e2d759-cabd-11d3-a11b-00105a1f515a")
    IWbemRawSdAccessor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ long lFlags,
            /* [in] */ ULONG uBufSize,
            /* [out] */ ULONG *puSDSize,
            /* [length_is][size_is][out][in] */ byte *pSD) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Put( 
            /* [in] */ long lFlags,
            /* [in] */ ULONG uBufSize,
            /* [size_is][in] */ byte *pSD) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemRawSdAccessorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemRawSdAccessor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemRawSdAccessor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemRawSdAccessor * This);
        
        HRESULT ( STDMETHODCALLTYPE *Get )( 
            IWbemRawSdAccessor * This,
            /* [in] */ long lFlags,
            /* [in] */ ULONG uBufSize,
            /* [out] */ ULONG *puSDSize,
            /* [length_is][size_is][out][in] */ byte *pSD);
        
        HRESULT ( STDMETHODCALLTYPE *Put )( 
            IWbemRawSdAccessor * This,
            /* [in] */ long lFlags,
            /* [in] */ ULONG uBufSize,
            /* [size_is][in] */ byte *pSD);
        
        END_INTERFACE
    } IWbemRawSdAccessorVtbl;

    interface IWbemRawSdAccessor
    {
        CONST_VTBL struct IWbemRawSdAccessorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemRawSdAccessor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemRawSdAccessor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemRawSdAccessor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemRawSdAccessor_Get(This,lFlags,uBufSize,puSDSize,pSD)	\
    (This)->lpVtbl -> Get(This,lFlags,uBufSize,puSDSize,pSD)

#define IWbemRawSdAccessor_Put(This,lFlags,uBufSize,pSD)	\
    (This)->lpVtbl -> Put(This,lFlags,uBufSize,pSD)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemRawSdAccessor_Get_Proxy( 
    IWbemRawSdAccessor * This,
    /* [in] */ long lFlags,
    /* [in] */ ULONG uBufSize,
    /* [out] */ ULONG *puSDSize,
    /* [length_is][size_is][out][in] */ byte *pSD);


void __RPC_STUB IWbemRawSdAccessor_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemRawSdAccessor_Put_Proxy( 
    IWbemRawSdAccessor * This,
    /* [in] */ long lFlags,
    /* [in] */ ULONG uBufSize,
    /* [size_is][in] */ byte *pSD);


void __RPC_STUB IWbemRawSdAccessor_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemRawSdAccessor_INTERFACE_DEFINED__ */


#ifndef __IWbemShutdown_INTERFACE_DEFINED__
#define __IWbemShutdown_INTERFACE_DEFINED__

/* interface IWbemShutdown */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWbemShutdown;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b7b31df9-d515-11d3-a11c-00105a1f515a")
    IWbemShutdown : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Shutdown( 
            /* [in] */ LONG uReason,
            /* [in] */ ULONG uMaxMilliseconds,
            /* [in] */ IWbemContext *pCtx) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemShutdownVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemShutdown * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemShutdown * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemShutdown * This);
        
        HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            IWbemShutdown * This,
            /* [in] */ LONG uReason,
            /* [in] */ ULONG uMaxMilliseconds,
            /* [in] */ IWbemContext *pCtx);
        
        END_INTERFACE
    } IWbemShutdownVtbl;

    interface IWbemShutdown
    {
        CONST_VTBL struct IWbemShutdownVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemShutdown_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemShutdown_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemShutdown_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemShutdown_Shutdown(This,uReason,uMaxMilliseconds,pCtx)	\
    (This)->lpVtbl -> Shutdown(This,uReason,uMaxMilliseconds,pCtx)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemShutdown_Shutdown_Proxy( 
    IWbemShutdown * This,
    /* [in] */ LONG uReason,
    /* [in] */ ULONG uMaxMilliseconds,
    /* [in] */ IWbemContext *pCtx);


void __RPC_STUB IWbemShutdown_Shutdown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemShutdown_INTERFACE_DEFINED__ */


#ifndef __IWbemCallStatus_INTERFACE_DEFINED__
#define __IWbemCallStatus_INTERFACE_DEFINED__

/* interface IWbemCallStatus */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IWbemCallStatus;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4212dc47-142e-4c6c-bc49-6ca232dd0959")
    IWbemCallStatus : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCallStatus( 
            /* [in] */ ULONG uFlags,
            /* [in] */ LCID lLocale,
            /* [out] */ HRESULT *phRes,
            /* [out] */ BSTR *pszMsg,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID *pObj) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemCallStatusVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemCallStatus * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemCallStatus * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemCallStatus * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCallStatus )( 
            IWbemCallStatus * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ LCID lLocale,
            /* [out] */ HRESULT *phRes,
            /* [out] */ BSTR *pszMsg,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID *pObj);
        
        END_INTERFACE
    } IWbemCallStatusVtbl;

    interface IWbemCallStatus
    {
        CONST_VTBL struct IWbemCallStatusVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemCallStatus_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemCallStatus_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemCallStatus_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemCallStatus_GetCallStatus(This,uFlags,lLocale,phRes,pszMsg,riid,pObj)	\
    (This)->lpVtbl -> GetCallStatus(This,uFlags,lLocale,phRes,pszMsg,riid,pObj)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemCallStatus_GetCallStatus_Proxy( 
    IWbemCallStatus * This,
    /* [in] */ ULONG uFlags,
    /* [in] */ LCID lLocale,
    /* [out] */ HRESULT *phRes,
    /* [out] */ BSTR *pszMsg,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ LPVOID *pObj);


void __RPC_STUB IWbemCallStatus_GetCallStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemCallStatus_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wbemcli_0123 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum tag_WMI_OBJ_TEXT
    {	WMI_OBJ_TEXT_MOF_V1	= 0,
	WMI_OBJ_TEXT_CIM_DTD_2_0	= 1,
	WMI_OBJ_TEXT_WMI_DTD_2_0	= 2,
	WMI_OBJ_TEXT_WMI_DTD_2_0_EX	= 3,
	WMI_OBJ_TEXT_WMI_EXT1	= 4,
	WMI_OBJ_TEXT_WMI_EXT2	= 5,
	WMI_OBJ_TEXT_WMI_EXT3	= 6,
	WMI_OBJ_TEXT_WMI_EXT4	= 7,
	WMI_OBJ_TEXT_WMI_EXT5	= 8,
	WMI_OBJ_TEXT_WMI_EXT6	= 9,
	WMI_OBJ_TEXT_WMI_EXT7	= 10,
	WMI_OBJ_TEXT_WMI_EXT8	= 11,
	WMI_OBJ_TEXT_WMI_EXT9	= 12,
	WMI_OBJ_TEXT_WMI_EXT10	= 13,
	WMI_OBJ_TEXT_LAST	= 14
    } 	WMI_OBJ_TEXT;



extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0123_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0123_v0_0_s_ifspec;

#ifndef __IWbemObjectTextSrc_INTERFACE_DEFINED__
#define __IWbemObjectTextSrc_INTERFACE_DEFINED__

/* interface IWbemObjectTextSrc */
/* [uuid][local][restricted][object] */ 


EXTERN_C const IID IID_IWbemObjectTextSrc;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bfbf883a-cad7-11d3-a11b-00105a1f515a")
    IWbemObjectTextSrc : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetText( 
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pObj,
            /* [in] */ ULONG uObjTextFormat,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ BSTR *strText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateFromText( 
            /* [in] */ long lFlags,
            /* [in] */ BSTR strText,
            /* [in] */ ULONG uObjTextFormat,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IWbemClassObject **pNewObj) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemObjectTextSrcVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemObjectTextSrc * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemObjectTextSrc * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemObjectTextSrc * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            IWbemObjectTextSrc * This,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject *pObj,
            /* [in] */ ULONG uObjTextFormat,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ BSTR *strText);
        
        HRESULT ( STDMETHODCALLTYPE *CreateFromText )( 
            IWbemObjectTextSrc * This,
            /* [in] */ long lFlags,
            /* [in] */ BSTR strText,
            /* [in] */ ULONG uObjTextFormat,
            /* [in] */ IWbemContext *pCtx,
            /* [out] */ IWbemClassObject **pNewObj);
        
        END_INTERFACE
    } IWbemObjectTextSrcVtbl;

    interface IWbemObjectTextSrc
    {
        CONST_VTBL struct IWbemObjectTextSrcVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemObjectTextSrc_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemObjectTextSrc_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemObjectTextSrc_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemObjectTextSrc_GetText(This,lFlags,pObj,uObjTextFormat,pCtx,strText)	\
    (This)->lpVtbl -> GetText(This,lFlags,pObj,uObjTextFormat,pCtx,strText)

#define IWbemObjectTextSrc_CreateFromText(This,lFlags,strText,uObjTextFormat,pCtx,pNewObj)	\
    (This)->lpVtbl -> CreateFromText(This,lFlags,strText,uObjTextFormat,pCtx,pNewObj)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemObjectTextSrc_GetText_Proxy( 
    IWbemObjectTextSrc * This,
    /* [in] */ long lFlags,
    /* [in] */ IWbemClassObject *pObj,
    /* [in] */ ULONG uObjTextFormat,
    /* [in] */ IWbemContext *pCtx,
    /* [out] */ BSTR *strText);


void __RPC_STUB IWbemObjectTextSrc_GetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectTextSrc_CreateFromText_Proxy( 
    IWbemObjectTextSrc * This,
    /* [in] */ long lFlags,
    /* [in] */ BSTR strText,
    /* [in] */ ULONG uObjTextFormat,
    /* [in] */ IWbemContext *pCtx,
    /* [out] */ IWbemClassObject **pNewObj);


void __RPC_STUB IWbemObjectTextSrc_CreateFromText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemObjectTextSrc_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wbemcli_0125 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_wbemcli_0125_0001
    {	WBEM_TRANSACTION_STATE_NULL	= 0,
	WBEM_TRANSACTION_STATE_PENDING	= 1,
	WBEM_TRANSACTION_STATE_PRECOMMIT	= 2,
	WBEM_TRANSACTION_STATE_COMMIT	= 3,
	WBEM_TRANSACTION_STATE_EVENT_PLAYBACK	= 4,
	WBEM_TRANSACTION_STATE_COMPLETED	= 5,
	WBEM_TRANSACTION_STATE_ROLLED_BACK	= 6,
	WBEM_TRANSACTION_STATE_CLEANUP	= 7,
	WBEM_TRANSACTION_STATE_FATAL	= 8
    } 	WBEM_TRANSACTION_STATUS_FLAG;



extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0125_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0125_v0_0_s_ifspec;

#ifndef __IWbemTransaction_INTERFACE_DEFINED__
#define __IWbemTransaction_INTERFACE_DEFINED__

/* interface IWbemTransaction */
/* [uuid][object] */ 


EXTERN_C const IID IID_IWbemTransaction;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3f7bb3cc-9985-42e7-9186-2d53124ad20b")
    IWbemTransaction : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Begin( 
            /* [in] */ ULONG uTimeout,
            /* [in] */ ULONG uFlags,
            /* [in] */ GUID *pTransGUID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Rollback( 
            /* [in] */ ULONG uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ ULONG uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryState( 
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG *puState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemTransactionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWbemTransaction * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWbemTransaction * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWbemTransaction * This);
        
        HRESULT ( STDMETHODCALLTYPE *Begin )( 
            IWbemTransaction * This,
            /* [in] */ ULONG uTimeout,
            /* [in] */ ULONG uFlags,
            /* [in] */ GUID *pTransGUID);
        
        HRESULT ( STDMETHODCALLTYPE *Rollback )( 
            IWbemTransaction * This,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IWbemTransaction * This,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE *QueryState )( 
            IWbemTransaction * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG *puState);
        
        END_INTERFACE
    } IWbemTransactionVtbl;

    interface IWbemTransaction
    {
        CONST_VTBL struct IWbemTransactionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemTransaction_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemTransaction_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemTransaction_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemTransaction_Begin(This,uTimeout,uFlags,pTransGUID)	\
    (This)->lpVtbl -> Begin(This,uTimeout,uFlags,pTransGUID)

#define IWbemTransaction_Rollback(This,uFlags)	\
    (This)->lpVtbl -> Rollback(This,uFlags)

#define IWbemTransaction_Commit(This,uFlags)	\
    (This)->lpVtbl -> Commit(This,uFlags)

#define IWbemTransaction_QueryState(This,uFlags,puState)	\
    (This)->lpVtbl -> QueryState(This,uFlags,puState)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemTransaction_Begin_Proxy( 
    IWbemTransaction * This,
    /* [in] */ ULONG uTimeout,
    /* [in] */ ULONG uFlags,
    /* [in] */ GUID *pTransGUID);


void __RPC_STUB IWbemTransaction_Begin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemTransaction_Rollback_Proxy( 
    IWbemTransaction * This,
    /* [in] */ ULONG uFlags);


void __RPC_STUB IWbemTransaction_Rollback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemTransaction_Commit_Proxy( 
    IWbemTransaction * This,
    /* [in] */ ULONG uFlags);


void __RPC_STUB IWbemTransaction_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemTransaction_QueryState_Proxy( 
    IWbemTransaction * This,
    /* [in] */ ULONG uFlags,
    /* [out] */ ULONG *puState);


void __RPC_STUB IWbemTransaction_QueryState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemTransaction_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wbemcli_0126 */
/* [local] */ 

typedef struct tag_CompileStatusInfo
    {
    long lPhaseError;
    HRESULT hRes;
    long ObjectNum;
    long FirstLine;
    long LastLine;
    DWORD dwOutFlags;
    } 	WBEM_COMPILE_STATUS_INFO;

typedef /* [v1_enum] */ 
enum tag_WBEM_COMPILER_OPTIONS
    {	WBEM_FLAG_CHECK_ONLY	= 0x1,
	WBEM_FLAG_AUTORECOVER	= 0x2,
	WBEM_FLAG_WMI_CHECK	= 0x4,
	WBEM_FLAG_CONSOLE_PRINT	= 0x8,
	WBEM_FLAG_DONT_ADD_TO_LIST	= 0x10,
	WBEM_FLAG_SPLIT_FILES	= 0x20
    } 	WBEM_COMPILER_OPTIONS;



extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0126_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0126_v0_0_s_ifspec;

#ifndef __IMofCompiler_INTERFACE_DEFINED__
#define __IMofCompiler_INTERFACE_DEFINED__

/* interface IMofCompiler */
/* [uuid][object][local] */ 


EXTERN_C const IID IID_IMofCompiler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6daf974e-2e37-11d2-aec9-00c04fb68820")
    IMofCompiler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CompileFile( 
            /* [string][in] */ LPWSTR FileName,
            /* [string][in] */ LPWSTR ServerAndNamespace,
            /* [string][in] */ LPWSTR User,
            /* [string][in] */ LPWSTR Authority,
            /* [string][in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompileBuffer( 
            /* [in] */ long BuffSize,
            /* [size_is][in] */ BYTE *pBuffer,
            /* [string][in] */ LPWSTR ServerAndNamespace,
            /* [string][in] */ LPWSTR User,
            /* [string][in] */ LPWSTR Authority,
            /* [string][in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateBMOF( 
            /* [string][in] */ LPWSTR TextFileName,
            /* [string][in] */ LPWSTR BMOFFileName,
            /* [string][in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMofCompilerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMofCompiler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMofCompiler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMofCompiler * This);
        
        HRESULT ( STDMETHODCALLTYPE *CompileFile )( 
            IMofCompiler * This,
            /* [string][in] */ LPWSTR FileName,
            /* [string][in] */ LPWSTR ServerAndNamespace,
            /* [string][in] */ LPWSTR User,
            /* [string][in] */ LPWSTR Authority,
            /* [string][in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *CompileBuffer )( 
            IMofCompiler * This,
            /* [in] */ long BuffSize,
            /* [size_is][in] */ BYTE *pBuffer,
            /* [string][in] */ LPWSTR ServerAndNamespace,
            /* [string][in] */ LPWSTR User,
            /* [string][in] */ LPWSTR Authority,
            /* [string][in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBMOF )( 
            IMofCompiler * This,
            /* [string][in] */ LPWSTR TextFileName,
            /* [string][in] */ LPWSTR BMOFFileName,
            /* [string][in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo);
        
        END_INTERFACE
    } IMofCompilerVtbl;

    interface IMofCompiler
    {
        CONST_VTBL struct IMofCompilerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMofCompiler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMofCompiler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMofCompiler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMofCompiler_CompileFile(This,FileName,ServerAndNamespace,User,Authority,Password,lOptionFlags,lClassFlags,lInstanceFlags,pInfo)	\
    (This)->lpVtbl -> CompileFile(This,FileName,ServerAndNamespace,User,Authority,Password,lOptionFlags,lClassFlags,lInstanceFlags,pInfo)

#define IMofCompiler_CompileBuffer(This,BuffSize,pBuffer,ServerAndNamespace,User,Authority,Password,lOptionFlags,lClassFlags,lInstanceFlags,pInfo)	\
    (This)->lpVtbl -> CompileBuffer(This,BuffSize,pBuffer,ServerAndNamespace,User,Authority,Password,lOptionFlags,lClassFlags,lInstanceFlags,pInfo)

#define IMofCompiler_CreateBMOF(This,TextFileName,BMOFFileName,ServerAndNamespace,lOptionFlags,lClassFlags,lInstanceFlags,pInfo)	\
    (This)->lpVtbl -> CreateBMOF(This,TextFileName,BMOFFileName,ServerAndNamespace,lOptionFlags,lClassFlags,lInstanceFlags,pInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMofCompiler_CompileFile_Proxy( 
    IMofCompiler * This,
    /* [string][in] */ LPWSTR FileName,
    /* [string][in] */ LPWSTR ServerAndNamespace,
    /* [string][in] */ LPWSTR User,
    /* [string][in] */ LPWSTR Authority,
    /* [string][in] */ LPWSTR Password,
    /* [in] */ LONG lOptionFlags,
    /* [in] */ LONG lClassFlags,
    /* [in] */ LONG lInstanceFlags,
    /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo);


void __RPC_STUB IMofCompiler_CompileFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMofCompiler_CompileBuffer_Proxy( 
    IMofCompiler * This,
    /* [in] */ long BuffSize,
    /* [size_is][in] */ BYTE *pBuffer,
    /* [string][in] */ LPWSTR ServerAndNamespace,
    /* [string][in] */ LPWSTR User,
    /* [string][in] */ LPWSTR Authority,
    /* [string][in] */ LPWSTR Password,
    /* [in] */ LONG lOptionFlags,
    /* [in] */ LONG lClassFlags,
    /* [in] */ LONG lInstanceFlags,
    /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo);


void __RPC_STUB IMofCompiler_CompileBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMofCompiler_CreateBMOF_Proxy( 
    IMofCompiler * This,
    /* [string][in] */ LPWSTR TextFileName,
    /* [string][in] */ LPWSTR BMOFFileName,
    /* [string][in] */ LPWSTR ServerAndNamespace,
    /* [in] */ LONG lOptionFlags,
    /* [in] */ LONG lClassFlags,
    /* [in] */ LONG lInstanceFlags,
    /* [out][in] */ WBEM_COMPILE_STATUS_INFO *pInfo);


void __RPC_STUB IMofCompiler_CreateBMOF_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMofCompiler_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wbemcli_0128 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum tag_WBEM_INFORMATION_FLAG_TYPE
    {	WBEM_FLAG_SHORT_NAME	= 0x1,
	WBEM_FLAG_LONG_NAME	= 0x2
    } 	WBEM_INFORMATION_FLAG_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0128_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0128_v0_0_s_ifspec;

/* interface __MIDL_itf_wbemcli_0134 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum tag_WBEM_BATCH_TYPE
    {	WBEM_FLAG_BATCH_IF_NEEDED	= 0,
	WBEM_FLAG_MUST_BATCH	= 0x1,
	WBEM_FLAG_MUST_NOT_BATCH	= 0x2
    } 	WBEM_BATCH_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0134_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0134_v0_0_s_ifspec;

/* interface __MIDL_itf_wbemcli_0135 */
/* [local] */ 

#define IWbemBinder IWbemConnection
#define IID_IWbemBinder IID_IWbemConnection
#define CLSID_WbemBinder CLSID_WbemConnection


extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0135_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0135_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\managementeventargs.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;

namespace System.Management
{

internal class IdentifierChangedEventArgs : EventArgs
{
	internal IdentifierChangedEventArgs () {}
}

internal class InternalObjectPutEventArgs : EventArgs
{
	private ManagementPath path;

	internal InternalObjectPutEventArgs (ManagementPath path) 
	{
		this.path = path.Clone();
	}

	internal ManagementPath Path {
		get { return path; }
	}
}

	
	/// <summary>
	///    <para>Represents the virtual base class to hold event data for WMI events.</para>
	/// </summary>
public abstract class ManagementEventArgs : EventArgs
{
	private object context;

	/// <summary>
	/// Constructor. This is not callable directly by applications.
	/// </summary>
	/// <param name="context">The operation context which is echoed back
	/// from the operation which trigerred the event.</param>
	internal ManagementEventArgs (object context) {
		this.context = context;
	}

	/// <summary>
	///    <para> Gets the operation context echoed back
	///       from the operation that triggered the event.</para>
	/// </summary>
	/// <value>
	///    A WMI context object containing
	///    context information provided by the operation that triggered the event.
	/// </value>
	public object Context { get { return context; } 
	}
}

/// <summary>
/// <para>Holds event data for the <see cref='System.Management.ManagementOperationObserver.ObjectReady'/> event.</para>
/// </summary>
public class ObjectReadyEventArgs : ManagementEventArgs
{
	private ManagementBaseObject wmiObject;
    
	/// <summary>
	/// Constructor.
	/// </summary>
	/// <param name="context">The operation context which is echoed back
	/// from the operation which triggerred the event.</param>
	/// <param name="wmiObject">The newly arrived WmiObject.</param>
	internal ObjectReadyEventArgs (
					object context,
					ManagementBaseObject wmiObject
					) : base (context)
	{
		this.wmiObject = wmiObject;
	}

	/// <summary>
	///    <para> Gets the newly-returned object.</para>
	/// </summary>
	/// <value>
	/// <para>A <see cref='System.Management.ManagementBaseObject'/> representing the 
	///    newly-returned object.</para>
	/// </value>
	public ManagementBaseObject NewObject 
	{
		get {
			return wmiObject;
		}
	}
}

/// <summary>
/// <para> Holds event data for the <see cref='System.Management.ManagementOperationObserver.Completed'/> event.</para>
/// </summary>
public class CompletedEventArgs : ManagementEventArgs
{
	private readonly int status;
	private readonly ManagementBaseObject wmiObject;

	/// <summary>
	/// Constructor.
	/// </summary>
	/// <param name="context">The operation context which is echoed back
	/// from the operation which trigerred the event.</param>
	/// <param name="status">The completion status of the operation.</param>
	/// <param name="wmiStatusObject">Additional status information
	/// encapsulated within a WmiObject. This may be null.</param>
	internal CompletedEventArgs (
					object context,
					int status,
					ManagementBaseObject wmiStatusObject
					) : base (context)
	{
		wmiObject = wmiStatusObject;
		this.status = status;
	}

	/// <summary>
	///    <para>Gets or sets additional status information
	///       within a WMI object. This may be null.</para>
	/// </summary>
	/// <value>
	/// <para><see langword='null '/> if an error did not occur. Otherwise, may be non-null if the provider
	///    supports extended error information.</para>
	/// </value>
	public ManagementBaseObject StatusObject 
	{
		get {
			return wmiObject;
		}
	}

	/// <summary>
	///    <para>Gets the completion status of the operation.</para>
	/// </summary>
	/// <value>
	/// <para>A <see cref='System.Management.ManagementStatus'/> value
	///    indicating the return code of the operation.</para>
	/// </value>
	public ManagementStatus Status 
	{
		get {
			return (ManagementStatus) status;
		}
	}
}

/// <summary>
/// <para>Holds event data for the <see cref='System.Management.ManagementOperationObserver.ObjectPut'/> event.</para>
/// </summary>
public class ObjectPutEventArgs : ManagementEventArgs
{
	private ManagementPath wmiPath;
    
	/// <summary>
	/// Constructor
	/// </summary>
	/// <param name="context">The operation context which is echoed back
	/// from the operation which trigerred the event.</param>
	/// <param name="path">The WmiPath representing the identity of the
	/// object that has been put.</param>
	internal ObjectPutEventArgs (
					object context,
					ManagementPath path
					) : base (context)
	{
		wmiPath = path;
	}

	/// <summary>
	///    <para> Gets the identity of the
	///       object that has been put.</para>
	/// </summary>
	/// <value>
	/// <para>A <see cref='System.Management.ManagementPath'/> containing the path of the object that has 
	///    been put.</para>
	/// </value>
	public ManagementPath Path 
	{
		get {
			return wmiPath;
		}
	}
}

/// <summary>
/// <para>Holds event data for the <see cref='System.Management.ManagementOperationObserver.Progress'/> event.</para>
/// </summary>
public class ProgressEventArgs : ManagementEventArgs
{
	private int			upperBound;
	private int			current;
	private string		message;
    
	/// <summary>
	/// Constructor
	/// </summary>
	/// <param name="context">The operation context which is echoed back
	/// from the operation which trigerred the event.</param>
	/// <param name="upperBound">A quantity representing the total
	/// amount of work required to be done by the operation.</param>
	/// <param name="current">A quantity representing the current
	/// amount of work required to be done by the operation. This is
	/// always less than or equal to upperBound.</param>
	/// <param name="message">Optional additional information regarding
	/// operation progress.</param>
	internal ProgressEventArgs (
					object context,
					int upperBound,
					int current,
					string message
					) : base (context)
	{
		this.upperBound = upperBound;
		this.current = current;
		this.message = message;
	}

	/// <summary>
	///    <para> Gets the total
	///       amount of work required to be done by the operation.</para>
	/// </summary>
	/// <value>
	///    An integer representing the total
	///    amount of work for the operation.
	/// </value>
	public int UpperBound 
	{
		get {
			return upperBound;
		}
	}

	/// <summary>
	///    <para> Gets the current amount of work 
	///       done by the operation. This is always less than or equal to <see cref='System.Management.ProgressEventArgs.UpperBound'/>.</para>
	/// </summary>
	/// <value>
	///    <para>An integer representing the current amount of work 
	///       already completed by the operation.</para>
	/// </value>
	public int Current 
	{
		get {
			return current;
		}
	}

	/// <summary>
	///    <para>Gets or sets optional additional information regarding the operation's progress.</para>
	/// </summary>
	/// <value>
	///    A string containing additional
	///    information regarding the operation's progress.
	/// </value>
	public string Message 
	{
		get {
			return (null != message) ? message : String.Empty;
		}
	}
}

/// <summary>
/// <para>Holds event data for the <see cref='System.Management.ManagementEventWatcher.EventArrived'/> event.</para>
/// </summary>
public class EventArrivedEventArgs : ManagementEventArgs
{
	private ManagementBaseObject eventObject;

	internal EventArrivedEventArgs (
				object context,
				ManagementBaseObject eventObject) : base (context)
	{
		this.eventObject = eventObject;
	}

	/// <summary>
	///    <para> Gets the WMI event that was delivered.</para>
	/// </summary>
	/// <value>
	///    The object representing the WMI event.
	/// </value>
	public ManagementBaseObject NewEvent 
	{
		get { return this.eventObject; }
	}
}

/// <summary>
/// <para>Holds event data for the <see cref='System.Management.ManagementEventWatcher.Stopped'/> event.</para>
/// </summary>
public class StoppedEventArgs : ManagementEventArgs
{
	private int status;

	internal StoppedEventArgs (
				object context,
				int status) : base (context) 
	{
		this.status = status;
	}

	/// <summary>
	///    <para> Gets the completion status of the operation.</para>
	/// </summary>
	/// <value>
	/// <para>A <see cref='System.Management.ManagementStatus'/> value representing the status of the 
	///    operation.</para>
	/// </value>
	public ManagementStatus Status 
	{
		get {
			return (ManagementStatus) status;
		}
	}
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.Permissions;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("System.Management")]
[assembly:AssemblyDescription("This assembly contains the classes necessary to access management information from managed code")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("Microsoft")]
[assembly:AssemblyProduct("WMI")]
[assembly:AssemblyCopyright("1995-2001")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.5000.0")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(true)]
[assembly:AssemblyKeyFile("FinalPublicKey.snk")]
[assembly:AssemblyKeyName("")]

[assembly:CLSCompliant(true)]

// Do not surface these APIs to class COM clients
[assembly:ComVisible(false)]

// Request permissions up-front to avoid any code running if the client doesn't have enough permissions
[assembly:SecurityPermission(SecurityAction.RequestMinimum, UnmanagedCode=true)]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\managementbaseobject.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Collections;
using System.Diagnostics;
using System.Runtime.InteropServices;
using WbemClient_v1;
using System.ComponentModel;
using System.Runtime.Serialization;
using System.Globalization;
using System.Security.Permissions;

namespace System.Management
{
	/// <summary>
	/// <para>Describes the possible text formats that can be used with <see cref='System.Management.ManagementBaseObject.GetText'/>.</para>
	/// </summary>
	public enum TextFormat 
	{
		/// <summary>
		/// Managed Object Format
		/// </summary>
		Mof = 0,
		/// <summary>
		/// XML DTD that corresponds to CIM DTD version 2.0
		/// </summary>
		CimDtd20 = 1,
		/// <summary>
		/// XML WMI DTD that corresponds to CIM DTD version 2.0. 
		/// Using this value enables a few WMI-specific extensions, like embedded objects.
		/// </summary>
		WmiDtd20 = 2
	};
		
	/// <summary>
	///    <para>Describes the possible CIM types for properties, qualifiers, or method parameters.</para>
	/// </summary>
	public enum CimType 
	{
		/// <summary>
		///    <para>A signed 8-bit integer.</para>
		/// </summary>
		SInt8 = 16,
		/// <summary>
		///    <para>An unsigned 8-bit integer.</para>
		/// </summary>
		UInt8 = 17,
		/// <summary>
		///    <para>A signed 16-bit integer.</para>
		/// </summary>
		SInt16 = 2,
		/// <summary>
		///    <para>An unsigned 16-bit integer.</para>
		/// </summary>
		UInt16 = 18,
		/// <summary>
		///    <para>A signed 32-bit integer.</para>
		/// </summary>
		SInt32 = 3,
		/// <summary>
		///    <para>An unsigned 32-bit integer.</para>
		/// </summary>
		UInt32 = 19,
        /// <summary>
        ///    <para>A signed 64-bit integer.</para>
        /// </summary>
        SInt64 = 20,
        /// <summary>
        ///    <para>An unsigned 64-bit integer.</para>
        /// </summary>
        UInt64 = 21,
        /// <summary>
        ///    <para>A floating-point 32-bit number.</para>
        /// </summary>
        Real32 = 4,
        /// <summary>
        ///    <para>A floating point 64-bit number.</para>
        /// </summary>
        Real64 = 5,
        /// <summary>
        ///    <para> A boolean.</para>
        /// </summary>
        Boolean = 11,
        /// <summary>
        ///    <para>A string.</para>
        /// </summary>
        String = 8,
		/// <summary>
		///    <para> A date or time value, represented in a string in DMTF 
		///       date/time format: yyyymmddHHMMSS.mmmmmmsUUU</para>
		///    <para>where:</para>
		///    <para>yyyymmdd - is the date in year/month/day</para>
		///    <para>HHMMSS - is the time in hours/minutes/seconds</para>
		///    <para>mmmmmm - is the number of microseconds in 6 digits</para>
		///    <para>sUUU - is a sign (+ or -) and a 3-digit UTC offset</para>
		/// </summary>
		DateTime = 101,
        /// <summary>
        ///    <para>A reference to another object. This is represented by a 
        ///       string containing the path to the referenced object</para>
        /// </summary>
        Reference = 102,
        /// <summary>
        ///    <para> A 16-bit character.</para>
        /// </summary>
        Char16 = 103,
        /// <summary>
        ///    <para>An embedded object.</para>
        ///    <para>Note that embedded objects differ from references in that the embedded object 
        ///       doesn't have a path and its lifetime is identical to the lifetime of the
        ///       containing object.</para>
        /// </summary>
        Object = 13,
	};

	/// <summary>
	/// <para>Describes the object comparison modes that can be used with <see cref='System.Management.ManagementBaseObject.CompareTo'/>.
	///    Note that these values may be combined.</para>
	/// </summary>
	[Flags]
	public enum ComparisonSettings
	{
		/// <summary>
		///    <para>A mode that compares all elements of the compared objects.</para>
		/// </summary>
		IncludeAll = 0,
		/// <summary>
		///    <para>A mode that compares the objects, ignoring qualifiers.</para>
		/// </summary>
		IgnoreQualifiers = 0x1,
		/// <summary>
		///    <para> A mode that ignores the source of the objects, namely the server
		///       and the namespace they came from, in comparison to other objects.</para>
		/// </summary>
		IgnoreObjectSource = 0x2,
		/// <summary>
		///    <para> A mode that ignores the default values of properties.
		///       This value is only meaningful when comparing classes.</para>
		/// </summary>
		IgnoreDefaultValues = 0x4,
		/// <summary>
		///    <para>A mode that assumes that the objects being compared are instances of 
		///       the same class. Consequently, this value causes comparison
		///       of instance-related information only. Use this flag to optimize
		///       performance. If the objects are not of the same class, the results are undefined.</para>
		/// </summary>
		IgnoreClass = 0x8,
		/// <summary>
		///    <para> A mode that compares string values in a case-insensitive
		///       manner. This applies to strings and to qualifier values. Property and qualifier
		///       names are always compared in a case-insensitive manner whether this flag is
		///       specified or not.</para>
		/// </summary>
		IgnoreCase = 0x10,
		/// <summary>
		///    <para>A mode that ignores qualifier flavors. This flag still takes
		///       qualifier values into account, but ignores flavor distinctions such as
		///       propagation rules and override restrictions.</para>
		/// </summary>
		IgnoreFlavor = 0x20
	};
		
		
	internal enum QualifierType
	{
		ObjectQualifier,
		PropertyQualifier,
		MethodQualifier
	}


	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para> Contains the basic elements of a management 
	///       object. It serves as a base class to more specific management object classes.</para>
	/// </summary>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	[Serializable]
	[ToolboxItem(false)]
    public class ManagementBaseObject : Component, ICloneable, ISerializable
	{
        // This field holds onto a WbemContext for the lifetime of the appdomain.  This should
        // preven Fastprox.dll from unloading prematurely (WMI bugs # 2998 and # 4118 - URT bug # 90889)
        // BUG# 101254 is explicitly to add this fix.  Since this is fixed in WinXP, we only
        // hold onto a WbemContext if we are NOT running XP or later.
        private static WbemContext lockOnFastProx = System.Management.Instrumentation.WMICapabilities.IsWindowsXPOrHigher()?null:new WbemContext();

		//
		// The wbemObject is changed from a field to a property. This is to avoid major code churn and simplify the solution to
		// the problem where the Initialize call actually binds to the object. This occured even in cases like Get() whereby we
		// ended up getting the object twice. Any direct usage of this property will cause a call to Initialize ( true ) to be made
		// (if not already done) indicating that we wish to bind to the underlying WMI object.
		//
		// See changes to Initialize
		// 
		internal IWbemClassObjectFreeThreaded wbemObject
		{
			get
			{
				if ( _wbemObject == null )
				{
					Initialize ( true ) ;
				}
				return _wbemObject ; 
			}
			set
			{
				_wbemObject = value ;
			}
		}

		internal IWbemClassObjectFreeThreaded _wbemObject ;

		private PropertyDataCollection properties;
		private PropertyDataCollection systemProperties;
		private QualifierDataCollection qualifiers;
 
        /// <summary>
        /// <para>Initializes a new instance of the <see cref='System.Management.ManagementBaseObject'/> class that is serializable.</para>
        /// </summary>
        /// <param name='info'>The <see cref='System.Runtime.Serialization.SerializationInfo'/> to populate with data.</param>
	/// <param name='context'>The destination (see <see cref='System.Runtime.Serialization.StreamingContext'/> ) for this serialization.</param>
        protected ManagementBaseObject(SerializationInfo info, StreamingContext context)
        {
            wbemObject = info.GetValue("wbemObject", typeof(IWbemClassObjectFreeThreaded)) as IWbemClassObjectFreeThreaded;
            if(null == wbemObject)
                throw new SerializationException();
            properties = null;
            systemProperties = null;
            qualifiers = null;
        }

		/// <summary>
		///    <para>Provides the internal WMI object represented by a ManagementObject.</para>
		///    <para>See remarks with regard to usage.</para>
		/// </summary>
		/// <param name='managementObject'>The <see cref='System.Management.ManagementBaseObject'/> that references the requested WMI object. </param>
		/// <returns>
		/// <para>An <see cref='System.IntPtr'/> representing the internal WMI object.</para>
		/// </returns>
		/// <remarks>
		///    <para>This operator is used internally by instrumentation code. It is not intended 
		///       for direct use by regular client or instrumented applications.</para>
		/// </remarks>
		public static explicit operator IntPtr(ManagementBaseObject managementObject)
		{
			if(null == managementObject)
				return IntPtr.Zero;
			//
			// Removed Initialize call since wbemObject is a property that will call Initialize ( true ) on
			// its getter.
			//
			//managementObject.Initialize ( ) ;
			return (IntPtr)managementObject.wbemObject;
		}


		//FXCop requests explicit demand of the SerializationFormatter permission
		[SecurityPermission(SecurityAction.LinkDemand, SerializationFormatter=true)]
		void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
        {
			//
			// Removed Initialize call since wbemObject is a property that will call Initialize ( true ) on
			// its getter.
			//
			// Initialize (  ) ;
            info.AddValue("wbemObject", wbemObject, typeof(IWbemClassObjectFreeThreaded));
            info.AssemblyName = typeof(ManagementBaseObject).Assembly.FullName;
            info.FullTypeName = typeof(ManagementBaseObject).ToString();
        }

		// Factory
		/// <summary>
		/// Factory for various types of base object
		/// </summary>
		/// <param name="wbemObject"> IWbemClassObject </param>
		/// <param name="scope"> The scope</param>
		internal static ManagementBaseObject GetBaseObject(
			IWbemClassObjectFreeThreaded wbemObject,
			ManagementScope scope) 
		{
			ManagementBaseObject newObject = null;

			if (_IsClass(wbemObject))
				newObject = ManagementClass.GetManagementClass(wbemObject, scope);
			else
				newObject = ManagementObject.GetManagementObject(wbemObject, scope);

			return newObject;
		}

		//Constructor
		internal ManagementBaseObject(IWbemClassObjectFreeThreaded wbemObject) 
		{
			this.wbemObject = wbemObject;
			properties = null;
			systemProperties = null;
			qualifiers = null;
		}

		/// <summary>
		///    <para>Returns a copy of the object.</para>
		/// </summary>
		/// <returns>
		///    <para>The new cloned object.</para>
		/// </returns>
		public virtual Object Clone()
		{
			//
			// Removed Initialize call since wbemObject is a property that will call Initialize ( true ) on
			// its getter.
			//
			// Initialize ( ) ;
			IWbemClassObjectFreeThreaded theClone = null;

			int status = wbemObject.Clone_(out theClone);

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}

			return new ManagementBaseObject(theClone);
		}

		internal virtual void Initialize ( bool getObject ) {}

		//
		//Properties
		//

		/// <summary>
		/// <para>Gets or sets a collection of <see cref='System.Management.PropertyData'/> objects describing the properties of the
		///    management object.</para>
		/// </summary>
		/// <value>
		/// <para>A <see cref='System.Management.PropertyDataCollection'/> that represents the 
		///    properties of the management object.</para>
		/// </value>
		/// <seealso cref='System.Management.PropertyData'/>
		public virtual PropertyDataCollection Properties 
		{
			get { 
				Initialize ( true ) ;

				if (properties == null)
					properties = new PropertyDataCollection(this, false);

				return properties;
			}
		}

		/// <summary>
		///    <para>Gets or sets the collection of WMI system properties of the management object (for example, the 
		///       class name, server, and namespace). WMI system property names begin with
		///       "__".</para>
		/// </summary>
		/// <value>
		/// <para>A <see cref='System.Management.PropertyDataCollection'/> that represents the system properties of the management object.</para>
		/// </value>
		/// <seealso cref='System.Management.PropertyData'/>
		public virtual PropertyDataCollection SystemProperties 
		{
			get {
				Initialize ( false ) ;

				if (systemProperties == null)
					systemProperties = new PropertyDataCollection(this, true);

				return systemProperties;
			}
		}

		/// <summary>
		/// <para>Gets or sets the collection of <see cref='System.Management.QualifierData'/> objects defined on the management object. 
		///    Each element in the collection holds information such as the qualifier name,
		///    value, and flavor.</para>
		/// </summary>
		/// <value>
		/// <para>A <see cref='System.Management.QualifierDataCollection'/> that represents the qualifiers 
		///    defined on the management object.</para>
		/// </value>
		/// <seealso cref='System.Management.QualifierData'/>
		public virtual QualifierDataCollection Qualifiers 
		{
			get { 
				Initialize ( true ) ;

				if (qualifiers == null)
					qualifiers = new QualifierDataCollection(this);

				return qualifiers;
			}
		}

		/// <summary>
		///    <para>Gets or sets the path to the management object's class.</para>
		/// </summary>
		/// <value>
		/// <para>A <see cref='System.Management.ManagementPath'/> that represents the path to the management object's class.</para>
		/// </value>
		/// <example>
		///    <para>For example, for the \\MyBox\root\cimv2:Win32_LogicalDisk= 
		///       'C:' object, the class path is \\MyBox\root\cimv2:Win32_LogicalDisk
		///       .</para>
		/// </example>
		public virtual ManagementPath ClassPath 
		{ 
			get { 
				Object serverName = null;
				Object scopeName = null;
				Object className = null;
				int propertyType = 0;
				int propertyFlavor = 0;
				int status = (int)ManagementStatus.NoError;

				//
				// Removed Initialize call since wbemObject is a property that will call Initialize ( true ) on
				// its getter.
				//
				// Initialize ( ) ;
				status = wbemObject.Get_("__SERVER", 0, ref serverName, ref propertyType, ref propertyFlavor);
				
				if (status == (int)ManagementStatus.NoError)
				{
					status = wbemObject.Get_("__NAMESPACE", 0, ref scopeName, ref propertyType, ref propertyFlavor);

					if (status == (int)ManagementStatus.NoError)
						status = wbemObject.Get_("__CLASS", 0, ref className, ref propertyType, ref propertyFlavor);
				}

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}

				ManagementPath classPath = new ManagementPath();

				// Some of these may throw if they are NULL
				try {
					classPath.Server = (string)(serverName is System.DBNull ? "" : serverName);
					classPath.NamespacePath = (string)(scopeName is System.DBNull ? "" : scopeName);
					classPath.ClassName = (string)(className is System.DBNull ? "" : className);
				} catch (Exception) {}

				return classPath;
            } 
		}


		//
		//Methods
		//

		//******************************************************
		//[] operator by property name
		//******************************************************
		/// <summary>
		///    <para> Gets access to property values through [] notation.</para>
		/// </summary>
		/// <param name='propertyName'>The name of the property of interest. </param>
		/// <value>
		///    An <see cref='System.Object'/> containing the
		///    value of the requested property.
		/// </value>
		public Object this[string propertyName] 
		{ 
			get { return GetPropertyValue(propertyName); }
			set { 
				Initialize ( true ) ;
				try {
					SetPropertyValue (propertyName, value);
				}
				catch (Exception e) {
					ManagementException.ThrowWithExtendedInfo(e);
				}
			}
		}
		
		//******************************************************
		//GetPropertyValue
		//******************************************************
		/// <summary>
		///    <para>Gets an equivalent accessor to a property's value.</para>
		/// </summary>
		/// <param name='propertyName'>The name of the property of interest. </param>
		/// <returns>
		///    <para>The value of the specified property.</para>
		/// </returns>
		public Object GetPropertyValue(string propertyName)
		{ 
			if (null == propertyName)
				throw new ArgumentNullException ("propertyName");

			// Check for system properties
			if (propertyName.StartsWith ("__"))
				return SystemProperties[propertyName].Value;
			else
				return Properties[propertyName].Value;
		}

		//******************************************************
		//GetQualifierValue
		//******************************************************
		/// <summary>
		///    <para>Gets the value of the specified qualifier.</para>
		/// </summary>
		/// <param name='qualifierName'>The name of the qualifier of interest. </param>
		/// <returns>
		///    <para>The value of the specified qualifier.</para>
		/// </returns>
		public Object GetQualifierValue(string qualifierName)
		{
			return Qualifiers [qualifierName].Value;
		}

		//******************************************************
		//SetQualifierValue
		//******************************************************
		/// <summary>
		///    <para>Sets the value of the named qualifier.</para>
		/// </summary>
		/// <param name='qualifierName'>The name of the qualifier to set. This parameter cannot be null.</param>
		/// <param name='qualifierValue'>The value to set.</param>
		public void SetQualifierValue(string qualifierName, object qualifierValue)
		{
			Qualifiers [qualifierName].Value = qualifierValue;
		}
			
		
		//******************************************************
		//GetPropertyQualifierValue
		//******************************************************
		/// <summary>
		///    <para>Returns the value of the specified property qualifier.</para>
		/// </summary>
		/// <param name='propertyName'>The name of the property to which the qualifier belongs. </param>
		/// <param name='qualifierName'>The name of the property qualifier of interest. </param>
		/// <returns>
		///    <para>The value of the specified qualifier.</para>
		/// </returns>
		public Object GetPropertyQualifierValue(string propertyName, string qualifierName)
		{
			return Properties[propertyName].Qualifiers[qualifierName].Value;
		}

		//******************************************************
		//SetPropertyQualifierValue
		//******************************************************
		/// <summary>
		///    <para>Sets the value of the specified property qualifier.</para>
		/// </summary>
		/// <param name='propertyName'>The name of the property to which the qualifier belongs.</param>
		/// <param name='qualifierName'>The name of the property qualifier of interest.</param>
		/// <param name='qualifierValue'>The new value for the qualifier.</param>
		public void SetPropertyQualifierValue(string propertyName, string qualifierName,
			object qualifierValue)
		{
			Properties[propertyName].Qualifiers[qualifierName].Value = qualifierValue;
		}

		//******************************************************
		//GetText
		//******************************************************
		/// <summary>
		///    <para>Returns a textual representation of the object in the specified format.</para>
		/// </summary>
		/// <param name='format'>The requested textual format. </param>
		/// <returns>
		///    <para>The textual representation of the
		///       object in the specified format.</para>
		/// </returns>
		/// <remarks>
		///    <para> Currently, the only format that WMI supports
		///       is Managed Object Format (MOF). In the future, other formats will be
		///       supported, such as Extensible Markup Language (XML).</para>
		/// </remarks>
		// TODO: What's the relationship to ISerializable if any ?
		public string GetText(TextFormat format)
		{
			string objText = null;
			int status = (int)ManagementStatus.NoError;

			//
			// Removed Initialize call since wbemObject is a property that will call Initialize ( true ) on
			// its getter.
			//
			// Initialize ( ) ;
			switch(format)
			{
				case TextFormat.Mof :

					status = wbemObject.GetObjectText_(0, out objText);

					if (status < 0)
					{
						if ((status & 0xfffff000) == 0x80041000)
							ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
						else
							Marshal.ThrowExceptionForHR(status);
					}

					return objText;

				case TextFormat.CimDtd20 :
				case TextFormat.WmiDtd20 :
					
					//This may throw on non-XP platforms... - should we catch ?
					IWbemObjectTextSrc wbemTextSrc = (IWbemObjectTextSrc)new WbemObjectTextSrc();
					IWbemContext ctx = (IWbemContext)new WbemContext();
					object v = (bool)true;
					ctx.SetValue_("IncludeQualifiers", 0, ref v);
					ctx.SetValue_("IncludeClassOrigin", 0, ref v);

					if (wbemTextSrc != null)
					{
						status = wbemTextSrc.GetText_(0, 
							(IWbemClassObject_DoNotMarshal)(Marshal.GetObjectForIUnknown(wbemObject)), 
							(uint)format, //note: this assumes the format enum has the same values as the underlying WMI enum !!
							 ctx, 
							 out objText);
						if (status < 0)
						{
							if ((status & 0xfffff000) == 0x80041000)
								ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
							else
								Marshal.ThrowExceptionForHR(status);
						}
					}

					return objText;

				default : 

					return null;
			}
		}

		/// <summary>
		///    <para>Compares two management objects.</para>
		/// </summary>
		/// <param name='obj'>An object to compare with this instance.</param>
		/// <returns>
		/// <see langword='true'/> if 
		/// <paramref name="obj"/> is an instance of <see cref='System.Management.ManagementBaseObject'/> and represents 
		///    the same object as this instance; otherwise, <see langword='false'/>.
		/// </returns>
		public override bool Equals(object obj)
		{
			bool result = false;
			
			try 
			{
				//
				// Removed Initialize call since CompareTo calls Initialize.
				// its getter.
				// 
				// Initialize ( ) ;

				if (obj is ManagementBaseObject)
				{
					result = CompareTo ((ManagementBaseObject)obj, ComparisonSettings.IncludeAll);
				}
				else
				{
					return false;
				}
			} catch  (Exception exc)
			{
				if (exc is ManagementException && ((ManagementException) exc).ErrorCode == ManagementStatus.NotFound)
				{
					//we could wind up here if Initialize() throws (either here or inside CompareTo())
					//Since we cannot throw from Equals() imprelemtation and it is invalid to assume
					//that two objects are different because they fail to initialize (this assumption causes bug 100527)
					//so, we can just compare these invalid paths "by value"

					if (this is ManagementObject && obj is ManagementObject)
					{
						int compareRes = String.Compare(((ManagementObject)this).Path.Path,
										((ManagementObject)obj).Path.Path,
										true,CultureInfo.InvariantCulture);
						return (compareRes == 0);
					}
				}
				return false;
			}

			


			return result;
		}

        /// <summary>
        ///     <para>Serves as a hash function for a particular type, suitable for use in hashing algorithms and data structures like a hash table.</para>
        /// </summary>
        /// <returns>
        ///     <para>A hash code for the current object.</para>
        /// </returns>
        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

		//******************************************************
		//CompareTo
		//******************************************************
		/// <summary>
		///    <para>Compares this object to another, based on specified options.</para>
		/// </summary>
		/// <param name='otherObject'>The object to which to compare this object. </param>
		/// <param name='settings'>Options on how to compare the objects. </param>
		/// <returns>
		/// <para><see langword='true'/> if the objects compared are equal 
		///    according to the given options; otherwise, <see langword='false'/>
		///    .</para>
		/// </returns>
		public bool CompareTo(ManagementBaseObject otherObject, ComparisonSettings settings)
		{
			if (null == otherObject)
				throw new ArgumentNullException ("otherObject");

			//
			// Removed Initialize call since wbemObject is a property that will call Initialize ( true ) on
			// its getter.
			//
			// Initialize ( ) ;
			bool result = false;

			if (null != wbemObject)
			{
				int status = (int) ManagementStatus.NoError;

				//
				// Removed Initialize call since wbemObject is a property that will call Initialize ( true ) on
				// its getter.
				//
				//otherObject.Initialize ( false ) ;

				status = wbemObject.CompareTo_((int) settings, otherObject.wbemObject);

				if ((int)ManagementStatus.Different == status)
					result = false;
				else if ((int)ManagementStatus.NoError == status)
					result = true;
				else if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else if (status < 0)
					Marshal.ThrowExceptionForHR(status);
			}
			
			return result;
		}

		internal string ClassName
		{
			get {
				//
				// Removed Initialize call since wbemObject is a property that will call Initialize ( true ) on
				// its getter.
				//
				// Initialize ( ) ;
				object val = null;
				int dummy1 = 0, dummy2 = 0;
				int status = (int)ManagementStatus.NoError;

				status = wbemObject.Get_ ("__CLASS", 0, ref val, ref dummy1, ref dummy2);

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}

				if (val is System.DBNull)
					return String.Empty;
				else
					return ((string) val);
			}
		}

		private static bool _IsClass(IWbemClassObjectFreeThreaded wbemObject)
		{
			object val = null;
			int dummy1 = 0, dummy2 = 0;

			int status = wbemObject.Get_("__GENUS", 0, ref val, ref dummy1, ref dummy2);

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}
			
			return ((int)val == (int)tag_WBEM_GENUS_TYPE.WBEM_GENUS_CLASS);
		}

		internal bool IsClass
		{
			get {
				//
				// Removed Initialize call since wbemObject is a property that will call Initialize ( true ) on
				// its getter.
				//
				// Initialize ( ) ;
				return _IsClass(wbemObject);
			}
		}

		/// <summary>
		///    <para>Sets the value of the named property.</para>
		/// </summary>
		/// <param name='propertyName'>The name of the property to be changed.</param>
		/// <param name='propertyValue'>The new value for this property.</param>
		public void SetPropertyValue (
			string propertyName,
			object propertyValue)
		{
			if (null == propertyName)
				throw new ArgumentNullException ("propertyName");

			// Check for system properties
			if (propertyName.StartsWith ("__"))
				SystemProperties[propertyName].Value = propertyValue;
			else
				Properties[propertyName].Value = propertyValue;
		}
		
	}//ManagementBaseObject
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\managementdatetime.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;


namespace System.Management
{
	/// <summary>
	///    <para> Provides methods to convert DMTF datetime and time interval to CLR compliant 
	///    <see cref='System.DateTime'/> and <see cref='System.TimeSpan'/> format and vice versa.
	///    </para>
	/// </summary>
	/// <example>
	///    <code lang='C#'>
	/// using System;
	/// using System.Management;
	///
	/// // The sample below demonstrates the various conversions that can be done using ManagementDateTimeConverter class    
	/// class Sample_ManagementDateTimeConverterClass
	/// {
	///     public static int Main(string[] args) 
	///     {
	///			string dmtfDate = "20020408141835.999999-420";
	///			string dmtfTimeInterval = "00000010122532:123456:000";
	///			
	///			// Converting DMTF datetime to System.DateTime
	///			DateTime dt = ManagementDateTimeConverter.ToDateTime(dmtfDate);
	///    
	///			// Converting System.DateTime to DMTF datetime
	///			string dmtfDate = ManagementDateTimeConverter.ToDateTime(DateTime.Now);
	///
	///			// Converting DMTF timeinterval to System.TimeSpan
	///			System.TimeSpan tsRet = ManagementDateTimeConverter. ToTimeSpan(dmtfTimeInterval);
	///
	///			//Converting System.TimeSpan to DMTF time interval format
	///			System.TimeSpan ts = new System.TimeSpan(10,12,25,32,456);
	///			string dmtfTimeInt  = ManagementDateTimeConverter.ToDmtfTimeInterval(ts);
	///			
	///			return 0;
	///
	///		}
	///	}
	///    </code>
	///    <code lang='VB'>
	/// Imports System
	/// Imports System.Management
	///	   
	/// 'The sample below demonstrates the various conversions that can be done using ManagementDateTimeConverter class    
	/// Class Sample_ManagementClass
	///		Overloads Public Shared Function Main(args() As String) As Integer
	///			Dim dmtfDate As String = "20020408141835.999999-420"
	///			Dim dmtfTimeInterval As String = "00000010122532:123456:000"
	///			
	///			'Converting DMTF datetime and intervals to System.DateTime
	///			Dim dt As DateTime = ManagementDateTimeConverter.ToDateTime(dmtfDate)
	///
	///			'Converting System.DateTime to DMTF datetime
	///			dmtfDate = ManagementDateTimeConverter.ToDateTime(DateTime.Now)
	///			
	///			' Converting DMTF timeinterval to System.TimeSpan
	///			Dim tsRet As System.TimeSpan = ManagementDateTimeConverter.ToTimeSpan(dmtfTimeInterval)
	///			
	///			'Converting System.TimeSpan to DMTF time interval format
	///			Dim ts As System.TimeSpan = New System.TimeSpan(10, 12, 25, 32, 456)
	///			String dmtfTimeInt = ManagementDateTimeConverter.ToDmtfTimeInterval(ts)
	///			
	///			Return 0
	///		End Function
	///	End Class
	///
	///    </code>
	/// </example>
	public sealed class ManagementDateTimeConverter
	{
		// constants
		private const int SIZEOFDMTFDATETIME = 25;
		private const int MAXSIZE_UTC_DMTF = 999;
		private const long MAXDATE_INTIMESPAN = 99999999;

		private ManagementDateTimeConverter()
		{
		}


		/// <summary>
		/// <para>Converts a given DMTF datetime to <see cref='System.DateTime'/> object. The returned DateTime will be in the 
		///			current TimeZone of the system.</para>
		/// </summary>
		/// <param name='dmtfDate'>A string representing the datetime in DMTF format.</param>
		/// <returns>
		/// <para>A <see cref='System.DateTime'/> object that represents the given DMTF datetime.</para>
		/// </returns>
		/// <remarks>
		///			<para> Date and time in WMI is represented in DMTF datetime format. This format is explained in WMI SDK documentation.
		///				DMTF datetime string has an UTC offset which this datetime string represents.
		///				 During conversion to <see cref='System.DateTime'/>, UTC offset is used to convert the date to the 
		///				current timezone. According to DMTF format a particular field can be represented by the character 
		///				'*'. This will be converted to the MinValue of this field that can be represented in <see cref='System.DateTime'/>.
		///			</para>
		/// </remarks>
		/// <example>
		///    <code lang='C#'>
		///	// Convert a DMTF datetime to System.DateTime 
		///	DateTime date = ManagementDateTimeConverter.ToDateTime("20020408141835.999999-420");
		///    </code>
		///    <code lang='VB'>
		///	' Convert a DMTF datetime to System.DateTime
		///	Dim date as DateTime = ManagementDateTimeConverter.ToDateTime("20020408141835.999999-420")
		///    </code>
		/// </example>
		public static DateTime ToDateTime(string dmtfDate)
		{
			int year = DateTime.MinValue.Year;
			int month = DateTime.MinValue.Month;
			int day = DateTime.MinValue.Day;
			int hour = DateTime.MinValue.Hour;
			int minute = DateTime.MinValue.Minute;
			int second = DateTime.MinValue.Second;
			int millisec = 0;
			string dmtf = dmtfDate;
			DateTime datetime = DateTime.MinValue;

			// If the string passed is empty or null then throw
			// an exception
			if(dmtf == null)
			{
				throw new System.ArgumentOutOfRangeException();
			}
			if (dmtf.Length == 0) 
			{
				throw new System.ArgumentOutOfRangeException();
			}
			
			// if the length of the string is not equal to the 
			// standard length of the DMTF datetime then throw an exception
			if(dmtf.Length != SIZEOFDMTFDATETIME)
			{
				throw new System.ArgumentOutOfRangeException();
			}

			System.Int64 ticks = 0;
			try
			{
				string tempString = System.String.Empty;
				tempString = dmtf.Substring(0, 4);
				if (("****" != tempString)) 
				{
					year = System.Int32.Parse(tempString);
				}
				tempString = dmtf.Substring(4, 2);
				if (("**" != tempString)) 
				{
					month = System.Int32.Parse(tempString);
				}
				tempString = dmtf.Substring(6, 2);
				if (("**" != tempString)) 
				{
					day = System.Int32.Parse(tempString);
				}
				tempString = dmtf.Substring(8, 2);
				if (("**" != tempString)) 
				{
					hour = System.Int32.Parse(tempString);
				}
				tempString = dmtf.Substring(10, 2);
				if (("**" != tempString)) 
				{
					minute = System.Int32.Parse(tempString);
				}
				tempString = dmtf.Substring(12, 2);
				if (("**" != tempString)) 
				{
					second = System.Int32.Parse(tempString);
				}
				tempString = dmtf.Substring(15, 6);
				if (("******" != tempString)) 
				{
					ticks = (System.Int64.Parse(tempString)) * (System.TimeSpan.TicksPerMillisecond/1000);
				}
				if( year < 0 || month < 0 || day < 0 || hour < 0 || minute < 0 || second < 0 || ticks < 0)
				{
					throw new System.ArgumentOutOfRangeException();
				}

			}
			catch
			{
				throw new System.ArgumentOutOfRangeException();
			}


			// Construct a new System.DateTime object
			datetime = new System.DateTime(year, month, day, hour, minute, second, millisec);
			// Then add the ticks calculated from the microseconds
			datetime = datetime.AddTicks(ticks);
			
			// Adjust the UTC time to reflect the current zone time
			System.TimeZone curZone = System.TimeZone.CurrentTimeZone;
			System.TimeSpan tickOffset = curZone.GetUtcOffset(datetime);
			long OffsetMins = tickOffset.Ticks / System.TimeSpan.TicksPerMinute;
			
			// Adjusting the DateTime for the current UTC
			int UTCOffset =  0;
			string tempString1 = dmtf.Substring(22, 3);
			long OffsetToBeAdjusted = 0;
			if (("***" != tempString1)) 
			{
				tempString1 = dmtf.Substring(21, 4);
				try
				{
					UTCOffset = System.Int32.Parse(tempString1);
				}
				catch
				{
					throw new System.ArgumentOutOfRangeException();
				}

				OffsetToBeAdjusted = UTCOffset-OffsetMins;
				
				// We have to substract the minutes from the time
				datetime = datetime.AddMinutes(OffsetToBeAdjusted * -1);

			}
			return datetime;
		}

		/// <summary>
		/// <para>Converts a given <see cref='System.DateTime'/> object to DMTF format.</para>
		///		
		/// </summary>
		/// <param name='date'>A <see cref='System.DateTime'/> object representing the datetime to be converted to DMTF datetime.</param>
		/// <returns>
		/// <para>A string that represents the DMTF datetime for the given DateTime object.</para>
		/// </returns>
		/// <remarks>
		///			<para> Date and time in WMI is represented in DMTF datetime format. This format is explained in WMI SDK documentation.
		///				The DMTF datetime string represented will be with respect to the UTC offset of the 
		///				current timezone. The lowest precision in DMTF is microseconds and 
		///				in <see cref='System.DateTime'/> is Ticks , which is equivalent to 100 of nanoseconds.
		///				 During conversion these Ticks are converted to microseconds and rounded 
		///				 off to the the nearest microsecond.
		///			</para>
		/// </remarks>
		/// <example>
		///    <code lang='C#'>
		///	// Convert the current time in System.DateTime to DMTF format
		///	string dmtfDateTime = ManagementDateTimeConverter.ToDmtfDateTime(DateTime.Now);
		///    </code>
		///    <code lang='VB'>
		///	' Convert the current time in System.DateTime to DMTF format
		///	Dim dmtfDateTime as String = ManagementDateTimeConverter.ToDmtfDateTime(DateTime.Now)
		///    </code>
		/// </example>
		public static string ToDmtfDateTime(DateTime date)
		{
			string UtcString = String.Empty;
			// Fill up the UTC field in the DMTF date with the current
			// zones UTC value
			System.TimeZone curZone = System.TimeZone.CurrentTimeZone;
			System.TimeSpan tickOffset = curZone.GetUtcOffset(date);
			long OffsetMins = (tickOffset.Ticks / System.TimeSpan.TicksPerMinute);

			// If the offset is more than that what can be specified in DMTF format, then
			// convert the date to UniversalTime
			if(Math.Abs(OffsetMins) > MAXSIZE_UTC_DMTF)
			{
				date = date.ToUniversalTime();
				UtcString = "+000";
			}
			else
			if ((tickOffset.Ticks >= 0)) 
			{
				UtcString = "+" + ((tickOffset.Ticks / System.TimeSpan.TicksPerMinute)).ToString().PadLeft(3,'0');
			}
			else 
			{
				string strTemp = OffsetMins.ToString();
				UtcString = "-" + strTemp.Substring(1, strTemp.Length-1).PadLeft(3,'0');
			}

			string dmtfDateTime = date.Year.ToString().PadLeft(4,'0');

			dmtfDateTime = (dmtfDateTime + date.Month.ToString().PadLeft(2, '0'));
			dmtfDateTime = (dmtfDateTime + date.Day.ToString().PadLeft(2, '0'));
			dmtfDateTime = (dmtfDateTime + date.Hour.ToString().PadLeft(2, '0'));
			dmtfDateTime = (dmtfDateTime + date.Minute.ToString().PadLeft(2, '0'));
			dmtfDateTime = (dmtfDateTime + date.Second.ToString().PadLeft(2, '0'));
			dmtfDateTime = (dmtfDateTime + ".");
			
			// Construct a DateTime with with the precision to Second as same as the passed DateTime and so get
			// the ticks difference so that the microseconds can be calculated
			DateTime dtTemp = new DateTime(date.Year ,date.Month,date.Day ,date.Hour ,date.Minute ,date.Second,0);
			System.Int64 microsec = ((date.Ticks-dtTemp.Ticks) * 1000) / System.TimeSpan.TicksPerMillisecond;
			
			// fill the microseconds field
			String strMicrosec = microsec.ToString();
			if(strMicrosec.Length > 6)
			{
				strMicrosec = strMicrosec.Substring(0,6);				
			}
			dmtfDateTime = dmtfDateTime + strMicrosec.PadLeft(6,'0');
			// adding the UTC offset
			dmtfDateTime = dmtfDateTime + UtcString;

			return dmtfDateTime;
		}
		/// <summary>
		/// <para>Converts a given DMTF time interval to <see cref='System.TimeSpan'/> object.</para>
		/// </summary>
		/// <param name='dmtfTimespan'>A string represesentation of the DMTF time interval.</param>
		/// <returns>
		/// <para>A <see cref='System.TimeSpan'/> object that represents the given DMTF time interval.</para>
		/// </returns>
		/// <remarks>
		///			<para> Time interval in WMI is represented in DMTF format. This format is explained in WMI SDK documentation.
		///					If the DMTF time interval value is more than that of 
		///					<see cref='System.TimeSpan.MaxValue'/> then <see cref='System.ArgumentOutOfRangeException'/> is thrown.
		///			</para>
		/// </remarks>
		/// <example>
		///    <code lang='C#'> 
		///	// Convert a DMTF time interval to System.TimeSpan 
		///	TimeSpan dmtfTimeInterval = ManagementDateTimeConverter.ToTimeSpan("00000010122532:123456:000");
		///    </code>
		///    <code lang='VB'> 
		///	' Convert a DMTF time interval to System.TimeSpan 
		///	Dim ts as TimeSpan = ManagementDateTimeConverter.ToTimeSpan("00000010122532:123456:000")
		///    </code>
		/// </example>
		public static TimeSpan ToTimeSpan(string dmtfTimespan)
		{
			int days = 0;
			int hours = 0;
			int minutes = 0;
			int seconds = 0;

			string dmtfts = dmtfTimespan;
			TimeSpan timespan = TimeSpan.MinValue;

			if (dmtfts == null) 
			{
				throw new System.ArgumentOutOfRangeException();
			}
			if (dmtfts.Length == 0) 
			{
				throw new System.ArgumentOutOfRangeException();
			}
			if(dmtfts.Length != SIZEOFDMTFDATETIME)
			{
				throw new System.ArgumentOutOfRangeException();
			}
			if(dmtfts.Substring(21,4) != ":000")
			{
				throw new System.ArgumentOutOfRangeException();
			}

			System.Int64 ticks = 0;
			try
			{
				string tempString = System.String.Empty;

				tempString = dmtfts.Substring(0, 8);
				days = System.Int32.Parse(tempString);

				tempString = dmtfts.Substring(8, 2);
				hours = System.Int32.Parse(tempString);

				tempString = dmtfts.Substring(10, 2);
				minutes = System.Int32.Parse(tempString);

				tempString = dmtfts.Substring(12, 2);
				seconds = System.Int32.Parse(tempString);

				tempString = dmtfts.Substring(15, 6);
				ticks = (System.Int64.Parse(tempString)) * (System.TimeSpan.TicksPerMillisecond/1000);

			}
			catch
			{
				throw new System.ArgumentOutOfRangeException();
			}

			if( days < 0 || hours < 0 || minutes < 0 || seconds < 0 || ticks < 0 )
			{
				throw new System.ArgumentOutOfRangeException();
			}

			timespan = new System.TimeSpan(days, hours, minutes, seconds, 0);
			// Get a timepan for the additional ticks obtained for the microsecond part of DMTF time interval
			// and then add it to the the original timespan
			TimeSpan tsTemp = System.TimeSpan.FromTicks(ticks);
			timespan = timespan + tsTemp;
			
			return timespan;
		}

		/// <summary>
		/// <para>Converts a given <see cref='System.TimeSpan'/> object to DMTF time interval.</para>
		/// </summary>
		/// <param name='timespan'> A <see cref='System.TimeSpan'/> object representing the datetime to be converted to DMTF time interval.
		/// </param>
		/// <returns>
		/// <para>A string that represents the DMTF time interval for the given TimeSpan object.</para>
		/// </returns>
		/// <remarks>
		///			<para> Time interval in WMI is represented in DMTF datetime format. This format 
		///				is explained in WMI SDK documentation. The lowest precision in 
		///				DMTF is microseconds and in <see cref='System.TimeSpan'/> is Ticks , which is equivalent 
		///				to 100 of nanoseconds.During conversion these Ticks are converted to 
		///				microseconds and rounded off to the the nearest microsecond.
		///			</para>
		/// </remarks>
		/// <example>
		///    <code lang='C#'>
		///	// Construct a Timespan object and convert it to DMTF format
		///	System.TimeSpan ts = new System.TimeSpan(10,12,25,32,456);
		///	String dmtfTimeInterval = ManagementDateTimeConverter.ToDmtfTimeInterval(ts);
		///    </code>
		///    <code lang='VB'>
		///	// Construct a Timespan object and convert it to DMTF format
		///	Dim ts as System.TimeSpan = new System.TimeSpan(10,12,25,32,456)
		///	Dim dmtfTimeInterval as String = ManagementDateTimeConverter.ToDmtfTimeInterval(ts)
		///    </code>
		/// </example>
		public static string ToDmtfTimeInterval(TimeSpan timespan)
		{
			
			string dmtftimespan = timespan.Days.ToString().PadLeft(8,'0');
			
			// Days that can be represented is more than what can be represented
			// then throw an exception 
			// and also negative timespan cannot be represented in DMTF
			if(timespan.Days > MAXDATE_INTIMESPAN || timespan < TimeSpan.Zero)
			{
				throw new System.ArgumentOutOfRangeException();
			}

			dmtftimespan = (dmtftimespan + timespan.Hours.ToString().PadLeft(2, '0'));
			dmtftimespan = (dmtftimespan + timespan.Minutes.ToString().PadLeft(2, '0'));
			dmtftimespan = (dmtftimespan + timespan.Seconds.ToString().PadLeft(2, '0'));
			dmtftimespan = (dmtftimespan + ".");
			
			// Construct a DateTime with with the precision to Second as same as the passed DateTime and so get
			// the ticks difference so that the microseconds can be calculated
			TimeSpan tsTemp = new TimeSpan(timespan.Days ,timespan.Hours,timespan.Minutes ,timespan.Seconds ,0);
			System.Int64 microsec = ((timespan.Ticks-tsTemp.Ticks) * 1000) / System.TimeSpan.TicksPerMillisecond;
			
			// fill the microseconds field
			String strMicrosec = microsec.ToString();		
			if(strMicrosec.Length > 6)
			{
				strMicrosec = strMicrosec.Substring(0,6);				
			}
			dmtftimespan = dmtftimespan + strMicrosec.PadLeft(6,'0');
			
			dmtftimespan = dmtftimespan + ":000";

			return dmtftimespan;
		}
	} // ManagementDateTimeConverter
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\managementclass.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Collections.Specialized;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using WbemClient_v1;
using System.CodeDom;

namespace System.Management
{
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para> Represents a management class.</para>
	/// </summary>
	/// <example>
	///    <code lang='C#'>using System;
	/// using System.Management;
	/// 
	/// // This example demonstrates getting information about a class using the ManagementClass object
	/// class Sample_ManagementClass
	/// {
	///     public static int Main(string[] args) {
	///         ManagementClass diskClass = new ManagementClass("Win32_LogicalDisk");
	///         diskClass.Get();
	///         Console.WriteLine("Logical Disk class has " + diskClass.Properties.Count + " properties");
	///         return 0;
	///     }
	/// }
	///    </code>
	///    <code lang='VB'>Imports System
	/// Imports System.Management
	/// 
	/// ' This example demonstrates getting information about a class using the ManagementClass object
	/// Class Sample_ManagementClass
	///     Overloads Public Shared Function Main(args() As String) As Integer
	///         Dim diskClass As New ManagementClass("Win32_LogicalDisk")
	///         diskClass.Get()
	///         Console.WriteLine(("Logical Disk class has " &amp; _
	///                            diskClass.Properties.Count.ToString() &amp; _
	///                            " properties"))
	///         Return 0
	///     End Function
	/// End Class
	///    </code>
	/// </example>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
    [Serializable]
    public class ManagementClass : ManagementObject
	{
		private MethodDataCollection methods;

		/// <summary>
		/// Internal factory for classes, used when deriving a class
		/// or cloning a class. For these purposes we always mark
		/// the class as "bound".
		/// </summary>
		/// <param name="wbemObject">The underlying WMI object</param>
		/// <param name="mgObj">Seed class from which we will get initialization info</param>
		internal static ManagementClass GetManagementClass(
			IWbemClassObjectFreeThreaded wbemObject,
			ManagementClass mgObj)
		{ 
			ManagementClass newClass = new ManagementClass();
            newClass.wbemObject = wbemObject;

			if (null != mgObj)
			{
				newClass.scope = ManagementScope._Clone(mgObj.scope);

				ManagementPath objPath = mgObj.Path;

				if (null != objPath)
					newClass.path = ManagementPath._Clone(objPath);

				// Ensure we have our class name in the path
				object className = null;
				int dummy = 0;

				int status = wbemObject.Get_("__CLASS", 0, ref className, ref dummy, ref dummy);

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}

				if (className != System.DBNull.Value)
					newClass.path.internalClassName = (string)className;

				ObjectGetOptions options = mgObj.Options;
				if (null != options)
					newClass.options = ObjectGetOptions._Clone(options);

				// Finally we ensure that this object is marked as bound.
				// We do this as a last step since setting certain properties
				// (Options, Path and Scope) would mark it as unbound
				//
				// ***
				// *	Changed isBound flag to wbemObject==null check.
				// *	newClass.IsBound = true;
				// ***
			}

			return newClass;
		}

		internal static ManagementClass GetManagementClass(
			IWbemClassObjectFreeThreaded wbemObject,
			ManagementScope scope) 
		{
			ManagementClass newClass = new ManagementClass();
			newClass.path = new ManagementPath(ManagementPath.GetManagementPath(wbemObject));

			if (null != scope)
				newClass.scope = ManagementScope._Clone(scope);
			
			newClass.wbemObject = wbemObject;

			return newClass;
		}

		//default constructor
		/// <overload>
		///    Initializes a new instance
		///    of the <see cref='System.Management.ManagementClass'/> class.
		/// </overload>
		/// <summary>
		/// <para> Initializes a new instance of the <see cref='System.Management.ManagementClass'/> class. This is the
		///    default constructor.</para>
		/// </summary>
		/// <example>
		///    <code lang='C#'>ManagementClass c = new ManagementClass();
		///    </code>
		///    <code lang='VB'>Dim c As New ManagementClass()
		///    </code>
		/// </example>
		public ManagementClass() : this ((ManagementScope)null, (ManagementPath)null, null) {}

		//parameterized constructors
		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.ManagementClass'/> class initialized to the
		///    given path.</para>
		/// </summary>
		/// <param name='path'>A <see cref='System.Management.ManagementPath'/> specifying which WMI class to bind to.</param>
		/// <remarks>
		/// <para>The <paramref name="path"/> parameter must specify a WMI class
		///    path.</para>
		/// </remarks>
		/// <example>
		///    <code lang='C#'>ManagementClass c = new ManagementClass(
		///     new ManagementPath("Win32_LogicalDisk"));
		///    </code>
		///    <code lang='VB'>Dim c As New ManagementClass( _
		///     New ManagementPath("Win32_LogicalDisk"))
		///    </code>
		/// </example>
		public ManagementClass(ManagementPath path) : this(null, path, null) {}

		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.ManagementClass'/> class initialized to the given path.</para>
		/// </summary>
		/// <param name='path'>The path to the WMI class.</param>
		/// <example>
		///    <code lang='C#'>ManagementClass c = new
		///       ManagementClass("Win32_LogicalDisk");
		///    </code>
		///    <code lang='VB'>Dim c As New ManagementClass("Win32_LogicalDisk")
		///    </code>
		/// </example>
		public ManagementClass(string path) : this(null, new ManagementPath(path), null) {}

		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.ManagementClass'/> class initialized to the
		///    given WMI class path using the specified options.</para>
		/// </summary>
		/// <param name='path'>A <see cref='System.Management.ManagementPath'/> representing the WMI class path.</param>
		/// <param name=' options'>An <see cref='System.Management.ObjectGetOptions'/> representing the options to use when retrieving this class.</param>
		/// <example>
		///    <code lang='C#'>ManagementPath p = new ManagementPath("Win32_Process");
		/// //Options specify that amended qualifiers are to be retrieved along with the class
		/// ObjectGetOptions o = new ObjectGetOptions(null, true);    
		/// ManagementClass c = new ManagementClass(p,o);
		///    </code>
		///    <code lang='VB'>Dim p As New ManagementPath("Win32_Process")
		/// ' Options specify that amended qualifiers are to be retrieved along with the class
		/// Dim o As New ObjectGetOptions(Null, True)
		/// Dim c As New ManagementClass(p,o)
		///    </code>
		/// </example>
		public ManagementClass(ManagementPath path, ObjectGetOptions options) : this(null, path, options) {}

		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.ManagementClass'/> class initialized to the given WMI class path 
		///    using the specified options.</para>
		/// </summary>
		/// <param name='path'>The path to the WMI class.</param>
		/// <param name=' options'>An <see cref='System.Management.ObjectGetOptions'/> representing the options to use when retrieving the WMI class.</param>
		/// <example>
		///    <code lang='C#'>//Options specify that amended qualifiers should be retrieved along with the class
		/// ObjectGetOptions o = new ObjectGetOptions(null, true); 
		/// ManagementClass c = new ManagementClass("Win32_ComputerSystem",o);
		///    </code>
		///    <code lang='VB'>' Options specify that amended qualifiers should be retrieved along with the class
		/// Dim o As New ObjectGetOptions(Null, True)
		/// Dim c As New ManagementClass("Win32_ComputerSystem",o)
		///    </code>
		/// </example>
		public ManagementClass(string path, ObjectGetOptions options) 
			: this(null, new ManagementPath(path), options) {}

		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.ManagementClass'/> class for the specified
		///    WMI class in the specified scope and with the specified options.</para>
		/// </summary>
		/// <param name='scope'>A <see cref='System.Management.ManagementScope'/> that specifies the scope (server and namespace) where the WMI class resides. </param>
		/// <param name=' path'>A <see cref='System.Management.ManagementPath'/> that represents the path to the WMI class in the specified scope.</param>
		/// <param name=' options'>An <see cref='System.Management.ObjectGetOptions'/> that specifies the options to use when retrieving the WMI class.</param>
		/// <remarks>
		///    <para> The path can be specified as a full
		///       path (including server and namespace). However, if a scope is specified, it will
		///       override the first portion of the full path.</para>
		/// </remarks>
		/// <example>
		///    <code lang='C#'>ManagementScope s = new ManagementScope("\\\\MyBox\\root\\cimv2");
		/// ManagementPath p = new ManagementPath("Win32_Environment");
		/// ObjectGetOptions o = new ObjectGetOptions(null, true);
		/// ManagementClass c = new ManagementClass(s, p, o);
		///    </code>
		///    <code lang='VB'>Dim s As New ManagementScope("\\MyBox\root\cimv2")
		/// Dim p As New ManagementPath("Win32_Environment")
		/// Dim o As New ObjectGetOptions(Null, True)
		/// Dim c As New ManagementClass(s, p, o)
		///    </code>
		/// </example>
		public ManagementClass(ManagementScope scope, ManagementPath path, ObjectGetOptions options)
			: base (scope, path, options) {}

		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.ManagementClass'/> class for the specified WMI class, in the 
		///    specified scope, and with the specified options.</para>
		/// </summary>
		/// <param name='scope'>The scope in which the WMI class resides.</param>
		/// <param name=' path'>The path to the WMI class within the specified scope.</param>
		/// <param name=' options'>An <see cref='System.Management.ObjectGetOptions'/> that specifies the options to use when retrieving the WMI class.</param>
		/// <remarks>
		///    <para> The path can be specified as a full
		///       path (including server and namespace). However, if a scope is specified, it will
		///       override the first portion of the full path.</para>
		/// </remarks>
		/// <example>
		///    <code lang='C#'>ManagementClass c = new ManagementClass("\\\\MyBox\\root\\cimv2", 
		///                                         "Win32_Environment", 
		///                                         new ObjectGetOptions(null, true));
		///    </code>
		///    <code lang='VB'>Dim c As New ManagementClass("\\MyBox\root\cimv2", _
		///                              "Win32_Environment", _
		///                              new ObjectGetOptions(Null, True))
		///    </code>
		/// </example>
		public ManagementClass(string scope, string path, ObjectGetOptions options)
			: base (new ManagementScope(scope), new ManagementPath(path), options) {}

		ManagementClass(SerializationInfo info, StreamingContext context) : base(info, context) {}

		/// <summary>
		///    <para>Gets or sets the path of the WMI class to 
		///       which the <see cref='System.Management.ManagementClass'/>
		///       object is bound.</para>
		/// </summary>
		/// <value>
		///    <para>The path of the object's class.</para>
		/// </value>
		/// <remarks>
		///    <para> When the property is set to a new value, 
		///       the <see cref='System.Management.ManagementClass'/>
		///       object will be
		///       disconnected from any previously-bound WMI class. Reconnect to the new WMI class path.</para>
		/// </remarks>
		/// <example>
		///    <code lang='C#'>ManagementClass c = new ManagementClass(); 
		/// c.Path = "Win32_Environment";
		///    </code>
		///    <code lang='VB'>Dim c As New ManagementClass()
		/// c.Path = "Win32_Environment"
		///    </code>
		/// </example>
		public override ManagementPath Path 
		{
			get
			{
				return base.Path;
			}
			set
			{
				// This must be a class path or empty (don't allow instance paths)
				if ((null == value) || value.IsClass || value.IsEmpty)
					base.Path = value;
				else
					throw new ArgumentOutOfRangeException();
			}
		}
				
		/// <summary>
		///    <para> Gets or sets an array containing all WMI classes in the 
		///       inheritance hierarchy from this class to the top.</para>
		/// </summary>
		/// <value>
		///    A string collection containing the
		///    names of all WMI classes in the inheritance hierarchy of this class.
		/// </value>
		/// <remarks>
		///    <para>This property is read-only.</para>
		/// </remarks>
		/// <example>
		///    <code lang='C#'>ManagementClass c = new ManagementClass("Win32_LogicalDisk");
		/// foreach (string s in c.Derivation)
		///     Console.WriteLine("Further derived from : ", s);
		///    </code>
		///    <code lang='VB'>Dim c As New ManagementClass("Win32_LogicalDisk")
		/// Dim s As String
		/// For Each s In c.Derivation
		///     Console.WriteLine("Further derived from : " &amp; s)
		/// Next s
		///    </code>
		/// </example>
		public StringCollection Derivation 
		{ 
			get
			{
				StringCollection result = new StringCollection();

				//
				// Removed Initialize call since wbemObject is a property that will call Initialize ( true ) on
				// its getter.
				//
				// Initialize ( ) ;
				int dummy1 = 0, dummy2 = 0;
				object val = null;

				int status = wbemObject.Get_("__DERIVATION", 0, ref val, ref dummy1, ref dummy2);
				
				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}

				if (null != val)
					result.AddRange((String [])val);

				return result; 
			} 
		}


		/// <summary>
		/// <para>Gets or sets a collection of <see cref='System.Management.MethodData'/> objects that
		///    represent the methods defined in the WMI class.</para>
		/// </summary>
		/// <value>
		/// <para>A <see cref='System.Management.MethodDataCollection'/> representing the methods defined in the WMI class.</para>
		/// </value>
		/// <example>
		///    <code lang='C#'>ManagementClass c = new ManagementClass("Win32_Process");
		/// foreach (Method m in c.Methods)
		///     Console.WriteLine("This class contains this method : ", m.Name);
		///    </code>
		///    <code lang='VB'>Dim c As New ManagementClass("Win32_Process")
		/// Dim m As Method
		/// For Each m in c.Methods
		///      Console.WriteLine("This class contains this method : " &amp; m.Name)
		///    </code>
		/// </example>
		public MethodDataCollection Methods 
		{ 
			get
			{
				Initialize ( true ) ;

				if (methods == null)
					methods = new MethodDataCollection(this);

				return methods;
			}
		}

		//
		//Methods
		//

		//******************************************************
		//GetInstances
		//******************************************************
		/// <overload>
		///    Returns the collection of
		///    all instances of the class.
		/// </overload>
		/// <summary>
		///    <para>Returns the collection of all instances of the class.</para>
		/// </summary>
		/// <returns>
		/// <para>A collection of the <see cref='System.Management.ManagementObject'/> objects 
		///    representing the instances of the class.</para>
		/// </returns>
		/// <example>
		///    <code lang='C#'>ManagementClass c = new ManagementClass("Win32_Process");
		/// foreach (ManagementObject o in c.GetInstances())
		///      Console.WriteLine("Next instance of Win32_Process : ", o.Path);
		///    </code>
		///    <code lang='VB'>Dim c As New ManagementClass("Win32_Process")
		/// Dim o As ManagementObject
		/// For Each o In c.GetInstances()
		///      Console.WriteLine("Next instance of Win32_Process : " &amp; o.Path)
		/// Next o
		///    </code>
		/// </example>
		public ManagementObjectCollection GetInstances()
		{
			return GetInstances((EnumerationOptions)null);
		}

		
		/// <summary>
		///    <para>Returns the collection of all instances of the class using the specified options.</para>
		/// </summary>
		/// <param name='options'>The additional operation options.</param>
		/// <returns>
		/// <para>A collection of the <see cref='System.Management.ManagementObject'/> objects 
		///    representing the instances of the class, according to the specified options.</para>
		/// </returns>
		/// <example>
		///    <code lang='C#'>EnumerationOptions opt = new EnumerationOptions();
		/// //Will enumerate instances of the given class and any subclasses.
		/// o.enumerateDeep = true;
		/// ManagementClass c = new ManagementClass("CIM_Service");
		/// foreach (ManagementObject o in c.GetInstances(opt))
		///     Console.WriteLine(o["Name"]);
		///    </code>
		///    <code lang='VB'>Dim opt As New EnumerationOptions()
		/// 'Will enumerate instances of the given class and any subclasses.
		/// o.enumerateDeep = True
		/// Dim c As New ManagementClass("CIM_Service")
		/// Dim o As ManagementObject
		/// For Each o In c.GetInstances(opt)
		///     Console.WriteLine(o["Name"])
		/// Next o
		///    </code>
		/// </example>
		public ManagementObjectCollection GetInstances(EnumerationOptions options) 
		{
			if ((null == Path) || (String.Empty == Path.Path))
				throw new InvalidOperationException();

			Initialize ( false );
			IEnumWbemClassObject enumWbem = null;

			EnumerationOptions o = (null == options) ? new EnumerationOptions() : (EnumerationOptions)options.Clone();
			//Need to make sure that we're not passing invalid flags to enumeration APIs.
			//The only flags in EnumerationOptions not valid for enumerations are EnsureLocatable & PrototypeOnly.
			o.EnsureLocatable = false; o.PrototypeOnly = false;

			SecurityHandler securityHandler	= null;
			int status						= (int)ManagementStatus.NoError;

			try
			{
				securityHandler = Scope.GetSecurityHandler();

				status = Scope.GetIWbemServices().CreateInstanceEnum_(
															ClassName, 
															o.Flags, 
															o.GetContext(),
															out enumWbem);

				if (status >= 0)
					securityHandler.Secure(enumWbem);
			}
			finally
			{
				if (securityHandler != null)
					securityHandler.Reset();
			}

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}

			return new ManagementObjectCollection(Scope, o, enumWbem);
		}

		/// <summary>
		///    <para>Returns the collection of all instances of the class, asynchronously.</para>
		/// </summary>
		/// <param name='watcher'>The object to handle the asynchronous operation's progress. </param>
		/// <example>
		///    <code lang='C#'>ManagementClass c = new ManagementClass("Win32_Share");
		/// MyHandler h = new MyHandler();
		/// ManagementOperationObserver ob = new ManagementOperationObserver();
		/// ob.ObjectReady += new ObjectReadyEventHandler (h.NewObject);
		/// ob.Completed += new CompletedEventHandler (h.Done);
		/// 
		/// c.GetInstances(ob);
		/// 
		/// while (!h.Completed)
		///     System.Threading.Thread.Sleep (1000);
		/// 
		/// //Here you can use the object
		/// Console.WriteLine(o["SomeProperty"]);
		///      
		/// public class MyHandler
		/// {
		///     private bool completed = false;
		/// 
		///     public void NewObject(object sender, ObjectReadyEventArgs e) {
		///         Console.WriteLine("New result arrived !", ((ManagementObject)(e.NewObject))["Name"]);
		///     }
		/// 
		///     public void Done(object sender, CompletedEventArgs e) {
		///         Console.WriteLine("async Get completed !");
		///         completed = true;
		///     }
		/// 
		///     public bool Completed { 
		///         get {
		///             return completed;
		///         }
		///     }
		/// }
		///    </code>
		///    <code lang='VB'>Dim c As New ManagementClass("Win32_Share")
		/// Dim h As New MyHandler()
		/// Dim ob As New ManagementOperationObserver()
		/// ob.ObjectReady += New ObjectReadyEventHandler(h.NewObject)
		/// ob.Completed += New CompletedEventHandler(h.Done)
		/// 
		/// c.GetInstances(ob)
		/// 
		/// While Not h.Completed
		///     System.Threading.Thread.Sleep(1000)
		/// End While
		/// 
		/// 'Here you can use the object
		/// Console.WriteLine(o("SomeProperty"))
		///      
		/// Public Class MyHandler
		///     Private completed As Boolean = false
		/// 
		///     Public Sub Done(sender As Object, e As EventArrivedEventArgs)
		///         Console.WriteLine("async Get completed !")
		///     completed = True
		///     End Sub    
		/// 
		///     Public ReadOnly Property Completed() As Boolean
		///         Get
		///             Return completed
		///     End Get
		///     End Property
		/// End Class
		///    </code>
		/// </example>
		public void GetInstances(ManagementOperationObserver watcher) 
		{
			GetInstances(watcher, (EnumerationOptions)null);
		}
		

		/// <summary>
		///    <para>Returns the collection of all instances of the class, asynchronously, using 
		///       the specified options.</para>
		/// </summary>
		/// <param name='watcher'>The object to handle the asynchronous operation's progress. </param>
		/// <param name=' options'>The specified additional options for getting the instances.</param>
		public void GetInstances(ManagementOperationObserver watcher, EnumerationOptions options) 
		{
			if (null == watcher)
				throw new ArgumentNullException("watcher");
			
			if ((null ==Path) || (String.Empty == Path.Path))
				throw new InvalidOperationException();

			Initialize ( false ) ;

			EnumerationOptions o = (null == options) ? new EnumerationOptions() : (EnumerationOptions)options.Clone();

			//Need to make sure that we're not passing invalid flags to enumeration APIs.
			//The only flags in EnumerationOptions not valid for enumerations are EnsureLocatable & PrototypeOnly.
			o.EnsureLocatable = false; o.PrototypeOnly = false;
			
			// Ensure we switch off ReturnImmediately as this is invalid for async calls
			o.ReturnImmediately = false;

			// If someone has registered for progress, make sure we flag it
			if (watcher.HaveListenersForProgress)
				o.SendStatus = true;
			
			WmiEventSink sink = watcher.GetNewSink(Scope, o.Context);

			SecurityHandler securityHandler	= null;
			int status						= (int)ManagementStatus.NoError;

			securityHandler = Scope.GetSecurityHandler();

			status = Scope.GetIWbemServices().CreateInstanceEnumAsync_(
				ClassName,
				o.Flags,
				o.GetContext(),
				sink.Stub);

			if (securityHandler != null)
					securityHandler.Reset();

			if (status < 0)
			{
				watcher.RemoveSink(sink);
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}
		}

		//******************************************************
		//GetSubclasses
		//******************************************************
		/// <overload>
		///    Returns the collection of
		///    all subclasses for the class.
		/// </overload>
		/// <summary>
		///    <para>Returns the collection of all subclasses for the class.</para>
		/// </summary>
		/// <returns>
		/// <para>A collection of the <see cref='System.Management.ManagementObject'/> objects that
		///    represent the subclasses of the WMI class.</para>
		/// </returns>
		public ManagementObjectCollection GetSubclasses()
		{
			return GetSubclasses((EnumerationOptions)null);
		}
		
		
		/// <summary>
		///    <para>Retrieves the subclasses of the class using the specified
		///       options.</para>
		/// </summary>
		/// <param name='options'>The specified additional options for retrieving subclasses of the class.</param>
		/// <returns>
		/// <para>A collection of the <see cref='System.Management.ManagementObject'/> objects
		///    representing the subclasses of the WMI class, according to the specified
		///    options.</para>
		/// </returns>
		/// <example>
		///    <code lang='C#'>EnumerationOptions opt = new EnumerationOptions();
		///    
		/// //Causes return of deep subclasses as opposed to only immediate ones.
		/// opt.enumerateDeep = true;  
		///   
		/// ManagementObjectCollection c = (new
		///       ManagementClass("Win32_Share")).GetSubclasses(opt);
		///    </code>
		///    <code lang='VB'>Dim opt As New EnumerationOptions()
		/// 
		/// 'Causes return of deep subclasses as opposed to only immediate ones.
		/// opt.enumerateDeep = true
		/// 
		/// Dim cls As New ManagementClass("Win32_Share")
		/// Dim c As ManagementObjectCollection
		/// 
		/// c = cls.GetSubClasses(opt)
		///    </code>
		/// </example>
		public ManagementObjectCollection GetSubclasses(EnumerationOptions options) 
		{ 
			if (null == Path)
				throw new InvalidOperationException();

			Initialize ( false ) ;
			IEnumWbemClassObject enumWbem = null;

			EnumerationOptions o = (null == options) ? new EnumerationOptions() : (EnumerationOptions)options.Clone();
			//Need to make sure that we're not passing invalid flags to enumeration APIs.
			//The only flags in EnumerationOptions not valid for enumerations are EnsureLocatable & PrototypeOnly.
			o.EnsureLocatable = false; o.PrototypeOnly = false;

			SecurityHandler securityHandler = null;
			int status						= (int)ManagementStatus.NoError;

			try
			{
				securityHandler = Scope.GetSecurityHandler();

				status = Scope.GetIWbemServices().CreateClassEnum_(
					ClassName, 
					o.Flags, 
					o.GetContext(),
					out enumWbem);

				if (status >= 0)
					securityHandler.Secure(enumWbem);
			}
			finally
			{
				if (securityHandler != null)
					securityHandler.Reset();
			}

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}

			return new ManagementObjectCollection(Scope, o, enumWbem);
		}

		/// <summary>
		///    <para>Returns the collection of all subclasses of the class, asynchronously.</para>
		/// </summary>
		/// <param name='watcher'>The object to handle the asynchronous operation's progress. </param>
		public void GetSubclasses(ManagementOperationObserver watcher) 
		{ 
			GetSubclasses(watcher, (EnumerationOptions)null);
		}


		/// <summary>
		///    <para>Retrieves the subclasses of the class, asynchronously, using the specified 
		///       options.</para>
		/// </summary>
		/// <param name='watcher'>The object to handle the asynchronous operation's progress. </param>
		/// <param name='options'>The specified additional options to use in subclass retrieval.</param>
		public void GetSubclasses(ManagementOperationObserver watcher,
										EnumerationOptions options) 
		{ 				
			if (null == watcher)
				throw new ArgumentNullException("watcher");
			
			if (null == Path)
				throw new InvalidOperationException();

			Initialize ( false ) ;

			EnumerationOptions o = (null == options) ? new EnumerationOptions() : 
									  (EnumerationOptions)options.Clone();

			//Need to make sure that we're not passing invalid flags to enumeration APIs.
			//The only flags in EnumerationOptions not valid for enumerations are EnsureLocatable & PrototypeOnly.
			o.EnsureLocatable = false; o.PrototypeOnly = false;

			// Ensure we switch off ReturnImmediately as this is invalid for async calls
			o.ReturnImmediately = false;

			// If someone has registered for progress, make sure we flag it
			if (watcher.HaveListenersForProgress)
				o.SendStatus = true;

			WmiEventSink sink = watcher.GetNewSink(Scope, o.Context);

			SecurityHandler securityHandler = null;
			int status						= (int)ManagementStatus.NoError;

			securityHandler = Scope.GetSecurityHandler();

			status = Scope.GetIWbemServices().CreateClassEnumAsync_(
				ClassName,
				o.Flags,
				o.GetContext(),
				sink.Stub);

			if (securityHandler != null)
				securityHandler.Reset();

			if (status < 0)
			{
				watcher.RemoveSink(sink);
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}
		}

		//******************************************************
		//Derive
		//******************************************************
		/// <summary>
		///    <para>Derives a new class from this class.</para>
		/// </summary>
		/// <param name='newClassName'>The name of the new class to be derived.</param>
		/// <returns>
		/// <para>A new <see cref='System.Management.ManagementClass'/> 
		/// that represents a new WMI class derived from the original class.</para>
		/// </returns>
		/// <remarks>
		///    <para>Note that the newly returned class has not been committed 
		///       until the <see cref='System.Management.ManagementObject.Put'/>() method is explicitly called.</para>
		/// </remarks>
		/// <example>
		///    <code lang='C#'>ManagementClass existingClass = new ManagementClass("CIM_Service");
		///    ManagementClass newClass = existingClass.Derive("My_Service");
		///    newClass.Put(); //to commit the new class to the WMI repository.
		///    </code>
		///    <code lang='VB'>Dim existingClass As New ManagementClass("CIM_Service")
		/// Dim newClass As ManagementClass
		/// 
		/// newClass = existingClass.Derive("My_Service")
		/// newClass.Put()  'to commit the new class to the WMI repository.
		///    </code>
		/// </example>
		public ManagementClass Derive(string newClassName)
		{
			ManagementClass newClass = null;

			if (null == newClassName)
				throw new ArgumentNullException("newClassName");
			else 
			{
				// Check the path is valid
				ManagementPath path = new ManagementPath();

				try
				{
					path.ClassName = newClassName;
				}
				catch (Exception)
				{
					throw new ArgumentOutOfRangeException("newClassName");
				}

				if (!path.IsClass)
					throw new ArgumentOutOfRangeException("newClassName");
			}

			if (PutButNotGot)
			{
				//Path = new ManagementPath(putPath);
				Get();
				PutButNotGot = false;
			}
				
			//
			// Removed Initialize call since wbemObject is a property that will call Initialize ( true ) on
			// its getter.
			//
			// Initialize ( ) ;

			IWbemClassObjectFreeThreaded newWbemClass = null;
			int status = this.wbemObject.SpawnDerivedClass_(0, out newWbemClass);
				
			if (status >= 0)
			{
				object val = newClassName;
				status = newWbemClass.Put_("__CLASS", 0, ref val, 0);
					
				if (status >= 0)
					newClass = ManagementClass.GetManagementClass(newWbemClass, this);
			} 

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}

			return newClass;
		}

		//******************************************************
		//CreateInstance
		//******************************************************
		/// <summary>
		///    <para>Creates a new instance of the WMI class.</para>
		/// </summary>
		/// <returns>
		/// <para>A <see cref='System.Management.ManagementObject'/> that represents a new
		///    instance of the WMI class.</para>
		/// </returns>
		/// <remarks>
		///    <para>Note that the new instance is not committed until the 
		///    <see cref='System.Management.ManagementObject.Put'/>() method is called. Before committing it, the key properties must
		///       be specified.</para>
		/// </remarks>
		/// <example>
		///    <code lang='C#'>ManagementClass envClass = new ManagementClass("Win32_Environment");
		///    ManagementObject newInstance = 
		///       existingClass.CreateInstance("My_Service");
		///    newInstance["Name"] = "Cori";
		///    newInstance.Put(); //to commit the new instance.
		///    </code>
		///    <code lang='VB'>Dim envClass As New ManagementClass("Win32_Environment")
		/// Dim newInstance As ManagementObject
		/// 
		/// newInstance = existingClass.CreateInstance("My_Service")
		/// newInstance("Name") = "Cori"
		/// newInstance.Put()  'to commit the new instance.
		///    </code>
		/// </example>
		public ManagementObject CreateInstance()
		{
			ManagementObject newInstance = null;

			if (PutButNotGot)
			{
				//Path = new ManagementPath(putPath);
				Get();
				PutButNotGot = false;
			}

			//
			// Removed Initialize call since wbemObject is a property that will call Initialize ( true ) on
			// its getter.
			//
			// Initialize ( ) ;

			IWbemClassObjectFreeThreaded newWbemInstance = null;
			int status = this.wbemObject.SpawnInstance_(0, out newWbemInstance);

			if (status >= 0)
				newInstance = ManagementObject.GetManagementObject(newWbemInstance, Scope);
			else
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}

			return newInstance;
		}

		/// <summary>
		///    <para>Returns a copy of the object.</para>
		/// </summary>
		/// <returns>
		///    <para> The cloned 
		///       object.</para>
		/// </returns>
		/// <remarks>
		///    <para>Note that this does not create a copy of the
		///       WMI class; only an additional representation is created.</para>
		/// </remarks>
		public override Object Clone()
		{
			//
			// Removed Initialize call since wbemObject is a property that will call Initialize ( true ) on
			// its getter.
			//
			// Initialize ( ) ;
			
			IWbemClassObjectFreeThreaded theClone = null;
			int status = wbemObject.Clone_(out theClone);

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}

			return ManagementClass.GetManagementClass(theClone, this);
		}


		//******************************************************
		//GetRelatedClasses
		//******************************************************
		/// <overload>
		///    Retrieves classes related
		///    to the WMI class.
		/// </overload>
		/// <summary>
		///    <para> Retrieves classes related to the WMI class.</para>
		/// </summary>
		/// <returns>
		/// <para>A collection of the <see cref='System.Management.ManagementClass'/> or <see cref='System.Management.ManagementObject'/> 
		/// objects that represents WMI classes or instances related to
		/// the WMI class.</para>
		/// </returns>
		/// <remarks>
		///    <para>The method queries the WMI schema for all
		///       possible associations that the WMI class may have with other classes, or in rare
		///       cases, to instances.</para>
		/// </remarks>
		/// <example>
		///    <code lang='C#'>ManagementClass c = new ManagementClass("Win32_LogicalDisk");
		/// 
		/// foreach (ManagementClass r in c.GetRelatedClasses())
		///     Console.WriteLine("Instances of {0} may have
		///                        relationships to this class", r["__CLASS"]);
		///    </code>
		///    <code lang='VB'>Dim c As New ManagementClass("Win32_LogicalDisk")
		/// Dim r As ManagementClass
		/// 
		/// For Each r In c.GetRelatedClasses()
		///     Console.WriteLine("Instances of {0} may have relationships _
		///                        to this class", r("__CLASS"))
		/// Next r
		///    </code>
		/// </example>
		public ManagementObjectCollection GetRelatedClasses()
		{
			return GetRelatedClasses((string)null);
		}

		/// <summary>
		///    <para> Retrieves classes related to the WMI class.</para>
		/// </summary>
		/// <param name='relatedClass'><para>The class from which resulting classes have to be derived.</para></param>
		/// <returns>
		///    A collection of classes related to
		///    this class.
		/// </returns>
		public ManagementObjectCollection GetRelatedClasses(
			string relatedClass) 
		{ 
			return GetRelatedClasses(relatedClass, null, null, null, null, null, null); 
		}

	
		/// <summary>
		///    <para> Retrieves classes related to the WMI class based on the specified 
		///       options.</para>
		/// </summary>
		/// <param name=' relatedClass'><para>The class from which resulting classes have to be derived.</para></param>
		/// <param name=' relationshipClass'> The relationship type which resulting classes must have with the source class.</param>
		/// <param name=' relationshipQualifier'>This qualifier must be present on the relationship.</param>
		/// <param name=' relatedQualifier'>This qualifier must be present on the resulting classes.</param>
		/// <param name=' relatedRole'>The resulting classes must have this role in the relationship.</param>
		/// <param name=' thisRole'>The source class must have this role in the relationship.</param>
		/// <param name=' options'>The options for retrieving the resulting classes.</param>
		/// <returns>
		///    <para>A collection of classes related to
		///       this class.</para>
		/// </returns>
		public ManagementObjectCollection GetRelatedClasses(
											string relatedClass,
											string relationshipClass,
											string relationshipQualifier,
											string relatedQualifier,
											string relatedRole,
											string thisRole,
											EnumerationOptions options)
		{
			if ((null == Path) || (String.Empty == Path.Path))
				throw new InvalidOperationException();

			Initialize ( false ) ;

			IEnumWbemClassObject enumWbem = null;

			EnumerationOptions o = (null != options) ? (EnumerationOptions)options.Clone() : new EnumerationOptions();
			//Ensure EnumerateDeep flag bit is turned off as it's invalid for queries
			o.EnumerateDeep = true;

			RelatedObjectQuery q = new RelatedObjectQuery(true,	Path.Path, 
															relatedClass,
															relationshipClass, 
															relatedQualifier,
															relationshipQualifier, 
															relatedRole, thisRole);

			SecurityHandler securityHandler = null;
			int status						= (int)ManagementStatus.NoError;

    		try
			{
				securityHandler = Scope.GetSecurityHandler();
				
				status = Scope.GetIWbemServices().ExecQuery_(
					q.QueryLanguage, 
					q.QueryString, 
					o.Flags, 
					o.GetContext(), 
					out enumWbem);

				if (status >= 0)
					securityHandler.Secure(enumWbem);
			}
			finally
			{
				if (securityHandler != null)
					securityHandler.Reset();
			}
			
			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}

			//Create collection object
			return new ManagementObjectCollection(Scope, o, enumWbem);
		}


		/// <summary>
		///    <para> Retrieves classes 
		///       related to the WMI class, asynchronously.</para>
		/// </summary>
		/// <param name='watcher'>The object to handle the asynchronous operation's progress. </param>
		public void GetRelatedClasses(
			ManagementOperationObserver watcher)
		{
			GetRelatedClasses(watcher, (string)null);
		}

		/// <summary>
		///    <para> Retrieves classes related to the WMI class, asynchronously, given the related 
		///       class name.</para>
		/// </summary>
		/// <param name='watcher'>The object to handle the asynchronous operation's progress. </param>
		/// <param name=' relatedClass'>The name of the related class.</param>
		public void GetRelatedClasses(
			ManagementOperationObserver watcher, 
			string relatedClass) 
		{
			GetRelatedClasses(watcher, relatedClass, null, null, null, null, null, null);
		}

		
		/// <summary>
		///    <para> Retrieves classes related to the 
		///       WMI class, asynchronously, using the specified options.</para>
		/// </summary>
		/// <param name='watcher'>Handler for progress and results of the asynchronous operation.</param>
		/// <param name=' relatedClass'><para>The class from which resulting classes have to be derived.</para></param>
		/// <param name=' relationshipClass'> The relationship type which resulting classes must have with the source class.</param>
		/// <param name=' relationshipQualifier'>This qualifier must be present on the relationship.</param>
		/// <param name=' relatedQualifier'>This qualifier must be present on the resulting classes.</param>
		/// <param name=' relatedRole'>The resulting classes must have this role in the relationship.</param>
		/// <param name=' thisRole'>The source class must have this role in the relationship.</param>
		/// <param name=' options'>The options for retrieving the resulting classes.</param>
		public void GetRelatedClasses(
			ManagementOperationObserver watcher, 
			string relatedClass,
			string relationshipClass,
			string relationshipQualifier,
			string relatedQualifier,
			string relatedRole,
			string thisRole,
			EnumerationOptions options)
		{
			if ((null == Path) || (String.Empty == Path.Path))
				throw new InvalidOperationException();

			Initialize ( true ) ;

			if (null == watcher)
				throw new ArgumentNullException("watcher");
			else
			{
				EnumerationOptions o = (null != options) 
								? (EnumerationOptions)options.Clone() : new EnumerationOptions();

				//Ensure EnumerateDeep flag bit is turned off as it's invalid for queries
				o.EnumerateDeep = true;

				// Ensure we switch off ReturnImmediately as this is invalid for async calls
				o.ReturnImmediately = false;

				// If someone has registered for progress, make sure we flag it
				if (watcher.HaveListenersForProgress)
					o.SendStatus = true;
			
				WmiEventSink sink = watcher.GetNewSink(
					Scope, 
					o.Context);

				RelatedObjectQuery q = new RelatedObjectQuery(true, Path.Path, 
																relatedClass, relationshipClass, 
																relatedQualifier, relationshipQualifier, 
																relatedRole, thisRole);
            
				SecurityHandler securityHandler = null;
				int status						= (int)ManagementStatus.NoError;

				securityHandler = Scope.GetSecurityHandler();

				status = Scope.GetIWbemServices().ExecQueryAsync_(
						q.QueryLanguage, 
						q.QueryString, 
						o.Flags, 
						o.GetContext(), 
						sink.Stub);

				if (securityHandler != null)
					securityHandler.Reset();

				if (status < 0)
				{
					watcher.RemoveSink(sink);
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}
			}
		}

		//******************************************************
		//GetRelationshipClasses
		//******************************************************
		/// <overload>
		///    Retrieves relationship
		///    classes that relate the class to others.
		/// </overload>
		/// <summary>
		///    <para>Retrieves relationship classes that relate the class to others.</para>
		/// </summary>
		/// <returns>
		///    <para>A collection of association classes
		///       that relate the class to any other class.</para>
		/// </returns>
		public ManagementObjectCollection GetRelationshipClasses()
		{
			return GetRelationshipClasses((string)null);
		}

		/// <summary>
		///    <para>Retrieves relationship classes that relate the class to others, where the 
		///       endpoint class is the specified class.</para>
		/// </summary>
		/// <param name='relationshipClass'>The endpoint class for all relationship classes returned.</param>
		/// <returns>
		///    <para>A collection of association classes
		///       that relate the class to the specified class.</para>
		/// </returns>
		public ManagementObjectCollection GetRelationshipClasses(
			string relationshipClass)
		{ 
			return GetRelationshipClasses(relationshipClass, null, null, null); 
		}


		/// <summary>
		///    <para> Retrieves relationship classes that relate this class to others, according to 
		///       specified options.</para>
		/// </summary>
		/// <param name='relationshipClass'><para> All resulting relationship classes must derive from this class.</para></param>
		/// <param name=' relationshipQualifier'>Resulting relationship classes must have this qualifier.</param>
		/// <param name=' thisRole'>The source class must have this role in the resulting relationship classes.</param>
		/// <param name=' options'>Specifies options for retrieving the results.</param>
		/// <returns>
		///    <para>A collection of association classes
		///       that relate this class to others, according to the specified options.</para>
		/// </returns>
		public ManagementObjectCollection GetRelationshipClasses(
											string relationshipClass,
											string relationshipQualifier,
											string thisRole,
											EnumerationOptions options)
        {
			if ((null == Path) || (String.Empty == Path.Path))
				throw new InvalidOperationException();

			Initialize ( false ) ;

			IEnumWbemClassObject enumWbem = null;

			EnumerationOptions o = (null != options) ? options : new EnumerationOptions();
			//Ensure EnumerateDeep flag is turned off as it's invalid for queries
			o.EnumerateDeep = true;

			
			RelationshipQuery q = new RelationshipQuery(true, Path.Path, relationshipClass,  
														relationshipQualifier, thisRole);
            
			SecurityHandler securityHandler = null;
			int status						= (int)ManagementStatus.NoError;

			//Execute WMI query
			try
			{
				securityHandler = Scope.GetSecurityHandler();

				status = Scope.GetIWbemServices().ExecQuery_(
					q.QueryLanguage, 
					q.QueryString, 
					o.Flags, 
					o.GetContext(), 
					out enumWbem);

				if (status >= 0)
					securityHandler.Secure(enumWbem);
			}
			finally
			{
				if (securityHandler != null)
					securityHandler.Reset();
			}

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}

			//Create collection object
			return new ManagementObjectCollection(Scope, o, enumWbem);
		}


		/// <summary>
		///    <para>Retrieves relationship classes that relate the class to others, 
		///       asynchronously.</para>
		/// </summary>
		/// <param name='watcher'>The object to handle the asynchronous operation's progress. </param>
		public void GetRelationshipClasses(
			ManagementOperationObserver watcher)
		{
			GetRelationshipClasses(watcher, (string)null);
		}

		/// <summary>
		///    <para>Retrieves relationship classes that relate the class to the specified WMI class, 
		///       asynchronously.</para>
		/// </summary>
		/// <param name='watcher'>The object to handle the asynchronous operation's progress. </param>
		/// <param name=' relationshipClass'>The WMI class to which all returned relationships should point.</param>
		public void GetRelationshipClasses(
			ManagementOperationObserver watcher, 
			string relationshipClass)
		{
			GetRelationshipClasses(watcher, relationshipClass, null, null, null);
		}
		

		/// <summary>
		///    <para>Retrieves relationship classes that relate the class according to the specified 
		///       options, asynchronously.</para>
		/// </summary>
		/// <param name='watcher'>The handler for progress and results of the asynchronous operation.</param>
		/// <param name='relationshipClass'><para>The class from which all resulting relationship classes must derive.</para></param>
		/// <param name=' relationshipQualifier'>The qualifier which the resulting relationship classes must have.</param>
		/// <param name=' thisRole'>The role which the source class must have in the resulting relationship classes.</param>
		/// <param name=' options'> The options for retrieving the results.</param>
		/// <returns>
		///    <para>A collection of association classes
		///       relating this class to others, according to the given options.</para>
		/// </returns>
		public void GetRelationshipClasses(
			ManagementOperationObserver watcher, 
			string relationshipClass,
			string relationshipQualifier,
			string thisRole,
			EnumerationOptions options)
		{
			if ((null == Path) || (String.Empty == Path.Path))
				throw new InvalidOperationException();
			if (null == watcher)
				throw new ArgumentNullException("watcher");
			else
			{
				Initialize ( true ) ;
			
				EnumerationOptions o = 
						(null != options) ? (EnumerationOptions)options.Clone() : new EnumerationOptions();

				//Ensure EnumerateDeep flag is turned off as it's invalid for queries
				o.EnumerateDeep = true;

				// Ensure we switch off ReturnImmediately as this is invalid for async calls
				o.ReturnImmediately = false;

				// If someone has registered for progress, make sure we flag it
				if (watcher.HaveListenersForProgress)
					o.SendStatus = true;
				
				WmiEventSink sink = watcher.GetNewSink(Scope, o.Context);

				RelationshipQuery q = new RelationshipQuery(true, Path.Path, relationshipClass,
						relationshipQualifier, thisRole);

				SecurityHandler securityHandler = null;
				int status						= (int)ManagementStatus.NoError;

				securityHandler = Scope.GetSecurityHandler();

				status = Scope.GetIWbemServices().ExecQueryAsync_(
						q.QueryLanguage, 
						q.QueryString, 
						o.Flags, 
						o.GetContext(), 
						sink.Stub);

				if (securityHandler != null)
					securityHandler.Reset();

				if (status < 0)
				{
					watcher.RemoveSink(sink);
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}
			}
		}

		
		/// <overload>
		///    <para>Generates a strongly-typed class for a given WMI class.</para>
		/// </overload>
		/// <summary>
		///    <para>Generates a strongly-typed class for a given WMI class.</para>
		/// </summary>
		/// <param name='includeSystemClassInClassDef'><see langword='true'/> if the class for managing system properties must be included; otherwise, <see langword='false'/>.</param>
		/// <param name='systemPropertyClass'><see langword='true'/> if the generated class will manage system properties; otherwise, <see langword='false'/>.</param>
		/// <returns>
		/// <para>A <see cref='System.CodeDom.CodeTypeDeclaration'/> instance
		///    representing the declaration for the strongly-typed class.</para>
		/// </returns>
		/// <example>
		///    <code lang='C#'>using System;
		/// using System.Management; 
		/// using System.CodeDom;
		/// using System.IO;
		/// using System.CodeDom.Compiler;
		/// using Microsoft.CSharp;
		/// 
		/// void GenerateCSharpCode()
		/// {
		///       string strFilePath = "C:\\temp\\LogicalDisk.cs";
		///       CodeTypeDeclaration ClsDom;
		///     
		///       ManagementClass cls1 = new ManagementClass(null,"Win32_LogicalDisk",null);
		///       ClsDom = cls1.GetStronglyTypedClassCode(false,false);
		///     
		///       ICodeGenerator cg = (new CSharpCodeProvider()).CreateGenerator ();
		///       CodeNamespace cn = new CodeNamespace("TestNamespace");
		///     
		///       // Add any imports to the code
		///       cn.Imports.Add (new CodeNamespaceImport("System"));
		///       cn.Imports.Add (new CodeNamespaceImport("System.ComponentModel"));
		///       cn.Imports.Add (new CodeNamespaceImport("System.Management"));
		///       cn.Imports.Add(new CodeNamespaceImport("System.Collections"));
		///    
		///       // Add class to the namespace
		///       cn.Types.Add (ClsDom);
		///     
		///       //Now create the filestream (output file)
		///       TextWriter tw = new StreamWriter(new
		///       FileStream (strFilePath,FileMode.Create));
		///     
		///       // And write it to the file
		///       cg.GenerateCodeFromNamespace (cn, tw, new CodeGeneratorOptions());
		/// 
		///       tw.Close();
		/// }
		///    </code>
		/// </example>
		public CodeTypeDeclaration GetStronglyTypedClassCode(bool includeSystemClassInClassDef, bool systemPropertyClass)
		{
			// Ensure that the object is valid
			Get();
			ManagementClassGenerator classGen = new ManagementClassGenerator(this);
			return classGen.GenerateCode(includeSystemClassInClassDef,systemPropertyClass);
		}
		
		
		/// <summary>
		///    <para>Generates a strongly-typed class for a given WMI class. This function generates code for Visual Basic, 
		///       C#, or JScript, depending on the input parameters.</para>
		/// </summary>
		/// <param name='lang'>The language of the code to be generated.</param>
		/// <param name='filePath'>The path of the file where the code is to be written.</param>
		/// <param name='classNamespace'>The .NET namespace into which the class should be generated. If this is empty, the namespace will be generated from the WMI namespace.</param>
		/// <returns>
		/// <para><see langword='true'/>, if the method succeeded; 
		///    otherwise, <see langword='false'/> .</para>
		/// </returns>
		/// <example>
		///    <code lang='C#'>using System;
		/// using System.Management; 
		///    
		/// ManagementClass cls = new ManagementClass(null,"Win32_LogicalDisk",null,"");
		/// cls.GetStronglyTypedClassCode(CodeLanguage.CSharp,"C:\temp\Logicaldisk.cs",String.Empty);
		///    </code>
		/// </example>
		public bool GetStronglyTypedClassCode(CodeLanguage lang, String filePath,String classNamespace)
		{
			// Ensure that the object is valid
			Get();
			ManagementClassGenerator classGen = new ManagementClassGenerator(this);
			return classGen.GenerateCode(lang , filePath,classNamespace);
		}

	}//ManagementClass
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\managementeventwatcher.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Collections;
using System.Runtime.InteropServices;
using WbemClient_v1;
using System.Diagnostics;
using System.ComponentModel;
using System.Threading;

namespace System.Management
{
	/// <summary>
	/// <para>Represents the method that will handle the <see cref='E:System.Management.ManagementEventWatcher.EventArrived'/> event.</para>
	/// </summary>
	public delegate void EventArrivedEventHandler(object sender, EventArrivedEventArgs e);

	/// <summary>
	/// <para>Represents the method that will handle the <see cref='E:System.Management.ManagementEventWatcher.Stopped'/> event.</para>
	/// </summary>
	public delegate void StoppedEventHandler (object sender, StoppedEventArgs e);

	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para> Subscribes to temporary event notifications
	///       based on a specified event query.</para>
	/// </summary>
	/// <example>
	///    <code lang='C#'>using System; 
	/// using System.Management; 
	/// 
	/// // This example demonstrates how to subscribe to an event using the ManagementEventWatcher object. 
	/// class Sample_ManagementEventWatcher 
	/// { 
	///     public static int Main(string[] args) { 
	/// 
	///         //For the example, we'll put a class into the repository, and watch
	///         //for class deletion events when the class is deleted.
	///         ManagementClass newClass = new ManagementClass(); 
	///         newClass["__CLASS"] = "TestDeletionClass";
	///         newClass.Put();
	/// 
	///         //Set up an event watcher and a handler for the event
	///         ManagementEventWatcher watcher = new ManagementEventWatcher(
	///             new WqlEventQuery("__ClassDeletionEvent"));
	///         MyHandler handler = new MyHandler();
	///         watcher.EventArrived += new EventArrivedEventHandler(handler.Arrived);
	/// 
	///         //Start watching for events
	///         watcher.Start();
	///       
	///         // For the purpose of this sample, we delete the class to trigger the event
	///         // and wait for two seconds before terminating the consumer
	///         newClass.Delete();
	///        
	///         System.Threading.Thread.Sleep(2000);
	///  
	///         //Stop watching
	///         watcher.Stop();
	///        
	///         return 0;
	///     }
	///  
	///     public class MyHandler {
	///         public void Arrived(object sender, EventArrivedEventArgs e) {
	///             Console.WriteLine("Class Deleted = " +
	///                ((ManagementBaseObject)e.NewEvent["TargetClass"])["__CLASS"]);
	///         }
	///     }
	/// }
	///    </code>
	///    <code lang='VB'>Imports System
	/// Imports System.Management
	/// 
	/// ' This example demonstrates how to subscribe an event using the ManagementEventWatcher object.
	/// Class Sample_ManagementEventWatcher
	///     Public Shared Sub Main()
	/// 
	///         ' For the example, we'll put a class into the repository, and watch
	///         ' for class deletion events when the class is deleted.
	///         Dim newClass As New ManagementClass()
	///         newClass("__CLASS") = "TestDeletionClass"
	///         newClass.Put()
	///         
	///         ' Set up an event watcher and a handler for the event
	///         Dim watcher As _
	///             New ManagementEventWatcher(New WqlEventQuery("__ClassDeletionEvent"))
	///         Dim handler As New MyHandler()
	///         AddHandler watcher.EventArrived, AddressOf handler.Arrived
	///  
	///         ' Start watching for events
	///         watcher.Start()
	/// 
	///         ' For the purpose of this sample, we delete the class to trigger the event
	///         ' and wait for two seconds before terminating the consumer      
	///         newClass.Delete()
	/// 
	///         System.Threading.Thread.Sleep(2000)
	///   
	///         ' Stop watching
	///         watcher.Stop()
	/// 
	///     End Sub
	/// 
	///     Public Class MyHandler
	///         Public Sub Arrived(sender As Object, e As EventArrivedEventArgs)
	///             Console.WriteLine("Class Deleted = " &amp; _
	///                 CType(e.NewEvent("TargetClass"), ManagementBaseObject)("__CLASS"))
	///         End Sub
	///     End Class
	/// End Class
	///    </code>
	/// </example>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	[ToolboxItem(false)]
	public class ManagementEventWatcher : Component
	{
		//fields
		private ManagementScope			scope;
		private EventQuery				query;
		private EventWatcherOptions		options;
		private IEnumWbemClassObject	enumWbem;
		private IWbemClassObjectFreeThreaded[]		cachedObjects; //points to objects currently available in cache
		private uint					cachedCount; //says how many objects are in the cache (when using BlockSize option)
		private uint					cacheIndex; //used to walk the cache
		private SinkForEventQuery		sink; // the sink implementation for event queries
		private WmiDelegateInvoker		delegateInvoker; 
		
		//Called when IdentifierChanged() event fires
		private void HandleIdentifierChange(object sender, 
					IdentifierChangedEventArgs e)
		{
			// Invalidate any sync or async call in progress
			Stop();
		}

		//default constructor
		/// <overload>
		///    Initializes a new instance of the <see cref='System.Management.ManagementEventWatcher'/> class.
		/// </overload>
		/// <summary>
		/// <para> Initializes a new instance of the <see cref='System.Management.ManagementEventWatcher'/> class. For further
		///    initialization, set the properties on the object. This is the default constructor.</para>
		/// </summary>
		public ManagementEventWatcher() : this((ManagementScope)null, null, null) {}

		//parameterized constructors
		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.ManagementEventWatcher'/> class when given a WMI event query.</para>
		/// </summary>
		/// <param name='query'>An <see cref='System.Management.EventQuery'/> object representing a WMI event query, which determines the events for which the watcher will listen.</param>
		/// <remarks>
		///    <para>The namespace in which the watcher will be listening for
		///       events is the default namespace that is currently set.</para>
		/// </remarks>
		public ManagementEventWatcher (
			EventQuery query) : this(null, query, null) {}

		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.ManagementEventWatcher'/> class when given a WMI event query in the 
		///    form of a string.</para>
		/// </summary>
		/// <param name='query'> A WMI event query, which defines the events for which the watcher will listen.</param>
		/// <remarks>
		///    <para>The namespace in which the watcher will be listening for
		///       events is the default namespace that is currently set.</para>
		/// </remarks>
		public ManagementEventWatcher (
			string query) : this(null, new EventQuery(query), null) {}

		/// <summary>
		/// <para> Initializes a new instance of the <see cref='System.Management.ManagementEventWatcher'/> 
		/// class that listens for events conforming to the given WMI event query.</para>
		/// </summary>
		/// <param name='scope'>A <see cref='System.Management.ManagementScope'/> object representing the scope (namespace) in which the watcher will listen for events.</param>
		/// <param name=' query'>An <see cref='System.Management.EventQuery'/> object representing a WMI event query, which determines the events for which the watcher will listen.</param>
		public ManagementEventWatcher(
			ManagementScope scope, 
			EventQuery query) : this(scope, query, null) {}

		/// <summary>
		/// <para> Initializes a new instance of the <see cref='System.Management.ManagementEventWatcher'/> 
		/// class that listens for events conforming to the given WMI event query. For this
		/// variant, the query and the scope are specified as strings.</para>
		/// </summary>
		/// <param name='scope'> The management scope (namespace) in which the watcher will listen for events.</param>
		/// <param name=' query'> The query that defines the events for which the watcher will listen.</param>
		public ManagementEventWatcher(
			string scope, 
			string query) : this(new ManagementScope(scope), new EventQuery(query), null) {}

      		/// <summary>
      		/// <para> Initializes a new instance of the <see cref='System.Management.ManagementEventWatcher'/> class that listens for 
      		///    events conforming to the given WMI event query, according to the specified options. For
      		///    this variant, the query and the scope are specified as strings. The options
      		///    object can specify options such as a timeout and context information.</para>
      		/// </summary>
      		/// <param name='scope'>The management scope (namespace) in which the watcher will listen for events.</param>
      		/// <param name=' query'>The query that defines the events for which the watcher will listen.</param>
      		/// <param name='options'>An <see cref='System.Management.EventWatcherOptions'/> object representing additional options used to watch for events. </param>
      		public ManagementEventWatcher(
			string scope,
			string query,
			EventWatcherOptions options) : this(new ManagementScope(scope), new EventQuery(query), options) {}

		/// <summary>
		/// <para> Initializes a new instance of the <see cref='System.Management.ManagementEventWatcher'/> class 
		///    that listens for events conforming to the given WMI event query, according to the specified
		///    options. For this variant, the query and the scope are specified objects. The
		///    options object can specify options such as timeout and context information.</para>
		/// </summary>
		/// <param name='scope'>A <see cref='System.Management.ManagementScope'/> object representing the scope (namespace) in which the watcher will listen for events.</param>
		/// <param name=' query'>An <see cref='System.Management.EventQuery'/> object representing a WMI event query, which determines the events for which the watcher will listen.</param>
		/// <param name='options'>An <see cref='System.Management.EventWatcherOptions'/> object representing additional options used to watch for events. </param>
		public ManagementEventWatcher(
			ManagementScope scope, 
			EventQuery query, 
			EventWatcherOptions options)
		{
			if (null != scope)
				this.scope = ManagementScope._Clone(scope, new IdentifierChangedEventHandler(HandleIdentifierChange));
			else
				this.scope = ManagementScope._Clone(null, new IdentifierChangedEventHandler(HandleIdentifierChange));

			if (null != query)
				this.query = (EventQuery)query.Clone();
			else
				this.query = new EventQuery();
			this.query.IdentifierChanged += new IdentifierChangedEventHandler(HandleIdentifierChange);

			if (null != options)
				this.options = (EventWatcherOptions)options.Clone();
			else
				this.options = new EventWatcherOptions();
			this.options.IdentifierChanged += new IdentifierChangedEventHandler(HandleIdentifierChange);

			enumWbem = null;
			cachedCount = 0; 
			cacheIndex = 0;
			sink = null;
			delegateInvoker = new WmiDelegateInvoker (this);
		}
		
		/// <summary>
		///    <para>Ensures that outstanding calls are cleared. This is the destructor for the object.</para>
		/// </summary>
		~ManagementEventWatcher ()
		{
			// Ensure any outstanding calls are cleared
			Stop ();

			if (null != scope)
				scope.IdentifierChanged -= new IdentifierChangedEventHandler (HandleIdentifierChange);

			if (null != options)
				options.IdentifierChanged -= new IdentifierChangedEventHandler (HandleIdentifierChange);

			if (null != query)
				query.IdentifierChanged -= new IdentifierChangedEventHandler (HandleIdentifierChange);
		}

		// 
		// Events
		//

		/// <summary>
		///    <para> Occurs when a new event arrives.</para>
		/// </summary>
		public event EventArrivedEventHandler		EventArrived;

		/// <summary>
		///    <para> Occurs when a subscription is canceled.</para>
		/// </summary>
		public event StoppedEventHandler			Stopped;

		//
		//Public Properties
		//

		/// <summary>
		///    <para>Gets or sets the scope in which to watch for events (namespace or scope).</para>
		/// </summary>
		/// <value>
		///    <para> The scope in which to watch for events (namespace or scope).</para>
		/// </value>
		public ManagementScope Scope 
		{
			get { 
				return scope; 
			} 
			set {
				if (null != value)
				{
					ManagementScope oldScope = scope;
					scope = (ManagementScope)value.Clone ();

					// Unregister ourselves from the previous scope object
					if (null != oldScope)
						oldScope.IdentifierChanged -= new IdentifierChangedEventHandler(HandleIdentifierChange);

					//register for change events in this object
					scope.IdentifierChanged += new IdentifierChangedEventHandler(HandleIdentifierChange);
					//the scope property has changed so act like we fired the event
					HandleIdentifierChange(this, null);
				}
				else
					throw new ArgumentNullException();
			}
		}

		/// <summary>
		///    <para>Gets or sets the criteria to apply to events.</para>
		/// </summary>
		/// <value>
		///    <para> The criteria to apply to the events, which is equal to the event query.</para>
		/// </value>
		public EventQuery Query 
		{
			get { 
				return query; 
			} 
			set { 
				if (null != value)
				{
					ManagementQuery oldQuery = query;
					query = (EventQuery)value.Clone ();

					// Unregister ourselves from the previous query object
					if (null != oldQuery)
						oldQuery.IdentifierChanged -= new IdentifierChangedEventHandler(HandleIdentifierChange);

					//register for change events in this object
					query.IdentifierChanged += new IdentifierChangedEventHandler(HandleIdentifierChange);
					//the query property has changed so act like we fired the event
					HandleIdentifierChange(this, null);
				}
				else
					throw new ArgumentNullException();
			}
		}

		/// <summary>
		///    <para>Gets or sets the options used to watch for events.</para>
		/// </summary>
		/// <value>
		///    <para>The options used to watch for events.</para>
		/// </value>
		public EventWatcherOptions Options 
		{ 
			get { 
				return options; 
			} 
			set { 
				if (null != value)
				{
					EventWatcherOptions oldOptions = options;
					options = (EventWatcherOptions)value.Clone ();

					// Unregister ourselves from the previous scope object
					if (null != oldOptions)
						oldOptions.IdentifierChanged -= new IdentifierChangedEventHandler(HandleIdentifierChange);

					cachedObjects = new IWbemClassObjectFreeThreaded[options.BlockSize];
					//register for change events in this object
					options.IdentifierChanged += new IdentifierChangedEventHandler(HandleIdentifierChange);
					//the options property has changed so act like we fired the event
					HandleIdentifierChange(this, null);
				}
				else
					throw new ArgumentNullException();
			} 
		}

		/// <summary>
		///    <para>Waits for the next event that matches the specified query to arrive, and
		///       then returns it.</para>
		/// </summary>
		/// <returns>
		/// <para>A <see cref='System.Management.ManagementBaseObject'/> representing the 
		///    newly arrived event.</para>
		/// </returns>
		/// <remarks>
		///    <para>If the event watcher object contains options with
		///       a specified timeout, the API will wait for the next event only for the specified
		///       amount of time; otherwise, the API will be blocked until the next event occurs.</para>
		/// </remarks>
		public ManagementBaseObject WaitForNextEvent()
		{
			ManagementBaseObject obj = null;

			Initialize ();
			
			lock(this)
			{
				SecurityHandler securityHandler = Scope.GetSecurityHandler();

				int status = (int)ManagementStatus.NoError;

				try 
				{
					if (null == enumWbem)	//don't have an enumerator yet - get it
					{
						//Execute the query 
						status = Scope.GetIWbemServices().ExecNotificationQuery_(
							query.QueryLanguage,
							query.QueryString, 
							options.Flags,
							options.GetContext (),
							out enumWbem);
			
						//Set security on enumerator 
						if (status >= 0)
							securityHandler.Secure(enumWbem);
					}

					if (status >= 0)
					{
						if ((cachedCount - cacheIndex) == 0) //cache is empty - need to get more objects
						{
	#if true
							//Because Interop doesn't support custom marshalling for arrays, we have to use
							//the "DoNotMarshal" objects in the interop and then convert to the "FreeThreaded"
							//counterparts afterwards.
							IWbemClassObject_DoNotMarshal[] tempArray = new IWbemClassObject_DoNotMarshal[options.BlockSize];

							int timeout = (ManagementOptions.InfiniteTimeout == options.Timeout)
								? (int) tag_WBEM_TIMEOUT_TYPE.WBEM_INFINITE :
								(int) options.Timeout.TotalMilliseconds;
							
							status = enumWbem.Next_(timeout, (uint)options.BlockSize, 
													tempArray, out cachedCount);
							cacheIndex = 0;

							if (status >= 0)
							{
								//Convert results and put them in cache. Note that we may have timed out
								//in which case we might not have all the objects. If no object can be returned
								//we throw a timeout exception... - TODO: what should happen if there was a timeout
								//but at least some objects were returned ??
								if (cachedCount == 0)
									ManagementException.ThrowWithExtendedInfo(ManagementStatus.Timedout);

								for (int i = 0; i < cachedCount; i++)
									cachedObjects[i] = new IWbemClassObjectFreeThreaded(Marshal.GetIUnknownForObject(tempArray[i]));
							}

	#else
							//This was workaround when using TLBIMP we couldn't pass in arrays...

							IWbemClassObjectFreeThreaded cachedObject = cachedObjects[0];
							int timeout = (ManagementOptions.InfiniteTimeout == options.Timeout)
								? (int) tag_WBEM_TIMEOUT_TYPE.WBEM_INFINITE :
								(int) options.Timeout.TotalMilliseconds;
							status = enumWbem.Next_ (timeout, 1, out cachedObjects, out cachedCount);

							cacheIndex = 0;

							if (status >= 0)
							{
								//Create ManagementObject for result. Note that we may have timed out
								//in which case we won't have an object
								if (null == cachedObject)
									ManagementException.ThrowWithExtendedInfo(ManagementStatus.Timedout);

								cachedObjects[0] = cachedObject;
							}
	#endif
						}

						if (status >= 0)
						{
							obj = new ManagementBaseObject(cachedObjects[cacheIndex]);
							cacheIndex++;
						}
					}
				} 
				finally 
				{
					securityHandler.Reset();
				}

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}
			}

			return obj;
		}


		//********************************************
		//Start
		//********************************************
		/// <summary>
		///    <para>Subscribes to events with the given query and delivers 
		///       them, asynchronously, through the <see cref='System.Management.ManagementEventWatcher.EventArrived'/> event.</para>
		/// </summary>
		public void Start()
		{
			Initialize ();

			// Cancel any current event query
			Stop ();
			
			// Submit a new query
			SecurityHandler securityHandler = Scope.GetSecurityHandler();
			IWbemServices wbemServices = scope.GetIWbemServices();

			try
			{
				sink = new SinkForEventQuery(this, options.Context, wbemServices);

				// For async event queries we should ensure 0 flags as this is
				// the only legal value
				int status = wbemServices.ExecNotificationQueryAsync_(
					query.QueryLanguage,
					query.QueryString,
					0,
					options.GetContext(),
					sink.Stub);

				if (status < 0)
				{
					if (sink != null)
					{
						sink.ReleaseStub();
						sink = null;
					}

					if ((status & 0xfffff000) == 0x80041000)

						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}
			}
			finally
			{
				securityHandler.Reset();
			}
		}
		
		//********************************************
		//Stop
		//********************************************
		/// <summary>
		///    <para>Cancels the subscription whether it is synchronous or asynchronous.</para>
		/// </summary>
		public void Stop()
		{
			//For semi-synchronous, release the WMI enumerator to cancel the subscription
			if (null != enumWbem)
			{
				Marshal.ReleaseComObject(enumWbem);
				enumWbem = null;
				FireStopped (new StoppedEventArgs (options.Context, (int)ManagementStatus.OperationCanceled));
			}

			// In async mode cancel the call to the sink - this will
			// unwind the operation and cause a Stopped message
			if (null != sink)
			{
				sink.Cancel ();
				sink = null;
			}
		}

		private void Initialize ()
		{
			//If the query is not set yet we can't do it
			if (null == query)
				throw new InvalidOperationException();

			if (null == options)
				Options = new EventWatcherOptions ();

			//If we're not connected yet, this is the time to do it...
			lock (this)
			{
				if (null == scope)
					Scope = new ManagementScope ();

				if (null == cachedObjects)
					cachedObjects = new IWbemClassObjectFreeThreaded[options.BlockSize];
			}

			lock (scope)
			{
				scope.Initialize ();
			}
		}


		internal void FireStopped (StoppedEventArgs args)
		{
			try {
				delegateInvoker.FireEventToDelegates (Stopped, args);
			} catch {}
		}

		internal void FireEventArrived (EventArrivedEventArgs args)
		{
			try {
				delegateInvoker.FireEventToDelegates (EventArrived, args);
			} catch {}
		}



	}

	internal class SinkForEventQuery : IWmiEventSource
	{
		private ManagementEventWatcher			eventWatcher;
		private object							context;
		private IWbemServices					services;
		private IWbemObjectSink	stub;			// The secured IWbemObjectSink

		public SinkForEventQuery (ManagementEventWatcher eventWatcher,
							 object context, 
							 IWbemServices services)
		{
			this.services = services;
			this.context = context;
			this.eventWatcher = eventWatcher;
            if(MTAHelper.IsNoContextMTA())  // Bug#110141 - Checking for MTA is not enough.  We need to make sure we are not in a COM+ Context
                HackToCreateStubInMTA(this);
            else
            {
				//
				// [marioh, RAID: 111108]
				// Ensure we are able to trap exceptions from worker thread.
				//
				ThreadDispatch disp = new ThreadDispatch ( new ThreadDispatch.ThreadWorkerMethodWithParam ( HackToCreateStubInMTA ) ) ;
				disp.Parameter = this ;
				disp.Start ( ) ;
//				Thread thread = new Thread(new ThreadStart(HackToCreateStubInMTA));
//                thread.ApartmentState = ApartmentState.MTA;
//                thread.Start();
//                thread.Join();
			}
		}

		void HackToCreateStubInMTA(object param)
		{
			SinkForEventQuery obj = (SinkForEventQuery) param ;
			IWmiSinkDemultiplexor sinkDmux = (IWmiSinkDemultiplexor) new WmiSinkDemultiplexor ();
			object dmuxStub = null;
			sinkDmux.GetDemultiplexedStub (obj, out dmuxStub);
			obj.stub = (IWbemObjectSink) dmuxStub;
		}

		internal IWbemObjectSink Stub { 
			get { return stub; }
		}

		public void Indicate(IntPtr pWbemClassObject)
		{
            Marshal.AddRef(pWbemClassObject);
            IWbemClassObjectFreeThreaded obj = new IWbemClassObjectFreeThreaded(pWbemClassObject);
			try

			{
				EventArrivedEventArgs args = new EventArrivedEventArgs(context, new ManagementBaseObject(obj));

				eventWatcher.FireEventArrived(args);
			}
			catch {}
		}
	
		public void SetStatus (
						int flags, 
						int hResult, 
						String message, 
						IntPtr pErrObj)
		{
#if TODO_ERROBJ_NEVER_USED
            IWbemClassObjectFreeThreaded errObj = null;
            if(pErrObj != IntPtr.Zero)
            {
                Marshal.AddRef(pErrObj);
                errObj = new IWbemClassObjectFreeThreaded(pErrObj);
            }
#endif // TODO_ERROBJ_NEVER_USED

			try 
			{


				// Fire Stopped event
				eventWatcher.FireStopped(new StoppedEventArgs(context, hResult));

				//This handles cases in which WMI calls SetStatus to indicate a problem, for example
				//a queue overflow due to slow client processing.
				//Currently we just cancel the subscription in this case.
                // BUG# 97657 - When you cancel a call with CancelAsyncCall, on Windows 2000,
                // you get a SetStatus with WBEM_E_CALL_CANCELLED.  On Windows XP, you get
                // a set status with WBEM_S_OPERATION_CANCELLED!!!
				if (    hResult != (int)tag_WBEMSTATUS.WBEM_E_CALL_CANCELLED
                     && hResult != (int)tag_WBEMSTATUS.WBEM_S_OPERATION_CANCELLED)
					ThreadPool.QueueUserWorkItem(new WaitCallback(Cancel2));// Cancel(); // BUG#118550 - On Win2k, we get a deadlock if we do a Cancel within a SetStatus
			}
			catch {}
		}

        // BUG#118550 - On Win2k, we get a deadlock if we do a Cancel within a SetStatus
        // Instead of calling it from SetStatus, we use ThreadPoo.QueueUserWorkItem
		void Cancel2(object o)
		{
			//
			// Try catch the call to cancel. In this case the cancel is being done without the client
			// knowing about it so catching all exceptions is not a bad thing to do. If a client calls
			// Stop (which calls Cancel), they will still recieve any exceptions that may have occured.
			//
			try
			{
				Cancel();
			}
			catch
			{
			}
		}

		internal void Cancel () 
		{
			if (null != stub)
			{
				lock(this)
				{
					if (null != stub)
					{
						int status = services.CancelAsyncCall_(stub);

						// Release prior to throwing an exception.
						ReleaseStub();

						if (status < 0)
						{
							if ((status & 0xfffff000) == 0x80041000)
								ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
							else
								Marshal.ThrowExceptionForHR(status);
						}
					}
				}
			}
		}

		internal void ReleaseStub ()
		{
			if (null != stub)
			{
				lock(this)
				{
					/*
					 * We force a release of the stub here so as to allow
					 * unsecapp.exe to die as soon as possible.
					 */
					if (null != stub)
					{
						try 
						{
							System.Runtime.InteropServices.Marshal.ReleaseComObject(stub);
							stub = null;
						} 
						catch {}
					}
				}
			}
		}
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\managementexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using WbemClient_v1;
using System.Security.Permissions;

namespace System.Management
{

	/// <summary>
	///    <para>Represents the enumeration of all WMI error codes that are currently defined.</para>
	/// </summary>
	public enum ManagementStatus
	{
		/// <summary>
		///    The operation was successful.
		/// </summary>
		NoError							= 0,
		/// <summary>
		///    <para> This value is returned when no more objects 
		///       are available, the number of objects returned is less than the number requested,
		///       or at the end of an enumeration. It is also returned when the method is called
		///       with a value of 0 for the <paramref name="uCount"/> parameter.</para>
		/// </summary>
		False							= 1,
		/// <summary>
		///    <para>An overridden property was deleted. This value is
		///       returned to signal that the original, non-overridden value has been restored as a
		///       result of the deletion.</para>
		/// </summary>
		ResetToDefault					= 0x40002,
		/// <summary>
		///    <para> The compared items (such as objects and classes)
		///       are not identical.</para>
		/// </summary>
		Different		                = 0x40003,
		/// <summary>
		///    <para> A call timed out. This is not an
		///       error condition; therefore, some results may have been returned.</para>
		/// </summary>
		Timedout						= 0x40004,
		/// <summary>
		///    <para> No more data is available from the enumeration; the 
		///       user should terminate the enumeration. </para>
		/// </summary>
		NoMoreData						= 0x40005,
		/// <summary>
		///    <para> The operation was
		///       canceled.</para>
		/// </summary>
		OperationCanceled				= 0x40006,
		/// <summary>
		///    <para>A request is still in progress; however, the results are not
		///       yet available.</para>
		/// </summary>
		Pending			                = 0x40007,
		/// <summary>
		///    <para> More than one copy of the same object was detected in 
		///       the result set of an enumeration. </para>
		/// </summary>
		DuplicateObjects				= 0x40008,
		/// <summary>
		///    <para>The user did not receive all of the requested objects
		///       because of inaccessible resources (other than security violations).</para>
		/// </summary>
		PartialResults					= 0x40010,
		/// <summary>
		///    <para>The call failed.</para>
		/// </summary>
		Failed                          = unchecked((int)0x80041001),
		/// <summary>
		///    <para> The object could not be found. </para>
		/// </summary>
		NotFound                        = unchecked((int)0x80041002),
		/// <summary>
		///    The current user does not have permission to perform the
		///    action.
		/// </summary>
		AccessDenied                    = unchecked((int)0x80041003),
		/// <summary>
		///    <para> The provider failed after 
		///       initialization. </para>
		/// </summary>
		ProviderFailure                 = unchecked((int)0x80041004),
		/// <summary>
		///    A type mismatch occurred.
		/// </summary>
		TypeMismatch                    = unchecked((int)0x80041005),
		/// <summary>
		///    There was not enough memory for the operation.
		/// </summary>
		OutOfMemory                     = unchecked((int)0x80041006),
		/// <summary>
		///    <para>The context object is not valid.</para>
		/// </summary>
		InvalidContext                  = unchecked((int)0x80041007),
		/// <summary>
		///    <para> One of the parameters to the call is not correct. 
		///    </para>
		/// </summary>
		InvalidParameter                = unchecked((int)0x80041008),
		/// <summary>
		///    <para> The resource, typically a remote server, is not 
		///       currently available. </para>
		/// </summary>
		NotAvailable                    = unchecked((int)0x80041009),
		/// <summary>
		///    <para>An internal, critical, and unexpected error occurred. 
		///       Report this error to Microsoft Technical Support.</para>
		/// </summary>
		CriticalError                   = unchecked((int)0x8004100A),
		/// <summary>
		///    <para>One or more network packets were corrupted during a remote session.</para>
		/// </summary>
		InvalidStream                   = unchecked((int)0x8004100B),
		/// <summary>
		///    <para> The feature or operation is not supported. </para>
		/// </summary>
		NotSupported                    = unchecked((int)0x8004100C),
		/// <summary>
		///    The specified superclass is not valid.
		/// </summary>
		InvalidSuperclass               = unchecked((int)0x8004100D),
		/// <summary>
		///    <para> The specified namespace could not be found. </para>
		/// </summary>
		InvalidNamespace                = unchecked((int)0x8004100E),
		/// <summary>
		///    The specified instance is not valid.
		/// </summary>
		InvalidObject                   = unchecked((int)0x8004100F),
		/// <summary>
		///    The specified class is not valid.
		/// </summary>
		InvalidClass                    = unchecked((int)0x80041010),
		/// <summary>
		///    A provider referenced in the schema does not have a
		///    corresponding registration.
		/// </summary>
		ProviderNotFound				= unchecked((int)0x80041011),
		/// <summary>
		///    A provider referenced in the schema has an incorrect or
		///    incomplete registration.
		/// </summary>
		InvalidProviderRegistration		= unchecked((int)0x80041012),
		/// <summary>
		///    COM cannot locate a provider referenced in the schema.
		/// </summary>
		ProviderLoadFailure				= unchecked((int)0x80041013),
		/// <summary>
		///  A component, such as a provider, failed to initialize for internal reasons. 
		/// </summary>
		InitializationFailure           = unchecked((int)0x80041014),
		/// <summary>
		///    A networking error that prevents normal operation has
		///    occurred.
		/// </summary>
		TransportFailure                = unchecked((int)0x80041015),
		/// <summary>
		///    <para> The requested operation is not valid. This error usually 
		///       applies to invalid attempts to delete classes or properties. </para>
		/// </summary>
		InvalidOperation                = unchecked((int)0x80041016),
		/// <summary>
		///    The query was not syntactically valid.
		/// </summary>
		InvalidQuery                    = unchecked((int)0x80041017),
		/// <summary>
		///    <para>The requested query language is not supported.</para>
		/// </summary>
		InvalidQueryType				= unchecked((int)0x80041018),
		/// <summary>
		/// <para>In a put operation, the <see langword='wbemChangeFlagCreateOnly'/>
		/// flag was specified, but the instance already exists.</para>
		/// </summary>
		AlreadyExists                   = unchecked((int)0x80041019),
		/// <summary>
		///    <para>The add operation cannot be performed on the qualifier 
		///       because the owning object does not permit overrides.</para>
		/// </summary>
		OverrideNotAllowed				= unchecked((int)0x8004101A),
		/// <summary>
		///    <para> The user attempted to delete a qualifier that was not 
		///       owned. The qualifier was inherited from a parent class. </para>
		/// </summary>
		PropagatedQualifier             = unchecked((int)0x8004101B),
		/// <summary>
		///    <para> The user attempted to delete a property that was not 
		///       owned. The property was inherited from a parent class. </para>
		/// </summary>
		PropagatedProperty              = unchecked((int)0x8004101C),
		/// <summary>
		///    The client made an unexpected and illegal sequence of
		///    calls.
		/// </summary>
		Unexpected                      = unchecked((int)0x8004101D),
		/// <summary>
		///    <para>The user requested an illegal operation, such as 
		///       spawning a class from an instance.</para>
		/// </summary>
		IllegalOperation                = unchecked((int)0x8004101E),
		/// <summary>
		///    <para> There was an illegal attempt to specify a key qualifier 
		///       on a property that cannot be a key. The keys are specified in the class
		///       definition for an object and cannot be altered on a per-instance basis.</para>
		/// </summary>
		CannotBeKey						= unchecked((int)0x8004101F),
		/// <summary>
		///    <para>The current object is not a valid class definition.
		///       Either it is incomplete, or it has not been registered with WMI using
		///    <see cref='System.Management.ManagementObject.Put'/>().</para>
		/// </summary>
		IncompleteClass                 = unchecked((int)0x80041020),
		/// <summary>
		///    Reserved for future use.
		/// </summary>
		InvalidSyntax                   = unchecked((int)0x80041021),
		/// <summary>
		///    Reserved for future use.
		/// </summary>
		NondecoratedObject              = unchecked((int)0x80041022),
		/// <summary>
		///    <para>The property that you are attempting to modify is read-only.</para>
		/// </summary>
		ReadOnly                        = unchecked((int)0x80041023),
		/// <summary>
		///    <para> The provider cannot perform the requested operation, such 
		///       as requesting a query that is too complex, retrieving an instance, creating or
		///       updating a class, deleting a class, or enumerating a class. </para>
		/// </summary>
		ProviderNotCapable				= unchecked((int)0x80041024),
		/// <summary>
		///    <para>An attempt was made to make a change that would
		///       invalidate a derived class.</para>
		/// </summary>
		ClassHasChildren				= unchecked((int)0x80041025),
		/// <summary>
		///    <para> An attempt has been made to delete or modify a class that 
		///       has instances. </para>
		/// </summary>
		ClassHasInstances				= unchecked((int)0x80041026),
		/// <summary>
		///    Reserved for future use.
		/// </summary>
		QueryNotImplemented				= unchecked((int)0x80041027),
		/// <summary>
		///    <para> A value of null was specified for a property that may
		///       not be null, such as one that is marked by a <see langword='Key'/>, <see langword='Indexed'/>, or
		///    <see langword='Not_Null'/> qualifier.</para>
		/// </summary>
		IllegalNull                     = unchecked((int)0x80041028),
		/// <summary>
		///    <para> The value provided for a qualifier was not a 
		///       legal qualifier type.</para>
		/// </summary>
		InvalidQualifierType			= unchecked((int)0x80041029),
		/// <summary>
		///    The CIM type specified for a property is not valid.
		/// </summary>
		InvalidPropertyType				= unchecked((int)0x8004102A),
		/// <summary>
		///    <para> The request was made with an out-of-range value, or is 
		///       incompatible with the type. </para>
		/// </summary>
		ValueOutOfRange					= unchecked((int)0x8004102B),
		/// <summary>
		///    <para>An illegal attempt was made to make a class singleton, 
		///       such as when the class is derived from a non-singleton class.</para>
		/// </summary>
		CannotBeSingleton				= unchecked((int)0x8004102C),
		/// <summary>
		///    The CIM type specified is not valid.
		/// </summary>
		InvalidCimType					= unchecked((int)0x8004102D),
		/// <summary>
		///    The requested method is not available.
		/// </summary>
		InvalidMethod                   = unchecked((int)0x8004102E),
		/// <summary>
		///    <para> The parameters provided for the method are not valid. 
		///    </para>
		/// </summary>
		InvalidMethodParameters			= unchecked((int)0x8004102F),
		/// <summary>
		///    There was an attempt to get qualifiers on a system
		///    property.
		/// </summary>
		SystemProperty                  = unchecked((int)0x80041030),
		/// <summary>
		///    The property type is not recognized.
		/// </summary>
		InvalidProperty                 = unchecked((int)0x80041031),
		/// <summary>
		///    <para> An asynchronous process has been canceled internally or 
		///       by the user. Note that because of the timing and nature of the asynchronous
		///       operation, the operation may not have been truly canceled. </para>
		/// </summary>
		CallCanceled                   = unchecked((int)0x80041032),
		/// <summary>
		///    <para>The user has requested an operation while WMI is in the 
		///       process of quitting.</para>
		/// </summary>
		ShuttingDown                    = unchecked((int)0x80041033),
		/// <summary>
		///    <para> An attempt was made to reuse an existing method name from 
		///       a superclass, and the signatures did not match. </para>
		/// </summary>
		PropagatedMethod                = unchecked((int)0x80041034),
		/// <summary>
		///    <para> One or more parameter values, such as a query text, is 
		///       too complex or unsupported. WMI is requested to retry the operation
		///       with simpler parameters. </para>
		/// </summary>
		UnsupportedParameter            = unchecked((int)0x80041035),
		/// <summary>
		///    A parameter was missing from the method call.
		/// </summary>
		MissingParameterID		        = unchecked((int)0x80041036),
		/// <summary>
		///    A method parameter has an invalid <see langword='ID'/> qualifier.
		/// </summary>
		InvalidParameterID				= unchecked((int)0x80041037),
		/// <summary>
		/// <para> One or more of the method parameters have <see langword='ID'/> 
		/// qualifiers that are out of sequence. </para>
		/// </summary>
		NonconsecutiveParameterIDs		= unchecked((int)0x80041038),
		/// <summary>
		/// <para> The return value for a method has an <see langword='ID'/> qualifier. 
		/// </para>
		/// </summary>
		ParameterIDOnRetval				= unchecked((int)0x80041039),
		/// <summary>
		///    The specified object path was invalid.
		/// </summary>
		InvalidObjectPath				= unchecked((int)0x8004103A),
		/// <summary>
		///    <para> There is not enough free disk space to continue the 
		///       operation. </para>
		/// </summary>
		OutOfDiskSpace					= unchecked((int)0x8004103B),
		/// <summary>
		///    <para> The supplied buffer was too small to hold all the objects 
		///       in the enumerator or to read a string property. </para>
		/// </summary>
		BufferTooSmall					= unchecked((int)0x8004103C),
		/// <summary>
		///    The provider does not support the requested put
		///    operation.
		/// </summary>
		UnsupportedPutExtension			= unchecked((int)0x8004103D),
		/// <summary>
		///    <para> An object with an incorrect type or version was 
		///       encountered during marshaling. </para>
		/// </summary>
		UnknownObjectType				= unchecked((int)0x8004103E),
		/// <summary>
		///    <para> A packet with an incorrect type or version was 
		///       encountered during marshaling. </para>
		/// </summary>
		UnknownPacketType				= unchecked((int)0x8004103F),
		/// <summary>
		///    The packet has an unsupported version.
		/// </summary>
		MarshalVersionMismatch			= unchecked((int)0x80041040),
		/// <summary>
		///    <para>The packet is corrupted.</para>
		/// </summary>
		MarshalInvalidSignature			= unchecked((int)0x80041041),
		/// <summary>
		///    An attempt has been made to mismatch qualifiers, such as
		///    putting [key] on an object instead of a property.
		/// </summary>
		InvalidQualifier				= unchecked((int)0x80041042),
		/// <summary>
		///    A duplicate parameter has been declared in a CIM method.
		/// </summary>
		InvalidDuplicateParameter		= unchecked((int)0x80041043),
		/// <summary>
		///    <para> Reserved for future use. </para>
		/// </summary>
		TooMuchData						= unchecked((int)0x80041044),
		/// <summary>
		///    <para>The delivery of an event has failed. The provider may 
		///       choose to re-raise the event.</para>
		/// </summary>
		ServerTooBusy					= unchecked((int)0x80041045),
		/// <summary>
		///    The specified flavor was invalid.
		/// </summary>
		InvalidFlavor					= unchecked((int)0x80041046),
		/// <summary>
		///    <para> An attempt has been made to create a reference that is 
		///       circular (for example, deriving a class from itself). </para>
		/// </summary>
		CircularReference				= unchecked((int)0x80041047),
		/// <summary>
		///    The specified class is not supported.
		/// </summary>
		UnsupportedClassUpdate			= unchecked((int)0x80041048),
		/// <summary>
		///    <para> An attempt was made to change a key when instances or derived 
		///       classes are already using the key. </para>
		/// </summary>
		CannotChangeKeyInheritance		= unchecked((int)0x80041049),
		/// <summary>
		///    <para> An attempt was made to change an index when instances or derived 
		///       classes are already using the index. </para>
		/// </summary>
		CannotChangeIndexInheritance	= unchecked((int)0x80041050),
		/// <summary>
		///    <para> An attempt was made to create more properties than the 
		///       current version of the class supports. </para>
		/// </summary>
		TooManyProperties				= unchecked((int)0x80041051),
		/// <summary>
		///    <para> A property was redefined with a conflicting type in a 
		///       derived class. </para>
		/// </summary>
		UpdateTypeMismatch				= unchecked((int)0x80041052),
		/// <summary>
		///    <para> An attempt was made in a derived class to override a 
		///       non-overrideable qualifier. </para>
		/// </summary>
		UpdateOverrideNotAllowed		= unchecked((int)0x80041053),
		/// <summary>
		///    <para> A method was redeclared with a conflicting signature in a 
		///       derived class. </para>
		/// </summary>
		UpdatePropagatedMethod			= unchecked((int)0x80041054),
		/// <summary>
		///    An attempt was made to execute a method not marked with
		///    [implemented] in any relevant class.
		/// </summary>
		MethodNotImplemented			= unchecked((int)0x80041055),
		/// <summary>
		///    <para> An attempt was made to execute a method marked with 
		///       [disabled]. </para>
		/// </summary>
		MethodDisabled      			= unchecked((int)0x80041056),
		/// <summary>
		///    <para> The refresher is busy with another operation. </para>
		/// </summary>
		RefresherBusy					= unchecked((int)0x80041057),
		/// <summary>
		///    <para> The filtering query is syntactically invalid. </para>
		/// </summary>
		UnparsableQuery                 = unchecked((int)0x80041058),
		/// <summary>
		///    The FROM clause of a filtering query references a class
		///    that is not an event class.
		/// </summary>
		NotEventClass					= unchecked((int)0x80041059),
		/// <summary>
		///    A GROUP BY clause was used without the corresponding
		///    GROUP WITHIN clause.
		/// </summary>
		MissingGroupWithin				= unchecked((int)0x8004105A),
		/// <summary>
		///    A GROUP BY clause was used. Aggregation on all properties
		///    is not supported.
		/// </summary>
		MissingAggregationList			= unchecked((int)0x8004105B),
		/// <summary>
		///    <para> Dot notation was used on a property that is not an 
		///       embedded object. </para>
		/// </summary>
		PropertyNotAnObject				= unchecked((int)0x8004105C),
		/// <summary>
		///    A GROUP BY clause references a property that is an
		///    embedded object without using dot notation.
		/// </summary>
		AggregatingByObject				= unchecked((int)0x8004105D),
		/// <summary>
		///    An event provider registration query
		///    (<see langword='__EventProviderRegistration'/>) did not specify the classes for which
		///    events were provided.
		/// </summary>
		UninterpretableProviderQuery	= unchecked((int)0x8004105F),
		/// <summary>
		///    <para> An request was made to back up or restore the repository 
		///       while WinMgmt.exe was using it. </para>
		/// </summary>
		BackupRestoreWinmgmtRunning		= unchecked((int)0x80041060),
		/// <summary>
		///    <para> The asynchronous delivery queue overflowed from the 
		///       event consumer being too slow. </para>
		/// </summary>
		QueueOverflow                   = unchecked((int)0x80041061),
		/// <summary>
		///    The operation failed because the client did not have the
		///    necessary security privilege.
		/// </summary>
		PrivilegeNotHeld				= unchecked((int)0x80041062),
		/// <summary>
		///    <para>The operator is not valid for this property type.</para>
		/// </summary>
		InvalidOperator                 = unchecked((int)0x80041063),
		/// <summary>
		///    <para> The user specified a username, password, or authority on a 
		///       local connection. The user must use an empty user name and password and rely on
		///       default security. </para>
		/// </summary>
		LocalCredentials                = unchecked((int)0x80041064),
		/// <summary>
		///    <para> The class was made abstract when its superclass is not 
		///       abstract. </para>
		/// </summary>
		CannotBeAbstract				= unchecked((int)0x80041065),
		/// <summary>
		///    <para> An amended object was used in a put operation without the 
		///       WBEM_FLAG_USE_AMENDED_QUALIFIERS flag being specified. </para>
		/// </summary>
		AmendedObject					= unchecked((int)0x80041066),
		/// <summary>
		///    The client was not retrieving objects quickly enough from
		///    an enumeration.
		/// </summary>
		ClientTooSlow					= unchecked((int)0x80041067),

		/// <summary>
		///    <para> The provider registration overlaps with the system event 
		///       domain. </para>
		/// </summary>
		RegistrationTooBroad			= unchecked((int)0x80042001),
		/// <summary>
		///    <para> A WITHIN clause was not used in this query. </para>
		/// </summary>
		RegistrationTooPrecise			= unchecked((int)0x80042002)
	}

	/// <summary>
	///    <para> Represents management exceptions.</para>
	/// </summary>
	/// <example>
	///    <code lang='C#'>using System;
	/// using System.Management;
	/// 
	/// // This sample demonstrates how to display error
	/// // information stored in a ManagementException object.
	/// class Sample_ManagementException
	/// {
	///     public static int Main(string[] args)
	///     {
	///         try
	///         {
	///             ManagementObject disk =
	///                 new ManagementObject("Win32_LogicalDisk.DeviceID='BAD:'");
	///             disk.Get(); // throws ManagementException
	///             Console.WriteLine("This shouldn't be displayed.");
	///         }
	///         catch (ManagementException e)
	///         {
	///           Console.WriteLine("ErrorCode " + e.ErrorCode);
	///           Console.WriteLine("Message " + e.Message);
	///           Console.WriteLine("Source " + e.Source);
	///           if (e.ErrorInformation) //extended error object
	///               Console.WriteLine("Extended Description : " + e.ErrorInformation["Description"]);
	///         }
	///         return 0;
	///     }
	/// }
	///    </code>
	///    <code lang='VB'>Imports System
	/// Imports System.Management
	/// 
	/// ' This sample demonstrates how to display error
	/// ' information stored in a ManagementException object.
	/// Class Sample_ManagementException
	///     Overloads Public Shared Function Main(args() As String) As Integer
	///         Try
	///             Dim disk As New ManagementObject("Win32_LogicalDisk.DeviceID='BAD:'")
	///             disk.Get() ' throws ManagementException
	///             Console.WriteLine("This shouldn't be displayed.")
	///         Catch e As ManagementException
	///             Console.WriteLine("ErrorCode " &amp; e.ErrorCode)
	///             Console.WriteLine("Message " &amp; e.Message)
	///             Console.WriteLine("Source " &amp; e.Source)
	///             If e.ErrorInformation != Nothing Then 'extended error object
	///                 Console.WriteLine("Extended Description : " &amp; e.ErrorInformation("Description"))
	///             End If
	///         End Try
	///         Return 0
	///     End Function
	/// End Class
	///    </code>
	/// </example>
    [Serializable]
	public class ManagementException : SystemException 
	{
		private ManagementBaseObject	errorObject = null;
		private ManagementStatus		errorCode = 0;

		internal static void ThrowWithExtendedInfo(ManagementStatus errorCode)
		{
			ManagementBaseObject errObj = null;
			string msg = null;

			//Try to get extended error info first, and save in errorObject member
			IWbemClassObjectFreeThreaded obj = WbemErrorInfo.GetErrorInfo();
			if (obj != null)
				errObj = new ManagementBaseObject(obj);

			//If the error code is not a WMI one and there's an extended error object available, stick the message
			//from the extended error object in.
			if (((msg = GetMessage(errorCode)) == null) && (errObj != null))
				try 
				{
					msg = (string)errObj["Description"];
				} 
				catch {}

			throw new ManagementException(errorCode, msg, errObj);
		}
		

		internal static void ThrowWithExtendedInfo(Exception e)
		{
			ManagementBaseObject errObj = null;
			string msg = null;

			//Try to get extended error info first, and save in errorObject member
			IWbemClassObjectFreeThreaded obj = WbemErrorInfo.GetErrorInfo();
			if (obj != null)
				errObj = new ManagementBaseObject(obj);

			//If the error code is not a WMI one and there's an extended error object available, stick the message
			//from the extended error object in.
			if (((msg = GetMessage(e)) == null) && (errObj != null))
				try 
				{
					msg = (string)errObj["Description"];
				} 
				catch {}

			throw new ManagementException(e, msg, errObj);
		}


		internal ManagementException(ManagementStatus errorCode, string msg, ManagementBaseObject errObj) : base (msg)
		{
			this.errorCode = errorCode;
			this.errorObject = errObj;
		}
	
		internal ManagementException(Exception e, string msg, ManagementBaseObject errObj) : base (msg, e)
		{
			try 
			{
				if (e is ManagementException)
				{
					errorCode = ((ManagementException)e).ErrorCode;

					// May/may not have extended error info.
					//
					if (errorObject != null)
						errorObject = (ManagementBaseObject)((ManagementException)e).errorObject.Clone();
					else
						errorObject = null;
				}
				else if (e is COMException)
					errorCode = (ManagementStatus)((COMException)e).ErrorCode;
				else
					errorCode = (ManagementStatus)this.HResult;
			}
			catch {}
		}

        /// <summary>
        /// <para>Initializes a new instance of the <see cref='System.Management.ManagementException'/> class that is serializable.</para>
        /// </summary>
        /// <param name='info'>The <see cref='System.Runtime.Serialization.SerializationInfo'/> to populate with data.</param>
	/// <param name='context'>The destination (see <see cref='System.Runtime.Serialization.StreamingContext'/> ) for this serialization.</param>
        protected ManagementException(SerializationInfo info, StreamingContext context) : base(info, context)
        {
            errorCode = (ManagementStatus)info.GetValue("errorCode", typeof(ManagementStatus));
            errorObject = info.GetValue("errorObject", typeof(ManagementBaseObject)) as ManagementBaseObject;
        }
		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.ManagementException'/> class</para>
		/// </summary>
		public ManagementException():this(ManagementStatus.Failed, "", null)
		{
			 
		}

		
		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.ManagementException'/> 
		/// class with a specified error message.</para>
		/// <param name='message'>The message that describes the error.</param>
		/// </summary>
		public ManagementException(string message):this(ManagementStatus.Failed, message, null)
		{
			
		}

		/// <summary>
		/// <para>Initializes a empty new instance of the <see cref='System.Management.ManagementException'/> class </para>
		/// <param name='message'>The message that describes the error.</param>
		/// <param name='info'>The exception that is the cause of the current exception. If the innerException 
		/// parameter is not a null reference (Nothing in Visual Basic), the current exception is raised in a catch 
		/// block that handles the inner exception.</param>
		/// </summary>
		public ManagementException(string message,Exception innerException):this(innerException, message, null)
		{	
			// if the exception passed is not a ManagementException, then initialize the ErrorCode to Failed
			if (!(innerException is ManagementException))
				errorCode = ManagementStatus.Failed;
		}

        /// <summary>
        /// <para>Populates the <see cref='System.Runtime.Serialization.SerializationInfo'/> object with the data needed to 
        ///    serialize the <see cref='System.Management.ManagementException'/>
        ///    object.</para>
        /// </summary>
        /// <param name='info'>The <see cref='System.Runtime.Serialization.SerializationInfo'/> to populate with data.</param>
	/// <param name='context'>The destination (see <see cref='System.Runtime.Serialization.StreamingContext'/> ) for this serialization.</param>
 
		//FXCop requests explicit demand of the SerializationFormatter permission
		[SecurityPermission(SecurityAction.Demand, SerializationFormatter=true)]
		public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            base.GetObjectData(info, context);
            info.AddValue("errorCode", errorCode);
            info.AddValue("errorObject", errorObject);
        }

		private static string GetMessage(Exception e)
		{
			string msg = null;

			if (e is COMException)
			{
				// Try and get WMI error message. If not use the one in 
				// the exception
				msg = GetMessage ((ManagementStatus)((COMException)e).ErrorCode);
			}

			if (null == msg)
				msg = e.Message;

			return msg;
		}

		private static string GetMessage(ManagementStatus errorCode)
		{
			string msg = null;
			IWbemStatusCodeText statusCode = null;
			int hr;

			statusCode = (IWbemStatusCodeText) new WbemStatusCodeText();
			if (statusCode != null)
			{
				try {
					hr = statusCode.GetErrorCodeText_((int)errorCode, 0, 1, out msg);

					// Just in case it didn't like the flag=1, try it again
					// with flag=0.
					if (hr != 0)
						hr = statusCode.GetErrorCodeText_((int)errorCode, 0, 0, out msg);
				}
				catch {}
			}

			return msg;
		}

		/// <summary>
		///    <para>Gets the extended error object provided by WMI.</para>
		/// </summary>
		/// <value>
		/// <para>A <see cref='System.Management.ManagementBaseObject'/> representing the 
		///    extended error object provided by WMI, if available; <see langword='null'/>
		///    otherwise.</para>
		/// </value>
		public ManagementBaseObject ErrorInformation 
		{
			get 
			{ return errorObject; }
		}

		/// <summary>
		///    <para>Gets the error code reported by WMI, which caused this exception.</para>
		/// </summary>
		/// <value>
		///    A <see cref='System.Management.ManagementStatus'/> value representing the error code returned by
		///    the WMI operation.
		/// </value>
		public ManagementStatus ErrorCode 
		{
			get 
			{ return errorCode; }
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\managementnamedvaluecollection.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Collections;
using System.Collections.Specialized;
using WbemClient_v1;
using System.Runtime.Serialization;

namespace System.Management 
{
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para> Represents a collection of named values
	///       suitable for use as context information to WMI operations. The
	///       names are case-insensitive.</para>
	/// </summary>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class ManagementNamedValueCollection : NameObjectCollectionBase 
	{
		// Notification of when the content of this collection changes
		internal event IdentifierChangedEventHandler IdentifierChanged;

		//Fires IdentifierChanged event
		private void FireIdentifierChanged()
		{
			if (IdentifierChanged != null)
				IdentifierChanged(this, null);
		}

		//default constructor
		/// <overload>
		///    Initializes a new instance
		///    of the <see cref='System.Management.ManagementNamedValueCollection'/> class.
		/// </overload>
		/// <summary>
		/// <para> Initializes a new instance of the <see cref='System.Management.ManagementNamedValueCollection'/> class, which is empty. This is 
		///    the default constructor.</para>
		/// </summary>
		public ManagementNamedValueCollection() 
		{
        }


        /// <summary>
        /// <para>Initializes a new instance of the <see cref='System.Management.ManagementNamedValueCollection'/> class that is serializable 
        ///    and uses the specified <see cref='System.Runtime.Serialization.SerializationInfo'/>
        ///    and <see cref='System.Runtime.Serialization.StreamingContext'/>.</para>
        /// </summary>
        /// <param name='info'>The <see cref='System.Runtime.Serialization.SerializationInfo'/> to populate with data.</param>
	/// <param name='context'>The destination (see <see cref='System.Runtime.Serialization.StreamingContext'/> ) for this serialization.</param>
        public ManagementNamedValueCollection(SerializationInfo info, StreamingContext context) : base(info, context)
        {
        }

		/// <summary>
		///    <para>Internal method to return an IWbemContext representation
		///    of the named value collection.</para>
		/// </summary>
		internal IWbemContext GetContext() 
		{
			IWbemContext wbemContext = null;

			// Only build a context if we have something to put in it
			if (0 < Count)
			{
				int status = (int)ManagementStatus.NoError;

				try {
					wbemContext = (IWbemContext) new WbemContext ();

					foreach (string name in this)
					{
						object val = base.BaseGet(name);
						status = wbemContext.SetValue_ (name, 0, ref val);
						if ((status & 0x80000000) != 0)
						{
							break;
						}
					}
				} catch {}	// BUGBUG : why ignore error?
			}
			
			return wbemContext;
		}

		/// <summary>
		///    <para> Adds a single-named value to the collection.</para>
		/// </summary>
		/// <param name=' name'>The name of the new value.</param>
		/// <param name=' value'>The value to be associated with the name.</param>
		public void Add (string name, object value) 
		{
			// Remove any old entry
			try 
			{
				base.BaseRemove (name);
			} catch {}

			base.BaseAdd (name, value);
			FireIdentifierChanged ();
		}

		/// <summary>
		///    <para> Removes a single-named value from the collection. 
		///       If the collection does not contain an element with the
		///       specified name, the collection remains unchanged and no
		///       exception is thrown.</para>
		/// </summary>
		/// <param name=' name'>The name of the value to be removed.</param>
		public void Remove (string name)
		{
			base.BaseRemove (name);
			FireIdentifierChanged ();
		}

		/// <summary>
		///    <para>Removes all entries from the collection.</para>
		/// </summary>
		public void RemoveAll () 
		{
			base.BaseClear ();
			FireIdentifierChanged ();
		}

		/// <summary>
		///    <para>Creates a clone of the collection. Individual values 
		///       are cloned. If a value does not support cloning, then a <see cref='System.NotSupportedException'/>
		///       is thrown. </para>
		/// </summary>
		/// <returns>
		///    The new copy of the collection.
		/// </returns>
		public ManagementNamedValueCollection Clone ()
		{
			ManagementNamedValueCollection nvc = new ManagementNamedValueCollection();

			foreach (string name in this)
			{
				// If we can clone the value, do so. Otherwise throw.
				object val = base.BaseGet (name);

				if (null != val)
				{
					Type valueType = val.GetType ();
					
					if (valueType.IsByRef)
					{
						try 
						{
							object clonedValue = ((ICloneable)val).Clone ();
							nvc.Add (name, clonedValue);
						}
						catch 
						{
							throw new NotSupportedException ();
						}
					}
					else
					{
						nvc.Add (name, val);
					}
				}
				else
					nvc.Add (name, null);
			}

			return nvc;
		}

		/// <summary>
		///    <para>Returns the value associated with the specified name from this collection.</para>
		/// </summary>
		/// <param name=' name'>The name of the value to be returned.</param>
		/// <value>
		/// <para>An <see cref='System.Object'/> containing the 
		///    value of the specified item in this collection.</para>
		/// </value>
		public object this[string name] 
		{
			get { 
				return base.BaseGet(name);
            }
		}        
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\managementobject.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Collections;
using System.Runtime.InteropServices;
using WbemClient_v1;
using System.ComponentModel;
using System.Runtime.Serialization;
using System.Globalization;

namespace System.Management
{
	/// <summary>
	/// Delegate definition for the IdentifierChanged event.
	/// This event is used to signal the ManagementObject that an identifying property
	/// has been changed. Identifying properties are the ones that identify the object, 
	/// namely the scope, path and options.
	/// </summary>
	internal delegate void IdentifierChangedEventHandler(object sender, 
					IdentifierChangedEventArgs e);
    
	/// <summary>
	/// Delegate definition for InternalObjectPut event. This is used so that
	/// the WmiEventSink can signal to this object that the async Put call has
	/// completed.
	/// </summary>
	internal delegate void InternalObjectPutEventHandler(object sender,
		InternalObjectPutEventArgs e);
    

	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para> Represents a data management object.</para>
	/// </summary>
	/// <example>
	///    <code lang='C#'>using System;
	/// using System.Management;
	/// 
	/// // This example demonstrates reading a property of a ManagementObject.
	/// class Sample_ManagementObject
	/// {
	///     public static int Main(string[] args) {
	///         ManagementObject disk = new ManagementObject(
	///             "win32_logicaldisk.deviceid=\"c:\"");
	///         disk.Get();
	///         Console.WriteLine("Logical Disk Size = " + disk["Size"] + " bytes");
	///         return 0;
	///     }
	/// }
	///    </code>
	///    <code lang='VB'>Imports System
	/// Imports System.Management
	/// 
	/// ' This example demonstrates reading a property of a ManagementObject.
	/// Class Sample_ManagementObject
	///     Overloads Public Shared Function Main(args() As String) As Integer
	///         Dim disk As New ManagementObject("win32_logicaldisk.deviceid=""c:""")
	///         disk.Get()
	///         Console.WriteLine(("Logical Disk Size = " &amp; disk("Size").ToString() _
	///             &amp; " bytes"))
	///         Return 0
	///     End Function
	/// End Class
	///    </code>
	/// </example>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
    [Serializable]
    public class ManagementObject : ManagementBaseObject, ICloneable
	{
		// constants
		internal const string ID = "ID";
		internal const string RETURNVALUE = "RETURNVALUE";

		//Fields

		private	IWbemClassObjectFreeThreaded	wmiClass;
		internal ManagementScope				scope;
		internal ManagementPath					path;
		internal ObjectGetOptions				options;

		//Used to represent whether this managementObject is currently bound to a wbemObject
		//or not - whenever an "identifying" property is changed (Path, Scope...) the object
		//is "detached" (isBound becomes false) so that we refresh the wbemObject next time
		//it's used, in conformance with the new property values.
		//
		// ***
		// *	Changed isBound flag to wbemObject==null check.
		// *	private bool isBound;
		// ***
		
		//This is used to identify a state in which a Put() operation was performed, but the
		//object was not retrieved again, so the WMI object that's available at this point
		//cannot be used for certain operations, namely CreateInstance, GetSubclasses, Derive,
		//Clone & ClassPath. 
		//When these operations are invoked, if we are in this state we need to implicitly
		//get the object...
		private bool putButNotGot;
		
		//Event fired when any "identifying" property changes.
		internal event IdentifierChangedEventHandler IdentifierChanged;

		//Fires IdentifierChanged event
		internal void FireIdentifierChanged()
		{
			if (IdentifierChanged != null)
				IdentifierChanged(this, null);
		}

		internal bool PutButNotGot 
		{
			get 
			{ return putButNotGot; }
			set 
			{ putButNotGot = value; }
		}

		//Called when IdentifierChanged() event fires
		private void HandleIdentifierChange(object sender, 
			IdentifierChangedEventArgs e)
		{
			// Detach the object from the WMI object underneath
			//
			// ***
			// *	Changed isBound flag to wbemObject==null check.
			// *	isBound = false;
			// ***
			wbemObject = null;
		}

		internal bool IsBound 
		{
			get
			{ return _wbemObject != null; }
		}

		//internal constructor
		internal static ManagementObject GetManagementObject(
			IWbemClassObjectFreeThreaded wbemObject,
			ManagementObject mgObj) 
		{
			ManagementObject newObject = new ManagementObject();
			newObject.wbemObject = wbemObject;

			if (null != mgObj)
			{
				newObject.scope = ManagementScope._Clone(mgObj.scope);

				if (null != mgObj.path)
					newObject.path = ManagementPath._Clone(mgObj.path);

				if (null != mgObj.options)
					newObject.options = ObjectGetOptions._Clone(mgObj.options);

				// We set isBound last since assigning to Scope, Path
				// or Options can trigger isBound to be set false.
				//
				// ***
				// *	Changed isBound flag to wbemObject==null check.
				// *	newObject.isBound = mgObj.isBound;
				// ***
			}

			return newObject;
		}

		internal static ManagementObject GetManagementObject(
			IWbemClassObjectFreeThreaded wbemObject,
			ManagementScope scope) 
		{
			ManagementObject newObject = new ManagementObject();
			newObject.wbemObject = wbemObject;

			newObject.path = new ManagementPath(ManagementPath.GetManagementPath(wbemObject));
			newObject.path.IdentifierChanged += new IdentifierChangedEventHandler(newObject.HandleIdentifierChange);

			newObject.scope = ManagementScope._Clone(scope, new IdentifierChangedEventHandler(newObject.HandleIdentifierChange));

			// Since we have an object, we should mark it as bound. Note
			// that we do this AFTER setting Scope and Path, since those
			// have side-effects of setting isBound=false.
			//
			// ***
			// *	Changed isBound flag to wbemObject==null check.
			// *	newObject.isBound = true;
			// ***

			return newObject;
		}

		//default constructor
		/// <overload>
		///    Initializes a new instance of the <see cref='System.Management.ManagementObject'/> class.
		/// </overload>
		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.ManagementObject'/> class. This is the
		///    default constructor.</para>
		/// </summary>
		/// <example>
		///    <code lang='C#'>ManagementObject o = new ManagementObject();
		/// 
		/// //Now set the path on this object to bind it to a 'real' manageable entity
		/// o.Path = "Win32_LogicalDisk='c:'"; 
		/// 
		/// //Now it can be used 
		/// Console.WriteLine(o["FreeSpace"]);
		///    </code>
		///    <code lang='VB'>Dim o As New ManagementObject()
		/// 
		/// 'Now set the path on this object to bind it to a 'real' manageable entity
		/// o.Path = "Win32_LogicalDisk=""c:"""
		/// 
		/// 'Now it can be used 
		/// Console.WriteLine(o("FreeSpace"))
		///    </code>
		/// </example>
		public ManagementObject() : this ((ManagementScope)null, null, null) {}

		//parameterized constructors
		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.ManagementObject'/> class for the specified WMI 
		///    object path. The path is provided as a <see cref='System.Management.ManagementPath'/>.</para>
		/// </summary>
		/// <param name='path'>A <see cref='System.Management.ManagementPath'/> that contains a path to a WMI object.</param>
		/// <example>
		///    <code lang='C#'>ManagementPath p = new ManagementPath("Win32_Service.Name='Alerter'");
		/// ManagementObject o = new ManagementObject(p);
		///    </code>
		///    <code lang='VB'>Dim p As New ManagementPath("Win32_Service.Name=""Alerter""")
		/// Dim o As New ManagementObject(p)
		///    </code>
		/// </example>
		public ManagementObject(ManagementPath path) : this(null, path, null) {}

		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.ManagementObject'/> class for the specified WMI object path. The path 
		///    is provided as a string.</para>
		/// </summary>
		/// <param name='path'>A WMI path.</param>
		/// <remarks>
		///    <para>If the specified path is a relative path only (a server 
		///       or namespace is not specified), the default path is the local machine, and the
		///       default namespace is the <see cref='System.Management.ManagementPath.DefaultPath'/>
		///       path (by default, root\cimv2). If the user specifies a
		///       full path, the default settings are overridden.</para>
		/// </remarks>
		/// <example>
		///    <code lang='C#'>ManagementObject o = new ManagementObject("Win32_Service.Name='Alerter'");
		///    
		/// //or with a full path :
		///    
		/// ManagementObject o = new ManagementObject("\\\\MyServer\\root\\MyApp:MyClass.Key='abc'");
		///    </code>
		///    <code lang='VB'>Dim o As New ManagementObject("Win32_Service.Name=""Alerter""")
		///    
		/// //or with a full path :
		///    
		/// Dim o As New ManagementObject("\\\\MyServer\\root\\MyApp:MyClass.Key=""abc""");
		///    </code>
		/// </example>
		public ManagementObject(string path) : this(null, new ManagementPath(path), null) {}

		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.ManagementObject'/> class bound to the specified 
		///    WMI path, including the specified additional options.</para>
		/// </summary>
		/// <param name='path'>A <see cref='System.Management.ManagementPath'/> containing the WMI path.</param>
		/// <param name=' options'>An <see cref='System.Management.ObjectGetOptions'/> containing additional options for binding to the WMI object. This parameter could be null if default options are to be used.</param>
		/// <example>
		///    <code lang='C#'>ManagementPath p = new ManagementPath("Win32_ComputerSystem.Name='MyMachine'");
		///    
		/// //Set options for no context info, but requests amended qualifiers 
		/// //to be contained in the object
		/// ObjectGetOptions opt = new ObjectGetOptions(null, true);    
		/// 
		/// ManagementObject o = new ManagementObject(p, opt);
		///    
		/// Console.WriteLine(o.GetQualifierValue("Description"));
		///    </code>
		///    <code lang='VB'>Dim p As New ManagementPath("Win32_ComputerSystem.Name=""MyMachine""")
		///    
		/// 'Set options for no context info, but requests amended qualifiers 
		/// 'to be contained in the object
		/// Dim opt As New ObjectGetOptions(null, true)
		/// 
		/// Dim o As New ManagementObject(p, opt)
		///    
		/// Console.WriteLine(o.GetQualifierValue("Description"));
		///    </code>
		/// </example>
		public ManagementObject(ManagementPath path, ObjectGetOptions options) : this(null, path, options) {}

		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.ManagementObject'/> class bound to the specified WMI path, including the 
		///    specified additional options. In this variant, the path can be specified as a
		///    string.</para>
		/// </summary>
		/// <param name='path'>The WMI path to the object.</param>
		/// <param name=' options'>An <see cref='System.Management.ObjectGetOptions'/> representing options to get the specified WMI object.</param>
		/// <example>
		///    <code lang='C#'>//Set options for no context info, 
		/// //but requests amended qualifiers to be contained in the object
		/// ObjectGetOptions opt = new ObjectGetOptions(null, true); 
		/// 
		/// ManagementObject o = new ManagementObject("Win32_ComputerSystem.Name='MyMachine'", opt);
		///    
		/// Console.WriteLine(o.GetQualifierValue("Description"));
		///    </code>
		///    <code lang='VB'>'Set options for no context info, 
		/// 'but requests amended qualifiers to be contained in the object
		/// Dim opt As New ObjectGetOptions(null, true)
		/// 
		/// Dim o As New ManagementObject("Win32_ComputerSystem.Name=""MyMachine""", opt);
		///    
		/// Console.WriteLine(o.GetQualifierValue("Description"))
		///    </code>
		/// </example>
		public ManagementObject(string path, ObjectGetOptions options) : 
			this(new ManagementPath(path), options) {}

		/// <summary>
		/// <para> Initializes a new instance of the <see cref='System.Management.ManagementObject'/> 
		/// class bound to the specified WMI path that includes the specified options.</para>
		/// </summary>
		/// <param name='scope'>A <see cref='System.Management.ManagementScope'/> representing the scope in which the WMI object resides. In this version, scopes can only be WMI namespaces.</param>
		/// <param name=' path'>A <see cref='System.Management.ManagementPath'/> representing the WMI path to the manageable object.</param>
		/// <param name=' options'>An <see cref='System.Management.ObjectGetOptions'/> specifying additional options for getting the object.</param>
		/// <remarks>
		///    <para> Because WMI paths can be relative or full, a conflict between the scope and the path 
		///       specified may arise. However, if a scope is specified and
		///       a relative WMI path is specified, then there is no conflict. The
		///       following are some possible conflicts: </para>
		///    <para> If a scope is not specified and a relative WMI 
		///       path is specified, then the scope will default to the local machine's <see cref='System.Management.ManagementPath.DefaultPath'/>. </para>
		///    <para> If a scope is not specified and a full WMI path is 
		///       specified, then the scope will be inferred from the scope portion of the full
		///       path. For example, the full WMI path: <c>\\MyMachine\root\MyNamespace:MyClass.Name='abc'</c> will
		///    represent the WMI object 'MyClass.Name='abc'" in the scope
		///    '\\MyMachine\root\MyNamespace'. </para>
		/// If a scope is specified and a full WMI path is specified, then the scope
		/// will override the scope portion of the full path. For example, if the following
		/// scope was specified: \\MyMachine\root\MyScope, and the following full path was
		/// specified: \\MyMachine\root\MyNamespace:MyClass.Name='abc', then look for the
		/// following <c>object:
		/// \\MyMachine\root\MyScope:MyClass.Name=
		/// 'abc'</c>
		/// (the scope part of the full path is ignored).
		/// </remarks>
		/// <example>
		///    <code lang='C#'>ManagementScope s = new ManagementScope("\\\\MyMachine\\root\\cimv2");
		/// ManagementPath p = new ManagementPath("Win32_LogicalDisk.Name='c:'");
		/// ManagementObject o = new ManagementObject(s,p);
		///    </code>
		///    <code lang='VB'>Dim s As New ManagementScope("\\MyMachine\root\cimv2");
		/// Dim p As New ManagementPath("Win32_LogicalDisk.Name=""c:""");
		/// Dim o As New ManagementObject(s,p);
		///    </code>
		/// </example>
		public ManagementObject(ManagementScope scope, ManagementPath path, ObjectGetOptions options)
            : base (null)
        {
            ManagementObjectCTOR(scope, path, options);
        }

        void ManagementObjectCTOR(ManagementScope scope, ManagementPath path, ObjectGetOptions options)
        {
			// We may use this to set the scope path
			string nsPath = String.Empty;

			if ((null != path) && !path.IsEmpty)
			{
				//If this is a ManagementObject then the path has to be an instance,
				// and if this is a ManagementClass the path has to be a class.
				if (GetType() == typeof(ManagementObject) && path.IsClass)
					throw new ArgumentOutOfRangeException("path");
				else if (GetType() == typeof(ManagementClass) && path.IsInstance)
					throw new ArgumentOutOfRangeException("path");

				// Save the namespace path portion of the path (if any) in case
				// we don't have a scope
				nsPath = path.GetNamespacePath((int)tag_WBEM_GET_TEXT_FLAGS.WBEMPATH_GET_SERVER_AND_NAMESPACE_ONLY);

				if ((null != scope) && (String.Empty != scope.Path.NamespacePath))
				{
					// If the scope has a path too, the namespace portion of
					// scope.path takes precedence over what is specified in path
					path = new ManagementPath(path.RelativePath);
					path.NamespacePath = scope.Path.GetNamespacePath((int)tag_WBEM_GET_TEXT_FLAGS.WBEMPATH_GET_SERVER_AND_NAMESPACE_ONLY);
				}

				// If the supplied path is a class or instance use it, otherwise
				// leave it empty
				if (path.IsClass || path.IsInstance)
					this.path = ManagementPath._Clone(path, new IdentifierChangedEventHandler(HandleIdentifierChange));

				else
					this.path = ManagementPath._Clone(null, new IdentifierChangedEventHandler(HandleIdentifierChange));
			}

			if (null != options)
				this.options = ObjectGetOptions._Clone(options, new IdentifierChangedEventHandler(HandleIdentifierChange));

			if (null != scope)
				this.scope = ManagementScope._Clone(scope, new IdentifierChangedEventHandler(HandleIdentifierChange));
			else
			{
				// Use the path if possible, otherwise let it default
				if (String.Empty != nsPath)
				{
					this.scope = new ManagementScope(nsPath);
					this.scope.IdentifierChanged += new IdentifierChangedEventHandler(HandleIdentifierChange);
				}
			}

			//register for identifier change events
			IdentifierChanged += new IdentifierChangedEventHandler(HandleIdentifierChange);
			// ***
			// *	Changed isBound flag to wbemObject==null check.
			// *	isBound = false;
			// ***
			putButNotGot = false;

		}

		/// <summary>
		/// <para> Initializes a new instance of the <see cref='System.Management.ManagementObject'/> class
		///    bound to the specified WMI path, and includes the specified options. The scope and
		///    the path are specified as strings.</para>
		/// </summary>
		/// <param name='scopeString'>The scope for the WMI object.</param>
		/// <param name=' pathString'>The WMI object path.</param>
		/// <param name=' options'>An <see cref='System.Management.ObjectGetOptions'/> representing additional options for getting the WMI object.</param>
		/// <remarks>
		///    <para>See the equivalent overload for details.</para>
		/// </remarks>
		/// <example>
		///    <code lang='C#'>GetObjectOptions opt = new GetObjectOptions(null, true);
		/// ManagementObject o = new ManagementObject("root\\MyNamespace", "MyClass.Name='abc'", opt);
		///    </code>
		///    <code lang='VB'>Dim opt As New GetObjectOptions(null, true)
		/// Dim o As New ManagementObject("root\MyNamespace", "MyClass.Name=""abc""", opt);
		///    </code>
		/// </example>
		public ManagementObject(string scopeString, string pathString, ObjectGetOptions options)
			: this(new ManagementScope(scopeString), new ManagementPath(pathString), options) {}

        /// <summary>
        /// <para>Initializes a new instance of the <see cref='System.Management.ManagementObject'/> class that is serializable.</para>
        /// </summary>
        /// <param name='info'>The <see cref='System.Runtime.Serialization.SerializationInfo'/> to populate with data.</param>
	/// <param name='context'>The destination (see <see cref='System.Runtime.Serialization.StreamingContext'/> ) for this serialization.</param>
        public ManagementObject(SerializationInfo info, StreamingContext context) : base(info, context)
        {
            ManagementObjectCTOR(null, null, null);
        }

		/// <summary>
		///    <para> Gets or sets the scope in which this object resides.</para>
		/// </summary>
		/// <value>
		/// <para> A <see cref='System.Management.ManagementScope'/>.</para>
		/// </value>
		/// <remarks>
		///    <para> 
		///       Changing
		///       this property after the management object has been bound to a WMI object in
		///       a particular namespace results in releasing the original WMI object. This causes the management object to
		///       be rebound to the new object specified by the new path properties and scope
		///       values. </para>
		///    <para>The rebinding is performed in a "lazy" manner, that is, only when a requested
		///       value requires the management object to be bound to the WMI object. Changes can
		///       be made to more than just this property before attempting to rebind (for example, modifying the scope
		///       and path properties simultaneously).</para>
		/// </remarks>
		/// <example>
		///    <code lang='C#'>//Create the object with the default namespace (root\cimv2)
		/// ManagementObject o = new ManagementObject();    
		/// 
		/// //Change the scope (=namespace) of this object to the one specified.
		/// o.Scope = new ManagementScope("root\\MyAppNamespace");
		///    </code>
		///    <code lang='VB'>'Create the object with the default namespace (root\cimv2)
		/// Dim o As New ManagementObject()
		/// 
		/// 'Change the scope (=namespace) of this object to the one specified.
		/// o.Scope = New ManagementScope("root\MyAppNamespace")
		///    </code>
		/// </example>
		public ManagementScope Scope 
		{
			get 
			{
				if (scope == null)
					return scope = ManagementScope._Clone(null);
				else
					return scope;
			}
			set 
			{
				if (null != value)
				{
					if (null != scope)
						scope.IdentifierChanged -= new IdentifierChangedEventHandler(HandleIdentifierChange);

					scope = ManagementScope._Clone((ManagementScope)value, new IdentifierChangedEventHandler(HandleIdentifierChange));

					//the scope property has changed so fire event
					FireIdentifierChanged();
				}
				else 
					throw new ArgumentNullException();
			}
		}
		
		/// <summary>
		///    <para> Gets or sets the object's WMI path.</para>
		/// </summary>
		/// <value>
		/// <para>A <see cref='System.Management.ManagementPath'/> representing the object's path.</para>
		/// </value>
		/// <remarks>
		///    <para> 
		///       Changing the property after the management
		///       object has been bound to a WMI object in a particular namespace results in releasing
		///       the original WMI object. This causes the management object to be rebound to
		///       the new object specified by the new path properties and scope values.</para>
		///    <para>The rebinding is performed in a "lazy" manner, that is, only when a requested 
		///       value requires the management object to be bound to the WMI object. Changes can
		///       be made to more than just the property before attempting to rebind (for example,
		///       modifying the scope and path properties simultaneously).</para>
		/// </remarks>
		/// <example>
		///    <code lang='C#'>ManagementObject o = new ManagementObject(); 
		/// 
		/// //Specify the WMI path to which this object should be bound to
		/// o.Path = new ManagementPath("MyClass.Name='foo'");
		///    </code>
		///    <code lang='VB'>Dim o As New ManagementObject()
		/// 
		/// 'Specify the WMI path to which this object should be bound to
		/// o.Path = New ManagementPath("MyClass.Name=""foo""");
		///    </code>
		/// </example>
		public virtual ManagementPath Path 
		{ 
			get 
			{
				if (path == null)
					return path = ManagementPath._Clone(null);
				else
					return path;
			} 
			set 
			{
				ManagementPath newPath = (null != value) ? value : new ManagementPath();

				//If the new path contains a namespace path and the scope is currently defaulted,
				//we want to set the scope to the new namespace path provided
				string nsPath = newPath.GetNamespacePath((int)tag_WBEM_GET_TEXT_FLAGS.WBEMPATH_GET_SERVER_AND_NAMESPACE_ONLY);
				if ((nsPath.Length > 0) && (scope != null) && (scope.IsDefaulted))
					Scope = new ManagementScope(nsPath);

				// This must be a class for a ManagementClass object or an instance for a ManagementObject, or empty
				if ((GetType() == typeof(ManagementObject) && newPath.IsInstance) || 
					(GetType() == typeof(ManagementClass) && newPath.IsClass) || 
					newPath.IsEmpty)
				{
					if (null != path)
						path.IdentifierChanged -=  new IdentifierChangedEventHandler(HandleIdentifierChange);

					path = ManagementPath._Clone((ManagementPath)value, new IdentifierChangedEventHandler(HandleIdentifierChange));

					//the path property has changed so fire event
					FireIdentifierChanged();
				}
				else
					throw new ArgumentOutOfRangeException();
			}
		}

		/// <summary>
		///    <para> 
		///       Gets or
		///       sets additional information to use when retrieving the object.</para>
		/// </summary>
		/// <value>
		/// <para>An <see cref='System.Management.ObjectGetOptions'/> to use when retrieving the object.</para>
		/// </value>
		/// <remarks>
		///    <para> When the property is
		///       changed after the management object has been bound to a WMI object, the management object
		///       is disconnected from the original WMI object and later rebound using the new
		///       options.</para>
		/// </remarks>
		/// <example>
		///    <code lang='C#'>//Contains default options
		/// ManagementObject o = new ManagementObject("MyClass.Name='abc'"); 
		/// 
		/// //Replace default options, in this case requesting retrieval of
		/// //amended qualifiers along with the WMI object.
		/// o.Options = new ObjectGetOptions(null, true);
		///    </code>
		///    <code lang='VB'>'Contains default options
		/// Dim o As New ManagementObject("MyClass.Name=""abc""")
		/// 
		/// 'Replace default options, in this case requesting retrieval of
		/// 'amended qualifiers along with the WMI object.
		/// o.Options = New ObjectGetOptions(null, true)
		///    </code>
		/// </example>
		public ObjectGetOptions Options 
		{
			get 
			{
				if (options == null)
					return options = ObjectGetOptions._Clone(null);
				else
					return options;
			} 
			set 
			{
				if (null != value)
				{
					if (null != options)
						options.IdentifierChanged -= new IdentifierChangedEventHandler(HandleIdentifierChange);

					options = ObjectGetOptions._Clone((ObjectGetOptions)value, new IdentifierChangedEventHandler(HandleIdentifierChange));

					//the options property has changed so fire event
					FireIdentifierChanged();
				}
				else
					throw new ArgumentNullException();
			}
		}

		/// <summary>
		///    <para>Gets or sets the path to the object's class.</para>
		/// </summary>
		/// <value>
		/// <para>A <see cref='System.Management.ManagementPath'/> representing the path to the object's 
		///    class.</para>
		/// </value>
		/// <remarks>
		///    <para>This property is read-only.</para>
		/// </remarks>
		/// <example>
		///    <code lang='C#'>ManagementObject o = new ManagementObject("MyClass.Name='abc'"); 
		/// 
		/// //Get the class definition for the object above.
		/// ManagementClass c = new ManagementClass(o.ClassPath);
		///    </code>
		///    <code lang='VB'>Dim o As New ManagementObject("MyClass.Name=""abc""")
		/// 
		/// 'Get the class definition for the object above.
		/// Dim c As New ManagementClass(o.ClassPath);
		///    </code>
		/// </example>
		public override ManagementPath ClassPath 
		{ 
			get 
			{ 
				Object serverName = null;
				Object scopeName = null;
				Object className = null;
				int propertyType = 0;
				int propertyFlavor = 0;

				if (PutButNotGot)
				{
					Get();
					PutButNotGot = false;
				}
			
				//
				// Removed Initialize call since wbemObject is a property that will call Initialize ( true ) on
				// its getter.
				//
				// Initialize ( ) ;

				int status = wbemObject.Get_("__SERVER", 0, ref serverName, ref propertyType, ref propertyFlavor);

				if (status >= 0)
				{
					status = wbemObject.Get_("__NAMESPACE", 0, ref scopeName, ref propertyType, ref propertyFlavor);
					
					if (status >= 0)
					{
						status = wbemObject.Get_("__CLASS", 0, ref className, ref propertyType, ref propertyFlavor);
					}
				}

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}

				ManagementPath classPath = new ManagementPath();

				// Some of these may throw if they are NULL
				try 
				{
					classPath.Server = (string)(serverName is System.DBNull ? "" : serverName);
					classPath.NamespacePath = (string)(scopeName is System.DBNull ? "" : scopeName);
					classPath.ClassName = (string)(className is System.DBNull ? "" : className);
				} 
				catch (Exception) {}

				return classPath;
			} 
		}

		//
		//Methods
		//

		//******************************************************
		//Get
		//******************************************************
		/// <overload>
		///    Binds to the management object.
		/// </overload>
		/// <summary>
		///    <para> Binds to the management object.</para>
		/// </summary>
		/// <remarks>
		///    <para> The method is implicitly
		///       invoked at the first attempt to get or set information to the WMI object. It
		///       can also be explicitly invoked at the user's discretion, to better control the
		///       timing and manner of retrieval.</para>
		/// </remarks>
		/// <example>
		///    <code lang='C#'>ManagementObject o = new ManagementObject("MyClass.Name='abc'"); 
		/// string s = o["SomeProperty"]; //this causes an implicit Get(). 
		/// 
		/// //or :
		/// 
		/// ManagementObject o= new ManagementObject("MyClass.Name= 'abc'");
		/// o.Get(); //explicitly 
		/// //Now it's faster because the object has already been retrieved.
		/// string s = o["SomeProperty"];
		///    </code>
		///    <code lang='VB'>Dim o As New ManagementObject("MyClass.Name=""abc""") 
		/// string s = o("SomeProperty") 'this causes an implicit Get(). 
		/// 
		/// 'or :
		/// 
		/// Dim o As New ManagementObject("MyClass.Name= ""abc""")
		/// o.Get()  'explicitly 
		/// 'Now it's faster because the object has already been retrieved.
		/// string s = o("SomeProperty");
		///    </code>
		/// </example>
		public void Get()
		{
			IWbemClassObjectFreeThreaded tempObj = null;

			Initialize ( false ) ; // this may throw

			if ((null == path) || (String.Empty == path.Path))
				throw new InvalidOperationException();
			else
			{
				ObjectGetOptions gOptions = 
					(null == options) ? new ObjectGetOptions() : options;
				
				SecurityHandler securityHandler = null;
				int status						= (int)ManagementStatus.NoError;

				try
				{
					securityHandler = scope.GetSecurityHandler();

					status = scope.GetIWbemServices().GetObject_(
															path.RelativePath, 
															gOptions.Flags, 
															gOptions.GetContext(),
															out tempObj,
															IntPtr.Zero);
				
					if (status < 0)
					{
						if ((status & 0xfffff000) == 0x80041000)
							ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
						else
							Marshal.ThrowExceptionForHR(status);
					}

					wbemObject = tempObj;
				} 
				finally
				{
					if (securityHandler != null)
						securityHandler.Reset();
				}
			}
		}

		//******************************************************
		//Get
		//******************************************************
		/// <summary>
		///    <para> Binds to the management object asynchronously.</para>
		/// </summary>
		/// <param name='watcher'>The object to receive the results of the operation as events.</param>
		/// <remarks>
		///    <para>The method will issue the request to get the object
		///       and then will immediately return. The results of the operation will then be
		///       delivered through events being fired on the watcher object provided.</para>
		/// </remarks>
		/// <example>
		///    <code lang='C#'>ManagementObject o = new ManagementObject("MyClass.Name='abc'");
		/// 
		/// //Set up handlers for asynchronous get
		/// MyHandler h = new MyHandler();
		/// ManagementOperationObserver ob = new ManagementOperationObserver();
		/// ob.Completed += new CompletedEventHandler(h.Done);
		/// 
		/// //Get the object asynchronously
		/// o.Get(ob);
		/// 
		/// //Wait until operation is completed
		/// while (!h.Completed)
		///     System.Threading.Thread.Sleep (1000);
		/// 
		/// //Here we can use the object
		/// Console.WriteLine(o["SomeProperty"]);
		/// 
		/// public class MyHandler
		/// {
		///     private bool completed = false;
		/// 
		///     public void Done(object sender, CompletedEventArgs e) {
		///         Console.WriteLine("async Get completed !");
		///         completed = true;
		///     }
		///     
		///     public bool Completed { 
		///         get {
		///             return completed;
		///         }
		///     }
		/// }
		///    </code>
		///    <code lang='VB'>Dim o As New ManagementObject("MyClass.Name=""abc""")
		/// 
		/// 'Set up handlers for asynchronous get
		/// Dim h As New MyHandler()
		/// Dim ob As New ManagementOperationObserver()
		/// ob.Completed += New CompletedEventHandler(h.Done)
		/// 
		/// 'Get the object asynchronously
		/// o.Get(ob)
		/// 
		/// 'Wait until operation is completed
		/// While Not h.Completed
		///     System.Threading.Thread.Sleep(1000)
		/// End While
		///     
		/// 'Here we can use the object
		/// Console.WriteLine(o("SomeProperty"))
		/// 
		/// Public Class MyHandler
		///     Private _completed As Boolean = false;
		/// 
		///     Public Sub Done(sender As Object, e As EventArrivedEventArgs)
		///         Console.WriteLine("async Get completed !")
		///         _completed = True
		///     End Sub    
		/// 
		///     Public ReadOnly Property Completed() As Boolean
		///        Get
		///            Return _completed
		///        End Get
		///     End Property
		/// End Class
		///    </code>
		/// </example>
		public void Get(ManagementOperationObserver watcher)
		{
			Initialize ( false ) ;

			if ((null == path) || (String.Empty == path.Path))
				throw new InvalidOperationException();
			else if (null == watcher)
				throw new ArgumentNullException("watcher");
			else
			{
				IWbemServices wbemServices = scope.GetIWbemServices();

				ObjectGetOptions o = ObjectGetOptions._Clone(options);

				WmiGetEventSink sink = watcher.GetNewGetSink(
					scope,
					o.Context, 
					this);

				// If someone has registered for progress, make sure we flag it
				if (watcher.HaveListenersForProgress)
					o.SendStatus = true;

				SecurityHandler securityHandler = null;
				int status						= (int)ManagementStatus.NoError;

				securityHandler = scope.GetSecurityHandler();

				status = wbemServices.GetObjectAsync_(
											path.RelativePath,
											o.Flags,
											o.GetContext(),
											sink.Stub);
				
				if (securityHandler != null)
					securityHandler.Reset();

				if (status < 0)
				{
					watcher.RemoveSink(sink);
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}
			}
		}

		//******************************************************
		//GetRelated 
		//****************************************************
		/// <overload>
		///    <para>Gets a collection of objects related to the object (associators).</para>
		/// </overload>
		/// <summary>
		///    <para>Gets a collection of objects related to the object (associators).</para>
		/// </summary>
		/// <returns>
		/// <para>A <see cref='System.Management.ManagementObjectCollection'/> containing the 
		///    related objects.</para>
		/// </returns>
		/// <remarks>
		///    <para> The operation is equivalent to an ASSOCIATORS OF query where ResultClass = relatedClass.</para>
		/// </remarks>
		/// <example>
		///    <code lang='C#'>ManagementObject o = new ManagementObject("Win32_Service='Alerter'");
		/// foreach(ManagementBaseObject b in o.GetRelated())
		///     Console.WriteLine("Object related to Alerter service : ", b.Path);
		///    </code>
		///    <code lang='VB'>Dim o As New ManagementObject("Win32_Service=""Alerter""")
		/// Dim b As ManagementBaseObject
		/// For Each b In o.GetRelated()
		///     Console.WriteLine("Object related to Alerter service : ", b.Path)
		/// Next b
		///    </code>
		/// </example>
		public ManagementObjectCollection GetRelated()
		{
			return GetRelated((string)null);
		}

		//******************************************************
		//GetRelated 
		//****************************************************
		/// <summary>
		///    <para>Gets a collection of objects related to the object (associators).</para>
		/// </summary>
		/// <param name='relatedClass'>A class of related objects. </param>
		/// <returns>
		///    A <see cref='System.Management.ManagementObjectCollection'/> containing the related objects.
		/// </returns>
		/// <example>
		///    <code lang='C#'>ManagementObject o = new ManagementObject("Win32_Service='Alerter'");
		/// foreach (ManagementBaseObject b in o.GetRelated("Win32_Service")
		///     Console.WriteLine("Service related to the Alerter service {0} is {1}", b["Name"], b["State"]);
		///    </code>
		///    <code lang='VB'>Dim o As New ManagementObject("Win32_Service=""Alerter""");
		/// Dim b As ManagementBaseObject
		/// For Each b in o.GetRelated("Win32_Service")
		///     Console.WriteLine("Service related to the Alerter service {0} is {1}", b("Name"), b("State"))
		/// Next b
		///    </code>
		/// </example>
		public ManagementObjectCollection GetRelated(
			string relatedClass) 
		{ 
			return GetRelated(relatedClass, null, null, null, null, null, false, null); 
		}


		//******************************************************
		//GetRelated 
		//****************************************************
		/// <summary>
		///    <para>Gets a collection of objects related to the object (associators).</para>
		/// </summary>
		/// <param name='relatedClass'>The class of the related objects. </param>
		/// <param name='relationshipClass'>The relationship class of interest. </param>
		/// <param name='relationshipQualifier'>The qualifier required to be present on the relationship class. </param>
		/// <param name='relatedQualifier'>The qualifier required to be present on the related class. </param>
		/// <param name='relatedRole'>The role that the related class is playing in the relationship. </param>
		/// <param name='thisRole'>The role that this class is playing in the relationship. </param>
		/// <param name='classDefinitionsOnly'>When this method returns, it contains only class definitions for the instances that match the query. </param>
		/// <param name='options'>Extended options for how to execute the query. </param>
		/// <returns>
		///    A <see cref='System.Management.ManagementObjectCollection'/> containing the related objects.
		/// </returns>
		/// <remarks>
		///    <para>This operation is equivalent to an ASSOCIATORS OF query where ResultClass = &lt;relatedClass&gt;.</para>
		/// </remarks>
		public ManagementObjectCollection GetRelated(
			string relatedClass,
			string relationshipClass,
			string relationshipQualifier,
			string relatedQualifier,
			string relatedRole,
			string thisRole,
			bool classDefinitionsOnly,
			EnumerationOptions options)
		{
			if ((null == path) || (String.Empty == path.Path))
				throw new InvalidOperationException();
			
			Initialize ( false ) ;

			IEnumWbemClassObject enumWbem = null;
			EnumerationOptions o = (null != options) ? options : new EnumerationOptions();
			RelatedObjectQuery q = new RelatedObjectQuery(
				path.Path, 
				relatedClass,
				relationshipClass, 
				relationshipQualifier,
				relatedQualifier, relatedRole, 
				thisRole, classDefinitionsOnly);
            

			//Make sure the EnumerateDeep flag bit is turned off because it's invalid for queries
			o.EnumerateDeep = true; //note this turns the FLAG to 0 !!

			SecurityHandler securityHandler = null;
			int status						= (int)ManagementStatus.NoError;

			try
			{
				securityHandler = scope.GetSecurityHandler();

				status = scope.GetIWbemServices().ExecQuery_(
														q.QueryLanguage, 
														q.QueryString, 
														o.Flags, 
														o.GetContext(), 
														out enumWbem);

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}

				securityHandler.Secure(enumWbem);
			}
			finally
			{
				if (securityHandler != null)
					securityHandler.Reset();
			}

			//Create collection object
			return new ManagementObjectCollection(scope, o, enumWbem);
		}


		//******************************************************
		//GetRelated 
		//****************************************************
		/// <summary>
		///    <para> Gets a collection of objects
		///       related to the object (associators) asynchronously. This call returns immediately, and a
		///       delegate is called when the results are available.</para>
		/// </summary>
		/// <param name='watcher'>The object to use to return results. </param>
		public void GetRelated(
			ManagementOperationObserver watcher)
		{
			GetRelated(watcher, (string)null);
		}

		//******************************************************
		//GetRelated 
		//****************************************************
		/// <summary>
		///    <para>Gets a collection of objects related to the object (associators).</para>
		/// </summary>
		/// <param name='watcher'>The object to use to return results. </param>
		/// <param name='relatedClass'>The class of related objects. </param>
		/// <remarks>
		///    <para>This operation is equivalent to an ASSOCIATORS OF query where ResultClass = &lt;relatedClass&gt;.</para>
		/// </remarks>
		public void GetRelated(
			ManagementOperationObserver watcher, 
			string relatedClass) 
		{
			GetRelated(watcher, relatedClass, null, null, null, null, null, false, null);
		}

			
		//******************************************************
		//GetRelated 
		//****************************************************
		/// <summary>
		///    <para>Gets a collection of objects related to the object (associators).</para>
		/// </summary>
		/// <param name='watcher'>The object to use to return results. </param>
		/// <param name='relatedClass'>The class of the related objects. </param>
		/// <param name='relationshipClass'>The relationship class of interest. </param>
		/// <param name='relationshipQualifier'>The qualifier required to be present on the relationship class. </param>
		/// <param name='relatedQualifier'>The qualifier required to be present on the related class. </param>
		/// <param name='relatedRole'>The role that the related class is playing in the relationship. </param>
		/// <param name='thisRole'>The role that this class is playing in the relationship. </param>
		/// <param name='classDefinitionsOnly'>Return only class definitions for the instances that match the query. </param>
		/// <param name='options'>Extended options for how to execute the query.</param>
		/// <remarks>
		///    <para>This operation is equivalent to an ASSOCIATORS OF query where ResultClass = &lt;relatedClass&gt;.</para>
		/// </remarks>
		public void GetRelated(
			ManagementOperationObserver watcher, 
			string relatedClass,
			string relationshipClass,
			string relationshipQualifier,
			string relatedQualifier,
			string relatedRole,
			string thisRole,
			bool classDefinitionsOnly,
			EnumerationOptions options)
		{
			if ((null == path) || (String.Empty == path.Path))
				throw new InvalidOperationException();

			Initialize ( true ) ;

			if (null == watcher)
				throw new ArgumentNullException("watcher");
			else
			{
				// Ensure we switch off ReturnImmediately as this is invalid for async calls
				EnumerationOptions o = (null != options) 
					? (EnumerationOptions)options.Clone() : new EnumerationOptions();
				o.ReturnImmediately = false;

				// If someone has registered for progress, make sure we flag it
				if (watcher.HaveListenersForProgress)
					o.SendStatus = true;

				WmiEventSink sink = watcher.GetNewSink(
					scope, 
					o.Context);

				RelatedObjectQuery q = new RelatedObjectQuery(path.Path, relatedClass,
					relationshipClass, relationshipQualifier,
					relatedQualifier, relatedRole, 
					thisRole, classDefinitionsOnly);
            

				//Make sure the EnumerateDeep flag bit is turned off because it's invalid for queries
				o.EnumerateDeep = true; //note this turns the FLAG to 0 !!
				
				SecurityHandler securityHandler	= null;
				int status						= (int)ManagementStatus.NoError;

				securityHandler = scope.GetSecurityHandler();

				status = scope.GetIWbemServices().ExecQueryAsync_(
														q.QueryLanguage, 
														q.QueryString, 
														o.Flags, 
														o.GetContext(), 
														sink.Stub);

				securityHandler.Reset();

				if (status < 0)
				{
					watcher.RemoveSink(sink);
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}
			}
		}

		//*******************************************************************
		//GetRelationships
		//*******************************************************************
		/// <overload>
		///    Gets a collection of associations to the object.
		/// </overload>
		/// <summary>
		///    <para>Gets a collection of associations to the object.</para>
		/// </summary>
		/// <returns>
		/// <para>A <see cref='System.Management.ManagementObjectCollection'/> containing the association objects.</para>
		/// </returns>
		/// <remarks>
		///    <para> The operation is equivalent to a REFERENCES OF query.</para>
		/// </remarks>
		public ManagementObjectCollection GetRelationships()
		{
			return GetRelationships((string)null);
		}

		//*******************************************************************
		//GetRelationships
		//*******************************************************************
		/// <summary>
		///    <para>Gets a collection of associations to the object.</para>
		/// </summary>
		/// <param name='relationshipClass'>The associations to include. </param>
		/// <returns>
		///    A <see cref='System.Management.ManagementObjectCollection'/> containing the association objects.
		/// </returns>
		/// <remarks>
		///    <para>This operation is equivalent to a REFERENCES OF query where the AssocClass = &lt;relationshipClass&gt;.</para>
		/// </remarks>
		public ManagementObjectCollection GetRelationships(
			string relationshipClass)
		{ 
			return GetRelationships(relationshipClass, null, null, false, null); 
		}

			
		//*******************************************************************
		//GetRelationships
		//*******************************************************************
		/// <summary>
		///    <para>Gets a collection of associations to the object.</para>
		/// </summary>
		/// <param name='relationshipClass'>The type of relationship of interest. </param>
		/// <param name='relationshipQualifier'>The qualifier to be present on the relationship. </param>
		/// <param name='thisRole'>The role of this object in the relationship. </param>
		/// <param name='classDefinitionsOnly'>When this method returns, it contains only the class definitions for the result set. </param>
		/// <param name='options'>The extended options for the query execution. </param>
		/// <returns>
		///    A <see cref='System.Management.ManagementObjectCollection'/> containing the association objects.
		/// </returns>
		/// <remarks>
		///    <para>This operation is equivalent to a REFERENCES OF query with possibly all the extensions.</para>
		/// </remarks>
		public ManagementObjectCollection GetRelationships(		
			string relationshipClass,
			string relationshipQualifier,
			string thisRole,
			bool classDefinitionsOnly,
			EnumerationOptions options)
		{
			if ((null == path) || (String.Empty == path.Path))
				throw new InvalidOperationException();
			
			Initialize ( false ) ;

			IEnumWbemClassObject enumWbem = null;
			EnumerationOptions o = 
				(null != options) ? options : new EnumerationOptions();
			RelationshipQuery q = new RelationshipQuery(path.Path, relationshipClass,  
				relationshipQualifier, thisRole, classDefinitionsOnly);
            

			//Make sure the EnumerateDeep flag bit is turned off because it's invalid for queries
			o.EnumerateDeep = true; //note this turns the FLAG to 0 !!

			SecurityHandler securityHandler = null;
			int status						= (int)ManagementStatus.NoError;

			try
			{
				securityHandler = scope.GetSecurityHandler();

				status = scope.GetIWbemServices().ExecQuery_(
													q.QueryLanguage, 
													q.QueryString, 
													o.Flags, 
													o.GetContext(), 
													out enumWbem);

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}

				securityHandler.Secure(enumWbem);
			}
			finally
			{
				if (securityHandler != null)
					securityHandler.Reset();
			}

			//Create collection object
			return new ManagementObjectCollection(scope, o, enumWbem);
		}


		//*******************************************************************
		//GetRelationships
		//*******************************************************************
		/// <summary>
		///    <para>Gets a collection of associations to the object.</para>
		/// </summary>
		/// <param name='watcher'>The object to use to return results. </param>
		/// <remarks> 
		/// This operation is equivalent to a REFERENCES OF query
		/// </remarks>
		public void GetRelationships(
			ManagementOperationObserver watcher)
		{
			GetRelationships(watcher, (string)null);
		}

		//*******************************************************************
		//GetRelationships
		//*******************************************************************
		/// <summary>
		///    <para>Gets a collection of associations to the object.</para>
		/// </summary>
		/// <param name='watcher'>The object to use to return results. </param>
		/// <param name='relationshipClass'>The associations to include. </param>
		/// <remarks>
		///    <para>This operation is equivalent to a REFERENCES OF query where the AssocClass = &lt;relationshipClass&gt;.</para>
		/// </remarks>
		public void GetRelationships(
			ManagementOperationObserver watcher, 
			string relationshipClass)
		{
			GetRelationships(watcher, relationshipClass, null, null, false, null);
		}
		
		
		//*******************************************************************
		//GetRelationships
		//*******************************************************************
		/// <summary>
		///    <para>Gets a collection of associations to the object.</para>
		/// </summary>
		/// <param name='watcher'>The object to use to return results. </param>
		/// <param name='relationshipClass'>The type of relationship of interest. </param>
		/// <param name='relationshipQualifier'>The qualifier to be present on the relationship. </param>
		/// <param name='thisRole'>The role of this object in the relationship. </param>
		/// <param name='classDefinitionsOnly'>When this method returns, it contains only the class definitions for the result set. </param>
		/// <param name='options'>The extended options for the query execution. </param>
		/// <remarks>
		///    <para>This operation is equivalent to a REFERENCES OF query with possibly all the extensions.</para>
		/// </remarks>
		public void GetRelationships(
			ManagementOperationObserver watcher, 
			string relationshipClass,
			string relationshipQualifier,
			string thisRole,
			bool classDefinitionsOnly,
			EnumerationOptions options)
		{
			if ((null == path)  || (String.Empty == path.Path))
				throw new InvalidOperationException();
			if (null == watcher)
				throw new ArgumentNullException("watcher");
			else
			{
				Initialize ( false ) ;
			
				// Ensure we switch off ReturnImmediately as this is invalid for async calls
				EnumerationOptions o = 
					(null != options) ? (EnumerationOptions)options.Clone() : 
					new EnumerationOptions();
				o.ReturnImmediately = false;
				
				// If someone has registered for progress, make sure we flag it
				if (watcher.HaveListenersForProgress)
					o.SendStatus = true;

				WmiEventSink sink = watcher.GetNewSink(scope, o.Context);

				RelationshipQuery q = new RelationshipQuery(path.Path, relationshipClass,
					relationshipQualifier, thisRole, classDefinitionsOnly);
				
				
				//Make sure the EnumerateDeep flag bit is turned off because it's invalid for queries
				o.EnumerateDeep = true; //note this turns the FLAG to 0 !!

				SecurityHandler securityHandler = null;
				int status						= (int)ManagementStatus.NoError;

				securityHandler = scope.GetSecurityHandler();

				status = scope.GetIWbemServices().ExecQueryAsync_(
														q.QueryLanguage, 
														q.QueryString, 
														o.Flags, 
														o.GetContext(), 
														sink.Stub);
			
				if (securityHandler != null)
					securityHandler.Reset();

				if (status < 0)
				{
					watcher.RemoveSink(sink);
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}
			}
		}

		//******************************************************
		//Put
		//******************************************************
		/// <overload>
		///    Commits the changes to the object.
		/// </overload>
		/// <summary>
		///    <para>Commits the changes to the object.</para>
		/// </summary>
		/// <returns>
		/// <para>A <see cref='System.Management.ManagementPath'/> containing the path to the committed 
		///    object.</para>
		/// </returns>
		public ManagementPath Put()
		{ 
			return Put((PutOptions) null); 
		}


		//******************************************************
		//Put
		//******************************************************
		/// <summary>
		///    <para>Commits the changes to the object.</para>
		/// </summary>
		/// <param name='options'>The options for how to commit the changes. </param>
		/// <returns>
		///    A <see cref='System.Management.ManagementPath'/> containing the path to the committed object.
		/// </returns>
		public ManagementPath Put(PutOptions options)
		{
			ManagementPath newPath = null;
			Initialize ( true ) ;
			PutOptions o = (null != options) ? options : new PutOptions();

			IWbemServices wbemServices = scope.GetIWbemServices();

			//
			// Must do this convoluted allocation since the IWbemServices ref IWbemCallResult
			// has been redefined to be an IntPtr.  Due to the fact that it wasn't possible to
			// pass NULL for the optional argument.
			//
			IntPtr ppwbemCallResult			= IntPtr.Zero;
			IntPtr pwbemCallResult			= IntPtr.Zero;
			IWbemCallResult wbemCallResult	= null;
			SecurityHandler securityHandler	= null;
			int status						= (int)ManagementStatus.NoError;

			try
			{
				securityHandler = scope.GetSecurityHandler();
				
				ppwbemCallResult = Marshal.AllocHGlobal(IntPtr.Size);
				Marshal.WriteIntPtr(ppwbemCallResult, IntPtr.Zero);		// Init to NULL.

				if (IsClass)
					status = wbemServices.PutClass_(
						wbemObject,
						o.Flags | (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_RETURN_IMMEDIATELY, 
						o.GetContext(), 
						ppwbemCallResult);
				else
					status = wbemServices.PutInstance_(
						wbemObject, 
						o.Flags | (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_RETURN_IMMEDIATELY, 
						o.GetContext(), 
						ppwbemCallResult);
					
				// Keep this statement here; otherwise, there'll be a leak in error cases.
				pwbemCallResult = Marshal.ReadIntPtr(ppwbemCallResult);

				wbemCallResult = (IWbemCallResult)Marshal.GetObjectForIUnknown(pwbemCallResult);
				securityHandler.Secure(wbemCallResult);

				int hr;
				status = wbemCallResult.GetCallStatus_((int)tag_WBEM_TIMEOUT_TYPE.WBEM_INFINITE, out hr);

				if (status >= 0)
					status = hr;

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}

				newPath = GetPath(wbemCallResult);

//				if (IsClass)
//					newPath.RelativePath = ClassName;
			} 
			finally
			{
				if (securityHandler != null)
					securityHandler.Reset();
				
				if (ppwbemCallResult != IntPtr.Zero)					// Cleanup from allocations above.
					Marshal.FreeHGlobal(ppwbemCallResult);
				
				if (pwbemCallResult != IntPtr.Zero)
					Marshal.Release(pwbemCallResult);
				
				if (wbemCallResult != null)
					Marshal.ReleaseComObject(wbemCallResult);
			}

			//Set the flag that tells the object that we've put it, so that a refresh is 
			//triggered when an operation that needs this is invoked (CreateInstance, Derive).
			putButNotGot = true;
			
			// Update our path to address the object just put. Note that
			// we do this in such a way as to NOT trigger the setting of this
			// ManagementObject into an unbound state
			path.SetRelativePath(newPath.RelativePath);

			return newPath;
		}

		private ManagementPath GetPath(IWbemCallResult callResult)
		{
			ManagementPath newPath = null;
			int status = (int)ManagementStatus.NoError;

			try
			{
				//
				// Obtain the path from the call result.
				// Note this will return the relative path at best.
				//
				string resultPath = null;

				status = callResult.GetResultString_(
					(int)tag_WBEM_TIMEOUT_TYPE.WBEM_INFINITE, 
					out resultPath);
						
				if (status >= 0)
				{
					newPath = new ManagementPath(scope.Path.Path);
					newPath.RelativePath = resultPath;
				}
				else
				{
					//
					// That didn't work. Use the path in the object instead.
					//
					object pathValue = GetPropertyValue("__PATH");

					// No path? Try Relpath?
					if (pathValue != null)
						newPath = new ManagementPath((string)pathValue);
					else
					{
						pathValue = GetPropertyValue("__RELPATH");

						if (pathValue != null)
						{
							newPath = new ManagementPath(scope.Path.Path);
							newPath.RelativePath = (string)pathValue;
						}
					}
				}

			} 
			catch {}

			if (newPath == null)
				newPath = new ManagementPath();

			return newPath;
		}

		/// <summary>
		///    <para>Commits the changes to the object, asynchronously.</para>
		/// </summary>
		/// <param name='watcher'>A <see cref='System.Management.ManagementOperationObserver'/> used to handle the progress and results of the asynchronous operation.</param>
		public void Put(ManagementOperationObserver watcher)
		{
			Put(watcher, null);
		}

		/// <summary>
		///    <para>Commits the changes to the object asynchronously and
		///       using the specified options.</para>
		/// </summary>
		/// <param name='watcher'>A <see cref='System.Management.ManagementOperationObserver'/> used to handle the progress and results of the asynchronous operation.</param>
		/// <param name=' options'>A <see cref='System.Management.PutOptions'/> used to specify additional options for the commit operation.</param>
		public void Put(ManagementOperationObserver watcher, PutOptions options)
		{
			if (null == watcher)
				throw new ArgumentNullException("watcher");
			else
			{
				Initialize ( false ) ;

				PutOptions o = (null == options) ?
					new PutOptions() : (PutOptions)options.Clone();
				
				// If someone has registered for progress, make sure we flag it
				if (watcher.HaveListenersForProgress)
					o.SendStatus = true;

				IWbemServices wbemServices = scope.GetIWbemServices();
				WmiEventSink sink = watcher.GetNewPutSink(scope, 
					o.Context, scope.Path.GetNamespacePath((int)tag_WBEM_GET_TEXT_FLAGS.WBEMPATH_GET_SERVER_AND_NAMESPACE_ONLY), ClassName);

				// Add ourselves to the watcher so we can update our state
				sink.InternalObjectPut += 
					new InternalObjectPutEventHandler(this.HandleObjectPut);

				SecurityHandler securityHandler	= null;
				// Assign to error initially to insure internal event handler cleanup
				// on non-management exception.
				int status						= (int)ManagementStatus.Failed;

				securityHandler = scope.GetSecurityHandler();

				if (IsClass)
					status = wbemServices.PutClassAsync_(	
						wbemObject, 
						o.Flags, 
						o.GetContext(),
						sink.Stub);
				else
					status = wbemServices.PutInstanceAsync_(
						wbemObject, 
						o.Flags, 
						o.GetContext(),
						sink.Stub);
				
				if (securityHandler != null)
					securityHandler.Reset();

				if (status < 0)
				{
					sink.InternalObjectPut -= new InternalObjectPutEventHandler(this.HandleObjectPut);
					watcher.RemoveSink(sink);
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}
			}
		}

		internal void HandleObjectPut(object sender, InternalObjectPutEventArgs e)
		{
			try 
			{
				if (sender is WmiEventSink) 
				{
					((WmiEventSink)sender).InternalObjectPut -= new InternalObjectPutEventHandler(this.HandleObjectPut);
					putButNotGot = true;
					path.SetRelativePath(e.Path.RelativePath);
				}
			} 
			catch {}
		}

		//******************************************************
		//CopyTo
		//******************************************************
		/// <overload>
		///    Copies the object to a different location.
		/// </overload>
		/// <summary>
		///    <para>Copies the object to a different location.</para>
		/// </summary>
		/// <param name='path'>The <see cref='System.Management.ManagementPath'/> to which the object should be copied. </param>
		/// <returns>
		///    <para>The new path of the copied object.</para>
		/// </returns>
		public ManagementPath CopyTo(ManagementPath path)
		{
			return CopyTo(path,(PutOptions)null);
		}

		/// <summary>
		///    <para>Copies the object to a different location.</para>
		/// </summary>
		/// <param name='path'>The path to which the object should be copied. </param>
		/// <returns>
		///    The new path of the copied object.
		/// </returns>
		public ManagementPath CopyTo(string path)
		{
			return CopyTo(new ManagementPath(path), (PutOptions)null);
		}
		
		/// <summary>
		///    <para>Copies the object to a different location.</para>
		/// </summary>
		/// <param name='path'>The path to which the object should be copied.</param>
		/// <param name='options'>The options for how the object should be put.</param>
		/// <returns>
		///    The new path of the copied object.
		/// </returns>
		public ManagementPath CopyTo(string path, PutOptions options)
		{
			return CopyTo(new ManagementPath(path), options);
		}

		/// <summary>
		///    <para>Copies the object to a different location.</para>
		/// </summary>
		/// <param name='path'>The <see cref='System.Management.ManagementPath'/> to which the object should be copied.</param>
		/// <param name='options'>The options for how the object should be put.</param>
		/// <returns>
		///    The new path of the copied object.
		/// </returns>
		public ManagementPath CopyTo(ManagementPath path, PutOptions options)
		{
			Initialize ( false ) ;

			ManagementScope destinationScope = null;
			
			// Build a scope for our target destination
			destinationScope = new ManagementScope(path, scope);
			destinationScope.Initialize();

			PutOptions o = (null != options) ? options : new PutOptions();
			IWbemServices wbemServices = destinationScope.GetIWbemServices();
			ManagementPath newPath = null;

			//
			// TO-DO : This code is almost identical to Put - should consolidate.
			//
			// Must do this convoluted allocation since the IWbemServices ref IWbemCallResult
			// has been redefined to be an IntPtr.  Due to the fact that it wasn't possible to
			// pass NULL for the optional argument.
			//
			IntPtr ppwbemCallResult			= IntPtr.Zero;
			IntPtr pwbemCallResult			= IntPtr.Zero;
			IWbemCallResult wbemCallResult	= null;
			SecurityHandler securityHandler	= null;
			int status						= (int)ManagementStatus.NoError;

			try 
			{
				securityHandler = destinationScope.GetSecurityHandler();

				ppwbemCallResult = Marshal.AllocHGlobal(IntPtr.Size);
				Marshal.WriteIntPtr(ppwbemCallResult, IntPtr.Zero);		// Init to NULL.

				if (IsClass)
					status = wbemServices.PutClass_(
						wbemObject, 
						o.Flags | (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_RETURN_IMMEDIATELY, 
						o.GetContext(), 
						ppwbemCallResult);
				else
					status = wbemServices.PutInstance_(
						wbemObject, 
						o.Flags | (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_RETURN_IMMEDIATELY, 
						o.GetContext(), 
						ppwbemCallResult);

				// Keep this statement here; otherwise, there'll be a leak in error cases.
				pwbemCallResult = Marshal.ReadIntPtr(ppwbemCallResult);

				//Use the CallResult to retrieve the resulting object path
				wbemCallResult = (IWbemCallResult)Marshal.GetObjectForIUnknown(pwbemCallResult);
				securityHandler.Secure(wbemCallResult);

				int hr;
				status = wbemCallResult.GetCallStatus_((int)tag_WBEM_TIMEOUT_TYPE.WBEM_INFINITE, out hr);

				if (status >= 0)
					status = hr;

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}

				newPath = GetPath(wbemCallResult);
				newPath.NamespacePath = path.GetNamespacePath((int)tag_WBEM_GET_TEXT_FLAGS.WBEMPATH_GET_SERVER_AND_NAMESPACE_ONLY);
			} 
			finally
			{
				if (securityHandler != null)
					securityHandler.Reset();
				
				if (ppwbemCallResult != IntPtr.Zero)					// Cleanup from allocations above.
					Marshal.FreeHGlobal(ppwbemCallResult);
				
				if (pwbemCallResult != IntPtr.Zero)
					Marshal.Release(pwbemCallResult);
				
				if (wbemCallResult != null)
					Marshal.ReleaseComObject(wbemCallResult);
			}

			return newPath;
		}

		/// <summary>
		///    <para>Copies the object to a different location, asynchronously.</para>
		/// </summary>
		/// <param name='watcher'>The object that will receive the results of the operation.</param>
		/// <param name='path'>A <see cref='System.Management.ManagementPath'/> specifying the path to which the object should be copied.</param>
		public void CopyTo(ManagementOperationObserver watcher, ManagementPath path)
		{
			CopyTo(watcher, path, null);
		}

		/// <summary>
		///    <para>Copies the object to a different location, asynchronously.</para>
		/// </summary>
		/// <param name='watcher'>The object that will receive the results of the operation.</param>
		/// <param name='path'> The path to which the object should be copied.</param>
		public void CopyTo(ManagementOperationObserver watcher, string path)
		{
			CopyTo(watcher, new ManagementPath(path), null);
		}

		/// <summary>
		///    <para>Copies the object to a different location, asynchronously.</para>
		/// </summary>
		/// <param name='watcher'>The object that will receive the results of the operation.</param>
		/// <param name='path'>The path to which the object should be copied.</param>
		/// <param name='options'>The options for how the object should be put.</param>
		public void CopyTo(ManagementOperationObserver watcher, string path, PutOptions options)
		{
			CopyTo(watcher, new ManagementPath(path), options);
		}

		/// <summary>
		///    <para>Copies the object to a different location, asynchronously.</para>
		/// </summary>
		/// <param name='watcher'>The object that will receive the results of the operation.</param>
		/// <param name='path'>The path to which the object should be copied.</param>
		/// <param name='options'>The options for how the object should be put.</param>
		public void CopyTo(ManagementOperationObserver watcher, ManagementPath path, PutOptions options)
		{
			if (null == watcher)
				throw new ArgumentNullException("watcher");
			else
			{
				Initialize ( false ) ;
				ManagementScope destinationScope = null;

				destinationScope = new ManagementScope(path, scope);
				destinationScope.Initialize();

				PutOptions o = (null != options) ? (PutOptions) options.Clone() : new PutOptions();

				// If someone has registered for progress, make sure we flag it
				if (watcher.HaveListenersForProgress)
					o.SendStatus = true;

				WmiEventSink sink = watcher.GetNewPutSink(destinationScope, o.Context, 
					path.GetNamespacePath((int)tag_WBEM_GET_TEXT_FLAGS.WBEMPATH_GET_SERVER_AND_NAMESPACE_ONLY), ClassName);
				IWbemServices destWbemServices = destinationScope.GetIWbemServices();

				SecurityHandler securityHandler = null;
				int status						= (int)ManagementStatus.NoError;

				securityHandler = destinationScope.GetSecurityHandler();

				if (IsClass)
					status = destWbemServices.PutClassAsync_(
													wbemObject, 
													o.Flags, 
													o.GetContext(), 
													sink.Stub);
				else
					status = destWbemServices.PutInstanceAsync_(
													wbemObject, 
													o.Flags, 
													o.GetContext(), 
													sink.Stub);

				if (securityHandler != null)
					securityHandler.Reset();

				if (status < 0)
				{
					watcher.RemoveSink(sink);
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}
			}
		}

		//******************************************************
		//Delete
		//******************************************************
		/// <overload>
		///    Deletes the object.
		/// </overload>
		/// <summary>
		///    <para>Deletes the object.</para>
		/// </summary>
		public void Delete()
		{ 
			Delete((DeleteOptions) null); 
		}
		
		/// <summary>
		///    <para>Deletes the object.</para>
		/// </summary>
		/// <param name='options'>The options for how to delete the object. </param>
		public void Delete(DeleteOptions options)
		{
			if ((null == path) || (String.Empty == path.Path))
				throw new InvalidOperationException();
			
			Initialize ( false ) ;
			DeleteOptions o = (null != options) ? options : new DeleteOptions();
			IWbemServices wbemServices = scope.GetIWbemServices();

			SecurityHandler securityHandler = null;
			int status						= (int)ManagementStatus.NoError;

			try
			{
				securityHandler = scope.GetSecurityHandler();

				if (IsClass)
					status = wbemServices.DeleteClass_(
						path.RelativePath, 
						o.Flags, 
						o.GetContext(), 
						IntPtr.Zero);
				else
					status = wbemServices.DeleteInstance_(
						path.RelativePath, 
						o.Flags,
						o.GetContext(), 
						IntPtr.Zero);
			
				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}
			}
			finally
			{
				if (securityHandler != null)
					securityHandler.Reset();
			}
		}


		/// <summary>
		///    <para>Deletes the object.</para>
		/// </summary>
		/// <param name='watcher'>The object that will receive the results of the operation.</param>
		public void Delete(ManagementOperationObserver watcher)
		{
			Delete(watcher, null);
		}

		/// <summary>
		///    <para>Deletes the object.</para>
		/// </summary>
		/// <param name='watcher'>The object that will receive the results of the operation.</param>
		/// <param name='options'>The options for how to delete the object.</param>
		public void Delete(ManagementOperationObserver watcher, DeleteOptions options)
		{
			if ((null == path) || (String.Empty == path.Path))
				throw new InvalidOperationException();
			else if (null == watcher)
				throw new ArgumentNullException("watcher");
			else
			{
				Initialize ( false ) ;
				DeleteOptions o = (null != options) ? (DeleteOptions) options.Clone() : new DeleteOptions();

				// If someone has registered for progress, make sure we flag it
				if (watcher.HaveListenersForProgress)
					o.SendStatus = true;

				IWbemServices wbemServices = scope.GetIWbemServices();
				WmiEventSink sink = watcher.GetNewSink(scope, o.Context);

				SecurityHandler securityHandler = null;
				int status						= (int)ManagementStatus.NoError;

				securityHandler = scope.GetSecurityHandler();

				if (IsClass)
					status = wbemServices.DeleteClassAsync_(
						path.RelativePath, 
						o.Flags, 
						o.GetContext(),
						sink.Stub);
				else
					status = wbemServices.DeleteInstanceAsync_(
						path.RelativePath, 
						o.Flags, 
						o.GetContext(),
						sink.Stub);

				if (securityHandler != null)
					securityHandler.Reset();

				if (status < 0)
				{
					watcher.RemoveSink(sink);
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}
			}
		}

		//******************************************************
		//InvokeMethod
		//******************************************************
		/// <overload>
		///    <para>Invokes a method on the object.</para>
		/// </overload>
		/// <summary>
		///    <para> 
		///       Invokes a method on the object.</para>
		/// </summary>
		/// <param name='methodName'>The name of the method to execute. </param>
		/// <param name='args'>An array containing parameter values. </param>
		/// <returns>
		///    <para>The value returned by the method.</para>
		/// </returns>
		/// <remarks>
		///    <para>If the method is static, the execution
		///       should still succeed.</para>
		/// </remarks>
		/// <example>
		///    <code lang='C#'>using System;
		/// using System.Management;
		/// 
		/// // This sample demonstrates invoking a WMI method using an array of arguments.
		/// public class InvokeMethod 
		/// {    
		///     public static void Main() 
		///     {
		/// 
		///         //Get the object on which the method will be invoked
		///         ManagementClass processClass = new ManagementClass("Win32_Process");
		/// 
		///         //Create an array containing all arguments for the method
		///         object[] methodArgs = {"notepad.exe", null, null, 0};
		/// 
		///         //Execute the method
		///         object result = processClass.InvokeMethod ("Create", methodArgs);
		/// 
		///         //Display results
		///         Console.WriteLine ("Creation of process returned: " + result);
		///         Console.WriteLine ("Process id: " + methodArgs[3]);
		///     }
		/// 
		/// }
		///    </code>
		///    <code lang='VB'>Imports System
		/// Imports System.Management
		/// 
		/// ' This sample demonstrates invoking a WMI method using an array of arguments.
		/// Class InvokeMethod
		///     Public Overloads Shared Function Main(ByVal args() As String) As Integer
		/// 
		///         ' Get the object on which the method will be invoked
		///         Dim processClass As New ManagementClass("Win32_Process")
		/// 
		///         ' Create an array containing all arguments for the method
		///         Dim methodArgs() As Object = {"notepad.exe", Nothing, Nothing, 0}
		/// 
		///         ' Execute the method
		///         Dim result As Object = processClass.InvokeMethod("Create", methodArgs)
		/// 
		///         'Display results
		///         Console.WriteLine("Creation of process returned: {0}", result)
		///         Console.WriteLine("Process id: {0}", methodArgs(3))
		///         Return 0
		///     End Function
		/// End Class
		///    </code>
		/// </example>
		public Object InvokeMethod(string methodName, Object[] args) 
		{ 
			object result = null;

			if ((null == path) || (String.Empty == path.Path))
				throw new InvalidOperationException();
			else if (null == methodName)
				throw new ArgumentNullException("methodName");
			else
			{
				Initialize ( false ) ;
			
				// Map args into a inparams structure
				ManagementBaseObject inParameters;
				IWbemClassObjectFreeThreaded inParametersClass, outParametersClass;
				GetMethodParameters(methodName, out inParameters, 
					out inParametersClass, out outParametersClass);

				MapInParameters(args, inParameters, inParametersClass);

				// Call ExecMethod
				ManagementBaseObject outParameters = 
					InvokeMethod(methodName, inParameters, null);

				// Map outparams to args
				result = MapOutParameters(args, outParameters, outParametersClass);
			}

			return result;
		}

		//******************************************************
		//InvokeMethod
		//******************************************************
		/// <summary>
		///    <para>Invokes a method on the object, asynchronously.</para>
		/// </summary>
		/// <param name='watcher'>The object to receive the results of the operation.</param>
		/// <param name='methodName'>The name of the method to execute. </param>
		/// <param name='args'>An array containing parameter values. </param>
		/// <remarks>
		///    <para>If the method is static, the execution
		///       should still succeed.</para>
		/// </remarks>
		public void InvokeMethod(
			ManagementOperationObserver watcher, 
			string methodName, 
			Object[] args) 
		{ 
			if ((null == path) || (String.Empty == path.Path))
				throw new InvalidOperationException();
			else if (null == watcher)
				throw new ArgumentNullException("watcher");
			else if (null == methodName)
				throw new ArgumentNullException("methodName");
			else
			{
				Initialize ( false ) ;
			
				// Map args into a inparams structure
				ManagementBaseObject inParameters;
				IWbemClassObjectFreeThreaded inParametersClass, outParametersClass;
				GetMethodParameters(methodName, out inParameters, 
					out inParametersClass,	out outParametersClass);

				MapInParameters(args, inParameters, inParametersClass);

				// Call the method
				InvokeMethod(watcher, methodName, inParameters, null);
			}
		}

		/// <summary>
		///    <para>Invokes a method on the WMI object. The input and output 
		///       parameters are represented as <see cref='System.Management.ManagementBaseObject'/>
		///       objects.</para>
		/// </summary>
		/// <param name='methodName'>The name of the method to execute.</param>
		/// <param name=' inParameters'>A <see cref='System.Management.ManagementBaseObject'/> holding the input parameters to the method.</param>
		/// <param name=' options'>An <see cref='System.Management.InvokeMethodOptions'/> containing additional options for the execution of the method.</param>
		/// <returns>
		/// <para>A <see cref='System.Management.ManagementBaseObject'/> containing the
		///    output parameters and return value of the executed method.</para>
		/// </returns>
		/// <example>
		///    <code lang='C#'>using System;
		/// using System.Management;
		/// 
		/// // This sample demonstrates invoking a WMI method using parameter objects
		/// public class InvokeMethod 
		/// {    
		///     public static void Main() 
		///     {
		/// 
		///         //Get the object on which the method will be invoked
		///         ManagementClass processClass = new ManagementClass("Win32_Process");
		/// 
		///         //Get an input parameters object for this method
		///         ManagementBaseObject inParams = processClass.GetMethodParameters("Create");
		/// 
		///         //Fill in input parameter values
		///         inParams["CommandLine"] = "calc.exe";
		/// 
		///         //Execute the method
		///         ManagementBaseObject outParams = processClass.InvokeMethod ("Create", inParams, null);
		/// 
		///         //Display results
		///         //Note: The return code of the method is provided in the "returnValue" property of the outParams object
		///         Console.WriteLine("Creation of calculator process returned: " + outParams["returnValue"]);
		///         Console.WriteLine("Process ID: " + outParams["processId"]);
		///    }
		/// }
		///    </code>
		///    <code lang='VB'>
		/// Imports System
		/// Imports System.Management
		/// 
		/// ' This sample demonstrates invoking a WMI method using parameter objects
		/// Class InvokeMethod
		///     Public Overloads Shared Function Main(ByVal args() As String) As Integer
		/// 
		///         ' Get the object on which the method will be invoked
		///         Dim processClass As New ManagementClass("Win32_Process")
		/// 
		///          ' Get an input parameters object for this method
		///         Dim inParams As ManagementBaseObject = processClass.GetMethodParameters("Create")
		/// 
		///         ' Fill in input parameter values
		///         inParams("CommandLine") = "calc.exe"
		/// 
		///         ' Execute the method
		///         Dim outParams As ManagementBaseObject = processClass.InvokeMethod("Create", inParams, Nothing)
		/// 
		///         ' Display results
		///         ' Note: The return code of the method is provided in the "returnValue" property of the outParams object
		///         Console.WriteLine("Creation of calculator process returned: {0}", outParams("returnValue"))
		///         Console.WriteLine("Process ID: {0}", outParams("processId"))
		/// 
		///         Return 0
		///     End Function
		/// End Class
		///    </code>
		/// </example>
		public ManagementBaseObject InvokeMethod(
			string methodName, 
			ManagementBaseObject inParameters, 
			InvokeMethodOptions options)
		{
			ManagementBaseObject outParameters = null;
			
			if ((null == path) || (String.Empty == path.Path))
				throw new InvalidOperationException();
			else if (null == methodName)
				throw new ArgumentNullException("methodName");
			else
			{
				Initialize ( false ) ;
				InvokeMethodOptions o = (null != options) ? options : new InvokeMethodOptions();
				IWbemServices wbemServices = scope.GetIWbemServices();

				SecurityHandler securityHandler = null;
				int status						= (int)ManagementStatus.NoError;

				try
				{
					securityHandler = scope.GetSecurityHandler();

					IWbemClassObjectFreeThreaded inParams = (null == inParameters) ? null : inParameters.wbemObject;
					IWbemClassObjectFreeThreaded outParams = null;

					status = scope.GetIWbemServices().ExecMethod_(
						path.RelativePath, 
						methodName,
						o.Flags, 
						o.GetContext(),
						inParams,
						out outParams,
						IntPtr.Zero);

					if (status < 0)
					{
						if ((status & 0xfffff000) == 0x80041000)
							ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
						else
							Marshal.ThrowExceptionForHR(status);
					}

					outParameters = new ManagementBaseObject(outParams);
				} 
				finally
				{
					if (securityHandler != null)
						securityHandler.Reset();
				}
			}

			return outParameters;
		}

		/// <summary>
		///    <para>Invokes a method on the object, asynchronously.</para>
		/// </summary>
		/// <param name='watcher'>A <see cref='System.Management.ManagementOperationObserver'/> used to handle the asynchronous execution's progress and results.</param>
		/// <param name=' methodName'>The name of the method to be executed.</param>
		/// <param name=' inParameters'><para>A <see cref='System.Management.ManagementBaseObject'/> containing the input parameters for the method.</para></param>
		/// <param name=' options'>An <see cref='System.Management.InvokeMethodOptions'/> containing additional options used to execute the method.</param>
		/// <remarks>
		///    <para>The method invokes the specified method execution and then 
		///       returns. Progress and results are reported through events on the <see cref='System.Management.ManagementOperationObserver'/>.</para>
		/// </remarks>
		public void InvokeMethod(
			ManagementOperationObserver watcher, 
			string methodName, 
			ManagementBaseObject inParameters, 
			InvokeMethodOptions options)
		{
			if ((null == path) || (String.Empty == path.Path))
				throw new InvalidOperationException();
			else if (null == watcher)
				throw new ArgumentNullException("watcher");
			else if (null == methodName)
				throw new ArgumentNullException("methodName");
			else
			{
				Initialize ( false ) ;
				InvokeMethodOptions o = (null != options) ? 
					(InvokeMethodOptions) options.Clone() : new InvokeMethodOptions();

				// If someone has registered for progress, make sure we flag it
				if (watcher.HaveListenersForProgress)
					o.SendStatus = true;
	
				WmiEventSink sink = watcher.GetNewSink(scope, o.Context);

				SecurityHandler securityHandler = null;
				int status						= (int)ManagementStatus.NoError;

				securityHandler = scope.GetSecurityHandler();

				IWbemClassObjectFreeThreaded inParams = null;

				if (null != inParameters)
					inParams = inParameters.wbemObject;

				status = scope.GetIWbemServices().ExecMethodAsync_(
					path.RelativePath, 
					methodName,
					o.Flags, 
					o.GetContext(),
					inParams,
					sink.Stub);

				if (securityHandler != null)
					securityHandler.Reset();

				if (status < 0)
				{
					watcher.RemoveSink(sink);
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}
			}
		}
        
		//******************************************************
		//GetMethodParameters
		//******************************************************
		/// <summary>
		/// <para>Returns a <see cref='System.Management.ManagementBaseObject'/> representing the list of input parameters for a method.</para>
		/// </summary>
		/// <param name='methodName'>The name of the method. </param>
		/// <returns>
		/// <para>A <see cref='System.Management.ManagementBaseObject'/> containing the
		///    input parameters to the method.</para>
		/// </returns>
		/// <remarks>
		///    <para> Gets the object containing the input parameters to a 
		///       method, and then fills in the values and passes the object to the <see cref='System.Management.ManagementObject.InvokeMethod'/>() call.</para>
		/// </remarks>
		public ManagementBaseObject GetMethodParameters(
			string methodName)
		{
			ManagementBaseObject inParameters;
			IWbemClassObjectFreeThreaded dummy1, dummy2;
				
			GetMethodParameters(methodName, out inParameters, out dummy1, out dummy2);

			return inParameters;
		}

		private void GetMethodParameters(
			string methodName,
			out ManagementBaseObject inParameters,
			out IWbemClassObjectFreeThreaded inParametersClass,
			out IWbemClassObjectFreeThreaded outParametersClass)
		{
			inParameters = null;
			inParametersClass = null;
			outParametersClass = null;

			if (null == methodName)
				throw new ArgumentNullException("methodName");
			else
			{
				Initialize ( false ) ;

				// Do we have the class?
				if (null == wmiClass)
				{
					ManagementPath classPath = ClassPath;

					if ((null == classPath) || !(classPath.IsClass))
						throw new InvalidOperationException();
					else 
					{
						ManagementClass classObject = 
							new ManagementClass(scope, classPath, null);
						classObject.Get();
						wmiClass = classObject.wbemObject;
					}
				}

				int status = (int)ManagementStatus.NoError;

				// Ask it for the method parameters
				status = wmiClass.GetMethod_(methodName, 0, out inParametersClass, out outParametersClass);

                // bug#92427 - To ensure that all forms of invoke return the same error codes when
                // the method does not exist, we will map WBEM_E_NOT_FOUND to WBEM_E_METHOD_NOT_IMPLEMENTED.
                if(status == (int)tag_WBEMSTATUS.WBEM_E_NOT_FOUND)
                    status = (int)tag_WBEMSTATUS.WBEM_E_METHOD_NOT_IMPLEMENTED;

				if (status >= 0)
				{
					// Hand out instances
					if (inParametersClass != null)
					{
						IWbemClassObjectFreeThreaded inParamsInstance = null;
						status = inParametersClass.SpawnInstance_(0, out inParamsInstance);

						if (status >= 0)
						{
							inParameters = new ManagementBaseObject(inParamsInstance);
						}
					}
				} 

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}
			}
		}

		/// <summary>
		///    <para>Creates a copy of the object.</para>
		/// </summary>
		/// <returns>
		///    <para>The copied object.</para>
		/// </returns>
		public override Object Clone()
		{
			if (PutButNotGot)
			{
				Get();
				PutButNotGot = false;
			}

			//
			// Removed Initialize call since wbemObject is a property that will call Initialize ( true ) on
			// its getter.
			//
			// Initialize ( ) ;

			IWbemClassObjectFreeThreaded theClone = null;

			int status = wbemObject.Clone_(out theClone);

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}

			return ManagementObject.GetManagementObject(theClone, this);
		}

		//******************************************************
		//ToString
		//******************************************************
		/// <summary>
		///    <para>Returns the full path of the object. This is an override of the
		///       default object implementation.</para>
		/// </summary>
		/// <returns>
		///    <para> The full path of
		///       the object.</para>
		/// </returns>
		public override string ToString()
		{
			if (null != path)
				return path.Path;
			else
				return "";
		}

		//
		// The prototype of Initialize has been changed to accept a bool, indicating whether or not
		// the caller wants to bind to the underlying WMI object in the Initialize call or not.
		//
		internal override void Initialize( bool getObject )
		{
			bool needToGetObject = false;

			//If we're not connected yet, this is the time to do it... We lock
			//the state to prevent 2 threads simultaneously doing the same
			//connection
			lock (this)
			{
				// Make sure we have some kind of path if we get here. Note that
				// we don't use a set to the Path property since that would trigger
				// an IdentifierChanged event
				if (null == path)
				{
					path = new ManagementPath();
					path.IdentifierChanged += new IdentifierChangedEventHandler(HandleIdentifierChange);
				}

				//Have we already got this object
				if (!IsBound && ( getObject == true ) )
					needToGetObject = true;

				if (null == scope)
				{
					// If our object has a valid namespace path, use that
					string nsPath = path.GetNamespacePath((int)tag_WBEM_GET_TEXT_FLAGS.WBEMPATH_GET_SERVER_AND_NAMESPACE_ONLY);

					// Set the scope - note that we do not set through
					// the Scope property since that would trigger an IdentifierChanged
					// event and reset isBound to false.
					if (0 < nsPath.Length)
						scope = new ManagementScope(nsPath);
					else
					{
						// Use the default constructor
						scope = new ManagementScope();
					}

					// Hook ourselves up to this scope for future change notifications
					scope.IdentifierChanged += new IdentifierChangedEventHandler(HandleIdentifierChange);
				}
				else if ((null == scope.Path) || scope.Path.IsEmpty)
				{
					// We have a scope but an empty path - use the object's path or the default
					string nsPath = path.GetNamespacePath((int)tag_WBEM_GET_TEXT_FLAGS.WBEMPATH_GET_SERVER_AND_NAMESPACE_ONLY);

					if (0 < nsPath.Length)
						scope.Path = new ManagementPath(nsPath);
					else
						scope.Path = ManagementPath.DefaultPath;
				}
			
				lock (scope)
				{
					if (!scope.IsConnected)
					{
						scope.Initialize(); 

						// If we have just connected, make sure we get the object
						if ( getObject == true )
						{
							needToGetObject = true;
						}
					}

					if (needToGetObject)
					{
						// If we haven't set up any options yet, now is the time.
						// Again we don't use the set to the Options property
						// since that would trigger an IdentifierChangedEvent and
						// force isBound=false.
						if (null == options)
						{
							options = new ObjectGetOptions();
							options.IdentifierChanged += new IdentifierChangedEventHandler(HandleIdentifierChange);
						}

						IWbemClassObjectFreeThreaded tempObj = null;
						IWbemServices wbemServices = scope.GetIWbemServices();

						SecurityHandler securityHandler = null;
						int status						= (int)ManagementStatus.NoError;

						try
						{
							securityHandler = scope.GetSecurityHandler();

							string objectPath = null;
							string curPath = path.RelativePath;

							if (String.Empty != curPath)
								objectPath = curPath;
							status = wbemServices.GetObject_(objectPath, options.Flags, options.GetContext(), out tempObj, IntPtr.Zero);

							if (status >= 0)
							{
								wbemObject = tempObj;

								// Getting the object succeeded, we are bound
								//
								// ***
								// *	Changed isBound flag to wbemObject==null check.
								// *	isBound = true;
								// ***

								// now set the path from the "real" object
								object val = null;
								int dummy1 = 0, dummy2 = 0;

								status = wbemObject.Get_("__PATH", 0, ref val, ref dummy1, ref dummy2);

								if (status >= 0)
								{
									path = (System.DBNull.Value != val) ? (new ManagementPath((string)val)) : (new ManagementPath ());
									path.IdentifierChanged += new IdentifierChangedEventHandler(HandleIdentifierChange);
								}
							}

							if (status < 0)
							{
								if ((status & 0xfffff000) == 0x80041000)
									ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
								else
									Marshal.ThrowExceptionForHR(status);
							}
						}
						finally
						{
							if (securityHandler != null)
								securityHandler.Reset();
						}
					}
				}
			}
		}


		private void MapInParameters(
			object [] args, 
			ManagementBaseObject inParams,
			IWbemClassObjectFreeThreaded inParamsClass)
		{
			int status = (int)ManagementStatus.NoError;

			if (null != inParamsClass)
			{
				if ((null != args) && (0 < args.Length))
				{
					int maxIndex = args.GetUpperBound(0);
					int minIndex = args.GetLowerBound(0);
					int topId = maxIndex - minIndex;

					/*
					 * Iterate through the [in] parameters of the class to find
					 * the ID positional qualifier. We do this in the class because
					 * we cannot be sure that the qualifier will be propagated to
					 * the instance.
					 */

					status = inParamsClass.BeginEnumeration_
							((int)tag_WBEM_CONDITION_FLAG_TYPE.WBEM_FLAG_NONSYSTEM_ONLY);

					if (status >= 0)
					{
						while (true) 
						{
							object						  val = null;
							int							  dummy = 0;
							string						  propertyName = null;
							IWbemQualifierSetFreeThreaded qualifierSet = null;

							status = inParamsClass.Next_(0, ref propertyName, ref val, ref dummy, ref dummy);

							if (status >= 0)
							{
								if (null == propertyName)
									break;

								status = inParamsClass.GetPropertyQualifierSet_(propertyName, out qualifierSet);

								if (status >= 0)
								{
									object id = 0;
									qualifierSet.Get_(ID, 0, ref id, ref dummy);	// Errors intentionally ignored.
					
									// If the id is in range, map the value into the args array
									int idIndex = (int)id;
									if ((0 <= idIndex) && (topId >= idIndex))
										inParams[propertyName] = args [minIndex + idIndex];

									// Dispose for next iteration.
									qualifierSet.Dispose();
								}
							}

							if (status < 0)
							{
								break;
							}
						}
					}

					if (status < 0)
					{
						if ((status & 0xfffff000) == 0x80041000)
							ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
						else
							Marshal.ThrowExceptionForHR(status);
					}
				}
			}
		}

		private object MapOutParameters(
			object [] args, 
			ManagementBaseObject outParams,
			IWbemClassObjectFreeThreaded outParamsClass)
		{
			object result = null;
			int maxIndex = 0, minIndex = 0, topId = 0;

			int status = (int)ManagementStatus.NoError;

			if (null != outParamsClass)
			{
				if ((null != args) && (0 < args.Length))
				{
					maxIndex = args.GetUpperBound(0);
					minIndex = args.GetLowerBound(0);
					topId = maxIndex - minIndex;
				}
				/*
					* Iterate through the [out] parameters of the class to find
					* the ID positional qualifier. We do this in the class because
					* we cannot be sure that the qualifier will be propagated to
					* the instance.
				*/

				status = outParamsClass.BeginEnumeration_ 
					((int)tag_WBEM_CONDITION_FLAG_TYPE.WBEM_FLAG_NONSYSTEM_ONLY);

				if (status >= 0)
				{
					while (true) 
					{
						object						  val = null;
						int							  dummy = 0;
						string						  propertyName = null;
						IWbemQualifierSetFreeThreaded qualifierSet = null;

						status = outParamsClass.Next_(0, ref propertyName, ref val, ref dummy, ref dummy);

						if (status >= 0)
						{
							if (null == propertyName)
								break;

							// Handle the result parameter separately
							if (propertyName.ToUpper(CultureInfo.InvariantCulture) == RETURNVALUE)
							{
								result = outParams[RETURNVALUE];
							}
							else  // Shouldn't get here if no args!
							{
								status = outParamsClass.GetPropertyQualifierSet_(propertyName, out qualifierSet);

								if (status >= 0)
								{
									object id = 0;
									qualifierSet.Get_(ID, 0, ref id, ref dummy);	// Errors intentionally ignored.
				
									// If the id is in range, map the value into the args array
									int idIndex = (int)id;
									if ((0 <= idIndex) && (topId >= idIndex))
										args [minIndex + idIndex] = outParams[propertyName];

									// Dispose for next iteration.
									qualifierSet.Dispose();
								}
							}
						}

						if (status < 0)
						{
							break;
						}
					}
				}

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}
			}

			return result; 
		}

	}//ManagementObject
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\managementobjectsearcher.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Collections;
using System.Runtime.InteropServices;
using WbemClient_v1;
using System.Diagnostics;
using System.ComponentModel;

namespace System.Management
{

	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para> Retrieves a collection of management objects based
	///       on a specified query.</para>
	///    <para>This class is one of the more commonly used entry points to retrieving 
	///       management information. For example, it can be used to enumerate all disk
	///       drives, network adapters, processes and many more management objects on a
	///       system, or to query for all network connections that are up, services that are
	///       paused etc. </para>
	///    <para>When instantiated, an instance of this class takes as input a WMI 
	///       query represented in an <see cref='System.Management.ObjectQuery'/> or it's derivatives, and optionally a <see cref='System.Management.ManagementScope'/> representing the WMI namespace
	///       to execute the query in. It can also take additional advanced
	///       options in an <see cref='System.Management.EnumerationOptions'/> object. When the Get() method on this object
	///       is invoked, the ManagementObjectSearcher executes the given query in the
	///       specified scope and returns a collection of management objects that match the
	///       query in a <see cref='System.Management.ManagementObjectCollection'/>.</para>
	/// </summary>
	/// <example>
	///    <code lang='C#'>using System;
	/// using System.Management;
	/// 
	/// // This sample demonstrates perform a query using
	/// // ManagementObjectSearcher object.
	/// class Sample_ManagementObjectSearcher
	/// {
	///     public static int Main(string[] args) {
	///         ManagementObjectSearcher searcher = new 
	///             ManagementObjectSearcher("select * from win32_share");
	///         foreach (ManagementObject share in searcher.Get()) {
	///             Console.WriteLine("Share = " + share["Name"]);
	///         }
	///         return 0;
	///     }
	/// }
	///    </code>
	///    <code lang='VB'>Imports System
	/// Imports System.Management
	/// 
	/// ' This sample demonstrates perform a query using
	/// ' ManagementObjectSearcher object.
	/// Class Sample_ManagementObjectSearcher
	///     Overloads Public Shared Function Main(args() As String) As Integer
	///         Dim searcher As New ManagementObjectSearcher("SELECT * FROM Win32_Share")
	///         Dim share As ManagementObject
	///         For Each share In searcher.Get()
	///             Console.WriteLine("Share = " &amp; share("Name").ToString())
	///         Next share
	///         Return 0
	///     End Function
	/// End Class
	///    </code>
	/// </example>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	[ToolboxItem(false)]
	public class ManagementObjectSearcher : Component
	{
		//fields
		private ManagementScope scope;
		private ObjectQuery query;
		private EnumerationOptions options;
		
		//default constructor
		/// <overload>
		///    Initializes a new instance of the <see cref='System.Management.ManagementObjectSearcher'/> class.
		/// </overload>
		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.ManagementObjectSearcher'/> class. After some properties on 
		///    this object are set, the object can be used to invoke a query for management information. This is the default
		///    constructor.</para>
		/// </summary>
		/// <example>
		///    <code lang='C#'>ManagementObjectSearcher s = new ManagementObjectSearcher();
		///    </code>
		///    <code lang='VB'>Dim s As New ManagementObjectSearcher()
		///    </code>
		/// </example>
		public ManagementObjectSearcher() : this((ManagementScope)null, null, null) {}
		
		//parameterized constructors
		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.ManagementObjectSearcher'/> class used 
		///    to invoke the specified query for management information.</para>
		/// </summary>
		/// <param name='queryString'>The WMI query to be invoked by the object.</param>
		/// <example>
		///    <code lang='C#'>ManagementObjectSearcher s = 
		///     new ManagementObjectSearcher("SELECT * FROM Win32_Service");
		///    </code>
		///    <code lang='VB'>Dim s As New ManagementObjectSearcher("SELECT * FROM Win32_Service")
		///    </code>
		/// </example>
		public ManagementObjectSearcher(string queryString) : this(null, new ObjectQuery(queryString), null) {}

		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.ManagementObjectSearcher'/> class used to invoke the 
		///    specified query for management information.</para>
		/// </summary>
		/// <param name='query'>An <see cref='System.Management.ObjectQuery'/> representing the query to be invoked by the searcher.</param>
		/// <example>
		///    <code lang='C#'>SelectQuery q = new SelectQuery("Win32_Service", "State='Running'");
		/// ManagementObjectSearcher s = new ManagementObjectSearcher(q);
		///    </code>
		///    <code lang='VB'>Dim q As New SelectQuery("Win32_Service", "State=""Running""")
		/// Dim s As New ManagementObjectSearcher(q)
		///    </code>
		/// </example>
		public ManagementObjectSearcher(ObjectQuery query) : this (null, query, null) {} 

		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.ManagementObjectSearcher'/> class used to invoke the
		///    specified query in the specified scope.</para>
		/// </summary>
		/// <param name='scope'>The scope in which to query.</param>
		/// <param name=' queryString'>The query to be invoked.</param>
		/// <remarks>
		/// <para>If no scope is specified, the default scope (<see cref='System.Management.ManagementPath.DefaultPath'/>) is used.</para>
		/// </remarks>
		/// <example>
		///    <code lang='C#'>ManagementObjectSearcher s = new ManagementObjectSearcher(
		///                                "root\\MyApp", 
		///                                "SELECT * FROM MyClass WHERE MyProp=5");
		///    </code>
		///    <code lang='VB'>Dim s As New ManagementObjectSearcher( _
		///                                "root\MyApp", _
		///                                "SELECT * FROM MyClass WHERE MyProp=5")
		///    </code>
		/// </example>
		public ManagementObjectSearcher(string scope, string queryString) : 
										this(new ManagementScope(scope), new ObjectQuery(queryString), null) {}

		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.ManagementObjectSearcher'/> class used to invoke the 
		///    specified query in the specified scope.</para>
		/// </summary>
		/// <param name='scope'>A <see cref='System.Management.ManagementScope'/> representing the scope in which to invoke the query.</param>
		/// <param name=' query'>An <see cref='System.Management.ObjectQuery'/> representing the query to be invoked.</param>
		/// <remarks>
		/// <para>If no scope is specified, the default scope (<see cref='System.Management.ManagementPath.DefaultPath'/>) is 
		///    used.</para>
		/// </remarks>
		/// <example>
		///    <code lang='C#'>ManagementScope myScope = new ManagementScope("root\\MyApp");
		/// SelectQuery q = new SelectQuery("Win32_Environment", "User=&lt;system&gt;");
		/// ManagementObjectSearcher s = new ManagementObjectSearcher(myScope,q);
		///    </code>
		///    <code lang='VB'>Dim myScope As New ManagementScope("root\MyApp")
		/// Dim q As New SelectQuery("Win32_Environment", "User=&lt;system&gt;")
		/// Dim s As New ManagementObjectSearcher(myScope,q)
		///    </code>
		/// </example>
		public ManagementObjectSearcher(ManagementScope scope, ObjectQuery query) : this(scope, query, null) {}

		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.ManagementObjectSearcher'/> class used to invoke the specified
		///    query, in the specified scope, and with the specified options.</para>
		/// </summary>
		/// <param name='scope'>The scope in which the query should be invoked.</param>
		/// <param name=' queryString'>The query to be invoked.</param>
		/// <param name=' options'>An <see cref='System.Management.EnumerationOptions'/> specifying additional options for the query.</param>
		/// <example>
		///    <code lang='C#'>ManagementObjectSearcher s = new ManagementObjectSearcher(
		///     "root\\MyApp", 
		///     "SELECT * FROM MyClass", 
		///     new EnumerationOptions(null, InfiniteTimeout, 1, true, false, true);
		///    </code>
		///    <code lang='VB'>Dim s As New ManagementObjectSearcher( _
		///     "root\MyApp", _
		///     "SELECT * FROM MyClass", _
		///     New EnumerationOptions(Null, InfiniteTimeout, 1, True, False, True)
		///    </code>
		/// </example>
		public ManagementObjectSearcher(string scope, string queryString, EnumerationOptions options) :
										this(new ManagementScope(scope), new ObjectQuery(queryString), options) {}
		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.ManagementObjectSearcher'/> class to be
		///    used to invoke the specified query in the specified scope, with the specified
		///    options.</para>
		/// </summary>
		/// <param name='scope'>A <see cref='System.Management.ManagementScope'/> specifying the scope of the query</param>
		/// <param name=' query'>An <see cref='System.Management.ObjectQuery'/> specifying the query to be invoked</param>
		/// <param name=' options'>An <see cref='System.Management.EnumerationOptions'/> specifying additional options to be used for the query.</param>
		/// <example>
		///    <code lang='C#'>ManagementScope scope = new ManagementScope("root\\MyApp");
		/// SelectQuery q = new SelectQuery("SELECT * FROM MyClass");
		/// EnumerationOptions o = new EnumerationOptions(null, InfiniteTimeout, 1, true, false, true);
		/// ManagementObjectSearcher s = new ManagementObjectSearcher(scope, q, o);
		///    </code>
		///    <code lang='VB'>Dim scope As New ManagementScope("root\MyApp")
		/// Dim q As New SelectQuery("SELECT * FROM MyClass")
		/// Dim o As New EnumerationOptions(Null, InfiniteTimeout, 1, True, False, True)
		/// Dim s As New ManagementObjectSearcher(scope, q, o)
		///    </code>
		/// </example>
		public ManagementObjectSearcher(ManagementScope scope, ObjectQuery query, EnumerationOptions options) 
		{
			this.scope = ManagementScope._Clone(scope);

			if (null != query)
				this.query = (ObjectQuery)query.Clone();
			else
				this.query = new ObjectQuery();

			if (null != options)
				this.options = (EnumerationOptions)options.Clone();
			else
				this.options = new EnumerationOptions();
		}

	
		//
		//Public Properties
		//

		/// <summary>
		///    <para>Gets or sets the scope in which to look for objects (the scope represents a WMI namespace).</para>
		/// </summary>
		/// <value>
		///    <para> The scope (namespace) in which to look for objects.</para>
		/// </value>
		/// <remarks>
		///    <para>When the value of this property is changed, 
		///       the <see cref='System.Management.ManagementObjectSearcher'/>
		///       is re-bound to the new scope.</para>
		/// </remarks>
		/// <example>
		///    <code lang='C#'>ManagementObjectSearcher s = new ManagementObjectSearcher();
		/// s.Scope = "root\\MyApp";
		///    </code>
		///    <code lang='VB'>Dim s As New ManagementObjectSearcher()
		/// s.Scope = "root\MyApp"
		///    </code>
		/// </example>
		public ManagementScope Scope 
		{
			get { 
				return scope; 
			} 
			set {
				if (null != value)
					scope = (ManagementScope) value.Clone ();
				else
					throw new ArgumentNullException ();
			}
		}

		/// <summary>
		///    <para> Gets or sets the query to be invoked in the
		///       searcher (that is, the criteria to be applied to the search for management objects).</para>
		/// </summary>
		/// <value>
		///    <para> The criteria to apply to the query.</para>
		/// </value>
		/// <remarks>
		/// <para>When the value of this property is changed, the <see cref='System.Management.ManagementObjectSearcher'/> 
		/// is reset to use the new query.</para>
		/// </remarks>
		public ObjectQuery Query 
		{
			get { 
				return query; 
			} 
			set { 
				if (null != value)
					query = (ObjectQuery)value.Clone ();
				else
					throw new ArgumentNullException ();
			}
		}

		/// <summary>
		///    <para>Gets or sets the options for how to search for objects.</para>
		/// </summary>
		/// <value>
		///    <para>The options for how to search for objects.</para>
		/// </value>
		public EnumerationOptions Options 
		{ 
			get { 
				return options; 
			} 
			set { 
				if (null != value)
					options = (EnumerationOptions) value.Clone ();
				else
					throw new ArgumentNullException();
			} 
		}

		//********************************************
		//Get()
		//********************************************
		/// <overload>
		///    Invokes the specified WMI query and returns the resulting collection.
		/// </overload>
		/// <summary>
		///    <para>Invokes the specified WMI query and returns the
		///       resulting collection.</para>
		/// </summary>
		/// <returns>
		/// <para>A <see cref='System.Management.ManagementObjectCollection'/> containing the objects that match the
		///    specified query.</para>
		/// </returns>
		public ManagementObjectCollection Get()
		{
			Initialize ();
			IEnumWbemClassObject ew = null;
			SecurityHandler securityHandler = scope.GetSecurityHandler();
			EnumerationOptions enumOptions = (EnumerationOptions)options.Clone();

			int status = (int)ManagementStatus.NoError;

			try {
				//If this is a simple SelectQuery (className only), and the enumerateDeep is set, we have
				//to find out whether this is a class enumeration or instance enumeration and call CreateInstanceEnum/
				//CreateClassEnum appropriately, because with ExecQuery we can't do a deep enumeration.
				if ((query.GetType() == typeof(SelectQuery)) && 
					(((SelectQuery)query).Condition == null) && 
					(((SelectQuery)query).SelectedProperties == null) &&
					(options.EnumerateDeep == true))
				{
					//Need to make sure that we're not passing invalid flags to enumeration APIs.
					//The only flags not valid for enumerations are EnsureLocatable & PrototypeOnly.
					enumOptions.EnsureLocatable = false; enumOptions.PrototypeOnly = false;
					
					if (((SelectQuery)query).IsSchemaQuery == false) //deep instance enumeration
						status = scope.GetIWbemServices().CreateInstanceEnum_(
								((SelectQuery)query).ClassName,
								enumOptions.Flags,
								enumOptions.GetContext(),
								out ew);
					else //deep class enumeration
						status = scope.GetIWbemServices().CreateClassEnum_(
								((SelectQuery)query).ClassName,
								enumOptions.Flags,
								enumOptions.GetContext(),
								out ew);
				}
				else //we can use ExecQuery
				{
					//Make sure the EnumerateDeep flag bit is turned off because it's invalid for queries
					enumOptions.EnumerateDeep = true;
					status = scope.GetIWbemServices().ExecQuery_(
														query.QueryLanguage,
														query.QueryString,
														enumOptions.Flags, 
														enumOptions.GetContext(),
														out ew);
				}

				//Set security on the enumerator
				if ((status & 0x80000000) == 0)
				{
					securityHandler.Secure (ew);
				}
			}	catch (Exception e) {
				// BUGBUG : securityHandler.Reset()?
				ManagementException.ThrowWithExtendedInfo(e);
			} finally {
				securityHandler.Reset();
			}

			if ((status & 0xfffff000) == 0x80041000)
			{
				ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
			}
			else if ((status & 0x80000000) != 0)
			{
				Marshal.ThrowExceptionForHR(status);
			}

			//Create a new collection object for the results

			return new ManagementObjectCollection(scope, options, ew);
		}//Get()


		//********************************************
		//Get() asynchronous
		//********************************************
		/// <summary>
		///    <para>Invokes the WMI query, asynchronously, and binds to a watcher to deliver the results.</para>
		/// </summary>
		/// <param name='watcher'>The watcher that raises events triggered by the operation. </param>
		public void Get(ManagementOperationObserver watcher)
		{
			if (null == watcher)
				throw new ArgumentNullException ("watcher");

			Initialize ();
			IWbemServices wbemServices = scope.GetIWbemServices ();
			
			EnumerationOptions enumOptions = (EnumerationOptions)options.Clone();
			// Ensure we switch off ReturnImmediately as this is invalid for async calls
			enumOptions.ReturnImmediately = false;
			// If someone has registered for progress, make sure we flag it
			if (watcher.HaveListenersForProgress)
				enumOptions.SendStatus = true;

			WmiEventSink sink = watcher.GetNewSink (scope, enumOptions.Context);
			SecurityHandler securityHandler = scope.GetSecurityHandler();

			int status = (int)ManagementStatus.NoError;

			try {
				//If this is a simple SelectQuery (className only), and the enumerateDeep is set, we have
				//to find out whether this is a class enumeration or instance enumeration and call CreateInstanceEnum/
				//CreateClassEnum appropriately, because with ExecQuery we can't do a deep enumeration.
				if ((query.GetType() == typeof(SelectQuery)) && 
					(((SelectQuery)query).Condition == null) && 
					(((SelectQuery)query).SelectedProperties == null) &&
					(options.EnumerateDeep == true))
				{
					//Need to make sure that we're not passing invalid flags to enumeration APIs.
					//The only flags not valid for enumerations are EnsureLocatable & PrototypeOnly.
					enumOptions.EnsureLocatable = false; enumOptions.PrototypeOnly = false;
					
					if (((SelectQuery)query).IsSchemaQuery == false) //deep instance enumeration
						status = wbemServices.CreateInstanceEnumAsync_(
							((SelectQuery)query).ClassName, 
							enumOptions.Flags, 
							enumOptions.GetContext(), 
							sink.Stub);
					else	
						status = wbemServices.CreateClassEnumAsync_(
							((SelectQuery)query).ClassName, 
							enumOptions.Flags, 
							enumOptions.GetContext(), 
							sink.Stub);
				}
				else //we can use ExecQuery
				{
					//Make sure the EnumerateDeep flag bit is turned off because it's invalid for queries
					enumOptions.EnumerateDeep = true;

					status = wbemServices.ExecQueryAsync_(
							query.QueryLanguage, 
							query.QueryString, 
							enumOptions.Flags, 
							enumOptions.GetContext(), 
							sink.Stub);
				}
			} catch (Exception e) {
				// BUGBUG : securityHandler.Reset()?
				watcher.RemoveSink (sink);
				ManagementException.ThrowWithExtendedInfo (e);
			} finally {
				securityHandler.Reset();
			}

			if ((status & 0xfffff000) == 0x80041000)
			{
				ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
			}
			else if ((status & 0x80000000) != 0)
			{
				Marshal.ThrowExceptionForHR(status);
			}
		}


		private void Initialize()
		{
			//If the query is not set yet we can't do it
			if (null == query)
				throw new InvalidOperationException();

			//If we're not connected yet, this is the time to do it...
			lock (this)
			{
				if (null == scope)
					scope = ManagementScope._Clone(null);
			}

			lock (scope)
			{
				if (!scope.IsConnected)
					scope.Initialize();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\managementoperationwatcher.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using WbemClient_v1;

namespace System.Management
{

	/// <summary>
	/// <para>Represents the method that will handle the <see cref='E:System.Management.ManagementOperationObserver.ObjectReady'/> event.</para>
	/// </summary>
	public delegate void ObjectReadyEventHandler(object sender, ObjectReadyEventArgs e);

	/// <summary>
	/// <para>Represents the method that will handle the <see cref='E:System.Management.ManagementOperationObserver.Completed'/> event.</para>
	/// </summary>
	public delegate void CompletedEventHandler (object sender, CompletedEventArgs e);

	/// <summary>
	/// <para>Represents the method that will handle the <see cref='E:System.Management.ManagementOperationObserver.Progress'/> event.</para>
	/// </summary>
	public delegate void ProgressEventHandler (object sender, ProgressEventArgs e);

	/// <summary>
	/// <para>Represents the method that will handle the <see cref='E:System.Management.ManagementOperationObserver.ObjectPut'/> event.</para>
	/// </summary>
	public delegate void ObjectPutEventHandler(object sender, ObjectPutEventArgs e);

	/// <summary>
	///    <para>Used to manage asynchronous operations and handle management information and events received asynchronously.</para>
	/// </summary>
	/// <example>
	///    <code lang='C#'>using System; 
	/// using System.Management; 
	/// 
	/// // This sample demonstrates how to read a ManagementObject asychronously 
	/// // using the ManagementOperationObserver object. 
	/// 
	/// class Sample_ManagementOperationObserver {
	///     public static int Main(string[] args) {
	/// 
	///         //Set up a handler for the asynchronous callback
	///         ManagementOperationObserver observer = new ManagementOperationObserver(); 
	///         MyHandler completionHandler = new MyHandler(); 
	///         observer.Completed += new CompletedEventHandler(completionHandler.Done); 
	/// 
	///         //Invoke the asynchronous read of the object
	///         ManagementObject disk = new ManagementObject("Win32_logicaldisk='C:'"); 
	///         disk.Get(observer); 
	/// 
	///         //For the purpose of this sample, we keep the main 
	///         // thread alive until the asynchronous operation is completed. 
	/// 
	///         while (!completionHandler.IsComplete) { 
	///             System.Threading.Thread.Sleep(500); 
	///         } 
	/// 
	///         Console.WriteLine("Size= " + disk["Size"] + " bytes."); 
	/// 
	///         return 0; 
	///     } 
	/// 
	///     public class MyHandler 
	///     {
	///         private bool isComplete = false;
	///  
	///         public void Done(object sender, CompletedEventArgs e) { 
	///             isComplete = true;
	///         }
	/// 
	///         public bool IsComplete {
	///             get {
	///                 return isComplete;
	///             }
	///         }
	///     }
	/// }
	///    </code>
	///    <code lang='VB'>Imports System
	/// Imports System.Management
	/// 
	/// ' This sample demonstrates how to read a ManagementObject asychronously
	/// ' using the ManagementOperationObserver object.
	/// 
	/// Class Sample_ManagementOperationObserver
	///     Overloads Public Shared Function Main(args() As String) As Integer
	/// 
	///         'Set up a handler for the asynchronous callback
	///         Dim observer As New ManagementOperationObserver()
	///         Dim completionHandler As New MyHandler()
	///         AddHandler observer.Completed, AddressOf completionHandler.Done
	///       
	///         ' Invoke the object read asynchronously
	///         Dim disk As New ManagementObject("Win32_logicaldisk='C:'")
	///         disk.Get(observer)
	/// 
	///         ' For the purpose of this sample, we keep the main
	///         ' thread alive until the asynchronous operation is finished.
	///         While Not completionHandler.IsComplete Then
	///             System.Threading.Thread.Sleep(500)
	///         End While
	///        
	///         Console.WriteLine("Size = " + disk("Size").ToString() &amp; " bytes")
	///       
	///         Return 0
	///     End Function
	/// 
	///     Public Class MyHandler
	///         Private _isComplete As Boolean = False
	///    
	///         Public Sub Done(sender As Object, e As CompletedEventArgs)
	///             _isComplete = True
	///         End Sub 'Done
	/// 
	///         Public ReadOnly Property IsComplete() As Boolean
	///             Get
	///                 Return _isComplete
	///             End Get
	///         End Property
	///     End Class
	/// End Class
	///    </code>
	/// </example>
	public class ManagementOperationObserver 
	{
		private Hashtable m_sinkCollection;
		private WmiDelegateInvoker delegateInvoker;
		
		/// <summary>
		///    <para> Occurs when a new object is available.</para>
		/// </summary>
		public event ObjectReadyEventHandler		ObjectReady;

		/// <summary>
		///    <para> Occurs when an operation has completed.</para>
		/// </summary>
		public event CompletedEventHandler			Completed;

		/// <summary>
		///    <para> Occurs to indicate the progress of an ongoing operation.</para>
		/// </summary>
		public event ProgressEventHandler			Progress;

		/// <summary>
		///    <para> Occurs when an object has been successfully committed.</para>
		/// </summary>
		public event ObjectPutEventHandler			ObjectPut;

		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.ManagementOperationObserver'/> class. This is the default constructor.</para>
		/// </summary>
		public ManagementOperationObserver () 
		{
			// We make our sink collection synchronized
			m_sinkCollection = new Hashtable ();
			delegateInvoker = new WmiDelegateInvoker (this);
		}

		/// <summary>
		///    <para> Cancels all outstanding operations.</para>
		/// </summary>
		public void Cancel () 
		{
			// Cancel all the sinks we have - make a copy to avoid things
			// changing under our feet
			Hashtable copiedSinkTable =  new Hashtable ();

			lock (m_sinkCollection) {
				// TODO - the MemberwiseClone method should be used here
				IDictionaryEnumerator sinkEnum = m_sinkCollection.GetEnumerator();

				try {
					sinkEnum.Reset ();
					
					while (sinkEnum.MoveNext ()) {
						DictionaryEntry entry = (DictionaryEntry) sinkEnum.Current;
						copiedSinkTable.Add (entry.Key, entry.Value);
					}
				} catch {}
			}

			// Now step through the copy and cancel everything
			try {
				IDictionaryEnumerator copiedSinkEnum = copiedSinkTable.GetEnumerator();
				copiedSinkEnum.Reset ();

				while (copiedSinkEnum.MoveNext ())
				{
					DictionaryEntry entry = (DictionaryEntry) copiedSinkEnum.Current;
					WmiEventSink eventSink = (WmiEventSink) entry.Value;

					try {
						eventSink.Cancel ();
					} catch {}
				}
			} catch {}
		}

		internal WmiEventSink GetNewSink (
						ManagementScope scope, 
						object context) 
		{
			try {
				WmiEventSink eventSink = WmiEventSink.GetWmiEventSink(this, context, scope, null, null);
		
				// Add it to our collection
				lock (m_sinkCollection) {
					m_sinkCollection.Add (eventSink.GetHashCode(), eventSink);
				}

				return eventSink;
			} catch {
				return null;
			}
		}

		internal bool HaveListenersForProgress 
		{
			get 
			{
				bool result = false;

				try {
					if (Progress != null)
						result = ((Progress.GetInvocationList ()).Length > 0);
				} catch (Exception) { }

				return result;
			}
		}
		internal WmiEventSink GetNewPutSink (
						ManagementScope scope, 
						object context,
						string path,
						string className) 
		{
			try {
				WmiEventSink eventSink = WmiEventSink.GetWmiEventSink(this, context, scope, path, className);
		
				// Add it to our collection
				lock (m_sinkCollection) {
					m_sinkCollection.Add (eventSink.GetHashCode(), eventSink);
				}

				return eventSink;
			} catch {
				return null;
			}
		}

		internal WmiGetEventSink GetNewGetSink (
							ManagementScope scope,
							object context,
							ManagementObject managementObject)
		{
			try {
				WmiGetEventSink eventSink = WmiGetEventSink.GetWmiGetEventSink(this, 
									context, scope, managementObject);
		
				// Add it to our collection
				lock (m_sinkCollection) {
					m_sinkCollection.Add (eventSink.GetHashCode(), eventSink);
				}

				return eventSink;
			} catch {
				return null;
			}
		}

		internal void RemoveSink (WmiEventSink eventSink)
		{
			try {
				lock (m_sinkCollection) {
					m_sinkCollection.Remove (eventSink.GetHashCode ());
				}

				// Release the stub as we are now disconnected
				eventSink.ReleaseStub ();
			} catch {}
		}

		/// <summary>
		/// Fires the ObjectReady event to whomsoever is listening
		/// </summary>
		/// <param name="args"> </param>
		internal void FireObjectReady (ObjectReadyEventArgs args)
		{
			try {
				delegateInvoker.FireEventToDelegates (ObjectReady, args);
			} catch {}
		}

		internal void FireCompleted (CompletedEventArgs args)
		{
			try {
				delegateInvoker.FireEventToDelegates (Completed, args);
			} catch {}
		}

		internal void FireProgress (ProgressEventArgs args)
		{
			try {
				delegateInvoker.FireEventToDelegates (Progress, args);
			} catch {}
		}

		internal void FireObjectPut (ObjectPutEventArgs args)
		{
			try {
				delegateInvoker.FireEventToDelegates (ObjectPut, args);
			} catch {}
		}
	}

	internal class WmiEventState 
	{
		private Delegate d;
		private ManagementEventArgs args;
		private AutoResetEvent h;

		internal WmiEventState (Delegate d, ManagementEventArgs args, AutoResetEvent h)
		{
			this.d = d;
			this.args = args;
			this.h = h;
		}

		public Delegate Delegate {
			get { return d; }
		}

		public ManagementEventArgs Args {
			get { return args; }
		}

		public AutoResetEvent AutoResetEvent {
			get { return h; }
		}
	}

	/// <summary>
	/// This class handles the posting of events to delegates. For each event
	/// it queues a set of requests (one per target delegate) to the thread pool
	/// to handle the event. It ensures that no single delegate can throw
	/// an exception that prevents the event from reaching any other delegates.
	/// It also ensures that the sender does not signal the processing of the
	/// WMI event as "done" until all target delegates have signalled that they are
	/// done.
	/// </summary>
	internal class WmiDelegateInvoker
	{
		internal object sender;

		internal WmiDelegateInvoker (object sender)
		{
			this.sender = sender;
		}

		/// <summary>
		/// Custom handler for firing a WMI event to a list of delegates. We use
		/// the process thread pool to handle the firing.
		/// </summary>
		/// <param name="md">The MulticastDelegate representing the collection
		/// of targets for the event</param>
		/// <param name="args">The accompanying event arguments</param>
		internal void FireEventToDelegates (MulticastDelegate md, ManagementEventArgs args)
		{
			try 
			{
				if (null != md)
				{
	#if USEPOOL
					Delegate[] delegateList = md.GetInvocationList ();

					if (null != delegateList)
					{
						int numDelegates = delegateList.Length;
						AutoResetEvent[] waitHandles = new AutoResetEvent [numDelegates];

						/*
						 * For each target delegate, queue a request to the 
						 * thread pool to handle the POST. We pass as state the 
						 *  1) Target delegate
						 *  2) Event args
						 *  3) AutoResetEvent that the thread should signal to 
						 *     indicate that it is done.
						 */
						for (int i = 0; i < numDelegates; i++)
						{
							waitHandles [i] = new AutoResetEvent (false);
							ThreadPool.QueueUserWorkItem (
									new WaitCallback (this.FireEventToDelegate),
									new WmiEventState (delegateList[i], args, waitHandles[i]));
						}

						/*
						 * We wait for all the delegates to signal that they are done.
						 * This is because if we return from the IWbemObjectSink callback
						 * before they are all done, it is possible that a delegate will
						 * begin to process the next callback before the current callback
						 * processing is done.
						 */
						WaitHandle.WaitAll (waitHandles, 10000, true);
						}
					}
	#endif
					foreach (Delegate d in md.GetInvocationList())
					{
						try {
							d.DynamicInvoke (new object [] {this.sender, args});	
						} catch {}
					}
				}
			}
			catch {}
		}

	#if USE_POOL
		/// <summary>
		/// This is the WaitCallback for firing an event from the thread pool
		/// </summary>
		/// <param name="state">Represents a WmiEventState object</param>
		internal void FireEventToDelegate (object state)
		{
			if (state is WmiEventState)
			{
				WmiEventState oState = (WmiEventState) state;

				try {
					oState.Delegate.DynamicInvoke (new object [] {this.sender, oState.Args});	
				} catch {}
				finally {
					// Signal that we are done
					oState.AutoResetEvent.Set();
				}
			}
		}
	#endif
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\managementobjectcollection.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Collections;
using System.Runtime.InteropServices;
using WbemClient_v1;
using System.ComponentModel;

namespace System.Management
{
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para> Represents different collections of management objects 
	///       retrieved through WMI. The objects in this collection are of <see cref='System.Management.ManagementBaseObject'/>-derived types, including <see cref='System.Management.ManagementObject'/> and <see cref='System.Management.ManagementClass'/>
	///       .</para>
	///    <para> The collection can be the result of a WMI 
	///       query executed through a <see cref='System.Management.ManagementObjectSearcher'/> object, or an enumeration of
	///       management objects of a specified type retrieved through a <see cref='System.Management.ManagementClass'/> representing that type.
	///       In addition, this can be a collection of management objects related in a specified
	///       way to a specific management object - in this case the collection would
	///       be retrieved through a method such as <see cref='System.Management.ManagementObject.GetRelated()'/>.</para>
	/// <para>The collection can be walked using the <see cref='System.Management.ManagementObjectCollection.ManagementObjectEnumerator'/> and objects in it can be inspected or 
	///    manipulated for various management tasks.</para>
	/// </summary>
	/// <example>
	///    <code lang='C#'>using System; 
	/// using System.Management; 
	/// 
	/// // This example demonstrates how to enumerate instances of a ManagementClass object.
	/// class Sample_ManagementObjectCollection 
	/// { 
	///     public static int Main(string[] args) { 
	///         ManagementClass diskClass = new ManagementClass("Win32_LogicalDisk");
	///         ManagementObjectCollection disks = diskClass.GetInstances(); 
	///         foreach (ManagementObject disk in disks) { 
	///             Console.WriteLine("Disk = " + disk["deviceid"]); 
	///         } 
	///         return 0;
	///     }
	/// }
	///    </code>
	///    <code lang='VB'>Imports System 
	/// Imports System.Management 
	/// 
	/// ' This example demonstrates how to enumerate instances of a ManagementClass object.
	/// Class Sample_ManagementObjectCollection 
	///     Overloads Public Shared Function Main(args() As String) As Integer 
	///         Dim diskClass As New ManagementClass("Win32_LogicalDisk") 
	///         Dim disks As ManagementObjectCollection = diskClass.GetInstances()
	///         Dim disk As ManagementObject
	///         For Each disk In disks
	///             Console.WriteLine("Disk = " &amp; disk("deviceid").ToString())
	///         Next disk
	///         Return 0
	///     End Function
	/// End Class
	///    </code>
	/// </example>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class ManagementObjectCollection : ICollection, IEnumerable, IDisposable
	{
		private static readonly string name = typeof(ManagementObjectCollection).FullName;

		// lockable wrapper around a boolean flag
		private class FirstEnum 
		{
			public bool firstEnum = true;
		}

		//fields
		private	FirstEnum firstEnum;
		internal ManagementScope scope;
		internal EnumerationOptions options;
		private IEnumWbemClassObject enumWbem; //holds WMI enumerator for this collection
		internal IWbemClassObjectFreeThreaded current; //points to current object in enumeration
		private bool isDisposed = false;

		//internal IWbemServices GetIWbemServices () {
		//	return scope.GetIWbemServices ();
		//}

		//internal ConnectionOptions Connection {
		//	get { return scope.Connection; }
		//}

		//Constructor
		internal ManagementObjectCollection(
			ManagementScope scope,
			EnumerationOptions options, 
			IEnumWbemClassObject enumWbem)
		{
			if (null != options)
				this.options = (EnumerationOptions) options.Clone();
			else
				this.options = new EnumerationOptions ();

			if (null != scope)
				this.scope = (ManagementScope)scope.Clone ();
			else
				this.scope = ManagementScope._Clone(null);

			this.enumWbem = enumWbem;
			current = null;
			firstEnum = new FirstEnum ();
		}

		/// <summary>
		/// <para>Disposes of resources the object is holding. This is the destructor for the object.</para>
		/// </summary>		
		~ManagementObjectCollection ()
		{
			try 
			{
				Dispose ( false );
			}
			finally 
			{
				// Nothing more to do.
			}
		}

		/// <summary>
		/// Releases resources associated with this object. After this
		/// method has been called, an attempt to use this object will
		/// result in an ObjectDisposedException being thrown.
		/// </summary>
		public void Dispose ()
		{
			if (!isDisposed)
			{
				Dispose ( true ) ;
			}
		}

		private void Dispose ( bool disposing )
		{
			if ( disposing )
			{
				 firstEnum.firstEnum = true;
				 GC.SuppressFinalize (this);
				 isDisposed = true;
			 }
			Marshal.ReleaseComObject (enumWbem);
		}


		//
		//ICollection properties & methods
		//

		/// <summary>
		///    <para>Represents the number of objects in the collection.</para>
		/// </summary>
		/// <value>
		///    <para>The number of objects in the collection.</para>
		/// </value>
		/// <remarks>
		///    <para>This property is very expensive - it requires that
		///    all members of the collection be enumerated.</para>
		/// </remarks>
		public int Count 
		{
			get
			{
				if (isDisposed)
					throw new ObjectDisposedException(name);
				
				int i = 0;
				foreach (ManagementBaseObject o in this)
					i++;

				return i;
			}
		}

		/// <summary>
		///    <para>Represents whether the object is synchronized.</para>
		/// </summary>
		/// <value>
		/// <para><see langword='true'/>, if the object is synchronized; 
		///    otherwise, <see langword='false'/>.</para>
		/// </value>
		public bool IsSynchronized 
		{
			get
			{
				if (isDisposed)
					throw new ObjectDisposedException(name);

				return false;
			}
		}

		/// <summary>
		///    <para>Represents the object to be used for synchronization.</para>
		/// </summary>
		/// <value>
		///    <para> The object to be used for synchronization.</para>
		/// </value>
		public Object SyncRoot 
		{ 
			get
			{
				if (isDisposed)
					throw new ObjectDisposedException(name);

				return this; 
			}
		}

		/// <overload>
		///    Copies the collection to an array.
		/// </overload>
		/// <summary>
		///    <para> Copies the collection to an array.</para>
		/// </summary>
		/// <param name='array'>An array to copy to. </param>
		/// <param name='index'>The index to start from. </param>
		public void CopyTo (Array array, Int32 index) 
		{
			if (isDisposed)
				throw new ObjectDisposedException(name);

			if (null == array)
				throw new ArgumentNullException ("array");

			if ((index < array.GetLowerBound (0)) || (index > array.GetUpperBound(0)))
				throw new ArgumentOutOfRangeException ("index");

			// Since we don't know the size until we've enumerated
			// we'll have to dump the objects in a list first then
			// try to copy them in.

			int capacity = array.Length - index;
			int numObjects = 0;
			ArrayList arrList = new ArrayList ();

			ManagementObjectEnumerator en = this.GetEnumerator();
			ManagementBaseObject obj;

			while (en.MoveNext())
			{
				obj = en.Current;

				arrList.Add(obj);
				numObjects++;

				if (numObjects > capacity)
					throw new ArgumentException ("index");
			}

			// If we get here we are OK. Now copy the list to the array
			arrList.CopyTo (array, index);

			return;
		}

		/// <summary>
		/// <para>Copies the items in the collection to a <see cref='System.Management.ManagementBaseObject'/> 
		/// array.</para>
		/// </summary>
		/// <param name='objectCollection'>The target array.</param>
		/// <param name=' index'>The index to start from.</param>
		public void CopyTo (ManagementBaseObject[] objectCollection, Int32 index)
		{
			CopyTo ((Array)objectCollection, index);
		}

		//
		//IEnumerable methods
		//

 		//****************************************
		//GetEnumerator
		//****************************************
		/// <summary>
		///    <para>Returns the enumerator for the collection.</para>
		/// </summary>
		/// <returns>
		///    An <see cref='System.Collections.IEnumerator'/>that can be used to iterate through the
		///    collection.
		/// </returns>
		public ManagementObjectEnumerator GetEnumerator()
		{
			if (isDisposed)
				throw new ObjectDisposedException(name);

			// Unless this is the first enumerator, we have
			// to clone. This may throw if we are non-rewindable.
			lock (firstEnum)
			{
				if (firstEnum.firstEnum)
				{
					firstEnum.firstEnum = false;
					return new ManagementObjectEnumerator(this, enumWbem);
				}
				else
				{
					IEnumWbemClassObject enumWbemClone = null;
					int status = (int)ManagementStatus.NoError;

					try {
						status = enumWbem.Clone_(out enumWbemClone);
						scope.GetSecurityHandler().Secure(enumWbemClone);

						if ((status & 0x80000000) == 0)
						{
							//since the original enumerator might not be reset, we need
							//to reset the new one.
							status = enumWbemClone.Reset_();
						}
					} catch (Exception e) {
						ManagementException.ThrowWithExtendedInfo (e);
					}

					if ((status & 0xfffff000) == 0x80041000)
					{
						// BUGBUG : release callResult.
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					}
					else if ((status & 0x80000000) != 0)
					{
						// BUGBUG : release callResult.
						Marshal.ThrowExceptionForHR(status);
					}

					return new ManagementObjectEnumerator (this, enumWbemClone);
				}
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator ();
		}

		

		//
		// ManagementObjectCollection methods
		//

		//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
		/// <summary>
		///    <para>Represents the enumerator on the collection.</para>
		/// </summary>
		/// <example>
		///    <code lang='C#'>using System; 
		/// using System.Management; 
		/// 
		/// // This example demonstrates how to enumerate all logical disks 
		/// // using the ManagementObjectEnumerator object. 
		/// class Sample_ManagementObjectEnumerator 
		/// {
		///     public static int Main(string[] args) { 
		///         ManagementClass diskClass = new ManagementClass("Win32_LogicalDisk");
		///         ManagementObjectCollection disks = diskClass.GetInstances();
		///         ManagementObjectCollection.ManagementObjectEnumerator disksEnumerator =
		///             disks.GetEnumerator();
		///         while(disksEnumerator.MoveNext()) { 
		///             ManagementObject disk = (ManagementObject)disksEnumerator.Current;
		///            Console.WriteLine("Disk found: " + disk["deviceid"]);
		///         }
		///         return 0;
		///     }
		/// }
		///    </code>
		///    <code lang='VB'>Imports System
		///       Imports System.Management
		///       ' This sample demonstrates how to enumerate all logical disks
		///       ' using ManagementObjectEnumerator object.
		///       Class Sample_ManagementObjectEnumerator
		///       Overloads Public Shared Function Main(args() As String) As Integer
		///       Dim diskClass As New ManagementClass("Win32_LogicalDisk")
		///       Dim disks As ManagementObjectCollection = diskClass.GetInstances()
		///       Dim disksEnumerator As _
		///       ManagementObjectCollection.ManagementObjectEnumerator = _
		///       disks.GetEnumerator()
		///       While disksEnumerator.MoveNext()
		///       Dim disk As ManagementObject = _
		///       CType(disksEnumerator.Current, ManagementObject)
		///       Console.WriteLine("Disk found: " &amp; disk("deviceid"))
		///       End While
		///       Return 0
		///       End Function
		///       End Class
		///    </code>
		/// </example>
		//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
		public class ManagementObjectEnumerator : IEnumerator, IDisposable
		{
			private static readonly string name = typeof(ManagementObjectEnumerator).FullName;
			private IEnumWbemClassObject enumWbem;
			private ManagementObjectCollection collectionObject;
			private uint cachedCount; //says how many objects are in the enumeration cache (when using BlockSize option)
			private int cacheIndex; //used to walk the enumeration cache
			private IWbemClassObjectFreeThreaded[] cachedObjects; //points to objects currently available in enumeration cache
			private bool atEndOfCollection;
			private bool isDisposed = false;

			//constructor
			internal ManagementObjectEnumerator(
				ManagementObjectCollection collectionObject,
				IEnumWbemClassObject enumWbem)
			{
				this.enumWbem = enumWbem;
				this.collectionObject = collectionObject;
				cachedObjects = new IWbemClassObjectFreeThreaded[collectionObject.options.BlockSize];
				cachedCount = 0; 
				cacheIndex = -1; // Reset position
				atEndOfCollection = false;
			}


			/// <summary>
			/// <para>Disposes of resources the object is holding. This is the destructor for the object.</para>
			/// </summary>		
			~ManagementObjectEnumerator ()
			{
				try 
				{
					Dispose ();
				}
				finally 
				{
					// Nothing more to do.
				}
			}


			/// <summary>
			/// Releases resources associated with this object. After this
			/// method has been called, an attempt to use this object will
			/// result in an ObjectDisposedException being thrown.
			/// </summary>
			public void Dispose ()
			{
				if (!isDisposed)
				{
					if (null != enumWbem)
					{
						Marshal.ReleaseComObject (enumWbem);
						enumWbem = null;
					}

					cachedObjects = null;

					// DO NOT dispose of collectionObject.  It is merely a reference - its lifetime
					// exceeds that of this object.  If collectionObject.Dispose was to be done here,
					// a reference count would be needed.
					//
					collectionObject = null;

					isDisposed = true;

					GC.SuppressFinalize (this);
				}
			}

			
			/// <summary>
			///    <para>Returns the current object in the
			///       enumeration.</para>
			/// </summary>
			/// <value>
			///    <para>The current object in the enumeration.</para>
			/// </value>
			public ManagementBaseObject Current 
			{
				get {
					if (isDisposed)
						throw new ObjectDisposedException(name);

					if (cacheIndex < 0)
						throw new InvalidOperationException();

					return ManagementBaseObject.GetBaseObject (cachedObjects[cacheIndex],
						collectionObject.scope);
				}
			}

			object IEnumerator.Current {
				get {
					return Current;
				}
			}

 			//****************************************
			//MoveNext
			//****************************************
			/// <summary>
			///    Indicates whether the enumerator has moved to
			///    the next object in the enumeration.
			/// </summary>
			/// <returns>
			/// <para><see langword='true'/>, if the enumerator was 
			///    successfully advanced to the next element; <see langword='false'/> if the enumerator has
			///    passed the end of the collection.</para>
			/// </returns>
			public bool MoveNext ()
			{
				if (isDisposed)
					throw new ObjectDisposedException(name);
				
				//If there are no more objects in the collection return false
				if (atEndOfCollection) 
					return false;

				//Look for the next object
				cacheIndex++;

				if ((cachedCount - cacheIndex) == 0) //cache is empty - need to get more objects
				{

					//If the timeout is set to infinite, need to use the WMI infinite constant
					int timeout = (collectionObject.options.Timeout.Ticks == Int64.MaxValue) ? 
						(int)tag_WBEM_TIMEOUT_TYPE.WBEM_INFINITE : (int)collectionObject.options.Timeout.TotalMilliseconds;

					//Get the next [BLockSize] objects within the specified timeout
					// TODO - cannot use arrays of IWbemClassObject with a TLBIMP
					// generated wrapper
					SecurityHandler securityHandler = collectionObject.scope.GetSecurityHandler();

#if true
					//Because Interop doesn't support custom marshalling for arrays, we have to use
					//the "DoNotMarshal" objects in the interop and then convert to the "FreeThreaded"
					//counterparts afterwards.
					IWbemClassObject_DoNotMarshal[] tempArray = new IWbemClassObject_DoNotMarshal[collectionObject.options.BlockSize];

					int status = enumWbem.Next_(timeout, (uint)collectionObject.options.BlockSize, tempArray, out cachedCount);

					securityHandler.Reset ();

					if (status >= 0)
					{
						//Convert results and put them in cache.
						for (int i = 0; i < cachedCount; i++)
							cachedObjects[i] = new IWbemClassObjectFreeThreaded(Marshal.GetIUnknownForObject(tempArray[i]));
					}

#else
					IWbemClassObjectFreeThreaded obj = null;

					int status = enumWbem.Next_(timeout, 1, out obj, out cachedCount);

					securityHandler.Reset ();

					if (status >= 0)
						cachedObjects[0] = obj;

#endif
					if (status < 0)
					{
						if ((status & 0xfffff000) == 0x80041000)
							ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
						else
							Marshal.ThrowExceptionForHR(status);
					}
					else
					{
						//If there was a timeout and no object can be returned we throw a timeout exception... 
						// - TODO: what should happen if there was a timeout but at least some objects were returned ??
						if ((status == (int)tag_WBEMSTATUS.WBEM_S_TIMEDOUT) && (cachedCount == 0))
							ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);

                        //If not timeout and no objects were returned - we're at the end of the collection
						if ((status == (int)tag_WBEMSTATUS.WBEM_S_FALSE) && (cachedCount == 0))
						{
							atEndOfCollection = true;
							cacheIndex--; //back to last object

/* This call to Dispose is being removed as per discussion with URT people and the newly supported
 * Dispose() call in the foreach implementation itself.
 * 
 * 								//Release the COM object (so that the user doesn't have to)
								Dispose();
*/
							return false;
						}
					}

					cacheIndex = 0;
				}

				return true;
			}

 			//****************************************
			//Reset
			//****************************************
			/// <summary>
			///    <para>Resets the enumerator to the beginning of the collection.</para>
			/// </summary>
			public void Reset ()
			{
				if (isDisposed)
					throw new ObjectDisposedException(name);

				//If the collection is not rewindable you can't do this
				if (!collectionObject.options.Rewindable)
					throw new InvalidOperationException();
				else
				{
					//Reset the WMI enumerator
					SecurityHandler securityHandler = collectionObject.scope.GetSecurityHandler();
					int status = (int)ManagementStatus.NoError;

					try {
						status = enumWbem.Reset_();
					} catch (Exception e) {
						// BUGBUG : securityHandler.Reset()?
						ManagementException.ThrowWithExtendedInfo (e);
					} finally {
						securityHandler.Reset ();
					}

					if ((status & 0xfffff000) == 0x80041000)
					{
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					}
					else if ((status & 0x80000000) != 0)
					{
						Marshal.ThrowExceptionForHR(status);
					}

					//Flush the current enumeration cache
					for (int i=(cacheIndex >= 0 ? cacheIndex : 0); i<cachedCount; i++)
						Marshal.ReleaseComObject((IWbemClassObject_DoNotMarshal)(Marshal.GetObjectForIUnknown(cachedObjects[i]))); 

					cachedCount = 0; 
					cacheIndex = -1; 
					atEndOfCollection = false;
				}
			}

		} //ManagementObjectEnumerator class

	} //ManagementObjectCollection class



	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	/// This class is used for collections of WMI relationship (=association)
	/// 	collections. We subclass to add Add/Remove functionality
	/// </summary>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	internal class RelationshipCollection : ManagementObjectCollection
	{
		internal RelationshipCollection (
			ManagementScope scope,
			ObjectQuery query, 
			EnumerationOptions options, 
			IEnumWbemClassObject enumWbem) : base (scope, options, enumWbem) {}

		//****************************************
		//Add
		//****************************************
		/// <summary>
		/// Adds a relationship to the specified object
		/// </summary>
		public void Add (ManagementPath relatedObjectPath)
		{
		}

 		//****************************************
		//Reset
		//****************************************
		/// <summary>
		/// Removes the relationship to the specified object
		/// </summary>
		public void Remove (ManagementPath relatedObjectPath)
		{
		}

	}		
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\method.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Runtime.InteropServices;
using WbemClient_v1;

namespace System.Management
{
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para> Contains information about a WMI method.</para>
	/// </summary>
	/// <example>
	///    <code lang='C#'>using System; 
	/// using System.Management; 
	/// 
	/// // This example shows how to obtain meta data 
	/// // about a WMI method with a given name in a given WMI class 
	/// 
	/// class Sample_MethodData 
	/// { 
	///     public static int Main(string[] args) { 
	/// 
	///         // Get the "SetPowerState" method in the Win32_LogicalDisk class 
	///         ManagementClass diskClass = new ManagementClass("win32_logicaldisk");
	///         MethodData m = diskClass.Methods["SetPowerState"];
	///       
	///         // Get method name (albeit we already know it)
	///         Console.WriteLine("Name: " + m.Name);
	/// 
	///         // Get the name of the top-most class where this specific method was defined
	///         Console.WriteLine("Origin: " + m.Origin);
	///       
	///         // List names and types of input parameters
	///         ManagementBaseObject inParams = m.InParameters;
	///         foreach(PropertyData pdata in inParams.Properties) {
	///             Console.WriteLine();
	///             Console.WriteLine("InParam_Name: " + pdata.Name);
	///             Console.WriteLine("InParam_Type: " + pdata.Type);
	///         }
	///       
	///         // List names and types of output parameters
	///         ManagementBaseObject outParams = m.OutParameters;
	///         foreach(PropertyData pdata in outParams.Properties) {
	///             Console.WriteLine();
	///             Console.WriteLine("OutParam_Name: " + pdata.Name);
	///             Console.WriteLine("OutParam_Type: " + pdata.Type);
	///         }
	///       
	///         return 0;
	///     }
	/// }
	///    </code>
	///    <code lang='VB'>Imports System
	/// Imports System.Management
	///       
	/// ' This example shows how to obtain meta data 
	/// ' about a WMI method with a given name in a given WMI class 
	/// 
	/// Class Sample_ManagementClass
	///     Overloads Public Shared Function Main(args() As String) As Integer
	///         
	///         ' Get the "SetPowerState" method in the Win32_LogicalDisk class 
	///         Dim diskClass As New ManagementClass("Win32_LogicalDisk")
	///         Dim m As MethodData = diskClass.Methods("SetPowerState")
	///       
	///         ' Get method name (albeit we already know it)
	///         Console.WriteLine("Name: " &amp; m.Name)
	///         
	///         ' Get the name of the top-most class where
	///         ' this specific method was defined
	///         Console.WriteLine("Origin: " &amp; m.Origin)
	/// 
	///         ' List names and types of input parameters
	///         Dim inParams As ManagementBaseObject 
	///         inParams = m.InParameters
	///         Dim pdata As PropertyData
	///         For Each pdata In inParams.Properties
	///             Console.WriteLine()
	///             Console.WriteLine("InParam_Name: " &amp; pdata.Name)
	///             Console.WriteLine("InParam_Type: " &amp; pdata.Type)
	///         Next pdata
	/// 
	///         ' List names and types of output parameters
	///         Dim outParams As ManagementBaseObject 
	///         outParams = m.OutParameters
	///         For Each pdata in outParams.Properties
	///             Console.WriteLine()
	///             Console.WriteLine("OutParam_Name: " &amp; pdata.Name)
	///             Console.WriteLine("OutParam_Type: " &amp; pdata.Type)
	///         Next pdata
	///      
	///         Return 0
	///     End Function
	/// End Class
	///    </code>
	/// </example>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class MethodData
	{
		private ManagementObject parent; //needed to be able to get method qualifiers
		private string methodName;
		private IWbemClassObjectFreeThreaded wmiInParams;
		private IWbemClassObjectFreeThreaded wmiOutParams;
		private QualifierDataCollection qualifiers;

		internal MethodData(ManagementObject parent, string methodName)
		{
			this.parent = parent;
			this.methodName = methodName;
			RefreshMethodInfo();
			qualifiers = null;
		}


		//This private function is used to refresh the information from the Wmi object before returning the requested data
		private void RefreshMethodInfo()
		{
			int status = (int)ManagementStatus.Failed;

			try {
				status = parent.wbemObject.GetMethod_(methodName, 0, out wmiInParams, out wmiOutParams);
			} catch (Exception e) {
				ManagementException.ThrowWithExtendedInfo(e);
			}
			if ((status & 0xfffff000) == 0x80041000)
			{
				ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
			}
			else if ((status & 0x80000000) != 0)
			{
				Marshal.ThrowExceptionForHR(status);
			}
		}


		/// <summary>
		///    <para>Gets or sets the name of the method.</para>
		/// </summary>
		/// <value>
		///    <para>The name of the method.</para>
		/// </value>
		public string Name 
		{
			get	{ return methodName != null ? methodName : ""; }
		}

		/// <summary>
		///    <para> Gets or sets the input parameters to the method. Each 
		///       parameter is described as a property in the object. If a parameter is both in
		///       and out, it appears in both the <see cref='System.Management.MethodData.InParameters'/> and <see cref='System.Management.MethodData.OutParameters'/>
		///       properties.</para>
		/// </summary>
		/// <value>
		///    <para> 
		///       A <see cref='System.Management.ManagementBaseObject'/>
		///       containing all the input parameters to the
		///       method.</para>
		/// </value>
		/// <remarks>
		///    <para>Each parameter in the object should have an 
		///    <see langword='ID'/> 
		///    qualifier, identifying the order of the parameters in the method call.</para>
		/// </remarks>
		public ManagementBaseObject InParameters 
		{
			get { 
				RefreshMethodInfo();
				return (null == wmiInParams) ? null : new ManagementBaseObject(wmiInParams); }
		}

		/// <summary>
		///    <para> Gets or sets the output parameters to the method. Each 
		///       parameter is described as a property in the object. If a parameter is both in
		///       and out, it will appear in both the <see cref='System.Management.MethodData.InParameters'/> and <see cref='System.Management.MethodData.OutParameters'/>
		///       properties.</para>
		/// </summary>
		/// <value>
		/// <para>A <see cref='System.Management.ManagementBaseObject'/> containing all the output parameters to the method. </para>
		/// </value>
		/// <remarks>
		///    <para>Each parameter in this object should have an 
		///    <see langword='ID'/> qualifier to identify the 
		///       order of the parameters in the method call.</para>
		///    <para>The ReturnValue property is a special property of 
		///       the <see cref='System.Management.MethodData.OutParameters'/>
		///       object and
		///       holds the return value of the method.</para>
		/// </remarks>
		public ManagementBaseObject OutParameters 
		{
			get { 
				RefreshMethodInfo();
				return (null == wmiOutParams) ? null : new ManagementBaseObject(wmiOutParams); }
		}

		/// <summary>
		///    <para>Gets the name of the management class in which the method was first 
		///       introduced in the class inheritance hierarchy.</para>
		/// </summary>
		/// <value>
		///    A string representing the originating
		///    management class name.
		/// </value>
		public string Origin 
		{
			get {
				string className = null;
				int status = parent.wbemObject.GetMethodOrigin_(methodName, out className);

				if (status < 0)
				{
					if (status == (int)tag_WBEMSTATUS.WBEM_E_INVALID_OBJECT)
						className = String.Empty;	// Interpret as an unspecified property - return ""
					else if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}

				return className;
			}
		}

		/// <summary>
		///    <para>Gets a collection of qualifiers defined in the 
		///       method. Each element is of type <see cref='System.Management.QualifierData'/>
		///       and contains information such as the qualifier name, value, and
		///       flavor.</para>
		/// </summary>
		/// <value>
		///    A <see cref='System.Management.QualifierDataCollection'/> containing the
		///    qualifiers for this method.
		/// </value>
		/// <seealso cref='System.Management.QualifierData'/>
		public QualifierDataCollection Qualifiers 
		{
			get {
				if (qualifiers == null)
					qualifiers = new QualifierDataCollection(parent, methodName, QualifierType.MethodQualifier);
				return qualifiers;
			}
		}

	}//MethodData
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\methodset.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Collections;
using System.Runtime.InteropServices;
using WbemClient_v1;

namespace System.Management
{
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para> Represents the set of methods available in the collection.</para>
	/// </summary>
	/// <example>
	///    <code lang='C#'>using System;
	/// using System.Management;
	/// 
	/// // This sample demonstrates enumerate all methods in a ManagementClass object.
	/// class Sample_MethodDataCollection
	/// {
	///     public static int Main(string[] args) {
	///         ManagementClass diskClass = new ManagementClass("win32_logicaldisk");
	///         MethodDataCollection diskMethods = diskClass.Methods;
	///         foreach (MethodData method in diskMethods) {
	///             Console.WriteLine("Method = " + method.Name);
	///         }
	///         return 0;
	///     }
	/// }
	///    </code>
	///    <code lang='VB'>Imports System
	/// Imports System.Management
	/// 
	/// ' This sample demonstrates enumerate all methods in a ManagementClass object.
	/// Class Sample_MethodDataCollection
	///     Overloads Public Shared Function Main(args() As String) As Integer
	///         Dim diskClass As New ManagementClass("win32_logicaldisk")
	///         Dim diskMethods As MethodDataCollection = diskClass.Methods
	///         Dim method As MethodData
	///         For Each method In diskMethods
	///             Console.WriteLine("Method = " &amp; method.Name)
	///         Next method
	///         Return 0
	///     End Function
	/// End Class
	///    </code>
	/// </example>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class MethodDataCollection : ICollection, IEnumerable 
	{
		private ManagementObject parent;

		private class enumLock 
		{
		} //used to lock usage of BeginMethodEnum/NextMethod

		internal MethodDataCollection(ManagementObject parent) : base()
		{
			this.parent = parent;
		}

		//
		//ICollection
		//

		/// <summary>
		/// <para>Represents the number of objects in the <see cref='System.Management.MethodDataCollection'/>.</para>
		/// </summary>
		/// <value>
		/// <para> The number of objects in the <see cref='System.Management.MethodDataCollection'/>. </para>
		/// </value>
		public int Count 
		{
			get {
				int i = 0;
				IWbemClassObjectFreeThreaded inParams = null, outParams = null;
				string methodName;
				int status = (int)ManagementStatus.Failed;

				lock(typeof(enumLock))
				{
					try 
					{
						status = parent.wbemObject.BeginMethodEnumeration_(0);

						if (status >= 0)
						{
							methodName = "";	// Condition primer to branch into the while loop.
							while (methodName != null && status >= 0 && status != (int)tag_WBEMSTATUS.WBEM_S_NO_MORE_DATA)
							{
								methodName = null; inParams = null; outParams = null;
								status = parent.wbemObject.NextMethod_(0, out methodName, out inParams, out outParams);
								if (status >= 0 && status != (int)tag_WBEMSTATUS.WBEM_S_NO_MORE_DATA)
									i++;
							}
							parent.wbemObject.EndMethodEnumeration_();	// Ignore status.
						}
					} 
					catch (Exception e) 
					{
						ManagementException.ThrowWithExtendedInfo(e);
					}
				} // lock

				if ((status & 0xfffff000) == 0x80041000)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				}
				else if ((status & 0x80000000) != 0)
				{
					Marshal.ThrowExceptionForHR(status);
				}

				return i;
			}
		}

		/// <summary>
		///    <para>Indicates whether the object is synchronized.</para>
		/// </summary>
		/// <value>
		/// <para><see langword='true'/> if the object is synchronized; 
		///    otherwise, <see langword='false'/>.</para>
		/// </value>
		public bool IsSynchronized { get { return false; } 
		}

		/// <summary>
		///    <para>Represents the object to be used for synchronization.</para>
		/// </summary>
		/// <value>
		///    <para>The object to be used for synchronization.</para>
		/// </value>
		public object SyncRoot { get { return this; } 
		}

		/// <overload>
		/// <para>Copies the <see cref='System.Management.MethodDataCollection'/> into an array.</para>
		/// </overload>
		/// <summary>
		/// <para> Copies the <see cref='System.Management.MethodDataCollection'/> into an array.</para>
		/// </summary>
		/// <param name='array'>The array to which to copy the collection. </param>
		/// <param name='index'>The index from which to start. </param>
		public void CopyTo(Array array, int index)
		{
			//Use an enumerator to get the MethodData objects and attach them into the target array
			foreach (MethodData m in this)
				array.SetValue(m, index++);
		}

		/// <summary>
		/// <para>Copies the <see cref='System.Management.MethodDataCollection'/> to a specialized <see cref='System.Management.MethodData'/> 
		/// array.</para>
		/// </summary>
		/// <param name='methodArray'>The destination array to which to copy the <see cref='System.Management.MethodData'/> objects.</param>
		/// <param name=' index'>The index in the destination array from which to start the copy.</param>
		public void CopyTo(MethodData[] methodArray, int index)
		{
			CopyTo((Array)methodArray, index);
		}

		//
		// IEnumerable
		//
		IEnumerator IEnumerable.GetEnumerator()
		{
			return (IEnumerator)(new MethodDataEnumerator(parent));
		}

		/// <summary>
		/// <para>Returns an enumerator for the <see cref='System.Management.MethodDataCollection'/>.</para>
		/// </summary>
		/// <remarks>
		///    <para> Each call to this method
		///       returns a new enumerator on the collection. Multiple enumerators can be obtained
		///       for the same method collection. However, each enumerator takes a snapshot
		///       of the collection, so changes made to the collection after the enumerator was
		///       obtained are not reflected.</para>
		/// </remarks>
		/// <returns>An <see cref="System.Collections.IEnumerator"/> to enumerate through the collection.</returns>
		public MethodDataEnumerator GetEnumerator()
		{
				return new MethodDataEnumerator(parent);
		}

		//Enumerator class
		/// <summary>
		/// <para>Represents the enumerator for <see cref='System.Management.MethodData'/> 
		/// objects in the <see cref='System.Management.MethodDataCollection'/>.</para>
		/// </summary>
		/// <example>
		///    <code lang='C#'>using System;
		/// using System.Management;
		/// 
		/// // This sample demonstrates how to enumerate all methods in
		/// // Win32_LogicalDisk class using MethodDataEnumerator object.
		/// 
		/// class Sample_MethodDataEnumerator 
		/// {
		///  public static int Main(string[] args) 
		///  {
		///   ManagementClass diskClass = new ManagementClass("win32_logicaldisk");
		///   MethodDataCollection.MethodDataEnumerator diskEnumerator = 
		///    diskClass.Methods.GetEnumerator();
		///   while(diskEnumerator.MoveNext()) 
		///   {
		///    MethodData method = diskEnumerator.Current;
		///    Console.WriteLine("Method = " + method.Name);
		///   }   
		///   return 0;
		///  }
		/// }
		///    </code>
		///    <code lang='VB'>Imports System
		/// Imports System.Management
		/// 
		/// ' This sample demonstrates how to enumerate all methods in
		/// ' Win32_LogicalDisk class using MethodDataEnumerator object.
		/// 
		/// Class Sample_MethodDataEnumerator
		///  Overloads Public Shared Function Main(args() As String) As Integer
		///   Dim diskClass As New ManagementClass("win32_logicaldisk")
		///   Dim diskEnumerator As _
		///        MethodDataCollection.MethodDataEnumerator = _
		///       diskClass.Methods.GetEnumerator()
		///   While diskEnumerator.MoveNext()
		///    Dim method As MethodData = diskEnumerator.Current
		///    Console.WriteLine("Method = " &amp; method.Name)
		///   End While
		///   Return 0
		///  End Function 
		/// End Class
		///    </code>
		/// </example>
		public class MethodDataEnumerator : IEnumerator
		{
			private ManagementObject parent;
			private ArrayList methodNames; //can't use simple array because we don't know the size...
			private IEnumerator en;

			//Internal constructor
			//Because WMI doesn't provide a "GetMethodNames" for methods similar to "GetNames" for properties,
			//We have to walk the methods list and cache the names here.
			//We lock to ensure that another thread doesn't interfere in the Begin/Next sequence.
			internal MethodDataEnumerator(ManagementObject parent)
			{
				this.parent = parent;
				methodNames = new ArrayList(); 
				IWbemClassObjectFreeThreaded inP = null, outP = null;
				string tempMethodName;
				int status = (int)ManagementStatus.Failed;

				lock(typeof(enumLock))
				{
					try 
					{
						status = parent.wbemObject.BeginMethodEnumeration_(0);

						if (status >= 0)
						{
							tempMethodName = "";	// Condition primer to branch into the while loop.
							while (tempMethodName != null && status >= 0 && status != (int)tag_WBEMSTATUS.WBEM_S_NO_MORE_DATA)
							{
								tempMethodName = null;
								status = parent.wbemObject.NextMethod_(0, out tempMethodName, out inP, out outP);
								if (status >= 0 && status != (int)tag_WBEMSTATUS.WBEM_S_NO_MORE_DATA)
									methodNames.Add(tempMethodName);
							}
							parent.wbemObject.EndMethodEnumeration_();	// Ignore status.
						}
					} 
					catch (Exception e) 
					{
						ManagementException.ThrowWithExtendedInfo(e);
					}
					en = methodNames.GetEnumerator();
				}
				
				if ((status & 0xfffff000) == 0x80041000)
				{
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				}
				else if ((status & 0x80000000) != 0)
				{
					Marshal.ThrowExceptionForHR(status);
				}
			}
		
			object IEnumerator.Current { get { return (object)this.Current; } }

			/// <summary>
			/// <para>Returns the current <see cref='System.Management.MethodData'/> in the <see cref='System.Management.MethodDataCollection'/> 
			/// enumeration.</para>
			/// </summary>
			/// <value>The current <see cref='System.Management.MethodData'/> item in the collection.</value>
			public MethodData Current 
			{
				get 
				{ return new MethodData(parent, (string)en.Current);
				}
			}

			/// <summary>
			/// <para>Moves to the next element in the <see cref='System.Management.MethodDataCollection'/> enumeration.</para>
			/// </summary>
			/// <returns><see langword='true'/> if the enumerator was successfully advanced to the next method; <see langword='false'/> if the enumerator has passed the end of the collection.</returns>
			public bool MoveNext ()
			{
				return en.MoveNext();			
			}

			/// <summary>
			/// <para>Resets the enumerator to the beginning of the <see cref='System.Management.MethodDataCollection'/> enumeration.</para>
			/// </summary>
			public void Reset()
			{
				en.Reset();
			}
            
		}//MethodDataEnumerator


		//
		//Methods
		//

		/// <summary>
		/// <para>Returns the specified <see cref='System.Management.MethodData'/> from the <see cref='System.Management.MethodDataCollection'/>.</para>
		/// </summary>
		/// <param name='methodName'>The name of the method requested.</param>
		/// <value>A <see cref='System.Management.MethodData'/> instance containing all information about the specified method.</value>
		public virtual MethodData this[string methodName] 
		{
			get { 
				if (null == methodName)
					throw new ArgumentNullException ("methodName");

				return new MethodData(parent, methodName);
			}
		}
		

		/// <summary>
		/// <para>Removes a <see cref='System.Management.MethodData'/> from the <see cref='System.Management.MethodDataCollection'/>.</para>
		/// </summary>
		/// <param name='methodName'>The name of the method to remove from the collection.</param>
		/// <remarks>
		///    <para> 
		///       Removing <see cref='System.Management.MethodData'/> objects from the <see cref='System.Management.MethodDataCollection'/>
		///       can only be done when the class has no
		///       instances. Any other case will result in an exception.</para>
		/// </remarks>
		public virtual void Remove(string methodName)
		{
			if (parent.GetType() == typeof(ManagementObject)) //can't remove methods from instance
				throw new InvalidOperationException();

			int status = (int)ManagementStatus.Failed;

			try {
				status = parent.wbemObject.DeleteMethod_(methodName);
			} catch (Exception e) {
				ManagementException.ThrowWithExtendedInfo(e);
			}

			if ((status & 0xfffff000) == 0x80041000)
			{
				ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
			}
			else if ((status & 0x80000000) != 0)
			{
				Marshal.ThrowExceptionForHR(status);
			}
		}

		//This variant takes only a method name and assumes a void method with no in/out parameters
		/// <overload>
		/// <para>Adds a <see cref='System.Management.MethodData'/> to the <see cref='System.Management.MethodDataCollection'/>.</para>
		/// </overload>
		/// <summary>
		/// <para>Adds a <see cref='System.Management.MethodData'/> to the <see cref='System.Management.MethodDataCollection'/>. This overload will
		///    add a new method with no parameters to the collection.</para>
		/// </summary>
		/// <param name='methodName'>The name of the method to add.</param>
		/// <remarks>
		/// <para> Adding <see cref='System.Management.MethodData'/> objects to the <see cref='System.Management.MethodDataCollection'/> can only 
		///    be done when the class has no instances. Any other case will result in an
		///    exception.</para>
		/// </remarks>
		public virtual void Add(string methodName)
		{
			Add(methodName, null, null);
		}



		//This variant takes the full information, i.e. the method name and in & out param objects
		/// <summary>
		/// <para>Adds a <see cref='System.Management.MethodData'/> to the <see cref='System.Management.MethodDataCollection'/>. This overload will add a new method with the 
		///    specified parameter objects to the collection.</para>
		/// </summary>
		/// <param name='methodName'>The name of the method to add.</param>
		/// <param name=' inParams'>The <see cref='System.Management.ManagementBaseObject'/> holding the input parameters to the method.</param>
		/// <param name=' outParams'>The <see cref='System.Management.ManagementBaseObject'/> holding the output parameters to the method.</param>
		/// <remarks>
		/// <para> Adding <see cref='System.Management.MethodData'/> objects to the <see cref='System.Management.MethodDataCollection'/> can only be 
		///    done when the class has no instances. Any other case will result in an
		///    exception.</para>
		/// </remarks>
		public virtual void Add(string methodName, ManagementBaseObject inParams, ManagementBaseObject outParams)
		{
			IWbemClassObjectFreeThreaded wbemIn = null, wbemOut = null;

			if (parent.GetType() == typeof(ManagementObject)) //can't add methods to instance
				throw new InvalidOperationException();

			if (inParams != null)
				wbemIn = inParams.wbemObject;
			if (outParams != null)
				wbemOut = outParams.wbemObject;

			int status = (int)ManagementStatus.Failed;

			try {
				status = parent.wbemObject.PutMethod_(methodName, 0, wbemIn, wbemOut);
			} catch (Exception e) {
				ManagementException.ThrowWithExtendedInfo(e);
			}

			if ((status & 0xfffff000) == 0x80041000)
			{
				ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
			}
			else if ((status & 0x80000000) != 0)
			{
				Marshal.ThrowExceptionForHR(status);
			}
		}

	}//MethodDataCollection
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\managementpath.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Diagnostics;
using System.Collections;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Runtime.InteropServices;
using WbemUtilities_v1;
using WbemClient_v1;
using System.Globalization;
using System.Reflection;
using System.ComponentModel.Design.Serialization;

namespace System.Management
{
	/// <summary>
	///    <para>Provides a wrapper for parsing and building paths to WMI objects.</para>
	/// </summary>
	/// <example>
	///    <code lang='C#'>using System; 
	/// using System.Management;
	///  
	/// // This sample displays all properties in a ManagementPath object. 
	/// 
	/// class Sample_ManagementPath 
	/// { 
	///     public static int Main(string[] args) { 
	///         ManagementPath path = new ManagementPath( "\\\\MyServer\\MyNamespace:Win32_logicaldisk='c:'");
	///       
	///         // Results of full path parsing 
	///         Console.WriteLine("Path: " + path.Path);
	///         Console.WriteLine("RelativePath: " + path.RelativePath);
	///         Console.WriteLine("Server: " + path.Server); 
	///         Console.WriteLine("NamespacePath: " + path.NamespacePath); 
	///         Console.WriteLine("ClassName: " + path.ClassName);
	///         Console.WriteLine("IsClass: " + path.IsClass); 
	///         Console.WriteLine("IsInstance: " + path.IsInstance); 
	///         Console.WriteLine("IsSingleton: " + path.IsSingleton); 
	///            
	///         // Change a portion of the full path 
	///         path.Server = "AnotherServer";
	///         Console.WriteLine("New Path: " + path.Path); 
	///         return 0; 
	///    } 
	/// }
	///    </code>
	///    <code lang='VB'>Imports System
	/// Imports System.Management 
	/// 
	/// 'This sample displays all properties in a ManagementPath object. 
	/// Class Sample_ManagementPath Overloads
	///     Public Shared Function Main(args() As String) As Integer
	///         Dim path As _ New
	///         ManagementPath("\\MyServer\MyNamespace:Win32_LogicalDisk='c:'") 
	/// 
	///         ' Results of full path parsing
	///         Console.WriteLine("Path: " &amp; path.Path) 
	///         Console.WriteLine("RelativePath: " &amp; path.RelativePath)
	///         Console.WriteLine("Server: " &amp; path.Server)
	///         Console.WriteLine("NamespacePath: " &amp; path.NamespacePath) 
	///         Console.WriteLine("ClassName: " &amp; path.ClassName) 
	///         Console.WriteLine("IsClass: " &amp; path.IsClass)
	///         Console.WriteLine("IsInstance: " &amp; path.IsInstance) 
	///         Console.WriteLine("IsSingleton: " &amp; path.IsSingleton) 
	/// 
	///         ' Change a portion of the full path 
	///         path.Server= "AnotherServer"
	///         Console.WriteLine("New Path: " &amp; path.Path)
	///         Return 0
	///     End Function
	/// End Class
	///    </code>
	/// </example>
	[TypeConverter(typeof(ManagementPathConverter ))]
	public class ManagementPath : ICloneable
	{
		private static ManagementPath defaultPath = new ManagementPath("//./root/cimv2");

		//Used to minimize the cases in which new wbemPath (WMI object path parser) objects need to be constructed
		//This is done for performance reasons.
		private bool   isWbemPathShared = false; 
		
		internal event IdentifierChangedEventHandler IdentifierChanged;

		//Fires IdentifierChanged event
		private void FireIdentifierChanged()
		{
			if (IdentifierChanged != null)
				IdentifierChanged(this, null);
		}

		//internal factory
		/// <summary>
		/// Internal static "factory" method for making a new ManagementPath
		/// from the system property of a WMI object
		/// </summary>
		/// <param name="wbemObject">The WMI object whose __PATH property will
		/// be used to supply the returned object</param>
		internal static string GetManagementPath (
			IWbemClassObjectFreeThreaded wbemObject)
		{
			string path = null;
			int status	= (int)ManagementStatus.Failed;

			if (null != wbemObject)
			{
				int dummy1 = 0, dummy2 = 0;
				object val = null;
				status = wbemObject.Get_ ("__PATH", 0, ref val, ref dummy1, ref dummy2);
				if ((status < 0) || (val == System.DBNull.Value))
				{
					//try to get the relpath instead
					status = wbemObject.Get_ ("__RELPATH", 0, ref val, ref dummy1, ref dummy2);
					if (status < 0)	
					{
						if ((status & 0xfffff000) == 0x80041000)
							ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
						else
							Marshal.ThrowExceptionForHR(status);
					}
				}
				
				if (System.DBNull.Value == val)
					path = null;
				else
					path = (string)val;
			}

			return path;
		}

		//Used internally to check whether a string passed in as a namespace is indeed syntactically correct
		//for a namespace (e.g. either has "\" or "/" in it or is the special case of "root")
		//This doesn't check for the existance of that namespace, nor does it guarrantee correctness.
		internal static bool IsValidNamespaceSyntax(string nsPath)
		{
			if (nsPath.Length != 0)
			{
				// Any path separators present?
				char[] pathSeparators = { '\\', '/' };
				if (nsPath.IndexOfAny(pathSeparators) == -1)
				{
					// No separators.  The only valid path is "root".
					if (String.Compare("root", nsPath, true,CultureInfo.InvariantCulture) != 0)
						return false;
				}
			}
			
			return true;
		}


		internal static ManagementPath _Clone(ManagementPath path)
		{
			return ManagementPath._Clone(path, null);
		}

		internal static ManagementPath _Clone(ManagementPath path, IdentifierChangedEventHandler handler)
		{
			ManagementPath pathTmp = new ManagementPath();

			// Wire up change handler chain. Use supplied handler, if specified;
			// otherwise, default to that of the path argument.
			if (handler != null)
				pathTmp.IdentifierChanged = handler;

			// Assign ManagementPath IWbemPath to this.wmiPath.  
			// Optimization for performance : As long as the path is only read, we share this interface.
			// On the first write, a private copy will be needed; 
			// isWbemPathShared signals ManagementPath to create such a copy at write-time.
			if (path != null && path.wmiPath != null)
			{
				pathTmp.wmiPath = path.wmiPath;
				pathTmp.isWbemPathShared = path.isWbemPathShared = true;
			}

			return pathTmp;
		}

		/// <overload>
		///    Initializes a new instance
		///    of the <see cref='System.Management.ManagementPath'/> class.
		/// </overload>
		/// <summary>
		/// <para> Initializes a new instance of the <see cref='System.Management.ManagementPath'/> class that is empty. This is the default constructor.</para>
		/// </summary>
		public ManagementPath () : this ((string) null) {}

		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.ManagementPath'/> class for the given path.</para>
		/// </summary>
		/// <param name='path'> The object path. </param>
		public ManagementPath(string path) 
		{
			if ((null != path) && (0 < path.Length))
				wmiPath = CreateWbemPath(path);
		}
		
		/// <summary>
		///    <para>Returns the full object path as the string representation.</para>
		/// </summary>
		/// <returns>
		///    A string containing the full object
		///    path represented by this object. This value is equivalent to the value of the
		/// <see cref='System.Management.ManagementPath.Path'/> property.
		/// </returns>
		public override string ToString () 
		{
			return this.Path;
		}

		/// <summary>
		/// <para>Returns a copy of the <see cref='System.Management.ManagementPath'/>.</para>
		/// </summary>
		/// <returns>
		///    The cloned object.
		/// </returns>
		public ManagementPath Clone ()
		{
			return new ManagementPath (Path);
		}

		/// <summary>
		/// Standard Clone returns a copy of this ManagementPath as a generic "Object" type
		/// </summary>
		/// <returns>
		///    The cloned object.
		/// </returns>
		object ICloneable.Clone ()
		{
			return Clone ();	
		}

		/// <summary>
		///    <para>Gets or sets the default scope path used when no scope is specified.
		///       The default scope is /-/ \\.\root\cimv2, and can be changed by setting this property.</para>
		/// </summary>
		/// <value>
		///    <para>By default the scope value is /-/ \\.\root\cimv2, or a different scope path if
		///       the default was changed.</para>
		/// </value>
		public static ManagementPath DefaultPath 
		{
			get { return ManagementPath.defaultPath; }
			set { ManagementPath.defaultPath = value; }
		}
		
		//private members
		private IWbemPath		wmiPath;

		private IWbemPath CreateWbemPath(string path)
		{
			IWbemPath wbemPath = (IWbemPath)MTAHelper.CreateInMTA(typeof(WbemDefPath));//new WbemDefPath();
			SetWbemPath(wbemPath, path);
			return wbemPath;
		}

		private void SetWbemPath(string path)
		{
			// Test/utilize isWbemPathShared *only* on public + internal members!
			if (wmiPath == null)
				wmiPath = CreateWbemPath(path);
			else
				SetWbemPath(wmiPath, path);
		}

		private void SetWbemPath(IWbemPath wbemPath, string path)
		{
			if (null != wbemPath)
			{
				uint flags = (uint) tag_WBEM_PATH_CREATE_FLAG.WBEMPATH_CREATE_ACCEPT_ALL;

				//For now we have to special-case the "root" namespace - 
				//  this is because in the case of "root", the path parser cannot tell whether 
				//  this is a namespace name or a class name
				//TODO : fix this so that special-casing is not needed
				if (path.ToLower(CultureInfo.InvariantCulture).Equals("root"))
					flags = flags | (uint) tag_WBEM_PATH_CREATE_FLAG.WBEMPATH_TREAT_SINGLE_IDENT_AS_NS;

				int status = wbemPath.SetText_(flags, path);

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}
			}
		}

		private string GetWbemPath()
		{
			return GetWbemPath(this.wmiPath);
		}

		private string GetWbemPath(IWbemPath wbemPath)
		{
			String pathStr = String.Empty;

			if (null != wbemPath)
			{
				// TODO - due to a bug in the current WMI path
				// parser, requesting the path from a parser which has
				// been only given a relative path results in an incorrect
				// value being returned (e.g. \\.\win32_logicaldisk). To work
				// around this for now we check if there are any namespaces,
				// and if not ask for the relative path instead.
				int flags = (int)tag_WBEM_GET_TEXT_FLAGS.WBEMPATH_GET_SERVER_TOO;
				uint nCount = 0;

				int status = (int)ManagementStatus.NoError;

				status = wbemPath.GetNamespaceCount_(out nCount);

				if (status >= 0)
				{
					if (0 == nCount)
						flags = (int)tag_WBEM_GET_TEXT_FLAGS.WBEMPATH_GET_RELATIVE_ONLY;

					// Get the space we need to reserve
					uint bufLen = 0;
				
					status = wbemPath.GetText_(flags, ref bufLen, null);

					if (status >= 0 && 0 < bufLen)
					{
						pathStr = new String ('0', (int) bufLen-1);
						status = wbemPath.GetText_(flags, ref bufLen, pathStr);
					}
				}

				if (status < 0)
				{
					if (status == (int)tag_WBEMSTATUS.WBEM_E_INVALID_PARAMETER)
						;	// Interpret as unspecified - return ""
					else if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}
			}

			return pathStr;
		}

		private void ClearKeys (bool setAsSingleton)
		{
			// Test/utilize isWbemPathShared *only* on public + internal members!
			int status = (int)ManagementStatus.NoError;

			try {
				if (null != wmiPath)
				{
					IWbemPathKeyList keyList = null;
					status = wmiPath.GetKeyList_(out keyList);

					if (null != keyList)
					{
						status = keyList.RemoveAllKeys_(0);
						if ((status & 0x80000000) == 0)
						{
							sbyte bSingleton = (setAsSingleton) ? (sbyte)(-1) : (sbyte)0;
							status = keyList.MakeSingleton_(bSingleton);
							FireIdentifierChanged ();		// BUGBUG : RemoveAllKeys success?
						}
					}
				}
			}
			catch (Exception e) {
				ManagementException.ThrowWithExtendedInfo(e);
			}
		
			if ((status & 0xfffff000) == 0x80041000)
			{
				ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
			}
			else if ((status & 0x80000000) != 0)
			{
				Marshal.ThrowExceptionForHR(status);
			}
		}
		
		internal bool IsEmpty 
		{
			get {
				return (Path == String.Empty);
			}
		}


		//
		// Methods
		//

		/// <summary>
		///    <para> Sets the path as a new class path. This means that the path must have
		///       a class name but not key values.</para>
		/// </summary>
		public void SetAsClass ()
		{
			if (IsClass || IsInstance)
			{
				// Check if this IWbemPath is shared among multiple managed objects.
				// With this write, it will have to maintain its own copy.
				if (isWbemPathShared)
				{
					wmiPath = CreateWbemPath(this.GetWbemPath());
					isWbemPathShared = false;
				}

				ClearKeys (false);
			}
			else
				throw new ManagementException (ManagementStatus.InvalidOperation, null, null);
		}

		/// <summary>
		///    <para> Sets the path as a new singleton object path. This means that it is a path to an instance but
		///       there are no key values.</para>
		/// </summary>
		public void SetAsSingleton ()
		{
			if (IsClass || IsInstance)
			{
				// Check if this IWbemPath is shared among multiple managed objects.
				// With this write, it will have to maintain its own copy.
				if (isWbemPathShared)
				{
					wmiPath = CreateWbemPath(this.GetWbemPath());
					isWbemPathShared = false;
				}

				ClearKeys (true);
			}
			else
				throw new ManagementException (ManagementStatus.InvalidOperation, null, null);
		}

		//
		// Properties
		//

		/// <summary>
		///    <para> Gets or sets the string representation of the full path in the object.</para>
		/// </summary>
		/// <value>
		///    <para>A string containing the full path
		///       represented in this object.</para>
		/// </value>
		[RefreshProperties(RefreshProperties.All)]
		public string Path
		{
			get
			{
				return this.GetWbemPath();
			}
			set
			{
				try
				{
					// Before overwriting, check it's OK
					// Note, we've never done such validation, should we?
					//
					// Check if this IWbemPath is shared among multiple managed objects.
					// With this write, it will have to maintain its own copy.
					if (isWbemPathShared)
					{
						wmiPath = CreateWbemPath(this.GetWbemPath());
						isWbemPathShared = false;
					}

					this.SetWbemPath(value);
				}
				catch (Exception)
				{
					throw new ArgumentOutOfRangeException ();
				}
				FireIdentifierChanged();
			}
		}

		/// <summary>
		///    <para> Gets or sets the relative path: class name and keys only.</para>
		/// </summary>
		/// <value>
		///    A string containing the relative
		///    path (not including the server and namespace portions) represented in this
		///    object.
		/// </value>
		[RefreshProperties(RefreshProperties.All)]
		public string RelativePath
		{
			get 
			{ 
				String pathStr = String.Empty;

				if (null != wmiPath)
				{
					// Get the space we need to reserve
					uint bufLen = 0;
					int status = wmiPath.GetText_(
							(int) tag_WBEM_GET_TEXT_FLAGS.WBEMPATH_GET_RELATIVE_ONLY,
							ref bufLen, 
							null);

					if (status >= 0 && 0 < bufLen)
					{
						pathStr = new String ('0', (int) bufLen-1);
						status = wmiPath.GetText_(
							(int) tag_WBEM_GET_TEXT_FLAGS.WBEMPATH_GET_RELATIVE_ONLY,
							ref bufLen, 
							pathStr);
					}

					if (status < 0)
					{
						if (status == (int)tag_WBEMSTATUS.WBEM_E_INVALID_PARAMETER)
							;	// Interpret as unspecified - return ""
						else if ((status & 0xfffff000) == 0x80041000)
							ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
						else
							Marshal.ThrowExceptionForHR(status);
					}
				}

				return pathStr;
			}

			set {
				try {
					// No need for isWbemPathShared here since internal SetRelativePath
					// always creates a new copy.
					SetRelativePath (value);
				} catch (COMException) {
					throw new ArgumentOutOfRangeException ();
				}
				FireIdentifierChanged();
			}
		}

		internal void SetRelativePath (string relPath)
		{
			// No need for isWbemPathShared here since internal SetRelativePath
			// always creates a new copy.
			ManagementPath newPath = new ManagementPath (relPath);
			newPath.NamespacePath = this.GetNamespacePath((int)tag_WBEM_GET_TEXT_FLAGS.WBEMPATH_GET_SERVER_AND_NAMESPACE_ONLY);
			newPath.Server = this.Server;
			wmiPath = newPath.wmiPath;
		}

		//Used to update the relative path when the user changes any key properties
		internal void UpdateRelativePath(string relPath)
		{
			if (relPath == null)
				return;

			//Get the server & namespace part from the existing path, and concatenate the given relPath.
			//NOTE : we need to do this because IWbemPath doesn't have a function to set the relative path alone...
			string newPath = String.Empty;
			string nsPath = this.GetNamespacePath((int)tag_WBEM_GET_TEXT_FLAGS.WBEMPATH_GET_SERVER_AND_NAMESPACE_ONLY);

			if (nsPath != String.Empty)
				newPath = String.Concat(nsPath, ":", relPath);
			else
				newPath = relPath;

			// Check if this IWbemPath is shared among multiple managed objects.
			// With this write, it will have to maintain its own copy.
			if (isWbemPathShared)
			{
				wmiPath = CreateWbemPath(this.GetWbemPath());
				isWbemPathShared = false;
			}

			this.SetWbemPath(newPath);
		}

		
		/// <summary>
		///    <para>Gets or sets the server part of the path.</para>
		/// </summary>
		/// <value>
		///    A string containing the server name
		///    from the path represented in this object.
		/// </value>
		[RefreshProperties(RefreshProperties.All)]
		public string Server
		{
			get { 
				String pathStr = String.Empty;

				if (null != wmiPath) {

					uint uLen = 0;
					int status = wmiPath.GetServer_(ref uLen, null);

					if (status >= 0 && 0 < uLen)
					{
						pathStr = new String ('0', (int) uLen-1);
						status = wmiPath.GetServer_(ref uLen, pathStr);
					}

					if (status < 0)
					{
						if (status == (int)tag_WBEMSTATUS.WBEM_E_NOT_AVAILABLE)
							;	// Interpret as unspecified - return ""
						else if ((status & 0xfffff000) == 0x80041000)
							ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
						else
							Marshal.ThrowExceptionForHR(status);
					}
				}

				return pathStr;
			}
			set {
				String oldValue = Server;

				// Only set if changed
				if (0 != String.Compare(oldValue,value,true,CultureInfo.InvariantCulture))
				{
					if (null == wmiPath)
						wmiPath = (IWbemPath)MTAHelper.CreateInMTA(typeof(WbemDefPath));//new WbemDefPath ();
					else if (isWbemPathShared)
					{
						// Check if this IWbemPath is shared among multiple managed objects.
						// With this write, it will have to maintain its own copy.
						wmiPath = CreateWbemPath(this.GetWbemPath());
						isWbemPathShared = false;
					}

					int status = wmiPath.SetServer_(value);

					if (status < 0)
					{
						if ((status & 0xfffff000) == 0x80041000)
							ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
						else
							Marshal.ThrowExceptionForHR(status);
					}

					FireIdentifierChanged();
				}
			}
		}

		internal string SetNamespacePath(string nsPath, out bool bChange) 
		{
			int			status = (int)ManagementStatus.NoError;
			string		nsOrg = null;
			string		nsNew = null;
			IWbemPath	wmiPathTmp = null; 
			bChange = false;

			Debug.Assert(nsPath != null);

			//Do some validation on the path to make sure it is a valid namespace path (at least syntactically)
			if (!IsValidNamespaceSyntax(nsPath))
				ManagementException.ThrowWithExtendedInfo((ManagementStatus)tag_WBEMSTATUS.WBEM_E_INVALID_NAMESPACE);

			wmiPathTmp = CreateWbemPath(nsPath);
			if (wmiPath == null)
				wmiPath = this.CreateWbemPath("");
			else if (isWbemPathShared)
			{
				// Check if this IWbemPath is shared among multiple managed objects.
				// With this write, it will have to maintain its own copy.
				wmiPath = CreateWbemPath(this.GetWbemPath());
				isWbemPathShared = false;
			}

			nsOrg = GetNamespacePath(wmiPath,
				(int)tag_WBEM_GET_TEXT_FLAGS.WBEMPATH_GET_NAMESPACE_ONLY);
			nsNew = GetNamespacePath(wmiPathTmp,
				(int)tag_WBEM_GET_TEXT_FLAGS.WBEMPATH_GET_NAMESPACE_ONLY);

			if (String.Compare(nsOrg, nsNew, true,CultureInfo.InvariantCulture) != 0)
			{
				wmiPath.RemoveAllNamespaces_();									// Out with the old... Ignore status code.

				// Add the new ones in
				bChange = true;													// Now dirty from above.
				uint nCount = 0;
				status = wmiPathTmp.GetNamespaceCount_(out nCount);

				if (status >= 0)
				{
					for (uint i = 0; i < nCount; i++) 
					{
						uint uLen = 0;
						status = wmiPathTmp.GetNamespaceAt_(i, ref uLen, null);
							
						if (status >= 0)
						{
							string nSpace = new String('0', (int) uLen-1);
							status = wmiPathTmp.GetNamespaceAt_(i, ref uLen, nSpace);
							if (status >= 0)
							{
								status = wmiPath.SetNamespaceAt_(i, nSpace);
									
								if (status < 0)
									break;
							}
							else
								break;
						}
						else
							break;
					}
				}
			}
			else {;}	// Continue on. Could have different server name, same ns specified.

			//
			// Update Server property if specified in the namespace.
			// eg: "\\MyServer\root\cimv2".
			//
			if (status >= 0 && nsPath.Length > 1 &&
				(nsPath[0] == '\\' && nsPath[1] == '\\' ||
				 nsPath[0] == '/'  && nsPath[1] == '/'))
			{
				uint uLen = 0;
				status = wmiPathTmp.GetServer_(ref uLen, null);

				if (status >= 0 && uLen > 0)
				{
					string serverNew = new String ('0', (int) uLen-1);
					status = wmiPathTmp.GetServer_(ref uLen, serverNew);

					if (status >= 0)
					{
						// Compare server name on this object, if specified, to the caller's.
						//     Update this object if different or unspecified.
						uLen = 0;
						status = wmiPath.GetServer_(ref uLen, null);			// NB: Cannot use property get since it may throw.

						if (status >= 0)
						{
							string serverOrg = new String('0', (int)uLen-1);
							status = wmiPath.GetServer_(ref uLen, serverOrg);

							if (status >= 0 && String.Compare(serverOrg, serverNew, true,CultureInfo.InvariantCulture) != 0)
								status = wmiPath.SetServer_(serverNew);
						}
						else if (status == (int)tag_WBEMSTATUS.WBEM_E_NOT_AVAILABLE)
						{
							status = wmiPath.SetServer_(serverNew);
							if (status >= 0)
								bChange = true;
						}
					}
				}
				else if (status == (int)tag_WBEMSTATUS.WBEM_E_NOT_AVAILABLE)	// No caller-supplied server name;
					status = (int)ManagementStatus.NoError;						// Ignore error.
			}

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}

			return nsNew;
		}

		internal string GetNamespacePath(int flags)
		{
			return GetNamespacePath(wmiPath, flags);
		}

		internal string GetNamespacePath(IWbemPath wbemPath, int flags)
		{
			string pathStr = String.Empty;

			if (null != wbemPath)
			{
				// TODO - due to a bug in the current WMI path
				// parser, requesting the namespace path from a parser which has
				// been only given a relative path results in an incorrect
				// value being returned (e.g. \\.\). To work
				// around this for now we check if there are any namespaces,
				// and if not just return "".
				uint nCount = 0;
				int status = (int)ManagementStatus.NoError;

				status = wbemPath.GetNamespaceCount_(out nCount);

				if (status >= 0 && nCount > 0)
				{
					// Get the space we need to reserve
					uint bufLen = 0;
					status = wbemPath.GetText_(flags, ref bufLen, null);

					if (status >= 0 && bufLen > 0)
					{
						pathStr = new String ('0', (int) bufLen-1);
						status = wbemPath.GetText_(flags, ref bufLen, pathStr);
					}
				}

				if (status < 0)
				{
					if (status == (int)tag_WBEMSTATUS.WBEM_E_INVALID_PARAMETER)
						;	// Interpret as unspecified - return ""
					else if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}
			}

			return pathStr;
		}

		/// <summary>
		///    <para>Gets or sets the namespace part of the path. Note that this does not include
		///       the server name, which can be retrieved separately.</para>
		/// </summary>
		/// <value>
		///    A string containing the namespace
		///    portion of the path represented in this object.
		/// </value>
		[RefreshProperties(RefreshProperties.All)]
		public string NamespacePath {
			get 
			{
				return GetNamespacePath((int)tag_WBEM_GET_TEXT_FLAGS.WBEMPATH_GET_NAMESPACE_ONLY);
			}
			set	
			{
				bool bChange = false;

				try
				{
					// isWbemPathShared handled in internal SetNamespacePath.
					SetNamespacePath(value, out bChange);
				}
				catch (COMException)
				{
					throw new ArgumentOutOfRangeException ();
				}

				if (bChange)
					FireIdentifierChanged();
			}
		}

		/// <summary>
		///    Gets or sets the class portion of the path.
		/// </summary>
		/// <value>
		///    A string containing the name of the
		///    class.
		/// </value>
		[RefreshProperties(RefreshProperties.All)]
		public string ClassName
		{
			get
			{
				return internalClassName;
			}
			set 
			{
				String oldValue = ClassName;

				// Only set if changed
				if (0 != String.Compare(oldValue,value,true,CultureInfo.InvariantCulture))
				{
					// isWbemPathShared handled in internal className property accessor.
					internalClassName = value;
					FireIdentifierChanged();
				}
			}
		}

		internal string internalClassName
		{
			get
			{
				String pathStr = String.Empty;
				int status = (int)ManagementStatus.NoError;

				if (null != wmiPath)
				{
					uint bufLen = 0;
					status = wmiPath.GetClassName_(ref bufLen, null);

					if (status >= 0 && 0 < bufLen)
					{
						pathStr = new String ('0', (int) bufLen-1);
						status = wmiPath.GetClassName_(ref bufLen, pathStr);

						if (status < 0)
							pathStr = String.Empty;
					}
				}

				return pathStr;
			}
			set
			{
				int status = (int)ManagementStatus.NoError;

				if (wmiPath == null)
					wmiPath = (IWbemPath)MTAHelper.CreateInMTA(typeof(WbemDefPath));//new WbemDefPath();
				else if (isWbemPathShared)
				{
					// Check if this IWbemPath is shared among multiple managed objects.
					// With this write, it will have to maintain its own copy.
					wmiPath = CreateWbemPath(this.GetWbemPath());
					isWbemPathShared = false;
				}

				try
				{
					status = wmiPath.SetClassName_(value);
				}
				catch (COMException)
				{       // BUGBUG : Change this?
					throw new ArgumentOutOfRangeException ();
				}

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}
			}
		}
			
		/// <summary>
		///    <para>Gets or sets a value indicating whether this is a class path.</para>
		/// </summary>
		/// <value>
		/// <para><see langword='true'/> if this is a class path; otherwise, 
		/// <see langword='false'/>.</para>
		/// </value>
		public bool IsClass 
		{
			get
			{
				if (null == wmiPath)
					return false;

				ulong uInfo = 0;
				int status = wmiPath.GetInfo_(0, out uInfo);

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}

				return (0 != (uInfo & (ulong)tag_WBEM_PATH_STATUS_FLAG.WBEMPATH_INFO_IS_CLASS_REF));
			}
		}

		/// <summary>
		///    <para>Gets or sets a value indicating whether this is an instance path.</para>
		/// </summary>
		/// <value>
		/// <para><see langword='true'/> if this is an instance path; otherwise, 
		/// <see langword='false'/>.</para>
		/// </value>
		public bool IsInstance 
		{
			get
			{
				if (null == wmiPath)
					return false;

				ulong uInfo = 0;
				int status = wmiPath.GetInfo_(0, out uInfo);

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}

				return (0 != (uInfo & (ulong)tag_WBEM_PATH_STATUS_FLAG.WBEMPATH_INFO_IS_INST_REF));
			}
		}

		/// <summary>
		///    <para>Gets or sets a value indicating whether this is a singleton instance path.</para>
		/// </summary>
		/// <value>
		/// <para><see langword='true'/> if this is a singleton instance path; otherwise, 
		/// <see langword='false'/>.</para>
		/// </value>
		public bool IsSingleton 
		{
			get
			{
				if (null == wmiPath)
					return false;

				ulong uInfo = 0;
				int status = wmiPath.GetInfo_(0, out uInfo);

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}

				return (0 != (uInfo & (ulong)tag_WBEM_PATH_STATUS_FLAG.WBEMPATH_INFO_IS_SINGLETON));
			}
		}
	}

	/// <summary>
	/// Converts a String to a ManagementPath
	/// </summary>
	class ManagementPathConverter : ExpandableObjectConverter 
	{
        
		/// <summary>
		/// Determines if this converter can convert an object in the given source type to the native type of the converter. 
		/// </summary>
		/// <param name='context'>An ITypeDescriptorContext that provides a format context.</param>
		/// <param name='sourceType'>A Type that represents the type you wish to convert from.</param>
		/// <returns>
		///    <para>true if this converter can perform the conversion; otherwise, false.</para>
		/// </returns>
		public override Boolean CanConvertFrom(ITypeDescriptorContext context, Type sourceType) 
		{
			if ((sourceType == typeof(ManagementPath))) 
			{
				return true;
			}
			return base.CanConvertFrom(context,sourceType);
		}
        
		/// <summary>
		/// Gets a value indicating whether this converter can convert an object to the given destination type using the context.
		/// </summary>
		/// <param name='context'>An ITypeDescriptorContext that provides a format context.</param>
		/// <param name='destinationType'>A Type that represents the type you wish to convert to.</param>
		/// <returns>
		///    <para>true if this converter can perform the conversion; otherwise, false.</para>
		/// </returns>
		public override Boolean CanConvertTo(ITypeDescriptorContext context, Type destinationType) 
		{
			if ((destinationType == typeof(InstanceDescriptor))) 
			{
				return true;
			}
			return base.CanConvertTo(context,destinationType);
		}
        
		/// <summary>
		///      Converts the given object to another type.  The most common types to convert
		///      are to and from a string object.  The default implementation will make a call
		///      to ToString on the object if the object is valid and if the destination
		///      type is string.  If this cannot convert to the desitnation type, this will
		///      throw a NotSupportedException.
		/// </summary>
		/// <param name='context'>An ITypeDescriptorContext that provides a format context.</param>
		/// <param name='culture'>A CultureInfo object. If a null reference (Nothing in Visual Basic) is passed, the current culture is assumed.</param>
		/// <param name='value'>The Object to convert.</param>
		/// <param name='destinationType'>The Type to convert the value parameter to.</param>
		/// <returns>An Object that represents the converted value.</returns>
		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) 
		{

			if (destinationType == null) 
			{
				throw new ArgumentNullException("destinationType");
			}

			if (value is ManagementPath && destinationType == typeof(InstanceDescriptor)) 
			{
				ManagementPath obj = ((ManagementPath)(value));
				ConstructorInfo ctor = typeof(ManagementPath).GetConstructor(new Type[] {typeof(System.String)});
				if (ctor != null) 
				{
					return new InstanceDescriptor(ctor, new object[] {obj.Path});
				}
			}
			return base.ConvertTo(context,culture,value,destinationType);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\managementoptions.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Diagnostics;
using System.Text;
using System.Collections;
using System.ComponentModel;

using System.Security.Cryptography;
using WbemClient_v1;


namespace System.Management
{
	/// <summary>
	///    <para>Describes the authentication level to be used to connect to WMI. This is used for the COM connection to WMI.</para>
	/// </summary>
	public enum AuthenticationLevel 
	{ 
		/// <summary>
		///    <para>The default COM authentication level. WMI uses the default Windows Authentication setting.</para>
		/// </summary>
		Default=0, 
		/// <summary>
		///    <para> No COM authentication.</para>
		/// </summary>
		None=1, 
		/// <summary>
		///    <para> Connect-level COM authentication.</para>
		/// </summary>
		Connect=2, 
		/// <summary>
		///    <para> Call-level COM authentication.</para>
		/// </summary>
		Call=3, 
		/// <summary>
		///    <para> Packet-level COM authentication.</para>
		/// </summary>
		Packet=4, 
		/// <summary>
		///    <para>Packet Integrity-level COM authentication.</para>
		/// </summary>
		PacketIntegrity=5,
		/// <summary>
		///    <para>Packet Privacy-level COM authentication.</para>
		/// </summary>
		PacketPrivacy=6,
		/// <summary>
		///    <para>Authentication level should remain as it was before.</para>
		/// </summary>
		Unchanged=-1
	}

	/// <summary>
	///    <para>Describes the impersonation level to be used to connect to WMI.</para>
	/// </summary>
	public enum ImpersonationLevel 
	{ 
		/// <summary>
		///    <para>Default impersonation.</para>
		/// </summary>
		Default=0,
		/// <summary>
		///    <para> Anonymous COM impersonation level that hides the 
		///       identity of the caller. Calls to WMI may fail
		///       with this impersonation level.</para>
		/// </summary>
		Anonymous=1, 
		/// <summary>
		///    <para> Identify-level COM impersonation level that allows objects 
		///       to query the credentials of the caller. Calls to
		///       WMI may fail with this impersonation level.</para>
		/// </summary>
		Identify=2, 
		/// <summary>
		///    <para> Impersonate-level COM impersonation level that allows 
		///       objects to use the credentials of the caller. This is the recommended impersonation level for WMI calls.</para>
		/// </summary>
		Impersonate=3, 
		/// <summary>
		///    <para> Delegate-level COM impersonation level that allows objects
		///       to permit other objects to use the credentials of the caller. This
		///       level, which will work with WMI calls but may constitute an unnecessary
		///       security risk, is supported only under Windows 2000.</para>
		/// </summary>
		Delegate=4 
	}
	
	/// <summary>
	///    <para>Describes the possible effects of saving an object to WMI when 
	///       using <see cref='System.Management.ManagementObject.Put'/>.</para>
	/// </summary>
	public enum PutType 
	{ 
		/// <summary>
		///    <para> Updates an existing object
		///       only; does not create a new object.</para>
		/// </summary>
		UpdateOnly=1, 
		/// <summary>
		///    <para> Creates an object only;
		///       does not update an existing object.</para>
		/// </summary>
		CreateOnly=2, 
		/// <summary>
		///    <para> Saves the object, whether
		///       updating an existing object or creating a new object.</para>
		/// </summary>
		UpdateOrCreate=3 
	}

	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para>Provides an abstract base class for all options objects.</para>
	/// </summary>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	[TypeConverter(typeof(ExpandableObjectConverter))]
	abstract public class ManagementOptions : ICloneable
	{
		/// <summary>
		///    <para> Specifies an infinite timeout.</para>
		/// </summary>
		public static readonly TimeSpan InfiniteTimeout = TimeSpan.MaxValue;

		internal int flags;
		internal ManagementNamedValueCollection context;
		internal TimeSpan timeout;

		//Used when any public property on this object is changed, to signal
		//to the containing object that it needs to be refreshed.
		internal event IdentifierChangedEventHandler IdentifierChanged;

		//Fires IdentifierChanged event
		internal void FireIdentifierChanged()
		{
			if (IdentifierChanged != null)
				IdentifierChanged(this, null);
		}

		//Called when IdentifierChanged() event fires
		internal void HandleIdentifierChange(object sender,
							IdentifierChangedEventArgs args)
		{
			//Something inside ManagementOptions changed, we need to fire an event
			//to the parent object
			FireIdentifierChanged();
		}
		
		internal int Flags {
			get { return flags; }
			set { flags = value; }
		}

		/// <summary>
		///    <para> Gets or sets a WMI context object. This is a
		///       name-value pairs list to be passed through to a WMI provider that supports
		///       context information for customized operation.</para>
		/// </summary>
		/// <value>
		///    <para>A name-value pairs list to be passed through to a WMI provider that
		///       supports context information for customized operation.</para>
		/// </value>
		public ManagementNamedValueCollection Context 
		{
			get
			{
				if (context == null)
					return context = new ManagementNamedValueCollection();
				else
					return context;
			}
			set
			{
				ManagementNamedValueCollection oldContext = context;

				if (null != value)
					context = (ManagementNamedValueCollection) value.Clone();
				else
					context = new ManagementNamedValueCollection ();

				if (null != oldContext)
					oldContext.IdentifierChanged -= new IdentifierChangedEventHandler(HandleIdentifierChange);

				//register for change events in this object
				context.IdentifierChanged += new IdentifierChangedEventHandler(HandleIdentifierChange);

				//the context property has changed so act like we fired the event
				HandleIdentifierChange(this,null);
			}
		}

		/// <summary>
		///    <para>Gets or sets the timeout to apply to the operation. 
		///       Note that for operations that return collections, this timeout applies to the
		///       enumeration through the resulting collection, not the operation itself
		///       (the <see cref='System.Management.EnumerationOptions.ReturnImmediately'/>
		///       property is used for the latter).</para>
		///    This property is used to indicate that the operation should be performed semisynchronously.
		/// </summary>
		/// <value>
		/// <para>The default value for this property is <see cref='System.Management.ManagementOptions.InfiniteTimeout'/> 
		/// , which means the operation will block.
		/// The value specified must be positive.</para>
		/// </value>
		public TimeSpan Timeout 
		{
			get 
			{ return timeout; }
			set 
			{ 
				//Timespan allows for negative values, but we want to make sure it's positive here...
				if (value.Ticks < 0)
					throw new ArgumentOutOfRangeException();

				timeout = value;
				FireIdentifierChanged();
			}
		}


		internal ManagementOptions() : this(null, InfiniteTimeout) {}
		internal ManagementOptions(ManagementNamedValueCollection context, TimeSpan timeout) : this(context, timeout, 0) {}
		internal ManagementOptions(ManagementNamedValueCollection context, TimeSpan timeout, int flags)
		{
			this.flags = flags;
			if (context != null)
				this.Context = context;
			else
				this.context = null;
			this.Timeout = timeout;
		}


		internal IWbemContext GetContext () {
			if (context != null)
				return context.GetContext();
			else
				return null;
		}
		
		// We do not expose this publicly; instead the flag is set automatically
		// when making an async call if we detect that someone has requested to
		// listen for status messages.
		internal bool SendStatus 
		{
			get 
			{ return (((Flags & (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_SEND_STATUS) != 0) ? true : false); }
			set 
			{
				Flags = (value == false) ? (Flags & (int)~tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_SEND_STATUS) : 
					(Flags | (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_SEND_STATUS);
			}
		}

		/// <summary>
		///    <para> Returns a copy of the object.</para>
		/// </summary>
		/// <returns>
		///    <para>The cloned object.</para>
		/// </returns>
		public abstract object Clone();
	}


	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para>Provides a base class for query and enumeration-related options
	///       objects.</para>
	/// </summary>
	/// <example>
	///    <code lang='C#'>using System;
	/// using System.Management;
	/// 
	/// // This example demonstrates how to enumerate all top-level WMI classes
	/// // and subclasses in root/cimv2 namespace.
	/// class Sample_EnumerationOptions
	/// {
	///     public static int Main(string[] args) {
	///         ManagementClass newClass = new ManagementClass();
	///         EnumerationOptions options = new EnumerationOptions();
	///         options.EnumerateDeep = false;
	///         foreach(ManagementObject o in newClass.GetSubclasses(options)) {
	///             Console.WriteLine(o["__Class"]);
	///         }
	///         return 0;
	///     }
	/// }
	///    </code>
	///    <code lang='VB'>Imports System
	/// Imports System.Management
	/// 
	/// ' This example demonstrates how to enumerate all top-level WMI classes
	/// ' and subclasses in root/cimv2 namespace.
	/// Class Sample_EnumerationOptions
	///     Overloads Public Shared Function Main(args() As String) As Integer
	///         Dim newClass As New ManagementClass()
	///         Dim options As New EnumerationOptions()
	///         options.EnumerateDeep = False
	///         Dim o As ManagementObject
	///         For Each o In newClass.GetSubclasses(options)
	///             Console.WriteLine(o("__Class"))
	///         Next o
	///         Return 0
	///     End Function
	/// End Class
	///    </code>
	/// </example>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class EnumerationOptions : ManagementOptions
	{
		private int blockSize;

		/// <summary>
		///    <para>Gets or sets a value indicating whether the invoked operation should be 
		///       performed in a synchronous or semisynchronous fashion. If this property is set
		///       to <see langword='true'/>, the enumeration is invoked and the call returns immediately. The actual
		///       retrieval of the results will occur when the resulting collection is walked.</para>
		/// </summary>
		/// <value>
		/// <para><see langword='true'/> if the invoked operation should 
		///    be performed in a synchronous or semisynchronous fashion; otherwise,
		/// <see langword='false'/>. The default value is <see langword='true'/>.</para>
		/// </value>
		public bool ReturnImmediately 
		{
			get { return (((Flags & (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_RETURN_IMMEDIATELY) != 0) ? true : false); }
			set {
				Flags = (value == false) ? (Flags & (int)~tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_RETURN_IMMEDIATELY) : 
							(Flags | (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_RETURN_IMMEDIATELY);
			}
		}

		/// <summary>
		///    <para> Gets or sets the block size
		///       for block operations. When enumerating through a collection, WMI will return results in
		///       groups of the specified size.</para>
		/// </summary>
		/// <value>
		///    <para>The default value is 1.</para>
		/// </value>
		public int BlockSize 
		{
			get { return blockSize; }
			set { 
				//Unfortunately BlockSize was defined as int, but valid values are only  > 0
				if (value <= 0)
					throw new ArgumentOutOfRangeException();

				blockSize = value;
			}
		}

		/// <summary>
		///    <para>Gets or sets a value indicating whether the collection is assumed to be 
		///       rewindable. If <see langword='true'/>, the objects in the
		///       collection will be kept available for multiple enumerations. If
		///    <see langword='false'/>, the collection
		///       can only be enumerated one time.</para>
		/// </summary>
		/// <value>
		/// <para><see langword='true'/> if the collection is assumed to 
		///    be rewindable; otherwise, <see langword='false'/>. The default value is
		/// <see langword='true'/>.</para>
		/// </value>
		/// <remarks>
		///    <para>A rewindable collection is more costly in memory
		///       consumption as all the objects need to be kept available at the same time.
		///       In a collection defined as non-rewindable, the objects are discarded after being returned
		///       in the enumeration.</para>
		/// </remarks>
		public bool Rewindable 
		{
			get { return (((Flags & (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_FORWARD_ONLY) != 0) ? false : true); }
			set { 
				Flags = (value == true) ? (Flags & (int)~tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_FORWARD_ONLY) : 
											(Flags | (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_FORWARD_ONLY);
			}
		}	

		/// <summary>
		///    <para> Gets or sets a value indicating whether the objects returned from
		///       WMI should contain amended information. Typically, amended information is localizable
		///       information attached to the WMI object, such as object and property
		///       descriptions.</para>
		/// </summary>
		/// <value>
		/// <para><see langword='true'/> if the objects returned from WMI 
		///    should contain amended information; otherwise, <see langword='false'/>. The
		///    default value is <see langword='false'/>.</para>
		/// </value>
		/// <remarks>
		///    <para>If descriptions and other amended information are not of 
		///       interest, setting this property to <see langword='false'/>
		///       is more
		///       efficient.</para>
		/// </remarks>
		public bool UseAmendedQualifiers 
		{
			get { return (((Flags & (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_USE_AMENDED_QUALIFIERS) != 0) ? true : false); }
			set { 
				Flags = (value == true) ? (Flags | (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_USE_AMENDED_QUALIFIERS) :
											(Flags & (int)~tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_USE_AMENDED_QUALIFIERS); 
			}
		}

		/// <summary>
		///    <para>Gets or sets a value indicating whether to the objects returned should have
		///       locatable information in them. This ensures that the system properties, such as
		///    <see langword='__PATH'/>, <see langword='__RELPATH'/>, and 
		///    <see langword='__SERVER'/>, are non-NULL. This flag can only be used in queries,
		///       and is ignored in enumerations.</para>
		/// </summary>
		/// <value>
		/// <para><see langword='true'/> if WMI 
		///    should ensure all returned objects have valid paths; otherwise,
		/// <see langword='false'/>. The default value is <see langword='false'/>.</para>
		/// </value>
		public bool EnsureLocatable 
		{
			get 
			{ return (((Flags & (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_ENSURE_LOCATABLE) != 0) ? true : false); }
			set 
			{ Flags = (value == true) ? (Flags | (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_ENSURE_LOCATABLE) :
					  (Flags & (int)~tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_ENSURE_LOCATABLE) ; }
		}


		/// <summary>
		///    <para>Gets or sets a value indicating whether the query should return a
		///       prototype of the result set instead of the actual results. This flag is used for
		///       prototyping.</para>
		/// </summary>
		/// <value>
		/// <para><see langword='true'/> if the 
		///    query should return a prototype of the result set instead of the actual results;
		///    otherwise, <see langword='false'/>. The default value is
		/// <see langword='false'/>.</para>
		/// </value>
		public bool PrototypeOnly 
		{
			get 
			{ return (((Flags & (int)tag_WBEM_QUERY_FLAG_TYPE.WBEM_FLAG_PROTOTYPE) != 0) ? true : false); }
			set 
			{ Flags = (value == true) ? (Flags | (int)tag_WBEM_QUERY_FLAG_TYPE.WBEM_FLAG_PROTOTYPE) :
					  (Flags & (int)~tag_WBEM_QUERY_FLAG_TYPE.WBEM_FLAG_PROTOTYPE) ; }
		}

		/// <summary>
		///    <para> Gets or sets a value indicating whether direct access to the WMI provider is requested for the specified
		///       class, without any regard to its superclass or derived classes.</para>
		/// </summary>
		/// <value>
		/// <para><see langword='true'/> if only 
		///    objects of the specified class should be received, without regard to derivation
		///    or inheritance; otherwise, <see langword='false'/>. The default value is
		/// <see langword='false'/>. </para>
		/// </value>
		public bool DirectRead 
		{
			get 
			{ return (((Flags & (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_DIRECT_READ) != 0) ? true : false); }
			set 
			{ Flags = (value == true) ? (Flags | (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_DIRECT_READ) :
					  (Flags & (int)~tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_DIRECT_READ) ; }
		}

		
		/// <summary>
		///    <para> Gets or sets a value indicating whether recursive enumeration is 
		///       requested into all classes derived from the specified superclass. If
		///    <see langword='false'/>, only immediate derived
		///       class members are returned.</para>
		/// </summary>
		/// <value>
		/// <para><see langword='true'/> if recursive enumeration is 
		///    requested into all classes derived from the specified superclass; otherwise,
		/// <see langword='false'/>. The default value is <see langword='false'/>.</para>
		/// </value>
		public bool EnumerateDeep 
		{
			get 
			{ return (((Flags & (int)tag_WBEM_QUERY_FLAG_TYPE.WBEM_FLAG_SHALLOW) != 0) ? false : true); }
			set 
			{ Flags = (value == false) ? (Flags | (int)tag_WBEM_QUERY_FLAG_TYPE.WBEM_FLAG_SHALLOW) :
					  (Flags & (int)~tag_WBEM_QUERY_FLAG_TYPE.WBEM_FLAG_SHALLOW); }
		}

		
		//default constructor
		/// <overload>
		///    Initializes a new instance
		///    of the <see cref='System.Management.EnumerationOptions'/> class.
		/// </overload>
		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.EnumerationOptions'/>
		/// class with default values (see the individual property descriptions
		/// for what the default values are). This is the default constructor. </para>
		/// </summary>
		public EnumerationOptions() : this (null, InfiniteTimeout, 1, true, true, false, false, false, false, false) {}
		

		
		//Constructor that specifies flags as individual values - we need to set the flags acordingly !
		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.EnumerationOptions'/> class to be used for queries or enumerations, 
		///    allowing the user to specify values for the different options.</para>
		/// </summary>
		/// <param name='context'>The options context object containing provider-specific information that can be passed through to the provider.</param>
		/// <param name=' timeout'>The timeout value for enumerating through the results.</param>
		/// <param name=' blockSize'>The number of items to retrieve at one time from WMI.</param>
		/// <param name=' rewindable'><see langword='true'/> to specify whether the result set is rewindable (=allows multiple traversal or one-time); otherwise, <see langword='false'/>.</param>
		/// <param name=' returnImmediatley'><see langword='true'/> to specify whether the operation should return immediately (semi-sync) or block until all results are available; otherwise, <see langword='false'/> .</param>
		/// <param name=' useAmendedQualifiers'><see langword='true'/> to specify whether the returned objects should contain amended (locale-aware) qualifiers; otherwise, <see langword='false'/> .</param>
		/// <param name=' ensureLocatable'><see langword='true'/> to specify to WMI that it should ensure all returned objects have valid paths; otherwise, <see langword='false'/> .</param>
		/// <param name=' prototypeOnly'><see langword='true'/> to return a prototype of the result set instead of the actual results; otherwise, <see langword='false'/> .</param>
		/// <param name=' directRead'><see langword='true'/> to to retrieve objects of only the specified class only or from derived classes as well; otherwise, <see langword='false'/> .</param>
		/// <param name=' enumerateDeep'><see langword='true'/> to specify recursive enumeration in subclasses; otherwise, <see langword='false'/> .</param>
		public EnumerationOptions(
			ManagementNamedValueCollection context, 
			TimeSpan timeout, 
			int blockSize,
			bool rewindable,
			bool returnImmediatley,
			bool useAmendedQualifiers,
			bool ensureLocatable,
			bool prototypeOnly,
			bool directRead,
			bool enumerateDeep) : base(context, timeout)
		{
			BlockSize = blockSize;
			Rewindable = rewindable;
			ReturnImmediately = returnImmediatley;
			UseAmendedQualifiers = useAmendedQualifiers;
			EnsureLocatable = ensureLocatable;
			PrototypeOnly = prototypeOnly;
			DirectRead = directRead;
			EnumerateDeep = enumerateDeep;
		}

		/// <summary>
		///    <para> Returns a copy of the object.</para>
		/// </summary>
		/// <returns>
		///    <para>The cloned object.</para>
		/// </returns>
		public override object Clone ()
		{
			ManagementNamedValueCollection newContext = null;

			if (null != Context)
				newContext = (ManagementNamedValueCollection)Context.Clone();

			return new EnumerationOptions (newContext, Timeout, blockSize, Rewindable,
							ReturnImmediately, UseAmendedQualifiers, EnsureLocatable, PrototypeOnly, DirectRead, EnumerateDeep);
		}
		
	}//EnumerationOptions



	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para> Specifies options for management event watching.</para>
	/// </summary>
	/// <example>
	///    <code lang='C#'>using System; 
	/// using System.Management; 
	/// 
	/// // This example demonstrates how to specify a timeout and a batch count 
	/// // when listening to an event using ManagementEventWatcher object. 
	/// class Sample_EventWatcherOptions 
	/// { 
	///     public static int Main(string[] args) {
	///         ManagementClass newClass = new ManagementClass(); 
	///         newClass["__CLASS"] = "TestDeletionClass"; 
	///         newClass.Put(); 
	///         
	///         EventWatcherOptions options = new EventWatcherOptions(null, 
	///                                                               new TimeSpan(0,0,0,5),
	///                                                               1); 
	///         ManagementEventWatcher watcher = new ManagementEventWatcher(null, 
	///                                                                     new WqlEventQuery("__classdeletionevent"), 
	///                                                                     options); 
	///         MyHandler handler = new MyHandler(); 
	///         watcher.EventArrived += new EventArrivedEventHandler(handler.Arrived); 
	///         watcher.Start(); 
	/// 
	///         // Delete class to trigger event
	///         newClass.Delete(); 
	/// 
	///         //For the purpose of this example, we will wait
	///         // two seconds before main thread terminates.
	///         System.Threading.Thread.Sleep(2000); 
	/// 
	///         watcher.Stop(); 
	/// 
	///         return 0;
	///     } 
	/// 
	///     public class MyHandler
	///     {
	///        public void Arrived(object sender, EventArrivedEventArgs e) {
	///            Console.WriteLine("Class Deleted= " +
	///                ((ManagementBaseObject)e.NewEvent["TargetClass"])["__CLASS"]);
	///        } 
	///     }
	/// }
	///    </code>
	///    <code lang='VB'>Imports System
	/// Imports System.Management
	/// 
	/// ' This example demonstrates how to specify a timeout and a batch count 
	/// ' when listening to an event using the ManagementEventWatcher object. 
	/// Class Sample_EventWatcherOptions
	///     Public Shared Sub Main() 
	///         Dim newClass As New ManagementClass() 
	///         newClass("__CLASS") = "TestDeletionClass"
	///         newClass.Put()
	///     
	///         Dim options As _
	///             New EventWatcherOptions(Nothing, New TimeSpan(0, 0, 0, 5), 1)
	///         Dim watcher As New ManagementEventWatcher( _
	///             Nothing, _
	///             New WqlEventQuery("__classdeletionevent"), _
	///             options)
	///         Dim handler As New MyHandler()
	///         AddHandler watcher.EventArrived, AddressOf handler.Arrived
	///         watcher.Start()
	///       
	///         ' Delete class to trigger event
	///         newClass.Delete()
	///       
	///         ' For the purpose of this example, we will wait
	///         ' two seconds before main thread terminates.
	///         System.Threading.Thread.Sleep(2000)
	///         watcher.Stop()
	///     End Sub
	///      
	///     Public Class MyHandler
	///         Public Sub Arrived(sender As Object, e As EventArrivedEventArgs)
	///             Console.WriteLine("Class Deleted = " &amp; _
	///                 CType(e.NewEvent("TargetClass"), ManagementBaseObject)("__CLASS"))
	///         End Sub
	///     End Class
	/// End Class
	///    </code>
	/// </example>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class EventWatcherOptions : ManagementOptions
	{
		private int blockSize = 1;
		
		/// <summary>
		///    <para>Gets or sets the block size for block operations. When waiting for events, this
		///       value specifies how many events to wait for before returning.</para>
		/// </summary>
		/// <value>
		///    <para>The default value is 1.</para>
		/// </value>
		public int BlockSize 
		{
			get { return blockSize; }
			set 
			{ 
				blockSize = value; 
				FireIdentifierChanged ();
			}

		}

		/// <overload>
		/// <para>Initializes a new instance of the <see cref='System.Management.EventWatcherOptions'/> class. </para>
		/// </overload>
		/// <summary>
		/// <para> Initializes a new instance of the <see cref='System.Management.EventWatcherOptions'/> class for event watching, using default values.
		///    This is the default constructor.</para>
		/// </summary>
		public EventWatcherOptions() 
			: this (null, InfiniteTimeout, 1) {}

		/// <summary>
		/// <para> Initializes a new instance of the <see cref='System.Management.EventWatcherOptions'/> class with the given
		///    values.</para>
		/// </summary>
		/// <param name='context'>The options context object containing provider-specific information to be passed through to the provider. </param>
		/// <param name=' timeout'>The timeout to wait for the next events.</param>
		/// <param name=' blockSize'>The number of events to wait for in each block.</param>
		public EventWatcherOptions(ManagementNamedValueCollection context, TimeSpan timeout, int blockSize) 
			: base(context, timeout) 
		{
			Flags = (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_RETURN_IMMEDIATELY|(int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_FORWARD_ONLY;
			BlockSize = blockSize;
		}

		/// <summary>
		///    <para> Returns a copy of the object.</para>
		/// </summary>
		/// <returns>
		///    The cloned object.
		/// </returns>
		public override object Clone () 
		{
			ManagementNamedValueCollection newContext = null;

			if (null != Context)
				newContext = (ManagementNamedValueCollection)Context.Clone();

			return new EventWatcherOptions (newContext, Timeout, blockSize);
		}
	}//EventWatcherOptions



	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para> Specifies options for getting a management object.</para>
	/// </summary>
	/// <example>
	///    <code lang='C#'>using System;
	/// using System.Management;
	/// 
	/// // This example demonstrates how to set a timeout value and list
	/// // all amended qualifiers in a ManagementClass object.
	/// class Sample_ObjectGetOptions
	/// {
	///     public static int Main(string[] args) {
	///         // Request amended qualifiers
	///         ObjectGetOptions options =
	///             new ObjectGetOptions(null, new TimeSpan(0,0,0,5), true);
	///         ManagementClass diskClass =
	///             new ManagementClass("root/cimv2", "Win32_Process", options);
	///         foreach(QualifierData qualifier in diskClass.Qualifiers) {
	///             Console.WriteLine(qualifier.Name + ":" + qualifier.Value);
	///         }
	///         return 0;
	///     }
	/// }
	///    </code>
	///    <code lang='VB'>Imports System
	/// Imports System.Management
	/// 
	/// ' This example demonstrates how to set a timeout value and list
	/// ' all amended qualifiers in a ManagementClass object.
	/// Class Sample_ObjectGetOptions
	///     Overloads Public Shared Function Main(args() As String) As Integer
	///         ' Request amended qualifiers
	///         Dim options As _
	///             New ObjectGetOptions(Nothing, New TimeSpan(0, 0, 0, 5), True)
	///         Dim diskClass As New ManagementClass( _
	///             "root/cimv2", _
	///             "Win32_Process", _
	///             options)
	///         Dim qualifier As QualifierData
	///         For Each qualifier In diskClass.Qualifiers
	///             Console.WriteLine(qualifier.Name &amp; ":" &amp; qualifier.Value)
	///         Next qualifier
	///         Return 0
	///     End Function
	/// End Class
	///    </code>
	/// </example>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class ObjectGetOptions : ManagementOptions
	{
		internal static ObjectGetOptions _Clone(ObjectGetOptions options)
		{
			return ObjectGetOptions._Clone(options, null);
		}

		internal static ObjectGetOptions _Clone(ObjectGetOptions options, IdentifierChangedEventHandler handler)
		{
			ObjectGetOptions optionsTmp;
			
			if (options != null)
				optionsTmp = new ObjectGetOptions(options.context, options.timeout, options.UseAmendedQualifiers);
			else
				optionsTmp = new ObjectGetOptions();

			// Wire up change handler chain. Use supplied handler, if specified;
			// otherwise, default to that of the path argument.
			if (handler != null)
				optionsTmp.IdentifierChanged += handler;
			else if (options != null)
				optionsTmp.IdentifierChanged += new IdentifierChangedEventHandler(options.HandleIdentifierChange);

			return optionsTmp;
		}

		/// <summary>
		///    <para> Gets or sets a value indicating whether the objects returned from WMI should
		///       contain amended information. Typically, amended information is localizable information
		///       attached to the WMI object, such as object and property descriptions.</para>
		/// </summary>
		/// <value>
		/// <para><see langword='true'/> if the objects returned from WMI 
		///    should contain amended information; otherwise, <see langword='false'/>. The
		///    default value is <see langword='false'/>.</para>
		/// </value>
		public bool UseAmendedQualifiers 
		{
			get { return (((Flags & (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_USE_AMENDED_QUALIFIERS) != 0) ? true : false); }
			set { 
				Flags = (value == true) ? (Flags | (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_USE_AMENDED_QUALIFIERS) :
											(Flags & (int)~tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_USE_AMENDED_QUALIFIERS); 
				FireIdentifierChanged();
			}
		}

		/// <overload>
		/// <para>Initializes a new instance of the <see cref='System.Management.ObjectGetOptions'/> class.</para>
		/// </overload>
		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.ObjectGetOptions'/> class for getting a WMI object, using
		///    default values. This is the default constructor.</para>
		/// </summary>
		public ObjectGetOptions() : this(null, InfiniteTimeout, false) {}

		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.ObjectGetOptions'/> class for getting a WMI object, using the
		///    specified provider-specific context.</para>
		/// </summary>
		/// <param name='context'>A provider-specific, named-value pairs context object to be passed through to the provider.</param>
		public ObjectGetOptions(ManagementNamedValueCollection context) : this(context, InfiniteTimeout, false) {}

		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.ObjectGetOptions'/> class for getting a WMI object,
		///    using the given options values.</para>
		/// </summary>
		/// <param name='context'>A provider-specific, named-value pairs context object to be passed through to the provider.</param>
		/// <param name=' timeout'>The length of time to let the operation perform before it times out. The default is <see cref='System.Management.ManagementOptions.InfiniteTimeout'/> .</param>
		/// <param name=' useAmendedQualifiers'><see langword='true'/> if the returned objects should contain amended (locale-aware) qualifiers; otherwise, <see langword='false'/>. </param>
		public ObjectGetOptions(ManagementNamedValueCollection context, TimeSpan timeout, bool useAmendedQualifiers) : base(context, timeout)
		{
			UseAmendedQualifiers = useAmendedQualifiers;
		}

		/// <summary>
		///    <para> Returns a copy of the object.</para>
		/// </summary>
		/// <returns>
		///    <para>The cloned object.</para>
		/// </returns>
		public override object Clone () 
		{
			ManagementNamedValueCollection newContext = null;

			if (null != Context)
				newContext = (ManagementNamedValueCollection)Context.Clone();

			return new ObjectGetOptions (newContext, Timeout, UseAmendedQualifiers);
		}
	}

	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para> Specifies options for committing management
	///       object changes.</para>
	/// </summary>
	/// <example>
	///    <code lang='C#'>using System; 
	/// using System.Management; 
	/// 
	/// // This example demonstrates how to specify a PutOptions using 
	/// // PutOptions object when saving a ManagementClass object to 
	/// // the WMI respository. 
	/// class Sample_PutOptions 
	/// {
	///     public static int Main(string[] args) { 
	///         ManagementClass newClass = new ManagementClass("root/default",
	///                                                        String.Empty,
	///                                                        null); 
	///         newClass["__Class"] = "class999xc";
	/// 
	///         PutOptions options = new PutOptions(); 
	///         options.Type = PutType.UpdateOnly;
	/// 
	///         try
	///         {
	///             newClass.Put(options); //will fail if the class doesn't already exist
	///         }
	///         catch (ManagementException e)
	///         {
	///             Console.WriteLine("Couldn't update class: " + e.ErrorCode);
	///         }
	///         return 0;
	///     }
	/// }
	///    </code>
	///    <code lang='VB'>Imports System
	/// Imports System.Management
	/// 
	/// ' This example demonstrates how to specify a PutOptions using
	/// ' PutOptions object when saving a ManagementClass object to
	/// ' WMI respository.
	/// Class Sample_PutOptions
	///     Overloads Public Shared Function Main(args() As String) As Integer
	///         Dim newClass As New ManagementClass( _
	///            "root/default", _
	///            String.Empty, _
	///            Nothing)
	///         newClass("__Class") = "class999xc"
	/// 
	///         Dim options As New PutOptions()
	///         options.Type = PutType.UpdateOnly 'will fail if the class doesn't already exist
	/// 
	///         Try
	///             newClass.Put(options)
	///         Catch e As ManagementException
	///             Console.WriteLine("Couldn't update class: " &amp; e.ErrorCode)
	///         End Try
	///         Return 0
	///     End Function
	/// End Class
	///    </code>
	/// </example>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class PutOptions : ManagementOptions
	{

		/// <summary>
		///    <para> Gets or sets a value indicating whether the objects returned from WMI should
		///       contain amended information. Typically, amended information is localizable information
		///       attached to the WMI object, such as object and property descriptions.</para>
		/// </summary>
		/// <value>
		/// <para><see langword='true'/> if the objects returned from WMI 
		///    should contain amended information; otherwise, <see langword='false'/>. The
		///    default value is <see langword='false'/>.</para>
		/// </value>
		public bool UseAmendedQualifiers 
		{
			get { return (((Flags & (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_USE_AMENDED_QUALIFIERS) != 0) ? true : false); }
			set { Flags = (value == true) ? (Flags | (int)tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_USE_AMENDED_QUALIFIERS) :
											(Flags & (int)~tag_WBEM_GENERIC_FLAG_TYPE.WBEM_FLAG_USE_AMENDED_QUALIFIERS); }
		}

		/// <summary>
		///    <para>Gets or sets the type of commit to be performed for the object.</para>
		/// </summary>
		/// <value>
		/// <para>The default value is <see cref='System.Management.PutType.UpdateOrCreate'/>.</para>
		/// </value>
		public PutType Type 
		{
			get { return (((Flags & (int)tag_WBEM_CHANGE_FLAG_TYPE.WBEM_FLAG_UPDATE_ONLY) != 0) ? PutType.UpdateOnly :
						  ((Flags & (int)tag_WBEM_CHANGE_FLAG_TYPE.WBEM_FLAG_CREATE_ONLY) != 0) ? PutType.CreateOnly : 
																				PutType.UpdateOrCreate);
			}
			set { 
				switch (value)
				{
					case PutType.UpdateOnly : Flags |= (int)tag_WBEM_CHANGE_FLAG_TYPE.WBEM_FLAG_UPDATE_ONLY; break;
					case PutType.CreateOnly : Flags |= (int)tag_WBEM_CHANGE_FLAG_TYPE.WBEM_FLAG_CREATE_ONLY; break;
					case PutType.UpdateOrCreate : Flags |= (int)tag_WBEM_CHANGE_FLAG_TYPE.WBEM_FLAG_CREATE_OR_UPDATE; break;
					default : throw new ArgumentException();
				}
			}
		}

		/// <overload>
		/// <para> Initializes a new instance of the <see cref='System.Management.PutOptions'/> class.</para>
		/// </overload>
		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.PutOptions'/> class for put operations, using default values.
		///    This is the default constructor.</para>
		/// </summary>
		public PutOptions() : this(null, InfiniteTimeout, false, PutType.UpdateOrCreate) {}

		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.PutOptions'/> class for committing a WMI object, using the
		///    specified provider-specific context.</para>
		/// </summary>
		/// <param name='context'>A provider-specific, named-value pairs context object to be passed through to the provider.</param>
		public PutOptions(ManagementNamedValueCollection context) : this(context, InfiniteTimeout, false, PutType.UpdateOrCreate) {}

		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.PutOptions'/> class for committing a WMI object, using
		///    the specified option values.</para>
		/// </summary>
		/// <param name='context'>A provider-specific, named-value pairs object to be passed through to the provider. </param>
		/// <param name=' timeout'>The length of time to let the operation perform before it times out. The default is <see cref='System.Management.ManagementOptions.InfiniteTimeout'/> .</param>
		/// <param name=' useAmendedQualifiers'><see langword='true'/> if the returned objects should contain amended (locale-aware) qualifiers; otherwise, <see langword='false'/>. </param>
		/// <param name=' putType'> The type of commit to be performed (update or create).</param>
		public PutOptions(ManagementNamedValueCollection context, TimeSpan timeout, bool useAmendedQualifiers, PutType putType) : base(context, timeout)
		{
			UseAmendedQualifiers = useAmendedQualifiers;
			Type = putType;
		}

		/// <summary>
		///    <para> Returns a copy of the object.</para>
		/// </summary>
		/// <returns>
		///    <para>The cloned object.</para>
		/// </returns>
		public override object Clone () 
		{
			ManagementNamedValueCollection newContext = null;

			if (null != Context)
				newContext = (ManagementNamedValueCollection)Context.Clone();

			return new PutOptions (newContext, Timeout, UseAmendedQualifiers, Type);
		}
	}

	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para> Specifies options for deleting a management
	///       object.</para>
	/// </summary>
	/// <example>
	///    <code lang='C#'>using System;
	/// using System.Management;
	/// 
	/// // This example demonstrates how to specify a timeout value
	/// // when deleting a ManagementClass object.
	/// class Sample_DeleteOptions
	/// {
	///     public static int Main(string[] args) {
	///         ManagementClass newClass = new ManagementClass();
	///         newClass["__CLASS"] = "ClassToDelete";
	///         newClass.Put();
	///    
	///         // Set deletion options: delete operation timeout value
	///         DeleteOptions opt = new DeleteOptions(null, new TimeSpan(0,0,0,5));
	///         
	///         ManagementClass dummyClassToDelete =
	///             new ManagementClass("ClassToDelete");
	///         dummyClassToDelete.Delete(opt);
	/// 
	///         return 0;
	///     }
	/// }
	///    </code>
	///    <code lang='VB'>Imports System
	/// Imports System.Management
	/// 
	/// ' This sample demonstrates how to specify a timeout value
	/// ' when deleting a ManagementClass object.
	/// Class Sample_DeleteOptions
	///     Overloads Public Shared Function Main(args() As String) As Integer
	///         Dim newClass As New ManagementClass()
	///         newClass("__CLASS") = "ClassToDelete"
	///         newClass.Put()
	/// 
	///         ' Set deletion options: delete operation timeout value
	///         Dim opt As New DeleteOptions(Nothing, New TimeSpan(0, 0, 0, 5))
	///         
	///         Dim dummyClassToDelete As New ManagementClass("ClassToDelete")
	///         dummyClassToDelete.Delete(opt)
	///         Return 0
	///     End Function
	/// End Class
	///    </code>
	/// </example>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class DeleteOptions : ManagementOptions
	{
		/// <overload>
		/// <para>Initializes a new instance of the <see cref='System.Management.DeleteOptions'/> class.</para>
		/// </overload>
		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.DeleteOptions'/> class for the delete operation, using default values.
		///    This is the default constructor.</para>
		/// </summary>
		public DeleteOptions() : base () {}

		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.DeleteOptions'/> class for a delete operation, using
		///    the specified values.</para>
		/// </summary>
		/// <param name='context'>A provider-specific, named-value pairs object to be passed through to the provider. </param>
		/// <param name='timeout'>The length of time to let the operation perform before it times out. The default value is <see cref='System.Management.ManagementOptions.InfiniteTimeout'/> . Setting this parameter will invoke the operation semisynchronously.</param>
		public DeleteOptions(ManagementNamedValueCollection context, TimeSpan timeout) : base(context, timeout) {}

		/// <summary>
		///    <para> Returns a copy of the object.</para>
		/// </summary>
		/// <returns>
		///    <para>A cloned object.</para>
		/// </returns>
		public override object Clone () 
		{
			ManagementNamedValueCollection newContext = null;

			if (null != Context)
				newContext = (ManagementNamedValueCollection)Context.Clone();

			return new DeleteOptions (newContext, Timeout);
		}
	}

	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para> Specifies options for invoking a management method.</para>
	/// </summary>
	/// <example>
	///    <code lang='C#'>using System; 
	/// using System.Management; 
	/// 
	/// // This example demonstrates how to stop a system service. 
	/// class Sample_InvokeMethodOptions 
	/// { 
	///     public static int Main(string[] args) {
	///         ManagementObject service = 
	///             new ManagementObject("win32_service=\"winmgmt\"");
	///         InvokeMethodOptions options = new InvokeMethodOptions();
	///         options.Timeout = new TimeSpan(0,0,0,5); 
	/// 
	///         ManagementBaseObject outParams = service.InvokeMethod("StopService", null, options);
	/// 
	///         Console.WriteLine("Return Status = " + outParams["ReturnValue"]);
	/// 
	///         return 0;
	///     }
	/// }
	///    </code>
	///    <code lang='VB'>Imports System
	/// Imports System.Management
	/// 
	/// ' This sample demonstrates how to stop a system service.
	/// Class Sample_InvokeMethodOptions
	///     Overloads Public Shared Function Main(args() As String) As Integer
	///         Dim service As New ManagementObject("win32_service=""winmgmt""")
	///         Dim options As New InvokeMethodOptions()
	///         options.Timeout = New TimeSpan(0, 0, 0, 5)
	///         
	///         Dim outParams As ManagementBaseObject = service.InvokeMethod( _
	///             "StopService", _
	///             Nothing, _
	///             options)
	/// 
	///         Console.WriteLine("Return Status = " &amp; _
	///             outParams("ReturnValue").ToString())
	///       
	///         Return 0
	///     End Function
	/// End Class
	///    </code>
	/// </example>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class InvokeMethodOptions : ManagementOptions
	{
		/// <overload>
		/// <para>Initializes a new instance of the <see cref='System.Management.InvokeMethodOptions'/> class.</para>
		/// </overload>
		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.InvokeMethodOptions'/> class for the <see cref='System.Management.ManagementObject.InvokeMethod'/> operation, using default values.
		///    This is the default constructor.</para>
		/// </summary>
		public InvokeMethodOptions() : base () {}

		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.InvokeMethodOptions'/> class for an invoke operation using 
		///    the specified values.</para>
		/// </summary>
		/// <param name=' context'>A provider-specific, named-value pairs object to be passed through to the provider. </param>
		/// <param name='timeout'>The length of time to let the operation perform before it times out. The default value is <see cref='System.Management.ManagementOptions.InfiniteTimeout'/> . Setting this parameter will invoke the operation semisynchronously.</param>
		public InvokeMethodOptions(ManagementNamedValueCollection context, TimeSpan timeout) : base(context, timeout) {}

		/// <summary>
		///    <para> Returns a copy of the object.</para>
		/// </summary>
		/// <returns>
		///    <para>The cloned object.</para>
		/// </returns>
		public override object Clone () 
		{
			ManagementNamedValueCollection newContext = null;

			if (null != Context)
				newContext = (ManagementNamedValueCollection)Context.Clone();

			return new InvokeMethodOptions (newContext, Timeout);
		}
	}


	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para> Specifies all settings required to make a WMI connection.</para>
	/// </summary>
	/// <example>
	///    <code lang='C#'>using System;
	/// using System.Management;
	/// 
	/// // This example demonstrates how to connect to remote machine
	/// // using supplied credentials.
	/// class Sample_ConnectionOptions
	/// {
	///     public static int Main(string[] args) {
	///         ConnectionOptions options = new ConnectionOptions();
	///         options.Username = UserName; //could be in domain\user format
	///         options.Password = SecurelyStoredPassword;
	///         ManagementScope scope = new ManagementScope(
	///             "\\\\servername\\root\\cimv2",
	///             options);
	///         try {
	///             scope.Connect();
	///             ManagementObject disk = new ManagementObject(
	///                 scope,
	///                 new ManagementPath("Win32_logicaldisk='c:'"),
	///                 null);
	///             disk.Get();
	///         }
	///         catch (Exception e) {
	///             Console.WriteLine("Failed to connect: " + e.Message);
	///         }
	///         return 0;
	///     }
	/// }
	///    </code>
	///    <code lang='VB'>Imports System
	/// Imports System.Management
	/// 
	/// ' This example demonstrates how to connect to remote machine
	/// ' using supplied credentials.
	/// Class Sample_ConnectionOptions
	///     Overloads Public Shared Function Main(args() As String) As Integer
	///         Dim options As New ConnectionOptions()
	///         options.Username = UserName
	///         options.Password = SecurelyStoredPassword
	///         Dim scope As New ManagementScope("\\servername\root\cimv2", options)
	///         Try
	///             scope.Connect()
	///             Dim disk As New ManagementObject(scope, _
	///                 New ManagementPath("Win32_logicaldisk='c:'"), Nothing)
	///             disk.Get()
	///         Catch e As UnauthorizedAccessException
	///             Console.WriteLine(("Failed to connect: " + e.Message))
	///         End Try
	///         Return 0
	///     End Function
	/// End Class
	///    </code>
	/// </example>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class ConnectionOptions : ManagementOptions
	{
		private class EncryptedData
		{
			private byte[] encryptedData = null;
			private Rijndael rijndael	 = null;

			public EncryptedData(EncryptedData data) { SetData(data); }
			public EncryptedData(string data) { SetData(data); }

			// This encrypts the passed data

			public void SetData(EncryptedData data)
			{
				encryptedData = data.encryptedData;
				if (rijndael == null)
					rijndael = data.rijndael;
			}

			public void SetData(string data)
			{
				if (data != null)
				{
					if (rijndael == null)
					{
						rijndael = Rijndael.Create();
						rijndael.GenerateKey();			// Not sure if this is necessary. Is
						rijndael.GenerateIV();			// this done by default in the ctor?
					}

					ICryptoTransform encryptor = rijndael.CreateEncryptor();
					encryptedData = encryptor.TransformFinalBlock(ToBytes(data), 0, (data.Length) * 2);
				}
				else
					encryptedData = null;
			}

			// This decrypts the stored string aray and returns it to the user

			public string GetData()
			{
				if (encryptedData != null && rijndael != null)
				{
					ICryptoTransform decryptor = rijndael.CreateDecryptor();
					return ToString(decryptor.TransformFinalBlock(encryptedData, 0, encryptedData.Length));
				}
				else
					return null;
			}

			static byte[] ToBytes(string str)
			{
				Debug.Assert(str != null);
		
				byte [] rg = new Byte[(str.Length) * 2];
				int i = 0;

				foreach(char c in str.ToCharArray())
				{
					rg[i++] = (byte)(c >> 8);
					rg[i++] = (byte)(c & 0x00FF);
				}

				return rg;
			}

			static string ToString(byte[] bytes)
			{
				Debug.Assert(bytes != null);

				int length = bytes.Length / 2;
				StringBuilder sb = new StringBuilder();
				sb.Length = length;

				for (int i = 0; i < length; i++)
					sb[i] = (char)(bytes[i * 2] << 8 | (char)bytes[i * 2 + 1]);

				return sb.ToString();
			}
		}
 
		internal const string DEFAULTLOCALE = null;
		internal const string DEFAULTAUTHORITY = null;
		internal const ImpersonationLevel DEFAULTIMPERSONATION = ImpersonationLevel.Impersonate;
		internal const AuthenticationLevel DEFAULTAUTHENTICATION = AuthenticationLevel.Unchanged;
		internal const bool DEFAULTENABLEPRIVILEGES = false;

		//Fields
		private string locale;
		private string username;
		private EncryptedData password = null;
		private string authority;
		private ImpersonationLevel impersonation;
		private AuthenticationLevel authentication;
		private bool enablePrivileges;
		

		//
		//Properties
		//

		/// <summary>
		///    <para>Gets or sets the locale to be used for the connection operation.</para>
		/// </summary>
		/// <value>
		///    <para>The default value is DEFAULTLOCALE.</para>
		/// </value>
		public string Locale 
		{
			get { return (null != locale) ? locale : String.Empty; } 
			set { 
				if (locale != value)
				{
					locale = value; 
					FireIdentifierChanged();
				}
			} 
		}

		/// <summary>
		///    <para>Gets or sets the user name to be used for the connection operation.</para>
		/// </summary>
		/// <value>
		///    <para>Null if the connection will use the currently logged-on user; otherwise, a string representing the user name. The default value is null.</para>
		/// </value>
		/// <remarks>
		///    <para>If the user name is from a domain other than the current 
		///       domain, the string may contain the domain name and user name, separated by a backslash:</para>
		///    <c>
		///       <para>string username = "EnterDomainHere\\EnterUsernameHere";</para>
		///    </c>
		/// <para> The <paramref name="strUser"/> parameter cannot be an empty 
		///    string.</para>
		/// </remarks>
		public string Username 
		{
			get { return username; } 
			set {
				if (username != value)
				{
					username = value; 
					FireIdentifierChanged();
				}
			} 
		}

		/// <summary>
		///    <para>Gets or sets the password for the specified user.</para>
		/// </summary>
		/// <value>
		///    <para> The default value is null. If the user name is also
		///       null, the credentials used will be those of the currently logged-on user.</para>
		/// </value>
		/// <remarks>
		///    <para> A blank string ("") specifies a valid
		///       zero-length password.</para>
		/// </remarks>
		public string Password 
		{ 
			set {
				if (password == null)
					password = new EncryptedData(value);
				else if (password.GetData() != value)
				{
					password.SetData(value);
					FireIdentifierChanged();
				}
			}
		}

		/// <summary>
		///    <para>Gets or sets the authority to be used to authenticate the specified user.</para>
		/// </summary>
		/// <value>
		///    <para>If not null, this property can contain the name of the
		///       Windows NT/Windows 2000 domain in which to obtain the user to
		///       authenticate.</para>
		/// </value>
		/// <remarks>
		///    <para> 
		///       The property must be passed
		///       as follows: If it begins with the string "Kerberos:", Kerberos
		///       authentication will be used and this property should contain a Kerberos principal name. For
		///       example, Kerberos:&lt;principal name&gt;.</para>
		///    <para>If the property value begins with the string "NTLMDOMAIN:", NTLM 
		///       authentication will be used and the property should contain a NTLM domain name.
		///       For example, NTLMDOMAIN:&lt;domain name&gt;. </para>
		///    <para>If the property is null, NTLM authentication will be used and the NTLM domain 
		///       of the current user will be used.</para>
		/// </remarks>
		public string Authority 
		{
			get { return (null != authority) ? authority : String.Empty; } 
			set {
				if (authority != value)
				{
					authority = value; 
					FireIdentifierChanged();
				}
			} 
		}

		/// <summary>
		///    <para>Gets or sets the COM impersonation level to be used for operations in this connection.</para>
		/// </summary>
		/// <value>
		///    <para>The COM impersonation level to be used for operations in 
		///       this connection. The default value is <see cref='System.Management.ImpersonationLevel.Impersonate' qualify='true'/>, which indicates that the WMI provider can
		///       impersonate the client when performing the requested operations in this connection.</para>
		/// </value>
		/// <remarks>
		/// <para>The <see cref='System.Management.ImpersonationLevel.Impersonate' qualify='true'/> setting is advantageous when the provider is 
		///    a trusted application or service. It eliminates the need for the provider to
		///    perform client identity and access checks for the requested operations. However,
		///    note that if for some reason the provider cannot be trusted, allowing it to
		///    impersonate the client may constitute a security threat. In such cases, it is
		///    recommended that this property be set by the client to a lower value, such as
		/// <see cref='System.Management.ImpersonationLevel. Identify' qualify='true'/>. Note that this may cause failure of the 
		///    provider to perform the requested operations, for lack of sufficient permissions
		///    or inability to perform access checks.</para>
		/// </remarks>
		public ImpersonationLevel Impersonation 
		{
			get { return impersonation; } 
			set { 
				if (impersonation != value)
				{
					impersonation = value; 
					FireIdentifierChanged();
				}
			} 
		}

		/// <summary>
		///    <para>Gets or sets the COM authentication level to be used for operations in this connection.</para>
		/// </summary>
		/// <value>
		///    <para>The COM authentication level to be used for operations 
		///       in this connection. The default value is <see cref='System.Management.AuthenticationLevel.Unchanged' qualify='true'/>, which indicates that the
		///       client will use the authentication level requested by the server, according to
		///       the standard DCOM negotiation process.</para>
		/// </value>
		/// <remarks>
		///    <para>On Windows 2000 and below, the WMI service will request 
		///       Connect level authentication, while on Windows XP and higher it will request
		///       Packet level authentication. If the client requires a specific authentication
		///       setting, this property can be used to control the authentication level on this
		///       particular connection. For example, the property can be set to <see cref='System.Management.AuthenticationLevel.PacketPrivacy' qualify='true'/>
		///       if the
		///       client requires all communication to be encrypted.</para>
		/// </remarks>
		public AuthenticationLevel Authentication 
		{
			get { return authentication; } 
			set {
				if (authentication != value)
				{
					authentication = value; 
					FireIdentifierChanged();
				}
			} 
		}

		/// <summary>
		///    <para>Gets or sets a value indicating whether user privileges need to be enabled for 
		///       the connection operation. This property should only be used when the operation
		///       performed requires a certain user privilege to be enabled
		///       (for example, a machine reboot).</para>
		/// </summary>
		/// <value>
		/// <para><see langword='true'/> if user privileges need to be 
		///    enabled for the connection operation; otherwise, <see langword='false'/>. The
		///    default value is <see langword='false'/>.</para>
		/// </value>
		public bool EnablePrivileges 
		{
			get { return enablePrivileges; } 
			set {
				if (enablePrivileges != value)
				{
					enablePrivileges = value; 
					FireIdentifierChanged();
				}
			} 
		}

		//
		//Constructors
		//

		//default
		/// <overload>
		/// <para>Initializes a new instance of the <see cref='System.Management.ConnectionOptions'/> class.</para>
		/// </overload>
		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.ConnectionOptions'/> class for the connection operation, using default values. This is the 
		///    default constructor.</para>
		/// </summary>
		public ConnectionOptions () :
			this (DEFAULTLOCALE, null, null, DEFAULTAUTHORITY,
					DEFAULTIMPERSONATION, DEFAULTAUTHENTICATION,
					DEFAULTENABLEPRIVILEGES, null, InfiniteTimeout) {}

		
		//parameterized
		/// <summary>
		/// <para> Initializes a new instance of the <see cref='System.Management.ConnectionOptions'/> class to be used for a WMI
		///    connection, using the specified values.</para>
		/// </summary>
		/// <param name='locale'>The locale to be used for the connection.</param>
		/// <param name=' username'>The user name to be used for the connection. If null, the credentials of the currently logged-on user are used.</param>
		/// <param name=' password'>The password for the given user name. If the user name is also null, the credentials used will be those of the currently logged-on user.</param>
		/// <param name=' authority'><para>The authority to be used to authenticate the specified user.</para></param>
		/// <param name=' impersonation'>The COM impersonation level to be used for the connection.</param>
		/// <param name=' authentication'>The COM authentication level to be used for the connection.</param>
		/// <param name=' enablePrivileges'><see langword='true'/>to enable special user privileges; otherwise, <see langword='false'/> . This parameter should only be used when performing an operation that requires special Windows NT user privileges.</param>
		/// <param name=' context'>A provider-specific, named value pairs object to be passed through to the provider.</param>
		/// <param name=' timeout'>Reserved for future use.</param>
		public ConnectionOptions (string locale,
				string username, string password, string authority,
				ImpersonationLevel impersonation, AuthenticationLevel authentication,
				bool enablePrivileges,
				ManagementNamedValueCollection context, TimeSpan timeout) : base (context, timeout)
		{
			if (locale != null) 
				this.locale = locale;

			this.username = username;
			this.enablePrivileges = enablePrivileges;

			if (password != null)
				this.password = new EncryptedData(password);

			if (authority != null) 
				this.authority = authority;

			if (impersonation != 0)
				this.impersonation = impersonation;

			if (authentication != 0)
				this.authentication = authentication;
		}

		/// <summary>
		///    <para> Returns a copy of the object.</para>
		/// </summary>
		/// <returns>
		///    <para>The cloned object.</para>
		/// </returns>
		public override object Clone ()
		{
			ManagementNamedValueCollection newContext = null;

			if (null != Context)
				newContext = (ManagementNamedValueCollection)Context.Clone();
			
			return new ConnectionOptions (locale, username, GetPassword (),
				authority, impersonation, authentication, enablePrivileges, newContext, Timeout);
		}

		//
		//Methods
		//

		internal string GetPassword()
		{
			if (password != null)
				return password.GetData();
			else
				return null;
		}

		internal ConnectionOptions(ManagementNamedValueCollection context, TimeSpan timeout, int flags) : base(context, timeout, flags) {}

		internal ConnectionOptions(ManagementNamedValueCollection context) : base(context, InfiniteTimeout) {}

		internal static ConnectionOptions _Clone(ConnectionOptions options)
		{
			return ConnectionOptions._Clone(options, null);
		}

		internal static ConnectionOptions _Clone(ConnectionOptions options, IdentifierChangedEventHandler handler)
		{
			ConnectionOptions optionsTmp;

			if (options != null)
			{
				optionsTmp = new ConnectionOptions(options.Context, options.Timeout, options.Flags);

				optionsTmp.locale = options.locale;

				optionsTmp.username = options.username;
				optionsTmp.enablePrivileges = options.enablePrivileges;

				if (options.password != null)
					optionsTmp.password = new EncryptedData(options.password);
				else
					optionsTmp.password = null;

				if (options.authority != null) 
					optionsTmp.authority = options.authority;

				if (options.impersonation != 0)
					optionsTmp.impersonation = options.impersonation;

				if (options.authentication != 0)
					optionsTmp.authentication = options.authentication;
			}
			else
				optionsTmp = new ConnectionOptions();

			// Wire up change handler chain. Use supplied handler, if specified;
			// otherwise, default to that of the path argument.
			if (handler != null)
				optionsTmp.IdentifierChanged += handler;
			else if (options != null)
				optionsTmp.IdentifierChanged += new IdentifierChangedEventHandler(options.HandleIdentifierChange);

			return optionsTmp;
		}

	}//ConnectionOptions
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\managementscope.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.ComponentModel;
using System.Runtime.InteropServices;
using System.Threading;
using WbemClient_v1;
using System.Globalization;
using System.Reflection;
using System.ComponentModel.Design.Serialization;


namespace System.Management
{
	/// <summary>
	///    <para>Represents a scope for management operations. In v1.0 the scope defines the WMI namespace in which management operations are performed.</para>
	/// </summary>
	/// <example>
	///    <code lang='C#'>using System;
	/// using System.Management;
	/// 
	/// // This sample demonstrates how to connect to root/default namespace
	/// // using ManagmentScope object.
	/// class Sample_ManagementScope
	/// {
	///     public static int Main(string[] args)
	///     {
	///         ManagementScope scope = new ManagementScope("root\\default");
	///         scope.Connect();
	///         ManagementClass newClass = new ManagementClass(
	///             scope,
	///             new ManagementPath(),
	///             null);
	///         return 0;
	///     }
	/// }
	///    </code>
	///    <code lang='VB'>Imports System
	/// Imports System.Management
	/// 
	/// ' This sample demonstrates how to connect to root/default namespace
	/// ' using ManagmentScope object.
	/// Class Sample_ManagementScope
	///     Overloads Public Shared Function Main(args() As String) As Integer
	///         Dim scope As New ManagementScope("root\default")
	///         scope.Connect()
	///         Dim newClass As New ManagementClass(scope, _
	///             New ManagementPath(), _
	///             Nothing)
	///         Return 0
	///     End Function
	/// End Class
	///    </code>
	/// </example>
	[TypeConverter(typeof(ManagementScopeConverter))]
	public class ManagementScope : ICloneable
	{
		private ManagementPath		validatedPath;		
		private IWbemServices		wbemServices;
		private ConnectionOptions	options;
		internal event IdentifierChangedEventHandler IdentifierChanged;
		internal bool IsDefaulted; //used to tell whether the current scope has been created from the default
					  //scope or not - this information is used to tell whether it can be overridden
					  //when a new path is set or not.

		[DllImport("rpcrt4.dll")]
		static extern int RpcMgmtEnableIdleCleanup ( );		

		private static bool rpcGarbageCollectionEnabled = false ;

		//Fires IdentifierChanged event
		private void FireIdentifierChanged()
		{
			if (IdentifierChanged != null)
				IdentifierChanged(this,null);
		}

		//Called when IdentifierChanged() event fires
		private void HandleIdentifierChange(object sender,
							IdentifierChangedEventArgs args)
		{
			// Since our object has changed we had better signal to ourself that
			// an connection needs to be established
			wbemServices = null;

			//Something inside ManagementScope changed, we need to fire an event
			//to the parent object
			FireIdentifierChanged();
		}

		// Private path property accessor which performs minimal validation on the
		// namespace path. IWbemPath cannot differentiate between a class or a name-
		// space if path separators are not present in the path.  Therefore, IWbemPath
		// will allow a namespace of "rootBeer" vs "root".  Since it is established
		// that the scope path is indeed a namespace path, we perform this validation.
		private ManagementPath prvpath
		{
			get
			{
				return validatedPath;
			}
			set
			{
				if (value != null)
				{
					string pathValue = value.Path;
					if (!ManagementPath.IsValidNamespaceSyntax(pathValue))
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)tag_WBEMSTATUS.WBEM_E_INVALID_NAMESPACE);
				}

				validatedPath = value;
			}
		}

		internal IWbemServices GetIWbemServices () {

            // Lets start by assuming that we'll return the RCW that we already have
            IWbemServices localCopy = wbemServices;

            // Get an IUnknown for this apartment
            IntPtr pUnk = Marshal.GetIUnknownForObject(wbemServices);

            // Get an 'IUnknown RCW' for this apartment
            Object unknown = Marshal.GetObjectForIUnknown(pUnk);

            // Release the ref count on the IUnknwon
            Marshal.Release(pUnk);

            // See if we are in the same apartment as where the original IWbemServices lived
            // If we are in a different apartment, give the caller an RCW generated just for their
            // apartment, and set the proxy blanket appropriately
            if(!object.ReferenceEquals(unknown, wbemServices))
            {
                // We need to set the proxy blanket on 'unknown' or else the QI for IWbemServices may
                // fail if we are running under a local user account.  The QI has to be done by
                // someone who is a member of the 'Everyone' group on the target machine, or DCOM
                // won't let the call through.
				SecurityHandler securityHandler = GetSecurityHandler ();
				securityHandler.SecureIUnknown(unknown);

                // Now, we can QI and secure the IWbemServices
                localCopy = (IWbemServices)unknown;

                // We still need to bless the IWbemServices in this apartment
                securityHandler.Secure(localCopy);
            }

            return localCopy; // STRANGE: Why does it still work if I return 'wbemServices'?
		}

		/// <summary>
		/// <para> Gets or sets a value indicating whether the <see cref='System.Management.ManagementScope'/> is currently bound to a
		///    WMI server and namespace.</para>
		/// </summary>
		/// <value>
		/// <para><see langword='true'/> if a connection is alive (bound 
		///    to a server and namespace); otherwise, <see langword='false'/>.</para>
		/// </value>
		/// <remarks>
		///    <para> A scope is disconnected after creation until someone 
		///       explicitly calls <see cref='System.Management.ManagementScope.Connect'/>(), or uses the scope for any
		///       operation that requires a live connection. Also, the scope is
		///       disconnected from the previous connection whenever the identifying properties of the scope are
		///       changed.</para>
		/// </remarks>
		public bool IsConnected  
		{
			get { 
				return (null != wbemServices); 
			}
		}

		//Internal constructor
		internal ManagementScope (ManagementPath path, IWbemServices wbemServices, 
				IWmiSec securityHelper, ConnectionOptions options)
		{
			if (null != path)
				this.Path = path;

			if (null != options)
				this.Options = options;

			// We set this.wbemServices after setting Path and Options
			// because the latter operations can cause wbemServices to be NULLed.
			this.wbemServices = wbemServices;
//			this.securityHelper = securityHelper;
		}

		internal ManagementScope (ManagementPath path, ManagementScope scope)
			: this (path, (null != scope) ? scope.options : null) {}

		internal static ManagementScope _Clone(ManagementScope scope)
		{
			return ManagementScope._Clone(scope, null);
		}

		internal static ManagementScope _Clone(ManagementScope scope, IdentifierChangedEventHandler handler)
		{
			ManagementScope scopeTmp = new ManagementScope(null, null, null, null);

			// Wire up change handler chain. Use supplied handler, if specified;
			// otherwise, default to that of the scope argument.
			if (handler != null)
				scopeTmp.IdentifierChanged = handler;
			else if (scope != null)
				scopeTmp.IdentifierChanged = new IdentifierChangedEventHandler(scope.HandleIdentifierChange);

			// Set scope path.
			if (scope == null)
			{
				// No path specified. Default.
				scopeTmp.prvpath = ManagementPath._Clone(ManagementPath.DefaultPath, new IdentifierChangedEventHandler(scopeTmp.HandleIdentifierChange));
				scopeTmp.IsDefaulted = true;

				scopeTmp.wbemServices = null;
				scopeTmp.options = null;
//				scopeTmp.securityHelper = null;					// BUGBUG : should this allocate a new object?
			}
			else
			{
				if (scope.prvpath == null)
				{
					// No path specified. Default.
					scopeTmp.prvpath = ManagementPath._Clone(ManagementPath.DefaultPath, new IdentifierChangedEventHandler(scopeTmp.HandleIdentifierChange));
					scopeTmp.IsDefaulted = true;
				}
				else
				{
					// Use scope-supplied path.
					scopeTmp.prvpath = ManagementPath._Clone(scope.prvpath, new IdentifierChangedEventHandler(scopeTmp.HandleIdentifierChange));
					scopeTmp.IsDefaulted = scope.IsDefaulted;
				}

				scopeTmp.wbemServices = scope.wbemServices;
				if (scope.options != null)
					scopeTmp.options = ConnectionOptions._Clone(scope.options, new IdentifierChangedEventHandler(scopeTmp.HandleIdentifierChange));
//				scopeTmp.securityHelper = scope.securityHelper;	// BUGBUG : should this allocate a new one?
			}

			return scopeTmp;
		}

		//Default constructor
		/// <overload>
		///    Initializes a new instance
		///    of the <see cref='System.Management.ManagementScope'/> class.
		/// </overload>
		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.ManagementScope'/> class, with default values. This is the
		///    default constructor.</para>
		/// </summary>
		/// <remarks>
		///    <para> If the object doesn't have any
		///       properties set before connection, it will be initialized with default values
		///       (for example, the local machine and the root\cimv2 namespace).</para>
		/// </remarks>
		/// <example>
		///    <code lang='C#'>ManagementScope s = new ManagementScope();
		///    </code>
		///    <code lang='VB'>Dim s As New ManagementScope()
		///    </code>
		/// </example>
		public ManagementScope () : 
			this (new ManagementPath (ManagementPath.DefaultPath.Path)) 
		{
			//Flag that this scope uses the default path
			IsDefaulted = true;
		}

		//Parameterized constructors
		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.ManagementScope'/> class representing
		///    the specified scope path.</para>
		/// </summary>
		/// <param name='path'>A <see cref='System.Management.ManagementPath'/> containing the path to a server and namespace for the <see cref='System.Management.ManagementScope'/>.</param>
		/// <example>
		///    <code lang='C#'>ManagementScope s = new ManagementScope(new ManagementPath("\\\\MyServer\\root\\default"));
		///    </code>
		///    <code lang='VB'>Dim p As New ManagementPath("\\MyServer\root\default")
		/// Dim s As New ManagementScope(p)
		///    </code>
		/// </example>
		public ManagementScope (ManagementPath path) : this(path, (ConnectionOptions)null) {}

		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.ManagementScope'/> class representing the specified scope 
		///    path.</para>
		/// </summary>
		/// <param name='path'>The server and namespace path for the <see cref='System.Management.ManagementScope'/>.</param>
		/// <example>
		///    <code lang='C#'>ManagementScope s = new ManagementScope("\\\\MyServer\\root\\default");
		///    </code>
		///    <code lang='VB'>Dim s As New ManagementScope("\\MyServer\root\default")
		///    </code>
		/// </example>
		public ManagementScope (string path) : this(new ManagementPath(path), (ConnectionOptions)null) {}
		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.ManagementScope'/> class representing the specified scope path, 
		///    with the specified options.</para>
		/// </summary>
		/// <param name='path'>The server and namespace for the <see cref='System.Management.ManagementScope'/>.</param>
		/// <param name=' options'>A <see cref='System.Management.ConnectionOptions'/> containing options for the connection.</param>
		/// <example>
		///    <code lang='C#'>ConnectionOptions opt = new ConnectionOptions();
		/// opt.Username = UserName;
		/// opt.Password = SecurelyStoredPassword;
		/// ManagementScope s = new ManagementScope("\\\\MyServer\\root\\default", opt);
		///    </code>
		///    <code lang='VB'>Dim opt As New ConnectionOptions()
		/// opt.Username = UserName 
		/// opt.Password = SecurelyStoredPassword
		/// Dim s As New ManagementScope("\\MyServer\root\default", opt);
		///    </code>
		/// </example>
		public ManagementScope (string path, ConnectionOptions options) : this (new ManagementPath(path), options) {}

		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.ManagementScope'/> class representing the specified scope path, 
		///    with the specified options.</para>
		/// </summary>
		/// <param name='path'>A <see cref='System.Management.ManagementPath'/> containing the path to the server and namespace for the <see cref='System.Management.ManagementScope'/>.</param>
		/// <param name=' options'>The <see cref='System.Management.ConnectionOptions'/> containing options for the connection.</param>
		/// <example>
		///    <code lang='C#'>ConnectionOptions opt = new ConnectionOptions();
		/// opt.Username = UserName;
		/// opt.Password = SecurelyStoredPassword;
		/// 
		/// ManagementPath p = new ManagementPath("\\\\MyServer\\root\\default");   
		/// ManagementScope = new ManagementScope(p, opt);
		///    </code>
		///    <code lang='VB'>Dim opt As New ConnectionOptions()
		/// opt.UserName = UserName
		/// opt.Password = SecurelyStoredPassword
		/// 
		/// Dim p As New ManagementPath("\\MyServer\root\default")
		/// Dim s As New ManagementScope(p, opt)
		///    </code>
		/// </example>
		public ManagementScope (ManagementPath path, ConnectionOptions options)
		{
			if (null != path)
				this.prvpath = ManagementPath._Clone(path, new IdentifierChangedEventHandler(HandleIdentifierChange));
			else
				this.prvpath = ManagementPath._Clone(null);

			if (null != options)
				this.options = ConnectionOptions._Clone(options, new IdentifierChangedEventHandler(HandleIdentifierChange));
			else
				this.options = null;

			IsDefaulted = false; //assume that this scope is not initialized by the default path
		}

		/// <summary>
		///    <para> Gets or sets options for making the WMI connection.</para>
		/// </summary>
		/// <value>
		/// <para>The valid <see cref='System.Management.ConnectionOptions'/> 
		/// containing options for the WMI connection.</para>
		/// </value>
		/// <example>
		///    <code lang='C#'>//This constructor creates a scope object with default options
		/// ManagementScope s = new ManagementScope("root\\MyApp"); 
		/// 
		/// //Change default connection options -
		/// //In this example, set the system privileges to enabled for operations that require system privileges.
		/// s.Options.EnablePrivileges = true;
		///    </code>
		///    <code lang='VB'>'This constructor creates a scope object with default options
		/// Dim s As New ManagementScope("root\\MyApp")
		/// 
		/// 'Change default connection options -
		/// 'In this example, set the system privileges to enabled for operations that require system privileges.
		/// s.Options.EnablePrivileges = True
		///    </code>
		/// </example>
		public ConnectionOptions Options
		{
			get
			{
				if (options == null)
					return options = ConnectionOptions._Clone(null);
				else
					return options;
			}
			set
			{
				if (null != value)
				{
					if (null != options)
						options.IdentifierChanged -= new IdentifierChangedEventHandler(HandleIdentifierChange);

					options = ConnectionOptions._Clone((ConnectionOptions)value, new IdentifierChangedEventHandler(HandleIdentifierChange));

					//the options property has changed so act like we fired the event
					HandleIdentifierChange(this,null);
				}
				else
					throw new ArgumentNullException ();
			}
		}
	
		/// <summary>
		/// <para>Gets or sets the path for the <see cref='System.Management.ManagementScope'/>.</para>
		/// </summary>
		/// <value>
		/// <para> A <see cref='System.Management.ManagementPath'/> containing
		///    the path to a server and namespace.</para>
		/// </value>
		/// <example>
		///    <code lang='C#'>ManagementScope s = new ManagementScope();
		/// s.Path = new ManagementPath("root\\MyApp");
		///    </code>
		///    <code lang='VB'>Dim s As New ManagementScope()
		/// s.Path = New ManagementPath("root\MyApp")
		///    </code>
		/// </example>
		public ManagementPath Path 
		{
			get
			{
				if (prvpath == null)
					return prvpath = ManagementPath._Clone(null);
				else
					return prvpath;
			}
			set
			{
				if (null != value)
				{
					if (null != prvpath)
						prvpath.IdentifierChanged -= new IdentifierChangedEventHandler(HandleIdentifierChange);

					IsDefaulted = false; //someone is specifically setting the scope path so it's not defaulted any more

					prvpath = ManagementPath._Clone((ManagementPath)value, new IdentifierChangedEventHandler(HandleIdentifierChange));

					//the path property has changed so act like we fired the event
					HandleIdentifierChange(this,null);
				}
				else
					throw new ArgumentNullException ();
			}
		}

		/// <summary>
		///    <para>Returns a copy of the object.</para>
		/// </summary>
		/// <returns>
		/// <para>A new copy of the <see cref='System.Management.ManagementScope'/>.</para>
		/// </returns>
		public ManagementScope Clone()
		{
			return ManagementScope._Clone(this);
		}

		/// <summary>
		///    <para>Clone a copy of this object.</para>
		/// </summary>
		/// <returns>
		///    A new copy of this object.
		///    object.
		/// </returns>
		Object ICloneable.Clone()
		{
			return Clone();
		}

		/// <summary>
		/// <para>Connects this <see cref='System.Management.ManagementScope'/> to the actual WMI
		///    scope.</para>
		/// </summary>
		/// <remarks>
		///    <para>This method is called implicitly when the
		///       scope is used in an operation that requires it to be connected. Calling it
		///       explicitly allows the user to control the time of connection.</para>
		/// </remarks>
		/// <example>
		///    <code lang='C#'>ManagementScope s = new ManagementScope("root\\MyApp");
		/// 
		/// //Explicit call to connect the scope object to the WMI namespace
		/// s.Connect();
		/// 
		/// //The following doesn't do any implicit scope connections because s is already connected.
		/// ManagementObject o = new ManagementObject(s, "Win32_LogicalDisk='C:'", null);
		///    </code>
		///    <code lang='VB'>Dim s As New ManagementScope("root\\MyApp")
		/// 
		/// 'Explicit call to connect the scope object to the WMI namespace
		/// s.Connect()
		/// 
		/// 'The following doesn't do any implicit scope connections because s is already connected.
		/// Dim o As New ManagementObject(s, "Win32_LogicalDisk=""C:""", null)
		///    </code>
		/// </example>
		public void Connect ()
		{
			Initialize ();
		}

		internal void Initialize ()
		{
			//If the path is not set yet we can't do it
			if (null == prvpath)
				throw new InvalidOperationException();


			/*
			 * If we're not connected yet, this is the time to do it... We lock
			 * the state to prevent 2 threads simultaneously doing the same
			 * connection. To avoid taking the lock unnecessarily we examine
			 * isConnected first
			 */ 
			if (!IsConnected)
			{
				lock (this)
				{
					if (!IsConnected)
					{
                        // The locator cannot be marshalled accross apartments, so we must create the locator
                        // and get the IWbemServices from an MTA thread
                        if(!MTAHelper.IsNoContextMTA())  // Bug#110141 - Checking for MTA is not enough.  We need to make sure we are not in a COM+ Context
                        {
							//
							// [marioh, RAID: 111108]
							// Ensure we are able to trap exceptions from worker thread.
							//
							ThreadDispatch disp = new ThreadDispatch ( new ThreadDispatch.ThreadWorkerMethodWithParam ( InitializeGuts ) ) ;
							disp.Parameter = this ;
							disp.Start ( ) ;

							
//                            statusFromMTA = 0;
//                            Thread thread = new Thread(new ThreadStart(InitializeGuts));
//                            thread.ApartmentState = ApartmentState.MTA;
//                            thread.Start();
//                            thread.Join();
//                            if ((statusFromMTA & 0xfffff000) == 0x80041000)
//                                ManagementException.ThrowWithExtendedInfo((ManagementStatus)statusFromMTA);
//                            else if ((statusFromMTA & 0x80000000) != 0)
//                                Marshal.ThrowExceptionForHR(statusFromMTA);
						}
                        else
                            InitializeGuts(this);
					}
				}
			}
		}

		//int statusFromMTA;
		void InitializeGuts(object o)
		{
			ManagementScope threadParam = (ManagementScope) o ;
			IWbemLocator loc = (IWbemLocator) new WbemLocator();
						
			if (null == options)
				threadParam.Options = new ConnectionOptions ();

			string nsPath = threadParam.prvpath.GetNamespacePath((int)tag_WBEM_GET_TEXT_FLAGS.WBEMPATH_GET_SERVER_AND_NAMESPACE_ONLY);

			// If no namespace specified, fill in the default one
			if ((null == nsPath) || (0 == nsPath.Length))
			{
				// NB: we use a special method to set the namespace
				// path here as we do NOT want to trigger an
				// IdentifierChanged event as a result of this set
						
				bool bUnused;
				nsPath = threadParam.prvpath.SetNamespacePath(ManagementPath.DefaultPath.Path, out bUnused);
			}

			// If we have privileges to enable, now is the time
			SecurityHandler securityHandler = GetSecurityHandler ();
						
			int status = (int)ManagementStatus.NoError;

			//If we're on XP or higher, always use the "max_wait" flag to avoid hanging
			if ((Environment.OSVersion.Platform == PlatformID.Win32NT) &&
				(Environment.OSVersion.Version.Major >= 5) &&
				(Environment.OSVersion.Version.Minor >= 1))
				threadParam.options.Flags |= (int)tag_WBEM_CONNECT_OPTIONS.WBEM_FLAG_CONNECT_USE_MAX_WAIT;

			try 
			{
				status = loc.ConnectServer_(
					nsPath,
					threadParam.options.Username, 
					threadParam.options.GetPassword(), 
					threadParam.options.Locale,
					threadParam.options.Flags,
					threadParam.options.Authority,
					threadParam.options.GetContext(),
					out threadParam.wbemServices);

				//Set security on services pointer
				GetSecurityHandler().Secure(threadParam.wbemServices);

				//
				// RAID: 127453 [marioh]
				// Make sure we enable RPC garbage collection to avoid tons
				// of useless idle connections not being recycled. This only
				// has impact on Win2k and below since XP has this enabled by
				// default.
				//
				if ( rpcGarbageCollectionEnabled == false )
				{
					RpcMgmtEnableIdleCleanup ( ) ;
					rpcGarbageCollectionEnabled = true ;
				}

				Marshal.ReleaseComObject(loc);
				loc = null;

			} 
			catch (Exception e) 
			{
				// BUGBUG : securityHandler.Reset()?
				ManagementException.ThrowWithExtendedInfo (e);
			} 
			finally 
			{
				securityHandler.Reset ();
			}

			//statusFromMTA = status;

			if ((status & 0xfffff000) == 0x80041000)
			{
				ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
			}
			else if ((status & 0x80000000) != 0)
			{
				Marshal.ThrowExceptionForHR(status);
			}
		}


		internal SecurityHandler GetSecurityHandler ()
		{
			return new SecurityHandler(this);
		}
	}//ManagementScope	

	internal class SecurityHandler 
	{
		private bool needToReset = false;
		private IntPtr handle;
		private ManagementScope scope;
		private IWmiSec securityHelper;

		internal SecurityHandler (ManagementScope theScope) {
			this.scope = theScope;

			if (null == securityHelper)
				securityHelper = (IWmiSec)MTAHelper.CreateInMTA(typeof(WmiSec));//new WmiSec();

			if (null != scope)
			{
				if (scope.Options.EnablePrivileges)
				{
					securityHelper.SetSecurity (ref needToReset, ref handle);
				}
			}
		}

		internal void Reset ()
		{
			if (needToReset)
			{
				needToReset = false;
				
				if (null != scope)
				{
					securityHelper.ResetSecurity (handle);
				}
			}

		}			

		internal void Secure (IWbemServices services)
		{
			if (null != scope)
				securityHelper.BlessIWbemServices(
					services,
					scope.Options.Username,
					scope.Options.GetPassword (),
					scope.Options.Authority,
					(int)scope.Options.Impersonation,
					(int)scope.Options.Authentication);
		}
		
		internal void Secure (IEnumWbemClassObject enumWbem)
		{
			if (null != scope)
				securityHelper.BlessIEnumWbemClassObject(
					enumWbem,
					scope.Options.Username,
					scope.Options.GetPassword (),
					scope.Options.Authority,
					(int)scope.Options.Impersonation,
					(int)scope.Options.Authentication);
		}


		internal void Secure (IWbemCallResult callResult)
		{
			if (null != scope)
				securityHelper.BlessIWbemCallResult(
					callResult,
					scope.Options.Username,
					scope.Options.GetPassword (),
					scope.Options.Authority,
					(int)scope.Options.Impersonation,
					(int)scope.Options.Authentication);
		}

		internal void SecureIUnknown(object unknown)
		{
			// We use a hack to call BlessIWbemServices with an IUnknown instead of an IWbemServices
			// In VNext, we should really change the implementation of WMINet_Utils.dll so that it has
			// a method which explicitly takes an IUnknown.  We rely on the fact that the implementation
			// of BlessIWbemServices actually casts the first parameter to IUnknown before blessing
			IWmiSecAlternateForIUnknown securityHelperTemp = (IWmiSecAlternateForIUnknown)securityHelper;
			securityHelperTemp.BlessIWbemServices(
				unknown,
				scope.Options.Username,
				scope.Options.GetPassword (),
				scope.Options.Authority,
				(int)scope.Options.Impersonation,
				(int)scope.Options.Authentication);
		}


	} //SecurityHandler	

	/// <summary>
	/// Converts a String to a ManagementScope
	/// </summary>
	class ManagementScopeConverter : ExpandableObjectConverter 
	{
        
		/// <summary>
		/// Determines if this converter can convert an object in the given source type to the native type of the converter. 
		/// </summary>
		/// <param name='context'>An ITypeDescriptorContext that provides a format context.</param>
		/// <param name='sourceType'>A Type that represents the type you wish to convert from.</param>
		/// <returns>
		///    <para>true if this converter can perform the conversion; otherwise, false.</para>
		/// </returns>
		public override Boolean CanConvertFrom(ITypeDescriptorContext context, Type sourceType) 
		{
			if ((sourceType == typeof(ManagementScope))) 
			{
				return true;
			}
			return base.CanConvertFrom(context,sourceType);
		}
        
		/// <summary>
		/// Gets a value indicating whether this converter can convert an object to the given destination type using the context.
		/// </summary>
		/// <param name='context'>An ITypeDescriptorContext that provides a format context.</param>
		/// <param name='destinationType'>A Type that represents the type you wish to convert to.</param>
		/// <returns>
		///    <para>true if this converter can perform the conversion; otherwise, false.</para>
		/// </returns>
		public override Boolean CanConvertTo(ITypeDescriptorContext context, Type destinationType) 
		{
			if ((destinationType == typeof(InstanceDescriptor))) 
			{
				return true;
			}
			return base.CanConvertTo(context,destinationType);
		}
        
		/// <summary>
		///      Converts the given object to another type.  The most common types to convert
		///      are to and from a string object.  The default implementation will make a call
		///      to ToString on the object if the object is valid and if the destination
		///      type is string.  If this cannot convert to the desitnation type, this will
		///      throw a NotSupportedException.
		/// </summary>
		/// <param name='context'>An ITypeDescriptorContext that provides a format context.</param>
		/// <param name='culture'>A CultureInfo object. If a null reference (Nothing in Visual Basic) is passed, the current culture is assumed.</param>
		/// <param name='value'>The Object to convert.</param>
		/// <param name='destinationType'>The Type to convert the value parameter to.</param>
		/// <returns>An Object that represents the converted value.</returns>
		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) 
		{

			if (destinationType == null) 
			{
				throw new ArgumentNullException("destinationType");
			}

			if (value is ManagementScope && destinationType == typeof(InstanceDescriptor)) 
			{
				ManagementScope obj = ((ManagementScope)(value));
				ConstructorInfo ctor = typeof(ManagementScope).GetConstructor(new Type[] {typeof(System.String)});
				if (ctor != null) 
				{
					return new InstanceDescriptor(ctor, new object[] {obj.Path.Path});
				}
			}
			return base.ConvertTo(context,culture,value,destinationType);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\mgmtresmanager.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Resources;
using System.Reflection;

namespace System.Management
{
    internal sealed class RC
    {
        // Private constructor to prevent instances of this class from being created
        RC(){}

        // ResourceManager instance
        static readonly ResourceManager resMgr = new ResourceManager(Assembly.GetExecutingAssembly().GetName().Name ,Assembly.GetExecutingAssembly(),null);

        // Public method to get string from resources
        public static string GetString(string strToGet)
        {
            return resMgr.GetString(strToGet);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\property.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Collections;
using System.Diagnostics;
using System.Runtime.InteropServices;
using WbemClient_v1;
using System.Runtime.CompilerServices;

namespace System.Management
{
    // Bug#808408 - We use this class to prevent the accidental returning of a boxed value type to a caller
    // If we store a boxed value type in a private field, and return it to the caller through a public
    // property or method, the call can potentially change its value.  The GetSafeObject method does two things
    // 1) If the value is a primitive, we know that it will implement IConvertible.  IConvertible.ToType will
    // copy a boxed primitive
    // 2) In the case of a boxed non-primitive value type, or simply a reference type, we call
    // RuntimeHelpers.GetObjectValue.  This returns reference types right back to the caller, but if passed
    // a boxed non-primitive value type, it will return a boxed copy.  We cannot use GetObjectValue for primitives
    // because its implementation does not copy boxed primitives.
    class ValueTypeSafety
    {
        public static object GetSafeObject(object theValue)
        {
            if(null == theValue)
                return null;
            else if(theValue.GetType().IsPrimitive)
                return ((IConvertible)theValue).ToType(typeof(object), null);
            else
                return RuntimeHelpers.GetObjectValue(theValue);
        }
    }

	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para> Represents information about a WMI property.</para>
	/// </summary>
	/// <example>
	///    <code lang='C#'>using System;
	/// using System.Management;
	/// 
	/// // This sample displays all properties that qualifies the "DeviceID" property
	/// // in Win32_LogicalDisk.DeviceID='C' instance.
	/// class Sample_PropertyData
	/// {
	///     public static int Main(string[] args) {
	///         ManagementObject disk =
	///             new ManagementObject("Win32_LogicalDisk.DeviceID=\"C:\"");
	///         PropertyData diskProperty = disk.Properties["DeviceID"];
	///         Console.WriteLine("Name: " + diskProperty.Name);
	///         Console.WriteLine("Type: " + diskProperty.Type);
	///         Console.WriteLine("Value: " + diskProperty.Value);
	///         Console.WriteLine("IsArray: " + diskProperty.IsArray);
	///         Console.WriteLine("IsLocal: " + diskProperty.IsLocal);
	///         Console.WriteLine("Origin: " + diskProperty.Origin);
	///         return 0;
	///     }
	/// }
	///    </code>
	///    <code lang='VB'>Imports System
	/// Imports System.Management
	/// 
	/// ' This sample displays all properties that qualifies the "DeviceID" property
	/// ' in Win32_LogicalDisk.DeviceID='C' instance.
	/// Class Sample_PropertyData
	///     Overloads Public Shared Function Main(args() As String) As Integer
	///         Dim disk As New ManagementObject("Win32_LogicalDisk.DeviceID=""C:""")
	///         Dim diskProperty As PropertyData = disk.Properties("DeviceID")
	///         Console.WriteLine("Name: " &amp; diskProperty.Name)
	///         Console.WriteLine("Type: " &amp; diskProperty.Type)
	///         Console.WriteLine("Value: " &amp; diskProperty.Value)
	///         Console.WriteLine("IsArray: " &amp; diskProperty.IsArray)
	///         Console.WriteLine("IsLocal: " &amp; diskProperty.IsLocal)
	///         Console.WriteLine("Origin: " &amp; diskProperty.Origin)
	///         Return 0
	///     End Function
	/// End Class
	///    </code>
	/// </example>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class PropertyData
	{
		private ManagementBaseObject parent;  //need access to IWbemClassObject pointer to be able to refresh property info
									//and get property qualifiers
		private string propertyName;

		private Object propertyValue;
		private int propertyType;
		private int propertyFlavor;
		private QualifierDataCollection qualifiers;

		internal PropertyData(ManagementBaseObject parent, string propName)
		{
			this.parent = parent;
			this.propertyName = propName;
			qualifiers = null;
			RefreshPropertyInfo();
		}

		//This private function is used to refresh the information from the Wmi object before returning the requested data
		private void RefreshPropertyInfo()
		{
			propertyValue = null;	// Needed so we don't leak this in/out parameter...

			int status = parent.wbemObject.Get_(propertyName, 0, ref propertyValue, ref propertyType, ref propertyFlavor);

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}
		}

		/// <summary>
		///    <para>Gets or sets the name of the property.</para>
		/// </summary>
		/// <value>
		///    A string containing the name of the
		///    property.
		/// </value>
		public string Name 
		{ //doesn't change for this object so we don't need to refresh
			get { return propertyName != null ? propertyName : ""; }
		}

		/// <summary>
		///    <para>Gets or sets the current value of the property.</para>
		/// </summary>
		/// <value>
		///    An object containing the value of the
		///    property.
		/// </value>
		public Object Value 
		{
			get { 
				RefreshPropertyInfo(); 
				return ValueTypeSafety.GetSafeObject(MapWmiValueToValue(propertyValue,
						(CimType)(propertyType & ~(int)tag_CIMTYPE_ENUMERATION.CIM_FLAG_ARRAY),
						(0 != (propertyType & (int)tag_CIMTYPE_ENUMERATION.CIM_FLAG_ARRAY))));
			}
			set {
				RefreshPropertyInfo();

				object newValue = MapValueToWmiValue(value, 
							(CimType)(propertyType & ~(int)tag_CIMTYPE_ENUMERATION.CIM_FLAG_ARRAY),
							(0 != (propertyType & (int)tag_CIMTYPE_ENUMERATION.CIM_FLAG_ARRAY)));

				int status = parent.wbemObject.Put_(propertyName, 0, ref newValue, 0);

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}
				//if succeeded and this object has a path, update the path to reflect the new key value
				//NOTE : we could only do this for key properties but since it's not trivial to find out
				//       whether this property is a key or not, we just do it for any property
				else 
					if (parent.GetType() == typeof(ManagementObject))
						((ManagementObject)parent).Path.UpdateRelativePath((string)parent["__RELPATH"]);
				
			}
		}

		/// <summary>
		///    <para>Gets or sets the CIM type of the property.</para>
		/// </summary>
		/// <value>
		/// <para>A <see cref='System.Management.CimType'/> value 
		///    representing the CIM type of the property.</para>
		/// </value>
		public CimType Type {
			get { 
				RefreshPropertyInfo(); 
				return (CimType)(propertyType & ~(int)tag_CIMTYPE_ENUMERATION.CIM_FLAG_ARRAY); 
			}
		}

		/// <summary>
		///    <para>Gets or sets a value indicating whether the property has been defined in the current WMI class.</para>
		/// </summary>
		/// <value>
		/// <para><see langword='true'/> if the property has been defined 
		///    in the current WMI class; otherwise, <see langword='false'/>.</para>
		/// </value>
		public bool IsLocal 
		{
			get { 
				RefreshPropertyInfo();
				return ((propertyFlavor & (int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_ORIGIN_PROPAGATED) != 0) ? false : true ; }
		}

		/// <summary>
		///    <para>Gets or sets a value indicating whether the property is an array.</para>
		/// </summary>
		/// <value>
		/// <para><see langword='true'/> if the property is an array; otherwise, <see langword='false'/>.</para>
		/// </value>
		public bool IsArray 
		{
			get { 
				RefreshPropertyInfo();
				return ((propertyType & (int)tag_CIMTYPE_ENUMERATION.CIM_FLAG_ARRAY) != 0);}
		}

		/// <summary>
		///    <para>Gets or sets the name of the WMI class in the hierarchy in which the property was introduced.</para>
		/// </summary>
		/// <value>
		///    A string containing the name of the
		///    originating WMI class.
		/// </value>
		public string Origin 
		{
			get { 
				string className = null;
				int status = parent.wbemObject.GetPropertyOrigin_(propertyName, out className);

				if (status < 0)
				{
					if (status == (int)tag_WBEMSTATUS.WBEM_E_INVALID_OBJECT)
						className = String.Empty;	// Interpret as an unspecified property - return ""
					else if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}

				return className;
			}
		}

		
		/// <summary>
		///    <para>Gets or sets the set of qualifiers defined on the property.</para>
		/// </summary>
		/// <value>
		/// <para>A <see cref='System.Management.QualifierDataCollection'/> that represents 
		///    the set of qualifiers defined on the property.</para>
		/// </value>
		public QualifierDataCollection Qualifiers 
		{
			get {
				if (qualifiers == null)
					qualifiers = new QualifierDataCollection(parent, propertyName, QualifierType.PropertyQualifier);

				return qualifiers;
			}
		}

		/// <summary>
		/// Takes a property value returned from WMI and maps it to an
		/// appropriate managed code representation.
		/// </summary>
		/// <param name="wmiValue"> </param>
		/// <param name="type"> </param>
		/// <param name="isArray"> </param>
		internal static object MapWmiValueToValue(object wmiValue, CimType type, bool isArray)
		{
			object val = null;

			if ((System.DBNull.Value != wmiValue) && (null != wmiValue))
			{
				if (isArray)
				{
					Array wmiValueArray = (Array)wmiValue;
					int length = wmiValueArray.Length;

					switch (type)
					{
						case CimType.UInt16:
							val = new UInt16 [length];
							
							for (int i = 0; i < length; i++)
								((UInt16[])val) [i] = (UInt16)((Int32)(wmiValueArray.GetValue(i)));
							break;
							
						case CimType.UInt32:
							val = new UInt32 [length];
							
							for (int i = 0; i < length; i++)
								((UInt32[])val)[i] = (UInt32)((Int32)(wmiValueArray.GetValue(i)));
							break;
						
						case CimType.UInt64:
							val = new UInt64 [length];
							
							for (int i = 0; i < length; i++)
								((UInt64[])val) [i] = Convert.ToUInt64((String)(wmiValueArray.GetValue(i)));
							break;

						case CimType.SInt8:
							val = new SByte [length];
							
							for (int i = 0; i < length; i++)
								((SByte[])val) [i] = (SByte)((Int16)(wmiValueArray.GetValue(i)));
							break;

						case CimType.SInt64:
							val = new Int64 [length];
							
							for (int i = 0; i < length; i++)
								((Int64[])val) [i] = Convert.ToInt64((String)(wmiValueArray.GetValue(i)));
							break;

						case CimType.Char16:
							val = new Char [length];
							
							for (int i = 0; i < length; i++)
								((Char[])val) [i] = (Char)((Int16)(wmiValueArray.GetValue(i)));
							break;

						case CimType.Object:
							val = new ManagementBaseObject [length];

							for (int i = 0; i < length; i++)
								((ManagementBaseObject[])val) [i] = new ManagementBaseObject(new IWbemClassObjectFreeThreaded(Marshal.GetIUnknownForObject(wmiValueArray.GetValue(i))));
							break;
						
						default:
							val = wmiValue;
							break;
					}
				}
				else
				{
					switch (type)
					{
						case CimType.SInt8:
							val = (SByte)((Int16)wmiValue);
							break;

						case CimType.UInt16:
							val = (UInt16)((Int32)wmiValue);
							break;

						case CimType.UInt32:
							val = (UInt32)((Int32)wmiValue);
							break;
						
						case CimType.UInt64:
							val = Convert.ToUInt64((String)wmiValue);
							break;

						case CimType.SInt64:
							val = Convert.ToInt64((String)wmiValue);
							break;

						case CimType.Char16:
							val = (Char)((Int16)wmiValue);
							break;

						case CimType.Object:
							val = new ManagementBaseObject(new IWbemClassObjectFreeThreaded(Marshal.GetIUnknownForObject(wmiValue)));
							break;
						
						default:
							val = wmiValue;
							break;
					}
				}
			}

			return val; 
		}

		/// <summary>
		/// Takes a managed code value, together with a desired property 
		/// </summary>
		/// <param name="val"> </param>
		/// <param name="type"> </param>
		/// <param name="isArray"> </param>
		internal static object MapValueToWmiValue(object val, CimType type, bool isArray)
		{
			object wmiValue = System.DBNull.Value;

			if (null != val)
			{
				if (isArray)
				{
					Array valArray = (Array)val;
					int length = valArray.Length;

					switch (type)
					{
						case CimType.SInt8:
							wmiValue = new Int16 [length];
							for (int i = 0; i < length; i++)
								((Int16[])(wmiValue))[i] = (Int16)Convert.ToSByte(valArray.GetValue(i));
							break;

						case CimType.UInt8: 
							if (val is Byte[])
								wmiValue = val;
							else
							{
								wmiValue = new Byte [length];
								for (int i = 0; i < length; i++)
									((Byte[])wmiValue)[i] = Convert.ToByte(valArray.GetValue(i));
							}
							break;

						case CimType.SInt16:
							if (val is Int16[])
								wmiValue = val;
							else
							{
								wmiValue = new Int16 [length];
								for (int i = 0; i < length; i++)
									((Int16[])(wmiValue))[i] = Convert.ToInt16(valArray.GetValue(i));
							}
							break;

						case CimType.UInt16:
							wmiValue = new Int32 [length];
							for (int i = 0; i < length; i++)
								((Int32[])(wmiValue))[i] = (Int32)(Convert.ToUInt16(valArray.GetValue(i)));
							break;

						case CimType.SInt32:
							if (val is Int32[])
								wmiValue = val;
							else
							{
								wmiValue = new Int32 [length];
								for (int i = 0; i < length; i++)
									((Int32[])(wmiValue))[i] = Convert.ToInt32(valArray.GetValue(i));
							}				
							break;

						case CimType.UInt32:
							wmiValue = new Int32 [length];
							for (int i = 0; i < length; i++)
								((Int32[])(wmiValue))[i] = (Int32)(Convert.ToUInt32(valArray.GetValue(i)));
							break;

						case CimType.SInt64:
							wmiValue = new String [length];
							for (int i = 0; i < length; i++)
								((String[])(wmiValue))[i] = (Convert.ToInt64(valArray.GetValue(i))).ToString();
							break;

						case CimType.UInt64:
							wmiValue = new String [length];
							for (int i = 0; i < length; i++)
								((String[])(wmiValue))[i] = (Convert.ToUInt64(valArray.GetValue(i))).ToString();
							break;

						case CimType.Real32:
							if (val is Single[])
								wmiValue = val;
							else
							{
								wmiValue = new Single [length];
								for (int i = 0; i < length; i++)
									((Single[])(wmiValue))[i] = Convert.ToSingle(valArray.GetValue(i));
							}				
							break;

						case CimType.Real64:
							if (val is Double[])
								wmiValue = val;
							else
							{
								wmiValue = new Double [length];
								for (int i = 0; i < length; i++)
									((Double[])(wmiValue))[i] = Convert.ToDouble(valArray.GetValue(i));
							}				
							break;

						case CimType.Char16: 
							wmiValue = new Int16 [length];
							for (int i = 0; i < length; i++)
								((Int16[])(wmiValue))[i] = (Int16)Convert.ToChar(valArray.GetValue(i));
							break;

						case CimType.String:
						case CimType.DateTime:
						case CimType.Reference:
							if (val is String[])
								wmiValue = val;
							else
							{
								wmiValue = new String [length];
								for (int i = 0; i < length; i++)
									((String[])(wmiValue))[i] = (valArray.GetValue(i)).ToString();
							}
							break;

						case CimType.Boolean:
							if (val is Boolean[])
								wmiValue = val;
							else
							{
								wmiValue = new Boolean [length];
								for (int i = 0; i < length; i++)
									((Boolean[])(wmiValue))[i] = Convert.ToBoolean(valArray.GetValue(i));
							}
							break;

						case CimType.Object:
							wmiValue = new IWbemClassObject_DoNotMarshal[length];

							for (int i = 0; i < length; i++)
							{
								//
								// Removed below Initialize call since wbemObject is a property that will call Initialize ( true ) on
								// its getter.
								//
								//((ManagementBaseObject)valArray.GetValue(i)).Initialize ( false ) ;
								((IWbemClassObject_DoNotMarshal[])(wmiValue))[i] = (IWbemClassObject_DoNotMarshal)(Marshal.GetObjectForIUnknown(((ManagementBaseObject)valArray.GetValue(i)).wbemObject));
							}
							break;

						default:
							wmiValue = val;
							break;
					}
				}
				else
				{
					switch (type)
					{
						case CimType.SInt8:
							wmiValue = (Int16)Convert.ToSByte(val);
							break;

						case CimType.UInt8:
							wmiValue = Convert.ToByte(val);
							break;

						case CimType.SInt16:
							wmiValue = Convert.ToInt16(val); 
							break;

						case CimType.UInt16:
							wmiValue = (Int32)(Convert.ToUInt16(val));
							break;

						case CimType.SInt32:
							wmiValue = Convert.ToInt32(val); 
							break;

						case CimType.UInt32:
							wmiValue = (Int32)Convert.ToUInt32(val);
							break;

						case CimType.SInt64:
							wmiValue = (Convert.ToInt64(val)).ToString();
							break;

						case CimType.UInt64:
							wmiValue = (Convert.ToUInt64(val)).ToString();
							break;

						case CimType.Real32:
							wmiValue = Convert.ToSingle(val);
							break;

						case CimType.Real64:
							wmiValue = Convert.ToDouble(val);
							break;

						case CimType.Char16:
							wmiValue = (Int16)Convert.ToChar(val);
							break;

						case CimType.String:
						case CimType.DateTime:
						case CimType.Reference:
							wmiValue = val.ToString();
							break;

						case CimType.Boolean:
							wmiValue = Convert.ToBoolean(val);
							break;

						case CimType.Object:
							if (val is ManagementBaseObject)
							{
								//
								// Removed Initialize call since wbemObject is a property that will call Initialize ( true ) on
								// its getter.
								//
								//((ManagementBaseObject)val).Initialize ( false ) ;
								wmiValue = Marshal.GetObjectForIUnknown(((ManagementBaseObject) val).wbemObject);
							}
							else
							{
								Debug.Assert(false, "Unhandled object type");
								wmiValue = val;
							}
							break;

						default:
							wmiValue = val;
							break;
					}
				}
			}

			return wmiValue;
		}

		internal static object MapValueToWmiValue(object val, out bool isArray, out CimType type)
		{
			object wmiValue = System.DBNull.Value;
			isArray = false;
			type = 0;
			
			if (null != val)
			{
				isArray = val.GetType().IsArray;
				Type valueType = val.GetType();

				if (isArray)
				{
					Type elementType = valueType.GetElementType();

					// Casting primitive types to object[] is not allowed
					if (elementType.IsPrimitive)
					{
						if (elementType == typeof(System.Byte))
						{
							byte[] arrayValue = (byte[])val;
							int length = arrayValue.Length;
							type = CimType.UInt8;
							wmiValue = new short[length];

							for (int i = 0; i < length; i++)
								((short[])wmiValue) [i] = ((IConvertible)((System.Byte)(arrayValue[i]))).ToInt16(null);
						}
						else if (elementType == typeof(System.SByte))
						{
							sbyte[] arrayValue = (sbyte[])val;
							int length = arrayValue.Length;
							type = CimType.SInt8;
							wmiValue = new short[length];

							for (int i = 0; i < length; i++)
								((short[])wmiValue) [i] = ((IConvertible)((System.SByte)(arrayValue[i]))).ToInt16(null);
						}
						else if (elementType == typeof(System.Boolean))
						{
							type = CimType.Boolean;
							wmiValue = (bool[])val;
						}					
						else if (elementType == typeof(System.UInt16))
						{
							ushort[] arrayValue = (ushort[])val;
							int length = arrayValue.Length;
							type = CimType.UInt16;
							wmiValue = new int[length];

							for (int i = 0; i < length; i++)
								((int[])wmiValue) [i] = ((IConvertible)((System.UInt16)(arrayValue[i]))).ToInt32(null);
						}
						else if (elementType == typeof(System.Int16))
						{
							type = CimType.SInt16;
							wmiValue = (short[])val;
						}
						else if (elementType == typeof(System.Int32))
						{
							type = CimType.SInt32;
							wmiValue = (int[])val;
						}
						else if (elementType == typeof(System.UInt32))
						{
							uint[] arrayValue = (uint[])val;
							int length = arrayValue.Length;
							type = CimType.UInt32;
							wmiValue = new string[length];

							for (int i = 0; i < length; i++)
								((string[])wmiValue) [i] = ((System.UInt32)(arrayValue[i])).ToString();
						}
						else if (elementType == typeof(System.UInt64))
						{
							ulong[] arrayValue = (ulong[])val;
							int length = arrayValue.Length;
							type = CimType.UInt64;
							wmiValue = new string[length];

							for (int i = 0; i < length; i++)
								((string[])wmiValue) [i] = ((System.UInt64)(arrayValue[i])).ToString();
						}
						else if (elementType == typeof(System.Int64))
						{
							long[] arrayValue = (long[])val;
							int length = arrayValue.Length;
							type = CimType.SInt64;
							wmiValue = new string[length];

							for (int i = 0; i < length; i++)
								((string[])wmiValue) [i] = ((long)(arrayValue[i])).ToString();
						}
						else if (elementType == typeof(System.Single))
						{
							type = CimType.Real32;
							wmiValue = (System.Single[])val;
						}
						else if (elementType == typeof(System.Double))
						{
							type = CimType.Real64;
							wmiValue = (double[])val;
						}
						else if (elementType == typeof(System.Char))
						{
							char[] arrayValue = (char[])val;
							int length = arrayValue.Length;
							type = CimType.Char16;
							wmiValue = new short[length];

							for (int i = 0; i < length; i++)
								((short[])wmiValue) [i] = ((IConvertible)((System.Char)(arrayValue[i]))).ToInt16(null);
						}
					}
					else
					{
						// Non-primitive types
						if (elementType == typeof(System.String))
						{
							type = CimType.String;
							wmiValue = (string[])val;
						}
						else
						{
							// Check for an embedded object array
							if (val is ManagementBaseObject[])
							{
								Array valArray = (Array)val;
								int length = valArray.Length;
								type = CimType.Object;
								wmiValue = new IWbemClassObject_DoNotMarshal[length];

								for (int i = 0; i < length; i++)
								{
									//
									// Removed Initialize call since wbemObject is a property that will call Initialize ( true ) on
									// its getter.
									//
									//((ManagementBaseObject)valArray.GetValue(i)).Initialize ( false ) ;
									((IWbemClassObject_DoNotMarshal[])(wmiValue))[i] = (IWbemClassObject_DoNotMarshal)(Marshal.GetObjectForIUnknown(((ManagementBaseObject)valArray.GetValue(i)).wbemObject));
								}
							}
							else
								// System.Decimal, System.IntPr, System.UIntPtr, unhandled object, or unknown.
								Debug.Assert(false, "Unhandled type");
						}
					}
				}
				else	// Non-array values
				{
					if (valueType == typeof(System.UInt16))
					{
						type = CimType.UInt16;
						wmiValue = ((IConvertible)((System.UInt16)val)).ToInt32(null);
					}
					else if (valueType == typeof(System.UInt32))
					{
						type = CimType.UInt32;
						if (((System.UInt32)val & 0x80000000) != 0)
							wmiValue = Convert.ToString(val);
						else
							wmiValue = Convert.ToInt32(val);
					}
					else if (valueType == typeof(System.UInt64))
					{
						type = CimType.UInt64;
						wmiValue = ((System.UInt64)val).ToString();
					}
					else if (valueType == typeof(System.SByte))
					{
						type = CimType.SInt8;
						wmiValue = ((IConvertible)((System.SByte)val)).ToInt16(null);
					}
					else if (valueType == typeof(System.Byte))
					{
                        type = CimType.UInt8;
						wmiValue = val;
					}
					else if (valueType == typeof(System.Int16))
					{
						type = CimType.SInt16;
						wmiValue = val;
					}
					else if (valueType == typeof(System.Int32))
					{
						type = CimType.SInt32;
						wmiValue = val;
					}
					else if (valueType == typeof(System.Int64))
					{
						type = CimType.SInt64;
						wmiValue = val.ToString();
					}
					else if (valueType == typeof(System.Boolean))
					{
						type = CimType.Boolean;
						wmiValue = val;
					}
					else if (valueType == typeof(System.Single))
					{
						type = CimType.Real32;
						wmiValue = val;
					}
					else if (valueType == typeof(System.Double))
					{
						type = CimType.Real64;
						wmiValue = val;
					}
					else if (valueType == typeof(System.Char))
					{
						type = CimType.Char16;
						wmiValue = ((IConvertible)((System.Char)val)).ToInt16(null);
					}
					else if (valueType == typeof(System.String))
					{
						type = CimType.String;
						wmiValue = val;
					}
					else
					{
						// Check for an embedded object
						if (val is ManagementBaseObject)
						{
							type = CimType.Object;
							//
							// Removed Initialize call since wbemObject is a property that will call Initialize ( true ) on
							// its getter.
							//
							//((ManagementBaseObject)val).Initialize ( false ) ;
							wmiValue = Marshal.GetObjectForIUnknown(((ManagementBaseObject) val).wbemObject);
						}
						else
							// System.Decimal, System.IntPr, System.UIntPtr, unhandled object, or unknown.
							Debug.Assert(false, "Unhandled type");
					}
				}
			}

			return wmiValue;
		}

	}//PropertyData
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\propertyset.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Collections;
using System.Diagnostics;
using System.Runtime.InteropServices;
using WbemClient_v1;
using System.ComponentModel;

namespace System.Management
{
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para> Represents the set of properties of a WMI object.</para>
	/// </summary>
	/// <example>
	///    <code lang='C#'>using System; 
	/// using System.Management; 
	/// 
	/// // This sample demonstrates how to enumerate properties 
	/// // in a ManagementObject object.
	/// class Sample_PropertyDataCollection 
	/// { 
	///     public static int Main(string[] args) {
	///         ManagementObject disk = new ManagementObject("win32_logicaldisk.deviceid = \"c:\""); 
	///         PropertyDataCollection diskProperties = disk.Properties;
	///         foreach (PropertyData diskProperty in diskProperties) {
	///             Console.WriteLine("Property = " + diskProperty.Name);
	///         }
	///         return 0;
	///     }
	/// }
	///    </code>
	///    <code lang='VB'>Imports System
	/// Imports System.Management
	/// 
	/// ' This sample demonstrates how to enumerate properties
	/// ' in a ManagementObject object.
	/// Class Sample_PropertyDataCollection
	///     Overloads Public Shared Function Main(args() As String) As Integer
	///         Dim disk As New ManagementObject("win32_logicaldisk.deviceid=""c:""")
	///         Dim diskProperties As PropertyDataCollection = disk.Properties
	///         Dim diskProperty As PropertyData
	///         For Each diskProperty In diskProperties
	///             Console.WriteLine("Property = " &amp; diskProperty.Name)
	///         Next diskProperty
	///         Return 0
	///     End Function
	/// End Class
	///    </code>
	/// </example>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class PropertyDataCollection : ICollection, IEnumerable
	{
		private ManagementBaseObject parent;
		bool isSystem;

		internal PropertyDataCollection(ManagementBaseObject parent, bool isSystem) : base()
		{
			this.parent = parent;
			this.isSystem = isSystem;
		}

		//
		//ICollection
		//

		/// <summary>
		/// <para>Gets or sets the number of objects in the <see cref='System.Management.PropertyDataCollection'/>.</para>
		/// </summary>
		/// <value>
		///    <para>The number of objects in the collection.</para>
		/// </value>
		public int Count 
		{
			get {
				string[] propertyNames = null; object qualVal = null;
				int flag;
				if (isSystem)
					flag = (int)tag_WBEM_CONDITION_FLAG_TYPE.WBEM_FLAG_SYSTEM_ONLY;
				else
					flag = (int)tag_WBEM_CONDITION_FLAG_TYPE.WBEM_FLAG_NONSYSTEM_ONLY;

				flag = flag | (int)tag_WBEM_CONDITION_FLAG_TYPE.WBEM_FLAG_ALWAYS;

				int status = parent.wbemObject.GetNames_(null, flag, ref qualVal, out propertyNames);

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}

				return propertyNames.Length;
			}
		}

		/// <summary>
		///    <para>Gets or sets a value indicating whether the object is synchronized.</para>
		/// </summary>
		/// <value>
		/// <para><see langword='true'/> if the object is synchronized; 
		///    otherwise, <see langword='false'/>.</para>
		/// </value>
		public bool IsSynchronized { get { return false; } 
		}

		/// <summary>
		///    <para>Gets or sets the object to be used for synchronization.</para>
		/// </summary>
		/// <value>
		///    <para>The object to be used for synchronization.</para>
		/// </value>
		public object SyncRoot { get { return this; } 
		}

		/// <overload>
		/// <para>Copies the <see cref='System.Management.PropertyDataCollection'/> into an array.</para>
		/// </overload>
		/// <summary>
		/// <para>Copies the <see cref='System.Management.PropertyDataCollection'/> into an array.</para>
		/// </summary>
		/// <param name='array'>The array to which to copy the <see cref='System.Management.PropertyDataCollection'/>. </param>
		/// <param name='index'>The index from which to start copying. </param>
		public void CopyTo(Array array, Int32 index) 
		{
			if (null == array)
				throw new ArgumentNullException("array");

			if ((index < array.GetLowerBound(0)) || (index > array.GetUpperBound(0)))
				throw new ArgumentOutOfRangeException("index");

			// Get the names of the properties 
			string[] nameArray = null;
			object dummy = null;
			int flag = 0;

			if (isSystem)
				flag |= (int)tag_WBEM_CONDITION_FLAG_TYPE.WBEM_FLAG_SYSTEM_ONLY;
			else
				flag |= (int)tag_WBEM_CONDITION_FLAG_TYPE.WBEM_FLAG_NONSYSTEM_ONLY;
				
			flag |= (int)tag_WBEM_CONDITION_FLAG_TYPE.WBEM_FLAG_ALWAYS;
				
			int status = this.parent.wbemObject.GetNames_(null, flag, ref dummy, out nameArray);

			if (status >= 0)
			{
				if ((index + nameArray.Length) > array.Length)
					throw new ArgumentException("index");

				foreach (string propertyName in nameArray)
					array.SetValue(new PropertyData(parent, propertyName), index++);
			}

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}

			return;
		}

		/// <summary>
		/// <para>Copies the <see cref='System.Management.PropertyDataCollection'/> to a specialized <see cref='System.Management.PropertyData'/> object
		///    array.</para>
		/// </summary>
		/// <param name='propertyArray'>The destination array to contain the copied <see cref='System.Management.PropertyDataCollection'/>.</param>
		/// <param name=' index'>The index in the destination array from which to start copying.</param>
		public void CopyTo(PropertyData[] propertyArray, Int32 index)
		{
			CopyTo((Array)propertyArray, index);	
		}
		//
		// IEnumerable
		//
		IEnumerator IEnumerable.GetEnumerator()
		{
			return (IEnumerator)(new PropertyDataEnumerator(parent, isSystem));
		}

		/// <summary>
		/// <para>Returns the enumerator for this <see cref='System.Management.PropertyDataCollection'/>.</para>
		/// </summary>
		/// <returns>
		/// <para>An <see cref='System.Collections.IEnumerator'/> 
		/// that can be used to iterate through the collection.</para>
		/// </returns>
		public PropertyDataEnumerator GetEnumerator()
		{
			return new PropertyDataEnumerator(parent, isSystem);
		}

		//Enumerator class
		/// <summary>
		/// <para>Represents the enumerator for <see cref='System.Management.PropertyData'/> 
		/// objects in the <see cref='System.Management.PropertyDataCollection'/>.</para>
		/// </summary>
		/// <example>
		///    <code lang='C#'>using System; 
		/// using System.Management; 
		/// 
		/// // This sample demonstrates how to enumerate all properties in a 
		/// // ManagementObject using the PropertyDataEnumerator object. 
		/// class Sample_PropertyDataEnumerator 
		/// {
		///     public static int Main(string[] args) { 
		///         ManagementObject disk = new ManagementObject("Win32_LogicalDisk.DeviceID='C:'");
		///         PropertyDataCollection.PropertyDataEnumerator propertyEnumerator = disk.Properties.GetEnumerator();
		///         while(propertyEnumerator.MoveNext()) {
		///             PropertyData p = (PropertyData)propertyEnumerator.Current;
		///             Console.WriteLine("Property found: " + p.Name);
		///         }
		///         return 0;
		///     }
		/// }
		///    </code>
		///    <code lang='VB'>Imports System
		/// Imports System.Management
		/// 
		/// ' This sample demonstrates how to enumerate all properties in a
		/// ' ManagementObject using PropertyDataEnumerator object.
		/// Class Sample_PropertyDataEnumerator
		///     Overloads Public Shared Function Main(args() As String) As Integer
		///         Dim disk As New ManagementObject("Win32_LogicalDisk.DeviceID='C:'")
		///         Dim propertyEnumerator As _
		///           PropertyDataCollection.PropertyDataEnumerator = disk.Properties.GetEnumerator()
		///         While propertyEnumerator.MoveNext()
		///             Dim p As PropertyData = _
		///                 CType(propertyEnumerator.Current, PropertyData)
		///             Console.WriteLine("Property found: " &amp; p.Name)
		///          End While
		///          Return 0
		///      End Function
		/// End Class
		///    </code>
		/// </example>
		public class PropertyDataEnumerator : IEnumerator
		{
			private ManagementBaseObject parent;
			private string[] propertyNames;
			private int index;

			internal PropertyDataEnumerator(ManagementBaseObject parent, bool isSystem)
			{
				this.parent = parent;
				propertyNames = null; index = -1;
				int flag; object qualVal = null;

				if (isSystem)
					flag = (int)tag_WBEM_CONDITION_FLAG_TYPE.WBEM_FLAG_SYSTEM_ONLY;
				else
					flag = (int)tag_WBEM_CONDITION_FLAG_TYPE.WBEM_FLAG_NONSYSTEM_ONLY;
				flag = flag | (int)tag_WBEM_CONDITION_FLAG_TYPE.WBEM_FLAG_ALWAYS;

				int status = parent.wbemObject.GetNames_(null, flag, ref qualVal, out propertyNames);

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}
			}
		
			object IEnumerator.Current { get { return (object)this.Current; } }

			/// <summary>
			/// <para>Gets the current <see cref='System.Management.PropertyData'/> in the <see cref='System.Management.PropertyDataCollection'/> enumeration.</para>
			/// </summary>
			/// <value>
			///    The current <see cref='System.Management.PropertyData'/>
			///    element in the collection.
			/// </value>
			public PropertyData Current 
			{
				get {
					if ((index == -1) || (index == propertyNames.Length))
						throw new InvalidOperationException();
					else
						return new PropertyData(parent, propertyNames[index]);
				}
			}

			/// <summary>
			/// <para> Moves to the next element in the <see cref='System.Management.PropertyDataCollection'/> 
			/// enumeration.</para>
			/// </summary>
			/// <returns>
			/// <para><see langword='true'/> if the enumerator was successfully advanced to the next element; 
			/// <see langword='false'/> if the enumerator has passed the end of the collection.</para>
			/// </returns>
			public bool MoveNext()
			{
				if (index == propertyNames.Length) //passed the end of the array
					return false; //don't advance the index any more

				index++;
				return (index == propertyNames.Length) ? false : true;
			}

			/// <summary>
			/// <para>Resets the enumerator to the beginning of the <see cref='System.Management.PropertyDataCollection'/> 
			/// enumeration.</para>
			/// </summary>
			public void Reset()
			{
				index = -1;
			}
            
		}//PropertyDataEnumerator



		//
		// Methods
		//

		/// <summary>
		/// <para> Returns the specified property from the <see cref='System.Management.PropertyDataCollection'/>, using [] syntax.</para>
		/// </summary>
		/// <param name='propertyName'>The name of the property to retrieve.</param>
		/// <value>
		/// <para> A <see cref='System.Management.PropertyData'/>, based on
		///    the name specified.</para>
		/// </value>
		/// <example>
		///    <code lang='C#'>ManagementObject o = new ManagementObject("Win32_LogicalDisk.Name = 'C:'");
		/// Console.WriteLine("Free space on C: drive is: ", c.Properties["FreeSpace"].Value);
		///    </code>
		///    <code lang='VB'>Dim o As New ManagementObject("Win32_LogicalDisk.Name=""C:""")
		/// Console.WriteLine("Free space on C: drive is: " &amp; c.Properties("FreeSpace").Value)
		///    </code>
		/// </example>
		public virtual PropertyData this[string propertyName] 
		{
			get { 
				if (null == propertyName)
					throw new ArgumentNullException("propertyName");

				return new PropertyData(parent, propertyName);
            }
		}

		/// <summary>
		/// <para>Removes a <see cref='System.Management.PropertyData'/> from the <see cref='System.Management.PropertyDataCollection'/>.</para>
		/// </summary>
		/// <param name='propertyName'>The name of the property to be removed.</param>
		/// <remarks>
		///    <para> Properties can only be removed from class definitions, 
		///       not from instances. This method is only valid when invoked on a property
		///       collection in a <see cref='System.Management.ManagementClass'/>.</para>
		/// </remarks>
		/// <example>
		///    <code lang='C#'>ManagementClass c = new ManagementClass("MyClass");
		/// c.Properties.Remove("PropThatIDontWantOnThisClass");
		///    </code>
		///    <code lang='VB'>Dim c As New ManagementClass("MyClass")
		/// c.Properties.Remove("PropThatIDontWantOnThisClass")
		///    </code>
		/// </example>
		public virtual void Remove(string propertyName)
		{
			// On instances, reset the property to the default value for the class.
			if (parent.GetType() == typeof(ManagementObject))
			{
				ManagementClass cls = new ManagementClass(parent.ClassPath);
				parent.SetPropertyValue(propertyName, cls.GetPropertyValue(propertyName));
			}
			else
			{
				int status = parent.wbemObject.Delete_(propertyName);

				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}
			}
		}

		/// <overload>
		/// <para>Adds a new <see cref='System.Management.PropertyData'/> with the specified value.</para>
		/// </overload>
		/// <summary>
		/// <para>Adds a new <see cref='System.Management.PropertyData'/> with the specified value. The value cannot
		///    be null and must be convertable to a CIM type.</para>
		/// </summary>
		/// <param name='propertyName'>The name of the new property.</param>
		/// <param name='propertyValue'>The value of the property (cannot be null).</param>
		/// <remarks>
		///    <para> Properties can only be added to class definitions, not 
		///       to instances. This method is only valid when invoked on a <see cref='System.Management.PropertyDataCollection'/>
		///       in
		///       a <see cref='System.Management.ManagementClass'/>.</para>
		/// </remarks>
		public virtual void Add(string propertyName, Object propertyValue)
		{
			if (null == propertyValue)
				throw new ArgumentNullException("propertyValue");

			if (parent.GetType() == typeof(ManagementObject)) //can't add properties to instance
				throw new InvalidOperationException();

			CimType cimType = 0;
			bool isArray = false;
			object wmiValue = PropertyData.MapValueToWmiValue(propertyValue, out isArray, out cimType);
			int wmiCimType = (int)cimType;

			if (isArray)
				wmiCimType |= (int)tag_CIMTYPE_ENUMERATION.CIM_FLAG_ARRAY;

			int status = parent.wbemObject.Put_(propertyName, 0, ref wmiValue, wmiCimType);

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}
		}

		/// <summary>
		/// <para>Adds a new <see cref='System.Management.PropertyData'/> with the specified value and CIM type.</para>
		/// </summary>
		/// <param name='propertyName'>The name of the property.</param>
		/// <param name='propertyValue'>The value of the property (which can be null).</param>
		/// <param name='propertyType'>The CIM type of the property.</param>
		/// <remarks>
		///    <para> Properties can only be added to class definitions, not 
		///       to instances. This method is only valid when invoked on a <see cref='System.Management.PropertyDataCollection'/>
		///       in
		///       a <see cref='System.Management.ManagementClass'/>.</para>
		/// </remarks>
		public void Add(string propertyName, Object propertyValue, CimType propertyType)
		{
			if (null == propertyName)
				throw new ArgumentNullException("propertyName");

			if (parent.GetType() == typeof(ManagementObject)) //can't add properties to instance
				throw new InvalidOperationException();

			int wmiCimType = (int)propertyType;
			bool isArray = false;

			if ((null != propertyValue) && propertyValue.GetType().IsArray)
			{
				isArray = true;
				wmiCimType = (wmiCimType | (int)tag_CIMTYPE_ENUMERATION.CIM_FLAG_ARRAY);
			}

			object wmiValue = PropertyData.MapValueToWmiValue(propertyValue, propertyType, isArray);

			int status = parent.wbemObject.Put_(propertyName, 0, ref wmiValue, wmiCimType);

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}
		}
		
		/// <summary>
		/// <para>Adds a new <see cref='System.Management.PropertyData'/> with no assigned value.</para>
		/// </summary>
		/// <param name='propertyName'>The name of the property.</param>
		/// <param name='propertyType'>The CIM type of the property.</param>
		/// <param name='isArray'><see langword='true'/> to specify that the property is an array type; otherwise, <see langword='false'/>.</param>
		/// <remarks>
		///    <para> Properties can only be added to class definitions, not 
		///       to instances. This method is only valid when invoked on a <see cref='System.Management.PropertyDataCollection'/>
		///       in
		///       a <see cref='System.Management.ManagementClass'/>.</para>
		/// </remarks>
		public void Add(string propertyName, CimType propertyType, bool isArray)
		{
			if (null == propertyName)
				throw new ArgumentNullException(propertyName);

			if (parent.GetType() == typeof(ManagementObject)) //can't add properties to instance
				throw new InvalidOperationException();

			int wmiCimType = (int)propertyType;  
			
			if (isArray)
				wmiCimType = (wmiCimType | (int)tag_CIMTYPE_ENUMERATION.CIM_FLAG_ARRAY);

			object dummyObj = System.DBNull.Value;

			int status = parent.wbemObject.Put_(propertyName, 0, ref dummyObj, wmiCimType);

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}
		}
		
	}//PropertyDataCollection
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\qualifierset.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Collections;
using System.Runtime.InteropServices;
using WbemClient_v1;

namespace System.Management
{
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	/// <para> Represents a collection of <see cref='System.Management.QualifierData'/> objects.</para>
	/// </summary>
	/// <example>
	///    <code lang='C#'>using System; 
	/// using System.Management;
	///  
	/// // This sample demonstrates how to list all qualifiers including amended 
	/// // qualifiers of a ManagementClass object. 
	/// class Sample_QualifierDataCollection 
	/// { 
	///     public static int Main(string[] args) { 
	///         ManagementClass diskClass = new ManagementClass("Win32_LogicalDisk"); 
	///         diskClass.Options.UseAmendedQualifiers = true;
	///         QualifierDataCollection qualifierCollection = diskClass.Qualifiers;
	///         foreach (QualifierData q in qualifierCollection) {
	///             Console.WriteLine(q.Name + " = " + q.Value);
	///         }
	///         return 0;
	///     }
	/// }
	///    </code>
	///    <code lang='VB'>Imports System
	///       Imports System.Management
	///       ' This sample demonstrates how to list all qualifiers including amended
	///       ' qualifiers of a ManagementClass object.
	///       Class Sample_QualifierDataCollection
	///       Overloads Public Shared Function Main(args() As String) As Integer
	///       Dim diskClass As New ManagementClass("Win32_LogicalDisk")
	///       diskClass.Options.UseAmendedQualifiers = true
	///       Dim qualifierCollection As QualifierDataCollection = diskClass.Qualifiers
	///       Dim q As QualifierData
	///       For Each q In qualifierCollection
	///       Console.WriteLine(q.Name &amp; " = " &amp; q.Value)
	///       Next q
	///       Return 0
	///       End Function
	///       End Class
	///    </code>
	/// </example>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class QualifierDataCollection : ICollection, IEnumerable
	{
		private ManagementBaseObject parent;
		private string propertyOrMethodName;
		private QualifierType qualifierSetType;

		internal QualifierDataCollection(ManagementBaseObject parent) : base()
		{
			this.parent = parent;
			this.qualifierSetType = QualifierType.ObjectQualifier;
			this.propertyOrMethodName = null;
		}

		internal QualifierDataCollection(ManagementBaseObject parent, string propertyOrMethodName, QualifierType type) : base()
		{
			this.parent = parent;
			this.propertyOrMethodName = propertyOrMethodName;
			this.qualifierSetType = type;
		}

		/// <summary>
		/// Return the qualifier set associated with its type
		/// Overload with use of private data member, qualifierType
		/// </summary>
		private IWbemQualifierSetFreeThreaded GetTypeQualifierSet()
		{
			return GetTypeQualifierSet(qualifierSetType);
		}

		/// <summary>
		/// Return the qualifier set associated with its type
		/// </summary>
		private IWbemQualifierSetFreeThreaded GetTypeQualifierSet(QualifierType qualifierSetType)
		{
			IWbemQualifierSetFreeThreaded qualifierSet	= null;
			int status						= (int)ManagementStatus.NoError;

			switch (qualifierSetType) 
			{
				case QualifierType.ObjectQualifier :
					status = parent.wbemObject.GetQualifierSet_(out qualifierSet);
					break;
				case QualifierType.PropertyQualifier :
					status = parent.wbemObject.GetPropertyQualifierSet_(propertyOrMethodName, out qualifierSet);
					break;
				case QualifierType.MethodQualifier :
					status = parent.wbemObject.GetMethodQualifierSet_(propertyOrMethodName, out qualifierSet);
					break;
				default :
					throw new ManagementException(ManagementStatus.Unexpected, null, null);	// Is this the best fit error ??
			}

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}

			return qualifierSet;
		}

		//
		//ICollection
		//

		/// <summary>
		/// <para>Gets or sets the number of <see cref='System.Management.QualifierData'/> objects in the <see cref='System.Management.QualifierDataCollection'/>.</para>
		/// </summary>
		/// <value>
		///    <para>The number of objects in the collection.</para>
		/// </value>
		public int Count 
		{
			get {
				string[] qualifierNames = null;
                IWbemQualifierSetFreeThreaded quals;
                try
                {
                    quals = GetTypeQualifierSet();
                }
                catch(ManagementException e)
                {
                    // If we ask for the number of qualifiers on a system property, we return '0'
                    if(qualifierSetType == QualifierType.PropertyQualifier && e.ErrorCode == ManagementStatus.SystemProperty)
                        return 0;
                    else
                        throw;
                }
				int status = quals.GetNames_(0, out qualifierNames);
				
				if (status < 0)
				{
					if ((status & 0xfffff000) == 0x80041000)
						ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
					else
						Marshal.ThrowExceptionForHR(status);
				}

				return qualifierNames.Length;
			}
		}

		/// <summary>
		///    <para>Gets or sets a value indicating whether the object is synchronized.</para>
		/// </summary>
		/// <value>
		/// <para><see langword='true'/> if the object is synchronized; 
		///    otherwise, <see langword='false'/>.</para>
		/// </value>
		public bool IsSynchronized { get { return false; } 
		}

		/// <summary>
		///    <para>Gets or sets the object to be used for synchronization.</para>
		/// </summary>
		/// <value>
		///    <para>The object to be used for synchronization.</para>
		/// </value>
		public object SyncRoot { get { return this; } 
		}

		/// <overload>
		/// <para>Copies the <see cref='System.Management.QualifierDataCollection'/> into an array.</para>
		/// </overload>
		/// <summary>
		/// <para> Copies the <see cref='System.Management.QualifierDataCollection'/> into an array.</para>
		/// </summary>
		/// <param name='array'>The array to which to copy the <see cref='System.Management.QualifierDataCollection'/>. </param>
		/// <param name='index'>The index from which to start copying. </param>
		public void CopyTo(Array array, int index)
		{
			if (null == array)
				throw new ArgumentNullException("array");

			if ((index < array.GetLowerBound(0)) || (index > array.GetUpperBound(0)))
				throw new ArgumentOutOfRangeException("index");

			// Get the names of the qualifiers
			string[] qualifierNames = null;
            IWbemQualifierSetFreeThreaded quals;
            try
            {
                quals = GetTypeQualifierSet();
            }
            catch(ManagementException e)
            {
                // There are NO qualifiers on system properties, so we just return
                if(qualifierSetType == QualifierType.PropertyQualifier && e.ErrorCode == ManagementStatus.SystemProperty)
                    return;
                else
                    throw;
            }
			int status = quals.GetNames_(0, out qualifierNames);

			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}

			if ((index + qualifierNames.Length) > array.Length)
				throw new ArgumentException("index");

			foreach (string qualifierName in qualifierNames)
				array.SetValue(new QualifierData(parent, propertyOrMethodName, qualifierName, qualifierSetType), index++);

			return;
		}

		/// <summary>
		/// <para>Copies the <see cref='System.Management.QualifierDataCollection'/> into a specialized 
		/// <see cref='System.Management.QualifierData'/> 
		/// array.</para>
		/// </summary>
		/// <param name='qualifierArray'><para>The specialized array of <see cref='System.Management.QualifierData'/> objects 
		/// to which to copy the <see cref='System.Management.QualifierDataCollection'/>.</para></param>
		/// <param name=' index'>The index from which to start copying.</param>
		public void CopyTo(QualifierData[] qualifierArray, int index)
		{
			CopyTo((Array)qualifierArray, index);
		}

		//
		// IEnumerable
		//
		IEnumerator IEnumerable.GetEnumerator()
		{
			return (IEnumerator)(new QualifierDataEnumerator(parent, propertyOrMethodName, qualifierSetType));
		}

		/// <summary>
		/// <para>Returns an enumerator for the <see cref='System.Management.QualifierDataCollection'/>. This method is strongly typed.</para>
		/// </summary>
		/// <returns>
		/// <para>An <see cref='System.Collections.IEnumerator'/> that can be used to iterate through the 
		///    collection.</para>
		/// </returns>
		public QualifierDataEnumerator GetEnumerator()
		{
			return new QualifierDataEnumerator(parent, propertyOrMethodName, qualifierSetType);
		}

		/// <summary>
		/// <para>Represents the enumerator for <see cref='System.Management.QualifierData'/> 
		/// objects in the <see cref='System.Management.QualifierDataCollection'/>.</para>
		/// </summary>
		/// <example>
		///    <code lang='C#'>using System; 
		/// using System.Management; 
		/// 
		/// // This sample demonstrates how to enumerate qualifiers of a ManagementClass 
		/// // using QualifierDataEnumerator object. 
		/// class Sample_QualifierDataEnumerator 
		/// { 
		///     public static int Main(string[] args) { 
		///         ManagementClass diskClass = new ManagementClass("Win32_LogicalDisk"); 
		///         diskClass.Options.UseAmendedQualifiers = true; 
		///         QualifierDataCollection diskQualifier = diskClass.Qualifiers;
		///         QualifierDataCollection.QualifierDataEnumerator 
		///             qualifierEnumerator = diskQualifier.GetEnumerator();
		///         while(qualifierEnumerator.MoveNext()) {
		///             Console.WriteLine(qualifierEnumerator.Current.Name + " = " +
		///                 qualifierEnumerator.Current.Value);
		///         }
		///         return 0;
		///     }
		/// }
		///    </code>
		///    <code lang='VB'>Imports System
		/// Imports System.Management
		/// 
		/// ' This sample demonstrates how to enumerate qualifiers of a ManagementClass
		/// ' using QualifierDataEnumerator object.
		/// Class Sample_QualifierDataEnumerator
		///     Overloads Public Shared Function Main(args() As String) As Integer
		///         Dim diskClass As New ManagementClass("win32_logicaldisk")
		///         diskClass.Options.UseAmendedQualifiers = True
		///         Dim diskQualifier As QualifierDataCollection = diskClass.Qualifiers
		///         Dim qualifierEnumerator As _
		///             QualifierDataCollection.QualifierDataEnumerator = _
		///                 diskQualifier.GetEnumerator()
		///         While qualifierEnumerator.MoveNext()
		///             Console.WriteLine(qualifierEnumerator.Current.Name &amp; _
		///                 " = " &amp; qualifierEnumerator.Current.Value)
		///         End While
		///         Return 0
		///     End Function
		/// End Class
		///    </code>
		/// </example>
		public class QualifierDataEnumerator : IEnumerator
		{
			private ManagementBaseObject parent;
			private string propertyOrMethodName;
			private QualifierType qualifierType;
			private string[] qualifierNames;
			private int index = -1;

			//Internal constructor
			internal QualifierDataEnumerator(ManagementBaseObject parent, string propertyOrMethodName, 
														QualifierType qualifierType)
			{
				this.parent						= parent;
				this.propertyOrMethodName		= propertyOrMethodName;
				this.qualifierType				= qualifierType;
				this.qualifierNames				= null;

				IWbemQualifierSetFreeThreaded qualifierSet	= null;
				int status						= (int)ManagementStatus.NoError;

				switch (qualifierType) 
				{
					case QualifierType.ObjectQualifier :
						status = parent.wbemObject.GetQualifierSet_(out qualifierSet);
						break;
					case QualifierType.PropertyQualifier :
						status = parent.wbemObject.GetPropertyQualifierSet_(propertyOrMethodName, out qualifierSet);
						break;
					case QualifierType.MethodQualifier :
						status = parent.wbemObject.GetMethodQualifierSet_(propertyOrMethodName, out qualifierSet);
						break;
					default :
						throw new ManagementException(ManagementStatus.Unexpected, null, null);	// Is this the best fit error ??
				}

                // If we got an error code back, assume there are NO qualifiers for this object/property/method
                if(status < 0)
                {
                    // TODO: Should we look at specific error codes.  For example, if you ask
                    // for the qualifier set on a system property, GetPropertyQualifierSet() returns
                    // WBEM_E_SYSTEM_PROPERTY.
                    qualifierNames = new String[]{};
                }
                else
                {
                    status = qualifierSet.GetNames_(0, out qualifierNames);
    							
                    if (status < 0)
                    {
                        if ((status & 0xfffff000) == 0x80041000)
                            ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
                        else
                            Marshal.ThrowExceptionForHR(status);
                    }
                }
			}
		
			//Standard "Current" variant
			object IEnumerator.Current {	get { return (object)this.Current; } }

			/// <summary>
			/// <para>Gets or sets the current <see cref='System.Management.QualifierData'/> in the <see cref='System.Management.QualifierDataCollection'/> enumeration.</para>
			/// </summary>
			/// <value>
			/// <para>The current <see cref='System.Management.QualifierData'/> element in the collection.</para>
			/// </value>
			public QualifierData Current 
			{
				get {
					if ((index == -1) || (index == qualifierNames.Length))
						throw new InvalidOperationException();
					else
						return new QualifierData(parent, propertyOrMethodName, 
												qualifierNames[index], qualifierType);
				}
			}

			/// <summary>
			/// <para> Moves to the next element in the <see cref='System.Management.QualifierDataCollection'/> enumeration.</para>
			/// </summary>
			/// <returns>
			/// <para><see langword='true'/> if the enumerator was successfully advanced to the next 
			///    element; <see langword='false'/> if the enumerator has passed the end of the
			///    collection.</para>
			/// </returns>
			public bool MoveNext()
			{
				if (index == qualifierNames.Length) //passed the end of the array
					return false; //don't advance the index any more

				index++;
				return (index == qualifierNames.Length) ? false : true;
			}

			/// <summary>
			/// <para>Resets the enumerator to the beginning of the <see cref='System.Management.QualifierDataCollection'/> enumeration.</para>
			/// </summary>
			public void Reset()
			{
				index = -1;
			}
            
		}//QualifierDataEnumerator


		//
		//Methods
		//

		/// <summary>
		/// <para> Gets the specified <see cref='System.Management.QualifierData'/> from the <see cref='System.Management.QualifierDataCollection'/>.</para>
		/// </summary>
		/// <param name='qualifierName'>The name of the <see cref='System.Management.QualifierData'/> to access in the <see cref='System.Management.QualifierDataCollection'/>. </param>
		/// <value>
		/// <para>A <see cref='System.Management.QualifierData'/>, based on the name specified.</para>
		/// </value>
		public virtual QualifierData this[string qualifierName] 
		{
			get { 
				if (null == qualifierName)
					throw new ArgumentNullException("qualifierName");

				return new QualifierData(parent, propertyOrMethodName, qualifierName, qualifierSetType); 
			}
		}

		/// <summary>
		/// <para>Removes a <see cref='System.Management.QualifierData'/> from the <see cref='System.Management.QualifierDataCollection'/> by name.</para>
		/// </summary>
		/// <param name='qualifierName'>The name of the <see cref='System.Management.QualifierData'/> to remove. </param>
		public virtual void Remove(string qualifierName)
		{
			int status = GetTypeQualifierSet().Delete_(qualifierName);
		
			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}
		}

		/// <overload>
		/// <para>Adds a <see cref='System.Management.QualifierData'/> to the <see cref='System.Management.QualifierDataCollection'/>.</para>
		/// </overload>
		/// <summary>
		/// <para>Adds a <see cref='System.Management.QualifierData'/> to the <see cref='System.Management.QualifierDataCollection'/>. This overload specifies the qualifier name and value.</para>
		/// </summary>
		/// <param name='qualifierName'>The name of the <see cref='System.Management.QualifierData'/> to be added to the <see cref='System.Management.QualifierDataCollection'/>. </param>
		/// <param name='qualifierValue'>The value for the new qualifier. </param>
		public virtual void Add(string qualifierName, object qualifierValue)
		{
			Add(qualifierName, qualifierValue, false, false, false, true);
		}



		/// <summary>
		/// <para>Adds a <see cref='System.Management.QualifierData'/> to the <see cref='System.Management.QualifierDataCollection'/>. This overload 
		///    specifies all property values for a <see cref='System.Management.QualifierData'/> object.</para>
		/// </summary>
		/// <param name='qualifierName'>The qualifier name. </param>
		/// <param name='qualifierValue'>The qualifier value. </param>
		/// <param name='isAmended'><see langword='true'/> to specify that this qualifier is amended (flavor); otherwise, <see langword='false'/>. </param>
		/// <param name='propagatesToInstance'><see langword='true'/> to propagate this qualifier to instances; otherwise, <see langword='false'/>. </param>
		/// <param name='propagatesToSubclass'><see langword='true'/> to propagate this qualifier to subclasses; otherwise, <see langword='false'/>. </param>
		/// <param name='isOverridable'><see langword='true'/> to specify that this qualifier's value is overridable in instances of subclasses; otherwise, <see langword='false'/>. </param>
		public virtual void Add(string qualifierName, object qualifierValue, bool isAmended, bool propagatesToInstance, bool propagatesToSubclass, bool isOverridable)
		{
			
			//Build the flavors bitmask and call the internal Add that takes a bitmask
			int qualFlavor = 0;
			if (isAmended) qualFlavor = (qualFlavor | (int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_AMENDED);
			if (propagatesToInstance) qualFlavor = (qualFlavor | (int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE);
			if (propagatesToSubclass) qualFlavor = (qualFlavor | (int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS);

			// Note we use the NOT condition here since WBEM_FLAVOR_OVERRIDABLE == 0
			if (!isOverridable) qualFlavor = (qualFlavor | (int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_NOT_OVERRIDABLE);

			//Try to add the qualifier to the WMI object
			int status = GetTypeQualifierSet().Put_(qualifierName, ref qualifierValue, qualFlavor);
						
			if (status < 0)
			{
				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else
					Marshal.ThrowExceptionForHR(status);
			}
		}

	}//QualifierDataCollection
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\qualifier.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Runtime.InteropServices;
using WbemClient_v1;

namespace System.Management
{
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para> Contains information about a WMI qualifier.</para>
	/// </summary>
	/// <example>
	///    <code lang='C#'>using System;
	/// using System.Management;
	/// 
	/// // This sample demonstrates how to enumerate qualifiers
	/// // of a ManagementClass object.
	/// class Sample_QualifierData
	/// {
	///     public static int Main(string[] args) {
	///         ManagementClass diskClass = new ManagementClass("Win32_LogicalDisk");
	///         diskClass.Options.UseAmendedQualifiers = true;
	///         QualifierData diskQualifier = diskClass.Qualifiers["Description"];
	///         Console.WriteLine(diskQualifier.Name + " = " + diskQualifier.Value);
	///         return 0;
	///     }
	/// }
	///    </code>
	///    <code lang='VB'>Imports System
	/// Imports System.Management
	/// 
	/// ' This sample demonstrates how to enumerate qualifiers
	/// ' of a ManagementClass object.
	/// Class Sample_QualifierData
	///     Overloads Public Shared Function Main(args() As String) As Integer
	///         Dim diskClass As New ManagementClass("win32_logicaldisk")
	///         diskClass.Options.UseAmendedQualifiers = True
	///         Dim diskQualifier As QualifierData = diskClass.Qualifiers("Description")
	///         Console.WriteLine(diskQualifier.Name + " = " + diskQualifier.Value)
	///         Return 0
	///     End Function
	/// End Class
	///    </code>
	/// </example>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class QualifierData
	{
		private ManagementBaseObject parent;  //need access to IWbemClassObject pointer to be able to refresh qualifiers
		private string propertyOrMethodName; //remains null for object qualifiers
		private string qualifierName;
		private QualifierType qualifierType;
		private Object qualifierValue;
		private int qualifierFlavor;
		private IWbemQualifierSetFreeThreaded qualifierSet;

		internal QualifierData(ManagementBaseObject parent, string propName, string qualName, QualifierType type)		
		{
			this.parent = parent;
			this.propertyOrMethodName = propName;
			this.qualifierName = qualName;
			this.qualifierType = type;
			RefreshQualifierInfo();
		}

		//This private function is used to refresh the information from the Wmi object before returning the requested data
		private void RefreshQualifierInfo()
		{
			int status = (int)ManagementStatus.Failed;

			qualifierSet = null;
			switch (qualifierType) {
				case QualifierType.ObjectQualifier :
					status = parent.wbemObject.GetQualifierSet_(out qualifierSet);
					break;
				case QualifierType.PropertyQualifier :
					status = parent.wbemObject.GetPropertyQualifierSet_(propertyOrMethodName, out qualifierSet);
					break;
				case QualifierType.MethodQualifier :
					status = parent.wbemObject.GetMethodQualifierSet_(propertyOrMethodName, out qualifierSet);
					break;
				default :
					throw new ManagementException(ManagementStatus.Unexpected, null, null); //is this the best fit error ??
			}

			if ((status & 0x80000000) == 0) //success
			{
				qualifierValue = null; //Make sure it's null so that we don't leak !
				if (qualifierSet != null)
					status = qualifierSet.Get_(qualifierName, 0, ref qualifierValue, ref qualifierFlavor);
			}

			if ((status & 0xfffff000) == 0x80041000) //WMI error
				ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
			else if ((status & 0x80000000) != 0) //any failure
				Marshal.ThrowExceptionForHR(status);
		}


		private object MapQualValueToWmiValue(object qualVal)
		{
			object wmiValue = System.DBNull.Value;

			if (null != qualVal)
			{
				if (qualVal is Array)
				{
					if ((qualVal is Int32[]) || (qualVal is Double[]) || (qualVal is String[]) || (qualVal is Boolean[]))
						wmiValue = qualVal;
					else
					{
						Array valArray = (Array)qualVal;
						int length = valArray.Length;
						//If this is an object array, we cannot use GetElementType() to determine the type
						//of the actual content. So we'll use the first element to type the array
						//Type elementType = valArray.GetType().GetElementType();
						Type elementType = (length > 0 ? valArray.GetValue(0).GetType() : null);

						if (elementType == typeof(Int32))
						{
							wmiValue = new Int32 [length];
							for (int i = 0; i < length; i++)
								((Int32[])(wmiValue))[i] = Convert.ToInt32(valArray.GetValue(i));
						}
						else if (elementType == typeof(Double))
						{
							wmiValue = new Double [length];
							for (int i = 0; i < length; i++)
								((Double[])(wmiValue))[i] = Convert.ToDouble(valArray.GetValue(i));
						}
						else if (elementType == typeof(String))
						{
							wmiValue = new String [length];
							for (int i = 0; i < length; i++)
								((String[])(wmiValue))[i] = (valArray.GetValue(i)).ToString();
						}
						else if (elementType == typeof(Boolean))
						{
							wmiValue = new Boolean [length];
							for (int i = 0; i < length; i++)
								((Boolean[])(wmiValue))[i] = Convert.ToBoolean(valArray.GetValue(i));
						}
						else
							wmiValue = valArray; //should this throw ?
					}
				}
				else
					wmiValue = qualVal;
			}

			return wmiValue;
		}


		/// <summary>
		///    <para>Represents the name of the qualifier.</para>
		/// </summary>
		/// <value>
		///    <para>The name of the qualifier.</para>
		/// </value>
		public string Name 
		{
			get { return qualifierName != null ? qualifierName : ""; }
		}

		/// <summary>
		///    <para>Gets or sets the value of the qualifier.</para>
		/// </summary>
		/// <value>
		///    <para>The value of the qualifier.</para>
		/// </value>
		/// <remarks>
		///    <para> Qualifiers can only be of the following subset of CIM 
		///       types: <see langword='string'/>, <see langword='uint16'/>,
		///    <see langword='uint32'/>, <see langword='sint32'/>, <see langword='uint64'/>, 
		///    <see langword='sint64'/>, <see langword='real32'/>, <see langword='real64'/>, 
		///    <see langword='bool'/>.
		///       </para>
		/// </remarks>
		public Object Value 
		{
			get { 
				RefreshQualifierInfo();
				return ValueTypeSafety.GetSafeObject(qualifierValue); 
			}
			set {
				int status = (int)ManagementStatus.NoError;

				RefreshQualifierInfo();
				object newValue = MapQualValueToWmiValue(value);
					
				status = qualifierSet.Put_(qualifierName, ref newValue, 
					qualifierFlavor & ~(int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_MASK_ORIGIN);  

				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else if ((status & 0x80000000) != 0)
					Marshal.ThrowExceptionForHR(status);
			}
		}

		/// <summary>
		///    <para> Gets or sets a value indicating whether the qualifier is amended.</para>
		/// </summary>
		/// <value>
		/// <para><see langword='true'/> if this qualifier is amended; 
		///    otherwise, <see langword='false'/>.</para>
		/// </value>
		/// <remarks>
		///    <para> Amended qualifiers are
		///       qualifiers whose value can be localized through WMI. Localized qualifiers
		///       reside in separate namespaces in WMI and can be merged into the basic class
		///       definition when retrieved.</para>
		/// </remarks>
		public bool IsAmended 
		{
			get { 
				RefreshQualifierInfo(); 
				return ((int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_MASK_AMENDED ==
					(qualifierFlavor & (int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_AMENDED));
			}
			set 
			{
				int status = (int)ManagementStatus.NoError;

				RefreshQualifierInfo ();
				// Mask out origin bits 
				int flavor = qualifierFlavor & ~(int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_MASK_ORIGIN;

				if (value)
					flavor |= (int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_AMENDED;
				else
					flavor &= ~(int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_AMENDED;

				status = qualifierSet.Put_(qualifierName, ref qualifierValue, flavor);

				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else if ((status & 0x80000000) != 0)
					Marshal.ThrowExceptionForHR(status);
			}
		}

		/// <summary>
		///    <para>Gets or sets a value indicating whether the qualifier has been defined locally on 
		///       this class or has been propagated from a base class.</para>
		/// </summary>
		/// <value>
		/// <para><see langword='true'/> if the qualifier has been defined 
		///    locally on this class; otherwise, <see langword='false'/>. </para>
		/// </value>
		public bool IsLocal 
		{
			get {
				RefreshQualifierInfo();
				return ((int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_ORIGIN_LOCAL ==
					(qualifierFlavor & (int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_MASK_ORIGIN));
			}
		}

		/// <summary>
		///    <para>Gets or sets a value indicating whether the qualifier should be propagated to instances of the 
		///       class.</para>
		/// </summary>
		/// <value>
		/// <para><see langword='true'/> if this qualifier should be 
		///    propagated to instances of the class; otherwise, <see langword='false'/>.</para>
		/// </value>
		public bool PropagatesToInstance 
		{
			get {
				RefreshQualifierInfo();
				return ((int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE ==
					(qualifierFlavor & (int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE));
			}
			set {
				int status = (int)ManagementStatus.NoError;

				RefreshQualifierInfo ();
				// Mask out origin bits 
				int flavor = qualifierFlavor & ~(int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_MASK_ORIGIN;

				if (value)
					flavor |= (int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE;
				else
					flavor &= ~(int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE;

				status = qualifierSet.Put_(qualifierName, ref qualifierValue, flavor);

				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else if ((status & 0x80000000) != 0)
					Marshal.ThrowExceptionForHR(status);
			}
		}

		/// <summary>
		///    <para>Gets or sets a value indicating whether the qualifier should be propagated to 
		///       subclasses of the class.</para>
		/// </summary>
		/// <value>
		/// <para><see langword='true'/> if the qualifier should be 
		///    propagated to subclasses of this class; otherwise, <see langword='false'/>.</para>
		/// </value>
		public bool PropagatesToSubclass 
		{
			get {
				RefreshQualifierInfo();
				return ((int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS ==
					(qualifierFlavor & (int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS));
			}
			set {
				int status = (int)ManagementStatus.NoError;

				RefreshQualifierInfo ();
				// Mask out origin bits 
				int flavor = qualifierFlavor & ~(int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_MASK_ORIGIN;

				if (value)
					flavor |= (int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;
				else
					flavor &= ~(int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;

				status = qualifierSet.Put_(qualifierName, ref qualifierValue, flavor);

				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else if ((status & 0x80000000) != 0)
					Marshal.ThrowExceptionForHR(status);
			}
		}

		/// <summary>
		///    <para>Gets or sets a value indicating whether the value of the qualifier can be 
		///       overridden when propagated.</para>
		/// </summary>
		/// <value>
		/// <para><see langword='true'/> if the value of the qualifier 
		///    can be overridden when propagated; otherwise, <see langword='false'/>.</para>
		/// </value>
		public bool IsOverridable 
		{
			get {
				RefreshQualifierInfo();
				return ((int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_OVERRIDABLE == 
					(qualifierFlavor & (int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_MASK_PERMISSIONS));
			}
			set {
				int status = (int)ManagementStatus.NoError;

				RefreshQualifierInfo ();
				// Mask out origin bits 
				int flavor = qualifierFlavor & ~(int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_MASK_ORIGIN;
					
				if (value)
					flavor &= ~(int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_NOT_OVERRIDABLE;
				else
					flavor |= (int)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_NOT_OVERRIDABLE;

				status = qualifierSet.Put_(qualifierName, ref qualifierValue, flavor);

				if ((status & 0xfffff000) == 0x80041000)
					ManagementException.ThrowWithExtendedInfo((ManagementStatus)status);
				else if ((status & 0x80000000) != 0)
					Marshal.ThrowExceptionForHR(status);
			}
		}

	}//QualifierData
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\wmiutil.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Runtime.InteropServices;
using WbemClient_v1;

namespace System.Management
{

	[Guid("2FD73A3B-64B3-480D-AEE9-54469D77123E"),	
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IWmiSec
	{
    	[PreserveSig] 
	    void BlessIWbemServices(
		[MarshalAs(UnmanagedType.Interface)]IWbemServices pIWbemServices,
		[MarshalAs(UnmanagedType.BStr)] string user,
		[MarshalAs(UnmanagedType.BStr)]  string password,
		[MarshalAs(UnmanagedType.BStr)] string authority,
		 int impersonationLevel,
		 int authenticationLevel);

    	[PreserveSig] 
	    void BlessIEnumWbemClassObject(
		[MarshalAs(UnmanagedType.Interface)]IEnumWbemClassObject pIEnumWbemClassObject,
		[MarshalAs(UnmanagedType.BStr)] string user,
		[MarshalAs(UnmanagedType.BStr)]  string password,
		[MarshalAs(UnmanagedType.BStr)] string authority,
		 int impersonationLevel,
		 int authenticationLevel);

    	[PreserveSig] 
	    void BlessIWbemCallResult(
		[MarshalAs(UnmanagedType.Interface)]IWbemCallResult pIWbemCallResult,
		[MarshalAs(UnmanagedType.BStr)] string user,
		[MarshalAs(UnmanagedType.BStr)]  string password,
		[MarshalAs(UnmanagedType.BStr)] string authority,
		 int impersonationLevel,
		 int authenticationLevel);

		[PreserveSig]
		void SetSecurity(
			[In,Out] ref bool needToReset,
			[In,Out] ref IntPtr handle);

		[PreserveSig]
		void ResetSecurity(
			[In] IntPtr handle);
	}

    // This interface is kind of a hack to use IWmiSec with an IUnknown instead
    // of an IWbemServices on the first method.  It relies on the fact that the
    // implementation of BlessIWbemServices just casts the first parameter to
    // IUnknown before setting the proxy blanket.  In VNext, we obviously want
    // to change the implementation of WMINet_Utils.dll to include a method that
    // blesses an IUnknown.  We didn't do this because we didn't discover that
    // we needed to bless an IUnknown until just before RTM.  It was less risky
    // to change just the RCW instead of changing the IDL, .H, .CPP, and the RCW
    // in order to add another method.
    [Guid("2FD73A3B-64B3-480D-AEE9-54469D77123E"),	
    InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IWmiSecAlternateForIUnknown
    {
        [PreserveSig] 
        void BlessIWbemServices(
            [MarshalAs(UnmanagedType.IUnknown)]object pIWbemServices,
            [MarshalAs(UnmanagedType.BStr)] string user,
            [MarshalAs(UnmanagedType.BStr)]  string password,
            [MarshalAs(UnmanagedType.BStr)] string authority,
            int impersonationLevel,
            int authenticationLevel);
    }

    [ComImport, Guid("A8F03BE3-EDB7-4972-821F-AF6F8EA34884")]
	internal class WmiSec
	{
	}

	[Guid("A9A8F102-71CC-4C72-BC16-48E2CC917ADC"),	
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IWmiSinkDemultiplexor
	{
    	[PreserveSig] 
	    void GetDemultiplexedStub(
			[In,MarshalAs(UnmanagedType.IUnknown)]object pIUnknown,
			[Out,MarshalAs(UnmanagedType.IUnknown)]out object ppIUnknown
		);
	}

	[ComImport, Guid("D2EAA715-DAC7-4771-AF5C-931611A1853C")]
	internal class WmiSinkDemultiplexor
	{
	}

	[ComImport, Guid("87A5AD68-A38A-43ef-ACA9-EFE910E5D24C"),
	 InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IWmiEventSource
	{
		[PreserveSig]
		void Indicate(IntPtr pIWbemClassObject);

		[PreserveSig]
		void SetStatus(
			int lFlags,
			int hResult,
			[MarshalAs(UnmanagedType.BStr)] string strParam ,
			IntPtr pObjParam
		);
	}

#if USEIWOS
	// The following is a manually defined wrapper for IWbemObjectSink
	// since the size_is attribute cannot be dealt with by TlbImp.
	[Guid("7c857801-7381-11cf-884d-00aa004b2e24"),
	 InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	public interface IWbemObjectSink
	{
		[PreserveSig]
	    void Indicate(
	        long lObjectCount,
			[MarshalAs(UnmanagedType.Interface, SizeParamIndex=0)] IWbemClassObject [] apObjArray
	        );

		[PreserveSig]
	    void SetStatus(
	        long lFlags,
	        int hResult,
	        [MarshalAs(UnmanagedType.BStr)] string strParam,
	        [MarshalAs(UnmanagedType.Interface)] IWbemClassObject pObjParam
	        );

	};
#endif

	//Class for calling GetErrorInfo from managed code
	class WbemErrorInfo
	{
		public static IWbemClassObjectFreeThreaded GetErrorInfo()
		{
            IErrorInfo errorInfo = GetErrorInfo(0);
            if(null != errorInfo)
            {
                IntPtr pUnk = Marshal.GetIUnknownForObject(errorInfo);
                IntPtr pIWbemClassObject;
                Marshal.QueryInterface(pUnk, ref IWbemClassObjectFreeThreaded.IID_IWbemClassObject, out pIWbemClassObject);
                Marshal.Release(pUnk);

                // The IWbemClassObjectFreeThreaded instance will own reference count on pIWbemClassObject
                if(pIWbemClassObject != IntPtr.Zero)
                    return new IWbemClassObjectFreeThreaded(pIWbemClassObject);
            }
            return null;
		}
 
		[DllImport("oleaut32.dll", PreserveSig=false)]
		static extern IErrorInfo GetErrorInfo(int reserved);
	}

	//RCW for IErrorInfo
	[ComImport]
	[Guid("1CF2B120-547D-101B-8E65-08002B2BD119")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
		internal interface IErrorInfo 
	{
		Guid GetGUID();

 		[return:MarshalAs(UnmanagedType.BStr)]
		string GetSource();

		[return:MarshalAs(UnmanagedType.BStr)]
		string GetDescription();

		[return:MarshalAs(UnmanagedType.BStr)]
		string GetHelpFile();

		uint GetHelpContext();
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\managementquery.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Collections.Specialized;
using WbemUtilities_v1;
using WbemClient_v1;
using System.Globalization;
using System.Reflection;
using System.ComponentModel.Design.Serialization;
using System.ComponentModel;
using System.ComponentModel.Design;



namespace System.Management
{
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para> Provides an abstract base class for all management query objects.</para>
	/// </summary>
	/// <remarks>
	///    <para> This class is abstract; only
	///       derivatives of it are actually used in the API.</para>
	/// </remarks>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	[TypeConverter(typeof(ManagementQueryConverter ))]
	public abstract class ManagementQuery : ICloneable
	{
		internal const string DEFAULTQUERYLANGUAGE = "WQL";
		internal static readonly string tokenSelect = "select ";	// Keep trailing space char.

		//Used when any public property on this object is changed, to signal
		//to the containing object that it needs to be refreshed.
		internal event IdentifierChangedEventHandler IdentifierChanged;

		//Fires IdentifierChanged event
		internal void FireIdentifierChanged()
		{
			if (IdentifierChanged != null)
				IdentifierChanged(this, null);
		}

		private string queryLanguage;
		private string queryString;

		internal void SetQueryString (string qString)
		{
			queryString = qString;
		}

		//default constructor
		internal ManagementQuery() : this(DEFAULTQUERYLANGUAGE, null) {}

		//parameterized constructors
		internal ManagementQuery(string query) : this(DEFAULTQUERYLANGUAGE, query) {}
		internal ManagementQuery(string language, string query)
		{
			QueryLanguage = language;
			QueryString = query;
		}

		/// <summary>
		///  Parses the query string and sets the property values accordingly.
		/// </summary>
		/// <param name="query">The query string to be parsed.</param>
		protected internal virtual void ParseQuery (string query) {}

		//
		//properties
		//
		/// <summary>
		///    <para>Gets or sets the query in text format.</para>
		/// </summary>
		/// <value>
		///    <para> If the query object is
		///       constructed with no parameters, the property is null until specifically set. If the
		///       object was constructed with a specified query, the property returns the specified
		///       query string.</para>
		/// </value>
		public virtual string QueryString
		{
			get {return (null != queryString) ? queryString : String.Empty;}
			set {
				if (queryString != value) {
					ParseQuery (value);	// this may throw
					queryString = value;
					FireIdentifierChanged ();
				}
			}
		}

		/// <summary>
		///    <para> Gets or sets the query language used in the query
		///       string, defining the format of the query string.</para>
		/// </summary>
		/// <value>
		///    <para>Can be set to any supported query
		///       language. "WQL" is the only value supported intrinsically by WMI.</para>
		/// </value>
		public virtual String QueryLanguage
		{
			get {return (null != queryLanguage) ? queryLanguage : String.Empty;}
			set {
				if (queryLanguage != value) {
					queryLanguage = value;
					FireIdentifierChanged ();
				}
			}
		}

		//ICloneable
		/// <summary>
		///    <para>Returns a copy of the object.</para>
		/// </summary>
		/// <returns>
		///    The cloned object.
		/// </returns>
		public abstract object Clone();

		internal void ParseToken (ref string q, string token, string op, ref bool bTokenFound, ref string tokenValue)
		{
			if (bTokenFound)
				throw new ArgumentException ();	// Invalid query - duplicate token

			bTokenFound = true;
			q = q.Remove (0, token.Length).TrimStart (null);

			// Next character should be the operator if any
			if (op != null)
			{
				if (0 != q.IndexOf(op))
					throw new ArgumentException();	// Invalid query

				// Strip off the op and any leading WS
				q = q.Remove(0, op.Length).TrimStart(null);
			}

			if (0 == q.Length)
				throw new ArgumentException ();		// Invalid query - token has no value
			
			// Next token should be the token value - look for terminating WS 
			// or end of string
			int i;
			if (-1 == (i = q.IndexOf (' ')))
				i = q.Length;			// No WS => consume entire string
				
			tokenValue = q.Substring (0, i);
			q = q.Remove (0, tokenValue.Length).TrimStart(null);
		}

		internal void ParseToken (ref string q, string token, ref bool bTokenFound)
		{
			if (bTokenFound)
				throw new ArgumentException ();	// Invalid query - duplicate token

			bTokenFound = true;
			q = q.Remove (0, token.Length).TrimStart (null);
		}
	
	}//ManagementQuery


	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para> Represents a management query that returns instances or classes.</para>
	/// </summary>
	/// <remarks>
	///    <para>This class or its derivatives are used to specify a 
	///       query in the <see cref='System.Management.ManagementObjectSearcher'/>. Use
	///       a more specific query class whenever possible.</para>
	/// </remarks>
	/// <example>
	///    <code lang='C#'>using System;
	/// using System.Management;
	/// 
	/// // This sample demonstrates creating a query.
	/// 
	/// class Sample_ObjectQuery
	/// {
	///     public static int Main(string[] args)
	///     {
	///         ObjectQuery objectQuery = new ObjectQuery("select * from Win32_Share");
	///         ManagementObjectSearcher searcher =
	///             new ManagementObjectSearcher(objectQuery);
	///         foreach (ManagementObject share in searcher.Get())
	///         {
	///             Console.WriteLine("Share = " + share["Name"]);
	///         }
	///         return 0;
	///     }
	/// }
	///    </code>
	///    <code lang='VB'>Imports System
	/// Imports System.Management
	/// 
	/// ' This sample demonstrates creating a query.
	/// 
	/// Class Sample_ObjectQuery
	///     Overloads Public Shared Function Main(args() As String) As Integer
	///         Dim objectQuery As New ObjectQuery("select * from Win32_Share")
	///         Dim searcher As New ManagementObjectSearcher(objectQuery)
	///         Dim share As ManagementObject
	///         For Each share In searcher.Get()
	///             Console.WriteLine("Share = " &amp; share("Name"))
	///         Next share
	///         Return 0
	///     End Function
	/// End Class
	///    </code>
	/// </example>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class ObjectQuery : ManagementQuery
	{
		/// <overload>
		/// <para>Initializes a new instance of the <see cref='System.Management.ObjectQuery'/> 
		/// class.</para>
		/// </overload>
		/// <summary>
		/// <para> Initializes a new instance of the <see cref='System.Management.ObjectQuery'/> 
		/// class with no initialized values. This
		/// is the default constructor.</para>
		/// </summary>
		public ObjectQuery() : base() {}
		/// <summary>
		/// <para> Initializes a new instance of the <see cref='System.Management.ObjectQuery'/> 
		/// class
		/// for a specific query string.</para>
		/// </summary>
		/// <param name='query'>The string representation of the query.</param>
		public ObjectQuery(string query) : base(query) {}
		/// <summary>
		/// <para> Initializes a new instance of the <see cref='System.Management.ObjectQuery'/> 
		/// class for a specific
		/// query string and language.</para>
		/// </summary>
		/// <param name='language'>The query language in which this query is specified.</param>
		/// <param name=' query'>The string representation of the query.</param>
		public ObjectQuery(string language, string query) : base(language, query) {}

		//ICloneable
		/// <summary>
		///    <para>Returns a copy of the object.</para>
		/// </summary>
		/// <returns>
		///    The cloned object.
		/// </returns>
		public override object Clone ()
		{
			return new ObjectQuery(QueryLanguage, QueryString);
		}
		
	}//ObjectQuery


	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para> Represents a WMI event query.</para>
	/// </summary>
	/// <remarks>
	///    <para> Objects of this class or its derivatives are used in 
	///    <see cref='System.Management.ManagementEventWatcher'/> to subscribe to
	///       WMI events. Use more specific derivatives of this class whenever possible.</para>
	/// </remarks>
	/// <example>
	///    <code lang='C#'>using System;
	/// using System.Management;
	/// 
	/// // This sample demonstrates how to subscribe to an event
	/// // using the EventQuery object.
	/// 
	/// class Sample_EventQuery
	/// {
	///     public static int Main(string[] args)
	///     {
	///         //For this example, we make sure we have an arbitrary class on root\default
	///         ManagementClass newClass = new ManagementClass(
	///             "root\\default",
	///             String.Empty,
	///             null);
	///         newClass["__Class"] = "TestWql";
	///         newClass.Put();
	/// 
	///         //Create a query object for watching for class deletion events
	///         EventQuery eventQuery = new EventQuery("select * from __classdeletionevent");
	/// 
	///         //Initialize an event watcher object with this query
	///         ManagementEventWatcher watcher = new ManagementEventWatcher(
	///             new ManagementScope("root/default"),
	///             eventQuery);
	/// 
	///         //Set up a handler for incoming events
	///         MyHandler handler = new MyHandler();
	///         watcher.EventArrived += new EventArrivedEventHandler(handler.Arrived);
	/// 
	///         //Start watching for events
	///         watcher.Start();
	/// 
	///         //For this example, we delete the class to trigger an event
	///         newClass.Delete();
	/// 
	///         //Nothing better to do - we loop to wait for an event to arrive.
	///         while (!handler.IsArrived) {
	///              System.Threading.Thread.Sleep(1000);
	///         }
	/// 
	///         //In this example we only want to wait for one event, so we can stop watching
	///         watcher.Stop();
	/// 
	///         //Get some values from the event.
	///         //Note: this can also be done in the event handler.
	///         ManagementBaseObject eventArg =
	///             (ManagementBaseObject)(handler.ReturnedArgs.NewEvent["TargetClass"]);
	///         Console.WriteLine("Class Deleted = " + eventArg["__CLASS"]);
	/// 
	///         return 0;
	///     }
	/// 
	///     public class MyHandler
	///     {
	///         private bool isArrived = false;
	///         private EventArrivedEventArgs args;
	/// 
	///         //Handles the event when it arrives
	///         public void Arrived(object sender, EventArrivedEventArgs e) {
	///             args = e;
	///             isArrived = true;
	///         }
	///  
	///         //Public property to get at the event information stored in the handler
	///         public EventArrivedEventArgs ReturnedArgs {
	///             get {
	///                 return args;
	///             }
	///         }
	/// 
	///         //Used to determine whether the event has arrived or not.
	///         public bool IsArrived {
	///             get {
	///                 return isArrived;
	///             }
	///         }
	///     }
	/// }
	///    </code>
	///    <code lang='VB'>Imports System
	/// Imports System.Management
	/// 
	/// ' This sample demonstrates how to subscribe an event
	/// ' using the EventQuery object.
	/// 
	/// Class Sample_EventQuery
	///     Public Shared Sub Main()
	/// 
	///         'For this example, we make sure we have an arbitrary class on root\default
	///         Dim newClass As New ManagementClass( _
	///             "root\default", _
	///             String.Empty, Nothing)
	///             newClass("__Class") = "TestWql"
	///             newClass.Put()
	/// 
	///         'Create a query object for watching for class deletion events
	///         Dim eventQuery As New EventQuery("select * from __classdeletionevent")
	/// 
	///         'Initialize an event watcher object with this query
	///         Dim watcher As New ManagementEventWatcher( _
	///             New ManagementScope("root/default"), _
	///             eventQuery)
	/// 
	///         'Set up a handler for incoming events
	///         Dim handler As New MyHandler()
	///         AddHandler watcher.EventArrived, AddressOf handler.Arrived
	///    
	///         'Start watching for events
	///         watcher.Start()
	/// 
	///         'For this example, we delete the class to trigger an event
	///         newClass.Delete()
	/// 
	///         'Nothing better to do - we loop to wait for an event to arrive.
	///         While Not handler.IsArrived
	///             Console.Write("0")
	///             System.Threading.Thread.Sleep(1000)
	///         End While
	/// 
	///         'In this example we only want to wait for one event, so we can stop watching
	///         watcher.Stop()
	/// 
	///         'Get some values from the event
	///         'Note: this can also be done in the event handler.
	///         Dim eventArg As ManagementBaseObject = CType( _
	///             handler.ReturnedArgs.NewEvent("TargetClass"), _
	///             ManagementBaseObject)
	///         Console.WriteLine(("Class Deleted = " + eventArg("__CLASS")))
	/// 
	///     End Sub
	/// 
	///     Public Class MyHandler
	///         Private _isArrived As Boolean = False
	///         Private args As EventArrivedEventArgs
	/// 
	///         'Handles the event when it arrives
	///         Public Sub Arrived(sender As Object, e As EventArrivedEventArgs)
	///             args = e
	///             _isArrived = True
	///         End Sub
	/// 
	///         'Public property to get at the event information stored in the handler         
	///         Public ReadOnly Property ReturnedArgs() As EventArrivedEventArgs
	///             Get
	///                 Return args
	///             End Get
	///         End Property
	/// 
	///         'Used to determine whether the event has arrived or not.
	///         Public ReadOnly Property IsArrived() As Boolean
	///             Get
	///                 Return _isArrived
	///             End Get
	///         End Property
	///     End Class
	/// End Class
	///    </code>
	/// </example>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class EventQuery : ManagementQuery
	{
		/// <overload>
		/// <para>Initializes a new instance of the <see cref='System.Management.EventQuery'/> 
		/// class.</para>
		/// </overload>
		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.EventQuery'/> 
		/// class. This is the
		/// default constructor.</para>
		/// </summary>
		public EventQuery() : base() {}
		/// <summary>
		/// <para> Initializes a new instance of the <see cref='System.Management.EventQuery'/> 
		/// class for the specified query.</para>
		/// </summary>
		/// <param name='query'>A textual representation of the event query.</param>
		public EventQuery(string query) : base(query) {}
		/// <summary>
		/// <para> Initializes a new instance of the <see cref='System.Management.EventQuery'/> 
		/// class for the specified
		/// language and query.</para>
		/// </summary>
		/// <param name='language'>The language in which the query string is specified. </param>
		/// <param name=' query'>The string representation of the query.</param>
		public EventQuery(string language, string query) : base(language, query) {}

		//ICloneable
		/// <summary>
		///    <para>Returns a copy of the object.</para>
		/// </summary>
		/// <returns>
		///    The cloned object.
		/// </returns>
		public override object Clone()
		{
			return new EventQuery(QueryLanguage, QueryString);
		}
	}//EventQuery


	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para> Represents a WMI data query in WQL format.</para>
	/// </summary>
	/// <example>
	///    <code lang='C#'>using System; 
	/// using System.Management; 
	/// 
	/// // This sample demonstrates how to use a WqlObjectQuery class to 
	/// // perform an object query. 
	/// 
	/// class Sample_WqlObjectQuery 
	/// { 
	///     public static int Main(string[] args) {
	///         WqlObjectQuery objectQuery = new WqlObjectQuery("select * from Win32_Share");
	///         ManagementObjectSearcher searcher =
	///             new ManagementObjectSearcher(objectQuery);
	/// 
	///         foreach (ManagementObject share in searcher.Get()) { 
	///             Console.WriteLine("Share = " + share["Name"]);
	///         }
	/// 
	///         return 0;
	///     }
	/// }
	///    </code>
	///    <code lang='VB'>Imports System
	/// Imports System.Management
	/// 
	/// ' This sample demonstrate how to use a WqlObjectQuery class to
	/// ' perform an object query.
	/// 
	/// Class Sample_WqlObjectQuery
	///     Overloads Public Shared Function Main(args() As String) As Integer
	///         Dim objectQuery As New WqlObjectQuery("select * from Win32_Share")
	///         Dim searcher As New ManagementObjectSearcher(objectQuery)
	///         
	///         Dim share As ManagementObject
	///         For Each share In searcher.Get()
	///             Console.WriteLine("Share = " &amp; share("Name"))
	///         Next share
	/// 
	///         Return 0
	///     End Function
	/// End Class
	///    </code>
	/// </example>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class WqlObjectQuery : ObjectQuery
	{
		//constructors
		//Here we don't take a language argument but hard-code it to WQL in the base class
		/// <overload>
		/// <para>Initializes a new instance of the <see cref='System.Management.WqlObjectQuery'/> class.</para>
		/// </overload>
		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.WqlObjectQuery'/> class. This is the
		///    default constructor.</para>
		/// </summary>
		public WqlObjectQuery() : base(null) {}
	
		/// <summary>
		/// <para> Initializes a new instance of the <see cref='System.Management.WqlObjectQuery'/> class initialized to the
		///    specified query.</para>
		/// </summary>
		/// <param name='query'><para> The representation of the data query.</para></param>
		public WqlObjectQuery(string query) : base(query) {}

		//QueryLanguage property is read-only in this class (does this work ??)
		/// <summary>
		///    <para>Gets or sets the language of the query.</para>
		/// </summary>
		/// <value>
		///    <para> The value of this
		///       property is always "WQL".</para>
		/// </value>
		public override string QueryLanguage
		{
			get 
			{return base.QueryLanguage;}
		}

		//ICloneable
		/// <summary>
		///    <para>Creates a copy of the object.</para>
		/// </summary>
		/// <returns>
		///    The copied object.
		/// </returns>
		public override object Clone()
		{
			return new WqlObjectQuery(QueryString);
		}


	}//WqlObjectQuery



	
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para> Represents a WQL SELECT data query.</para>
	/// </summary>
	/// <example>
	///    <code lang='C#'>using System;
	/// using System.Management;
	/// 
	/// // This sample demonstrates how to perform a WQL select query.
	/// 
	/// class Sample_SelectQuery
	/// {
	///     public static int Main(string[] args) {
	///         SelectQuery selectQuery = new SelectQuery("win32_logicaldisk");
	///         ManagementObjectSearcher searcher =
	///             new ManagementObjectSearcher(selectQuery);
	/// 
	///         foreach (ManagementObject disk in searcher.Get()) {
	///             Console.WriteLine(disk.ToString());
	///         }
	///         return 0;
	///     }
	/// }
	///    </code>
	///    <code lang='VB'>Imports System
	/// Imports System.Management
	/// 
	/// ' This sample demonstrates how to perform a WQL select query.
	/// 
	/// Class Sample_SelectQuery
	///     Overloads Public Shared Function Main(args() As String) As Integer
	///         Dim selectQuery As New SelectQuery("win32_logicaldisk")
	///         Dim searcher As New ManagementObjectSearcher(selectQuery)
	///    
	///         Dim disk As ManagementObject
	///         For Each disk In  searcher.Get()
	///             Console.WriteLine(disk.ToString())
	///         Next disk
	///         
	///         Return 0
	///     End Function
	/// End Class
	///    </code>
	/// </example>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class SelectQuery : WqlObjectQuery
	{
		private bool isSchemaQuery = false;
		private string className;
		private string condition;
		private StringCollection selectedProperties;

		//default constructor
		/// <overload>
		/// <para>Initializes a new instance of the <see cref='System.Management.SelectQuery'/> 
		/// class.</para>
		/// </overload>
		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.SelectQuery'/> 
		/// class. This is the
		/// default constructor.</para>
		/// </summary>
		public SelectQuery() :this(null) {}
		
		//parameterized constructors
		//ISSUE : We have 2 possible constructors that take a single string :
		//  one that takes the full query string and the other that takes the class name.
		//  We resolve this by trying to parse the string, if it succeeds we assume it's the query, if
		//  not we assume it's the class name.
		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.SelectQuery'/> class for the specified
		///    query or the specified class name.</para>
		/// </summary>
		/// <param name='queryOrClassName'>The entire query or the class name to use in the query. The parser in this class attempts to parse the string as a valid WQL SELECT query. If the parser is unsuccessful, it assumes the string is a class name.</param>
		/// <example>
		///    <code lang='C#'>SelectQuery s = new SelectQuery("SELECT * FROM Win32_Service WHERE State='Stopped'); 
		/// 
		/// or 
		/// 
		/// //This is equivalent to "SELECT * FROM Win32_Service"
		/// SelectQuery s = new SelectQuery("Win32_Service");
		///    </code>
		///    <code lang='VB'>Dim s As New SelectQuery("SELECT * FROM Win32_Service WHERE State='Stopped')
		/// 
		/// or
		/// 
		/// //This is equivalent to "SELECT * FROM Win32_Service"
		/// Dim s As New SelectQuery("Win32_Service")
		///    </code>
		/// </example>
		public SelectQuery(string queryOrClassName)
		{
			selectedProperties = new StringCollection ();

			if (null != queryOrClassName)
			{
				// Minimally determine if the string is a query or class name.
				//
				if (queryOrClassName.TrimStart().ToLower(CultureInfo.InvariantCulture).StartsWith(tokenSelect))
				{
					// Looks to be a query - do further checking.
					//
					QueryString = queryOrClassName;		// Parse/validate; may throw.
				}
				else
				{
					// Do some basic sanity checking on whether it's a class name
					//
					try
					{
						ManagementPath p = new ManagementPath (queryOrClassName);

						if (p.IsClass && (String.Empty == p.NamespacePath))
							ClassName = queryOrClassName;
						else
							throw new ArgumentException ();
					}
					catch (Exception)
					{
						throw new ArgumentException ();
					}
				}
			}
		}

		/// <summary>
		/// <para> Initializes a new instance of the <see cref='System.Management.SelectQuery'/> 
		/// class with the specified
		/// class name and condition.</para>
		/// </summary>
		/// <param name='className'>The name of the class to select in the query.</param>
		/// <param name=' condition'>The condition to be applied in the query.</param>
		/// <example>
		///    <code lang='C#'>SelectQuery s = new SelectQuery("Win32_Process", "HandleID=1234");
		///    </code>
		///    <code lang='VB'>Dim s As New SelectQuery("Win32_Process", "HandleID=1234")
		///    </code>
		/// </example>
		public SelectQuery(string className, string condition) : this(className, condition, null) {}

		/// <summary>
		/// <para> Initializes a new instance of the <see cref='System.Management.SelectQuery'/> 
		/// class with the specified
		/// class name and condition, selecting only the specified properties.</para>
		/// </summary>
		/// <param name='className'>The name of the class from which to select.</param>
		/// <param name=' condition'>The condition to be applied to instances of the selected class.</param>
		/// <param name=' selectedProperties'>An array of property names to be returned in the query results.</param>
		/// <example>
		///    <code lang='C#'>String[] properties = {"VariableName", "VariableValue"};
		/// 
		/// SelectQuery s = new SelectQuery("Win32_Environment",
		///                                 "User='&lt;system&gt;'", 
		///                                 properties);
		///    </code>
		///    <code lang='VB'>Dim properties As String[] = {"VariableName", "VariableValue"}
		/// 
		/// Dim s As New SelectQuery("Win32_Environment", _
		///                          "User=""&lt;system&gt;""", _
		///                          properties)
		///    </code>
		/// </example>
		public SelectQuery(string className, string condition, string[] selectedProperties) : base ()
		{
			this.isSchemaQuery = false;
			this.className = className;
			this.condition = condition;
			this.selectedProperties = new StringCollection ();

			if (null != selectedProperties)
				this.selectedProperties.AddRange (selectedProperties);

			BuildQuery();
		}

		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.SelectQuery'/> 
		/// class for a schema query, optionally specifying a condition. For schema queries,
		/// only the <paramref name="condition"/> parameter is valid: <paramref name="className"/>
		/// and <paramref name="selectedProperties"/>
		/// are not supported and are ignored.</para>
		/// </summary>
		/// <param name='isSchemaQuery'><see langword='true'/>to indicate that this is a schema query; otherwise, <see langword='false'/>. A <see langword='false'/> value is invalid in this constructor.</param>
		/// <param name=' condition'>The condition to be applied to form the result set of classes.</param>
		/// <example>
		///    <code lang='C#'>SelectQuery s = new SelectQuery(true, "__CLASS = 'Win32_Service'");
		///    </code>
		///    <code lang='VB'>Dim s As New SelectQuery(true, "__CLASS = ""Win32_Service""")
		///    </code>
		/// </example>
		public SelectQuery(bool isSchemaQuery, string condition) : base ()
		{
			if (isSchemaQuery == false)
				throw new ArgumentException(null, "isSchemaQuery");
			
			this.isSchemaQuery = true;
			this.className = null;
			this.condition = condition;
			this.selectedProperties = null;

			BuildQuery();
		}
		
		
		/// <summary>
		/// <para>Gets or sets the query in the <see cref='System.Management.SelectQuery'/>, in string form.</para>
		/// </summary>
		/// <value>
		///    <para>A string representing the query.</para>
		/// </value>
		/// <remarks>
		///    <para> Setting this
		///       property value overrides any previous value stored in the object. In addition, setting this
		///       property causes the other members of the object to be updated when the string
		///       is reparsed.</para>
		/// </remarks>
		/// <example>
		///    <code lang='C#'>SelectQuery s = new SelectQuery(); 
		/// s.QueryString = "SELECT * FROM Win32_LogicalDisk";
		///    </code>
		///    <code lang='VB'>Dim s As New SelectQuery()
		/// s.QueryString = "SELECT * FROM Win32_LogicalDisk"
		///    </code>
		/// </example>
		public override string QueryString
		{
			get {
				// We need to force a rebuild as we may not have detected
				// a change to selected properties
				BuildQuery ();
				return base.QueryString;}
			set {
				base.QueryString = value;
			}
		}

		/// <summary>
		///    <para>Gets or sets a value indicating whether this query is a schema query or an instances query.</para>
		/// </summary>
		/// <value>
		/// <para><see langword='true'/> if this query 
		///    should be evaluated over the schema; <see langword='false'/> if the query should
		///    be evaluated over instances.</para>
		/// </value>
		/// <remarks>
		///    <para>Setting this property value overrides any
		///       previous value stored in the object. The query string is
		///       rebuilt to reflect the new query type.</para>
		/// </remarks>
		public bool IsSchemaQuery
		{
			get 
			{ return isSchemaQuery; }
			set 
			{ isSchemaQuery = value; BuildQuery(); FireIdentifierChanged(); }
		}


		/// <summary>
		///    <para>Gets or sets the class name to be selected from in the query.</para>
		/// </summary>
		/// <value>
		///    <para>A string representing the name of the
		///       class.</para>
		/// </value>
		/// <remarks>
		///    <para> Setting this property value
		///       overrides any previous value stored in the object. The query string is
		///       rebuilt to reflect the new class name.</para>
		/// </remarks>
		/// <example>
		///    <code lang='C#'>SelectQuery s = new SelectQuery("SELECT * FROM Win32_LogicalDisk");
		/// Console.WriteLine(s.QueryString); //output is : SELECT * FROM Win32_LogicalDisk
		/// 
		/// s.ClassName = "Win32_Process";
		/// Console.WriteLine(s.QueryString); //output is : SELECT * FROM Win32_Process
		///    </code>
		///    <code lang='VB'>Dim s As New SelectQuery("SELECT * FROM Win32_LogicalDisk")
		/// Console.WriteLine(s.QueryString)  'output is : SELECT * FROM Win32_LogicalDisk
		/// 
		/// s.ClassName = "Win32_Process"
		/// Console.WriteLine(s.QueryString)  'output is : SELECT * FROM Win32_Process
		///    </code>
		/// </example>
		public string ClassName
		{
			get { return (null != className) ? className : String.Empty; }
			set { className = value; BuildQuery(); FireIdentifierChanged(); }
		}

		/// <summary>
		///    <para>Gets or sets the condition to be applied in the SELECT
		///       query.</para>
		/// </summary>
		/// <value>
		///    A string containing the condition to
		///    be applied in the SELECT query.
		/// </value>
		/// <remarks>
		///    <para> Setting this property value overrides any previous value 
		///       stored in the object. The query string is rebuilt to reflect the new
		///       condition.</para>
		/// </remarks>
		public string Condition
		{
			get { return (null != condition) ? condition : String.Empty; }
			set { condition = value; BuildQuery(); FireIdentifierChanged(); }
		}

		/// <summary>
		///    <para> Gets or sets an array of property names to be
		///       selected in the query.</para>
		/// </summary>
		/// <value>
		/// <para>A <see cref='System.Collections.Specialized.StringCollection'/> containing the names of the 
		///    properties to be selected in the query.</para>
		/// </value>
		/// <remarks>
		///    <para> Setting this property value overrides any previous value stored 
		///       in the object. The query string is rebuilt to reflect the new
		///       properties.</para>
		/// </remarks>
		public StringCollection SelectedProperties
		{
			get { return selectedProperties; }
			set { 
				if (null != value)
				{
					// A tad painful since StringCollection doesn't support ICloneable
					StringCollection src = (StringCollection)value;
					StringCollection dst = new StringCollection ();

					foreach (String s in src)
						dst.Add (s);
						
					selectedProperties = dst; 
				}
				else
					selectedProperties = new StringCollection ();

				BuildQuery(); 
				FireIdentifierChanged(); 
			}
		}

		/// <summary>
		///  Builds the query string according to the current property values.
		/// </summary>
		protected internal void BuildQuery()
		{
			string s;

			if (isSchemaQuery == false) //this is an instances query
			{
				//If the class name is not set we can't build a query
				//Shouldn't throw here because the user may be in the process of filling in the properties...
				if (className == null)
					SetQueryString (String.Empty);

				if ((className == null) || (className == String.Empty))
					return;

				//Select clause
				s = tokenSelect;

				//If properties are specified list them
				if ((null != selectedProperties) && (0 < selectedProperties.Count))
				{
					int count = selectedProperties.Count;

					for (int i = 0; i < count; i++)
						s = s + selectedProperties[i] + ((i == (count - 1)) ? " " : ",");
				}
				else
					s = s + "* ";

				//From clause
				s = s + "from " + className;

			}
			else //this is a schema query, ignore className or selectedProperties.
			{
				//Select clause
				s = "select * from meta_class";
			}

			//Where clause
			if ((!Condition.Equals(String.Empty)) && (Condition != null))
				s = s + " where " + condition;

			//Set the queryString member to the built query (NB: note we set
			//by accessing the internal helper function rather than the property,
			//since we do not want to force a parse of a query we just built).
			SetQueryString (s);
		}


		/// <summary>
		///  Parses the query string and sets the property values accordingly.
		/// </summary>
		/// <param name="query">The query string to be parsed.</param>
		protected internal override void ParseQuery(string query)
		{
			//Clear out previous property values
			className = null;
			condition = null;
			if (selectedProperties != null)
				selectedProperties.Clear();

			//Trim whitespaces
			string q = query.Trim();
			bool bFound = false; string tempProp; int i;

			if (isSchemaQuery == false) //instances query
			{
				//Find "select" clause and get the property list if exists
				string keyword = tokenSelect;
				if ((q.Length >= keyword.Length) && (String.Compare(q, 0, keyword, 0, keyword.Length, true,CultureInfo.InvariantCulture) == 0)) //select clause found
				{
					ParseToken (ref q, keyword, ref bFound);
					if (q[0] != '*') //we have properties
					{
						if (null != selectedProperties)
							selectedProperties.Clear ();
						else 
							selectedProperties = new StringCollection ();

						//get the property list
						while (true)
						{
							if ((i = q.IndexOf(',')) > 0)
							{
								tempProp = q.Substring(0, i);
								q = q.Remove(0, i+1).TrimStart(null);
								tempProp = tempProp.Trim();
								if (tempProp != String.Empty)
									selectedProperties.Add(tempProp);
							}
							else
							{ //last property in the list
								if ((i = q.IndexOf(' ')) > 0)
								{
									tempProp = q.Substring(0, i);
									q = q.Remove(0, i).TrimStart(null);
									selectedProperties.Add(tempProp);
									break;
								}
								else //bad query
									throw new ArgumentException();
							}
						} //while
					}
					else
						q = q.Remove(0, 1).TrimStart(null);
				}
				else //select clause has to be there, otherwise the parsing fails
					throw new ArgumentException();

				//Find "from" clause, get the class name and remove the clause
				keyword = "from "; bFound = false;
				if ((q.Length >= keyword.Length) && (String.Compare(q, 0, keyword, 0, keyword.Length, true,CultureInfo.InvariantCulture) == 0)) //from clause found
					ParseToken(ref q, keyword, null, ref bFound, ref className);
				else //from clause has to be there, otherwise the parsing fails
					throw new ArgumentException(); 

				//Find "where" clause, get the condition out and remove the clause
				keyword = "where ";
				if ((q.Length >= keyword.Length) && (String.Compare(q, 0, keyword, 0, keyword.Length, true,CultureInfo.InvariantCulture) == 0)) //where clause exists
				{
					condition = q.Substring(keyword.Length).Trim();
				}
			} //if isSchemaQuery == false
			else //this is a schema query
			{
				//Find "select" clause and make sure it's the right syntax
				string keyword = "select"; 

				// Should start with "select"
				if ((q.Length < keyword.Length) || 
					(0 != String.Compare (q, 0, keyword, 0, keyword.Length, true,CultureInfo.InvariantCulture)))
					throw new ArgumentException ();

				q = q.Remove (0, keyword.Length).TrimStart (null);

				// Next should be a '*'
				if (0 != q.IndexOf ('*', 0))
					throw new ArgumentException ();

				q = q.Remove (0, 1).TrimStart (null);

				// Next should be "from"
				keyword = "from";

				if ((q.Length < keyword.Length) || 
					(0 != String.Compare (q, 0, keyword, 0, keyword.Length, true,CultureInfo.InvariantCulture)))
					throw new ArgumentException ();

				q = q.Remove (0, keyword.Length).TrimStart (null);

				// Next should be "meta_class"
				keyword = "meta_class";

				if ((q.Length < keyword.Length) || 
					(0 != String.Compare (q, 0, keyword, 0, keyword.Length, true,CultureInfo.InvariantCulture)))
					throw new ArgumentException ();

				q = q.Remove (0, keyword.Length).TrimStart (null);

				// There may be a where clause
				if (0 < q.Length)
				{
					//Find "where" clause, and get the condition out
					keyword = "where"; 
				
					if ((q.Length < keyword.Length) || 
						(0 != String.Compare (q, 0, keyword, 0, keyword.Length, true,CultureInfo.InvariantCulture)))
						throw new ArgumentException ();

					q = q.Remove (0, keyword.Length);

					// Must be some white space next
					if ((0 == q.Length) || !Char.IsWhiteSpace (q[0]))
						throw new ArgumentException();	// Invalid query
				
					q = q.TrimStart(null);	// Remove the leading whitespace

					condition = q;
				}
				else
					condition = String.Empty;

				//Empty not-applicable properties
				className = null;
				selectedProperties = null;
			}//schema query
		}

		/// <summary>
		///    <para> Creates a copy of the object.</para>
		/// </summary>
		/// <returns>
		///    The copied object.
		/// </returns>
		public override Object Clone ()
		{
			string[] strArray = null;

			if (null != selectedProperties)
			{
				int count = selectedProperties.Count;

				if (0 < count)
				{
					strArray = new String [count];
					selectedProperties.CopyTo (strArray, 0);
				}
			}

			if (isSchemaQuery == false)
				return new SelectQuery(className, condition, strArray);
			else
				return new SelectQuery(true, condition);
		}

	}//SelectQuery

	
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para> Represents a WQL ASSOCIATORS OF data query. 
	///       It can be used for both instances and schema queries.</para>
	/// </summary>
	/// <example>
	///    <code lang='C#'>using System;
	/// using System.Management;
	/// 
	/// // This sample demonstrates how to query all instances associated
	/// // with Win32_LogicalDisk='C:'.
	/// 
	/// class Sample_RelatedObjectQuery
	/// {
	///     public static int Main(string[] args) {
	/// 
	///         //This query requests all objects related to the 'C:' drive.
	///         RelatedObjectQuery relatedQuery =
	///             new RelatedObjectQuery("win32_logicaldisk='c:'");
	///         ManagementObjectSearcher searcher =
	///             new ManagementObjectSearcher(relatedQuery);
	///     
	///         foreach (ManagementObject relatedObject in searcher.Get()) {
	///             Console.WriteLine(relatedObject.ToString());
	///         }
	///  
	///         return 0;
	///     }
	/// }
	///    </code>
	///    <code lang='VB'>Imports System
	/// Imports System.Management
	/// 
	/// ' This sample demonstrates how to query all instances associated
	/// ' with Win32_LogicalDisk='C:'.
	/// 
	/// Class Sample_RelatedObjectQuery
	///     Overloads Public Shared Function Main(args() As String) As Integer
	///  
	///         'This query requests all objects related to the 'C:' drive.
	///         Dim relatedQuery As New RelatedObjectQuery("win32_logicaldisk='c:'")
	///         Dim searcher As New ManagementObjectSearcher(relatedQuery)
	///    
	///         Dim relatedObject As ManagementObject
	///         For Each relatedObject In  searcher.Get()
	///             Console.WriteLine(relatedObject.ToString())
	///         Next relatedObject
	/// 
	///         Return 0
	///     End Function
	/// End Class
	///    </code>
	/// </example>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class RelatedObjectQuery : WqlObjectQuery
	{
		private static readonly string tokenAssociators = "associators";
		private static readonly string tokenOf = "of";
		private static readonly string tokenWhere = "where";
		private static readonly string tokenResultClass = "resultclass";
		private static readonly string tokenAssocClass = "assocclass";
		private static readonly string tokenResultRole = "resultrole";
		private static readonly string tokenRole = "role";
		private static readonly string tokenRequiredQualifier = "requiredqualifier";
		private static readonly string tokenRequiredAssocQualifier = "requiredassocqualifier";
		private static readonly string tokenClassDefsOnly = "classdefsonly";
		private static readonly string tokenSchemaOnly = "schemaonly";

		private bool isSchemaQuery;
		private string sourceObject;
		private string relatedClass;
		private string relationshipClass;
		private string relatedQualifier;
		private string relationshipQualifier;
		private string relatedRole;
		private string thisRole;
		private bool classDefinitionsOnly;

		
		//default constructor
		/// <overload>
		///    Initializes a new instance
		///    of the <see cref='System.Management.RelatedObjectQuery'/> class.
		/// </overload>
		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.RelatedObjectQuery'/> class. This is the
		///    default constructor.</para>
		/// </summary>
		public RelatedObjectQuery() :this(null) {}
		
		//parameterized constructor
		//ISSUE : We have 2 possible constructors that take a single string :
		//  one that takes the full query string and the other that takes the source object path.
		//  We resolve this by trying to parse the string, if it succeeds we assume it's the query, if
		//  not we assume it's the source object.
		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.RelatedObjectQuery'/>class. If the specified string can be succesfully parsed as 
		///    a WQL query, it is considered to be the query string; otherwise, it is assumed to be the path of the source
		///    object for the query. In this case, the query is assumed to be an instance query. </para>
		/// </summary>
		/// <param name='queryOrSourceObject'>The query string or the path of the source object.</param>
		/// <example>
		///    <code lang='C#'>//This query retrieves all objects related to the 'mymachine' computer system
		/// //It specifies the full query string in the constructor
		/// RelatedObjectQuery q = 
		///     new RelatedObjectQuery("associators of {Win32_ComputerSystem.Name='mymachine'}");
		///    
		/// //or 
		/// 
		/// //This query retrieves all objects related to the 'Alerter' service
		/// //It specifies only the object of interest in the constructor
		/// RelatedObjectQuery q = 
		///     new RelatedObjectQuery("Win32_Service.Name='Alerter'");
		///    </code>
		///    <code lang='VB'>'This query retrieves all objects related to the 'mymachine' computer system
		/// 'It specifies the full query string in the constructor
		/// Dim q As New RelatedObjectQuery("associators of {Win32_ComputerSystem.Name='mymachine'}")
		/// 
		/// 'or
		/// 
		/// 'This query retrieves all objects related to the 'Alerter' service  
		/// 'It specifies only the object of interest in the constructor
		/// Dim q As New RelatedObjectQuery("Win32_Service.Name='Alerter'")
		///    </code>
		/// </example>
		public RelatedObjectQuery(string queryOrSourceObject) 
		{
			if (null != queryOrSourceObject)
			{
				// Minimally determine if the string is a query or instance name.
				//
				if (queryOrSourceObject.TrimStart().ToLower(CultureInfo.InvariantCulture).StartsWith(tokenAssociators))
				{
					// Looks to be a query - do further checking.
					//
					QueryString = queryOrSourceObject;	// Parse/validate; may throw.
				}
				else
				{
					// We'd like to treat it as the source object. Is it a valid
					// class or instance?
					//
					// Do some basic sanity checking on whether it's a class/instance name
					//
					try
					{
						ManagementPath p = new ManagementPath (queryOrSourceObject);

						if ((p.IsClass || p.IsInstance) && (String.Empty == p.NamespacePath))
						{
							SourceObject = queryOrSourceObject;
							isSchemaQuery = false;
						}
						else
							throw new ArgumentException ();
					}
					catch (Exception)
					{
						throw new ArgumentException ();
					}
				}
			}
		}

		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.RelatedObjectQuery'/> class for the given source object and related class.
		///    The query is assumed to be an instance query (as opposed to a schema query).</para>
		/// </summary>
		/// <param name='sourceObject'>The path of the source object for this query.</param>
		/// <param name='relatedClass'>The related objects class.</param>
		public RelatedObjectQuery(string sourceObject, string relatedClass) : this(sourceObject, relatedClass, 
																					null, null, null, null, null, false) {}
		
		//Do we need additional variants of constructors here ??
		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.RelatedObjectQuery'/> class for the given set of parameters.
		///    The query is assumed to be an instance query (as opposed to a schema query).</para>
		/// </summary>
		/// <param name='sourceObject'>The path of the source object.</param>
		/// <param name='relatedClass'>The related objects required class.</param>
		/// <param name='relationshipClass'>The relationship type.</param>
		/// <param name='relatedQualifier'>The qualifier required to be present on the related objects.</param>
		/// <param name='relationshipQualifier'>The qualifier required to be present on the relationships.</param>
		/// <param name='relatedRole'>The role that the related objects are required to play in the relationship.</param>
		/// <param name='thisRole'>The role that the source object is required to play in the relationship.</param>
		/// <param name='classDefinitionsOnly'><see langword='true'/>to return only the class definitions of the related objects; otherwise, <see langword='false'/> .</param>
		public RelatedObjectQuery(string sourceObject,
								   string relatedClass, 
							       string relationshipClass, 
								   string relatedQualifier, 
								   string relationshipQualifier, 
								   string relatedRole, 
								   string thisRole, 
								   bool classDefinitionsOnly) 
		{
			this.isSchemaQuery = false;
			this.sourceObject = sourceObject;
			this.relatedClass = relatedClass;
			this.relationshipClass = relationshipClass;
			this.relatedQualifier = relatedQualifier;
			this.relationshipQualifier = relationshipQualifier;
			this.relatedRole = relatedRole;
			this.thisRole = thisRole;
			this.classDefinitionsOnly = classDefinitionsOnly;
			BuildQuery();

		}

		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.RelatedObjectQuery'/> class for a schema query using the given set 
		///    of parameters. This constructor is used for schema queries only: the first
		///    parameter must be set to <see langword='true'/>
		///    .</para>
		/// </summary>
		/// <param name='isSchemaQuery'><see langword='true'/>to indicate that this is a schema query; otherwise, <see langword='false'/> .</param>
		/// <param name='sourceObject'>The path of the source class.</param>
		/// <param name='relatedClass'>The related objects' required base class.</param>
		/// <param name='relationshipClass'>The relationship type.</param>
		/// <param name='relatedQualifier'>The qualifier required to be present on the related objects.</param>
		/// <param name='relationshipQualifier'>The qualifier required to be present on the relationships.</param>
		/// <param name='relatedRole'>The role that the related objects are required to play in the relationship.</param>
		/// <param name='thisRole'>The role that the source class is required to play in the relationship.</param>
		public RelatedObjectQuery(bool isSchemaQuery,
			string sourceObject,
			string relatedClass, 
			string relationshipClass, 
			string relatedQualifier, 
			string relationshipQualifier, 
			string relatedRole, 
			string thisRole) 
		{
			if (isSchemaQuery == false)
				throw new ArgumentException(null, "isSchemaQuery");

			this.isSchemaQuery = true;
			this.sourceObject = sourceObject;
			this.relatedClass = relatedClass;
			this.relationshipClass = relationshipClass;
			this.relatedQualifier = relatedQualifier;
			this.relationshipQualifier = relationshipQualifier;
			this.relatedRole = relatedRole;
			this.thisRole = thisRole;
			this.classDefinitionsOnly = false; //this parameter is not relevant for schema queries.
			BuildQuery();

		}

		/// <summary>
		///    <para>Gets or sets a value indicating whether this is a schema query or an instance query.</para>
		/// </summary>
		/// <value>
		/// <see langword='true'/> if this query 
		///    should be evaluated over the schema; <see langword='false'/> if the query should
		///    be evaluated over instances.
		/// </value>
		/// <remarks>
		///    <para>Setting this property value overrides any
		///       previous value stored in the object. The query string is
		///       rebuilt to reflect the new query type.</para>
		/// </remarks>
		public bool IsSchemaQuery
		{
			get 
			{ return isSchemaQuery; }
			set 
			{ isSchemaQuery = value; BuildQuery(); FireIdentifierChanged(); }
		}

		/// <summary>
		///    <para> Gets or sets the source object to be used for the query. For instance
		///       queries, this is typically an instance path. For schema queries, this is typically a class name.</para>
		/// </summary>
		/// <value>
		///    A string representing the path of the
		///    object to be used for the query.
		/// </value>
		/// <remarks>
		///    <para>Setting this property value overrides any
		///       previous value stored in the object. The query string is
		///       rebuilt to reflect the new source object.</para>
		/// </remarks>
		public string SourceObject
		{
			get { return (null != sourceObject) ? sourceObject : String.Empty; }
			set { sourceObject = value; BuildQuery(); FireIdentifierChanged(); }
		}

		/// <summary>
		///    <para>Gets or sets the class of the endpoint objects.</para>
		/// </summary>
		/// <value>
		///    <para>A string containing the related class
		///       name.</para>
		/// </value>
		/// <remarks>
		///    <para>Setting this property value overrides any
		///       previous value stored in the object. The query string is
		///       rebuilt to reflect the new related class.</para>
		/// </remarks>
		/// <example>
		///    <para>To find all the Win32 services available on a computer, this property is set 
		///       to "Win32_Service" : </para>
		///    <code lang='C#'>RelatedObjectQuery q = new RelatedObjectQuery("Win32_ComputerSystem='MySystem'");
		/// q.RelatedClass = "Win32_Service";
		///    </code>
		///    <code lang='VB'>Dim q As New RelatedObjectQuery("Win32_ComputerSystem=""MySystem""")
		/// q.RelatedClass = "Win32_Service"
		///    </code>
		/// </example>
		public string RelatedClass
		{
			get { return (null != relatedClass) ? relatedClass : String.Empty; }
			set { relatedClass = value; BuildQuery(); FireIdentifierChanged(); }
		}

		/// <summary>
		///    <para>Gets or sets the type of relationship (association).</para>
		/// </summary>
		/// <value>
		///    <para>A string containing the relationship
		///       class name.</para>
		/// </value>
		/// <remarks>
		///    <para>Setting this property value overrides any
		///       previous value stored in the object. The query string is
		///       rebuilt to reflect the new relationship class.</para>
		/// </remarks>
		/// <example>
		///    <para>For example, for finding all the Win32 services dependent on 
		///       a service, this property should be set to the "Win32_DependentService" association class: </para>
		///    <code lang='C#'>RelatedObjectQuery q = new RelatedObjectQuery("Win32_Service='TCP/IP'");
		/// q.RelationshipClass = "Win32_DependentService";
		///    </code>
		///    <code lang='VB'>Dim q As New RelatedObjectQuery("Win32_Service=""TCP/IP""")
		/// q.RelationshipClass = "Win32_DependentService"
		///    </code>
		/// </example>
		public string RelationshipClass
		{
			get { return (null != relationshipClass) ? relationshipClass : String.Empty; }
			set { relationshipClass = value; BuildQuery(); FireIdentifierChanged(); }
		}

		/// <summary>
		///    <para>Gets or sets a qualifier required to be defined on the related objects.</para>
		/// </summary>
		/// <value>
		///    A string containing the name of the
		///    qualifier required on the related objects.
		/// </value>
		/// <remarks>
		///    <para>Setting this property value overrides any
		///       previous value stored in the object. The query string is
		///       rebuilt to reflect the new qualifier.</para>
		/// </remarks>
		public string RelatedQualifier
		{
			get { return (null != relatedQualifier) ? relatedQualifier : String.Empty; }
			set { relatedQualifier = value; BuildQuery(); FireIdentifierChanged(); }
		}

		/// <summary>
		///    <para>Gets or sets a qualifier required to be defined on the relationship objects.</para>
		/// </summary>
		/// <value>
		///    <para>A string containing the name of the qualifier required 
		///       on the relationship objects.</para>
		/// </value>
		/// <remarks>
		///    <para>Setting this property value overrides any
		///       previous value stored in the object. The query string is
		///       rebuilt to reflect the new qualifier.</para>
		/// </remarks>
		public string RelationshipQualifier
		{
			get { return (null != relationshipQualifier) ? relationshipQualifier : String.Empty; }
			set { relationshipQualifier = value; BuildQuery(); FireIdentifierChanged(); }
		}

		/// <summary>
		///    <para>Gets or sets the role that the related objects returned should be playing in the relationship.</para>
		/// </summary>
		/// <value>
		///    <para>A string containing the role of the
		///       related objects.</para>
		/// </value>
		/// <remarks>
		///    <para>Setting this property value overrides any
		///       previous value stored in the object. The query string is
		///       rebuilt to reflect the new role.</para>
		/// </remarks>
		public string RelatedRole
		{
			get { return (null != relatedRole) ? relatedRole : String.Empty; }
			set { relatedRole = value; BuildQuery(); FireIdentifierChanged(); }
		}

		/// <summary>
		///    <para>Gets or sets the role that the source object should be playing in the relationship.</para>
		/// </summary>
		/// <value>
		///    <para>A string containing the role of this object.</para>
		/// </value>
		/// <remarks>
		///    <para>Setting this property value overrides any
		///       previous value stored in the object. The query string is
		///       rebuilt to reflect the new role.</para>
		/// </remarks>
		public string ThisRole
		{
			get { return (null != thisRole) ? thisRole : String.Empty; }
			set { thisRole = value; BuildQuery(); FireIdentifierChanged(); }
		}

		/// <summary>
		///    <para>Gets or sets a value indicating that for all instances that adhere to the query, only their class definitions be returned.
		///       This parameter is only valid for instance queries.</para>
		/// </summary>
		/// <value>
		/// <see langword='true'/> if the query 
		///    requests only class definitions of the result set; otherwise,
		/// <see langword='false'/>.
		/// </value>
		/// <remarks>
		///    <para>Setting this property value overrides any
		///       previous value stored in the object. The query string is
		///       rebuilt to reflect the new flag.</para>
		/// </remarks>
		public bool ClassDefinitionsOnly
		{
			get { return classDefinitionsOnly; }
			set { classDefinitionsOnly = value; BuildQuery(); FireIdentifierChanged(); }
		}


		/// <summary>
		///  Builds the query string according to the current property values.
		/// </summary>
		protected internal void BuildQuery()
		{
			//If the source object is not set we can't build a query
			//Shouldn't throw here because the user may be in the process of filling in the properties...
			if (sourceObject == null)
				SetQueryString (String.Empty);

			if ((sourceObject == null) || (sourceObject == String.Empty))
				return;

			//"associators" clause
			string s = tokenAssociators + " " + tokenOf + " {" + sourceObject + "}";

			//If any of the other parameters are set we need a "where" clause
			if (!RelatedClass.Equals (String.Empty) || 
				!RelationshipClass.Equals (String.Empty) || 
				!RelatedQualifier.Equals (String.Empty) || 
				!RelationshipQualifier.Equals (String.Empty) || 
				!RelatedRole.Equals (String.Empty) || 
				!ThisRole.Equals (String.Empty) || 
				classDefinitionsOnly ||
				isSchemaQuery)
			{
				s = s + " " + tokenWhere;

				//"ResultClass"
				if (!RelatedClass.Equals (String.Empty))
					s = s + " " + tokenResultClass + " = " + relatedClass;

				//"AssocClass"
				if (!RelationshipClass.Equals (String.Empty))
					s = s + " " + tokenAssocClass + " = " + relationshipClass;

				//"ResultRole"
				if (!RelatedRole.Equals (String.Empty))
					s = s + " " + tokenResultRole + " = " + relatedRole;

				//"Role"
				if (!ThisRole.Equals (String.Empty))
					s = s + " " + tokenRole + " = " + thisRole;

				//"RequiredQualifier"
				if (!RelatedQualifier.Equals (String.Empty))
					s = s + " " + tokenRequiredQualifier + " = " + relatedQualifier;

				//"RequiredAssocQualifier"
				if (!RelationshipQualifier.Equals (String.Empty))
					s = s + " " + tokenRequiredAssocQualifier + " = " + relationshipQualifier;

				//"SchemaOnly" and "ClassDefsOnly"
				if (!isSchemaQuery) //this is an instance query - classDefs allowed
				{
					if (classDefinitionsOnly)
						s = s + " " + tokenClassDefsOnly;
				}
				else //this is a schema query, schemaonly required
					s = s + " " + tokenSchemaOnly;
			}
	
			//Set the queryString member to the built query (NB: note we set
			//by accessing the internal helper function rather than the property,
			//since we do not want to force a parse of a query we just built).
			SetQueryString (s);

		}//BuildQuery()


		/// <summary>
		///  Parses the query string and sets the property values accordingly.
		/// </summary>
		/// <param name="query">The query string to be parsed.</param>
		protected internal override void ParseQuery(string query)
		{
			// Temporary variables to hold token values until we are sure query is valid
			string tempSourceObject = null;
			string tempRelatedClass = null;
			string tempRelationshipClass = null;
			string tempRelatedRole = null;
			string tempThisRole = null;
			string tempRelatedQualifier = null;
			string tempRelationshipQualifier = null;
			bool   tempClassDefsOnly = false;
			bool   tempIsSchemaQuery = false;

			//Trim whitespaces
			string q = query.Trim(); 
			int i;

			//Find "associators" clause
			if (0 != String.Compare(q, 0, tokenAssociators, 0, tokenAssociators.Length, true,CultureInfo.InvariantCulture))
				throw new ArgumentException();	// Invalid query
			
			// Strip off the clause
			q = q.Remove(0, tokenAssociators.Length);

			// Must be some white space next
			if ((0 == q.Length) || !Char.IsWhiteSpace (q[0]))
				throw new ArgumentException();	// Invalid query
			
			q = q.TrimStart(null);	// Remove the leading whitespace

			// Next token should be "of"
			if (0 != String.Compare(q, 0, tokenOf, 0, tokenOf.Length, true,CultureInfo.InvariantCulture))
				throw new ArgumentException();	// Invalid query
			
			// Strip off the clause and leading WS
			q = q.Remove(0, tokenOf.Length).TrimStart (null);

			// Next character should be "{"
			if (0 != q.IndexOf('{'))
				throw new ArgumentException();	// Invalid query

			// Strip off the "{" and any leading WS
			q = q.Remove(0, 1).TrimStart(null);

			// Next item should be the source object
			if (-1 == (i = q.IndexOf('}')))
				throw new ArgumentException();	// Invalid query

			tempSourceObject = q.Substring(0, i).TrimEnd(null);
			q = q.Remove(0, i+1).TrimStart(null);
				
			// At this point we may or may not have a "where" clause
			if (0 < q.Length)
			{
				// Next should be the "where" clause
				if (0 != String.Compare (q, 0, tokenWhere, 0, tokenWhere.Length, true,CultureInfo.InvariantCulture))
					throw new ArgumentException();	// Invalid query
				
				q = q.Remove (0, tokenWhere.Length);

				// Must be some white space next
				if ((0 == q.Length) || !Char.IsWhiteSpace (q[0]))
					throw new ArgumentException();	// Invalid query
				
				q = q.TrimStart(null);	// Remove the leading whitespace

				// Remaining tokens can appear in any order
				bool bResultClassFound = false;
				bool bAssocClassFound = false;
				bool bResultRoleFound = false;
				bool bRoleFound = false;
				bool bRequiredQualifierFound = false;
				bool bRequiredAssocQualifierFound = false;
				bool bClassDefsOnlyFound = false;
				bool bSchemaOnlyFound = false;

				// Keep looking for tokens until we are done
				while (true)
				{
					if ((q.Length >= tokenResultClass.Length) && (0 == String.Compare (q, 0, tokenResultClass, 0, tokenResultClass.Length, true,CultureInfo.InvariantCulture)))
						ParseToken (ref q, tokenResultClass, "=", ref bResultClassFound, ref tempRelatedClass);
					else if ((q.Length >= tokenAssocClass.Length) && (0 == String.Compare (q, 0, tokenAssocClass, 0, tokenAssocClass.Length, true,CultureInfo.InvariantCulture)))
						ParseToken (ref q, tokenAssocClass, "=", ref bAssocClassFound, ref tempRelationshipClass);
					else if ((q.Length >= tokenResultRole.Length) && (0 == String.Compare (q, 0, tokenResultRole, 0, tokenResultRole.Length, true,CultureInfo.InvariantCulture)))
						ParseToken (ref q, tokenResultRole, "=", ref bResultRoleFound, ref tempRelatedRole);
					else if ((q.Length >= tokenRole.Length) && (0 == String.Compare (q, 0, tokenRole, 0, tokenRole.Length, true,CultureInfo.InvariantCulture)))
						ParseToken (ref q, tokenRole, "=", ref bRoleFound, ref tempThisRole);
					else if ((q.Length >= tokenRequiredQualifier.Length) && (0 == String.Compare (q, 0, tokenRequiredQualifier, 0, tokenRequiredQualifier.Length, true,CultureInfo.InvariantCulture)))
						ParseToken (ref q, tokenRequiredQualifier, "=", ref bRequiredQualifierFound, ref tempRelatedQualifier);
					else if ((q.Length >= tokenRequiredAssocQualifier.Length) && (0 == String.Compare (q, 0, tokenRequiredAssocQualifier, 0, tokenRequiredAssocQualifier.Length, true,CultureInfo.InvariantCulture)))
						ParseToken (ref q, tokenRequiredAssocQualifier, "=", ref bRequiredAssocQualifierFound, ref tempRelationshipQualifier);
					else if ((q.Length >= tokenSchemaOnly.Length) && (0 == String.Compare (q, 0, tokenSchemaOnly, 0, tokenSchemaOnly.Length, true,CultureInfo.InvariantCulture)))
					{
						ParseToken (ref q, tokenSchemaOnly, ref bSchemaOnlyFound);
						tempIsSchemaQuery = true;
					}
					else if ((q.Length >= tokenClassDefsOnly.Length) && (0 == String.Compare (q, 0, tokenClassDefsOnly, 0, tokenClassDefsOnly.Length, true,CultureInfo.InvariantCulture)))
					{
						ParseToken (ref q, tokenClassDefsOnly, ref bClassDefsOnlyFound);
						tempClassDefsOnly = true;
					}
					else if (0 == q.Length)
						break;		// done
					else 
						throw new ArgumentException();		// Unrecognized token
				}

				//Can't have both classDefsOnly and schemaOnly
				if (bSchemaOnlyFound && bClassDefsOnlyFound)
					throw new ArgumentException();
			}

			// Getting here means we parsed successfully. Assign the values.
			sourceObject = tempSourceObject;
			relatedClass = tempRelatedClass;
			relationshipClass = tempRelationshipClass;
			relatedRole = tempRelatedRole;
			thisRole = tempThisRole;
			relatedQualifier = tempRelatedQualifier;
			relationshipQualifier = tempRelationshipQualifier;
			classDefinitionsOnly = tempClassDefsOnly;
			isSchemaQuery = tempIsSchemaQuery;

		}//ParseQuery()


		//ICloneable
		/// <summary>
		///    <para>Creates a copy of the object.</para>
		/// </summary>
		/// <returns>
		///    The copied object.
		/// </returns>
		public override object Clone()
		{
			if (isSchemaQuery == false)
				return new RelatedObjectQuery(sourceObject, relatedClass, relationshipClass, 
											relatedQualifier, relationshipQualifier, relatedRole, 
											thisRole, classDefinitionsOnly);
			else
				return new RelatedObjectQuery(true, sourceObject, relatedClass, relationshipClass, 
											relatedQualifier, relationshipQualifier, relatedRole, 
											thisRole);
				
		}

	}//RelatedObjectQuery


	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para> Represents a WQL REFERENCES OF data query.</para>
	/// </summary>
	/// <example>
	///    <para>The following example searches for all objects related to the 
	///       'C:' drive object:</para>
	///    <code lang='C#'>using System;
	/// using System.Management;
	/// 
	/// class Sample_RelationshipQuery
	/// {
	///     public static int Main(string[] args) {
	///         RelationshipQuery query = 
	///             new RelationshipQuery("references of {Win32_LogicalDisk.DeviceID='C:'}");
	///         ManagementObjectSearcher searcher =
	///             new ManagementObjectSearcher(query);
	///         
	///         foreach (ManagementObject assoc in searcher.Get()) {
	///             Console.WriteLine("Association class = " + assoc["__CLASS"]);
	///         }
	/// 
	///         return 0;
	///     }
	/// }
	///    </code>
	///    <code lang='VB'>Imports System
	/// Imports System.Management
	///  
	/// Class Sample_RelatedObjectQuery
	///     Overloads Public Shared Function Main(args() As String) As Integer
	///         Dim query As New RelationshipQuery("references of {Win32_LogicalDisk.DeviceID='C:'}")
	///         Dim searcher As New ManagementObjectSearcher(query)
	///         Dim assoc As ManagementObject
	///         
	///         For Each assoc In searcher.Get()
	///             Console.WriteLine("Association class = " &amp; assoc("__CLASS"))
	///         Next assoc
	///         
	///         Return 0
	///     End Function
	/// End Class
	///    </code>
	/// </example>

	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class RelationshipQuery : WqlObjectQuery
	{
		private static readonly string tokenReferences = "references";
		private static readonly string tokenOf = "of";
		private static readonly string tokenWhere = "where";
		private static readonly string tokenResultClass = "resultclass";
		private static readonly string tokenRole = "role";
		private static readonly string tokenRequiredQualifier = "requiredqualifier";
		private static readonly string tokenClassDefsOnly = "classdefsonly";
		private static readonly string tokenSchemaOnly = "schemaonly";

		private string sourceObject;
		private string relationshipClass;
		private string relationshipQualifier;
		private string thisRole;
		private bool classDefinitionsOnly;
		private bool isSchemaQuery;
		
		//default constructor
		/// <overload>
		///    Initializes a new instance
		///    of the <see cref='System.Management.RelationshipQuery'/> class.
		/// </overload>
		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.RelationshipQuery'/> class. This is the default constructor.</para>
		/// </summary>
		public RelationshipQuery() :this(null) {}
		
		//parameterized constructor
		//ISSUE : We have 2 possible constructors that take a single string :
		//  one that takes the full query string and the other that takes the source object path.
		//  We resolve this by trying to parse the string, if it succeeds we assume it's the query, if
		//  not we assume it's the source object.
		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.RelationshipQuery'/>class. If the specified string can be succesfully parsed as 
		///    a WQL query, it is considered to be the query string; otherwise, it is assumed to be the path of the source
		///    object for the query. In this case, the query is assumed to be an instances query. </para>
		/// </summary>
		/// <param name='queryOrSourceObject'>The query string or the class name for this query.</param>
		/// <example>
		///    <para>This example shows the two different ways to use this constructor:</para>
		///    <code lang='C#'>//Full query string is specified to the constructor
		/// RelationshipQuery q = new RelationshipQuery("references of {Win32_ComputerSystem.Name='mymachine'}");
		///    
		/// //Only the object of interest is specified to the constructor
		/// RelationshipQuery q = new RelationshipQuery("Win32_Service.Name='Alerter'");
		///    </code>
		///    <code lang='VB'>'Full query string is specified to the constructor
		/// Dim q As New RelationshipQuery("references of {Win32_ComputerSystem.Name='mymachine'}")
		///    
		/// 'Only the object of interest is specified to the constructor
		/// Dim q As New RelationshipQuery("Win32_Service.Name='Alerter'")
		///    </code>
		/// </example>
		public RelationshipQuery(string queryOrSourceObject)
		{
			if (null != queryOrSourceObject)
			{
				// Minimally determine if the string is a query or instance name.
				//
				if (queryOrSourceObject.TrimStart().ToLower(CultureInfo.InvariantCulture).StartsWith(tokenReferences))
				{
					// Looks to be a query - do further checking.
					//
					QueryString = queryOrSourceObject;	// Parse/validate; may throw.
				}
				else
				{
					// We'd like to treat it as the source object. Is it a valid
					// class or instance?
					try 
					{
						// Do some basic sanity checking on whether it's a class/instance name
						//
						ManagementPath p = new ManagementPath (queryOrSourceObject);

						if ((p.IsClass || p.IsInstance) && (String.Empty == p.NamespacePath))
						{
							SourceObject = queryOrSourceObject;
							isSchemaQuery = false;
						}
						else
							throw new ArgumentException ();
					}
					catch (Exception)
					{
						throw new ArgumentException ();
					}
				}
			}
		}

		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.RelationshipQuery'/> class for the given source object and relationship class.
		///    The query is assumed to be an instance query (as opposed to a schema query).</para>
		/// </summary>
		/// <param name='sourceObject'> The path of the source object for this query.</param>
		/// <param name='relationshipClass'> The type of relationship for which to query.</param>
		public RelationshipQuery(string sourceObject, string relationshipClass) : this(sourceObject, relationshipClass, 
																					    null, null, false) {}
		//Do we need additional variants of constructors here ??
		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.RelationshipQuery'/> class for the given set of parameters.
		///    The query is assumed to be an instance query (as opposed to a schema query).</para>
		/// </summary>
		/// <param name='sourceObject'> The path of the source object for this query.</param>
		/// <param name='relationshipClass'> The type of relationship for which to query.</param>
		/// <param name='relationshipQualifier'> A qualifier required to be present on the relationship object.</param>
		/// <param name='thisRole'> The role that the source object is required to play in the relationship.</param>
		/// <param name='classDefinitionsOnly'>When this method returns, it contains a boolean that indicates that only class definitions for the resulting objects are returned.</param>
		public RelationshipQuery(string sourceObject,
							      string relationshipClass, 
								  string relationshipQualifier, 
								  string thisRole, 
								  bool classDefinitionsOnly) 
		{
			this.isSchemaQuery = false;
			this.sourceObject = sourceObject;
			this.relationshipClass = relationshipClass;
			this.relationshipQualifier = relationshipQualifier;
			this.thisRole = thisRole;
			this.classDefinitionsOnly = classDefinitionsOnly;
			BuildQuery();
		}

		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.RelationshipQuery'/> class for a schema query using the given set 
		///    of parameters. This constructor is used for schema queries only, so the first
		///    parameter must be <see langword='true'/>
		///    .</para>
		/// </summary>
		/// <param name='isSchemaQuery'><see langword='true'/>to indicate that this is a schema query; otherwise, <see langword='false'/> .</param>
		/// <param name='sourceObject'> The path of the source class for this query.</param>
		/// <param name='relationshipClass'> The type of relationship for which to query.</param>
		/// <param name='relationshipQualifier'> A qualifier required to be present on the relationship class.</param>
		/// <param name='thisRole'> The role that the source class is required to play in the relationship.</param>
		public RelationshipQuery(bool isSchemaQuery,
			string sourceObject,
			string relationshipClass, 
			string relationshipQualifier, 
			string thisRole) 
		{
			if (isSchemaQuery == false)
				throw new ArgumentException(null, "isSchemaQuery");

			this.isSchemaQuery = true;
			this.sourceObject = sourceObject;
			this.relationshipClass = relationshipClass;
			this.relationshipQualifier = relationshipQualifier;
			this.thisRole = thisRole;
			this.classDefinitionsOnly = false; //this parameter is not relevant for schema queries.
			BuildQuery();

		}
		
		
		/// <summary>
		///    <para>Gets or sets a value indicating whether this query is a schema query or an instance query.</para>
		/// </summary>
		/// <value>
		/// <see langword='true'/> if this query 
		///    should be evaluated over the schema; <see langword='false'/> if the query should
		///    be evaluated over instances.
		/// </value>
		/// <remarks>
		///    <para>Setting this property value overrides any
		///       previous value stored in the object. The query string is
		///       rebuilt to reflect the new query type.</para>
		/// </remarks>
		public bool IsSchemaQuery
		{
			get 
			{ return isSchemaQuery; }
			set 
			{ isSchemaQuery = value; BuildQuery(); FireIdentifierChanged(); }
		}

		
		/// <summary>
		///    <para>Gets or sets the source object for this query.</para>
		/// </summary>
		/// <value>
		///    A string representing the path of
		///    the object to be used for the query.
		/// </value>
		/// <remarks>
		///    <para>Setting this property value overrides any
		///       previous value stored in the object. The query string is
		///       rebuilt to reflect the new source object.</para>
		/// </remarks>
		public string SourceObject
		{
			get { return (null != sourceObject) ? sourceObject : String.Empty; }
			set { sourceObject = value; BuildQuery(); FireIdentifierChanged(); }
		}

		/// <summary>
		///    <para>Gets or sets the class of the relationship objects wanted in the query.</para>
		/// </summary>
		/// <value>
		///    A string containing the relationship
		///    class name.
		/// </value>
		/// <remarks>
		///    <para>Setting this property value overrides any
		///       previous value stored in the object. The query string is
		///       rebuilt to reflect the new class.</para>
		/// </remarks>
		public string RelationshipClass
		{
			get { return (null != relationshipClass) ? relationshipClass : String.Empty; }
			set { relationshipClass = value; BuildQuery(); FireIdentifierChanged(); }
		}

		/// <summary>
		///    <para>Gets or sets a qualifier required on the relationship objects.</para>
		/// </summary>
		/// <value>
		///    A string containing the name of the
		///    qualifier required on the relationship objects.
		/// </value>
		/// <remarks>
		///    <para>Setting this property value overrides any
		///       previous value stored in the object. The query string is
		///       rebuilt to reflect the new qualifier.</para>
		/// </remarks>
		public string RelationshipQualifier
		{
			get { return (null != relationshipQualifier) ? relationshipQualifier : String.Empty; }
			set { relationshipQualifier = value; BuildQuery(); FireIdentifierChanged(); }
		}

		/// <summary>
		///    <para>Gets or sets the role of the source object in the relationship.</para>
		/// </summary>
		/// <value>
		///    A string containing the role of this
		///    object.
		/// </value>
		/// <remarks>
		///    <para>Setting this property value overrides any
		///       previous value stored in the object. The query string is
		///       rebuilt to reflect the new role.</para>
		/// </remarks>
		public string ThisRole
		{
			get { return (null != thisRole) ? thisRole : String.Empty; }
			set { thisRole = value; BuildQuery(); FireIdentifierChanged(); }
		}

		/// <summary>
		///    <para>Gets or sets a value indicating that only the class definitions of the relevant relationship objects be returned.</para>
		/// </summary>
		/// <value>
		/// <para><see langword='true'/> if the query requests only class definitions of the 
		///    result set; otherwise, <see langword='false'/>.</para>
		/// </value>
		/// <remarks>
		///    <para>Setting this property value overrides any previous
		///       value stored in the object. As a side-effect, the query string is
		///       rebuilt to reflect the new flag.</para>
		/// </remarks>
		public bool ClassDefinitionsOnly
		{
			get { return classDefinitionsOnly; }
			set { classDefinitionsOnly = value; BuildQuery(); FireIdentifierChanged(); }
		}


		/// <summary>
		///  Builds the query string according to the current property values.
		/// </summary>
		protected internal void BuildQuery()
		{
			//If the source object is not set we can't build a query
			//Shouldn't throw here because the user may be in the process of filling in the properties...
			if (sourceObject == null)
				SetQueryString(String.Empty);

			if ((sourceObject == null) || (sourceObject == String.Empty))
				return;

			//"references" clause
			string s = tokenReferences + " " + tokenOf + " {" + sourceObject + "}";

			//If any of the other parameters are set we need a "where" clause
			if (!RelationshipClass.Equals(String.Empty) || 
				!RelationshipQualifier.Equals(String.Empty) || 
				!ThisRole.Equals(String.Empty) || 
				classDefinitionsOnly ||
				isSchemaQuery)
			{
				s = s + " " + tokenWhere;

				//"ResultClass"
				if (!RelationshipClass.Equals(String.Empty))
					s = s + " " + tokenResultClass + " = " + relationshipClass;

				//"Role"
				if (!ThisRole.Equals(String.Empty))
					s = s + " " + tokenRole + " = " + thisRole;

				//"RequiredQualifier"
				if (!RelationshipQualifier.Equals(String.Empty))
					s = s + " " + tokenRequiredQualifier + " = " + relationshipQualifier;

				//"SchemaOnly" and "ClassDefsOnly"
				if (!isSchemaQuery) //this is an instance query - classDefs allowed
				{
					if (classDefinitionsOnly)
						s = s + " " + tokenClassDefsOnly;
				}
				else //this is a schema query, schemaonly required
					s = s + " " + tokenSchemaOnly;
				
			}

			//Set the queryString member to the built query (NB: note we set
			//by accessing the internal helper function rather than the property,
			//since we do not want to force a parse of a query we just built).
			SetQueryString (s);
		} //BuildQuery()

		
		/// <summary>
		///  Parses the query string and sets the property values accordingly.
		/// </summary>
		/// <param name="query">The query string to be parsed.</param>
		protected internal override void ParseQuery(string query)
		{
			// Temporary variables to hold token values until we are sure query is valid
			string tempSourceObject = null;
			string tempRelationshipClass = null;
			string tempThisRole = null;
			string tempRelationshipQualifier = null;
			bool   tempClassDefsOnly = false;
			bool   tempSchemaOnly = false;

			//Trim whitespaces
			string q = query.Trim(); 
			int i;

			//Find "references" clause
			if (0 != String.Compare(q, 0, tokenReferences, 0, tokenReferences.Length, true,CultureInfo.InvariantCulture))
				throw new ArgumentException();	// Invalid query
			
			// Strip off the clause
			q = q.Remove(0, tokenReferences.Length);

			// Must be some white space next
			if ((0 == q.Length) || !Char.IsWhiteSpace (q[0]))
				throw new ArgumentException();	// Invalid query
			
			q = q.TrimStart(null);	// Remove the leading whitespace

			// Next token should be "of"
			if (0 != String.Compare(q, 0, tokenOf, 0, tokenOf.Length, true,CultureInfo.InvariantCulture))
				throw new ArgumentException();	// Invalid query
			
			// Strip off the clause and leading WS
			q = q.Remove(0, tokenOf.Length).TrimStart (null);

			// Next character should be "{"
			if (0 != q.IndexOf('{'))
				throw new ArgumentException();	// Invalid query

			// Strip off the "{" and any leading WS
			q = q.Remove(0, 1).TrimStart(null);

			// Next item should be the source object
			if (-1 == (i = q.IndexOf('}')))
				throw new ArgumentException();	// Invalid query

			tempSourceObject = q.Substring(0, i).TrimEnd(null);
			q = q.Remove(0, i+1).TrimStart(null);
				
			// At this point we may or may not have a "where" clause
			if (0 < q.Length)
			{
				// Next should be the "where" clause
				if (0 != String.Compare (q, 0, tokenWhere, 0, tokenWhere.Length, true,CultureInfo.InvariantCulture))
					throw new ArgumentException();	// Invalid query
				
				q = q.Remove (0, tokenWhere.Length);

				// Must be some white space next
				if ((0 == q.Length) || !Char.IsWhiteSpace (q[0]))
					throw new ArgumentException();	// Invalid query
				
				q = q.TrimStart(null);	// Remove the leading whitespace

				// Remaining tokens can appear in any order
				bool bResultClassFound = false;
				bool bRoleFound = false;
				bool bRequiredQualifierFound = false;
				bool bClassDefsOnlyFound = false;
				bool bSchemaOnlyFound = false;

				// Keep looking for tokens until we are done
				while (true)
				{
					if ((q.Length >= tokenResultClass.Length) && (0 == String.Compare (q, 0, tokenResultClass, 0, tokenResultClass.Length, true,CultureInfo.InvariantCulture)))
						ParseToken (ref q, tokenResultClass, "=", ref bResultClassFound, ref tempRelationshipClass);
					else if ((q.Length >= tokenRole.Length) && (0 == String.Compare (q, 0, tokenRole, 0, tokenRole.Length, true,CultureInfo.InvariantCulture)))
						ParseToken (ref q, tokenRole, "=", ref bRoleFound, ref tempThisRole);
					else if ((q.Length >= tokenRequiredQualifier.Length) && (0 == String.Compare (q, 0, tokenRequiredQualifier, 0, tokenRequiredQualifier.Length, true,CultureInfo.InvariantCulture)))
						ParseToken (ref q, tokenRequiredQualifier, "=", ref bRequiredQualifierFound, ref tempRelationshipQualifier);
					else if ((q.Length >= tokenClassDefsOnly.Length) && (0 == String.Compare (q, 0, tokenClassDefsOnly, 0, tokenClassDefsOnly.Length, true,CultureInfo.InvariantCulture)))
					{
						ParseToken (ref q, tokenClassDefsOnly, ref bClassDefsOnlyFound);
						tempClassDefsOnly = true;
					}
					else if ((q.Length >= tokenSchemaOnly.Length) && (0 == String.Compare (q, 0, tokenSchemaOnly, 0, tokenSchemaOnly.Length, true,CultureInfo.InvariantCulture)))
					{
						ParseToken (ref q, tokenSchemaOnly, ref bSchemaOnlyFound);
						tempSchemaOnly = true;
					}
					else if (0 == q.Length)
						break;		// done
					else 
						throw new ArgumentException();		// Unrecognized token
				}

				//Can't have both classDefsOnly and schemaOnly
				if (tempClassDefsOnly && tempSchemaOnly)
					throw new ArgumentException();

			}

			// Getting here means we parsed successfully. Assign the values.
			sourceObject = tempSourceObject;
			relationshipClass = tempRelationshipClass;
			thisRole = tempThisRole;
			relationshipQualifier = tempRelationshipQualifier;
			classDefinitionsOnly = tempClassDefsOnly;
			isSchemaQuery = tempSchemaOnly;

		}//ParseQuery()


		//ICloneable
		/// <summary>
		///    <para>Creates a copy of the object.</para>
		/// </summary>
		/// <returns>
		///    The copied object.
		/// </returns>
		public override object Clone()
		{
			if (isSchemaQuery == false)
				return new RelationshipQuery(sourceObject, relationshipClass, 
											relationshipQualifier, thisRole, classDefinitionsOnly);
			else
				return new RelationshipQuery(true, sourceObject, relationshipClass, relationshipQualifier,
											thisRole);
		}

	}//RelationshipQuery


	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//	
	/// <summary>
	///    <para> Represents a WMI event query in WQL format.</para>
	/// </summary>
	/// <example>
	///    <code lang='C#'>using System;
	/// using System.Management;
	/// 
	/// // This sample demonstrates how to subscribe to an event
	/// // using a WQL event query.
	/// 
	/// class Sample_EventQuery
	/// {
	///     public static int Main(string[] args)
	///     {
	///         //For this example, we make sure we have an arbitrary class on root\default
	///         ManagementClass newClass = new ManagementClass(
	///             "root\\default",
	///             String.Empty,
	///             null);
	///         newClass["__Class"] = "TestWql";
	///         newClass.Put();
	/// 
	///         //Create a query object for watching for class deletion events
	///         WqlEventQuery eventQuery = new WqlEventQuery("select * from __classdeletionevent");
	/// 
	///         //Initialize an event watcher object with this query
	///         ManagementEventWatcher watcher = new ManagementEventWatcher(
	///             new ManagementScope("root/default"),
	///             eventQuery);
	/// 
	///         //Set up a handler for incoming events
	///         MyHandler handler = new MyHandler();
	///         watcher.EventArrived += new EventArrivedEventHandler(handler.Arrived);
	/// 
	///         //Start watching for events
	///         watcher.Start();
	/// 
	///         //For this example, we delete the class to trigger an event
	///         newClass.Delete();
	/// 
	///         //Nothing better to do - we loop to wait for an event to arrive.
	///         while (!handler.IsArrived) {
	///              System.Threading.Thread.Sleep(1000);
	///         }
	/// 
	///         //In this example we only want to wait for one event, so we can stop watching
	///         watcher.Stop();
	/// 
	///         return 0;
	///     }
	/// 
	///     public class MyHandler
	///     {
	///         private bool isArrived = false;
	///  
	///         //Handles the event when it arrives
	///         public void Arrived(object sender, EventArrivedEventArgs e) {
	///             ManagementBaseObject eventArg = (ManagementBaseObject)(e.NewEvent["TargetClass"]);
	///             Console.WriteLine("Class Deleted = " + eventArg["__CLASS"]);
	///             isArrived = true;
	///         }
	///  
	///          //Used to determine whether the event has arrived or not.
	///         public bool IsArrived {
	///             get {
	///                 return isArrived;
	///             }
	///         }
	///     }
	/// }
	///    </code>
	///    <code lang='VB'>Imports System
	/// Imports System.Management
	/// 
	/// ' This sample demonstrates how to subscribe an event
	/// ' using a WQL event query.
	/// 
	/// Class Sample_EventQuery
	///     Public Shared Sub Main()
	/// 
	///         'For this example, we make sure we have an arbitrary class on root\default
	///         Dim newClass As New ManagementClass( _
	///             "root\default", _
	///             String.Empty, Nothing)
	///             newClass("__Class") = "TestWql"
	///             newClass.Put()
	/// 
	///         'Create a query object for watching for class deletion events
	///         Dim eventQuery As New WqlEventQuery("select * from __classdeletionevent")
	/// 
	///         'Initialize an event watcher object with this query
	///         Dim watcher As New ManagementEventWatcher( _
	///             New ManagementScope("root/default"), _
	///             eventQuery)
	/// 
	///         'Set up a handler for incoming events
	///         Dim handler As New MyHandler()
	///         AddHandler watcher.EventArrived, AddressOf handler.Arrived
	///    
	///         'Start watching for events
	///         watcher.Start()
	/// 
	///         'For this example, we delete the class to trigger an event
	///         newClass.Delete()
	/// 
	///         'Nothing better to do - we loop to wait for an event to arrive.
	///         While Not handler.IsArrived
	///             Console.Write("0")
	///             System.Threading.Thread.Sleep(1000)
	///         End While
	/// 
	///         'In this example we only want to wait for one event, so we can stop watching
	///         watcher.Stop()
	/// 
	///     End Sub
	/// 
	///     Public Class MyHandler
	///         Private _isArrived As Boolean = False
	///  
	///         'Handles the event when it arrives
	///         Public Sub Arrived(sender As Object, e As EventArrivedEventArgs)
	///             Dim eventArg As ManagementBaseObject = CType( _
	///                 e.NewEvent("TargetClass"), _
	///                 ManagementBaseObject)
	///             Console.WriteLine(("Class Deleted = " + eventArg("__CLASS")))
	///             _isArrived = True
	///         End Sub
	/// 
	///         'Used to determine whether the event has arrived or not.
	///         Public ReadOnly Property IsArrived() As Boolean
	///             Get
	///                 Return _isArrived
	///             End Get
	///         End Property
	///     End Class
	/// End Class
	///    </code>
	/// </example>
	//CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC//
	public class WqlEventQuery : EventQuery
	{
		private static readonly string tokenSelectAll = "select * ";

		private string eventClassName;
		private TimeSpan withinInterval;
		private string condition;
		private TimeSpan groupWithinInterval;
		private StringCollection groupByPropertyList;
		private string havingCondition;

		//default constructor
		/// <overload>
		/// <para> Initializes a new instance of the <see cref='System.Management.WqlEventQuery'/> class.</para>
		/// </overload>
		/// <summary>
		/// <para>Initializes a new instance of the <see cref='System.Management.WqlEventQuery'/> 
		/// class. This is the default
		/// constructor.</para>
		/// </summary>
		public WqlEventQuery() : this(null, TimeSpan.Zero, null, TimeSpan.Zero, null, null) {}
        
		//parameterized constructors
		//ISSUE : We have 2 possible constructors that take a single string :
		//  one that takes the full query string and the other that takes the class name.
		//  We resolve this by trying to parse the string, if it succeeds we assume it's the query, if
		//  not we assume it's the class name.
		/// <summary>
		/// <para> Initializes a new instance of the <see cref='System.Management.WqlEventQuery'/> 
		/// class based on the given
		/// query string or event class name.</para>
		/// </summary>
		/// <param name='queryOrEventClassName'>The string representing either the entire event query or the name of the event class to query. The object will try to parse the string as a valid event query. If unsuccessful, the parser will assume that the parameter represents an event class name.</param>
		/// <example>
		///    <para>The two options below are equivalent :</para>
		///    <code lang='C#'>//Full query string specified to the constructor
		/// WqlEventQuery q = new WqlEventQuery("SELECT * FROM MyEvent");
		///    
		/// //Only relevant event class name specified to the constructor   
		/// WqlEventQuery q = new WqlEventQuery("MyEvent"); //results in the same query as above.
		///    </code>
		///    <code lang='VB'>'Full query string specified to the constructor
		/// Dim q As New WqlEventQuery("SELECT * FROM MyEvent")
		///    
		/// 'Only relevant event class name specified to the constructor   
		/// Dim q As New WqlEventQuery("MyEvent") 'results in the same query as above
		///    </code>
		/// </example>
		public WqlEventQuery(string queryOrEventClassName) 
		{
			groupByPropertyList = new StringCollection();

			if (null != queryOrEventClassName)
			{
				// Minimally determine if the string is a query or event class name.
				//
				if (queryOrEventClassName.TrimStart().ToLower(CultureInfo.InvariantCulture).StartsWith(tokenSelectAll))
				{
					QueryString = queryOrEventClassName;	// Parse/validate; may throw.
				}
				else
				{
					try 
					{
						// Do some basic sanity checking on whether it's a class name
						//
						ManagementPath p = new ManagementPath (queryOrEventClassName);

						if (p.IsClass && (String.Empty == p.NamespacePath))
						{
							EventClassName = queryOrEventClassName;
						}
						else
							throw new ArgumentException ();
					}
					catch (Exception)
					{
						throw new ArgumentException ();
					}
				}
			}
		}

		/// <summary>
		/// <para> Initializes a new instance of the <see cref='System.Management.WqlEventQuery'/> 
		/// class for the
		/// specified event class name, with the specified condition.</para>
		/// </summary>
		/// <param name='eventClassName'>The name of the event class to query.</param>
		/// <param name=' condition'>The condition to apply to events of the specified class.</param>
		/// <example>
		///    <para>This example shows how to create an event query that contains a condition in 
		///       addition to the event class :</para>
		///    <code lang='C#'>//Requests all "MyEvent" events where the event's properties
		/// //match the specified condition
		/// WqlEventQuery q = new WqlEventQuery("MyEvent", "FirstProp &lt; 20 and SecondProp = 'red'");
		///    </code>
		///    <code lang='VB'>'Requests all "MyEvent" events where the event's properties
		/// 'match the specified condition
		/// Dim q As New WqlEventQuery("MyEvent", "FirstProp &lt; 20 and SecondProp = 'red'")
		///    </code>
		/// </example>
		public WqlEventQuery(string eventClassName, string condition) : this(eventClassName, TimeSpan.Zero, condition, TimeSpan.Zero, null, null) {}

		/// <summary>
		/// <para> Initializes a new instance of the <see cref='System.Management.WqlEventQuery'/> 
		/// class for the specified
		/// event class, with the specified latency time.</para>
		/// </summary>
		/// <param name='eventClassName'>The name of the event class to query.</param>
		/// <param name=' withinInterval'>A timespan value specifying the latency acceptable for receiving this event. This value is used in cases where there is no explicit event provider for the query requested, and WMI is required to poll for the condition. This interval is the maximum amount of time that can pass before notification of an event must be delivered. </param>
		/// <example>
		///    <para>This example shows creating an event query that contains 
		///       a
		///       time interval.</para>
		///    <code lang='C#'>//Requests all instance creation events, with a specified latency of
		/// //10 seconds. The query created is "SELECT * FROM __InstanceCreationEvent WITHIN 10"
		/// WqlEventQuery q = new WqlEventQuery("__InstanceCreationEvent",
		///                                     new TimeSpan(0,0,10));
		///    </code>
		///    <code lang='VB'>'Requests all instance creation events, with a specified latency of
		/// '10 seconds. The query created is "SELECT * FROM __InstanceCreationEvent WITHIN 10"
		/// Dim t As New TimeSpan(0,0,10)
		/// Dim q As New WqlEventQuery("__InstanceCreationEvent", t)
		///    </code>
		/// </example>
		public WqlEventQuery(string eventClassName, TimeSpan withinInterval): 
										this(eventClassName, withinInterval, null, TimeSpan.Zero, null, null) {}
		/// <summary>
		/// <para> Initializes a new instance of the <see cref='System.Management.WqlEventQuery'/> 
		/// class with the specified
		/// event class name, polling interval, and condition.</para>
		/// </summary>
		/// <param name='eventClassName'>The name of the event class to query. </param>
		/// <param name=' withinInterval'>A timespan value specifying the latency acceptable for receiving this event. This value is used in cases where there is no explicit event provider for the query requested and WMI is required to poll for the condition. This interval is the maximum amount of time that can pass before notification of an event must be delivered. </param>
		/// <param name=' condition'>The condition to apply to events of the specified class.</param>
		/// <example>
		///    <para> This example creates the event query: "SELECT * FROM 
		///    <see langword='__InstanceCreationEvent '/>WITHIN 10 WHERE 
		///    <see langword='TargetInstance'/> ISA <see langword='Win32_Service'/>", which means 
		///       "send notification of the creation of <see langword='Win32_Service '/>
		///       instances,
		///       with a 10-second polling interval."</para>
		///    <code lang='C#'>//Requests notification of the creation of Win32_Service instances with a 10 second
		/// //allowed latency.
		/// WqlEventQuery q = new WqlEventQuery("__InstanceCreationEvent", 
		///                                     new TimeSpan(0,0,10), 
		///                                     "TargetInstance isa 'Win32_Service'");
		///    </code>
		///    <code lang='VB'>'Requests notification of the creation of Win32_Service instances with a 10 second
		/// 'allowed latency.
		/// Dim t As New TimeSpan(0,0,10)
		/// Dim q As New WqlEventQuery("__InstanceCreationEvent", _
		///                            t, _
		///                            "TargetInstance isa ""Win32_Service""")
		///    </code>
		/// </example>
		public WqlEventQuery(string eventClassName, TimeSpan withinInterval, string condition) : 
										this(eventClassName, withinInterval, condition, TimeSpan.Zero, null, null) {}

		/// <summary>
		/// <para> Initializes a new instance of the <see cref='System.Management.WqlEventQuery'/> 
		/// class with the specified
		/// event class name, condition, and grouping interval.</para>
		/// </summary>
		/// <param name='eventClassName'>The name of the event class to query. </param>
		/// <param name='condition'>The condition to apply to events of the specified class.</param>
		/// <param name=' groupWithinInterval'>The specified interval at which WMI sends one aggregate event, rather than many events.</param>
		/// <example>
		///    <para>This example creates the event query: "SELECT * FROM 
		///    <see langword='FrequentEvent'/> WHERE <see langword='InterestingProperty'/>= 5 
		///       GROUP WITHIN 10", which means "send notification of events of type
		///    <see langword='FrequentEvent'/>, in which the 
		///    <see langword='InterestingProperty'/> is equal to 5, but send an aggregate event in 
		///       a
		///       10-second interval."</para>
		///    <code lang='C#'>//Sends an aggregate of the requested events every 10 seconds
		/// WqlEventQuery q = new WqlEventQuery("FrequentEvent", 
		///                                     "InterestingProperty = 5", 
		///                                     new TimeSpan(0,0,10));
		///    </code>
		///    <code lang='VB'>'Sends an aggregate of the requested events every 10 seconds
		/// Dim t As New TimeSpan(0,0,10)
		/// Dim q As New WqlEventQuery("FrequentEvent", _
		///                            "InterestingProperty = 5", _
		///                            t)
		///    </code>
		/// </example>
		public WqlEventQuery(string eventClassName, string condition, TimeSpan groupWithinInterval) :
										this(eventClassName, TimeSpan.Zero, condition, groupWithinInterval, null, null) {}

		/// <summary>
		/// <para> Initializes a new instance of the <see cref='System.Management.WqlEventQuery'/> 
		/// class with the specified event class
		/// name, condition, grouping interval, and grouping properties.</para>
		/// </summary>
		/// <param name='eventClassName'>The name of the event class to query. </param>
		/// <param name='condition'>The condition to apply to events of the specified class.</param>
		/// <param name=' groupWithinInterval'>The specified interval at which WMI sends one aggregate event, rather than many events. </param>
		/// <param name=' groupByPropertyList'>The properties in the event class by which the events should be grouped.</param>
		/// <example>
		///    <para>This example creates the event query: "SELECT * FROM 
		///    <see langword='EmailEvent'/> WHERE <see langword='Sender'/> = 'MyBoss' GROUP 
		///       WITHIN 300 BY <see langword='Importance'/>", which means "send notification when
		///       new email from a particular sender has arrived within the last 10 minutes,
		///       combined with other events that have the same value in the
		///    <see langword='Importance'/> 
		///    property."</para>
		/// <code lang='C#'>//Requests "EmailEvent" events where the Sender property is "MyBoss", and 
		/// //groups them based on importance
		/// String[] props = {"Importance"};
		/// WqlEventQuery q = new WqlEventQuery("EmailEvent", 
		///                                     "Sender = 'MyBoss'", 
		///                                     new TimeSpan(0,10,0), 
		///                                     props);
		/// </code>
		/// <code lang='VB'>'Requests "EmailEvent" events where the Sender property is "MyBoss", and 
		/// 'groups them based on importance
		/// Dim props() As String = {"Importance"}
		/// Dim t As New TimeSpan(0,10,0)
		/// Dim q As New WqlEventQuery("EmailEvent", _
		///                            "Sender = ""MyBoss""", _
		///                            t, _
		///                            props)
		/// </code>
		/// </example>
		public WqlEventQuery(string eventClassName, string condition, TimeSpan groupWithinInterval, string[] groupByPropertyList) : 
			this(eventClassName, TimeSpan.Zero, condition, groupWithinInterval, groupByPropertyList, null) {}

		/// <summary>
		/// <para> Initializes a new instance of the <see cref='System.Management.WqlEventQuery'/> 
		/// class with the specified event class
		/// name, condition, grouping interval, grouping properties, and specified number of events.</para>
		/// </summary>
		/// <param name='eventClassName'>The name of the event class on which to be queried.</param>
		/// <param name='withinInterval'>A timespan value specifying the latency acceptable for receiving this event. This value is used in cases where there is no explicit event provider for the query requested, and WMI is required to poll for the condition. This interval is the maximum amount of time that can pass before notification of an event must be delivered.</param>
		/// <param name=' condition'>The condition to apply to events of the specified class.</param>
		/// <param name=' groupWithinInterval'>The specified interval at which WMI sends one aggregate event, rather than many events. </param>
		/// <param name=' groupByPropertyList'>The properties in the event class by which the events should be grouped.</param>
		/// <param name=' havingCondition'>The condition to apply to the number of events.</param>
		/// <example>
		///    <para>This example creates the event query: "SELECT * FROM 
		///    <see langword='__InstanceCreationEvent '/>WHERE <see langword='TargetInstance'/> 
		///    ISA <see langword='Win32_NTLogEvent '/>GROUP WITHIN 300 BY
		/// <see langword='TargetInstance.SourceName'/> HAVING 
		/// <see langword='NumberOfEvents'/> &gt; 15" which means "deliver aggregate events 
		///    only if the number of <see langword='Win32_NTLogEvent '/>events received from the
		///    same source exceeds 15."</para>
		/// <code lang='C#'>//Requests sending aggregated events if the number of events exceeds 15.
		/// String[] props = {"TargetInstance.SourceName"};
		/// WqlEventQuery q = new WqlEventQuery("__InstanceCreationEvent", 
		///                                     "TargetInstance isa 'Win32_NTLogEvent'", 
		///                                     new TimeSpan(0,10,0), 
		///                                     props, 
		///                                     "NumberOfEvents &gt;15");
		/// </code>
		/// <code lang='VB'>'Requests sending aggregated events if the number of events exceeds 15.
		/// Dim props() As String = {"TargetInstance.SourceName"};
		/// Dim t As New TimeSpan(0,10,0)
		/// Dim q As WqlEventQuery("__InstanceCreationEvent", _
		///                        "TargetInstance isa ""Win32_NTLogEvent""", _
		///                        t, _
		///                        props, _
		///                        "NumberOfEvents &gt;15")
		/// </code>
		/// </example>
		public WqlEventQuery(string eventClassName, TimeSpan withinInterval, string condition, TimeSpan groupWithinInterval, 
						  string[] groupByPropertyList, string havingCondition)
		{
			this.eventClassName = eventClassName;
			this.withinInterval = withinInterval;
			this.condition = condition;
			this.groupWithinInterval = groupWithinInterval;
			this.groupByPropertyList = new StringCollection ();

			if (null != groupByPropertyList)
				this.groupByPropertyList.AddRange (groupByPropertyList);
			
			this.havingCondition = havingCondition;
			BuildQuery();
		}

		
		//QueryLanguage property is read-only in this class (does this work ??)
		/// <summary>
		///    <para>Gets or sets the language of the query.</para>
		/// </summary>
		/// <value>
		///    <para>The value of this property in this
		///       object is always "WQL".</para>
		/// </value>
		public override string QueryLanguage
		{
			get 
			{return base.QueryLanguage;}
		}
		
		/// <summary>
		///    <para>Gets or sets the string representing the query.</para>
		/// </summary>
		/// <value>
		///    A string representing the query.
		/// </value>
		public override string QueryString
		{
			get 
			{
				// We need to force a rebuild as we may not have detected
				// a change to selected properties
				BuildQuery ();
				return base.QueryString;
			}
			set 
			{
				base.QueryString = value;
			}
		}
	
		/// <summary>
		///    <para> Gets or sets the event class to query.</para>
		/// </summary>
		/// <value>
		///    A string containing the name of the
		///    event class to query.
		/// </value>
		/// <remarks>
		///    <para> Setting this property value overrides any previous value 
		///       stored
		///       in the object. The query string is rebuilt to
		///       reflect the new class name.</para>
		/// </remarks>
		/// <example>
		/// <para>This example creates a new <see cref='System.Management.WqlEventQuery'/> 
		/// that represents the query: "SELECT * FROM <see langword='MyEvent'/> ".</para>
		/// <code lang='C#'>WqlEventQuery q = new WqlEventQuery();
		/// q.EventClassName = "MyEvent";
		/// </code>
		/// <code lang='VB'>Dim q As New WqlEventQuery()
		/// q.EventClassName = "MyEvent"
		/// </code>
		/// </example>
		public string EventClassName
		{
			get { return (null != eventClassName) ? eventClassName : String.Empty; }
			set { eventClassName = value; BuildQuery(); }
		}

		/// <summary>
		///    <para>Gets or sets the condition to be applied to events of the
		///       specified class.</para>
		/// </summary>
		/// <value>
		///    <para>The condition is represented as a
		///       string, containing one or more clauses of the form: &lt;propName&gt;
		///       &lt;operator&gt; &lt;value&gt; combined with and/or operators. &lt;propName&gt;
		///       must represent a property defined on the event class specified in this query.</para>
		/// </value>
		/// <remarks>
		///    <para>Setting this property value overrides any previous value 
		///       stored in the object. The query string is rebuilt to
		///       reflect the new condition.</para>
		/// </remarks>
		/// <example>
		/// <para>This example creates a new <see cref='System.Management.WqlEventQuery'/> 
		/// that represents the query: "SELECT * FROM <see langword='MyEvent'/> WHERE
		/// <see langword='PropVal'/> &gt; 8".</para>
		/// <code lang='C#'>WqlEventQuery q = new WqlEventQuery();
		/// q.EventClassName = "MyEvent";
		/// q.Condition = "PropVal &gt; 8";
		/// </code>
		/// <code lang='VB'>Dim q As New WqlEventQuery()
		/// q.EventClassName = "MyEvent"
		/// q.Condition = "PropVal &gt; 8"
		/// </code>
		/// </example>
		public string Condition 
		{
			get { return (null != condition) ? condition : String.Empty; }
			set { condition = value; BuildQuery(); }
		}

		/// <summary>
		///    <para>Gets or sets the polling interval to be used in this query.</para>
		/// </summary>
		/// <value>
		///    <para>Null, if there is no polling involved; otherwise, a 
		///       valid <see cref='System.TimeSpan'/>
		///       value if polling is required.</para>
		/// </value>
		/// <remarks>
		///    <para>This property should only be set in cases
		///       where there is no event provider for the event requested, and WMI is required to
		///       poll for the requested condition.</para>
		///    <para>Setting this property value overrides any previous value 
		///       stored in
		///       the object. The query string is rebuilt to reflect the new interval.</para>
		/// </remarks>
		/// <example>
		/// <para>This example creates a new <see cref='System.Management.WqlEventQuery'/> 
		/// that represents the query: "SELECT * FROM <see langword='__InstanceModificationEvent '/>WITHIN 10 WHERE <see langword='PropVal'/> &gt; 8".</para>
		/// <code lang='C#'>WqlEventQuery q = new WqlEventQuery();
		/// q.EventClassName = "__InstanceModificationEvent";
		/// q.Condition = "PropVal &gt; 8";
		/// q.WithinInterval = new TimeSpan(0,0,10);
		/// </code>
		/// <code lang='VB'>Dim q As New WqlEventQuery()
		/// q.EventClassName = "__InstanceModificationEvent"
		/// q.Condition = "PropVal &gt; 8"
		/// q.WithinInterval = New TimeSpan(0,0,10)
		/// </code>
		/// </example>
		public TimeSpan WithinInterval
		{
			get { return withinInterval; }
			set { withinInterval = value; BuildQuery(); }
		}

		/// <summary>
		///    <para>Gets or sets the interval to be used for grouping events of
		///       the same type.</para>
		/// </summary>
		/// <value>
		///    <para> Null, if there is no
		///       grouping involved; otherwise, the interval in which WMI should group events of
		///       the same type.</para>
		/// </value>
		/// <remarks>
		///    <para> Setting this property value overrides any previous value stored in 
		///       the object. The query string is rebuilt to reflect the new interval.</para>
		/// </remarks>
		/// <example>
		/// <para>This example creates a new <see cref='System.Management.WqlEventQuery'/> 
		/// that represents the query: "SELECT * FROM <see langword='MyEvent'/> WHERE
		/// <see langword='PropVal'/> &gt; 8 GROUP WITHIN 10", which means "send notification 
		/// of all <see langword='MyEvent'/> events where the <see langword='PropVal'/>
		/// property is greater than 8, and aggregate these events within 10-second intervals."</para>
		/// <code lang='C#'>WqlEventQuery q = new WqlEventQuery();
		/// q.EventClassName = "MyEvent";
		/// q.Condition = "PropVal &gt; 8";
		/// q.GroupWithinInterval = new TimeSpan(0,0,10);
		/// </code>
		/// <code lang='VB'>Dim q As New WqlEventQuery()
		/// q.EventClassName = "MyEvent"
		/// q.Condition = "PropVal &gt; 8"
		/// q.GroupWithinInterval = New TimeSpan(0,0,10)
		/// </code>
		/// </example>
		public TimeSpan GroupWithinInterval
		{
			get { return groupWithinInterval; }
			set { groupWithinInterval = value; BuildQuery(); }
		}

		/// <summary>
		///    <para>Gets or sets properties in the event to be used for
		///       grouping events of the same type.</para>
		/// </summary>
		/// <value>
		///    <para> 
		///       Null, if no grouping is required; otherwise, a collection of event
		///       property names.</para>
		/// </value>
		/// <remarks>
		///    <para> Setting this property value overrides any previous value stored in 
		///       the object. The query string is rebuilt to reflect the new grouping.</para>
		/// </remarks>
		/// <example>
		/// <para>This example creates a new <see cref='System.Management.WqlEventQuery'/> 
		/// that represents the query: "SELECT * FROM <see langword='EmailEvent'/> GROUP
		/// WITHIN 300 BY <see langword='Sender'/>", which means "send notification of all
		/// <see langword='EmailEvent'/> events, aggregated by the <see langword='Sender'/>property, within 10-minute intervals."</para>
		/// <code lang='C#'>WqlEventQuery q = new WqlEventQuery();
		/// q.EventClassName = "EmailEvent";
		/// q.GroupWithinInterval = new TimeSpan(0,10,0);
		/// q.GroupByPropertyList = new StringCollection();
		/// q.GroupByPropertyList.Add("Sender");
		/// </code>
		/// <code lang='VB'>Dim q As New WqlEventQuery()
		/// q.EventClassName = "EmailEvent"
		/// q.GroupWithinInterval = New TimeSpan(0,10,0)
		/// q.GroupByPropertyList = New StringCollection()
		/// q.GroupByPropertyList.Add("Sender")
		/// </code>
		/// </example>
		public StringCollection GroupByPropertyList
		{
			get { return groupByPropertyList; }
			set { 
				// A tad painful since StringCollection doesn't support ICloneable
				StringCollection src = (StringCollection)value;
				StringCollection dst = new StringCollection ();

				foreach (String s in src)
					dst.Add (s);
					
				groupByPropertyList = dst; 
				BuildQuery();
			}
		}

		/// <summary>
		///    <para>Gets or sets the condition to be applied to the aggregation of
		///       events, based on the number of events received.</para>
		/// </summary>
		/// <value>
		///    <para> 
		///       Null, if no aggregation or no condition should be applied;
		///       otherwise, a condition of the form "NumberOfEvents &lt;operator&gt;
		///       &lt;value&gt;".</para>
		/// </value>
		/// <remarks>
		///    <para> Setting this property value overrides any previous value stored in
		///       the object. The query string is rebuilt to reflect the new grouping condition.</para>
		/// </remarks>
		/// <example>
		/// <para>This example creates a new <see cref='System.Management.WqlEventQuery'/> 
		/// that represents the query: "SELECT * FROM <see langword='EmailEvent'/> GROUP
		/// WITHIN 300 HAVING <see langword='NumberOfEvents'/> &gt; 5", which means "send
		/// notification of all <see langword='EmailEvent'/> events, aggregated within
		/// 10-minute intervals, if there are more than 5 occurrences."</para>
		/// <code lang='C#'>WqlEventQuery q = new WqlEventQuery();
		/// q.EventClassName = "EmailEvent";
		/// q.GroupWithinInterval = new TimeSpan(0,10,0);
		/// q.HavingCondition = "NumberOfEvents &gt; 5";
		/// </code>
		/// <code lang='VB'>Dim q As New WqlEventQuery()
		/// q.EventClassName = "EmailEvent"
		/// q.GroupWithinInterval = new TimeSpan(0,10,0)
		/// q.HavingCondition = "NumberOfEvents &gt; 5"
		/// </code>
		/// </example>
		public string HavingCondition
		{
			get { return (null != havingCondition) ? havingCondition : String.Empty; }
			set { havingCondition = value; BuildQuery(); }
		}

		
		/// <summary>
		///  Builds the query string according to the current property values.
		/// </summary>
		protected internal void BuildQuery()
		{
			//If the event class name is not set we can't build a query
			//This shouldn't throw because the user may be in the process of setting properties...
			if ((eventClassName == null) || (eventClassName == String.Empty))
			{
				SetQueryString (String.Empty);
				return;
			}

			//Select clause
			string s = tokenSelectAll;	//no property list allowed here...

			//From clause
			s = s + "from " + eventClassName;

			//Within clause
			if (withinInterval != TimeSpan.Zero)
				s = s + " within " + withinInterval.TotalSeconds.ToString();

			//Where clause
			if (!Condition.Equals(String.Empty))
				s = s + " where " + condition;

			//Group within clause
			if (groupWithinInterval != TimeSpan.Zero)
			{
				s = s + " group within " + groupWithinInterval.TotalSeconds.ToString();

				//Group By clause
				if ((null != groupByPropertyList) && (0 < groupByPropertyList.Count))
				{
					int count = groupByPropertyList.Count;
					s = s + " by ";

					for (int i=0; i<count; i++)
						s = s + groupByPropertyList[i] + (i == (count - 1) ? "" : ",");
				}

				//Having clause
				if (!HavingCondition.Equals(String.Empty))
				{
					s = s + " having " + havingCondition;
				}
			}

			//Set the queryString member to the built query (NB: note we set
			//by accessing the internal helper function rather than the property,
			//since we do not want to force a parse of a query we just built).
			SetQueryString (s);

		}//BuildQuery

		//TODO : Need to solidify this parsing....
		/// <summary>
		///  Parses the query string and sets the property values accordingly.
		/// </summary>
		/// <param name="query">The query string to be parsed.</param>
		protected internal override void ParseQuery(string query)
		{
			//Clear out previous property values
			eventClassName = null;
			withinInterval = TimeSpan.Zero;
			condition = null;
			groupWithinInterval = TimeSpan.Zero;
			if (groupByPropertyList != null)
				groupByPropertyList.Clear();
			havingCondition = null;
			
			//Trim whitespaces
			string q = query.Trim(); 
			int i; 
			string w, tempProp;
			bool bFound = false;

            //Find "select" clause and make sure it's a select *
			string keyword = tokenSelect;
			if ((q.Length < keyword.Length) || (0 != String.Compare (q, 0, keyword, 0, keyword.Length, true,CultureInfo.InvariantCulture)))
				throw new ArgumentException();
			q =	q.Remove(0, keyword.Length).TrimStart(null);

			if (!q.StartsWith("*")) 
					throw new ArgumentException();
			q = q.Remove(0, 1).TrimStart(null);

			//Find "from" clause
			keyword = "from ";
			if ((q.Length < keyword.Length) || (0 != String.Compare (q, 0, keyword, 0, keyword.Length, true,CultureInfo.InvariantCulture)))
				throw new ArgumentException();
			ParseToken(ref q, keyword, null, ref bFound, ref eventClassName);

			//Find "within" clause
			keyword = "within ";
			if ((q.Length >= keyword.Length) && (0 == String.Compare (q, 0, keyword, 0, keyword.Length, true,CultureInfo.InvariantCulture))) 
			{
				string intervalString = null; bFound = false;
				ParseToken(ref q, keyword, null, ref bFound, ref intervalString);
				withinInterval = TimeSpan.FromSeconds(((IConvertible)intervalString).ToDouble(null));
			}
            
			//Find "group within" clause
			keyword = "group within ";
			if ((q.Length >= keyword.Length) && ((i = q.ToLower(CultureInfo.InvariantCulture).IndexOf(keyword)) != -1)) //found
			{
				//Separate the part of the string before this - that should be the "where" clause
				w = q.Substring(0, i).Trim();
				q = q.Remove(0, i);

				string intervalString = null; bFound=false;
				ParseToken(ref q, keyword, null, ref bFound, ref intervalString);
				groupWithinInterval = TimeSpan.FromSeconds(((IConvertible)intervalString).ToDouble(null));

				//Find "By" subclause
				keyword = "by ";
				if ((q.Length >= keyword.Length) && (0 == String.Compare (q, 0, keyword, 0, keyword.Length, true,CultureInfo.InvariantCulture)))
				{
					q = q.Remove(0, keyword.Length);
					if (null != groupByPropertyList)
						groupByPropertyList.Clear ();
					else
						groupByPropertyList = new StringCollection ();

					//get the property list
					while (true)
					{
						if ((i = q.IndexOf(',')) > 0)
						{
							tempProp = q.Substring(0, i);
							q = q.Remove(0, i+1).TrimStart(null);
							tempProp = tempProp.Trim();
							if (tempProp != String.Empty)
								groupByPropertyList.Add(tempProp);
						}
						else
						{ //last property in the list
							if ((i = q.IndexOf(' ')) > 0)
							{
								tempProp = q.Substring(0, i);
								q = q.Remove(0, i).TrimStart(null);
								groupByPropertyList.Add(tempProp);
								break;
							}
							else //end of the query
							{
								groupByPropertyList.Add(q);
								return;
							}
						}
					} //while
				} //by

				//Find "Having" subclause
				keyword = "having "; bFound = false;
				if ((q.Length >= keyword.Length) && (0 == String.Compare (q, 0, keyword, 0, keyword.Length, true,CultureInfo.InvariantCulture)))
				{   //the rest until the end is assumed to be the having condition
					q = q.Remove(0, keyword.Length);
					
					if (q.Length == 0) //bad query
						throw new ArgumentException();

					havingCondition = q;
				}
			}
			else
				//No "group within" then everything should be the "where" clause
				w = q.Trim();

			//Find "where" clause
			keyword = "where ";
			if ((w.Length >= keyword.Length) && (0 == String.Compare (w, 0, keyword, 0, keyword.Length, true,CultureInfo.InvariantCulture))) //where clause exists
			{
				condition = w.Substring(keyword.Length);				
			}

		}//ParseQuery()


		//ICloneable
		/// <summary>
		///    <para>Creates a copy of the object.</para>
		/// </summary>
		/// <returns>
		///    The copied object.
		/// </returns>
		public override object Clone()
		{
			string[] strArray = null;

			if (null != groupByPropertyList)
			{
				int count = groupByPropertyList.Count;

				if (0 < count)
				{
					strArray = new String [count];
					groupByPropertyList.CopyTo (strArray, 0);
				}
			}

			return new WqlEventQuery(eventClassName, withinInterval, condition, groupWithinInterval, 
																			strArray, havingCondition);
		}

	}//WqlEventQuery


	/// <summary>
	/// Converts a String to a ManagementQuery
	/// </summary>
	class ManagementQueryConverter : ExpandableObjectConverter 
	{
        
		/// <summary>
		/// Determines if this converter can convert an object in the given source type to the native type of the converter. 
		/// </summary>
		/// <param name='context'>An ITypeDescriptorContext that provides a format context.</param>
		/// <param name='sourceType'>A Type that represents the type you wish to convert from.</param>
		/// <returns>
		///    <para>true if this converter can perform the conversion; otherwise, false.</para>
		/// </returns>
		public override Boolean CanConvertFrom(ITypeDescriptorContext context, Type sourceType) 
		{
			if ((sourceType == typeof(ManagementQuery))) 
			{
				return true;
			}
			return base.CanConvertFrom(context,sourceType);
		}
        
		/// <summary>
		/// Gets a value indicating whether this converter can convert an object to the given destination type using the context.
		/// </summary>
		/// <param name='context'>An ITypeDescriptorContext that provides a format context.</param>
		/// <param name='destinationType'>A Type that represents the type you wish to convert to.</param>
		/// <returns>
		///    <para>true if this converter can perform the conversion; otherwise, false.</para>
		/// </returns>
		public override Boolean CanConvertTo(ITypeDescriptorContext context, Type destinationType) 
		{
			if ((destinationType == typeof(InstanceDescriptor))) 
			{
				return true;
			}
			return base.CanConvertTo(context,destinationType);
		}
        
		/// <summary>
		///      Converts the given object to another type.  The most common types to convert
		///      are to and from a string object.  The default implementation will make a call
		///      to ToString on the object if the object is valid and if the destination
		///      type is string.  If this cannot convert to the desitnation type, this will
		///      throw a NotSupportedException.
		/// </summary>
		/// <param name='context'>An ITypeDescriptorContext that provides a format context.</param>
		/// <param name='culture'>A CultureInfo object. If a null reference (Nothing in Visual Basic) is passed, the current culture is assumed.</param>
		/// <param name='value'>The Object to convert.</param>
		/// <param name='destinationType'>The Type to convert the value parameter to.</param>
		/// <returns>An Object that represents the converted value.</returns>
		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) 
		{

			if (destinationType == null) 
			{
				throw new ArgumentNullException("destinationType");
			}

			if (value is EventQuery && destinationType == typeof(InstanceDescriptor)) 
			{
				EventQuery obj = ((EventQuery)(value));
				ConstructorInfo ctor = typeof(EventQuery).GetConstructor(new Type[] {typeof(System.String)});
				if (ctor != null) 
				{
					return new InstanceDescriptor(ctor, new object[] {obj.QueryString});
				}
			}			
		
			if (value is ObjectQuery && destinationType == typeof(InstanceDescriptor)) 
			{
				ObjectQuery obj = ((ObjectQuery)(value));
				ConstructorInfo ctor = typeof(ObjectQuery).GetConstructor(new Type[] {typeof(System.String)});
				if (ctor != null) 
				{
					return new InstanceDescriptor(ctor, new object[] {obj.QueryString});
				}
			}
			return base.ConvertTo(context,culture,value,destinationType);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\instrumentation\codespit.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

namespace System.Management.Instrumentation
{
    using System;
    using System.IO;
    using System.Collections;
    using System.Collections.Specialized;

    class CodeWriter
    {
        int depth;
        ArrayList children = new ArrayList();

        public static explicit operator String(CodeWriter writer)
        {
            return writer.ToString();
        }

        public override string ToString()
        {
            StringWriter writer = new StringWriter();
            WriteCode(writer);
            return writer.ToString();
        }

        void WriteCode(TextWriter writer)
        {
            string prefix = new String(' ', depth*4);
            foreach(Object child in children)
            {
                if(null == child)
                {
                    writer.WriteLine();
                }
                else if(child is string)
                {
                    writer.Write(prefix);
                    writer.WriteLine(child);
                }
                else
                    ((CodeWriter)child).WriteCode(writer);
            }
        }

        public CodeWriter AddChild(string name)
        {
            Line(name);
            Line("{");
            CodeWriter child =  new CodeWriter();
            child.depth = depth+1;
            children.Add(child);
            Line("}");
            return child;
        }

        public CodeWriter AddChild(params string[] parts)
        {
            return AddChild(String.Concat(parts));
        }

        public CodeWriter AddChildNoIndent(string name)
        {
            Line(name);
            CodeWriter child =  new CodeWriter();
            child.depth = depth+1;
            children.Add(child);
            return child;
        }

        public CodeWriter AddChild(CodeWriter snippet)
        {
            snippet.depth = depth;
            children.Add(snippet);
            return snippet;
        }
        public void Line(string line)
        {
            children.Add(line);
        }
        public void Line(params string[] parts)
        {
            Line(String.Concat(parts));
        }
        public void Line()
        {
            children.Add(null);
        }
    }

    class ReferencesCollection
    {
        StringCollection namespaces = new StringCollection();
        public StringCollection Namespaces { get { return namespaces; } }

        StringCollection assemblies = new StringCollection();
        public StringCollection Assemblies { get { return assemblies; } }

        CodeWriter usingCode = new CodeWriter();
        public CodeWriter UsingCode { get {return usingCode; } }

        public void Add(Type type)
        {
            if(!namespaces.Contains(type.Namespace))
            {
                namespaces.Add(type.Namespace);
                usingCode.Line(String.Format("using {0};", type.Namespace));
            }
            if(!assemblies.Contains(type.Assembly.Location))
                assemblies.Add(type.Assembly.Location);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\wmieventsink.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//#define USETLBIMP
//#define USEIWOS

using System;
using WbemClient_v1;
using System.Runtime.InteropServices;
using System.Diagnostics;
using System.Threading;
#if USETLBIMP
using WMISECLib;
#endif

namespace System.Management
{

#if USETLBIMP
internal class WmiEventSink : WMISECLib.IWmiEventSource
#elif USEIWOS
internal class WmiEventSink : IWbemObjectSink
#else
internal class WmiEventSink : IWmiEventSource
#endif
{
	private static int						s_hash = 0;
	private int								hash;
	private ManagementOperationObserver		watcher;
	private object							context;
	private ManagementScope					scope;
	private object							stub;			// The secured IWbemObjectSink

	// Used for Put's only
	internal event InternalObjectPutEventHandler  InternalObjectPut;
	private ManagementPath					path;			
	private string							className;


    static ManagementOperationObserver watcherParameter;
    static object contextParameter; 
    static ManagementScope scopeParameter;
    static string pathParameter;
    static string classNameParameter;
    static WmiEventSink wmiEventSinkNew;

    internal static WmiEventSink GetWmiEventSink(
        ManagementOperationObserver watcher,
        object context, 
        ManagementScope scope,
        string path,
        string className)
    {
        if(MTAHelper.IsNoContextMTA()) // Bug#110141 - Checking for MTA is not enough.  We need to make sure we are not in a COM+ Context
            return new WmiEventSink(watcher, context, scope, path, className);

        watcherParameter = watcher;
        contextParameter = context;
        scopeParameter = scope;
        pathParameter = path;
        classNameParameter = className;

		//
		// [marioh, RAID: 111108]
		// Ensure we are able to trap exceptions from worker thread.
		//
		ThreadDispatch disp = new ThreadDispatch ( new ThreadDispatch.ThreadWorkerMethod ( HackToCreateWmiEventSink ) ) ;
		disp.Start ( ) ;

//        Thread thread = new Thread(new ThreadStart(HackToCreateWmiEventSink));
//        thread.Start(); // TODO: What if this throws an exception
//        thread.Join();
		return wmiEventSinkNew;
    }

    static void HackToCreateWmiEventSink()
    {
        wmiEventSinkNew = new WmiEventSink(watcherParameter, contextParameter, scopeParameter, pathParameter, classNameParameter);
    }

	protected WmiEventSink (ManagementOperationObserver watcher,
						 object context, 
						 ManagementScope scope,
						 string path,
						 string className)
	{
		try {
			this.context = context;
			this.watcher = watcher;
			this.className = className;

			if (null != path)
				this.path = new ManagementPath (path);

			if (null != scope)
				this.scope = (ManagementScope) scope.Clone ();
#if USETLBIMP
			WMISECLib.WmiSinkDemultiplexor sinkDmux = new WMISECLib.WmiSinkDemultiplexor ();
			sinkDmux.GetDemultiplexedStub (this, ref m_stub);
#elif USEIWOS 
			IUnsecuredApartment unsecApp = new UnsecuredApartment ();
			unsecApp.CreateObjectStub (this, ref m_stub);
#else
            IWmiSinkDemultiplexor sinkDmux = (IWmiSinkDemultiplexor) new WmiSinkDemultiplexor ();
			sinkDmux.GetDemultiplexedStub (this, out stub);
#endif
			hash = Threading.Interlocked.Increment(ref s_hash);
		} catch {}
	}

	public override int GetHashCode () {
		return hash;
	}

	public IWbemObjectSink Stub { 
		get { 			
			try {
				return (null != stub) ? (IWbemObjectSink) stub : null; 
			} catch {
				return null;
			}
		}
	}

#if USEIWOS
	public virtual void Indicate (long lNumObjects, IWbemClassObject [] objArray)
	{
		try {
			for (long i = 0; i < lNumObjects; i++) {
				ObjectReadyEventArgs args = new ObjectReadyEventArgs (m_context, 
					new WmiObject(m_services, objArray[i]));
				watcher.FireObjectReady (args);
			}
		} catch {}
	}
#else
	public virtual void Indicate (IntPtr pIWbemClassObject)
	{
        Marshal.AddRef(pIWbemClassObject);
        IWbemClassObjectFreeThreaded obj = new IWbemClassObjectFreeThreaded(pIWbemClassObject);
		try {
			ObjectReadyEventArgs args = new ObjectReadyEventArgs (context, 
										ManagementBaseObject.GetBaseObject (obj, scope));
			watcher.FireObjectReady (args); 
		} catch {}
	}
#endif

	public void SetStatus (
#if USEIWOS
					long flags,
#else
					int flags, 
#endif
					int hResult, 
					String message, 
					IntPtr pErrorObj)
	{
        IWbemClassObjectFreeThreaded errObj = null;
        if(pErrorObj != IntPtr.Zero)
        {
            Marshal.AddRef(pErrorObj);
            errObj = new IWbemClassObjectFreeThreaded(pErrorObj);
        }

		try {
			if (flags == (int) tag_WBEM_STATUS_TYPE.WBEM_STATUS_COMPLETE)
			{
				// Is this a Put? If so fire the ObjectPut event
				if (null != path)
				{
					if (null == className)
						path.RelativePath = message;
					else
						path.RelativePath = className;

					// Fire the internal event (if anyone is interested)
					if (null != InternalObjectPut)
					{
						try {
							InternalObjectPutEventArgs iargs = new InternalObjectPutEventArgs (path);
							InternalObjectPut (this, iargs);
						} catch {}
					}

					ObjectPutEventArgs args = new ObjectPutEventArgs (context, path);
					watcher.FireObjectPut(args);
				}

				// Fire Completed event
				CompletedEventArgs args2 = new CompletedEventArgs (context, hResult, 
												new ManagementBaseObject (errObj));
				watcher.FireCompleted (args2);
				
				// Unhook and tidy up
				watcher.RemoveSink (this);
			}
			else if (0 != (flags & (int) tag_WBEM_STATUS_TYPE.WBEM_STATUS_PROGRESS))
			{
				// Fire Progress event
				ProgressEventArgs args = new ProgressEventArgs (context, 
					(int) (((uint)hResult & 0xFFFF0000) >> 16), hResult & 0xFFFF, message);

				watcher.FireProgress (args);
			}
		} catch {}
	}

	internal void Cancel () 
	{
		// BUGBUG : Throw exception on failure?
		try {
			scope.GetIWbemServices().CancelAsyncCall_((IWbemObjectSink) stub);
		} catch {}		
	}

	internal void ReleaseStub ()
	{
		try {
			/*
			 * We force a release of the stub here so as to allow
			 * unsecapp.exe to die as soon as possible.
			 */
			if (null != stub)
			{
				System.Runtime.InteropServices.Marshal.ReleaseComObject(stub);
				stub = null;
			}
		} catch {}
	}

}

// Special sink implementation for ManagementObject.Get
// Doesn't issue ObjectReady events
internal class WmiGetEventSink : WmiEventSink
{
	private ManagementObject	managementObject;

    static ManagementOperationObserver watcherParameter;
    static object contextParameter; 
    static ManagementScope scopeParameter;
    static ManagementObject managementObjectParameter;

    static WmiGetEventSink wmiGetEventSinkNew;

    internal static WmiGetEventSink GetWmiGetEventSink(
        ManagementOperationObserver watcher,
        object context, 
        ManagementScope scope,
        ManagementObject managementObject)
    {
        if(MTAHelper.IsNoContextMTA()) // Bug#110141 - Checking for MTA is not enough.  We need to make sure we are not in a COM+ Context
            return new WmiGetEventSink(watcher, context, scope, managementObject);

        watcherParameter = watcher;
        contextParameter = context;
        scopeParameter = scope;
        managementObjectParameter = managementObject;

		//
		// [marioh, RAID: 111108]
		// Ensure we are able to trap exceptions from worker thread.
		//
		ThreadDispatch disp = new ThreadDispatch ( new ThreadDispatch.ThreadWorkerMethod ( HackToCreateWmiGetEventSink ) ) ;
		disp.Start ( ) ;

//		Thread thread = new Thread(new ThreadStart(HackToCreateWmiGetEventSink));
//        thread.Start(); // TODO: What if this throws an exception
//        thread.Join();
		return wmiGetEventSinkNew;
    }

    static void HackToCreateWmiGetEventSink()
    {
        wmiGetEventSinkNew = new WmiGetEventSink(watcherParameter, contextParameter, scopeParameter, managementObjectParameter);
    }


	private WmiGetEventSink (ManagementOperationObserver watcher,
						 object context, 
						 ManagementScope scope,
						 ManagementObject managementObject) :
		base (watcher, context, scope, null, null)
	{
		this.managementObject = managementObject;
	}

#if USEIWOS
	public override void Indicate (long lNumObjects, IWbemClassObject [] objArray)
	{
		try {
			for (long i = 0; i < lNumObjects; i++) {
				if (null != managementObject)
					managementObject.WmiObject = objArray[i];
			}
		} catch () {}
	}
#else
	public override void Indicate (IntPtr pIWbemClassObject)
	{
        Marshal.AddRef(pIWbemClassObject);
		IWbemClassObjectFreeThreaded obj = new IWbemClassObjectFreeThreaded(pIWbemClassObject);
		if (null != managementObject)
		{
			try {
				managementObject.wbemObject = obj;
			} catch {}
		}
	}
#endif

}



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\generator\wmigenerator\wmigenerator.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Management
{
using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.IO;
using System.Reflection;
using System.Management;
using System.Collections;
using Microsoft.CSharp;
using Microsoft.VisualBasic;
using Microsoft.JScript;
using System.Globalization;


/// <summary>
/// 	<para>Defines the languages supported by the code generator.</para>
/// </summary>
public enum CodeLanguage
{
	/// <summary>
	///    A value for generating C# code.
	/// </summary>
	CSharp,
	/// <summary>
	///    <para>A value for generating JScript code.</para>
	/// </summary>
	JScript,
	/// <summary>
	///    <para>A value for generating Visual Basic code.</para>
	/// </summary>
	VB
};



/// <summary>
///    Used to generate a strongly-typed code class for a given WMI class.
/// </summary>
internal class ManagementClassGenerator
{
	private string	OriginalServer		= string.Empty;
	private string	OriginalNamespace	= string.Empty;
	private string	OriginalClassName	= string.Empty;
	private string	OriginalPath		= string.Empty;
	private bool	bSingletonClass		= false;
	private	bool	bUnsignedSupported	= true;
//	private bool	bValueMapInt64		= false;
	private string	NETNamespace		= string.Empty;
	private string arrConvFuncName = string.Empty;
	private string enumType		= string.Empty;
	private const	int		DMTF_DATETIME_STR_LENGTH = 25;
	private	bool	bDateConversionFunctionsAdded = false;
	private	bool	bTimeSpanConversionFunctionsAdded = false;




	private ManagementClass classobj;
	private ICodeGenerator cg;
	private TextWriter tw = null;
	private string genFileName = string.Empty;
	private CodeTypeDeclaration cc;
	private CodeTypeDeclaration ccc;
	private CodeTypeDeclaration ecc;
	private CodeTypeDeclaration EnumObj;
	private CodeNamespace cn;
	private CodeMemberProperty  cmp;
	private CodeConstructor cctor;
	private CodeMemberField cf;
	private CodeObjectCreateExpression coce;
	private CodeSnippetExpression cle;
	private CodeParameterDeclarationExpression cpde;
	private CodeIndexerExpression cie;
	private CodeMemberField cmf;
	private CodeMemberMethod cmm;
	private CodePropertyReferenceExpression cpre;
	private CodeMethodInvokeExpression cmie;
	private CodeExpressionStatement cmis;
	private CodeConditionStatement cis;
	private CodeBinaryOperatorExpression cboe;
	private CodeIterationStatement cfls;
	private CodeAttributeArgument caa;
	private CodeAttributeDeclaration cad;
	private ConnectionOptions		cop;
	

	private ArrayList arrKeyType	= new ArrayList(5);
	private ArrayList arrKeys		= new ArrayList(5);
	private ArrayList BitMap		= new ArrayList(5);
	private ArrayList BitValues		= new ArrayList(5);
	private ArrayList ValueMap		= new ArrayList(5);
	private ArrayList Values		= new ArrayList(5);

	private SortedList PublicProperties = new SortedList(new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
	private SortedList PublicMethods	= new SortedList (new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
	private SortedList PublicNamesUsed	= new SortedList(new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
	private SortedList PrivateNamesUsed = new SortedList(new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
	
	private ArrayList CommentsString = new ArrayList(5);
	private bool		bHasEmbeddedProperties = false;

	const int IDS_COMMENT_SHOULDSERIALIZE		= 0;
	const int IDS_COMMENT_ISPROPNULL			= 1;
	const int IDS_COMMENT_RESETPROP				= 2;
	const int IDS_COMMENT_ATTRIBPROP			= 3;
	const int IDS_COMMENT_DATECONVFUNC			= 4;
	const int IDS_COMMENT_GETINSTANCES			= 5;
	const int IDS_COMMENT_CLASSBEGIN			= 6;
	const int IDS_COMMENT_PRIV_AUTOCOMMIT		= 7;
	const int IDS_COMMENT_CONSTRUCTORS			= 8;
	const int IDS_COMMENT_ORIG_NAMESPACE		= 9;
	const int IDS_COMMENT_CLASSNAME				= 10;
	const int IDS_COMMENT_SYSOBJECT				= 11;
	const int IDS_COMMENT_LATEBOUNDOBJ			= 12;
	const int IDS_COMMENT_MGMTSCOPE				= 13;
	const int IDS_COMMENT_AUTOCOMMITPROP		= 14;
	const int IDS_COMMENT_MGMTPATH				= 15;
	const int IDS_COMMENT_PROP_TYPECONVERTER	= 16;
	const int IDS_COMMENT_SYSPROPCLASS			= 17;
	const int IDS_COMMENT_ENUMIMPL				= 18;
	const int IDS_COMMENT_LATEBOUNDPROP			= 19;
	const int IDS_COMMENTS_CREATEDCLASS			= 20;
	const int IDS_COMMENT_EMBEDDEDOBJ			= 21;
	const int IDS_COMMENT_CURRENTOBJ			= 22;
	const int IDS_COMMENT_FLAGFOREMBEDDED		= 23;
	

	/// <summary>
	///    <para>Creates an empty generator object. This is the default constructor.</para>
	/// </summary>
	public ManagementClassGenerator()
	{
	}

	/// <summary>
	///    <para>Creates a generator object and initializes it
	///     with the specified <see cref="System.Management.ManagementClass"/>.</para>
	/// </summary>
	/// <param name='cls'><see cref="System.Management.ManagementClass"/> object for which the code is to be generated.</param>
	public ManagementClassGenerator(ManagementClass cls)
	{
		classobj = cls;
	}

	/// <summary>
	///    <para> 
	///       Returns a <see cref="System.CodeDom.CodeTypeDeclaration"/> for
	///       this class.</para>
	/// </summary>
	/// <param name='includeSystemProperties'>Indicates if a class for handling system properties should be included.</param>
	/// <param name='systemPropertyClass'>Indicates if the generated code is for a class that handles system properties.</param>
	/// <returns>
	///    <para>Returns the <see cref="System.CodeDom.CodeTypeDeclaration"/> for the WMI class.</para>
	/// </returns>
	/// <remarks>
	///    <para>If includeSystemProperties is <see langword="true"/>, 
	///       the ManagementSystemProperties class is included in the generated class definition.
	///       This parameter is ignored if systemPropertyClass is <see langword="true"/>.</para>
	/// </remarks>
	public CodeTypeDeclaration GenerateCode(bool includeSystemProperties ,bool systemPropertyClass)
	{
		CodeTypeDeclaration retType;

		if (systemPropertyClass == true)
		{
			//Initialize the public attributes . private variables
			InitilializePublicPrivateMembers();
			retType = GenerateSystemPropertiesClass();
		}
		else
		{
			CheckIfClassIsProperlyInitialized();
			InitializeCodeGeneration();
			retType = GetCodeTypeDeclarationForClass(includeSystemProperties);
		}

		return retType;
	}

	/// <summary>
	/// Generates a strongly-typed code class for the specified language provider (C#, Visual Basic or JScript)
	/// and writes it to the specified file.
	/// </summary>
	/// <param name="lang">The language to generate in.</param>
	/// <param name="FilePath">The path to the file where the generated code should be stored.</param>
	/// <param name="Namespace">The .NET namespace into which the class is generated.</param>
	public bool GenerateCode(CodeLanguage lang ,String filePath,String netNamespace)
	{
		// check for proper arguments
		if (filePath == null )
		{
			throw new ArgumentOutOfRangeException (GetString("NULLFILEPATH_EXCEPT"));
		}

		if (filePath == string.Empty)
		{
			throw new ArgumentOutOfRangeException (GetString("EMPTY_FILEPATH_EXCEPT"));
		}

		NETNamespace = netNamespace;
		CheckIfClassIsProperlyInitialized();
		// Initialize Code Generator
		InitializeCodeGeneration();

		//Now create the filestream (output file)
		tw = new StreamWriter(new FileStream (filePath,FileMode.Create),System.Text.Encoding.UTF8);

		return GenerateAndWriteCode(lang);

	}

	/// <summary>
	/// Checks if mandatory properties are properly initialized.
	/// </summary>
	void CheckIfClassIsProperlyInitialized()
	{
		if (classobj == null)
		{
			if (OriginalNamespace == null || ( OriginalNamespace != null && OriginalNamespace == string.Empty))
			{
				throw new ArgumentOutOfRangeException (GetString("NAMESPACE_NOTINIT_EXCEPT"));  
			}
		
			if (OriginalClassName == null || ( OriginalClassName != null && OriginalClassName == string.Empty))
			{
				throw new ArgumentOutOfRangeException (GetString("CLASSNAME_NOTINIT_EXCEPT"));
			}
		}
	}
	private void InitializeCodeGeneration()
	{

		//First try to get the class object for the given WMI Class.
		//If we cannot get it then there is no point in continuing 
		//as we won't have any information for the code generation.
		InitializeClassObject();

		//Initialize the public attributes . private variables
		InitilializePublicPrivateMembers();

		//First form the namespace for the generated class.
		//The namespace will look like System.Wmi.Root.Cimv2.Win32
		//for the path \\root\cimv2:Win32_Service and the class name will be
		//Service.
		ProcessNamespaceAndClassName();

		//First we will sort out the different naming collision that might occur 
		//in the generated code.
		ProcessNamingCollisions();
	}

	/// <summary>
	/// This function will generate the code. This is the function which 
	/// should be called for generating the code.
	/// </summary>
	/// <param name="bIncludeSystemClassinClassDef"> 
	/// Flag to indicate if system properties are to be included or not
	/// </param>
	private CodeTypeDeclaration GetCodeTypeDeclarationForClass(bool bIncludeSystemClassinClassDef)
	{
		try
		{
			//Create type defination for the class
			cc = new CodeTypeDeclaration (PrivateNamesUsed["GeneratedClassName"].ToString());
			// Adding Component as base class so as to enable drag and drop
			cc.BaseTypes.Add(new CodeTypeReference(PrivateNamesUsed["ComponentClass"].ToString()));


			AddClassComments(cc);
			//Generate the code for defaultNamespace
			//public string defNamespace {
			//	get {
			//			return (<defNamespace>);
			//		}
			//}
			GeneratePublicReadOnlyProperty(PublicNamesUsed["NamespaceProperty"].ToString(),"System.String",
				OriginalNamespace,false,true,GetString("COMMENT_ORIGNAMESPACE"));

			/*
					Generate the following code for className 
					[Browsable(true)]
					[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
					public string ManagementClassName {
						get {
							string strRet = CreatedClassName;
							if (((PrivateLateBoundObject != null) 
										&& (PrivateLateBoundObject.Path != null))) {
								strRet = ((string)(PrivateLateBoundObject["__CLASS"]));
								if (((strRet == null) 
											|| (strRet == System.String.Empty))) {
									strRet = CreatedClassName;
								}
							}
							return strRet;
						}
					}
			*/


			// Add a private member variable to hold the namespace of the created class
			// Generate a private member variable for storing the generated class Name
			GeneratePrivateMember(PrivateNamesUsed["CreationWmiNamespace"].ToString(),"System.String",
				new CodePrimitiveExpression(OriginalNamespace),true,GetString("COMMENT_CREATEDWMINAMESPACE"));

			GenerateClassNameProperty();

			// Generate a private member variable for storing the generated class Name
			GeneratePrivateMember(PrivateNamesUsed["CreationClassName"].ToString(),"System.String",
									new CodePrimitiveExpression(OriginalClassName),true,GetString("COMMENT_CREATEDCLASS"));

			//public SystemPropertiesClass _SystemProps{
			//	get {
			//			return (privSysProps);
			//		}
			//}
			GeneratePublicReadOnlyProperty(PublicNamesUsed["SystemPropertiesProperty"].ToString(),PublicNamesUsed["SystemPropertiesClass"].ToString(),
				PrivateNamesUsed["SystemPropertiesObject"].ToString(),true,true,
				GetString("COMMENT_SYSOBJECT"));

			//public wmiObjectClass _Object{
			//	get {
			//			return (privWmiObject);
			//		}
			//}
			GeneratePublicReadOnlyProperty(PublicNamesUsed["LateBoundObjectProperty"].ToString(),PublicNamesUsed["BaseObjClass"].ToString(),
				PrivateNamesUsed["CurrentObject"].ToString(),true,false,
				GetString("COMMENT_LATEBOUNDPROP"));

			//public ManagementScope Scope {
			//	get {
			//			return privScope;
			//		}
			//	set {
			//			privScope = value;
			//		}
			//}

			GenerateScopeProperty();
/*			GeneratePublicProperty(PublicNamesUsed["ScopeProperty"].ToString(),PublicNamesUsed["ScopeClass"].ToString(),
				new CodePropertyReferenceExpression(
				new CodeSnippetExpression(PrivateNamesUsed["LateBoundObject"].ToString())
				,"Scope"),true,GetString("COMMENT_MGMTSCOPE"),false);
*/

			//public bool AutoCommit {
			//	get {
			//			return AutoCommitProp;;
			//		}
			//	set {
			//			AutoCommitProp; = value;
			//		}
			//}

			GeneratePublicProperty(PublicNamesUsed["AutoCommitProperty"].ToString(),"System.Boolean",
				new CodeSnippetExpression(PrivateNamesUsed["AutoCommitProperty"].ToString()),false,
				GetString("COMMENT_AUTOCOMMITPROP"),false);

			//public ManagementPath Path {
			//	get {
			//			return privWmiObject.Path;
			//		}
			//	set {
			//			if (String.Compare(value.ClassName,className,true,CultureInfo.InvariantCulture) != 0)
			//				throw new ArgumentException("Class name doesn\'t match.");
			//			privWmiObject.Path = value;
			//		}
			//}
			GeneratePathProperty();
			
			// Adding a private member for storing the ManagementScope to be used by various static methods
			GeneratePrivateMember(PrivateNamesUsed["statMgmtScope"].ToString(),PublicNamesUsed["ScopeClass"].ToString(),
				new CodePrimitiveExpression(null),true,GetString("COMMENT_STATICMANAGEMENTSCOPE"));

			// Generate a property "StaticScope" to set and get the static ManagementScope for the class
			GeneratePublicProperty(PrivateNamesUsed["staticScope"].ToString(),PublicNamesUsed["ScopeClass"].ToString(),
							new CodeVariableReferenceExpression(PrivateNamesUsed["statMgmtScope"].ToString()),true,	GetString("COMMENT_STATICSCOPEPROPERTY"),true);

			// Generate a function to check if a given class can be represented 
			// by the generated class
			GenerateIfClassvalidFunction();

			//Now generate properties of the WMI Class
			GenerateProperties();

			//Now Generate static ConstructPath()
			GenerateConstructPath();
		
			//Now create the default constructor
			GenerateDefaultConstructor();

			if (bSingletonClass == true)
			{
				//Now Generate a constructor which accepts only the scope
				GenerateConstructorWithScope();

				//Now Generate a constructor which accepts only the get options
				GenerateConstructorWithOptions();

				//Now generate a constructor which accepts both scope and options
				GenerateConstructorWithScopeOptions();
			}
			else
			{
				//Now create the constuctor which accepts the key values
				GenerateConstructorWithKeys();

				//Also generate a constructor which accepts a scope and keys
				GenerateConstructorWithScopeKeys();

				//Now generate constructor with Path & Options
				GenerateConstructorWithPathOptions();

				//Now Generate a constructor with scope & path
				GenerateConstructorWithScopePath();

				//Now Generate the GetInstances()
				GenerateGetInstancesWithNoParameters();

				//Now Generate the GetInstances(condition)
				GenerateGetInstancesWithCondition();

				//Now Generate the GetInstances(propertylist)
				GenerateGetInstancesWithProperties();

				//Now Generate the GetInstances(condition,propertylist)
				GenerateGetInstancesWithWhereProperties();

				//Now Generate the GetInstances(scope)
				GenerateGetInstancesWithScope();

				//Now Generate the GetInstances(scope,condition)
				GenerateGetInstancesWithScopeCondition();

				//Now Generate the GetInstances(scope,propertylist)
				GenerateGetInstancesWithScopeProperties();

				//Now Generate the GetInstances(scope,condition,propertylist)
				GenerateGetInstancesWithScopeWhereProperties();

				//Generate the Collection Class
				GenerateCollectionClass();
			}

			//Now create constructor with path object
			GenerateConstructorWithPath();

			//Now Generate the constructor with path,scope,options
			GenerateConstructorWithScopePathOptions();

			//Now generate Constructor with latebound Object
			GenarateConstructorWithLateBound();

			//Now generate Constructor with latebound Object
			// and the object is an embedded object
			GenarateConstructorWithLateBoundForEmbedded();

			// Generate static CreateInstance() to create instance of the class
			GenerateCreateInstance();

			// Generate static DeleteInstance() to delete instance
			GenerateDeleteInstance();

			//Now Enumerate all the methods
			GenerateMethods();

			//Now declare the private class variables
			//private Wmi_SystemProps SystemProps
			GeneratePrivateMember(PrivateNamesUsed["SystemPropertiesObject"].ToString(),PublicNamesUsed["SystemPropertiesClass"].ToString(),null);

			//private WmiObject privObject
			GeneratePrivateMember(PrivateNamesUsed["LateBoundObject"].ToString(),PublicNamesUsed["LateBoundClass"].ToString(),GetString("COMMENT_LATEBOUNDOBJ"));

			//private Internal AutoCommitProperty
			GeneratePrivateMember(PrivateNamesUsed["AutoCommitProperty"].ToString(),"System.Boolean" ,new CodePrimitiveExpression(true),false,GetString("COMMENT_PRIVAUTOCOMMIT"));

			//private WmiObject Embedded object
			GeneratePrivateMember(PrivateNamesUsed["EmbeddedObject"].ToString(),PublicNamesUsed["BaseObjClass"].ToString(),GetString("COMMENT_EMBEDDEDOBJ"));

			//private WmiObject for current object used
			GeneratePrivateMember(PrivateNamesUsed["CurrentObject"].ToString(),PublicNamesUsed["BaseObjClass"].ToString(),GetString("COMMENT_CURRENTOBJ"));

			//private WmiObject for current object used
			GeneratePrivateMember(PrivateNamesUsed["IsEmbedded"].ToString(),"System.Boolean",new CodePrimitiveExpression(false),false,GetString("COMMENT_FLAGFOREMBEDDED"));

			//Now generate the Type Converter class also
			cc.Members.Add(GenerateTypeConverterClass());

			if (bIncludeSystemClassinClassDef)
			{
				cc.Members.Add(GenerateSystemPropertiesClass());
			}
			
			if(bHasEmbeddedProperties)
			{
				AddCommentsForEmbeddedProperties();
			}
			// Added at the end so that this comment is the last comment just before declaring the class
			cc.Comments.Add(new CodeCommentStatement(GetString("COMMENT_CLASSBEGIN") + 
													OriginalClassName));
			return cc;
		}
		catch (Exception exc)
		{
			throw (exc);
		}
	}

	bool GenerateAndWriteCode(CodeLanguage lang)
	{

		if (InitializeCodeGenerator(lang) == false)
		{
			return false;
		}

		//Now Initialize the code class for generation
		InitializeCodeTypeDeclaration(lang);

		// Call this function to create CodeTypeDeclaration for the WMI class
		GetCodeTypeDeclarationForClass(true);

		//As we have finished the class definition, generate the class code NOW!!!!!
		cn.Types.Add (cc);

		//throw new Exception("about to call GenerateCodeFromNamespace");

		cg.GenerateCodeFromNamespace (cn, tw, new CodeGeneratorOptions());

		//tw.Flush();
		tw.Close();

		return true;

	}

	/// <summary>
	/// Function for initializing the class object that will be used to get all the 
	/// method and properties of the WMI Class for generating the code.
	/// </summary>
	private void InitializeClassObject()
	{
		//First try to connect to WMI and get the class object.
		// If it fails then no point in continuing
		try
		{
			// If object is not initialized by the constructor
			if (classobj == null)
			{
				ManagementPath thePath;
				if (OriginalPath != string.Empty)
				{
					thePath = new ManagementPath(OriginalPath);
					//				classobj = new ManagementClass (OriginalPath);
				}
				else
				{
					thePath = new ManagementPath();
					if (OriginalServer != String.Empty)
						thePath.Server = OriginalServer;
					thePath.ClassName = OriginalClassName;
					thePath.NamespacePath = OriginalNamespace;
					//				classobj = new ManagementClass (thePath);

					/*
					throw new Exception("OriginalServer is " + OriginalServer +
						" OriginalNamespace is " + OriginalNamespace +
						" OriginalClassName is " + OriginalClassName +
						" results in " + thePath.Path);
						*/
				}

				if (cop != null && cop.Username != string.Empty)
				{
					ManagementScope MgScope = new ManagementScope(thePath,cop);
					classobj = new ManagementClass(MgScope,thePath,null);
				}
				else
				{
					classobj = new ManagementClass (thePath);
				}
			}
			else
			{
				// Get the common properties
				ManagementPath thePath = classobj.Path;
				OriginalServer = thePath.Server;
				OriginalClassName = thePath.ClassName;
				OriginalNamespace = thePath.NamespacePath;

				char[] arrString = OriginalNamespace.ToCharArray();

				// Remove the server from the namespace
				if (arrString.Length >= 2 && arrString[0] == '\\' && arrString[1] == '\\')
				{
					bool bStart = false;
					int Len = OriginalNamespace.Length;
					OriginalNamespace = string.Empty;
					for (int i = 2 ; i < Len ; i++)
					{
						if (bStart == true)
						{
							OriginalNamespace = OriginalNamespace + arrString[i];
						}
						else
							if (arrString[i] == '\\')
						{
							bStart = true;
						}
					}
				}

			}
			//throw new Exception("classobj's path is " + classobj.Path.Path);				
		
			try
			{
				classobj.Get();
			}
			catch(ManagementException)
			{
				throw ;
			}
			//By default all classes are non-singleton(???)
			bSingletonClass = false;			
			foreach (QualifierData q in classobj.Qualifiers)
			{
				if (String.Compare(q.Name,"singleton",true,CultureInfo.InvariantCulture) == 0)
				{
					//This is a singleton class
					bSingletonClass = true;
					break;
				}
			}
		}
		catch(Exception e)
		{
			//TODO: Decide what to do here???????
			//Console.WriteLine("Exception Occured on Create.Reason [{0}]\n\nStack Trace : \n{1}",e.Message,e.StackTrace);
			throw e;
		}
	}
	/// <summary>
	/// This functrion initializes the public attributes and private variables 
	/// list that will be used in the generated code. 
	/// </summary>
	void InitilializePublicPrivateMembers()
	{
		//Initialize the public members
		PublicNamesUsed.Add("SystemPropertiesProperty","SystemProperties");
		PublicNamesUsed.Add("LateBoundObjectProperty","LateBoundObject");
		PublicNamesUsed.Add("NamespaceProperty","OriginatingNamespace");
		PublicNamesUsed.Add("ClassNameProperty","ManagementClassName");
		PublicNamesUsed.Add("ScopeProperty","Scope");
		PublicNamesUsed.Add("PathProperty","Path");
		PublicNamesUsed.Add("SystemPropertiesClass","ManagementSystemProperties");
		PublicNamesUsed.Add("LateBoundClass","System.Management.ManagementObject");
		PublicNamesUsed.Add("PathClass","System.Management.ManagementPath");
		PublicNamesUsed.Add("ScopeClass","System.Management.ManagementScope");
		PublicNamesUsed.Add("QueryOptionsClass","System.Management.EnumerationOptions");
		PublicNamesUsed.Add("GetOptionsClass","System.Management.ObjectGetOptions");
		PublicNamesUsed.Add("ArgumentExceptionClass","System.ArgumentException");
		PublicNamesUsed.Add("QueryClass","SelectQuery");
		PublicNamesUsed.Add("ObjectSearcherClass","System.Management.ManagementObjectSearcher");
		PublicNamesUsed.Add("FilterFunction","GetInstances");
		PublicNamesUsed.Add("ConstructPathFunction","ConstructPath");
		PublicNamesUsed.Add("TypeConverter","TypeConverter");
		PublicNamesUsed.Add("AutoCommitProperty","AutoCommit");
		PublicNamesUsed.Add("CommitMethod","CommitObject");
		PublicNamesUsed.Add("ManagementClass","System.Management.ManagementClass");
		PublicNamesUsed.Add("NotSupportedExceptClass","System.NotSupportedException");
		PublicNamesUsed.Add("BaseObjClass","System.Management.ManagementBaseObject");
		PublicNamesUsed.Add("OptionsProp","Options");		
		PublicNamesUsed.Add("ClassPathProperty","ClassPath");
/*		PublicNamesUsed.Add("DateConverter","ManagementDateTimeConverter");
		PublicNamesUsed.Add("ToDateTimeMethod","ToDateTime");
		PublicNamesUsed.Add("ToDMTFDateTimeMethod" , "ToDmtfDateTime");
		PublicNamesUsed.Add("ToDMTFTimeInterval" , "ToDmtfTimeInterval");
		PublicNamesUsed.Add("ToTimeSpan" , "ToTimeSpan");
*/		PublicNamesUsed.Add("CreateInst","CreateInstance");
		PublicNamesUsed.Add("DeleteInst","Delete");
		// Adding this so that the namespace resolving routine does not name
		// any properties with the name "System"
		PublicNamesUsed.Add("SystemNameSpace","System");
		PublicNamesUsed.Add("ArgumentOutOfRangeException","System.ArgumentOutOfRangeException");

		//Initialize the Private Members
		PrivateNamesUsed.Add("SystemPropertiesObject","PrivateSystemProperties");	
		PrivateNamesUsed.Add("LateBoundObject","PrivateLateBoundObject");			
		PrivateNamesUsed.Add("AutoCommitProperty","AutoCommitProp");
		PrivateNamesUsed.Add("Privileges","EnablePrivileges");
		PrivateNamesUsed.Add("ComponentClass","System.ComponentModel.Component");
		PrivateNamesUsed.Add("ScopeParam","mgmtScope");
		PrivateNamesUsed.Add("NullRefExcep","System.NullReferenceException");
		PrivateNamesUsed.Add("ConverterClass","WMIValueTypeConverter");		
		PrivateNamesUsed.Add("EnumParam","enumOptions");
		PrivateNamesUsed.Add("CreationClassName" , "CreatedClassName");
		PrivateNamesUsed.Add("CreationWmiNamespace" , "CreatedWmiNamespace");
		PrivateNamesUsed.Add("ClassNameCheckFunc","CheckIfProperClass");
		PrivateNamesUsed.Add("EmbeddedObject","embeddedObj");
		PrivateNamesUsed.Add("CurrentObject","curObj");
		PrivateNamesUsed.Add("IsEmbedded","isEmbedded");
		PrivateNamesUsed.Add("ToDateTimeMethod","ToDateTime");
		PrivateNamesUsed.Add("ToDMTFDateTimeMethod" , "ToDmtfDateTime");
		PrivateNamesUsed.Add("ToDMTFTimeIntervalMethod" , "ToDmtfTimeInterval");
		PrivateNamesUsed.Add("ToTimeSpanMethod" , "ToTimeSpan");
		PrivateNamesUsed.Add("SetMgmtScope" , "SetStaticManagementScope");
		PrivateNamesUsed.Add("statMgmtScope" , "statMgmtScope");
		PrivateNamesUsed.Add("staticScope" , "StaticScope");
		
	
	}

	/// <summary>
	/// This function will solve the naming collisions that might occur
	/// due to the collision between the local objects of the generated
	/// class and the properties/methos of the original WMI Class.
	/// </summary>
	void ProcessNamingCollisions()
	{
		if (classobj.Properties != null)
		{
			foreach(PropertyData prop in classobj.Properties)
			{
				PublicProperties.Add(prop.Name,prop.Name);
			}
		}

		if (classobj.Methods != null)
		{
			foreach(MethodData meth in classobj.Methods)
			{
				PublicMethods.Add(meth.Name,meth.Name);
			}
		}

		int nIndex;

		//Process the collisions here
		//We will check each public names with the property names here.
		foreach(String s in PublicNamesUsed.Values)
		{
			nIndex = IsContainedIn(s,ref PublicProperties);
			if ( nIndex != -1)
			{
				//We had found a collision with a public property
				//So we will resolve the collision by changing the property name 
				//and continue
				PublicProperties.SetByIndex(nIndex,ResolveCollision(s,false));
				continue;
			}
		
			nIndex = IsContainedIn(s,ref PublicMethods);
			if (nIndex != -1)
			{
				//We had found a collision with a public method
				//So we will resolve the collision by changing the method name 
				//and continue
				PublicMethods.SetByIndex(nIndex,ResolveCollision(s,false));
				continue;
			}
		}

		//Now we will check for collision against private variables
		foreach(String s in PublicProperties.Values)
		{
			nIndex = IsContainedIn(s,ref PrivateNamesUsed);
			if (nIndex != -1)
			{
				//We had found a collision with a public property
				//So we will resolve the collision by changing the private name 
				//and continue
				PrivateNamesUsed.SetByIndex(nIndex,ResolveCollision(s,false));
			}
		}
	
		foreach(String s in PublicMethods.Values)
		{
			nIndex = IsContainedIn(s,ref PrivateNamesUsed);
			if (nIndex != -1)
			{
				//We had found a collision with a public method
				//So we will resolve the collision by changing the private name 
				//and continue
				PrivateNamesUsed.SetByIndex(nIndex,ResolveCollision(s,false));
			}
		}

		//Now we will create the CollectionClass and Enumerator Class names as they are dependent on the
		//generated class name and the generated class name might have changed due to collision
		string strTemp = PrivateNamesUsed["GeneratedClassName"].ToString()+"Collection";
		PrivateNamesUsed.Add("CollectionClass",ResolveCollision(strTemp,true));

		strTemp = PrivateNamesUsed["GeneratedClassName"].ToString()+"Enumerator";
		PrivateNamesUsed.Add("EnumeratorClass",ResolveCollision(strTemp,true));
	}

	/// <summary>
	/// This function is used to resolve (actually generate a new name) collision
	/// between the generated class properties/variables with WMI methods/properties.
	/// This function safely assumes that there will be atleast one string left 
	/// in the series prop0, prop1 ...prop(maxInt) . Otherwise this function will
	/// enter an infinite loop. May be we can avoid this through something, which 
	/// i will think about it later
	/// </summary>
	/// <param name="inString"> </param>
	/// <param name="bCheckthisFirst"></param> 
	private String ResolveCollision(string inString,bool bCheckthisFirst)
	{
		string strTemp = inString;
		bool bCollision = true;
		int k = -1;
		if (bCheckthisFirst == false)
		{
			k++;
			strTemp = strTemp + k.ToString();
		}

		while(bCollision == true)
		{
			if (IsContainedIn(strTemp,ref PublicProperties) == -1)
			{
				if (IsContainedIn(strTemp,ref PublicMethods) == -1)
				{
					if (IsContainedIn(strTemp,ref PublicNamesUsed) == -1)
					{
						if (IsContainedIn(strTemp,ref PrivateNamesUsed) == -1)
						{
							//So this is not colliding with anything.
							bCollision = false;
							break;
						}
					}
				}
			}
		
			k++;
			strTemp = strTemp + k.ToString();
		}
		return strTemp;
	}

	/// <summary>
	/// This function processes the WMI namespace and WMI classname and converts them to
	/// the namespace used to generate the class and the classname.
	/// </summary>
	private void ProcessNamespaceAndClassName()
	{
		string strClass = string.Empty;
		string strNs = string.Empty;

		// if Namespace is not alread set then construct the namespace
		if (NETNamespace == String.Empty)
		{
			strNs = OriginalNamespace;
			strNs = strNs.Replace ('\\','.');
			//			strNs = "System.Management." + strNs;
			strNs = strNs.ToUpper(CultureInfo.InvariantCulture);
		}
		else
		{
			strNs = NETNamespace;
		}

		if (OriginalClassName.IndexOf('_') > 0)
		{
			strClass = OriginalClassName.Substring(0,OriginalClassName.IndexOf('_'));
			// if Namespace is not alread set then construct the namespace
			if (NETNamespace == String.Empty)
			{
				strNs += ".";
				strNs += strClass;
			}
			//Now trim the class name without the first '_'
			strClass = OriginalClassName.Substring(OriginalClassName.IndexOf('_')+1);
		}
		else
		{
			strClass = OriginalClassName;
		}

		PrivateNamesUsed.Add("GeneratedClassName",strClass);
		PrivateNamesUsed.Add("GeneratedNamespace",strNs);
		//		PrivateNamesUsed.Add("ConverterClass",strClass+"Converter");
	}



	private void InitializeCodeTypeDeclaration(CodeLanguage lang)
	{
		//Comment statement //Early Bound Managed Code Wrapper for WMI class <WMiClass>  
		//ccs = new CodeCommentStatement (String.Format ("Early Bound Managed Code Wrapper for WMI class {0}",OriginalClassName));
		//cg.GenerateCodeFromStatement (ccs, tw, new CodeGeneratorOptions());

		//Now add the import statements
		cn = new CodeNamespace(PrivateNamesUsed["GeneratedNamespace"].ToString());
		cn.Imports.Add (new CodeNamespaceImport("System"));
		cn.Imports.Add (new CodeNamespaceImport("System.ComponentModel"));
		cn.Imports.Add (new CodeNamespaceImport("System.Management"));
		cn.Imports.Add(new CodeNamespaceImport("System.Collections"));
		cn.Imports.Add(new CodeNamespaceImport("System.Globalization"));
		
		if(lang == CodeLanguage.VB)
		{
			cn.Imports.Add(new CodeNamespaceImport("Microsoft.VisualBasic"));
		}

	}
	/// <summary>
	/// This function generates the code for the read only property.
	/// The generated code will be of the form
	///		public &lt;propType&gt; &lt;propName&gt;{
	///			get {
	///					return (&lt;propValue&gt;);
	///				}
	///		}
	/// </summary>
	/// <param name="propName"> </param>
	/// <param name="propType"> </param>
	/// <param name="propValue"> </param>
	/// <param name="isLiteral"></param>
	/// <param name="isBrowsable"></param>
	/// <param name="Comment"></param>
	private void GeneratePublicReadOnlyProperty(string propName, string propType, object propValue,bool isLiteral,bool isBrowsable,string Comment)
	{
		cmp = new CodeMemberProperty ();
		cmp.Name = propName;
		cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final ;
		cmp.Type = new CodeTypeReference(propType);

		caa = new CodeAttributeArgument();
		caa.Value = new CodePrimitiveExpression(isBrowsable);
		cad = new CodeAttributeDeclaration();
		cad.Name = "Browsable";
		cad.Arguments.Add(caa);
		cmp.CustomAttributes = new CodeAttributeDeclarationCollection();
		cmp.CustomAttributes.Add(cad);

		caa = new CodeAttributeArgument();
		caa.Value = new CodeSnippetExpression("DesignerSerializationVisibility.Hidden");
		cad = new CodeAttributeDeclaration();
		cad.Name = "DesignerSerializationVisibility";
		cad.Arguments.Add(caa);
		cmp.CustomAttributes.Add(cad);

		if (isLiteral == true)
		{
			cmp.GetStatements.Add (new CodeMethodReturnStatement (new CodeSnippetExpression(propValue.ToString())));
		}
		else
		{
			cmp.GetStatements.Add (new CodeMethodReturnStatement (new CodePrimitiveExpression(propValue)));
		}
		cc.Members.Add (cmp);
		if(Comment != null && Comment != String.Empty )
		{
			cmp.Comments.Add(new CodeCommentStatement(Comment));
		}
	}

	private void GeneratePublicProperty(string propName,string propType, CodeExpression Value,bool isBrowsable,string Comment,bool isStatic)
	{
		cmp = new CodeMemberProperty();
		cmp.Name = propName;
		cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmp.Type = new CodeTypeReference(propType);

		if(isStatic)
		{
			cmp.Attributes = cmp.Attributes | MemberAttributes.Static;
		}
		
		caa = new CodeAttributeArgument();
		caa.Value = new CodePrimitiveExpression(isBrowsable);
		cad = new CodeAttributeDeclaration();
		cad.Name = "Browsable";
		cad.Arguments.Add(caa);
		cmp.CustomAttributes = new CodeAttributeDeclarationCollection();
		cmp.CustomAttributes.Add(cad);

		// If the property is not Path then add an attribb DesignerSerializationVisibility
		// to indicate that the property is to be hidden for designer serilization.
		if (IsDesignerSerializationVisibilityToBeSet(propName))
		{
			caa = new CodeAttributeArgument();
			caa.Value = new CodeSnippetExpression("DesignerSerializationVisibility.Hidden");
			cad = new CodeAttributeDeclaration();
			cad.Name = "DesignerSerializationVisibility";
			cad.Arguments.Add(caa);
			cmp.CustomAttributes.Add(cad);
		}

		cmp.GetStatements.Add(new CodeMethodReturnStatement(Value));

		cmp.SetStatements.Add(new CodeAssignStatement(Value,
			new CodeSnippetExpression("value")));
		cc.Members.Add(cmp);

		if(Comment != null && Comment != String.Empty)
		{
			cmp.Comments.Add(new CodeCommentStatement(Comment));
		}
	}

	void GeneratePathProperty()
	{
		cmp = new CodeMemberProperty();
		cmp.Name = PublicNamesUsed["PathProperty"].ToString();
		cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmp.Type = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());

		caa = new CodeAttributeArgument();
		caa.Value = new CodePrimitiveExpression(true);
		cad = new CodeAttributeDeclaration();
		cad.Name = "Browsable";
		cad.Arguments.Add(caa);
		cmp.CustomAttributes = new CodeAttributeDeclarationCollection();
		cmp.CustomAttributes.Add(cad);

		cpre = new CodePropertyReferenceExpression(new CodeSnippetExpression(
			PrivateNamesUsed["LateBoundObject"].ToString()),
			"Path");

		cis = new CodeConditionStatement();
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeVariableReferenceExpression(PrivateNamesUsed["IsEmbedded"].ToString());
		cboe.Right = new CodePrimitiveExpression(false);
		cboe.Operator = CodeBinaryOperatorType.ValueEquality;
		cis.Condition = cboe;

		cis.TrueStatements.Add(new CodeMethodReturnStatement(cpre));
		cis.FalseStatements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(null)));
		cmp.GetStatements.Add(cis);

		
		
		cis = new CodeConditionStatement();
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeVariableReferenceExpression(PrivateNamesUsed["IsEmbedded"].ToString());
		cboe.Right = new CodePrimitiveExpression(false);
		cboe.Operator = CodeBinaryOperatorType.ValueEquality;
		cis.Condition = cboe;

		CodeConditionStatement cis1 = new CodeConditionStatement();
		cmie = new CodeMethodInvokeExpression();
		cmie.Method.MethodName = PrivateNamesUsed["ClassNameCheckFunc"].ToString();
					

		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmie.Parameters.Add(new CodeVariableReferenceExpression("value"));
		cmie.Parameters.Add(new CodePrimitiveExpression(null));

		CodeBinaryOperatorExpression cboe1 = new CodeBinaryOperatorExpression();
		cboe1.Left = cmie;
		cboe1.Right = new CodePrimitiveExpression(true);
		cboe1.Operator = CodeBinaryOperatorType.IdentityInequality;
		cis1.Condition = cboe1;
		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["ArgumentExceptionClass"].ToString());
		coce.Parameters.Add(new CodePrimitiveExpression(GetString("CLASSNOT_FOUND_EXCEPT"))); 
		cis1.TrueStatements.Add(new CodeThrowExceptionStatement(coce));
		cis.TrueStatements.Add(cis1);


		cis.TrueStatements.Add(new CodeAssignStatement(cpre,
								new CodeSnippetExpression("value")));

		cmp.SetStatements.Add(cis);
		cc.Members.Add(cmp);

		cmp.Comments.Add(new CodeCommentStatement(GetString("COMMENT_MGMTPATH")));
	}

	/// <summary>
	/// Function for generating the helper class "ManagementSystemProperties" which is 
	/// used for seperating the system properties from the other properties. This is used 
	/// just to make the drop down list in the editor to look good.
	/// </summary>
	CodeTypeDeclaration GenerateSystemPropertiesClass()
	{
		CodeTypeDeclaration SysPropsClass = new CodeTypeDeclaration(PublicNamesUsed["SystemPropertiesClass"].ToString());
		SysPropsClass.TypeAttributes =TypeAttributes.NestedPublic;

		//First create the constructor
		//	public ManagementSystemProperties(ManagementObject obj)

		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cpde = new CodeParameterDeclarationExpression();
		cpde.Type = new CodeTypeReference(PublicNamesUsed["BaseObjClass"].ToString());
		cpde.Name = "ManagedObject";
		cctor.Parameters.Add(cpde);
		cctor.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(PrivateNamesUsed["LateBoundObject"].ToString()),new CodeSnippetExpression("ManagedObject")));
		SysPropsClass.Members.Add(cctor);

		caa = new CodeAttributeArgument();
		caa.Value = new CodeTypeOfExpression (typeof(System.ComponentModel.ExpandableObjectConverter)) ;
		cad = new CodeAttributeDeclaration();
		cad.Name = PublicNamesUsed["TypeConverter"].ToString();
		cad.Arguments.Add(caa);
		SysPropsClass.CustomAttributes.Add(cad);

		char [] strPropTemp;
		char [] strPropName;
		int i = 0;

		foreach (PropertyData prop in classobj.SystemProperties)
		{
			cmp = new CodeMemberProperty ();
			//All properties are browsable by default.
			caa = new CodeAttributeArgument();
			caa.Value = new CodePrimitiveExpression(true);
			cad = new CodeAttributeDeclaration();
			cad.Name = "Browsable";
			cad.Arguments.Add(caa);
			cmp.CustomAttributes = new CodeAttributeDeclarationCollection();
			cmp.CustomAttributes.Add(cad);

			//Now we will have to find the occurance of the first character and trim all the characters before that
			strPropTemp = prop.Name.ToCharArray();
			for(i=0;i < strPropTemp.Length;i++)
			{
				if (Char.IsLetterOrDigit(strPropTemp[i]) == true)
				{
					break;
				}
			}
			if (i == strPropTemp.Length)
			{
				i = 0;
			}
			strPropName = new char[strPropTemp.Length - i];
			for(int j=i;j < strPropTemp.Length;j++)
			{
				strPropName[j - i] = strPropTemp[j];
			}
                        		
			cmp.Name = (new string(strPropName)).ToUpper(CultureInfo.InvariantCulture); //ConvertToTitleCase(new string(strPropName));
			cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
			cmp.Type = ConvertCIMType(prop.Type,prop.IsArray);

			cie = new CodeIndexerExpression(
				new CodeVariableReferenceExpression(PrivateNamesUsed["LateBoundObject"].ToString()),
				new CodeExpression[] {new CodePrimitiveExpression(prop.Name)});

			cmp.GetStatements.Add (new CodeMethodReturnStatement (new CodeCastExpression(cmp.Type,cie)));
			SysPropsClass.Members.Add(cmp);
		}
		//private WmiObject _privObject
		cf = new CodeMemberField();
		cf.Name = PrivateNamesUsed["LateBoundObject"].ToString();
		cf.Attributes = MemberAttributes.Private | MemberAttributes.Final ;
		cf.Type = new CodeTypeReference(PublicNamesUsed["BaseObjClass"].ToString());
		SysPropsClass.Members.Add(cf);

		SysPropsClass.Comments.Add(new CodeCommentStatement(GetString("COMMENT_SYSPROPCLASS")));
		return SysPropsClass;

	}
	/// <summary>
	/// This function will enumerate all the properties (except systemproperties)
	/// of the WMI class and will generate them as properties of the managed code
	/// wrapper class.
	/// </summary>
	void GenerateProperties()
	{
		bool bRead;
		bool bWrite;
		bool bStatic;
		bool bDynamicClass = IsDynamicClass();
		CodeMemberMethod cmm2 = null;
		CodeMemberProperty cmp2 = null;
		string IsValidPropName = string.Empty;
		bool bDateIsTimeInterval = false;

		for(int i=0;i< PublicProperties.Count;i++)
		{
			bDateIsTimeInterval = false;
			PropertyData prop = classobj.Properties[PublicProperties.GetKey(i).ToString()];
			bRead = true;		//All properties are readable by default
			bWrite = true;		//All properties are writeable by default
			bStatic = false;	//By default all properties are non static

			cmp = new CodeMemberProperty ();
			cmp.Name = PublicProperties[prop.Name].ToString();
			cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
			cmp.Type = ConvertCIMType(prop.Type,prop.IsArray);

			if(prop.Type == CimType.DateTime)
			{
				CodeTypeReference dateType = cmp.Type;
				// Check if it is Time interval and if so change the type to Time Interval
				bDateIsTimeInterval = GetDateTimeType(prop,ref dateType);
				cmp.Type = dateType;
			}
			
			// Check if the property is a of type ManagementBaseObject
			// or array of ManagementBaseObject. If so then the property
			// is of type embedded object
			if((cmp.Type.ArrayRank == 0 && cmp.Type.BaseType == PublicNamesUsed["BaseObjClass"].ToString()) ||
				cmp.Type.ArrayRank > 0 && cmp.Type.ArrayElementType .BaseType == PublicNamesUsed["BaseObjClass"].ToString())
			{
				bHasEmbeddedProperties = true;
			}

			// Method for Is<PropertyName>Null property
			IsValidPropName = "Is" + PublicProperties[prop.Name].ToString() + "Null";

			cmp2 = new CodeMemberProperty ();
			cmp2.Name = IsValidPropName;
			cmp2.Attributes = MemberAttributes.Public | MemberAttributes.Final;
			cmp2.Type = new CodeTypeReference("System.Boolean");

			//All properties are browsable, by default
			caa = new CodeAttributeArgument();
			caa.Value = new CodePrimitiveExpression(true);
			cad = new CodeAttributeDeclaration();
			cad.Name = "Browsable";
			cad.Arguments.Add(caa);
			cmp.CustomAttributes = new CodeAttributeDeclarationCollection();
			cmp.CustomAttributes.Add(cad);

			caa = new CodeAttributeArgument();
			caa.Value = new CodePrimitiveExpression(false);
			cad = new CodeAttributeDeclaration();
			cad.Name = "Browsable";
			cad.Arguments.Add(caa);
			cmp2.CustomAttributes = new CodeAttributeDeclarationCollection();
			cmp2.CustomAttributes.Add(cad);

			// None of the properties are seriazable thru designer
			caa = new CodeAttributeArgument();
			caa.Value = new CodeSnippetExpression("DesignerSerializationVisibility.Hidden");
			cad = new CodeAttributeDeclaration();
			cad.Name = "DesignerSerializationVisibility";
			cad.Arguments.Add(caa);
			cmp.CustomAttributes.Add(cad);
			cmp2.CustomAttributes.Add(cad);

			cie = new CodeIndexerExpression(
				new CodeSnippetExpression(PrivateNamesUsed["CurrentObject"].ToString()),
				new CodeExpression[] {new CodePrimitiveExpression(prop.Name)});


			bool bNullable = false;
			String description = ProcessPropertyQualifiers(prop,ref bRead,ref bWrite,ref bStatic,bDynamicClass,out bNullable);

			if(description != String.Empty)
			{
				//All properties are Description, by default
				caa = new CodeAttributeArgument();
				caa.Value = new CodePrimitiveExpression(description);
				cad = new CodeAttributeDeclaration();
				cad.Name = "Description";
				cad.Arguments.Add(caa);
				cmp.CustomAttributes.Add(cad);
			}

		
			//BUGBUG: WMI Values qualifier values cannot be used as
			//enumerator constants: they contain spaces, dots, dashes, etc.
			//These need to be modified, otherwise the generated file won't compile.
			//Uncomment the line below when that is fixed.
			bool isPropertyEnum = GeneratePropertyHelperEnums(prop,PublicProperties[prop.Name].ToString());

			if (bRead == true)
			{
				if(IsPropertyValueType(prop.Type)  && prop.IsArray == false)
				{

					/*
							[Browsable(false)]
							[DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
							public <Type> Is<PropertyName>Null {
								get {
									if ((PrivateLateBoundObject[<PropertyName>] == null)) {
										return true;
									}
									else {
										return false;
									}
								}
							}
					*/
					cis = new CodeConditionStatement();	
					cis.Condition = new CodeBinaryOperatorExpression(cie,
						CodeBinaryOperatorType.IdentityEquality,
						new CodePrimitiveExpression(null));


					cis.TrueStatements.Add(new CodeMethodReturnStatement (new CodePrimitiveExpression(true) ));
					cis.FalseStatements.Add(new CodeMethodReturnStatement (new CodePrimitiveExpression(false) ));
					cmp2.GetStatements.Add (cis);
					cc.Members.Add (cmp2);

					// Adding TypeConverter Attribute
					caa = new CodeAttributeArgument();
					caa.Value = new CodeTypeOfExpression (PrivateNamesUsed["ConverterClass"].ToString()) ;
					cad = new CodeAttributeDeclaration();
					cad.Name = PublicNamesUsed["TypeConverter"].ToString();
					cad.Arguments.Add(caa);
					cmp.CustomAttributes.Add(cad);

					// Since functions handling Datetime, TimeSpan returns MinValue, there is no need to check for null in the property
					// accessor for Datetime
					if(prop.Type != CimType.DateTime)
					{
						cis = new CodeConditionStatement();
						cis.Condition = new CodeBinaryOperatorExpression(cie,
							CodeBinaryOperatorType.IdentityEquality,
							new CodePrimitiveExpression(null));

						if (isPropertyEnum)
						{
							if(prop.IsArray)
							{
								cis.TrueStatements.Add(new CodeMethodReturnStatement (new CodePrimitiveExpression(null)));
							}
							else
							{
								// return (<EnumName>)System.Convert.ToInt32(0);
								cmie = new CodeMethodInvokeExpression();
								cmie.Method.TargetObject = new CodeSnippetExpression("System.Convert");
								cmie.Parameters.Add(new CodePrimitiveExpression(0));
								cmie.Method.MethodName = arrConvFuncName;
								cis.TrueStatements.Add(new CodeMethodReturnStatement (new CodeCastExpression(cmp.Type,cmie )));
							}
						}
						else
						{
							cmie = new CodeMethodInvokeExpression();
							cmie.Parameters.Add(new CodePrimitiveExpression(0));
							cmie.Method.MethodName = GetConversionFunction(prop.Type);
							cmie.Method.TargetObject = new CodeSnippetExpression("System.Convert");
							if(prop.IsArray)
							{
								CodeExpression [] cInit = {cmie };
								cis.TrueStatements.Add(new CodeMethodReturnStatement(
														new CodeArrayCreateExpression(cmp.Type,cInit)));
														
							}
							else
							{
								// return (<EnumName>)System.Convert.<ConvertFuncName>(0);
								cis.TrueStatements.Add(new CodeMethodReturnStatement (cmie));
							}
						}						
						cmp.GetStatements.Add (cis);
					}

					/*
						private bool ShouldSerialize<propertyName>()
						{
							if(Is<PropertyName>Null = true)
								return false;
							
							return true;
							
								
						}
					*/
					cmm = new CodeMemberMethod();
					cmm.Name = "ShouldSerialize" + PublicProperties[prop.Name].ToString();
					cmm.Attributes = MemberAttributes.Private |  MemberAttributes.Final;
					cmm.ReturnType = new CodeTypeReference("System.Boolean");

					CodeConditionStatement cis2 = new CodeConditionStatement();
					cis2.Condition = new CodeBinaryOperatorExpression(new CodeVariableReferenceExpression(IsValidPropName),
						CodeBinaryOperatorType.ValueEquality,
						new CodePrimitiveExpression(false));

					cis2.TrueStatements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(true)));

					cmm.Statements.Add(cis2);
					cmm.Statements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(false)));
					cc.Members.Add (cmm);
				}

				if (prop.Type == CimType.Reference)
				{
					//Call this function to add code for PropertyGet for properties like
					// DateTime,TimeSpan and Reference( ie. properties which require some object
					// to be created before returning)
					GenerateCodeForRefAndDateTimeTypes(cie,prop.IsArray,cmp.GetStatements,PublicNamesUsed["PathClass"].ToString(),null,false);
				}
				else
				if (prop.Type == CimType.DateTime)
				{
					//Call this function to add code for PropertyGet for properties like
					// DateTime ,TimeSpan and Reference( ie. properties which require some object
					// to be created before returning)
					if(bDateIsTimeInterval)
					{
						GenerateCodeForRefAndDateTimeTypes(cie,prop.IsArray,cmp.GetStatements,"System.TimeSpan",null,false);
					}
					else
					{
						GenerateCodeForRefAndDateTimeTypes(cie,prop.IsArray,cmp.GetStatements,"System.DateTime",null,false);
					}
				}
				else
				{
					if (isPropertyEnum)
					{
						if(prop.IsArray)
						{
							AddGetStatementsForEnumArray(cie,cmp);
						}
						else
						{
							cmie = new CodeMethodInvokeExpression();
							cmie.Method.TargetObject = new CodeSnippetExpression("Convert");
							cmie.Parameters.Add(cie);
							cmie.Method.MethodName = arrConvFuncName;
							cmp.GetStatements.Add (new CodeMethodReturnStatement (new CodeCastExpression(cmp.Type,cmie )));
						}
					}
					else
					{
						cmp.GetStatements.Add (new CodeMethodReturnStatement (new CodeCastExpression(cmp.Type,cie)));
					}
				}

			}


			if (bWrite == true)
			{
				if(bNullable)
				{
					cmm2 = new CodeMemberMethod ();
					cmm2.Name = "Reset" + PublicProperties[prop.Name].ToString();
					cmm2.Attributes = MemberAttributes.Private |  MemberAttributes.Final;
					cmm2.Statements.Add(new CodeAssignStatement(cie,new CodePrimitiveExpression(null)));
				}

				// if the type of the property is CIM_REFERENCE then just get the
				// path as string and update the property
				if (prop.Type == CimType.Reference)
				{
					//Call this function to add code for PropertySet for properties like
					// DateTime,TimeSpan and Reference( ie. properties which require some object
					// to be created before returning)
					AddPropertySet(cie,prop.IsArray,cmp.SetStatements,PublicNamesUsed["PathClass"].ToString(),null);
				}
				else
				if (prop.Type == CimType.DateTime)
				{
					//Call this function to add code for PropertySet for properties like
					// DateTime ,TimeSpan and Reference( ie. properties which require some object
					// to be created before returning)
					if(bDateIsTimeInterval)
					{
						AddPropertySet(cie,prop.IsArray,cmp.SetStatements,"System.TimeSpan",null);
					}
					else
					{
						AddPropertySet(cie,prop.IsArray,cmp.SetStatements,"System.DateTime",null);
					}
				}
				else
				{
					cmp.SetStatements.Add(new CodeAssignStatement(cie,new CodeSnippetExpression("value"))); 
				}
				cmie = new CodeMethodInvokeExpression();
				cmie.Method.TargetObject = new CodeVariableReferenceExpression(PrivateNamesUsed["LateBoundObject"].ToString());
				cmie.Method.MethodName = "Put";

					
				cboe = new CodeBinaryOperatorExpression(new CodeVariableReferenceExpression(PrivateNamesUsed["AutoCommitProperty"].ToString()),
														CodeBinaryOperatorType.ValueEquality,
														new CodePrimitiveExpression(true));
				
				CodeBinaryOperatorExpression cboe1 = new CodeBinaryOperatorExpression(new CodeVariableReferenceExpression(PrivateNamesUsed["IsEmbedded"].ToString()),
													CodeBinaryOperatorType.ValueEquality,
													new CodePrimitiveExpression(false));
													
				CodeBinaryOperatorExpression cboe2 = new CodeBinaryOperatorExpression();
				cboe2.Right = cboe;
				cboe2.Left = cboe1;
				cboe2.Operator = CodeBinaryOperatorType.BooleanAnd;
				
				
				cis = new CodeConditionStatement();
				cis.Condition = cboe2;
				
				cis.TrueStatements.Add(new CodeExpressionStatement(cmie));

				cmp.SetStatements.Add(cis);
				if(bNullable)
				{
					cmm2.Statements.Add(cis);
				}
			
			}
			cc.Members.Add(cmp);
			if(bNullable & bWrite)
			{
				cc.Members.Add(cmm2);
			}

		

		}
		// Add a function to commit the changes of the objects to WMI
		GenerateCommitMethod();
	}
	/// <summary>
	/// This function will process the qualifiers for a given WMI property and set the 
	/// attributes of the generated property accordingly.
	/// </summary>
	string ProcessPropertyQualifiers(PropertyData prop,ref bool bRead, ref bool bWrite, ref bool bStatic,bool bDynamicClass,out bool nullable)
	{
		bool hasWrite = false;
		bool writeValue = false;
		bool hasRead = false;
		bool bMapsFailed = false;
		nullable = true;

		// property is always readable
		bRead = true;
		bWrite = false;
		arrConvFuncName = "ToInt32";
		enumType = "System.Int32";
		
		string description = String.Empty;
		foreach (QualifierData q in prop.Qualifiers)
		{
			if (String.Compare(q.Name,"description",true,CultureInfo.InvariantCulture) == 0)
			{
				description = q.Value.ToString();
			}
			else
				if (String.Compare(q.Name,"Not_Null",true,CultureInfo.InvariantCulture) == 0)
			{
				nullable = false;
			}
			else
				if (String.Compare(q.Name,"key",true,CultureInfo.InvariantCulture) == 0)
			{
				//This is a key. So push it in to the key array
				arrKeyType.Add(cmp.Type);
				arrKeys.Add(prop.Name);
				nullable = false;
				break;
			}
			else if (string.Compare(q.Name,"static",true,CultureInfo.InvariantCulture) == 0)
			{
				//This property is static. So add static to the Type of the object
				bStatic = true;
				cmp.Attributes |= MemberAttributes.Static;
			}
			else if (string.Compare(q.Name,"read",true,CultureInfo.InvariantCulture) == 0)
			{
				hasRead = true;
				if ((bool)q.Value == false)
				{
					bRead = false;
				}
				else
				{
					bRead = true;
				}
			}
			else if (string.Compare(q.Name,"write",true,CultureInfo.InvariantCulture) == 0)
			{
				hasWrite = true;
				if ((bool)q.Value == true)
				{
					writeValue = true;
				}
				else
				{
					writeValue = false;
				}
			}
				// check for ValueMap/Values and BitMap/BitValues pair and create
				// Enum Accordingly
			else if (string.Compare(q.Name,"ValueMap",true,CultureInfo.InvariantCulture) == 0 && bMapsFailed == false)
			{
				try
				{
					ValueMap.Clear();
					//Now check whether the type of the property is int
					if (isTypeInt(prop.Type) == true)
					{
						if (q.Value != null)
						{
							string [] strArray = (string [])q.Value;
							for(int i=0;i < strArray.Length ;i++)
							{
								try
								{
									arrConvFuncName = ConvertToNumericValueAndAddToArray(prop.Type,strArray[i],ValueMap,out enumType);
								}
								catch(OverflowException)
								{
									//									ValueMap.Add(Convert.ToInt64(strArray[i]));
									//									bValueMapInt64 = true;
								}
							}
						}
					}
				}
				catch
				{
					bMapsFailed = true;
					ValueMap.Clear();
				}
			}
			else if (string.Compare(q.Name,"Values",true,CultureInfo.InvariantCulture) == 0 && bMapsFailed == false)
			{
				try
				{
					Values.Clear();
					if (isTypeInt(prop.Type) == true)
					{
						if (q.Value != null)
						{
							ArrayList arTemp = new ArrayList(5);
							string [] strArray = (string[])q.Value;
							for(int i=0;i < strArray.Length;i++)
							{
								string strName = ConvertValuesToName(strArray[i]);
								arTemp.Add(strName);
							}
							ResolveEnumNameValues(arTemp,ref Values);
						}
					}
				}
				catch
				{
					Values.Clear();
					bMapsFailed = true;
				}

			}
			else if (string.Compare(q.Name,"BitMap",true,CultureInfo.InvariantCulture) == 0 && bMapsFailed == false)
			{
				try
				{
					BitMap.Clear();
					if (isTypeInt(prop.Type) == true)
					{
						if (q.Value != null)
						{
							string [] strArray = (string [])q.Value;
							for(int i=0;i < strArray.Length;i++)
							{							
								BitMap.Add(ConvertBitMapValueToInt32(strArray[i]));
							}
						}
					}
				}
				catch
				{
					BitMap.Clear();
					bMapsFailed = true;
				}
			}
			else if (string.Compare(q.Name,"BitValues",true,CultureInfo.InvariantCulture) == 0 && bMapsFailed == false)
			{
				try
				{
					BitValues.Clear();
					if (isTypeInt(prop.Type) == true)
					{
						if (q.Value != null)
						{
							ArrayList arTemp = new ArrayList(5);
							string [] strArray = (string [])q.Value;
							for(int i=0;i < strArray.Length;i++)
							{
								string strName = ConvertValuesToName(strArray[i]);
								arTemp.Add(strName);
							}
							ResolveEnumNameValues(arTemp,ref BitValues);
						}
					}
				}
				catch
				{
					BitValues.Clear();
					bMapsFailed = true;
				}
			
			}
		}
	
		// Property is not writeable only if "read" qualifier is present and its value is "true"
		// Also, for dynamic classes, absence of "write" qualifier means that the property is read-only.
		if ((!bDynamicClass && !hasWrite && !hasRead)||
			(!bDynamicClass && hasWrite && writeValue)||
			(bDynamicClass && hasWrite && writeValue))
		{
			bWrite = true;
		}
	
		return description;
	}
	/// <summary>
	/// This function will generate enums corresponding to the Values/Valuemap pair
	/// and for the BitValues/Bitmap pair.
	/// </summary>
	/// <returns>
	/// returns if the property is an enum. This is checked by if enum is added or not
	/// </returns>
	bool GeneratePropertyHelperEnums(PropertyData prop,string strPropertyName)
	{
		bool isEnumAdded = false;
		bool bZeroFieldInEnum = false;
		//Only if the property is of type int and there is atleast values qualifier on it
		//then we will generate an enum for the values/valuemap(if available)
		//Here we don't have to check explicitly for type of the property as the size of 
		//values array will be zero if the type is not int.
		string strEnum = ResolveCollision(strPropertyName+"Values",true);

		// if there is a mismatch in the number of values and ValueMaps then
		// there is an error in the value maps and so don't add enum
		if (Values.Count > 0 && (ValueMap.Count == 0 || ValueMap.Count == Values.Count))
		{
			if(ValueMap.Count == 0)
			{
				bZeroFieldInEnum = true;
			}

			//Now we will have to create an enum.
			EnumObj = new CodeTypeDeclaration(strEnum);
			EnumObj.TypeAttributes = TypeAttributes.NestedPublic;
			cc.Members.Add(EnumObj);

			isEnumAdded = true;

			// FIXX VB code generator cannot handle this
			EnumObj.BaseTypes.Add(new CodeTypeReference(enumType));


			//Now convert the type to the generated enum type
			if(prop.IsArray)
			{
				cmp.Type = new CodeTypeReference(strEnum,1);
			}
			else
			{
				cmp.Type = new CodeTypeReference(strEnum);
			}

			EnumObj.IsEnum = true;
			EnumObj.TypeAttributes = TypeAttributes.Public; // | TypeAttributes.ValueType | TypeAttributes.Enum;
			for(int i=0; i < Values.Count;i++)
			{
				cmf = new CodeMemberField ();
				cmf.Name = Values[i].ToString();
				if (ValueMap.Count > 0)
				{
					cmf.InitExpression = new CodePrimitiveExpression(ValueMap[i]);

					if(bZeroFieldInEnum == false)
					{
						if(System.Convert.ToUInt64(ValueMap[i]) == 0)	// Bug No: 121987
						{
							bZeroFieldInEnum = true;
						}
					}
				}
				EnumObj.Members.Add(cmf);
			}

			// If there is no 0 valued field in enum, just add a invalid for enum
			// This is just to show in property browser
			if(bZeroFieldInEnum == false)
			{
				cmf = new CodeMemberField ();
				cmf.Name = "INVALID_ENUM_VALUE";
				cmf.InitExpression = new CodePrimitiveExpression(0);
				EnumObj.Members.Add(cmf);
			}
		}
		//Now clear the Values & ValueMap Array
		Values.Clear();
		ValueMap.Clear();


		bZeroFieldInEnum = false;

		//Only if the property is of type int and there is atleast values qualifier on it
		//then we will generate an enum for the values/valuemap(if available)
		//Here we don't have to check explicitly for type of the property as the size of 
		//values array will be zero if the type is not int.
		if (BitValues.Count > 0 && (BitMap.Count == 0 || BitMap.Count == BitValues.Count))
		{
			if(BitMap.Count == 0)
			{
				bZeroFieldInEnum = true;
			}

			//Now we will create the enum
			EnumObj = new CodeTypeDeclaration(strEnum);
			EnumObj.TypeAttributes = TypeAttributes.NestedPublic;
			cc.Members.Add(EnumObj);

			isEnumAdded = true;

			// FIXX VB code generator cannot handle this
			EnumObj.BaseTypes.Add(new CodeTypeReference(enumType));

			//Now convert the type to the generated enum type
			if(prop.IsArray)
			{
				cmp.Type = new CodeTypeReference(strEnum,1);
			}
			else
			{
				cmp.Type = new CodeTypeReference(strEnum);
			}

			EnumObj.IsEnum = true;
			EnumObj.TypeAttributes = TypeAttributes.Public; // | TypeAttributes.ValueType | TypeAttributes.Enum;
			Int32 bitValue = 1;
			for(int i=0; i < BitValues.Count;i++)
			{
				cmf = new CodeMemberField ();
				cmf.Name = BitValues[i].ToString();
				if (ValueMap.Count > 0)
				{
					cmf.InitExpression = new CodePrimitiveExpression(BitMap[i]);
				}
				else
				{
					cmf.InitExpression = new CodePrimitiveExpression(bitValue);
					//Now shift 1 more bit so that we can put it for the next element in the enum
					bitValue = bitValue << 1;
				}
				if(bZeroFieldInEnum == false)
				{
					if( (System.Convert.ToUInt64(BitMap[i]) == 0) )		// Bug No: 121987
					{
						bZeroFieldInEnum = true;
					}
				}
				EnumObj.Members.Add(cmf);
			}

			// If there is no 0 valued field in enum, just add a invalid for enum
			// This is just to show in property browser
			if(bZeroFieldInEnum == false)
			{
				cmf = new CodeMemberField ();
				cmf.Name = "INVALID_ENUM_VALUE";
				cmf.InitExpression = new CodePrimitiveExpression(0);
				EnumObj.Members.Add(cmf);
			}
		}
		//Now clear the Bitmap and BitValues Array
		BitValues.Clear();
		BitMap.Clear();
		return isEnumAdded;

	}
	/// <summary>
	/// This function generated the static function which s used to construct the path
	/// 	private static String ConstructPath(String keyName)
	///		{
	///			//FOR NON SINGLETON CLASSES
	///			String strPath;
	///		    strPath = ((("\\&lt;defNamespace&gt;:&lt;defClassName&gt;";
	///		    strPath = ((_strPath) + (((".Key1=") + (key_Key1))));
	///		    strPath = ((_strPath) + (((",Key2=") + ((("\"") + (((key_Key2) + ("\""))))))));
	///			return strPath;
	///			
	///			//FOR SINGLETON CLASS
	///			return "\\&lt;defNameSpace&gt;:&lt;defClassName&gt;=@";
	///		}
	/// </summary>
	void GenerateConstructPath()
	{
		string strType;
		cmm = new CodeMemberMethod();
		cmm.Name = PublicNamesUsed["ConstructPathFunction"].ToString();
		cmm.Attributes = MemberAttributes.Private | MemberAttributes.Static | MemberAttributes.Final;
		cmm.ReturnType = new CodeTypeReference("System.String");

		for(int i=0; i < arrKeys.Count;i++)
		{
			strType = ((CodeTypeReference)arrKeyType[i]).BaseType;
			cmm.Parameters.Add(new CodeParameterDeclarationExpression(strType,
				"key"+arrKeys[i].ToString()));
		}

		string strPath = OriginalNamespace + ":" + OriginalClassName;
		if (bSingletonClass == true)
		{
			strPath = strPath + "=@";
			cmm.Statements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(strPath)));
		}
		else
		{
			string strPathObject = "strPath";
			//Declare the String strPath;
			cmm.Statements.Add(new CodeVariableDeclarationStatement("System.String",strPathObject,new CodePrimitiveExpression(strPath)));

			for(int i=0; i < arrKeys.Count;i++)
			{
				if (((CodeTypeReference)arrKeyType[i]).BaseType == "System.String")
				{
					cboe = new CodeBinaryOperatorExpression(new CodeSnippetExpression("key"+arrKeys[i]),
						CodeBinaryOperatorType.Add,
						new CodePrimitiveExpression("\""));

					cboe = new CodeBinaryOperatorExpression(new CodePrimitiveExpression("\""),
						CodeBinaryOperatorType.Add,
						cboe);

					cboe = new CodeBinaryOperatorExpression(new CodePrimitiveExpression(
						((i==0)?("."+arrKeys[i]+"="):(","+arrKeys[i]+"="))),
						CodeBinaryOperatorType.Add,
						cboe);
					cboe = new CodeBinaryOperatorExpression(new CodeSnippetExpression(strPathObject),
						CodeBinaryOperatorType.Add,
						cboe);
				}
				else
				{
					cmie = new CodeMethodInvokeExpression();
					cmie.Method.TargetObject = new CodeSnippetExpression("key"+arrKeys[i]);
					cmie.Method.MethodName = "ToString";

					cboe = new CodeBinaryOperatorExpression(new CodePrimitiveExpression(
						((i==0)?("."+arrKeys[i]+"="):(","+arrKeys[i]+"="))),
						CodeBinaryOperatorType.Add,
						cmie);
					cboe = new CodeBinaryOperatorExpression(new CodeSnippetExpression(strPathObject),
						CodeBinaryOperatorType.Add,
						cboe);
				}
				cmm.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(strPathObject),cboe));
			}
			cmm.Statements.Add(new CodeMethodReturnStatement(new CodeSnippetExpression(strPathObject)));
		}
		cc.Members.Add(cmm);
	}
	/// <summary>
	/// This function generates the default constructor.
	/// public Cons() {
	///		_privObject = new ManagementObject();
	///     _privSystemProps = new ManagementSystemProperties(_privObject);
	/// }
	/// </summary>
	void GenerateDefaultConstructor()
	{
		cctor = new CodeConstructor();
		cctor.Attributes = MemberAttributes.Public;

		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
			new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString()),
			new CodePrimitiveExpression(null)));
		//If it is a singleton class, then we will make the default constructor to point to the
		//only object available
		if (bSingletonClass == true)
		{
			cmie = new CodeMethodInvokeExpression();
			cmie.Method.TargetObject = new CodeVariableReferenceExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
			cmie.Method.MethodName = PublicNamesUsed["ConstructPathFunction"].ToString();

			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());
			coce.Parameters.Add(cmie);
				
			cctor.ChainedConstructorArgs.Add(coce);
		}
		else
		{
			cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
				new CodeTypeReference(PublicNamesUsed["PathClass"].ToString()),
				new CodePrimitiveExpression(null)));
		}
		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
			new CodeTypeReference(PublicNamesUsed["GetOptionsClass"].ToString()),
			new CodePrimitiveExpression(null)));
		cc.Members.Add(cctor);

		cctor.Comments.Add(new CodeCommentStatement(GetString("COMMENT_CONSTRUCTORS")));
	}
	/// <summary>
	///This function create the constuctor which accepts the key values.
	///public cons(UInt32 key_Key1, String key_Key2) :this(null,&lt;ClassName&gt;.ConstructPath(&lt;key1,key2&gt;),null) {
	/// }
	///</summary>
	void GenerateConstructorWithKeys()
	{
		if (arrKeyType.Count > 0)
		{
			cctor = new CodeConstructor();		
			cctor.Attributes = MemberAttributes.Public;
			for(int i=0; i < arrKeys.Count;i++)
			{
				cpde = new CodeParameterDeclarationExpression();
				cpde.Type = new CodeTypeReference(((CodeTypeReference)arrKeyType[i]).BaseType);
				cpde.Name = "key"+arrKeys[i].ToString();
				cctor.Parameters.Add(cpde);
			}

			// if the key of the class maps to "System.Management.ManagementPath" type then add a dummy param
			// to avoid duplicate constructors
			if(cctor.Parameters.Count == 1 && cctor.Parameters[0].Type.BaseType == PublicNamesUsed["PathClass"].ToString())
			{
				cpde = new CodeParameterDeclarationExpression();
				cpde.Type = new CodeTypeReference("System.Object");
				cpde.Name = "dummyParam";
				cctor.Parameters.Add(cpde);
			}
			
			cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
				new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString()),
				new CodePrimitiveExpression(null)));

			cmie = new CodeMethodInvokeExpression();
			cmie.Method.TargetObject = new CodeVariableReferenceExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
			cmie.Method.MethodName = PublicNamesUsed["ConstructPathFunction"].ToString(); 

			for(int i=0; i < arrKeys.Count;i++)
			{
				cmie.Parameters.Add(new CodeSnippetExpression("key"+arrKeys[i]));
			}

			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());
			coce.Parameters.Add(cmie);

			cctor.ChainedConstructorArgs.Add(new CodeCastExpression(new CodeTypeReference(
				PublicNamesUsed["PathClass"].ToString()),
				coce));
			cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
				new CodeTypeReference(PublicNamesUsed["GetOptionsClass"].ToString()),
				new CodePrimitiveExpression(null)));
			cc.Members.Add(cctor);
		}		
	}

	/// <summary>
	///This function create the constuctor which accepts a scope and key values.
	///public cons(ManagementScope scope,UInt32 key_Key1, String key_Key2) :this(scope,&lt;ClassName&gt;.ConstructPath(&lt;key1,key2&gt;),null) {
	/// }
	///</summary>
	void GenerateConstructorWithScopeKeys()
	{
		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),PrivateNamesUsed["ScopeParam"].ToString()));

		if (arrKeyType.Count > 0)
		{
			for(int i=0; i < arrKeys.Count;i++)
			{
				cpde = new CodeParameterDeclarationExpression();
				cpde.Type = new CodeTypeReference(((CodeTypeReference)arrKeyType[i]).BaseType);
				cpde.Name = "key"+arrKeys[i].ToString();
				cctor.Parameters.Add(cpde);
			}
			
			// if the key of the class maps to "System.Management.ManagementPath" type then add a dummy param
			// to avoid duplicate constructors
			if(cctor.Parameters.Count == 2 && cctor.Parameters[1].Type.BaseType == PublicNamesUsed["PathClass"].ToString())
			{
				cpde = new CodeParameterDeclarationExpression();
				cpde.Type = new CodeTypeReference("System.Object");
				cpde.Name = "dummyParam";
				cctor.Parameters.Add(cpde);
			}

			cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
				new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString()),
				new CodeSnippetExpression(PrivateNamesUsed["ScopeParam"].ToString())));

			cmie = new CodeMethodInvokeExpression();
			cmie.Method.TargetObject = new CodeVariableReferenceExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
			cmie.Method.MethodName = PublicNamesUsed["ConstructPathFunction"].ToString();				

			for(int i=0; i < arrKeys.Count;i++)
			{
				cmie.Parameters.Add(new CodeSnippetExpression("key"+arrKeys[i]));
			}

			coce = new CodeObjectCreateExpression();
			coce.CreateType = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());
			coce.Parameters.Add(cmie);
			cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
				new CodeTypeReference(PublicNamesUsed["PathClass"].ToString()),
				coce));
			cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
				new CodeTypeReference(PublicNamesUsed["GetOptionsClass"].ToString()),
				new CodePrimitiveExpression(null)));
			cc.Members.Add(cctor);
		}		
	}


	/// <summary>
	/// This function generates code for the constructor which accepts ManagementPath as the parameter.
	/// The generated code will look something like this
	///		public Cons(ManagementPath path) : this (null, path,null){
	///		}
	/// </summary>
	void GenerateConstructorWithPath()
	{
		string strPathObject = "path";
		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cpde = new CodeParameterDeclarationExpression();
		cpde.Type = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());
		cpde.Name = strPathObject;
		cctor.Parameters.Add(cpde);

		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
			new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString()),
			new CodePrimitiveExpression(null)));
		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
			new CodeTypeReference(PublicNamesUsed["PathClass"].ToString()),
			new CodeSnippetExpression(strPathObject)));
		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
			new CodeTypeReference(PublicNamesUsed["GetOptionsClass"].ToString()),
			new CodePrimitiveExpression(null)));
		cc.Members.Add(cctor);


	}
	/// <summary>
	/// This function generates code for the constructor which accepts ManagementPath and GetOptions
	/// as parameters.
	/// The generated code will look something like this
	///		public Cons(ManagementPath path, ObjectGetOptions options) : this (null, path,options){
	///		}
	/// </summary>
	void GenerateConstructorWithPathOptions()
	{
		string strPathObject = "path";
		string strGetOptions = "getOptions";

		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["PathClass"].ToString(),
			strPathObject));
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["GetOptionsClass"].ToString(),
			strGetOptions));

		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
			new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString()),
			new CodePrimitiveExpression(null)));
		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
			new CodeTypeReference(PublicNamesUsed["PathClass"].ToString()),
			new CodeSnippetExpression(strPathObject)));
		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
			new CodeTypeReference(PublicNamesUsed["GetOptionsClass"].ToString()),
			new CodeSnippetExpression(strGetOptions)));
		cc.Members.Add(cctor);
	}
	/// <summary>
	/// This function generates code for the constructor which accepts Scope as a string, path as a 
	/// string and GetOptions().
	/// The generated code will look something like this
	///		public Cons(String scope, String path, ObjectGetOptions options) : 
	///							this (new ManagementScope(scope), new ManagementPath(path),options){
	///		}
	/// </summary>
	void GenerateConstructorWithScopePath()
	{
		string strPathObject = "path";

		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),PrivateNamesUsed["ScopeParam"].ToString()));
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["PathClass"].ToString(),strPathObject));
		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
			new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString()),
			new CodeSnippetExpression(PrivateNamesUsed["ScopeParam"].ToString())));
		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
			new CodeTypeReference(PublicNamesUsed["PathClass"].ToString()),
			new CodeSnippetExpression(strPathObject)));
		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
			new CodeTypeReference(PublicNamesUsed["GetOptionsClass"].ToString()),
			new CodePrimitiveExpression(null)));
		cc.Members.Add(cctor);
	}
	/// <summary>
	/// This function generates code for the constructor which accepts ManagementScope as parameters.
	/// The generated code will look something like this
	///		public Cons(ManagementScope scope, ObjectGetOptions options) : this (scope, &lt;ClassName&gt;.ConstructPath(),null){
	///		}
	/// </summary>
	void GenerateConstructorWithScope()
	{

		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),
			PrivateNamesUsed["ScopeParam"].ToString()));
		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
			new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString()),
			new CodeSnippetExpression(PrivateNamesUsed["ScopeParam"].ToString())));
		cmie = new CodeMethodInvokeExpression();
		cmie.Method.TargetObject =new CodeVariableReferenceExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
		cmie.Method.MethodName = PublicNamesUsed["ConstructPathFunction"].ToString();					
				
		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());
		coce.Parameters.Add(cmie);

		cctor.ChainedConstructorArgs.Add(coce);

		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
			new CodeTypeReference(PublicNamesUsed["GetOptionsClass"].ToString()),
			new CodePrimitiveExpression(null)));
		cc.Members.Add(cctor);
	}

	/// <summary>
	/// This function generates code for the constructor which accepts GetOptions
	/// as parameters.
	/// The generated code will look something like this
	///		public Cons(ObjectGetOptions options) : this (null, &lt;ClassName&gt;.ConstructPath(),options){
	///		}
	/// </summary>
	void GenerateConstructorWithOptions()
	{
		string strGetOptions = "getOptions";

		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["GetOptionsClass"].ToString(),
			strGetOptions));

		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
			new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString()),
			new CodePrimitiveExpression(null)));
		cmie = new CodeMethodInvokeExpression();
		cmie.Method.TargetObject = new CodeVariableReferenceExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
		cmie.Method.MethodName = PublicNamesUsed["ConstructPathFunction"].ToString();
			
		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());
		coce.Parameters.Add(cmie);

		cctor.ChainedConstructorArgs.Add(coce);
		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
			new CodeTypeReference(PublicNamesUsed["GetOptionsClass"].ToString()),
			new CodeSnippetExpression(strGetOptions)));
		cc.Members.Add(cctor);
	}

	/// <summary>
	/// This function generates code for the constructor which accepts ManagementScope and GetOptions
	/// as parameters.
	/// The generated code will look something like this
	///		public Cons(ManagementScope scope, ObjectGetOptions options) : this (scope, &lt;ClassName&gt;.ConstructPath(),options){
	///		}
	/// </summary>
	void GenerateConstructorWithScopeOptions()
	{
		string strGetOptions = "getOptions";

		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),
			PrivateNamesUsed["ScopeParam"].ToString()));
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["GetOptionsClass"].ToString(),
			strGetOptions));

		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
			new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString()),
			new CodeSnippetExpression(PrivateNamesUsed["ScopeParam"].ToString())));
	
		cmie = new CodeMethodInvokeExpression();
		cmie.Method.TargetObject = new CodeVariableReferenceExpression(PrivateNamesUsed["GeneratedClassName"].ToString());
		cmie.Method.MethodName = PublicNamesUsed["ConstructPathFunction"].ToString();				

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());
		coce.Parameters.Add(cmie);

		cctor.ChainedConstructorArgs.Add(coce);

		cctor.ChainedConstructorArgs.Add(new CodeCastExpression(
			new CodeTypeReference(PublicNamesUsed["GetOptionsClass"].ToString()),
			new CodeSnippetExpression(strGetOptions)));
		cc.Members.Add(cctor);
	}


	/// <summary>
	/// This function generated the constructor like
	///		public cons(ManagementScope scope, ManagamentPath path,ObjectGetOptions getOptions)
	///		{
	///			PrivateObject = new ManagementObject(scope,path,getOptions);
	///			PrivateSystemProperties = new ManagementSystemProperties(PrivateObject);
	///		}
	/// </summary>
	void GenerateConstructorWithScopePathOptions()
	{
		string strPathObject = "path";
		string strGetOptions = "getOptions";
		bool bPrivileges = true;
	
		try
		{
			classobj.Qualifiers["priveleges"].ToString();
		}
		catch(ManagementException e)
		{
			if (e.ErrorCode == ManagementStatus.NotFound)
			{
				bPrivileges = false;
			}
			else
			{
				throw;
			}
		}

		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),PrivateNamesUsed["ScopeParam"].ToString()));
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["PathClass"].ToString(),strPathObject));
		cctor.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["GetOptionsClass"].ToString(),strGetOptions));

		//First if path is not null, then we will check whether the class name is the same.
		//if it is not the same, then we will throw an exception
		cis = new CodeConditionStatement();
		cis.Condition = new CodeBinaryOperatorExpression(new CodeSnippetExpression(strPathObject),
			CodeBinaryOperatorType.IdentityInequality,
			new CodePrimitiveExpression(null));
		CodeConditionStatement cis1 = new CodeConditionStatement();

		cmie = new CodeMethodInvokeExpression();
		cmie.Method.MethodName = PrivateNamesUsed["ClassNameCheckFunc"].ToString();
					

		cmie.Parameters.Add(new CodeVariableReferenceExpression(PrivateNamesUsed["ScopeParam"].ToString()));
		cmie.Parameters.Add(new CodeVariableReferenceExpression(strPathObject));
		cmie.Parameters.Add(new CodeVariableReferenceExpression(strGetOptions));
		
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = cmie;
		cboe.Right = new CodePrimitiveExpression(true);
		cboe.Operator = CodeBinaryOperatorType.IdentityInequality;
		cis1.Condition = cboe;
		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["ArgumentExceptionClass"].ToString());
		coce.Parameters.Add(new CodePrimitiveExpression(GetString("CLASSNOT_FOUND_EXCEPT"))); 
		cis1.TrueStatements.Add(new CodeThrowExceptionStatement(coce));

		cis.TrueStatements.Add(cis1);
		cctor.Statements.Add(cis);

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["LateBoundClass"].ToString());
		coce.Parameters.Add(new CodeSnippetExpression(PrivateNamesUsed["ScopeParam"].ToString()));
		coce.Parameters.Add(new CodeSnippetExpression(strPathObject));
		coce.Parameters.Add(new CodeSnippetExpression(strGetOptions));
		cctor.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(
			PrivateNamesUsed["LateBoundObject"].ToString()),
			coce));
		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["SystemPropertiesClass"].ToString());
		cle = new CodeSnippetExpression(PrivateNamesUsed["LateBoundObject"].ToString());
		coce.Parameters.Add(cle);
		cctor.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(
			PrivateNamesUsed["SystemPropertiesObject"].ToString()),
			coce));

		cctor.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(PrivateNamesUsed["CurrentObject"].ToString()),
												new CodeVariableReferenceExpression(PrivateNamesUsed["LateBoundObject"].ToString())));
		cc.Members.Add(cctor);
		// Enable the privileges if the class has privileges qualifier
		if (bPrivileges == true)
		{
			//Generate the statement 
			//	Boolean bPriveleges = PrivateLateBoundObject.Scope.Options.EnablePrivileges;
			cpre = new CodePropertyReferenceExpression(new CodePropertyReferenceExpression(
				new CodePropertyReferenceExpression(
				new CodeSnippetExpression(PrivateNamesUsed["LateBoundObject"].ToString()),
				PublicNamesUsed["ScopeProperty"].ToString()),
				"Options"),
				"EnablePrivileges");

			cctor.Statements.Add(new CodeAssignStatement(cpre, new CodePrimitiveExpression(true)));
		
		}

	
	}
	/// <summary>
	/// This function generates code for the constructor which accepts ManagementObject as the parameter.
	/// The generated code will look something like this
	///		public Cons(ManagementObject theObject) {
	///		if (CheckIfProperClass(theObject.Scope, theObject.Path, theObject.Options) = true) {
	///				privObject = theObject;
	///				privSystemProps = new WmiSystemProps(privObject);
	///				curObj = privObject;
	///			}
	///			else {
	///				throw new ArgumentException("Class name doesn't match");
	///			}
	///		}
	/// </summary>
	void GenarateConstructorWithLateBound()
	{
		string strLateBoundObject = "theObject";
		string LateBoundSystemProperties = "SystemProperties";

		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cpde = new CodeParameterDeclarationExpression();
		cpde.Type = new CodeTypeReference(PublicNamesUsed["LateBoundClass"].ToString());
		cpde.Name = strLateBoundObject;
		cctor.Parameters.Add(cpde);

		cis = new CodeConditionStatement();
		cpre = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(strLateBoundObject),LateBoundSystemProperties);
		cie = new CodeIndexerExpression(cpre,new CodePrimitiveExpression("__CLASS"));
		cpre = new CodePropertyReferenceExpression(cie,"Value");


		cmie = new CodeMethodInvokeExpression();
		cmie.Method.MethodName = PrivateNamesUsed["ClassNameCheckFunc"].ToString();	
		cmie.Parameters.Add(new CodeVariableReferenceExpression(strLateBoundObject));

		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = cmie;
		cboe.Right = new CodePrimitiveExpression(true);
		cboe.Operator = CodeBinaryOperatorType.ValueEquality;
		cis.Condition = cboe;

		cis.TrueStatements.Add(new CodeAssignStatement(
			new CodeVariableReferenceExpression(PrivateNamesUsed["LateBoundObject"].ToString()),
			new CodeVariableReferenceExpression(strLateBoundObject)));

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["SystemPropertiesClass"].ToString());
		coce.Parameters.Add(new CodeVariableReferenceExpression(PrivateNamesUsed["LateBoundObject"].ToString()));
		cis.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(PrivateNamesUsed["SystemPropertiesObject"].ToString()),coce));
		cis.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(PrivateNamesUsed["CurrentObject"].ToString()),
														new CodeVariableReferenceExpression(PrivateNamesUsed["LateBoundObject"].ToString())));

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["ArgumentExceptionClass"].ToString());
		coce.Parameters.Add(new CodePrimitiveExpression(GetString("CLASSNOT_FOUND_EXCEPT"))); 
		cis.FalseStatements.Add(new CodeThrowExceptionStatement(coce));


		cctor.Statements.Add(cis);
		cc.Members.Add(cctor);
	}

	
	/// <summary>
	/// This function generates code for the constructor which accepts ManagementObject as the parameter.
	/// The generated code will look something like this
	///		public Cons(ManagementBaseObject theObject) {
	///		if (CheckIfProperClass(theObject) = true) 
	///		{
	///			embeddedObj = theObject
	///			PrivateSystemProperties = New ManagementSystemProperties(theObject)
	///			curObj = embeddedObj
	///			isEmbedded = true
	///		}
	///		else
	///		{
	///			throw new ArgumentException("Class name doesn't match");
	///		}
	///	}																			 
	///
	/// </summary>
	void GenarateConstructorWithLateBoundForEmbedded()
	{
		string strLateBoundObject = "theObject";
//		string LateBoundSystemProperties = "SystemProperties";

		cctor = new CodeConstructor();		
		cctor.Attributes = MemberAttributes.Public;
		cpde = new CodeParameterDeclarationExpression();
		cpde.Type = new CodeTypeReference(PublicNamesUsed["BaseObjClass"].ToString());
		cpde.Name = strLateBoundObject;
		cctor.Parameters.Add(cpde);

		cmie = new CodeMethodInvokeExpression();
		cmie.Method.MethodName = PrivateNamesUsed["ClassNameCheckFunc"].ToString();
					

		cmie.Parameters.Add(new CodeVariableReferenceExpression(strLateBoundObject));

		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = cmie;
		cboe.Right = new CodePrimitiveExpression(true);
		cboe.Operator = CodeBinaryOperatorType.ValueEquality;
		cis = new CodeConditionStatement();
		cis.Condition = cboe;

		cis.TrueStatements.Add(new CodeAssignStatement(
			new CodeVariableReferenceExpression(PrivateNamesUsed["EmbeddedObject"].ToString()),
			new CodeVariableReferenceExpression(strLateBoundObject)));

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["SystemPropertiesClass"].ToString());
		coce.Parameters.Add(new CodeVariableReferenceExpression(strLateBoundObject));
		cis.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(PrivateNamesUsed["SystemPropertiesObject"].ToString()),coce));
		cis.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(PrivateNamesUsed["CurrentObject"].ToString()),
														new CodeVariableReferenceExpression(PrivateNamesUsed["EmbeddedObject"].ToString())));

		cis.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(PrivateNamesUsed["IsEmbedded"].ToString()),
										new CodePrimitiveExpression(true)));

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["ArgumentExceptionClass"].ToString());
		coce.Parameters.Add(new CodePrimitiveExpression(GetString("CLASSNOT_FOUND_EXCEPT")));
		cis.FalseStatements.Add(new CodeThrowExceptionStatement(coce));


		cctor.Statements.Add(cis);
		cc.Members.Add(cctor);
	}

	/// <summary>
	/// This function generates the WMI methods as the methods in the generated class.
	/// The generated code will look something like this
	///		public &lt;retType&gt; Method1(&lt;type&gt; param1, &lt;type&gt; param2,...) {
	///            ManagementBaseObject inParams = null;
	///            inParams = _privObject.GetMethodParameters("ChangeStartMode");
	///            inParams["&lt;inparam1&gt;"] = &lt;Value&gt;;
	///            inParams["&lt;inoutparam2&gt;"] = &lt;Value&gt;;
	///            ................................
	///            ManagementBaseObject outParams = _privObject.InvokeMethod("ChangeStartMode", inParams, null);
	///            inoutParam3 = (&lt;type&gt;)(outParams.Properties["&lt;inoutParam3&gt;"]);
	///            outParam4 = (String)(outParams.Properties["&lt;outParam4&gt;"]);
	///            ................................
	///            return (&lt;retType&gt;)(outParams.Properties["ReturnValue"].Value);
	///     }
	///     
	///     The code generated changes if the method is static function
	///		public &lt;retType&gt; Method1(&lt;type&gt; param1, &lt;type&gt; param2,...) {
	///            ManagementBaseObject inParams = null;
	///			   ManagementObject classObj = new ManagementObject(null, "WIN32_SHARE", null); // the clasname
	///            inParams = classObj.GetMethodParameters("Create");
	///            inParams["&lt;inparam1&gt;"] = &lt;Value&gt;;
	///            inParams["&lt;inoutparam2&gt;"] = &lt;Value&gt;;
	///            ................................
	///            ManagementBaseObject outParams = classObj.InvokeMethod("ChangeStartMode", inParams, null);
	///            inoutParam3 = (&lt;type&gt;)(outParams.Properties["&lt;inoutParam3&gt;"]);
	///            outParam4 = (String)(outParams.Properties["&lt;outParam4&gt;"]);
	///            ................................
	///            return (&lt;retType&gt;)(outParams.Properties["ReturnValue"].Value);
	///     }
	///     
	/// </summary>
	void GenerateMethods()
	{
		string strInParams = "inParams";
		string strOutParams = "outParams";
		string strClassObj	= "classObj";
		bool	bStatic		= false;
		bool	bPrivileges = false;
		CodePropertyReferenceExpression cprePriveleges = null;
		CimType cimRetType = CimType.SInt8;						// Initialized to remove warnings
		CodeTypeReference retRefType = null;
		bool isRetArray = false;
		bool bIsCimDateTimeInterval = false;

		ArrayList outParamsName = new ArrayList(5);
		ArrayList inoutParams = new ArrayList(5);
		ArrayList inoutParamsType = new ArrayList(5);
		for(int k=0;k< PublicMethods.Count;k++)
		{

			bStatic = false;
			MethodData meth = classobj.Methods[PublicMethods.GetKey(k).ToString()];
			string strTemp = PrivateNamesUsed["LateBoundObject"].ToString();
			if (meth.OutParameters != null)
			{
				if(meth.OutParameters.Properties != null)
				{
					//First Populate the out Params name so that we can find in/out parameters
					foreach (PropertyData prop in meth.OutParameters.Properties)
					{
						outParamsName.Add(prop.Name);
					}
				}
			}
			cmm = new CodeMemberMethod();
			cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final;
			cmm.Name = PublicMethods[meth.Name].ToString();			

			//Check if the method is static
			foreach (QualifierData q in meth.Qualifiers)
			{
				if (string.Compare(q.Name,"static",true,CultureInfo.InvariantCulture) == 0)
				{
					//It is a static function
					cmm.Attributes |= MemberAttributes.Static;
					bStatic = true;
					break;
				}
				else
					if (string.Compare(q.Name,"privileges",true,CultureInfo.InvariantCulture) == 0)
				{
					//It is a function which needs privileges to be set
					bPrivileges = true;
				}
			}
							
			// For Static method , the member variable "IsEmbedded" cannot be accessed
			cis = new CodeConditionStatement();
			cboe = new CodeBinaryOperatorExpression();

			if(bStatic)
			{
				cmm.Statements.Add(new CodeVariableDeclarationStatement("System.Boolean","IsMethodStatic",new CodePrimitiveExpression(bStatic)));
				cboe.Left = new CodeVariableReferenceExpression("IsMethodStatic");
				cboe.Right = new CodePrimitiveExpression(true);
			}
			else
			{
				cboe.Left = new CodeVariableReferenceExpression(PrivateNamesUsed["IsEmbedded"].ToString());
				cboe.Right = new CodePrimitiveExpression(false);
			}

			cboe.Operator = CodeBinaryOperatorType.ValueEquality;
			cis.Condition = cboe;

			bool bfirst = true;
			//Generate the statement 
			//	ManagementBaseObject inParams = null;
			cis.TrueStatements.Add(new CodeVariableDeclarationStatement(PublicNamesUsed["BaseObjClass"].ToString(),
				strInParams,new CodePrimitiveExpression(null)));


			if (bStatic == true)
			{
				string strPath = "mgmtPath";
				CodeObjectCreateExpression cocePath = new CodeObjectCreateExpression();
				cocePath.CreateType = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());
				cocePath.Parameters.Add(new CodeVariableReferenceExpression(PrivateNamesUsed["CreationClassName"].ToString()));
				cis.TrueStatements.Add(new CodeVariableDeclarationStatement(PublicNamesUsed["PathClass"].ToString(),strPath,cocePath));

				CodeObjectCreateExpression coce1 = new CodeObjectCreateExpression();
				coce1.CreateType = new CodeTypeReference(PublicNamesUsed["ManagementClass"].ToString());
				coce1.Parameters.Add(new CodeVariableReferenceExpression(PrivateNamesUsed["statMgmtScope"].ToString()));
				coce1.Parameters.Add(new CodeVariableReferenceExpression(strPath));
				coce1.Parameters.Add(new CodePrimitiveExpression(null));

				coce = new CodeObjectCreateExpression();
				coce.CreateType = new CodeTypeReference(PublicNamesUsed["ManagementClass"].ToString());
				coce.Parameters.Add(coce1);	
				cis.TrueStatements.Add(new CodeVariableDeclarationStatement(PublicNamesUsed["ManagementClass"].ToString(),strClassObj,coce1));
				strTemp = strClassObj;
			}

			if (bPrivileges == true)
			{
				//Generate the statement 
				//	Boolean bPriveleges = PrivateLateBoundObject.Scope.Options.EnablePrivileges;
				cprePriveleges = new CodePropertyReferenceExpression(new CodePropertyReferenceExpression(
					new CodePropertyReferenceExpression(
					new CodeSnippetExpression(bStatic ? strClassObj : PrivateNamesUsed["LateBoundObject"].ToString()),
					PublicNamesUsed["ScopeProperty"].ToString()),
					"Options"),
					"EnablePrivileges");

				cis.TrueStatements.Add(new CodeVariableDeclarationStatement("System.Boolean",
					PrivateNamesUsed["Privileges"].ToString(),cprePriveleges));

				cis.TrueStatements.Add(new CodeAssignStatement(cprePriveleges, new CodePrimitiveExpression(true)));
		
			}

			//Do these things only when there is a valid InParameters
			if (meth.InParameters != null)
			{
				//Now put the in parameters
				if (meth.InParameters.Properties != null)
				{
					foreach (PropertyData prop in meth.InParameters.Properties)
					{
						bIsCimDateTimeInterval = false;
						if (bfirst == true)
						{
							//Now Generate the statement
							//	inParams = privObject.GetMethodParameters(<MethodName>);
							cmie = new CodeMethodInvokeExpression(
								new CodeSnippetExpression(strTemp),
								"GetMethodParameters",
								new CodePrimitiveExpression(meth.Name));
							//cmie.MethodName = "GetMethodParameters";
							//cmie.TargetObject = new CodeSnippetExpression(PrivateNamesUsed["LateBoundObject"].ToString());
							//cmie.Parameters.Add(new CodePrimitiveExpression(meth.Name));
							cis.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(strInParams),cmie));
							bfirst = false;
						}

						cpde = new CodeParameterDeclarationExpression();
						cpde.Name = prop.Name;
						cpde.Type = ConvertCIMType(prop.Type,prop.IsArray);
						cpde.Direction = FieldDirection.In;


						if( prop.Type == CimType.DateTime)
						{
							CodeTypeReference dateType = cpde.Type;
							// Check if it is Time interval and if so change the type to Time Interval
							bIsCimDateTimeInterval = GetDateTimeType(prop,ref dateType);
							cpde.Type = dateType;
						}

						//Find out whether it is a in/out Parameter
						for(int i=0; i < outParamsName.Count;i++)
						{
							if (string.Compare(prop.Name,outParamsName[i].ToString(),true,CultureInfo.InvariantCulture) == 0)
							{
								//It is an in/out Parameter
								cpde.Direction = FieldDirection.Ref;
								inoutParams.Add(prop.Name);
								inoutParamsType.Add(cpde.Type);
							}
						}
					
						cmm.Parameters.Add(cpde);
						//Also generate the statement
						//inParams["PropName"] = Value;
						cie = new CodeIndexerExpression(new CodeSnippetExpression(strInParams),new CodePrimitiveExpression(prop.Name));
							
						// if the type of the property is CIM_REFERENCE then just get the
						// path as string set the property to that string
						if (prop.Type == CimType.Reference)
						{
							//Call this function to add code for converting the path to
							// string and assigning it to parameter
							AddPropertySet(cie,prop.IsArray,cis.TrueStatements,PublicNamesUsed["PathClass"].ToString(),new CodeVariableReferenceExpression(cpde.Name));
						}
						else
						if (prop.Type == CimType.DateTime)
						{
							//Call this function to add code for converting the DateTime,TimeSpan to string
							// and assigning it to the parameter
							if(bIsCimDateTimeInterval)
							{
								AddPropertySet(cie,prop.IsArray,cis.TrueStatements,"System.TimeSpan",new CodeVariableReferenceExpression(cpde.Name));
							}
							else
							{
								AddPropertySet(cie,prop.IsArray,cis.TrueStatements,"System.DateTime",new CodeVariableReferenceExpression(cpde.Name));
							}
						}
						else
						{
							cis.TrueStatements.Add(new CodeAssignStatement(cie,new CodeVariableReferenceExpression(cpde.Name)));
						}
					}
				}
			}
			//Now clear the outParamsName array
			outParamsName.Clear();
			bool bInOut;
			bool bRetVal = false;
			bfirst = true;
			bool bInvoke = false;
			CodeMethodInvokeExpression cmie2 = null;
			//Do these only when the outParams is Valid
			if (meth.OutParameters != null)
			{
				if (meth.OutParameters.Properties != null)
				{
					foreach (PropertyData prop in meth.OutParameters.Properties)
					{
						bIsCimDateTimeInterval = false;
						if (bfirst == true)
						{
							//Now generate the statement
							//	ManagementBaseObject outParams = privObject.InvokeMethod(<methodName>,inParams,options);
							cmie = new CodeMethodInvokeExpression(
								new CodeSnippetExpression(strTemp),
								"InvokeMethod");

							cmie.Parameters.Add(new CodePrimitiveExpression(meth.Name));
							cmie.Parameters.Add(new CodeSnippetExpression(strInParams));
							cmie.Parameters.Add(new CodePrimitiveExpression(null));
							cis.TrueStatements.Add(new CodeVariableDeclarationStatement(PublicNamesUsed["BaseObjClass"].ToString(),strOutParams,cmie));
							bfirst = false;
							bInvoke = true;
						}

						bInOut = false;
						for(int i=0; i < inoutParams.Count;i++)
						{
							if (string.Compare(prop.Name,inoutParams[i].ToString(),true,CultureInfo.InvariantCulture) == 0)
							{
								bInOut = true;
							}
						}
						if (bInOut == true)
							continue;

						if (string.Compare(prop.Name,"ReturnValue",true,CultureInfo.InvariantCulture) == 0)
						{
							cmm.ReturnType = ConvertCIMType(prop.Type,prop.IsArray);
							bRetVal = true;
							cimRetType = prop.Type;

							if( prop.Type == CimType.DateTime)
							{
								CodeTypeReference dateType = cmm.ReturnType;
								// Check if it is Time interval and if so change the type to Time Interval
								bool isRetTypeTimeInterval = GetDateTimeType(prop,ref dateType);
								cmm.ReturnType = dateType;
							}
							retRefType = cmm.ReturnType;
							isRetArray = prop.IsArray;
						}
						else
						{
							cpde = new CodeParameterDeclarationExpression();
							cpde.Name = prop.Name;
							cpde.Type = ConvertCIMType(prop.Type,prop.IsArray);
							cpde.Direction = FieldDirection.Out;
							cmm.Parameters.Add(cpde);

							if( prop.Type == CimType.DateTime)
							{
								CodeTypeReference dateType = cpde.Type;
								// Check if it is Time interval and if so change the type to Time Interval
								bIsCimDateTimeInterval = GetDateTimeType(prop,ref dateType);
								cpde.Type = dateType;
							}

							//Now for each out params generate the statement
							//	<outParam> = outParams.Properties["<outParam>"];
							cpre = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(strOutParams),"Properties");
							cie = new CodeIndexerExpression(cpre,new CodePrimitiveExpression(prop.Name));

							if (prop.Type == CimType.Reference)
							{
								//Call this function to add code for converting string CIM_REFERENCE
								// to ManagementPath
								GenerateCodeForRefAndDateTimeTypes(cie,prop.IsArray,cis.TrueStatements,PublicNamesUsed["PathClass"].ToString(),new CodeVariableReferenceExpression(prop.Name),true);
							}
							else
							if (prop.Type == CimType.DateTime)
							{
								//Call this function to add code for converting datetime,TimeSpan in DMTF formate
								// to System.DateTime
								if(bIsCimDateTimeInterval)
								{
									GenerateCodeForRefAndDateTimeTypes(cie,prop.IsArray,cis.TrueStatements,"System.TimeSpan",new CodeVariableReferenceExpression(prop.Name),true);
								}
								else
								{
									GenerateCodeForRefAndDateTimeTypes(cie,prop.IsArray,cis.TrueStatements,"System.DateTime",new CodeVariableReferenceExpression(prop.Name),true);
								}
							}
							else
							{
								if(prop.IsArray || prop.Type == CimType.Object)
								{
									cis.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(prop.Name),
																	new CodeCastExpression(ConvertCIMType(prop.Type,prop.IsArray),
																	new CodePropertyReferenceExpression(cie,"Value"))));
								}
								else
								{
									cmie2 = new CodeMethodInvokeExpression();
									cmie2.Parameters.Add(new CodePropertyReferenceExpression(cie,"Value"));
									cmie2.Method.MethodName = GetConversionFunction(prop.Type);
									cmie2.Method.TargetObject = new CodeSnippetExpression("System.Convert");

									cis.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(prop.Name),cmie2));
								}
							
							}


							//Now for each out params generate the statement if it is an embedded instance
							if(prop.Type == CimType.DateTime && prop.IsArray == false)
							{
								if(bIsCimDateTimeInterval)
								{
									coce = new CodeObjectCreateExpression();
									coce.CreateType = new CodeTypeReference("System.TimeSpan");
									coce.Parameters.Add(new CodePrimitiveExpression(0));
									coce.Parameters.Add(new CodePrimitiveExpression(0));
									coce.Parameters.Add(new CodePrimitiveExpression(0));
									coce.Parameters.Add(new CodePrimitiveExpression(0));
									coce.Parameters.Add(new CodePrimitiveExpression(0));
									
									cis.FalseStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(prop.Name),coce));
								}
								else
								{
									cis.FalseStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(prop.Name),
															new CodePropertyReferenceExpression(new CodeVariableReferenceExpression("DateTime"),
																								"MinValue")));
								}

							}
							else
							if(IsPropertyValueType(prop.Type) && prop.IsArray == false)
							{
								cmie2 = new CodeMethodInvokeExpression();
								cmie2.Parameters.Add(new CodePrimitiveExpression(0));
								cmie2.Method.MethodName = GetConversionFunction(prop.Type);
								cmie2.Method.TargetObject = new CodeSnippetExpression("System.Convert");
								cis.FalseStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(prop.Name),cmie2));
							}
							else
							{
								cis.FalseStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(prop.Name),
									new CodePrimitiveExpression(null)));
							}

						}
					}
				}
			}

			if (bInvoke == false)
			{
				//Now there is no out parameters to invoke the function
				//So just call Invoke.
				cmie = new CodeMethodInvokeExpression(
					new CodeSnippetExpression(PrivateNamesUsed["LateBoundObject"].ToString()),
					"InvokeMethod"
					);

				cmie.Parameters.Add(new CodePrimitiveExpression(meth.Name));
				cmie.Parameters.Add(new CodeSnippetExpression(strInParams));
				cmie.Parameters.Add(new CodePrimitiveExpression(null));			// Bug NO: 108605

				cmis = new CodeExpressionStatement(cmie);
				cis.TrueStatements.Add(cmis);
			}

			//Now for each in/out params generate the statement
			//	<inoutParam> = outParams.Properties["<inoutParam>"];
			for(int i=0;i < inoutParams.Count;i++)
			{
				cpre = new CodePropertyReferenceExpression(new CodeSnippetExpression(strOutParams),"Properties");
				cie = new CodeIndexerExpression(cpre,new CodePrimitiveExpression(inoutParams[i].ToString()));
				cis.TrueStatements.Add(new CodeAssignStatement(new CodeSnippetExpression(inoutParams[i].ToString()),
					new CodeCastExpression((CodeTypeReference)inoutParamsType[i],
					new CodePropertyReferenceExpression(cie,"Value"))));
			}
			inoutParams.Clear();

			// Assign the privileges back
			if (bPrivileges == true)
			{
				cis.TrueStatements.Add(new CodeAssignStatement(cprePriveleges, new CodeVariableReferenceExpression(PrivateNamesUsed["Privileges"].ToString())));
			}

			//Now check if there is a return value. If there is one then return it from the function
			if (bRetVal == true)
			{
				CodeVariableDeclarationStatement cRetVal = new CodeVariableDeclarationStatement(retRefType,"retVar");
				cpre = new CodePropertyReferenceExpression(new CodeSnippetExpression(strOutParams),"Properties");
				cie = new CodeIndexerExpression(cpre,new CodePrimitiveExpression("ReturnValue"));

				if (retRefType.BaseType == PublicNamesUsed["PathClass"].ToString())
				{
					cmm.Statements.Add(cRetVal);
					cmm.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression("retVar"),new CodePrimitiveExpression(null)));

					//Call this function to add code for converting string CIM_REFERENCE
					// to ManagementPath and return
					GenerateCodeForRefAndDateTimeTypes(cie,isRetArray,cis.TrueStatements,PublicNamesUsed["PathClass"].ToString(),new CodeVariableReferenceExpression("retVar"),true);
					cis.TrueStatements.Add(new CodeMethodReturnStatement(new CodeVariableReferenceExpression("retVar")));
					cis.FalseStatements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(null)));
				}
				else
				if (retRefType.BaseType == "System.DateTime")
				{
					cmm.Statements.Add(cRetVal);
					cmm.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression("retVar"),
						new CodePropertyReferenceExpression(new CodeVariableReferenceExpression("DateTime"),"MinValue")));
					
					//Call this function to add code for converting DMTF format string datetime to System.DateTime before returning
					GenerateCodeForRefAndDateTimeTypes(cie,isRetArray,cis.TrueStatements,"System.DateTime",new CodeVariableReferenceExpression("retVar"),true);
					cis.TrueStatements.Add(new CodeMethodReturnStatement(new CodeVariableReferenceExpression("retVar")));
					cis.FalseStatements.Add(new CodeMethodReturnStatement(new CodeVariableReferenceExpression("retVar")));
				}
				else
				if (retRefType.BaseType == "System.TimeSpan")
				{
					cmm.Statements.Add(cRetVal);
					coce = new CodeObjectCreateExpression();
					coce.CreateType = new CodeTypeReference("System.TimeSpan");
					coce.Parameters.Add(new CodePrimitiveExpression(0));
					coce.Parameters.Add(new CodePrimitiveExpression(0));
					coce.Parameters.Add(new CodePrimitiveExpression(0));
					coce.Parameters.Add(new CodePrimitiveExpression(0));
					coce.Parameters.Add(new CodePrimitiveExpression(0));

					cmm.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression("retVar"),coce));
					
					//Call this function to add code for converting DMTF format string Time Interval to System.TimeSpan before returning
					GenerateCodeForRefAndDateTimeTypes(cie,isRetArray,cis.TrueStatements,"System.TimeSpan",new CodeVariableReferenceExpression("retVar"),true);
					cis.TrueStatements.Add(new CodeMethodReturnStatement(new CodeVariableReferenceExpression("retVar")));
					cis.FalseStatements.Add(new CodeMethodReturnStatement(new CodeVariableReferenceExpression("retVar")));
				}
				else
				// if the return value is not array and not of type CimType.Object
				if(retRefType.ArrayRank == 0 && retRefType.BaseType != PublicNamesUsed["BaseObjClass"].ToString())
				{
					cmie = new CodeMethodInvokeExpression();
					cmie.Parameters.Add(new CodePropertyReferenceExpression(cie,"Value"));
					cmie.Method.MethodName = GetConversionFunction(cimRetType);
					cmie.Method.TargetObject = new CodeSnippetExpression("System.Convert");

					cis.TrueStatements.Add(new CodeMethodReturnStatement(cmie));

					cmie = new CodeMethodInvokeExpression();
					cmie.Parameters.Add(new CodePrimitiveExpression(0));
					cmie.Method.MethodName = GetConversionFunction(cimRetType);
					cmie.Method.TargetObject = new CodeSnippetExpression("System.Convert");

					cis.FalseStatements.Add(new CodeMethodReturnStatement(cmie));
				}
				// if the return type is array, then just do type casting before returning
				else
				{
					cis.TrueStatements.Add(new CodeMethodReturnStatement(
										new CodeCastExpression(retRefType,new CodePropertyReferenceExpression(cie,"Value"))));

					cis.FalseStatements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(null)));
				}
			}
			
			cmm.Statements.Add(cis);
			cc.Members.Add(cmm);
		}
	}

	/// <summary>
	/// This function returns a Collectionclass for the query 
	///		"Select * from &lt;ClassName&gt;"
	///	This is a static method. The output is like this
	///		public static ServiceCollection All()
	///		{
	///			return GetInstances((System.Management.ManagementScope)null,(System.Management.EnumerateionOptions)null);
	///		}        
	/// </summary>
	void GenerateGetInstancesWithNoParameters()
	{
		cmm = new CodeMemberMethod();
        
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static ;
		cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
		cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());

		cmie = new CodeMethodInvokeExpression();

		cmie.Method.MethodName = PublicNamesUsed["FilterFunction"].ToString();
		cmie.Parameters.Add(new CodeCastExpression(new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString()),
								new CodePrimitiveExpression(null)));
		cmie.Parameters.Add(new CodeCastExpression(new CodeTypeReference(PublicNamesUsed["QueryOptionsClass"].ToString()),
								new CodePrimitiveExpression(null)));
		
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));

		cc.Members.Add(cmm);
		cmm.Comments.Add(new CodeCommentStatement(GetString("COMMENT_GETINSTANCES")));
	}

	/// <summary>
	/// This function will accept the condition and will return collection for the query
	///		"select * from &lt;ClassName&gt; where &lt;condition&gt;"
	///	The generated code will be like
	///		public static ServiceCollection GetInstances(String Condition) {
	///			return GetInstances(null,Condition,null);
	///     }
	/// </summary>
	void GenerateGetInstancesWithCondition()
	{
		string strCondition = "condition";
		cmm = new CodeMemberMethod();
        
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static ;
		cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
		cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("System.String",strCondition));

		cmie = new CodeMethodInvokeExpression(
			null, //no TargetObject?
			PublicNamesUsed["FilterFunction"].ToString()
			);

		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmie.Parameters.Add(new CodeVariableReferenceExpression(strCondition));
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));

		cc.Members.Add(cmm);
	}

	/// <summary>
	/// This function returns the collection for the query 
	///		"select &lt;parameterList&gt; from &lt;ClassName&gt;"
	///	The generated output is like
	///		public static ServiceCollection GetInstances(String []selectedProperties) {
	///			return GetInstances(null,null,selectedProperties);
	///		}
	/// </summary>
	void GenerateGetInstancesWithProperties()
	{
		string strSelectedProperties = "selectedProperties";
		cmm = new CodeMemberMethod();
        
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static ;
		cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
		cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("System.String []",strSelectedProperties));

		cmie = new CodeMethodInvokeExpression(
			null,
			PublicNamesUsed["FilterFunction"].ToString()
			);
		//cmie.MethodName = PublicNamesUsed["FilterFunction"].ToString();
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmie.Parameters.Add(new CodeVariableReferenceExpression(strSelectedProperties));
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));

		cc.Members.Add(cmm);
	}

	/// <summary>
	/// This function returns the collection for the query 
	///		"select &lt;parameterList> from &lt;ClassName&gt; where &lt;WhereClause&gt;"
	///	The generated output is like
	///		public static ServiceCollection GetInstances(String condition, String []selectedProperties) {
	///			return GetInstances(null,condition,selectedProperties);
	///		}
	/// </summary>
	void GenerateGetInstancesWithWhereProperties()
	{
		string strSelectedProperties = "selectedProperties";
		string strCondition = "condition";
		cmm = new CodeMemberMethod();
        
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static ;
		cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
		cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("System.String",strCondition));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("System.String []",strSelectedProperties));

		cmie = new CodeMethodInvokeExpression(
			null, //no TargetObject?
			PublicNamesUsed["FilterFunction"].ToString()
			);

		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmie.Parameters.Add(new CodeVariableReferenceExpression(strCondition));
		cmie.Parameters.Add(new CodeVariableReferenceExpression(strSelectedProperties));
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));

		cc.Members.Add(cmm);
	}

	/// <summary>
	/// This function returns a Collectionclass for the query 
	///		"Select * from &lt;ClassName&gt;"
	///	This is a static method. The output is like this
	///	public static (ObjectCollection)GetInstances(System.Management.ManagementScope mgmtScope, System.Management.EnumerationOptions enumOptions) 
	///	{
	///		if ((mgmtScope == null)) 
	///		{
	///			mgmtScope = new System.Management.ManagementScope();
	///			mgmtScope.Path.NamespacePath = "root\\CimV2";
	///		}
	///		System.Management.ManagementPath pathObj = new System.Management.ManagementPath();
	///		pathObj.ClassName = "CIM_LogicalDisk";
	///		pathObj.NamespacePath = "root\\CimV2";
	///		System.Management.ManagementClass clsObject = new System.Management.ManagementClass(mgmtScope, pathObj, null);
	///		if ((enumOptions == null)) 
	///		{
	///			enumOptions = new System.Management.EnumerationOptions();
	///			enumOptions.EnsureLocatable = true;
	///		}
	///		return new ObjectCollection(clsObject.GetInstances(enumOptions));
	///	}
	///	This method takes the scope which is useful for connection to remote machine
	/// </summary>
	void GenerateGetInstancesWithScope()
	{
		cmm = new CodeMemberMethod();
        
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static ;
		cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
		cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),PrivateNamesUsed["ScopeParam"].ToString()));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["QueryOptionsClass"].ToString(),
								PrivateNamesUsed["EnumParam"].ToString()));

		
		string strClass = "clsObject";
		string pathObj = "pathObj";


		cis = new CodeConditionStatement();
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeSnippetExpression(PrivateNamesUsed["ScopeParam"].ToString());
		cboe.Right = new CodePrimitiveExpression(null);
		cboe.Operator = CodeBinaryOperatorType.IdentityEquality;
		cis.Condition = cboe;
		
		CodeConditionStatement cis1 = new CodeConditionStatement();
		CodeBinaryOperatorExpression cboe1 = new CodeBinaryOperatorExpression();
		cboe1.Left = new CodeVariableReferenceExpression(PrivateNamesUsed["statMgmtScope"].ToString());
		cboe1.Right = new CodePrimitiveExpression(null);
		cboe1.Operator = CodeBinaryOperatorType.IdentityEquality;
		cis1.Condition = cboe1;

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString());
		cis1.TrueStatements.Add(new CodeAssignStatement(new CodeSnippetExpression(PrivateNamesUsed["ScopeParam"].ToString()),coce));	

		cis1.TrueStatements.Add(new CodeAssignStatement(new CodePropertyReferenceExpression(
														new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(PrivateNamesUsed["ScopeParam"].ToString()),
														"Path"),"NamespacePath"),
														new CodePrimitiveExpression(classobj.Scope.Path.NamespacePath)));

	
		cis1.FalseStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(PrivateNamesUsed["ScopeParam"].ToString()),
									new CodeVariableReferenceExpression(PrivateNamesUsed["statMgmtScope"].ToString())));
									
		cis.TrueStatements.Add(cis1);
		cmm.Statements.Add(cis);

		// Create a path object for the class
		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());

		cmm.Statements.Add(new CodeVariableDeclarationStatement(PublicNamesUsed["PathClass"].ToString(),pathObj,coce));

		cmm.Statements.Add(new CodeAssignStatement(new CodePropertyReferenceExpression(
										new CodeVariableReferenceExpression(pathObj),"ClassName"),
										new CodePrimitiveExpression(OriginalClassName)));

		cmm.Statements.Add(new CodeAssignStatement(new CodePropertyReferenceExpression(
										new CodeVariableReferenceExpression(pathObj),"NamespacePath"),
										new CodePrimitiveExpression(classobj.Scope.Path.NamespacePath)));
	

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["ManagementClass"].ToString());
		coce.Parameters.Add(new CodeVariableReferenceExpression(PrivateNamesUsed["ScopeParam"].ToString()));
		coce.Parameters.Add(new CodeVariableReferenceExpression(pathObj));
		coce.Parameters.Add(new CodePrimitiveExpression(null));

		cmm.Statements.Add(new CodeVariableDeclarationStatement(PublicNamesUsed["ManagementClass"].ToString(),
							strClass,coce));

		cis = new CodeConditionStatement();
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeVariableReferenceExpression(PrivateNamesUsed["EnumParam"].ToString());
		cboe.Right = new CodePrimitiveExpression(null);
		cboe.Operator = CodeBinaryOperatorType.IdentityEquality;
		cis.Condition = cboe;

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["QueryOptionsClass"].ToString());
		cis.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(PrivateNamesUsed["EnumParam"].ToString()),
			coce));
		cis.TrueStatements.Add(new CodeAssignStatement(new CodePropertyReferenceExpression(
			new CodeVariableReferenceExpression(PrivateNamesUsed["EnumParam"].ToString()),
			"EnsureLocatable"),
			new CodePrimitiveExpression(true)));

		cmm.Statements.Add(cis);


		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());
		
		cmie = new CodeMethodInvokeExpression();
		cmie.Method = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression(strClass),"GetInstances");
		cmie.Parameters.Add(new CodeVariableReferenceExpression(PrivateNamesUsed["EnumParam"].ToString()));
		coce.Parameters.Add(cmie);
		cmm.Statements.Add(new CodeMethodReturnStatement(coce));

		cc.Members.Add(cmm);
		
	}

	/// <summary>
	/// This function will accept the condition and will return collection for the query
	///		"select * from &lt;ClassName&gt; where &lt;condition&gt;"
	///	The generated code will be like
	///		public static ServiceCollection GetInstances(String Condition) {
	///			return GetInstances(scope,Condition,null);
	///     }
	/// </summary>
	void GenerateGetInstancesWithScopeCondition()
	{
		string strCondition = "condition";
		cmm = new CodeMemberMethod();
        
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static ;
		cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
		cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),PrivateNamesUsed["ScopeParam"].ToString()));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("System.String",strCondition));

		cmie = new CodeMethodInvokeExpression(
			null,
			PublicNamesUsed["FilterFunction"].ToString()
			);
		//cmie.MethodName = PublicNamesUsed["FilterFunction"].ToString();
		cmie.Parameters.Add(new CodeVariableReferenceExpression(PrivateNamesUsed["ScopeParam"].ToString()));
		cmie.Parameters.Add(new CodeVariableReferenceExpression(strCondition));
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));

		cc.Members.Add(cmm);
	}

	/// <summary>
	/// This function returns the collection for the query 
	///		"select &lt;parameterList&gt; from &lt;ClassName&gt;"
	///	The generated output is like
	///		public static ServiceCollection GetInstances(String []selectedProperties) {
	///			return GetInstances(scope,null,selectedProperties);
	///		}
	/// </summary>
	void GenerateGetInstancesWithScopeProperties()
	{
		string strSelectedProperties = "selectedProperties";
		cmm = new CodeMemberMethod();
        
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static ;
		cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
		cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),PrivateNamesUsed["ScopeParam"].ToString()));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("System.String []",strSelectedProperties));

		cmie = new CodeMethodInvokeExpression(
			null, //no TargetObject?
			PublicNamesUsed["FilterFunction"].ToString()
			);

		cmie.Parameters.Add(new CodeVariableReferenceExpression(PrivateNamesUsed["ScopeParam"].ToString()));
		cmie.Parameters.Add(new CodePrimitiveExpression(null));
		cmie.Parameters.Add(new CodeVariableReferenceExpression(strSelectedProperties));
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));

		cc.Members.Add(cmm);
	}

	/// <summary>
	/// This function generates the code like 
	/// 	public static ServiceCollection GetInstances(ManagementScope scope,String Condition, String[] selectedProperties)	{
	///			if (scope == null)
	///			{
	///				scope = new ManagementScope();
	///				scope.Path.NamespacePath = WMINamespace;
	///			}
	/// 		ManagementObjectSearcher ObjectSearcher = new ManagementObjectSearcher(scope,new SelectQuery("Win32_Service",Condition,selectedProperties));
	///			QueryOptions query = new QueryOptions();
	///			query.EnsureLocatable = true;
	///			ObjectSearcher.Options = query;
	///	        return new ServiceCollection(ObjectSearcher.Get());
	///		}
	/// </summary>
	void GenerateGetInstancesWithScopeWhereProperties()
	{
		string strCondition = "condition";
		string strSelectedProperties = "selectedProperties";
		string strObjectSearcher = "ObjectSearcher";

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static ;
		cmm.Name = PublicNamesUsed["FilterFunction"].ToString();
		cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());

		cmm.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),PrivateNamesUsed["ScopeParam"].ToString()));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("System.String",strCondition));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("System.String []",strSelectedProperties));

		cis = new CodeConditionStatement();
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeSnippetExpression(PrivateNamesUsed["ScopeParam"].ToString());
		cboe.Right = new CodePrimitiveExpression(null);
		cboe.Operator = CodeBinaryOperatorType.IdentityEquality;
		cis.Condition = cboe;


		CodeConditionStatement cis1 = new CodeConditionStatement();
		CodeBinaryOperatorExpression cboe1 = new CodeBinaryOperatorExpression();
		cboe1.Left = new CodeVariableReferenceExpression(PrivateNamesUsed["statMgmtScope"].ToString());
		cboe1.Right = new CodePrimitiveExpression(null);
		cboe1.Operator = CodeBinaryOperatorType.IdentityEquality;
		cis1.Condition = cboe1;

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString());
		cis1.TrueStatements.Add(new CodeAssignStatement(new CodeSnippetExpression(PrivateNamesUsed["ScopeParam"].ToString()),coce));	

		cis1.TrueStatements.Add(new CodeAssignStatement(new CodePropertyReferenceExpression(
			new CodePropertyReferenceExpression(new CodeSnippetExpression(PrivateNamesUsed["ScopeParam"].ToString()),
			"Path"),"NamespacePath"),
			new CodePrimitiveExpression(classobj.Scope.Path.NamespacePath)));

		cis1.FalseStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(PrivateNamesUsed["ScopeParam"].ToString()),
									new CodeVariableReferenceExpression(PrivateNamesUsed["statMgmtScope"].ToString())));

	
		cis.TrueStatements.Add(cis1);
		cmm.Statements.Add(cis);
		CodeObjectCreateExpression coce1 = new CodeObjectCreateExpression();
		coce1.CreateType = new CodeTypeReference(PublicNamesUsed["QueryClass"].ToString());
		coce1.Parameters.Add(new CodePrimitiveExpression(OriginalClassName));
		coce1.Parameters.Add(new CodeSnippetExpression(strCondition));
		coce1.Parameters.Add(new CodeSnippetExpression(strSelectedProperties));

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["ObjectSearcherClass"].ToString());
		coce.Parameters.Add(new CodeSnippetExpression(PrivateNamesUsed["ScopeParam"].ToString()));
		coce.Parameters.Add(coce1);

		cmm.Statements.Add(new CodeVariableDeclarationStatement(PublicNamesUsed["ObjectSearcherClass"].ToString(),
			strObjectSearcher,coce));

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["QueryOptionsClass"].ToString());

		cmm.Statements.Add(new CodeVariableDeclarationStatement(
								new CodeTypeReference(PublicNamesUsed["QueryOptionsClass"].ToString()),
								PrivateNamesUsed["EnumParam"].ToString(),coce));

		cmm.Statements.Add(new CodeAssignStatement(new CodePropertyReferenceExpression(
								new CodeVariableReferenceExpression(PrivateNamesUsed["EnumParam"].ToString()),
								"EnsureLocatable"),
								new CodePrimitiveExpression(true)));



		cmm.Statements.Add(new CodeAssignStatement(new CodePropertyReferenceExpression(
			new CodeSnippetExpression(strObjectSearcher),
			"Options"),
			new CodeVariableReferenceExpression(PrivateNamesUsed["EnumParam"].ToString())));

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PrivateNamesUsed["CollectionClass"].ToString());
		coce.Parameters.Add(new CodeMethodInvokeExpression(new CodeSnippetExpression(strObjectSearcher),
			"Get"));
		cmm.Statements.Add(new CodeMethodReturnStatement(coce));

		cc.Members.Add(cmm);
	}

	/// <summary>
	/// This function will add the variable as a private member to the class.
	/// The generated code will look like this
	///         private &lt;MemberType&gt; &lt;MemberName&gt;;
	/// </summary>
	void GeneratePrivateMember(string memberName,string MemberType,string Comment)
	{
		GeneratePrivateMember(memberName,MemberType,null,false,Comment);
	}

	/// <summary>
	/// This function will add the variable as a private member to the class.
	/// The generated code will look like this
	///         private &lt;MemberType&gt; &lt;MemberName&gt; = &lt;initValue&gt;;
	/// </summary>
	void GeneratePrivateMember(string memberName,string MemberType,CodeExpression initExpression,bool isStatic,string Comment)
	{
		cf = new CodeMemberField();
		cf.Name = memberName;
		cf.Attributes = MemberAttributes.Private | MemberAttributes.Final ;
		if(isStatic == true)
		{
			cf.Attributes = cf.Attributes | MemberAttributes.Static;
		}
		cf.Type = new CodeTypeReference(MemberType);
		if (initExpression != null)
		{
			cf.InitExpression = initExpression;
		}
		cc.Members.Add(cf);

		if(Comment != null && Comment != string.Empty)
		{
			cf.Comments.Add(new CodeCommentStatement(Comment));
		}
	}

	CodeTypeDeclaration GenerateTypeConverterClass()
	{
		string TypeDescriptorContextClass = "System.ComponentModel.ITypeDescriptorContext";
		string contextObject = "context";
		string TypeDstObject = "destinationType";
		string ValueVar = "value";
		string CultureInfoClass	= "System.Globalization.CultureInfo";
		string CultureInfoVar = "culture";
		string IDictionary	= "System.Collections.IDictionary";
		string DictVar		= "dictionary";
		string propColl		= "PropertyDescriptorCollection";
		string AttributeVar	= "attributeVar";


		string baseTypeParam = "baseType";
		string baseTypeMemberVariable = "baseConverter";
		string TypeDescriptorClass = "TypeDescriptor";
		string srcType	= "srcType";
	
	
		CodeTypeDeclaration CodeConvertorClass = new CodeTypeDeclaration(PrivateNamesUsed["ConverterClass"].ToString());
		CodeConvertorClass.BaseTypes.Add(PublicNamesUsed["TypeConverter"].ToString());

		cf = new CodeMemberField();
		cf.Name = baseTypeMemberVariable;
		cf.Attributes = MemberAttributes.Private | MemberAttributes.Final ;
		cf.Type = new CodeTypeReference(PublicNamesUsed["TypeConverter"].ToString());

		CodeConvertorClass.Members.Add(cf);

		cctor = new CodeConstructor();
		//		cctor.Attributes = MemberAttributes.Assembly;
		cctor.Attributes = MemberAttributes.Public ;
		cpde = new CodeParameterDeclarationExpression();
		cpde.Name = baseTypeParam;
		cpde.Type = new CodeTypeReference("System.Type");
		cctor.Parameters.Add(cpde);

		cmie = new CodeMethodInvokeExpression(new CodeSnippetExpression(TypeDescriptorClass),"GetConverter");

		cmie.Parameters.Add(new CodeSnippetExpression(baseTypeParam));

		cctor.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(baseTypeMemberVariable),cmie));
		CodeConvertorClass.Members.Add(cctor);

		/*
		public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type srcType);
		{
			return baseType.CanConvertFrom(srcType);
		}
		*/

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Override  | MemberAttributes.Overloaded;
		cmm.Name = "CanConvertFrom";
		cmm.ReturnType = new CodeTypeReference("System.Boolean");

		cmm.Parameters.Add(new CodeParameterDeclarationExpression(TypeDescriptorContextClass,contextObject));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("System.Type",srcType));
	
		cmie = new CodeMethodInvokeExpression(new CodeSnippetExpression(baseTypeMemberVariable),"CanConvertFrom");
		cmie.Parameters.Add(new CodeVariableReferenceExpression(contextObject));
		cmie.Parameters.Add(new CodeVariableReferenceExpression(srcType));
	
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
		CodeConvertorClass.Members.Add(cmm);



		/*
		public virtual bool CanConvertTo(ITypeDescriptorContext context, Type TypeDstObject);
		{
			return baseType.CanConvertTo(context,TypeDstObject);
		}
		*/

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Override  | MemberAttributes.Overloaded;
		cmm.Name = "CanConvertTo";
		cmm.ReturnType = new CodeTypeReference("System.Boolean");

		cmm.Parameters.Add(new CodeParameterDeclarationExpression(TypeDescriptorContextClass,contextObject));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("System.Type",TypeDstObject));
	
		cmie = new CodeMethodInvokeExpression(new CodeSnippetExpression(baseTypeMemberVariable),"CanConvertTo");
		cmie.Parameters.Add(new CodeVariableReferenceExpression(contextObject));
		cmie.Parameters.Add(new CodeVariableReferenceExpression(TypeDstObject));
	
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
		CodeConvertorClass.Members.Add(cmm);



		/*
		public virtual object ConvertFrom(ITypeDescriptorContext context,CultureInfo culInfo, object value);
		{
			return baseType.ConvertFrom(context,culInfo,value);
		}
		*/

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Override  | MemberAttributes.Overloaded;
		cmm.Name = "ConvertFrom";
		cmm.ReturnType = new CodeTypeReference("System.Object");

		cmm.Parameters.Add(new CodeParameterDeclarationExpression(TypeDescriptorContextClass,contextObject));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(CultureInfoClass,CultureInfoVar));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference("System.Object"),ValueVar));
	
		cmie = new CodeMethodInvokeExpression(new CodeSnippetExpression(baseTypeMemberVariable),"ConvertFrom");
		cmie.Parameters.Add(new CodeVariableReferenceExpression(contextObject));
		cmie.Parameters.Add(new CodeVariableReferenceExpression(CultureInfoVar));
		cmie.Parameters.Add(new CodeVariableReferenceExpression(ValueVar));
	
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
		CodeConvertorClass.Members.Add(cmm);



		/*
			public virtual object CreateInstance(ITypeDescriptorContext,IDictionary dictionary);
			{
				return baseType.CreateInstance(context,dictionary);
			}
			*/

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Override  | MemberAttributes.Overloaded;
		cmm.ReturnType = new CodeTypeReference("System.Object");

		cmm.Name = "CreateInstance";
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(TypeDescriptorContextClass,contextObject));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(IDictionary,DictVar));
	
		cmie = new CodeMethodInvokeExpression(new CodeSnippetExpression(baseTypeMemberVariable),"CreateInstance");
		cmie.Parameters.Add(new CodeVariableReferenceExpression(contextObject));
		cmie.Parameters.Add(new CodeVariableReferenceExpression(DictVar));
	
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
		CodeConvertorClass.Members.Add(cmm);


		/*
			public virtual bool GetCreateInstanceSupported(ITypeDescriptorContext context);
			{
				return baseType.GetCreateInstanceSupported(context);
			}
			*/

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Override  | MemberAttributes.Overloaded;
		cmm.Name = "GetCreateInstanceSupported";
		cmm.ReturnType = new CodeTypeReference("System.Boolean");

		cmm.Parameters.Add(new CodeParameterDeclarationExpression(TypeDescriptorContextClass,contextObject));
	
		cmie = new CodeMethodInvokeExpression(new CodeSnippetExpression(baseTypeMemberVariable),"GetCreateInstanceSupported");
		cmie.Parameters.Add(new CodeVariableReferenceExpression(contextObject));
	
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
		CodeConvertorClass.Members.Add(cmm);

		/*
			public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context,object value,Attribute [] attributes);
			{
				return baseType.GetProperties(context,value);
			}
			*/

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Override  | MemberAttributes.Overloaded;
		cmm.Name = "GetProperties";
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(TypeDescriptorContextClass,contextObject));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference("System.Object"),ValueVar));

		CodeTypeReference crt = new CodeTypeReference(new CodeTypeReference("System.Attribute"),1);
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(crt,AttributeVar));
		CodeParameterDeclarationExpression cpdm = new CodeParameterDeclarationExpression();
		cmm.ReturnType = new CodeTypeReference(propColl);
	
		cmie = new CodeMethodInvokeExpression(new CodeSnippetExpression(baseTypeMemberVariable),"GetProperties");
		cmie.Parameters.Add(new CodeVariableReferenceExpression(contextObject));
		cmie.Parameters.Add(new CodeVariableReferenceExpression(ValueVar));
		cmie.Parameters.Add(new CodeVariableReferenceExpression(AttributeVar));
	
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
		CodeConvertorClass.Members.Add(cmm);

		/*
			public virtual GetPropertiesSupported(ITypeDescriptorContext context);
			{
				return baseType.GetPropertiesSupported(context);
			}
			*/

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Override  | MemberAttributes.Overloaded;
		cmm.Name = "GetPropertiesSupported";
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(TypeDescriptorContextClass,contextObject));
		cmm.ReturnType = new CodeTypeReference("System.Boolean");
	
		cmie = new CodeMethodInvokeExpression(new CodeSnippetExpression(baseTypeMemberVariable),"GetPropertiesSupported");
		cmie.Parameters.Add(new CodeVariableReferenceExpression(contextObject));
	
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
		CodeConvertorClass.Members.Add(cmm);
	
		/*
			public StandardValuesCollection virtual GetStandardValues(ITypeDescriptorContext context);
			{
				return baseType.GetStandardValues(context);
			}
			*/

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Override  | MemberAttributes.Overloaded;
		cmm.Name = "GetStandardValues";
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(TypeDescriptorContextClass,contextObject));
		cmm.ReturnType = new CodeTypeReference("System.ComponentModel.TypeConverter.StandardValuesCollection");
	
		cmie = new CodeMethodInvokeExpression(new CodeSnippetExpression(baseTypeMemberVariable),"GetStandardValues");
		cmie.Parameters.Add(new CodeVariableReferenceExpression(contextObject));
	
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
		CodeConvertorClass.Members.Add(cmm);

		/*
			public virtual GetStandardValuesExclusive(ITypeDescriptorContext context);
			{
				return baseType.GetStandardValuesExclusive(context);
			}
			*/

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Override  | MemberAttributes.Overloaded;
		cmm.Name = "GetStandardValuesExclusive";
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(TypeDescriptorContextClass,contextObject));
		cmm.ReturnType = new CodeTypeReference("System.Boolean");
	
		cmie = new CodeMethodInvokeExpression(new CodeSnippetExpression(baseTypeMemberVariable),"GetStandardValuesExclusive");
		cmie.Parameters.Add(new CodeVariableReferenceExpression(contextObject));
	
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
		CodeConvertorClass.Members.Add(cmm);

		/*
			public virtual GetStandardValuesSupported(ITypeDescriptorContext context);
			{
				return baseType.GetStandardValuesSupported(context);
			}
			*/

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Override  | MemberAttributes.Overloaded;
		cmm.Name = "GetStandardValuesSupported";
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(TypeDescriptorContextClass,contextObject));
		cmm.ReturnType = new CodeTypeReference("System.Boolean");
	
		cmie = new CodeMethodInvokeExpression(new CodeSnippetExpression(baseTypeMemberVariable),"GetStandardValuesSupported");
		cmie.Parameters.Add(new CodeVariableReferenceExpression(contextObject));
	
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
		CodeConvertorClass.Members.Add(cmm);

		/*
				public override object ConvertTo(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value, System.Type destinationType) 
				{
				
					if(context != null)
					{
						if ((context.PropertyDescriptor.ShouldSerializeValue(context.Instance) == false)) 
						{
							return "";
						}
					}
					return baseConverter.ConvertTo(context, culture, value, destinationType);
				}
		*/

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Override  | MemberAttributes.Overloaded;
		cmm.Name = "ConvertTo";

		cmm.Parameters.Add(new CodeParameterDeclarationExpression(TypeDescriptorContextClass,contextObject));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(CultureInfoClass,CultureInfoVar));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(new CodeTypeReference("System.Object"),ValueVar));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("System.Type",TypeDstObject));
		cmm.ReturnType = new CodeTypeReference("System.Object");


		CodeBinaryOperatorExpression cboe1 = new CodeBinaryOperatorExpression();
		cboe1.Left = new CodeVariableReferenceExpression(contextObject);
		cboe1.Right = new CodePrimitiveExpression(null);
		cboe1.Operator = CodeBinaryOperatorType.IdentityInequality;

		cis = new CodeConditionStatement();
		cis.Condition = cboe1;

		cmie = new CodeMethodInvokeExpression(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(contextObject),
			"PropertyDescriptor")
			,"ShouldSerializeValue");

		cmie.Parameters.Add(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(contextObject),
			"Instance"));
	
		CodeConditionStatement cis2 = new CodeConditionStatement();
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = cmie;
		cboe.Right = new CodePrimitiveExpression(false);
		cboe.Operator = CodeBinaryOperatorType.ValueEquality;

		cis2.Condition = cboe;

		cis.TrueStatements.Add(cis2);

		cis2.TrueStatements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression("")));

	
		cmm.Statements.Add(cis);

		cmie = new CodeMethodInvokeExpression(new CodeSnippetExpression(baseTypeMemberVariable),"ConvertTo");
		cmie.Parameters.Add(new CodeVariableReferenceExpression(contextObject));
		cmie.Parameters.Add(new CodeVariableReferenceExpression(CultureInfoVar));
		cmie.Parameters.Add(new CodeVariableReferenceExpression(ValueVar));
		cmie.Parameters.Add(new CodeVariableReferenceExpression(TypeDstObject));

		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
	
		CodeConvertorClass.Members.Add(cmm);	
		
		CodeConvertorClass.Comments.Add(new CodeCommentStatement(GetString("COMMENT_PROPTYPECONVERTER")));

		return CodeConvertorClass;

	}



	private void GenerateCollectionClass()
	{
		string strManagementObjectCollectionType = "ManagementObjectCollection";
		string strObjectCollection = "ObjectCollection";
		string strobjCollection = "objCollection";

		//public class ServiceCollection : ICollection, IEnumerable
		ccc = new CodeTypeDeclaration(PrivateNamesUsed["CollectionClass"].ToString());

		ccc.BaseTypes.Add("System.Object");
		ccc.BaseTypes.Add("ICollection");
		ccc.TypeAttributes =TypeAttributes.NestedPublic ;

		//private ManagementObjectCollection objCollection;
		cf = new CodeMemberField();
		cf.Name = strObjectCollection;
		cf.Attributes = MemberAttributes.Private | MemberAttributes.Final;		
		cf.Type = new CodeTypeReference(strManagementObjectCollectionType);
		ccc.Members.Add(cf);

		//internal ServiceCollection(ManagementObjectCollection obj)
		//{
		//	objCollection = obj;
		//}

		cctor = new CodeConstructor();
		//		cctor.Attributes = MemberAttributes.Assembly;
		cctor.Attributes = MemberAttributes.Public;
		cpde = new CodeParameterDeclarationExpression();
		cpde.Name = strobjCollection;
		cpde.Type = new CodeTypeReference(strManagementObjectCollectionType);
		cctor.Parameters.Add(cpde);

		cctor.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(strObjectCollection),
			new CodeSnippetExpression(strobjCollection)));
		ccc.Members.Add(cctor);


		//public Int32 Count {
		//	get { 
		//			return objCollection.Count; 
		//		}
		//}

		cmp = new CodeMemberProperty();
		cmp.Type = new CodeTypeReference("System.Int32");
		cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmp.Name = "Count";
		cmp.ImplementationTypes.Add("System.Collections.ICollection");
		//cmp.ImplementsType = "ICollection";
		cmp.GetStatements.Add(new CodeMethodReturnStatement(new CodePropertyReferenceExpression(
			new CodeSnippetExpression(strObjectCollection),
			"Count")));
		ccc.Members.Add(cmp);


		//public bool IsSynchronized {
		//	get {
		//		return objCollection.IsSynchronized;
		//	}
		//}

		cmp = new CodeMemberProperty();
		cmp.Type = new CodeTypeReference("System.Boolean");
		cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmp.Name = "IsSynchronized";
		cmp.ImplementationTypes.Add("System.Collections.ICollection");
		//cmp.ImplementsType = "ICollection";
		cmp.GetStatements.Add(new CodeMethodReturnStatement(new CodePropertyReferenceExpression(
			new CodeSnippetExpression(strObjectCollection),
			"IsSynchronized")));
		ccc.Members.Add(cmp);

		//public Object SyncRoot { 
		//	get { 
		//		return this; 
		//	} 
		//}

		cmp = new CodeMemberProperty();
		cmp.Type = new CodeTypeReference("System.Object");
		cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmp.Name = "SyncRoot";
		cmp.ImplementationTypes.Add("System.Collections.ICollection");
		//cmp.ImplementsType = "ICollection";
		cmp.GetStatements.Add(new CodeMethodReturnStatement(new CodeThisReferenceExpression()));
		ccc.Members.Add(cmp);

		//public void CopyTo (Array array, Int32 index) 
		//{
		//	objCollection.CopyTo(array,index);
		//	for(int iCtr=0;iCtr < array.Length ;iCtr++)
		//	{
		//		array.SetValue(new Service((ManagementObject)array.GetValue(iCtr)),iCtr);
		//	}
		//}

		string strArray = "array";
		string strIndex = "index";
		string strnCtr = "nCtr";

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmm.Name = "CopyTo";
		cmm.ImplementationTypes.Add("System.Collections.ICollection");

		cpde = new CodeParameterDeclarationExpression();
		cpde.Name = strArray;
		cpde.Type = new CodeTypeReference("System.Array");
		cmm.Parameters.Add(cpde);

		cpde = new CodeParameterDeclarationExpression();
		cpde.Name = strIndex;
		cpde.Type = new CodeTypeReference("System.Int32");
		cmm.Parameters.Add(cpde);

		cmie = new CodeMethodInvokeExpression(
			new CodeSnippetExpression(strObjectCollection),
			"CopyTo"
			);

		cmie.Parameters.Add(new CodeSnippetExpression(strArray));
		cmie.Parameters.Add(new CodeSnippetExpression(strIndex));
		cmm.Statements.Add(new CodeExpressionStatement(cmie));

		cmm.Statements.Add(new CodeVariableDeclarationStatement("System.Int32",strnCtr));
		cfls = new CodeIterationStatement();

		//		cfls.InitStatement = new CodeVariableDeclarationStatement("Int32",strnCtr,new CodePrimitiveExpression(0));
		cfls.InitStatement = new CodeAssignStatement(new CodeSnippetExpression(strnCtr),new CodePrimitiveExpression(0));
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeSnippetExpression(strnCtr);
		cboe.Operator = CodeBinaryOperatorType.LessThan;
		cboe.Right = new CodePropertyReferenceExpression(new CodeSnippetExpression(strArray),"Length");
		cfls.TestExpression = cboe;
		cfls.IncrementStatement = new CodeAssignStatement(new CodeSnippetExpression(strnCtr),
			new CodeBinaryOperatorExpression(
			new CodeSnippetExpression(strnCtr),
			CodeBinaryOperatorType.Add,
			new CodePrimitiveExpression(1)));

		cmie = new CodeMethodInvokeExpression(
			new CodeSnippetExpression(strArray),
			"SetValue");

		CodeMethodInvokeExpression cmie1 = new CodeMethodInvokeExpression(
			new CodeSnippetExpression(strArray),
			"GetValue",
			new CodeSnippetExpression(strnCtr));
		//cmie1.MethodName = "GetValue";
		//cmie1.TargetObject = new CodeSnippetExpression(strArray);
		//cmie1.Parameters.Add(new CodeSnippetExpression(strnCtr));

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PrivateNamesUsed["GeneratedClassName"].ToString());
		coce.Parameters.Add(new CodeCastExpression(PublicNamesUsed["LateBoundClass"].ToString(),cmie1));

		cmie.Parameters.Add(coce);
		cmie.Parameters.Add(new CodeSnippetExpression(strnCtr));
		cfls.Statements.Add(new CodeExpressionStatement(cmie));

		cmm.Statements.Add(cfls);
		ccc.Members.Add(cmm);

		//ServiceEnumerator GetEnumerator()
		//{
		//	return new ServiceEnumerator (objCollection.GetEnumerator());
		//}

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmm.Name = "GetEnumerator";
		cmm.ImplementationTypes.Add("System.Collections.IEnumerable");
		//		cmm.ReturnType = PrivateNamesUsed["EnumeratorClass"].ToString();
		cmm.ReturnType = new CodeTypeReference("System.Collections.IEnumerator");
		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PrivateNamesUsed["EnumeratorClass"].ToString());
		coce.Parameters.Add(new CodeMethodInvokeExpression(new CodeSnippetExpression(strObjectCollection),"GetEnumerator"));
		cmm.Statements.Add(new CodeMethodReturnStatement(coce));
		ccc.Members.Add(cmm);

		/*
		//ZINA: commenting this out for now, since 
		//"cmm.ImplementationTypes.Add("IEnumerable");"
		//does not work, and therefore the function is ambiguous and
		//does not compile.

		//IEnumerator IEnumerable.GetEnumerator()
		//{
		//	return GetEnumerator ();
		//}

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.VTableMask;
		cmm.Name = "GetEnumerator";
		cmm.ReturnType = new CodeTypeReference("IEnumerator");
		cmm.ImplementationTypes.Add("IEnumerable");
		//cmm.ImplementsType = "IEnumerable";
		cmie = new CodeMethodInvokeExpression(
					null,	//no TargetObject?
					"GetEnumerator"
					);

		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
		ccc.Members.Add(cmm);
	*/	

		//Now generate the Enumerator Class
		GenerateEnumeratorClass();

		ccc.Comments.Add(new CodeCommentStatement(GetString("COMMENT_ENUMIMPL")));
		cc.Members.Add(ccc);
	}

	private void GenerateEnumeratorClass()
	{
		string strObjectEnumerator = "ObjectEnumerator";
		string strManagementObjectEnumeratorType = "ManagementObjectEnumerator";
		string strManagementObjectCollectionType = "ManagementObjectCollection";
		string strobjEnum = "objEnum";

		//public class ServiceEnumerator : IEnumerator
		ecc = new CodeTypeDeclaration(PrivateNamesUsed["EnumeratorClass"].ToString());
		ecc.TypeAttributes =TypeAttributes.NestedPublic;

		ecc.BaseTypes.Add("System.Object");
		ecc.BaseTypes.Add("System.Collections.IEnumerator");

		//private ManagementObjectCollection.ManagementObjectEnumerator ObjectEnumerator;
		cf = new CodeMemberField();
		cf.Name = strObjectEnumerator;
		cf.Attributes = MemberAttributes.Private | MemberAttributes.Final ;
		cf.Type = new CodeTypeReference(strManagementObjectCollectionType+"."+ 
			strManagementObjectEnumeratorType);
		ecc.Members.Add(cf);

		//constructor
		//internal ServiceEnumerator(ManagementObjectCollection.ManagementObjectEnumerator objEnum)
		//{
		//	ObjectEnumerator = objEnum;
		//}
		cctor = new CodeConstructor();
		//		cctor.Attributes = MemberAttributes.Assembly;
		cctor.Attributes = MemberAttributes.Public;
		cpde = new CodeParameterDeclarationExpression();
		cpde.Name = strobjEnum;
		cpde.Type = new CodeTypeReference(strManagementObjectCollectionType + "." + 
			strManagementObjectEnumeratorType);
		cctor.Parameters.Add(cpde);

		cctor.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(strObjectEnumerator),
			new CodeSnippetExpression(strobjEnum)));
		ecc.Members.Add(cctor);

		//public Service Current {
		//get {
		//		return new Service((ManagementObject)ObjectEnumerator.Current);
		//	}
		//}

		cmp = new CodeMemberProperty();
		//		cmp.Type = PrivateNamesUsed["GeneratedClassName"].ToString();
		cmp.Type = new CodeTypeReference("System.Object");
		cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmp.Name = "Current";
		cmp.ImplementationTypes.Add("System.Collections.IEnumerator");
		//cmp.ImplementsType = "IEnumerator";
		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PrivateNamesUsed["GeneratedClassName"].ToString());
		coce.Parameters.Add(new CodeCastExpression(PublicNamesUsed["LateBoundClass"].ToString(),
			new CodePropertyReferenceExpression(
			new CodeSnippetExpression(strObjectEnumerator),
			"Current")));
		cmp.GetStatements.Add(new CodeMethodReturnStatement(coce));
		ecc.Members.Add(cmp);

		/*		//object IEnumerator.Current {
				//get {
				//		return Current;
				//	}
				//}

				cmp = new CodeMemberProperty();
				cmp.Attributes = MemberAttributes.VTableMask;
				cmp.Type = "object";
				cmp.Name = "IEnumerator.Current";
				cmp.GetStatements.Add(new CodeMethodReturnStatement(new CodeSnippetExpression("Current")));
				ecc.Members.Add(cmp);
		*/
		//public bool MoveNext ()
		//{
		//	return ObjectEnumerator.MoveNext();
		//}

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmm.Name = "MoveNext";
		cmm.ImplementationTypes.Add("System.Collections.IEnumerator");
		//cmm.ImplementsType = "IEnumerator";
		cmm.ReturnType = new CodeTypeReference("System.Boolean");
		cmie = new CodeMethodInvokeExpression(
			new CodeSnippetExpression(strObjectEnumerator),
			"MoveNext"
			);

		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
		ecc.Members.Add(cmm);

		//public void Reset ()
		//{
		//	ObjectEnumerator.Reset();
		//}

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmm.Name = "Reset";
		cmm.ImplementationTypes.Add("System.Collections.IEnumerator");
		//cmm.ImplementsType = "IEnumerator";
		cmie = new CodeMethodInvokeExpression(
			new CodeSnippetExpression(strObjectEnumerator),
			"Reset"
			);
		cmm.Statements.Add(new CodeExpressionStatement (cmie));
		ecc.Members.Add(cmm);

		ccc.Members.Add(ecc);
	}

	/// <summary>
	/// This function will find a given string in the passed 
	/// in a case insensitive manner and will return true if the string is found.
	/// </summary>
	int IsContainedIn(String strToFind, ref SortedList sortedList)
	{
		int nIndex = -1;
		for (int i=0; i < sortedList.Count; i++)
		{
			if (String.Compare(sortedList.GetByIndex(i).ToString(),strToFind,true,CultureInfo.InvariantCulture) == 0)
			{
				//The string is found. This is the index
				nIndex = i;
				break;
			}
		}
		return nIndex;
	}
	/// <summary>
	/// This function will convert the given CIMTYPE to an acceptable .NET type.
	/// Since CLS doen't support lotz of the basic types, we are using .NET helper 
	/// classes here. We safely assume that there won't be any problem using them
	/// since .NET has to be there for the System.Management.Dll to work.
	/// </summary>
	/// <param name="cType"> </param>
	/// <param name="isArray"> </param>
	private CodeTypeReference ConvertCIMType(CimType cType,bool isArray)
	{
		string strType;
		switch(cType)
		{
			case CimType.SInt8:
			{
				strType = "System.SByte";
				break;
			}
			case CimType.UInt8: //TODO : is this fine???
			{
				strType = "System.Byte";
				break;
			}
			case CimType.SInt16:
			{
				strType = "System.Int16";
				break;
			}
			case CimType.UInt16:
			{
				if (bUnsignedSupported == false)
				{
					strType = "System.Int16";
				}
				else
				{
					strType = "System.UInt16";
				}
				break;
			}
			case CimType.SInt32:
			{
				strType = "System.Int32";
				break;
			}
			case CimType.UInt32:
			{
				if (bUnsignedSupported == false)
				{
					strType = "System.Int32";
				}
				else
				{
					strType = "System.UInt32";
				}
				break;
			}
			case CimType.SInt64:
			{
				strType = "System.Int64";
				break;
			}
			case CimType.UInt64:
			{
				if (bUnsignedSupported == false)
				{
					strType = "System.Int64";
				}
				else
				{
					strType = "System.UInt64";
				}
				break;
			}
			case CimType.Real32:
			{
				strType = "System.Single";
				break;
			}
			case CimType.Real64:
			{
				strType = "System.Double";
				break;
			}
			case CimType.Boolean:
			{
				strType = "System.Boolean";
				break;
			}
			case CimType.String:
			{
				strType = "System.String";
				break;
			}
			case CimType.DateTime:
			{
				strType = "System.DateTime";
				break;
			}
			case CimType.Reference:
			{
				strType = PublicNamesUsed["PathClass"].ToString();
				break;
			}
			case CimType.Char16:
			{
				strType = "System.Char";
				break;
			}
			case CimType.Object:
			default:
				strType = PublicNamesUsed["BaseObjClass"].ToString();
				break;
		}

		if (isArray )
		{
			return new CodeTypeReference(strType,1);
		}
		else
		{
			return new CodeTypeReference(strType);
		}
	}
	/// <summary>
	/// This function is used to determine whether the given CIMTYPE can be represented as an integer.
	/// This helper function is mainly used to determine whether this type will be support by enums.
	/// </summary>
	/// <param name="cType"> </param>
	private bool isTypeInt(CimType cType)
	{
		bool retVal;
		switch(cType)
		{
			case CimType.UInt8: //TODO : is this fine???
			case CimType.UInt16:
			case CimType.UInt32:		// FIXX VB code generator cannot have Long enumerators
			case CimType.SInt8:
			case CimType.SInt16:
			case CimType.SInt32:
			{
				retVal = true;
				break;
			}
			case CimType.SInt64:
			case CimType.UInt64:
			case CimType.Real32:
			case CimType.Real64:
			case CimType.Boolean:
			case CimType.String:
			case CimType.DateTime:
			case CimType.Reference:
			case CimType.Char16:
			case CimType.Object:
			default:
				retVal = false;
				break;
		}

		return retVal;

	}

	/// <summary>
	///    <para>[To be supplied.]</para>
	/// </summary>
	public string GeneratedFileName
	{
		get
		{
			return genFileName;
		}
	}

	/// <summary>
	///    <para>[To be supplied.]</para>
	/// </summary>
	public string GeneratedTypeName
	{
		get
		{
			return PrivateNamesUsed["GeneratedNamespace"].ToString() + "." +
				PrivateNamesUsed["GeneratedClassName"].ToString();
		}
	}

	/// <summary>
	/// Function to convert a given ValueMap or BitMap name to propert enum name
	/// </summary>
	string ConvertValuesToName(string str)
	{
		string strRet = String.Empty;
		string strToReplace = "_";
		string strToAdd = String.Empty;
		bool  bAdd = true;
		if (str.Length == 0)
		{
			return string.Copy("");
		}

		char[] arrString = str.ToCharArray();
		// First character
		if (Char.IsLetter(arrString[0]) == false)
		{
			strRet = "Val_";
			strToAdd = "l";
		}

		for(int i=0;i < str.Length;i++)
		{
			bAdd = true;
			if (Char.IsLetterOrDigit(arrString[i]) == false)
			{
				// if the previous character added is "_" then
				// don't add that to the output string again
				if (strToAdd == strToReplace)
				{
					bAdd = false;
				}
				else
				{
					strToAdd = strToReplace;
				}
			}
			else
			{
				strToAdd = new string(arrString[i],1);
			}

			if (bAdd == true)
			{
				strRet = String.Concat(strRet,strToAdd);
			}
		}
		return strRet;
	}

	/// <summary>
	/// This function goes thru the names in array list and resolves any duplicates
	/// if any so that these names can be added as values of enum
	/// </summary>
	void ResolveEnumNameValues(ArrayList arrIn,ref ArrayList arrayOut)
	{
		arrayOut.Clear();
		int		nCurIndex = 0;
		string strToAdd = String.Empty;

		for( int i = 0 ; i < arrIn.Count ; i++)
		{
			strToAdd = arrIn[i].ToString();
			if (true == IsContainedInArray(strToAdd,arrayOut))
			{
				nCurIndex = 0;
				strToAdd = arrIn[i].ToString() + nCurIndex.ToString();
				while(true == IsContainedInArray(strToAdd,arrayOut))
				{
					nCurIndex++;
					strToAdd = arrIn[i].ToString() + nCurIndex.ToString();
				}

			}
			arrayOut.Add(strToAdd);
		}

	}

	/// <summary>
	/// This function will find a given string in the passed 
	/// array list.
	/// </summary>
	bool IsContainedInArray(String strToFind, ArrayList arrToSearch)
	{
		for (int i=0; i < arrToSearch.Count; i++)
		{
			if (String.Compare(arrToSearch[i].ToString(),strToFind,false,CultureInfo.InvariantCulture) == 0)
			{
				return true;
			}
		}
		return false;
	}

	/// <summary>
	/// Function to create a appropriate generator
	/// </summary>
	bool InitializeCodeGenerator(CodeLanguage lang)
	{
		switch(lang)
		{
			case CodeLanguage.VB:
				cg = (new VBCodeProvider()).CreateGenerator ();
				break;
		
			case CodeLanguage.JScript:
				JScriptCodeProvider jsp = new JScriptCodeProvider();
				cg = jsp.CreateGenerator();   
				break;

			case CodeLanguage.CSharp:
				cg = (new CSharpCodeProvider()).CreateGenerator ();
				break;

		}
		GetUnsignedSupport(lang);
		return true;

	}

	/// <summary>
	/// Function which checks if the language supports Unsigned numbers
	/// </summary>
	/// <param name="Language">Language</param>
	/// <returns>true - if unsigned is supported</returns>
	void GetUnsignedSupport(CodeLanguage Language)
	{
		switch(Language)
		{
			case CodeLanguage.CSharp:
				bUnsignedSupported = true;
				break;

			case CodeLanguage.VB:
			case CodeLanguage.JScript:
//				bUnsignedSupported = false;
				break;

			default:
				break;
		}	
	}

	/// <summary>
	/// Function which adds commit function to commit all the changes
	/// to the object to WMI
	/// </summary>
	void GenerateCommitMethod()
	{
		cmm = new CodeMemberMethod();
		cmm.Name = PublicNamesUsed["CommitMethod"].ToString();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final;

		caa = new CodeAttributeArgument();
		caa.Value = new CodePrimitiveExpression(true);
		cad = new CodeAttributeDeclaration();
		cad.Name = "Browsable";
		cad.Arguments.Add(caa);
		cmm.CustomAttributes = new CodeAttributeDeclarationCollection();
		cmm.CustomAttributes.Add(cad);

		cis = new CodeConditionStatement();
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeVariableReferenceExpression(PrivateNamesUsed["IsEmbedded"].ToString());
		cboe.Right = new CodePrimitiveExpression(false);
		cboe.Operator = CodeBinaryOperatorType.ValueEquality;
		cis.Condition = cboe;
		
		cmie = new CodeMethodInvokeExpression();
		cmie.Method.TargetObject = new CodeSnippetExpression(PrivateNamesUsed["LateBoundObject"].ToString());
		cmie.Method.MethodName = "Put";

		cis.TrueStatements.Add(new CodeExpressionStatement(cmie));
		cmm.Statements.Add(cis);
		cc.Members.Add(cmm);

	}

	/// <summary>
	/// Function to convert a value in format "0x..." to a integer
	/// to the object to WMI
	/// </summary>
	Int32 ConvertBitMapValueToInt32(String bitMap)
	{
		String strTemp = "0x";
		Int32 ret = 0;

		if (bitMap.StartsWith(strTemp) || bitMap.StartsWith(strTemp.ToUpper(CultureInfo.InvariantCulture)))
		{
			strTemp = String.Empty;
			char[] arrString = bitMap.ToCharArray();
			int Len = bitMap.Length;
			for (int i = 2 ; i < Len ; i++)
			{
				strTemp = strTemp + arrString[i];
			}
			ret = System.Convert.ToInt32(strTemp);
		}
		else
		{
			ret = System.Convert.ToInt32(bitMap);
		}

		return ret;
	}


	/// <summary>
	/// Function to get the Converstion function to be used for Numeric datatypes
	/// </summary>
	String GetConversionFunction(CimType cimType)
	{
		String retFunctionName = String.Empty;

		switch(cimType)
		{
			case CimType.UInt8:  
				retFunctionName = "ToByte";
				break;
		
			case CimType.SInt8:
				retFunctionName = "ToSByte";
				break;

			case CimType.SInt16:
				retFunctionName = "ToInt16";
				break;

			case CimType.UInt16:
				if (bUnsignedSupported == false)
				{
					retFunctionName = "ToInt16";
				}
				else
				{
					retFunctionName = "ToUInt16";
				}
				break;
		
			case CimType.SInt32:
		
				retFunctionName = "ToInt32";
				break;
		
			case CimType.UInt32:
			{
				if (bUnsignedSupported == false)
				{
					retFunctionName = "ToInt32";
				}
				else
				{
					retFunctionName = "ToUInt32";
				}
				break;
			}
			case CimType.SInt64:
			{
				retFunctionName = "ToInt64";
				break;
			}
			case CimType.UInt64:
			{
				if (bUnsignedSupported == false)
				{
					retFunctionName = "ToInt64";
				}
				else
				{
					retFunctionName = "ToUInt64";
				}
				break;
			}
			case CimType.Real32:
			{
				retFunctionName = "ToSingle";
				break;
			}
			case CimType.Real64:
			{
				retFunctionName = "ToDouble";
				break;
			}
			case CimType.Boolean:
			{
				retFunctionName = "ToBoolean";
				break;
			}

			case CimType.Char16:
			{
				retFunctionName = "ToChar";
				break;
			}
			
			case CimType.String:
			{
				retFunctionName = "ToString";
				break;
			}

		}
		return retFunctionName;
	}

	/// <summary>
	/// Checks if a given property is to be visible for Designer seriliazation
	/// </summary>
	bool IsDesignerSerializationVisibilityToBeSet(String propName)
	{
		if (String.Compare(propName,"Path",true,CultureInfo.InvariantCulture) != 0)
		{
			return true;
		}
		return false;
	}


	/// <summary>
	/// Checks if the given property type is represented as ValueType
	/// </summary>
	private bool IsPropertyValueType(CimType cType)
	{
		bool ret = true;
		switch(cType)
		{
			case CimType.String:
			case CimType.Reference:
			case CimType.Object:
				ret = false;
				break;

		}
		return ret;
	}

	/// <summary>
	/// Gets the dynamic qualifier on the class to find if the 
	/// class is a dynamic class
	/// </summary>
	private bool  IsDynamicClass()
	{
		bool ret = false;
		try
		{
			ret = System.Convert.ToBoolean(classobj.Qualifiers["dynamic"].Value);
		}
		catch(ManagementException)
		{
			// do nothing. THis may be due to dynamic qualifer not presen which is equivalent
			// dynamic qualifier absent
		}
		return ret;
	}


	/// <summary>
	/// Converts a numberic value to appropriate type and adds it to array
	/// </summary>
	private string ConvertToNumericValueAndAddToArray(CimType cimType, string numericValue,ArrayList arrayToAdd,out string enumType)
	{
		string retFunctionName = String.Empty;
		enumType = String.Empty;

		switch(cimType)
		{
			case CimType.UInt8:  			
			case CimType.SInt8:
			case CimType.SInt16:
			case CimType.UInt16:
			case CimType.SInt32:			
				arrayToAdd.Add(System.Convert.ToInt32(numericValue));
				retFunctionName = "ToInt32";
				enumType = "System.Int32";
				break;

			case CimType.UInt32:
				arrayToAdd.Add(System.Convert.ToInt64(numericValue));
				retFunctionName = "ToInt64";
				enumType = "System.Int64";
				break;
		}
		return retFunctionName;
	}
/*
	/// <summary>
	/// Function to initialize the comments to be put in the generated code
	/// Later can be moved to Resource once resource for System.management.dll is setup
	/// </summary>
	private void InitializeComments()
	{
		string strComment = "Functions ShouldSerialize<PropertyName> are functions used by VS property browser to check if"; 
		
		strComment = strComment  + " a particular property has to be serialized. These functions are added for all ValueType";
		strComment = strComment  + " properties ( properties of type Int32, BOOL etc.. which cannot be set to null). These functions";
		strComment = strComment  + " uses Is<PropertyName>Null function. These functions are also used in the TypeConverter implementation";
		strComment = strComment  + " for the properties to check for NULL value of property so that a empty value can be shown";
		strComment = strComment  + " in Property browser in case of Drag and Drop in Visual studio.";

		CommentsString.Add(strComment);	// IDS_COMMENT_SHOULDSERIALIZE

		strComment = "Functions Is<PropertyName>Null() are functions . These functions are to be used to check if a property is NULL.";
		CommentsString.Add(strComment);	// IDS_COMMENT_ISPROPNULL

		strComment = "Functions Reset<PropertyName> are added for Nullable Read/Write properties. These functions are used in VS designere in"; 
		strComment = strComment + " property browser to set a property to NULL.";
		CommentsString.Add(strComment);	// IDS_COMMENT_RESETPROP

		strComment = "Every property added to the class for WMI property has attributes set to define its behaviour in Visual Studio";
		strComment = strComment + " designer and as well as to define a TypeConverter to be used.";
		CommentsString.Add(strComment);	// IDS_COMMENT_ATTRIBPROP

		strComment = "DateTime Conversions are added for the class to convert DMTF date to System.DateTime and Vise-versa. Conversion from DMTF";
		strComment = strComment + " to System.DateTime conversion ignores the microseconds as System.DateTime doesn't have the microseconds part in it.";
		CommentsString.Add(strComment);	// IDS_COMMENT_DATECONVFUNC

		strComment = "Different flavours of GetInstances() help in enumerating instances of the WMI class.";
		CommentsString.Add(strComment);	// IDS_COMMENT_GETINSTANCES

		strComment = "An Early Bound class generated for the WMI class "; 
		CommentsString.Add(strComment);	// IDS_COMMENT_CLASSBEGIN

		CommentsString.Add("Member variable to store the autocommit behaviour for the class"); // IDS_COMMENT_PRIV_AUTOCOMMIT

		CommentsString.Add("Below are different flavours of constructors to initialize the instance with a WMI object"); // IDS_COMMENT_CONSTRUCTORS

		CommentsString.Add("Property returns the namespace of the WMI class"); // IDS_COMMENT_ORIG_NAMESPACE

		CommentsString.Add("Name of the WMI class");	// IDS_COMMENT_CLASSNAME;

		CommentsString.Add("Property pointing to a embeded object to get System properties of the WMI object"); // IDS_COMMENT_SYSOBJECT

		CommentsString.Add("Underlying lateBound WMI object"); // IDS_COMMENT_LATEBOUNDOBJ

		CommentsString.Add(" ManagementScope of the object"); //  IDS_COMMENT_MGMTSCOPE

		strComment = "Property to show the autocommit behaviour for the WMI object. If this is";
		strComment = strComment + "true then WMI object is saved to WMI then for change in every";
		strComment = strComment + "property (ie Put is called after modification of a property) ";
		CommentsString.Add(strComment); // IDS_COMMENT_AUTOCOMMITPROP

		CommentsString.Add("The ManagementPath of the underlying WMI object"); // IDS_COMMENT_MGMTPATH

		CommentsString.Add("TypeConverter to handle null values for ValueType properties"); // IDS_COMMENT_PROP_TYPECONVERTER

		CommentsString.Add(" Embedded class to represent WMI system Properties"); // IDS_COMMENT_SYSPROPCLASS

		CommentsString.Add("Enumerator implementation for enumerating instances of the class"); // IDS_COMMENT_ENUMIMPL
		CommentsString.Add("Property returning the underlying lateBound object"); // IDS_COMMENT_LATEBOUNDPROP

		CommentsString.Add("Private property to hold the name of WMI class which created this class"); // IDS_COMMENTS_CREATEDCLASS
		CommentsString.Add("Private variable to hold the embedded property representing the instance"); // IDS_COMMENT_EMBEDDEDOBJ
		CommentsString.Add("The current WMI object used"); //IDS_COMMENT_CURRENTOBJ
		CommentsString.Add("Flag to indicate if an instance is an embedded object"); // IDS_COMMENT_FLAGFOREMBEDDED

	}
*/
	/// <summary>
	/// Adds comments at the begining of the class defination
	/// </summary>
	void AddClassComments(CodeTypeDeclaration cc)
	{
		cc.Comments.Add(new CodeCommentStatement(GetString("COMMENT_SHOULDSERIALIZE")));
		cc.Comments.Add(new CodeCommentStatement(GetString("COMMENT_ISPROPNULL")));
		cc.Comments.Add(new CodeCommentStatement(GetString("COMMENT_RESETPROP")));
		cc.Comments.Add(new CodeCommentStatement(GetString("COMMENT_ATTRIBPROP")));

	}

	/// <summary>
	/// Stub function to get a particular string by ID.
	/// Later can be replaced by a a function call to get string
	/// from string resource
	/// </summary>
	string GetString(string strToGet)
	{
		return RC.GetString(strToGet);
	}

	/// <summary>
	/// Generates code for ManagementClassName Property
	/// </summary>
	private void GenerateClassNameProperty()
	{
		string strRetVar = "strRet";
		cmp = new CodeMemberProperty ();
		cmp.Name = PublicNamesUsed["ClassNameProperty"].ToString();
		cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final ;
		cmp.Type = new CodeTypeReference("System.String");

		caa = new CodeAttributeArgument();
		caa.Value = new CodePrimitiveExpression(true);
		cad = new CodeAttributeDeclaration();
		cad.Name = "Browsable";
		cad.Arguments.Add(caa);
		cmp.CustomAttributes = new CodeAttributeDeclarationCollection();
		cmp.CustomAttributes.Add(cad);

		caa = new CodeAttributeArgument();
		caa.Value = new CodeSnippetExpression("DesignerSerializationVisibility.Hidden");
		cad = new CodeAttributeDeclaration();
		cad.Name = "DesignerSerializationVisibility";
		cad.Arguments.Add(caa);
		cmp.CustomAttributes.Add(cad);

		cmp.GetStatements.Add (new CodeVariableDeclarationStatement("System.String",strRetVar,
			new CodeVariableReferenceExpression(PrivateNamesUsed["CreationClassName"].ToString())));


		cis = new CodeConditionStatement();
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeVariableReferenceExpression(PrivateNamesUsed["CurrentObject"].ToString());
		cboe.Right = new CodePrimitiveExpression(null);
		cboe.Operator = CodeBinaryOperatorType.IdentityInequality;
		cis.Condition = cboe;

		CodeConditionStatement cis1 = new CodeConditionStatement();

		CodeBinaryOperatorExpression cboe1 = new CodeBinaryOperatorExpression();
		cboe1.Left = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(PrivateNamesUsed["CurrentObject"].ToString()),
														PublicNamesUsed["ClassPathProperty"].ToString());
		cboe1.Right = new CodePrimitiveExpression(null);
		cboe1.Operator = CodeBinaryOperatorType.IdentityInequality;
		cis1.Condition = cboe1;

		cis.TrueStatements.Add(cis1);

		cis1.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(strRetVar),
			new CodeCastExpression(new CodeTypeReference("System.String"),
			new CodeIndexerExpression(new CodeVariableReferenceExpression(PrivateNamesUsed["CurrentObject"].ToString()),
			new CodePrimitiveExpression("__CLASS")))));

		CodeConditionStatement cis2 = new CodeConditionStatement();

		CodeBinaryOperatorExpression cboe3 = new CodeBinaryOperatorExpression();	
		cboe3.Left = new CodeVariableReferenceExpression(strRetVar);
		cboe3.Right = new CodePrimitiveExpression(null);
		cboe3.Operator = CodeBinaryOperatorType.IdentityEquality;

		CodeBinaryOperatorExpression cboe4 = new CodeBinaryOperatorExpression();
		cboe4.Left = new CodeVariableReferenceExpression(strRetVar);
		cboe4.Right = new CodePropertyReferenceExpression(new CodeSnippetExpression("System.String"),"Empty");
		cboe4.Operator = CodeBinaryOperatorType.IdentityEquality;

		CodeBinaryOperatorExpression cboe5 = new CodeBinaryOperatorExpression();
		cboe5.Left = cboe3;
		cboe5.Right = cboe4;
		cboe5.Operator = CodeBinaryOperatorType.BooleanOr;

		cis2.Condition = cboe5;

		cis2.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(strRetVar),
			new CodeVariableReferenceExpression(PrivateNamesUsed["CreationClassName"].ToString())));
								
		cis1.TrueStatements.Add(cis2);
								
		cmp.GetStatements.Add(cis);

		cmp.GetStatements.Add (new CodeMethodReturnStatement (new CodeVariableReferenceExpression(strRetVar)));
		cc.Members.Add (cmp);
	}

	/// <summary>
	/// Generates the functions CheckIfProperClass() which checks if the given path
	/// can be represented with the generated code
	/// </summary>
	void GenerateIfClassvalidFuncWithAllParams()
	{
		string strPathParam = "path";
		string strGetOptions = "OptionsParam";

		cmm = new CodeMemberMethod ();
		cmm.Name = PrivateNamesUsed["ClassNameCheckFunc"].ToString();
		cmm.Attributes = MemberAttributes.Private | MemberAttributes.Final ;
		cmm.ReturnType = new CodeTypeReference("System.Boolean");

		cmm.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["ScopeClass"].ToString(),PrivateNamesUsed["ScopeParam"].ToString()));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["PathClass"].ToString(),strPathParam));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["GetOptionsClass"].ToString(),strGetOptions));


		CodeExpression[] parms = new CodeExpression[]
		{
			new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(strPathParam),"ClassName"),
			new CodeVariableReferenceExpression(PublicNamesUsed["ClassNameProperty"].ToString()),
			new CodePrimitiveExpression(true),
			new CodePropertyReferenceExpression(new CodeVariableReferenceExpression("CultureInfo"),"InvariantCulture")
		};

		cmie = new CodeMethodInvokeExpression(
			new CodeSnippetExpression("System.String"),
			"Compare",
			parms
			);

		cboe = new CodeBinaryOperatorExpression();	
		cboe.Left = cmie;
		cboe.Right = new CodePrimitiveExpression(0);
		cboe.Operator = CodeBinaryOperatorType.ValueEquality;

		CodeBinaryOperatorExpression cboe1 = new CodeBinaryOperatorExpression();	
		cboe1.Left = new CodeVariableReferenceExpression(strPathParam);
		cboe1.Right = new CodePrimitiveExpression(null);
		cboe1.Operator = CodeBinaryOperatorType.IdentityInequality;

		CodeBinaryOperatorExpression cboe2 = new CodeBinaryOperatorExpression();	
		cboe2.Left = cboe1;
		cboe2.Right = cboe;
		cboe2.Operator = CodeBinaryOperatorType.BooleanAnd;
		
		cis = new CodeConditionStatement();
		cis.Condition = cboe2;

		cis.TrueStatements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(true)));

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["LateBoundClass"].ToString());
		coce.Parameters.Add(new CodeVariableReferenceExpression(PrivateNamesUsed["ScopeParam"].ToString()));
		coce.Parameters.Add(new CodeVariableReferenceExpression(strPathParam));
		coce.Parameters.Add(new CodeVariableReferenceExpression(strGetOptions));

		CodeMethodReferenceExpression cmre = new CodeMethodReferenceExpression();
		cmre.MethodName = PrivateNamesUsed["ClassNameCheckFunc"].ToString();

		cis.FalseStatements.Add(new CodeMethodReturnStatement(new CodeMethodInvokeExpression(cmre,coce)));
		cmm.Statements.Add(cis);

//		cmm.Statements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(false)));
	
		cc.Members.Add(cmm);
	}
	/// <summary>
	/// Generates the functions CheckIfProperClass() which checks if the given path
	/// can be represented with the generated code
	/// </summary>
	void GenerateIfClassvalidFunction()
	{
		// Call this function to generate the first overload of this function
		GenerateIfClassvalidFuncWithAllParams();

		string strTempObj	= "theObj";
		string strnCtr		= "count";
		string strDerivation = "parentClasses";

		cmm = new CodeMemberMethod ();
		cmm.Name = PrivateNamesUsed["ClassNameCheckFunc"].ToString();
		cmm.Attributes = MemberAttributes.Private | MemberAttributes.Final ;
		cmm.ReturnType = new CodeTypeReference("System.Boolean");

		cmm.Parameters.Add(new CodeParameterDeclarationExpression(PublicNamesUsed["BaseObjClass"].ToString(),strTempObj));


		CodeExpression[] parms = new CodeExpression[]
		{
			new CodeCastExpression("System.String",
								new CodeIndexerExpression(new CodeVariableReferenceExpression(strTempObj),
														new CodePrimitiveExpression("__CLASS"))),
			new CodeVariableReferenceExpression(PublicNamesUsed["ClassNameProperty"].ToString()),
			new CodePrimitiveExpression(true),
			new CodePropertyReferenceExpression(new CodeVariableReferenceExpression("CultureInfo"),"InvariantCulture")
		};

		cmie = new CodeMethodInvokeExpression(
			new CodeSnippetExpression("System.String"),
			"Compare",
			parms
			);

		cboe = new CodeBinaryOperatorExpression();	
		cboe.Left = cmie;
		cboe.Right = new CodePrimitiveExpression(0);
		cboe.Operator = CodeBinaryOperatorType.ValueEquality;

		CodeBinaryOperatorExpression cboe1 = new CodeBinaryOperatorExpression();	
		cboe1.Left = new CodeVariableReferenceExpression(strTempObj);
		cboe1.Right = new CodePrimitiveExpression(null);
		cboe1.Operator = CodeBinaryOperatorType.IdentityInequality;

		CodeBinaryOperatorExpression cboe2 = new CodeBinaryOperatorExpression();	
		cboe2.Left = cboe1;
		cboe2.Right = cboe;
		cboe2.Operator = CodeBinaryOperatorType.BooleanAnd;
		
		cis = new CodeConditionStatement();
		cis.Condition = cboe2;

		cis.TrueStatements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(true)));

		CodeExpression cs = new CodeCastExpression("System.Array",
												new CodeIndexerExpression(new CodeVariableReferenceExpression(strTempObj),
															new CodePrimitiveExpression("__DERIVATION")));


		cis.FalseStatements.Add(new CodeVariableDeclarationStatement("System.Array",strDerivation,cs));

		CodeConditionStatement cis1 = new CodeConditionStatement();
		cboe = new CodeBinaryOperatorExpression();	
		cboe.Left = new CodeVariableReferenceExpression(strDerivation);
		cboe.Right = new CodePrimitiveExpression(null);
		cboe.Operator = CodeBinaryOperatorType.IdentityInequality;
		cis1.Condition = cboe;

		cfls = new CodeIterationStatement();

		cis1.TrueStatements.Add(new CodeVariableDeclarationStatement("Int32",strnCtr,new CodePrimitiveExpression(0)));
		cfls.InitStatement = new CodeAssignStatement(new CodeVariableReferenceExpression(strnCtr),new CodePrimitiveExpression(0));
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeVariableReferenceExpression(strnCtr);
		cboe.Operator = CodeBinaryOperatorType.LessThan;
		cboe.Right = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(strDerivation),"Length");
		cfls.TestExpression = cboe;
		cfls.IncrementStatement = new CodeAssignStatement(new CodeSnippetExpression(strnCtr),
			new CodeBinaryOperatorExpression(
			new CodeSnippetExpression(strnCtr),
			CodeBinaryOperatorType.Add,
			new CodePrimitiveExpression(1)));

		CodeMethodInvokeExpression cmie1 = new CodeMethodInvokeExpression();
		cmie1.Method.MethodName = "GetValue";
		cmie1.Method.TargetObject = new CodeVariableReferenceExpression(strDerivation);
		cmie1.Parameters.Add(new CodeVariableReferenceExpression(strnCtr));

		CodeExpression[] parms1 = new CodeExpression[]  
		{
			new CodeCastExpression(new CodeTypeReference("System.String"),cmie1),
			new CodeVariableReferenceExpression(PublicNamesUsed["ClassNameProperty"].ToString()),
			new CodePrimitiveExpression(true),
			new CodePropertyReferenceExpression(new CodeVariableReferenceExpression("CultureInfo"),"InvariantCulture")
		};
		
		CodeMethodInvokeExpression cmie2 = new CodeMethodInvokeExpression(new CodeSnippetExpression("System.String"),
			"Compare",
			parms1);

		CodeConditionStatement cis2 = new CodeConditionStatement();
		cboe = new CodeBinaryOperatorExpression();	
		cboe.Left = cmie2;
		cboe.Right = new CodePrimitiveExpression(0);
		cboe.Operator = CodeBinaryOperatorType.ValueEquality;
		cis2.Condition = cboe;

		cis2.TrueStatements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(true)));
		
		cis1.TrueStatements.Add(cfls);
		cfls.Statements.Add(cis2);

		cis.FalseStatements.Add(cis1);
			
		cmm.Statements.Add(cis);
		cmm.Statements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(false)));
		cc.Members.Add(cmm);

	}

	/// <summary>
	/// Generates code for Property Get for Cimtype.Reference and CimType.DateTime type property
	/// Also generated code to initialize a variable after converting a property to DateTime and ManagementPathProperty
	/// </summary>
	void GenerateCodeForRefAndDateTimeTypes(CodeIndexerExpression prop,bool bArray,CodeStatementCollection statColl,string strType,CodeVariableReferenceExpression varToAssign,bool bIsValueProprequired)
	{
	
		if(bArray == false)
		{			

			CodeConditionStatement cis1 = new CodeConditionStatement();
			CodeBinaryOperatorExpression cboe1 = new CodeBinaryOperatorExpression();
			cboe1.Left = prop;
			cboe1.Operator = CodeBinaryOperatorType.IdentityInequality;
			cboe1.Right = new CodePrimitiveExpression(null);
			cis1.Condition = cboe1;

			// if the type is string then check for null is to be done
			// otherwise, the DateTime Conversion function will do for DateTime types
			if(String.Compare(strType,PublicNamesUsed["PathClass"].ToString(),true,CultureInfo.InvariantCulture) == 0)
			{
				CodeMethodReferenceExpression cmre = new CodeMethodReferenceExpression();
				cmre.MethodName = "ToString";
				cmre.TargetObject = prop;

				cmie = new CodeMethodInvokeExpression();
				cmie.Method = cmre;

				if(varToAssign == null)
				{
					cis1.TrueStatements.Add (new CodeMethodReturnStatement(CreateObjectForProperty(strType,prop,cmie)));
					statColl.Add(cis1);
					statColl.Add (new CodeMethodReturnStatement(new CodePrimitiveExpression(null)));
				}
				else
				{
					// Assign null to variable
					statColl.Add(new CodeAssignStatement(varToAssign,new CodePrimitiveExpression(null)));
					cis1.TrueStatements.Add (new CodeAssignStatement(varToAssign ,CreateObjectForProperty(strType,prop,cmie)));
					statColl.Add(cis1);				
				}
			}
			else
			{

				statColl.Add(cis1);				
				CodeExpression ce = null;
				if(bIsValueProprequired)
				{
					ce = new CodeCastExpression("System.String",new CodePropertyReferenceExpression(prop,"Value"));
				}
				else
				{
					ce = new CodeCastExpression("System.String",prop);
				}

				if(varToAssign == null)
				{
					cis1.TrueStatements.Add(new CodeMethodReturnStatement(CreateObjectForProperty(strType,prop,ce)));
					cis1.FalseStatements.Add(new CodeMethodReturnStatement(CreateObjectForProperty(strType,prop,null)));
				}
				else
				{
					cis1.TrueStatements.Add(new CodeAssignStatement(varToAssign,CreateObjectForProperty(strType,prop,ce)));
					cis1.FalseStatements.Add(new CodeAssignStatement(varToAssign,CreateObjectForProperty(strType,prop,null)));
				}
			}

		}
		else
		{
			string strLength = "len";
			string strnCtr = "iCounter";
			string strArray = "arrToRet";

			CodeConditionStatement cis1 = new CodeConditionStatement();
			CodeBinaryOperatorExpression cboe1 = new CodeBinaryOperatorExpression();
			cboe1.Left = prop;
			cboe1.Operator = CodeBinaryOperatorType.IdentityInequality;
			cboe1.Right = new CodePrimitiveExpression(null);
			cis1.Condition = cboe1;

			CodePropertyReferenceExpression LenProp = null;
			if(bIsValueProprequired == true)
			{
				LenProp = new CodePropertyReferenceExpression(new CodeCastExpression(new CodeTypeReference("System.Array"),
															new CodePropertyReferenceExpression(prop,"Value") ),
															"Length");
			}
			else
			{
				LenProp = new CodePropertyReferenceExpression(new CodeCastExpression(new CodeTypeReference("System.Array"),
																prop),
																"Length");
			}
			cis1.TrueStatements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.Int32"),strLength,LenProp));

			CodeTypeReference arrPathType = new CodeTypeReference(new CodeTypeReference(strType),1);
			cis1.TrueStatements.Add(new CodeVariableDeclarationStatement(
				arrPathType,
				strArray,
				new CodeArrayCreateExpression(new CodeTypeReference(strType),
				new CodeVariableReferenceExpression(strLength))));

			cfls = new CodeIterationStatement();

			cfls.InitStatement = new CodeVariableDeclarationStatement(new CodeTypeReference("Int32"),
				strnCtr,new CodePrimitiveExpression(0));
			cboe1 = new CodeBinaryOperatorExpression();
			cboe1.Left = new CodeVariableReferenceExpression(strnCtr);
			cboe1.Operator = CodeBinaryOperatorType.LessThan;
			cboe1.Right = new CodeVariableReferenceExpression(strLength);
			cfls.TestExpression = cboe1;
			cfls.IncrementStatement = new CodeAssignStatement(new CodeVariableReferenceExpression(strnCtr),
				new CodeBinaryOperatorExpression(
				new CodeVariableReferenceExpression(strnCtr),
				CodeBinaryOperatorType.Add,
				new CodePrimitiveExpression(1)));


			CodeMethodInvokeExpression cmie1 = new CodeMethodInvokeExpression();
			cmie1.Method.MethodName = "GetValue";
			if(bIsValueProprequired == true)
			{
				cmie1.Method.TargetObject = new CodeCastExpression(new CodeTypeReference("System.Array"),new CodePropertyReferenceExpression(prop,"Value"));
			}
			else
			{
				cmie1.Method.TargetObject = new CodeCastExpression(new CodeTypeReference("System.Array"), prop);
			}
			cmie1.Parameters.Add(new CodeVariableReferenceExpression(strnCtr));

			CodeMethodInvokeExpression cmie2 = new CodeMethodInvokeExpression();
			cmie2.Method.MethodName = "ToString";
			cmie2.Method.TargetObject = cmie1;
			
			cfls.Statements.Add( new CodeAssignStatement(new CodeIndexerExpression(new CodeVariableReferenceExpression(strArray),
				new CodeVariableReferenceExpression(strnCtr)),CreateObjectForProperty(strType,prop,cmie2)));

			cis1.TrueStatements.Add(cfls);
			if(varToAssign == null)
			{
				cis1.TrueStatements.Add(new CodeMethodReturnStatement(new CodeVariableReferenceExpression(strArray)));
				statColl.Add (cis1);
				statColl.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(null)));
			}
			else
			{
				// Assign null to variable
				statColl.Add(new CodeAssignStatement(varToAssign,new CodePrimitiveExpression(null)));
				cis1.TrueStatements.Add(new CodeAssignStatement(varToAssign ,new CodeVariableReferenceExpression(strArray)));
				statColl.Add (cis1);
			}

		}
	}


	/// <summary>
	/// Generates code for Property Set for Cimtype.DateTime and CimType.Reference type property
	/// </summary>
	void AddPropertySet(CodeIndexerExpression prop,bool bArray,CodeStatementCollection statColl,string strType,CodeVariableReferenceExpression varValue)
	{
		if(varValue == null)
		{
			varValue = new CodeVariableReferenceExpression("value");
		}

		if(bArray == false)
		{
			statColl.Add(new CodeAssignStatement(prop,
							ConvertPropertyToString(strType, varValue)));
		}
		else
		{
			string strLength = "len";
			string strnCtr = "iCounter";
			string strArray = "arrProp";

			CodeConditionStatement cis1 = new CodeConditionStatement();
			CodeBinaryOperatorExpression cboe1 = new CodeBinaryOperatorExpression();
			cboe1.Left = varValue;
			cboe1.Operator = CodeBinaryOperatorType.IdentityInequality;
			cboe1.Right = new CodePrimitiveExpression(null);
			cis1.Condition = cboe1;

			CodePropertyReferenceExpression LenProp = new CodePropertyReferenceExpression(
				new CodeCastExpression(new CodeTypeReference("System.Array"),varValue),
				"Length");

			cis1.TrueStatements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference("System.Int32"),strLength,LenProp));

			CodeTypeReference arrPathType = new CodeTypeReference(new CodeTypeReference("System.String"),1);
			cis1.TrueStatements.Add(new CodeVariableDeclarationStatement(
				arrPathType,
				strArray,
				new CodeArrayCreateExpression(new CodeTypeReference("System.String"),
				new CodeVariableReferenceExpression(strLength))));

			cfls = new CodeIterationStatement();

			cfls.InitStatement = new CodeVariableDeclarationStatement(new CodeTypeReference("Int32"),
				strnCtr,new CodePrimitiveExpression(0));
			cboe1 = new CodeBinaryOperatorExpression();
			cboe1.Left = new CodeVariableReferenceExpression(strnCtr);
			cboe1.Operator = CodeBinaryOperatorType.LessThan;
			cboe1.Right = new CodeVariableReferenceExpression(strLength);
			cfls.TestExpression = cboe1;
			cfls.IncrementStatement = new CodeAssignStatement(new CodeVariableReferenceExpression(strnCtr),
				new CodeBinaryOperatorExpression(
				new CodeVariableReferenceExpression(strnCtr),
				CodeBinaryOperatorType.Add,
				new CodePrimitiveExpression(1)));


			CodeMethodInvokeExpression cmie1 = new CodeMethodInvokeExpression();
			cmie1.Method.MethodName = "GetValue";
			cmie1.Method.TargetObject = new CodeCastExpression(new CodeTypeReference("System.Array"),varValue);
					
			cmie1.Parameters.Add(new CodeVariableReferenceExpression(strnCtr));

			cfls.Statements.Add( new CodeAssignStatement(new CodeIndexerExpression(new CodeVariableReferenceExpression(strArray),
				new CodeVariableReferenceExpression(strnCtr)),ConvertPropertyToString(strType,cmie1)));

			cis1.TrueStatements.Add(cfls);

			cis1.TrueStatements.Add(new CodeAssignStatement(prop,new CodeVariableReferenceExpression(strArray)));
			cis1.FalseStatements.Add(new CodeAssignStatement(prop,new CodePrimitiveExpression(null)));
			statColl.Add (cis1);
		}
	}

	/// <summary>
	/// Internal function used to create object. Used in adding code for Property Get for DateTime and Reference properties
	/// </summary>
	CodeExpression CreateObjectForProperty(string strType,CodeIndexerExpression property,CodeExpression param)
	{
		switch(strType)
		{
			case "System.DateTime" : 
				if(param == null)
				{
					return new CodePropertyReferenceExpression(new CodeVariableReferenceExpression("System.DateTime"),"MinValue");
				}
				else
				{
					cmie = new CodeMethodInvokeExpression();
//					cmie.Method.TargetObject = new CodeVariableReferenceExpression(PublicNamesUsed["DateConverter"].ToString());
					cmie.Parameters.Add(param);
					cmie.Method.MethodName = PrivateNamesUsed["ToDateTimeMethod"].ToString();
					return cmie;
				}
				
			case "System.TimeSpan" : 
				if(param == null)
				{
					coce = new CodeObjectCreateExpression();
					coce.CreateType = new CodeTypeReference("System.TimeSpan");
					coce.Parameters.Add(new CodePrimitiveExpression(0));
					coce.Parameters.Add(new CodePrimitiveExpression(0));
					coce.Parameters.Add(new CodePrimitiveExpression(0));
					coce.Parameters.Add(new CodePrimitiveExpression(0));
					coce.Parameters.Add(new CodePrimitiveExpression(0));
					return coce;
					//new CodePropertyReferenceExpression(new CodeVariableReferenceExpression("System.TimeSpan"),"MinValue");
				}
				else
				{
					cmie = new CodeMethodInvokeExpression();
//					cmie.Method.TargetObject = new CodeVariableReferenceExpression(PublicNamesUsed["DateConverter"].ToString());
					cmie.Parameters.Add(param);
					cmie.Method.MethodName = PrivateNamesUsed["ToTimeSpanMethod"].ToString();
					return cmie;
				}
			
			case "System.Management.ManagementPath":
				coce = new CodeObjectCreateExpression();
				coce.CreateType = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());
				coce.Parameters.Add(param);
				return coce;

				
		}

		return null;
	}
	/// <summary>
	/// Internal function used to create code to convert DateTime or ManagementPath to String
	/// convert a expression. Used in adding code for Property Set for DateTime and Reference properties
	/// </summary>
	CodeExpression ConvertPropertyToString(string strType,CodeExpression beginingExpression)
	{
		switch(strType)
		{
			case "System.DateTime" : 

				CodeMethodInvokeExpression cmie1 = new CodeMethodInvokeExpression();
				cmie1.Parameters.Add(new CodeCastExpression(new CodeTypeReference("System.DateTime"),beginingExpression));
//				cmie1.Method.TargetObject = new CodeVariableReferenceExpression(PublicNamesUsed["DateConverter"].ToString());
				cmie1.Method.MethodName = PrivateNamesUsed["ToDMTFDateTimeMethod"].ToString();
				return cmie1;
				
			case "System.TimeSpan" : 

				CodeMethodInvokeExpression cmie2 = new CodeMethodInvokeExpression();
				cmie2.Parameters.Add(new CodeCastExpression(new CodeTypeReference("System.TimeSpan"),beginingExpression));
//				cmie2.Method.TargetObject = new CodeVariableReferenceExpression(PublicNamesUsed["DateConverter"].ToString());
				cmie2.Method.MethodName = PrivateNamesUsed["ToDMTFTimeIntervalMethod"].ToString();
				return cmie2;
			
			case "System.Management.ManagementPath":
				return  new CodePropertyReferenceExpression(new CodeCastExpression(
					new CodeTypeReference(PublicNamesUsed["PathClass"].ToString()),
					beginingExpression),PublicNamesUsed["PathProperty"].ToString());

				
		}

		return null;
	}

	private void GenerateScopeProperty()
	{
		cmp = new CodeMemberProperty();
		cmp.Name = PublicNamesUsed["ScopeProperty"].ToString();
		cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmp.Type = new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString());

		caa = new CodeAttributeArgument();
		caa.Value = new CodePrimitiveExpression(true);
		cad = new CodeAttributeDeclaration();
		cad.Name = "Browsable";
		cad.Arguments.Add(caa);
		cmp.CustomAttributes = new CodeAttributeDeclarationCollection();
		cmp.CustomAttributes.Add(cad);

		// If the property is not Path then add an attribb DesignerSerializationVisibility
		// to indicate that the property is to be hidden for designer serilization.
		if (IsDesignerSerializationVisibilityToBeSet(PublicNamesUsed["ScopeProperty"].ToString()))
		{
			caa = new CodeAttributeArgument();
			caa.Value = new CodeSnippetExpression("DesignerSerializationVisibility.Hidden");
			cad = new CodeAttributeDeclaration();
			cad.Name = "DesignerSerializationVisibility";
			cad.Arguments.Add(caa);
			cmp.CustomAttributes.Add(cad);
		}

		cis = new CodeConditionStatement();
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeVariableReferenceExpression(PrivateNamesUsed["IsEmbedded"].ToString());
		cboe.Right = new CodePrimitiveExpression(false);
		cboe.Operator = CodeBinaryOperatorType.ValueEquality;
		cis.Condition = cboe;

		CodeExpression Value = new CodePropertyReferenceExpression(
										new CodeSnippetExpression(PrivateNamesUsed["LateBoundObject"].ToString()),"Scope");
		cis.TrueStatements.Add(new CodeMethodReturnStatement(Value));
		cis.FalseStatements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(null)));

		cmp.GetStatements.Add(cis);

		cis = new CodeConditionStatement();
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeVariableReferenceExpression(PrivateNamesUsed["IsEmbedded"].ToString());
		cboe.Right = new CodePrimitiveExpression(false);
		cboe.Operator = CodeBinaryOperatorType.ValueEquality;
		cis.Condition = cboe;

		cis.TrueStatements.Add(new CodeAssignStatement(Value,
			new CodeSnippetExpression("value")));
		
		cmp.SetStatements.Add(cis);
		cc.Members.Add(cmp);

		cmp.Comments.Add(new CodeCommentStatement(GetString("COMMENT_MGMTSCOPE")));
	}

	void AddGetStatementsForEnumArray(CodeIndexerExpression ciProp,CodeMemberProperty cmProp)
	{
		string strArray = "arrEnumVals";
		string ArrToRet = "enumToRet";
		string strnCtr = "counter";
		string strEnumName = cmProp.Type.BaseType;
	

		cmProp.GetStatements.Add(new CodeVariableDeclarationStatement("System.Array",strArray,
								new CodeCastExpression("System.Array",ciProp)));

		cmProp.GetStatements.Add(new CodeVariableDeclarationStatement(new CodeTypeReference(strEnumName,1),ArrToRet,
										new CodeArrayCreateExpression(new CodeTypeReference(strEnumName),
										new CodePropertyReferenceExpression(
										new CodeVariableReferenceExpression(strArray),"Length"))));
		
		cfls = new CodeIterationStatement();

		cmProp.GetStatements.Add(new CodeVariableDeclarationStatement("Int32",strnCtr,new CodePrimitiveExpression(0)));
		cfls.InitStatement = new CodeAssignStatement(new CodeVariableReferenceExpression(strnCtr),new CodePrimitiveExpression(0));
		CodeBinaryOperatorExpression cboe1 = new CodeBinaryOperatorExpression();
		cboe1.Left = new CodeVariableReferenceExpression(strnCtr);
		cboe1.Operator = CodeBinaryOperatorType.LessThan;
		cboe1.Right = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(strArray),"Length");
		cfls.TestExpression = cboe1;
		cfls.IncrementStatement = new CodeAssignStatement(new CodeVariableReferenceExpression(strnCtr),
														new CodeBinaryOperatorExpression(
														new CodeVariableReferenceExpression(strnCtr),
														CodeBinaryOperatorType.Add,
														new CodePrimitiveExpression(1)));


		CodeMethodInvokeExpression cmie1 = new CodeMethodInvokeExpression();
		cmie1.Method.MethodName = "GetValue";
		cmie1.Method.TargetObject = new CodeVariableReferenceExpression(strArray);
		cmie1.Parameters.Add(new CodeVariableReferenceExpression(strnCtr));
		
		CodeMethodInvokeExpression cmie2 = new CodeMethodInvokeExpression();
		cmie2.Method.TargetObject = new CodeSnippetExpression("System.Convert");
		cmie2.Parameters.Add(cmie1);
		cmie2.Method.MethodName = arrConvFuncName;
		cfls.Statements.Add(new CodeAssignStatement(new CodeIndexerExpression(new CodeVariableReferenceExpression(ArrToRet),
									new CodeSnippetExpression(strnCtr)),
									new CodeCastExpression(new CodeTypeReference(strEnumName),cmie2 )));


		cmProp.GetStatements.Add(cfls);

		cmProp.GetStatements.Add(new CodeMethodReturnStatement(new CodeVariableReferenceExpression(ArrToRet)));
		
	}
	
	private void AddCommentsForEmbeddedProperties()
	{
		cc.Comments.Add(new CodeCommentStatement(GetString("")));
		cc.Comments.Add(new CodeCommentStatement(GetString("")));
		cc.Comments.Add(new CodeCommentStatement(GetString("")));
		cc.Comments.Add(new CodeCommentStatement(GetString("")));
		cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDDED_COMMENT1")));
		cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDDED_COMMENT2")));
		cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDDED_COMMENT3")));
		cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDDED_COMMENT4")));
		cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDDED_COMMENT5")));
		cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDDED_COMMENT6")));
		cc.Comments.Add(new CodeCommentStatement(GetString("")));

		cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDDED_COMMENT7")));
		cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_VB_CODESAMP1")));
		cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_VB_CODESAMP2")));
		cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_VB_CODESAMP3")));
		cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_VB_CODESAMP4")));
		cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_VB_CODESAMP5")));
		cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_VB_CODESAMP6")));
		cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_VB_CODESAMP7")));
		cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_VB_CODESAMP8")));
		cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_VB_CODESAMP9")));
		cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_VB_CODESAMP10")));
		cc.Comments.Add(new CodeCommentStatement(GetString("")));

		cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDDED_COMMENT8")));
		cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_CS_CODESAMP1")));
		cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_CS_CODESAMP2")));
		cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_CS_CODESAMP3")));
		cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_CS_CODESAMP4")));
		cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_CS_CODESAMP5")));
		cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_CS_CODESAMP6")));
		cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_CS_CODESAMP7")));
		cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_CS_CODESAMP8")));
		cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_CS_CODESAMP9")));
		cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_CS_CODESAMP10")));
		cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_CS_CODESAMP11")));
		cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_CS_CODESAMP12")));
		cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_CS_CODESAMP13")));
		cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_CS_CODESAMP14")));
		cc.Comments.Add(new CodeCommentStatement(GetString("EMBEDED_CS_CODESAMP15")));
	}

	// This function checks the "SubType" Qualifier and if the value of this qualifies
	// is "interval" then the returned CodeTypeReference is of type System.TimeSpan
	// otherwise the returned type will be System.DateTime.
	// This functions is called only for cimtype.DateTime type properties
	private  bool GetDateTimeType(PropertyData prop,ref CodeTypeReference codeType )
	{
		bool isTimeInterval = false;
		codeType = null;
		if(prop.IsArray)
		{
			codeType = new CodeTypeReference("System.DateTime",1);
		}
		else
		{
			codeType =  new CodeTypeReference("System.DateTime");
		}

		try
		{
			if(String.Compare(prop.Qualifiers["SubType"].Value.ToString() ,"interval",true,CultureInfo.InvariantCulture) == 0)
			{
				isTimeInterval = true;
				if(prop.IsArray)
				{
					codeType = new CodeTypeReference("System.TimeSpan",1);
				}
				else
				{
					codeType =  new CodeTypeReference("System.TimeSpan");
				}
			}

		}
		catch
		{
		}

		if(isTimeInterval)
		{
			if(bTimeSpanConversionFunctionsAdded == false)
			{
				cc.Comments.Add(new CodeCommentStatement(GetString("COMMENT_TIMESPANCONVFUNC")));
				bTimeSpanConversionFunctionsAdded = true;
				// Call this function to generate conversion function
				GenerateTimeSpanConversionFunction();
			}
		}
		else
		{
			if(bDateConversionFunctionsAdded == false)
			{
				cc.Comments.Add(new CodeCommentStatement(GetString("COMMENT_DATECONVFUNC")));
				bDateConversionFunctionsAdded = true;
				// Call this function to generate conversion function
				GenerateDateTimeConversionFunction();
			}
		}

		return isTimeInterval;
	}

	/// <summary>
	/// This function generates static CreateInstance to create an WMI instance.
	/// public static GenClass CreateInstance() {
	///		return new GenClass(new ManagementClass(new System.Management.ManagementClass(CreatedWmiNamespace, CreatedClassName, null).CreateInstance()));
	/// }
	/// </summary>
	void GenerateCreateInstance()
	{
		cmm = new CodeMemberMethod();
		string strScope = "mgmtScope";
		string strPath = "mgmtPath";
        
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final | MemberAttributes.Static ;
		cmm.Name = PublicNamesUsed["CreateInst"].ToString();
		cmm.ReturnType = new CodeTypeReference(PrivateNamesUsed["GeneratedClassName"].ToString());

		caa = new CodeAttributeArgument();
		caa.Value = new CodePrimitiveExpression(true);
		cad = new CodeAttributeDeclaration();
		cad.Name = "Browsable";
		cad.Arguments.Add(caa);
		cmm.CustomAttributes = new CodeAttributeDeclarationCollection();
		cmm.CustomAttributes.Add(cad);


		
		
		cmm.Statements.Add(new CodeVariableDeclarationStatement(PublicNamesUsed["ScopeClass"].ToString(),
																strScope,
																new CodePrimitiveExpression(null)));
																
		CodeConditionStatement cis1 = new CodeConditionStatement();
		CodeBinaryOperatorExpression cboe1 = new CodeBinaryOperatorExpression();
		cboe1.Left = new CodeVariableReferenceExpression(PrivateNamesUsed["statMgmtScope"].ToString());
		cboe1.Right = new CodePrimitiveExpression(null);
		cboe1.Operator = CodeBinaryOperatorType.IdentityEquality;
		cis1.Condition = cboe1;

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PublicNamesUsed["ScopeClass"].ToString());
		cis1.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(strScope),coce));	

		cis1.TrueStatements.Add(new CodeAssignStatement(new CodePropertyReferenceExpression(
														new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(strScope),
														"Path"),"NamespacePath"),
														new CodeVariableReferenceExpression(PrivateNamesUsed["CreationWmiNamespace"].ToString())));

	
		cis1.FalseStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(strScope),
									new CodeVariableReferenceExpression(PrivateNamesUsed["statMgmtScope"].ToString())));


		cmm.Statements.Add(cis1);
		
		CodeObjectCreateExpression cocePath = new CodeObjectCreateExpression();
		cocePath.CreateType = new CodeTypeReference(PublicNamesUsed["PathClass"].ToString());
		cocePath.Parameters.Add(new CodeVariableReferenceExpression(PrivateNamesUsed["CreationClassName"].ToString()));
		cmm.Statements.Add(new CodeVariableDeclarationStatement(PublicNamesUsed["PathClass"].ToString(),strPath,cocePath));

		CodeObjectCreateExpression coce1 = new CodeObjectCreateExpression();
		coce1.CreateType = new CodeTypeReference(PublicNamesUsed["ManagementClass"].ToString());
		coce1.Parameters.Add(new CodeVariableReferenceExpression(strScope));
		coce1.Parameters.Add(new CodeVariableReferenceExpression(strPath));
		coce1.Parameters.Add(new CodePrimitiveExpression(null));
		
		CodeMethodInvokeExpression cmie1 = new CodeMethodInvokeExpression();
		cmie1.Method.MethodName = "CreateInstance";
		cmie1.Method.TargetObject = coce1;

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PrivateNamesUsed["GeneratedClassName"].ToString());
		coce.Parameters.Add(cmie1);

		cmm.Statements.Add(new CodeMethodReturnStatement(coce));

		cc.Members.Add(cmm);

	}

	/// <summary>
	/// This function generates static CreateInstance to create an WMI instance.
	/// public static GenClass CreateInstance() {
	///		PrivateLateBoundObject.Delete();
	/// }
	/// </summary>
	void GenerateDeleteInstance()
	{
		cmm = new CodeMemberMethod();
        
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final ;
		cmm.Name = PublicNamesUsed["DeleteInst"].ToString();

		caa = new CodeAttributeArgument();
		caa.Value = new CodePrimitiveExpression(true);
		cad = new CodeAttributeDeclaration();
		cad.Name = "Browsable";
		cad.Arguments.Add(caa);
		cmm.CustomAttributes = new CodeAttributeDeclarationCollection();
		cmm.CustomAttributes.Add(cad);

		
		CodeMethodInvokeExpression cmie1 = new CodeMethodInvokeExpression();
		cmie1.Method.MethodName = "Delete";
		cmie1.Method.TargetObject = new CodeVariableReferenceExpression(PrivateNamesUsed["LateBoundObject"].ToString());
		
		cmm.Statements.Add(cmie1);

		cc.Members.Add(cmm);

	}

	/// <summary>
	/// Function to genreate helper function for DMTF to DateTime and DateTime to DMTF 
	/// </summary>
	void GenerateDateTimeConversionFunction()
	{
		AddToDateTimeFunction();
		AddToDMTFFunction();
	}

	/// <summary>
	/// Function to genreate helper function for DMTF Time interval to TimeSpan and vice versa
	/// </summary>
	void GenerateTimeSpanConversionFunction()
	{
		AddToTimeSpanFunction();
		AddToDMTFTimeIntervalFunction();

	}


	/// <summary>
	/// Generated code for function to do conversion of date from DMTF format to DateTime format
	/// </summary>
	void AddToDateTimeFunction()
	{
		String dmtfParam = "dmtfDate";
		String year	= "year";
		String month = "month";
		String day = "day";
		String hour = "hour";
		String minute = "minute";
		String second = "second";
		String ticks = "ticks";
		String dmtf = "dmtf";
		String tempStr = "tempString";
		String datetimeVariable = "datetime";

		CodeMemberMethod cmmdt = new CodeMemberMethod();
		cmmdt.Name = PrivateNamesUsed["ToDateTimeMethod"].ToString();
		cmmdt.Attributes = MemberAttributes.Final | MemberAttributes.Static;
		cmmdt.ReturnType = new CodeTypeReference("System.DateTime");
		cmmdt.Parameters.Add(new CodeParameterDeclarationExpression("System.String",dmtfParam));
		cmmdt.Comments.Add(new CodeCommentStatement(GetString("COMMENT_TODATETIME")));

		CodePropertyReferenceExpression cpre = new CodePropertyReferenceExpression(new CodeSnippetExpression("System.DateTime"),"Now");
		CodePropertyReferenceExpression cpreMinVal = new CodePropertyReferenceExpression(new CodeSnippetExpression("System.DateTime"),"MinValue");
		
		//Int32 year = System.DateTime.MinValue.Year;
		cmmdt.Statements.Add(new CodeVariableDeclarationStatement("System.Int32",year,new CodePropertyReferenceExpression(cpreMinVal,"Year")));

		//Int32 month = System.DateTime.MinValue.Month;
		cmmdt.Statements.Add(new CodeVariableDeclarationStatement("System.Int32",month,	new CodePropertyReferenceExpression(cpreMinVal,"Month")));
		//Int32 day = System.DateTime.MinValue.Day;
		cmmdt.Statements.Add(new CodeVariableDeclarationStatement("System.Int32",day,new CodePropertyReferenceExpression(cpreMinVal,"Day")));
	
		//Int32 hour = System.DateTime.MinValue.Hour;
		cmmdt.Statements.Add(new CodeVariableDeclarationStatement("System.Int32",hour,new CodePropertyReferenceExpression(cpreMinVal,"Hour")));
		//Int32 minute = System.DateTime.MinValue.Minute;
		cmmdt.Statements.Add(new CodeVariableDeclarationStatement("System.Int32",minute,new CodePropertyReferenceExpression(cpreMinVal,"Minute")));
		//Int32 second = System.DateTime.MinValue.Second;
		cmmdt.Statements.Add(new CodeVariableDeclarationStatement("System.Int32",second,new CodePropertyReferenceExpression(cpreMinVal,"Second")));
		
		//Int32 millisec = 0;
		cmmdt.Statements.Add(new CodeVariableDeclarationStatement("System.Int64",ticks,new CodePrimitiveExpression(0)));

		//String dmtf = dmtfDate ;
		cmmdt.Statements.Add(new CodeVariableDeclarationStatement("System.String",dmtf,new CodeSnippetExpression(dmtfParam)));
		
		//System.DateTime datetime = System.DateTime.MinValue ;
		cmmdt.Statements.Add(new CodeVariableDeclarationStatement("System.DateTime",datetimeVariable,cpreMinVal));

		//String tempString = String.Empty ;
		cmmdt.Statements.Add(new CodeVariableDeclarationStatement("System.String",tempStr,new CodePropertyReferenceExpression(
			new CodeSnippetExpression("System.String"),"Empty")));


		/*		if (dmtf == null)
				{
					throw new System.ArgumentOutOfRangeException();
				}
		*/

		CodeBinaryOperatorExpression cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeVariableReferenceExpression(dmtf);
		cboe.Right = new CodePrimitiveExpression(null);
		cboe.Operator = CodeBinaryOperatorType.IdentityEquality;

		CodeConditionStatement cis = new CodeConditionStatement();
		cis.Condition = cboe;

		CodeObjectCreateExpression codeThrowException = new CodeObjectCreateExpression();
		codeThrowException.CreateType = new CodeTypeReference(PublicNamesUsed["ArgumentOutOfRangeException"].ToString());
		cis.TrueStatements.Add(new CodeThrowExceptionStatement(codeThrowException));

		cmmdt.Statements.Add(cis);

		/*		if (dmtf.Length == 0)
				{
					throw new System.ArgumentOutOfRangeException();
				}
		*/

		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(dmtf),"Length");
		cboe.Right = new CodePrimitiveExpression(0);
		cboe.Operator = CodeBinaryOperatorType.ValueEquality;

		cis = new CodeConditionStatement();
		cis.Condition = cboe;

		cis.TrueStatements.Add(new CodeThrowExceptionStatement(codeThrowException));

		cmmdt.Statements.Add(cis);


		/*		if (str.Length != DMTF_DATETIME_STR_LENGTH )
				{
					throw new System.ArgumentOutOfRangeException();
				}
		*/
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(dmtf),"Length");
		cboe.Right = new CodePrimitiveExpression(DMTF_DATETIME_STR_LENGTH);
		cboe.Operator = CodeBinaryOperatorType.IdentityInequality;

		cis = new CodeConditionStatement();
		cis.Condition = cboe;
		cis.TrueStatements.Add(new CodeThrowExceptionStatement(codeThrowException));

		cmmdt.Statements.Add(cis);

		CodeTryCatchFinallyStatement tryblock = new CodeTryCatchFinallyStatement();
		DateTimeConversionFunctionHelper(tryblock.TryStatements,"****",tempStr,dmtf,year,0,4);
		DateTimeConversionFunctionHelper(tryblock.TryStatements,"**",tempStr,dmtf,month,4,2);
		DateTimeConversionFunctionHelper(tryblock.TryStatements,"**",tempStr,dmtf,day,6,2);
		DateTimeConversionFunctionHelper(tryblock.TryStatements,"**",tempStr,dmtf,hour,8,2);
		DateTimeConversionFunctionHelper(tryblock.TryStatements,"**",tempStr,dmtf,minute,10,2);
		DateTimeConversionFunctionHelper(tryblock.TryStatements,"**",tempStr,dmtf,second,12,2);

		/*
			tempString = dmtf.Substring(15, 6);
			if (("******" != tempString)) 
			{
				ticks = (System.Int64.Parse(tempString)) * (System.TimeSpan.TicksPerMillisecond/1000);
			}
		*/

		CodeMethodReferenceExpression  cmre = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression(dmtf),"Substring");
		CodeMethodInvokeExpression cmie = new CodeMethodInvokeExpression();
		cmie.Method = cmre;
		cmie.Parameters.Add(new CodePrimitiveExpression(15));
		cmie.Parameters.Add(new CodePrimitiveExpression(6));
		tryblock.TryStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(tempStr), cmie));


		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodePrimitiveExpression("******");
		cboe.Right = new CodeVariableReferenceExpression(tempStr);
		cboe.Operator = CodeBinaryOperatorType.IdentityInequality;
		cis = new CodeConditionStatement();
		cis.Condition = cboe;

		CodeMethodReferenceExpression  cmre1 = new CodeMethodReferenceExpression(new CodeSnippetExpression("System.Int64"),"Parse");
		CodeMethodInvokeExpression cmie1 = new CodeMethodInvokeExpression();
		cmie1.Method = cmre1;
		cmie1.Parameters.Add(new CodeVariableReferenceExpression(tempStr));

		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodePropertyReferenceExpression(new CodeSnippetExpression("System.TimeSpan"),"TicksPerMillisecond");
		cboe.Right = new CodePrimitiveExpression(1000);
		cboe.Operator = CodeBinaryOperatorType.Divide;

		CodeBinaryOperatorExpression cboe2 = new CodeBinaryOperatorExpression();
		cboe2.Left = cmie1;
		cboe2.Right = cboe;
		cboe2.Operator = CodeBinaryOperatorType.Multiply;

		cis.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(ticks),cboe2));
		
		tryblock.TryStatements.Add(cis);

		/*
			if( year < 0 || month < 0 || day < 0 || hour < 0 || minute < 0 || second < 0 || ticks < 0)
			{
				throw new System.ArgumentOutOfRangeException();
			}
		*/

		CodeBinaryOperatorExpression cboeYear = new CodeBinaryOperatorExpression();
		cboeYear.Left = new CodeVariableReferenceExpression(year);
		cboeYear.Right = new CodePrimitiveExpression(0);
		cboeYear.Operator = CodeBinaryOperatorType.LessThan;


		CodeBinaryOperatorExpression cboeMonth = new CodeBinaryOperatorExpression();
		cboeMonth.Left = new CodeVariableReferenceExpression(month);
		cboeMonth.Right = new CodePrimitiveExpression(0);
		cboeMonth.Operator = CodeBinaryOperatorType.LessThan;

		CodeBinaryOperatorExpression cboeDay = new CodeBinaryOperatorExpression();
		cboeDay.Left = new CodeVariableReferenceExpression(day);
		cboeDay.Right = new CodePrimitiveExpression(0);
		cboeDay.Operator = CodeBinaryOperatorType.LessThan;

		CodeBinaryOperatorExpression cboeHour = new CodeBinaryOperatorExpression();
		cboeHour.Left = new CodeVariableReferenceExpression(hour);
		cboeHour.Right = new CodePrimitiveExpression(0);
		cboeHour.Operator = CodeBinaryOperatorType.LessThan;

		CodeBinaryOperatorExpression cboeMinute = new CodeBinaryOperatorExpression();
		cboeMinute.Left = new CodeVariableReferenceExpression(minute);
		cboeMinute.Right = new CodePrimitiveExpression(0);
		cboeMinute.Operator = CodeBinaryOperatorType.LessThan;

		CodeBinaryOperatorExpression cboeSecond = new CodeBinaryOperatorExpression();
		cboeSecond.Left = new CodeVariableReferenceExpression(second);
		cboeSecond.Right = new CodePrimitiveExpression(0);
		cboeSecond.Operator = CodeBinaryOperatorType.LessThan;

		CodeBinaryOperatorExpression cboeTicks = new CodeBinaryOperatorExpression();
		cboeTicks.Left = new CodeVariableReferenceExpression(ticks);
		cboeTicks.Right = new CodePrimitiveExpression(0);
		cboeTicks.Operator = CodeBinaryOperatorType.LessThan;

		CodeBinaryOperatorExpression cboetemp1 = new CodeBinaryOperatorExpression();
		cboetemp1.Left = cboeYear;
		cboetemp1.Right = cboeMonth;
		cboetemp1.Operator = CodeBinaryOperatorType.BooleanOr;

		CodeBinaryOperatorExpression cboetemp2 = new CodeBinaryOperatorExpression();
		cboetemp2.Left = cboetemp1;
		cboetemp2.Right = cboeDay;
		cboetemp2.Operator = CodeBinaryOperatorType.BooleanOr;

		CodeBinaryOperatorExpression cboetemp3 = new CodeBinaryOperatorExpression();
		cboetemp3.Left = cboetemp2;
		cboetemp3.Right = cboeHour;
		cboetemp3.Operator = CodeBinaryOperatorType.BooleanOr;

		CodeBinaryOperatorExpression cboetemp4 = new CodeBinaryOperatorExpression();
		cboetemp4.Left = cboetemp3;
		cboetemp4.Right = cboeMinute;
		cboetemp4.Operator = CodeBinaryOperatorType.BooleanOr;

		CodeBinaryOperatorExpression cboetemp5 = new CodeBinaryOperatorExpression();
		cboetemp5.Left = cboetemp4;
		cboetemp5.Right = cboeMinute;
		cboetemp5.Operator = CodeBinaryOperatorType.BooleanOr;

		CodeBinaryOperatorExpression cboetemp6 = new CodeBinaryOperatorExpression();
		cboetemp6.Left = cboetemp5;
		cboetemp6.Right = cboeSecond;
		cboetemp6.Operator = CodeBinaryOperatorType.BooleanOr;

		CodeBinaryOperatorExpression cboetemp7 = new CodeBinaryOperatorExpression();
		cboetemp7.Left = cboetemp6;
		cboetemp7.Right = cboeTicks;
		cboetemp7.Operator = CodeBinaryOperatorType.BooleanOr;

		cis = new CodeConditionStatement();
		cis.Condition = cboetemp7;

		cis.TrueStatements.Add(new CodeThrowExceptionStatement(codeThrowException));

		tryblock.TryStatements.Add(cis);
		/*
			catch
			{
				throw new System.ArgumentOutOfRangeException();
			}
		*/
		string exceptVar = "e";
		CodeCatchClause catchblock = new CodeCatchClause(exceptVar);
		catchblock.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(exceptVar),new CodeVariableReferenceExpression(exceptVar)));
		catchblock.Statements.Add(new CodeThrowExceptionStatement(codeThrowException));
		tryblock.CatchClauses.Add(catchblock);
		
		cmmdt.Statements.Add(tryblock);


		/*
			datetime = new System.DateTime(year, month, day, hour, minute, second, millisec);
		*/

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference("System.DateTime");
		coce.Parameters.Add(new CodeVariableReferenceExpression(year));
		coce.Parameters.Add(new CodeVariableReferenceExpression(month));
		coce.Parameters.Add(new CodeVariableReferenceExpression(day));
		coce.Parameters.Add(new CodeVariableReferenceExpression(hour));
		coce.Parameters.Add(new CodeVariableReferenceExpression(minute));
		coce.Parameters.Add(new CodeVariableReferenceExpression(second));
		coce.Parameters.Add(new CodePrimitiveExpression(0));

		cmmdt.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(datetimeVariable),coce));
		
		/*
			datetime = datetime.AddTicks(ticks);
		*/
		CodeMethodReferenceExpression  cmre2 = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression(datetimeVariable),"AddTicks");
		CodeMethodInvokeExpression cmie2 = new CodeMethodInvokeExpression();
		cmie2.Method = cmre2;
		cmie2.Parameters.Add(new CodeVariableReferenceExpression(ticks));

		cmmdt.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(datetimeVariable),cmie2));

		/*
			System.TimeSpan tickOffset = System.TimeZone.CurrentTimeZone.GetUtcOffset(datetime);
		*/
		cmre1 = new CodeMethodReferenceExpression(new CodeSnippetExpression("System.TimeZone.CurrentTimeZone"),"GetUtcOffset");
		cmie1 = new CodeMethodInvokeExpression();
		cmie1.Method = cmre1;
		cmie1.Parameters.Add(new CodeVariableReferenceExpression(datetimeVariable));

		String tickoffset = "tickOffset";
		cmmdt.Statements.Add(new CodeVariableDeclarationStatement("System.TimeSpan",tickoffset,cmie1));

		/*
			System.Int32 UTCOffset =  0;
			System.Int64 OffsetToBeAdjusted = 0;
			long OffsetMins = tickOffset.Ticks / System.TimeSpan.TicksPerMinute;
			tempString = dmtf.Substring(22, 3);
		*/
		String utcOffset = "UTCOffset";
		cmmdt.Statements.Add(new CodeVariableDeclarationStatement("System.Int32",utcOffset,new CodePrimitiveExpression(0)));
		String offsetAdjust = "OffsetToBeAdjusted";
		cmmdt.Statements.Add(new CodeVariableDeclarationStatement("System.Int64",offsetAdjust,new CodePrimitiveExpression(0)));
		
		String OffsetMins = "OffsetMins";
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodePropertyReferenceExpression(new CodeSnippetExpression(tickoffset),"Ticks");
		cboe.Right = new CodePropertyReferenceExpression(new CodeSnippetExpression("System.TimeSpan"),"TicksPerMinute");
		cboe.Operator = CodeBinaryOperatorType.Divide;
		cmmdt.Statements.Add(new CodeVariableDeclarationStatement("System.Int64",OffsetMins,cboe));

		cmre = new CodeMethodReferenceExpression(new CodeSnippetExpression(dmtf),"Substring");
		cmie = new CodeMethodInvokeExpression();
		cmie.Method = cmre;
		cmie.Parameters.Add(new CodePrimitiveExpression(22));
		cmie.Parameters.Add(new CodePrimitiveExpression(3));
		cmmdt.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(tempStr), cmie));

		/*
			if (("***" != tempString1)) 
			{
				tempString1 = dmtf.Substring(21, 4);
				try
				{
					UTCOffset = System.Int32.Parse(tempString1);
				}
				catch
				{
					throw new System.ArgumentOutOfRangeException();
				}

				OffsetToBeAdjusted = UTCOffset-OffsetMins;
					
				// We have to substract the minutes from the time
				datetime = datetime.AddMinutes(OffsetToBeAdjusted * -1);

			}
		*/
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeVariableReferenceExpression(tempStr);
		cboe.Right = new CodePrimitiveExpression("***");
		cboe.Operator = CodeBinaryOperatorType.IdentityInequality;

		cis = new CodeConditionStatement();
		cis.Condition = cboe;

		cmre = new CodeMethodReferenceExpression(new CodeSnippetExpression(dmtf),"Substring");
		cmie = new CodeMethodInvokeExpression();
		cmie.Method = cmre;
		cmie.Parameters.Add(new CodePrimitiveExpression(21));
		cmie.Parameters.Add(new CodePrimitiveExpression(4));
		cis.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(tempStr), cmie));

		CodeTryCatchFinallyStatement tryblock2 = new CodeTryCatchFinallyStatement();

		cmre = new CodeMethodReferenceExpression(new CodeSnippetExpression("System.Int32"),"Parse");
		cmie = new CodeMethodInvokeExpression();
		cmie.Method = cmre;
		cmie.Parameters.Add(new CodeVariableReferenceExpression(tempStr));
		tryblock2.TryStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(utcOffset), cmie));
		
		CodeCatchClause catchblock2 = new CodeCatchClause(exceptVar);
		catchblock2.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(exceptVar),new CodeVariableReferenceExpression(exceptVar)));
		catchblock2.Statements.Add(new CodeThrowExceptionStatement(codeThrowException));
		tryblock2.CatchClauses.Add(catchblock);

		cis.TrueStatements.Add(tryblock2);

		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeVariableReferenceExpression(OffsetMins);
		cboe.Right = new CodeVariableReferenceExpression(utcOffset);
		cboe.Operator = CodeBinaryOperatorType.Subtract;
		cis.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(offsetAdjust),cboe));

		cmre = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression(datetimeVariable),"AddMinutes");
		cmie = new CodeMethodInvokeExpression();
		cmie.Method = cmre;
		cmie.Parameters.Add(new CodeVariableReferenceExpression(offsetAdjust));
		cis.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(datetimeVariable),cmie));

		cmmdt.Statements.Add(cis);
	/*
			return datetime;
		
	*/
		cmmdt.Statements.Add(new CodeMethodReturnStatement(new CodeVariableReferenceExpression(datetimeVariable)));
		cc.Members.Add(cmmdt);
	}
	
	/// <summary>
	/// Generates some common code used in conversion function for DateTime
	/// </summary>
	void DateTimeConversionFunctionHelper(CodeStatementCollection cmmdt ,
											String toCompare,
											String tempVarName,
											String dmtfVarName,
											String toAssign,
											Int32 SubStringParam1, 
											Int32 SubStringParam2)
	{
		CodeMethodReferenceExpression  cmre = new CodeMethodReferenceExpression(new CodeSnippetExpression(dmtfVarName),"Substring");
		CodeMethodInvokeExpression cmie = new CodeMethodInvokeExpression();
		cmie.Method = cmre;
		cmie.Parameters.Add(new CodePrimitiveExpression(SubStringParam1));
		cmie.Parameters.Add(new CodePrimitiveExpression(SubStringParam2));
		cmmdt.Add(new CodeAssignStatement(new CodeSnippetExpression(tempVarName), cmie));

		CodeBinaryOperatorExpression cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodePrimitiveExpression(toCompare);
		cboe.Right = new CodeSnippetExpression(tempVarName);
		cboe.Operator = CodeBinaryOperatorType.IdentityInequality;

		CodeConditionStatement cis = new CodeConditionStatement();
		cis.Condition = cboe;
		cmre = new CodeMethodReferenceExpression(new CodeSnippetExpression("System.Int32"),"Parse");
		cmie = new CodeMethodInvokeExpression();
		cmie.Method = cmre;
		cmie.Parameters.Add(new CodeSnippetExpression(tempVarName));

		cis.TrueStatements.Add( new CodeAssignStatement(new CodeSnippetExpression(toAssign),cmie));

		cmmdt.Add(cis);
	}

	void AddToDMTFTimeIntervalFunction()
	{
		String dmtfTimeSpan = "dmtftimespan";
		String timespan	= "timespan";
		String tsTemp = "tsTemp";
		String microsec = "microsec";
		String strmicrosec = "strMicroSec";

		CodeMemberMethod cmmts = new CodeMemberMethod();
		cmmts.Name = PrivateNamesUsed["ToDMTFTimeIntervalMethod"].ToString();
		cmmts.Attributes = MemberAttributes.Final | MemberAttributes.Static;
		cmmts.ReturnType = new CodeTypeReference("System.String");
		cmmts.Parameters.Add(new CodeParameterDeclarationExpression("System.TimeSpan",timespan));
		cmmts.Comments.Add(new CodeCommentStatement(GetString("COMMENT_TODMTFTIMEINTERVAL")));


		/*
			string dmtftimespan = timespan.Days.ToString().PadLeft(8,'0');
		*/
		CodePropertyReferenceExpression cpre1 = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(timespan),"Days");
		cmie = new CodeMethodInvokeExpression();
		cmie.Method = new CodeMethodReferenceExpression(cpre1,"ToString");
		
		CodeMethodInvokeExpression cmie1 = new CodeMethodInvokeExpression();
		cmie1.Method = new CodeMethodReferenceExpression(cmie,"PadLeft");
		cmie1.Parameters.Add(new CodePrimitiveExpression(8));
		cmie1.Parameters.Add(new CodePrimitiveExpression('0'));

		cmmts.Statements.Add(new CodeVariableDeclarationStatement("System.String",dmtfTimeSpan,cmie1));

		CodeObjectCreateExpression codeThrowException = new CodeObjectCreateExpression();
		codeThrowException.CreateType = new CodeTypeReference(PublicNamesUsed["ArgumentOutOfRangeException"].ToString());

		/*
			if(timespan.Days > MAXDATE_INTIMESPAN || timespan < System.TimeSpan.Zero)
			{
				throw new System.ArgumentOutOfRangeException();
			}
		*/
		CodeBinaryOperatorExpression cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(timespan),"Days");
		cboe.Right = new CodePrimitiveExpression(99999999);
		cboe.Operator = CodeBinaryOperatorType.GreaterThan;

		CodeMethodReferenceExpression cmre2 = new CodeMethodReferenceExpression();
		cmre2.MethodName = "Compare";
		cmre2.TargetObject = new CodeVariableReferenceExpression("System.TimeSpan");
		cmie1 = new CodeMethodInvokeExpression();
		cmie1.Method = cmre2;
		cmie1.Parameters.Add(new CodeVariableReferenceExpression(timespan));
		cmie1.Parameters.Add(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression("System.TimeSpan"),"Zero"));

		CodeBinaryOperatorExpression cboe2 = new CodeBinaryOperatorExpression();
		cboe2.Left = cmie1;
		cboe2.Right = new CodePrimitiveExpression(0);
		cboe2.Operator = CodeBinaryOperatorType.LessThan;

		CodeBinaryOperatorExpression cboe3 = new CodeBinaryOperatorExpression();
		cboe3.Left = cboe;
		cboe3.Right = cboe2;
		cboe3.Operator = CodeBinaryOperatorType.BooleanOr;

		CodeConditionStatement cis = new CodeConditionStatement();
		cis.Condition = cboe3;
		cis.TrueStatements.Add(new CodeThrowExceptionStatement(codeThrowException));

		cmmts.Statements.Add(cis);
		/*
			dmtftimespan = (dmtftimespan + timespan.Hours.ToString().PadLeft(2, '0'));
		*/

		cpre1 = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(timespan),"Hours");
		cmie = new CodeMethodInvokeExpression();
		cmie.Method = new CodeMethodReferenceExpression(cpre1,"ToString");
		
		cmie1 = new CodeMethodInvokeExpression();
		cmie1.Method = new CodeMethodReferenceExpression(cmie,"PadLeft");
		cmie1.Parameters.Add(new CodePrimitiveExpression(2));
		cmie1.Parameters.Add(new CodePrimitiveExpression('0'));

		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeVariableReferenceExpression(dmtfTimeSpan);
		cboe.Right = cmie1;
		cboe.Operator = CodeBinaryOperatorType.Add;

		cmmts.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(dmtfTimeSpan),cboe));

		/*
			dmtftimespan = (dmtftimespan + timespan.Minutes.ToString().PadLeft(2, '0'));
		*/

		cpre1 = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(timespan),"Minutes");
		cmie = new CodeMethodInvokeExpression();
		cmie.Method = new CodeMethodReferenceExpression(cpre1,"ToString");
		
		cmie1 = new CodeMethodInvokeExpression();
		cmie1.Method = new CodeMethodReferenceExpression(cmie,"PadLeft");
		cmie1.Parameters.Add(new CodePrimitiveExpression(2));
		cmie1.Parameters.Add(new CodePrimitiveExpression('0'));

		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeVariableReferenceExpression(dmtfTimeSpan);
		cboe.Right = cmie1;
		cboe.Operator = CodeBinaryOperatorType.Add;

		cmmts.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(dmtfTimeSpan),cboe));

		/*
			dmtftimespan = (dmtftimespan + timespan.Seconds.ToString().PadLeft(2, '0'));
		*/

		cpre1 = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(timespan),"Seconds");
		cmie = new CodeMethodInvokeExpression();
		cmie.Method = new CodeMethodReferenceExpression(cpre1,"ToString");
		
		cmie1 = new CodeMethodInvokeExpression();
		cmie1.Method = new CodeMethodReferenceExpression(cmie,"PadLeft");
		cmie1.Parameters.Add(new CodePrimitiveExpression(2));
		cmie1.Parameters.Add(new CodePrimitiveExpression('0'));

		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeVariableReferenceExpression(dmtfTimeSpan);
		cboe.Right = cmie1;
		cboe.Operator = CodeBinaryOperatorType.Add;

		cmmts.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(dmtfTimeSpan),cboe));

		/*
			dmtftimespan = dmtftimespan + ".";
		*/
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeVariableReferenceExpression(dmtfTimeSpan);
		cboe.Right = new CodePrimitiveExpression(".");
		cboe.Operator = CodeBinaryOperatorType.Add;

		cmmts.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(dmtfTimeSpan),cboe));

		/*
			TimeSpan tsTemp = new TimeSpan(timespan.Days ,timespan.Hours,timespan.Minutes ,timespan.Seconds ,0);
		*/
		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference("System.TimeSpan");
		coce.Parameters.Add(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(timespan),"Days"));
		coce.Parameters.Add(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(timespan),"Hours"));
		coce.Parameters.Add(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(timespan),"Minutes"));
		coce.Parameters.Add(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(timespan),"Seconds"));
		coce.Parameters.Add(new CodePrimitiveExpression(0));
		cmmts.Statements.Add(new CodeVariableDeclarationStatement("System.TimeSpan",tsTemp,coce));

		/*
			System.Int64 microsec = ((timespan.Ticks-tsTemp.Ticks) * 1000) / System.TimeSpan.TicksPerMillisecond;
		*/

		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(timespan),"Ticks");
		cboe.Right = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(tsTemp),"Ticks");
		cboe.Operator = CodeBinaryOperatorType.Subtract;

		CodeBinaryOperatorExpression cboe1 = new CodeBinaryOperatorExpression();
		cboe1.Left = cboe;
		cboe1.Right = new CodePrimitiveExpression(1000);
		cboe1.Operator = CodeBinaryOperatorType.Multiply;

		cboe2 = new CodeBinaryOperatorExpression();
		cboe2.Left = cboe1;
		cboe2.Right = new CodePropertyReferenceExpression(new CodeSnippetExpression("System.TimeSpan"),"TicksPerMillisecond");
		cboe2.Operator = CodeBinaryOperatorType.Divide;
		cmmts.Statements.Add(new CodeVariableDeclarationStatement("System.Int64",microsec,cboe2));
		
		/*
			System.String strMicrosec = microsec.ToString();	
		*/	
		cmie = new CodeMethodInvokeExpression();
		cmie.Method = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression(microsec),"ToString");
		cmmts.Statements.Add(new CodeVariableDeclarationStatement("System.String",strmicrosec,cmie));

		/*
			if(strMicrosec.Length > 6)
			{
				strMicrosec = strMicrosec.Substring(0,6);				
			}
		*/
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(strmicrosec),"Length");
		cboe.Right = new CodePrimitiveExpression(6);
		cboe.Operator = CodeBinaryOperatorType.GreaterThan;

		cis = new CodeConditionStatement();
		cis.Condition = cboe;


		cmie = new CodeMethodInvokeExpression();
		cmie.Method = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression(strmicrosec),"Substring");
		cmie.Parameters.Add(new CodePrimitiveExpression(0));
		cmie.Parameters.Add(new CodePrimitiveExpression(6));
		
		cis.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(strmicrosec),cmie));
		cmmts.Statements.Add(cis);

		/*
			dmtftimespan = dmtftimespan + strMicrosec.PadLeft(6,'0');
		*/

		cmie = new CodeMethodInvokeExpression();
		cmie.Method = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression(strmicrosec),"PadLeft");
		cmie.Parameters.Add(new CodePrimitiveExpression(6));
		cmie.Parameters.Add(new CodePrimitiveExpression('0'));

		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeVariableReferenceExpression(dmtfTimeSpan);
		cboe.Right = cmie;
		cboe.Operator = CodeBinaryOperatorType.Add;
		cmmts.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(dmtfTimeSpan),cboe));

		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeVariableReferenceExpression(dmtfTimeSpan);
		cboe.Right = new CodePrimitiveExpression(":000");
		cboe.Operator = CodeBinaryOperatorType.Add;
		cmmts.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(dmtfTimeSpan),cboe));

		cmmts.Statements.Add(new CodeMethodReturnStatement(new CodeVariableReferenceExpression(dmtfTimeSpan)));

		cc.Members.Add(cmmts);

	}

	void AddToDMTFFunction()
	{
		String strUtc = "utcString";
		String dateParam	= "date";

		CodeMemberMethod cmmdt = new CodeMemberMethod();
		cmmdt.Name = PrivateNamesUsed["ToDMTFDateTimeMethod"].ToString();
		cmmdt.Attributes = MemberAttributes.Final | MemberAttributes.Static;
		cmmdt.ReturnType = new CodeTypeReference("System.String");
		cmmdt.Parameters.Add(new CodeParameterDeclarationExpression("System.DateTime",dateParam));
		cmmdt.Comments.Add(new CodeCommentStatement(GetString("COMMENT_TODMTFDATETIME")));

		/*
		 	string UtcString = String.Empty;
		*/
		cmmdt.Statements.Add(new CodeVariableDeclarationStatement("System.String",strUtc,
												new CodePropertyReferenceExpression(new CodeSnippetExpression("System.String"),"Empty")));

	
		/*
 			System.TimeSpan tickOffset = System.TimeZone.CurrentTimeZone.GetUtcOffset(date);
			long OffsetMins = tickOffset.Ticks / System.TimeSpan.TicksPerMinute;
		*/

		CodeMethodReferenceExpression cmre = new CodeMethodReferenceExpression(new CodeSnippetExpression("System.TimeZone.CurrentTimeZone"),"GetUtcOffset");
		CodeMethodInvokeExpression cmie1 = new CodeMethodInvokeExpression();
		cmie1.Method = cmre;
		cmie1.Parameters.Add(new CodeVariableReferenceExpression(dateParam));

		String tickoffset = "tickOffset";
		cmmdt.Statements.Add(new CodeVariableDeclarationStatement("System.TimeSpan",tickoffset,cmie1));

		String OffsetMins = "OffsetMins";
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodePropertyReferenceExpression(new CodeSnippetExpression(tickoffset),"Ticks");
		cboe.Right = new CodePropertyReferenceExpression(new CodeSnippetExpression("System.TimeSpan"),"TicksPerMinute");
		cboe.Operator = CodeBinaryOperatorType.Divide;
		cmmdt.Statements.Add(new CodeVariableDeclarationStatement("System.Int64",OffsetMins,cboe));

		/*
			if(Math.Abs(OffsetMins) > MAXSIZE_UTC_DMTF)
			{
				date = date.ToUniversalTime();
				UtcString = "+000";
			}
		*/

		cmre = new CodeMethodReferenceExpression(new CodeSnippetExpression("System.Math"),"Abs");
		cmie1 = new CodeMethodInvokeExpression();
		cmie1.Method = cmre;
		cmie1.Parameters.Add(new CodeVariableReferenceExpression(OffsetMins));

		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = cmie1;
		cboe.Right = new CodePrimitiveExpression(999);
		cboe.Operator = CodeBinaryOperatorType.GreaterThan;

		CodeConditionStatement cis1 = new CodeConditionStatement();
		cis1.Condition = cboe;

		cmre = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression(dateParam),"ToUniversalTime");
		cmie1 = new CodeMethodInvokeExpression();
		cmie1.Method = cmre;

		cis1.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(dateParam),cmie1));
		cis1.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(strUtc),new CodePrimitiveExpression("+000")));
		/*
			else
			if ((tickOffset.Ticks >= 0)) 
			{
				UtcString = "+" + ((tickOffset.Ticks / System.TimeSpan.TicksPerMinute)).ToString().PadLeft(3,'0');
			}
		*/
		CodeBinaryOperatorExpression cboe1 = new CodeBinaryOperatorExpression();
		cboe1.Left = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(tickoffset),"Ticks");
		cboe1.Right = new CodePrimitiveExpression(0);
		cboe1.Operator = CodeBinaryOperatorType.GreaterThanOrEqual;

		CodeConditionStatement cis2 = new CodeConditionStatement();
		cis2.Condition = cboe1;

		CodeBinaryOperatorExpression cboe2 = new CodeBinaryOperatorExpression();
		cboe2.Left = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(tickoffset),"Ticks");
		cboe2.Right = new CodePropertyReferenceExpression(new CodeSnippetExpression("System.TimeSpan"),"TicksPerMinute");
		cboe2.Operator = CodeBinaryOperatorType.Divide;

		cmie1 = new CodeMethodInvokeExpression();
		cmie1.Method = new CodeMethodReferenceExpression(cboe2,"ToString");

		CodeMethodInvokeExpression cmie2 = new CodeMethodInvokeExpression();
		cmie2.Method = new CodeMethodReferenceExpression(cmie1,"PadLeft");
		cmie2.Parameters.Add(new CodePrimitiveExpression(3));
		cmie2.Parameters.Add(new CodePrimitiveExpression('0'));

		cis2.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(strUtc),
								new CodeBinaryOperatorExpression(new CodePrimitiveExpression("+"),CodeBinaryOperatorType.Add,cmie2)));
		
		/*
			else 
			{
				string strTemp = OffsetMins.ToString();
				UtcString = "-" + strTemp.Substring(1, strTemp.Length-1).PadLeft(3,'0');
			}
		*/

		cmie1 = new CodeMethodInvokeExpression();
		cmie1.Method = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression(OffsetMins),"ToString");
		cis2.FalseStatements.Add(new CodeVariableDeclarationStatement("System.String","strTemp",cmie1));

		cmie2 = new CodeMethodInvokeExpression();
		cmie2.Method = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression("strTemp"),"Substring");
		cmie2.Parameters.Add(new CodePrimitiveExpression(1));
		cmie2.Parameters.Add(new CodeBinaryOperatorExpression(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression("strTemp"),"Length"),
																CodeBinaryOperatorType.Subtract,
																new CodePrimitiveExpression(1)));


		CodeMethodInvokeExpression cmie3 = new CodeMethodInvokeExpression();
		cmie3.Method = new CodeMethodReferenceExpression(cmie2,"PadLeft");
		cmie3.Parameters.Add(new CodePrimitiveExpression(3));
		cmie3.Parameters.Add(new CodePrimitiveExpression('0'));

		cis2.FalseStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(strUtc),
														new CodeBinaryOperatorExpression(new CodePrimitiveExpression("-"),
														CodeBinaryOperatorType.Add,cmie3)));
		cis1.FalseStatements.Add(cis2);
		cmmdt.Statements.Add(cis1);

		/*
			string dmtfDateTime = date.Year.ToString().PadLeft(4,'0');
		*/

		String dmtfDateTime = "dmtfDateTime";
		cmie1 = new CodeMethodInvokeExpression();
		cmie1.Method = new CodeMethodReferenceExpression(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(dateParam),"Year"),"ToString");


		cmie2 = new CodeMethodInvokeExpression();
		cmie2.Method = new CodeMethodReferenceExpression(cmie1,"PadLeft");
		cmie2.Parameters.Add(new CodePrimitiveExpression(4));
		cmie2.Parameters.Add(new CodePrimitiveExpression('0'));

		cmmdt.Statements.Add(new CodeVariableDeclarationStatement("System.String",dmtfDateTime,cmie2));
		
		/*
			dmtfDateTime = (dmtfDateTime + date.Month.ToString().PadLeft(2, '0'));
		*/

		ToDMTFDateHelper("Month",cmmdt);

		/*
			dmtfDateTime = (dmtfDateTime + date.Day.ToString().PadLeft(2, '0'));
		*/
		ToDMTFDateHelper("Day",cmmdt);

		/*
			dmtfDateTime = (dmtfDateTime + date.Hour.ToString().PadLeft(2, '0'));
		*/
		ToDMTFDateHelper("Hour",cmmdt);

		/*
			dmtfDateTime = (dmtfDateTime + date.Minute.ToString().PadLeft(2, '0'));
		*/

		ToDMTFDateHelper("Minute",cmmdt);

		/*
			dmtfDateTime = (dmtfDateTime + date.Second.ToString().PadLeft(2, '0'));
		*/

		ToDMTFDateHelper("Second",cmmdt);

		/*
			dmtfDateTime = (dmtfDateTime + ".");
		*/
		cmmdt.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(dmtfDateTime),
												new CodeBinaryOperatorExpression(new CodeVariableReferenceExpression(dmtfDateTime),
												CodeBinaryOperatorType.Add,new CodePrimitiveExpression("."))));

		/*
			DateTime dtTemp = new DateTime(date.Year ,date.Month,date.Day ,date.Hour ,date.Minute ,date.Second,0);
		*/

		String dtTemp = "dtTemp";
		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference("System.DateTime");
		coce.Parameters.Add(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(dateParam),"Year"));
		coce.Parameters.Add(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(dateParam),"Month"));
		coce.Parameters.Add(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(dateParam),"Day"));
		coce.Parameters.Add(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(dateParam),"Hour"));
		coce.Parameters.Add(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(dateParam),"Minute"));
		coce.Parameters.Add(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(dateParam),"Second"));
		coce.Parameters.Add(new CodePrimitiveExpression(0));
		cmmdt.Statements.Add(new CodeVariableDeclarationStatement("System.DateTime",dtTemp,coce));

		/*
			System.Int64 microsec = ((date.Ticks-dtTemp.Ticks) * 1000) / System.TimeSpan.TicksPerMillisecond;
		*/

		String microsec = "microsec";
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(dateParam),"Ticks");
		cboe.Right = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(dtTemp),"Ticks");
		cboe.Operator = CodeBinaryOperatorType.Subtract;

		cboe1 = new CodeBinaryOperatorExpression();
		cboe1.Left = cboe;
		cboe1.Right = new CodePrimitiveExpression(1000);
		cboe1.Operator = CodeBinaryOperatorType.Multiply;

		cboe2 = new CodeBinaryOperatorExpression();
		cboe2.Left = cboe1;
		cboe2.Right = new CodePropertyReferenceExpression(new CodeSnippetExpression("System.TimeSpan"),"TicksPerMillisecond");
		cboe2.Operator = CodeBinaryOperatorType.Divide;
		cmmdt.Statements.Add(new CodeVariableDeclarationStatement("System.Int64",microsec,cboe2));

		/*
			System.String strMicrosec = microsec.ToString();	
		*/	
		String strmicrosec = "strMicrosec";
		cmie1 = new CodeMethodInvokeExpression();
		cmie1.Method = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression(microsec),"ToString");
		cmmdt.Statements.Add(new CodeVariableDeclarationStatement("System.String",strmicrosec,cmie1));

		/*
			if(strMicrosec.Length > 6)
			{
				strMicrosec = strMicrosec.Substring(0,6);				
			}
		*/
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(strmicrosec),"Length");
		cboe.Right = new CodePrimitiveExpression(6);
		cboe.Operator = CodeBinaryOperatorType.GreaterThan;

		cis1 = new CodeConditionStatement();
		cis1.Condition = cboe;


		cmie1 = new CodeMethodInvokeExpression();
		cmie1.Method = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression(strmicrosec),"Substring");
		cmie1.Parameters.Add(new CodePrimitiveExpression(0));
		cmie1.Parameters.Add(new CodePrimitiveExpression(6));
		
		cis1.TrueStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(strmicrosec),cmie1));
		cmmdt.Statements.Add(cis1);

		/*
			dmtfDateTime = dmtfDateTime + strMicrosec.PadLeft(6,'0');
		*/

		cmie1 = new CodeMethodInvokeExpression();
		cmie1.Method = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression(strmicrosec),"PadLeft");
		cmie1.Parameters.Add(new CodePrimitiveExpression(6));
		cmie1.Parameters.Add(new CodePrimitiveExpression('0'));

		cboe1 = new CodeBinaryOperatorExpression();
		cboe1.Left = new CodeVariableReferenceExpression(dmtfDateTime);
		cboe1.Right = cmie1;
		cboe1.Operator = CodeBinaryOperatorType.Add;
		cmmdt.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(dmtfDateTime),cboe1));

		
		/*
			dmtfDateTime = dmtfDateTime + UtcString;
		*/

		cmmdt.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(dmtfDateTime),
													new CodeBinaryOperatorExpression(new CodeVariableReferenceExpression(dmtfDateTime),
													CodeBinaryOperatorType.Add,
													new CodeVariableReferenceExpression(strUtc))));

		cmmdt.Statements.Add(new CodeMethodReturnStatement(new CodeVariableReferenceExpression(dmtfDateTime)));

		cc.Members.Add(cmmdt);
	
	}

	// Helper function exclusively added to be used from AddToDMTFFunction function
	void ToDMTFDateHelper(string dateTimeMember,CodeMemberMethod cmmdt)
	{
		String dmtfDateTime = "dmtfDateTime";
		String dateParam = "date";
		CodeMethodInvokeExpression cmie = new CodeMethodInvokeExpression();
		cmie.Method = new CodeMethodReferenceExpression(new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(dateParam),dateTimeMember),"ToString");


		CodeMethodInvokeExpression cmie2 = new CodeMethodInvokeExpression();
		cmie2.Method = new CodeMethodReferenceExpression(cmie,"PadLeft");
		cmie2.Parameters.Add(new CodePrimitiveExpression(2));
		cmie2.Parameters.Add(new CodePrimitiveExpression('0'));

		cmmdt.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(dmtfDateTime),
													new CodeBinaryOperatorExpression(new CodeVariableReferenceExpression(dmtfDateTime),
													CodeBinaryOperatorType.Add,cmie2)));
	}

	void AddToTimeSpanFunction()
	{
		String tsParam	= "dmtfTimespan";
		String days = "days";
		String hours = "hours";
		String minutes = "minutes";
		String seconds = "seconds";
		String ticks = "ticks";

		CodeMemberMethod cmmts = new CodeMemberMethod();
		cmmts.Name = PrivateNamesUsed["ToTimeSpanMethod"].ToString();
		cmmts.Attributes = MemberAttributes.Final | MemberAttributes.Static;
		cmmts.ReturnType = new CodeTypeReference("System.TimeSpan");
		cmmts.Parameters.Add(new CodeParameterDeclarationExpression("System.String",tsParam));
		cmmts.Comments.Add(new CodeCommentStatement(GetString("COMMENT_TOTIMESPAN")));


		//Int32 days = 0;
		cmmts.Statements.Add(new CodeVariableDeclarationStatement("System.Int32",days,new CodePrimitiveExpression(0)));
		//Int32 hours = 0;
		cmmts.Statements.Add(new CodeVariableDeclarationStatement("System.Int32",hours,new CodePrimitiveExpression(0)));
		//Int32 minutes = 0;
		cmmts.Statements.Add(new CodeVariableDeclarationStatement("System.Int32",minutes,new CodePrimitiveExpression(0)));
		//Int32 seconds = 0;
		cmmts.Statements.Add(new CodeVariableDeclarationStatement("System.Int32",seconds,new CodePrimitiveExpression(0)));
		//Int32 ticks = 0;
		cmmts.Statements.Add(new CodeVariableDeclarationStatement("System.Int64",ticks,new CodePrimitiveExpression(0)));


		/*		if (dmtfTimespan == null)
				{
					throw new System.ArgumentOutOfRangeException();
				}
		*/

		CodeBinaryOperatorExpression cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeVariableReferenceExpression(tsParam);
		cboe.Right = new CodePrimitiveExpression(null);
		cboe.Operator = CodeBinaryOperatorType.IdentityEquality;

		CodeConditionStatement cis = new CodeConditionStatement();
		cis.Condition = cboe;

		CodeObjectCreateExpression codeThrowException = new CodeObjectCreateExpression();
		codeThrowException.CreateType = new CodeTypeReference(PublicNamesUsed["ArgumentOutOfRangeException"].ToString());
		cis.TrueStatements.Add(new CodeThrowExceptionStatement(codeThrowException));

		cmmts.Statements.Add(cis);

		/*		if (dmtfTimespan.Length == 0)
				{
					throw new System.ArgumentOutOfRangeException();
				}
		*/

		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(tsParam),"Length");
		cboe.Right = new CodePrimitiveExpression(0);
		cboe.Operator = CodeBinaryOperatorType.ValueEquality;

		cis = new CodeConditionStatement();
		cis.Condition = cboe;

		cis.TrueStatements.Add(new CodeThrowExceptionStatement(codeThrowException));

		cmmts.Statements.Add(cis);


		/*		if (dmtfTimespan.Length != DMTF_DATETIME_STR_LENGTH )
				{
					throw new System.ArgumentOutOfRangeException();
				}
		*/
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodePropertyReferenceExpression(new CodeVariableReferenceExpression(tsParam),"Length");
		cboe.Right = new CodePrimitiveExpression(DMTF_DATETIME_STR_LENGTH);
		cboe.Operator = CodeBinaryOperatorType.IdentityInequality;

		cis = new CodeConditionStatement();
		cis.Condition = cboe;
		cis.TrueStatements.Add(new CodeThrowExceptionStatement(codeThrowException));

		cmmts.Statements.Add(cis);
		
		/*
			if(dmtfTimespan.Substring(21,4) != ":000")
			{
				throw new System.ArgumentOutOfRangeException();
			}
		*/
		
		CodeMethodInvokeExpression cmie = new CodeMethodInvokeExpression();
		cmie.Method = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression(tsParam),"Substring");
		cmie.Parameters.Add(new CodePrimitiveExpression(21));
		cmie.Parameters.Add(new CodePrimitiveExpression(4));

		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = cmie;
		cboe.Right = new CodePrimitiveExpression(":000");
		cboe.Operator = CodeBinaryOperatorType.IdentityInequality;

		cis = new CodeConditionStatement();
		cis.Condition = cboe;
		cis.TrueStatements.Add(new CodeThrowExceptionStatement(codeThrowException));

		cmmts.Statements.Add(cis);

		CodeTryCatchFinallyStatement tryblock = new CodeTryCatchFinallyStatement();

		/*
			string tempString = System.String.Empty;
		*/
		string strTemp = "tempString";
		tryblock.TryStatements.Add(new CodeVariableDeclarationStatement("System.String",strTemp,
								new CodePropertyReferenceExpression(new CodeSnippetExpression("System.String"),"Empty")));
		/*
			tempString = dmtfTimespan.Substring(0, 8);
			days = System.Int32.Parse(tempString);

			tempString = dmtfTimespan.Substring(8, 2);
			hours = System.Int32.Parse(tempString);

			tempString = dmtfTimespan.Substring(10, 2);
			minutes = System.Int32.Parse(tempString);

			tempString = dmtfTimespan.Substring(12, 2);
			seconds = System.Int32.Parse(tempString);
		*/

		ToTimeSpanHelper(0,8,days,tryblock.TryStatements);
		ToTimeSpanHelper(8,2,hours,tryblock.TryStatements);
		ToTimeSpanHelper(10,2,minutes,tryblock.TryStatements);
		ToTimeSpanHelper(12,2,seconds,tryblock.TryStatements);

		/*
			tempString = dmtfTimespan.Substring(15, 6);
		*/

		cmie = new CodeMethodInvokeExpression();
		cmie.Method = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression(tsParam),"Substring");
		cmie.Parameters.Add(new CodePrimitiveExpression(15));
		cmie.Parameters.Add(new CodePrimitiveExpression(6));

		tryblock.TryStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(strTemp),cmie));

		cmie = new CodeMethodInvokeExpression();
		cmie.Method = new CodeMethodReferenceExpression(new CodeSnippetExpression("System.Int64"),"Parse");
		cmie.Parameters.Add(new CodeVariableReferenceExpression(strTemp));

		/*
			ticks = (System.Int64.Parse(tempString)) * (System.TimeSpan.TicksPerMillisecond/1000);
		*/
		tryblock.TryStatements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(ticks),
									new CodeBinaryOperatorExpression(cmie,CodeBinaryOperatorType.Multiply,
									new CodeBinaryOperatorExpression(new CodePropertyReferenceExpression(new CodeSnippetExpression("System.TimeSpan"),"TicksPerMillisecond"),
									CodeBinaryOperatorType.Divide,new CodePrimitiveExpression(1000)))));
								

		/*
			if( days < 0 || hours < 0 || minutes < 0 || seconds < 0 || ticks < 0)
			{
				throw new System.ArgumentOutOfRangeException();
			}
		*/

		CodeBinaryOperatorExpression cboeDays = new CodeBinaryOperatorExpression();
		cboeDays.Left = new CodeVariableReferenceExpression(days);
		cboeDays.Right = new CodePrimitiveExpression(0);
		cboeDays.Operator = CodeBinaryOperatorType.LessThan;


		CodeBinaryOperatorExpression cboeHours = new CodeBinaryOperatorExpression();
		cboeHours.Left = new CodeVariableReferenceExpression(hours);
		cboeHours.Right = new CodePrimitiveExpression(0);
		cboeHours.Operator = CodeBinaryOperatorType.LessThan;

		CodeBinaryOperatorExpression cboeMinutes = new CodeBinaryOperatorExpression();
		cboeMinutes.Left = new CodeVariableReferenceExpression(minutes);
		cboeMinutes.Right = new CodePrimitiveExpression(0);
		cboeMinutes.Operator = CodeBinaryOperatorType.LessThan;

		CodeBinaryOperatorExpression cboeSeconds = new CodeBinaryOperatorExpression();
		cboeSeconds.Left = new CodeVariableReferenceExpression(seconds);
		cboeSeconds.Right = new CodePrimitiveExpression(0);
		cboeSeconds.Operator = CodeBinaryOperatorType.LessThan;

		CodeBinaryOperatorExpression cboeTicks = new CodeBinaryOperatorExpression();
		cboeTicks.Left = new CodeVariableReferenceExpression(ticks);
		cboeTicks.Right = new CodePrimitiveExpression(0);
		cboeTicks.Operator = CodeBinaryOperatorType.LessThan;

		CodeBinaryOperatorExpression cboetemp1 = new CodeBinaryOperatorExpression();
		cboetemp1.Left = cboeDays;
		cboetemp1.Right = cboeHours;
		cboetemp1.Operator = CodeBinaryOperatorType.BooleanOr;

		CodeBinaryOperatorExpression cboetemp2 = new CodeBinaryOperatorExpression();
		cboetemp2.Left = cboetemp1;
		cboetemp2.Right = cboeMinutes;
		cboetemp2.Operator = CodeBinaryOperatorType.BooleanOr;

		CodeBinaryOperatorExpression cboetemp3 = new CodeBinaryOperatorExpression();
		cboetemp3.Left = cboetemp2;
		cboetemp3.Right = cboeSeconds;
		cboetemp3.Operator = CodeBinaryOperatorType.BooleanOr;

		CodeBinaryOperatorExpression cboetemp4 = new CodeBinaryOperatorExpression();
		cboetemp4.Left = cboetemp3;
		cboetemp4.Right = cboeTicks;
		cboetemp4.Operator = CodeBinaryOperatorType.BooleanOr;

		cis = new CodeConditionStatement();
		cis.Condition = cboetemp4;

		cis.TrueStatements.Add(new CodeThrowExceptionStatement(codeThrowException));

		/*
			catch
			{
				throw new System.ArgumentOutOfRangeException();
			}
		*/
		string exceptVar = "e";
		CodeCatchClause catchblock = new CodeCatchClause(exceptVar);
		catchblock.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(exceptVar),new CodeVariableReferenceExpression(exceptVar)));
		catchblock.Statements.Add(new CodeThrowExceptionStatement(codeThrowException));
		tryblock.CatchClauses.Add(catchblock);
		tryblock.TryStatements.Add(cis);

		cmmts.Statements.Add(tryblock);

		/*
			timespan = new System.TimeSpan(days, hours, minutes, seconds, 0);
		*/

		string timespan = "timespan";
		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference("System.TimeSpan");
		coce.Parameters.Add(new CodeVariableReferenceExpression(days));
		coce.Parameters.Add(new CodeVariableReferenceExpression(hours));
		coce.Parameters.Add(new CodeVariableReferenceExpression(minutes));
		coce.Parameters.Add(new CodeVariableReferenceExpression(seconds));
		coce.Parameters.Add(new CodePrimitiveExpression(0));

		cmmts.Statements.Add(new CodeVariableDeclarationStatement("System.TimeSpan",timespan,coce));

		/*
			TimeSpan tsTemp = System.TimeSpan.FromTicks(ticks);
			timespan = timespan.Add(tsTemp);
		*/
		string tsTemp = "tsTemp";
		cmie = new CodeMethodInvokeExpression();
		cmie.Method = new CodeMethodReferenceExpression(new CodeSnippetExpression("System.TimeSpan"),"FromTicks");
		cmie.Parameters.Add(new CodeVariableReferenceExpression(ticks));

		cmmts.Statements.Add(new CodeVariableDeclarationStatement("System.TimeSpan",tsTemp,cmie));
		
		cmie = new CodeMethodInvokeExpression();
		cmie.Method = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression(timespan),"Add");
		cmie.Parameters.Add(new CodeVariableReferenceExpression(tsTemp));

		cmmts.Statements.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(timespan),cmie));


		/*
			return timespan;
		*/
		cmmts.Statements.Add(new CodeMethodReturnStatement(new CodeVariableReferenceExpression(timespan)));

		cc.Members.Add(cmmts);
	}

	// Exclusive helper function to be used from AddToTimeSpanFunction
	void ToTimeSpanHelper(int start,int numOfCharacters,String strVarToAssign,CodeStatementCollection statCol)
	{
		String strTemp = "tempString";
		String tsParam	= "dmtfTimespan";

		CodeMethodInvokeExpression cmie = new CodeMethodInvokeExpression();
		cmie.Method = new CodeMethodReferenceExpression(new CodeVariableReferenceExpression(tsParam),"Substring");
		cmie.Parameters.Add(new CodePrimitiveExpression(start));
		cmie.Parameters.Add(new CodePrimitiveExpression(numOfCharacters));

		statCol.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(strTemp),cmie));

		cmie = new CodeMethodInvokeExpression();
		cmie.Method = new CodeMethodReferenceExpression(new CodeSnippetExpression("System.Int32"),"Parse");
		cmie.Parameters.Add(new CodeVariableReferenceExpression(strTemp));

		statCol.Add(new CodeAssignStatement(new CodeVariableReferenceExpression(strVarToAssign),cmie));
	}


}


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\instrumentation\eventsource.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Management.Instrumentation
{
    using System;
    using System.Runtime.InteropServices;
    using System.Collections;
    using System.Text.RegularExpressions;
    using System.Threading;
    using System.Security;
    using System.Globalization;

    class ComThreadingInfo
    {
        public enum APTTYPE
        {
            APTTYPE_CURRENT = -1,
            APTTYPE_STA = 0,
            APTTYPE_MTA = 1,
            APTTYPE_NA  = 2,
            APTTYPE_MAINSTA = 3
        }

        public enum THDTYPE
        {
            THDTYPE_BLOCKMESSAGES   = 0,
            THDTYPE_PROCESSMESSAGES = 1
        }

        [ComImport]
        [Guid("000001ce-0000-0000-C000-000000000046")]
        [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
        interface IComThreadingInfo 
        {
            APTTYPE GetCurrentApartmentType();
            THDTYPE GetCurrentThreadType();
            Guid GetCurrentLogicalThreadId();
            void SetCurrentLogicalThreadId([In] Guid rguid);
        }

        Guid IID_IUnknown = new Guid("00000000-0000-0000-C000-000000000046");

        ComThreadingInfo()
        {
            IComThreadingInfo info = (IComThreadingInfo)CoGetObjectContext(ref IID_IUnknown);

            apartmentType  = info.GetCurrentApartmentType();
            threadType = info.GetCurrentThreadType();
            logicalThreadId = info.GetCurrentLogicalThreadId();
        }

        public static ComThreadingInfo Current
        {
            get
            {
                return new ComThreadingInfo();
            }
        }

        public override string ToString()
        {
            return String.Format("{{{0}}} - {1} - {2}", LogicalThreadId, ApartmentType, ThreadType);
        }

        APTTYPE apartmentType;
        THDTYPE threadType;
        Guid logicalThreadId;

        public APTTYPE ApartmentType { get { return apartmentType; } 
        }
        public THDTYPE ThreadType { get { return threadType; } 
        }
        public Guid LogicalThreadId { get { return logicalThreadId; } 
        }

        [DllImport("ole32.dll", PreserveSig = false)]
        [return:MarshalAs(UnmanagedType.IUnknown)]
        static extern object CoGetObjectContext([In] ref Guid riid);
    }

    sealed class EventSource : IWbemProviderInit, IWbemEventProvider, IWbemEventProviderQuerySink, IWbemEventProviderSecurity, IWbemServices_Old
    {
        IWbemDecoupledRegistrar registrar = (IWbemDecoupledRegistrar)new WbemDecoupledRegistrar();

        static ArrayList eventSources = new ArrayList();

        InstrumentedAssembly instrumentedAssembly;

        public EventSource(string namespaceName, string appName, InstrumentedAssembly instrumentedAssembly)
        {
            lock(eventSources)
            {
                // This is a pathalogical case where the process is shutting down, but
                // someone wants us to register us as a provider.  In this case, we ignore
                // the request.  This would be problematic if the eventSources list has already
                // been enumerated and all other eventSources unregistered.  If we were allowed
                // to register a new event source, it would never be unregistered
                if(shutdownInProgress != 0)
                    return;

                this.instrumentedAssembly = instrumentedAssembly;

                int hr = registrar.Register_(0, null, null, null, namespaceName, appName, this);

                if(hr != 0)
                    Marshal.ThrowExceptionForHR(hr);

                // If we've gotten here, we were successful with the Register call
                eventSources.Add(this);
            }
        }

#if OldShutdown
        ~EventSource()
        {
            // Kill worker thread
            if(lengthFromSTA != -1)
            {
                alive = false;
                SetEvent(hDoIndicate);
//                doIndicate.Set();
            }

            registrar.UnRegister_();
        }
#endif

        ~EventSource()
        {
            // BUGBUG:
            // Hopefully the event source will have already been unregistered,
            // but just in case, we'll make sure it is.
            // This can currently happen if we are loaded into the non-default
            // AppDomain, and no-one calls AppDomain.Unload().  In this case,
            // we won't get AppDomain.ProcessExit, or AppDomain.DomainUnload.
            // When this happens, this destructor will be called during the
            // 'finalize for process shutdown' routine.  If we have an existing
            // incoming call on IWbemServices, it might be terminated abnormally.
            // This can unfortunately cause WMI to wait indefinately for us.
            UnRegister();
        }

        void UnRegister()
        {
            lock(this)
            {
                // Only unregister one time
                if(registrar == null)
                    return;

                // Kill worker thread
                if(lengthFromSTA != -1)
                {
                    alive = false;
                    SetEvent(hDoIndicate);
                    //                doIndicate.Set();
                }
                registrar.UnRegister_();
                registrar = null;
            }
        }

        static int shutdownInProgress = 0;
        static ReaderWriterLock preventShutdownLock = new ReaderWriterLock();
        static void ProcessExit(object o, EventArgs args)
        {
            // We can be called multiple times, but only one time will we
            // try to unregister all the event sources
            if(shutdownInProgress != 0)
                return;

            // Notify anyone interested that a shutdown as been initiated
            Interlocked.Increment(ref shutdownInProgress);

            try
            {
                // Wait for anyone currently in a DCOM callback to finish
                preventShutdownLock.AcquireWriterLock(-1);

                // Unregister all existing event sources
                lock(eventSources)
                {
                    foreach(EventSource eventSource in eventSources)
                        eventSource.UnRegister();
                }
            }
            finally
            {
                // Let any straglers call start their calls
                preventShutdownLock.ReleaseWriterLock();
                Thread.Sleep(50);

                // Wait for any stragler that started
                preventShutdownLock.AcquireWriterLock(-1);
                preventShutdownLock.ReleaseWriterLock();
            }
        }
        static EventSource()
        {
            // We'll register for both ProcessExit and DomainUnload.  It is OK
            // if both are called, but bad if neither are called.  See comments
            // in ~EventSource();
            AppDomain.CurrentDomain.ProcessExit += new EventHandler(ProcessExit);
            AppDomain.CurrentDomain.DomainUnload += new EventHandler(ProcessExit);
        }

        IWbemServices pNamespaceNA = null;
        IWbemObjectSink pSinkNA = null;
        IWbemServices pNamespaceMTA = null;
        IWbemObjectSink pSinkMTA = null;

        AutoResetEvent doIndicate = new AutoResetEvent(false);
        AutoResetEvent doneIndicate = new AutoResetEvent(false);
        [DllImport("kernel32")] static extern IntPtr CreateEvent(IntPtr pSecurity, int manual, int initial, IntPtr name);
        [SuppressUnmanagedCodeSecurity, DllImport("kernel32")] static extern int SetEvent(IntPtr handle);
        [SuppressUnmanagedCodeSecurity, DllImport("kernel32")] static extern int WaitForSingleObject(IntPtr handle, int timeout);

        IntPtr hDoIndicate = CreateEvent(IntPtr.Zero, 0, 0, IntPtr.Zero);
        IntPtr hDoneIndicate = CreateEvent(IntPtr.Zero, 0, 0, IntPtr.Zero);


        // Worker thread for each EventSource
        int lengthFromSTA = -1;
        IntPtr[] objectsFromSTA;
        public void MTAWorkerThread()
        {
            while(true)
            {
                doIndicate.WaitOne();
                if(alive == false)
                    break;
                if(pSinkMTA != null)
                {
                    int hresult = pSinkMTA.Indicate_(lengthFromSTA, objectsFromSTA);
                    if (hresult < 0)
                    {
                        if ((hresult & 0xfffff000) == 0x80041000)
                            ManagementException.ThrowWithExtendedInfo((ManagementStatus)hresult);
                        else
                            Marshal.ThrowExceptionForHR(hresult);
                    }
                }

                doneIndicate.Set();
            }
        }

		//
		// [marioh, RAID: 111108]
		// Ensure we are able to trap exceptions from worker thread.
		// Called from IndicateEvents which in turn is protected from
		// concurrent access.
		//
		private Exception exception = null ;
		public void MTAWorkerThread2()
		{
			exception = null ;
			while(true)
			{
				try
				{
					WaitForSingleObject(hDoIndicate, -1);
					if(alive == false)
						break;

					if(pSinkMTA != null)
					{
						int hresult = pSinkMTA.Indicate_(lengthFromSTA, objectsFromSTA);
						if (hresult < 0)
						{
							if ((hresult & 0xfffff000) == 0x80041000)
								ManagementException.ThrowWithExtendedInfo((ManagementStatus)hresult);
							else
								Marshal.ThrowExceptionForHR(hresult);
						}
					}
				}
				catch ( Exception e )
				{
					exception = e ;
				}
				finally
				{
					SetEvent(hDoneIndicate);
				}
			}
		}


        bool alive = true;

        public void IndicateEvents(int length, IntPtr[] objects)
        {
            if(pSinkMTA == null)
                return;
            if(MTAHelper.IsNoContextMTA()) // Bug#110141 - Checking for MTA is not enough.  We need to make sure we are not in a COM+ Context
            {
                // Sink lives in MTA
                int hresult = pSinkMTA.Indicate_(length, objects);
                if (hresult < 0)
                {
                    if ((hresult & 0xfffff000) == 0x80041000)
                        ManagementException.ThrowWithExtendedInfo((ManagementStatus)hresult);
                    else
                        Marshal.ThrowExceptionForHR(hresult);
                }
            }
            else
            {
                // Do it from worker thread
                if(lengthFromSTA == -1)
                {
                    // We've never created worker thread
                    Thread thread = new Thread(new ThreadStart(MTAWorkerThread2));
                    thread.IsBackground = true; // bug#92154 - worker thread must be allowed to die on process shutdown
                    thread.ApartmentState = ApartmentState.MTA;
                    thread.Start();
                }
                lengthFromSTA = length;
                objectsFromSTA = objects;
                SetEvent(hDoIndicate);
                WaitForSingleObject(hDoneIndicate, -1);
				if ( exception != null )
				{
					throw exception ;
				}

//                doIndicate.Set();
//                doneIndicate.WaitOne();
            }
        }

		void RelocateSinkRCWToMTA()
		{
			ThreadDispatch disp = new ThreadDispatch ( new ThreadDispatch.ThreadWorkerMethodWithParam ( RelocateSinkRCWToMTA_ThreadFuncion ) ) ;
			disp.Parameter = this ;
			disp.Start ( ) ;

//            Thread thread = new Thread(new ThreadStart(RelocateSinkRCWToMTA_ThreadFuncion));
//            thread.ApartmentState = ApartmentState.MTA;
//            thread.Start();
//            thread.Join();
		}

		void RelocateSinkRCWToMTA_ThreadFuncion( object param )
		{
			EventSource threadParam = (EventSource) param ;
			threadParam.pSinkMTA = (IWbemObjectSink)RelocateRCWToCurrentApartment(threadParam.pSinkNA);
			threadParam.pSinkNA = null;
		}

		void RelocateNamespaceRCWToMTA()
		{
			ThreadDispatch disp = new ThreadDispatch ( new ThreadDispatch.ThreadWorkerMethodWithParam ( RelocateNamespaceRCWToMTA_ThreadFuncion ) ) ;
			disp.Parameter = this ;
			disp.Start ( ) ;

//            Thread thread = new Thread(new ThreadStart(RelocateNamespaceRCWToMTA_ThreadFuncion));
//            thread.ApartmentState = ApartmentState.MTA;
//            thread.Start();
//            thread.Join();
		}

		void RelocateNamespaceRCWToMTA_ThreadFuncion( object param )
		{
			EventSource threadParam = (EventSource) param ;
			threadParam.pNamespaceMTA = (IWbemServices)RelocateRCWToCurrentApartment(threadParam.pNamespaceNA);
			threadParam.pNamespaceNA = null;
		}

        static object RelocateRCWToCurrentApartment(object comObject)
        {
            if(null == comObject)
                return null;

            IntPtr pUnk = Marshal.GetIUnknownForObject(comObject);
            int references = Marshal.ReleaseComObject(comObject);
            if(references != 0)
                throw new Exception(); // TODO?

            comObject = Marshal.GetObjectForIUnknown(pUnk);
            Marshal.Release(pUnk);
            return comObject;
        }

        public bool Any()
        {
            return (null==pSinkMTA)||(mapQueryIdToQuery.Count==0);
        }

        Hashtable mapQueryIdToQuery = new Hashtable();
        // IWbemProviderInit
        int IWbemProviderInit.Initialize_(
            [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszUser,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszNamespace,
            [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszLocale,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemServices   pNamespace,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemProviderInitSink   pInitSink)
        {
//            Console.WriteLine(ComThreadingInfo.Current.ApartmentType);

            this.pNamespaceNA = pNamespace;
            RelocateNamespaceRCWToMTA();

            this.pSinkNA = null;
            this.pSinkMTA = null;

            lock(mapQueryIdToQuery)
            {
                mapQueryIdToQuery.Clear();
            }

            pInitSink.SetStatus_((int)tag_WBEM_EXTRA_RETURN_CODES.WBEM_S_INITIALIZED, 0);
            Marshal.ReleaseComObject(pInitSink);

            return 0;
        }

        // IWbemEventProvider
        int IWbemEventProvider.ProvideEvents_(
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pSink,
            [In] Int32 lFlags)
        {
//            Console.WriteLine(ComThreadingInfo.Current.ApartmentType);
            this.pSinkNA = pSink;
            RelocateSinkRCWToMTA();

            // TODO: Why do we get NewQuery BEFORE ProvideEvents?
//            mapQueryIdToQuery.Clear();
            return 0;
        }

        // IWbemEventProviderQuerySink
        int IWbemEventProviderQuerySink.NewQuery_(
            [In] UInt32 dwId,
            [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszQueryLanguage,
            [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszQuery)
        {
            lock(mapQueryIdToQuery)
            {
                // HACK: for bug where CancelQuery is not called correctly
                // and we get a NewQuery where dwId is already in our hashtable
                if(mapQueryIdToQuery.ContainsKey(dwId))
                    mapQueryIdToQuery.Remove(dwId);
                mapQueryIdToQuery.Add(dwId, wszQuery);
            }
            return 0;
        }

        int IWbemEventProviderQuerySink.CancelQuery_([In] UInt32 dwId)
        {
            lock(mapQueryIdToQuery)
            {
                mapQueryIdToQuery.Remove(dwId);
            }
            return 0;
        }

        // IWbemEventProviderSecurity
        int IWbemEventProviderSecurity.AccessCheck_(
            [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszQueryLanguage,
            [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszQuery,
            [In] Int32 lSidLength,
            [In] ref Byte pSid)
        {
            return 0;
        }

        // IWbemServices
        int IWbemServices_Old.OpenNamespace_([In][MarshalAs(UnmanagedType.BStr)]  string   strNamespace,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In][Out][MarshalAs(UnmanagedType.Interface)]  ref IWbemServices   ppWorkingNamespace,
            [In] IntPtr ppCallResult)
        {
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.CancelAsyncCall_([In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pSink)
        {
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.QueryObjectSink_([In] Int32 lFlags,
            [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemObjectSink   ppResponseHandler)
        {
            ppResponseHandler = null;
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.GetObject_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In][Out][MarshalAs(UnmanagedType.Interface)]  ref IWbemClassObject_DoNotMarshal   ppObject,
            [In] IntPtr ppCallResult)
        {
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.GetObjectAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler)
        {
//            pResponseHandler.SetStatus(0, (int)tag_WBEMSTATUS.WBEM_E_NOT_FOUND, null, null);
//            Marshal.ReleaseComObject(pResponseHandler);
//            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_FOUND);

            Match match = Regex.Match(strObjectPath.ToLower(CultureInfo.InvariantCulture), "(.*?)\\.instanceid=\"(.*?)\",processid=\"(.*?)\"");
            if(match.Success==false)
            {
                pResponseHandler.SetStatus_(0, (int)tag_WBEMSTATUS.WBEM_E_NOT_FOUND, null, IntPtr.Zero);
                Marshal.ReleaseComObject(pResponseHandler);
                return (int)(tag_WBEMSTATUS.WBEM_E_NOT_FOUND);
            }

            string className = match.Groups[1].Value;
            string instanceId = match.Groups[2].Value;
            string processId = match.Groups[3].Value;


            if(Instrumentation.ProcessIdentity != processId)
            {
                pResponseHandler.SetStatus_(0, (int)tag_WBEMSTATUS.WBEM_E_NOT_FOUND, null, IntPtr.Zero);
                Marshal.ReleaseComObject(pResponseHandler);
                return (int)(tag_WBEMSTATUS.WBEM_E_NOT_FOUND);
            }

            int id = ((IConvertible)instanceId).ToInt32(null);
            Object theObject = null;

            try
            {
                InstrumentedAssembly.readerWriterLock.AcquireReaderLock(-1);
                theObject = InstrumentedAssembly.mapIDToPublishedObject[id.ToString()];
            }
            finally
            {
                InstrumentedAssembly.readerWriterLock.ReleaseReaderLock();
            }

            if(theObject != null)
            {
                Type converterType = (Type)instrumentedAssembly.mapTypeToConverter[theObject.GetType()];
                if(converterType != null)
                {
                    Object converter = Activator.CreateInstance(converterType);
                    ConvertToWMI func = (ConvertToWMI)Delegate.CreateDelegate(typeof(ConvertToWMI), converter, "ToWMI");
                    IntPtr[] objs = new IntPtr[] {(IntPtr)converter.GetType().GetField("instWbemObjectAccessIP").GetValue(converter)};
                    Marshal.AddRef(objs[0]);
                    IWbemClassObjectFreeThreaded inst = new IWbemClassObjectFreeThreaded(objs[0]);

                    Object o = id;
                    inst.Put_("InstanceId", 0, ref o, 0);
                    o = Instrumentation.ProcessIdentity;
                    inst.Put_("ProcessId", 0, ref o, 0);
                    //                ConvertFuncToWMI func = (ConvertFuncToWMI)InstrumentedAssembly.mapTypeToToWMIFunc[h.Target.GetType()];
                    lock(theObject)
                        func(theObject);
                    pResponseHandler.Indicate_(1, objs);

                    pResponseHandler.SetStatus_(0, 0, null, IntPtr.Zero);
                    Marshal.ReleaseComObject(pResponseHandler);
                    return 0;
                }
            }
            pResponseHandler.SetStatus_(0, (int)tag_WBEMSTATUS.WBEM_E_NOT_FOUND, null, IntPtr.Zero);
            Marshal.ReleaseComObject(pResponseHandler);
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_FOUND);
#if xxx
            IWbemClassObject classObj = null;
            IWbemCallResult result = null;
            pNamespace.GetObject("TestInstance", 0, pCtx, ref classObj, ref result);
            IWbemClassObject inst;
            classObj.SpawnInstance(0, out inst);

            TestInstance testInstance = (TestInstance)mapNameToTestInstance[match.Groups[1].Value];

            Object o = (object)testInstance.name;
            inst.Put("name", 0, ref o, 0);
            o = (object)testInstance.value;
            inst.Put("value", 0, ref o, 0);

            pResponseHandler.Indicate(1, new IWbemClassObject[] {inst});
            pResponseHandler.SetStatus_(0, 0, IntPtr.Zero, IntPtr.Zero);
            Marshal.ReleaseComObject(pResponseHandler);
#endif
        }

        int IWbemServices_Old.PutClass_([In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pObject,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In] IntPtr ppCallResult)
        {
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.PutClassAsync_([In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pObject,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler)
        {
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.DeleteClass_([In][MarshalAs(UnmanagedType.BStr)]  string   strClass,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In] IntPtr ppCallResult)
        {
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.DeleteClassAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strClass,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler)
        {
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.CreateClassEnum_([In][MarshalAs(UnmanagedType.BStr)]  string   strSuperclass,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject   ppEnum)
        {
            ppEnum = null;
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.CreateClassEnumAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strSuperclass,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler)
        {
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.PutInstance_([In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pInst,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In] IntPtr ppCallResult)
        {
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.PutInstanceAsync_([In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pInst,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler)
        {
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.DeleteInstance_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In] IntPtr ppCallResult)
        {
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.DeleteInstanceAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler)
        {
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.CreateInstanceEnum_([In][MarshalAs(UnmanagedType.BStr)]  string   strFilter,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject   ppEnum)
        {
            ppEnum = null;
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        protected const string DllName = "wminet_utils.dll";
        protected const string EntryPointName = "UFunc";
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] public static extern int GetPropertyHandle_f27(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszPropertyName, [Out] out Int32 pType, [Out] out Int32 plHandle);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] public static extern int WritePropertyValue_f28(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Int32 lNumBytes, [In][MarshalAs(UnmanagedType.LPWStr)] string str);

        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int Clone_f12(int vFunc, IntPtr pWbemClassObject, [Out] out IntPtr ppCopy);

        int IWbemServices_Old.CreateInstanceEnumAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strFilter,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler)
        {
            try
            {
                // Make sure we do not let a shutdown kill this thread
                preventShutdownLock.AcquireReaderLock(-1);

                // If we are already shutting down, don't do anything
                if(shutdownInProgress != 0)
                    return 0;

                // If batching takes longer than 1/10 of a second, we want to stop
                // and flush the batch
                uint timeLimitForBatchFlush = (uint)Environment.TickCount + 100;

                // Find the managed type that is being requested by this call
                Type managedType = null;
                foreach(Type type in instrumentedAssembly.mapTypeToConverter.Keys)
                {
                    if(0==String.Compare(ManagedNameAttribute.GetMemberName(type), strFilter, false,CultureInfo.InvariantCulture))
                    {
                        managedType = type;
                        break;
                    }
                }

                // If we do not support the requested type, just exit
                if(null == managedType)
                    return 0;

                // size for batching
                int batchSize = 64;

                // Array of IWbemClassObject IntPtrs for batching
                IntPtr[] objs = new IntPtr[batchSize];
                IntPtr[] objsClone = new IntPtr[batchSize];

                // Array of converter methods for batching
                ConvertToWMI[] funcs = new ConvertToWMI[batchSize];

                // Array of IWbemClassObjectFreeThreaded instances for batching
                IWbemClassObjectFreeThreaded[] insts = new IWbemClassObjectFreeThreaded[batchSize];

                // IWbemObjectAccess handle for 'InstanceId'
                int handleInstanceId = 0;

                // Current number of objects in batch
                int count = 0;

                // The process identity string
                Object processIdentity = Instrumentation.ProcessIdentity;

                // Walk all published instances
                try
                {
                    // Don't let anyone add entries to the dictionary while we are enumerating it.
                    // Other people can read from the dictionary
                    InstrumentedAssembly.readerWriterLock.AcquireReaderLock(-1);
                    foreach(DictionaryEntry entry in InstrumentedAssembly.mapIDToPublishedObject)
                    {
                        // If the process is going away, stop indicating more instances
                        if(shutdownInProgress != 0)
                            return 0;

                        // Is this object the type requested by this query?
                        if(managedType != entry.Value.GetType())
                            continue;

                        // Initialize this batch entry if necessary.  Each element of the batch arrays
                        // are initialized 'just in time'.  If we have less than batchSize entries total
                        // (or it takes too long to batch), we do not unnecessarily allocate the batch entry
						if(funcs[count] == null)
						{
							Object converter = Activator.CreateInstance((Type)instrumentedAssembly.mapTypeToConverter[managedType]);
							funcs[count] = (ConvertToWMI)Delegate.CreateDelegate(typeof(ConvertToWMI), converter, "ToWMI");

							//
							// Reuters VSQFE#: 750	[marioh]
							// In order for the instance data batching logic to work properly, we HAVE TO convert the .NET
							// objects to WMI objects before we update the batching pointers since the ToWMI method in the generated
							// code will Spawn new instances.
							// 
							lock(entry.Value)
								funcs[count](entry.Value);

							objs[count] = (IntPtr)converter.GetType().GetField("instWbemObjectAccessIP").GetValue(converter);
							Marshal.AddRef(objs[count]);
							insts[count] = new IWbemClassObjectFreeThreaded(objs[count]);
							insts[count].Put_("ProcessId", 0, ref processIdentity, 0);

							int cimType;
							if(count==0)
								GetPropertyHandle_f27(27, insts[count], "InstanceId", out cimType, out handleInstanceId);
						}
						else
						{
							//
							// Reuters VSQFE#: 750	[marioh]
							// If we end up re-using an existing delegate from the batch array, we still have to convert
							// the .NET to WMI objects and update the instance pointers.
							//

							// Copy the managed instance information into the IWbemClassObject'
							// We're using a batch, therefore we have to convert them.
							lock(entry.Value)
								funcs[count](entry.Value);

							objs[count] = (IntPtr) funcs[count].Target.GetType().GetField("instWbemObjectAccessIP").GetValue(funcs[count].Target);

							//
							// We have to AddRef the interface pointer due to the IWbemClassObjectFreeThreaded not addreffing
							// but releasing in the destructor. Great huh?
							//
							Marshal.AddRef(objs[count]);
							insts[count] = new IWbemClassObjectFreeThreaded(objs[count]);
							insts[count].Put_("ProcessId", 0, ref processIdentity, 0);

							int cimType;
							if(count==0)
								GetPropertyHandle_f27(27, insts[count], "InstanceId", out cimType, out handleInstanceId);
						}

                        // We have an instance to publish.  Store the instance ID in 'InstanceId'
                        string instanceId = (string)entry.Key;
                        WritePropertyValue_f28(28, insts[count], handleInstanceId, (instanceId.Length+1)*2, instanceId);

						//                        // Copy the managed instance information into the IWbemClassObject'
						//                        lock(entry.Value)
						//                            funcs[count](entry.Value);

                        // Increment the batch counter
                        count++;

                        // If we've reached batchSize, or if we've gone longer than 1/10th second since
                        // an Indicate, flush the batch
                        if(count == batchSize || ((uint)Environment.TickCount) >= timeLimitForBatchFlush)
                        {
                            // Do the Indicate to WMI
                            // NOTE: On WinXP, we cannot control whether the implementation of
                            // Indicate will immediately send the objects to WMI, or if it will
                            // batch them.  If it batches them, we cannot reuse them in a future
                            // call to Indicate, or change them in any way after the call to
                            // Indicate.  Because of this, we will always 'Clone' the objects
                            // just before calling Indicate.  The performance is negligable, even
                            // on Windows 2000, which can handle about 200,000 Clones per second
                            // on a 1 GHz machine.
                            for(int i=0;i<count;i++)
                                Clone_f12(12, objs[i], out objsClone[i]);
                            int hr = pResponseHandler.Indicate_(count, objsClone);
                            for(int i=0;i<count;i++)
                                Marshal.Release(objsClone[i]);

                            // If hr is not S_OK, we stop the enumeration.  This can happen if the
                            // client cancels the call.
                            if(hr != 0 )
                                return 0;

                            // Reset the batch counter
                            count = 0;

                            // Reset the time limit for another 1/10th second in the future
                            timeLimitForBatchFlush = (uint)Environment.TickCount + 100;
                        }
                    }
                }
                finally
                {
                    InstrumentedAssembly.readerWriterLock.ReleaseReaderLock();
                }
                if(count > 0)
                {
                    // NOTE: On WinXP, we cannot control whether the implementation of
                    // Indicate will immediately send the objects to WMI, or if it will
                    // batch them.  If it batches them, we cannot reuse them in a future
                    // call to Indicate, or change them in any way after the call to
                    // Indicate.  Because of this, we will always 'Clone' the objects
                    // just before calling Indicate.  The performance is negligable, even
                    // on Windows 2000, which can handle about 200,000 Clones per second
                    // on a 1 GHz machine.
                    for(int i=0;i<count;i++)
                        Clone_f12(12, objs[i], out objsClone[i]);
                    pResponseHandler.Indicate_(count, objsClone);
                    for(int i=0;i<count;i++)
                        Marshal.Release(objsClone[i]);
                }
            }
            finally
            {
                pResponseHandler.SetStatus_(0, 0, null, IntPtr.Zero);
                Marshal.ReleaseComObject(pResponseHandler);
                preventShutdownLock.ReleaseReaderLock();
            }
            return 0;
        }

        int IWbemServices_Old.ExecQuery_([In][MarshalAs(UnmanagedType.BStr)]  string   strQueryLanguage,
            [In][MarshalAs(UnmanagedType.BStr)]  string   strQuery,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject   ppEnum)
        {
            ppEnum = null;
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.ExecQueryAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strQueryLanguage,
            [In][MarshalAs(UnmanagedType.BStr)]  string   strQuery,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler)
        {
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.ExecNotificationQuery_([In][MarshalAs(UnmanagedType.BStr)]  string   strQueryLanguage,
            [In][MarshalAs(UnmanagedType.BStr)]  string   strQuery,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject   ppEnum)
        {
            ppEnum = null;
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.ExecNotificationQueryAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strQueryLanguage,
            [In][MarshalAs(UnmanagedType.BStr)]  string   strQuery,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler)
        {
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.ExecMethod_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath,
            [In][MarshalAs(UnmanagedType.BStr)]  string   strMethodName,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pInParams,
            [In][Out][MarshalAs(UnmanagedType.Interface)]  ref IWbemClassObject_DoNotMarshal   ppOutParams,
            [In] IntPtr ppCallResult)
        {
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }

        int IWbemServices_Old.ExecMethodAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath,
            [In][MarshalAs(UnmanagedType.BStr)]  string   strMethodName,
            [In] Int32 lFlags,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pInParams,
            [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler)
        {
            return (int)(tag_WBEMSTATUS.WBEM_E_NOT_SUPPORTED);
        }
    }
}


#if UNUSED_CODE
    class HResultException : Exception
    {
        public HResultException(int hr)
        {
            base.HResult = hr;
        }
    }

    class WbemStatusException : HResultException
    {
        public WbemStatusException(tag_WBEMSTATUS status) : base((int)status) {}
    }

    /*********************************************
     * Wbem Internal
     *********************************************/
    [TypeLibTypeAttribute(0x0200)]
    [InterfaceTypeAttribute(0x0001)]
    [GuidAttribute("6C19BE32-7500-11D1-AD94-00C04FD8FDFF")]
    [ComImport]
    interface IWbemMetaData
    {
        void GetClass([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszClassName, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pContext, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemClassObject   ppClass);
    } // end of IWbemMetaData

    [GuidAttribute("755F9DA6-7508-11D1-AD94-00C04FD8FDFF")]
    [TypeLibTypeAttribute(0x0200)]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemMultiTarget
    {
        void DeliverEvent([In] UInt32 dwNumEvents, [In][MarshalAs(UnmanagedType.Interface)]  ref IWbemClassObject   aEvents, [In] ref tag_WBEM_REM_TARGETS aTargets);
        void DeliverStatus([In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Error)]  Int32   hresStatus, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszStatus, [In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject   pErrorObj, [In] ref tag_WBEM_REM_TARGETS pTargets);
    } // end of IWbemMultiTarget

    struct tag_WBEM_REM_TARGETS
    {
        public Int32 m_lNumTargets;

        //        [ComConversionLossAttribute]
        //        public IntPtr m_aTargets;
        [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] UInt32[]  m_aTargets;
    } // end of tag_WBEM_REM_TARGETS
  
    [GuidAttribute("60E512D4-C47B-11D2-B338-00105A1F4AAF")]
    [TypeLibTypeAttribute(0x0200)]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemFilterProxy
    {
        void Initialize([In][MarshalAs(UnmanagedType.Interface)]  IWbemMetaData   pMetaData, [In][MarshalAs(UnmanagedType.Interface)]  IWbemMultiTarget   pMultiTarget);
        void Lock();
        void Unlock();
        void AddFilter([In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pContext, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszQuery, [In] UInt32 Id);
        void RemoveFilter([In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pContext, [In] UInt32 Id);
        void RemoveAllFilters([In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pContext);
        void AddDefinitionQuery([In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pContext, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszQuery);
        void RemoveAllDefinitionQueries([In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pContext);
        void Disconnect();
    } // end of IWbemFilterProxy

    [TypeLibTypeAttribute(0x0202)]
    [GuidAttribute("6C19BE35-7500-11D1-AD94-00C04FD8FDFF")]
    [ClassInterfaceAttribute((short)0x0000)]
    [ComImport]
    class WbemFilterProxy  /*: IWbemFilterProxy, IWbemObjectSink*/
    {
    } // end of WbemFilterProxy
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\instrumentation\attributes.cs ===
//------------------------------------------------------------------------------
// <copyright from='1997' to='2001' company='Microsoft Corporation'>           
//    Copyright (c) Microsoft Corporation. All Rights Reserved.                
//    Information Contained Herein is Proprietary and Confidential.            
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Management.Instrumentation
{
    using System;
    using System.Reflection;
    using System.Collections;
    using System.Text.RegularExpressions;
    using System.Management;
    using System.Globalization;

    /// <summary>
    ///    <para>Specifies that this assembly provides management instrumentation. This attribute should appear one time per assembly.</para>
    /// </summary>
    /// <remarks>
    /// <para>For more information about using attributes, see <see topic="cpconExtendingMetadataUsingAttributes" title="Extending Metadata Using Attributes"/> .</para>
    /// </remarks>
    [AttributeUsage(AttributeTargets.Assembly)]
    public class InstrumentedAttribute : Attribute
    {
        string namespaceName;
        string securityDescriptor;

        /// <overload>
        ///    Initializes a new instance
        ///    of the <see cref='System.Management.Instrumentation.InstrumentedAttribute'/> class.
        /// </overload>
        /// <summary>
        /// <para>Initializes a new instance of the <see cref='System.Management.Instrumentation.InstrumentedAttribute'/> 
        /// class that is set for the root\default namespace. This is the default constructor.</para>
        /// </summary>
        public InstrumentedAttribute() : this(null, null) {}

        /// <summary>
        /// <para>Initializes a new instance of the <see cref='System.Management.Instrumentation.InstrumentedAttribute'/> class that is set to the specified namespace for instrumentation within this assembly.</para>
        /// </summary>
        /// <param name='namespaceName'>The namespace for instrumentation instances and events.</param>
        public InstrumentedAttribute(string namespaceName) : this(namespaceName, null) {}

        /// <summary>
        /// <para>Initializes a new instance of the <see cref='System.Management.Instrumentation.InstrumentedAttribute'/> class that is set to the specified namespace and security settings for instrumentation within this assembly.</para>
        /// </summary>
        /// <param name='namespaceName'>The namespace for instrumentation instances and events.</param>
        /// <param name='securityDescriptor'> A security descriptor that allows only the specified users or groups to run applications that provide the instrumentation supported by this assembly.</param>
        public InstrumentedAttribute(string namespaceName, string securityDescriptor)
        {
            // TODO: Do we need validation
            // bug#62511 - always use backslash in name
            if(namespaceName != null)
                namespaceName = namespaceName.Replace('/', '\\');

            if(namespaceName == null || namespaceName.Length == 0)
                namespaceName = "root\\default"; // bug#60933 Use a default namespace if null


            bool once = true;
            foreach(string namespacePart in namespaceName.Split('\\'))
            {
                if(     namespacePart.Length == 0
                    ||  (once && namespacePart.ToLower(CultureInfo.InvariantCulture) != "root")  // Must start with 'root'
                    ||  !Regex.Match(namespacePart, @"^[a-z,A-Z]").Success // All parts must start with letter
                    ||  Regex.Match(namespacePart, @"_$").Success // Must not end with an underscore
                    ||  Regex.Match(namespacePart, @"[^a-z,A-Z,0-9,_,\u0080-\uFFFF]").Success) // Only letters, digits, or underscores
                {
                    ManagementException.ThrowWithExtendedInfo(ManagementStatus.InvalidNamespace);
                }
                once = false;
            }

            this.namespaceName = namespaceName;
            this.securityDescriptor = securityDescriptor;
        }

        /// <summary>
        ///    <para>Gets or sets the namespace for instrumentation instances and events in this assembly.</para>
        /// </summary>
        /// <value>
        ///    <para>If not specified, the default namespace will be set as "\\.\root\default". 
        ///       Otherwise, a string indicating the name of the namespace for instrumentation
        ///       instances and events in this assembly.</para>
        /// </value>
        /// <remarks>
        ///    It is highly recommended that the namespace name be specified by the
        ///    assembly, and that it should be a unique namespace per assembly, or per
        ///    application. Having a specific namespace for each assembly or
        ///    application instrumentation allows more granularity for securing access to
        ///    instrumentation provided by different assemblies or applications.
        /// </remarks>
        public string NamespaceName 
        {
            get { return namespaceName == null ? string.Empty : namespaceName; }
        }
        
        /// <summary>
        ///    <para> Gets or sets a security descriptor that allows only the specified users or groups to run
        ///       applications that provide the instrumentation supported by this assembly.</para>
        /// </summary>
        /// <value>
        ///    If null, the default value is defined as the Local Administrators Group. This
        ///    will only allow members of the local administrators group to publish data and
        ///    fire events from this assembly. Otherwise, this is a string in SDDL format
        ///    representing the security descriptor that defines which users and groups can
        ///    provide instrumentation data and events from this application.
        /// </value>
        /// <remarks>
        ///    <para>Users or groups not specified in this
        ///       security descriptor may still run the application, but cannot provide
        ///       instrumentation from this assembly.</para>
        /// </remarks>
        public string SecurityDescriptor
        {
            get
            {
                // This will never return an empty string.  Instead, it will
                // return null, or a non-zero length string
                if(null == securityDescriptor || securityDescriptor.Length == 0)
                    return null;
                return securityDescriptor;
            }
        }

        internal static InstrumentedAttribute GetAttribute(Assembly assembly)
        {
            Object [] rg = assembly.GetCustomAttributes(typeof(InstrumentedAttribute), false);
            if(rg.Length > 0)
                return ((InstrumentedAttribute)rg[0]);
            return new InstrumentedAttribute();
        }

        internal static Type[] GetInstrumentedTypes(Assembly assembly)
        {
            ArrayList types = new ArrayList();
            GetInstrumentedDerivedTypes(assembly, types, null);
            return (Type[])types.ToArray(typeof(Type));
        }

        static void GetInstrumentedDerivedTypes(Assembly assembly, ArrayList types, Type typeParent)
        {
            foreach(Type type in assembly.GetTypes())
            {
                if(IsInstrumentationClass(type) && InstrumentationClassAttribute.GetBaseInstrumentationType(type) == typeParent)
                {
                    types.Add(type);
                    GetInstrumentedDerivedTypes(assembly, types, type);
                }
            }
        }

        static bool IsInstrumentationClass(Type type)
        {
            return (null != InstrumentationClassAttribute.GetAttribute(type));
        }

    }
    
    /// <summary>
    ///    <para>Specifies the type of instrumentation provided by a class.</para>
    /// </summary>
    /// <example>
    ///    <code lang='C#'>using System;
    /// using System.Management;
    /// using System.Configuration.Install;
    /// using System.Management.Instrumentation;
    /// 
    /// // This example demonstrates how to create a Management Event class by using
    /// // the InstrumentationClass attribute and to fire a Management Event from
    /// // managed code.
    /// 
    /// // Specify which namespace the Management Event class is created in
    /// [assembly:Instrumented("Root/Default")]
    /// 
    /// // Let the system know you will run InstallUtil.exe utility against
    /// // this assembly
    /// [System.ComponentModel.RunInstaller(true)]
    /// public class MyInstaller : DefaultManagementProjectInstaller {}
    /// 
    /// // Create a Management Instrumentation Event class
    /// [InstrumentationClass(InstrumentationType.Event)]
    /// public class MyEvent
    /// {
    ///     public string EventName;
    /// }
    /// 
    /// public class WMI_InstrumentedEvent_Example
    /// {
    ///     public static void Main() {
    ///         MyEvent e = new MyEvent();
    ///         e.EventName = "Hello";
    ///         
    ///         // Fire a Management Event
    ///         Instrumentation.Fire(e);
    ///         
    ///         return;
    ///     }
    /// }
    ///    </code>
    ///    <code lang='VB'>Imports System
    /// Imports System.Management
    /// Imports System.Configuration.Install
    /// Imports System.Management.Instrumentation
    /// 
    /// ' This sample demonstrates how to create a Management Event class by using
    /// ' the InstrumentationClass attribute and to fire a Management Event from
    /// ' managed code.
    /// 
    /// ' Specify which namespace the Manaegment Event class is created in
    /// &lt;assembly: Instrumented("Root/Default")&gt;
    /// 
    /// ' Let the system know InstallUtil.exe utility will be run against
    /// ' this assembly
    /// &lt;System.ComponentModel.RunInstaller(True)&gt; _
    /// Public Class MyInstaller
    ///     Inherits DefaultManagementProjectInstaller
    /// End Class 'MyInstaller
    /// 
    /// ' Create a Management Instrumentation Event class
    /// &lt;InstrumentationClass(InstrumentationType.Event)&gt; _ 
    /// Public Class MyEvent
    ///     Public EventName As String
    /// End Class
    /// 
    /// Public Class Sample_EventProvider
    ///     Public Shared Function Main(args() As String) As Integer
    ///         Dim e As New MyEvent()
    ///         e.EventName = "Hello"
    ///         
    ///         ' Fire a Management Event
    ///         Instrumentation.Fire(e)
    ///         
    ///         Return 0
    ///     End Function
    /// End Class
    ///    </code>
    /// </example>
    public enum InstrumentationType
    {
        /// <summary>
        ///    <para>Specifies that the class provides instances for management instrumentation.</para>
        /// </summary>
        Instance,
        /// <summary>
        ///    <para>Specifies that the class provides events for management instrumentation.</para>
        /// </summary>
        Event,
        /// <summary>
        ///    <para>Specifies that the class defines an abstract class for management instrumentation.</para>
        /// </summary>
        Abstract
    }

    /// <summary>
    /// Specifies that a class provides event or instance instrumentation.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
    public class InstrumentationClassAttribute : Attribute
    {
        InstrumentationType instrumentationType;
        string managedBaseClassName;

        /// <overload>
        ///    Initializes a new instance
        ///    of the <see cref='System.Management.Instrumentation.InstrumentationClassAttribute'/> class.
        /// </overload>
        /// <summary>
        /// <para>Initializes a new instance of the <see cref='System.Management.Instrumentation.InstrumentationClassAttribute'/> class that is used if this type is derived from another type that has the <see cref='System.Management.Instrumentation.InstrumentationClassAttribute'/> attribute, or if this is a 
        ///    top-level instrumentation class (for example, an instance or abstract class
        ///    without a base class, or an event derived from <see langword='__ExtrinsicEvent'/>).</para>
        /// </summary>
        /// <param name='instrumentationType'>The type of instrumentation provided by this class.</param>
        public InstrumentationClassAttribute(InstrumentationType instrumentationType)
        {
            this.instrumentationType = instrumentationType;
        }

        /// <summary>
        /// <para>Initializes a new instance of the <see cref='System.Management.Instrumentation.InstrumentationClassAttribute'/> class that
        ///    has schema for an existing base class. The class must contain
        ///    proper member definitions for the properties of the existing
        ///    WMI base class.</para>
        /// </summary>
        /// <param name='instrumentationType'>The type of instrumentation provided by this class.</param>
        /// <param name='managedBaseClassName'>The name of the base class.</param>
        public InstrumentationClassAttribute(InstrumentationType instrumentationType, string managedBaseClassName)
        {
            this.instrumentationType = instrumentationType;
            this.managedBaseClassName = managedBaseClassName;
        }

        /// <summary>
        ///    <para>Gets or sets the type of instrumentation provided by this class.</para>
        /// </summary>
        /// <value>
        ///    Contains an <see cref='System.Management.Instrumentation.InstrumentationType'/> value that
        ///    indicates whether this is an instrumented event, instance or abstract class.
        /// </value>
        public InstrumentationType InstrumentationType
        {
            get { return instrumentationType; }
        }

        /// <summary>
        ///    <para>Gets or sets the name of the base class of this instrumentation class.</para>
        /// </summary>
        /// <value>
        ///    <para>If not null, this string indicates the WMI baseclass that this class inherits
        ///       from in the CIM schema.</para>
        /// </value>
        public string ManagedBaseClassName
        {
            get
            {
                // This will never return an empty string.  Instead, it will
                // return null, or a non-zero length string
                if(null == managedBaseClassName || managedBaseClassName.Length == 0)
                    return null;

                return managedBaseClassName;
            }
        }

        internal static InstrumentationClassAttribute GetAttribute(Type type)
        {
            // We don't want BaseEvent or Instance to look like that have an 'InstrumentedClass' attribute
            if(type == typeof(BaseEvent) || type == typeof(Instance))
                return null;

            // We will inherit the 'InstrumentedClass' attribute from a base class
            Object [] rg = type.GetCustomAttributes(typeof(InstrumentationClassAttribute), true);
            if(rg.Length > 0)
                return ((InstrumentationClassAttribute)rg[0]);
            return null;
        }

		/// <summary>
		/// <para>Displays the <see langword='Type'/> of the base class.</para>
		/// </summary>
		/// <param name='type'></param>
		/// <returns>
		/// <para>The <see langword='Type'/> of the base class, if this class is derived from another 
		///    instrumentation class; otherwise, null.</para>
		/// </returns>
		internal static Type GetBaseInstrumentationType(Type type)
        {
            // If the BaseType has a InstrumentationClass attribute,
            // we return the BaseType
            if(GetAttribute(type.BaseType) != null)
                return type.BaseType;
            return null;
        }
    }

    /// <summary>
    ///    <para>Allows an instrumented class, or member of an instrumented class,
    ///       to present an alternate name through management instrumentation.</para>
    /// </summary>
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Field | AttributeTargets.Property  | AttributeTargets.Method)]
    public class ManagedNameAttribute : Attribute
    {
        string name;

		/// <summary>
		/// <para>Gets the name of the managed entity.</para>
		/// </summary>
		/// <value>
		/// Contains the name of the managed entity.
		/// </value>
		public string Name
		{
			get { return name ; }
		}

        /// <summary>
        /// <para>Initializes a new instance of the <see cref='System.Management.Instrumentation.ManagedNameAttribute'/> class that allows the alternate name to be specified
        ///    for the type, field, property, method, or parameter to which this attribute is applied.</para>
        /// </summary>
        /// <param name='name'>The alternate name for the type, field, property, method, or parameter to which this attribute is applied.</param>
        public ManagedNameAttribute(string name)
        {
            this.name = name;
        }

        internal static string GetMemberName(MemberInfo member)
        {
            // This works for all sorts of things: Type, MethodInfo, PropertyInfo, FieldInfo
            Object [] rg = member.GetCustomAttributes(typeof(ManagedNameAttribute), false);
            if(rg.Length > 0)
            {
                // bug#69115 - if null or empty string are passed, we just ignore this attribute
                ManagedNameAttribute attr = (ManagedNameAttribute)rg[0];
                if(attr.name != null && attr.name.Length != 0)
                    return attr.name;
            }

            return member.Name;
        }

        internal static string GetBaseClassName(Type type)
        {
            InstrumentationClassAttribute attr = InstrumentationClassAttribute.GetAttribute(type);
            string name = attr.ManagedBaseClassName;
            if(name != null)
                return name;
            
            // Get managed base type's attribute
            InstrumentationClassAttribute attrParent = InstrumentationClassAttribute.GetAttribute(type.BaseType);

            // If the base type does not have a InstrumentationClass attribute,
            // return a base type based on the InstrumentationType
            if(null == attrParent)
            {
                switch(attr.InstrumentationType)
                {
                    case InstrumentationType.Abstract:
                        return null;
                    case InstrumentationType.Instance:
                        return null;
                    case InstrumentationType.Event:
                        return "__ExtrinsicEvent";
                    default:
                        break;
                }
            }

            // Our parent was also a managed provider type.  Use it's managed name.
            return GetMemberName(type.BaseType);
        }
    }

    /// <summary>
    ///    <para>Allows a particular member of an instrumented class to be ignored
    ///       by management instrumentation</para>
    /// </summary>
    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property  | AttributeTargets.Method)]
    public class IgnoreMemberAttribute : Attribute
    {
    }

#if REQUIRES_EXPLICIT_DECLARATION_OF_INHERITED_PROPERTIES
    /// <summary>
    ///    <para>[To be supplied.]</para>
    /// </summary>
    [AttributeUsage(AttributeTargets.Field)]
    public class InheritedPropertyAttribute : Attribute
    {
        internal static InheritedPropertyAttribute GetAttribute(FieldInfo field)
        {
            Object [] rg = field.GetCustomAttributes(typeof(InheritedPropertyAttribute), false);
            if(rg.Length > 0)
                return ((InheritedPropertyAttribute)rg[0]);
            return null;
        }
    }
#endif

#if SUPPORTS_WMI_DEFAULT_VAULES
    [AttributeUsage(AttributeTargets.Field)]
    internal class ManagedDefaultValueAttribute : Attribute
    {
        Object defaultValue;
        public ManagedDefaultValueAttribute(Object defaultValue)
        {
            this.defaultValue = defaultValue;
        }

        public static Object GetManagedDefaultValue(FieldInfo field)
        {
            Object [] rg = field.GetCustomAttributes(typeof(ManagedDefaultValueAttribute), false);
            if(rg.Length > 0)
                return ((ManagedDefaultValueAttribute)rg[0]).defaultValue;

            return null;
        }
    }
#endif

#if SUPPORTS_ALTERNATE_WMI_PROPERTY_TYPE
    [AttributeUsage(AttributeTargets.Field)]
    internal class ManagedTypeAttribute : Attribute
    {
        Type type;
        public ManagedTypeAttribute(Type type)
        {
            this.type = type;
        }

        public static Type GetManagedType(FieldInfo field)
        {
            Object [] rg = field.GetCustomAttributes(typeof(ManagedTypeAttribute), false);
            if(rg.Length > 0)
                return ((ManagedTypeAttribute)rg[0]).type;

            return field.FieldType;
        }
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\instrumentation\assemblynameutility.cs ===
//------------------------------------------------------------------------------
// <copyright from='1997' to='2001' company='Microsoft Corporation'>           
//    Copyright (c) Microsoft Corporation. All Rights Reserved.                
//    Information Contained Herein is Proprietary and Confidential.            
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Management.Instrumentation
{
	using System;
	using System.Reflection;
	using System.Globalization;

	class AssemblyNameUtility
	{
		private static string BinToString(byte [] rg)
		{
			if(rg == null)
				return "";
			string sz = "";
			for(int i=0;i<rg.GetLength(0);i++)
			{
				sz += String.Format("{0:x2}", rg[i]);
			}
			return sz;
		}

		public static string UniqueToAssemblyMinorVersion(Assembly assembly)
		{
            AssemblyName an = assembly.GetName(true);
			return an.Name + "_SN_"+BinToString(an.GetPublicKeyToken()) + "_Version_"+an.Version.Major +"."+ an.Version.Minor;// +"."+ an.Version.Revision+"."+an.Version.Build;
		}

        static string UniqueToAssemblyVersion(Assembly assembly)
        {
            AssemblyName an = assembly.GetName(true);
            return an.Name + "_SN_"+BinToString(an.GetPublicKeyToken()) + "_Version_"+an.Version.Major +"."+ an.Version.Minor+"."+an.Version.Build +"."+ an.Version.Revision;
        }

        public static string UniqueToAssemblyBuild(Assembly assembly)
		{
            return UniqueToAssemblyVersion(assembly) + "_Mvid_"+MetaDataInfo.GetMvid(assembly).ToString().ToLower(CultureInfo.InvariantCulture);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\instrumentation\metadatainfo.cs ===
//------------------------------------------------------------------------------
// <copyright from='1997' to='2001' company='Microsoft Corporation'>           
//    Copyright (c) Microsoft Corporation. All Rights Reserved.                
//    Information Contained Herein is Proprietary and Confidential.            
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Management.Instrumentation
{
    using System;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Runtime.CompilerServices;
    using System.Text;


    /// <summary>
    /// CoClass for getting an IMetaDataDispenser
    /// </summary>
    [ComImport]
    [Guid("E5CB7A31-7512-11d2-89CE-0080C792E5D8")]
    [TypeLibType(TypeLibTypeFlags.FCanCreate) /*0x0002*/]
    [ClassInterface(ClassInterfaceType.None  /*(short)0x0000*/)]
    class CorMetaDataDispenser 
    {
    }

    /// <summary>
    /// This version of the IMetaDataDispenser interface defines
    /// the interfaces so that the last parameter from cor.h
    /// is the return value of the methods.  The 'raw' way to
    /// implement these methods is as follows:
    ///    void OpenScope(
    ///        [In][MarshalAs(UnmanagedType.LPWStr)]  string   szScope,
    ///        [In] UInt32 dwOpenFlags,
    ///        [In] ref Guid riid,
    ///        [Out] out IntPtr ppIUnk);
    /// The way to call this other version is as follows
    ///    IntPtr unk;
    ///    dispenser.OpenScope(assemblyName, 0, ref guidIMetaDataImport, out unk);
    ///    importInterface = (IMetaDataImport)Marshal.GetObjectForIUnknown(unk);
    ///    Marshal.Release(unk);
    /// </summary>
    [ComImport]
    [Guid("809c652e-7396-11d2-9771-00a0c9b4d50c")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown /*0x0001*/)]
    [TypeLibType(TypeLibTypeFlags.FRestricted /*0x0200*/)]
    interface IMetaDataDispenser
    {
        [return:MarshalAs(UnmanagedType.Interface)]
        object DefineScope(
            [In] ref Guid rclsid,
            [In] UInt32  dwCreateFlags,
            [In] ref Guid riid);

        [return:MarshalAs(UnmanagedType.Interface)]
        object OpenScope(
            [In][MarshalAs(UnmanagedType.LPWStr)]  string   szScope,
            [In] UInt32 dwOpenFlags,
            [In] ref Guid riid);

        [return:MarshalAs(UnmanagedType.Interface)]
        object OpenScopeOnMemory(
            [In] IntPtr pData,
            [In] UInt32 cbData,
            [In] UInt32 dwOpenFlags,
            [In] ref Guid riid);
    }


    /// <summary>
    /// This class is an INCOMPLETE IMPLEMENTATION OF IMetaDataImport.  For the purposes of
    /// System.Management.dll, we only needed to call one method, GetScopeProps
    /// </summary>
    [ComImport]
    [Guid("7DAC8207-D3AE-4c75-9B67-92801A497D44")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown /*0x0001*/)]
    [TypeLibType(TypeLibTypeFlags.FRestricted /*0x0200*/)]
    interface IMetaDataImportInternalOnly
    {
        void f1();
        void f2();
        void f3();
        void f4();
        void f5();
        void f6();
        void f7();
        void GetScopeProps(
            [Out][MarshalAs(UnmanagedType.LPWStr)] StringBuilder szName,
            [In] UInt32 cchName,
            [Out] out UInt32 pchName,
            [Out] out Guid pmvid);
    }


    /// <summary>
    /// This class wraps the functionality of IMetaDataImport.  It abstracts the
    /// details of working directly with the interface.
    /// </summary>
    class MetaDataInfo : IDisposable
    {
        public MetaDataInfo(Assembly assembly) : this(assembly.Location) {}

        public MetaDataInfo(string assemblyName)
        {
            // Get guid for IMetaDataImport
            Guid guidIMetaDataImport = new Guid(((GuidAttribute)Attribute.GetCustomAttribute(typeof(IMetaDataImportInternalOnly), typeof(GuidAttribute), false)).Value);

            // Get an IMetaDataImport for the assembly from a dispenser
            IMetaDataDispenser dispenser = (IMetaDataDispenser)new CorMetaDataDispenser();
            importInterface = (IMetaDataImportInternalOnly)dispenser.OpenScope(assemblyName, 0, ref guidIMetaDataImport);
            Marshal.ReleaseComObject(dispenser);
        }

        IMetaDataImportInternalOnly importInterface;

        // These two fields are initialized the first time either is requested
        // They are both retrieved through IMetaDataImport GetScopeProps
        string name = null;
        Guid mvid;

        void InitNameAndMvid()
        {
            // If we have never retrieved the name and MVID, get them now
            if(null==name)
            {
                UInt32 cchName;
                StringBuilder sb = new StringBuilder();
                sb.Capacity = 0;
                importInterface.GetScopeProps(sb, (UInt32)sb.Capacity, out cchName, out mvid);
                sb.Capacity = (int)cchName;
                importInterface.GetScopeProps(sb, (UInt32)sb.Capacity, out cchName, out mvid);
                name = sb.ToString();
            }
        }

        public string Name
        {
            get
            {
                InitNameAndMvid();
                return name;
            }
        }

        public Guid Mvid
        {
            get
            {
                InitNameAndMvid();
                return mvid;
            }
        }

        public void Dispose()
        {
            // We implement IDisposable on this class because the IMetaDataImport
            // can be an expensive object to keep in memory.
            if(importInterface == null)
                Marshal.ReleaseComObject(importInterface);
            importInterface = null;
            GC.SuppressFinalize(this);
        }

        ~MetaDataInfo()
        {
            Dispose();
        }

        public static Guid GetMvid(Assembly assembly)
        {
            using(MetaDataInfo info = new MetaDataInfo(assembly))
            {
                return info.Mvid;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\interopclasses\wmiinterop.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

using System;
using System.Runtime.InteropServices;
using System.Security;
using System.Runtime.Serialization;
using System.Threading;
using System.Globalization;
using System.Security.Permissions;

namespace WbemClient_v1 {}
namespace WbemUtilities_v1 {}

namespace System.Management
{
	#region FreeThreadedInterfaces
	[Serializable]
	sealed class IWbemClassObjectFreeThreaded : IDisposable, ISerializable
    {
        //
		// This is to force load wminet_utils.dll as a COM component. Since wminet_utils.dll
		// lives in the version framework directory, a direct DllImport will try to load the
		// wminet_utils.dll from the currently set environment path. In certain cases, such as
		// redist install this path will not be set and we get a DllNotFound exception thrown.
		// By forcing the DLL to be loaded as a COM DLL, mscoree will go to the registry and get
		// the correct path and succeed in loading the DLL. Once the DllImport occurs, the DLL will
		// already be in the cache.
		// 
		static WmiSec wmiSec = new WmiSec();
		const string DllName = "wminet_utils.dll";
		const string EntryPointName = "UFunc";
        const string SerializationBlobName = "flatWbemClassObject";
        static readonly string name = typeof(IWbemClassObjectFreeThreaded).FullName;
        public static Guid IID_IWbemClassObject = new Guid("DC12A681-737F-11CF-884D-00AA004B2E24");

        IntPtr pWbemClassObject = IntPtr.Zero;

        public IWbemClassObjectFreeThreaded(IntPtr pWbemClassObject)
        {
            // This instance will now own a single ref count on pWbemClassObject
            this.pWbemClassObject = pWbemClassObject;
        }

        public static implicit operator IntPtr(IWbemClassObjectFreeThreaded wbemClassObject)
        {
            if(null == wbemClassObject)
                return IntPtr.Zero;
            return wbemClassObject.pWbemClassObject;
        }

        public IWbemClassObjectFreeThreaded(SerializationInfo info, StreamingContext context)
        {
            Byte[] rg = info.GetValue(SerializationBlobName, typeof(Byte[])) as Byte[];
            if(null == rg)
                throw new SerializationException();

            DeserializeFromBlob(rg);
        }

		//FXCop requests explicit demand of the SerializationFormatter permission
		[SecurityPermission(SecurityAction.Demand, SerializationFormatter=true)]
		void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
        {
            info.AddValue(SerializationBlobName, SerializeToBlob());
        }

        public void Dispose()
        {
            if(pWbemClassObject != IntPtr.Zero)
            {
                Marshal.Release(pWbemClassObject);
                pWbemClassObject = IntPtr.Zero;
            }
            GC.SuppressFinalize(this);
        }

        ~IWbemClassObjectFreeThreaded()
        {
            Dispose();
        }

        void DeserializeFromBlob(Byte [] rg)
        {
            IntPtr hGlobal = IntPtr.Zero;
            UCOMIStream stream = null;
            try
            {
                // If something goes wrong, we want to make sure the object is invalidated
                pWbemClassObject = IntPtr.Zero;

                hGlobal = Marshal.AllocHGlobal(rg.Length);
                Marshal.Copy(rg, 0, hGlobal, rg.Length);
                stream = CreateStreamOnHGlobal(hGlobal, 0);
                pWbemClassObject = CoUnmarshalInterface(stream, ref IID_IWbemClassObject);
            }
            finally
            {
                if(stream != null)
                    Marshal.ReleaseComObject(stream);
                if(hGlobal != IntPtr.Zero)
                    Marshal.FreeHGlobal(hGlobal);
            }
        }

        Byte[] SerializeToBlob()
        {
            Byte [] rg = null;
            UCOMIStream stream = null;
            IntPtr pData = IntPtr.Zero;
            try
            {
                // Stream will own the HGlobal
                stream = CreateStreamOnHGlobal(IntPtr.Zero, 1);

                CoMarshalInterface(stream, ref IID_IWbemClassObject, pWbemClassObject, (UInt32)MSHCTX.MSHCTX_DIFFERENTMACHINE, IntPtr.Zero, (UInt32)MSHLFLAGS.MSHLFLAGS_TABLEWEAK);

                STATSTG statstg;
                stream.Stat(out statstg, (int)STATFLAG.STATFLAG_DEFAULT);
                rg = new Byte[statstg.cbSize];
                pData = GlobalLock(GetHGlobalFromStream(stream));
                Marshal.Copy(pData, rg, 0, (int)statstg.cbSize);
            }
            finally
            {
                if(pData != IntPtr.Zero)
                    GlobalUnlock(pData);
                if(stream != null)
                    Marshal.ReleaseComObject(stream);
            }
            return rg;
        }

        // Interface methods
        public int GetQualifierSet_(out IWbemQualifierSetFreeThreaded ppQualSet)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            IntPtr pQualSet;
            int hResult = GetQualifierSet_f(3, pWbemClassObject, out pQualSet);
            if(hResult < 0)
                ppQualSet = null;
            else
                ppQualSet = new IWbemQualifierSetFreeThreaded(pQualSet);
            return hResult;
        }
        public int Get_(string wszName, Int32 lFlags, ref object pVal, ref Int32 pType, ref Int32 plFlavor)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            int hr = Get_f(4, pWbemClassObject, wszName, lFlags, ref pVal, ref pType, ref plFlavor);
            // There is a BUG in WMI where some instances (events and out params from method invocations)
            // do not have a __PATH property.  Unfortunately, GetNames says the object DOES have a __PATH
            // property.  Going under the assumption that __PATH should always exist, we make a slight fixup
            // if we detect a missing __PATH
            if(hr == (int)ManagementStatus.InvalidObject)
            {
                // We optimize the quick string comparison before trying the case insensitive comparison
                if(wszName == "__PATH" || wszName.ToLower(CultureInfo.InvariantCulture) == "__path")
                {
                    hr = 0;
                    pType = (Int32)tag_CIMTYPE_ENUMERATION.CIM_STRING;
                    plFlavor = (Int32)tag_WBEM_FLAVOR_TYPE.WBEM_FLAVOR_ORIGIN_SYSTEM;
                    pVal = DBNull.Value;
                }
            }
            return hr;
        }
        public int Put_(string wszName, Int32 lFlags, ref object pVal, Int32 Type)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return Put_f(5, pWbemClassObject, wszName, lFlags, ref pVal, Type);
        }
        public int Delete_(string wszName)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return Delete_f(6, pWbemClassObject, wszName);
        }
        public int GetNames_(string wszQualifierName, Int32 lFlags, ref object pQualifierVal, out string[] pNames)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return GetNames_f(7, pWbemClassObject, wszQualifierName, lFlags, ref pQualifierVal, out pNames);
        }
        public int BeginEnumeration_(Int32 lEnumFlags)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return BeginEnumeration_f(8, pWbemClassObject, lEnumFlags);
        }
        public int Next_(Int32 lFlags, ref string strName, ref object pVal, ref Int32 pType, ref Int32 plFlavor)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            pVal = null; // This is really an Out parameter - it will be overwritten TODO: Fix
            strName = null;  // This is really an Out parameter - it will be overwritten TODO: Fix
            return Next_f(9, pWbemClassObject, lFlags, ref strName, ref pVal, ref pType, ref plFlavor);
        }
        public int EndEnumeration_()
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return EndEnumeration_f(10, pWbemClassObject);
        }
        public int GetPropertyQualifierSet_(string wszProperty, out IWbemQualifierSetFreeThreaded ppQualSet)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            IntPtr pQualSet;
            int hResult = GetPropertyQualifierSet_f(11, pWbemClassObject, wszProperty, out pQualSet);
            if(hResult < 0)
                ppQualSet = null;
            else
                ppQualSet = new IWbemQualifierSetFreeThreaded(pQualSet);
            return hResult;
        }
        public int Clone_(out IWbemClassObjectFreeThreaded ppCopy)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            IntPtr pWbemClassObjectNew;
            int hResult = Clone_f(12, pWbemClassObject, out pWbemClassObjectNew);
            if(hResult < 0)
                ppCopy = null;
            else
                ppCopy = new IWbemClassObjectFreeThreaded(pWbemClassObjectNew);
            return hResult;
        }
        public int GetObjectText_(Int32 lFlags, out string pstrObjectText)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return GetObjectText_f(13, pWbemClassObject, lFlags, out pstrObjectText);
        }
        public int SpawnDerivedClass_(Int32 lFlags, out IWbemClassObjectFreeThreaded ppNewClass)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            IntPtr pWbemClassObjectNew;
            int hResult = SpawnDerivedClass_f(14, pWbemClassObject, lFlags, out pWbemClassObjectNew);
            if(hResult < 0)
                ppNewClass = null;
            else
                ppNewClass = new IWbemClassObjectFreeThreaded(pWbemClassObjectNew);
            return hResult;
        }
        public int SpawnInstance_(Int32 lFlags, out IWbemClassObjectFreeThreaded ppNewInstance)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            IntPtr pWbemClassObjectNew;
            int hResult = SpawnInstance_f(15, pWbemClassObject, lFlags, out pWbemClassObjectNew);
            if(hResult < 0)
                ppNewInstance = null;
            else
                ppNewInstance = new IWbemClassObjectFreeThreaded(pWbemClassObjectNew);
            return hResult;
        }
        public int CompareTo_(Int32 lFlags, IWbemClassObjectFreeThreaded pCompareTo)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return CompareTo_f(16, pWbemClassObject, lFlags, pCompareTo.pWbemClassObject);
        }
        public int GetPropertyOrigin_(string wszName, out string pstrClassName)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return GetPropertyOrigin_f(17, pWbemClassObject, wszName, out pstrClassName);
        }
        public int InheritsFrom_(string strAncestor)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return InheritsFrom_f(18, pWbemClassObject, strAncestor);
        }
        public int GetMethod_(string wszName, Int32 lFlags, out IWbemClassObjectFreeThreaded ppInSignature, out IWbemClassObjectFreeThreaded ppOutSignature)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            IntPtr pInSignature;
            IntPtr pOutSignature;
            int hResult = GetMethod_f(19, pWbemClassObject, wszName, lFlags, out pInSignature, out pOutSignature);
            ppInSignature = null;
            ppOutSignature = null;
            if(hResult >= 0)
            {
                // This can be NULL
                if(pInSignature != IntPtr.Zero)
                    ppInSignature = new IWbemClassObjectFreeThreaded(pInSignature);
                if(pOutSignature != IntPtr.Zero)
                    ppOutSignature = new IWbemClassObjectFreeThreaded(pOutSignature);
            }
            return hResult;
        }
        public int PutMethod_(string wszName, Int32 lFlags, IWbemClassObjectFreeThreaded pInSignature, IWbemClassObjectFreeThreaded pOutSignature)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return PutMethod_f(20, pWbemClassObject, wszName, lFlags, pInSignature, pOutSignature);
        }
        public int DeleteMethod_(string wszName)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return DeleteMethod_f(21, pWbemClassObject, wszName);
        }
        public int BeginMethodEnumeration_(Int32 lEnumFlags)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return BeginMethodEnumeration_f(22, pWbemClassObject, lEnumFlags);
        }
        public int NextMethod_(Int32 lFlags, out string pstrName, out IWbemClassObjectFreeThreaded ppInSignature, out IWbemClassObjectFreeThreaded ppOutSignature)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);

            // TODO: Provide overload which optionally only gets the name param
            IntPtr pInSignature;
            IntPtr pOutSignature;
            int hResult = NextMethod_f(23, pWbemClassObject, lFlags, out pstrName, out pInSignature, out pOutSignature);
            ppInSignature = null;
            ppOutSignature = null;
            if(hResult >= 0)
            {
                // This can be NULL
                if(pInSignature != IntPtr.Zero)
                    ppInSignature = new IWbemClassObjectFreeThreaded(pInSignature);
                if(pOutSignature != IntPtr.Zero)
                    ppOutSignature = new IWbemClassObjectFreeThreaded(pOutSignature);
            }
            return hResult;
        }
        public int EndMethodEnumeration_()
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return EndMethodEnumeration_f(24, pWbemClassObject);
        }
        public int GetMethodQualifierSet_(string wszMethod, out IWbemQualifierSetFreeThreaded ppQualSet)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            IntPtr pQualSet;
            int hResult = GetMethodQualifierSet_f(25, pWbemClassObject, wszMethod, out pQualSet);
            if(hResult < 0)
                ppQualSet = null;
            else
                ppQualSet = new IWbemQualifierSetFreeThreaded(pQualSet);
            return hResult;
        }
        public int GetMethodOrigin_(string wszMethodName, out string pstrClassName)
        {
            if(pWbemClassObject == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return GetMethodOrigin_f(26, pWbemClassObject, wszMethodName, out pstrClassName);
        }

        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int GetQualifierSet_f(int vFunc, IntPtr pWbemClassObject, [Out] out IntPtr ppQualSet);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int Get_f(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [In][Out] ref object pVal, [In][Out] ref Int32 pType, [In][Out] ref Int32 plFlavor);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int Put_f(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [In] ref object pVal, [In] Int32 Type);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int Delete_f(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int GetNames_f(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszQualifierName, [In] Int32 lFlags, [In] ref object pQualifierVal, [Out][MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_BSTR)]  out string[]   pNames);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int BeginEnumeration_f(int vFunc, IntPtr pWbemClassObject, [In] Int32 lEnumFlags);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int Next_f(int vFunc, IntPtr pWbemClassObject, [In] Int32 lFlags, [In][Out][MarshalAs(UnmanagedType.BStr)]  ref string   strName, [In][Out] ref object pVal, [In][Out] ref Int32 pType, [In][Out] ref Int32 plFlavor);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int EndEnumeration_f(int vFunc, IntPtr pWbemClassObject);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int GetPropertyQualifierSet_f(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszProperty, [Out] out IntPtr ppQualSet);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int Clone_f(int vFunc, IntPtr pWbemClassObject, [Out] out IntPtr ppCopy);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int GetObjectText_f(int vFunc, IntPtr pWbemClassObject, [In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.BStr)]  out string   pstrObjectText);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int SpawnDerivedClass_f(int vFunc, IntPtr pWbemClassObject, [In] Int32 lFlags, [Out] out IntPtr ppNewClass);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int SpawnInstance_f(int vFunc, IntPtr pWbemClassObject, [In] Int32 lFlags, [Out] out IntPtr ppNewInstance);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int CompareTo_f(int vFunc, IntPtr pWbemClassObject, [In] Int32 lFlags, [In] IntPtr pCompareTo);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int GetPropertyOrigin_f(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [Out][MarshalAs(UnmanagedType.BStr)]  out string   pstrClassName);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int InheritsFrom_f(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   strAncestor);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int GetMethod_f(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [Out]out IntPtr ppInSignature, [Out] out IntPtr ppOutSignature);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int PutMethod_f(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [In] IntPtr pInSignature, [In] IntPtr pOutSignature);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int DeleteMethod_f(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int BeginMethodEnumeration_f(int vFunc, IntPtr pWbemClassObject, [In] Int32 lEnumFlags);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int NextMethod_f(int vFunc, IntPtr pWbemClassObject, [In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.BStr)] out string pstrName, [Out] out IntPtr ppInSignature, [Out] out IntPtr ppOutSignature);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int EndMethodEnumeration_f(int vFunc, IntPtr pWbemClassObject);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int GetMethodQualifierSet_f(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszMethod, [Out] out IntPtr ppQualSet);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int GetMethodOrigin_f(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszMethodName, [Out][MarshalAs(UnmanagedType.BStr)]  out string   pstrClassName);

        enum STATFLAG 
        {
            STATFLAG_DEFAULT    = 0,
            STATFLAG_NONAME     = 1
        }

        enum MSHCTX
        {
            MSHCTX_LOCAL               = 0,
            MSHCTX_NOSHAREDMEM         = 1,
            MSHCTX_DIFFERENTMACHINE    = 2,
            MSHCTX_INPROC              = 3 
        }

        enum MSHLFLAGS 
        {
            MSHLFLAGS_NORMAL         = 0,
            MSHLFLAGS_TABLESTRONG    = 1,
            MSHLFLAGS_TABLEWEAK      = 2,
            MSHLFLAGS_NOPING         = 3
        }

        [DllImport("ole32.dll", PreserveSig=false)]
        static extern UCOMIStream CreateStreamOnHGlobal(IntPtr hGlobal, int fDeleteOnRelease);

        [DllImport("ole32.dll", PreserveSig=false)]
        static extern IntPtr GetHGlobalFromStream([In] UCOMIStream pstm);

        [DllImport("kernel32.dll", PreserveSig=true)]
        static extern IntPtr GlobalLock([In] IntPtr hGlobal);

        [DllImport("kernel32.dll", PreserveSig=true)]
        static extern int GlobalUnlock([In] IntPtr pData);

//	Not used
//        [DllImport("ole32.dll", PreserveSig=false)]
//        static extern void CoGetMarshalSizeMax(
//            [In] ref UInt32 ulSize,      //Pointer to the upper-bound value
//            [In] ref Guid riid,         //Reference to the identifier of the interface
//            [In] IntPtr Unk,      //Pointer to the interface to be marshaled
//            [In] UInt32 dwDestContext,  //Destination process
//            [In] IntPtr pvDestContext,   //Reserved for future use
//            [In] UInt32 mshlflags       //Reason for marshaling
//            );

        [DllImport("ole32.dll", PreserveSig=false)]
        static extern void CoMarshalInterface(
            [In] UCOMIStream pStm,        //Pointer to the stream used for marshaling
            [In] ref Guid riid,          //Reference to the identifier of the 
            [In] IntPtr Unk,      //Pointer to the interface to be marshaled
            [In] UInt32 dwDestContext,  //Destination process
            [In] IntPtr pvDestContext,   //Reserved for future use
            [In] UInt32 mshlflags       //Reason for marshaling
            );

        [DllImport("ole32.dll", PreserveSig=false)]
        static extern IntPtr CoUnmarshalInterface(
            [In] UCOMIStream pStm,  //Pointer to the stream
            [In] ref Guid riid     //Reference to the identifier of the interface
            );
    }

    sealed class IWbemQualifierSetFreeThreaded : IDisposable
    {
        const string DllName = "wminet_utils.dll";
        const string EntryPointName = "UFunc";
        const string SerializationBlobName = "flatWbemClassObject";
        static readonly string name = typeof(IWbemQualifierSetFreeThreaded).FullName;
        public static Guid IID_IWbemClassObject = new Guid("DC12A681-737F-11CF-884D-00AA004B2E24");

        IntPtr pWbemQualifierSet = IntPtr.Zero;
        public IWbemQualifierSetFreeThreaded(IntPtr pWbemQualifierSet)
        {
            // This instance will now own a single ref count on pWbemClassObject
            this.pWbemQualifierSet = pWbemQualifierSet;
        }

        public void Dispose()
        {
            if(pWbemQualifierSet != IntPtr.Zero)
            {
                Marshal.Release(pWbemQualifierSet);
                pWbemQualifierSet = IntPtr.Zero;
            }
            GC.SuppressFinalize(this);
        }

        ~IWbemQualifierSetFreeThreaded()
        {
            Dispose();
        }

        public int Get_(string wszName, Int32 lFlags, ref object pVal, ref Int32 plFlavor)
        {
            if(pWbemQualifierSet == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return Get_f(3, pWbemQualifierSet, wszName, lFlags, ref pVal, ref plFlavor);
        }
        public int Put_(string wszName, ref object pVal, Int32 lFlavor)
        {
            if(pWbemQualifierSet == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return Put_f(4, pWbemQualifierSet, wszName, ref pVal, lFlavor);
        }
        public int Delete_(string wszName)
        {
            if(pWbemQualifierSet == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return Delete_f(5, pWbemQualifierSet, wszName);
        }
        public int GetNames_(Int32 lFlags, out string[] pNames)
        {
            if(pWbemQualifierSet == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return GetNames_f(6, pWbemQualifierSet, lFlags, out pNames);
        }
        public int BeginEnumeration_(Int32 lFlags)
        {
            if(pWbemQualifierSet == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return BeginEnumeration_f(7, pWbemQualifierSet, lFlags);
        }
        public int Next_(Int32 lFlags, out string pstrName, out object pVal, out Int32 plFlavor)
        {
            if(pWbemQualifierSet == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return Next_f(8, pWbemQualifierSet, lFlags, out pstrName, out pVal, out plFlavor);
        }
        public int EndEnumeration_()
        {
            if(pWbemQualifierSet == IntPtr.Zero)
                throw new ObjectDisposedException(name);
            return EndEnumeration_f(9, pWbemQualifierSet);
        }

        
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int Get_f(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [In][Out] ref object pVal, [In][Out] ref Int32 plFlavor);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int Put_f(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] ref object pVal, [In] Int32 lFlavor);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int Delete_f(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int GetNames_f(int vFunc, IntPtr pWbemClassObject, [In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_BSTR)]  out string[]   pNames);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int BeginEnumeration_f(int vFunc, IntPtr pWbemClassObject, [In] Int32 lFlags);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int Next_f(int vFunc, IntPtr pWbemClassObject, [In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.BStr)]  out string   pstrName, [Out] out object pVal, [Out] out Int32 plFlavor);
        [SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] static extern int EndEnumeration_f(int vFunc, IntPtr pWbemClassObject);
    }

    class MarshalWbemObject : ICustomMarshaler 
    {
        public static ICustomMarshaler GetInstance(string cookie)
        {
            return new MarshalWbemObject(cookie);
        }

        string cookie;
        MarshalWbemObject(string cookie)
        {
            this.cookie = cookie;
        }

        public void CleanUpManagedData(object obj) 
        {
        }

        public void CleanUpNativeData(IntPtr pObj) 
        {
//            Marshal.Release(pObj);
        }

        public int GetNativeDataSize() 
        {
            return -1; // not a value type, so use -1
        }

        public IntPtr MarshalManagedToNative(object obj) 
        {
            return (IntPtr)obj;
        }

        public object MarshalNativeToManaged(IntPtr pObj) 
        {
            return new IWbemClassObjectFreeThreaded(pObj);
        }
    }
	#endregion

    #region Interfaces
    [InterfaceTypeAttribute(0x0001)]
    [TypeLibTypeAttribute(0x0200)]
    [GuidAttribute("DC12A681-737F-11CF-884D-00AA004B2E24")]
    [ComImport]
    interface IWbemClassObject_DoNotMarshal
    {
        [PreserveSig] int GetQualifierSet_([Out][MarshalAs(UnmanagedType.Interface)]  out IWbemQualifierSet_DoNotMarshal   ppQualSet);
        [PreserveSig] int Get_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [In][Out] ref object pVal, [In][Out] ref Int32 pType, [In][Out] ref Int32 plFlavor);
        [PreserveSig] int Put_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [In] ref object pVal, [In] Int32 Type);
        [PreserveSig] int Delete_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName);
        [PreserveSig] int GetNames_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszQualifierName, [In] Int32 lFlags, [In] ref object pQualifierVal, [Out][MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_BSTR)]  out string[]   pNames);
        [PreserveSig] int BeginEnumeration_([In] Int32 lEnumFlags);
        [PreserveSig] int Next_([In] Int32 lFlags, [In][Out][MarshalAs(UnmanagedType.BStr)]  ref string   strName, [In][Out] ref object pVal, [In][Out] ref Int32 pType, [In][Out] ref Int32 plFlavor);
        [PreserveSig] int EndEnumeration_();
        [PreserveSig] int GetPropertyQualifierSet_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszProperty, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemQualifierSet_DoNotMarshal   ppQualSet);
        [PreserveSig] int Clone_([Out][MarshalAs(UnmanagedType.Interface)]  out IWbemClassObject_DoNotMarshal   ppCopy);
        [PreserveSig] int GetObjectText_([In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.BStr)]  out string   pstrObjectText);
        [PreserveSig] int SpawnDerivedClass_([In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemClassObject_DoNotMarshal   ppNewClass);
        [PreserveSig] int SpawnInstance_([In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemClassObject_DoNotMarshal   ppNewInstance);
        [PreserveSig] int CompareTo_([In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pCompareTo);
        [PreserveSig] int GetPropertyOrigin_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [Out][MarshalAs(UnmanagedType.BStr)]  out string   pstrClassName);
        [PreserveSig] int InheritsFrom_([In][MarshalAs(UnmanagedType.LPWStr)]  string   strAncestor);
        [PreserveSig] int GetMethod_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemClassObject_DoNotMarshal   ppInSignature, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemClassObject_DoNotMarshal   ppOutSignature);
        [PreserveSig] int PutMethod_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pInSignature, [In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pOutSignature);
        [PreserveSig] int DeleteMethod_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName);
        [PreserveSig] int BeginMethodEnumeration_([In] Int32 lEnumFlags);
        [PreserveSig] int NextMethod_([In] Int32 lFlags, [In][Out][MarshalAs(UnmanagedType.BStr)]  ref string   pstrName, [In][Out][MarshalAs(UnmanagedType.Interface)]  ref IWbemClassObject_DoNotMarshal   ppInSignature, [In][Out][MarshalAs(UnmanagedType.Interface)]  ref IWbemClassObject_DoNotMarshal   ppOutSignature);
        [PreserveSig] int EndMethodEnumeration_();
        [PreserveSig] int GetMethodQualifierSet_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszMethod, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemQualifierSet_DoNotMarshal   ppQualSet);
        [PreserveSig] int GetMethodOrigin_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszMethodName, [Out][MarshalAs(UnmanagedType.BStr)]  out string   pstrClassName);
    }

    [InterfaceTypeAttribute(0x0001)]
    [GuidAttribute("DC12A680-737F-11CF-884D-00AA004B2E24")]
    [TypeLibTypeAttribute(0x0200)]
    [ComImport]
    interface IWbemQualifierSet_DoNotMarshal
    {
        [PreserveSig] int Get_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [In][Out] ref object pVal, [In][Out] ref Int32 plFlavor);
        [PreserveSig] int Put_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] ref object pVal, [In] Int32 lFlavor);
        [PreserveSig] int Delete_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName);
        [PreserveSig] int GetNames_([In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_BSTR)]  out string[]   pNames);
        [PreserveSig] int BeginEnumeration_([In] Int32 lFlags);
        [PreserveSig] int Next_([In] Int32 lFlags, [In][Out][MarshalAs(UnmanagedType.BStr)]  ref string   pstrName, [In][Out] ref object pVal, [In][Out] ref Int32 plFlavor);
        [PreserveSig] int EndEnumeration_();
    }

    [InterfaceTypeAttribute(0x0001)]
    [TypeLibTypeAttribute(0x0200)]
    [GuidAttribute("DC12A687-737F-11CF-884D-00AA004B2E24")]
    [ComImport]
    interface IWbemLocator
    {
        [PreserveSig] int ConnectServer_([In][MarshalAs(UnmanagedType.BStr)]  string   strNetworkResource, [In][MarshalAs(UnmanagedType.BStr)]  string   strUser, [In][MarshalAs(UnmanagedType.BStr)]  string   strPassword, [In][MarshalAs(UnmanagedType.BStr)]  string   strLocale, [In] Int32 lSecurityFlags, [In][MarshalAs(UnmanagedType.BStr)]  string   strAuthority, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemServices   ppNamespace);
    }

    [GuidAttribute("44ACA674-E8FC-11D0-A07C-00C04FB68820")]
    [TypeLibTypeAttribute(0x0200)]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemContext
    {
        [PreserveSig] int Clone_([Out][MarshalAs(UnmanagedType.Interface)]  out IWbemContext   ppNewCopy);
        [PreserveSig] int GetNames_([In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_BSTR)]  out string[]   pNames);
        [PreserveSig] int BeginEnumeration_([In] Int32 lFlags);
        [PreserveSig] int Next_([In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.BStr)]  out string   pstrName, [Out] out object pValue);
        [PreserveSig] int EndEnumeration_();
        [PreserveSig] int SetValue_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [In] ref object pValue);
        [PreserveSig] int GetValue_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [Out] out object pValue);
        [PreserveSig] int DeleteValue_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags);
        [PreserveSig] int DeleteAll_();
    }

    [InterfaceTypeAttribute(0x0001)]
    [TypeLibTypeAttribute(0x0200)]
    [GuidAttribute("9556DC99-828C-11CF-A37E-00AA003240C7")]
    [ComImport]
    interface IWbemServices
    {
        [PreserveSig] int OpenNamespace_([In][MarshalAs(UnmanagedType.BStr)]  string   strNamespace, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][Out][MarshalAs(UnmanagedType.Interface)]  ref IWbemServices   ppWorkingNamespace, [In] IntPtr ppCallResult);
        [PreserveSig] int CancelAsyncCall_([In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pSink);
        [PreserveSig] int QueryObjectSink_([In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemObjectSink   ppResponseHandler);
        [PreserveSig] int GetObject_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [Out][MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(MarshalWbemObject))] out IWbemClassObjectFreeThreaded ppObject, [In] IntPtr ppCallResult);
        [PreserveSig] int GetObjectAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int PutClass_([In] IntPtr pObject, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In] IntPtr ppCallResult);
        [PreserveSig] int PutClassAsync_([In] IntPtr pObject, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int DeleteClass_([In][MarshalAs(UnmanagedType.BStr)]  string   strClass, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In] IntPtr ppCallResult);
        [PreserveSig] int DeleteClassAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strClass, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int CreateClassEnum_([In][MarshalAs(UnmanagedType.BStr)]  string   strSuperclass, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject   ppEnum);
        [PreserveSig] int CreateClassEnumAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strSuperclass, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int PutInstance_([In] IntPtr pInst, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In] IntPtr ppCallResult);
        [PreserveSig] int PutInstanceAsync_([In] IntPtr pInst, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int DeleteInstance_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In] IntPtr ppCallResult);
        [PreserveSig] int DeleteInstanceAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int CreateInstanceEnum_([In][MarshalAs(UnmanagedType.BStr)]  string   strFilter, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject   ppEnum);
        [PreserveSig] int CreateInstanceEnumAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strFilter, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int ExecQuery_([In][MarshalAs(UnmanagedType.BStr)]  string   strQueryLanguage, [In][MarshalAs(UnmanagedType.BStr)]  string   strQuery, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject   ppEnum);
        [PreserveSig] int ExecQueryAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strQueryLanguage, [In][MarshalAs(UnmanagedType.BStr)]  string   strQuery, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int ExecNotificationQuery_([In][MarshalAs(UnmanagedType.BStr)]  string   strQueryLanguage, [In][MarshalAs(UnmanagedType.BStr)]  string   strQuery, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject   ppEnum);
        [PreserveSig] int ExecNotificationQueryAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strQueryLanguage, [In][MarshalAs(UnmanagedType.BStr)]  string   strQuery, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int ExecMethod_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath, [In][MarshalAs(UnmanagedType.BStr)]  string   strMethodName, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In] IntPtr pInParams, [Out][MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(MarshalWbemObject))] out IWbemClassObjectFreeThreaded ppOutParams, [In] IntPtr ppCallResult);
        [PreserveSig] int ExecMethodAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath, [In][MarshalAs(UnmanagedType.BStr)]  string   strMethodName, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In] IntPtr pInParams, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
    }

    [InterfaceTypeAttribute(0x0001)]
    [TypeLibTypeAttribute(0x0200)]
    [GuidAttribute("9556DC99-828C-11CF-A37E-00AA003240C7")]
    [ComImport]
    interface IWbemServices_Old
    {
        [PreserveSig] int OpenNamespace_([In][MarshalAs(UnmanagedType.BStr)]  string   strNamespace, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][Out][MarshalAs(UnmanagedType.Interface)]  ref IWbemServices   ppWorkingNamespace, [In] IntPtr ppCallResult);
        [PreserveSig] int CancelAsyncCall_([In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pSink);
        [PreserveSig] int QueryObjectSink_([In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemObjectSink   ppResponseHandler);
        [PreserveSig] int GetObject_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][Out][MarshalAs(UnmanagedType.Interface)]  ref IWbemClassObject_DoNotMarshal   ppObject, [In] IntPtr ppCallResult);
        [PreserveSig] int GetObjectAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int PutClass_([In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pObject, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In] IntPtr ppCallResult);
        [PreserveSig] int PutClassAsync_([In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pObject, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int DeleteClass_([In][MarshalAs(UnmanagedType.BStr)]  string   strClass, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In] IntPtr ppCallResult);
        [PreserveSig] int DeleteClassAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strClass, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int CreateClassEnum_([In][MarshalAs(UnmanagedType.BStr)]  string   strSuperclass, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject   ppEnum);
        [PreserveSig] int CreateClassEnumAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strSuperclass, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int PutInstance_([In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pInst, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In] IntPtr ppCallResult);
        [PreserveSig] int PutInstanceAsync_([In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pInst, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int DeleteInstance_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In] IntPtr ppCallResult);
        [PreserveSig] int DeleteInstanceAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int CreateInstanceEnum_([In][MarshalAs(UnmanagedType.BStr)]  string   strFilter, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject   ppEnum);
        [PreserveSig] int CreateInstanceEnumAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strFilter, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int ExecQuery_([In][MarshalAs(UnmanagedType.BStr)]  string   strQueryLanguage, [In][MarshalAs(UnmanagedType.BStr)]  string   strQuery, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject   ppEnum);
        [PreserveSig] int ExecQueryAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strQueryLanguage, [In][MarshalAs(UnmanagedType.BStr)]  string   strQuery, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int ExecNotificationQuery_([In][MarshalAs(UnmanagedType.BStr)]  string   strQueryLanguage, [In][MarshalAs(UnmanagedType.BStr)]  string   strQuery, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject   ppEnum);
        [PreserveSig] int ExecNotificationQueryAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strQueryLanguage, [In][MarshalAs(UnmanagedType.BStr)]  string   strQuery, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
        [PreserveSig] int ExecMethod_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath, [In][MarshalAs(UnmanagedType.BStr)]  string   strMethodName, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pInParams, [In][Out][MarshalAs(UnmanagedType.Interface)]  ref IWbemClassObject_DoNotMarshal   ppOutParams, [In] IntPtr ppCallResult);
        [PreserveSig] int ExecMethodAsync_([In][MarshalAs(UnmanagedType.BStr)]  string   strObjectPath, [In][MarshalAs(UnmanagedType.BStr)]  string   strMethodName, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pInParams, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pResponseHandler);
    }

    [GuidAttribute("44ACA675-E8FC-11D0-A07C-00C04FB68820")]
    [TypeLibTypeAttribute(0x0200)]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemCallResult
    {
        [PreserveSig] int GetResultObject_([In] Int32 lTimeout, [Out][MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(MarshalWbemObject))] out IWbemClassObjectFreeThreaded ppResultObject);
        [PreserveSig] int GetResultString_([In] Int32 lTimeout, [Out][MarshalAs(UnmanagedType.BStr)]  out string   pstrResultString);
        [PreserveSig] int GetResultServices_([In] Int32 lTimeout, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemServices   ppServices);
        [PreserveSig] int GetCallStatus_([In] Int32 lTimeout, [Out] out Int32 plStatus);
    }

    [TypeLibTypeAttribute(0x0200)]
    [GuidAttribute("7C857801-7381-11CF-884D-00AA004B2E24")]
    [InterfaceTypeAttribute(0x0001)]
    [System.Security.SuppressUnmanagedCodeSecurity]
    [ComImport]
    interface IWbemObjectSink
    {
//      [PreserveSig] int Indicate_([In] Int32 lObjectCount, [In][MarshalAs(UnmanagedType.Interface)]  ref IWbemClassObject   apObjArray);
//      [PreserveSig] int Indicate_([In] Int32 lObjectCount, [In][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] IWbemObjectAccess[] apObjArray);
        [SuppressUnmanagedCodeSecurity, PreserveSig] int Indicate_([In] Int32 lObjectCount, [In][MarshalAs(UnmanagedType.LPArray)] IntPtr[] apObjArray);
        [PreserveSig] int SetStatus_([In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Error)]  Int32   hResult, [In][MarshalAs(UnmanagedType.BStr)]  string   strParam, [In] IntPtr pObjParam);
    }

    [InterfaceTypeAttribute(0x0001)]
    [TypeLibTypeAttribute(0x0200)]
    [GuidAttribute("027947E1-D731-11CE-A357-000000000001")]
    [ComImport]
    interface IEnumWbemClassObject
    {
        [PreserveSig] int Reset_();
//      [PreserveSig] int Next_([In] Int32 lTimeout, [In] UInt32 uCount, [Out][MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef=typeof(MarshalWbemObject))] out IWbemClassObjectFreeThreaded apObjects, [Out] out UInt32 puReturned);
		[PreserveSig] int Next_([In] Int32 lTimeout, [In] UInt32 uCount, [In][Out][MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] IWbemClassObject_DoNotMarshal[] apObjects, [Out] out UInt32 puReturned);
		[PreserveSig] int NextAsync_([In] UInt32 uCount, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pSink);
        [PreserveSig] int Clone_([Out][MarshalAs(UnmanagedType.Interface)]  out IEnumWbemClassObject   ppEnum);
        [PreserveSig] int Skip_([In] Int32 lTimeout, [In] UInt32 nCount);
    }

    [InterfaceTypeAttribute(0x0001)]
    [GuidAttribute("B7B31DF9-D515-11D3-A11C-00105A1F515A")]
    [ComImport]
    interface IWbemShutdown
    {
        [PreserveSig] int Shutdown_([In] Int32 uReason, [In] UInt32 uMaxMilliseconds, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx);
    }

    [InterfaceTypeAttribute(0x0001)]
    [TypeLibTypeAttribute(0x0200)]
    [GuidAttribute("BFBF883A-CAD7-11D3-A11B-00105A1F515A")]
    [ComImport]
    interface IWbemObjectTextSrc
    {
        [PreserveSig] int GetText_([In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pObj, [In] UInt32 uObjTextFormat, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [Out][MarshalAs(UnmanagedType.BStr)]  out string   strText);
        [PreserveSig] int CreateFromText_([In] Int32 lFlags, [In][MarshalAs(UnmanagedType.BStr)]  string   strText, [In] UInt32 uObjTextFormat, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemClassObject_DoNotMarshal   pNewObj);
    }

    [GuidAttribute("49353C9A-516B-11D1-AEA6-00C04FB68820")]
    [TypeLibTypeAttribute(0x0200)]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemObjectAccess
    {
        [PreserveSig] int GetQualifierSet_([Out][MarshalAs(UnmanagedType.Interface)]  out IWbemQualifierSet_DoNotMarshal   ppQualSet);
        [PreserveSig] int Get_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [In][Out] ref object pVal, [In][Out] ref Int32 pType, [In][Out] ref Int32 plFlavor);
        [PreserveSig] int Put_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [In] ref object pVal, [In] Int32 Type);
        [PreserveSig] int Delete_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName);
        [PreserveSig] int GetNames_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszQualifierName, [In] Int32 lFlags, [In] ref object pQualifierVal, [Out][MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_BSTR)]  out string[]   pNames);
        [PreserveSig] int BeginEnumeration_([In] Int32 lEnumFlags);
        [PreserveSig] int Next_([In] Int32 lFlags, [In][Out][MarshalAs(UnmanagedType.BStr)]  ref string   strName, [In][Out] ref object pVal, [In][Out] ref Int32 pType, [In][Out] ref Int32 plFlavor);
        [PreserveSig] int EndEnumeration_();
        [PreserveSig] int GetPropertyQualifierSet_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszProperty, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemQualifierSet_DoNotMarshal   ppQualSet);
        [PreserveSig] int Clone_([Out][MarshalAs(UnmanagedType.Interface)]  out IWbemClassObject_DoNotMarshal   ppCopy);
        [PreserveSig] int GetObjectText_([In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.BStr)]  out string   pstrObjectText);
        [PreserveSig] int SpawnDerivedClass_([In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemClassObject_DoNotMarshal   ppNewClass);
        [PreserveSig] int SpawnInstance_([In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemClassObject_DoNotMarshal   ppNewInstance);
        [PreserveSig] int CompareTo_([In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pCompareTo);
        [PreserveSig] int GetPropertyOrigin_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [Out][MarshalAs(UnmanagedType.BStr)]  out string   pstrClassName);
        [PreserveSig] int InheritsFrom_([In][MarshalAs(UnmanagedType.LPWStr)]  string   strAncestor);
        [PreserveSig] int GetMethod_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemClassObject_DoNotMarshal   ppInSignature, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemClassObject_DoNotMarshal   ppOutSignature);
        [PreserveSig] int PutMethod_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pInSignature, [In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pOutSignature);
        [PreserveSig] int DeleteMethod_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName);
        [PreserveSig] int BeginMethodEnumeration_([In] Int32 lEnumFlags);
        [PreserveSig] int NextMethod_([In] Int32 lFlags, [In][Out][MarshalAs(UnmanagedType.BStr)]  ref string   pstrName, [In][Out][MarshalAs(UnmanagedType.Interface)]  ref IWbemClassObject_DoNotMarshal   ppInSignature, [In][Out][MarshalAs(UnmanagedType.Interface)]  ref IWbemClassObject_DoNotMarshal   ppOutSignature);
        [PreserveSig] int EndMethodEnumeration_();
        [PreserveSig] int GetMethodQualifierSet_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszMethod, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemQualifierSet_DoNotMarshal   ppQualSet);
        [PreserveSig] int GetMethodOrigin_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszMethodName, [Out][MarshalAs(UnmanagedType.BStr)]  out string   pstrClassName);
        [PreserveSig] int GetPropertyHandle_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszPropertyName, [Out] out Int32 pType, [Out] out Int32 plHandle);
        [PreserveSig] int WritePropertyValue_([In] Int32 lHandle, [In] Int32 lNumBytes, [In] ref Byte aData);
        [PreserveSig] int ReadPropertyValue_([In] Int32 lHandle, [In] Int32 lBufferSize, [Out] out Int32 plNumBytes, [Out] out Byte aData);
        [PreserveSig] int ReadDWORD_([In] Int32 lHandle, [Out] out UInt32 pdw);
        [PreserveSig] int WriteDWORD_([In] Int32 lHandle, [In] UInt32 dw);
        [PreserveSig] int ReadQWORD_([In] Int32 lHandle, [Out] out UInt64 pqw);
        [PreserveSig] int WriteQWORD_([In] Int32 lHandle, [In] UInt64 pw);
        [PreserveSig] int GetPropertyInfoByHandle_([In] Int32 lHandle, [Out][MarshalAs(UnmanagedType.BStr)]  out string   pstrName, [Out] out Int32 pType);
        [PreserveSig] int Lock_([In] Int32 lFlags);
        [PreserveSig] int Unlock_([In] Int32 lFlags);
    }

    [InterfaceTypeAttribute(0x0001)]
    [GuidAttribute("6DAF974E-2E37-11D2-AEC9-00C04FB68820")]
    [ComImport]
    interface IMofCompiler
    {
        [PreserveSig] int CompileFile_([In][MarshalAs(UnmanagedType.LPWStr)]  string   FileName, [In][MarshalAs(UnmanagedType.LPWStr)]  string   ServerAndNamespace, [In][MarshalAs(UnmanagedType.LPWStr)]  string   User, [In][MarshalAs(UnmanagedType.LPWStr)]  string   Authority, [In][MarshalAs(UnmanagedType.LPWStr)]  string   Password, [In] Int32 lOptionFlags, [In] Int32 lClassFlags, [In] Int32 lInstanceFlags, [In][Out] ref tag_CompileStatusInfo pInfo);
        [PreserveSig] int CompileBuffer_([In] Int32 BuffSize, [In] ref Byte pBuffer, [In][MarshalAs(UnmanagedType.LPWStr)]  string   ServerAndNamespace, [In][MarshalAs(UnmanagedType.LPWStr)]  string   User, [In][MarshalAs(UnmanagedType.LPWStr)]  string   Authority, [In][MarshalAs(UnmanagedType.LPWStr)]  string   Password, [In] Int32 lOptionFlags, [In] Int32 lClassFlags, [In] Int32 lInstanceFlags, [In][Out] ref tag_CompileStatusInfo pInfo);
        [PreserveSig] int CreateBMOF_([In][MarshalAs(UnmanagedType.LPWStr)]  string   TextFileName, [In][MarshalAs(UnmanagedType.LPWStr)]  string   BMOFFileName, [In][MarshalAs(UnmanagedType.LPWStr)]  string   ServerAndNamespace, [In] Int32 lOptionFlags, [In] Int32 lClassFlags, [In] Int32 lInstanceFlags, [In][Out] ref tag_CompileStatusInfo pInfo);
    }

    [GuidAttribute("1CFABA8C-1523-11D1-AD79-00C04FD8FDFF")]
    [TypeLibTypeAttribute(0x0200)]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IUnsecuredApartment
    {
        [PreserveSig] int CreateObjectStub_([In][MarshalAs(UnmanagedType.IUnknown)]  object   pObject, [Out][MarshalAs(UnmanagedType.IUnknown)]  out object   ppStub);
    }

    [GuidAttribute("EB87E1BC-3233-11D2-AEC9-00C04FB68820")]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemStatusCodeText
    {
        [PreserveSig] int GetErrorCodeText_([In][MarshalAs(UnmanagedType.Error)]  Int32   hRes, [In] UInt32 LocaleId, [In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.BStr)]  out string   MessageText);
        [PreserveSig] int GetFacilityCodeText_([In][MarshalAs(UnmanagedType.Error)]  Int32   hRes, [In] UInt32 LocaleId, [In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.BStr)]  out string   MessageText);
    }

    [GuidAttribute("C49E32C7-BC8B-11D2-85D4-00105A1F8304")]
    [TypeLibTypeAttribute(0x0200)]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemBackupRestore
    {
        [PreserveSig] int Backup_([In][MarshalAs(UnmanagedType.LPWStr)]  string   strBackupToFile, [In] Int32 lFlags);
        [PreserveSig] int Restore_([In][MarshalAs(UnmanagedType.LPWStr)]  string   strRestoreFromFile, [In] Int32 lFlags);
    }

    [TypeLibTypeAttribute(0x0200)]
    [GuidAttribute("A359DEC5-E813-4834-8A2A-BA7F1D777D76")]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemBackupRestoreEx
    {
        [PreserveSig] int Backup_([In][MarshalAs(UnmanagedType.LPWStr)]  string   strBackupToFile, [In] Int32 lFlags);
        [PreserveSig] int Restore_([In][MarshalAs(UnmanagedType.LPWStr)]  string   strRestoreFromFile, [In] Int32 lFlags);
        [PreserveSig] int Pause_();
        [PreserveSig] int Resume_();
    }

    [InterfaceTypeAttribute(0x0001)]
    [TypeLibTypeAttribute(0x0200)]
    [GuidAttribute("49353C99-516B-11D1-AEA6-00C04FB68820")]
    [ComImport]
    interface IWbemRefresher
    {
        [PreserveSig] int Refresh_([In] Int32 lFlags);
    }

    [GuidAttribute("2705C288-79AE-11D2-B348-00105A1F8177")]
    [TypeLibTypeAttribute(0x0200)]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemHiPerfEnum
    {
        [PreserveSig] int AddObjects_([In] Int32 lFlags, [In] UInt32 uNumObjects, [In] ref Int32 apIds, [In][MarshalAs(UnmanagedType.Interface)]  ref IWbemObjectAccess   apObj);
        [PreserveSig] int RemoveObjects_([In] Int32 lFlags, [In] UInt32 uNumObjects, [In] ref Int32 apIds);
        [PreserveSig] int GetObjects_([In] Int32 lFlags, [In] UInt32 uNumObjects, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemObjectAccess   apObj, [Out] out UInt32 puReturned);
        [PreserveSig] int RemoveAll_([In] Int32 lFlags);
    }

    [GuidAttribute("49353C92-516B-11D1-AEA6-00C04FB68820")]
    [TypeLibTypeAttribute(0x0200)]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemConfigureRefresher
    {
        [PreserveSig] int AddObjectByPath_([In][MarshalAs(UnmanagedType.Interface)]  IWbemServices   pNamespace, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszPath, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pContext, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemClassObject_DoNotMarshal   ppRefreshable, [In][Out] ref Int32 plId);
        [PreserveSig] int AddObjectByTemplate_([In][MarshalAs(UnmanagedType.Interface)]  IWbemServices   pNamespace, [In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pTemplate, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pContext, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemClassObject_DoNotMarshal   ppRefreshable, [In][Out] ref Int32 plId);
        [PreserveSig] int AddRefresher_([In][MarshalAs(UnmanagedType.Interface)]  IWbemRefresher   pRefresher, [In] Int32 lFlags, [In][Out] ref Int32 plId);
        [PreserveSig] int Remove_([In] Int32 lId, [In] Int32 lFlags);
        [PreserveSig] int AddEnum_([In][MarshalAs(UnmanagedType.Interface)]  IWbemServices   pNamespace, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszClassName, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pContext, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemHiPerfEnum   ppEnum, [In][Out] ref Int32 plId);
    }

    [InterfaceTypeAttribute(0x0001)]
    [TypeLibTypeAttribute(0x0200)]
    [GuidAttribute("E246107B-B06E-11D0-AD61-00C04FD8FDFF")]
    [ComImport]
    interface IWbemUnboundObjectSink
    {
        [PreserveSig] int IndicateToConsumer_([In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pLogicalConsumer, [In] Int32 lNumObjects, [In][MarshalAs(UnmanagedType.Interface)]  ref IWbemClassObject_DoNotMarshal   apObjects);
    }

    [InterfaceTypeAttribute(0x0001)]
    [GuidAttribute("CE61E841-65BC-11D0-B6BD-00AA003240C7")]
    [TypeLibTypeAttribute(0x0200)]
    [ComImport]
    interface IWbemPropertyProvider
    {
        [PreserveSig] int GetProperty_([In] Int32 lFlags, [In][MarshalAs(UnmanagedType.BStr)]  string   strLocale, [In][MarshalAs(UnmanagedType.BStr)]  string   strClassMapping, [In][MarshalAs(UnmanagedType.BStr)]  string   strInstMapping, [In][MarshalAs(UnmanagedType.BStr)]  string   strPropMapping, [Out] out object pvValue);
        [PreserveSig] int PutProperty_([In] Int32 lFlags, [In][MarshalAs(UnmanagedType.BStr)]  string   strLocale, [In][MarshalAs(UnmanagedType.BStr)]  string   strClassMapping, [In][MarshalAs(UnmanagedType.BStr)]  string   strInstMapping, [In][MarshalAs(UnmanagedType.BStr)]  string   strPropMapping, [In] ref object pvValue);
    }

    [InterfaceTypeAttribute(0x0001)]
    [TypeLibTypeAttribute(0x0200)]
    [GuidAttribute("E245105B-B06E-11D0-AD61-00C04FD8FDFF")]
    [ComImport]
    interface IWbemEventProvider
    {
        [PreserveSig] int ProvideEvents_([In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pSink, [In] Int32 lFlags);
    }

    [GuidAttribute("580ACAF8-FA1C-11D0-AD72-00C04FD8FDFF")]
    [TypeLibTypeAttribute(0x0200)]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemEventProviderQuerySink
    {
        [PreserveSig] int NewQuery_([In] UInt32 dwId, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszQueryLanguage, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszQuery);
        [PreserveSig] int CancelQuery_([In] UInt32 dwId);
    }

    [InterfaceTypeAttribute(0x0001)]
    [TypeLibTypeAttribute(0x0200)]
    [GuidAttribute("631F7D96-D993-11D2-B339-00105A1F4AAF")]
    [ComImport]
    interface IWbemEventProviderSecurity
    {
        [PreserveSig] int AccessCheck_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszQueryLanguage, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszQuery, [In] Int32 lSidLength, [In] ref Byte pSid);
    }

    [GuidAttribute("631F7D97-D993-11D2-B339-00105A1F4AAF")]
    [TypeLibTypeAttribute(0x0200)]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemProviderIdentity
    {
        [PreserveSig] int SetRegistrationObject_([In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pProvReg);
    }

    [InterfaceTypeAttribute(0x0001)]
    [TypeLibTypeAttribute(0x0200)]
    [GuidAttribute("E246107A-B06E-11D0-AD61-00C04FD8FDFF")]
    [ComImport]
    interface IWbemEventConsumerProvider
    {
        [PreserveSig] int FindConsumer_([In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pLogicalConsumer, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemUnboundObjectSink   ppConsumer);
    }

//    This interface removed from public IDL in WMI...
//    [InterfaceTypeAttribute(0x0001)]
//    [GuidAttribute("17CF534A-D8A3-4AD0-AC92-5E3D01717151")]
//    [TypeLibTypeAttribute(0x0200)]
//    [ComImport]
//    interface IWbemEventConsumerProviderEx
//    {
//        [PreserveSig] int FindConsumer_([In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pLogicalConsumer, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemUnboundObjectSink   ppConsumer);
//        [PreserveSig] int ValidateSubscription_([In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pLogicalConsumer);
//    }

    [GuidAttribute("1BE41571-91DD-11D1-AEB2-00C04FB68820")]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemProviderInitSink
    {
        [PreserveSig] int SetStatus_([In] Int32 lStatus, [In] Int32 lFlags);
    }

    [GuidAttribute("1BE41572-91DD-11D1-AEB2-00C04FB68820")]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemProviderInit
    {
        [PreserveSig] int Initialize_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszUser, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszNamespace, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszLocale, [In][MarshalAs(UnmanagedType.Interface)]  IWbemServices   pNamespace, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemProviderInitSink   pInitSink);
    }

    [TypeLibTypeAttribute(0x0200)]
    [GuidAttribute("49353C93-516B-11D1-AEA6-00C04FB68820")]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemHiPerfProvider
    {
        [PreserveSig] int QueryInstances_([In][MarshalAs(UnmanagedType.Interface)]  IWbemServices   pNamespace, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszClass, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pCtx, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectSink   pSink);
        [PreserveSig] int CreateRefresher_([In][MarshalAs(UnmanagedType.Interface)]  IWbemServices   pNamespace, [In] Int32 lFlags, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemRefresher   ppRefresher);
        [PreserveSig] int CreateRefreshableObject_([In][MarshalAs(UnmanagedType.Interface)]  IWbemServices   pNamespace, [In][MarshalAs(UnmanagedType.Interface)]  IWbemObjectAccess   pTemplate, [In][MarshalAs(UnmanagedType.Interface)]  IWbemRefresher   pRefresher, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pContext, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemObjectAccess   ppRefreshable, [Out] out Int32 plId);
        [PreserveSig] int StopRefreshing_([In][MarshalAs(UnmanagedType.Interface)]  IWbemRefresher   pRefresher, [In] Int32 lId, [In] Int32 lFlags);
        [PreserveSig] int CreateRefreshableEnum_([In][MarshalAs(UnmanagedType.Interface)]  IWbemServices   pNamespace, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszClass, [In][MarshalAs(UnmanagedType.Interface)]  IWbemRefresher   pRefresher, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pContext, [In][MarshalAs(UnmanagedType.Interface)]  IWbemHiPerfEnum   pHiPerfEnum, [Out] out Int32 plId);
        [PreserveSig] int GetObjects_([In][MarshalAs(UnmanagedType.Interface)]  IWbemServices   pNamespace, [In] Int32 lNumObjects, [In][Out][MarshalAs(UnmanagedType.Interface)]  ref IWbemObjectAccess   apObj, [In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   pContext);
    }

    [InterfaceTypeAttribute(0x0001)]
    [GuidAttribute("1005CBCF-E64F-4646-BCD3-3A089D8A84B4")]
    [ComImport]
    interface IWbemDecoupledRegistrar
    {
		[PreserveSig] int Register_([In] Int32 flags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   context, [In][MarshalAs(UnmanagedType.LPWStr)]  string   user, [In][MarshalAs(UnmanagedType.LPWStr)]  string   locale, [In][MarshalAs(UnmanagedType.LPWStr)]  string   scope, [In][MarshalAs(UnmanagedType.LPWStr)]  string   registration, [In][MarshalAs(UnmanagedType.IUnknown)]  object   unknown);
        [PreserveSig] int UnRegister_();
    }

    [GuidAttribute("86336D20-CA11-4786-9EF1-BC8A946B42FC")]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemDecoupledBasicEventProvider
    {
		[PreserveSig] int Register_([In] Int32 flags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   context, [In][MarshalAs(UnmanagedType.LPWStr)]  string   user, [In][MarshalAs(UnmanagedType.LPWStr)]  string   locale, [In][MarshalAs(UnmanagedType.LPWStr)]  string   scope, [In][MarshalAs(UnmanagedType.LPWStr)]  string   registration, [In][MarshalAs(UnmanagedType.IUnknown)]  object   unknown);
        [PreserveSig] int UnRegister_();
		[PreserveSig] int GetSink_([In] Int32 flags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   context, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemObjectSink   sink);
		[PreserveSig] int GetService_([In] Int32 flags, [In][MarshalAs(UnmanagedType.Interface)]  IWbemContext   context, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemServices   service);
    }

    [InterfaceTypeAttribute(0x0001)]
    [TypeLibTypeAttribute(0x0200)]
    [GuidAttribute("3AE0080A-7E3A-4366-BF89-0FEEDC931659")]
    [ComImport]
    interface IWbemEventSink
    {
        [PreserveSig] int Indicate_([In] Int32 lObjectCount, [In][MarshalAs(UnmanagedType.Interface)]  ref IWbemClassObject_DoNotMarshal   apObjArray);
        [PreserveSig] int SetStatus_([In] Int32 lFlags, [In][MarshalAs(UnmanagedType.Error)]  Int32   hResult, [In][MarshalAs(UnmanagedType.BStr)]  string   strParam, [In][MarshalAs(UnmanagedType.Interface)]  IWbemClassObject_DoNotMarshal   pObjParam);
        [PreserveSig] int IndicateWithSD_([In] Int32 lNumObjects, [In][MarshalAs(UnmanagedType.IUnknown)]  ref object   apObjects, [In] Int32 lSDLength, [In] ref Byte pSD);
        [PreserveSig] int SetSinkSecurity_([In] Int32 lSDLength, [In] ref Byte pSD);
        [PreserveSig] int IsActive_();
        [PreserveSig] int GetRestrictedSink_([In] Int32 lNumQueries, [In][MarshalAs(UnmanagedType.LPWStr)]  ref string   awszQueries, [In][MarshalAs(UnmanagedType.IUnknown)]  object   pCallback, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemEventSink   ppSink);
        [PreserveSig] int SetBatchingParameters_([In] Int32 lFlags, [In] UInt32 dwMaxBufferSize, [In] UInt32 dwMaxSendLatency);
    }

    [GuidAttribute("9AE62877-7544-4BB0-AA26-A13824659ED6")]
    /*[ComConversionLossAttribute]*/
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemPathKeyList
    {
        [PreserveSig] int GetCount_([Out] out UInt32 puKeyCount);
        [PreserveSig] int SetKey_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] UInt32 uFlags, [In] UInt32 uCimType, [In] IntPtr pKeyVal);
        [PreserveSig] int SetKey2_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] UInt32 uFlags, [In] UInt32 uCimType, [In] ref object pKeyVal);
        [PreserveSig] int GetKey_([In] UInt32 uKeyIx, [In] UInt32 uFlags, [In][Out] ref UInt32 puNameBufSize, [In][Out][MarshalAs(UnmanagedType.LPWStr)]  string   pszKeyName, [In][Out] ref UInt32 puKeyValBufSize, [In][Out] IntPtr pKeyVal, [Out] out UInt32 puApparentCimType);
        [PreserveSig] int GetKey2_([In] UInt32 uKeyIx, [In] UInt32 uFlags, [In][Out] ref UInt32 puNameBufSize, [In][Out][MarshalAs(UnmanagedType.LPWStr)]  string   pszKeyName, [In][Out] ref object pKeyValue, [Out] out UInt32 puApparentCimType);
        [PreserveSig] int RemoveKey_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] UInt32 uFlags);
        [PreserveSig] int RemoveAllKeys_([In] UInt32 uFlags);
        [PreserveSig] int MakeSingleton_([In] SByte bSet);
        [PreserveSig] int GetInfo_([In] UInt32 uRequestedInfo, [Out] out UInt64 puResponse);
        [PreserveSig] int GetText_([In] Int32 lFlags, [In][Out] ref UInt32 puBuffLength, [In][Out][MarshalAs(UnmanagedType.LPWStr)]  string   pszText);
    }

    [GuidAttribute("3BC15AF2-736C-477E-9E51-238AF8667DCC")]
    [InterfaceTypeAttribute(0x0001)]
    [ComImport]
    interface IWbemPath
    {
        [PreserveSig] int SetText_([In] UInt32 uMode, [In][MarshalAs(UnmanagedType.LPWStr)]  string   pszPath);
        [PreserveSig] int GetText_([In] Int32 lFlags, [In][Out] ref UInt32 puBuffLength, [In][Out][MarshalAs(UnmanagedType.LPWStr)]  string   pszText);
        [PreserveSig] int GetInfo_([In] UInt32 uRequestedInfo, [Out] out UInt64 puResponse);
        [PreserveSig] int SetServer_([In][MarshalAs(UnmanagedType.LPWStr)]  string   Name);
        [PreserveSig] int GetServer_([In][Out] ref UInt32 puNameBufLength, [In][Out][MarshalAs(UnmanagedType.LPWStr)]  string   pName);
        [PreserveSig] int GetNamespaceCount_([Out] out UInt32 puCount);
        [PreserveSig] int SetNamespaceAt_([In] UInt32 uIndex, [In][MarshalAs(UnmanagedType.LPWStr)]  string   pszName);
        [PreserveSig] int GetNamespaceAt_([In] UInt32 uIndex, [In][Out] ref UInt32 puNameBufLength, [In][Out][MarshalAs(UnmanagedType.LPWStr)]  string   pName);
        [PreserveSig] int RemoveNamespaceAt_([In] UInt32 uIndex);
        [PreserveSig] int RemoveAllNamespaces_();
        [PreserveSig] int GetScopeCount_([Out] out UInt32 puCount);
        [PreserveSig] int SetScope_([In] UInt32 uIndex, [In][MarshalAs(UnmanagedType.LPWStr)]  string   pszClass);
        [PreserveSig] int SetScopeFromText_([In] UInt32 uIndex, [In][MarshalAs(UnmanagedType.LPWStr)]  string   pszText);
        [PreserveSig] int GetScope_([In] UInt32 uIndex, [In][Out] ref UInt32 puClassNameBufSize, [In][Out][MarshalAs(UnmanagedType.LPWStr)]  string   pszClass, [Out][MarshalAs(UnmanagedType.Interface)]  out IWbemPathKeyList   pKeyList);
        [PreserveSig] int GetScopeAsText_([In] UInt32 uIndex, [In][Out] ref UInt32 puTextBufSize, [In][Out][MarshalAs(UnmanagedType.LPWStr)]  string   pszText);
        [PreserveSig] int RemoveScope_([In] UInt32 uIndex);
        [PreserveSig] int RemoveAllScopes_();
        [PreserveSig] int SetClassName_([In][MarshalAs(UnmanagedType.LPWStr)]  string   Name);
        [PreserveSig] int GetClassName_([In][Out] ref UInt32 puBuffLength, [In][Out][MarshalAs(UnmanagedType.LPWStr)]  string   pszName);
        [PreserveSig] int GetKeyList_([Out][MarshalAs(UnmanagedType.Interface)]  out IWbemPathKeyList   pOut);
        [PreserveSig] int CreateClassPart_([In] Int32 lFlags, [In][MarshalAs(UnmanagedType.LPWStr)]  string   Name);
        [PreserveSig] int DeleteClassPart_([In] Int32 lFlags);
        [PreserveSig] int IsRelative_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszMachine, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszNamespace);
        [PreserveSig] int IsRelativeOrChild_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszMachine, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszNamespace, [In] Int32 lFlags);
        [PreserveSig] int IsLocal_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszMachine);
        [PreserveSig] int IsSameClassName_([In][MarshalAs(UnmanagedType.LPWStr)]  string   wszClass);
    }

    [GuidAttribute("81166F58-DD98-11D3-A120-00105A1F515A")]
    [InterfaceTypeAttribute(0x0001)]
    /*[ComConversionLossAttribute]*/
    [ComImport]
    interface IWbemQuery
    {
        [PreserveSig] int Empty_();
        [PreserveSig] int SetLanguageFeatures_([In] Int32 lFlags, [In] UInt32 uArraySize, [In] ref UInt32 puFeatures);
        [PreserveSig] int TestLanguageFeatures_([In][Out] ref UInt32 uArraySize, [Out] out UInt32 puFeatures);
        [PreserveSig] int Parse_([In][MarshalAs(UnmanagedType.LPWStr)]  string   pszLang, [In][MarshalAs(UnmanagedType.LPWStr)]  string   pszQuery, [In] UInt32 uFlags);
        [PreserveSig] int GetAnalysis_([In] UInt32 uAnalysisType, [In] UInt32 uFlags, [Out] IntPtr pAnalysis);
        [PreserveSig] int FreeMemory_([In] IntPtr pMem);
        [PreserveSig] int GetQueryInfo_([In] UInt32 uAnalysisType, [In] UInt32 uInfoId, [In] UInt32 uBufSize, [Out] IntPtr pDestBuf);
        [PreserveSig] int AttachClassDef_([In] ref System.Guid riid, [In] IntPtr pClassDef);
        [PreserveSig] int TestObject_([In] UInt32 uTestType, [In] UInt32 uFlags, [In] ref System.Guid riid, [In] IntPtr pObj);
        [PreserveSig] int StringTest_([In] UInt32 uTestType, [In][MarshalAs(UnmanagedType.LPWStr)]  string   pszTestStr, [In][MarshalAs(UnmanagedType.LPWStr)]  string   pszExpr);
    }
    #endregion

    #region Enums
    enum tag_WBEM_GENUS_TYPE
    {
        WBEM_GENUS_CLASS = unchecked((int)0x00000001),
        WBEM_GENUS_INSTANCE = unchecked((int)0x00000002),
    }

    enum tag_WBEM_CHANGE_FLAG_TYPE
    {
        WBEM_FLAG_CREATE_OR_UPDATE = unchecked((int)0x00000000),
        WBEM_FLAG_UPDATE_ONLY = unchecked((int)0x00000001),
        WBEM_FLAG_CREATE_ONLY = unchecked((int)0x00000002),
        WBEM_FLAG_UPDATE_COMPATIBLE = unchecked((int)0x00000000),
        WBEM_FLAG_UPDATE_SAFE_MODE = unchecked((int)0x00000020),
        WBEM_FLAG_UPDATE_FORCE_MODE = unchecked((int)0x00000040),
        WBEM_MASK_UPDATE_MODE = unchecked((int)0x00000060),
        WBEM_FLAG_ADVISORY = unchecked((int)0x00010000),
    }

    enum tag_WBEM_GENERIC_FLAG_TYPE
    {
        WBEM_FLAG_RETURN_IMMEDIATELY = unchecked((int)0x00000010),
        WBEM_FLAG_RETURN_WBEM_COMPLETE = unchecked((int)0x00000000),
        WBEM_FLAG_BIDIRECTIONAL = unchecked((int)0x00000000),
        WBEM_FLAG_FORWARD_ONLY = unchecked((int)0x00000020),
        WBEM_FLAG_NO_ERROR_OBJECT = unchecked((int)0x00000040),
        WBEM_FLAG_RETURN_ERROR_OBJECT = unchecked((int)0x00000000),
        WBEM_FLAG_SEND_STATUS = unchecked((int)0x00000080),
        WBEM_FLAG_DONT_SEND_STATUS = unchecked((int)0x00000000),
        WBEM_FLAG_ENSURE_LOCATABLE = unchecked((int)0x00000100),
        WBEM_FLAG_DIRECT_READ = unchecked((int)0x00000200),
        WBEM_FLAG_SEND_ONLY_SELECTED = unchecked((int)0x00000000),
        WBEM_RETURN_WHEN_COMPLETE = unchecked((int)0x00000000),
        WBEM_RETURN_IMMEDIATELY = unchecked((int)0x00000010),
        WBEM_MASK_RESERVED_FLAGS = unchecked((int)0x0001F000),
        WBEM_FLAG_USE_AMENDED_QUALIFIERS = unchecked((int)0x00020000),
        WBEM_FLAG_STRONG_VALIDATION = unchecked((int)0x00100000),
    }

    enum tag_WBEM_STATUS_TYPE
    {
        WBEM_STATUS_COMPLETE = unchecked((int)0x00000000),
        WBEM_STATUS_REQUIREMENTS = unchecked((int)0x00000001),
        WBEM_STATUS_PROGRESS = unchecked((int)0x00000002),
    }

    enum tag_WBEM_TIMEOUT_TYPE
    {
        WBEM_NO_WAIT = unchecked((int)0x00000000),
        WBEM_INFINITE = unchecked((int)0xFFFFFFFF),
    }

    enum tag_WBEM_CONDITION_FLAG_TYPE
    {
        WBEM_FLAG_ALWAYS = unchecked((int)0x00000000),
        WBEM_FLAG_ONLY_IF_TRUE = unchecked((int)0x00000001),
        WBEM_FLAG_ONLY_IF_FALSE = unchecked((int)0x00000002),
        WBEM_FLAG_ONLY_IF_IDENTICAL = unchecked((int)0x00000003),
        WBEM_MASK_PRIMARY_CONDITION = unchecked((int)0x00000003),
        WBEM_FLAG_KEYS_ONLY = unchecked((int)0x00000004),
        WBEM_FLAG_REFS_ONLY = unchecked((int)0x00000008),
        WBEM_FLAG_LOCAL_ONLY = unchecked((int)0x00000010),
        WBEM_FLAG_PROPAGATED_ONLY = unchecked((int)0x00000020),
        WBEM_FLAG_SYSTEM_ONLY = unchecked((int)0x00000030),
        WBEM_FLAG_NONSYSTEM_ONLY = unchecked((int)0x00000040),
        WBEM_MASK_CONDITION_ORIGIN = unchecked((int)0x00000070),
        WBEM_FLAG_CLASS_OVERRIDES_ONLY = unchecked((int)0x00000100),
        WBEM_FLAG_CLASS_LOCAL_AND_OVERRIDES = unchecked((int)0x00000200),
        WBEM_MASK_CLASS_CONDITION = unchecked((int)0x00000300),
    }
    enum tag_WBEM_FLAVOR_TYPE
    {
        WBEM_FLAVOR_DONT_PROPAGATE = unchecked((int)0x00000000),
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE = unchecked((int)0x00000001),
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS = unchecked((int)0x00000002),
        WBEM_FLAVOR_MASK_PROPAGATION = unchecked((int)0x0000000F),
        WBEM_FLAVOR_OVERRIDABLE = unchecked((int)0x00000000),
        WBEM_FLAVOR_NOT_OVERRIDABLE = unchecked((int)0x00000010),
        WBEM_FLAVOR_MASK_PERMISSIONS = unchecked((int)0x00000010),
        WBEM_FLAVOR_ORIGIN_LOCAL = unchecked((int)0x00000000),
        WBEM_FLAVOR_ORIGIN_PROPAGATED = unchecked((int)0x00000020),
        WBEM_FLAVOR_ORIGIN_SYSTEM = unchecked((int)0x00000040),
        WBEM_FLAVOR_MASK_ORIGIN = unchecked((int)0x00000060),
        WBEM_FLAVOR_NOT_AMENDED = unchecked((int)0x00000000),
        WBEM_FLAVOR_AMENDED = unchecked((int)0x00000080),
        WBEM_FLAVOR_MASK_AMENDED = unchecked((int)0x00000080),
    }

    enum tag_WBEM_QUERY_FLAG_TYPE
    {
        WBEM_FLAG_DEEP = unchecked((int)0x00000000),
        WBEM_FLAG_SHALLOW = unchecked((int)0x00000001),
        WBEM_FLAG_PROTOTYPE = unchecked((int)0x00000002),
    }

    enum tag_WBEM_SECURITY_FLAGS
    {
        WBEM_ENABLE = unchecked((int)0x00000001),
        WBEM_METHOD_EXECUTE = unchecked((int)0x00000002),
        WBEM_FULL_WRITE_REP = unchecked((int)0x00000004),
        WBEM_PARTIAL_WRITE_REP = unchecked((int)0x00000008),
        WBEM_WRITE_PROVIDER = unchecked((int)0x00000010),
        WBEM_REMOTE_ACCESS = unchecked((int)0x00000020),
        WBEM_RIGHT_SUBSCRIBE = unchecked((int)0x00000001),
        WBEM_RIGHT_PUBLISH = unchecked((int)0x00000001),
    }

    enum tag_WBEM_LIMITATION_FLAG_TYPE
    {
        WBEM_FLAG_EXCLUDE_OBJECT_QUALIFIERS = unchecked((int)0x00000010),
        WBEM_FLAG_EXCLUDE_PROPERTY_QUALIFIERS = unchecked((int)0x00000020),
    }

    enum tag_WBEM_TEXT_FLAG_TYPE
    {
        WBEM_FLAG_NO_FLAVORS = unchecked((int)0x00000001),
    }

    enum tag_WBEM_COMPARISON_FLAG
    {
        WBEM_COMPARISON_INCLUDE_ALL = unchecked((int)0x00000000),
        WBEM_FLAG_IGNORE_QUALIFIERS = unchecked((int)0x00000001),
        WBEM_FLAG_IGNORE_OBJECT_SOURCE = unchecked((int)0x00000002),
        WBEM_FLAG_IGNORE_DEFAULT_VALUES = unchecked((int)0x00000004),
        WBEM_FLAG_IGNORE_CLASS = unchecked((int)0x00000008),
        WBEM_FLAG_IGNORE_CASE = unchecked((int)0x00000010),
        WBEM_FLAG_IGNORE_FLAVOR = unchecked((int)0x00000020),
    }

    enum tag_WBEM_LOCKING
    {
        WBEM_FLAG_ALLOW_READ = unchecked((int)0x00000001),
    }

    enum tag_CIMTYPE_ENUMERATION
    {
        CIM_ILLEGAL = unchecked((int)0x00000FFF),
        CIM_EMPTY = unchecked((int)0x00000000),
        CIM_SINT8 = unchecked((int)0x00000010),
        CIM_UINT8 = unchecked((int)0x00000011),
        CIM_SINT16 = unchecked((int)0x00000002),
        CIM_UINT16 = unchecked((int)0x00000012),
        CIM_SINT32 = unchecked((int)0x00000003),
        CIM_UINT32 = unchecked((int)0x00000013),
        CIM_SINT64 = unchecked((int)0x00000014),
        CIM_UINT64 = unchecked((int)0x00000015),
        CIM_REAL32 = unchecked((int)0x00000004),
        CIM_REAL64 = unchecked((int)0x00000005),
        CIM_BOOLEAN = unchecked((int)0x0000000B),
        CIM_STRING = unchecked((int)0x00000008),
        CIM_DATETIME = unchecked((int)0x00000065),
        CIM_REFERENCE = unchecked((int)0x00000066),
        CIM_CHAR16 = unchecked((int)0x00000067),
        CIM_OBJECT = unchecked((int)0x0000000D),
        CIM_FLAG_ARRAY = unchecked((int)0x00002000),
    }

    enum tag_WBEM_BACKUP_RESTORE_FLAGS
    {
        WBEM_FLAG_BACKUP_RESTORE_DEFAULT = unchecked((int)0x00000000),
        WBEM_FLAG_BACKUP_RESTORE_FORCE_SHUTDOWN = unchecked((int)0x00000001),
    }

    enum tag_WBEM_REFRESHER_FLAGS
    {
        WBEM_FLAG_REFRESH_AUTO_RECONNECT = unchecked((int)0x00000000),
        WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT = unchecked((int)0x00000001),
    }

    enum tag_WBEM_SHUTDOWN_FLAGS
    {
        WBEM_SHUTDOWN_UNLOAD_COMPONENT = unchecked((int)0x00000001),
        WBEM_SHUTDOWN_WMI = unchecked((int)0x00000002),
        WBEM_SHUTDOWN_OS = unchecked((int)0x00000003),
    }

    enum tag_WBEMSTATUS_FORMAT
    {
        WBEMSTATUS_FORMAT_NEWLINE = unchecked((int)0x00000000),
        WBEMSTATUS_FORMAT_NO_NEWLINE = unchecked((int)0x00000001),
    }

    enum tag_WBEMSTATUS
    {
        WBEM_NO_ERROR = unchecked((int)0x00000000),
        WBEM_S_NO_ERROR = unchecked((int)0x00000000),
        WBEM_S_SAME = unchecked((int)0x00000000),
        WBEM_S_FALSE = unchecked((int)0x00000001),
        WBEM_S_ALREADY_EXISTS = unchecked((int)0x00040001),
        WBEM_S_RESET_TO_DEFAULT = unchecked((int)0x00040002),
        WBEM_S_DIFFERENT = unchecked((int)0x00040003),
        WBEM_S_TIMEDOUT = unchecked((int)0x00040004),
        WBEM_S_NO_MORE_DATA = unchecked((int)0x00040005),
        WBEM_S_OPERATION_CANCELLED = unchecked((int)0x00040006),
        WBEM_S_PENDING = unchecked((int)0x00040007),
        WBEM_S_DUPLICATE_OBJECTS = unchecked((int)0x00040008),
        WBEM_S_ACCESS_DENIED = unchecked((int)0x00040009),
        WBEM_S_PARTIAL_RESULTS = unchecked((int)0x00040010),
        WBEM_S_NO_POSTHOOK = unchecked((int)0x00040011),
        WBEM_S_POSTHOOK_WITH_BOTH = unchecked((int)0x00040012),
        WBEM_S_POSTHOOK_WITH_NEW = unchecked((int)0x00040013),
        WBEM_S_POSTHOOK_WITH_STATUS = unchecked((int)0x00040014),
        WBEM_S_POSTHOOK_WITH_OLD = unchecked((int)0x00040015),
        WBEM_S_REDO_PREHOOK_WITH_ORIGINAL_OBJECT = unchecked((int)0x00040016),
        WBEM_S_SOURCE_NOT_AVAILABLE = unchecked((int)0x00040017),
        WBEM_E_FAILED = unchecked((int)0x80041001),
        WBEM_E_NOT_FOUND = unchecked((int)0x80041002),
        WBEM_E_ACCESS_DENIED = unchecked((int)0x80041003),
        WBEM_E_PROVIDER_FAILURE = unchecked((int)0x80041004),
        WBEM_E_TYPE_MISMATCH = unchecked((int)0x80041005),
        WBEM_E_OUT_OF_MEMORY = unchecked((int)0x80041006),
        WBEM_E_INVALID_CONTEXT = unchecked((int)0x80041007),
        WBEM_E_INVALID_PARAMETER = unchecked((int)0x80041008),
        WBEM_E_NOT_AVAILABLE = unchecked((int)0x80041009),
        WBEM_E_CRITICAL_ERROR = unchecked((int)0x8004100A),
        WBEM_E_INVALID_STREAM = unchecked((int)0x8004100B),
        WBEM_E_NOT_SUPPORTED = unchecked((int)0x8004100C),
        WBEM_E_INVALID_SUPERCLASS = unchecked((int)0x8004100D),
        WBEM_E_INVALID_NAMESPACE = unchecked((int)0x8004100E),
        WBEM_E_INVALID_OBJECT = unchecked((int)0x8004100F),
        WBEM_E_INVALID_CLASS = unchecked((int)0x80041010),
        WBEM_E_PROVIDER_NOT_FOUND = unchecked((int)0x80041011),
        WBEM_E_INVALID_PROVIDER_REGISTRATION = unchecked((int)0x80041012),
        WBEM_E_PROVIDER_LOAD_FAILURE = unchecked((int)0x80041013),
        WBEM_E_INITIALIZATION_FAILURE = unchecked((int)0x80041014),
        WBEM_E_TRANSPORT_FAILURE = unchecked((int)0x80041015),
        WBEM_E_INVALID_OPERATION = unchecked((int)0x80041016),
        WBEM_E_INVALID_QUERY = unchecked((int)0x80041017),
        WBEM_E_INVALID_QUERY_TYPE = unchecked((int)0x80041018),
        WBEM_E_ALREADY_EXISTS = unchecked((int)0x80041019),
        WBEM_E_OVERRIDE_NOT_ALLOWED = unchecked((int)0x8004101A),
        WBEM_E_PROPAGATED_QUALIFIER = unchecked((int)0x8004101B),
        WBEM_E_PROPAGATED_PROPERTY = unchecked((int)0x8004101C),
        WBEM_E_UNEXPECTED = unchecked((int)0x8004101D),
        WBEM_E_ILLEGAL_OPERATION = unchecked((int)0x8004101E),
        WBEM_E_CANNOT_BE_KEY = unchecked((int)0x8004101F),
        WBEM_E_INCOMPLETE_CLASS = unchecked((int)0x80041020),
        WBEM_E_INVALID_SYNTAX = unchecked((int)0x80041021),
        WBEM_E_NONDECORATED_OBJECT = unchecked((int)0x80041022),
        WBEM_E_READ_ONLY = unchecked((int)0x80041023),
        WBEM_E_PROVIDER_NOT_CAPABLE = unchecked((int)0x80041024),
        WBEM_E_CLASS_HAS_CHILDREN = unchecked((int)0x80041025),
        WBEM_E_CLASS_HAS_INSTANCES = unchecked((int)0x80041026),
        WBEM_E_QUERY_NOT_IMPLEMENTED = unchecked((int)0x80041027),
        WBEM_E_ILLEGAL_NULL = unchecked((int)0x80041028),
        WBEM_E_INVALID_QUALIFIER_TYPE = unchecked((int)0x80041029),
        WBEM_E_INVALID_PROPERTY_TYPE = unchecked((int)0x8004102A),
        WBEM_E_VALUE_OUT_OF_RANGE = unchecked((int)0x8004102B),
        WBEM_E_CANNOT_BE_SINGLETON = unchecked((int)0x8004102C),
        WBEM_E_INVALID_CIM_TYPE = unchecked((int)0x8004102D),
        WBEM_E_INVALID_METHOD = unchecked((int)0x8004102E),
        WBEM_E_INVALID_METHOD_PARAMETERS = unchecked((int)0x8004102F),
        WBEM_E_SYSTEM_PROPERTY = unchecked((int)0x80041030),
        WBEM_E_INVALID_PROPERTY = unchecked((int)0x80041031),
        WBEM_E_CALL_CANCELLED = unchecked((int)0x80041032),
        WBEM_E_SHUTTING_DOWN = unchecked((int)0x80041033),
        WBEM_E_PROPAGATED_METHOD = unchecked((int)0x80041034),
        WBEM_E_UNSUPPORTED_PARAMETER = unchecked((int)0x80041035),
        WBEM_E_MISSING_PARAMETER_ID = unchecked((int)0x80041036),
        WBEM_E_INVALID_PARAMETER_ID = unchecked((int)0x80041037),
        WBEM_E_NONCONSECUTIVE_PARAMETER_IDS = unchecked((int)0x80041038),
        WBEM_E_PARAMETER_ID_ON_RETVAL = unchecked((int)0x80041039),
        WBEM_E_INVALID_OBJECT_PATH = unchecked((int)0x8004103A),
        WBEM_E_OUT_OF_DISK_SPACE = unchecked((int)0x8004103B),
        WBEM_E_BUFFER_TOO_SMALL = unchecked((int)0x8004103C),
        WBEM_E_UNSUPPORTED_PUT_EXTENSION = unchecked((int)0x8004103D),
        WBEM_E_UNKNOWN_OBJECT_TYPE = unchecked((int)0x8004103E),
        WBEM_E_UNKNOWN_PACKET_TYPE = unchecked((int)0x8004103F),
        WBEM_E_MARSHAL_VERSION_MISMATCH = unchecked((int)0x80041040),
        WBEM_E_MARSHAL_INVALID_SIGNATURE = unchecked((int)0x80041041),
        WBEM_E_INVALID_QUALIFIER = unchecked((int)0x80041042),
        WBEM_E_INVALID_DUPLICATE_PARAMETER = unchecked((int)0x80041043),
        WBEM_E_TOO_MUCH_DATA = unchecked((int)0x80041044),
        WBEM_E_SERVER_TOO_BUSY = unchecked((int)0x80041045),
        WBEM_E_INVALID_FLAVOR = unchecked((int)0x80041046),
        WBEM_E_CIRCULAR_REFERENCE = unchecked((int)0x80041047),
        WBEM_E_UNSUPPORTED_CLASS_UPDATE = unchecked((int)0x80041048),
        WBEM_E_CANNOT_CHANGE_KEY_INHERITANCE = unchecked((int)0x80041049),
        WBEM_E_CANNOT_CHANGE_INDEX_INHERITANCE = unchecked((int)0x80041050),
        WBEM_E_TOO_MANY_PROPERTIES = unchecked((int)0x80041051),
        WBEM_E_UPDATE_TYPE_MISMATCH = unchecked((int)0x80041052),
        WBEM_E_UPDATE_OVERRIDE_NOT_ALLOWED = unchecked((int)0x80041053),
        WBEM_E_UPDATE_PROPAGATED_METHOD = unchecked((int)0x80041054),
        WBEM_E_METHOD_NOT_IMPLEMENTED = unchecked((int)0x80041055),
        WBEM_E_METHOD_DISABLED = unchecked((int)0x80041056),
        WBEM_E_REFRESHER_BUSY = unchecked((int)0x80041057),
        WBEM_E_UNPARSABLE_QUERY = unchecked((int)0x80041058),
        WBEM_E_NOT_EVENT_CLASS = unchecked((int)0x80041059),
        WBEM_E_MISSING_GROUP_WITHIN = unchecked((int)0x8004105A),
        WBEM_E_MISSING_AGGREGATION_LIST = unchecked((int)0x8004105B),
        WBEM_E_PROPERTY_NOT_AN_OBJECT = unchecked((int)0x8004105C),
        WBEM_E_AGGREGATING_BY_OBJECT = unchecked((int)0x8004105D),
        WBEM_E_UNINTERPRETABLE_PROVIDER_QUERY = unchecked((int)0x8004105F),
        WBEM_E_BACKUP_RESTORE_WINMGMT_RUNNING = unchecked((int)0x80041060),
        WBEM_E_QUEUE_OVERFLOW = unchecked((int)0x80041061),
        WBEM_E_PRIVILEGE_NOT_HELD = unchecked((int)0x80041062),
        WBEM_E_INVALID_OPERATOR = unchecked((int)0x80041063),
        WBEM_E_LOCAL_CREDENTIALS = unchecked((int)0x80041064),
        WBEM_E_CANNOT_BE_ABSTRACT = unchecked((int)0x80041065),
        WBEM_E_AMENDED_OBJECT = unchecked((int)0x80041066),
        WBEM_E_CLIENT_TOO_SLOW = unchecked((int)0x80041067),
        WBEM_E_NULL_SECURITY_DESCRIPTOR = unchecked((int)0x80041068),
        WBEM_E_TIMED_OUT = unchecked((int)0x80041069),
        WBEM_E_INVALID_ASSOCIATION = unchecked((int)0x8004106A),
        WBEM_E_AMBIGUOUS_OPERATION = unchecked((int)0x8004106B),
        WBEM_E_QUOTA_VIOLATION = unchecked((int)0x8004106C),
        WBEM_E_RESERVED_001 = unchecked((int)0x8004106D),
        WBEM_E_RESERVED_002 = unchecked((int)0x8004106E),
        WBEM_E_UNSUPPORTED_LOCALE = unchecked((int)0x8004106F),
        WBEM_E_HANDLE_OUT_OF_DATE = unchecked((int)0x80041070),
        WBEM_E_CONNECTION_FAILED = unchecked((int)0x80041071),
        WBEM_E_INVALID_HANDLE_REQUEST = unchecked((int)0x80041072),
        WBEM_E_PROPERTY_NAME_TOO_WIDE = unchecked((int)0x80041073),
        WBEM_E_CLASS_NAME_TOO_WIDE = unchecked((int)0x80041074),
        WBEM_E_METHOD_NAME_TOO_WIDE = unchecked((int)0x80041075),
        WBEM_E_QUALIFIER_NAME_TOO_WIDE = unchecked((int)0x80041076),
        WBEM_E_RERUN_COMMAND = unchecked((int)0x80041077),
        WBEM_E_DATABASE_VER_MISMATCH = unchecked((int)0x80041078),
        WBEM_E_VETO_DELETE = unchecked((int)0x80041079),
        WBEM_E_VETO_PUT = unchecked((int)0x8004107A),
        WBEM_E_INVALID_LOCALE = unchecked((int)0x80041080),
        WBEM_E_PROVIDER_SUSPENDED = unchecked((int)0x80041081),
        WBEM_E_SYNCHRONIZATION_REQUIRED = unchecked((int)0x80041082),
        WBEM_E_NO_SCHEMA = unchecked((int)0x80041083),
        WBEM_E_PROVIDER_ALREADY_REGISTERED = unchecked((int)0x80041084),
        WBEM_E_PROVIDER_NOT_REGISTERED = unchecked((int)0x80041085),
        WBEM_E_FATAL_TRANSPORT_ERROR = unchecked((int)0x80041086),
        WBEM_E_ENCRYPTED_CONNECTION_REQUIRED = unchecked((int)0x80041087),
        WBEM_E_PROVIDER_TIMED_OUT = unchecked((int)0x80041088),
        WBEM_E_NO_KEY = unchecked((int)0x80041089),
        WBEMESS_E_REGISTRATION_TOO_BROAD = unchecked((int)0x80042001),
        WBEMESS_E_REGISTRATION_TOO_PRECISE = unchecked((int)0x80042002),
        WBEMMOF_E_EXPECTED_QUALIFIER_NAME = unchecked((int)0x80044001),
        WBEMMOF_E_EXPECTED_SEMI = unchecked((int)0x80044002),
        WBEMMOF_E_EXPECTED_OPEN_BRACE = unchecked((int)0x80044003),
        WBEMMOF_E_EXPECTED_CLOSE_BRACE = unchecked((int)0x80044004),
        WBEMMOF_E_EXPECTED_CLOSE_BRACKET = unchecked((int)0x80044005),
        WBEMMOF_E_EXPECTED_CLOSE_PAREN = unchecked((int)0x80044006),
        WBEMMOF_E_ILLEGAL_CONSTANT_VALUE = unchecked((int)0x80044007),
        WBEMMOF_E_EXPECTED_TYPE_IDENTIFIER = unchecked((int)0x80044008),
        WBEMMOF_E_EXPECTED_OPEN_PAREN = unchecked((int)0x80044009),
        WBEMMOF_E_UNRECOGNIZED_TOKEN = unchecked((int)0x8004400A),
        WBEMMOF_E_UNRECOGNIZED_TYPE = unchecked((int)0x8004400B),
        WBEMMOF_E_EXPECTED_PROPERTY_NAME = unchecked((int)0x8004400C),
        WBEMMOF_E_TYPEDEF_NOT_SUPPORTED = unchecked((int)0x8004400D),
        WBEMMOF_E_UNEXPECTED_ALIAS = unchecked((int)0x8004400E),
        WBEMMOF_E_UNEXPECTED_ARRAY_INIT = unchecked((int)0x8004400F),
        WBEMMOF_E_INVALID_AMENDMENT_SYNTAX = unchecked((int)0x80044010),
        WBEMMOF_E_INVALID_DUPLICATE_AMENDMENT = unchecked((int)0x80044011),
        WBEMMOF_E_INVALID_PRAGMA = unchecked((int)0x80044012),
        WBEMMOF_E_INVALID_NAMESPACE_SYNTAX = unchecked((int)0x80044013),
        WBEMMOF_E_EXPECTED_CLASS_NAME = unchecked((int)0x80044014),
        WBEMMOF_E_TYPE_MISMATCH = unchecked((int)0x80044015),
        WBEMMOF_E_EXPECTED_ALIAS_NAME = unchecked((int)0x80044016),
        WBEMMOF_E_INVALID_CLASS_DECLARATION = unchecked((int)0x80044017),
        WBEMMOF_E_INVALID_INSTANCE_DECLARATION = unchecked((int)0x80044018),
        WBEMMOF_E_EXPECTED_DOLLAR = unchecked((int)0x80044019),
        WBEMMOF_E_CIMTYPE_QUALIFIER = unchecked((int)0x8004401A),
        WBEMMOF_E_DUPLICATE_PROPERTY = unchecked((int)0x8004401B),
        WBEMMOF_E_INVALID_NAMESPACE_SPECIFICATION = unchecked((int)0x8004401C),
        WBEMMOF_E_OUT_OF_RANGE = unchecked((int)0x8004401D),
        WBEMMOF_E_INVALID_FILE = unchecked((int)0x8004401E),
        WBEMMOF_E_ALIASES_IN_EMBEDDED = unchecked((int)0x8004401F),
        WBEMMOF_E_NULL_ARRAY_ELEM = unchecked((int)0x80044020),
        WBEMMOF_E_DUPLICATE_QUALIFIER = unchecked((int)0x80044021),
        WBEMMOF_E_EXPECTED_FLAVOR_TYPE = unchecked((int)0x80044022),
        WBEMMOF_E_INCOMPATIBLE_FLAVOR_TYPES = unchecked((int)0x80044023),
        WBEMMOF_E_MULTIPLE_ALIASES = unchecked((int)0x80044024),
        WBEMMOF_E_INCOMPATIBLE_FLAVOR_TYPES2 = unchecked((int)0x80044025),
        WBEMMOF_E_NO_ARRAYS_RETURNED = unchecked((int)0x80044026),
        WBEMMOF_E_MUST_BE_IN_OR_OUT = unchecked((int)0x80044027),
        WBEMMOF_E_INVALID_FLAGS_SYNTAX = unchecked((int)0x80044028),
        WBEMMOF_E_EXPECTED_BRACE_OR_BAD_TYPE = unchecked((int)0x80044029),
        WBEMMOF_E_UNSUPPORTED_CIMV22_QUAL_VALUE = unchecked((int)0x8004402A),
        WBEMMOF_E_UNSUPPORTED_CIMV22_DATA_TYPE = unchecked((int)0x8004402B),
        WBEMMOF_E_INVALID_DELETEINSTANCE_SYNTAX = unchecked((int)0x8004402C),
        WBEMMOF_E_INVALID_QUALIFIER_SYNTAX = unchecked((int)0x8004402D),
        WBEMMOF_E_QUALIFIER_USED_OUTSIDE_SCOPE = unchecked((int)0x8004402E),
        WBEMMOF_E_ERROR_CREATING_TEMP_FILE = unchecked((int)0x8004402F),
        WBEMMOF_E_ERROR_INVALID_INCLUDE_FILE = unchecked((int)0x80044030),
        WBEMMOF_E_INVALID_DELETECLASS_SYNTAX = unchecked((int)0x80044031),
    }

    enum tag_WMI_OBJ_TEXT
    {
        WMI_OBJ_TEXT_CIM_DTD_2_0 = unchecked((int)0x00000001),
        WMI_OBJ_TEXT_WMI_DTD_2_0 = unchecked((int)0x00000002),
        WMI_OBJ_TEXT_WMI_EXT1 = unchecked((int)0x00000003),
        WMI_OBJ_TEXT_WMI_EXT2 = unchecked((int)0x00000004),
        WMI_OBJ_TEXT_WMI_EXT3 = unchecked((int)0x00000005),
        WMI_OBJ_TEXT_WMI_EXT4 = unchecked((int)0x00000006),
        WMI_OBJ_TEXT_WMI_EXT5 = unchecked((int)0x00000007),
        WMI_OBJ_TEXT_WMI_EXT6 = unchecked((int)0x00000008),
        WMI_OBJ_TEXT_WMI_EXT7 = unchecked((int)0x00000009),
        WMI_OBJ_TEXT_WMI_EXT8 = unchecked((int)0x0000000A),
        WMI_OBJ_TEXT_WMI_EXT9 = unchecked((int)0x0000000B),
        WMI_OBJ_TEXT_WMI_EXT10 = unchecked((int)0x0000000C),
        WMI_OBJ_TEXT_LAST = unchecked((int)0x0000000D),
    }

    enum tag_WBEM_COMPILER_OPTIONS
    {
        WBEM_FLAG_CHECK_ONLY = unchecked((int)0x00000001),
        WBEM_FLAG_AUTORECOVER = unchecked((int)0x00000002),
        WBEM_FLAG_WMI_CHECK = unchecked((int)0x00000004),
        WBEM_FLAG_CONSOLE_PRINT = unchecked((int)0x00000008),
        WBEM_FLAG_DONT_ADD_TO_LIST = unchecked((int)0x00000010),
        WBEM_FLAG_SPLIT_FILES = unchecked((int)0x00000020),
        WBEM_FLAG_CONNECT_REPOSITORY_ONLY = unchecked((int)0x00000040),
    }

	enum tag_WBEM_CONNECT_OPTIONS
	{
		WBEM_FLAG_CONNECT_REPOSITORY_ONLY = 0X40,
		WBEM_FLAG_CONNECT_USE_MAX_WAIT = 0X80,
	}

    enum tag_WBEM_PROVIDER_REQUIREMENTS_TYPE
    {
        WBEM_REQUIREMENTS_START_POSTFILTER = unchecked((int)0x00000000),
        WBEM_REQUIREMENTS_STOP_POSTFILTER = unchecked((int)0x00000001),
        WBEM_REQUIREMENTS_RECHECK_SUBSCRIPTIONS = unchecked((int)0x00000002),
    }

    enum tag_WBEM_EXTRA_RETURN_CODES
    {
        WBEM_S_INITIALIZED = unchecked((int)0x00000000),
        WBEM_S_LIMITED_SERVICE = unchecked((int)0x00043001),
        WBEM_S_INDIRECTLY_UPDATED = unchecked((int)0x00043002),
        WBEM_S_SUBJECT_TO_SDS = unchecked((int)0x00043003),
        WBEM_E_RETRY_LATER = unchecked((int)0x80043001),
        WBEM_E_RESOURCE_CONTENTION = unchecked((int)0x80043002),
    }

    enum tag_WBEM_PROVIDER_FLAGS
    {
        WBEM_FLAG_OWNER_UPDATE = unchecked((int)0x00010000),
    }

    enum tag_WBEM_INFORMATION_FLAG_TYPE
    {
        WBEM_FLAG_SHORT_NAME = unchecked((int)0x00000001),
        WBEM_FLAG_LONG_NAME = unchecked((int)0x00000002),
    }

    enum tag_WBEM_BATCH_TYPE
    {
        WBEM_FLAG_BATCH_IF_NEEDED = unchecked((int)0x00000000),
        WBEM_FLAG_MUST_BATCH = unchecked((int)0x00000001),
        WBEM_FLAG_MUST_NOT_BATCH = unchecked((int)0x00000002),
    }

    enum tag_WBEM_PATH_STATUS_FLAG
    {
        WBEMPATH_INFO_ANON_LOCAL_MACHINE = unchecked((int)0x00000001),
        WBEMPATH_INFO_HAS_MACHINE_NAME = unchecked((int)0x00000002),
        WBEMPATH_INFO_IS_CLASS_REF = unchecked((int)0x00000004),
        WBEMPATH_INFO_IS_INST_REF = unchecked((int)0x00000008),
        WBEMPATH_INFO_HAS_SUBSCOPES = unchecked((int)0x00000010),
        WBEMPATH_INFO_IS_COMPOUND = unchecked((int)0x00000020),
        WBEMPATH_INFO_HAS_V2_REF_PATHS = unchecked((int)0x00000040),
        WBEMPATH_INFO_HAS_IMPLIED_KEY = unchecked((int)0x00000080),
        WBEMPATH_INFO_CONTAINS_SINGLETON = unchecked((int)0x00000100),
        WBEMPATH_INFO_V1_COMPLIANT = unchecked((int)0x00000200),
        WBEMPATH_INFO_V2_COMPLIANT = unchecked((int)0x00000400),
        WBEMPATH_INFO_CIM_COMPLIANT = unchecked((int)0x00000800),
        WBEMPATH_INFO_IS_SINGLETON = unchecked((int)0x00001000),
        WBEMPATH_INFO_IS_PARENT = unchecked((int)0x00002000),
        WBEMPATH_INFO_SERVER_NAMESPACE_ONLY = unchecked((int)0x00004000),
        WBEMPATH_INFO_NATIVE_PATH = unchecked((int)0x00008000),
        WBEMPATH_INFO_WMI_PATH = unchecked((int)0x00010000),
        WBEMPATH_INFO_PATH_HAD_SERVER = unchecked((int)0x00020000),
    }

    enum tag_WBEM_PATH_CREATE_FLAG
    {
        WBEMPATH_CREATE_ACCEPT_RELATIVE = unchecked((int)0x00000001),
        WBEMPATH_CREATE_ACCEPT_ABSOLUTE = unchecked((int)0x00000002),
        WBEMPATH_CREATE_ACCEPT_ALL = unchecked((int)0x00000004),
        WBEMPATH_TREAT_SINGLE_IDENT_AS_NS = unchecked((int)0x00000008),
    }

    enum tag_WBEM_GET_TEXT_FLAGS
    {
        WBEMPATH_COMPRESSED = unchecked((int)0x00000001),
        WBEMPATH_GET_RELATIVE_ONLY = unchecked((int)0x00000002),
        WBEMPATH_GET_SERVER_TOO = unchecked((int)0x00000004),
        WBEMPATH_GET_SERVER_AND_NAMESPACE_ONLY = unchecked((int)0x00000008),
        WBEMPATH_GET_NAMESPACE_ONLY = unchecked((int)0x00000010),
        WBEMPATH_GET_ORIGINAL = unchecked((int)0x00000020),
    }

    enum tag_WBEM_GET_KEY_FLAGS
    {
        WBEMPATH_TEXT = unchecked((int)0x00000001),
        WBEMPATH_QUOTEDTEXT = unchecked((int)0x00000002),
    }

    enum WMIQ_ANALYSIS_TYPE
    {
        WMIQ_ANALYSIS_RPN_SEQUENCE = unchecked((int)0x00000001),
        WMIQ_ANALYSIS_ASSOC_QUERY = unchecked((int)0x00000002),
        WMIQ_ANALYSIS_PROP_ANALYSIS_MATRIX = unchecked((int)0x00000003),
        WMIQ_ANALYSIS_QUERY_TEXT = unchecked((int)0x00000004),
        WMIQ_ANALYSIS_RESERVED = unchecked((int)0x08000000),
    }

    enum __MIDL___MIDL_itf_wmi_0000_0001
    {
        WMIQ_ANALYSIS_RPN_SEQUENCE = unchecked((int)0x00000001),
        WMIQ_ANALYSIS_ASSOC_QUERY = unchecked((int)0x00000002),
        WMIQ_ANALYSIS_PROP_ANALYSIS_MATRIX = unchecked((int)0x00000003),
        WMIQ_ANALYSIS_QUERY_TEXT = unchecked((int)0x00000004),
        WMIQ_ANALYSIS_RESERVED = unchecked((int)0x08000000),
    }

    enum WMIQ_RPN_TOKEN_FLAGS
    {
        WMIQ_RPN_TOKEN_EXPRESSION = unchecked((int)0x00000001),
        WMIQ_RPN_TOKEN_AND = unchecked((int)0x00000002),
        WMIQ_RPN_TOKEN_OR = unchecked((int)0x00000003),
        WMIQ_RPN_TOKEN_NOT = unchecked((int)0x00000004),
        WMIQ_RPN_OP_UNDEFINED = unchecked((int)0x00000000),
        WMIQ_RPN_OP_EQ = unchecked((int)0x00000001),
        WMIQ_RPN_OP_NE = unchecked((int)0x00000002),
        WMIQ_RPN_OP_GE = unchecked((int)0x00000003),
        WMIQ_RPN_OP_LE = unchecked((int)0x00000004),
        WMIQ_RPN_OP_LT = unchecked((int)0x00000005),
        WMIQ_RPN_OP_GT = unchecked((int)0x00000006),
        WMIQ_RPN_OP_LIKE = unchecked((int)0x00000007),
        WMIQ_RPN_OP_ISA = unchecked((int)0x00000008),
        WMIQ_RPN_OP_ISNOTA = unchecked((int)0x00000009),
        WMIQ_RPN_LEFT_PROPERTY_NAME = unchecked((int)0x00000001),
        WMIQ_RPN_RIGHT_PROPERTY_NAME = unchecked((int)0x00000002),
        WMIQ_RPN_CONST2 = unchecked((int)0x00000004),
        WMIQ_RPN_CONST = unchecked((int)0x00000008),
        WMIQ_RPN_RELOP = unchecked((int)0x00000010),
        WMIQ_RPN_LEFT_FUNCTION = unchecked((int)0x00000020),
        WMIQ_RPN_RIGHT_FUNCTION = unchecked((int)0x00000040),
        WMIQ_RPN_GET_TOKEN_TYPE = unchecked((int)0x00000001),
        WMIQ_RPN_GET_EXPR_SHAPE = unchecked((int)0x00000002),
        WMIQ_RPN_GET_LEFT_FUNCTION = unchecked((int)0x00000003),
        WMIQ_RPN_GET_RIGHT_FUNCTION = unchecked((int)0x00000004),
        WMIQ_RPN_GET_RELOP = unchecked((int)0x00000005),
        WMIQ_RPN_NEXT_TOKEN = unchecked((int)0x00000001),
        WMIQ_RPN_FROM_UNARY = unchecked((int)0x00000001),
        WMIQ_RPN_FROM_PATH = unchecked((int)0x00000002),
        WMIQ_RPN_FROM_CLASS_LIST = unchecked((int)0x00000004),
    }

    enum __MIDL___MIDL_itf_wmi_0000_0002
    {
        WMIQ_RPN_TOKEN_EXPRESSION = unchecked((int)0x00000001),
        WMIQ_RPN_TOKEN_AND = unchecked((int)0x00000002),
        WMIQ_RPN_TOKEN_OR = unchecked((int)0x00000003),
        WMIQ_RPN_TOKEN_NOT = unchecked((int)0x00000004),
        WMIQ_RPN_OP_UNDEFINED = unchecked((int)0x00000000),
        WMIQ_RPN_OP_EQ = unchecked((int)0x00000001),
        WMIQ_RPN_OP_NE = unchecked((int)0x00000002),
        WMIQ_RPN_OP_GE = unchecked((int)0x00000003),
        WMIQ_RPN_OP_LE = unchecked((int)0x00000004),
        WMIQ_RPN_OP_LT = unchecked((int)0x00000005),
        WMIQ_RPN_OP_GT = unchecked((int)0x00000006),
        WMIQ_RPN_OP_LIKE = unchecked((int)0x00000007),
        WMIQ_RPN_OP_ISA = unchecked((int)0x00000008),
        WMIQ_RPN_OP_ISNOTA = unchecked((int)0x00000009),
        WMIQ_RPN_LEFT_PROPERTY_NAME = unchecked((int)0x00000001),
        WMIQ_RPN_RIGHT_PROPERTY_NAME = unchecked((int)0x00000002),
        WMIQ_RPN_CONST2 = unchecked((int)0x00000004),
        WMIQ_RPN_CONST = unchecked((int)0x00000008),
        WMIQ_RPN_RELOP = unchecked((int)0x00000010),
        WMIQ_RPN_LEFT_FUNCTION = unchecked((int)0x00000020),
        WMIQ_RPN_RIGHT_FUNCTION = unchecked((int)0x00000040),
        WMIQ_RPN_GET_TOKEN_TYPE = unchecked((int)0x00000001),
        WMIQ_RPN_GET_EXPR_SHAPE = unchecked((int)0x00000002),
        WMIQ_RPN_GET_LEFT_FUNCTION = unchecked((int)0x00000003),
        WMIQ_RPN_GET_RIGHT_FUNCTION = unchecked((int)0x00000004),
        WMIQ_RPN_GET_RELOP = unchecked((int)0x00000005),
        WMIQ_RPN_NEXT_TOKEN = unchecked((int)0x00000001),
        WMIQ_RPN_FROM_UNARY = unchecked((int)0x00000001),
        WMIQ_RPN_FROM_PATH = unchecked((int)0x00000002),
        WMIQ_RPN_FROM_CLASS_LIST = unchecked((int)0x00000004),
    }

    enum WMIQ_ASSOCQ_FLAGS
    {
        WMIQ_ASSOCQ_ASSOCIATORS = unchecked((int)0x00000001),
        WMIQ_ASSOCQ_REFERENCES = unchecked((int)0x00000002),
        WMIQ_ASSOCQ_RESULTCLASS = unchecked((int)0x00000004),
        WMIQ_ASSOCQ_ASSOCCLASS = unchecked((int)0x00000008),
        WMIQ_ASSOCQ_ROLE = unchecked((int)0x00000010),
        WMIQ_ASSOCQ_RESULTROLE = unchecked((int)0x00000020),
        WMIQ_ASSOCQ_REQUIREDQUALIFIER = unchecked((int)0x00000040),
        WMIQ_ASSOCQ_REQUIREDASSOCQUALIFIER = unchecked((int)0x00000080),
        WMIQ_ASSOCQ_CLASSDEFSONLY = unchecked((int)0x00000100),
        WMIQ_ASSOCQ_KEYSONLY = unchecked((int)0x00000200),
        WMIQ_ASSOCQ_SCHEMAONLY = unchecked((int)0x00000400),
        WMIQ_ASSOCQ_CLASSREFSONLY = unchecked((int)0x00000800),
    }

    enum __MIDL___MIDL_itf_wmi_0000_0003
    {
        WMIQ_ASSOCQ_ASSOCIATORS = unchecked((int)0x00000001),
        WMIQ_ASSOCQ_REFERENCES = unchecked((int)0x00000002),
        WMIQ_ASSOCQ_RESULTCLASS = unchecked((int)0x00000004),
        WMIQ_ASSOCQ_ASSOCCLASS = unchecked((int)0x00000008),
        WMIQ_ASSOCQ_ROLE = unchecked((int)0x00000010),
        WMIQ_ASSOCQ_RESULTROLE = unchecked((int)0x00000020),
        WMIQ_ASSOCQ_REQUIREDQUALIFIER = unchecked((int)0x00000040),
        WMIQ_ASSOCQ_REQUIREDASSOCQUALIFIER = unchecked((int)0x00000080),
        WMIQ_ASSOCQ_CLASSDEFSONLY = unchecked((int)0x00000100),
        WMIQ_ASSOCQ_KEYSONLY = unchecked((int)0x00000200),
        WMIQ_ASSOCQ_SCHEMAONLY = unchecked((int)0x00000400),
        WMIQ_ASSOCQ_CLASSREFSONLY = unchecked((int)0x00000800),
    }

    enum tag_WMIQ_LANGUAGE_FEATURES
    {
        WMIQ_LF1_BASIC_SELECT = unchecked((int)0x00000001),
        WMIQ_LF2_CLASS_NAME_IN_QUERY = unchecked((int)0x00000002),
        WMIQ_LF3_STRING_CASE_FUNCTIONS = unchecked((int)0x00000003),
        WMIQ_LF4_PROP_TO_PROP_TESTS = unchecked((int)0x00000004),
        WMIQ_LF5_COUNT_STAR = unchecked((int)0x00000005),
        WMIQ_LF6_ORDER_BY = unchecked((int)0x00000006),
        WMIQ_LF7_DISTINCT = unchecked((int)0x00000007),
        WMIQ_LF8_ISA = unchecked((int)0x00000008),
        WMIQ_LF9_THIS = unchecked((int)0x00000009),
        WMIQ_LF10_COMPEX_SUBEXPRESSIONS = unchecked((int)0x0000000A),
        WMIQ_LF11_ALIASING = unchecked((int)0x0000000B),
        WMIQ_LF12_GROUP_BY_HAVING = unchecked((int)0x0000000C),
        WMIQ_LF13_WMI_WITHIN = unchecked((int)0x0000000D),
        WMIQ_LF14_SQL_WRITE_OPERATIONS = unchecked((int)0x0000000E),
        WMIQ_LF15_GO = unchecked((int)0x0000000F),
        WMIQ_LF16_SINGLE_LEVEL_TRANSACTIONS = unchecked((int)0x00000010),
        WMIQ_LF17_QUALIFIED_NAMES = unchecked((int)0x00000011),
        WMIQ_LF18_ASSOCIATONS = unchecked((int)0x00000012),
        WMIQ_LF19_SYSTEM_PROPERTIES = unchecked((int)0x00000013),
        WMIQ_LF20_EXTENDED_SYSTEM_PROPERTIES = unchecked((int)0x00000014),
        WMIQ_LF21_SQL89_JOINS = unchecked((int)0x00000015),
        WMIQ_LF22_SQL92_JOINS = unchecked((int)0x00000016),
        WMIQ_LF23_SUBSELECTS = unchecked((int)0x00000017),
        WMIQ_LF24_UMI_EXTENSIONS = unchecked((int)0x00000018),
        WMIQ_LF25_DATEPART = unchecked((int)0x00000019),
        WMIQ_LF26_LIKE = unchecked((int)0x0000001A),
        WMIQ_LF27_CIM_TEMPORAL_CONSTRUCTS = unchecked((int)0x0000001B),
        WMIQ_LF28_STANDARD_AGGREGATES = unchecked((int)0x0000001C),
        WMIQ_LF29_MULTI_LEVEL_ORDER_BY = unchecked((int)0x0000001D),
        WMIQ_LF30_WMI_PRAGMAS = unchecked((int)0x0000001E),
        WMIQ_LF31_QUALIFIER_TESTS = unchecked((int)0x0000001F),
        WMIQ_LF32_SP_EXECUTE = unchecked((int)0x00000020),
        WMIQ_LF33_ARRAY_ACCESS = unchecked((int)0x00000021),
        WMIQ_LF34_UNION = unchecked((int)0x00000022),
        WMIQ_LF35_COMPLEX_SELECT_TARGET = unchecked((int)0x00000023),
        WMIQ_LF36_REFERENCE_TESTS = unchecked((int)0x00000024),
        WMIQ_LF37_SELECT_INTO = unchecked((int)0x00000025),
        WMIQ_LF38_BASIC_DATETIME_TESTS = unchecked((int)0x00000026),
        WMIQ_LF39_COUNT_COLUMN = unchecked((int)0x00000027),
        WMIQ_LF40_BETWEEN = unchecked((int)0x00000028),
        WMIQ_LF_LAST = unchecked((int)0x00000028),
    }

    enum tag_WMIQ_RPNQ_FEATURE
    {
        WMIQ_RPNF_WHERE_CLAUSE_PRESENT = unchecked((int)0x00000001),
        WMIQ_RPNF_QUERY_IS_CONJUNCTIVE = unchecked((int)0x00000002),
        WMIQ_RPNF_QUERY_IS_DISJUNCTIVE = unchecked((int)0x00000004),
        WMIQ_RPNF_PROJECTION = unchecked((int)0x00000008),
        WMIQ_RPNF_FEATURE_SELECT_STAR = unchecked((int)0x00000010),
        WMIQ_RPNF_EQUALITY_TESTS_ONLY = unchecked((int)0x00000020),
        WMIQ_RPNF_COUNT_STAR = unchecked((int)0x00000040),
        WMIQ_RPNF_QUALIFIED_NAMES_IN_SELECT = unchecked((int)0x00000080),
        WMIQ_RPNF_QUALIFIED_NAMES_IN_WHERE = unchecked((int)0x00000100),
        WMIQ_RPNF_PROP_TO_PROP_TESTS = unchecked((int)0x00000200),
        WMIQ_RPNF_ORDER_BY = unchecked((int)0x00000400),
        WMIQ_RPNF_ISA_USED = unchecked((int)0x00000800),
        WMIQ_RPNF_ISNOTA_USED = unchecked((int)0x00001000),
        WMIQ_RPNF_GROUP_BY_HAVING = unchecked((int)0x00002000),
        WMIQ_RPNF_WITHIN_INTERVAL = unchecked((int)0x00004000),
        WMIQ_RPNF_WITHIN_AGGREGATE = unchecked((int)0x00008000),
        WMIQ_RPNF_SYSPROP_CLASS = unchecked((int)0x00010000),
        WMIQ_RPNF_REFERENCE_TESTS = unchecked((int)0x00020000),
        WMIQ_RPNF_DATETIME_TESTS = unchecked((int)0x00040000),
        WMIQ_RPNF_ARRAY_ACCESS = unchecked((int)0x00080000),
        WMIQ_RPNF_QUALIFIER_FILTER = unchecked((int)0x00100000),
        WMIQ_RPNF_SELECTED_FROM_PATH = unchecked((int)0x00200000),
    }
    #endregion

    #region Structs
    struct tag_CompileStatusInfo
    {
        public Int32 lPhaseError;
        [MarshalAs(UnmanagedType.Error)] public   Int32 hRes;
        public Int32 ObjectNum;
        public Int32 FirstLine;
        public Int32 LastLine;
        public UInt32 dwOutFlags;
    }

    struct tag_SWbemQueryQualifiedName
    {
        /*[ComConversionLossAttribute]*/
        public UInt32 m_uVersion;
        public UInt32 m_uTokenType;
        public UInt32 m_uNameListSize;
        public IntPtr m_ppszNameList;
        /*[ComConversionLossAttribute]*/
        public Int32 m_bArraysUsed;
        public IntPtr m_pbArrayElUsed;
        /*[ComConversionLossAttribute]*/
        public IntPtr m_puArrayIndex;
        /*[ComConversionLossAttribute]*/
    }

    struct tag_SWbemRpnConst
    {
        public UInt64 unionhack;
    }

    struct tag_SWbemRpnQueryToken
    {
        /*[ComConversionLossAttribute]*/
        public UInt32 m_uVersion;
        public UInt32 m_uTokenType;
        public UInt32 m_uSubexpressionShape;
        public UInt32 m_uOperator;
        public IntPtr m_pRightIdent;
        /*[ComConversionLossAttribute]*/
        public IntPtr m_pLeftIdent;
        /*[ComConversionLossAttribute]*/
        public UInt32 m_uConstApparentType;
        public tag_SWbemRpnConst m_Const;
        public UInt32 m_uConst2ApparentType;
        public tag_SWbemRpnConst m_Const2;
        [MarshalAs(UnmanagedType.LPWStr)] public   string m_pszRightFunc;
        [MarshalAs(UnmanagedType.LPWStr)] public   string m_pszLeftFunc;
    }

    struct tag_SWbemRpnTokenList
    {
        public UInt32 m_uVersion;
        public UInt32 m_uTokenType;
        public UInt32 m_uNumTokens;
    }

    struct tag_SWbemRpnEncodedQuery
    {
        /*[ComConversionLossAttribute]*/
        public UInt32 m_uVersion;
        public UInt32 m_uTokenType;
        public UInt32 m_uParsedFeatureMask1;
        public UInt32 m_uParsedFeatureMask2;
        public UInt32 m_uDetectedArraySize;
        public IntPtr m_puDetectedFeatures;
        /*[ComConversionLossAttribute]*/
        public UInt32 m_uSelectListSize;
        public IntPtr m_ppSelectList;
        /*[ComConversionLossAttribute]*/
        public UInt32 m_uFromTargetType;
        [MarshalAs(UnmanagedType.LPWStr)] public   string m_pszOptionalFromPath;
        public UInt32 m_uFromListSize;
        public IntPtr m_ppszFromList;
        /*[ComConversionLossAttribute]*/
        public UInt32 m_uWhereClauseSize;
        public IntPtr m_ppRpnWhereClause;
        /*[ComConversionLossAttribute]*/
        public double m_dblWithinPolling;
        public double m_dblWithinWindow;
        public UInt32 m_uOrderByListSize;
        public IntPtr m_ppszOrderByList;
        /*[ComConversionLossAttribute]*/
        public IntPtr m_uOrderDirectionEl;
        /*[ComConversionLossAttribute]*/
    }

    struct tag_SWbemAnalysisMatrix
    {
        /*[ComConversionLossAttribute]*/
        public UInt32 m_uVersion;
        public UInt32 m_uMatrixType;
        [MarshalAs(UnmanagedType.LPWStr)] public   string m_pszProperty;
        public UInt32 m_uPropertyType;
        public UInt32 m_uEntries;
        public IntPtr m_pValues;
        /*[ComConversionLossAttribute]*/
        public IntPtr m_pbTruthTable;
        /*[ComConversionLossAttribute]*/
    }

    struct tag_SWbemAnalysisMatrixList
    {
        /*[ComConversionLossAttribute]*/
        public UInt32 m_uVersion;
        public UInt32 m_uMatrixType;
        public UInt32 m_uNumMatrices;
        public IntPtr m_pMatrices;
        /*[ComConversionLossAttribute]*/
    }

    struct tag_SWbemAssocQueryInf
    {
        public UInt32 m_uVersion;
        public UInt32 m_uAnalysisType;
        public UInt32 m_uFeatureMask;
        [MarshalAs(UnmanagedType.Interface)] public   IWbemPath m_pPath;
        [MarshalAs(UnmanagedType.LPWStr)] public   string m_pszPath;
        [MarshalAs(UnmanagedType.LPWStr)] public   string m_pszQueryText;
        [MarshalAs(UnmanagedType.LPWStr)] public   string m_pszResultClass;
        [MarshalAs(UnmanagedType.LPWStr)] public   string m_pszAssocClass;
        [MarshalAs(UnmanagedType.LPWStr)] public   string m_pszRole;
        [MarshalAs(UnmanagedType.LPWStr)] public   string m_pszResultRole;
        [MarshalAs(UnmanagedType.LPWStr)] public   string m_pszRequiredQualifier;
        [MarshalAs(UnmanagedType.LPWStr)] public   string m_pszRequiredAssocQualifier;
    }
    #endregion

    #region Co Classes
    [ClassInterfaceAttribute((short)0x0000)]
    [GuidAttribute("4590F811-1D3A-11D0-891F-00AA004B2E24")]
    [TypeLibTypeAttribute(0x0202)]
    [ComImport]
    class WbemLocator 
    {
    }

    [ClassInterfaceAttribute((short)0x0000)]
    [GuidAttribute("674B6698-EE92-11D0-AD71-00C04FD8FDFF")]
    [TypeLibTypeAttribute(0x0202)]
    [ComImport]
    class WbemContext 
    {
    }

    [ClassInterfaceAttribute((short)0x0000)]
    [GuidAttribute("49BD2028-1523-11D1-AD79-00C04FD8FDFF")]
    [TypeLibTypeAttribute(0x0002)]
    [ComImport]
    class UnsecuredApartment 
    {
    }

    [GuidAttribute("9A653086-174F-11D2-B5F9-00104B703EFD")]
    [ClassInterfaceAttribute((short)0x0000)]
    [TypeLibTypeAttribute(0x0002)]
    [ComImport]
    class WbemClassObject 
    {
    }

    [ClassInterfaceAttribute((short)0x0000)]
    [GuidAttribute("6DAF9757-2E37-11D2-AEC9-00C04FB68820")]
    [TypeLibTypeAttribute(0x0002)]
    [ComImport]
    class MofCompiler 
    {
    }

    [ClassInterfaceAttribute((short)0x0000)]
    [TypeLibTypeAttribute(0x0002)]
    [GuidAttribute("EB87E1BD-3233-11D2-AEC9-00C04FB68820")]
    [ComImport]
    class WbemStatusCodeText 
    {
    }

    [GuidAttribute("C49E32C6-BC8B-11D2-85D4-00105A1F8304")]
    [ClassInterfaceAttribute((short)0x0000)]
    [TypeLibTypeAttribute(0x0002)]
    [ComImport]
    class WbemBackupRestore 
    {
    }

    [ClassInterfaceAttribute((short)0x0000)]
    [GuidAttribute("C71566F2-561E-11D1-AD87-00C04FD8FDFF")]
    [TypeLibTypeAttribute(0x0202)]
    [ComImport]
    class WbemRefresher 
    {
    }

    [ClassInterfaceAttribute((short)0x0000)]
    [TypeLibTypeAttribute(0x0202)]
    [GuidAttribute("8D1C559D-84F0-4BB3-A7D5-56A7435A9BA6")]
    [ComImport]
    class WbemObjectTextSrc 
    {
    }

 //   [ClassInterfaceAttribute((short)0x0000)]
 //   [GuidAttribute("CB8555CC-9128-11D1-AD9B-00C04FD8FDFF")]
 //   [TypeLibTypeAttribute(0x0002)]
 //   [ComImport]
 //   class WbemAdministrativeLocator 
 //   {
 //   }

 //   [TypeLibTypeAttribute(0x0002)]
 //   [ClassInterfaceAttribute((short)0x0000)]
 //   [GuidAttribute("CD184336-9128-11D1-AD9B-00C04FD8FDFF")]
 //   [ComImport]
 //   class WbemAuthenticatedLocator 
 //   {
 //   }

 //   [TypeLibTypeAttribute(0x0002)]
 //   [ClassInterfaceAttribute((short)0x0000)]
 //   [GuidAttribute("443E7B79-DE31-11D2-B340-00104BCC4B4A")]
 //   [ComImport]
 //   class WbemUnauthenticatedLocator 
 //   {
 //   }

    [GuidAttribute("4CFC7932-0F9D-4BEF-9C32-8EA2A6B56FCB")]
    [TypeLibTypeAttribute(0x0002)]
    [ClassInterfaceAttribute((short)0x0000)]
    [ComImport]
    class WbemDecoupledRegistrar 
    {
    }

    [GuidAttribute("F5F75737-2843-4F22-933D-C76A97CDA62F")]
    [TypeLibTypeAttribute(0x0002)]
    [ClassInterfaceAttribute((short)0x0000)]
    [ComImport]
    class WbemDecoupledBasicEventProvider 
    {
    }

    [ClassInterfaceAttribute((short)0x0000)]
    [GuidAttribute("CF4CC405-E2C5-4DDD-B3CE-5E7582D8C9FA")]
    [TypeLibTypeAttribute(0x0202)]
    [ComImport]
    class WbemDefPath 
    {
    }

    [GuidAttribute("EAC8A024-21E2-4523-AD73-A71A0AA2F56A")]
    [ClassInterfaceAttribute((short)0x0000)]
    [TypeLibTypeAttribute(0x0002)]
    [ComImport]
    class WbemQuery 
    {
    }
    #endregion

    class MTAHelper
    {
		// HACK: Make sure we load WMINet_Utils.dll before we call a DllImport method that uses it.
		static WmiSec wmiSec = new WmiSec();

		static Exception exception = null ;												// [marioh, RAID: 111108]

		static Type typeToCreate = null; // The type of object to be created on the MTA
        static object createdObject = null; // The object created by our worker thread

        static AutoResetEvent evtGo = new AutoResetEvent(false); // tells the worker to create an object on our behalf
        static AutoResetEvent evtDone = new AutoResetEvent(false); // tells the client thread that the requested object is ready

        static bool workerThreadInitialized = false;
        // Initialize worker thread
        // This is not done in a static constructor so that we don't do this in an MTA only application
        static void InitWorkerThread()
        {
            // Create the worker thread
            Thread thread = new Thread(new ThreadStart(WorkerThread));
            thread.ApartmentState = ApartmentState.MTA;
            thread.IsBackground = true;
            thread.Start();
        }

        // This method will create an instance of the requeted type in the MTA
        public static object CreateInMTA(Type type)
        {
            // If we are currently in the MTA, we can directly create the object
			if(IsNoContextMTA())  // Bug#110141 - Checking for MTA is not enough.  We need to make sure we are not in a COM+ Context
				return Activator.CreateInstance(type);

            // We need to create the object in the MTA by using a worker thread
            // that lives in the MTA.  Make sure only one person uses this worker
            // thread at a time
            object copyOfCreatedObject;
            lock(typeof(MTAHelper))
            {
                // Make sure worker thread is initialized
                if(workerThreadInitialized == false)
                {
                    InitWorkerThread();
                    workerThreadInitialized = true;
                }

                // Let the worker thread know what 'type' we want to create
                typeToCreate = type;
                evtGo.Set();
                evtDone.WaitOne();

				//
				// [marioh, RAID: 111108]
				// Rethrow exception if one occured in the worker thread.
				// 
				if ( exception != null )
				{
					throw exception ;
				}


                // Read the created object out of the static property
                // We must do this before releasing the lock on the worker thread
                copyOfCreatedObject = createdObject;
            }
            return copyOfCreatedObject;
        }

        static void WorkerThread()
        {
            // The worker thread will be a background thread, so we never have
            // to worry about killing it.  There is no chance that we will
            // be terminated inside the guts of the worker because we are
            // always waited on until we complete.  In other words, when the
            // process goes away, we are really assured that we will be in the
            // evtGo.WaitOne() block.
			exception = null ;
			while(true)
            {
                // Wait for someone who wants us to create an object
                evtGo.WaitOne();

				//
				// [marioh, RAID: 111108]
				// We need to try catch this and make sure the finally clause signals that the thread
				// has completed so main thread can wake up.
				// 
				try
				{
					// Create the requested object type
					createdObject = Activator.CreateInstance(typeToCreate);
				}
				catch ( Exception e )
				{
					exception = e ;
				}
				finally 
				{
					// Tell the caller that we are done creating the object
					evtDone.Set();
				}
            }
		}

		// Interfaces that we need to use
		static Guid IID_IObjectContext = new Guid("51372AE0-CAE7-11CF-BE81-00AA00A2FA25");
		static Guid IID_IComThreadingInfo = new Guid("000001ce-0000-0000-C000-000000000046");

		// 'Apartment Type' returned by IComThreadingInfo::GetCurrentApartmentType()
		enum APTTYPE
		{
			APTTYPE_CURRENT = -1,
			APTTYPE_STA = 0,
			APTTYPE_MTA = 1,
			APTTYPE_NA  = 2,
			APTTYPE_MAINSTA = 3
		}

		// High perf way of calling IComThreadingInfo::GetCurrentApartmentType()
		// NOTE: The first parameter of GetCurrentApartmentType_f3 must be '3'.  This specifies
		// the methods location in the VTable
		[SuppressUnmanagedCodeSecurity, DllImport("wminet_utils.dll", EntryPoint="UFunc")]
		static extern int GetCurrentApartmentType_f3(int vFunc, IntPtr pComThreadingInfo, [Out] out APTTYPE aptType);

		// Import of CoGetObjectContext
		[SuppressUnmanagedCodeSecurity, DllImport("ole32.dll")]
		static extern int CoGetObjectContext([In] ref Guid riid, [Out] out IntPtr pUnk);

		// A variable that is initialized once to tell us if we are on
		// a Win2k platform or above.
		static bool CanCallCoGetObjectContext = IsWindows2000OrHigher();

		// This method will tell us if the calling thread is in the MTA and we are not in a 'context'
		// Added for Bug#110141
		public static bool IsNoContextMTA()
		{
			// If the runtime says we are not an MTA thread, we'll trust it and return false
			if(Thread.CurrentThread.ApartmentState != ApartmentState.MTA)
				return false;

			// We know that 'ApartmentState' says we are MTA
			// If we are not on Win2k or above, we don't have to worry about 'context' or the neutral apartment
			// We know we are safely in the MTA and return true
			if(!CanCallCoGetObjectContext)
				return true;


			// We now will use IComThreadingInfo to make sure we are not in the neutral apartment, and
			// we check for IObjectContext to see if we have a 'context'
			IntPtr pComThreadingInfo = IntPtr.Zero;
			IntPtr pObjectContext = IntPtr.Zero;
			try
			{
				// If we CANNOT call CoGetObjectContext, assume we are not in the 'no context MTA' for safety
				// (NOTE: This call is expected to always succeed)
				if(0 != CoGetObjectContext(ref IID_IComThreadingInfo, out pComThreadingInfo))
					return false;

				APTTYPE aptType;

				// If we CANNOT get the apartment type, assume we are not in the 'no context MTA' for safety
				// (NOTE: This call is expected to always succeed)
				if(0 != GetCurrentApartmentType_f3(3, pComThreadingInfo, out aptType))
					return false;

				// If we are not in the MTA, return false
				if(aptType != APTTYPE.APTTYPE_MTA)
					return false;

				// If we CAN get to the IObejctContext interface, we have a 'context'
				if(0 == Marshal.QueryInterface(pComThreadingInfo, ref IID_IObjectContext, out pObjectContext))
					return false;
			}
			finally
			{
				if(pComThreadingInfo != IntPtr.Zero)
					Marshal.Release(pComThreadingInfo);
				if(pObjectContext != IntPtr.Zero)
					Marshal.Release(pObjectContext);
			}

			// We made it past all the tests
			return true;
		}

		static bool IsWindows2000OrHigher()
		{
			// If we are on Win2k or above, we are OK
			// - Platform == Win32NT and OS version >= 5.0.0.0
			OperatingSystem os = Environment.OSVersion;
			if(os.Platform==PlatformID.Win32NT && os.Version >= new Version(5, 0))
				return true;
			return false;
		}
    }


	/// <summary>
	/// The ThreadDispatch class allows clients to very easily spawn a thread, specify a worker delegate to be called from the
	/// spawned thread and wait until thread finishes work. This is important in cases where a new thread needs to be spawned but
	/// the main thread has to wait until the spawned thread finishes. As an example of this, in WMI we spawn MTA threads and create
	/// various objects in these threads to make sure we avoid marshaling cost. 
	/// If the worker thread returns a value it is stored in the ThreadDispatch object and accessible to clients via the Result property.
	/// Also, any exception thrown is propagated from worker thread to main thread (by rethrowing orinal exception):
	/// 
	///		ThreadDispatch disp = new ThreadDispatch ( new ThreadDispatch.ThreadWorkerMethod  ( Class1.Func ) ) ;
	///		disp.Start ( ) ;
	/// 
	/// Four different delegate types are supported:
	/// 
	///		1. Delegate with no parameter and no return value.
	///		2. Delegate with no parameter and return value.
	///		3. Delegate with parameter and no return value.
	///		4. Delegate with parameter and return value.
	/// 
	/// </summary>
	internal class ThreadDispatch 
	{
		#region Private fields
		private		Thread									thread ;					
		private		Exception								exception ;									// Exception thrown from worker method (if any). Exposed as property.
		private		ThreadWorkerMethodWithReturn			threadWorkerMethodWithReturn ;				// Delegate to be called for worker method with return value
		private		ThreadWorkerMethodWithReturnAndParam	threadWorkerMethodWithReturnAndParam ;		// Delegate to be called for worker method with return value and parameter
		private		ThreadWorkerMethod						threadWorkerMethod ;						// Delegate to be called for worker method
		private		ThreadWorkerMethodWithParam				threadWorkerMethodWithParam ;				// Delegate to be called for worker method with parameter
		private		object									threadReturn ;								// Return data from worker method.
		private		object									threadParams ;								// Parameters to be passed to worker method
		private		bool									backgroundThread ;							// Is this a background thread?
		private		ApartmentState							apartmentType ;								// Apartment type of thread
		#endregion

		#region Properties
		/// <summary>
		/// [Get] Gets the exception associated with the operation performed by thread.
		/// This can be null if no exception has been thrown.
		/// </summary>
		public System.Exception Exception
		{
			get
			{
				return this.exception ;
			}
		}

		/// <summary>
		/// [Get/Set] The parameter to be used by worker thread. This will typically be a 'this' reference for access to instance members.
		/// </summary>
		public object Parameter
		{
			get
			{
				return this.threadParams ;
			}
			set
			{
				this.threadParams = value ;
			}
		}

		/// <summary>
		/// [Get/Set] The background property of a thread. Defaults to false.
		/// </summary>
		public bool IsBackgroundThread
		{
			get
			{
				return this.backgroundThread ;
			}
			set
			{
				this.backgroundThread = value ;
			}
		}

		/// <summary>
		/// [Get] The result of the worker method called.
		/// </summary>
		public object Result
		{
			get
			{
				return this.threadReturn ;
			}
		}


		/// <summary>
		/// [Get/Set] The thread apartment type
		/// </summary>
		public ApartmentState ApartmentType
		{
			get 
			{
				return this.apartmentType ;
			}
			set
			{
				this.apartmentType = value ;
			}
		}
		#endregion

		#region Public Delegates
		/// <summary>
		/// Delegate declaration representing signature of worker method with return value.
		/// </summary>
		public delegate object	ThreadWorkerMethodWithReturn (  ) ;
		
		/// <summary>
		/// Delegate declaration representing signature of worker method with return value and parameter.
		/// </summary>
		public delegate object	ThreadWorkerMethodWithReturnAndParam ( object param ) ;

		/// <summary>
		/// Delegate declaration representing signature of worker method with no return value and no parameter
		/// </summary>
		public delegate void	ThreadWorkerMethod (  ) ;

		/// <summary>
		/// Delegate declaration representing signature of worker method with parameter.
		/// </summary>
		public delegate void	ThreadWorkerMethodWithParam ( object param ) ;
		#endregion

		#region Public methods
		/// <summary>
		/// Constructs a ThreadDispatch object with the thread worker method.
		///	Default settings on the ThreadDispatch object are:
		///		1. Parameter is null
		///		2. Thread ApartmentState will be MTA
		///		3. Background thread status will be false
		/// </summary>
		/// <param name="workerMethod">Delegate to be called to perform the work</param>
		public ThreadDispatch ( ThreadWorkerMethodWithReturn workerMethod ) : this ( )
		{
			InitializeThreadState ( null, workerMethod, ApartmentState.MTA, false ) ;
		}

		/// <summary>
		/// Constructs a ThreadDispatch object with the thread worker method.
		///	Default settings on the ThreadDispatch object are:
		///		1. Parameter is null
		///		2. Thread ApartmentState will be MTA
		///		3. Background thread status will be false
		/// </summary>
		/// <param name="workerMethod">Delegate to be called to perform the work</param>
		public ThreadDispatch ( ThreadWorkerMethodWithReturnAndParam workerMethod ) : this ( )
		{
			InitializeThreadState ( null, workerMethod, ApartmentState.MTA, false ) ;
		}

		/// <summary>
		/// Constructs a ThreadDispatch object with the thread worker method.
		///	Default settings on the ThreadDispatch object are:
		///		1. Parameter is null
		///		2. Thread ApartmentState will be MTA
		///		3. Background thread status will be false
		/// </summary>
		/// <param name="workerMethod">Delegate to be called to perform the work</param>
		public ThreadDispatch ( ThreadWorkerMethodWithParam workerMethod ) : this ( )
		{
			InitializeThreadState ( null, workerMethod, ApartmentState.MTA, false ) ;
		}

		/// <summary>
		/// Constructs a ThreadDispatch object with the thread worker method.
		///	Default settings on the ThreadDispatch object are:
		///		1. Parameter is null
		///		2. Thread ApartmentState will be MTA
		///		3. Background thread status will be false
		/// </summary>
		/// <param name="workerMethod">Delegate to be called to perform the work</param>
		public ThreadDispatch ( ThreadWorkerMethod workerMethod ) : this ( )
		{
			InitializeThreadState ( null, workerMethod, ApartmentState.MTA, false ) ;
		}

		/// <summary>
		/// Starts the thread execution and waits for thread to finish. If an exception occurs in the worker method
		/// this method rethrows the exception.
		/// </summary>
		public void Start ( )
		{
			this.exception = null ;
			DispatchThread ( ) ;
			if ( this.Exception != null )
			{
				throw this.Exception ;
			}
		}
		#endregion

		#region Private methods
		/// <summary>
		/// Initializes the ThreadDispatch instance with initial values. Note that this constructor is private to avoid
		/// declaring instances without specifying at least a worker delegate instance.
		/// </summary>
		private ThreadDispatch ( )
		{
			this.thread									= null ;
			this.exception								= null ;
			this.threadParams							= null ;
			this.threadWorkerMethodWithReturn			= null ;		
			this.threadWorkerMethodWithReturnAndParam	= null ;
			this.threadWorkerMethod						= null ;				
			this.threadWorkerMethodWithParam			= null;		
			this.threadReturn							= null ;
			this.backgroundThread						= false ;
			this.apartmentType							= ApartmentState.MTA ;
		}

		/// <summary>
		/// Initializes the thread state members.
		/// </summary>
		/// <param name="threadParams">Parameters to be passed to thread</param>
		/// <param name="workerMethod">The delegate to be called from thread</param>
		/// <param name="aptState">The apartment of the thread created</param>
		private void InitializeThreadState ( object threadParams, ThreadWorkerMethodWithReturn workerMethod, ApartmentState aptState, bool background )
		{
			this.threadParams = threadParams ;
			this.threadWorkerMethodWithReturn  = workerMethod ;
			this.thread = new Thread ( new ThreadStart ( ThreadEntryPointMethodWithReturn ) ) ;
			this.thread.ApartmentState = aptState ;
			this.backgroundThread = background ;
		}

		/// <summary>
		/// Initializes the thread state members.
		/// </summary>
		/// <param name="threadParams">Parameters to be passed to thread</param>
		/// <param name="workerMethod">The delegate to be called from thread</param>
		/// <param name="aptState">The apartment of the thread created</param>
		private void InitializeThreadState ( object threadParams, ThreadWorkerMethodWithReturnAndParam workerMethod, ApartmentState aptState, bool background )
		{
			this.threadParams = threadParams ;
			this.threadWorkerMethodWithReturnAndParam = workerMethod ;
			this.thread = new Thread ( new ThreadStart ( ThreadEntryPointMethodWithReturnAndParam ) ) ;
			this.thread.ApartmentState = aptState ;
			this.backgroundThread = background ;
		}

		/// <summary>
		/// Initializes the thread state members.
		/// </summary>
		/// <param name="threadParams">Parameters to be passed to thread</param>
		/// <param name="workerMethod">The delegate to be called from thread</param>
		/// <param name="aptState">The apartment of the thread created</param>
		private void InitializeThreadState ( object threadParams, ThreadWorkerMethod workerMethod, ApartmentState aptState, bool background )
		{
			this.threadParams = threadParams ;
			this.threadWorkerMethod  = workerMethod ;
			this.thread = new Thread ( new ThreadStart ( ThreadEntryPoint ) ) ;
			this.thread.ApartmentState = aptState ;
			this.backgroundThread = background ;
		}

		/// <summary>
		/// Initializes the thread state members.
		/// </summary>
		/// <param name="threadParams">Parameters to be passed to thread</param>
		/// <param name="workerMethod">The delegate to be called from thread</param>
		/// <param name="aptState">The apartment of the thread created</param>
		private void InitializeThreadState ( object threadParams, ThreadWorkerMethodWithParam workerMethod, ApartmentState aptState, bool background )
		{
			this.threadParams = threadParams ;
			this.threadWorkerMethodWithParam = workerMethod ;
			this.thread = new Thread ( new ThreadStart ( ThreadEntryPointMethodWithParam ) ) ;
			this.thread.ApartmentState = aptState ;
			this.backgroundThread = background ;
		}


		/// <summary>
		/// Starts the execution of the thread and waits until the threadFinished event is signaled before continuing
		/// </summary>
		private void DispatchThread ( )
		{
			this.thread.Start ( ) ;
			this.thread.Join ( ) ;
		}
		
		/// <summary>
		/// Entry point for the newly created thread. This method is wrapped in a try/catch block and captures any
		/// exceptions thrown from the worker method and re-throws the exception. 
		/// The worker method for this thread entry point has no parameter and no return value.
		/// </summary>
		private void ThreadEntryPoint ( )
		{
			try
			{
				this.threadWorkerMethod ( ) ;
			}
			catch ( Exception e )
			{
				this.exception = e ;
			}
		}

		/// <summary>
		/// Entry point for the newly created thread. This method is wrapped in a try/catch block and captures any
		/// exceptions thrown from the worker method and re-throws the exception. 
		/// The worker method for this thread entry point takes a parameter and no return value.
		/// </summary>

		private void ThreadEntryPointMethodWithParam ( )
		{
			try
			{
				this.threadWorkerMethodWithParam ( this.threadParams ) ;
			}
			catch ( Exception e )
			{
				this.exception = e ;
			}
		}

		/// <summary>
		/// Entry point for the newly created thread. This method is wrapped in a try/catch block and captures any
		/// exceptions thrown from the worker method and re-throws the exception. 
		/// The worker method for this thread entry point has no parameter but does return a value.
		/// </summary>

		private void ThreadEntryPointMethodWithReturn ( )
		{
			try
			{
				this.threadReturn = this.threadWorkerMethodWithReturn ( ) ;
			}
			catch ( Exception e )
			{
				this.exception = e ;
			}
		}

		/// <summary>
		/// Entry point for the newly created thread. This method is wrapped in a try/catch block and captures any
		/// exceptions thrown from the worker method and re-throws the exception. 
		/// The worker method for this thread entry point has a parameter and return value.
		/// </summary>

		private void ThreadEntryPointMethodWithReturnAndParam ( )
		{
			try
			{
				this.threadReturn = this.threadWorkerMethodWithReturnAndParam ( this.threadParams) ;
			}
			catch ( Exception e )
			{
				this.exception = e ;
			}
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\instrumentation\managementinstaller.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Management.Instrumentation
{
    using System;
    using System.Reflection;
    using System.Collections;
    using System.Configuration.Install;
    using System.Text;
    using System.IO;
	using System.Globalization;


    /// <summary>
    ///    <para>Installs instrumented assemblies. Include an instance of this installer class in the project installer for
    ///       an assembly that includes instrumentation.</para>
    /// </summary>
    /// <remarks>
    /// <para> If this is the only installer for your application, you may use the helper class <see cref='System.Management.Instrumentation.DefaultManagementProjectInstaller'/>
    /// provided in this namespace. </para>
    /// </remarks>
    /// <example>
    ///    <para>If you have a master project installer for your 
    ///       project, add the following code to your project installers constructor:</para>
    ///    <code lang='C#'>// Instantiate installer for assembly.
    /// ManagementInstaller managementInstaller = new ManagementInstaller();
    /// 
    /// // Add installer to collection.
    /// Installers.Add(managementInstaller);
    ///    </code>
    ///    <code lang='VB'>'Instantiate installer for assembly.
    /// Dim managementInstaller As New ManagementInstaller()
    /// 
    /// 'Add installer to collection.
    /// Installers.Add(managementInstaller)
    ///    </code>
    /// </example>
    public class ManagementInstaller : Installer
	{
        // TODO: Is this correct
        private static bool helpPrinted = false;
        /// <summary>
        ///    <para>Gets or sets installer options for this class.</para>
        /// </summary>
        /// <value>
        ///    <para>The help text for all the installers in the installer collection, including
        ///       the description of what each installer does and the command-line options (for
        ///       the installation program) that can be passed to and understood by each
        ///       installer.</para>
        /// </value>
        public override string HelpText {
            get {
                if (helpPrinted)
                    return base.HelpText;
                else {
                    helpPrinted = true;
//                    return Res.GetString(Res.HelpText) + "\r\n" + base.HelpText;
                    // TODO: Localize
                    StringBuilder help = new StringBuilder();
                    help.Append("/MOF=[filename]\r\n");
					help.Append(" " + RC.GetString("FILETOWRITE_MOF")+"\r\n\r\n");

					//
					// [RAID: 123895]
					// If the force parameter is present, we update registration information independent if it already
					// exists.
					//
					help.Append ( "/Force or /F\r\n" ) ;
					help.Append(" " + RC.GetString("FORCE_UPDATE"));
                    return help.ToString() + base.HelpText;
                }
            }
        }

    
		/// <summary>
		///    <para>Installs the assembly.</para>
		/// </summary>
		/// <param name='savedState'>The state of the assembly.</param>
		public override void Install(IDictionary savedState) {
			base.Install(savedState);
            // TODO: Localize
            Context.LogMessage(RC.GetString("WMISCHEMA_INSTALLATIONSTART"));

            string assemblyPath = Context.Parameters["assemblypath"];
            Assembly assembly = Assembly.LoadFrom(assemblyPath);

            SchemaNaming naming = SchemaNaming.GetSchemaNaming(assembly);

            // See if this assembly provides instrumentation
            if(null == naming)
                return;

			//
			// [RAID: 123895]
			// If the force parameter is present, we update registration information independent if it already
			// exists.
			//
            if( ( naming.IsAssemblyRegistered() == false ) || ( Context.Parameters.ContainsKey ( "force" ) ) || ( Context.Parameters.ContainsKey ( "f" ) ) )
            {
                Context.LogMessage(RC.GetString("REGESTRING_ASSEMBLY") + " " + naming.DecoupledProviderInstanceName);

                naming.RegisterNonAssemblySpecificSchema(Context);
                naming.RegisterAssemblySpecificSchema();
            }
            mof = naming.Mof;

            Context.LogMessage(RC.GetString("WMISCHEMA_INSTALLATIONEND"));
		}

        string mof;

		/// <summary>
		///    <para>Commits the assembly to the operation.</para>
		/// </summary>
		/// <param name='savedState'>The state of the assembly.</param>
		public override void Commit(IDictionary savedState) {
			base.Commit(savedState);

            // See if we were asked to generate a MOF file
            if(Context.Parameters.ContainsKey("mof"))
            {
                string mofFile = Context.Parameters["mof"];

                // bug#62252 - Pick a default MOF file name
                if(mofFile == null || mofFile.Length == 0)
                {
                    mofFile = Context.Parameters["assemblypath"];
                    if(mofFile == null || mofFile.Length == 0)
                        mofFile = "defaultmoffile";
                    else
                        mofFile = Path.GetFileName(mofFile);
                }

                // Append '.mof' in necessary
                if(mofFile.Length<4)
                    mofFile += ".mof";
                else
                {
                    string end = mofFile.Substring(mofFile.Length-4,4);
					end.ToLower(CultureInfo.InvariantCulture);
					if(end != ".mof")
                        mofFile += ".mof";
                }
                Context.LogMessage(RC.GetString("MOFFILE_GENERATING") + " " + mofFile);
                using(StreamWriter log = new StreamWriter(mofFile, false, Encoding.Unicode))
                {
                    log.WriteLine("//**************************************************************************");
                    log.WriteLine("//* {0}", mofFile);
                    log.WriteLine("//**************************************************************************");
                    log.WriteLine(mof);
                }
            }
		}
		/// <summary>
		///    <para>Rolls back the state of the assembly.</para>
		/// </summary>
		/// <param name='savedState'>The state of the assembly.</param>
		public override void Rollback(IDictionary savedState) {
			base.Rollback(savedState);
		}

		/// <summary>
		///    <para>Uninstalls the assembly.</para>
		/// </summary>
		/// <param name='savedState'>The state of the assembly.</param>
		public override void Uninstall(IDictionary savedState) {
			base.Uninstall(savedState);
		}
	}

    /// <summary>
    ///    <para> Installs an instrumented assembly. This class is a default project installer for assemblies that contain
    ///       management instrumentation and do not use other installers (such as services, or message
    ///       queues). To use this default project installer, simply derive a class from
    ///    <see cref='System.Management.Instrumentation.DefaultManagementProjectInstaller'/> inside the assembly. No methods need
    ///       to be overridden.</para>
    /// </summary>
    /// <remarks>
    ///    <para>If your project has a master project
    ///       installer, use the <see cref='System.Management.Instrumentation.ManagementInstaller'/> class instead.</para>
    /// </remarks>
    /// <example>
    ///    <para>Add the following code to your instrumented assembly to enable the installation step:</para>
    ///    <code lang='C#'>[System.ComponentModel.RunInstaller(true)]
    /// public class MyInstaller : DefaultManagementProjectInstaller {}
    ///    </code>
    ///    <code lang='VB'>&lt;System.ComponentModel.RunInstaller(true)&gt;
    /// public class MyInstaller
    ///     Inherits DefaultManagementProjectInstaller
    ///    </code>
    /// </example>
    public class DefaultManagementProjectInstaller : Installer
    {
        /// <summary>
        ///    <para>Initializes a new instance of the 
        ///    <see cref='System.Management.Instrumentation.DefaultManagementProjectInstaller'/> class. This is the default constructor.</para>
        /// </summary>
        public DefaultManagementProjectInstaller()
        {
            // Instantiate installer for assembly.
            ManagementInstaller managementInstaller = new ManagementInstaller();

            // Add installers to collection. Order is not important.
            Installers.Add(managementInstaller);
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\instrumentation\instrumentation.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Management.Instrumentation
{
    using System;
    using System.Collections;
    using System.Reflection;
    using System.Threading;
    using System.Runtime.InteropServices;
    using Microsoft.CSharp;
    using System.CodeDom.Compiler;
    using System.Management;
    using System.Security;
	using System.Security.Permissions;
    using System.Globalization;

    using WbemClient_v1;

	internal delegate void ProvisionFunction(Object o);

	class SecurityHelper
	{
		// BUG#112640
		// This is a global definition of an unmanaged code security permission to be used whereever we
		// want to do a full stack walk demand for the 'unmanaged code permission'
		internal static readonly SecurityPermission UnmanagedCode = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
	}

	/// <summary>
	///    <para> Provides helper functions for exposing events and data for management.
	///       There is a single instance of this class per application domain.</para>
	/// </summary>
	public class Instrumentation
    {
        [DllImport("kernel32.dll", CharSet=CharSet.Auto)]
        static extern int GetCurrentProcessId();

        // The processIdentity field and ProcessIdentity property provide
        // a string that should be globally unique accross on this machine.
        // NOTE: The 'ProcessIdentity' must be all lower case.  During object
        // retrival, we convert the keys to lower case and compare against
        // the ProcessIdentity.
        // ALTERNATIVE computation, but doesn't work for multi appdomains
        // - String.Format("{0}_{1:x16}", (uint)GetCurrentProcessId(), DateTime.Now.ToFileTime());
        static string processIdentity = null;
        static internal string ProcessIdentity
        {
            get
            {
                // Avoid double checked locking falacy
                lock(typeof(Instrumentation))
                {
                    if(null == processIdentity)
                        processIdentity = Guid.NewGuid().ToString().ToLower(CultureInfo.InvariantCulture);
                }
                return processIdentity;
            }
        }

        #region Public Members of Instrumentation class

        /// <summary>
        ///     <para>Registers the management instance or event classes in the specified assembly with WMI.  This ensures that the instrumentation schema is accessible to System.Management client applications.</para>
        /// </summary>
        /// <param name="assemblyToRegister"><para>The assembly containing instrumentation instance or event types.</para></param>
        public static void RegisterAssembly(Assembly assemblyToRegister)
        {
            // Check for valid argument
            if(null == assemblyToRegister)
                throw new ArgumentNullException("assemblyToRegister");

            // Force the schema to be registered if necessary
            GetInstrumentedAssembly(assemblyToRegister);
        }

        /// <summary>
        ///     <para>Determines if the instrumentation schema of the specified assembly has already been correctly registered with WMI.</para>
        /// </summary>
        /// <param name="assemblyToRegister"><para>The assembly containing instrumentation instance or event types.</para></param>
        /// <returns>
        ///     <para>true if the instrumentation schema in the specified assembly is registered with WMI; otherwise, false.</para>
        /// </returns>
        public static bool IsAssemblyRegistered(Assembly assemblyToRegister)
        {
            // Check for valid argument
            if(null == assemblyToRegister)
                throw new ArgumentNullException("assemblyToRegister");

            // See if we have already loaded this assembly in the current app domain
            lock(instrumentedAssemblies)
            {
                if(instrumentedAssemblies.ContainsKey(assemblyToRegister))
                    return true;
            }

            // See if the assembly is registered with WMI.  This will not force the
            // assembly to be registered, and will not load the dynamically generated
            // code if it is registered.
            SchemaNaming naming = SchemaNaming.GetSchemaNaming(assemblyToRegister);
            if(naming == null)
                return false;

            return naming.IsAssemblyRegistered();
        }
        
        /// <summary>
        ///    <para>Raises a management event.</para>
        /// </summary>
        /// <param name='eventData'>The object that determines the class, properties, and values of the event.</param>
        public static void Fire(Object eventData)
        {
            IEvent evt = eventData as IEvent;
            if(evt != null)
                evt.Fire();
            else
                GetFireFunction(eventData.GetType())(eventData);
        }

        /// <summary>
        ///    <para>Makes an instance visible through management instrumentation.</para>
        /// </summary>
        /// <param name='instanceData'>The instance that is to be visible through management instrumentation.</param>
        public static void Publish(Object instanceData)
        {
            Type t = instanceData as Type;
            Assembly assembly = instanceData as Assembly;
            IInstance instance = instanceData as IInstance;
            if(t != null)
            {
                // We were passed a 'type' to publish.  This is our cue to try to intall
                // the schema for the assembly that t belongs to
                GetInstrumentedAssembly(t.Assembly);
            }
            else if(assembly != null)
            {
                // We were passed an 'assembly' to publish.  This is our cue to try to intall
                // the schema for the assembly that t belongs to
                GetInstrumentedAssembly(assembly);
            }
            else if(instance != null)
            {
                instance.Published = true;
            }
            else
                GetPublishFunction(instanceData.GetType())(instanceData);
        }

        /// <summary>
        /// <para>Makes an instance that was previously published through the <see cref='System.Management.Instrumentation.Instrumentation.Publish'/>
        /// method no longer visible through management instrumentation.</para>
        /// </summary>
        /// <param name='instanceData'>The object to remove from visibility for management instrumentation.</param>
        public static void Revoke(Object instanceData)
        {
            IInstance instance = instanceData as IInstance;
            if(instance != null)
                instance.Published = false;
            else
                GetRevokeFunction(instanceData.GetType())(instanceData);
        }
	
		/// <summary>
		/// Specifies the maximum number of objects of the specified type to be provided at a time.
		/// </summary>
		/// <param name="instrumentationClass">The class for which the batch size is being set.</param>
		/// <param name="batchSize">The maximum number of objects to be provided at a time.</param>
        public static void SetBatchSize(Type instrumentationClass, int batchSize)
        {
            GetInstrumentedAssembly(instrumentationClass.Assembly).SetBatchSize(instrumentationClass, batchSize);
        }

        #endregion

        #region Non-Public Members of Instrumentation class

        internal static ProvisionFunction GetFireFunction(Type type)
        {
            return new ProvisionFunction(GetInstrumentedAssembly(type.Assembly).Fire);
        }

        internal static ProvisionFunction GetPublishFunction(Type type)
        {
            return new ProvisionFunction(GetInstrumentedAssembly(type.Assembly).Publish);
        }

        internal static ProvisionFunction GetRevokeFunction(Type type)
        {
            return new ProvisionFunction(GetInstrumentedAssembly(type.Assembly).Revoke);
        }

        private static Hashtable instrumentedAssemblies = new Hashtable();

        private static void Initialize(Assembly assembly)
        {
            lock(instrumentedAssemblies)
            {
                if(instrumentedAssemblies.ContainsKey(assembly))
                    return;

                SchemaNaming naming = SchemaNaming.GetSchemaNaming(assembly);
                if(naming == null)
                    return;

                if(false == naming.IsAssemblyRegistered())
                {
                    // If we are not an administrator, don't try to JIT install the schema
                    if(!WMICapabilities.IsUserAdmin())
                        throw new Exception(RC.GetString("ASSEMBLY_NOT_REGISTERED"));

                    naming.RegisterNonAssemblySpecificSchema(null);
                    naming.RegisterAssemblySpecificSchema();
                }

                InstrumentedAssembly instrumentedAssembly = new InstrumentedAssembly(assembly, naming);
                instrumentedAssemblies.Add(assembly, instrumentedAssembly);
            }
        }

		private static InstrumentedAssembly GetInstrumentedAssembly(Assembly assembly)
		{
            InstrumentedAssembly instrumentedAssembly;
            lock(instrumentedAssemblies)
            {
                if(false == instrumentedAssemblies.ContainsKey(assembly))
                    Initialize(assembly);
                instrumentedAssembly = (InstrumentedAssembly)instrumentedAssemblies[assembly];
            }
            return instrumentedAssembly;
		}

#if SUPPORTS_WMI_DEFAULT_VAULES
        internal static ProvisionFunction GetInitializeInstanceFunction(Type type)
		{
			return new ProvisionFunction(InitializeInstance);
		}

		private static void InitializeInstance(Object o)
		{
			Type type = o.GetType();
			string className = ManagedNameAttribute.GetClassName(type);
			SchemaNaming naming = InstrumentedAttribute.GetSchemaNaming(type.Assembly);
			ManagementClass theClass = new ManagementClass(naming.NamespaceName + ":" + className);
			foreach(FieldInfo field in type.GetFields())
			{
				Object val = theClass.Properties[ManagedNameAttribute.GetFieldName(field)].Value;
				if(null != val)
				{
					field.SetValue(o, val);
				}
			}
		}
#endif
        #endregion
    }

    delegate void ConvertToWMI(object obj);

    class InstrumentedAssembly
    {
        SchemaNaming naming;

		public EventSource source;

		private void InitEventSource(object param)
		{
			InstrumentedAssembly threadParam = (InstrumentedAssembly) param ;
			threadParam.source = new EventSource(threadParam.naming.NamespaceName, threadParam.naming.DecoupledProviderInstanceName, this);
		}

        public Hashtable mapTypeToConverter;

        public void FindReferences(Type type, CompilerParameters parameters)
        {
            parameters.ReferencedAssemblies.Add(type.Assembly.Location);

            // Add references for the base type
            if(type.BaseType != null && type.BaseType.Assembly != type.Assembly)
                FindReferences(type.BaseType, parameters);

            // Add references for implemented interfaces
            foreach(Type typeInterface in type.GetInterfaces())
            {
                if(typeInterface.Assembly != type.Assembly)
                    FindReferences(typeInterface, parameters);
            }
        }

        public InstrumentedAssembly(Assembly assembly, SchemaNaming naming)
        {
			SecurityHelper.UnmanagedCode.Demand(); // Bug#112640 - Close off any potential use from anything but fully trusted code
			this.naming = naming;

            Assembly compiledAssembly = naming.PrecompiledAssembly;
            if(null == compiledAssembly)
            {
                CSharpCodeProvider provider = new CSharpCodeProvider();
                ICodeCompiler compiler = provider.CreateCompiler();
                CompilerParameters parameters = new CompilerParameters();
                parameters.GenerateInMemory = true;
                parameters.ReferencedAssemblies.Add(assembly.Location);
                parameters.ReferencedAssemblies.Add(typeof(BaseEvent).Assembly.Location);
                parameters.ReferencedAssemblies.Add(typeof(System.ComponentModel.Component).Assembly.Location);

                // Must reference any base types in 'assembly'
                // TODO: Make this more restrictive.  Only look at instrumented types.
                foreach(Type type in assembly.GetTypes())
                    FindReferences(type, parameters);

                CompilerResults results = compiler.CompileAssemblyFromSource(parameters, naming.Code);
                foreach(CompilerError err in results.Errors)
                {
                    Console.WriteLine(err.ToString());
                }
                compiledAssembly = results.CompiledAssembly;
            }
            Type dynType = compiledAssembly.GetType("WMINET_Converter");
            mapTypeToConverter = (Hashtable)dynType.GetField("mapTypeToConverter").GetValue(null);

			// TODO: Is STA/MTA all we have to worry about?
			if(!MTAHelper.IsNoContextMTA())  // Bug#110141 - Checking for MTA is not enough.  We need to make sure we are not in a COM+ Context
			{
				ThreadDispatch disp = new ThreadDispatch ( new ThreadDispatch.ThreadWorkerMethodWithParam ( InitEventSource ) ) ;
				disp.Parameter = this ;
				disp.Start ( ) ;
				
				// We are on an STA thread.  Create the event source on an MTA
//				Thread thread = new Thread(new ThreadStart(InitEventSource));
//                thread.ApartmentState = ApartmentState.MTA;
//				thread.Start();
//				thread.Join();			
			}
			else
			{
				InitEventSource( this ) ;
			}
        }

		public void Fire(Object o)
		{
			SecurityHelper.UnmanagedCode.Demand(); // Bug#112640 - Close off any potential use from anything but fully trusted code
			Fire(o.GetType(), o);
		}



        public static ReaderWriterLock readerWriterLock = new ReaderWriterLock();
        public static Hashtable mapIDToPublishedObject = new Hashtable();
        static Hashtable mapPublishedObjectToID = new Hashtable();
        static int upcountId = 0x0EFF;
        public void Publish(Object o)
        {
			SecurityHelper.UnmanagedCode.Demand(); // Bug#112640 - Close off any potential use from anything but fully trusted code
			try
            {
                readerWriterLock.AcquireWriterLock(-1);
                if(mapPublishedObjectToID.ContainsKey(o))
                    return;// Bug#102932 - to make the same as IInstance, we do not throw new ArgumentException();
                mapIDToPublishedObject.Add(upcountId.ToString(), o);
                mapPublishedObjectToID.Add(o, upcountId);
                upcountId++;
            }
            finally
            {
                readerWriterLock.ReleaseWriterLock();
            }
        }

        public void Revoke(Object o)
        {
			SecurityHelper.UnmanagedCode.Demand(); // Bug#112640 - Close off any potential use from anything but fully trusted code
			try
            {
                readerWriterLock.AcquireWriterLock(-1);
                Object idObject = mapPublishedObjectToID[o];
                if(idObject == null)
                    return;// Bug#102932 - to make the same as IInstance, we do not throw new ArgumentException();
                int id = (int)idObject;
                mapPublishedObjectToID.Remove(o);
                mapIDToPublishedObject.Remove(id.ToString());
            }
            finally
            {
                readerWriterLock.ReleaseWriterLock();
            }
        }

        class TypeInfo
        {
			//
			// Reuters VSQFE#: 750	[marioh]
			// We store a reference to a fieldInfo that we use when updating the wbemojects pointer array.
			// Simply for efficiency reasons.
			//
			FieldInfo fieldInfo = null ;
			

            // Make ThreadLocal
            int batchSize = 64;//20;
            bool batchEvents = true;

            ConvertToWMI[] convertFunctionsBatch;
            ConvertToWMI convertFunctionNoBatch;
            IntPtr[] wbemObjects;
            Type converterType;


            int currentIndex = 0;

			//
			// [marioh, RAID: 123543]
			// Removed this member since no longer needed.
			// 
			//public object o;

            public EventSource source;

			//
			// [marioh, RAID: 123543]
			// Changed signature to account for sync problems.
			//
			public void Fire(object o)
			{
                if(source.Any())
                    return;

                if(!batchEvents)
                {
					// BUG#119210 - we need to lock this because we only have one
					// copy of wbemObjects[0] which is filled in by convertFunctionNoBatch
					lock(this)
					{
						convertFunctionNoBatch(o);

						//
						// Reuters VSQFE#: 750	[marioh]
						// At this point, the ToWMI method has been called and a new instance created.
						// We have to make sure the wbemObjects array (which is the array of IWbemClassObjects to be indicated)
						// is updated to point to the newly created instances.
						//
						wbemObjects[0] = (IntPtr) fieldInfo.GetValue ( convertFunctionNoBatch.Target ) ;
						source.IndicateEvents(1, wbemObjects);
					}
                }
                else
                {
                    lock(this)
                    {
                        convertFunctionsBatch[currentIndex++](o);
						
						//
						// Reuters VSQFE#: 750	[marioh]
						// At this point, the ToWMI method has been called and a new instance created.
						// We have to make sure the wbemObjects array (which is the array of IWbemClassObjects to be indicated)
						// is updated to point to the newly created instances.
						//
						wbemObjects[currentIndex-1] = (IntPtr) fieldInfo.GetValue ( convertFunctionsBatch[currentIndex-1].Target ) ;
                        if(cleanupThread == null)
                        {
                            int tickCount = Environment.TickCount;
                            if(tickCount-lastFire<1000)
                            {
                                cleanupThread = new Thread(new ThreadStart(Cleanup));
                                cleanupThread.ApartmentState = ApartmentState.MTA;
                                cleanupThread.Start();
                            }
                            else
                            {
                                source.IndicateEvents(currentIndex, wbemObjects);
                                currentIndex = 0;
                                lastFire = tickCount;
                            }
                        }
                        else if(currentIndex==batchSize)
                        {
                            source.IndicateEvents(currentIndex, wbemObjects);
                            currentIndex = 0;
                            lastFire = Environment.TickCount;
                        }
                    }
                }
            }


            public int lastFire = 0;

            public void SetBatchSize(int batchSize)
            {
				//
				// [RAID: 125526, marioh]
				// Check parameter validity before continuing.
				// Assumption: batchSize >= 1
				// Throws ArgumentOutOfRangeException if batchSize <= 0
				//
				if ( batchSize <= 0 )
				{
					throw new ArgumentOutOfRangeException ( ) ;
				}
                if(!WMICapabilities.MultiIndicateSupported)
                    batchSize = 1;
                lock(this)
                {
                    if(currentIndex > 0)
                    {
                        source.IndicateEvents(currentIndex, wbemObjects);
                        currentIndex = 0;
                        lastFire = Environment.TickCount;
                    }
                    wbemObjects = new IntPtr[batchSize];
                    if(batchSize > 1)
                    {
                        batchEvents = true;
                        this.batchSize = batchSize;

                        convertFunctionsBatch = new ConvertToWMI[batchSize];
                        for(int i=0;i<batchSize;i++)
                        {
                            Object converter = Activator.CreateInstance(converterType);
                            convertFunctionsBatch[i] = (ConvertToWMI)Delegate.CreateDelegate(typeof(ConvertToWMI), converter, "ToWMI");
                            wbemObjects[i] = ExtractIntPtr(converter);
                        }
						// Reuters VSQFE#: 750	[marioh] 
						// Initialize the FieldInfo used when refreshing instance pointers
						fieldInfo = convertFunctionsBatch[0].Target.GetType().GetField ("instWbemObjectAccessIP");
                    }
                    else
                    {
						// Reuters VSQFE#: 750	[marioh] 
						// Initialize the FieldInfo used when refreshing instance pointers
						fieldInfo = convertFunctionNoBatch.Target.GetType().GetField ("instWbemObjectAccessIP");
                        wbemObjects[0] = ExtractIntPtr(convertFunctionNoBatch.Target);
                        batchEvents = false;
                    }
                }
            }

            public IntPtr ExtractIntPtr(object o)
            {
                // return (IntPtr)o;
                return (IntPtr)o.GetType().GetField("instWbemObjectAccessIP").GetValue(o);
            }

            public void Cleanup()
            {
                int idleCount = 0;
                while(idleCount<20)
                {
                    Thread.Sleep(100);
                    if(0==currentIndex)
                    {
                        idleCount++;
                        continue;
                    }
                    idleCount = 0;
                    if((Environment.TickCount - lastFire)<100)
                        continue;
                    lock(this)
                    {
                        if(currentIndex>0)
                        {
                            source.IndicateEvents(currentIndex, wbemObjects);
                            currentIndex = 0;
                            lastFire = Environment.TickCount;
                        }
                    }
                }
                cleanupThread = null;
            }
            public Thread cleanupThread = null;

            public Type t;
            public TypeInfo(EventSource source, SchemaNaming naming, Type converterType)
            {
                this.converterType = converterType;
                this.source = source;

                Object converter = Activator.CreateInstance(converterType);
                convertFunctionNoBatch = (ConvertToWMI)Delegate.CreateDelegate(typeof(ConvertToWMI), converter, "ToWMI");

                // NOTE: wbemObjects[0] will get initialized in SetBatchSize if batchSize == 1

                SetBatchSize(batchSize);
			}
        }

        Hashtable mapTypeToTypeInfo = new Hashtable();

        public void SetBatchSize(Type t, int batchSize)
        {
            GetTypeInfo(t).SetBatchSize(batchSize);
        }

        TypeInfo lastTypeInfo = null;
        Type lastType = null;
        TypeInfo GetTypeInfo(Type t)
        {
            lock(mapTypeToTypeInfo)
            {
                if(lastType==t)
                    return lastTypeInfo;

                lastType = t;
                TypeInfo typeInfo = (TypeInfo)mapTypeToTypeInfo[t];
                if(null==typeInfo)
                {
                    typeInfo = new TypeInfo(source, naming, (Type)mapTypeToConverter[t]);
                    mapTypeToTypeInfo.Add(t, typeInfo);
                }
                lastTypeInfo = typeInfo;
                return typeInfo;
            }
        }

        public void Fire(Type t, Object o)
        {
            TypeInfo typeInfo = GetTypeInfo(t);

			//
			// [marioh, RAID: 123543]
			// Avoid race condition whereby the class member o is changed by multiple threads and can cause 
			// event corruption.
			//
			//typeInfo.o = o;
			typeInfo.Fire(o);		
		}
	}


    /// <summary>
    ///    <para>Specifies a source of a management instrumentation event. 
    ///       Objects that implement this interface are known to be sources of management
    ///       instrumentation events. Classes that do not derive from <see cref='System.Management.Instrumentation.BaseEvent'/> should implement
    ///       this interface instead.</para>
    /// </summary>
    public interface IEvent
    {
        /// <summary>
        ///    <para> 
        ///       Raises a management event.</para>
        /// </summary>
        void Fire();
    }

    /// <summary>
    ///    <para>Represents classes derived 
    ///       from <see cref='System.Management.Instrumentation.BaseEvent'/> that are known to be
    ///    management event classes. These derived classes inherit an implementation
    ///    of <see cref='System.Management.Instrumentation.IEvent'/> that allows events to be
    ///    fired through the <see cref='System.Management.Instrumentation.IEvent.Fire'/>
    ///    method.</para>
    /// </summary>
    /// <example>
    ///    <code lang='C#'>using System;
    /// using System.Management;
    /// using System.Configuration.Install;
    /// using System.Management.Instrumentation;
    /// 
    /// // This example demonstrates how to create a Management Event class by deriving
    /// // from BaseEvent class and to fire a Management Event from managed code.
    /// 
    /// // Specify which namespace the Manaegment Event class is created in
    /// [assembly:Instrumented("Root/Default")]
    /// 
    /// // Let the system know you will run InstallUtil.exe utility against
    /// // this assembly
    /// [System.ComponentModel.RunInstaller(true)]
    /// public class MyInstaller : DefaultManagementProjectInstaller {}
    /// 
    /// // Create a Management Instrumentation Event class
    /// public class MyEvent : BaseEvent
    /// {
    ///     public string EventName;
    /// }
    /// 
    /// public class Sample_EventProvider
    /// {
    ///     public static int Main(string[] args) {
    ///        MyEvent e = new MyEvent();
    ///        e.EventName = "Hello";
    ///        
    ///        // Fire the Management Event
    ///        e.Fire();
    ///        
    ///        return 0;
    ///     }
    /// }
    ///    </code>
    ///    <code lang='VB'>Imports System
    /// Imports System.Management
    /// Imports System.Configuration.Install
    /// Imports System.Management.Instrumentation
    /// 
    /// ' This sample demonstrates how to create a Management Event class by deriving
    /// ' from BaseEvent class and to fire a Management Event from managed code.
    /// 
    /// ' Specify which namespace the Manaegment Event class is created in
    /// &lt;assembly: Instrumented("Root/Default")&gt;
    /// 
    /// ' Let the system know InstallUtil.exe utility will be run against
    /// ' this assembly
    /// &lt;System.ComponentModel.RunInstaller(True)&gt; _
    /// Public Class MyInstaller
    ///     Inherits DefaultManagementProjectInstaller
    /// End Class
    /// 
    /// ' Create a Management Instrumentation Event class
    /// &lt;InstrumentationClass(InstrumentationType.Event)&gt; _ 
    /// Public Class MyEvent
    ///     Inherits BaseEvent
    ///     Public EventName As String
    /// End Class
    /// 
    /// Public Class Sample_EventProvider
    ///     Public Shared Function Main(args() As String) As Integer
    ///         Dim e As New MyEvent()
    ///         e.EventName = "Hello"
    /// 
    ///         ' Fire the Management Event
    ///         e.Fire()
    /// 
    ///         Return 0
    ///     End Function
    /// End Class
    ///    </code>
    /// </example>
    [InstrumentationClass(InstrumentationType.Event)]
    public abstract class BaseEvent : IEvent
	{
		private ProvisionFunction fireFunction = null;
		private ProvisionFunction FireFunction
		{
			get
			{
				if(null == fireFunction)
				{
					fireFunction = Instrumentation.GetFireFunction(this.GetType());
				}
				return fireFunction;
			}
		}

        /// <summary>
        ///    <para>Raises a management event.</para>
        /// </summary>
        public void Fire()
		{
			FireFunction(this);
		}
	}

    /// <summary>
    ///    <para>Specifies a source of a management instrumentation 
    ///       instance. Objects that implement this interface are known to be sources of
    ///       management instrumentation instances. Classes that do not derive from <see cref='System.Management.Instrumentation.Instance'/> should implement
    ///       this interface instead.</para>
    /// </summary>
    public interface IInstance
    {
        /// <summary>
        ///    Gets or sets a value indicating whether instances of
        ///    classes that implement this interface are visible through management
        ///    instrumentation.
        /// </summary>
        /// <value>
        /// <para><see langword='true'/>, if the 
        ///    instance is visible through management instrumentation; otherwise,
        /// <see langword='false'/>.</para>
        /// </value>
        bool Published
        {
            get;
            set;
        }
    }

    /// <summary>
    ///    <para> Represents derived classes known to be management 
    ///       instrumentation instance classes. These derived classes inherit an
    ///       implementation of <see cref='System.Management.Instrumentation.IInstance'/> that allows instances to be
    ///       published through the <see cref='System.Management.Instrumentation.IInstance.Published'/>
    ///       property.</para>
    /// </summary>
    /// <example>
    ///    <code lang='C#'>using System;
    /// using System.Management;
    /// using System.Configuration.Install;
    /// using System.Management.Instrumentation;
    /// 
    /// // This sample demonstrates how to create a Management Instrumentation Instance
    /// // class and how to publish an instance of this class to WMI.
    /// 
    /// // Specify which namespace the Instance class is created in
    /// [assembly:Instrumented("Root/Default")]
    /// 
    /// // Let the system know InstallUtil.exe utility will be run against
    /// // this assembly
    /// [System.ComponentModel.RunInstaller(true)]
    /// public class MyInstaller : DefaultManagementProjectInstaller {}
    /// 
    /// // Create a Management Instrumentation Instance class
    /// [InstrumentationClass(InstrumentationType.Instance)]
    /// public class InstanceClass : Instance
    /// {
    ///     public string SampleName;
    ///     public int SampleNumber;
    /// }
    /// 
    /// public class Sample_InstanceProvider
    /// {
    ///     public static int Main(string[] args) {
    ///         InstanceClass instClass = new InstanceClass();
    ///         instClass.SampleName = "Hello";
    ///         instClass.SampleNumber = 888;
    ///    
    ///         // Publish this instance to WMI
    ///         instClass.Published = true;
    ///    
    ///         return 0;
    ///     }
    /// }
    ///    </code>
    ///    <code lang='VB'>Imports System
    /// Imports System.Management
    /// Imports System.Configuration.Install
    /// Imports System.Management.Instrumentation
    /// 
    /// ' This sample demonstrate how to create a Management Instrumentation Instance
    /// ' class and how to publish an instance of this class to WMI.
    /// ' Specify which namespace the Instance class is created in
    /// &lt;assembly: Instrumented("Root/Default")&gt;
    /// 
    /// ' Let the system know InstallUtil.exe utility will be run against
    /// ' this assembly
    /// &lt;System.ComponentModel.RunInstaller(True)&gt;  _
    /// Public Class MyInstaller
    ///     Inherits DefaultManagementProjectInstaller
    /// End Class
    /// 
    /// ' Create a Management Instrumentation Instance class
    /// &lt;InstrumentationClass(InstrumentationType.Instance)&gt;  _
    /// Public Class InstanceClass
    ///     Inherits Instance
    ///     Public SampleName As String
    ///     Public SampleNumber As Integer
    /// End Class
    /// 
    /// Public Class Sample_InstanceProvider
    ///     Overloads Public Shared Function Main(args() As String) As Integer
    ///         Dim instClass As New InstanceClass()
    ///         instClass.SampleName = "Hello"
    ///         instClass.SampleNumber = 888
    /// 
    ///         ' Publish this instance to WMI
    ///         instClass.Published = True
    /// 
    ///         Return 0
    ///     End Function
    /// End Class
    ///    </code>
    /// </example>
    [InstrumentationClass(InstrumentationType.Instance)]
    public abstract class Instance : IInstance
    {
        private ProvisionFunction publishFunction = null;
        private ProvisionFunction revokeFunction = null;
        private ProvisionFunction PublishFunction
        {
            get
            {
                if(null == publishFunction)
                {
                    publishFunction = Instrumentation.GetPublishFunction(this.GetType());
                }
                return publishFunction;
            }
        }
        private ProvisionFunction RevokeFunction
        {
            get
            {
                if(null == revokeFunction)
                {
                    revokeFunction = Instrumentation.GetRevokeFunction(this.GetType());
                }
                return revokeFunction;
            }
        }
        private bool published = false;

		/// <summary>
		///    <para>Gets or sets a value indicating whether instances of classes that implement this interface are visible through management instrumentation.</para>
		/// </summary>
		/// <value>
		/// <para><see langword='true'/>, if the 
		///    instance is visible through management instrumentation; otherwise,
		/// <see langword='false'/>.</para>
		/// </value>
        [IgnoreMember]
		public bool Published
        {
            get
            {
                return published;
            }
            set
            {
                if(published && false==value)
                {
                    // We ARE published, and the caller is setting published to FALSE
                    RevokeFunction(this);
                    published = false;
                }
                else if(!published && true==value)
                {
                    // We ARE NOT published, and the caller is setting published to TRUE
                    PublishFunction(this);
                    published = true;
                }
            }
        }
    }
}

#if JEFF_WARNING_REMOVAL_TEST 
namespace System.Management
{
    class DoNothing
    {
        static void SayNothing()
        {
            tag_SWbemRpnConst w;
            w.unionhack = 0;

            tag_CompileStatusInfo x;
            x.lPhaseError = 0;
            x.hRes = 0;
            x.ObjectNum = 0;
            x.FirstLine = 0;
            x.LastLine = 0;
            x.dwOutFlags = 0;

            tag_SWbemQueryQualifiedName y;
            y.m_uVersion = 0;
            y.m_uTokenType = 0;
            y.m_uNameListSize = 0;
            y.m_ppszNameList = IntPtr.Zero;
            y.m_bArraysUsed = 0;
            y.m_pbArrayElUsed = IntPtr.Zero;
            y.m_puArrayIndex = IntPtr.Zero;

            tag_SWbemRpnQueryToken z;
            z.m_uVersion = 0;
            z.m_uTokenType = 0;
            z.m_uSubexpressionShape = 0;
            z.m_uOperator = 0;
            z.m_pRightIdent = IntPtr.Zero;
            z.m_pLeftIdent = IntPtr.Zero;
            z.m_uConstApparentType = 0;
            z.m_Const = w;
            z.m_uConst2ApparentType = 0;
            z.m_Const2 = w;
            z.m_pszRightFunc = "";
            z.m_pszLeftFunc = "";

            tag_SWbemRpnTokenList a;
            a.m_uVersion = 0;
            a.m_uTokenType = 0;
            a.m_uNumTokens = 0;

            tag_SWbemRpnEncodedQuery b;
            b.m_uVersion = 0;
            b.m_uTokenType = 0;
            b.m_uParsedFeatureMask1 = 0;
            b.m_uParsedFeatureMask2 = 0;
            b.m_uDetectedArraySize = 0;
            b.m_puDetectedFeatures = IntPtr.Zero;
            b.m_uSelectListSize = 0;
            b.m_ppSelectList = IntPtr.Zero;
            b.m_uFromTargetType = 0;
            b.m_pszOptionalFromPath = "";
            b.m_uFromListSize = 0;
            b.m_ppszFromList = IntPtr.Zero;
            b.m_uWhereClauseSize = 0;
            b.m_ppRpnWhereClause = IntPtr.Zero;
            b.m_dblWithinPolling = 0;
            b.m_dblWithinWindow = 0;
            b.m_uOrderByListSize = 0;
            b.m_ppszOrderByList = IntPtr.Zero;
            b.m_uOrderDirectionEl = IntPtr.Zero;

            tag_SWbemAnalysisMatrix c;
            c.m_uVersion = 0;
            c.m_uMatrixType = 0;
            c.m_pszProperty = "";
            c.m_uPropertyType = 0;
            c.m_uEntries = 0;
            c.m_pValues = IntPtr.Zero;
            c.m_pbTruthTable = IntPtr.Zero;

            tag_SWbemAnalysisMatrixList d;
            d.m_uVersion = 0;
            d.m_uMatrixType = 0;
            d.m_uNumMatrices = 0;
            d.m_pMatrices = IntPtr.Zero;

            tag_SWbemAssocQueryInf e;
            e.m_uVersion = 0;
            e.m_uAnalysisType = 0;
            e.m_uFeatureMask = 0;
            e.m_pPath = null;
            e.m_pszPath = "";
            e.m_pszQueryText = "";
            e.m_pszResultClass = "";
            e.m_pszAssocClass = "";
            e.m_pszRole = "";
            e.m_pszResultRole = "";
            e.m_pszRequiredQualifier = "";
            e.m_pszRequiredAssocQualifier = "";
        }
    }
}
#endif

#if xxxx

    /// <summary>
    ///    <para>[To be supplied.]</para>
    /// </summary>
    public static void SetField(Object inst, ISWbemProperty prop, FieldInfo field)
    {
        Object o = prop.get_Value();
        IConvertible i = (IConvertible)o;

        Type t2 = field.FieldType;

        if(t2 == typeof(SByte))
            o = i.ToSByte(null);
        else if(t2 == typeof(Byte))
            o = i.ToByte(null);
        else if(t2 == typeof(Int16))
            o = i.ToInt16(null);
        else if(t2 == typeof(UInt16))
            o = i.ToUInt16(null);
        else if(t2 == typeof(Int32))
            o = i.ToInt32(null);
        else if(t2 == typeof(UInt32))
            o = i.ToUInt32(null);
        else if(t2 == typeof(Int64))
            o = i.ToInt64(null);
        else if(t2 == typeof(UInt64))
            o = i.ToUInt64(null);
        else if(t2 == typeof(Single))
            o = i.ToSingle(null);
        else if(t2 == typeof(Double))
            o = i.ToDouble(null);
        else if(t2 == typeof(Boolean))
            o = i.ToBoolean(null);
        else if(t2 == typeof(String))
            o = i.ToString(null);
        else if(t2 == typeof(Char))
            o = i.ToChar(null);
        else if(t2 == typeof(DateTime))
//            o = i.ToDateTime(null);

        {/*Console.WriteLine(" NO CONVERSION TO DATETIME: "+o+" - "+o.GetType().Name);*/return;}
        else if(t2 == typeof(TimeSpan))
//            o = //i.To;
        {/*Console.WriteLine(" NO CONVERSION TO TIMESPAN: "+o+" - "+o.GetType().Name);*/return;}
        else if(t2 == typeof(Object))
            /*Nothing to do*/o = o;
        else
            throw new Exception("Unsupported type for default property - " + t2.Name);

        field.SetValue(inst, o);
    }

    /// <summary>
    ///    <para>[To be supplied.]</para>
    /// </summary>
    public static void SetProp(Object o, ISWbemProperty prop)
    {
        try
        {
            // TODO: FIX UP THIS MESS!!!!
            if(o == null)
                /*NOTHING TO DO*/o = o;
            else if(o.GetType() == typeof(DateTime))
            {
                DateTime dt = (DateTime)o;
                TimeSpan ts = dt.Subtract(dt.ToUniversalTime());
                int diffUTC = (ts.Minutes + ts.Hours * 60);
                if(diffUTC >= 0)
                    o = String.Format("{0:D4}{1:D2}{2:D2}{3:D2}{4:D2}{5:D2}.{6:D3}000+{7:D3}", new Object [] {dt.Year, dt.Month, dt.Day, dt.Hour, dt.Minute, dt.Second, dt.Millisecond, diffUTC});
                else
                    o = String.Format("{0:D4}{1:D2}{2:D2}{3:D2}{4:D2}{5:D2}.{6:D3}000-{7:D3}", new Object [] {dt.Year, dt.Month, dt.Day, dt.Hour, dt.Minute, dt.Second, dt.Millisecond, -diffUTC});
            }
            else if(o.GetType() == typeof(TimeSpan))
            {
                TimeSpan ts = (TimeSpan)o;
                o = String.Format("{0:D8}{1:D2}{2:D2}{3:D2}.{4:D3}000:000", new Object [] {ts.Days, ts.Hours, ts.Minutes, ts.Seconds, ts.Milliseconds});
            }
            else if(o.GetType() == typeof(char))
            {
                if(0 == (char)o)
                    o = (int)0;
                else
                  o=o.ToString();
            }

            prop.set_Value(ref o);
        }
        catch
        {
//            Console.WriteLine(prop.Name + " - "+o.GetType().Name + " - " + (o == null));
            o = o.ToString();
            prop.set_Value(ref o);
        }
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\test.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Cool source file
using System;
using System.WMI;
using System.IO;
//using Microsoft.Win32.Interop;

class WmiPlusTest
{
  public static int Main(String[] args)
  {

	TextWriter oldTW = null; //used to save old console.out for logging
	StreamWriter sw = null;  //used to redirect console.out to file for logging
    Console.WriteLine("WMI Plus Test Application");
   
	//validate arguments
	if ( ((args.Length != 0) && (args.Length != 2)) || ((args.Length == 2) && (args[0] != "/log")) ) 
    {
        Console.WriteLine("Usage: ... "); 
        return 0; 
    }
	
	//if "/log" specified, redirect Console.Out to log file
	if (args.Length > 0)
	{
		FileStream fs = new FileStream(args[1], FileMode.OpenOrCreate, FileAccess.ReadWrite); //open log file
		oldTW = Console.Out; //save default standard output
		sw = new StreamWriter(fs);
		Console.SetOut(sw); //replace with file
	}
	

	//Create a WmiPath object
	WmiPath Path = new WmiPath("root\\default");
	Console.WriteLine("String in WmiPath object is : {0}", Path.PathString);

	//Make a connection to this path
	WmiCollection Session = WmiCollection.Connect(Path);
//	WmiCollection Session = WmiCollection.Connect("root\\cimv2");
	
	//Get a class from this connection
	WmiObject ServiceClass = Session.Get(new WmiPath("MyStaticClass"));
	//Display the class name (__CLASS property of the class)
	Console.WriteLine("The name of this class is : {0}", ServiceClass["__CLASS"]);

	//Enumerate instances (static only because of security problem !!)
	WmiCollection Instances = Session.Open(new WmiPath("MyStaticClass"));
	foreach (WmiObject obj in Instances)
		Console.WriteLine("The key of this instance is : {0}", obj["MyProp"]);
    
	
//		WmiCollection Services = Session.Open("Win32_Service");		
//		foreach (WmiObject Service in Services)
//			Console.WriteLine("{0}", Service["Name"]);
//r	}
//r	catch (Exception e)
//r	{
//r		Console.WriteLine("Exception caught : {0}", e.Message);
//r	}
		

	//flush log file, and restore standard output if changed
	if (sw != null)
		sw.Flush();
	if (oldTW != null)
		Console.SetOut(oldTW);

	return 0;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\instrumentation\wmicapabilities.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.Management.Instrumentation
{
    using System;
    using System.IO;
    using System.Security.Principal;
    using Microsoft.Win32;
    using System.Diagnostics;
    using System.Globalization;

    internal class WMICapabilities
    {
        const string WMIKeyPath = @"Software\Microsoft\WBEM";
        const string WMINetKeyPath = @"Software\Microsoft\WBEM\.NET";
        const string WMICIMOMKeyPath = @"Software\Microsoft\WBEM\CIMOM";

        const string MultiIndicateSupportedValueNameVal = "MultiIndicateSupported";
        const string AutoRecoverMofsVal = "Autorecover MOFs";
        const string AutoRecoverMofsTimestampVal = "Autorecover MOFs timestamp";
        const string InstallationDirectoryVal = "Installation Directory";
        const string FrameworkSubDirectory = "Framework";

        /// <summary>
        /// Key to WMI.NET information
        /// </summary>
        static RegistryKey wmiNetKey = Registry.LocalMachine.OpenSubKey(WMINetKeyPath, false);

        static RegistryKey wmiKey = Registry.LocalMachine.OpenSubKey(WMIKeyPath, false);

        /// <summary>
        /// Indicates if IWbemObjectSink supports calls with multiple objects.
        /// On some versions of WMI, IWbemObjectSink will leak memory if
        /// Indicate is called with lObjectCount greater than 1.
        /// If the registry value,
        /// HKLM\Software\Microsoft\WBEM\.NET\MultiIndicateSupported
        /// exists and is non-zero, it is assumed that we can call Indicate
        /// with multiple objects.
        /// Allowed values
        /// -1 - We have not determined support for multi-indicate yet
        ///  0 - We do not support multi-indicate
        ///  1 - We support multi-indicate
        /// </summary>
        static int multiIndicateSupported = -1;
        static public bool MultiIndicateSupported
        {
            get
            {
                if(-1 == multiIndicateSupported)
                {
                    // Default multi-indicate support to what we think is
                    // possible based on the OS.
                    // This should be true for whistler, or Nova with FastProx.dll FilePrivatePart is >= 56.
                    multiIndicateSupported = MultiIndicatePossible()?1:0;

                    // See if there is a WMI.NET key
                    if(wmiNetKey != null)
                    {
                        // Try to get the 'MultiIndicateSupported' value
                        // Default to the default value in multiIndicateSupported
                        Object result = wmiNetKey.GetValue(MultiIndicateSupportedValueNameVal, multiIndicateSupported);

                        // The value should be a DWORD (returned as an 'int'), and is 1 if supported
                        if(result.GetType() == typeof(int) && (int)result==1)
                            multiIndicateSupported = 1;
                    }
                }
                return multiIndicateSupported == 1;
            }
        }

        static public void AddAutorecoverMof(string path)
        {
            RegistryKey wmiCIMOMKey = Registry.LocalMachine.OpenSubKey(WMICIMOMKeyPath, true);
            if(null != wmiCIMOMKey)
            {
                object mofsTemp = wmiCIMOMKey.GetValue(AutoRecoverMofsVal);
                string [] mofs = mofsTemp as string[];
                    if(null == mofs)
                    {
                        if(null != mofsTemp)
                        {
                            // Oh No!  We have a auto recover key, but it is not reg multistring
                            // We just give up
                            return;
                        }
                        mofs = new string[] {};
                    }

                // We ALWAYS update the autorecover timestamp
                wmiCIMOMKey.SetValue(AutoRecoverMofsTimestampVal, DateTime.Now.ToFileTime().ToString());

                // Look for path in existing autorecover key
                foreach(string mof in mofs)
                {
                    if(mof.ToLower(CultureInfo.InvariantCulture) == path.ToLower(CultureInfo.InvariantCulture))
                    {
                        // We already have this MOF
                        return;
                    }
                }

                // We have the array of strings.  Now, add a new one
                string [] newMofs = new string[mofs.Length+1];
                mofs.CopyTo(newMofs, 0);
                newMofs[newMofs.Length-1] = path;

                wmiCIMOMKey.SetValue(AutoRecoverMofsVal, newMofs);
                wmiCIMOMKey.SetValue(AutoRecoverMofsTimestampVal, DateTime.Now.ToFileTime().ToString());
            }
        }

        static string installationDirectory = null;
        public static string InstallationDirectory
        {
            get
            {
                if(null == installationDirectory && null != wmiKey)
                    installationDirectory = wmiKey.GetValue(InstallationDirectoryVal).ToString();
                return installationDirectory;
            }
        }

        public static string FrameworkDirectory
        {
            get
            {
                return Path.Combine(InstallationDirectory, FrameworkSubDirectory);
            }
        }

        public static bool IsUserAdmin()
        {
            // Bug#89083 - If we are on Win9x, we are always assumed to be an admin
            if(Environment.OSVersion.Platform == PlatformID.Win32Windows)
                return true;
            WindowsPrincipal principal = new WindowsPrincipal(WindowsIdentity.GetCurrent());
            return (principal.Identity.IsAuthenticated && principal.IsInRole(@"BUILTIN\Administrators"));
        }

        static bool IsNovaFile(FileVersionInfo info)
        {
            // A file is a Nova version if Major=1, Minor=50, and Build=1085
            return (    info.FileMajorPart==1
                &&  info.FileMinorPart==50
                &&  info.FileBuildPart==1085);
        }

        static bool MultiIndicatePossible()
        {
            // If we are on Whistler or above, we are OK
            // - Platform == Win32NT and OS version >= 5.1.0.0
            // - MajorVersion > 5 or (MajorVersion == 5 && MinorVersion > 0)
            OperatingSystem os = Environment.OSVersion;
            if(os.Platform==PlatformID.Win32NT &&  os.Version >= new Version(5, 1))
                return true;


            // We know that we can do multi-indicate if we are running Nova,
            // and the FastProx.dll FilePrivatePart is >= 56.
            string fastproxPath = Path.Combine(Environment.SystemDirectory, @"wbem\fastprox.dll");
            FileVersionInfo info = FileVersionInfo.GetVersionInfo(fastproxPath);
            if(IsNovaFile(info) && info.FilePrivatePart>=56)
                return true;

            return false;
        }

        public static bool IsWindowsXPOrHigher()
        {
            // If we are on Whistler or above, we are OK
            // - Platform == Win32NT and OS version >= 5.1.0.0
            // - MajorVersion > 5 or (MajorVersion == 5 && MinorVersion > 0)
            OperatingSystem os = Environment.OSVersion;
            if(os.Platform==PlatformID.Win32NT && os.Version >= new Version(5, 1))
                return true;
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\instrumentation\schemamapping.cs ===
//------------------------------------------------------------------------------
// <copyright from='1997' to='2001' company='Microsoft Corporation'>           
//    Copyright (c) Microsoft Corporation. All Rights Reserved.                
//    Information Contained Herein is Proprietary and Confidential.            
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Management.Instrumentation
{
    using System;
    using System.Reflection;
    using System.Management;
    using System.Collections;

    class SchemaMapping
    {
		Type classType;
        ManagementClass newClass;
        string className;
        string classPath;
        string codeClassName;
        CodeWriter code = new CodeWriter();

        public Type ClassType { get { return classType; } }
        public ManagementClass NewClass { get { return newClass; } }
        public string ClassName { get { return className; } }
        public string ClassPath { get { return classPath; } }
        public CodeWriter Code { get { return code; } }
        public string CodeClassName { get {return codeClassName; } }

        InstrumentationType instrumentationType;
        public InstrumentationType InstrumentationType { get { return instrumentationType; } }

        static public void ThrowUnsupportedMember(MemberInfo mi)
        {
            ThrowUnsupportedMember(mi, null);
        }
        static public void ThrowUnsupportedMember(MemberInfo mi, Exception innerException)
        {
            throw new ArgumentException(String.Format(RC.GetString("UNSUPPORTEDMEMBER_EXCEPT"), mi.Name), mi.Name, innerException);
        }
        public SchemaMapping(Type type, SchemaNaming naming, Hashtable mapTypeToConverterClassName)
        {
            codeClassName = (string)mapTypeToConverterClassName[type];
            classType = type;

            bool hasGenericEmbeddedObject = false;

            string baseClassName = ManagedNameAttribute.GetBaseClassName(type);
            className = ManagedNameAttribute.GetMemberName(type);
            instrumentationType = InstrumentationClassAttribute.GetAttribute(type).InstrumentationType;

            classPath = naming.NamespaceName + ":" + className;

            if(null == baseClassName)
            {
                newClass = new ManagementClass(naming.NamespaceName, "", null);
                newClass.SystemProperties ["__CLASS"].Value = className;
            }
            else
            {
                ManagementClass baseClass = new ManagementClass(naming.NamespaceName + ":" + baseClassName);
                if(instrumentationType == InstrumentationType.Instance)
                {
                    bool baseAbstract = false;
                    try
                    {
                        QualifierData o = baseClass.Qualifiers["abstract"];
                        if(o.Value is bool)
                            baseAbstract = (bool)o.Value;
                    }
                    catch(ManagementException e)
                    {
                        if(e.ErrorCode != ManagementStatus.NotFound)
                            throw;
                    }
                    if(!baseAbstract)
                        throw new Exception(RC.GetString("CLASSINST_EXCEPT"));

                }

                newClass = baseClass.Derive(className);
            }


            // Create the converter class
            CodeWriter codeClass = code.AddChild("public class "+codeClassName+" : IWmiConverter");

            // Create code block for one line Members
            CodeWriter codeOneLineMembers = codeClass.AddChild(new CodeWriter());
            codeOneLineMembers.Line("static ManagementClass managementClass = new ManagementClass(@\"" + classPath + "\");");
            codeOneLineMembers.Line("static IntPtr classWbemObjectIP;");
            codeOneLineMembers.Line("static Guid iidIWbemObjectAccess = new Guid(\"49353C9A-516B-11D1-AEA6-00C04FB68820\");");
            codeOneLineMembers.Line("internal ManagementObject instance = managementClass.CreateInstance();");
			codeOneLineMembers.Line("object reflectionInfoTempObj = null ; ");
			codeOneLineMembers.Line("FieldInfo reflectionIWbemClassObjectField = null ; ");
			codeOneLineMembers.Line("IntPtr emptyWbemObject = IntPtr.Zero ; ");
			
			//
			// Reuters VSQFE#: 750	[marioh] see comments above
			// Used as a temporary pointer to the newly created instance that we create to avoid re-using the same
			// object causing unbound memory usage in IWbemClassObject implementation.
			codeOneLineMembers.Line("IntPtr theClone = IntPtr.Zero;");
			codeOneLineMembers.Line("public static ManagementObject emptyInstance = managementClass.CreateInstance();");

			// TODO: Make these non-public
            codeOneLineMembers.Line("public IntPtr instWbemObjectAccessIP;");

            // Create static constructor to initialize handles
            CodeWriter codeCCTOR = codeClass.AddChild("static "+codeClassName+"()");
            codeCCTOR.Line("classWbemObjectIP = (IntPtr)managementClass;");
            codeCCTOR.Line("IntPtr wbemObjectAccessIP;");
            codeCCTOR.Line("Marshal.QueryInterface(classWbemObjectIP, ref iidIWbemObjectAccess, out wbemObjectAccessIP);");
            codeCCTOR.Line("int cimType;");
            
            // Create constructor
            CodeWriter codeCTOR = codeClass.AddChild("public "+codeClassName+"()");
            codeCTOR.Line("IntPtr wbemObjectIP = (IntPtr)instance;");
            codeCTOR.Line("Marshal.QueryInterface(wbemObjectIP, ref iidIWbemObjectAccess, out instWbemObjectAccessIP);");

			//
			// Reuters VSQFE#: 750	[marioh] 
			// In the CCTOR we set things up only once:
			//  1. We get the IWbemClassObjectFreeThreaded object '_wbemObject' from the ManagementObject instance
			//  2. We then get the actual IntPtr to the underlying WMI object
			//  3. Finally, the simple cast to IntPtr from the ManagementObject instance
			// These fields will be used later during the ToWMI call.
			codeCTOR.Line ("FieldInfo tempField = instance.GetType().GetField ( \"_wbemObject\", BindingFlags.Instance | BindingFlags.NonPublic );" );
			codeCTOR.Line("if ( tempField == null )");
			codeCTOR.Line("{");
			codeCTOR.Line("   tempField = instance.GetType().GetField ( \"wbemObject\", BindingFlags.Instance | BindingFlags.NonPublic ) ;");
			codeCTOR.Line("}");

			codeCTOR.Line ("reflectionInfoTempObj = tempField.GetValue (instance) ;");
			codeCTOR.Line("reflectionIWbemClassObjectField = reflectionInfoTempObj.GetType().GetField (\"pWbemClassObject\", BindingFlags.Instance | BindingFlags.NonPublic );");
			codeCTOR.Line("emptyWbemObject = (IntPtr) emptyInstance;");

			// Create destructor that will be called at process cleanup
            CodeWriter codeDTOR = codeClass.AddChild("~"+codeClassName+"()");
            codeDTOR.AddChild("if(instWbemObjectAccessIP != IntPtr.Zero)").Line("Marshal.Release(instWbemObjectAccessIP);");

            // Create method to convert from managed code to WMI
            CodeWriter codeToWMI = codeClass.AddChild("public void ToWMI(object obj)");

			//
			// Reuters VSQFE#: 750	[marioh] see comments above
			// Ensure the release of the WbemObjectAccess interface pointer.
			codeToWMI.Line( "if(instWbemObjectAccessIP != IntPtr.Zero)" ) ;
			codeToWMI.Line( "{" ) ;
			codeToWMI.Line("    Marshal.Release(instWbemObjectAccessIP);" ) ;
			codeToWMI.Line("    instWbemObjectAccessIP = IntPtr.Zero;" ) ;
			codeToWMI.Line( "}" ) ;

			codeToWMI.Line( "if(theClone != IntPtr.Zero)" ) ;
			codeToWMI.Line( "{" ) ;
			codeToWMI.Line("    Marshal.Release(theClone);" ) ;
			codeToWMI.Line("    theClone = IntPtr.Zero;" ) ;
			codeToWMI.Line( "}" ) ;

			codeToWMI.Line( "IWOA.Clone_f(12, emptyWbemObject, out theClone) ;" ) ;
			codeToWMI.Line( "Marshal.QueryInterface(theClone, ref iidIWbemObjectAccess, out instWbemObjectAccessIP) ;" ) ;
			codeToWMI.Line( "reflectionIWbemClassObjectField.SetValue ( reflectionInfoTempObj, theClone ) ;" ) ;

			codeToWMI.Line(String.Format("{0} instNET = ({0})obj;", type.FullName.Replace('+', '.'))); // bug#92918 - watch for nested classes

            // Explicit cast to IntPtr
            CodeWriter codeIntPtrCast = codeClass.AddChild("public static explicit operator IntPtr("+codeClassName+" obj)");
            codeIntPtrCast.Line("return obj.instWbemObjectAccessIP;");

            // Add GetInstance
            codeOneLineMembers.Line("public ManagementObject GetInstance() {return instance;}");

            PropertyDataCollection props = newClass.Properties;

            // type specific info
            switch(instrumentationType)
            {
                case InstrumentationType.Event:
                    break;
                case InstrumentationType.Instance:
                    props.Add("ProcessId", CimType.String, false);
                    props.Add("InstanceId", CimType.String, false);
                    props["ProcessId"].Qualifiers.Add("key", true);
                    props["InstanceId"].Qualifiers.Add("key", true);
                    newClass.Qualifiers.Add("dynamic", true, false, false, false, true);
                    newClass.Qualifiers.Add("provider", naming.DecoupledProviderInstanceName, false, false, false, true);
                    break;
                case InstrumentationType.Abstract:
                    newClass.Qualifiers.Add("abstract", true, false, false, false, true);
                    break;
                default:
                    break;
            }
			
            int propCount = 0;
            bool needsNullObj = false;
            foreach(MemberInfo field in type.GetMembers())
            {
                if(!(field is FieldInfo || field is PropertyInfo))
                    continue;

                if(field.GetCustomAttributes(typeof(IgnoreMemberAttribute), false).Length > 0)
                    continue;

                if(field is FieldInfo)
                {
                    FieldInfo fi = field as FieldInfo;

                    // We ignore statics
                    if(fi.IsStatic)
                        ThrowUnsupportedMember(field);
                }
                else if (field is PropertyInfo)
                {
                    PropertyInfo pi = field as PropertyInfo;
                    // We must have a 'get' property accessor
                    if(!pi.CanRead)
                        ThrowUnsupportedMember(field);

                    // We ignore static properties
                    MethodInfo mi = pi.GetGetMethod();
                    if(null == mi || mi.IsStatic)
                        ThrowUnsupportedMember(field);

                    // We don't support parameters on properties
                    if(mi.GetParameters().Length > 0)
                        ThrowUnsupportedMember(field);
                }
                
                String propName = ManagedNameAttribute.GetMemberName(field);


#if SUPPORTS_ALTERNATE_WMI_PROPERTY_TYPE
                Type t2 = ManagedTypeAttribute.GetManagedType(field);
#else
                Type t2;
                if(field is FieldInfo)
                    t2 = (field as FieldInfo).FieldType;
                else
                    t2 = (field as PropertyInfo).PropertyType;
#endif
                bool isArray = false;
                if(t2.IsArray)
                {
                    // We only support one dimensional arrays in this version
                    if(t2.GetArrayRank() != 1)
                        ThrowUnsupportedMember(field);

                    isArray = true;
                    t2 = t2.GetElementType();
                }

                string embeddedTypeName = null;
                string embeddedConverterName = null;
                if(mapTypeToConverterClassName.Contains(t2))
                {
                    embeddedConverterName = (string)mapTypeToConverterClassName[t2];
                    embeddedTypeName = ManagedNameAttribute.GetMemberName(t2);
                }

                bool isGenericEmbeddedObject = false;
                if(t2 == typeof(object))
                {
                    isGenericEmbeddedObject = true;
                    if(hasGenericEmbeddedObject == false)
                    {
                        hasGenericEmbeddedObject = true;
                        // Add map
                        codeOneLineMembers.Line("static Hashtable mapTypeToConverter = new Hashtable();");
                        foreach(DictionaryEntry entry in mapTypeToConverterClassName)
                        {
                            codeCCTOR.Line(String.Format("mapTypeToConverter[typeof({0})] = typeof({1});", ((Type)entry.Key).FullName.Replace('+', '.'), (string)entry.Value)); // bug#92918 - watch for nested classes
                        }
                    }

                }

                string propFieldName = "prop_" + (propCount);
                string handleFieldName = "handle_" + (propCount++);

                // Add handle for field, which is static accross all instances
                codeOneLineMembers.Line("static int " + handleFieldName + ";");
                codeCCTOR.Line(String.Format("IWOA.GetPropertyHandle_f27(27, wbemObjectAccessIP, \"{0}\", out cimType, out {1});", propName, handleFieldName));

                // Add PropertyData for field, which is specific to each instance
                codeOneLineMembers.Line("PropertyData " + propFieldName + ";");
                codeCTOR.Line(String.Format("{0} = instance.Properties[\"{1}\"];", propFieldName, propName));
				
				if(isGenericEmbeddedObject)
                {
                    CodeWriter codeNotNull = codeToWMI.AddChild(String.Format("if(instNET.{0} != null)", field.Name));
                    CodeWriter codeElse = codeToWMI.AddChild("else");
                    codeElse.Line(String.Format("{0}.Value = null;", propFieldName));
                    if(isArray)
                    {
                        codeNotNull.Line(String.Format("int len = instNET.{0}.Length;", field.Name));
                        codeNotNull.Line("ManagementObject[] embeddedObjects = new ManagementObject[len];");
                        codeNotNull.Line("IWmiConverter[] embeddedConverters = new IWmiConverter[len];");

                        CodeWriter codeForLoop = codeNotNull.AddChild("for(int i=0;i<len;i++)");

                        CodeWriter codeFoundType = codeForLoop.AddChild(String.Format("if((instNET.{0}[i] != null) && mapTypeToConverter.Contains(instNET.{0}[i].GetType()))", field.Name));
                        codeFoundType.Line(String.Format("Type type = (Type)mapTypeToConverter[instNET.{0}[i].GetType()];", field.Name));
                        codeFoundType.Line("embeddedConverters[i] = (IWmiConverter)Activator.CreateInstance(type);");
                        codeFoundType.Line(String.Format("embeddedConverters[i].ToWMI(instNET.{0}[i]);", field.Name));
                        codeFoundType.Line("embeddedObjects[i] = embeddedConverters[i].GetInstance();");

                        codeForLoop.AddChild("else").Line(String.Format("embeddedObjects[i] = SafeAssign.GetManagementObject(instNET.{0}[i]);", field.Name));

                        codeNotNull.Line(String.Format("{0}.Value = embeddedObjects;", propFieldName));
                    }
                    else
                    {
                        CodeWriter codeFoundType = codeNotNull.AddChild(String.Format("if(mapTypeToConverter.Contains(instNET.{0}.GetType()))", field.Name));
                        codeFoundType.Line(String.Format("Type type = (Type)mapTypeToConverter[instNET.{0}.GetType()];", field.Name));
                        codeFoundType.Line("IWmiConverter converter = (IWmiConverter)Activator.CreateInstance(type);");
                        codeFoundType.Line(String.Format("converter.ToWMI(instNET.{0});", field.Name));
                        codeFoundType.Line(String.Format("{0}.Value = converter.GetInstance();", propFieldName));

                        codeNotNull.AddChild("else").Line(String.Format("{0}.Value = SafeAssign.GetInstance(instNET.{1});", propFieldName, field.Name));
                    }
                }
                else if(embeddedTypeName != null)
                {
                    // If this is an embedded struct, it cannot be null
                    CodeWriter codeNotNull;
                    if(t2.IsValueType)
                        codeNotNull = codeToWMI;
                    else
                    {
                        codeNotNull = codeToWMI.AddChild(String.Format("if(instNET.{0} != null)", field.Name));
                        CodeWriter codeElse = codeToWMI.AddChild("else");
                        codeElse.Line(String.Format("{0}.Value = null;", propFieldName));
                    }

                    if(isArray)
                    {
                        codeNotNull.Line(String.Format("int len = instNET.{0}.Length;", field.Name));
                        codeNotNull.Line("ManagementObject[] embeddedObjects = new ManagementObject[len];");
                        codeNotNull.Line(String.Format("{0}[] embeddedConverters = new {0}[len];", embeddedConverterName));

                        CodeWriter codeForLoop = codeNotNull.AddChild("for(int i=0;i<len;i++)");
                        codeForLoop.Line(String.Format("embeddedConverters[i] = new {0}();", embeddedConverterName));

                        // If this is a struct array, the elements are never null
                        if(t2.IsValueType)
                        {
                            codeForLoop.Line(String.Format("embeddedConverters[i].ToWMI(instNET.{0}[i]);", field.Name));
                        }
                        else
                        {
                            CodeWriter codeArrayElementNotNull = codeForLoop.AddChild(String.Format("if(instNET.{0}[i] != null)", field.Name));
                            codeArrayElementNotNull.Line(String.Format("embeddedConverters[i].ToWMI(instNET.{0}[i]);", field.Name));
                        }
                        codeForLoop.Line("embeddedObjects[i] = embeddedConverters[i].instance;");

                        codeNotNull.Line(String.Format("{0}.Value = embeddedObjects;", propFieldName));
                    }
                    else
                    {

                        // We cannot create an instance of 'embeddedConverterName' because it may be the
                        // same type as we are defining (in other words, a cyclic loop, such as class XXX
                        // having an instance of an XXX as a member).  To prevent an infinite loop of constructing
                        // converter classes, we create a 'lazy' variable that is initialized to NULL, and the first
                        // time it is used, we set it to a 'new embeddedConverterName'.
                        codeOneLineMembers.Line(String.Format("{0} lazy_embeddedConverter_{1} = null;", embeddedConverterName, propFieldName));
                        CodeWriter codeConverterProp = codeClass.AddChild(String.Format("{0} embeddedConverter_{1}", embeddedConverterName, propFieldName));
                        CodeWriter codeGet = codeConverterProp.AddChild("get");
                        CodeWriter codeIf = codeGet.AddChild(String.Format("if(null == lazy_embeddedConverter_{0})", propFieldName));
                        codeIf.Line(String.Format("lazy_embeddedConverter_{0} = new {1}();", propFieldName, embeddedConverterName));
                        codeGet.Line(String.Format("return lazy_embeddedConverter_{0};", propFieldName));

                        codeNotNull.Line(String.Format("embeddedConverter_{0}.ToWMI(instNET.{1});", propFieldName, field.Name));
                        codeNotNull.Line(String.Format("{0}.Value = embeddedConverter_{0}.instance;", propFieldName));
                    }

                }
                else if(!isArray)
                {
                    if(t2 == typeof(Byte) || t2 == typeof(SByte))
                        codeToWMI.Line(String.Format("IWOA.WritePropertyValue_f28(28, instWbemObjectAccessIP, {0}, 1, ref instNET.{1});", handleFieldName, field.Name));
                    else if(t2 == typeof(Int16) || t2 == typeof(UInt16) || t2 == typeof(Char))
                        codeToWMI.Line(String.Format("IWOA.WritePropertyValue_f28(28, instWbemObjectAccessIP, {0}, 2, ref instNET.{1});", handleFieldName, field.Name));
                    else if(t2 == typeof(UInt32) || t2 == typeof(Int32) || t2 == typeof(Single))
                        codeToWMI.Line(String.Format("IWOA.WriteDWORD_f31(31, instWbemObjectAccessIP, {0}, instNET.{1});", handleFieldName, field.Name));
                    else if(t2 == typeof(UInt64) || t2 == typeof(Int64) || t2 == typeof(Double))
                        codeToWMI.Line(String.Format("IWOA.WriteQWORD_f33(33, instWbemObjectAccessIP, {0}, instNET.{1});", handleFieldName, field.Name));
                    else if(t2 == typeof(Boolean))
                    {
                        // TODO: Fix this to use IWOA
//                        codeToWMI.Line(String.Format("{0}.Value = instNET.{1};", propFieldName, field.Name));
                        codeToWMI.Line(String.Format("if(instNET.{0})", field.Name));
                        codeToWMI.Line(String.Format("    IWOA.WritePropertyValue_f28(28, instWbemObjectAccessIP, {0}, 2, ref SafeAssign.boolTrue);", handleFieldName));
                        codeToWMI.Line("else");
                        codeToWMI.Line(String.Format("    IWOA.WritePropertyValue_f28(28, instWbemObjectAccessIP, {0}, 2, ref SafeAssign.boolFalse);", handleFieldName));
                    }
                    else if(t2 == typeof(String))
                    {
                        CodeWriter codeQuickString = codeToWMI.AddChild(String.Format("if(null != instNET.{0})", field.Name));
                        codeQuickString.Line(String.Format("IWOA.WritePropertyValue_f28(28, instWbemObjectAccessIP, {0}, (instNET.{1}.Length+1)*2, instNET.{1});", handleFieldName, field.Name));
                        //                        codeToWMI.AddChild("else").Line(String.Format("{0}.Value = instNET.{1};", propFieldName, field.Name));
                        codeToWMI.AddChild("else").Line(String.Format("IWOA.Put_f5(5, instWbemObjectAccessIP, \"{0}\", 0, ref nullObj, 8);", propName));
                        if(needsNullObj == false)
                        {
                            needsNullObj = true;

                            // Bug#111623 - This line used to say 'nullObj = null;'  When nullObj was passed
                            // to IWOA.Put, this did NOT set the value of a string variable to NULL.  The correct
                            // thing to do was to pass a reference to DBNull.Value to IWOA.Put instead.
                            codeOneLineMembers.Line("object nullObj = DBNull.Value;");
                        }
                    }
                    else if(t2 == typeof(DateTime) || t2 == typeof(TimeSpan))
                    {
                        codeToWMI.Line(String.Format("IWOA.WritePropertyValue_f28(28, instWbemObjectAccessIP, {0}, 52, SafeAssign.WMITimeToString(instNET.{1}));", handleFieldName, field.Name));
                        //                        codeToWMI.Line(String.Format("{0}.Value = SafeAssign.DateTimeToString(instNET.{1});", propFieldName, field.Name));
                    }
                    else
                        codeToWMI.Line(String.Format("{0}.Value = instNET.{1};", propFieldName, field.Name));
                }
                else
                {
                    // We have an array type
                    if(t2 == typeof(DateTime) || t2 == typeof(TimeSpan))
                    {
                        codeToWMI.AddChild(String.Format("if(null == instNET.{0})", field.Name)).Line(String.Format("{0}.Value = null;", propFieldName));
                        codeToWMI.AddChild("else").Line(String.Format("{0}.Value = SafeAssign.WMITimeArrayToStringArray(instNET.{1});", propFieldName, field.Name));
                    }
                    else
                    {
                        // This handles arrays of all primative types
                        codeToWMI.Line(String.Format("{0}.Value = instNET.{1};", propFieldName, field.Name));
                    }
                }


                CimType cimtype = CimType.String;

                if(field.DeclaringType != type)
                    continue;


#if REQUIRES_EXPLICIT_DECLARATION_OF_INHERITED_PROPERTIES
                if(InheritedPropertyAttribute.GetAttribute(field) != null)
                    continue;
#else
                // See if this field already exists on the WMI class
                // In other words, is it inherited from a base class
                // TODO: Make this more efficient
                //  - If we have a null base class name, all property names
                //    should be new
                //  - We could get all base class property names into a
                //    hashtable, and look them up from there
                bool propertyExists = true;
                try
                {
                    PropertyData prop = newClass.Properties[propName];
                    // HACK for bug#96863 - The above line used to throw a
                    // not found exception.  This was changed with a recent
                    // checkin.  If this functionality is not reverted, the
                    // following statement should force the necessary 'not
                    // found' exception that we are looking for.
                    CimType cimType = prop.Type;

                    // Make sure that if the property exists, it is inherited
                    // If it is local, they probably named two properties with
                    // the same name
					if(prop.IsLocal)
					{
						throw new ArgumentException(String.Format(RC.GetString("MEMBERCONFLILCT_EXCEPT"), field.Name), field.Name);
					}
                }
                catch(ManagementException e)
                {
                    if(e.ErrorCode != ManagementStatus.NotFound)
                        throw;
                    else
                        propertyExists = false;
                }
                if(propertyExists)
                    continue;
#endif


                if(embeddedTypeName != null)
                    cimtype = CimType.Object;
                else if(isGenericEmbeddedObject)
                    cimtype = CimType.Object;
                else if(t2 == typeof(ManagementObject))
                    cimtype = CimType.Object;
                else if(t2 == typeof(SByte))
                    cimtype = CimType.SInt8;
                else if(t2 == typeof(Byte))
                    cimtype = CimType.UInt8;
                else if(t2 == typeof(Int16))
                    cimtype = CimType.SInt16;
                else if(t2 == typeof(UInt16))
                    cimtype = CimType.UInt16;
                else if(t2 == typeof(Int32))
                    cimtype = CimType.SInt32;
                else if(t2 == typeof(UInt32))
                    cimtype = CimType.UInt32;
                else if(t2 == typeof(Int64))
                    cimtype = CimType.SInt64;
                else if(t2 == typeof(UInt64))
                    cimtype = CimType.UInt64;
                else if(t2 == typeof(Single))
                    cimtype = CimType.Real32;
                else if(t2 == typeof(Double))
                    cimtype = CimType.Real64;
                else if(t2 == typeof(Boolean))
                    cimtype = CimType.Boolean;
                else if(t2 == typeof(String))
                    cimtype = CimType.String;
                else if(t2 == typeof(Char))
                    cimtype = CimType.Char16;
                else if(t2 == typeof(DateTime))
                    cimtype = CimType.DateTime;
                else if(t2 == typeof(TimeSpan))
                    cimtype = CimType.DateTime;
                else
                    ThrowUnsupportedMember(field);
// HACK: The following line cause a strange System.InvalidProgramException when run through InstallUtil
//				throw new Exception("Unsupported type for event member - " + t2.Name);


//              TODO: if(t2 == typeof(Decimal))

#if SUPPORTS_WMI_DEFAULT_VAULES
                Object defaultValue = ManagedDefaultValueAttribute.GetManagedDefaultValue(field);

                // TODO: Is it safe to make this one line?
                if(null == defaultValue)
                    props.Add(propName, cimtype, false);
                else
                    props.Add(propName, defaultValue, cimtype);
#else
                try
                {
                    props.Add(propName, cimtype, isArray);
                }
                catch(ManagementException e)
                {
                    ThrowUnsupportedMember(field, e);
                }
#endif

                // Must at 'interval' SubType on TimeSpans
                if(t2 == typeof(TimeSpan))
                {
                    PropertyData prop = props[propName];
                    prop.Qualifiers.Add("SubType", "interval", false, true, true, true);
                }

                if(embeddedTypeName != null)
                {
                    PropertyData prop = props[propName];
                    prop.Qualifiers["CIMTYPE"].Value = "object:"+embeddedTypeName;
                }
            }
            codeCCTOR.Line("Marshal.Release(wbemObjectAccessIP);");
//            codeToWMI.Line("Console.WriteLine(instance.GetText(TextFormat.Mof));");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\assocclass\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\asp+\processes\webform1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Processes
{
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Management;

/// <summary>
///    Summary description for WebForm1.
/// </summary>
public class WebForm1 : System.Web.UI.Page
{
	public ListBox ListBox1;
	private ManagementObjectSearcher searcher;
		
    protected void Page_Load(object sender, EventArgs e)
    {
        if (!IsPostBack)
        {
            //
            // Evals true first time browser hits the page
            //
			searcher = new ManagementObjectSearcher (new InstanceEnumerationQuery("Win32_Process"));
        }

		ListItemCollection items = ListBox1.Items;

		foreach (ManagementObject process in searcher.Get()) {
			items.Add ((string)process["Name"]);
		}
    }

    protected override void Init()
    {
        //
        // CODEGEN: This call is required by the ASP+ WFC Form Designer.
        //
        InitializeComponent();
    }

    /// <summary>
    ///    Required method for Designer support - do not modify
    ///    the contents of this method with the code editor
    /// </summary>
    private void InitializeComponent()
	{
		
		
		
		
		
	}
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\assocclass\class1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace assocClass
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		ManagementClass c = new ManagementClass ("CIM_Setting");

		foreach (ManagementClass cc in c.GetRelatedClasses ())
		{
			Console.WriteLine (cc.ClassPath);
		}

        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\asp+\processes\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\test1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Cool source file
using System;
using System.WMI;
using System.IO;

class WmiPlusTest
{
  public static int Main()
  {

	System.Diagnostics.TraceSwitch MySwitch = new System.Diagnostics.TraceSwitch("MySwitch",null);
    MySwitch.Level=System.Diagnostics.TraceLevel.Verbose;

    Console.WriteLine("WMI COM+ Test Application");
   
	
	//Create a WmiPath object
	WmiPath Path = new WmiPath("root\\cimv2");
	Console.WriteLine("String in WmiPath object is : {0}", Path.PathString);

	//Make a connection to this path
	WmiCollection Session = WmiCollection.Connect(Path);
	
	//Get a class from this connection
	WmiObject ServiceClass = Session.Get(new WmiPath("Win32_LogicalDisk"));
	//WmiObject ServiceClass = Session.Get("Win32_LogicalDisk");
	//Display the class name (__CLASS property of the class)
	Console.WriteLine("The name of this class is : {0}", ServiceClass["__CLASS"]);

	//Enumerate instances 
	WmiCollection Instances = Session.Open(new WmiPath("Win32_LogicalDisk"));
	foreach (WmiObject obj in Instances)
		Console.WriteLine("The key of this instance is : {0}", obj["Name"]);
    
	//Query
	WmiCollection QueryRes = Session.Query(new WmiQuery("select * from Win32_Service"));
	foreach (WmiObject Service in QueryRes)
		Console.WriteLine("{0}", Service["Name"]);

	return 0;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\asynctest1\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\classcreate\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\src\instrumentation\schemaregistration.cs ===
//------------------------------------------------------------------------------
// <copyright from='1997' to='2001' company='Microsoft Corporation'>           
//    Copyright (c) Microsoft Corporation. All Rights Reserved.                
//    Information Contained Herein is Proprietary and Confidential.            
// </copyright>                                                                
//------------------------------------------------------------------------------

// TODO: Better logging to context of InstallUtil
namespace System.Management.Instrumentation
{
    using System;
    using System.Reflection;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Configuration.Install;
    using System.Management;
    using Microsoft.Win32;
    using System.IO;
    using System.Text;
    using System.Runtime.InteropServices;
	using System.Globalization;
	
    class SchemaNaming
    {

        class InstallLogWrapper
        {
            InstallContext context = null;
            public InstallLogWrapper(InstallContext context)
            {
                this.context = context;
            }
            public void LogMessage(string str)
            {
                if(null != context)
                    context.LogMessage(str);
            }
        }

        public static SchemaNaming GetSchemaNaming(Assembly assembly)
        {
            InstrumentedAttribute attr = InstrumentedAttribute.GetAttribute(assembly);

            // See if this assembly provides instrumentation
            if(null == attr)
                return null;

            return new SchemaNaming(attr.NamespaceName, attr.SecurityDescriptor, assembly);
        }

        Assembly assembly;
        SchemaNaming(string namespaceName, string securityDescriptor, Assembly assembly)
        {
            this.assembly = assembly;
            assemblyInfo = new AssemblySpecificNaming(namespaceName, securityDescriptor, assembly);
        }

        ///////////////////////////////////////////
        // string constants
        const string Win32ProviderClassName = "__Win32Provider";
        const string EventProviderRegistrationClassName = "__EventProviderRegistration";
        const string InstanceProviderRegistrationClassName = "__InstanceProviderRegistration";
        const string DecoupledProviderClassName = "MSFT_DecoupledProvider";
        const string ProviderClassName = "WMINET_ManagedAssemblyProvider";
        const string InstrumentationClassName = "WMINET_Instrumentation";
        const string InstrumentedAssembliesClassName = "WMINET_InstrumentedAssembly";
        const string DecoupledProviderCLSID = "{54D8502C-527D-43f7-A506-A9DA075E229C}";
        const string GlobalWmiNetNamespace = @"root\MicrosoftWmiNet";
        const string InstrumentedNamespacesClassName = "WMINET_InstrumentedNamespaces";
        const string NamingClassName = "WMINET_Naming";


        ///////////////////////////////////////////
        // class that holds read only naming info
        // specific to an assembly
        private class AssemblySpecificNaming
        {
            public AssemblySpecificNaming(string namespaceName, string securityDescriptor, Assembly assembly)
            {
                this.namespaceName = namespaceName;
                this.securityDescriptor = securityDescriptor;
                this.decoupledProviderInstanceName = AssemblyNameUtility.UniqueToAssemblyMinorVersion(assembly);
                this.assemblyUniqueIdentifier = AssemblyNameUtility.UniqueToAssemblyBuild(assembly);
                this.assemblyName = assembly.GetName().FullName;
                this.assemblyPath = assembly.Location;
            }

            string namespaceName;
            string securityDescriptor;
            string decoupledProviderInstanceName;
            string assemblyUniqueIdentifier;
            string assemblyName;
            string assemblyPath;

            public string NamespaceName {get {return namespaceName;} }
            public string SecurityDescriptor {get {return securityDescriptor;} }
            public string DecoupledProviderInstanceName {get {return decoupledProviderInstanceName;} }
            public string AssemblyUniqueIdentifier {get {return assemblyUniqueIdentifier;} }
            public string AssemblyName {get {return assemblyName;} }
            public string AssemblyPath {get {return assemblyPath;} }
        }

        ///////////////////////////////////////////
        // Accessors for name information
        // After these methods, there should be no
        // use of the lower case names
        AssemblySpecificNaming assemblyInfo;

        public string NamespaceName {get {return assemblyInfo.NamespaceName;} }
        public string SecurityDescriptor {get {return assemblyInfo.SecurityDescriptor;} }
        public string DecoupledProviderInstanceName {get {return assemblyInfo.DecoupledProviderInstanceName;} }
        string AssemblyUniqueIdentifier {get {return assemblyInfo.AssemblyUniqueIdentifier;} }
        string AssemblyName {get {return assemblyInfo.AssemblyName;} }
        string AssemblyPath {get {return assemblyInfo.AssemblyPath;} }

        string Win32ProviderClassPath {get {return MakeClassPath(assemblyInfo.NamespaceName, Win32ProviderClassName);} }
        string DecoupledProviderClassPath {get {return MakeClassPath(assemblyInfo.NamespaceName, DecoupledProviderClassName);} }
        string InstrumentationClassPath {get {return MakeClassPath(assemblyInfo.NamespaceName, InstrumentationClassName);} }
        string EventProviderRegistrationClassPath {get {return MakeClassPath(assemblyInfo.NamespaceName, EventProviderRegistrationClassName);} }
        string EventProviderRegistrationPath {get {return AppendProperty(EventProviderRegistrationClassPath, "provider", @"\\\\.\\"+ProviderPath.Replace(@"\", @"\\").Replace(@"""", @"\"""));} }
        string InstanceProviderRegistrationClassPath {get {return MakeClassPath(assemblyInfo.NamespaceName, InstanceProviderRegistrationClassName);} }
        string InstanceProviderRegistrationPath {get {return AppendProperty(InstanceProviderRegistrationClassPath, "provider", @"\\\\.\\"+ProviderPath.Replace(@"\", @"\\").Replace(@"""", @"\"""));} }

        string ProviderClassPath {get {return MakeClassPath(assemblyInfo.NamespaceName, ProviderClassName);} }
        string ProviderPath {get {return AppendProperty(ProviderClassPath, "Name", assemblyInfo.DecoupledProviderInstanceName);} }
        string RegistrationClassPath {get {return MakeClassPath(assemblyInfo.NamespaceName, InstrumentedAssembliesClassName);} }
        string RegistrationPath {get {return AppendProperty(RegistrationClassPath, "Name", assemblyInfo.DecoupledProviderInstanceName);} }

        string GlobalRegistrationNamespace {get {return GlobalWmiNetNamespace;} }
        string GlobalInstrumentationClassPath {get {return MakeClassPath(GlobalWmiNetNamespace, InstrumentationClassName);} }
        string GlobalRegistrationClassPath {get {return MakeClassPath(GlobalWmiNetNamespace, InstrumentedNamespacesClassName);} }
        string GlobalRegistrationPath {get {return AppendProperty(GlobalRegistrationClassPath, "NamespaceName", assemblyInfo.NamespaceName.Replace(@"\", @"\\"));} }
        string GlobalNamingClassPath {get {return MakeClassPath(GlobalWmiNetNamespace, NamingClassName);} }

        string DataDirectory {get {return Path.Combine(WMICapabilities.FrameworkDirectory, NamespaceName);} }
        string MofPath {get {return Path.Combine(DataDirectory, DecoupledProviderInstanceName + ".mof");} }
        string CodePath {get {return Path.Combine(DataDirectory, DecoupledProviderInstanceName + ".cs");} }
        string PrecompiledAssemblyPath {get {return Path.Combine(DataDirectory, DecoupledProviderInstanceName + ".dll");} }

        static string MakeClassPath(string namespaceName, string className)
        {
            return namespaceName + ":" + className;
        }

        static string AppendProperty(string classPath, string propertyName, string propertyValue)
        {
            return classPath+'.'+propertyName+"=\""+propertyValue+'\"';
        }

        public bool IsAssemblyRegistered()
        {
            if(DoesInstanceExist(RegistrationPath))
            {
                ManagementObject inst = new ManagementObject(RegistrationPath);
//                return (0==AssemblyUniqueIdentifier.ToLower(CultureInfo.InvariantCulture).CompareTo(inst["RegisteredBuild"].ToString().ToLower()));
                return (0==String.Compare(AssemblyUniqueIdentifier,inst["RegisteredBuild"].ToString(),true,CultureInfo.InvariantCulture));
            }
            return false;
        }

        ManagementObject registrationInstance = null;
        ManagementObject RegistrationInstance
        {
            get
            {
                if(null == registrationInstance)
                    registrationInstance = new ManagementObject(RegistrationPath);
                return registrationInstance;
            }
        }

        public string Code
        {
            get
            {
                using(StreamReader reader = new StreamReader(CodePath))
                {
                    return reader.ReadToEnd();
                }
            }
        }

		public string Mof
		{
			get
			{
				using(StreamReader reader = new StreamReader(MofPath))
				{
					return reader.ReadToEnd();
				}
			}
		}

        public Assembly PrecompiledAssembly
        {
            get
            {
                if(File.Exists(PrecompiledAssemblyPath))
                    return Assembly.LoadFrom(PrecompiledAssemblyPath);
                return null;
            }
        }

        string GenerateMof(string [] mofs)
        {
            return String.Concat(
                "//**************************************************************************\r\n",
                String.Format("//* {0}\r\n", DecoupledProviderInstanceName),
                String.Format("//* {0}\r\n", AssemblyUniqueIdentifier),
                "//**************************************************************************\r\n",
                "#pragma autorecover\r\n",
                EnsureNamespaceInMof(GlobalRegistrationNamespace),
                EnsureNamespaceInMof(NamespaceName),

                PragmaNamespace(GlobalRegistrationNamespace),
                GetMofFormat(new ManagementClass(GlobalInstrumentationClassPath)),
                GetMofFormat(new ManagementClass(GlobalRegistrationClassPath)),
                GetMofFormat(new ManagementClass(GlobalNamingClassPath)),
                GetMofFormat(new ManagementObject(GlobalRegistrationPath)),

                PragmaNamespace(NamespaceName),
                GetMofFormat(new ManagementClass(InstrumentationClassPath)),
                GetMofFormat(new ManagementClass(RegistrationClassPath)),
                GetMofFormat(new ManagementClass(DecoupledProviderClassPath)),
                GetMofFormat(new ManagementClass(ProviderClassPath)),

                GetMofFormat(new ManagementObject(ProviderPath)),
//                events.Count>0?GetMofFormat(new ManagementObject(EventProviderRegistrationPath)):"",
                GetMofFormat(new ManagementObject(EventProviderRegistrationPath)),
                GetMofFormat(new ManagementObject(InstanceProviderRegistrationPath)),

                String.Concat(mofs),

                GetMofFormat(new ManagementObject(RegistrationPath)) );
        }

        [DllImport("wminet_utils.dll", PreserveSig=false)] static extern void VerifyClientKey();

        public void RegisterNonAssemblySpecificSchema(InstallContext installContext)
        {
			SecurityHelper.UnmanagedCode.Demand(); // Bug#112640 - Close off any potential use from anything but fully trusted code
			
			// Make sure the 'Client' key has the correct permissions
            VerifyClientKey();

            InstallLogWrapper context = new InstallLogWrapper(installContext);

            EnsureNamespace(context, GlobalRegistrationNamespace);

            EnsureClassExists(context, GlobalInstrumentationClassPath, new ClassMaker(MakeGlobalInstrumentationClass));

            EnsureClassExists(context, GlobalRegistrationClassPath, new ClassMaker(MakeNamespaceRegistrationClass));

            EnsureClassExists(context, GlobalNamingClassPath, new ClassMaker(MakeNamingClass));

            EnsureNamespace(context, NamespaceName);

            EnsureClassExists(context, InstrumentationClassPath, new ClassMaker(MakeInstrumentationClass));

            EnsureClassExists(context, RegistrationClassPath, new ClassMaker(MakeRegistrationClass));

            // Make sure Hosting model is set correctly by default.  If not, we blow away the class definition
            try
            {
                ManagementClass cls = new ManagementClass(DecoupledProviderClassPath);
                if(cls["HostingModel"].ToString() != "Decoupled:Com")
                {
                    cls.Delete();
                }
            }
            catch(ManagementException e)
            {
                if(e.ErrorCode != ManagementStatus.NotFound)
                    throw e;
            }

            EnsureClassExists(context, DecoupledProviderClassPath, new ClassMaker(MakeDecoupledProviderClass));

            EnsureClassExists(context, ProviderClassPath, new ClassMaker(MakeProviderClass));

            if(!DoesInstanceExist(GlobalRegistrationPath))
                RegisterNamespaceAsInstrumented();
        }

        public void RegisterAssemblySpecificSchema()
        {
			SecurityHelper.UnmanagedCode.Demand(); // Bug#112640 - Close off any potential use from anything but fully trusted code
			Type[] types = InstrumentedAttribute.GetInstrumentedTypes(assembly);

            StringCollection events = new StringCollection();
            StringCollection instances = new StringCollection();
            StringCollection abstracts = new StringCollection();

            string[] mofs = new string[types.Length];
            CodeWriter code = new CodeWriter();
            ReferencesCollection references = new ReferencesCollection();

            // Add the node with all the 'using' statements at the top
            code.AddChild(references.UsingCode);
            references.Add(typeof(Object));
            references.Add(typeof(ManagementClass));
            references.Add(typeof(Marshal));
            references.Add(typeof(System.Security.SuppressUnmanagedCodeSecurityAttribute));
			references.Add(typeof(System.Reflection.FieldInfo));
            references.Add(typeof(Hashtable));

            // Add a blank line
            code.Line();

            // Add master converter class
            CodeWriter codeWMIConverter = code.AddChild("public class WMINET_Converter");
            
            // Add master map of types to converters
            codeWMIConverter.Line("public static Hashtable mapTypeToConverter = new Hashtable();");
          
            // Add master CCTOR
            CodeWriter codeCCTOR = codeWMIConverter.AddChild("static WMINET_Converter()");

            // Make mapping of types to converter class names
            Hashtable mapTypeToConverterClassName = new Hashtable();
            for(int i=0;i<types.Length;i++)
                mapTypeToConverterClassName[types[i]] = "ConvertClass_" + i;

            for(int i=0;i<types.Length;i++)
            {
                SchemaMapping mapping = new SchemaMapping(types[i], this, mapTypeToConverterClassName);

                codeCCTOR.Line(String.Format("mapTypeToConverter[typeof({0})] = typeof({1});", mapping.ClassType.FullName.Replace('+', '.'), mapping.CodeClassName));  // bug#92918 - watch for nested classes

                ReplaceClassIfNecessary(mapping.ClassPath, mapping.NewClass);
                mofs[i] = GetMofFormat(mapping.NewClass);
                code.AddChild(mapping.Code);
                switch(mapping.InstrumentationType)
                {
                    case InstrumentationType.Event:
                        events.Add(mapping.ClassName);
                        break;
                    case InstrumentationType.Instance:
                        instances.Add(mapping.ClassName);
                        break;
                    case InstrumentationType.Abstract:
                        abstracts.Add(mapping.ClassName);
                        break;
                    default:
                        break;
                }
            }

            RegisterAssemblySpecificDecoupledProviderInstance();
            RegisterProviderAsEventProvider(events);
            RegisterProviderAsInstanceProvider();

            RegisterAssemblyAsInstrumented();

            Directory.CreateDirectory(DataDirectory);

            using(StreamWriter log = new StreamWriter(CodePath, false, Encoding.Unicode))
            {
                log.WriteLine(code);
                log.WriteLine(iwoaDef);
            }

            // Always generate the MOF in unicode
            using(StreamWriter log = new StreamWriter(MofPath, false, Encoding.Unicode))
            {
                log.WriteLine(GenerateMof(mofs));
            }
			RegisterSchemaUsingMofcomp ( MofPath ) ;
            //WMICapabilities.AddAutorecoverMof(MofPath);
        }
        const string iwoaDef = 
@"class IWOA
{
protected const string DllName = ""wminet_utils.dll"";
protected const string EntryPointName = ""UFunc"";
[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] public static extern int GetPropertyHandle_f27(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszPropertyName, [Out] out Int32 pType, [Out] out Int32 plHandle);
//[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] public static extern int WritePropertyValue_f28(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Int32 lNumBytes, [In] ref Byte aData);
[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] public static extern int ReadPropertyValue_f29(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Int32 lBufferSize, [Out] out Int32 plNumBytes, [Out] out Byte aData);
[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] public static extern int ReadDWORD_f30(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [Out] out UInt32 pdw);
[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] public static extern int WriteDWORD_f31(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] UInt32 dw);
[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] public static extern int ReadQWORD_f32(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [Out] out UInt64 pqw);
[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] public static extern int WriteQWORD_f33(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] UInt64 pw);
[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] public static extern int GetPropertyInfoByHandle_f34(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [Out][MarshalAs(UnmanagedType.BStr)]  out string   pstrName, [Out] out Int32 pType);
[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] public static extern int Lock_f35(int vFunc, IntPtr pWbemClassObject, [In] Int32 lFlags);
[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] public static extern int Unlock_f36(int vFunc, IntPtr pWbemClassObject, [In] Int32 lFlags);

[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] public static extern int Put_f5(int vFunc, IntPtr pWbemClassObject, [In][MarshalAs(UnmanagedType.LPWStr)]  string   wszName, [In] Int32 lFlags, [In] ref object pVal, [In] Int32 Type);
[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] public static extern int WritePropertyValue_f28(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Int32 lNumBytes, [In][MarshalAs(UnmanagedType.LPWStr)] string str);
[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] public static extern int WritePropertyValue_f28(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Int32 lNumBytes, [In] ref Byte n);
[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] public static extern int WritePropertyValue_f28(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Int32 lNumBytes, [In] ref SByte n);
[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] public static extern int WritePropertyValue_f28(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Int32 lNumBytes, [In] ref Int16 n);
[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] public static extern int WritePropertyValue_f28(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Int32 lNumBytes, [In] ref UInt16 n);
[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName, CharSet=CharSet.Unicode)] public static extern int WritePropertyValue_f28(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Int32 lNumBytes, [In] ref Char c);
[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] public static extern int WriteDWORD_f31(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Int32 dw);
[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] public static extern int WriteDWORD_f31(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Single dw);
[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] public static extern int WriteQWORD_f33(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Int64 pw);
[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] public static extern int WriteQWORD_f33(int vFunc, IntPtr pWbemClassObject, [In] Int32 lHandle, [In] Double pw);
[SuppressUnmanagedCodeSecurity, DllImport(DllName, EntryPoint=EntryPointName)] public static extern int Clone_f(int vFunc, IntPtr pWbemClassObject, [Out] out IntPtr ppCopy);
}
interface IWmiConverter
{
    void ToWMI(object obj);
    ManagementObject GetInstance();
}
class SafeAssign
{
    public static UInt16 boolTrue = 0xffff;
    public static UInt16 boolFalse = 0;
    static Hashtable validTypes = new Hashtable();
    static SafeAssign()
    {
        validTypes.Add(typeof(SByte), null);
        validTypes.Add(typeof(Byte), null);
        validTypes.Add(typeof(Int16), null);
        validTypes.Add(typeof(UInt16), null);
        validTypes.Add(typeof(Int32), null);
        validTypes.Add(typeof(UInt32), null);
        validTypes.Add(typeof(Int64), null);
        validTypes.Add(typeof(UInt64), null);
        validTypes.Add(typeof(Single), null);
        validTypes.Add(typeof(Double), null);
        validTypes.Add(typeof(Boolean), null);
        validTypes.Add(typeof(String), null);
        validTypes.Add(typeof(Char), null);
        validTypes.Add(typeof(DateTime), null);
        validTypes.Add(typeof(TimeSpan), null);
        validTypes.Add(typeof(ManagementObject), null);
        nullClass.SystemProperties [""__CLASS""].Value = ""nullInstance"";
    }
    public static object GetInstance(object o)
    {
        if(o is ManagementObject)
            return o;
        return null;
    }
    static ManagementClass nullClass = new ManagementClass();
    
    public static ManagementObject GetManagementObject(object o)
    {
        if(o != null && o is ManagementObject)
            return o as ManagementObject;
        // Must return empty instance
        return nullClass.CreateInstance();
    }
    public static object GetValue(object o)
    {
        Type t = o.GetType();
        if(t.IsArray)
            t = t.GetElementType();
        if(validTypes.Contains(t))
            return o;
        return null;
    }
    public static string WMITimeToString(DateTime dt)
    {
        TimeSpan ts = dt.Subtract(dt.ToUniversalTime());
        int diffUTC = (ts.Minutes + ts.Hours * 60);
        if(diffUTC >= 0)
            return String.Format(""{0:D4}{1:D2}{2:D2}{3:D2}{4:D2}{5:D2}.{6:D3}000+{7:D3}"", dt.Year, dt.Month, dt.Day, dt.Hour, dt.Minute, dt.Second, dt.Millisecond, diffUTC);
        return String.Format(""{0:D4}{1:D2}{2:D2}{3:D2}{4:D2}{5:D2}.{6:D3}000-{7:D3}"", dt.Year, dt.Month, dt.Day, dt.Hour, dt.Minute, dt.Second, dt.Millisecond, -diffUTC);
    }
    public static string WMITimeToString(TimeSpan ts)
    {
        return String.Format(""{0:D8}{1:D2}{2:D2}{3:D2}.{4:D3}000:000"", ts.Days, ts.Hours, ts.Minutes, ts.Seconds, ts.Milliseconds);
    }
    public static string[] WMITimeArrayToStringArray(DateTime[] dates)
    {
        string[] strings = new string[dates.Length];
        for(int i=0;i<dates.Length;i++)
            strings[i] = WMITimeToString(dates[i]);
        return strings;
    }
    public static string[] WMITimeArrayToStringArray(TimeSpan[] timeSpans)
    {
        string[] strings = new string[timeSpans.Length];
        for(int i=0;i<timeSpans.Length;i++)
            strings[i] = WMITimeToString(timeSpans[i]);
        return strings;
    }
}
";


        ///////////////////////////////////////////
        // Functions that create instances for the
        // registration of various objects
        void RegisterNamespaceAsInstrumented()
        {
            ManagementClass registrationClass = new ManagementClass(GlobalRegistrationClassPath);
            ManagementObject inst = registrationClass.CreateInstance();
            inst["NamespaceName"] = NamespaceName;
            inst.Put();
        }

        void RegisterAssemblyAsInstrumented()
        {
            ManagementClass registrationClass = new ManagementClass(RegistrationClassPath);
            ManagementObject inst = registrationClass.CreateInstance();
            inst["Name"] = DecoupledProviderInstanceName;
            inst["RegisteredBuild"] = AssemblyUniqueIdentifier;
            inst["FullName"] = AssemblyName;
            inst["PathToAssembly"] = AssemblyPath;
            inst["Code"] = "";
            inst["Mof"] = "";
            inst.Put();
        }

        void RegisterAssemblySpecificDecoupledProviderInstance()
        {
            ManagementClass providerClass = new ManagementClass(ProviderClassPath);
            ManagementObject inst = providerClass.CreateInstance();
            inst["Name"] = DecoupledProviderInstanceName;
            inst["HostingModel"] = "Decoupled:Com"; // TODO : SHOULD NOT NEED
            if(null != SecurityDescriptor)
                inst["SecurityDescriptor"] = SecurityDescriptor;
            inst.Put();
        }

        string RegisterProviderAsEventProvider(StringCollection events)
        {
            // TODO: Hanlde no events with MOF generation
//            if(events.Count == 0)
//                return null;

            ManagementClass providerRegistrationClass = new ManagementClass(EventProviderRegistrationClassPath);
            ManagementObject inst = providerRegistrationClass.CreateInstance();
            inst["provider"] = "\\\\.\\"+ProviderPath;
            string [] queries = new string[events.Count];
            int iCur = 0;
            foreach(string eventName in events)
                queries[iCur++] = "select * from "+eventName;

            inst["EventQueryList"] = queries;
            return inst.Put().Path;
        }

        string RegisterProviderAsInstanceProvider()
        {
            ManagementClass providerRegistrationClass = new ManagementClass(InstanceProviderRegistrationClassPath);
            ManagementObject inst = providerRegistrationClass.CreateInstance();
            inst["provider"] = "\\\\.\\"+ProviderPath;
            inst["SupportsGet"] = true;
            inst["SupportsEnumeration"] = true;
            return inst.Put().Path;
        }

        ///////////////////////////////////////////
        // Functions that create Class prototypes

        delegate ManagementClass ClassMaker();

        ManagementClass MakeNamingClass()
        {
            ManagementClass baseClass = new ManagementClass(GlobalInstrumentationClassPath);
            ManagementClass newClass = baseClass.Derive(NamingClassName);
            newClass.Qualifiers.Add("abstract", true);
            PropertyDataCollection props = newClass.Properties;
            props.Add("InstrumentedAssembliesClassName", InstrumentedAssembliesClassName, CimType.String);
            return newClass;
        }
        
        ManagementClass MakeInstrumentationClass()
        {
            ManagementClass newClass = new ManagementClass(NamespaceName, "", null);
            newClass.SystemProperties ["__CLASS"].Value = InstrumentationClassName;
            newClass.Qualifiers.Add("abstract", true);
            return newClass;
        }

        ManagementClass MakeGlobalInstrumentationClass()
        {
            ManagementClass newClass = new ManagementClass(GlobalWmiNetNamespace, "", null);
            newClass.SystemProperties ["__CLASS"].Value = InstrumentationClassName;
            newClass.Qualifiers.Add("abstract", true);
            return newClass;
        }

        ManagementClass MakeRegistrationClass()
        {
            ManagementClass baseClass = new ManagementClass(InstrumentationClassPath);
            ManagementClass newClass = baseClass.Derive(InstrumentedAssembliesClassName);
            PropertyDataCollection props = newClass.Properties;
            props.Add("Name", CimType.String, false);
            PropertyData prop = props["Name"];
            prop.Qualifiers.Add("key", true);
            props.Add("RegisteredBuild", CimType.String, false);
            props.Add("FullName", CimType.String, false);
            props.Add("PathToAssembly", CimType.String, false);
            props.Add("Code", CimType.String, false);
            props.Add("Mof", CimType.String, false);
            return newClass;
        }

        ManagementClass MakeNamespaceRegistrationClass()
        {
            ManagementClass baseClass = new ManagementClass(GlobalInstrumentationClassPath);
            ManagementClass newClass = baseClass.Derive(InstrumentedNamespacesClassName);
            PropertyDataCollection props = newClass.Properties;
            props.Add("NamespaceName", CimType.String, false);
            PropertyData prop = props["NamespaceName"];
            prop.Qualifiers.Add("key", true);
            return newClass;
        }

        ManagementClass MakeDecoupledProviderClass()
        {
            ManagementClass baseClass = new ManagementClass(Win32ProviderClassPath);
            ManagementClass newClass = baseClass.Derive(DecoupledProviderClassName);
            PropertyDataCollection props = newClass.Properties;
            props.Add("HostingModel", "Decoupled:Com", CimType.String);
            props.Add("SecurityDescriptor", CimType.String, false);
            props.Add("Version", 1, CimType.UInt32);
            props["CLSID"].Value = DecoupledProviderCLSID;
            return newClass;
        }

        ManagementClass MakeProviderClass()
        {
            ManagementClass baseClass = new ManagementClass(DecoupledProviderClassPath);
            ManagementClass newClass = baseClass.Derive(ProviderClassName);
            PropertyDataCollection props = newClass.Properties;
            props.Add("Assembly", CimType.String, false);
            return newClass;
        }

        ///////////////////////////////////////////
        // WMI Helper Functions

		//
		// [RAID#143683, marioh] This method was added to register the instrumentation schema by forking 
		// mofcomp.exe rather than simply writing it directly to the repository. The reason for this is
		// a change in .NET server that requires MOF files to be compiled using mofcomp in order to be
		// autorecoverable. It is no longer possible to do by directly accessing the autorecover key in the
		// registry (due to security considerations).
		//
		// Note: Due to code design, we are using mofcomp IN ADDITION to writing directly to the repository.
		//
		static void RegisterSchemaUsingMofcomp ( string mofPath )
		{
			System.Diagnostics.ProcessStartInfo processInfo = new System.Diagnostics.ProcessStartInfo ( ) ;
			processInfo.Arguments = mofPath ;
			processInfo.FileName = WMICapabilities.InstallationDirectory+"\\mofcomp.exe" ;
			processInfo.UseShellExecute = false ;
			processInfo.RedirectStandardOutput = true ;

			System.Diagnostics.Process proc = System.Diagnostics.Process.Start ( processInfo ) ;
			proc.WaitForExit ( ) ;
		}

        static void EnsureNamespace(string baseNamespace, string childNamespaceName)
        {
            if(!DoesInstanceExist(baseNamespace + ":__NAMESPACE.Name=\""+childNamespaceName+"\""))
            {
                ManagementClass namespaceClass = new ManagementClass(baseNamespace + ":__NAMESPACE");
                ManagementObject inst = namespaceClass.CreateInstance();
                inst["Name"] = childNamespaceName;
                inst.Put();
            }
        }

        static void EnsureNamespace(InstallLogWrapper context, string namespaceName)
        {
            context.LogMessage(RC.GetString("NAMESPACE_ENSURE")+ " " +namespaceName);

            string fullNamespace = null;
            foreach(string name in namespaceName.Split(new char[] {'\\'}))
            {
                if(fullNamespace == null)
                {
                    fullNamespace = name;
                    continue;
                }
                EnsureNamespace(fullNamespace, name);
                fullNamespace += "\\" + name;
            }
        }

        static void EnsureClassExists(InstallLogWrapper context, string classPath, ClassMaker classMakerFunction)
        {
            try
            {
                context.LogMessage(RC.GetString("CLASS_ENSURE") + " " +classPath);
                ManagementClass theClass = new ManagementClass(classPath);
                theClass.Get();
            }
            catch(ManagementException e)
            {
                if(e.ErrorCode == ManagementStatus.NotFound)
                {
                    // The class does not exist.  Create it.
                    context.LogMessage(RC.GetString("CLASS_ENSURECREATE")+ " " +classPath);
                    ManagementClass theClass = classMakerFunction();
                    theClass.Put();
                }
                else
                    throw e;
            }
        }

        static bool DoesInstanceExist(string objectPath)
        {
            bool exists = false;
            try
            {
                ManagementObject inst = new ManagementObject(objectPath);
                inst.Get();
                exists = true;
            }
            catch(ManagementException e)
            {
                if(     ManagementStatus.InvalidNamespace != e.ErrorCode
                    &&  ManagementStatus.InvalidClass != e.ErrorCode
                    &&  ManagementStatus.NotFound != e.ErrorCode
                    )
                    throw e;
            }
            return exists;
        }

        /// <summary>
        /// Given a class path, this function will return the ManagementClass
        /// if it exists, or null if it does not.
        /// </summary>
        /// <param name="classPath">WMI path to Class</param>
        /// <returns></returns>
        static ManagementClass SafeGetClass(string classPath)
        {
            ManagementClass theClass = null;
            try
            {
                ManagementClass existingClass = new ManagementClass(classPath);
                existingClass.Get();
                theClass = existingClass;
            }
            catch(ManagementException e)
            {
                if(e.ErrorCode != ManagementStatus.NotFound)
                    throw e;
            }
            return theClass;
        }

        /// <summary>
        /// Given a class path, and a ManagementClass class definition, this
        /// function will create the class if it does not exist, replace the
        /// class if it exists but is different, or do nothing if the class
        /// exists and is identical.  This is useful for performance reasons
        /// since it can be expensive to delete an existing class and replace
        /// it.
        /// </summary>
        /// <param name="classPath">WMI path to class</param>
        /// <param name="newClass">Class to create or replace</param>
        static void ReplaceClassIfNecessary(string classPath, ManagementClass newClass)
        {
            try
            {
                ManagementClass oldClass = SafeGetClass(classPath);
                if(null == oldClass)
                    newClass.Put();
                else
                {
                    // TODO: Figure Out Why CompareTo does not work!!!
                    //                if(false == newClass.CompareTo(newClass, ComparisonSettings.IgnoreCase | ComparisonSettings.IgnoreObjectSource))
                    if(newClass.GetText(TextFormat.Mof) != oldClass.GetText(TextFormat.Mof))
                    {
                        // TODO: Log to context?
                        oldClass.Delete();
                        newClass.Put();
                    }
                }
            }
            catch(ManagementException e)
            {
				string strformat = RC.GetString("CLASS_NOTREPLACED_EXCEPT") + "\r\n{0}\r\n{1}";
                throw new ArgumentException(String.Format(strformat, classPath, newClass.GetText(TextFormat.Mof)), e);
            }
        }

        static string GetMofFormat(ManagementObject obj)
        {
            return obj.GetText(TextFormat.Mof).Replace("\n", "\r\n") + "\r\n";
        }

        static string PragmaNamespace(string namespaceName)
        {
            return String.Format("#pragma namespace(\"\\\\\\\\.\\\\{0}\")\r\n\r\n", namespaceName.Replace("\\", "\\\\"));
        }

        static string EnsureNamespaceInMof(string baseNamespace, string childNamespaceName)
        {
            return String.Format("{0}instance of __Namespace\r\n{{\r\n  Name = \"{1}\";\r\n}};\r\n\r\n", PragmaNamespace(baseNamespace), childNamespaceName);
        }

        static string EnsureNamespaceInMof(string namespaceName)
        {
            string mof="";
            string fullNamespace = null;
            foreach(string name in namespaceName.Split(new char[] {'\\'}))
            {
                if(fullNamespace == null)
                {
                    fullNamespace = name;
                    continue;
                }
                mof+=EnsureNamespaceInMof(fullNamespace, name);
                fullNamespace += "\\" + name;
            }
            return mof;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\classenum\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\classqualifierenum\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\collection1\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\classcreate\class1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace ClassCreate
{
using System;
using System.Management;
using System.Runtime.InteropServices;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

	public static string ArrayToString (Array value)
	{
		System.Text.StringBuilder str = new System.Text.StringBuilder ();

		foreach (object o in value)
			str.Append (o + " ");

		return str.ToString ();
	}

	public static string ObjectArrayToString (Array value)
	{
		System.Text.StringBuilder str = new System.Text.StringBuilder ();

		foreach (ManagementBaseObject o in value)
			str.Append (o.GetText(TextFormat.Mof) + "\r\n");

		return str.ToString ();
	}

	public static int Main(string[] args)
    {
		// Ensure we delete any previous copies of the class and its subclasses
		try {
			ManagementClass testSubClass = new ManagementClass ("root/default:URTNEWSUBCLASS");
			testSubClass.Delete ();
		} catch (ManagementException) {}
		try {
			ManagementClass testClass = new ManagementClass ("root/default:URTNEWCLASS");
			testClass.Delete ();
		} catch (ManagementException) {}

		// Get an empty class
        ManagementClass emptyClass = new ManagementClass ("root/default", "", null);

		// Set the class name
		emptyClass.SystemProperties ["__CLASS"].Value = "URTNEWCLASS";

		// Add some qualifiers
		QualifierCollection qualSet = emptyClass.Qualifiers;

		qualSet.Add ("sint32", (int)132235);
		qualSet.Add ("string", "Floxihoxibellification");
		qualSet.Add ("real64", (double)-12.33434234);
		qualSet.Add ("boolean", true);
		qualSet.Add ("sint32Array", new int[] {1, 2, 3}, false, true, false, true);
		qualSet.Add ("stringArray", new string[] {"il", "spezzio"}, false, false, false, false);
		qualSet.Add ("real64Array", new double[] {1.2, -1.3}, true, true, true, true);
		qualSet.Add ("booleanArray", new bool[] {false, true}, true, false, true, true);

		Console.WriteLine ("sint32: " + qualSet["sint32"].Value);
		Console.WriteLine ("string: " + qualSet["string"].Value);
		Console.WriteLine ("real64: " + qualSet["real64"].Value);
		Console.WriteLine ("boolean: " + qualSet["boolean"].Value);
		Console.WriteLine ("sint32Array: " + ArrayToString((Array)qualSet["sint32Array"].Value));
		Console.WriteLine ("stringArray: " + ArrayToString((Array)qualSet["stringArray"].Value));
		Console.WriteLine ("real64Array: " + ArrayToString((Array)qualSet["real64Array"].Value));
		Console.WriteLine ("booleanArray: " + ArrayToString((Array)qualSet["booleanArray"].Value));

		// Add some properties
		PropertyCollection propSet = emptyClass.Properties;

		// Use the simple Add that selects the right type
		propSet.Add ("uint8", (byte)10);
		propSet.Add ("uint16", (ushort)10);
		propSet.Add ("uint32", (uint)10);
		propSet.Add ("uint32x", (int) 11);
		propSet.Add ("uint32xx", (UInt32)123);
		propSet.Add ("uint32xxx", "12");
		propSet.Add ("uint64", (ulong)10);
		propSet.Add ("sint8", (sbyte)10);
		propSet.Add ("sint16", (short)10);
		propSet.Add ("sint32", (int)10);
		propSet.Add ("sint64", (long)10);
		propSet.Add ("bool", true);
		propSet.Add ("string", "Wibble");
		propSet.Add ("real32", (float) 10.23);
		propSet.Add ("real64", (double) 11.2222);

		ManagementClass embeddedClass = new ManagementClass ("root/default", "", null);
		embeddedClass.SystemProperties ["__CLASS"].Value = "URTEMBEDDEDCLASS";
		propSet.Add ("object", embeddedClass);

		// For datetime/reference types, use the non-default Add
		propSet.Add ("datetime", "20000728044535.000000-420" ,CimType.DateTime);
		propSet.Add ("reference", "foo=10", CimType.Reference);

		// Echo the non-null property values
		Console.WriteLine ("uint8: " + emptyClass["uint8"]);
		Console.WriteLine ("uint16: " + emptyClass["uint16"]);
		Console.WriteLine ("uint32: " + emptyClass["uint32"]);
		Console.WriteLine ("uint32x: " + emptyClass["uint32x"]);
		Console.WriteLine ("uint32xx: " + emptyClass["uint32xx"]);
		Console.WriteLine ("uint32xxx: " + emptyClass["uint32xxx"]);
		Console.WriteLine ("uint64: " + emptyClass["uint64"]);
		Console.WriteLine ("sint8: " + emptyClass["sint8"]);
		Console.WriteLine ("sint16: " + emptyClass["sint16"]);
		Console.WriteLine ("sint32: " + emptyClass["sint32"]);
		Console.WriteLine ("sint64: " + emptyClass["sint64"]);
		Console.WriteLine ("bool: " + emptyClass["bool"]);
		Console.WriteLine ("string: " + emptyClass["string"]);
		Console.WriteLine ("real32: " + emptyClass["real32"]);
		Console.WriteLine ("real64: " + emptyClass["real64"]);
		Console.WriteLine ("datetime: " + emptyClass["datetime"]);
		Console.WriteLine ("reference: " + emptyClass["reference"]);
		Console.WriteLine ("object: " + ((ManagementBaseObject)emptyClass["object"]).GetText(TextFormat.Mof));


		// Add a null property and put some qualifiers on it
		propSet.Add("referenceNull", CimType.Reference, false);
		Property newProp = propSet["referenceNull"];
		newProp.Qualifiers.Add ("read", true);

		// Add other simple null properties
		propSet.Add ("uint8Null", CimType.UInt8, false);
		propSet.Add ("uint16Null", CimType.UInt16, false);
		propSet.Add ("uint32Null", CimType.UInt32, false);
		propSet.Add ("uint64Null", CimType.UInt64, false);
		propSet.Add ("sint8Null", CimType.SInt8, false);
		propSet.Add ("sint16Null", CimType.SInt16, false);
		propSet.Add ("sint32Null", CimType.SInt32, false);
		propSet.Add ("sint64Null", CimType.SInt64, false);
		propSet.Add ("boolNull", CimType.Boolean, false);
		propSet.Add ("stringNull", CimType.String, false);
		propSet.Add ("real32Null", CimType.Real32, false);
		propSet.Add ("real64Null", CimType.Real64, false);
		propSet.Add ("objectNull", CimType.Object, false);
		propSet.Add ("datetimeNull", CimType.DateTime, false);


		// Add array null properties
		propSet.Add ("uint8ArrayNull", CimType.UInt8, true);
		propSet.Add ("uint16ArrayNull", CimType.UInt16, true);
		propSet.Add ("uint32ArrayNull", CimType.UInt32, true);
		propSet.Add ("uint64ArrayNull", CimType.UInt64, true);
		propSet.Add ("sint8ArrayNull", CimType.SInt8, true);
		propSet.Add ("sint16ArrayNull", CimType.SInt16, true);
		propSet.Add ("sint32ArrayNull", CimType.SInt32, true);
		propSet.Add ("sint64ArrayNull", CimType.SInt64, true);
		propSet.Add ("boolArrayNull", CimType.Boolean, true);
		propSet.Add ("stringArrayNull", CimType.String, true);
		propSet.Add ("real32ArrayNull", CimType.Real32, true);
		propSet.Add ("real64ArrayNull", CimType.Real64, true);
		propSet.Add ("objectArrayNull", CimType.Object, true);
		propSet.Add ("datetimeArrayNull", CimType.DateTime, true);

		// Add some array properties
		propSet.Add ("uint8Array", new byte[]{10, 20});
		propSet.Add ("uint16Array", new ushort[] {10, 20});
		propSet.Add ("uint32Array", new uint[] {10, 20});
		propSet.Add ("uint64Array", new ulong[] {10, 20});
		propSet.Add ("sint8Array", new sbyte[] {10, 20});
		propSet.Add ("sint16Array", new short[] {10, 20});
		propSet.Add ("sint32Array", new int[] {10, 20});
		propSet.Add ("sint64Array", new long[] {10, 20});
		propSet.Add ("boolArray", new bool[] {true, false, true});
		propSet.Add ("stringArray", new string[] {"Wibble", "Wobble"});
		propSet.Add ("real32Array", new float[] {(float)10.23, (float)111.22});
		propSet.Add ("real64Array", new double[] {11.2222, -23.32});
		propSet.Add ("datetimeArray", new string[] {"20000728044535.000000-420"}, CimType.DateTime);
		propSet.Add ("referenceArray", new string[] {"Foo=10" ,"bar.Nonesuch=\"a\""}, CimType.Reference);
		// BUGBUG following causes a TypeMismatch - RAID 45235 against runtime
		propSet.Add ("objectArray", new ManagementClass[] { embeddedClass, embeddedClass });

		// Echo the non-null array property values
		Console.WriteLine ("uint8Array: " + ArrayToString((Array)emptyClass["uint8Array"]));
		Console.WriteLine ("uint16Array: " + ArrayToString((Array)emptyClass["uint16Array"]));
		Console.WriteLine ("uint32Array: " + ArrayToString((Array)emptyClass["uint32Array"]));
		Console.WriteLine ("uint64Array: " + ArrayToString((Array)emptyClass["uint64Array"]));
		Console.WriteLine ("sint8Array: " + ArrayToString((Array)emptyClass["sint8Array"]));
		Console.WriteLine ("sint16Array: " + ArrayToString((Array)emptyClass["sint16Array"]));
		Console.WriteLine ("sint32Array: " + ArrayToString((Array)emptyClass["sint32Array"]));
		Console.WriteLine ("sint64Array: " + ArrayToString((Array)emptyClass["sint64Array"]));
		Console.WriteLine ("boolArray: " + ArrayToString((Array)emptyClass["boolArray"]));
		Console.WriteLine ("stringArray: " + ArrayToString((Array)emptyClass["stringArray"]));
		Console.WriteLine ("real32Array: " + ArrayToString((Array)emptyClass["real32Array"]));
		Console.WriteLine ("real64Array: " + ArrayToString((Array)emptyClass["real64Array"]));
		Console.WriteLine ("datetimeArray: " + ArrayToString((Array)emptyClass["datetimeArray"]));
		Console.WriteLine ("referenceArray: " + ArrayToString((Array)emptyClass["referenceArray"]));
		Console.WriteLine ("objectArray: " + ObjectArrayToString((Array)emptyClass["objectArray"]));

		emptyClass.Put();
		Console.WriteLine ("Successfully saved new base class");

		// Create a derived class
		ManagementClass baseClass = new ManagementClass ("root/default:URTNEWCLASS");
		ManagementClass newClass = baseClass.Derive ("URTNEWSUBCLASS");
		newClass.Put();
		Console.WriteLine ("Successfully saved new subclass");
        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\classqualifierenum\class1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace ClassQualifierEnum
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
        ManagementClass MgmtsubclassObj = new ManagementClass();
		MgmtsubclassObj.Scope = new ManagementScope("root\\cimv2"); 
		MgmtsubclassObj.Path = new ManagementPath("Win32_Processor");
		MgmtsubclassObj.Options = new ObjectGetOptions();
		MgmtsubclassObj.Get();
		foreach (Qualifier Qual in MgmtsubclassObj.Qualifiers)
			Console.WriteLine("Qualifier    : {0} = {1}", Qual.Name, Qual.Value );
		Console.ReadLine();
		foreach (Property Prop in MgmtsubclassObj.Properties)
		{
			if (null == Prop.Value)
				Console.WriteLine("Property   : {0}", Prop.Name);
			else
				Console.WriteLine("Property   : {0} = {1}", Prop.Name, Prop.Value);
		}
		Console.ReadLine();
		return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\asynctest1\class1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace ClientTest
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		Console.WriteLine ("Main executing on thread " + System.Threading.Thread.CurrentThread.GetHashCode ());
		// Sync
		
		try {
			ManagementObject diskC = new ManagementObject("Win32_logicaldisk='C:'");
			diskC.Get ();
			Console.WriteLine (diskC["FreeSpace"]);
		} catch (ManagementException e) {
			Console.WriteLine ("Caught WMI Exception: " + e.Message + e.ErrorCode);
		}

		// Now do it async
		ManagementOperationWatcher results = new ManagementOperationWatcher ();
		ObjectHandler objHandler = new ObjectHandler ("LaLa");
		ObjectHandler objHandler2 = new ObjectHandler ("Po");
		CompletionHandler completionHandler = new CompletionHandler ();
		results.ObjectReady += new ObjectReadyEventHandler (objHandler.NewObject);
		results.ObjectReady += new ObjectReadyEventHandler (objHandler2.NewObject);
		results.Completed += new CompletedEventHandler (completionHandler.Done);
		
		// 1) Simple Get

		Console.WriteLine ("\nObject Get\n");
		Console.WriteLine ("==========\n\n");
		
		try {
			ManagementObject diskC = new ManagementObject("Win32_logicaldisk='C:'");
			diskC.Get (results);

			while (!completionHandler.IsComplete) {
				System.Threading.Thread.Sleep (1000);
			}

			completionHandler.Reset ();
		} catch (ManagementException e) {
			Console.WriteLine ("Caught WMI Exception (Get): " + e.Message + e.ErrorCode);
		}

		// 2) Enumeration

		Console.WriteLine ("\nObject Enumeration\n");
		Console.WriteLine ("==================\n\n");
		
		try {
			ManagementObjectSearcher searcher = new ManagementObjectSearcher (new SelectQuery("win32_logicaldisk"));
			searcher.Get (results);
			
			while (!completionHandler.IsComplete) {
				System.Threading.Thread.Sleep (1000);
			}
    
			completionHandler.Reset ();
		}
		catch (ManagementException e) {
			Console.WriteLine ("Caught WMI Exception (Query): " + e.Message + e.ErrorCode);
		}

		
		// 3) Object Put
		Console.WriteLine ("\nObject Put\n");
		Console.WriteLine ("==========\n\n");
		PutHandler putHandler = new PutHandler ();
		results.ObjectPut += new ObjectPutEventHandler (putHandler.JustPut);
		
		try {
			ManagementObject newObj = new ManagementObject("root/default:__cimomidentification=@");
			newObj.Get ();
			newObj.Put (results);

			while (!completionHandler.IsComplete) {
				System.Threading.Thread.Sleep (1000);
			}

			completionHandler.Reset ();

		} catch (ManagementException e) {
			Console.WriteLine ("Caught WMI Exception (Put): " + e.Message + e.ErrorCode);
		}

		// 4) Use a listener that throws an exception
		try {
			Console.WriteLine ("\nCreating listener with exception\n");
			Console.WriteLine ("================================\n\n");
			ManagementObjectSearcher objS = new ManagementObjectSearcher
				("root/default", "select * from __CIMOMIDentification");
			ManagementOperationWatcher watcher = new ManagementOperationWatcher ();
			ObjectHandler objH = new ObjectHandler ("Dipsy");
			watcher.ObjectReady += new ObjectReadyEventHandler (objH.NewObject);
			watcher.ObjectReady += new ObjectReadyEventHandler (objH.NewObjectWithException);
			watcher.ObjectReady += new ObjectReadyEventHandler (objH.NewObject);
			watcher.ObjectReady += new ObjectReadyEventHandler (objH.NewObject);
			watcher.Completed += new CompletedEventHandler (completionHandler.Done);

			objS.Get (watcher);

			while (!completionHandler.IsComplete) {
				System.Threading.Thread.Sleep (1000);
			}

			completionHandler.Reset ();
		}
		catch (ManagementException e)
		{
			Console.WriteLine ("Caught WMI Exception (Put): " + e.Message + e.ErrorCode);
		}

		return 0;
    }
}

public class ObjectHandler {
	private String m_name;

	public ObjectHandler (String name) {
		m_name = name;
	}

	public void NewObject (object sender, ObjectReadyEventArgs e) {
		Console.WriteLine ("New object arrived for " + m_name + " on thread " + System.Threading.Thread.CurrentThread.GetHashCode ());
		if (null != e.Context)
			Console.WriteLine ("Context is " + e.Context.ToString ());
		try {
			ManagementObject obj = (ManagementObject)e.NewObject;
			Console.WriteLine (obj["DeviceID"] + " " + obj["FreeSpace"]);
		} catch (Exception) {}
	}

	public void NewObjectWithException (object sender, ObjectReadyEventArgs e) {
		Console.WriteLine ("New ex object arrived for " + m_name + " on thread " + System.Threading.Thread.CurrentThread.GetHashCode ());
		throw new Exception ("ListenerException");
	}
}

public class InterestingEventHandler {
	public InterestingEventHandler () {}

	public void WMIEventArrived (object sender, ObjectReadyEventArgs e) {
		ManagementObject obj = (ManagementObject)e.NewObject;
		ManagementObject obj2 = (ManagementObject)(obj["TargetInstance"]);
		Console.WriteLine ("New event arrived about process " + obj2["Name"] + " on thread " + System.Threading.Thread.CurrentThread.GetHashCode ());
	}
}

public class PutHandler {
	public void JustPut (object sender, ObjectPutEventArgs e) {
		Console.WriteLine ("Path to save object is " + e.Path.Path + " on thread " +
					System.Threading.Thread.CurrentThread.GetHashCode ());

		if (null != e.Context)
			Console.WriteLine ("Context is " + e.Context.ToString ());
	}
}

public class CompletionHandler {
	private bool m_bIsComplete = false;

	public void Done (object sender, CompletedEventArgs e) {
		if (null != e.Context)
			Console.WriteLine ("Context is " + e.Context.ToString ());

		Console.WriteLine ("Operation completed with status " + e.Status + " on thread " 
							+ System.Threading.Thread.CurrentThread.GetHashCode ());
		m_bIsComplete = true;
	}

	public bool IsComplete {
		get { return m_bIsComplete; }
	}

	public void Reset () { m_bIsComplete = false; }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\classenum\class1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace ClassEnum
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		ManagementClass process = new ManagementClass ("cim_process");
		
		foreach (ManagementClass processSubClass in process.GetSubclasses ())
			Console.WriteLine ("Name of subclass is " + processSubClass.ClassPath);

		foreach (ManagementObject processInstance in process.GetInstances ())
			Console.WriteLine ("Name of instance is " + processInstance.Path.RelativePath);
        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\compareto\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\collectioncopyto\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\component\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\collection1\class1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Collection1
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		// Explicit scope + data query
		ManagementScope scope = new ManagementScope ("root/cimv2");
		DataQuery query = new DataQuery ("select * from Win32_process");
		
		ManagementObjectSearcher searcher = 
				new ManagementObjectSearcher (query);
		
		ManagementObjectCollection processes = searcher.Get();

		foreach (ManagementBaseObject process in processes) {
			Console.WriteLine (process["Name"]);
		}

		// Implicit scope + data query
		DataQuery query2 = new DataQuery ("select * from win32_logicaldisk");
		ManagementObjectSearcher searcher2 = 
				new ManagementObjectSearcher (query2);
		
		ManagementObjectCollection disks = searcher2.Get();

		foreach (ManagementObject disk in disks) {
			Console.WriteLine (disk["Freespace"]);
		}

		// Implicit scope + select query
		ManagementObjectSearcher searcher3 = 
			new ManagementObjectSearcher(new SelectQuery("win32_service"));

		foreach (ManagementObject service in searcher3.Get())
			Console.WriteLine (service["Name"]);

		//Asynchronous query
		ManagementOperationWatcher l = new ManagementOperationWatcher ();
		ObjectHandler objHandler = new ObjectHandler ("LaLa");
		ObjectHandler objHandler2 = new ObjectHandler ("Po");
		CompletionHandler completionHandler = new CompletionHandler ();
		
		l.ObjectReady += new ObjectReadyEventHandler (objHandler.NewObject);
		l.ObjectReady += new ObjectReadyEventHandler (objHandler2.NewObject);
		l.Completed += new CompletedEventHandler (completionHandler.Done);

		searcher2.Get (l);

		while (!completionHandler.IsComplete) {
			System.Threading.Thread.Sleep (1000);
		}

		//Event watcher
		ManagementEventWatcher w = new ManagementEventWatcher (
				"select * from __instancemodificationevent within 5 where targetinstance isa 'Win32_Process'");

		try {
			ManagementBaseObject o = w.WaitForNextEvent ();
			Console.WriteLine (o["__CLASS"]);
		} catch (ManagementException e) {
			Console.WriteLine ("Exception: " + e.Message);
		}
        return 0;
    }
}

public class ObjectHandler {
	private String m_name;

	public ObjectHandler (String name) {
		m_name = name;
	}

	public void NewObject (object sender, ObjectReadyEventArgs e) {
		Console.WriteLine ("New object arrived for " + m_name + " on thread " + System.Threading.Thread.CurrentThread.GetHashCode ());
		if (null != e.Context)
			Console.WriteLine ("Context is " + e.Context.ToString ());
		try {
			ManagementBaseObject obj = e.NewObject;
			Console.WriteLine (obj["DeviceID"] + " " + obj["FreeSpace"]);
		} catch (Exception) {}
	}
}

public class CompletionHandler {
	private bool m_bIsComplete = false;

	public void Done (object sender, CompletedEventArgs e) {
		if (null != e.Context)
			Console.WriteLine ("Context is " + e.Context.ToString ());

		Console.WriteLine ("Operation completed with status " + e.Status + " on thread " 
							+ System.Threading.Thread.CurrentThread.GetHashCode ());
		m_bIsComplete = true;
	}

	public bool IsComplete {
		get { return m_bIsComplete; }
	}

	public void Reset () { m_bIsComplete = false; }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\context\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\copyto\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\compareto\class1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace CompareTo
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		ManagementObject diskC = new ManagementObject ("Win32_LogicalDisk='C:'");
		ManagementObject diskD = new ManagementObject ("Win32_LogicalDisk='D:'");
		Console.WriteLine (diskC.CompareTo (diskD, ComparisonSettings.IncludeAll));

		ManagementObject anotherDiskC = new ManagementObject ("Win32_LogicalDisk='C:'");
		Console.WriteLine (diskC.CompareTo (diskC, ComparisonSettings.IncludeAll));
        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\component\form1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Component
{
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.WinForms;
using System.Data;

/// <summary>
///    Summary description for Form1.
/// </summary>
public class Form1 : System.WinForms.Form
{
    /// <summary> 
    ///    Required designer variable
    /// </summary>
    private System.ComponentModel.Container components;
	
	private System.Management.ManagementObject cDrive;
	
	private System.Management.ManagementObject win32LogicalDisk;

    public Form1()
    {
        //
        // Required for Win Form Designer support
        //
        InitializeComponent();

        //
        // TODO: Add any constructor code after InitializeComponent call
        //
    }

    /// <summary>
    ///    Clean up any resources being used
    /// </summary>
    public override void Dispose()
    {
        base.Dispose();
        components.Dispose();
    }

    /// <summary>
    ///    Required method for Designer support - do not modify
    ///    the contents of this method with the code editor
    /// </summary>
    private void InitializeComponent()
	{
		this.components = new System.ComponentModel.Container();
		this.cDrive = new System.Management.ManagementObject();
		this.win32LogicalDisk = new System.Management.ManagementObject();
		
		//@design cDrive.SetLocation(new System.Drawing.Point(116, 7));
		
		//@design win32LogicalDisk.SetLocation(new System.Drawing.Point(7, 7));
		
		this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
		this.Text = "Form1";
		//@design this.TrayLargeIcon = true;
		//@design this.TrayHeight = 201;
		this.ClientSize = new System.Drawing.Size(352, 277);
		
		
	}
    /*
     * The main entry point for the application.
     *
     */
    public static void Main(string[] args) 
    {
        Application.Run(new Form1());
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\context\class1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Context
{
using System;
using System.Collections;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
        // Create a class
			ManagementClass dummyClass = new ManagementClass("root/default","",null);
			dummyClass.SystemProperties["__CLASS"].Value = "TestDelClassSync";
			PropertySet mykeyprop = dummyClass.Properties;
			mykeyprop.Add("MydelKey","delHello");
			dummyClass.Put();

// Get the Class TestDelClassSync
			ManagementClass dummyDeleteCheck = new ManagementClass("root/default","TestDelClassSync",null);
			dummyDeleteCheck.Get();

// Set the Delete Options on the Class TestDelClassSync
			//int Capacity = 8;
			CaseInsensitiveHashtable MyHash = new CaseInsensitiveHashtable();
			DeleteOptions Options = new DeleteOptions(MyHash);
			dummyDeleteCheck.Delete(Options);
return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\createinstance\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\delegatethrow\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\collectioncopyto\class1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace CollectionCopyTo
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		ManagementObjectSearcher s = new ManagementObjectSearcher 
			(new DataQuery("select * from Win32_Process"));
		ManagementObject[] processes = new ManagementObject [100];

		ManagementObjectCollection c = s.Get ();
		c.CopyTo (processes, 0);
		
		for (int i = 0; i < processes.Length; i++)
			if (null != processes[i])
				Console.WriteLine (((ManagementObject)(processes[i]))["Name"]);

        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\copyto\class1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace CopyTo
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
        ManagementClass dummyClass = new ManagementClass("root/default","",null);
		dummyClass.SystemProperties["__CLASS"].Value = "TestMyCopyToClass";
		PropertySet mykeyprop = dummyClass.Properties;
		mykeyprop.Add("reg_prop","string_prop");
		mykeyprop.Add("MyKey","Hello");
		dummyClass.Put();
		ManagementPath myPath = new ManagementPath("root/cimv2");
		// CopyTo( )
		ManagementPath newPath = dummyClass.CopyTo(myPath); 
		Console.WriteLine (newPath.Path);
		return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\delegatethrowtest\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\deleteclass\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\enuminstances\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\createinstance\class1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace CreateInstance
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		try {
			ManagementClass existingClass = new ManagementClass ("root/default:TestCreateInstance");
			existingClass.Delete ();
		} catch {}

		ManagementClass newClass = new ManagementClass ("root/default", "", null);
		newClass["__CLASS"] = "TestCreateInstance";

		newClass.Properties.Add ("MyKey", CIMType.Uint32, false);
		newClass.Properties["mykey"].Qualifiers.Add ("key", true);
		newClass.Put();

		ManagementObject newInstance = newClass.CreateInstance ();
		newInstance["MyKey"] = 22;
		ManagementPath newPath = newInstance.Put();
		Console.WriteLine (newPath.Path);

		ManagementObject getInstance = new ManagementObject ("root/default:TestCreateInstance=22");
		Console.WriteLine (getInstance["__RELPATH"]);
        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\enuminstances\enumerateinstances.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace EnumInstances
{
using System;
using System.Management;

/// <summary>
///    ManagementObjectSearcher Example 1 : Enumerate environment variables
/// </summary>
public class EnumerateInstances
{
    public EnumerateInstances()
    {
    }

    public static int Main(string[] args)
    {
		//Build a query for enumeration of Win32_Environment instances
		InstanceEnumerationQuery query = new InstanceEnumerationQuery("Win32_Environment");

		//Instantiate an object searcher with this query
		ManagementObjectSearcher searcher = new ManagementObjectSearcher(query); 

		//Call Get() to retrieve the collection of objects and loop through it
		foreach (ManagementBaseObject envVar in searcher.Get())
			Console.WriteLine("Variable : {0}, Value = {1}", envVar["Name"],envVar["VariableValue"]);

		Console.ReadLine();

		return 0;
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\delegatethrow\form1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace DelegateThrow
{
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.WinForms;
using System.Data;
using System.Management;

/// <summary>
///    Summary description for Form1.
/// </summary>
public class Form1 : System.WinForms.Form
{
    /// <summary> 
    ///    Required designer variable
    /// </summary>
    private System.ComponentModel.Container components;
	private System.WinForms.Label labelStatus;
	private System.WinForms.GroupBox groupBox1;
	private System.WinForms.CheckBox checkBoxIncludeThrowingDelegate;
	private System.WinForms.Button buttonStart;
	private ManagementObjectSearcher searcher;
	
    public Form1()
    {
        //
        // Required for Win Form Designer support
        //
        InitializeComponent();

        //
        // TODO: Add any constructor code after InitializeComponent call
        //
    }

    /// <summary>
    ///    Clean up any resources being used
    /// </summary>
    public override void Dispose()
    {
        base.Dispose();
        components.Dispose();
    }

    /// <summary>
    ///    Required method for Designer support - do not modify
    ///    the contents of this method with the code editor
    /// </summary>
    private void InitializeComponent()
	{
		this.components = new System.ComponentModel.Container();
		this.checkBoxIncludeThrowingDelegate = new System.WinForms.CheckBox();
		this.labelStatus = new System.WinForms.Label();
		this.buttonStart = new System.WinForms.Button();
		this.groupBox1 = new System.WinForms.GroupBox();
		
		checkBoxIncludeThrowingDelegate.Location = new System.Drawing.Point(40, 104);
		checkBoxIncludeThrowingDelegate.Text = "Include Throwing Delegate";
		checkBoxIncludeThrowingDelegate.Size = new System.Drawing.Size(200, 24);
		checkBoxIncludeThrowingDelegate.AccessibleRole = System.WinForms.AccessibleRoles.CheckButton;
		checkBoxIncludeThrowingDelegate.TabIndex = 1;
		checkBoxIncludeThrowingDelegate.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
		
		labelStatus.Location = new System.Drawing.Point(16, 24);
		labelStatus.Text = "Not started";
		labelStatus.Size = new System.Drawing.Size(184, 24);
		labelStatus.TabIndex = 0;
		
		buttonStart.Location = new System.Drawing.Point(32, 32);
		buttonStart.Size = new System.Drawing.Size(224, 48);
		buttonStart.TabIndex = 0;
		buttonStart.Text = "Start";
		buttonStart.AddOnClick(new System.EventHandler(buttonStart_Click));
		
		groupBox1.Location = new System.Drawing.Point(32, 160);
		groupBox1.TabIndex = 2;
		groupBox1.TabStop = false;
		groupBox1.Text = "Status";
		groupBox1.Size = new System.Drawing.Size(224, 64);
		
		this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
		this.Text = "Form1";
		//@design this.TrayLargeIcon = true;
		//@design this.TrayHeight = 0;
		
		groupBox1.Controls.Add(labelStatus);
		this.Controls.Add(groupBox1);
		this.Controls.Add(checkBoxIncludeThrowingDelegate);
		this.Controls.Add(buttonStart);

		
		searcher = new ManagementObjectSearcher ("root/default", "select * from __CIMOMIdentification");
	
		
	}
	protected void buttonStart_Click(object sender, System.EventArgs e)
	{
		ManagementOperationWatcher watcher = new ManagementOperationWatcher ();
		CompletionHandler handler = new CompletionHandler (labelStatus);
		int opCount = 4;

		// Attach some event handlers for the object
		watcher.ObjectReady += new ObjectReadyEventHandler (handler.HandleObject);
		watcher.ObjectReady += new ObjectReadyEventHandler (handler.HandleObject);
		
		if (checkBoxIncludeThrowingDelegate.Checked)
		{
			watcher.ObjectReady += new ObjectReadyEventHandler (handler.HandleObjectWithException);
			opCount++;
		}

		watcher.ObjectReady += new ObjectReadyEventHandler (handler.HandleObject);
		watcher.ObjectReady += new ObjectReadyEventHandler (handler.HandleObject);
		
		// Add a completed event handler
		watcher.Completed += new CompletedEventHandler (handler.Done);

		// record the number of listeners
		handler.SetInitialOpCount (opCount);

		// go
		searcher.Get(watcher);
	}

    /*
     * The main entry point for the application.
     *
     */
    public static void Main(string[] args) 
    {
        Application.Run(new Form1());
    }

}

internal class CompletionHandler 
{
	private int opCount = 0;
	private int initialOpCount = 0;
	private Label labelStatus;

	internal CompletionHandler (Label labelStatus)
	{
		this.labelStatus = labelStatus;
	}

	internal void HandleObject (object sender, ObjectReadyEventArgs args) {
		++opCount;

	}

	internal void HandleObjectWithException (object sender, ObjectReadyEventArgs args) {
		++opCount;
		throw new Exception();
	}

	internal void Done (object sender, CompletedEventArgs args) {
		if (opCount == initialOpCount)
			labelStatus.Text = "All " + opCount + " callbacks processed";
		else
			labelStatus.Text = "Only " + opCount + " of " + initialOpCount + " callbacks processed";
	}

	internal void SetInitialOpCount (int opCount)
	{
		initialOpCount = opCount;
		this.opCount = 0;
	}
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\enumprops\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\delegatethrowtest\form1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace DelegateThrow
{
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.WinForms;
using System.Data;
using System.Management;

/// <summary>
///    Summary description for Form1.
/// </summary>
public class Form1 : System.WinForms.Form
{
    /// <summary> 
    ///    Required designer variable
    /// </summary>
    private System.ComponentModel.Container components;
	private System.WinForms.Label labelStatus;
	private System.WinForms.GroupBox groupBox1;
	private System.WinForms.CheckBox checkBoxIncludeThrowingDelegate;
	private System.WinForms.Button buttonStart;
	private ManagementObjectSearcher searcher;
	
    public Form1()
    {
        //
        // Required for Win Form Designer support
        //
        InitializeComponent();

        //
        // TODO: Add any constructor code after InitializeComponent call
        //
    }

    /// <summary>
    ///    Clean up any resources being used
    /// </summary>
    public override void Dispose()
    {
        base.Dispose();
        components.Dispose();
    }

    /// <summary>
    ///    Required method for Designer support - do not modify
    ///    the contents of this method with the code editor
    /// </summary>
    private void InitializeComponent()
	{
		this.components = new System.ComponentModel.Container();
		this.checkBoxIncludeThrowingDelegate = new System.WinForms.CheckBox();
		this.labelStatus = new System.WinForms.Label();
		this.buttonStart = new System.WinForms.Button();
		this.groupBox1 = new System.WinForms.GroupBox();
		
		checkBoxIncludeThrowingDelegate.Location = new System.Drawing.Point(40, 104);
		checkBoxIncludeThrowingDelegate.Text = "Include Throwing Delegate";
		checkBoxIncludeThrowingDelegate.Size = new System.Drawing.Size(200, 24);
		checkBoxIncludeThrowingDelegate.AccessibleRole = System.WinForms.AccessibleRoles.CheckButton;
		checkBoxIncludeThrowingDelegate.TabIndex = 1;
		checkBoxIncludeThrowingDelegate.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
		
		labelStatus.Location = new System.Drawing.Point(16, 24);
		labelStatus.Text = "Not started";
		labelStatus.Size = new System.Drawing.Size(184, 24);
		labelStatus.TabIndex = 0;
		
		buttonStart.Location = new System.Drawing.Point(32, 32);
		buttonStart.Size = new System.Drawing.Size(224, 48);
		buttonStart.TabIndex = 0;
		buttonStart.Text = "Start";
		buttonStart.AddOnClick(new System.EventHandler(buttonStart_Click));
		
		groupBox1.Location = new System.Drawing.Point(32, 160);
		groupBox1.TabIndex = 2;
		groupBox1.TabStop = false;
		groupBox1.Text = "Status";
		groupBox1.Size = new System.Drawing.Size(224, 64);
		
		this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
		this.Text = "Form1";
		//@design this.TrayLargeIcon = true;
		//@design this.TrayHeight = 0;
		
		groupBox1.Controls.Add(labelStatus);
		this.Controls.Add(groupBox1);
		this.Controls.Add(checkBoxIncludeThrowingDelegate);
		this.Controls.Add(buttonStart);

		
		searcher = new ManagementObjectSearcher ("root/default", "select * from __CIMOMIdentification");
	
		
	}
	protected void buttonStart_Click(object sender, System.EventArgs e)
	{
		ManagementOperationWatcher watcher = new ManagementOperationWatcher ();
		CompletionHandler handler = new CompletionHandler (labelStatus);
		int opCount = 4;

		// Attach some event handlers for the object
		watcher.ObjectReady += new ObjectReadyEventHandler (handler.HandleObject);
		watcher.ObjectReady += new ObjectReadyEventHandler (handler.HandleObject);
		
		if (checkBoxIncludeThrowingDelegate.Checked)
		{
			watcher.ObjectReady += new ObjectReadyEventHandler (handler.HandleObjectWithException);
			opCount++;
		}

		watcher.ObjectReady += new ObjectReadyEventHandler (handler.HandleObject);
		watcher.ObjectReady += new ObjectReadyEventHandler (handler.HandleObject);
		
		// Add a completed event handler
		watcher.Completed += new CompletedEventHandler (handler.Done);

		// record the number of listeners
		handler.SetInitialOpCount (opCount);

		// go
		searcher.Get(watcher);
	}

    /*
     * The main entry point for the application.
     *
     */
    public static void Main(string[] args) 
    {
        Application.Run(new Form1());
    }

}

internal class CompletionHandler 
{
	private int opCount = 0;
	private int initialOpCount = 0;
	private Label labelStatus;

	internal CompletionHandler (Label labelStatus)
	{
		this.labelStatus = labelStatus;
	}

	internal void HandleObject (object sender, ObjectReadyEventArgs args) {
		++opCount;

	}

	internal void HandleObjectWithException (object sender, ObjectReadyEventArgs args) {
		++opCount;
		throw new Exception();
	}

	internal void Done (object sender, CompletedEventArgs args) {
		if (opCount == initialOpCount)
			labelStatus.Text = "All " + opCount + " callbacks processed";
		else
			labelStatus.Text = "Only " + opCount + " of " + initialOpCount + " callbacks processed";
	}

	internal void SetInitialOpCount (int opCount)
	{
		initialOpCount = opCount;
		this.opCount = 0;
	}
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\enumsubclasses\test.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Cool source file
using System;
using System.WMI;
using System.IO;
//using Microsoft.Win32.Interop;

class WmiPlusTest
{
  public static int Main(String[] args)
  {

	TextWriter oldTW = null; //used to save old console.out for logging
	StreamWriter sw = null;  //used to redirect console.out to file for logging
    Console.WriteLine("WMI Plus Test Application");
   
	//validate arguments
	if ( ((args.Length != 0) && (args.Length != 2)) || ((args.Length == 2) && (args[0] != "/log")) ) 
    {
        Console.WriteLine("Usage: ... "); 
        return 0; 
    }
	
	//if "/log" specified, redirect Console.Out to log file
	if (args.Length > 0)
	{
		FileStream fs = new FileStream(args[1], FileMode.OpenOrCreate, FileAccess.ReadWrite); //open log file
		oldTW = Console.Out; //save default standard output
		sw = new StreamWriter(fs);
		Console.SetOut(sw); //replace with file
	}
	

	//Create a WmiPath object
	WmiPath Path = new WmiPath("root\\default");
	Console.WriteLine("String in WmiPath object is : {0}", Path.PathString);

	//Make a connection to this path
	WmiCollection Session = WmiCollection.Connect(Path);
//	WmiCollection Session = WmiCollection.Connect("root\\cimv2");
	
	//Get a class from this connection
	WmiObject ServiceClass = Session.Get(new WmiPath("MyStaticClass"));
	//Display the class name (__CLASS property of the class)
	Console.WriteLine("The name of this class is : {0}", ServiceClass["__CLASS"]);

	//Enumerate instances (static only because of security problem !!)
	WmiCollection Instances = Session.Open(new WmiPath("MyStaticClass"));
	foreach (WmiObject obj in Instances)
		Console.WriteLine("The key of this instance is : {0}", obj["MyProp"]);
    
	
//		WmiCollection Services = Session.Open("Win32_Service");		
//		foreach (WmiObject Service in Services)
//			Console.WriteLine("{0}", Service["Name"]);
//r	}
//r	catch (Exception e)
//r	{
//r		Console.WriteLine("Exception caught : {0}", e.Message);
//r	}
		

	//flush log file, and restore standard output if changed
	if (sw != null)
		sw.Flush();
	if (oldTW != null)
		Console.SetOut(oldTW);

	return 0;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\enumsubclasses\test1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Cool source file
using System;
using System.WMI;
using System.IO;

class WmiPlusTest
{
  public static int Main()
  {

	System.Diagnostics.TraceSwitch MySwitch = new System.Diagnostics.TraceSwitch("MySwitch",null);
    MySwitch.Level=System.Diagnostics.TraceLevel.Verbose;

    Console.WriteLine("WMI COM+ Test Application");
   
	
	//Create a WmiPath object
	WmiPath Path = new WmiPath("root\\cimv2");
	Console.WriteLine("String in WmiPath object is : {0}", Path.PathString);

	//Make a connection to this path
	WmiCollection Session = WmiCollection.Connect(Path);
	
	//Get a class from this connection
	WmiObject ServiceClass = Session.Get(new WmiPath("Win32_LogicalDisk"));
	//WmiObject ServiceClass = Session.Get("Win32_LogicalDisk");
	//Display the class name (__CLASS property of the class)
	Console.WriteLine("The name of this class is : {0}", ServiceClass["__CLASS"]);

	//Enumerate instances 
	WmiCollection Instances = Session.Open(new WmiPath("Win32_LogicalDisk"));
	foreach (WmiObject obj in Instances)
		Console.WriteLine("The key of this instance is : {0}", obj["Name"]);
    
	//Query
	WmiCollection QueryRes = Session.Query(new WmiQuery("select * from Win32_Service"));
	foreach (WmiObject Service in QueryRes)
		Console.WriteLine("{0}", Service["Name"]);

	return 0;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\eventwatcherasync\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\eventwatcherpolling\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\deleteclass\class1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace DeleteClass
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

	/*
	 * Note that if you remove the [MTAThread] attribute below, the code as
	 * arranged will run in an STA and block indefinitely because the 
	 * message pump cannot process the incoming RPC call.
	 * If you remove this attribute, you will also find that the line
	 * folowing the comment marked **SOURCE**, when moved to the line
	 * marked **DESTINATION**, causes the chosen threading model to be
	 * MTA and everything starts working again!
	 */

	[MTAThread]
    public static int Main(string[] args)
    {
        try
		{
			// **DESTINATION**
			// Create watcher and completionHandler
			
			ManagementOperationWatcher delete_res = new ManagementOperationWatcher();
			ManagementOperationWatcher results = new ManagementOperationWatcher();
			CompletionHandler completionHandler = new CompletionHandler();
			CompletionHandler completionHandler_res = new CompletionHandler();
			delete_res.Completed += new CompletedEventHandler(completionHandler_res.Done);
            results.Completed += new CompletedEventHandler(completionHandler.Done);
			PutHandler putHandler = new PutHandler ();
		    results.ObjectPut += new ObjectPutEventHandler (putHandler.JustPut);

			// Create the class TestDelClassasync for deletion later
			// **SOURCE **
			ManagementClass newclassObj = new ManagementClass("root/default","",null);
			newclassObj.SystemProperties["__CLASS"].Value = "TestDelClassasync";
			PropertySet mykeyprop = newclassObj.Properties;
			mykeyprop.Add("MyKey","Hello");

			Console.WriteLine("Thread is {0}", System.Threading.Thread.CurrentThread.ApartmentState);
			newclassObj.Put(results);
			while (!completionHandler.IsComplete) {
				System.Threading.Thread.Sleep (1000);
			}
			completionHandler.Reset ();
						
			ManagementClass dummyClassCheck = new ManagementClass("root/default","TestDelClassasync",null);
			//dummyClassCheck.Get();
			Console.WriteLine(dummyClassCheck.SystemProperties["__Class"].Value.ToString());

			// Delete the Class aync
			newclassObj.Delete(delete_res);
			while (!completionHandler_res.IsComplete) {
				System.Threading.Thread.Sleep (1000);
			}
			completionHandler_res.Reset ();
			if ("System.Management.ManagementOperationWatcher" == completionHandler_res.Sender)
			{
				Console.WriteLine("Test 10.2: Able to delete classes asynchronously.");
			}
			else
			{
				Console.WriteLine("Test 10.2: Unable to delete classes asynchronously.");
			}
		}
		catch (Exception e)
		{
			Console.WriteLine("Test 10.2: " + e.GetType().ToString());
			Console.WriteLine(e.Message + e.StackTrace);
		}


        return 0;
    }

	public class ObjectHandler {
	private String m_name;

	public ObjectHandler (String name) {
		m_name = name;
	}

	public void NewObject (object sender, ObjectReadyEventArgs e) {
		Console.WriteLine ("New object arrived for " + m_name + " on thread " + System.Threading.Thread.CurrentThread.GetHashCode ());
		if (null != e.Context)
			Console.WriteLine ("Context is " + e.Context.ToString ());
		try {
			ManagementObject obj = (ManagementObject)e.NewObject;
			Console.WriteLine (obj["DeviceID"] + " " + obj["FreeSpace"]);
		} catch (Exception) {}
	}
}

public class InterestingEventHandler {
	public InterestingEventHandler () {}

	public void WMIEventArrived (object sender, ObjectReadyEventArgs e) {
		ManagementObject obj = (ManagementObject)e.NewObject;
		ManagementObject obj2 = (ManagementObject)(obj["TargetInstance"]);
		Console.WriteLine ("New event arrived about process " + obj2["Name"] + " on thread " + System.Threading.Thread.CurrentThread.GetHashCode ());
	}
}

public class PutHandler {
	public void JustPut (object sender, ObjectPutEventArgs e) {
		Console.WriteLine ("Path to save object is " + e.Path.Path + " on thread " +
					System.Threading.Thread.CurrentThread.GetHashCode ());

		if (null != e.Context)
			Console.WriteLine ("Context is " + e.Context.ToString ());
	}
}

public class CompletionHandler {
	private bool m_bIsComplete = false;
	private string result = "";

	public void Done (object sender, CompletedEventArgs e) {
		if (null != e.Context)
			Console.WriteLine ("Context is " + e.Context.ToString ());

		result = sender.ToString ();

		Console.WriteLine ("Operation completed with status " + e.Status + " on thread " 
							+ System.Threading.Thread.CurrentThread.GetHashCode ());
		m_bIsComplete = true;
	}

	public bool IsComplete {
		get { return m_bIsComplete; }
	}

	public string Sender {
		get { return result; }
	}

	public void Reset () { m_bIsComplete = false; }
}
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\enumprops\enumerateproperties.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace EnumProps
{
using System;
using System.Management;


/// <summary>
///    ManagementObject Example 1 : enumerate properties of a service object
/// </summary>
public class EnumerateProperties
{
    public EnumerateProperties()
    {
    }

    public static int Main(string[] args)
    {
		//Get the Alerter service object
		ManagementObject myService = new ManagementObject("Win32_Service=\"Alerter\"");

		//Enumerate through the properties of this object and display the names and values
		foreach (Property p in myService.Properties)
			Console.WriteLine("Property {0} = {1}", p.Name, p.Value);

		Console.ReadLine(); //to pause before closing the window

        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\enumsubclasses\class1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Test2
{
    using System;
	using System.Management.Root.Cimv2.Win32;

    /// <summary>
    ///    Summary description for Class1.
    /// </summary>
    public class Class1
    {
        public Class1()
        {
            //
            // TODO: Add Constructor Logic here
            //
        }

        public static int Main(string[] args)
        {
            //
            // TODO: Add code to start application here
            //
			Wmisetting ws= new Wmisetting();
			ws.LoggingLevel = 1;
            return 0;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\eventwatcherasync\class1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace eventwatcherasync
{
using System;
using System.Management;
using System.Threading;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class EventWatcherAsync
{
    public EventWatcherAsync()
    {
    }

    public static int Main(string[] args)
    {
		//Create event query to receive timer events
		WQLEventQuery query = new WQLEventQuery("__TimerEvent", "TimerId=\"Timer1\"");

		//Initialize an event watcher and subscribe to events that match this query
		ManagementEventWatcher watcher = new ManagementEventWatcher(query);

		//Setup a listener for events
		watcher.EventArrived += new EventArrivedEventHandler((new EventHandler()).HandleEvent);

		watcher.Start();

		Thread.Sleep(10000);
		
		watcher.Stop();

		return 0;
    }
}

public class EventHandler
{
	public void HandleEvent(object sender, EventArrivedEventArgs e)
	{
		Console.WriteLine("Event arrived !");
	}

}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\exception\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\invokemethod\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\eventwatcherpolling\class1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace eventwatcherpolling
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class EventWatcherPolling
{
    public EventWatcherPolling()
    {
    }

	public static int Main(string[] args)
    {
		//Create event query to be notified within 1 second of a change in a service
		WQLEventQuery query = new WQLEventQuery("__InstanceModificationEvent", new TimeSpan(0,0,1), "TargetInstance isa \"Win32_Service\"");

		//Initialize an event watcher and subscribe to events that match this query
		ManagementEventWatcher watcher = new ManagementEventWatcher(query);
		
		//wait for 5 events
		int i = 0;
		while (i < 5)
		{
			//Block until the next event occurs
			ManagementBaseObject e = watcher.WaitForNextEvent();

			//Display information from the event
			Console.WriteLine("Service {0} has changed, State is {1}", 
				((ManagementBaseObject)e["TargetInstance"])["Name"],
				((ManagementBaseObject)e["TargetInstance"])["State"]);
			i++;
		}

		//cancel the subscription
		watcher.Stop();

		return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\invokemethodasync\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\enumsubclasses\wmisetting.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Early Bound Managed Code Wrapper for WMI class Win32_Wmisetting
//------------------------------------------------------------------------------
/// <autogenerated>
///     This class was generated by a tool.
///     Runtime Version: 1.0.2107.0
///
///     Changes to this file may cause incorrect behavior and will be lost if 
///     the code is regenerated.
/// </autogenerated>
//------------------------------------------------------------------------------

namespace System.Management.Root.Cimv2.Win32 {
    using System;
    using System.Management;
    
    public class Wmisetting {
        private _ManagementSystemProperties _privSystemProps;
        private ManagementObject _privObject;
        
        public Wmisetting() {
            String _strPath = "";
            if (((_defServer) != (String.Empty))) {
                _strPath = ((_strPath) + (_defServer));
            }
            _strPath = ((_strPath) + ((("\\") + (((_defNamespace) + (((":") + (((_defClassName) + ("=@"))))))))));
            _privObject = new ManagementObject(_strPath);
            _privSystemProps = new _ManagementSystemProperties(_privObject);
        }
        public Wmisetting(ManagementPath _thePath) {
            _privObject = new ManagementObject(_thePath);
            _privSystemProps = new _ManagementSystemProperties(_privObject);
        }
        
        public String _defServer {
            get {
                return "";
            }
        }
        public String _defNamespace {
            get {
                return "Root\\Cimv2";
            }
        }
        public String _defClassName {
            get {
                return "Win32_Wmisetting";
            }
        }
        public _ManagementSystemProperties _SystemProps {
            get {
                return _privSystemProps;
            }
        }
        public ManagementObject _Object {
            get {
                return _privObject;
            }
        }
        public String ASPScriptDefaultNamespace {
            get {
                return (String)(_privObject["ASPScriptDefaultNamespace"]);
            }
            set {
                _privObject["ASPScriptDefaultNamespace"] = value;
                _privObject.Put();
            }
        }
        public Boolean ASPScriptEnabled {
            get {
                return (Boolean)(_privObject["ASPScriptEnabled"]);
            }
            set {
                _privObject["ASPScriptEnabled"] = value;
                _privObject.Put();
            }
        }
        public String AutorecoverMofs {
            get {
                return (String)(_privObject["AutorecoverMofs"]);
            }
            set {
                _privObject["AutorecoverMofs"] = value;
                _privObject.Put();
            }
        }
        public UInt32 AutoStartWin9X {
            get {
                return (UInt32)(_privObject["AutoStartWin9X"]);
            }
            set {
                _privObject["AutoStartWin9X"] = value;
                _privObject.Put();
            }
        }
        public UInt32 BackupInterval {
            get {
                return (UInt32)(_privObject["BackupInterval"]);
            }
            set {
                _privObject["BackupInterval"] = value;
                _privObject.Put();
            }
        }
        public DateTime BackupLastTime {
            get {
                return (DateTime)(_privObject["BackupLastTime"]);
            }
            set {
                _privObject["BackupLastTime"] = value;
                _privObject.Put();
            }
        }
        public String BuildVersion {
            get {
                return (String)(_privObject["BuildVersion"]);
            }
            set {
                _privObject["BuildVersion"] = value;
                _privObject.Put();
            }
        }
        public String Caption {
            get {
                return (String)(_privObject["Caption"]);
            }
            set {
                _privObject["Caption"] = value;
                _privObject.Put();
            }
        }
        public String DatabaseDirectory {
            get {
                return (String)(_privObject["DatabaseDirectory"]);
            }
            set {
                _privObject["DatabaseDirectory"] = value;
                _privObject.Put();
            }
        }
        public UInt32 DatabaseMaxSize {
            get {
                return (UInt32)(_privObject["DatabaseMaxSize"]);
            }
            set {
                _privObject["DatabaseMaxSize"] = value;
                _privObject.Put();
            }
        }
        public String Description {
            get {
                return (String)(_privObject["Description"]);
            }
            set {
                _privObject["Description"] = value;
                _privObject.Put();
            }
        }
        public Boolean EnableAnonWin9xConnections {
            get {
                return (Boolean)(_privObject["EnableAnonWin9xConnections"]);
            }
            set {
                _privObject["EnableAnonWin9xConnections"] = value;
                _privObject.Put();
            }
        }
        public Boolean EnableEvents {
            get {
                return (Boolean)(_privObject["EnableEvents"]);
            }
            set {
                _privObject["EnableEvents"] = value;
                _privObject.Put();
            }
        }
        public Boolean EnableStartupHeapPreallocation {
            get {
                return (Boolean)(_privObject["EnableStartupHeapPreallocation"]);
            }
            set {
                _privObject["EnableStartupHeapPreallocation"] = value;
                _privObject.Put();
            }
        }
        public UInt32 HighThresholdOnClientObjects {
            get {
                return (UInt32)(_privObject["HighThresholdOnClientObjects"]);
            }
            set {
                _privObject["HighThresholdOnClientObjects"] = value;
                _privObject.Put();
            }
        }
        public UInt32 HighThresholdOnEvents {
            get {
                return (UInt32)(_privObject["HighThresholdOnEvents"]);
            }
            set {
                _privObject["HighThresholdOnEvents"] = value;
                _privObject.Put();
            }
        }
        public String InstallationDirectory {
            get {
                return (String)(_privObject["InstallationDirectory"]);
            }
            set {
                _privObject["InstallationDirectory"] = value;
                _privObject.Put();
            }
        }
        public UInt32 LastStartupHeapPreallocation {
            get {
                return (UInt32)(_privObject["LastStartupHeapPreallocation"]);
            }
            set {
                _privObject["LastStartupHeapPreallocation"] = value;
                _privObject.Put();
            }
        }
        public String LoggingDirectory {
            get {
                return (String)(_privObject["LoggingDirectory"]);
            }
            set {
                _privObject["LoggingDirectory"] = value;
                _privObject.Put();
            }
        }
        public UInt32 LoggingLevel {
            get {
                return (UInt32)(_privObject["LoggingLevel"]);
            }
            set {
                _privObject["LoggingLevel"] = value;
                _privObject.Put();
            }
        }
        public UInt32 LowThresholdOnClientObjects {
            get {
                return (UInt32)(_privObject["LowThresholdOnClientObjects"]);
            }
            set {
                _privObject["LowThresholdOnClientObjects"] = value;
                _privObject.Put();
            }
        }
        public UInt32 LowThresholdOnEvents {
            get {
                return (UInt32)(_privObject["LowThresholdOnEvents"]);
            }
            set {
                _privObject["LowThresholdOnEvents"] = value;
                _privObject.Put();
            }
        }
        public UInt32 MaxLogFileSize {
            get {
                return (UInt32)(_privObject["MaxLogFileSize"]);
            }
            set {
                _privObject["MaxLogFileSize"] = value;
                _privObject.Put();
            }
        }
        public UInt32 MaxWaitOnClientObjects {
            get {
                return (UInt32)(_privObject["MaxWaitOnClientObjects"]);
            }
            set {
                _privObject["MaxWaitOnClientObjects"] = value;
                _privObject.Put();
            }
        }
        public UInt32 MaxWaitOnEvents {
            get {
                return (UInt32)(_privObject["MaxWaitOnEvents"]);
            }
            set {
                _privObject["MaxWaitOnEvents"] = value;
                _privObject.Put();
            }
        }
        public String MofSelfInstallDirectory {
            get {
                return (String)(_privObject["MofSelfInstallDirectory"]);
            }
            set {
                _privObject["MofSelfInstallDirectory"] = value;
                _privObject.Put();
            }
        }
        public String SettingID {
            get {
                return (String)(_privObject["SettingID"]);
            }
            set {
                _privObject["SettingID"] = value;
                _privObject.Put();
            }
        }
        
        
        public class _ManagementSystemProperties {
            private ManagementObject _privObject;
            
            public _ManagementSystemProperties(ManagementObject ManagedObject) {
                _privObject = ManagedObject;
            }
            
            public Int32 Genus {
                get {
                    return (Int32)(_privObject["__GENUS"]);
                }
            }
            public String Class {
                get {
                    return (String)(_privObject["__CLASS"]);
                }
            }
            public String Superclass {
                get {
                    return (String)(_privObject["__SUPERCLASS"]);
                }
            }
            public String Dynasty {
                get {
                    return (String)(_privObject["__DYNASTY"]);
                }
            }
            public String Relpath {
                get {
                    return (String)(_privObject["__RELPATH"]);
                }
            }
            public Int32 Property_Count {
                get {
                    return (Int32)(_privObject["__PROPERTY_COUNT"]);
                }
            }
            public String Derivation {
                get {
                    return (String)(_privObject["__DERIVATION"]);
                }
            }
            public String Server {
                get {
                    return (String)(_privObject["__SERVER"]);
                }
            }
            public String Namespace {
                get {
                    return (String)(_privObject["__NAMESPACE"]);
                }
            }
            public String Path {
                get {
                    return (String)(_privObject["__PATH"]);
                }
            }
            
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\exception\class1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Exception
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		try {
			ManagementClass c = new ManagementClass ("nosuchclass000");
			Console.WriteLine ("Class name is {0}", c["__CLASS"]);
		} catch (ManagementException e) {
			Console.WriteLine ("Call returned {0:x} - {1}", (UInt32)e.ErrorCode, e.Message);
		}
        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\iis\iisvroot.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace IISVRoot
{
   using System;
   using System.IO;	
   using System.Management;

   /// <summary>
    /// Creates and Deletes IIS 6.0 Virtual Roots
    /// </summary>
    public class IISVirtualRoot
    {
   	public static void Main(string[] args)
   	{
		string strerror = "";		
		Create("W3SVC/1/ROOT/", "c:/NewDir/", "NewDir", out strerror);
		Console.WriteLine(strerror);
#if DELETE
                if (strerror.Length == 0)
                {
 			Delete("W3SVC/1/ROOT/", "c:/NewDir/", "NewDir", out strerror); 
			Console.WriteLine(strerror);                 
                }
#endif
   	}
        /// <summary>
        /// Creates an IIS 6.0 Virtual Root
        /// </summary>
        /// <param name="RootWeb"></param>
        /// <param name="PhysicalDirectory"> </param>
        /// <param name="VirtualDirectory"> </param>
        /// <param name="Error"> </param>
        static public void Create(string RootWeb, string PhysicalDirectory, string VirtualDirectory, out string Error)
        {
            try
            {
			// Create a new instance of IIS_WebVirtualDirSetting and set the appropriate properties
  			    ManagementClass vdirSettingClass = new ManagementClass("//jnoss3/root/MicrosoftIISv2:IIs_WebVirtualDirSetting");
			    ManagementObject vdirSetting = vdirSettingClass.CreateInstance ();
			    vdirSetting["Name"] = RootWeb + VirtualDirectory;
			    vdirSetting["Path"] = PhysicalDirectory;
			    vdirSetting["AppFriendlyName"]=VirtualDirectory;
			    vdirSetting["AppRoot"] = ("/LM/" + RootWeb + VirtualDirectory);
			    vdirSetting.Put();

                // Call the AppCreate2 method on the corresponding instance of IIS_WebVirtualDir
                ManagementObject vdir = new ManagementObject("//jnoss3/root/MicrosoftIISv2:IIs_WebVirtualDir.Name='" + RootWeb + VirtualDirectory + "'");
                object[] args = { 2 };
                vdir.InvokeMethod("AppCreate2", args);
                Error = "";
            }
            catch(Exception e)
            {
                Error = e.ToString();
            }
        }

        /// <summary>
        /// Deletes an IIS 6.0 Virtual Root
        /// </summary>
        /// <param name="WebRoot"> </param>
        /// <param name="PhysicalDirectory"> </param>
        /// <param name="VirtualDirectory"> </param>
        /// <param name="Error"> </param>
 #if DELETE
        static public void Delete(string RootWeb, string PhysicalDirectory, string VirtualDirectory, out string Error)
        {
            try
            {
                // delete IIS VRoot
                ManagementObject vdir = new ManagementObject("root/MicrosoftIISv2:IIs_WebVirtualDir='" +  RootWeb + VirtualDirectory + "'");
                object[] args = { true };
                vdir.InvokeMethod("AppDelete", args);
                vdir.Delete();
                // delete physical directory
                if (Directory.Exists(PhysicalDirectory))
                {
 	            Directory.Delete(PhysicalDirectory, true);
                }
                Error = "";
            }
            catch(Exception e)
            {
                Error = e.ToString();   
            }
        }
#endif
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\invokemethod\class1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace InvokeMethod
{
using System;
using System.Management;
using System.Collections;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		ManagementClass processClass = new ManagementClass ("Win32_Process");

		// 1. Invocation using parameter instances
		ManagementBaseObject inParams = processClass.GetMethodParameters ("Create");
		inParams["CommandLine"] = "calc.exe";
		ManagementBaseObject outParams = processClass.InvokeMethod ("Create", inParams, null);
		Console.WriteLine ("Creation of calculator process returned: " + outParams["returnValue"]);
		Console.WriteLine ("Process id: " + outParams["processId"]);

		// 2. Invocation using args array
		object[] methodArgs = { "notepad.exe", null, null, 0 };
		object result = processClass.InvokeMethod ("Create", methodArgs);
		Console.WriteLine ("Creation of process returned: " + result);
		Console.WriteLine ("Process id: " + methodArgs[3]);
        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\invokemethodasync\class1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace InvokeMethodAsync
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
        ManagementClass processClass = new ManagementClass("Win32_Process");

		// Create a watcher and completion handler
		ManagementOperationWatcher watcher = new ManagementOperationWatcher();
		ObjectReadyHandler objHandler = new ObjectReadyHandler();
            watcher.ObjectReady += new ObjectReadyEventHandler(objHandler.NewObject);

		// Invoke using parameter instances
		ManagementBaseObject inParams = processClass.GetMethodParameters("Create");
		inParams.Properties["CommandLine"].Value = "calc.exe";
		processClass.InvokeMethod(watcher, "Create", inParams, null);
			
		while(!objHandler.IsComplete)				//Infinite loop here
		{
			System.Threading.Thread.Sleep(1000);
		}
		objHandler.Reset(); 

		ManagementBaseObject o = objHandler.ReturnObject;
		Console.WriteLine(o.GetText(TextFormat.MOF));			
		Console.WriteLine ("Creation of calculator process returned: " + o["returnValue"]);
		Console.WriteLine ("Process id: " + o["processId"]);

		return 0;
    }

	public class ObjectReadyHandler
	{
		private bool m_bIsComplete = false;
        ManagementBaseObject m_returnObj;

		public void NewObject(object sender, ObjectReadyEventArgs e)
		{
			try
			{
				Console.WriteLine("New Object arrived!");
				m_returnObj = e.NewObject;
				m_bIsComplete = true;
			}
			catch (Exception ex)
			{
				Console.WriteLine("e.NewObject exception in ObjectHandler class - ");
				Console.Write(ex.Message + ex.StackTrace);
			}
		}

		public ManagementBaseObject ReturnObject
		{
			get {return m_returnObj;}
		}

		public bool IsComplete 
		{
			get{return m_bIsComplete;}
		}
		
		public void Reset()
		{
			m_bIsComplete = false;
		}
	}
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\nspath\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\nullcontext\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\jeffcoop\generictests\generictests.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Management;
using System.Management.Instrumentation;
using System.Configuration;
using System.Runtime.InteropServices;
using System.Security;
using System.Collections;
using System.Threading;

//[assembly:Instrumented]

#if xxx
[System.ComponentModel.RunInstaller(true)]
public class MyInstaller : DefaultManagementProjectInstaller {}
#endif

public class SimpleWriteInstance : Instance
{
    public string name;
    public int length;
}

[InstrumentationClass(InstrumentationType.Abstract)]
public class Embedded
{
    public int i;
    public int j;
}

[InstrumentationClass(InstrumentationType.Abstract)]
public class OutterEmbedded
{
    public string outterName = "OutterEmbedded";
    public InnerEmbedded inner = new InnerEmbedded();
}

[InstrumentationClass(InstrumentationType.Abstract)]
public class InnerEmbedded
{
    [ManagedName("innerNameAlt")] public string innerName = "InnerEmbedded";
}

[InstrumentationClass(InstrumentationType.Abstract)]
public struct StructEmbed
{
    public int i;
    public int j;
    public string str;
}


[InstrumentationClass(InstrumentationType.Event)]
public class ComplexBeep : BaseEvent
{
    public OutterEmbedded embed = new OutterEmbedded();
    public string name = "Hi there";
    public StructEmbed embeddedStruct;
    public StructEmbed[] embeddedStructArray = new StructEmbed[5];

    public ComplexBeep()
    {
        embeddedStruct.str = "wow";
        embeddedStructArray[3].i=3;
        embeddedStructArray[3].str="cool";

    }
}


class UnknownObject
{
    public string str = "hi";
}

[InstrumentationClass(InstrumentationType.Event)]
public class Beep1 : BaseEvent
{
    public int tone;
    public int tone2;
}

[InstrumentationClass(InstrumentationType.Event)]
public class ManyThings : BaseEvent
{
    public object [] things;
    public ManagementObject obj;
    public ManagementObject[] objects;
}


[InstrumentationClass(InstrumentationType.Event)]
[ManagedName("Beep2Alt")]
public class Beep2 : Beep1
{
    [ManagedName("xxxAlt")] public int xxx;
    public int yyy;
    public int zzz
    {
        get
        {
            return 93;
        }
    }
    public string str;
    public int[] rg;
    public int[] rg2;
    public string[] strarray;
    public string[] strarray2 = new string[] {"how", "are", "you"};

    public Embedded embed;
    public Embedded embed2;
    public Embedded[] embeds1;
    public Embedded[] embeds2;
    public Embedded[] embeds3;


}

[InstrumentationClass(InstrumentationType.Event)]
public class ChangeEvent : BaseEvent
{
    public object PreviousInstance;
    public object TargetInstance;
}

[InstrumentationClass(InstrumentationType.Event)]
public class DiverseEvent : BaseEvent
{
    public DateTime dt;
    public TimeSpan ts;
    public DateTime dt2;
    public TimeSpan ts2;
    public Byte b = 3;
    public SByte sb = -5;
    public Int16 i16 = -31234;
    public UInt16 ui16 = 45678;
    public Int32 i32 = -123456;
    public UInt32 ui32 = 123456;
    public Int64 i64 = -1234567890123;
    public UInt64 ui64 = 1234567890123;
    public char c = 'A';
    public Single sing = 1.234F;
    public Double dbl = 1.234567;
    public bool boolTrue = true;
    public bool boolFalse = false;
}

[InstrumentationClass(InstrumentationType.Event)]
public class DiverseEvent2 : BaseEvent
{
    public string name;
    public int i;
    public DateTime[] dates = new DateTime[] {DateTime.Now, new DateTime(), DateTime.Now};
    public DateTime[] dates2;
    public TimeSpan[] timeSpans  = new TimeSpan[] {new TimeSpan(5,4,3,2,456), new TimeSpan(), new TimeSpan(1,2,3,4,5)};
    public TimeSpan[] timeSpans2;
    public Byte[] bytes = new Byte[] {1,2,3};
    public Byte[] bytes2;
    public SByte[] sbytes = new SByte[] {-1,-2,-3};
    public SByte[] sbytes2;
    public Int16[] int16s = new Int16[] {-31234, -31235};
    public Int16[] int16s2;
    public UInt16[] uint16s = new UInt16[] {45678, 45679};
    public UInt16[] uint16s2;
    public Int32[] int32s = new Int32[] {-123456, -123457};
    public Int32[] int32s2;
    public UInt32[] uint32s = new UInt32[] {123456, 123568};
    public UInt32[] uint32s2;
    public Int64[] int64s = new Int64[] {-1234567890123, -1234567890124};
    public Int64[] int64s2;
    public UInt64[] uint64s = new UInt64[] {1234567890123, 1234567890123};
    public UInt64[] uint64s2;
    public char[] chars = new char[] {'A', 'B', 'C'};
    public char[] chars2;
    public Single[] singles = new Single[] {1.234F, 1.2345F};
    public Single[] singles2;
    public Double[] doubles = new Double[] {1.234567, 1.2345678};
    public Double[] doubles2;
    public bool[] bools = new bool[] {true, true, false, true};
    public bool[] bools2;
}

[InstrumentationClass(InstrumentationType.Event)]
public class VeryDiverseEvent : DiverseEvent
{
    public DateTime[] dates = new DateTime[] {DateTime.Now, new DateTime(), DateTime.Now};
    public TimeSpan[] timeSpans  = new TimeSpan[] {new TimeSpan(5,4,3,2,456), new TimeSpan(), new TimeSpan(1,2,3,4,5)};
    public Byte[] bytes = new Byte[] {1,2,3};
    public SByte[] sbytes = new SByte[] {-1,-2,-3};
    public Int16[] int16s = new Int16[] {-31234, -31235};
    public UInt16[] uint16s = new UInt16[] {45678, 45679};
    public Int32[] int32s = new Int32[] {-123456, -123457};
    public UInt32[] uint32s = new UInt32[] {123456, 123568};
    public Int64[] int64s = new Int64[] {-1234567890123, -1234567890124};
    public UInt64[] uint64s = new UInt64[] {1234567890123, 1234567890123};
    public char[] chars = new char[] {'A', 'B', 'C'};
    public Single[] singles = new Single[] {1.234F, 1.2345F};
    public Double[] doubles = new Double[] {1.234567, 1.2345678};
    public bool[] bools = new bool[] {true, true, false, true};
}

[InstrumentationClass(InstrumentationType.Instance)]
[ManagedName("SimpleManagedInstance")]
public class SimpleInstance : Instance
{
    public int i;
    public string name;
}

[InstrumentationClass(InstrumentationType.Instance)]
public class DiverseInstance : Instance
{
    public DateTime dt;
    public TimeSpan ts;
    public DateTime dt2;
    public TimeSpan ts2;
    public Byte b = 3;
    public SByte sb = -5;
    public Int16 i16 = -31234;
    public UInt16 ui16 = 45678;
    public Int32 i32 = -123456;
    public UInt32 ui32 = 123456;
    public Int64 i64 = -1234567890123;
    public UInt64 ui64 = 1234567890123;
    public char c = 'A';
    public Single sing = 1.234F;
    public Double dbl = 1.234567;
    public bool boolTrue = true;
    public bool boolFalse = false;
    public string name;
    public int i;
    public DateTime[] dates = new DateTime[] {DateTime.Now, new DateTime(), DateTime.Now};
    public DateTime[] dates2;
    public TimeSpan[] timeSpans  = new TimeSpan[] {new TimeSpan(5,4,3,2,456), new TimeSpan(), new TimeSpan(1,2,3,4,5)};
    public TimeSpan[] timeSpans2;
    public Byte[] bytes = new Byte[] {1,2,3};
    public Byte[] bytes2;
    public SByte[] sbytes = new SByte[] {-1,-2,-3};
    public SByte[] sbytes2;
    public Int16[] int16s = new Int16[] {-31234, -31235};
    public Int16[] int16s2;
    public UInt16[] uint16s = new UInt16[] {45678, 45679};
    public UInt16[] uint16s2;
    public Int32[] int32s = new Int32[] {-123456, -123457};
    public Int32[] int32s2;
    public UInt32[] uint32s = new UInt32[] {123456, 123568};
    public UInt32[] uint32s2;
    public Int64[] int64s = new Int64[] {-1234567890123, -1234567890124};
    public Int64[] int64s2;
    public UInt64[] uint64s = new UInt64[] {1234567890123, 1234567890123};
    public UInt64[] uint64s2;
    public char[] chars = new char[] {'A', 'B', 'C'};
    public char[] chars2;
    public Single[] singles = new Single[] {1.234F, 1.2345F};
    public Single[] singles2;
    public Double[] doubles = new Double[] {1.234567, 1.2345678};
    public Double[] doubles2;
    public bool[] bools = new bool[] {true, true, false, true};
    public bool[] bools2;
    public OutterEmbedded embeddedobject = new OutterEmbedded();
    public OutterEmbedded embeddedobject2 = null;
    public object embeddedobject3 = new OutterEmbedded();
    public object embeddedobject4 = null;
}

public class NewBeepXYZ : BaseEvent
{
    public int i;
}

public class NewBeepABCD : BaseEvent
{
    public int i;
}

public class NestedABC : NewBeepABCD
{
    public int j;
}


public class MyInstanceABC : Instance
{
    public string Name;
}
class App
{
    static void Main(string[] args)
    {
        SimpleWriteInstance inst1 = new SimpleWriteInstance();
        inst1.name = "Jeff";
        inst1.length = 33;
        inst1.Published = true;
        Console.WriteLine("inst1 published");
        Console.ReadLine();
        inst1.Published = false;
        Console.WriteLine("inst1 revoked");

        Instrumentation.Publish(typeof(App));
        Console.WriteLine("Get ready to start");
        Console.ReadLine();
        NestedABC nest = new NestedABC();
        nest.Fire();
        MyInstanceABC abc = new MyInstanceABC();
        abc.Name = "Lauren";
        Instrumentation.Publish(abc);
//        abc.Published = true;
        Console.WriteLine("Get ready to end");
//        return;
        ManagementClass classNamespace = new ManagementClass("root:__NAMESPACE");
        IntPtr ip = (IntPtr)classNamespace;


#if xxx
        string[] installArgs = new String[] {
                                                "/logfile=",
                                                "/LogToConsole=false",
                                                "/ShowCallStack",
                                                typeof(App).Assembly.Location,
        };
        System.Configuration.Install.ManagedInstallerClass.InstallHelper(installArgs);
#endif

        Console.WriteLine("done");
        Beep1 beep = new Beep1();
        beep.tone = 37;
        beep.tone2 = 55;
        beep.Fire();

        Beep2 beep2 = new Beep2();
        beep2.tone = 1;
        beep2.tone2 = 3;
        beep2.xxx = 12;
        beep2.yyy = 31;
        beep2.str = "Hello there";
        beep2.rg = new int[3];
        beep2.rg[0] = 73;
        beep2.rg[2] = 88;
        beep2.embed = new Embedded();
        beep2.embed.i = 987;
        beep2.embed.j = 654;

        beep2.embeds2 = new Embedded[4];
        beep2.embeds2[0] = new Embedded();
        beep2.embeds2[0].i = 23;
        beep2.embeds2[0].j = 24;
        beep2.embeds2[1] = new Embedded();
        beep2.embeds2[1].i = 25;
        beep2.embeds2[1].j = 26;
        beep2.embeds2[2] = new Embedded();
        beep2.embeds2[2].i = 27;
        beep2.embeds2[2].j = 28;
        beep2.embeds2[3] = new Embedded();
        beep2.embeds2[3].i = 29;
        beep2.embeds2[3].j = 30;


        beep2.embeds3 = new Embedded[3];
        beep2.embeds3[0] = new Embedded();
        beep2.embeds3[0].i = 23;
        beep2.embeds3[0].j = 24;
        beep2.embeds3[2] = new Embedded();
        beep2.embeds3[2].i = 27;
        beep2.embeds3[2].j = 28;

        beep2.Fire();

        ChangeEvent change = new ChangeEvent();

        Embedded embed = new Embedded();
        embed.i = 12;
        embed.j = 24;
        change.Fire();

        change.PreviousInstance = embed;
        change.Fire();

        change.TargetInstance = new OutterEmbedded();
        change.Fire();

        // PreviousInstance should be null
        change.PreviousInstance = new UnknownObject();
        change.Fire();

        // TargetInstance should be null
        change.TargetInstance = "how are you";
        change.Fire();

        // TargetInstance should be null
        change.TargetInstance = 37;
        change.Fire();

        change.TargetInstance = new ManagementObject("root:__Namespace.Name='cimv2'");
        change.Fire();

        new ComplexBeep().Fire();

        ManyThings things = new ManyThings();
        things.Fire();

        things.obj = new ManagementClass(@"root\cimv2:Win32_Process");
        things.Fire();

        things.obj = new ManagementObject("root:__Namespace.Name='cimv2'");
        things.objects = new ManagementObject[] {new ManagementObject("root:__Namespace.Name='cimv2'"), new ManagementObject("root:__Namespace.Name='default'")};
        things.things = new Object[] {};
        things.Fire();

        things.obj = null;
        things.objects = null;
        things.things = new Object[] {new OutterEmbedded(), new ManagementObject("root:__Namespace.Name='cimv2'")};
        things.Fire();

        things.things = new Object[] {new OutterEmbedded(), null, new ManagementObject("root:__Namespace.Name='cimv2'")};
        things.Fire();

        things.things = null;
        things.objects = null;
        things.obj = null;
        things.Fire();

        // BUG Wbem Test crashes if you try to view array of ManagementObjects!!!!!!!!!!!!!!!
        things.obj = new ManagementClass();
        things.objects = new ManagementObject[] {new ManagementObject()};
        things.things = new Object[] {new OutterEmbedded(), new ManagementObject(), new ManagementObject("root:__Namespace.Name='cimv2'")};
        things.Fire();

        DiverseEvent diverse = new DiverseEvent();
        diverse.dt = DateTime.Now;
        diverse.ts2 = new TimeSpan(3,2,1,5,654);
        diverse.Fire();

        DiverseEvent2 diverse2 = new DiverseEvent2();
        diverse2.name = "hello";
        diverse2.i = 74;
        diverse2.Fire();

        Console.WriteLine("fired");
        Console.WriteLine("press enter");
        Console.ReadLine();
        SimpleInstance inst = new SimpleInstance();
        DiverseInstance inst2 = new DiverseInstance();
        DiverseInstance inst3 = new DiverseInstance();
        inst.i=12;
        inst.name = "Lauren";

        inst.Published = true;
        inst2.Published = true;
        inst3.Published = true;
        Console.WriteLine("published");
        Console.ReadLine();
        inst.Published = false;
        inst2.Published = false;
        inst3.Published = false;
        Console.WriteLine("revoked");
        Console.ReadLine();
        inst.Published = true;
        inst2.Published = true;
        inst3.Published = true;
        Console.WriteLine("published");
        Console.ReadLine();
        inst.Published = false;
        inst2.Published = false;
        inst3.Published = false;
        Console.WriteLine("revoked");
        Console.ReadLine();

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\noauth\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]

[assembly:CLSCompliant(true)]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\noauth\class1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace NoAuth
{
using System;
using System.Management;

/// <summary>
///    Summary description for Class1.
/// </summary>
public class Class1
{
    public Class1()
    {
        //
        // TODO: Add Constructor Logic here
        //
    }

    public static int Main(string[] args)
    {
		string mylocale="ms_409";

		try 
		{
			// Setting the ManagementObject with the ConnectionOptions
			ConnectionOptions con = new ConnectionOptions(
						mylocale,
						".\\Administrator",
						"",
						null,
						ImpersonationLevel.Impersonate,
						AuthenticationLevel.None,
						false,
						null);

			ManagementPath mypath = new ManagementPath("Win32_LogicalDisk");
			ManagementScope myscope = new ManagementScope("\\\\w23-wmichssp17\\root\\cimv2",con);
			ManagementClass pobj = new ManagementClass(myscope,mypath,null);
			pobj.Get();
			Console.WriteLine(pobj.Scope.Options.Authentication); 
			Console.WriteLine(pobj["__PATH"]); 
	    }
		catch (ManagementException e)
	    {	
			Console.WriteLine("Access is Denied and cannot open class. " + e.Message); 
		}
		catch (Exception e)
		{
			Console.WriteLine(e.Message + e.StackTrace);
		}
        return 0;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\pathtest\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\priv2\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitle("")]
[assembly:AssemblyDescription("")]
[assembly:AssemblyConfiguration("")]
[assembly:AssemblyCompany("")]
[assembly:AssemblyProduct("")]
[assembly:AssemblyCopyright("")]
[assembly:AssemblyTrademark("")]
[assembly:AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Revision
//      Build Number
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// COM+ 2.0 documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified - the assembly cannot be signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. 
//   (*) If the key file and a key name attributes are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP - that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the file is installed into the CSP and used.
//   (*) Delay Signing is an advanced option - see the COM+ 2.0 documentation for 
//       more information on this.
//
[assembly:AssemblyDelaySign(false)]
[assembly:AssemblyKeyFile("")]
[assembly:AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\config\wmi\wmiclient\test\jeffcoop\bugrepros\bugrepros.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Management;
using System.Diagnostics;
using System.Threading;
using System.Runtime.InteropServices;
using System.Management.Instrumentation;
using System.Windows.Forms;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using System.Reflection;
class AppH2
{
    static void Main() 
    {
        int i=0;
        ManagementScope scope = new ManagementScope(@"root\cimv2");
        ManagementPath classPath = new ManagementPath("__NAMESPACE");
        //scope.Connect();
        while (true) 
        {
            Console.WriteLine(i++);
            ManagementClass mc = new ManagementClass(scope, classPath, null);;
            Console.WriteLine(scope.IsConnected);
            mc.GetInstances();
            GC.Collect();
            GC.WaitForPendingFinalizers();
        }
    }
}

class AppH
{
    [STAThread]
    static void Mainz()
    {
//        ManagementClass c = new ManagementClass(@"\\InvalidServer\root\cimv2" , "Win32_Process", null);
//        c.Get();
        ConnectionOptions options = new ConnectionOptions(null, @"REDMOND\xxx", "", null, ImpersonationLevel.Impersonate, AuthenticationLevel.Packet, true, null, TimeSpan.MaxValue);
        ManagementScope scope = new ManagementScope(@"\\serverrr\root\cimv2", options);
        ManagementClass c = new ManagementClass(scope, new ManagementPath("Win32_Process"), null);
//        ManagementClass c = new ManagementClass(@"\\serverrr\root\cimv2", "Win32_Process", null);
        ManagementOperationObserver watcher = new ManagementOperationObserver();
        watcher.ObjectReady += new ObjectReadyEventHandler(ObjReady);
        c.GetInstances(watcher);
        Console.WriteLine("ready");
        Console.ReadLine();
#if xxx
        foreach(ManagementObject o in c.GetInstances())
        {
            if("calc.exe".Equals(o["Name"].ToString().ToLower()))
            {
                Console.WriteLine("terminating");
                o.InvokeMethod("Terminate", new object[] {0});
            }
        }
#endif
    }
    static void ObjReady(object o1, ObjectReadyEventArgs args)
    {
        Console.WriteLine(args.NewObject["name"]);
        ManagementObject o = (ManagementObject)args.NewObject;
        if("calc.exe".Equals(o["Name"].ToString().ToLower()))
        {
            Console.WriteLine("terminating");
            o.InvokeMethod("Terminate", new object[] {0});
            Console.WriteLine("done");
        }
    }
}
public class inst : Instance
{
    public int i;
}
public class Appc
{
    [MTAThread]
    static void Mainz()
    {
        while(true)
        {
            for (int i=0;i<100;i++) 
            {
                ManagementClass c = new ManagementClass();
                c.Scope = new ManagementScope("root/default");
                c.Properties.Add("__CLASS", "NewClass", CimType.String);
                c.Properties.Add("MyKey", "WMI", CimType.String);
                c.Put();
                Console.Write("{0} ", i);
            }
            GC.Collect();
            GC.WaitForPendingFinalizers();
            GC.Collect();
            GC.WaitForPendingFinalizers();
        }
    }
}
public class Appe
{
    static void Mainz()
    {
        ConnectionOptions options = new ConnectionOptions(null, "serverrr\\Lauren", "xxx", null, ImpersonationLevel.Impersonate, AuthenticationLevel.Packet, true, null, TimeSpan.MaxValue);
        ManagementScope scope = new ManagementScope(@"\\serverrr\root\cimv2", options);
        ManagementClass classObj = new ManagementClass(scope, new ManagementPath("Win32_Process"), null);
        ManagementObjectCollection processes = classObj.GetInstances();
        foreach(ManagementObject obj in processes)
        {
            ManagementBaseObject outParams = obj.InvokeMethod("GetOwner", null, null);
            Console.WriteLine(@"{1}\{2} - {0}", obj["Name"], outParams["Domain"], outParams["User"]);
        }
    }
}
public class BadProp : Instance
{
    public string name;
    public string Name2;
}

[InstrumentationClass(InstrumentationType.Instance)]
public class BadProp2
{
}

class Appo
{
    static void Maina()
    {
        Instrumentation.RegisterAssembly(typeof(Appo).Assembly);

        BadProp2 inst2 = new BadProp2();
        Instrumentation.Publish(inst2);
        Instrumentation.Publish(inst2);
        Instrumentation.Revoke(inst2);
        Instrumentation.Revoke(inst2);

        BadProp inst = new BadProp();
        Instrumentation.Publish(inst);
        Console.WriteLine(inst.Published);
        Instrumentation.Publish(inst);
        Console.WriteLine(inst.Published);

        Instrumentation.Revoke(inst);
        Console.WriteLine(inst.Published);

        inst.Published = true;
        Console.WriteLine(inst.Published);

    }
}
class App
{
    [STAThread]
    static void Maina(string[] args)
    {
        Thread thread = new Thread(new ThreadStart(Test2));
        thread.ApartmentState = ApartmentState.STA;
        thread.IsBackground = false;
        thread.Start();
        Console.WriteLine("go");
        Console.ReadLine();


        Thread threadInit = new Thread(new ThreadStart(Init));
        threadInit.ApartmentState = ApartmentState.MTA;
        threadInit.Start();
        threadInit.Join();
        GC.Collect();
        GC.WaitForPendingFinalizers();
        GC.Collect();
        GC.WaitForPendingFinalizers();

        try
        {
            Test();
        }
        catch(Exception e)
        {
            Console.WriteLine(e.Message);
        }

        evt.Set();
        thread.Join();
    }
    static void Init()
    {
        ConnectionOptions options = new ConnectionOptions(null, "serverrr\\Lauren", "aaaa", null, ImpersonationLevel.Impersonate, AuthenticationLevel.Packet, true, null, TimeSpan.MaxValue);
        ManagementScope scope = new ManagementScope(@"\\serverrr\root\cimv2", options);
        classObj = new ManagementClass(scope, new ManagementPath("Win32_Process"), null);
        //		Console.WriteLine(classObj.GetText(TextFormat.Mof));
        try
        {
            //            classObj.InvokeMethod("create", null, null);
        }
        catch
        {
        }

    }
    static void Test()
    {
        UInt32 processId;
        UInt32 returnValue = Create("notepad.exe", null, null, out processId);
        Console.WriteLine(processId);
    }
    static ManualResetEvent evt = new ManualResetEvent(false);
    static void Test2()
    {
        evt.WaitOne();
        UInt32 processId;
        UInt32 returnValue = Create("notepad.exe", null, null, out processId);
        Console.WriteLine(processId);
    }

    static ManagementClass classObj;

    static System.UInt32 Create(string CommandLine, string CurrentDirectory, ManagementBaseObject ProcessStartupInformation, out System.UInt32 ProcessId) 
    {
        classObj.InvokeMethod("create", null, null);
        ProcessId = 0;
        return 0;
#if other_way
        ManagementBaseObject inParams = null;
        inParams = classObj.GetMethodParameters("Create");
        inParams["CommandLine"] = CommandLine;
        inParams["CurrentDirectory"] = CurrentDirectory;
        inParams["ProcessStartupInformation"] = ProcessStartupInformation;
        ManagementBaseObject outParams = classObj.InvokeMethod("Create", inParams, null);
        ProcessId = System.Convert.ToUInt32(outParams.Properties["ProcessId"].Value);
        return Convert.ToUInt32(outParams.Properties["ReturnValue"].Value);
#endif
    }
}



public class Cyclic : BaseEvent
{
    public string name;
    public Cyclic next;
    public Cyclic[] moreObjects;
}

public class DecimalSample : Instance
{
    [IgnoreMember] public Decimal amount;
    [ManagedName("amount")] public double _amount
    {
        get
        {
            return (double)amount;
        }
    }
}

class Appzzz
{
    static void Mainz()
    {
        Console.WriteLine("Start");
        Instrumentation.RegisterAssembly(typeof(Appzzz).Assembly);
        Console.WriteLine("Finish");
        DecimalSample instance = new DecimalSample();
        instance.amount = Decimal.Parse("7.310000");
        instance.Published = true;
        Console.WriteLine("Amount = {0}", instance.amount);
        Console.ReadLine();
        instance.Published = false;
    }
    static void Main2()
    {
        Cyclic c = new Cyclic();
        c.next = new Cyclic();
        c.next.name = "inner";
        c.name = "outer";
        c.moreObjects = new Cyclic[] {c.next, c.next};
        c.Fire();
        Console.WriteLine("done");
        Console.ReadLine();  
    }
}
#if nnn

public class evtevt : BaseEvent {}
public class inst : Instance
{
    public int i201;
    public int i202;
#if xxxx
    public int i203;
    public int i204;
    public int i205;
    public int i206;
    public int i207;
    public int i208;
    public int i209;
    public int i200;
    public int i211;
    public int i212;
    public int i213;
    public int i214;
    public int i215;
    public int i216;
    public int i217;
    public int i218;
    public int i219;
    public int i210;
    public int i221;
    public int i222;
    public int i223;
    public int i224;
    public int i225;
    public int i226;
    public int i227;
    public int i228;
    public int i229;
    public int i220;
    public int i231;
    public int i232;
    public int i233;
    public int i234;
    public int i235;
    public int i236;
    public int i237;
    public int i238;
    public int i239;
    public int i230;
    public int i241;
    public int i242;
    public int i243;
    public int i244;
    public int i245;
    public int i246;
    public int i247;
    public int i248;
    public int i249;
    public int i240;
    public int i251;
    public int i252;
    public int i253;
    public int i254;
    public int i255;
    public int i256;
    public int i257;
    public int i258;
    public int i259;
    public int i250;
    public int i261;
    public int i262;
    public int i263;
    public int i264;
    public int i265;
    public int i266;
    public int i267;
    public int i268;
    public int i269;
    public int i260;
    public int i271;
    public int i272;
    public int i273;
    public int i274;
    public int i275;
    public int i276;
    public int i277;
    public int i278;
    public int i279;
    public int i270;
    public int i281;
    public int i282;
    public int i283;
    public int i284;
    public int i285;
    public int i286;
    public int i287;
    public int i288;
    public int i289;
    public int i280;
    public int i291;
    public int i292;
    public int i293;
    public int i294;
    public int i295;
    public int i296;
    public int i297;
    public int i298;
    public int i299;
    public int i290;
    public int i301;
    public int i302;
    public int i303;
    public int i304;
    public int i305;
    public int i306;
    public int i307;
    public int i308;
    public int i309;
    public int i300;
    public int i311;
    public int i312;
    public int i313;
    public int i314;
    public int i315;
    public int i316;
    public int i317;
    public int i318;
    public int i319;
    public int i310;
    public int i321;
    public int i322;
    public int i323;
    public int i324;
    public int i325;
    public int i326;
    public int i327;
    public int i328;
    public int i329;
    public int i320;
    public int i331;
    public int i332;
    public int i333;
    public int i334;
    public int i335;
    public int i336;
    public int i337;
    public int i338;
    public int i339;
    public int i330;
    public int i341;
    public int i342;
    public int i343;
    public int i344;
    public int i345;
    public int i346;
    public int i347;
    public int i348;
    public int i349;
    public int i340;
    public int i351;
    public int i352;
    public int i353;
    public int i354;
    public int i355;
    public int i356;
    public int i357;
    public int i358;
    public int i359;
    public int i350;
    public int i361;
    public int i362;
    public int i363;
    public int i364;
    public int i365;
    public int i366;
    public int i367;
    public int i368;
    public int i369;
    public int i360;
    public int i371;
    public int i372;
    public int i373;
    public int i374;
    public int i375;
    public int i376;
    public int i377;
    public int i378;
    public int i379;
    public int i370;
    public int i381;
    public int i382;
    public int i383;
    public int i384;
    public int i385;
    public int i386;
    public int i387;
    public int i388;
    public int i389;
    public int i380;
    public int i391;
    public int i392;
    public int i393;
    public int i394;
    public int i395;
    public int i396;
    public int i397;
    public int i398;
    public int i399;
    public int i390;
    public int i401;
    public int i402;
    public int i403;
    public int i404;
    public int i405;
    public int i406;
    public int i407;
    public int i408;
    public int i409;
    public int i400;
    public int i411;
    public int i412;
    public int i413;
    public int i414;
    public int i415;
    public int i416;
    public int i417;
    public int i418;
    public int i419;
    public int i410;
    public int i421;
    public int i422;
    public int i423;
    public int i424;
    public int i425;
    public int i426;
    public int i427;
    public int i428;
    public int i429;
    public int i420;
    public int i431;
    public int i432;
    public int i433;
    public int i434;
    public int i435;
    public int i436;
    public int i437;
    public int i438;
    public int i439;
    public int i430;
    public int i441;
    public int i442;
    public int i443;
    public int i444;
    public int i445;
    public int i446;
    public int i447;
    public int i448;
    public int i449;
    public int i440;
    public int i451;
    public int i452;
    public int i453;
    public int i454;
    public int i455;
    public int i456;
    public int i457;
    public int i458;
    public int i459;
    public int i450;
    public int i461;
    public int i462;
    public int i463;
    public int i464;
    public int i465;
    public int i466;
    public int i467;
    public int i468;
    public int i469;
    public int i460;
    public int i471;
    public int i472;
    public int i473;
    public int i474;
    public int i475;
    public int i476;
    public int i477;
    public int i478;
    public int i479;
    public int i470;
    public int i481;
    public int i482;
    public int i483;
    public int i484;
    public int i485;
    public int i486;
    public int i487;
    public int i488;
    public int i489;
    public int i480;
    public int i491;
    public int i492;
    public int i493;
    public int i494;
    public int i495;
    public int i496;
    public int i497;
    public int i498;
    public int i499;
    public int i490;
    public int i001;
    public int i002;
    public int i003;
    public int i004;
    public int i005;
    public int i006;
    public int i007;
    public int i008;
    public int i009;
    public int i000;
    public int i011;
    public int i012;
    public int i013;
    public int i014;
    public int i015;
    public int i016;
    public int i017;
    public int i018;
    public int i019;
    public int i010;
    public int i021;
    public int i022;
    public int i023;
    public int i024;
    public int i025;
    public int i026;
    public int i027;
    public int i028;
    public int i029;
    public int i020;
    public int i031;
    public int i032;
    public int i033;
    public int i034;
    public int i035;
    public int i036;
    public int i037;
    public int i038;
    public int i039;
    public int i030;
    public int i041;
    public int i042;
    public int i043;
    public int i044;
    public int i045;
    public int i046;
    public int i047;
    public int i048;
    public int i049;
    public int i040;
    public int i051;
    public int i052;
    public int i053;
    public int i054;
    public int i055;
    public int i056;
    public int i057;
    public int i058;
    public int i059;
    public int i050;
    public int i061;
    public int i062;
    public int i063;
    public int i064;
    public int i065;
    public int i066;
    public int i067;
    public int i068;
    public int i069;
    public int i060;
    public int i071;
    public int i072;
    public int i073;
    public int i074;
    public int i075;
    public int i076;
    public int i077;
    public int i078;
    public int i079;
    public int i070;
    public int i081;
    public int i082;
    public int i083;
    public int i084;
    public int i085;
    public int i086;
    public int i087;
    public int i088;
    public int i089;
    public int i080;
    public int i091;
    public int i092;
    public int i093;
    public int i094;
    public int i095;
    public int i096;
    public int i097;
    public int i098;
    public int i099;
    public int i090;
    public int i101;
    public int i102;
    public int i103;
    public int i104;
    public int i105;
    public int i106;
    public int i107;
    public int i108;
    public int i109;
    public int i100;
    public int i111;
    public int i112;
    public int i113;
    public int i114;
    public int i115;
    public int i116;
    public int i117;
    public int i118;
    public int i119;
    public int i110;
    public int i121;
    public int i122;
    public int i123;
    public int i124;
    public int i125;
    public int i126;
    public int i127;
    public int i128;
    public int i129;
    public int i120;
    public int i131;
    public int i132;
    public int i133;
    public int i134;
    public int i135;
    public int i136;
    public int i137;
    public int i138;
    public int i139;
    public int i130;
    public int i141;
    public int i142;
    public int i143;
    public int i144;
    public int i145;
    public int i146;
    public int i147;
    public int i148;
    public int i149;
    public int i140;
    public int i151;
    public int i152;
    public int i153;
    public int i154;
    public int i155;
    public int i156;
    public int i157;
    public int i158;
    public int i159;
    public int i150;
    public int i161;
    public int i162;
    public int i163;
    public int i164;
    public int i165;
    public int i166;
    public int i167;
    public int i168;
    public int i169;
    public int i160;
    public int i171;
    public int i172;
    public int i173;
    public int i174;
    public int i175;
    public int i176;
    public int i177;
    public int i178;
    public int i179;
    public int i170;
    public int i181;
    public int i182;
    public int i183;
    public int i184;
    public int i185;
    public int i186;
    public int i187;
    public int i188;
    public int i189;
    public int i180;
    public int i191;
    public int i192;
    public int i193;
    public int i194;
    public int i195;
    public int i196;
    public int i197;
    public int i198;
    public int i199;
    public int i190;
#endif
}
    
public class inst3 : Instance
{
    public float   wmiyy_real32; //Culprit
    public double   wmiyy_real64c; //Culprit
    public DateTime wmiyy_DateTime; //Culprit
    public string wmiyy_sting;
    public string wmiyy_Alpha;
    public int wmiyy_Bravo;
    public string[] wmiyy_values1;
    public string wmiyy_values;
    public sbyte[] wmiyy_sint8nveT; 
    public sbyte[] wmiyy_sint8zveT;
    public sbyte[] wmiyy_sint8pveT;
    public sbyte   wmiyy_sint8;
    public byte[]  wmiyy_uint8zveT;
    public byte[]  wmiyy_uint8pveT;
    public byte   wmiyy_uint8;
    public short[] wmiyy_sint16zveT;
    public short[] wmiyy_sint16pveT;
    public short[] wmiyy_sint16nveT;
    public short   wmiyy_sint16;
    public int[]   wmiyy_int32zveT;
    public int[]   wmiyy_int32pveT;
    public int[]   wmiyy_int32nveT;
    public int     wmiyy_int32;
    public uint[]  wmiyy_uint32zveT;
    public uint    wmiyy_uint32;
    public long[]  wmiyy_sint64zveT;
    public long[]  wmiyy_sint64zv1eT;
    public long[] wmiyy_sint64pveT;
    public long[] wmiyy_sint64nveT;
    public long   wmiyy_sint64;
    public ulong[] wmiyy_uint64zveT;
    public ulong[] wmiyy_uint64pveT;
    public ulong   wmiyy_uint64;
    public char[]  wmiyy_char16pveT;
    public char[] wmiyy_char16nveT;
    public char[] wmiyy_char16zveT;
    public char wmiyy_char16;
    public float[] wmiyy_real32T;
    public float[] wmiyy_real32outT;
    //      public float   wmiyy_real32;
    public TimeSpan[] wmiyy_IntervalT;
    public TimeSpan   wmiyy_Interval;
    public double[] wmiyy_real64T;
    public double   wmiyy_real64;
    public bool[] wmiyy_booleantT;
    public bool[] wmiyy_booleanfT;
    public bool   wmiyy_boolean;
    public string wmiyy_stringT;
    public DateTime[] wmiyy_DateTimeT;
    //      public DateTime wmiyy_DateTime;
    public TimeSpan wmiyy_TimespanT;
    public float   wmizz_real32; //Culprit
    public double   wmizz_real64c; //Culprit
    public DateTime wmizz_DateTime; //Culprit
    public string wmizz_sting;
    public string wmizz_Alpha;
    public int wmizz_Bravo;
    public string[] wmizz_values1;
    public string wmizz_values;
    public sbyte[] wmizz_sint8nveT; 
    public sbyte[] wmizz_sint8zveT;
    public sbyte[] wmizz_sint8pveT;
    public sbyte   wmizz_sint8;
    public byte[]  wmizz_uint8zveT;
    public byte[]  wmizz_uint8pveT;
    public byte   wmizz_uint8;
    public short[] wmizz_sint16zveT;
    public short[] wmizz_sint16pveT;
    public short[] wmizz_sint16nveT;
    public short   wmizz_sint16;
    public int[]   wmizz_int32zveT;
    public int[]   wmizz_int32pveT;
    public int[]   wmizz_int32nveT;
    public int     wmizz_int32;
    public uint[]  wmizz_uint32zveT;
    public uint    wmizz_uint32;
    public long[]  wmizz_sint64zveT;
    public long[]  wmizz_sint64zv1eT;
    public long[] wmizz_sint64pveT;
    public long[] wmizz_sint64nveT;
    public long   wmizz_sint64;
    public ulong[] wmizz_uint64zveT;
    public ulong[] wmizz_uint64pveT;
    public ulong   wmizz_uint64;
    public char[]  wmizz_char16pveT;
    public char[] wmizz_char16nveT;
    public char[] wmizz_char16zveT;
    public char wmizz_char16;
    public float[] wmizz_real32T;
    public float[] wmizz_real32outT;
    //      public float   wmizz_real32;
    public TimeSpan[] wmizz_IntervalT;
    public TimeSpan   wmizz_Interval;
    public double[] wmizz_real64T;
    public double   wmizz_real64;
    public bool[] wmizz_booleantT;
    public bool[] wmizz_booleanfT;
    public bool   wmizz_boolean;
    public string wmizz_stringT;
    public DateTime[] wmizz_DateTimeT;
    //      public DateTime wmizz_DateTime;
    public TimeSpan wmizz_TimespanT;

#if xxx
    public float   wmixx_real32; //Culprit
    public double   wmixx_real64c; //Culprit
    public DateTime wmixx_DateTime; //Culprit
    public string wmixx_sting;
    public string wmixx_Alpha;
    public int wmixx_Bravo;
    public string[] wmixx_values1;
    public string wmixx_values;
    public sbyte[] wmixx_sint8nveT; 
    public sbyte[] wmixx_sint8zveT;
    public sbyte[] wmixx_sint8pveT;
    public sbyte   wmixx_sint8;
    public byte[]  wmixx_uint8zveT;
    public byte[]  wmixx_uint8pveT;
    public byte   wmixx_uint8;
    public short[] wmixx_sint16zveT;
    public short[] wmixx_sint16pveT;
    public short[] wmixx_sint16nveT;
    public short   wmixx_sint16;
    public int[]   wmixx_int32zveT;
    public int[]   wmixx_int32pveT;
    public int[]   wmixx_int32nveT;
    public int     wmixx_int32;
    public uint[]  wmixx_uint32zveT;
    public uint    wmixx_uint32;
    public long[]  wmixx_sint64zveT;
    public long[]  wmixx_sint64zv1eT;
    public long[] wmixx_sint64pveT;
    public long[] wmixx_sint64nveT;
    public long   wmixx_sint64;
    public ulong[] wmixx_uint64zveT;
    public ulong[] wmixx_uint64pveT;
    public ulong   wmixx_uint64;
    public char[]  wmixx_char16pveT;
    public char[] wmixx_char16nveT;
    public char[] wmixx_char16zveT;
    public char wmixx_char16;
    public float[] wmixx_real32T;
    public float[] wmixx_real32outT;
    //      public float   wmixx_real32;
    public TimeSpan[] wmixx_IntervalT;
    public TimeSpan   wmixx_Interval;
    public double[] wmixx_real64T;
    public double   wmixx_real64;
    public bool[] wmixx_booleantT;
    public bool[] wmixx_booleanfT;
    public bool   wmixx_boolean;
    public string wmixx_stringT;
    public DateTime[] wmixx_DateTimeT;
    //      public DateTime wmixx_DateTime;
    public TimeSpan wmixx_TimespanT;
    public float   wmi_real32; //Culprit
    public double   wmi_real64c; //Culprit
    public DateTime wmi_DateTime; //Culprit
    public string wmi_sting;
    public sbyte[] wmi_sint8nveT; 
    public sbyte[] wmi_sint8zveT;
    public sbyte[] wmi_sint8pveT;
    public sbyte   wmi_sint8;
    public byte[]  wmi_uint8zveT;
    public byte[]  wmi_uint8pveT;
    public byte   wmi_uint8;
    public short[] wmi_sint16zveT;
    public short[] wmi_sint16pveT;
    public short[] wmi_sint16nveT;
    public short   wmi_sint16;
    public int[]   wmi_int32zveT;
    public int[]   wmi_int32pveT;
    public int[]   wmi_int32nveT;
    public int     wmi_int32;
    public uint[]  wmi_uint32zveT;
    public uint    wmi_uint32;
    public long[]  wmi_sint64zveT;
    public long[]  wmi_sint64zv1eT;
    public long[] wmi_sint64pveT;
    public long[] wmi_sint64nveT;
    public long   wmi_sint64;
    public ulong[] wmi_uint64zveT;
    public ulong[] wmi_uint64pveT;
    public ulong   wmi_uint64;
    public char[]  wmi_char16pveT;
    public char[] wmi_char16nveT;
    public char[] wmi_char16zveT;
    public char wmi_char16;
    public float[] wmi_real32T;
    public float[] wmi_real32outT;
//    public float   wmi_real32;
    public TimeSpan[] wmi_IntervalT;
    public TimeSpan   wmi_Interval;
    public double[] wmi_real64T;
    public double   wmi_real64;
    public bool[] wmi_booleantT;
    public bool[] wmi_booleanfT;
    public bool   wmi_boolean;
    public string wmi_stringT;
    public DateTime[] wmi_DateTimeT;
//    public DateTime wmi_DateTime;
    public TimeSpan wmi_TimespanT;
#endif
}   

class Appzz
{
    static void Mainz()
    {
//        Console.WriteLine(AppDomain.CurrentDomain.Pr
        int c;
        for (c=0; c<10000; c++)
        {
            Instrumentation.Publish(new inst()); 
        }
        Console.WriteLine("Check Instance");
        Console.ReadLine();  
    }
}



[InstrumentationClass(InstrumentationType.Abstract)]
public class MyInst : Instance
{

}

[InstrumentationClass(InstrumentationType.Instance)]
public class BadOne : MyInst
{
}

public class Bizarre : BaseEvent
{
    // No static fields
    [IgnoreMember] public static int i;

    // No static properties
    [IgnoreMember] public static int j
    {
        get
        {
            return 17;
        }
    }
    // Properties must have a get
    [IgnoreMember] public int k
    {
        set {}
    }

    // No parameters on properties
    [IgnoreMember] public int this[int i]
    {
        get {return 17;}
    }

    // No enums
    public enum Days
    {
        Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday
    }
    [IgnoreMember] public Days days;

    // No Jagged arrays
    [IgnoreMember] public int [][] rg;

    // No Multi-diemnsional rectangular arrays
    [IgnoreMember] public int [,] rg2;
    [IgnoreMember] public int [,,,]rg3;
}

class NewApp
{
    static void Mainx()
    {
        // Get a ManagementClass and ManagementObject to serialize
        ManagementClass cls = new ManagementClass("__Win32Provider");
        ManagementObject obj = new ManagementObject("root:__Namespace='cimv2'");

        // Show the info we want to serialize
        Console.WriteLine("*** INITIAL CLASS PROPERTIES AND VALUES");
        foreach(PropertyData prop in cls.Properties)
            Console.WriteLine("{0} - {1}", prop.Name, prop.Value);
        Console.WriteLine("*** INITIAL CLASS MOF");
        Console.WriteLine(cls.GetText(TextFormat.Mof));
        Console.WriteLine("*** INITIAL OBJECT PROPERTIES AND VALUES");
        foreach(PropertyData prop in obj.Properties)
            Console.WriteLine("{0} - {1}", prop.Name, prop.Value);
        Console.WriteLine("*** INITIAL OBJECT MOF");
        Console.WriteLine(obj.GetText(TextFormat.Mof));

        //Open a file and serialize a ManagementClass and a ManagementObject into the file
        Stream stream = File.Open("MyClass1MyClass2.bin", FileMode.Create);
        BinaryFormatter bformatter = new BinaryFormatter();
        bformatter.Serialize(stream, cls);
        bformatter.Serialize(stream, obj);
        stream.Close();

        //Open file "MyClass1MyClass2.bin" and deserialize the MyClass1 object from it.
        stream = File.Open("MyClass1MyClass2.bin", FileMode.Open);
        bformatter = new BinaryFormatter();
        ManagementBaseObject baseObject1 = (ManagementBaseObject)bformatter.Deserialize(stream);
        ManagementBaseObject baseObject2 = (ManagementBaseObject)bformatter.Deserialize(stream);
        stream.Close();

        // Show the Deserialized information
        Console.WriteLine("*** DESERIALIZED CLASS PROPERTIES AND VALUES");
        foreach(PropertyData prop in baseObject1.Properties)
            Console.WriteLine("{0} - {1}", prop.Name, prop.Value);
        Console.WriteLine("*** DESERIALIZED CLASS MOF");
        Console.WriteLine(baseObject1.GetText(TextFormat.Mof));
        Console.WriteLine("*** DESERIALIZED OBJECT PROPERTIES AND VALUES");
        foreach(PropertyData prop in baseObject2.Properties)
            Console.WriteLine("{0} - {1}", prop.Name, prop.Value);
        Console.WriteLine("*** DESERIALIZED OBJECT MOF");
        Console.WriteLine(baseObject2.GetText(TextFormat.Mof));
    }
}

class Sample_ObjectPutEventArgs 
{
    static int ii=0;
    static ManagementOperationObserver observer;
    static ManagementClass newClass;
    [STAThread]
    public static int Mainx(string[] args) 
    {
        observer = new ManagementOperationObserver();
        MyHandler handler = new MyHandler();
        observer.ObjectPut += new ObjectPutEventHandler(handler.Done);
        newClass = new ManagementClass(
            "root/default",
            String.Empty, 
            null);
        newClass.SetPropertyValue("__Class", "Classsc99");
        newClass.Put(observer);
        ii=1;
        // For the purpose of this sample, we keep the main
        // thread alive until the asynchronous operation is finished.
        while (!handler.IsComplete) 
        {
            System.Threading.Thread.Sleep(500);
//            MessageBox.Show("hi");
        }	
        Console.WriteLine("Path = " + handler.ReturnedArgs.Path.Path.ToString());		
        return 0;
    }
	
    public class MyHandler 
    {	
        private bool isComplete = false;
        private ObjectPutEventArgs args;
		
        public void Done(object sender, ObjectPutEventArgs e) 
        {
            Console.WriteLine(ii);
            args = e;
            isComplete = true;
        }

        public bool IsComplete 
        {
            get 
            {
                return isComplete;
            }
        }
		
        public ObjectPutEventArgs ReturnedArgs 
        {
            get 
            {
                return args;
            }
        }
    }
}
public struct bytes16
{
    public int a;
    public int b;
    public int c;
    public int d;
}
public struct bytes64
{
    public bytes16 a;
    public bytes16 b;
    public bytes16 c;
    public bytes16 d;
}

public struct bytes256
{
    public bytes64 a;
    public bytes64 b;
    public bytes64 c;
    public bytes64 d;
}

public struct kilo1
{
    public bytes256 a;
    public bytes256 b;
    public bytes256 c;
    public bytes256 d;
}

[StructLayout(LayoutKind.Sequential)]
public class KiloObject
{
    public kilo1 k;
    public static int size = Marshal.SizeOf(typeof(KiloObject));
    public static int total = 0;
    public KiloObject()
    {
        GC.WaitForPendingFinalizers();
        int tempTotal = total;
        if(tempTotal%100 == 0)
            Console.WriteLine("{1:N0}", tempTotal, size*tempTotal);
        total++;
    }
    ~KiloObject()
    {
        total--;
    }
}

public class Kilo2
{
    ~Kilo2()
    {
    }
}

public class inst2 : Instance
{
    public string name;
    public int id;
}

public class evt2 : B