ameMost,
					&cbActual,
					NO_GRBIT,
					NULL ) );

		Assert( cbActual <= JET_cbNameMost );
		szCurrColumn[cbActual] = '\0';
		pcolcreateCurr->szColumnName = szCurrColumn;
		
		szCurrColumn += cbActual + 1;
		Assert( (BYTE *)szCurrColumn <= (BYTE *)rgszIndexes );

#ifdef DEBUG		
		// Assert Presentation order no longer supported.
		ULONG	ulPOrder;
		Call( ErrDispRetrieveColumn(
					reinterpret_cast<JET_SESID>( ppib ),
					pcolumnList->tableid,
					pcolumnList->columnidPresentationOrder,
					&ulPOrder,
					sizeof(ulPOrder),
					&cbActual,
					NO_GRBIT,
					NULL ) );
		Assert( JET_wrnColumnNull == err );
#endif		

		Call( ErrDispRetrieveColumn(
					reinterpret_cast<JET_SESID>( ppib ),
					pcolumnList->tableid, 
					pcolumnList->columnidcoltyp,
					&pcolcreateCurr->coltyp, 
					sizeof( pcolcreateCurr->coltyp ),
					&cbActual, 
					NO_GRBIT, 
					NULL ) );
		Assert( cbActual == sizeof( JET_COLTYP ) );
		Assert( JET_coltypNil != pcolcreateCurr->coltyp );

		Call( ErrDispRetrieveColumn(
					reinterpret_cast<JET_SESID>( ppib ),
					pcolumnList->tableid, 
					pcolumnList->columnidcbMax, 
					&pcolcreateCurr->cbMax, 
					sizeof( pcolcreateCurr->cbMax ), 
					&cbActual, 
					NO_GRBIT, 
					NULL ) );
		Assert( cbActual == sizeof( ULONG ) );

		Call( ErrDispRetrieveColumn(
					reinterpret_cast<JET_SESID>( ppib ),
					pcolumnList->tableid, 
					pcolumnList->columnidgrbit, 
					&pcolcreateCurr->grbit, 
					sizeof( pcolcreateCurr->grbit ), 
					&cbActual, 
					NO_GRBIT, 
					NULL ) );
		Assert( cbActual == sizeof( JET_GRBIT ) );

		Call( ErrDispRetrieveColumn(
					reinterpret_cast<JET_SESID>( ppib ),
					pcolumnList->tableid, 
					pcolumnList->columnidCp, 
					&pcolcreateCurr->cp,
					sizeof( pcolcreateCurr->cp ), 
					&cbActual, 
					NO_GRBIT, 
					NULL ) );
		Assert( cbActual == sizeof( USHORT ) );

		/*	retrieve default value.
		/**/
		if( pcolcreateCurr->grbit & JET_bitColumnUserDefinedDefault )
			{
			JET_USERDEFINEDDEFAULT * pudd = NULL;

			//  don't want to pass in NULL
			BYTE b;
			Call( ErrDispRetrieveColumn(
						reinterpret_cast<JET_SESID>( ppib ),
						pcolumnList->tableid, 
						pcolumnList->columnidDefault, 
						&b,
						sizeof( b ),
						&pcolcreateCurr->cbDefault, 
						NO_GRBIT, 
						NULL ) );
			
			pcolcreateCurr->pvDefault = cmemlist.PvAlloc( pcolcreateCurr->cbDefault );
			if( NULL == pcolcreateCurr->pvDefault )
				{
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}
				
			Call( ErrDispRetrieveColumn(
						reinterpret_cast<JET_SESID>( ppib ),
						pcolumnList->tableid, 
						pcolumnList->columnidDefault, 
						pcolcreateCurr->pvDefault,
						pcolcreateCurr->cbDefault,
						&pcolcreateCurr->cbDefault, 
						NO_GRBIT, 
						NULL ) );
			Assert( JET_wrnBufferTruncated != err );
			Assert( JET_wrnColumnNull != err );
			Assert( pcolcreateCurr->cbDefault > 0 );

			//  All of the information about a user-defined default is in the default buffer
			//  ErrINFOGetTableColumnInfo lays it out like this:
			//
			//  JET_USERDEFINEDDEFAULT | szCallback | pbUserData | szDependantColumns
			//
			//  The pointers in the JET_USERDEFINEDDEFAULT are no longer usable so they have
			//  to be fixed up. The cbDefault has to be reduced to sizeof( JET_USERDEFINEDDEFAULT )
			//  because that is what the JET APIs are expecting
			
			pudd = (JET_USERDEFINEDDEFAULT *)pcolcreateCurr->pvDefault;
			pudd->szCallback = ((CHAR*)(pcolcreateCurr->pvDefault)) + sizeof( JET_USERDEFINEDDEFAULT );
			pudd->pbUserData = ((BYTE*)(pudd->szCallback)) + strlen( pudd->szCallback ) + 1;
			if( NULL != pudd->szDependantColumns )
				{
				pudd->szDependantColumns = (CHAR *)pudd->pbUserData + pudd->cbUserData;
				}
			
			//  in order to create the column the pvDefault should point to the JET_USERDEFINEDDEFAULT structure
			Assert( pcolcreateCurr->cbDefault > sizeof( JET_USERDEFINEDDEFAULT ) );
			pcolcreateCurr->cbDefault = sizeof( JET_USERDEFINEDDEFAULT );
			}
		else
			{
			Assert( cbDefaultRecRemaining > 0 );		// can never reach cbDefaultRecRemaining, because of record overhead
			Assert( pbCurrDefault + cbDefaultRecRemaining == pbMax );
			Call( ErrDispRetrieveColumn(
						reinterpret_cast<JET_SESID>( ppib ),
						pcolumnList->tableid, 
						pcolumnList->columnidDefault, 
						pbCurrDefault,
						cbDefaultRecRemaining,
						&pcolcreateCurr->cbDefault, 
						NO_GRBIT, 
						NULL ) );
			Assert( JET_wrnBufferTruncated != err );
			Assert( pcolcreateCurr->cbDefault < cbDefaultRecRemaining );	// can never reach cbDefaultRecRemaining, because of record overhead
			pcolcreateCurr->pvDefault = pbCurrDefault;
			pbCurrDefault += pcolcreateCurr->cbDefault;
			cbDefaultRecRemaining -= pcolcreateCurr->cbDefault;
			Assert( cbDefaultRecRemaining > 0 );		// can never reach cbDefaultRecRemaining, because of record overhead
			Assert( pbCurrDefault + cbDefaultRecRemaining == pbMax );
			}

		// Save the source columnid.
		/* CONSIDER: Should the column id be checked? */
		Call( ErrDispRetrieveColumn(
					reinterpret_cast<JET_SESID>( ppib ),
					pcolumnList->tableid, 
					pcolumnList->columnidcolumnid, 
					pcolumnidSrc, 
					sizeof( JET_COLUMNID ), 
					&cbActual, 
					NO_GRBIT, 
					NULL ) );
		Assert( cbActual == sizeof( JET_COLUMNID ) );

		if ( pcolcreateCurr->grbit & JET_bitColumnTagged )
			{
			cTagged++;
			fidTaggedHighest = max( fidTaggedHighest, FidOfColumnid( *pcolumnidSrc ) );
			}

		pcolumnidSrc++;
		Assert( (BYTE *)pcolumnidSrc <= (BYTE *)rgcolcreate );

		pcolcreateCurr++;
		Assert( (BYTE *)pcolcreateCurr <= (BYTE *)rgidxcreate );
		cColumns++;

		err = ErrDispMove(
					reinterpret_cast<JET_SESID>( ppib ),
					pcolumnList->tableid, 
					JET_MoveNext, 
					NO_GRBIT );
		}

	Assert( cColumns == pcolumnList->cRecord );

	Assert( ptablecreate->rgcolumncreate == NULL );
	Assert( ptablecreate->cColumns == 0 );
	ptablecreate->rgcolumncreate = rgcolcreate;
	ptablecreate->cColumns = cColumns;


	Assert( ptablecreate->rgindexcreate == NULL );
	Assert( ptablecreate->cIndexes == 0 );

	for ( pfcbIndex = pfcbSrc;
		pfcbIndex != pfcbNil;
		pfcbIndex = pfcbIndex->PfcbNextIndex() )
		{
		if ( pfcbIndex->Pidb() != pidbNil )
			{
			// Derived indexes will get inherited from template.
			if ( !pfcbIndex->FDerivedIndex() )
				{
				Assert( (BYTE *)pidxcreateCurr < (BYTE *)rgidxunicode );
				Assert( (BYTE *)pidxunicodeCurr < (BYTE *)rgtuplelimits );
				Assert( (BYTE *)ptuplelimitsCurr < (BYTE *)rgconditionalcolumn );
				Assert( ( cConditionalColumns > 0 && (BYTE *)pconditionalcolumnCurr <= (BYTE *)rgszColumns )
					|| ( 0 == cConditionalColumns && (BYTE *)pconditionalcolumnCurr == (BYTE *)rgszColumns ) );
				Assert( (BYTE *)szCurrIndex < (BYTE *)rgszKeys );
				Assert( (BYTE *)szCurrKey < (BYTE *)rgbDefaultValues );

				memset( pidxcreateCurr, 0, sizeof( JET_INDEXCREATE ) );

				pidxcreateCurr->cbStruct 	= sizeof(JET_INDEXCREATE);
				pidxcreateCurr->szIndexName = szCurrIndex;
				pidxcreateCurr->szKey 		= szCurrKey;
				pidxcreateCurr->pidxunicode	= pidxunicodeCurr;

				CMPCopyOneIndex(
					pfcbSrc,
					pfcbIndex,
					pidxcreateCurr,
					ptuplelimitsCurr,
					pconditionalcolumnCurr );

				ptablecreate->cIndexes++;

				szCurrIndex += strlen( pidxcreateCurr->szIndexName ) + 1;
				Assert( (BYTE *)szCurrIndex <= (BYTE *)rgszKeys );
				
				szCurrKey += pidxcreateCurr->cbKey;
				Assert( (BYTE *)szCurrKey <= (BYTE *)rgbDefaultValues );

				if ( 0 != pidxcreateCurr->cConditionalColumn )
					{
					Assert( pidxcreateCurr->rgconditionalcolumn == pconditionalcolumnCurr );
					Assert( NULL != pconditionalcolumnCurr->szColumnName );
					Assert( pidxcreateCurr->cConditionalColumn > 0 );

					INT iConditionalColumn;
					for( iConditionalColumn = 0; iConditionalColumn < pidxcreateCurr->cConditionalColumn; ++iConditionalColumn )
						{
						szCurrKey += strlen( pidxcreateCurr->rgconditionalcolumn[iConditionalColumn].szColumnName ) + 1;
						}
					pconditionalcolumnCurr += pidxcreateCurr->cConditionalColumn;
					}
					
				pidxcreateCurr++;
				pidxunicodeCurr++;
				ptuplelimitsCurr++;
				Assert( (BYTE *)pidxcreateCurr <= (BYTE *)rgidxunicode );
				Assert( (BYTE *)pidxunicodeCurr <= (BYTE *)rgtuplelimits );
				Assert( (BYTE *)ptuplelimitsCurr <= (BYTE *)rgconditionalcolumn );
				}
			}
		else
			{
			// If IDB is null, must be sequential index.
			Assert( pfcbIndex == pfcbSrc );
			Assert( pfcbIndex->FSequentialIndex() );
			}
		}

	Assert( (BYTE *)pidxcreateCurr == (BYTE *)rgidxunicode );
	Assert( (BYTE *)pidxunicodeCurr == (BYTE *)rgtuplelimits );
	Assert( (BYTE *)ptuplelimitsCurr == (BYTE *)rgconditionalcolumn );
	Assert( ptablecreate->cIndexes == cIndexesToCreate );

	ptablecreate->rgindexcreate = rgidxcreate;
	
	Call( ErrFILECreateTable(
				ppib,
				pcompactinfo->ifmpDest,
				ptablecreate ) );
	Assert( ptablecreate->cCreated == 1 + cColumns + cIndexesToCreate );


	// If there's at least one tagged column, create an array for the
	// tagged columnid map.
	if ( cTagged > 0 )
		{
		Assert( FTaggedFid( fidTaggedHighest ) );
		cbAllocate = sizeof(JET_COLUMNID) * ( fidTaggedHighest + 1 - fidTaggedLeast );
		mpcolumnidcolumnidTagged = static_cast<JET_COLUMNID *>( PvOSMemoryHeapAlloc( cbAllocate ) );
		if ( mpcolumnidcolumnidTagged == NULL )
			{
			err = ErrERRCheck( JET_errOutOfMemory );
			goto HandleError;
			}
		memset( (BYTE *)mpcolumnidcolumnidTagged, 0, cbAllocate );
		}


	// Update columnid maps.
	for ( pcolcreateCurr = rgcolcreate, pcolumnidSrc = rgcolumnidSrc, cColumns = 0;
		cColumns < pcolumnList->cRecord;
		pcolcreateCurr++, pcolumnidSrc++, cColumns++ )
		{
		Assert( (BYTE *)pcolcreateCurr <= (BYTE *)rgidxcreate );
		Assert( (BYTE *)pcolumnidSrc <= (BYTE *)rgcolcreate );

		if ( FCOLUMNIDTemplateColumn( *pcolumnidSrc ) )
			{
			Assert( ptablecreate->grbit & JET_bitTableCreateTemplateTable );
			Assert( FCOLUMNIDTemplateColumn( pcolcreateCurr->columnid ) );
			}
		else
			{
			Assert( !( ptablecreate->grbit & JET_bitTableCreateTemplateTable ) );
			Assert( !( ptablecreate->grbit & JET_bitTableCreateNoFixedVarColumnsInDerivedTables ) );
			Assert( !FCOLUMNIDTemplateColumn( pcolcreateCurr->columnid ) );
			}

		if ( pcolcreateCurr->grbit & JET_bitColumnTagged )
			{
			Assert( FCOLUMNIDTagged( *pcolumnidSrc ) );
			Assert( FCOLUMNIDTagged( pcolcreateCurr->columnid ) );
			Assert( FidOfColumnid( *pcolumnidSrc ) <= fidTaggedHighest );
			Assert( mpcolumnidcolumnidTagged != NULL );
			Assert( mpcolumnidcolumnidTagged[FidOfColumnid( *pcolumnidSrc ) - fidTaggedLeast] == 0 );
			mpcolumnidcolumnidTagged[FidOfColumnid( *pcolumnidSrc ) - fidTaggedLeast] = pcolcreateCurr->columnid;
			}
		else
			{
			/*	else add the columnids to the columnid array
			/**/
			columnidInfo[ccolSingleValue].columnidDest = pcolcreateCurr->columnid;
			columnidInfo[ccolSingleValue].columnidSrc  = *pcolumnidSrc;
			ccolSingleValue++;
			}	// if ( columndef.grbit & JET_bitColumnTagged )
		}

	/*	set count of fixed and variable columns to copy
	/**/
	pcompactinfo->ccolSingleValue = ccolSingleValue; 

	if ( err == JET_errNoCurrentRecord )
		err = JET_errSuccess;

HandleError:
	if ( err < 0  &&  mpcolumnidcolumnidTagged )
		{
		OSMemoryHeapFree( mpcolumnidcolumnidTagged );
		mpcolumnidcolumnidTagged = NULL;
		}

	if ( fLocalAlloc )
		{
		OSMemoryHeapFree( rgcolumnidSrc );
		}

	cmemlist.FreeAllMemory();
	
	// Set return value.
	*pmpcolumnidcolumnidTagged = mpcolumnidcolumnidTagged;

	return err;
	}


LOCAL ERR ErrCMPCopyTable( 
	COMPACTINFO		*pcompactinfo, 
	const CHAR		*szObjectName,
	ULONG			ulFlags )
	{
	ERR				err;
	PIB				*ppib = pcompactinfo->ppib;
	INST			*pinst = PinstFromPpib( ppib );
	IFMP			ifmpSrc = pcompactinfo->ifmpSrc;
	FUCB			*pfucbSrc = pfucbNil;
	FUCB			*pfucbDest = pfucbNil;
	FCB				*pfcbSrc;
	CPG				cpgTableSrc;
	const CPG		cpgDbExtensionSizeSave = pinst->m_cpgSESysMin;
	JET_COLUMNLIST	columnList;
	JET_COLUMNID    *mpcolumnidcolumnidTagged = NULL;
	STATUSINFO		*pstatus = pcompactinfo->pstatus;
	ULONG			crowCopied = 0;
	ULONG			recidLast;
	ULONG			rgulAllocInfo[] = { ulCMPDefaultPages, ulCMPDefaultDensity };
	CHAR			*szTemplateTableName = NULL;
	BOOL			fCorruption = fFalse;
	JET_TABLECREATE2	tablecreate = {
						sizeof(JET_TABLECREATE2),
						(CHAR *)szObjectName,
						NULL,					// Template table
						ulCMPDefaultPages,
						ulCMPDefaultDensity,
						NULL, 0,				// Columns
						NULL, 0,				// Indexes
						NULL, 0,				// Callbacks
						NO_GRBIT,
						0,
						0
						};

	if ( pstatus  &&  pstatus->fDumpStats )
		{
		Assert( pstatus->hfCompactStats );
		fprintf( pstatus->hfCompactStats, "%s\t", szObjectName );
		fflush( pstatus->hfCompactStats );
		CMPSetTime( &pstatus->timerCopyTable );
		CMPSetTime( &pstatus->timerInitTable );
		}

	CallR( ErrFILEOpenTable(
				ppib,
				ifmpSrc,
				&pfucbSrc,
				szObjectName,
				JET_bitTableSequential ) );
	Assert( pfucbNil != pfucbSrc );

	err = ErrIsamGetTableInfo(
				reinterpret_cast<JET_SESID>( ppib ),
				reinterpret_cast<JET_TABLEID>( pfucbSrc ),
				rgulAllocInfo,
				sizeof(rgulAllocInfo),
				JET_TblInfoSpaceAlloc );
	if ( err < 0  &&  !fGlobalRepair )
		{
		goto HandleError;
		}

	// On error, just use the default values of rgulAllocInfo.
	tablecreate.ulPages = rgulAllocInfo[0];
	tablecreate.ulDensity = rgulAllocInfo[1];

	/*	if a table create the columns in the Dest Db the same as in
	/*	the src Db.
	/**/
	Assert( !( ulFlags & JET_bitObjectSystem ) );
	if ( ulFlags & JET_bitObjectTableTemplate )
		{
		Assert( ulFlags & JET_bitObjectTableFixedDDL );
		Assert( !( ulFlags & JET_bitObjectTableDerived ) );
		tablecreate.grbit = ( JET_bitTableCreateTemplateTable | JET_bitTableCreateFixedDDL );

		if ( ulFlags & JET_bitObjectTableNoFixedVarColumnsInDerivedTables )
			tablecreate.grbit |= JET_bitTableCreateNoFixedVarColumnsInDerivedTables;
		}
	else
		{
		Assert( !( ulFlags & JET_bitObjectTableNoFixedVarColumnsInDerivedTables ) );
		if ( ulFlags & JET_bitObjectTableFixedDDL )
			{
			tablecreate.grbit = JET_bitTableCreateFixedDDL;
			}
		if ( ulFlags & JET_bitObjectTableDerived )
			{
			szTemplateTableName = reinterpret_cast<CHAR *>( PvOSMemoryHeapAlloc( JET_cbNameMost + 1 ) );
			if ( NULL == szTemplateTableName )
				{
				err = ErrERRCheck( JET_errOutOfMemory );
				goto HandleError;
				}
				
			// extract name.
			Call( ErrIsamGetTableInfo(
						reinterpret_cast<JET_SESID>( ppib ),
						reinterpret_cast<JET_TABLEID>( pfucbSrc ),
						szTemplateTableName,
						JET_cbNameMost+1,
						JET_TblInfoTemplateTableName ) );

			Assert( strlen( szTemplateTableName ) > 0 );
			tablecreate.szTemplateTableName = szTemplateTableName;
			}
		}
		

	pfcbSrc = pfucbSrc->u.pfcb;
	Assert( pfcbNil != pfcbSrc );
	Assert( pfcbSrc->FTypeTable() );
	
	/*	get a table with the column information for the query in it
	/**/
	Call( ErrIsamGetTableColumnInfo(
				reinterpret_cast<JET_SESID>( ppib ),
				reinterpret_cast<JET_TABLEID>( pfucbSrc ),
				NULL,
				NULL,
				&columnList,
				sizeof(columnList),
				JET_ColInfoListCompact ) );

	err = ErrCMPCreateTableColumnIndex(
				pcompactinfo,
				pfcbSrc,
				&tablecreate,
				&columnList,
				pcompactinfo->rgcolumnids, 
				&mpcolumnidcolumnidTagged );

	// Must use dispatch layer for temp/sort table.
	CallS( ErrDispCloseTable( 
					reinterpret_cast<JET_SESID>( ppib ),
					columnList.tableid ) );

	// Act on error code returned from CreateTableColumnIndex().
	Call( err );

	pfucbDest = reinterpret_cast<FUCB *>( tablecreate.tableid );
	Assert( tablecreate.cCreated == 1 + tablecreate.cColumns + tablecreate.cIndexes + ( tablecreate.szCallback ? 1 : 0 ) );
	Assert( tablecreate.cColumns >= pcompactinfo->ccolSingleValue );

	if ( pstatus )
		{
		ULONG	rgcpgExtent[2];		// OwnExt and AvailExt

		Assert( pstatus->pfnStatus );
		Assert( pstatus->snt == JET_sntProgress );

		// tablecreate.cIndexes is only a count of the indexes that were created.  We
		// also need the number of indexes inherited.
		FCB	*pfcbIndex = pfucbDest->u.pfcb;
		Assert( pfcbIndex->FPrimaryIndex() );
		Assert( ( pfcbIndex->FSequentialIndex() && pfcbIndex->Pidb() == pidbNil )
			|| ( !pfcbIndex->FSequentialIndex() && pfcbIndex->Pidb() != pidbNil ) );
		INT	cSecondaryIndexes = 0;
		for ( pfcbIndex = pfcbIndex->PfcbNextIndex();
			pfcbIndex != pfcbNil;
			pfcbIndex = pfcbIndex->PfcbNextIndex() )
			{
			Assert( pfcbIndex->FTypeSecondaryIndex() );
			Assert( pfcbIndex->Pidb() != pidbNil );
			cSecondaryIndexes++;
			}
	
		pstatus->szTableName = (char *)szObjectName;
		pstatus->cTableFixedVarColumns = pcompactinfo->ccolSingleValue;
		pstatus->cTableTaggedColumns = tablecreate.cColumns - pcompactinfo->ccolSingleValue;
		pstatus->cTableInitialPages = rgulAllocInfo[0];
		pstatus->cSecondaryIndexes = cSecondaryIndexes;

		err = ErrIsamGetTableInfo(
					reinterpret_cast<JET_SESID>( ppib ),
					reinterpret_cast<JET_TABLEID>( pfucbSrc ),
					rgcpgExtent,
					sizeof(rgcpgExtent),
					JET_TblInfoSpaceUsage );
		if ( err < 0 )
			{
			if ( fGlobalRepair )
				{
				//	if failure in space query then default to
				//	one page owned and no pages available.
				fCorruption = fTrue;
				rgcpgExtent[0] = 1;
				rgcpgExtent[1] = 0;
				}
			else
				{
				goto HandleError;
				}
			}

		// AvailExt always less than OwnExt.
		Assert( rgcpgExtent[1] < rgcpgExtent[0] );

		// cunitProjected is the projected total pages completed once
		// this table has been copied.
		pstatus->cunitProjected = pstatus->cunitDone + rgcpgExtent[0];
		if ( pstatus->cunitProjected > pstatus->cunitTotal )
			{
			Assert( fGlobalRepair );
			fCorruption = fTrue;
			pstatus->cunitProjected = pstatus->cunitTotal;
			}

		const ULONG	cpgUsed = rgcpgExtent[0] - rgcpgExtent[1];
		Assert( cpgUsed > 0 );

		pstatus->cbRawData = 0;
		pstatus->cbRawDataLV = 0;
		pstatus->cLeafPagesTraversed = 0;
		pstatus->cLVPagesTraversed = 0;

		// If corrupt, suppress progression of meter.
		pstatus->cunitPerProgression =
			( fCorruption ? 0 : 1 + ( rgcpgExtent[1] / cpgUsed ) );
		pstatus->cTablePagesOwned = rgcpgExtent[0];
		pstatus->cTablePagesAvail = rgcpgExtent[1];

		if ( pstatus->fDumpStats )
			{
			Assert( pstatus->hfCompactStats );

			const TDB	* const ptdbT = pfucbDest->u.pfcb->Ptdb();
			Assert( ptdbNil != ptdbT );
			const INT	cColumns = ( ptdbT->FidFixedLast() + 1 - fidFixedLeast )
									+ ( ptdbT->FidVarLast() + 1 - fidVarLeast )
									+ ( ptdbT->FidTaggedLast() + 1 - fidTaggedLeast );

			if ( cColumns > pstatus->cTableFixedVarColumns + pstatus->cTableTaggedColumns )
				{
				Assert( pfucbDest->u.pfcb->FDerivedTable() );
				}
			else
				{
				Assert( cColumns == pstatus->cTableFixedVarColumns + pstatus->cTableTaggedColumns );
				}
		
			INT	iSec, iMSec;
			CMPGetTime( pstatus->timerInitTable, &iSec, &iMSec );
			fprintf(
				pstatus->hfCompactStats,
				"%d\t%d\t%d\t%d\t%d\t%d\t%d.%d\t",
				pstatus->cTableFixedVarColumns,
				pstatus->cTableTaggedColumns,
				cColumns,
				pstatus->cSecondaryIndexes,
				pstatus->cTablePagesOwned,
				pstatus->cTablePagesAvail,
				iSec, iMSec );
			fflush( pstatus->hfCompactStats );
			CMPSetTime( &pstatus->timerCopyRecords );
			}

		cpgTableSrc = rgcpgExtent[0];
		}
	else
		{
		Call( ErrIsamGetTableInfo(
					reinterpret_cast<JET_SESID>( ppib ),
					reinterpret_cast<JET_TABLEID>( pfucbSrc ),
					&cpgTableSrc,
					sizeof(cpgTableSrc),
					JET_TblInfoSpaceOwned ) );
		}

	//	set DB extension size to 1% of the current size of the table, up to
	//	a limit (I somewhat arbitrarily chose the limit to be a number of pages
	//	equal to the page size)
	//
	pinst->m_cpgSESysMin = max( cpgDbExtensionSizeSave, (CPG)min( g_cbPage, cpgTableSrc / 100 ) );

	err = ErrSORTCopyRecords(
				ppib,
				pfucbSrc,
				pfucbDest,
				(CPCOL *)pcompactinfo->rgcolumnids,
				pcompactinfo->ccolSingleValue,
				0,
				&crowCopied,
				&recidLast,
				pcompactinfo->rgbBuf,
				mpcolumnidcolumnidTagged,
				pstatus );

	if ( err >= 0 )
		{
		//  copy the callbacks from one database to another
		err = ErrCATCopyCallbacks(
				ppib,
				pcompactinfo->ifmpSrc,
				pcompactinfo->ifmpDest, 
				pfucbSrc->u.pfcb->ObjidFDP(),
				pfucbDest->u.pfcb->ObjidFDP()
				);
		}
		
	if ( pstatus )
		{
		if ( pstatus->fDumpStats )
			{
			INT	iSec, iMSec;
			Assert( pstatus->hfCompactStats );
			CMPGetTime( pstatus->timerCopyRecords, &iSec, &iMSec );
			fprintf( pstatus->hfCompactStats,
					"%d\t%I64d\t%I64d\t%d\t%d\t%d.%d\t",
					crowCopied,
					pstatus->cbRawData,
					pstatus->cbRawDataLV,
					pstatus->cLeafPagesTraversed,
					pstatus->cLVPagesTraversed,
					iSec, iMSec );
			fflush( pstatus->hfCompactStats );
			}

		if ( err >= 0 || fGlobalRepair )
			{
			// Top off progress meter for this table.
			Assert( pstatus->cunitDone <= pstatus->cunitProjected );
			pstatus->cunitDone = pstatus->cunitProjected;
			ERR	errT = ErrCMPReportProgress( pstatus );
			if ( err >= 0 )
				err = errT;
			}
		}

HandleError:
	pinst->m_cpgSESysMin = cpgDbExtensionSizeSave;

	if ( pfucbNil != pfucbDest )
		{
		Assert( (JET_TABLEID)pfucbDest == tablecreate.tableid );
		CallS( ErrFILECloseTable( ppib, pfucbDest ) );
		}

	if ( mpcolumnidcolumnidTagged != NULL )
		{
		OSMemoryHeapFree( mpcolumnidcolumnidTagged );
		}

	if ( szTemplateTableName != NULL )
		{
		OSMemoryHeapFree( szTemplateTableName );
		}

	Assert( pfucbNil != pfucbSrc );
	CallS( ErrFILECloseTable( ppib, pfucbSrc ) );
	
	if ( pstatus  &&  pstatus->fDumpStats )
		{
		INT	iSec, iMSec;
		Assert( pstatus->hfCompactStats );
		CMPGetTime( pstatus->timerCopyTable, &iSec, &iMSec );
		fprintf( pstatus->hfCompactStats, "%d.%d\n", iSec, iMSec );
		fflush( pstatus->hfCompactStats );
		}

	return err;
	}


LOCAL ERR ErrCMPCopySelectedTables(
	COMPACTINFO	*pcompactinfo,
	FUCB		*pfucbCatalog,
	const BOOL	fCopyDerivedTablesOnly,
	BOOL		*pfEncounteredDerivedTable )
	{
	ERR			err;
	FCB			*pfcbCatalog	= pfucbCatalog->u.pfcb;
	DATA		dataField;
	BOOL		fLatched		= fFalse;
	CHAR		szTableName[JET_cbNameMost+1];

	Assert( pfcbNil != pfcbCatalog );
	Assert( pfcbCatalog->FTypeTable() );
	Assert( pfcbCatalog->FFixedDDL() );
	Assert( pfcbCatalog->PgnoFDP() == pgnoFDPMSO );

	err = ErrIsamMove( pcompactinfo->ppib, pfucbCatalog, JET_MoveFirst, NO_GRBIT );
	if ( err < 0 )
		{
		Assert( JET_errRecordNotFound != err );
		if ( JET_errNoCurrentRecord == err )
			err = ErrERRCheck( JET_errDatabaseCorrupted );	// MSysObjects shouldn't be empty.

		return err;
		}

	do
		{
		Assert( !Pcsr( pfucbCatalog )->FLatched() );
		Call( ErrDIRGet( pfucbCatalog ) );
		fLatched = fTrue;
		
		const DATA&	dataRec				= pfucbCatalog->kdfCurr.data;
		BOOL		fProceedWithCopy	= fTrue;
		ULONG		ulFlags;

		Assert( FFixedFid( fidMSO_Flags ) );
		Call( ErrRECIRetrieveFixedColumn(
						pfcbNil,
						pfucbCatalog->u.pfcb->Ptdb(),
						fidMSO_Flags,
						dataRec,
						&dataField ) );
		Assert( JET_errSuccess == err );
		Assert( dataField.Cb() == sizeof(ULONG) );
		UtilMemCpy( &ulFlags, dataField.Pv(), sizeof(ULONG) );

		if ( ulFlags & JET_bitObjectTableDerived )
			{
			if ( !fCopyDerivedTablesOnly )
				{
				//	Must defer derived tables to a second pass
				//	(in order to ensure that the base tables are
				//	created first).
				*pfEncounteredDerivedTable = fTrue;
				fProceedWithCopy = fFalse;
				}
			}
		else if ( fCopyDerivedTablesOnly )
			{
			// Only want derived tables.  If this isn't one, skip it.
			fProceedWithCopy = fFalse;
			}


		if ( fProceedWithCopy )
			{
			
#ifdef DEBUG
			//	verify this is a column
			Assert( FFixedFid( fidMSO_Type ) );
			Call( ErrRECIRetrieveFixedColumn(
						pfcbNil,
						pfucbCatalog->u.pfcb->Ptdb(),
						fidMSO_Type,
						dataRec,
						&dataField ) );
			Assert( JET_errSuccess == err );
			Assert( dataField.Cb() == sizeof(SYSOBJ) );
			Assert( sysobjTable == *( (UnalignedLittleEndian< SYSOBJ > *)dataField.Pv() ) );
#endif			

			Assert( FVarFid( fidMSO_Name ) );
			Call( ErrRECIRetrieveVarColumn(
							pfcbNil,
							pfucbCatalog->u.pfcb->Ptdb(),
							fidMSO_Name,
							dataRec,
							&dataField ) );
			Assert( JET_errSuccess == err );
			Assert( dataField.Cb() > 0 );
			Assert( dataField.Cb() <= JET_cbNameMost );
			UtilMemCpy( szTableName, dataField.Pv(), dataField.Cb() );
			szTableName[dataField.Cb()] = '\0';

			Assert( Pcsr( pfucbCatalog )->FLatched() );
			CallS( ErrDIRRelease( pfucbCatalog ) );
			fLatched = fFalse;
					
			if ( !FCATSystemTable( szTableName ) && !FOLDSystemTable( szTableName ) && !FCATUnicodeFixupTable( szTableName ) )
				{
				err = ErrCMPCopyTable( pcompactinfo, szTableName, ulFlags );
				if ( err < 0 && fGlobalRepair )
					{
					const CHAR	*szName		= szTableName;
					err = JET_errSuccess;
					UtilReportEvent(
						eventWarning,
						REPAIR_CATEGORY,
						REPAIR_BAD_TABLE,
						1,
						&szName );
					}
				Call( err );
				}
			}
		else
			{
			Assert( Pcsr( pfucbCatalog )->FLatched() );
			CallS( ErrDIRRelease( pfucbCatalog ) );
			fLatched = fFalse;
			}
			
		err = ErrIsamMove( pcompactinfo->ppib, pfucbCatalog, JET_MoveNext, NO_GRBIT );
		}
	while ( err >= 0 );
		
	if ( JET_errNoCurrentRecord == err )
		err = JET_errSuccess;

HandleError:
	if ( fLatched )
		{
		//	if still latched at this point, an error must have occurred
		Assert( err < 0 );
		CallS( ErrDIRRelease( pfucbCatalog ) );
		}
			
	Assert( !Pcsr( pfucbCatalog )->FLatched() );

	return err;
	}


#ifdef SLVDEFRAG_HACK

LOCAL ERR ErrCMPCopySLVOwnerMapObjidFid(
	PIB			* const ppib,
	FCB			* const pfcbSrc,
	FCB			* const pfcbDest,
	SLVOWNERMAP	* const pnodeSrc,
	SLVOWNERMAP	* const pnodeDest )
	{
	ERR	 		err 		= JET_errSuccess;
	char 		szTableName[JET_cbNameMost + 1];
	char 		szColumnName[JET_cbNameMost + 1];

	memcpy( pnodeDest, pnodeSrc, sizeof(SLVOWNERMAP) );

	Call( ErrCATGetObjectNameFromObjid(
				ppib,
				pfcbSrc->Ifmp(),
				pnodeSrc->Objid(),
				sysobjTable,
				pnodeSrc->Objid(),
				szTableName,
				sizeof(szTableName) ) );

	{
	OBJID objid = pnodeDest->Objid();
	Call( ErrCATSeekTable( ppib, pfcbDest->Ifmp(), szTableName, NULL, &objid ) );
	pnodeDest->SetObjid( objid );
	}

	//	UNDONE: I think this will fail if this is a derived table and the SLV column is in the template.
	Enforce( !FCOLUMNIDTemplateColumn( pnodeSrc->Columnid() ) );
	Call( ErrCATGetObjectNameFromObjid(
				ppib,
				pfcbSrc->Ifmp(),
				pnodeSrc->Objid(),
				sysobjColumn,
				pnodeSrc->Columnid(),
				szColumnName,
				sizeof(szColumnName) ) );

	JET_COLUMNDEF columndefDest;
	
	Call( ErrIsamGetColumnInfo(
				(JET_SESID)ppib,
				(JET_DBID)pfcbDest->Ifmp(),
				szTableName,
				szColumnName,
				NULL,
				&columndefDest,
				sizeof(columndefDest),
				JET_ColInfo ) );

	pnodeDest->SetColumnid( columndefDest.columnid );
		
HandleError:
	return err;
}

LOCAL ERR ErrCMPCopySLVTree( PIB *ppib, FCB *pfcbSrc, FCB *pfcbDest )
	{
	ERR		err;
	FUCB	*pfucbSrc	= pfucbNil;
	FUCB	*pfucbDest	= pfucbNil;
	DIB		dib;
	KEY		key;
	DATA	data;
	PGNO	pgnoT;
	BYTE	rgbKey[sizeof(PGNO)];
	BYTE	rgbData[ max ( sizeof(SLVSPACENODE), sizeof(SLVOWNERMAP) ) ];

	const BOOL 		fCopySLVAvailTree 	= pfcbSrc->FTypeSLVAvail();

	Assert ( pfcbSrc->FTypeSLVAvail() || pfcbSrc->FTypeSLVOwnerMap() );
	Assert ( pfcbDest->FTypeSLVAvail() || pfcbDest->FTypeSLVOwnerMap() );
	Assert ( ( pfcbSrc->FTypeSLVAvail() && pfcbDest->FTypeSLVAvail() )
			|| ( pfcbSrc->FTypeSLVOwnerMap() && pfcbDest->FTypeSLVOwnerMap() ) );


	key.prefix.Nullify();
	key.suffix.SetCb( sizeof(PGNO) );
	key.suffix.SetPv( rgbKey );
	
	data.SetPv( rgbData );

	Assert( pfcbNil != pfcbSrc );
	Assert( pfcbNil != pfcbDest );

	Call( ErrDIROpen( ppib, pfcbSrc, &pfucbSrc ) );
	Call( ErrDIROpen( ppib, pfcbDest, &pfucbDest ) );

	dib.dirflag = fDIRNull;
	dib.pos = posFirst;
	dib.pbm = NULL;
	
	//	first, delete all nodes from dest tree
	err = ErrBTDown( pfucbDest, &dib, latchReadNoTouch );
	if ( JET_errRecordNotFound != err )
		{
		Assert( JET_errNoCurrentRecord != err );

		do
			{
			Call( err );
			Call( ErrBTFlagDelete( pfucbDest, fDIRNoVersion ) );
			Pcsr( pfucbDest )->Downgrade( latchReadTouch );
			err = ErrBTNext( pfucbDest, fDIRNull );
			}
		while ( JET_errNoCurrentRecord != err );
		}
	BTUp( pfucbDest );

	//	now copy all nodes from src
	err = ErrBTDown( pfucbSrc, &dib, latchReadNoTouch );
	if ( JET_errRecordNotFound != err )
		{
		OBJID 	objidTableSrc 		= objidNil;

		Assert( JET_errNoCurrentRecord != err );
		do
			{
			BOOL fObjectDeleted = fFalse; // table or column deleted so we need to mark the space as empty
			
			Call( err );

			Assert( sizeof(PGNO) == pfucbSrc->kdfCurr.key.Cb() );
			LongFromKey( &pgnoT, pfucbSrc->kdfCurr.key );
			KeyFromLong( rgbKey, pgnoT );
			Assert( sizeof(PGNO) == key.Cb() );
			
			Assert ( pfucbSrc->kdfCurr.data.Cb() <= sizeof(rgbData) );
			
			if ( fCopySLVAvailTree )
				{
				Assert( sizeof(SLVSPACENODE) == pfucbSrc->kdfCurr.data.Cb() );
				}
			else
				{
				Assert( SLVOWNERMAP::FValidData( pfucbSrc->kdfCurr.data ) );
				
				// m_objid must be first in structure and persistent in the node 
				objidTableSrc = *( (UnalignedLittleEndian< OBJID >*)pfucbSrc->kdfCurr.data.Pv() );
				}

			SLVOWNERMAP	nodeSrc;
			if (!fCopySLVAvailTree)
				{
				nodeSrc.Retrieve( pfucbSrc->kdfCurr.data );
				nodeSrc.CopyInto( data );
				}
			else
				{
				memcpy( rgbData, pfucbSrc->kdfCurr.data.Pv(), pfucbSrc->kdfCurr.data.Cb() );
				data.SetCb( pfucbSrc->kdfCurr.data.Cb() );
				}
				
			Call( ErrBTRelease( pfucbSrc ) );
				
			if ( !fCopySLVAvailTree && objidNil != objidTableSrc )
				{
				SLVOWNERMAP	nodeDest;
				err = ErrCMPCopySLVOwnerMapObjidFid( ppib, pfcbSrc, pfcbDest, &nodeSrc, &nodeDest );

				if ( err == JET_errColumnNotFound || err == JET_errObjectNotFound )
					{
					// we have to clean the page in SLVAvail and SLVOwnerMap
					// we insert the same node and after that we call ErrSLVDeleteCommittedRange that will clean SLVAvial and
					// will update the node from SLVOwnerMap just inserted
					fObjectDeleted = fTrue;
					err = JET_errSuccess;
					}
				Call ( err );

				nodeDest.CopyInto( data );
				}
				
			Call( ErrBTInsert( pfucbDest, key, data, fDIRNoVersion ) );
			BTUp( pfucbDest ); 

			if ( fObjectDeleted )
				{
				Call( ErrSLVDeleteCommittedRange(	ppib,
													pfcbDest->Ifmp(),
													OffsetOfPgno( pgnoT ),
													SLVPAGE_SIZE,
													CSLVInfo::fileidNil,
													0,
													L"" ) );
				}
			
			err = ErrBTNext( pfucbSrc, fDIRNull );
			}
		while ( JET_errNoCurrentRecord != err );
		}

	err = JET_errSuccess;

HandleError:
	if ( pfucbNil != pfucbDest )
		DIRClose( pfucbDest );
	if ( pfucbNil != pfucbSrc )
		DIRClose( pfucbSrc );

	return err;
	}

#endif	//	SLVDEFRAG_HACK


INLINE ERR ErrCMPCopyTables( COMPACTINFO *pcompactinfo )
	{
	ERR		err;
	FUCB	*pfucbCatalog	= pfucbNil;
	BOOL	fDerivedTables	= fFalse;

	CallR( ErrCATOpen( pcompactinfo->ppib, pcompactinfo->ifmpSrc, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	Call( ErrIsamSetCurrentIndex( pcompactinfo->ppib, pfucbCatalog, szMSORootObjectsIndex ) );

	fDerivedTables = fFalse;
	Call( ErrCMPCopySelectedTables(
				pcompactinfo,
				pfucbCatalog,
				fFalse,
				&fDerivedTables ) );

	if ( fDerivedTables )		// Process derived tables on second pass.
		{
		Call( ErrCMPCopySelectedTables(
					pcompactinfo,
					pfucbCatalog,
					fTrue,
					NULL ) );
		}

	Call( ErrCATClose( pcompactinfo->ppib, pfucbCatalog ) );
	pfucbCatalog = pfucbNil;

#ifdef SLVDEFRAG_HACK
	if ( !rgfmp[pcompactinfo->ifmpDest].FDefragSLVCopy() && 
		rgfmp[pcompactinfo->ifmpSrc].FSLVAttached() )
		{
		CHAR		szSLVPath[IFileSystemAPI::cchPathMax];
		SLVFILEHDR	*pslvfilehdr;

		Call( ErrCMPCopySLVTree(
					pcompactinfo->ppib,
					rgfmp[pcompactinfo->ifmpSrc].PfcbSLVAvail(),
					rgfmp[pcompactinfo->ifmpDest].PfcbSLVAvail() ) );

		// copy also the OwnerMap tree
		Assert ( pfcbNil != rgfmp[pcompactinfo->ifmpSrc].PfcbSLVOwnerMap() );
		Assert ( pfcbNil != rgfmp[pcompactinfo->ifmpDest].PfcbSLVOwnerMap() );
		Call ( ErrCMPCopySLVTree(
					pcompactinfo->ppib,
					rgfmp[pcompactinfo->ifmpSrc].PfcbSLVOwnerMap(),
					rgfmp[pcompactinfo->ifmpDest].PfcbSLVOwnerMap() ) );		

		Assert( rgfmp[pcompactinfo->ifmpDest].FSLVAttached() );

		Assert( NULL != rgfmp[pcompactinfo->ifmpSrc].SzSLVName() );
		strcpy( szSLVPath, rgfmp[pcompactinfo->ifmpSrc].SzSLVName() );

		pslvfilehdr = (SLVFILEHDR *)PvOSMemoryPageAlloc( g_cbPage, NULL );
		if ( NULL == pslvfilehdr )
			{
			err = ErrERRCheck( JET_errOutOfMemory );
			goto HandleError;
			}

		SLVClose( pcompactinfo->ifmpSrc );
		
        err = ErrUtilReadAndFixShadowedHeader(
        				PinstFromPpib( pcompactinfo->ppib )->m_pfsapi,
        				( const _TCHAR* ) szSLVPath,
        				( BYTE * ) pslvfilehdr,
        				( unsigned long ) g_cbPage,
        				(const unsigned long) (OffsetOf( SLVFILEHDR, le_cbPageSize )) );
		if ( err >= 0 )
			{
			Assert( rgfmp[pcompactinfo->ifmpDest].Pdbfilehdr()->FSLVExists() );
			rgfmp[pcompactinfo->ifmpDest].Pdbfilehdr()->SetSLVExists();
			memcpy( &rgfmp[pcompactinfo->ifmpDest].Pdbfilehdr()->signSLV, &pslvfilehdr->signSLV, sizeof(SIGNATURE) );

			// terrible hack: replace one SLV file's header with other 
			SLVSoftSyncHeaderSLVDB( pslvfilehdr, rgfmp[pcompactinfo->ifmpDest].Pdbfilehdr() );
			err = ErrUtilWriteShadowedHeader(	PinstFromPpib( pcompactinfo->ppib )->m_pfsapi, 
												rgfmp[pcompactinfo->ifmpDest].SzSLVName(), 
												fFalse,
												(BYTE *)pslvfilehdr, 
												g_cbPage,
												rgfmp[pcompactinfo->ifmpDest].PfapiSLV() );
			ERR errT;
			errT = ErrUtilWriteShadowedHeader(	PinstFromPpib( pcompactinfo->ppib )->m_pfsapi, 
												szSLVPath, 
												fFalse,
												(BYTE *)pslvfilehdr, 
												g_cbPage );
			if ( err >= 0 )
				{
				err = errT; 
				}
			}
		
		Assert( NULL != pslvfilehdr );
		OSMemoryPageFree( (VOID *)pslvfilehdr );

		Call( err );
		}
#endif // SLVDEFRAG_HACK

HandleError:
	if (pfucbNil != pfucbCatalog)
		{
		CallS( ErrCATClose( pcompactinfo->ppib, pfucbCatalog ) );
		pfucbCatalog = pfucbNil;
		}

	return err;
	}


INLINE ERR ErrCMPCloseDB( COMPACTINFO *pcompactinfo, ERR err )
	{
	ERR		errCloseSrc;
	ERR		errCloseDest;
	PIB		*ppib = pcompactinfo->ppib;

	errCloseSrc = ErrDBCloseDatabase( ppib, pcompactinfo->ifmpSrc, NO_GRBIT );
	errCloseDest = ErrDBCloseDatabase( ppib, pcompactinfo->ifmpDest, NO_GRBIT );

	if ( err >= 0 )
		{
		if ( errCloseSrc < 0 )
			err = errCloseSrc;
		else if ( errCloseDest < 0 )
			err = errCloseDest;
		}
		
	return err;
	}


ERR ISAMAPI ErrIsamCompact(
	JET_SESID		sesid,
	const CHAR		*szDatabaseSrc,
	IFileSystemAPI	*pfsapiDest,
	const CHAR		*szDatabaseDest,
	const CHAR		*szDatabaseSLVDest,
	JET_PFNSTATUS	pfnStatus,
	JET_CONVERT		*pconvert,
	JET_GRBIT		grbit )
	{
	ERR				err					= JET_errSuccess;
	COMPACTINFO		*pcompactinfo		= NULL;
	BOOL			fDatabasesOpened	= fFalse;
	BOOL			fGlobalRepairSave	= fGlobalRepair;

#ifdef RTM
#else
	CMEMLIST::UnitTest();
#endif	//	!RTM

	if ( pconvert )
		{
		//	convert was ripped out in ESE98
		return ErrERRCheck( JET_errFeatureNotAvailable );
		}

	pcompactinfo = (COMPACTINFO *)PvOSMemoryHeapAlloc( sizeof( COMPACTINFO ) );
	if ( !pcompactinfo )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}
	memset( pcompactinfo, 0, sizeof( COMPACTINFO ) );
	
 	pcompactinfo->ppib = reinterpret_cast<PIB *>( sesid );
 	if ( pcompactinfo->ppib->level > 0 )
 		{
 		Error( ErrERRCheck( JET_errInTransaction ), Cleanup );
 		}

	fGlobalRepair = grbit & JET_bitCompactRepair;

	if ( NULL != pfnStatus )
		{
		pcompactinfo->pstatus = (STATUSINFO *)PvOSMemoryHeapAlloc( sizeof(STATUSINFO) );
		if ( pcompactinfo->pstatus == NULL )
			{
			Error( ErrERRCheck( JET_errOutOfMemory ), Cleanup );
			}

		memset( pcompactinfo->pstatus, 0, sizeof(STATUSINFO) );

		pcompactinfo->pstatus->sesid = sesid;
		pcompactinfo->pstatus->pfnStatus = pfnStatus;
		
		if ( fGlobalRepair )
			pcompactinfo->pstatus->snp = JET_snpRepair;
		else
			pcompactinfo->pstatus->snp = JET_snpCompact;

		Call( ErrCMPInitProgress(
					pcompactinfo->pstatus,
					szDatabaseSrc,
					szCompactAction,
					( grbit & JET_bitCompactStats ) ? szCompactStatsFile : NULL ) );
		}

	else
		{
		pcompactinfo->pstatus = NULL;
		}

	/* Open and create the databases */
	Call( ErrCMPOpenDB( pcompactinfo, szDatabaseSrc, pfsapiDest, szDatabaseDest, szDatabaseSLVDest ) );
	if ( grbit & JET_bitCompactSLVCopy )
		{
		rgfmp[ pcompactinfo->ifmpDest ].SetDefragSLVCopy();
		}
	else
		{
		rgfmp[ pcompactinfo->ifmpDest ].ResetDefragSLVCopy();
		}
	fDatabasesOpened = fTrue;

	if ( NULL != pfnStatus )
		{
		Assert( pcompactinfo->pstatus );

		/* Init status meter.  We'll be tracking status by pages processed, */
		err = ErrIsamGetDatabaseInfo(
					sesid,
					(JET_DBID) pcompactinfo->ifmpSrc,
					&pcompactinfo->pstatus->cDBPagesOwned,
					sizeof(pcompactinfo->pstatus->cDBPagesOwned),
					JET_DbInfoSpaceOwned );
		if ( err < 0 )
			{
			if ( fGlobalRepair )
				{
				// Set to default value.
				pcompactinfo->pstatus->cDBPagesOwned = cpgDatabaseMin;
				}
			else
				{
				goto HandleError;
				}
			}
			
		err = ErrIsamGetDatabaseInfo(
					sesid,
					(JET_DBID) pcompactinfo->ifmpSrc,
					&pcompactinfo->pstatus->cDBPagesAvail,
					sizeof(pcompactinfo->pstatus->cDBPagesAvail),
					JET_DbInfoSpaceAvailable );
		if ( err < 0 )
			{
			if ( fGlobalRepair )
				{
				// Set to default value.
				pcompactinfo->pstatus->cDBPagesAvail = 0;
				}
			else
				goto HandleError;
			}

		// Don't count unused space in the database;
		Assert( pcompactinfo->pstatus->cDBPagesOwned >= cpgDatabaseMin );
		Assert( pcompactinfo->pstatus->cDBPagesAvail < pcompactinfo->pstatus->cDBPagesOwned );
		pcompactinfo->pstatus->cunitTotal = 
			pcompactinfo->pstatus->cDBPagesOwned - pcompactinfo->pstatus->cDBPagesAvail;

		// Approximate the number of pages used by MSysObjects
		pcompactinfo->pstatus->cunitDone = cpgMSOInitial;
		Assert( pcompactinfo->pstatus->cunitDone <= pcompactinfo->pstatus->cunitTotal );
		pcompactinfo->pstatus->cunitProjected = pcompactinfo->pstatus->cunitTotal;

		Call( ErrCMPReportProgress( pcompactinfo->pstatus ) );

		if ( pcompactinfo->pstatus->fDumpStats )
			{
			INT iSec, iMSec;

			Assert( pcompactinfo->pstatus->hfCompactStats );
			CMPGetTime( pcompactinfo->pstatus->timerInitDB, &iSec, &iMSec );
			fprintf(
				pcompactinfo->pstatus->hfCompactStats,
				"\nNew database created and initialized in %d.%d seconds.\n",
				iSec, iMSec );
				
			fprintf(
				pcompactinfo->pstatus->hfCompactStats,
				"    (Source database is %I64d bytes and it owns %d pages, of which %d are available.)\n",
				QWORD( pcompactinfo->pstatus->cDBPagesOwned + cpgDBReserved ) * g_cbPage,
				pcompactinfo->pstatus->cDBPagesOwned,
				pcompactinfo->pstatus->cDBPagesAvail );
			fprintf(
				pcompactinfo->pstatus->hfCompactStats,
				"\n\n%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n\n",
				szCMPSTATSTableName,
				szCMPSTATSFixedVarCols,
				szCMPSTATSTaggedCols,
				szCMPSTATSColumns,
				szCMPSTATSSecondaryIdx,
				szCMPSTATSPagesOwned,
				szCMPSTATSPagesAvail,
				szCMPSTATSInitTime,
				szCMPSTATSRecordsCopied,
				szCMPSTATSRawData,
				szCMPSTATSRawDataLV,
				szCMPSTATSLeafPages,
				szCMPSTATSMinLVPages,
				szCMPSTATSRecordsTime,
				szCMPSTATSTableTime );
			fflush( pcompactinfo->pstatus->hfCompactStats );
			}
		}


	/* Create and copy all non-container objects */

	Call( ErrCMPCopyTables( pcompactinfo ) );

	if ( pfnStatus )
		{
		Assert( pcompactinfo->pstatus );
		Assert( pcompactinfo->pstatus->cunitDone <= pcompactinfo->pstatus->cunitTotal );
		if ( pcompactinfo->pstatus->fDumpStats )
			{
			fprintf(
				pcompactinfo->pstatus->hfCompactStats,
				"\nDatabase defragmented to %I64d bytes.\n",
				rgfmp[pcompactinfo->ifmpDest].CbTrueFileSize() );
				
			INST *pinst = PinstFromPpib( (PIB *) sesid );
			fprintf(
				pcompactinfo->pstatus->hfCompactStats,
				"Temp. database used %I64d bytes during defragmentation.\n",
				rgfmp[pinst->m_mpdbidifmp[dbidTemp]].CbTrueFileSize() );
			fflush( pcompactinfo->pstatus->hfCompactStats );
			}
		}

		

HandleError:
	if ( fDatabasesOpened )
		{
		err = ErrCMPCloseDB( pcompactinfo, err );
		
		ERR	errT = ErrIsamDetachDatabase( sesid, pfsapiDest, szDatabaseDest );
		if ( errT < 0 && err >= 0 )
			err = errT;
		}

	if ( NULL != pfnStatus )		// top off status meter
		{
		Assert( pcompactinfo->pstatus );

		err = ErrCMPTermProgress( pcompactinfo->pstatus, szCompactAction, err );
		}

Cleanup:
	if ( pcompactinfo->pstatus )
		{
		OSMemoryHeapFree( pcompactinfo->pstatus );
		}

	OSMemoryHeapFree( pcompactinfo );

	fGlobalRepair = fGlobalRepairSave;
	return err;
	}

#endif	//	MINIMAL_FUNCTIONALITY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\dbtask.cxx ===
#include "std.hxx"

//  ****************************************************************
//	TASK
//  ****************************************************************

INT TASK::g_tasksDropped = 0;

TASK::TASK()
	{
	}

TASK::~TASK()
	{
	}

DWORD TASK::DispatchGP( void *pvThis )
	{
	ERR				err;
	TASK * const	ptask	= (TASK *)pvThis;
	INST * const	pinst	= ptask->PInstance();
	PIB *			ppibT;

	Assert( pinstNil != pinst );

	err = pinst->ErrGetSystemPib( &ppibT );
	if ( err >= JET_errSuccess )
		{
		err = ptask->ErrExecute( ppibT );
		pinst->ReleaseSystemPib( ppibT );
		}
	else
		{
		++g_tasksDropped;
		if( 0 == g_tasksDropped % 100 )
			{
			//	UNDONE: eventlog
			//
			//	The system was unable to perform background tasks due to low resources
			//	If this problem persists there may be a performance problem with the server
			}
		}

	if ( err < JET_errSuccess )
		{
		ptask->HandleError( err );
		}

	//  the TASK must have been allocated with "new"
	delete ptask;
	return 0;
	}

VOID TASK::Dispatch( PIB * const ppib, const ULONG_PTR ulThis )
	{
	TASK * const	ptask	= (TASK *)ulThis;
	const ERR		err		= ptask->ErrExecute( ppib );

	if ( err < 0 )
		{
		ptask->HandleError( err );
		}

	//  the TASK must have been allocated with "new"
	delete ptask;
	}


//  ****************************************************************
//	DBTASK
//  ****************************************************************
		
DBTASK::DBTASK( const IFMP ifmp ) :
	m_ifmp( ifmp )
	{
	FMP * const pfmp = &rgfmp[m_ifmp];
	CallS( pfmp->RegisterTask() );
	}

INST *DBTASK::PInstance()
	{
	return PinstFromIfmp( m_ifmp );
	}

DBTASK::~DBTASK()
	{
	FMP * const pfmp = &rgfmp[m_ifmp];
	CallS( pfmp->UnregisterTask() );
	}


#ifdef ASYNC_DB_EXTENSION

//  ****************************************************************
//	DBTASK
//  ****************************************************************

DBEXTENDTASK::DBEXTENDTASK( const IFMP ifmp, const QWORD cbSize ) :
	DBTASK( ifmp ),
	m_cbSizeTarget( cbSize )
	{
	}

ERR DBEXTENDTASK::ErrExecute( PIB * const ppib )
	{
	ERR			err			= JET_errSuccess;
	FMP *		pfmp		= rgfmp + m_ifmp;

#ifdef DONT_ZERO_TEMP_DB
	const BOOL	fFastExt	= ( dbidTemp == pfmp->Dbid() );
#else
	const BOOL	fFastExt	= fFalse;
#endif


	pfmp->SemIOExtendDB().Acquire();

	//	check to make sure no one beat us to the file extension
	//
	if ( m_cbSizeTarget > pfmp->CbTrueFileSize()
		&& m_cbSizeTarget > pfmp->CbAsyncExtendedTrueFileSize() )
		{
		err = pfmp->Pfapi()->ErrSetSize( m_cbSizeTarget, fFastExt );

		if ( JET_errSuccess == err )
			{
			pfmp->SetCbAsyncExtendedTrueFileSize( m_cbSizeTarget );
			}
		}

	pfmp->SemIOExtendDB().Release();

	return err;
	}

VOID DBEXTENDTASK::HandleError( const ERR err )
	{
	//	ignore errors - db extension will simply be
	//	retried synchronously
	}

#endif	//	ASYNC_DB_EXTENSION


//  ****************************************************************
//	RECTASK
//  ****************************************************************

RECTASK::RECTASK( const PGNO pgnoFDP, FCB * const pfcb, const IFMP ifmp, const BOOKMARK& bm ) :
	DBTASK( ifmp ),
	m_pgnoFDP( pgnoFDP ),
	m_pfcb( pfcb ),
	m_cbBookmarkKey( bm.key.Cb() ),
	m_cbBookmarkData( bm.data.Cb() )
	{
	//	don't fire off async tasks on the temp. database because the
	//	temp. database is simply not equipped to deal with concurrent access
	AssertRTL( dbidTemp != rgfmp[ifmp].Dbid() );

	Assert( !bm.key.FNull() );
	Assert( m_cbBookmarkKey <= sizeof( m_rgbBookmarkKey ) );
	Assert( m_cbBookmarkData <= sizeof( m_rgbBookmarkData ) );
	bm.key.CopyIntoBuffer( m_rgbBookmarkKey, sizeof( m_rgbBookmarkKey ) );
	memcpy( m_rgbBookmarkData, bm.data.Pv(), m_cbBookmarkData );

	//	if coming from version cleanup, refcount may be zero, so the only thing
	//	currently keeping this FCB pinned is the RCE that spawned this task
	//	if coming from OLD, there must already be a cursor open on this
	Assert( m_pgnoFDP == m_pfcb->PgnoFDP() );
	Assert( prceNil != m_pfcb->PrceOldest() || m_pfcb->WRefCount() > 0 );

	//	pin the FCB by incrementing its refcnt

//	Assert( m_pfcb->FNeedLock() );
//	m_pfcb->IncrementRefCount();
	m_pfcb->RegisterTask();
	
//	Assert( prceNil != m_pfcb->PrceOldest() || m_pfcb->WRefCount() > 1 );
	}

RECTASK::~RECTASK()
	{
	Assert( m_pfcb->PgnoFDP() == m_pgnoFDP );

	//	release the FCB by decrementing its refcnt

//	Assert( m_pfcb->WRefCount() > 0 );
//	Assert( m_pfcb->FNeedLock() );
//	m_pfcb->Release();
	m_pfcb->UnregisterTask();
	}

ERR RECTASK::ErrOpenCursor( PIB * const ppib, FUCB ** ppfucb )
	{
	ERR		err;

	Assert( m_pfcb->FInitialized() );
	Assert( m_pfcb->CTasksActive() > 0 );
	Assert( m_pgnoFDP == m_pfcb->PgnoFDP() );

	Call( ErrDIROpen( ppib, m_pfcb, ppfucb ) );
	Assert( pfucbNil != *ppfucb );
	FUCBSetIndex( *ppfucb );

HandleError:
	return err;
	}

ERR RECTASK::ErrOpenCursorAndGotoBookmark( PIB * const ppib, FUCB ** ppfucb )
	{
	ERR			err;
	BOOKMARK	bookmark;

	CallR( ErrOpenCursor( ppib, ppfucb ) );

	bookmark.key.Nullify();
	bookmark.key.suffix.SetPv( m_rgbBookmarkKey );
	bookmark.key.suffix.SetCb( m_cbBookmarkKey );
	bookmark.data.SetPv( m_rgbBookmarkData );
	bookmark.data.SetCb( m_cbBookmarkData );

	Call( ErrDIRGotoBookmark( *ppfucb, bookmark ) );

HandleError:
	if( err < 0 )
		{
		DIRClose( *ppfucb );
		*ppfucb = pfucbNil;		//	set to NULL in case caller tries to close it again
		}

	return err;
	}


//  ****************************************************************
//	DELETERECTASK
//  ****************************************************************

DELETERECTASK::DELETERECTASK( const PGNO pgnoFDP, FCB * const pfcb, const IFMP ifmp, const BOOKMARK& bm ) :
	RECTASK( pgnoFDP, pfcb, ifmp, bm )
	{
	}

ERR DELETERECTASK::ErrExecute( PIB * const ppib )
	{
	ERR			err;
	FUCB *		pfucb		= pfucbNil;
	BOOKMARK	bookmark;

	Assert( 0 == ppib->level );
	CallR( ErrOpenCursor( ppib, &pfucb ) );
	Assert( pfucbNil != pfucb );

	bookmark.key.Nullify();
	bookmark.key.suffix.SetPv( m_rgbBookmarkKey );
	bookmark.key.suffix.SetCb( m_cbBookmarkKey );
	bookmark.data.SetPv( m_rgbBookmarkData );
	bookmark.data.SetCb( m_cbBookmarkData );

	Call( ErrBTDelete( pfucb, bookmark ) );

HandleError:
	DIRClose( pfucb );

	return err;
	}

VOID DELETERECTASK::HandleError( const ERR err )
	{
	//	this should only be called if the task failed for some reason
	//
	Assert( err < JET_errSuccess );

	PinstFromIfmp( m_ifmp )->m_pver->IncrementCCleanupFailed();
	}


//  ****************************************************************
//	FINALIZETASK
//  ****************************************************************

FINALIZETASK::FINALIZETASK(
	const PGNO		pgnoFDP,
	FCB * const		pfcb,
	const IFMP		ifmp,
	const BOOKMARK&	bm,
	const USHORT	ibRecordOffset,
	const BOOL		fCallback,
	const BOOL		fDelete ) :
	RECTASK( pgnoFDP, pfcb, ifmp, bm ),
	m_ibRecordOffset( ibRecordOffset ),
	m_fCallback( !!fCallback ),
	m_fDelete( !!fDelete )
	{
	}

ERR FINALIZETASK::ErrExecute( PIB * const ppib )
	{
	ERR		err;
	FUCB *	pfucb		= pfucbNil;

	Assert( 0 == ppib->level );
	CallR( ErrOpenCursorAndGotoBookmark( ppib, &pfucb ) );
	Assert( pfucbNil != pfucb );

	//
	//	UNDONE: issue callback if m_fCallback and delete record if m_fDelete
	//	but for now, we unconditionally do one or the other, depending on
	//	whether this is ESE or ESENT
	//
	Assert( m_fCallback || m_fDelete );

#ifdef ESENT

	BOOL	fInTrx		= fFalse;

	Call( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	fInTrx = fTrue;

	Call( ErrDIRGet( pfucb ) );

	//  Currently all finalizable columns are ULONGs
	ULONG	ulColumn;
	ulColumn = *( (UnalignedLittleEndian< ULONG > *)( (BYTE *)pfucb->kdfCurr.data.Pv() + m_ibRecordOffset ) );

	CallS( ErrDIRRelease( pfucb ) );

	//	verify refcount is still at zero and there are
	//	no outstanding record updates
	if ( 0 == ulColumn
		&& !FVERActive( pfucb, pfucb->bmCurr )
		&& !pfucb->u.pfcb->FDeletePending() )
		{
		Call( ErrIsamDelete( ppib, pfucb ) );
		}

	Call( ErrDIRCommitTransaction( ppib, JET_bitCommitLazyFlush ) );
	fInTrx = fFalse;

#else

	const BOOL	fInTrx	= fFalse;

	Call( ErrDIRBeginTransaction( ppib, JET_bitTransactionReadOnly ) );	//	READ-ONLY transaction

	err = ErrRECCallback( ppib, pfucb, JET_cbtypFinalize, 0, NULL, NULL, 0 );
	
	//	no updates performed, so just force success
	//
	CallS( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );
	Assert( 0 == ppib->level );

#endif	//	ESENT

HandleError:	
	if ( fInTrx )
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}

	Assert( pfucbNil != pfucb );
	DIRClose( pfucb );
	return err;
	}

VOID FINALIZETASK::HandleError( const ERR err )
	{
	//	this should only be called if the task failed for some reason
	//
	Assert( err < JET_errSuccess );

	PinstFromIfmp( m_ifmp )->m_pver->IncrementCCleanupFailed();
	}


//  ****************************************************************
//	DELETELVTASK
//  ****************************************************************

DELETELVTASK::DELETELVTASK( const PGNO pgnoFDP, FCB * const pfcb, const IFMP ifmp, const BOOKMARK& bm ) :
	RECTASK( pgnoFDP, pfcb, ifmp, bm )
	{
	}

ERR DELETELVTASK::ErrExecute( PIB * const ppib )
	{
	ERR err = JET_errSuccess;
	BOOL fInTrx = fFalse;
	
	Assert( sizeof( LID ) == m_cbBookmarkKey );
	Assert( 0 == m_cbBookmarkData );
	
	FUCB * pfucb = pfucbNil;

	Assert( m_pfcb->FTypeLV() );
	CallR( ErrOpenCursorAndGotoBookmark( ppib, &pfucb ) );

	Call( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	fInTrx = fTrue;

	Call( ErrDIRGet( pfucb ) );
	Call( ErrRECDeletePossiblyDereferencedLV( pfucb, TrxOldest( PinstFromPfucb( pfucb ) ) ) );
	if ( Pcsr( pfucb )->FLatched() )
		{
		CallS( ErrDIRRelease( pfucb ) );
		}
	
	Call( ErrDIRCommitTransaction( ppib, JET_bitCommitLazyFlush ) );
	fInTrx = fFalse;

HandleError:	
	if ( fInTrx )
		{
		if ( Pcsr( pfucb )->FLatched() )
			{
			CallS( ErrDIRRelease( pfucb ) );
			}
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}

	if ( pfucbNil != pfucb )
		{
		DIRClose( pfucb );
		}
	return err;
	}

VOID DELETELVTASK::HandleError( const ERR err )
	{
	//	this should only be called if the task failed for some reason
	//
	Assert( err < JET_errSuccess );

	PinstFromIfmp( m_ifmp )->m_pver->IncrementCCleanupFailed();
	}


//  ****************************************************************
//	MERGEAVAILEXTTASK
//  ****************************************************************

MERGEAVAILEXTTASK::MERGEAVAILEXTTASK( const PGNO pgnoFDP, FCB * const pfcb, const IFMP ifmp, const BOOKMARK& bm ) :
	RECTASK( pgnoFDP, pfcb, ifmp, bm )
	{
	}

ERR MERGEAVAILEXTTASK::ErrExecute( PIB * const ppib )
	{
	ERR			err			= JET_errSuccess;
	FUCB		* pfucbAE	= pfucbNil;
	BOOL		fInTrx		= fFalse;
	BOOKMARK	bookmark;

	bookmark.key.Nullify();
	bookmark.key.suffix.SetPv( m_rgbBookmarkKey );
	bookmark.key.suffix.SetCb( m_cbBookmarkKey );
	bookmark.data.SetPv( m_rgbBookmarkData );
	bookmark.data.SetCb( m_cbBookmarkData );

	Assert( m_pgnoFDP == m_pfcb->PgnoFDP() );
	Assert( pgnoNull != m_pfcb->PgnoAE() );
	CallR( ErrSPIOpenAvailExt( ppib, m_pfcb, &pfucbAE ) );

	//	see comment in ErrBTDelete() regarding why transaction
	//	here is necessary
	//
	Call( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	fInTrx = fTrue;

	Call( ErrBTIMultipageCleanup( pfucbAE, bookmark ) );

	Call( ErrDIRCommitTransaction( ppib, JET_bitCommitLazyFlush ) );
	fInTrx = fFalse;

HandleError:
	Assert( pfucbNil != pfucbAE );
	Assert( !Pcsr( pfucbAE )->FLatched() );

	if ( fInTrx )
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}

	Assert( pfucbNil != pfucbAE );
	BTClose( pfucbAE );

	return err;
	}

VOID MERGEAVAILEXTTASK::HandleError( const ERR err )
	{
	//	this task will be re-issued when another record on the page is deleted
	}


#ifdef DISABLE_SLV
#else

//  ****************************************************************
//	FREESLVSPACETASK
//  ****************************************************************

SLVSPACETASK::SLVSPACETASK(
			const PGNO pgnoFDP,
			FCB * const pfcb,
			const IFMP ifmp,
			const BOOKMARK& bm,
			const SLVSPACEOPER oper,
			const LONG ipage,
			const LONG cpages ) :
	RECTASK( pgnoFDP, pfcb, ifmp, bm ),
	m_oper( oper ),
	m_ipage( ipage ),
	m_cpages( cpages )
	{
	}
		
ERR SLVSPACETASK::ErrExecute( PIB * const ppib )
	{
	ERR err = JET_errSuccess;
	BOOL fInTrx = fFalse;
	
	Assert( sizeof( PGNO ) == m_cbBookmarkKey );
	Assert( 0 == m_cbBookmarkData );
	
	FUCB * pfucb = pfucbNil;

	CallR( ErrOpenCursorAndGotoBookmark( ppib, &pfucb ) );

	Call( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	fInTrx = fTrue;

Refresh:
	Call( ErrDIRGet( pfucb ) );
	err = Pcsr( pfucb )->ErrUpgrade();
	if ( errBFLatchConflict == err )
		{
		Assert( !Pcsr( pfucb )->FLatched() );
		goto Refresh;
		}
	Call( err );

	// No need to mark the pages as unused in the SpaceMap
	// because the operation isn't moving pages out from the commited state
	// (transition into commited state are not marked in SpaceMap at this level)
	Assert ( slvspaceoperDeletedToFree == m_oper );
	
	Call( ErrBTMungeSLVSpace( pfucb, m_oper, m_ipage, m_cpages, fDIRNoVersion ) );
	CallS( ErrDIRRelease( pfucb ) );
	
	Call( ErrDIRCommitTransaction( ppib, JET_bitCommitLazyFlush ) );
	fInTrx = fFalse;

HandleError:	
	if ( fInTrx )
		{
		if ( Pcsr( pfucb )->FLatched() )
			{
			CallS( ErrDIRRelease( pfucb ) );
			}
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}
	if ( pfucbNil != pfucb )
		{
		DIRClose( pfucb );
		}
	return err;
	}

VOID SLVSPACETASK::HandleError( const ERR err )
	{
	//	this should only be called if the task failed for some reason
	//
	Assert( err < JET_errSuccess );

	PinstFromIfmp( m_ifmp )->m_pver->IncrementCCleanupFailed();
	}


//  ****************************************************************
//	OSSLVDELETETASK
//  ****************************************************************

OSSLVDELETETASK::OSSLVDELETETASK(
			const IFMP				ifmp,
			const QWORD				ibLogical,
			const QWORD				cbSize,
			const CSLVInfo::FILEID	fileid,
			const QWORD				cbAlloc,
			const wchar_t*			wszFileName ) :
	DBTASK( ifmp ),
	m_ibLogical( ibLogical ),
	m_cbSize( cbSize ),
	m_fileid( fileid ),
	m_cbAlloc( cbAlloc )
	{
	//	don't fire off async tasks on the temp. database because the
	//	temp. database is simply not equipped to deal with concurrent access
	AssertRTL( dbidTemp != rgfmp[ifmp].Dbid() );

	wcscpy( m_wszFileName, wszFileName );
	}
		
ERR OSSLVDELETETASK::ErrExecute( PIB * const ppib )
	{
	ERR			err		= JET_errSuccess;
	CSLVInfo	slvinfo;

	CallS( slvinfo.ErrCreateVolatile() );

	CallS( slvinfo.ErrSetFileID( m_fileid ) );
	CallS( slvinfo.ErrSetFileAlloc( m_cbAlloc ) );
	CallS( slvinfo.ErrSetFileName( m_wszFileName ) );

	CSLVInfo::HEADER header;
	header.cbSize			= m_cbSize;
	header.cRun				= 1;
	header.fDataRecoverable	= fFalse;
	header.rgbitReserved_31	= 0;
	header.rgbitReserved_32	= 0;
	CallS( slvinfo.ErrSetHeader( header ) );

	CSLVInfo::RUN run;
	run.ibVirtualNext	= m_cbSize;
	run.ibLogical		= m_ibLogical;
	run.qwReserved		= 0;
	run.ibVirtual		= 0;
	run.cbSize			= m_cbSize;
	run.ibLogicalNext	= m_ibLogical + m_cbSize;
	CallS( slvinfo.ErrMoveAfterLast() );
	CallS( slvinfo.ErrSetCurrentRun( run ) );

	Call( ErrOSSLVRootSpaceDelete( rgfmp[ m_ifmp ].SlvrootSLV(), slvinfo ) );

HandleError:
	slvinfo.Unload();
	return err;
	}

VOID OSSLVDELETETASK::HandleError( const ERR err )
	{
	//	this should only be called if the task failed for some reason
	//
	Assert( err < JET_errSuccess );

	PinstFromIfmp( m_ifmp )->m_pver->IncrementCCleanupFailed();
	}

#endif	//	DISABLE_SLV
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\dump.cxx ===
#include "std.hxx"
#include "_dump.hxx"
///#include <ctype.h>

LOCAL const char *rgszDBState[] = {
						"Illegal",
						"Just Created",
						"Dirty Shutdown",
						"Clean Shutdown",
						"Being Converted",
						"Force Detach Replay Error" };


// For ErrDUMPLog():

extern BOOL 	fDBGPrintToStdOut;

ULONG rgclrtyp[ lrtypMax ];
ULONG rgcb[ lrtypMax ];

/* in-memory log buffer. */
#define			csecLGBufSize 100

LOCAL VOID VARARG DUMPPrintF(const CHAR * fmt, ...)
	{
	va_list arg_ptr;
	va_start( arg_ptr, fmt );
	vprintf( fmt, arg_ptr );
	fflush( stdout );
	va_end( arg_ptr );
	}


LOCAL VOID DUMPPrintSig( SIGNATURE *psig )
	{
	LOGTIME tm = psig->logtimeCreate;
	DUMPPrintF( "Create time:%02d/%02d/%04d %02d:%02d:%02d ",
						(short) tm.bMonth, (short) tm.bDay,	(short) tm.bYear + 1900,
						(short) tm.bHours, (short) tm.bMinutes, (short) tm.bSeconds);
	DUMPPrintF( "Rand:%lu ", ULONG(psig->le_ulRandom) );
	DUMPPrintF( "Computer:%s\n", psig->szComputerName );
	}

VOID DUMPIAttachInfo( ATCHCHK *patchchk )
	{
	const DBTIME	dbtime	= patchchk->Dbtime();
	DUMPPrintF( "        dbtime: %I64u (%u-%u)\n",
				dbtime,
				((QWORDX *)&dbtime)->DwHigh(),
				((QWORDX *)&dbtime)->DwLow() );
	DUMPPrintF( "        objidLast: %u\n", patchchk->ObjidLast() );
	DUMPPrintF( "        Signature: " );
	DUMPPrintSig( &patchchk->signDb );
	DUMPPrintF( "        MaxDbSize: %u pages\n", patchchk->CpgDatabaseSizeMax() );
	DUMPPrintF( "        Last Attach: (0x%X,%X,%X)\n",
			patchchk->lgposAttach.lGeneration,
			patchchk->lgposAttach.isec,
			patchchk->lgposAttach.ib );
	DUMPPrintF( "        Last Consistent: (0x%X,%X,%X)\n",
			patchchk->lgposConsistent.lGeneration,
			patchchk->lgposConsistent.isec,
			patchchk->lgposConsistent.ib );
	}
	
ERR ErrDUMPCheckpoint( INST *pinst, IFileSystemAPI *const pfsapi, CHAR *szCheckpoint )
	{
	Assert( pinst->m_plog );
	Assert( pinst->m_pver );

	ERR err = pinst->m_plog->ErrLGDumpCheckpoint( pinst->m_pfsapi, szCheckpoint );

	return err;
	}
	
ERR LOG::ErrLGDumpCheckpoint( IFileSystemAPI *const pfsapi, CHAR *szCheckpoint )
	{
	ERR			err;
	LGPOS		lgpos;
	LOGTIME		tm;
	CHECKPOINT	*pcheckpoint = NULL;
	DBMS_PARAM	dbms_param;
	IFMP		ifmp;

	pcheckpoint = (CHECKPOINT *) PvOSMemoryPageAlloc( sizeof( CHECKPOINT ), NULL );
	if ( pcheckpoint == NULL )
		return ErrERRCheck( JET_errOutOfMemory );
	
	err = ErrLGReadCheckpoint( pfsapi, szCheckpoint, pcheckpoint, fTrue );
	if ( err == JET_errSuccess )
		{
		lgpos = pcheckpoint->checkpoint.le_lgposLastFullBackupCheckpoint;
		DUMPPrintF( "      LastFullBackupCheckpoint: (0x%X,%X,%X)\n",
				lgpos.lGeneration, lgpos.isec, lgpos.ib );
		
		lgpos = pcheckpoint->checkpoint.le_lgposCheckpoint;
		DUMPPrintF( "      Checkpoint: (0x%X,%X,%X)\n",
				lgpos.lGeneration, lgpos.isec, lgpos.ib );

		lgpos = pcheckpoint->checkpoint.le_lgposFullBackup;
		DUMPPrintF( "      FullBackup: (0x%X,%X,%X)\n",
				lgpos.lGeneration, lgpos.isec, lgpos.ib );

		tm = pcheckpoint->checkpoint.logtimeFullBackup;
		DUMPPrintF( "      FullBackup time: %02d/%02d/%04d %02d:%02d:%02d\n",
					(short) tm.bMonth, (short) tm.bDay,	(short) tm.bYear + 1900,
					(short) tm.bHours, (short) tm.bMinutes, (short) tm.bSeconds);
		
		lgpos = pcheckpoint->checkpoint.le_lgposIncBackup;
		DUMPPrintF( "      IncBackup: (0x%X,%X,%X)\n",
				lgpos.lGeneration, lgpos.isec, lgpos.ib );

		tm = pcheckpoint->checkpoint.logtimeIncBackup;
		DUMPPrintF( "      IncBackup time: %02d/%02d/%04d %02d:%02d:%02d\n",
					(short) tm.bMonth, (short) tm.bDay,	(short) tm.bYear + 1900,
					(short) tm.bHours, (short) tm.bMinutes, (short) tm.bSeconds);

		DUMPPrintF( "      Signature: " );
		DUMPPrintSig( &pcheckpoint->checkpoint.signLog );

		dbms_param = pcheckpoint->checkpoint.dbms_param;
		DUMPPrintF( "      Env (CircLog,Session,Opentbl,VerPage,Cursors,LogBufs,LogFile,Buffers)\n");
		DUMPPrintF( "          (%s,%7lu,%7lu,%7lu,%7lu,%7lu,%7lu,%7lu)\n",
					( dbms_param.fDBMSPARAMFlags & fDBMSPARAMCircularLogging ? "     on" : "    off" ),
					ULONG( dbms_param.le_lSessionsMax ),	ULONG( dbms_param.le_lOpenTablesMax ),
					ULONG( dbms_param.le_lVerPagesMax ), 	ULONG( dbms_param.le_lCursorsMax ),
					ULONG( dbms_param.le_lLogBuffers ), 	ULONG( dbms_param.le_lcsecLGFile ),
					ULONG( dbms_param.le_ulCacheSizeMax ) );
		
//		rgfmp = new FMP[ifmpMax];
		
		Call( ErrLGLoadFMPFromAttachments( m_pinst, pfsapi, pcheckpoint->rgbAttach ) );
		for ( ifmp = FMP::IfmpMinInUse(); ifmp <= FMP::IfmpMacInUse(); ifmp++)
			{
			FMP *pfmp = &rgfmp[ifmp];
			if ( pfmp->FInUse() )
				{
				ATCHCHK *patchchk = pfmp->Patchchk();

				DUMPPrintF( "%7d %s %s %s %s\n",
							pfmp->Dbid(),
							pfmp->SzDatabaseName(),
							pfmp->FLogOn() ? "LogOn" : "LogOff",
							pfmp->FVersioningOff() ? "VerOff" : "VerOn",
							pfmp->FReadOnlyAttach() ? "R" : "RW"
							);
				DUMPIAttachInfo( patchchk );
				}
			}
		}

HandleError:
//	if ( NULL != rgfmp )
//		FMP::Term();
	OSMemoryPageFree( pcheckpoint );		
	
	return err;
	}


LOCAL ERR ErrFindNextGen( INST *pinst, CHAR *szLog, LONG *plgen, CHAR *szLogFile )
	{
	Assert( pinst );
	Assert( szLog );
	Assert( szLogFile );
	Assert( plgen );
	Assert( 0 <= *plgen );
	Assert( lGenerationMaxDuringRecovery + 2 > *plgen );
	Assert( pinst->m_plog );
	Assert( pinst->m_pver );

	ERR					err;
	CHAR				szFind[IFileSystemAPI::cchPathMax];
	CHAR				szFileName[IFileSystemAPI::cchPathMax];
	IFileFindAPI		*pffapi = NULL;
	LONG				lGenMax = lGenerationMaxDuringRecovery + 2;
	IFileSystemAPI		*pfsapi = pinst->m_pfsapi;

	/*	make search string "<search path>\edb*.log"
	/**/
	szLogFile[0] = 0;
	strcpy( szFind, szLog );
	strcat( szFind, "*" );
	strcat( szFind, szLogExt );

	CallR( pfsapi->ErrFileFind( szFind, &pffapi ) );
	forever
		{
		CHAR	szDirT[IFileSystemAPI::cchPathMax];
		CHAR	szFNameT[IFileSystemAPI::cchPathMax];
		CHAR	szExtT[IFileSystemAPI::cchPathMax];

		/*	get file name and extension
		/**/
		Call( pffapi->ErrNext() );
		Call( pffapi->ErrPath( szFileName ) );
		Call( pfsapi->ErrPathParse( szFileName, szDirT, szFNameT, szExtT ) );

		/* if length of a numbered log file name and has log file extension
		/**/
		if ( UtilCmpFileName( szExtT, szLogExt ) == 0 )
			{
			if ( strlen( szFNameT ) == 8 )
				{
				INT		ib = 3;
				INT		ibMax = 8;
				LONG	lGen = 0;

				for ( ; ib < ibMax; ib++ )
					{
					BYTE	b = szFNameT[ib];

					if ( b >= '0' && b <= '9' )
						lGen = lGen * 16 + b - '0';
					else if ( b >= 'A' && b <= 'F' )
						lGen = lGen * 16 + b - 'A' + 10;
					else if ( b >= 'a' && b <= 'f' )
						lGen = lGen * 16 + b - 'a' + 10;
					else
						break;
					}

				if ( ib == ibMax )
					{
					Assert( lGen < lGenerationMaxDuringRecovery + 1 );
					if ( lGen < lGenMax && lGen > *plgen )
						{
						lGenMax = lGen;
						strcpy( szLogFile, szFileName );
						}
					}
				}

			else if ( strlen( szFNameT ) == 3 )
				{
				//	found jet.log
				if ( lGenMax == lGenerationMaxDuringRecovery + 2 && lGenerationMaxDuringRecovery + 1 > *plgen )
					{
					lGenMax = lGenerationMaxDuringRecovery + 1;
					strcpy( szLogFile, szFileName );
					}
				}
			}
		}

HandleError:
	delete pffapi;

	if ( err == JET_errFileNotFound )
		{
		err = JET_errSuccess;
		}
	if ( err == JET_errSuccess )
		{
		*plgen = lGenMax;
		}
	return err;
	}

ERR ErrDUMPLog( INST *pinst, CHAR *szLog, JET_GRBIT grbit )
	{
	ERR				err				= JET_errSuccess;
	ERR				errDump			= JET_errSuccess;
	CHAR			szLogFileDir[IFileSystemAPI::cchPathMax];
	CHAR			szLogFileName[IFileSystemAPI::cchPathMax];
	CHAR			szLogFileExt[IFileSystemAPI::cchPathMax];
	LGFILEHDR *		plgfilehdr		= NULL;
	LOG::LOGDUMP_OP	logdumpOp;

	logdumpOp.m_opts = 0;

	Call( pinst->m_pfsapi->ErrPathParse( szLog, szLogFileDir, szLogFileName, szLogFileExt ) );
	if ( 3 == strlen( szLogFileName ) + strlen( szLogFileExt ) )
		{
		LONG	lgen = 0;
		LONG 	lgenLast = 0;

		if ( 0 != szLogFileExt[0] )
			{
			strcat( szLogFileName, szLogFileExt );
			}

		logdumpOp.m_loghdr = LOG::LOGDUMP_LOGHDR_INVALID;
		if ( grbit & JET_bitDBUtilOptionDumpVerbose )
			{
			logdumpOp.m_fVerbose = 1;
			logdumpOp.m_fPrint = 1;
			}

		DUMPPrintF( "Verifying log files...\n" );
		DUMPPrintF( "     %sBase name: %s\n", logdumpOp.m_fVerbose ? " " : "", pinst->m_plog->m_szBaseName );

		plgfilehdr = (LGFILEHDR *) PvOSMemoryPageAlloc( sizeof( LGFILEHDR ), NULL );
		if ( plgfilehdr == NULL )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		Call( ErrFindNextGen( pinst, szLog, &lgen, szLogFileName ) );

		if ( !logdumpOp.m_fVerbose && 0 != szLogFileName[0] )
			DUMPPrintF( "\n" );

		while ( 0 != szLogFileName[0] )
			{
			lgenLast = lgen;
			if ( logdumpOp.m_fVerbose )
				{
				DUMPPrintF( "\n      Log file: %s", szLogFileName );
				}
			else
				{
				DUMPPrintF( "      Log file: %s", szLogFileName );
				}
			pinst->m_plog->m_fDumppingLogs = fTrue;
			err = pinst->m_plog->ErrLGDumpLog( pinst->m_pfsapi, szLogFileName, &logdumpOp, plgfilehdr );
			if ( err < JET_errSuccess )
				{
				errDump = ( errDump >= JET_errSuccess ? err : errDump );
				}
			else if ( LOG::LOGDUMP_LOGHDR_VALIDADJACENT == logdumpOp.m_loghdr
				&& lgen != plgfilehdr->lgfilehdr.le_lGeneration
				&& lgen < lGenerationMaxDuringRecovery + 1 )
				{
				DUMPPrintF( "\n      %sERROR: Mismatched log generation %lu (0x%lX) with log file name. Expected generation %lu (0x%lX).\n",
						( logdumpOp.m_fVerbose ? "" : "          " ),
						(ULONG)plgfilehdr->lgfilehdr.le_lGeneration, (LONG)plgfilehdr->lgfilehdr.le_lGeneration, 
						lgen, lgen );
				logdumpOp.m_loghdr = LOG::LOGDUMP_LOGHDR_VALID;
				errDump = ( errDump >= JET_errSuccess ? ErrERRCheck( JET_errLogGenerationMismatch ) : errDump );
				}
			else if ( !logdumpOp.m_fVerbose )
				{
				//	just verifying, so report that logfile is OK
				DUMPPrintF( " - OK\n" );
				}

			Call( ErrFindNextGen( pinst, szLog, &lgen, szLogFileName ) );

			//	if it is not jet.log file
			if ( lgen < lGenerationMaxDuringRecovery + 1 )
				{
				if ( lgen != lgenLast+1 )
					{
					Assert( lgenLast < lgen );
					if ( LOG::LOGDUMP_LOGHDR_VALIDADJACENT == logdumpOp.m_loghdr )
						{
						logdumpOp.m_loghdr = LOG::LOGDUMP_LOGHDR_VALID;
						}
					if ( logdumpOp.m_fVerbose )
						DUMPPrintF( "\n\n" );
					if ( lgen == lgenLast + 2 )
						{
						DUMPPrintF( "      Missing log file: %s%05lx%s\n", szLog, lgenLast+1, szLogExt );
						}
					else
						{
						DUMPPrintF( "      Missing log files: %s{%05lx - %05lx}%s\n", szLog, lgenLast+1, lgen-1, szLogExt );
						}
					errDump = ( errDump >= JET_errSuccess ? ErrERRCheck( JET_errMissingLogFile ) : errDump );
					}
				}

			if ( logdumpOp.m_fVerbose )
				DUMPPrintF( "\n" );
			}

		if ( errDump >= JET_errSuccess )
			{
			DUMPPrintF( "\nNo damaged log files were found.\n" );
			}
		else
			{
			DUMPPrintF( "\n" );
			}
		}
	else
		{
		logdumpOp.m_loghdr = LOG::LOGDUMP_LOGHDR_NOHDR;
		logdumpOp.m_fPrint = 1;

#ifdef DEBUG
		logdumpOp.m_fVerbose = 1;
#else
		if ( grbit & JET_bitDBUtilOptionDumpVerbose )
			{
			logdumpOp.m_fVerbose = 1;
			}
#endif			
		
		DUMPPrintF( "     Base name: %s\n", pinst->m_plog->m_szBaseName );
		DUMPPrintF( "      Log file: %s", szLog );
		pinst->m_plog->m_fDumppingLogs = fTrue;
		errDump = pinst->m_plog->ErrLGDumpLog( pinst->m_pfsapi, szLog, &logdumpOp );
		DUMPPrintF( "\n" );
		}
HandleError:
	if ( NULL != plgfilehdr )
		{
		OSMemoryPageFree( plgfilehdr );
		}
	if ( err >= JET_errSuccess && errDump < JET_errSuccess )
		{
		err = errDump;
		}
	return err;
	}

ERR LOG::ErrLGDumpLog( IFileSystemAPI *const pfsapi, CHAR *szLog, LOGDUMP_OP * const plogdumpOp, LGFILEHDR * const plgfilehdr )
	{
	Assert( NULL != plogdumpOp );
	Assert( !( ( LOGDUMP_LOGHDR_NOHDR == plogdumpOp->m_loghdr ) ^ (NULL == plgfilehdr ) ) );

	ERR					err;
	CHECKPOINT			*pcheckpoint	= NULL;
	DBMS_PARAM			dbms_param;
	IFMP				ifmp;
	LGPOS				lgposCheckpoint;
	CHAR 	  			szPathJetChkLog[IFileSystemAPI::cchPathMax];
	BOOL				fCloseNormally;
	BOOL				fCorrupt		= fFalse;
	ERR					errCorrupt		= JET_errSuccess;
	BOOL				fIsPatchable	= fFalse;
	LE_LGPOS			le_lgposFirstT;
	BYTE				*pbNextLR;
	const BOOL			fPrint			= plogdumpOp->m_fPrint;
	const INT			loghdr			= plogdumpOp->m_loghdr;

	if ( LOGDUMP_LOGHDR_VALIDADJACENT == loghdr )
		{
		//	if we fail reading next header will keep the current one
		plogdumpOp->m_loghdr = LOGDUMP_LOGHDR_VALID;
		}

	m_csecLGBuf = csecLGBufSize;	// XXX - what for? For call to InitLogBuf?
	
	//	initialize the sector sizes

	if ( pfsapi->ErrPathComplete( szLog, szPathJetChkLog ) == JET_errInvalidPath )
		{
		DUMPPrintF( "\n                ERROR: File not found.\n" );
		return ErrERRCheck( JET_errFileNotFound );
		}

	err = pfsapi->ErrFileAtomicWriteSize( szPathJetChkLog, (DWORD*)&m_cbSecVolume );
	if ( err < 0 )
		{
		DUMPPrintF( "\n                ERROR: File error %d.\n", err );
		return err;
		}

	//	NOTE: m_cbSec, m_csecHeader, and m_csecLGFile will be setup
	//		  when we call LOG::ErrLGReadFileHdr()

	m_fLGIgnoreVersion = fTrue;
	m_fRecovering = fTrue;		/* behave like doing recovery */
	m_plgfilehdr = NULL;

	/* open the log file, and read dump its log record. */
	Assert( !m_pfapiLog );
	err = pfsapi->ErrFileOpen( szLog, &m_pfapiLog, fTrue );
	if ( err < 0 )
		{
		DUMPPrintF( "\n                ERROR: Cannot open log file. Error %d.\n", err );
		goto HandleError;
		}

	/* dump file header */
	m_plgfilehdr = (LGFILEHDR *) PvOSMemoryPageAlloc( sizeof( LGFILEHDR ), NULL );
	if ( m_plgfilehdr == NULL )
		{
		DUMPPrintF( "\n                ERROR: Out of memory trying to validate log file.\n" );
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	err = ErrLGReadFileHdr( m_pfapiLog, m_plgfilehdr, fNoCheckLogID, fTrue );
	if ( err < 0 )
		{
		DUMPPrintF( "\n                ERROR: Cannot read log file header. Error %d.\n", err );
		goto HandleError;
		}
		
	if ( LOGDUMP_LOGHDR_VALIDADJACENT == loghdr && m_plgfilehdr->lgfilehdr.le_lGeneration != plgfilehdr->lgfilehdr.le_lGeneration + 1 )
		{
		//	edb.log is not the correct generation number (all other missing log file cases are caught in ErrDUMPLog())
		DUMPPrintF( "\n                ERROR: Missing log file(s). Log file is generation %lu (0x%lX), but expected generation is %u (0x%lX).\n",
			(ULONG)m_plgfilehdr->lgfilehdr.le_lGeneration, (LONG)m_plgfilehdr->lgfilehdr.le_lGeneration,
			(ULONG)(plgfilehdr->lgfilehdr.le_lGeneration + 1), (LONG)(plgfilehdr->lgfilehdr.le_lGeneration + 1) );
		Call( ErrERRCheck( JET_errMissingLogFile ) );
		}


	/*	dump checkpoint file
	/**/
	if ( fPrint )
		{
		DUMPPrintF( "\n      lGeneration: %u (0x%X)\n", (ULONG)m_plgfilehdr->lgfilehdr.le_lGeneration, (LONG)m_plgfilehdr->lgfilehdr.le_lGeneration );

		pcheckpoint = (CHECKPOINT *)PvOSMemoryPageAlloc( sizeof( CHECKPOINT ), NULL );
		if ( NULL != pcheckpoint )
			{
			CHAR szJetLogFileName[IFileSystemAPI::cchPathMax];
			CHAR szJetLogFileExt[IFileSystemAPI::cchPathMax];

			CallS( pfsapi->ErrPathParse( szLog, szPathJetChkLog, szJetLogFileName, szJetLogFileExt ) );
			szJetLogFileName[3] = 0;
			CallS( pfsapi->ErrPathBuild( m_pinst->m_szSystemPath, szJetLogFileName, szChkExt, szPathJetChkLog ) );
			err = ErrLGReadCheckpoint( pfsapi, szPathJetChkLog, pcheckpoint, fTrue );
			dbms_param = m_plgfilehdr->lgfilehdr.dbms_param;
		
			if ( JET_errSuccess == err )
				{
				lgposCheckpoint = pcheckpoint->checkpoint.le_lgposCheckpoint;
				DUMPPrintF( "      Checkpoint: (0x%X,%X,%X)\n",
							lgposCheckpoint.lGeneration,
							lgposCheckpoint.isec,
							lgposCheckpoint.ib );
				}
			else
				{
				DUMPPrintF( "      Checkpoint: NOT AVAILABLE\n" );
				err = JET_errSuccess;
				}
			}
		else
			{
			DUMPPrintF( "      Checkpoint: NOT AVAILABLE\n" );
			}

		DUMPPrintF( "      creation time: %02d/%02d/%04d %02d:%02d:%02d\n",
			(short) m_plgfilehdr->lgfilehdr.tmCreate.bMonth,
			(short) m_plgfilehdr->lgfilehdr.tmCreate.bDay,
			(short) m_plgfilehdr->lgfilehdr.tmCreate.bYear + 1900,
			(short) m_plgfilehdr->lgfilehdr.tmCreate.bHours,
			(short) m_plgfilehdr->lgfilehdr.tmCreate.bMinutes,
			(short) m_plgfilehdr->lgfilehdr.tmCreate.bSeconds);
		}

	if ( LOGDUMP_LOGHDR_VALIDADJACENT == loghdr
		&& 0 != memcmp( &m_plgfilehdr->lgfilehdr.tmPrevGen, &plgfilehdr->lgfilehdr.tmCreate, sizeof( LOGTIME ) ) )
		{
		DUMPPrintF( "%sERROR: Invalid log sequence. Previous generation time is [%02d/%02d/%04d %02d:%02d:%02d], but expected [%02d/%02d/%04d %02d:%02d:%02d].\n",
			( fPrint ? "      " : "\n                " ),
			(short) m_plgfilehdr->lgfilehdr.tmPrevGen.bMonth,
			(short) m_plgfilehdr->lgfilehdr.tmPrevGen.bDay,
			(short) m_plgfilehdr->lgfilehdr.tmPrevGen.bYear + 1900,
			(short) m_plgfilehdr->lgfilehdr.tmPrevGen.bHours,
			(short) m_plgfilehdr->lgfilehdr.tmPrevGen.bMinutes,
			(short) m_plgfilehdr->lgfilehdr.tmPrevGen.bSeconds,
			(short) plgfilehdr->lgfilehdr.tmCreate.bMonth,
			(short) plgfilehdr->lgfilehdr.tmCreate.bDay,
			(short) plgfilehdr->lgfilehdr.tmCreate.bYear + 1900,
			(short) plgfilehdr->lgfilehdr.tmCreate.bHours,
			(short) plgfilehdr->lgfilehdr.tmCreate.bMinutes,
			(short) plgfilehdr->lgfilehdr.tmCreate.bSeconds);

		Call( ErrERRCheck( JET_errInvalidLogSequence ) );
		}

	if ( fPrint )
		{
		DUMPPrintF( "      prev gen time: %02d/%02d/%04d %02d:%02d:%02d\n",
			(short) m_plgfilehdr->lgfilehdr.tmPrevGen.bMonth,
			(short) m_plgfilehdr->lgfilehdr.tmPrevGen.bDay,
			(short) m_plgfilehdr->lgfilehdr.tmPrevGen.bYear + 1900,
			(short) m_plgfilehdr->lgfilehdr.tmPrevGen.bHours,
			(short) m_plgfilehdr->lgfilehdr.tmPrevGen.bMinutes,
			(short) m_plgfilehdr->lgfilehdr.tmPrevGen.bSeconds);
		}

	if ( LOGDUMP_LOGHDR_VALIDADJACENT == loghdr
		&& ( m_plgfilehdr->lgfilehdr.le_ulMajor != plgfilehdr->lgfilehdr.le_ulMajor 
			|| m_plgfilehdr->lgfilehdr.le_ulMinor != plgfilehdr->lgfilehdr.le_ulMinor 
			|| m_plgfilehdr->lgfilehdr.le_ulUpdate > plgfilehdr->lgfilehdr.le_ulUpdate ) )
		{
		DUMPPrintF( "%sERROR: Invalid log version. Format LGVersion: (%d.%d.%d). Expected: (%d.%d.%d).\n",
			( fPrint ? "      " : "\n                " ),
			(short) m_plgfilehdr->lgfilehdr.le_ulMajor,
			(short) m_plgfilehdr->lgfilehdr.le_ulMinor,
			(short) m_plgfilehdr->lgfilehdr.le_ulUpdate,
			(short) plgfilehdr->lgfilehdr.le_ulMajor,
			(short) plgfilehdr->lgfilehdr.le_ulMinor,
			(short) plgfilehdr->lgfilehdr.le_ulUpdate );

		Call( ErrERRCheck( JET_errBadLogVersion ) );
		}

	if ( fPrint )
		{
		DUMPPrintF( "      Format LGVersion: (%d.%d.%d)\n",
			(short) m_plgfilehdr->lgfilehdr.le_ulMajor,
			(short) m_plgfilehdr->lgfilehdr.le_ulMinor,
			(short) m_plgfilehdr->lgfilehdr.le_ulUpdate );
		DUMPPrintF( "      Engine LGVersion: (%d.%d.%d)\n",
			(short) ulLGVersionMajor,
			(short) ulLGVersionMinor,
			(short) ulLGVersionUpdate );
		}

	if ( LOGDUMP_LOGHDR_VALIDADJACENT == loghdr
		&& 0 != memcmp( &m_plgfilehdr->lgfilehdr.signLog, &plgfilehdr->lgfilehdr.signLog, sizeof( SIGNATURE ) ) )
		{
		DUMPPrintF( "%sERROR: Invalid log signature: ", ( fPrint ? "      " : "\n                " ) );
		DUMPPrintSig( &m_plgfilehdr->lgfilehdr.signLog );
		DUMPPrintF( "             %s   Expected signature: ", ( fPrint ? "" : "          " ) );
		DUMPPrintSig( &plgfilehdr->lgfilehdr.signLog );

		Call( ErrERRCheck( JET_errBadLogSignature ) );
		}

	if ( fPrint )
		{
		DUMPPrintF( "      Signature: " );
		DUMPPrintSig( &m_plgfilehdr->lgfilehdr.signLog );
		DUMPPrintF( "      Env SystemPath: %s\n",
			m_plgfilehdr->lgfilehdr.dbms_param.szSystemPath);
		DUMPPrintF( "      Env LogFilePath: %s\n",
			m_plgfilehdr->lgfilehdr.dbms_param.szLogFilePath);
		DUMPPrintF( "      Env Log Sec size: %d\n",	(short) m_plgfilehdr->lgfilehdr.le_cbSec);
		DUMPPrintF( "      Env (CircLog,Session,Opentbl,VerPage,Cursors,LogBufs,LogFile,Buffers)\n");
		DUMPPrintF( "          (%s,%7lu,%7lu,%7lu,%7lu,%7lu,%7lu,%7lu)\n",
					( dbms_param.fDBMSPARAMFlags & fDBMSPARAMCircularLogging ? "     on" : "    off" ),
					ULONG( dbms_param.le_lSessionsMax ), 	ULONG( dbms_param.le_lOpenTablesMax ),
					ULONG( dbms_param.le_lVerPagesMax ), 	ULONG( dbms_param.le_lCursorsMax ),
					ULONG( dbms_param.le_lLogBuffers ), 	ULONG( dbms_param.le_lcsecLGFile ),
					ULONG( dbms_param.le_ulCacheSizeMax ) );
		DUMPPrintF( "      Using Reserved Log File: %s\n", 
					( m_plgfilehdr->lgfilehdr.fLGFlags & fLGReservedLog ) ? "true" : "false" );		
		DUMPPrintF( "      Circular Logging Flag (current file): %s\n", 
					( m_plgfilehdr->lgfilehdr.fLGFlags & fLGCircularLoggingCurrent ) ? "on":"off" ); 
		DUMPPrintF( "      Circular Logging Flag (past files): %s\n",
					( m_plgfilehdr->lgfilehdr.fLGFlags & fLGCircularLoggingHistory ) ? "on": "off" );
		err = ErrLGLoadFMPFromAttachments( m_pinst, pfsapi, m_plgfilehdr->rgbAttach );
		if ( err < 0 )
			{
			DUMPPrintF( "      ERROR: Cannot read database attachment list. Error %d.\n", err );
			goto HandleError;
			}
			
		for ( ifmp = FMP::IfmpMinInUse(); ifmp <= FMP::IfmpMacInUse(); ifmp++)
			{
			FMP *pfmp = &rgfmp[ifmp];
			if ( pfmp->FInUse() && fPrint )
				{
				ATCHCHK *patchchk = pfmp->Patchchk();

				DUMPPrintF( "      %d %s\n", pfmp->Dbid(), pfmp->SzDatabaseName() );
				DUMPIAttachInfo( patchchk );
				}
			}

		DUMPPrintF( "\n" );
		}

	if ( LOGDUMP_LOGHDR_NOHDR != plogdumpOp->m_loghdr )
		{
		//	we can set new current header for sure
		Assert( NULL != plgfilehdr );
		plogdumpOp->m_loghdr = LOGDUMP_LOGHDR_VALIDADJACENT;
		}


	/*	set buffer
	/**/
	m_cbSec = m_plgfilehdr->lgfilehdr.le_cbSec;
	err = ErrLGInitLogBuffers( m_csecLGBuf );
	if ( err < 0 )
		{
		DUMPPrintF( "%sERROR: Log file header is OK but integrity could not be verified due to an out-of-memory condition.\n",
					( fPrint ? "      " : "\n                " ) );
		goto HandleError;
		}

	m_fNewLogRecordAdded = fFalse;
	strcpy( m_szLogName, szLog );

	err = ErrLGCheckReadLastLogRecordFF( pfsapi, &fCloseNormally, fTrue, &fIsPatchable );
	if ( FErrIsLogCorruption( err ) )
		{
		Assert( !fIsPatchable );
		DUMPPrintF( "%sERROR: Log damaged (unusable). Last Lgpos: (0x%x,%X,%X). Error %d.\n",
					( fPrint ? "      " : "\n                " ),
					m_lgposLastRec.lGeneration,
					m_lgposLastRec.isec,
					m_lgposLastRec.ib,
					err );

		fCorrupt = fTrue;
		errCorrupt = err;
#ifdef DEBUG
		//	in case we're in verbose mode,
		//	keep going to try to print out
		//	as many log records as possible
		err = JET_errSuccess;
#else
		goto HandleError;
#endif
		}
	else if ( JET_errSuccess != err )
		{
		DUMPPrintF( "%sERROR: Log file header is OK but integrity could not be verified. Error %d.\n",
				( fPrint ? "      " : "\n                " ),
				err );

		Assert( 0 < err );
		goto HandleError;
		}
	else if ( fPrint )
		{
		DUMPPrintF( "      Last Lgpos: (0x%x,%X,%X)\n",
				m_lgposLastRec.lGeneration,
				m_lgposLastRec.isec,
				m_lgposLastRec.ib );
		}

	//	verbose dump
	if ( plogdumpOp->m_fVerbose )
		{
		// initialize other variables
		memset( rgclrtyp, 0, sizeof( rgclrtyp ) );
		memset( rgcb, 0, sizeof( rgcb ) );

#ifdef DEBUG
		fDBGPrintToStdOut = fTrue;
		m_fDBGTraceLog = fTrue;
		m_fDBGTraceRedo = fTrue;
		DUMPPrintF( "\n" );
#endif	//	DEBUG

		le_lgposFirstT.le_lGeneration = m_plgfilehdr->lgfilehdr.le_lGeneration;
		le_lgposFirstT.le_isec = (WORD) m_csecHeader;
		le_lgposFirstT.le_ib = 0;

		Assert( m_plread == pNil );
		m_plread = new LogReader();
		if ( pNil == m_plread )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		Call( m_plread->ErrLReaderInit( this, m_plgfilehdr->lgfilehdr.le_csecLGFile ) );
		Call( m_plread->ErrEnsureLogFile() );
		err = ErrLGLocateFirstRedoLogRecFF( &le_lgposFirstT, &pbNextLR );
		if ( err == errLGNoMoreRecords )
			{
			fCorrupt = fTrue;
			errCorrupt = ErrERRCheck( JET_errLogFileCorrupt );
			}

		while ( JET_errSuccess == err )
			{
			rgclrtyp[ *pbNextLR ]++;
			rgcb[ *pbNextLR ] += CbLGSizeOfRec( (LR*) pbNextLR );

			LR *plr = (LR *)pbNextLR;
#ifdef DEBUG
			if ( GetNOP() > 0 )
				{
				CheckEndOfNOPList( plr, this );
				}

			if ( 0 == GetNOP() || plr->lrtyp != lrtypNOP )
				{
				PrintLgposReadLR();
				ShowLR( plr, this );
				}
#endif // DEBUG

			err = ErrLGGetNextRecFF( &pbNextLR );
			}

		if ( err == errLGNoMoreRecords )
			{
			err = JET_errSuccess;
			}
		Call( err );
		CallS( err );

		if ( fCorrupt )
			{
			Assert( !fIsPatchable );
			Assert( errCorrupt < JET_errSuccess );
#ifdef DEBUG
			DUMPPrintF( ">%06.6X,%04.4X,%04.4X Log Damaged (unusable) -- cannot continue\n", 
						m_lgposLastRec.lGeneration, m_lgposLastRec.isec, m_lgposLastRec.ib );
#else // !DEBUG
			DUMPPrintF( "      Last Lgpos: (0x%x,%X,%X)\n",
					m_lgposLastRec.lGeneration,
					m_lgposLastRec.isec,
					m_lgposLastRec.ib );
			DUMPPrintF( "\nLog Damaged (unusable): %s\n\n", szLog );
#endif // DEBUG
			}
#ifdef DEBUG
		else if ( fIsPatchable )
			{
			DUMPPrintF( ">%06.6X,%04.4X,%04.4X Log Damaged (PATCHABLE) -- soft recovery will fix this\n",
						m_lgposLastRec.lGeneration, m_lgposLastRec.isec, m_lgposLastRec.ib );
			}
		else if ( GetNOP() > 0 )
			{
			CheckEndOfNOPList( NULL, this );
			}
#endif // DEBUG

		DUMPPrintF( "\n" );
		DUMPPrintF( "==================================\n" );
		DUMPPrintF( "Op         # Records     Avg. Size\n" );
		DUMPPrintF( "----------------------------------\n" );
#ifdef DEBUG
		int i;
		for ( i = 0; i < lrtypMax; i++ )
			{
			//	Temporary hack
			//	Do not print replaced lrtyps
			if ( lrtypInit == i || lrtypTerm == i || lrtypRecoveryUndo == i || lrtypRecoveryQuit == i )
				{
				continue;
				}
			const ULONG	cbAvgSize	= ( rgclrtyp[i] > 0 ? rgcb[i]/rgclrtyp[i] : 0 );
			DUMPPrintF( "%s  %7lu       %7lu\n", SzLrtyp( (LRTYP) i ), rgclrtyp[i], cbAvgSize );
			}
#else // DEBUG
			{
			const int cCollectable = 8;
			static const LRTYP rgcLrtypCollect[cCollectable][lrtypMax] = 
				{ 
					{ lrtypNOP, lrtypInit, lrtypTerm, lrtypMS, lrtypEnd, lrtypInit2, lrtypTerm2,
						lrtypRecoveryUndo, lrtypRecoveryQuit, lrtypFullBackup, lrtypIncBackup, 
						lrtypJetOp, lrtypTrace, lrtypRecoveryUndo2, lrtypRecoveryQuit2,
						lrtypBackup, 47, // hardcoded unknown
						lrtypChecksum, lrtypExtRestore,
						lrtypMax
						},
					{ lrtypBegin, lrtypBegin0, lrtypMax },
					{ lrtypCommit, lrtypCommit0, lrtypMax },
					{ lrtypMacroBegin, lrtypMacroCommit, lrtypMacroAbort, lrtypMax },
					{ lrtypInsert, lrtypFlagInsert, lrtypFlagInsertAndReplaceData, lrtypMax },
					{ lrtypCreateSingleExtentFDP, lrtypCreateMultipleExtentFDP, lrtypMax },
					{ lrtypDelete, lrtypFlagDelete, lrtypMax },
					{ lrtypReplace, lrtypReplaceD, lrtypMax }
				};
			
			const char *rgszLrtypCollect[cCollectable] = 
				{ 
				"Others   ",
				SzLrtyp( lrtypBegin ),
				SzLrtyp( lrtypCommit ),
				"MacroOp  ",
				SzLrtyp( lrtypInsert ),
				"CreateFDP",
				SzLrtyp( lrtypDelete ),
				SzLrtyp( lrtypReplace )
				};
				
			for ( int i = 0; i < lrtypMax; i++ )
				{
				for ( int j = 0; j < cCollectable; j++ )
					{
					int k;
					for ( k = 0; lrtypMax > k && lrtypMax != rgcLrtypCollect[j][k] && i != rgcLrtypCollect[j][k]; k++ )
						{
						//	Nothing
						}
					if ( lrtypMax != rgcLrtypCollect[j][k] && lrtypMax > k)
						{
						if ( 0 == k )
							{
							for ( k = 1; lrtypMax != rgcLrtypCollect[j][k]; k++ )
								{
								rgclrtyp[i] += rgclrtyp[rgcLrtypCollect[j][k]];
								rgcb[i] += rgcb[rgcLrtypCollect[j][k]];
								}
							const ULONG	cbAvgSize	= ( rgclrtyp[i] > 0 ? rgcb[i]/rgclrtyp[i] : 0 );
							DUMPPrintF( "%s  %7lu       %7lu\n", rgszLrtypCollect[j], rgclrtyp[i], cbAvgSize );
							}
						break;
						}
					}
				if ( j < cCollectable )
					{
					continue;
					}
				const ULONG	cbAvgSize	= ( rgclrtyp[i] > 0 ? rgcb[i]/rgclrtyp[i] : 0 );
				DUMPPrintF( "%s  %7lu       %7lu\n", SzLrtyp( (LRTYP) i ), rgclrtyp[i], cbAvgSize );
				}
			}
#endif // DEBUG

		DUMPPrintF( "==================================\n" );
		}


#ifdef DEBUG
#else // !DEBUG
	if ( fPrint && !fCorrupt )
		{
		DUMPPrintF( "\nIntegrity check passed for log file: %s\n", szLog );
		}
#endif // DEBUG


HandleError:
	m_fNewLogRecordAdded = fTrue;
	
	if ( pNil != m_plread )
		{
		if ( err == JET_errSuccess )
			{
			err = m_plread->ErrLReaderTerm();
			}
		else
			{
			m_plread->ErrLReaderTerm();
			}
		delete m_plread;
		m_plread = pNil;
		}

	OSMemoryPageFree( pcheckpoint );

	if ( NULL != m_plgfilehdr && LOGDUMP_LOGHDR_VALIDADJACENT == plogdumpOp->m_loghdr )
		{
		Assert( NULL != plgfilehdr );
		memcpy( plgfilehdr, m_plgfilehdr, sizeof( LGFILEHDR ) );
		}

	OSMemoryPageFree( m_plgfilehdr );
	m_plgfilehdr = NULL;

//	if ( rgfmp != NULL )
//		FMP::Term();

	delete m_pfapiLog;
	m_pfapiLog = NULL;

	LGTermLogBuffers();

	if ( err >= JET_errSuccess && errCorrupt < JET_errSuccess )
		{
		Assert( fCorrupt );
		err = errCorrupt;
		}
	return err;
	}


#ifdef DEBUG

//  ================================================================
struct DUMPNODE
//  ================================================================
	{
	DUMPNODE(
		const LGPOS& lgpos,
		LRTYP lrtyp,
		const NODELOC& nodeloc,
		const CHAR * szOper
		) :
			pdumpnodeNext( NULL ),
			pdumpnodePrev( NULL ),
			lgpos( lgpos ),
			lrtyp( lrtyp ),
			nodeloc( nodeloc ),
			nodelocCur( nodelocCur ),
			sz( new CHAR[strlen(szOper)+1] )
		{ 
		Assert( lrtyp < lrtypMax );
		strcpy( sz, szOper );
		}
	virtual ~DUMPNODE() { delete[] sz; }		
	
	DUMPNODE * pdumpnodeNext;
	DUMPNODE * pdumpnodePrev;
	NODELOC	   nodelocCur;

	CHAR 		* const sz;
	const LGPOS			lgpos;
	const LRTYP			lrtyp;
	const NODELOC		nodeloc;
	};


//  ================================================================
struct DUMPNODESPLIT : public DUMPNODE
//  ================================================================
	{
	DUMPNODESPLIT(
		const LGPOS& lgpos,
		LRTYP lrtyp,
		const NODELOC& nodeloc,
		const CHAR * szOper,
		PGNO  pgno,
		INT	  iline,
		BYTE  oper
		) :
			DUMPNODE( lgpos, lrtyp, nodeloc, szOper ),
			pgnoOld( pgno ),
			ilineOper( iline ),
			splitoper( oper )
		{
		}
	
	const PGNO	pgnoOld;
	const INT	ilineOper;
	const BYTE	splitoper;
	};


//  ================================================================
class DUMPLOGNODE
//  ================================================================
	{
	public:
		DUMPLOGNODE( const NODELOC& nodeloc, const LGPOS& lgpos, LOG *plog );
		~DUMPLOGNODE();

		VOID ProcessLR( const LR* plr, LGPOS *plgpos );
		VOID DumpNodes();

	private:
		VOID ProcessLRAfterLgpos_( const LR* plr, const LGPOS& lgpos );
		VOID ProcessLRBeforeLgpos_( const LR* plr, const LGPOS& lgpos );
		VOID UpdateNodelocBackward_( DUMPNODE * pdumpnode );
		
	private:
		const NODELOC 	m_nodelocOrig_;
		const LGPOS		m_lgposOrig_;
		LGPOS			m_lgposStart_;
		LGPOS			m_lgposEnd_;
		
		NODELOC			m_nodelocCur_;
		NODELOC			m_nodelocStart_;
		NODELOC			m_nodelocEnd_;

		DUMPNODE		*m_pdumpnodeHead_;
		DUMPNODE		*m_pdumpnodeTail_;

		BOOL			m_fInMacro;
		BOOL			m_fDumpSplit;
		
		LOG 			*m_plog;
	};


//  ================================================================
DUMPLOGNODE::DUMPLOGNODE( const NODELOC& nodeloc, const LGPOS& lgpos, LOG *plog ) :
//  ================================================================
	m_nodelocOrig_( nodeloc ),
	m_lgposOrig_( lgpos ),
	m_nodelocCur_( nodeloc ),
	m_lgposStart_( lgpos ),
	m_nodelocStart_( nodeloc ),
	m_lgposEnd_( lgpos ),
	m_nodelocEnd_( nodeloc ),
	m_pdumpnodeHead_( NULL ),
	m_pdumpnodeTail_( NULL ),
	m_fInMacro( fFalse ),
	m_fDumpSplit( fFalse ),
	m_plog( plog )
	{
	}


//  ================================================================
DUMPLOGNODE::~DUMPLOGNODE()
//  ================================================================
	{
	DUMPNODE * pdumpnode = m_pdumpnodeHead_;
	DUMPNODE * pdumpnodeDelete;
	while( pdumpnode )
		{
		pdumpnodeDelete = pdumpnode;
		pdumpnode = pdumpnode->pdumpnodeNext;
		delete pdumpnodeDelete;
		}
	}



//  ================================================================
VOID DUMPLOGNODE::ProcessLRBeforeLgpos_( const LR* plr, const LGPOS& lgpos )
//  ================================================================
	{
	DUMPNODE * pdumpnode = NULL;
	CHAR rgchBuf[1024];
	
	switch ( plr->lrtyp )
		{
		case lrtypNOP:
		case lrtypMS:
		case lrtypJetOp:
		case lrtypBegin:
		case lrtypBegin0:
		case lrtypBeginDT:
		case lrtypRefresh:
		case lrtypCommit:
		case lrtypCommit0:
		case lrtypPrepCommit:
		case lrtypPrepRollback:
		case lrtypRollback:
		case lrtypCreateDB:
		case lrtypAttachDB:
		case lrtypDetachDB:
		case lrtypCreateMultipleExtentFDP:
		case lrtypCreateSingleExtentFDP:
		case lrtypConvertFDP:
		case lrtypSetExternalHeader:
		case lrtypInit:
		case lrtypTerm:
		case lrtypShutDownMark:
		case lrtypRecoveryQuit:
		case lrtypRecoveryUndo:
		case lrtypFullBackup:
		case lrtypIncBackup:
		case lrtypBackup:
		case lrtypTrace:
		case lrtypExtRestore:
		case lrtypForceDetachDB:
		case lrtypEmptyTree:
		case lrtypForceFlushLog:
			break;

		case lrtypMacroBegin:
		case lrtypMacroCommit:
			{
			const NODELOC 			nodeloc( 0, 0, 0 );

			LrToSz( plr, rgchBuf, m_plog );
			pdumpnode = new DUMPNODE( lgpos, plr->lrtyp, nodeloc, rgchBuf );
			}
			break;

		case lrtypMacroAbort:
			AssertSz( fFalse, "lrtypMacroAbort not handled" );
			break;
			
		case lrtypUndoInfo:
			{
			const LRPAGE_ * const	plrpage = reinterpret_cast<const LRPAGE_ *>( plr );
			const NODELOC 			nodeloc( plrpage->dbid, plrpage->le_pgno, 0 );

			LrToSz( plr, rgchBuf, m_plog );
			pdumpnode = new DUMPNODE( lgpos, plrpage->lrtyp, nodeloc, rgchBuf );
			}
			break;

		case lrtypDelta:
		case lrtypFlagDelete:
		case lrtypFlagInsert:
		case lrtypFlagInsertAndReplaceData:
		case lrtypReplace:
		case lrtypReplaceD:
		case lrtypUndo:
		case lrtypInsert:
		case lrtypDelete:		
			{
			const LRNODE_ * const	plrnode = reinterpret_cast<const LRNODE_ *>( plr );
			const NODELOC 			nodeloc( plrnode->dbid, plrnode->le_pgno, plrnode->ILine() );

			LrToSz( plr, rgchBuf, m_plog );
			pdumpnode = new DUMPNODE( lgpos, plrnode->lrtyp, nodeloc, rgchBuf );
			}
			break;

		case lrtypSplit:
			{
			const LRSPLIT * const plrsplit = reinterpret_cast<const LRSPLIT *>( plr );

			switch( plrsplit->splittype )
				{
				case splittypeRight:
				case splittypeVertical:
				case splittypeAppend:
					{
					const NODELOC 	nodelocNew( plrsplit->dbid, plrsplit->le_pgnoNew, plrsplit->le_ilineSplit );
					
					LrToSz( plr, rgchBuf, m_plog );
					pdumpnode = new DUMPNODESPLIT(
						lgpos,
						plrsplit->lrtyp,
						nodelocNew,
						rgchBuf,
						plrsplit->le_pgno,
						plrsplit->le_ilineOper,
						plrsplit->splitoper
						);
					}
					break;
				default:
					break;
				}
			}
			break;
			
		case lrtypMerge:
			AssertSz( fFalse, "lrtypMerge not handled" );
			break;

		default:
			Assert( fFalse );
			break;			
		}

	if( pdumpnode )
		{
		if( NULL == m_pdumpnodeHead_ )
			{
			Assert( NULL == m_pdumpnodeTail_ );
			m_pdumpnodeHead_ = pdumpnode;
			m_pdumpnodeTail_ = pdumpnode;
			}
		else
			{
			Assert( NULL != m_pdumpnodeTail_ );
			m_pdumpnodeTail_->pdumpnodeNext = pdumpnode;
			pdumpnode->pdumpnodePrev 		= m_pdumpnodeTail_;
			m_pdumpnodeTail_ 				= pdumpnode;
			}
		}
	}



//  ================================================================
VOID DUMPLOGNODE::ProcessLRAfterLgpos_( const LR* plr, const LGPOS& lgpos )
//  ================================================================
	{
	DUMPNODE * pdumpnode = NULL;
	char rgchBuf[1024];
	
	switch ( plr->lrtyp )
		{
		case lrtypNOP:
		case lrtypMS:
		case lrtypJetOp:
		case lrtypBegin:
		case lrtypBegin0:
		case lrtypBeginDT:
		case lrtypRefresh:
		case lrtypCommit:
		case lrtypCommit0:
		case lrtypPrepCommit:
		case lrtypPrepRollback:
		case lrtypRollback:
		case lrtypCreateDB:
		case lrtypAttachDB:
		case lrtypDetachDB:
		case lrtypCreateMultipleExtentFDP:
		case lrtypCreateSingleExtentFDP:
		case lrtypConvertFDP:
		case lrtypSetExternalHeader:
		case lrtypInit:
		case lrtypTerm:
		case lrtypShutDownMark:
		case lrtypRecoveryQuit:
		case lrtypRecoveryUndo:
		case lrtypFullBackup:
		case lrtypBackup:
		case lrtypIncBackup:
		case lrtypTrace:
		case lrtypExtRestore:
		case lrtypForceDetachDB:
		case lrtypEmptyTree:
		case lrtypForceFlushLog:
			break;

		case lrtypMacroAbort:
			AssertSz( fFalse, "lrtypMacroAbort not handled" );
			break;

		case lrtypMacroBegin:
			m_fDumpSplit	= fFalse;
			m_fInMacro 		= fTrue;
			break;
			
		case lrtypMacroCommit:
			m_fDumpSplit	= fFalse;
			m_fInMacro 		= fFalse;
			break;

		case lrtypUndoInfo:
			{
			const LRPAGE_ * const	plrpage = reinterpret_cast<const LRPAGE_ *>( plr );
			const NODELOC 			nodeloc( plrpage->dbid, plrpage->le_pgno, 0 );

			if( m_nodelocCur_.FSamePage( nodeloc ) )
				{
				LrToSz( plr, rgchBuf, m_plog );
				pdumpnode = new DUMPNODE( lgpos, plrpage->lrtyp, nodeloc, rgchBuf );
				}
			}
			break;

		case lrtypDelta:
		case lrtypFlagDelete:
		case lrtypFlagInsert:
		case lrtypFlagInsertAndReplaceData:
		case lrtypReplace:
		case lrtypReplaceD:
		case lrtypUndo:
			{
			const LRNODE_ * const	plrnode = reinterpret_cast<const LRNODE_ *>( plr );
			const NODELOC 			nodeloc( plrnode->dbid, plrnode->le_pgno, plrnode->ILine() );

			if( m_fInMacro && m_fDumpSplit
				|| m_nodelocCur_ == nodeloc )
				{
				LrToSz( plr, rgchBuf, m_plog );
				pdumpnode = new DUMPNODE( lgpos, plrnode->lrtyp, nodeloc, rgchBuf );
				}
			}
			break;

		case lrtypInsert:
		case lrtypDelete:		
			{
			const LRNODE_ * const	plrnode = reinterpret_cast<const LRNODE_ *>( plr );
			const NODELOC 			nodeloc( plrnode->dbid, plrnode->le_pgno, plrnode->ILine() );

			if( m_fInMacro && m_fDumpSplit
				|| m_nodelocCur_.FSamePage( nodeloc ) && nodeloc <= m_nodelocCur_
				)
				{
				LrToSz( plr, rgchBuf, m_plog );
				pdumpnode = new DUMPNODE( lgpos, plrnode->lrtyp, nodeloc, rgchBuf );

				if( lrtypInsert == plr->lrtyp )
					{
					if( m_nodelocCur_ != nodeloc
						|| CmpLgpos( &lgpos, &m_lgposOrig_ ) != 0 )
						{
						m_nodelocCur_.MoveUp();
						}
					}
				else if( m_nodelocCur_ == nodeloc )
					{
					Assert( lrtypDelete == plr->lrtyp );
					m_nodelocCur_.MovePage( 0, 0 );			//  node no longer exists
					}
				else
					{
					Assert( lrtypDelete == plr->lrtyp );
					m_nodelocCur_.MoveDown();
					}
				}
			}
			break;

		case lrtypSplit:
			{
			const LRSPLIT * const plrsplit = reinterpret_cast<const LRSPLIT *>( plr );
			const NODELOC 	nodeloc( plrsplit->dbid, plrsplit->le_pgno, plrsplit->le_ilineSplit );
			const NODELOC 	nodelocNew( plrsplit->dbid, plrsplit->le_pgnoNew, 0 );

			if( nodeloc.FSamePage( m_nodelocCur_ ) && m_nodelocCur_ >= nodeloc
				|| nodelocNew.FSamePage( m_nodelocCur_ ) )
				{
				//  this node was split onto the new page
				LrToSz( plr, rgchBuf, m_plog );
				pdumpnode = new DUMPNODE(lgpos, plrsplit->lrtyp, nodeloc, rgchBuf );
				}

			if( nodeloc.FSamePage( m_nodelocCur_ ) )
				{
				if ( splittypeRight == plrsplit->splittype )
					{
					if( splitoperInsert == plrsplit->splitoper
						&& 	( m_nodelocCur_ > nodeloc
							|| 	m_nodelocCur_ == nodeloc
								&& CmpLgpos( &lgpos, &m_lgposOrig_ ) != 0 ) )
						{
						Assert( pdumpnode );
						Assert( m_fInMacro );
						m_nodelocCur_.MoveUp();
						m_fDumpSplit = fTrue;
						}

					if( m_nodelocCur_ >= nodeloc )
						{
						Assert( pdumpnode );
						Assert( m_fInMacro );
						m_nodelocCur_.MovePage( plrsplit->le_pgnoNew, m_nodelocCur_.Iline() - nodeloc.Iline() );
						m_fDumpSplit = fTrue;
						}
					}
				else if ( splittypeVertical == plrsplit->splittype )
					{
					Assert( pdumpnode );
					Assert( m_fInMacro );
					m_nodelocCur_.MovePage( plrsplit->le_pgnoNew, m_nodelocCur_.Iline() );
					m_fDumpSplit = fTrue;
					}
				else if ( splittypeAppend == plrsplit->splittype )
					{
					}
				else
					{
					}
				}
			}
			break;
			
		case lrtypMerge:
			{
			const LRMERGE * const plrmerge = reinterpret_cast<const LRMERGE *>( plr );
			const NODELOC 	nodeloc( plrmerge->dbid, plrmerge->le_pgno, 0 );
			const NODELOC 	nodelocNew( plrmerge->dbid, plrmerge->le_pgnoRight, 0 );

			if( nodeloc.FSamePage( m_nodelocCur_ )
				|| nodelocNew.FSamePage( m_nodelocCur_ ) )
				{
				AssertSz( fFalse, "lrtypMerge not handled" );
				}
			}
			break;

		default:
			Assert( fFalse );
			break;
			
		}

	if( pdumpnode )
		{
		if( m_nodelocCur_.Pgno() != 0 )
			{
			m_nodelocEnd_ = m_nodelocCur_;
			}
		m_lgposEnd_ = pdumpnode->lgpos;
		
		pdumpnode->pdumpnodePrev = m_pdumpnodeTail_;
		if( NULL == m_pdumpnodeHead_ )
			{
			Assert( NULL == m_pdumpnodeTail_ );
			m_pdumpnodeHead_ = pdumpnode;
			}
		else
			{
			Assert( NULL != m_pdumpnodeTail_ );
			m_pdumpnodeTail_->pdumpnodeNext = pdumpnode;
			}
		m_pdumpnodeTail_ = pdumpnode;

		pdumpnode->nodelocCur = m_nodelocCur_;
		}
	}


//  ================================================================
VOID DUMPLOGNODE::UpdateNodelocBackward_( DUMPNODE * pdumpnode )
//  ================================================================
	{
	BOOL fDelete = fTrue;
	
	switch ( pdumpnode->lrtyp )
		{
		case lrtypMacroBegin:
			m_fInMacro = fFalse;
			break;
			
		case lrtypMacroCommit:
			m_fInMacro = fTrue;
			break;

		case lrtypMacroAbort:
			AssertSz( fFalse, "lrtypMacroAbort not handled" );
			break;

		case lrtypUndoInfo:
			if( m_nodelocCur_.FSamePage( pdumpnode->nodeloc ) )
				{
				fDelete = fFalse;
				}
			break;

		case lrtypDelta:
		case lrtypFlagDelete:
		case lrtypFlagInsert:
		case lrtypFlagInsertAndReplaceData:
		case lrtypReplace:
		case lrtypReplaceD:
		case lrtypUndo:
			if( m_nodelocCur_ == pdumpnode->nodeloc )
				{
				fDelete = fFalse;
				}
			break;

		case lrtypInsert:
		case lrtypDelete:		
			if( m_nodelocCur_.FSamePage( pdumpnode->nodeloc ) 
				&& pdumpnode->nodeloc <= m_nodelocCur_ )
				{
				fDelete = fFalse;
						
				if( lrtypInsert == pdumpnode->lrtyp )
					{
					if( pdumpnode->nodeloc == m_nodelocCur_ )
						{
						//  this was the insert that created this node
						m_nodelocCur_.MovePage( 0,0 );
						}
					else
						{
						//  a node underneath this one was inserted
						m_nodelocCur_.MoveDown();
						}
					}
				else if( pdumpnode->nodeloc < m_nodelocCur_ )
					{
					//  a node underneath this node was deleted
					Assert( lrtypDelete == pdumpnode->lrtyp );
					m_nodelocCur_.MoveUp();
					}
				}
			break;

		case lrtypSplit:
			if( m_nodelocCur_.FSamePage( pdumpnode->nodeloc ) )
				{
				//  the page this node is on was created by this split
				fDelete = fFalse;
				const DUMPNODESPLIT * const pdumpnodesplit = static_cast<DUMPNODESPLIT *>( pdumpnode );
				DUMPPrintF( ">>> Split moves [%d:%d] to [%d:%d] <<<\n", m_nodelocCur_.Dbid(), m_nodelocCur_.Pgno(),
							m_nodelocCur_.Dbid(), pdumpnodesplit->pgnoOld );
				m_nodelocCur_.MovePage(
					pdumpnodesplit->pgnoOld,
					m_nodelocCur_.Iline() + pdumpnodesplit->nodeloc.Iline()
				);
					
				if( splitoperInsert == pdumpnodesplit->splitoper )
					{
					if( pdumpnodesplit->ilineOper < m_nodelocCur_.Iline() )
						{
						//  the node was inserted in front of us
						m_nodelocCur_.MoveDown();
						}			
					else if( pdumpnodesplit->ilineOper == m_nodelocCur_.Iline() )
						{
						//  this insertion created this node
						m_nodelocCur_.MovePage( 0, 0 );
						}
					}
				}
			break;
			
		case lrtypMerge:
			AssertSz( fFalse, "lrtypMerge not handled" );
			break;

		default:
			Assert( fFalse );
			break;
			
		}

	if( fDelete )
		{
		if( m_pdumpnodeHead_ == pdumpnode
			|| m_pdumpnodeTail_ == pdumpnode )
			{
			if( m_pdumpnodeHead_ == pdumpnode )
				{
				m_pdumpnodeHead_ = pdumpnode->pdumpnodeNext;
				if( m_pdumpnodeHead_ )
					{
					m_pdumpnodeHead_->pdumpnodePrev = NULL;
					}
				}

			if( m_pdumpnodeTail_ == pdumpnode )
				{
				m_pdumpnodeTail_ = pdumpnode->pdumpnodePrev;
				if( m_pdumpnodeTail_ )
					{
					m_pdumpnodeTail_->pdumpnodeNext = NULL;
					}
				}	
			}
		else
			{
			DUMPNODE * const pdumpnodeNext = pdumpnode->pdumpnodeNext;
			DUMPNODE * const pdumpnodePrev = pdumpnode->pdumpnodePrev;
			
			pdumpnodeNext->pdumpnodePrev = pdumpnodePrev;
			pdumpnodePrev->pdumpnodeNext = pdumpnodeNext;
			}

		delete pdumpnode;
		}
	else
		{
		if( m_nodelocCur_.Pgno() != 0 )
			{
			m_nodelocStart_ = m_nodelocCur_;
			}
		m_lgposStart_ = pdumpnode->lgpos;

		pdumpnode->nodelocCur = m_nodelocCur_;
		}
	}

//  ================================================================
VOID DUMPLOGNODE::ProcessLR( const	LR* plr, LGPOS *plgpos )
//  ================================================================
	{
	if( CmpLgpos( plgpos, &m_lgposOrig_ ) <= 0 )
		{
		ProcessLRBeforeLgpos_( plr, *plgpos );
		}
	else
		{
		ProcessLRAfterLgpos_( plr, *plgpos );
		}
	}

	
//  ================================================================
VOID DUMPLOGNODE::DumpNodes()
//  ================================================================
	{
	DUMPPrintF( "\n" );

	DUMPNODE * pdumpnode;

	m_nodelocCur_ = m_nodelocOrig_;

	pdumpnode = m_pdumpnodeTail_;
	while( pdumpnode && CmpLgpos( &m_lgposOrig_, &(pdumpnode->lgpos) ) <= 0 )
		{
		pdumpnode = pdumpnode->pdumpnodePrev;
		}
		
	while( pdumpnode )
		{
		DUMPNODE * const pdumpnodePrev = pdumpnode->pdumpnodePrev;
		UpdateNodelocBackward_( pdumpnode );
		pdumpnode = pdumpnodePrev;
		}

	DUMPPrintF( "\n" );

	pdumpnode = m_pdumpnodeHead_;
	while( pdumpnode )
		{
		DUMPPrintF( ">%06X,%04X,%04X ", pdumpnode->lgpos.lGeneration, pdumpnode->lgpos.isec, pdumpnode->lgpos.ib );
		DUMPPrintF( "%s", pdumpnode->sz );
		DUMPPrintF( " ([%d:%d:%d])",
			pdumpnode->nodelocCur.Dbid(),
			pdumpnode->nodelocCur.Pgno(),
			pdumpnode->nodelocCur.Iline() );
		DUMPPrintF( "\n" );
		pdumpnode = pdumpnode->pdumpnodeNext;
		}

	DUMPPrintF( "\n\n" );

	DUMPPrintF( 
		"[%d:%d:%d]@%06X,%04X,%04X ",
		m_nodelocOrig_.Dbid(), m_nodelocOrig_.Pgno(), m_nodelocOrig_.Iline(),
		m_lgposOrig_.lGeneration, m_lgposOrig_.isec, m_lgposOrig_.ib
	);
	DUMPPrintF(
		"starts at " );
	DUMPPrintF(
		"[%d:%d:%d]@%06X,%04X,%04X ",
		m_nodelocStart_.Dbid(), m_nodelocStart_.Pgno(), m_nodelocStart_.Iline(),
		m_lgposStart_.lGeneration, m_lgposStart_.isec, m_lgposStart_.ib
		);
	DUMPPrintF( " and moves to " );
	DUMPPrintF(
		"[%d:%d:%d]@%06X,%04X,%04X ",
		m_nodelocEnd_.Dbid(), m_nodelocEnd_.Pgno(), m_nodelocEnd_.Iline(),
		m_lgposEnd_.lGeneration, m_lgposEnd_.isec, m_lgposEnd_.ib
		);
	DUMPPrintF( "\n" );
	}

	
//  ================================================================
ERR ErrDUMPLogNode( INST *pinst, CHAR *szLog, const NODELOC& nodeloc, const LGPOS& lgpos )
//  ================================================================
	{
	Assert( pinst->m_plog );
	Assert( pinst->m_pver );

	return pinst->m_plog->ErrLGDumpLogNode( szLog, nodeloc, lgpos );
	}
	
ERR LOG::ErrLGDumpLogNode( CHAR *szLog, const NODELOC& nodeloc, const LGPOS& lgpos )
	{
	AssertTracking();

	return JET_errSuccess;
	}

#endif		// DEBUG


INLINE LOCAL VOID DUMPPrintBkinfo( BKINFO *pbkinfo )
	{
	LONG	genLow, genHigh;
	LOGTIME	tm = pbkinfo->logtimeMark;
	LGPOS	lgpos;
	
	lgpos = pbkinfo->le_lgposMark;
	genLow = pbkinfo->le_genLow;
	genHigh = pbkinfo->le_genHigh;
	DUMPPrintF( "        Log Gen: %u-%u (0x%x-0x%x)\n", genLow, genHigh, genLow, genHigh );
	DUMPPrintF( "           Mark: (0x%X,%X,%X)\n", lgpos.lGeneration, lgpos.isec, lgpos.ib );
		
	DUMPPrintF( "           Mark: %02d/%02d/%04d %02d:%02d:%02d\n",
						(short) tm.bMonth, (short) tm.bDay,	(short) tm.bYear + 1900,
						(short) tm.bHours, (short) tm.bMinutes, (short) tm.bSeconds);
	}	
		
ERR ErrDUMPHeader( INST *pinst, CHAR *szDatabase, BOOL fSetState )
	{
	ERR			err;
	DBFILEHDR_FIX	*pdfh;
	LGPOS		lgpos;
	LOGTIME		tm;

	pdfh = (DBFILEHDR_FIX * )PvOSMemoryPageAlloc( g_cbPage, NULL );
	if ( pdfh == NULL )
		return ErrERRCheck( JET_errOutOfMemory );
	
	err = ( ( !fSetState ) ? 
			ErrUtilReadShadowedHeader : ErrUtilReadAndFixShadowedHeader )
				( pinst->m_pfsapi, szDatabase, (BYTE*)pdfh, g_cbPage, OffsetOf( DBFILEHDR_FIX, le_cbPageSize ), NULL );
	if ( err < 0 )
		{
		if ( err == JET_errDiskIO )
			err = ErrERRCheck( JET_errDatabaseCorrupted );
		goto HandleError;
		}

	// check filetype
	if( filetypeUnknown != pdfh->le_filetype // old format
		&& filetypeDB != pdfh->le_filetype 
		&& filetypeSLV != pdfh->le_filetype )
		{
		// not a database or streaming file
		Call( ErrERRCheck( JET_errFileInvalidType ) );
		}

	if ( fSetState )
		{
		pdfh->SetDbstate( JET_dbstateConsistent );
		memset( &pdfh->le_lgposConsistent, 0, sizeof( pdfh->le_lgposConsistent ) );
		memset( &pdfh->logtimeConsistent, 0, sizeof( pdfh->logtimeConsistent ) );
		memset( &pdfh->le_lgposAttach, 0, sizeof( pdfh->le_lgposAttach ) );
		pdfh->le_lGenMinRequired = 0;
		pdfh->le_lGenMaxRequired = 0;
		Call( ErrUtilWriteShadowedHeader(	pinst->m_pfsapi, 
											szDatabase, 
											fTrue,
											(BYTE*)pdfh, 
											g_cbPage ) );
		}

	DUMPPrintF( "        File Type: %s\n", attribDb == pdfh->le_attrib ? "Database" : attribSLV == pdfh->le_attrib ? "Streaming File" : "UNKNOWN" );
	DUMPPrintF( "   Format ulMagic: 0x%lx\n", LONG( pdfh->le_ulMagic ) );
	DUMPPrintF( "   Engine ulMagic: 0x%lx\n", ulDAEMagic );
	DUMPPrintF( " Format ulVersion: 0x%lx,%d\n", LONG( pdfh->le_ulVersion ), short( pdfh->le_ulUpdate ) );
	DUMPPrintF( " Engine ulVersion: 0x%lx,%d\n", ulDAEVersion, ulDAEUpdate );
	DUMPPrintF( "Created ulVersion: 0x%lx,%d\n", LONG( pdfh->le_ulCreateVersion ), short( pdfh->le_ulCreateUpdate ) );
		
	DUMPPrintF( "     DB Signature: " );
	DUMPPrintSig( &pdfh->signDb );
		
#ifdef DBHDR_FORMAT_CHANGE
	DUMPPrintF( "      cbDbHdrPage: %l\n", (LONG)pdfh->le_ulCbDbHdrPage );
#endif
	
	DUMPPrintF( "         cbDbPage: %d\n", pdfh->le_cbPageSize );

	DBTIME dbtimeDirtied;
	dbtimeDirtied = pdfh->le_dbtimeDirtied;
	DUMPPrintF( "           dbtime: %I64u (0x%I64x)\n", dbtimeDirtied, dbtimeDirtied );

	switch ( pdfh->Dbstate() )
		{
		case JET_dbstateJustCreated:
		case JET_dbstateInconsistent:
		case JET_dbstateConsistent:
		case JET_dbstateBeingConverted:
		case JET_dbstateForceDetach:
			DUMPPrintF( "            State: %s\n", rgszDBState[pdfh->Dbstate()] );
			break;
		default:
			DUMPPrintF( "            State: %s\n", rgszDBState[0] );
			break;
		}

	DUMPPrintF(
			"     Log Required: %u-%u (0x%x-0x%x)\n",
			(ULONG) pdfh->le_lGenMinRequired,
			(ULONG) pdfh->le_lGenMaxRequired,
			(ULONG) pdfh->le_lGenMinRequired,
			(ULONG) pdfh->le_lGenMaxRequired );

	if ( attribDb == pdfh->le_attrib )
		DUMPPrintF( "   Streaming File: %s\n", pdfh->FSLVExists() ? "Yes" : "No" );

	DUMPPrintF( "         Shadowed: %s\n", pdfh->FShadowingDisabled() ? "No" : "Yes" );
	DUMPPrintF( "       Last Objid: %u\n", (ULONG) pdfh->le_objidLast );
	DBTIME dbtimeLastScrub;
	dbtimeLastScrub = pdfh->le_dbtimeLastScrub;
	DUMPPrintF( "     Scrub Dbtime: %I64u (0x%I64x)\n", dbtimeLastScrub, dbtimeLastScrub );
	DUMPPrintF( "       Scrub Date: " );
	tm = pdfh->logtimeScrub;
	DUMPPrintF( "%02d/%02d/%04d %02d:%02d:%02d\n",
		(short) tm.bMonth, (short) tm.bDay,	(short) tm.bYear + 1900,
		(short) tm.bHours, (short) tm.bMinutes, (short) tm.bSeconds);
	DUMPPrintF( "     Repair Count: %u\n", (ULONG) pdfh->le_ulRepairCount );	
	DUMPPrintF( "      Repair Date: " );
	tm = pdfh->logtimeRepair;
	DUMPPrintF( "%02d/%02d/%04d %02d:%02d:%02d\n",
		(short) tm.bMonth, (short) tm.bDay,	(short) tm.bYear + 1900,
		(short) tm.bHours, (short) tm.bMinutes, (short) tm.bSeconds);

	lgpos = pdfh->le_lgposConsistent;
	DUMPPrintF( "  Last Consistent: (0x%X,%X,%X)  ", lgpos.lGeneration, lgpos.isec, lgpos.ib );
		
	tm = pdfh->logtimeConsistent;
	DUMPPrintF( "%02d/%02d/%04d %02d:%02d:%02d\n",
		(short) tm.bMonth, (short) tm.bDay,	(short) tm.bYear + 1900,
		(short) tm.bHours, (short) tm.bMinutes, (short) tm.bSeconds);
		
	lgpos = pdfh->le_lgposAttach;
	DUMPPrintF( "      Last Attach: (0x%X,%X,%X)  ", lgpos.lGeneration, lgpos.isec, lgpos.ib );
		
	tm = pdfh->logtimeAttach;
	DUMPPrintF( "%02d/%02d/%04d %02d:%02d:%02d\n",
		(short) tm.bMonth, (short) tm.bDay,	(short) tm.bYear + 1900,
		(short) tm.bHours, (short) tm.bMinutes, (short) tm.bSeconds);
		
	lgpos = pdfh->le_lgposDetach;
	DUMPPrintF( "      Last Detach: (0x%X,%X,%X)  ", lgpos.lGeneration, lgpos.isec, lgpos.ib );
		
	tm = pdfh->logtimeDetach;
	DUMPPrintF( "%02d/%02d/%04d %02d:%02d:%02d\n",
		(short) tm.bMonth, (short) tm.bDay,	(short) tm.bYear + 1900,
		(short) tm.bHours, (short) tm.bMinutes, (short) tm.bSeconds);
		
	DUMPPrintF( "             Dbid: %d\n", (short) pdfh->le_dbid );
		
	DUMPPrintF( "    Log Signature: " );
	DUMPPrintSig( &pdfh->signLog );

	DUMPPrintF( "       OS Version: (%u.%u.%u SP %u)\n",
				(ULONG) pdfh->le_dwMajorVersion,
				(ULONG) pdfh->le_dwMinorVersion,
				(ULONG) pdfh->le_dwBuildNumber,
				(ULONG) pdfh->le_lSPNumber );

	DUMPPrintF( "\nPrevious Full Backup:\n" );
	DUMPPrintBkinfo( &pdfh->bkinfoFullPrev );
	
	DUMPPrintF( "\nCurrent Incremental Backup:\n" );
	DUMPPrintBkinfo( &pdfh->bkinfoIncPrev );
		
	DUMPPrintF( "\nCurrent Full Backup:\n" );
	DUMPPrintBkinfo( &pdfh->bkinfoFullCur );

	DUMPPrintF( "\nCurrent Shadow copy backup:\n" );
	DUMPPrintBkinfo( &pdfh->bkinfoSnapshotCur );	

	DUMPPrintF( "\n" );
	DUMPPrintF( "     cpgUpgrade55Format: %d\n", pdfh->le_cpgUpgrade55Format );
	DUMPPrintF( "    cpgUpgradeFreePages: %d\n", pdfh->le_cpgUpgradeFreePages );
	DUMPPrintF( "cpgUpgradeSpaceMapPages: %d\n", pdfh->le_cpgUpgradeSpaceMapPages );

#ifdef ELIMINATE_PATCH_FILE
	if ( pdfh->bkinfoFullCur.le_genLow && !pdfh->bkinfoFullCur.le_genHigh )
		{
		SIGNATURE signLog;
		SIGNATURE signDb;
		BKINFO bkinfoFullCur;

		PATCHHDR * ppatchHdr = (PATCHHDR *)pdfh;

		memcpy( &signLog, &pdfh->signLog, sizeof(signLog) );
		memcpy( &signDb, &pdfh->signDb, sizeof(signLog) );
		memcpy( &bkinfoFullCur, &pdfh->bkinfoFullCur, sizeof(BKINFO) );
		
		//	the patch file is always on the OS file-system
		Call ( pinst->m_plog->ErrLGBKReadAndCheckDBTrailer( pinst->m_pfsapi, szDatabase, (BYTE *)ppatchHdr) );

		if ( memcmp( &signDb, &ppatchHdr->signDb, sizeof( SIGNATURE ) ) != 0 ||
			 memcmp( &signLog, &ppatchHdr->signLog, sizeof( SIGNATURE ) ) != 0 ||
			 CmpLgpos( &bkinfoFullCur.le_lgposMark, &ppatchHdr->bkinfo.le_lgposMark ) != 0 )
			{
			Call ( ErrERRCheck( JET_errDatabasePatchFileMismatch ) );
			}
		
		DUMPPrintF( "\nPatch Current Full Backup:\n" );
		DUMPPrintBkinfo( &ppatchHdr->bkinfo );
		}
	
#endif // ELIMINATE_PATCH_FILE

HandleError:
	OSMemoryPageFree( pdfh );
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\dbutil.cxx ===
#include "std.hxx"
#include "_bt.hxx"
#include "_dump.hxx"


#if !defined( MINIMAL_FUNCTIONALITY ) || defined( DEBUGGER_EXTENSION )

//  ================================================================
VOID DBUTLSprintHex(
	CHAR * const 		szDest,
	const BYTE * const 	rgbSrc,
	const INT 			cbSrc,
	const INT 			cbWidth,
	const INT 			cbChunk,
	const INT			cbAddress,
	const INT			cbStart)
//  ================================================================
	{
	static const CHAR rgchConvert[] =	{ '0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f' };
			
	const BYTE * const pbMax = rgbSrc + cbSrc;
	const INT cchHexWidth = ( cbWidth * 2 ) + (  cbWidth / cbChunk );

	const BYTE * pb = rgbSrc;
	CHAR * sz = szDest;
	while( pbMax != pb )
		{
		sz += ( 0 == cbAddress ) ? 0 : sprintf( sz, "%*.*lx    ", cbAddress, cbAddress, pb - rgbSrc + cbStart );
		CHAR * szHex	= sz;
		CHAR * szText	= sz + cchHexWidth;
		do
			{
			for( INT cb = 0; cbChunk > cb && pbMax != pb; ++cb, ++pb )
				{
				*szHex++ 	= rgchConvert[ *pb >> 4 ];
				*szHex++ 	= rgchConvert[ *pb & 0x0F ];
				*szText++ 	= isprint( *pb ) ? *pb : '.';
				}
			*szHex++ = ' ';
			} while( ( ( pb - rgbSrc ) % cbWidth ) && pbMax > pb );
		while( szHex != sz + cchHexWidth )
			{
			*szHex++ = ' ';
			}
		*szText++ = '\n';
		*szText = '\0';
		sz = szText;
		}
	}

/*
//  ================================================================
LOCAL VOID DBUTLSprintHex(
	CHAR * const 		szDest,
	const BYTE * const 	rgbSrc,
	const INT 			cbSrc,
	const INT 			cbWidth = 16,
	const INT 			cbChunk = 4 )
//  ================================================================
	{
	CHAR 	szFormat[256];
	CHAR *	szDestT = szDest;

	const BYTE * pb 			= rgbSrc;
	const BYTE * const pbMax	= rgbSrc + cbSrc;

	Assert( cbWidth % cbChunk == 0 );

	sprintf( szFormat, "%%8.8lx    %%-%d.%ds %%-%d.%ds\n",
		cbWidth * 2 + cbWidth / cbChunk,
		cbWidth * 2 + cbWidth / cbChunk,
		cbWidth,
		cbWidth );
		
	while( pb < pbMax )
		{
		const INT ibAddress = pb - rgbSrc;

		CHAR rgchData[256];
		CHAR rgchText[256];

		CHAR * szData = rgchData;
		CHAR * szText = rgchText;
		
		do
			{
			INT ib;
			for( ib = 0; ib < cbChunk && pb < pbMax; ++ib, ++pb )
				{
				szData += sprintf( szData, "%2.2x", *pb );
				szText += sprintf( szText, "%c", isprint( *pb ) ? *pb : '.' );
				}

			*szData++ = ' ';
			} while( pb < pbMax && ( (pb - rgbSrc) % cbWidth != 0 ) );
		*szData = '\0';
		*szText = '\0';
		
		szDestT += sprintf( szDestT, szFormat, ibAddress, rgchData, rgchText );
		}
	*szDestT = '\0';
	}
*/

//  ================================================================
VOID DBUTLDumpRec( const VOID * const pv, const INT cb, CPRINTF * pcprintf, const INT cbWidth )
//  ================================================================
	{
	CHAR szBuf[g_cbPageMax];
	
	//  dump the columns of the record
	const REC * const prec = reinterpret_cast<const REC *>( pv );

	FID fid;
	
	const FID fidFixedFirst = fidFixedLeast;
	const FID fidFixedLast  = prec->FidFixedLastInRec();
	const INT cColumnsFixed = max( 0, fidFixedLast - fidFixedFirst + 1 );
	(*pcprintf)( "   Fixed Columns:  %d\n", cColumnsFixed );
	(*pcprintf)( "=================\n" );
	for( fid = fidFixedFirst; fid <= fidFixedLast; ++fid )
		{
		const UINT	ifid 					= fid - fidFixedLeast;
		const BYTE	* const prgbitNullity 	= prec->PbFixedNullBitMap() + ifid/8;

		(*pcprintf)( "%d:  %s\n", fid, FFixedNullBit( prgbitNullity, ifid ) ? "NULL" : "" );
		}		

	(*pcprintf)( "\n" );
	
	const FID fidVariableFirst = fidVarLeast ;
	const FID fidVariableLast  = prec->FidVarLastInRec();
	const INT cColumnsVariable = max( 0, fidVariableLast - fidVariableFirst + 1 );
	(*pcprintf)( "Variable Columns:  %d\n", cColumnsVariable );
	(*pcprintf)( "=================\n" );

	const UnalignedLittleEndian<REC::VAROFFSET> * const pibVarOffs		= ( const UnalignedLittleEndian<REC::VAROFFSET> * const )prec->PibVarOffsets();
	for( fid = fidVariableFirst; fid <= fidVariableLast; ++fid )
		{
		const UINT				ifid			= fid - fidVarLeast;
		const REC::VAROFFSET	ibStartOfColumn	= prec->IbVarOffsetStart( fid );
		const REC::VAROFFSET	ibEndOfColumn	= IbVarOffset( pibVarOffs[ifid] );

		(*pcprintf)( "%d:  ", fid );
		if ( FVarNullBit( pibVarOffs[ifid] ) )
			{
			(*pcprintf)( "NULL\n" );
			}
		else
			{
			const VOID * const pvColumn = prec->PbVarData() + ibStartOfColumn;
			const INT cbColumn			= ibEndOfColumn - ibStartOfColumn;
			(*pcprintf)( "%d bytes\n", cbColumn );
			DBUTLSprintHex( szBuf, (BYTE *)pvColumn, cbColumn, cbWidth );
			(*pcprintf)( "%s\n", szBuf );	
			}
		}		

	(*pcprintf)( "\n" );

	(*pcprintf)( "  Tagged Columns:\n" );
	(*pcprintf)( "=================\n" );

	DATA	dataRec;
	dataRec.SetPv( (VOID *)pv );
	dataRec.SetCb( cb );

	if ( !TAGFIELDS::FIsValidTagfields( dataRec, pcprintf ) )
		{
		(*pcprintf)( "Tagged column corruption detected.\n" );
		}

	(*pcprintf)( "TAGFIELDS array begins at offset 0x%x from start of record.\n\n", prec->PbTaggedData() - (BYTE *)prec );

	TAGFIELDS_ITERATOR ti( dataRec );

	ti.MoveBeforeFirst();

	while( JET_errSuccess == ti.ErrMoveNext() )
		{
		//	we are now on an individual column

		const CHAR * szComma = " ";

		(*pcprintf)( "%d:", ti.Fid() );
		if( ti.FNull() )
			{
			(*pcprintf)( "%sNull ", szComma );
			szComma = ", ";
			}
		if( ti.FDerived() )
			{
			(*pcprintf)( "%sDerived", szComma );
			szComma = ", ";
			}
		if( ti.FSLV() )
			{
			(*pcprintf)( "%sSLV", szComma );
			szComma = ", ";
			}
		if( ti.FLV() )
			{
			(*pcprintf)( "%sLong-Value", szComma );
			szComma = ", ";
			}
		(*pcprintf)( "\r\n" );

		ti.TagfldIterator().MoveBeforeFirst();

		int itag = 1;
		
		while( JET_errSuccess == ti.TagfldIterator().ErrMoveNext() )
			{
			const BOOL	fSeparated	= ti.TagfldIterator().FSeparated();

			(*pcprintf)( ">> itag %d: %d bytes: ", itag, ti.TagfldIterator().CbData() );
			if ( fSeparated )
				{
				(*pcprintf)( "separated" );
				}
			(*pcprintf)( "\r\n" );

#ifdef DISABLE_SLV
#else
			if ( ti.FSLV() && !fSeparated )
				{
				//	UNDONE: use CSLVInfo iterator instead of this manual hack
				CSLVInfo::HEADER*	pslvinfoHdr		= (CSLVInfo::HEADER *)( ti.TagfldIterator().PbData() );
				CSLVInfo::_RUN*		prun			= (CSLVInfo::_RUN *)( pslvinfoHdr + 1 );
				QWORD				ibVirtualPrev	= 0;

				(*pcprintf)( "SLV size: 0x%I64x bytes, Runs: %I64d, Recoverable: %s\r\n",
									pslvinfoHdr->cbSize,
									pslvinfoHdr->cRun,
									( pslvinfoHdr->fDataRecoverable ? "YES" : "NO" ) );

				for ( ULONG irun = 1; irun <= pslvinfoHdr->cRun; irun++ )
					{
					const PGNO	pgnoStart	= PGNO( ( prun->ibLogical / g_cbPage ) - cpgDBReserved + 1 );
					const PGNO	pgnoEnd		= PGNO( pgnoStart + ( ( prun->ibVirtualNext - ibVirtualPrev ) / g_cbPage ) - 1 );
					(*pcprintf)( "    Run %d: ibVirtualNext=0x%I64x, ibLogical=0x%I64x ",
									irun,
									prun->ibVirtualNext,
									prun->ibLogical );
					Assert( pgnoEnd >= pgnoStart );
					if ( pgnoStart == pgnoEnd )
						(*pcprintf)( "(page %d)\r\n", pgnoStart );
					else
						(*pcprintf)( "(pages %d-%d)\r\n", pgnoStart, pgnoEnd );

					ibVirtualPrev = prun->ibVirtualNext;
					prun++;
					}

				(*pcprintf)( "\r\n" );
				}
			else
#endif	//	DISABLE_SLV
				{
				szBuf[0] = 0;
				DBUTLSprintHex(
					szBuf,
					ti.TagfldIterator().PbData(),
					min( ti.TagfldIterator().CbData(), 240 ),	//	only print 240b of data to ensure we don't overrun printf buffer
					cbWidth );
				(*pcprintf)( "%s%s\r\n", szBuf, ( ti.TagfldIterator().CbData() > 240 ? "...\r\n" : "" ) );
				}

			++itag;
			}
		}

/*
	if ( TAGFIELDS::FIsValidTagfields( dataRec, pcprintf ) )
		{
		TAGFIELDS	tagfields( dataRec );
		tagfields.Dump( pcprintf, szBuf, cbWidth );
		}
	else
		{
		(*pcprintf)( "Tagged column corruption detected.\n" );
		}
*/

	(*pcprintf)( "\n" );
	}


#endif	//	!defined( MINIMAL_FUNCTIONALITY ) || defined( DEBUGGER_EXTENSION )


#ifdef MINIMAL_FUNCTIONALITY
#else

//	description of page_info table
const JET_COLUMNDEF rgcolumndefPageInfoTable[] =
	{
	//	Pgno
	{sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed | JET_bitColumnTTKey}, 

	//	consistency checked
	{sizeof(JET_COLUMNDEF), 0, JET_coltypBit, 0, 0, 0, 0, 0, JET_bitColumnFixed | JET_bitColumnNotNULL},
	
	//	Avail
	{sizeof(JET_COLUMNDEF), 0, JET_coltypBit, 0, 0, 0, 0, 0, JET_bitColumnFixed },

	//	Space free
	{sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed},

	//	Pgno left
	{sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed }, 

	//	Pgno right
	{sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed }
	};	

const INT icolumnidPageInfoPgno			= 0;
const INT icolumnidPageInfoFChecked		= 1;
const INT icolumnidPageInfoFAvail		= 2;
const INT icolumnidPageInfoFreeSpace	= 3;
const INT icolumnidPageInfoPgnoLeft		= 4;
const INT icolumnidPageInfoPgnoRight	= 5;

const INT ccolumndefPageInfoTable		= ( sizeof ( rgcolumndefPageInfoTable ) / sizeof(JET_COLUMNDEF) );
LOCAL JET_COLUMNID rgcolumnidPageInfoTable[ccolumndefPageInfoTable];


typedef ERR(*PFNDUMP)( PIB *ppib, FUCB *pfucbCatalog, VOID *pfnCallback, VOID *pvCallback );


LOCAL ERR ErrDBUTLDump( JET_SESID sesid, const JET_DBUTIL *pdbutil );


//	UNDONE: Need a better way of tracking total available space, especially if
//	space dumper must be online
CPG	cpgTotalAvailExt					= 0;


//  ================================================================
LOCAL VOID DBUTLPrintfIntN( INT iValue, INT ichMax )
//  ================================================================
	{
	CHAR	rgchT[17]; /* C-runtime max bytes == 17 */
	INT		ichT;

	_itoa( iValue, rgchT, 10 );
	for ( ichT = 0; rgchT[ichT] != '\0' && ichT < 17; ichT++ )
		;
	if ( ichT > ichMax ) //lint !e661
		{
		for ( ichT = 0; ichT < ichMax; ichT++ )
			printf( "#" );
		}
	else
		{
		for ( ichT = ichMax - ichT; ichT > 0; ichT-- )
			printf( " " );
		for ( ichT = 0; rgchT[ichT] != '\0'; ichT++ )
			printf( "%c", rgchT[ichT] );
		}
	return;
	}

LOCAL VOID DBUTLPrintfStringN( CHAR *sz, INT ichMax )
	{
	INT		ich;

	for ( ich = 0; sz[ich] != '\0' && ich < ichMax; ich++ )
		printf( "%c", sz[ich] );
	for ( ; ich < ichMax; ich++ )
		printf( " " );
	printf( " " );
	return;
	}


//  ================================================================
LOCAL ERR ErrDBUTLRegExt( DBCCINFO *pdbccinfo, PGNO pgnoFirst, CPG cpg, BOOL fAvailT )
//  ================================================================
	{
	ERR 			err = JET_errSuccess;
	PGNO			pgno;
	PIB				*ppib = pdbccinfo->ppib;
	JET_SESID		sesid = (JET_SESID) pdbccinfo->ppib;
	JET_TABLEID		tableid = pdbccinfo->tableidPageInfo;
	BYTE			fAvail = (BYTE) fAvailT;
	
	Assert( tableid != JET_tableidNil );

	for ( pgno = pgnoFirst; pgno <= pgnoFirst + cpg - 1; pgno++ )
		{
		BOOL		fFound;
		BYTE		fChecked = fFalse;

		CallR( ErrIsamBeginTransaction( (JET_SESID) ppib, NO_GRBIT ) );

		/*	search for page in the table
		/**/
		CallS( ErrDispMakeKey( sesid, tableid, (BYTE *)&pgno, sizeof(pgno), JET_bitNewKey ) );
  		err = ErrDispSeek( sesid, tableid, JET_bitSeekEQ );
		if ( err < 0 && err != JET_errRecordNotFound )
			{
			Assert( fFalse );
			Call( err );
			}
		
		fFound = ( err == JET_errRecordNotFound ) ? fFalse : fTrue;
		if ( fFound )
			{
			ULONG	cbActual;
			BYTE	fAvailT2;
			
			/*	is this in availext
			/**/
			Call( ErrDispRetrieveColumn( sesid, 
				tableid, 
				rgcolumnidPageInfoTable[icolumnidPageInfoFAvail],
				(BYTE *)&fAvailT2,
				sizeof(fAvailT2),
				&cbActual,
				0,
				NULL ) );

			Assert( err == JET_wrnColumnNull || cbActual == sizeof(fAvailT2) );
			if ( err != JET_wrnColumnNull )
				{
				Assert( !fAvail || fAvailT2 );
				}

			/*	if fAvail is false, no changes to record
			/**/
			if ( !fAvail )
				goto Commit;

			/*	get fChecked [for setting it later]
			/**/
			Call( ErrDispRetrieveColumn( sesid, 
				tableid, 
				rgcolumnidPageInfoTable[icolumnidPageInfoFChecked],
				(BYTE *)&fChecked,
				sizeof(fChecked),
				&cbActual,
				0,
				NULL ) );

			Assert( cbActual == sizeof(fChecked) );

			Call( ErrDispPrepareUpdate( sesid, tableid, JET_prepReplaceNoLock ) );
			}
		else
			{
			Call( ErrDispPrepareUpdate( sesid, tableid, JET_prepInsert ) );

			/*	pgno
			/**/
			Call( ErrDispSetColumn( sesid, 
				tableid, 
				rgcolumnidPageInfoTable[icolumnidPageInfoPgno],
				(BYTE *) &pgno, 
				sizeof(pgno), 
				0, 
				NULL ) );
			}

		/*	set FChecked
		/**/
		Call( ErrDispSetColumn( sesid, 
			tableid, 
			rgcolumnidPageInfoTable[icolumnidPageInfoFChecked],
			(BYTE *)&fChecked, 
			sizeof(fChecked), 
			0, 
			NULL ) );

		/*	fAvail set if in AvailExt node
		/**/
		if ( fAvail )
			{
			Call( ErrDispSetColumn( sesid,
				tableid,
				rgcolumnidPageInfoTable[icolumnidPageInfoFAvail],
				(BYTE *) &fAvail, 
				sizeof(fAvail), 
				0, 
				NULL ) );
			}

		/*	update
		/**/
		Call( ErrDispUpdate( sesid, tableid, NULL, 0, NULL, 0 ) );								
		
		/*	commit
		/**/
Commit:
		Assert( ppib->level == 1 );
		Call( ErrIsamCommitTransaction( ( JET_SESID ) ppib, 0 ) );
		}

	return JET_errSuccess;
	
HandleError:
	CallS( ErrIsamRollback( (JET_SESID) ppib, JET_bitRollbackAll ) );

	return err;
	}


//  ****************************************************************
//	DBCC Info Routines
//  ****************************************************************


//  ================================================================
LOCAL ERR ErrDBUTLPrintPageDump( DBCCINFO *pdbccinfo )
//  ================================================================
	{
	ERR					err;
	const JET_SESID		sesid	= (JET_SESID) pdbccinfo->ppib;
	const JET_TABLEID	tableid = pdbccinfo->tableidPageInfo;
	ULONG				cbT;
		
	FUCBSetSequential( reinterpret_cast<FUCB *>( tableid ) );

	Assert( pdbccinfo->grbitOptions & JET_bitDBUtilOptionPageDump );

	//	move to first record
	err = ErrDispMove( sesid, tableid, JET_MoveFirst, 0 );
	if ( JET_errNoCurrentRecord != err )
		{
		err = JET_errSuccess;
		goto HandleError;
		}
	Call( err );
	
	printf( "\n\n ***************** PAGE DUMP *******************\n\n" );
	printf( "PGNO\tAVAIL\tCHECK\tLEFT\tRIGHT\tFREESPACE\n" );

	/*	while there are more records, print record
	/**/
	for( ;
		JET_errSuccess == err; 
		err = ErrDispMove( sesid, tableid, JET_MoveNext, 0 ) )
		{
		PGNO	pgnoThis	= pgnoNull;
		PGNO	pgnoLeft	= pgnoNull;
		PGNO	pgnoRight	= pgnoNull;
		BYTE 	fChecked	= fFalse;
		BYTE 	fAvail		= fFalse;
		ULONG	cbFreeSpace	= 0;
		
		//	pgno
	 	Call( ErrDispRetrieveColumn( sesid, 
			tableid, 
			rgcolumnidPageInfoTable[icolumnidPageInfoPgno],
			(BYTE *) &pgnoThis, 
			sizeof(pgnoThis), 
			&cbT,
 			0, 
		 	NULL ) );
		Assert( sizeof(pgnoThis) == cbT );
		
		//	FAvail
		Call( ErrDispRetrieveColumn( sesid, 
			tableid, 
			rgcolumnidPageInfoTable[icolumnidPageInfoFAvail],
			(BYTE *) &fAvail, 
			sizeof(fAvail), 
			&cbT,
			0, 
			NULL ) );
		Assert( sizeof(fAvail) == cbT || JET_wrnColumnNull == err );
			
		//	FChecked
		Call( ErrDispRetrieveColumn( sesid, 
			tableid, 
		 	rgcolumnidPageInfoTable[icolumnidPageInfoFChecked],
		 	(BYTE *)&fChecked, 
		 	sizeof(fChecked), 
		 	&cbT,
		 	0, 
			NULL ) );
		Assert( cbT == sizeof(fChecked) );
		Assert( fChecked || fAvail );
			
		//	left and right pgno
		Call( ErrDispRetrieveColumn( sesid, 
			tableid, 
			rgcolumnidPageInfoTable[icolumnidPageInfoPgnoLeft],
			(BYTE *)&pgnoLeft, 
			sizeof(pgnoLeft), 
			&cbT,
			0, 		
			NULL ) );
		Assert( cbT == sizeof(pgnoLeft) );
								
		Call( ErrDispRetrieveColumn( sesid, 
			 tableid, 
			 rgcolumnidPageInfoTable[icolumnidPageInfoPgnoRight],
			 (BYTE *) &pgnoRight, 
			 sizeof(pgnoRight), 
			 &cbT,
			 0, 
			 NULL ) );
		Assert( cbT == sizeof(pgnoRight) );									
																	
		//	free space
		Call( ErrDispRetrieveColumn( sesid,
			tableid,
			rgcolumnidPageInfoTable[icolumnidPageInfoFreeSpace],
			(BYTE *) &cbFreeSpace, 
			sizeof(cbFreeSpace), 
			&cbT,
			0, 
			NULL ) );
		Assert( cbT == sizeof(cbFreeSpace) );

		//	print
		printf( "%u\t%s\t%s", pgnoThis, fAvail ? "FAvail" : "", fChecked ? "FCheck" : "" );
		if( fChecked )
			{
			printf( "\t%u\t%u\t%u", pgnoLeft, pgnoRight, cbFreeSpace );
			}
		printf( "\n" );
		}

	//	polymorph expected error to success
	if ( JET_errNoCurrentRecord == err )
		err = JET_errSuccess;

HandleError:
	return err;
	}


#ifdef DEBUG


//  ================================================================
LOCAL ERR ErrDBUTLISzToData( const CHAR * const sz, DATA * const pdata )
//  ================================================================
	{
	DATA& data = *pdata;
	
	const LONG cch = (LONG)strlen( sz );
	if( cch % 2 == 1
		|| cch <= 0 )
		{
		//  no data to insert
		return ErrERRCheck( JET_errInvalidParameter );
		}
	const LONG cbInsert = cch / 2;
	BYTE * pbInsert = (BYTE *)PvOSMemoryHeapAlloc( cbInsert );
	if( NULL == pbInsert )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}

	for( INT ibInsert = 0; ibInsert < cbInsert; ++ibInsert )
		{
		CHAR szConvert[3];
		szConvert[0] = sz[ibInsert * 2 ];
		szConvert[1] = sz[ibInsert * 2 + 1];
		szConvert[2] = 0;
		CHAR * pchEnd;
		const ULONG lConvert = strtoul( szConvert, &pchEnd, 16 );
		if( lConvert > 0xff 
			|| 0 != *pchEnd )
			{
			OSMemoryHeapFree( pbInsert );
			return ErrERRCheck( JET_errInvalidParameter );
			}
		pbInsert[ibInsert] = (BYTE)lConvert;
		}
			
	data.SetCb( cbInsert );
	data.SetPv( pbInsert );

	return JET_errSuccess;
	}


//  ================================================================
LOCAL ERR ErrDBUTLIInsertNode(
	PIB * const ppib,
	const IFMP ifmp,
	const PGNO pgno,
	const LONG iline,
	const DATA& data,
	CPRINTF * const pcprintf )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	CPAGE cpage;	
	CallR( cpage.ErrGetReadPage( ppib, ifmp, pgno, bflfNoTouch ) );
	Call( cpage.ErrUpgradeReadLatchToWriteLatch() );

	cpage.Dirty( bfdfFilthy );

	(*pcprintf)( "inserting data at %d:%d\r\n", pgno, iline );
	cpage.Insert( iline, &data, 1, 0 );

HandleError:
	cpage.ReleaseWriteLatch( fTrue );

	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLIReplaceNode(
	PIB * const ppib,
	const IFMP ifmp,
	const PGNO pgno,
	const LONG iline,
	const DATA& data,
	CPRINTF * const pcprintf )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	CPAGE cpage;	
	CallR( cpage.ErrGetReadPage( ppib, ifmp, pgno, bflfNoTouch ) );
	Call( cpage.ErrUpgradeReadLatchToWriteLatch() );

	cpage.Dirty( bfdfFilthy );

	(*pcprintf)( "replacing data at %d:%d\r\n", pgno, iline );
	cpage.Replace( iline, &data, 1, 0 );

HandleError:
	cpage.ReleaseWriteLatch( fTrue );

	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLISetNodeFlags(
	PIB * const ppib,
	const IFMP ifmp,
	const PGNO pgno,
	const LONG iline,
	const INT fFlags,
	CPRINTF * const pcprintf )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	CPAGE cpage;	
	CallR( cpage.ErrGetReadPage( ppib, ifmp, pgno, bflfNoTouch ) );
	Call( cpage.ErrUpgradeReadLatchToWriteLatch() );

	cpage.Dirty( bfdfFilthy );

	(*pcprintf)( "settings flags at %d:%d to 0x%x\r\n", pgno, iline, fFlags );
	cpage.ReplaceFlags( iline, fFlags );

HandleError:
	cpage.ReleaseWriteLatch( fTrue );

	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLIDeleteNode(
	PIB * const ppib,
	const IFMP ifmp,
	const PGNO pgno,
	const LONG iline,
	CPRINTF * const pcprintf )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	CPAGE cpage;	
	CallR( cpage.ErrGetReadPage( ppib, ifmp, pgno, bflfNoTouch ) );
	Call( cpage.ErrUpgradeReadLatchToWriteLatch() );

	cpage.Dirty( bfdfFilthy );

	(*pcprintf)( "deleting %d:%d\r\n", pgno, iline );
	cpage.Delete( iline );

HandleError:
	cpage.ReleaseWriteLatch( fTrue );

	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLISetExternalHeader(
	PIB * const ppib,
	const IFMP ifmp,
	const PGNO pgno,
	const DATA& data,
	CPRINTF * const pcprintf )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	CPAGE cpage;	
	CallR( cpage.ErrGetReadPage( ppib, ifmp, pgno, bflfNoTouch ) );
	Call( cpage.ErrUpgradeReadLatchToWriteLatch() );

	cpage.Dirty( bfdfFilthy );

	(*pcprintf)( "setting external header of %d\r\n", pgno );
	cpage.SetExternalHeader( &data, 1, 0 );

HandleError:
	cpage.ReleaseWriteLatch( fTrue );

	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLISetPgnoNext( 
	PIB * const ppib,
	const IFMP ifmp,
	const PGNO pgno,
	const PGNO pgnoNext,
	CPRINTF * const pcprintf )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	CPAGE cpage;	
	CallR( cpage.ErrGetReadPage( ppib, ifmp, pgno, bflfNoTouch ) );
	Call( cpage.ErrUpgradeReadLatchToWriteLatch() );

	cpage.Dirty( bfdfFilthy );

	(*pcprintf)( "setting pgnoNext of %d to %d (was %d)\r\n", pgno, pgnoNext, cpage.PgnoNext() );
	cpage.SetPgnoNext( pgnoNext );

HandleError:
	cpage.ReleaseWriteLatch( fTrue );

	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLISetPgnoPrev( 
	PIB * const ppib,
	const IFMP ifmp,
	const PGNO pgno,
	const PGNO pgnoPrev,
	CPRINTF * const pcprintf )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	CPAGE cpage;	
	CallR( cpage.ErrGetReadPage( ppib, ifmp, pgno, bflfNoTouch ) );
	Call( cpage.ErrUpgradeReadLatchToWriteLatch() );

	cpage.Dirty( bfdfFilthy );

	(*pcprintf)( "setting pgnoPrev of %d to %d (was %d)\r\n", pgno, pgnoPrev, cpage.PgnoPrev() );
	cpage.SetPgnoPrev( pgnoPrev );

HandleError:
	cpage.ReleaseWriteLatch( fTrue );

	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLISetPageFlags( 
	PIB * const ppib,
	const IFMP ifmp,
	const PGNO pgno,
	const ULONG fFlags,
	CPRINTF * const pcprintf )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	CPAGE cpage;	
	CallR( cpage.ErrGetReadPage( ppib, ifmp, pgno, bflfNoTouch ) );
	Call( cpage.ErrUpgradeReadLatchToWriteLatch() );

	cpage.Dirty( bfdfFilthy );

	(*pcprintf)( "setting flags of %d to 0x%x (was 0x%x)\r\n", pgno, fFlags, cpage.FFlags() );
	cpage.SetFlags( fFlags );

HandleError:
	cpage.ReleaseWriteLatch( fTrue );

	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLMungeDatabase(
	PIB * const ppib,
	const IFMP ifmp,
	const CHAR * const rgszCommand[],
	const INT cszCommand,
	CPRINTF * const pcprintf )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	if( 3 == cszCommand
		&& _stricmp( rgszCommand[0], "insert" ) == 0 )
		{
		PGNO	pgno;
		LONG	iline;
		DATA	data;
		
		if( 2 != sscanf( rgszCommand[1], "%d:%d", &pgno, &iline ) )
			{
			//  we didn't get all the arguments we need
			return ErrERRCheck( JET_errInvalidParameter );
			}
			
		CallR( ErrDBUTLISzToData( rgszCommand[2], &data ) );
		err = ErrDBUTLIInsertNode( ppib, ifmp, pgno, iline, data, pcprintf );		
		OSMemoryHeapFree( data.Pv() );
		return err;
		}
	if( 3 == cszCommand
		&& _stricmp( rgszCommand[0], "replace" ) == 0 )
		{
		PGNO	pgno;
		LONG	iline;
		DATA	data;
		
		if( 2 != sscanf( rgszCommand[1], "%d:%d", &pgno, &iline ) )
			{
			//  we didn't get all the arguments we need
			return ErrERRCheck( JET_errInvalidParameter );
			}
			
		CallR( ErrDBUTLISzToData( rgszCommand[2], &data ) );
		err = ErrDBUTLIReplaceNode( ppib, ifmp, pgno, iline, data, pcprintf );		
		OSMemoryHeapFree( data.Pv() );
		
		return err;
		}
	if( 3 == cszCommand
		&& _stricmp( rgszCommand[0], "setflags" ) == 0 )
		{
		PGNO	pgno;
		LONG	iline;		
		if( 2 != sscanf( rgszCommand[1], "%d:%d", &pgno, &iline ) )
			{
			//  we didn't get all the arguments we need
			return ErrERRCheck( JET_errInvalidParameter );
			}

		const ULONG fFlags = strtoul( rgszCommand[2], NULL, 0 );
		err = ErrDBUTLISetNodeFlags( ppib, ifmp, pgno, iline, fFlags, pcprintf );		
		
		return err;
		}
	else if( 2 == cszCommand
		&& _stricmp( rgszCommand[0], "delete" ) == 0 )
		{
		PGNO	pgno;
		LONG	iline;
		
		if( 2 != sscanf( rgszCommand[1], "%d:%d", &pgno, &iline ) )
			{
			//  we didn't get all the arguments we need
			return ErrERRCheck( JET_errInvalidParameter );
			}
			
		err = ErrDBUTLIDeleteNode( ppib, ifmp, pgno, iline, pcprintf );
		return err;
		}
	if( 3 == cszCommand
		&& _stricmp( rgszCommand[0], "exthdr" ) == 0 )
		{		
		char * pchEnd;
		const PGNO pgno = strtoul( rgszCommand[1], &pchEnd, 0 );
		if( pgnoNull == pgno
			|| 0 != *pchEnd )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}
			
		DATA	data;
		CallR( ErrDBUTLISzToData( rgszCommand[2], &data ) );
		err = ErrDBUTLISetExternalHeader( ppib, ifmp, pgno, data, pcprintf );		
		OSMemoryHeapFree( data.Pv() );
		
		return err;
		}
	if( 3 == cszCommand
		&& _stricmp( rgszCommand[0], "pgnonext" ) == 0 )
		{
		char * pchEnd;
		const PGNO pgno = strtoul( rgszCommand[1], &pchEnd, 0 );
		if( pgnoNull == pgno
			|| 0 != *pchEnd )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}
		const PGNO pgnoNext = strtoul( rgszCommand[2], NULL, 0 );
		if( 0 != *pchEnd )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}
		err = ErrDBUTLISetPgnoNext( ppib, ifmp, pgno, pgnoNext, pcprintf );				
		return err;
		}
	if( 3 == cszCommand
		&& _stricmp( rgszCommand[0], "pgnoprev" ) == 0 )
		{
		char * pchEnd;
		const PGNO pgno = strtoul( rgszCommand[1], &pchEnd, 0 );
		if( pgnoNull == pgno
			|| 0 != *pchEnd )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}
		const PGNO pgnoPrev = strtoul( rgszCommand[2], NULL, 0 );
		if( 0 != *pchEnd )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}
		err = ErrDBUTLISetPgnoPrev( ppib, ifmp, pgno, pgnoPrev, pcprintf );				
		return err;
		}
	if( 3 == cszCommand
		&& _stricmp( rgszCommand[0], "pageflags" ) == 0 )
		{
		char * pchEnd;
		const PGNO pgno = strtoul( rgszCommand[1], &pchEnd, 0 );
		if( pgnoNull == pgno
			|| 0 != *pchEnd )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}
		const ULONG fFlags = strtoul( rgszCommand[2], NULL, 0 );
		if( 0 != *pchEnd )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}
		err = ErrDBUTLISetPageFlags( ppib, ifmp, pgno, fFlags, pcprintf );				
		return err;
		}
	if( 1 == cszCommand
		&& _stricmp( rgszCommand[0], "help" ) == 0 )
		{
		(*pcprintf)( "insert <pgno>:<iline> <data>  -  insert a node\r\n" );
		(*pcprintf)( "replace <pgno>:<iline> <data>  -  replace a node\r\n" );
		(*pcprintf)( "delete <pgno>:<iline>  -  delete a node\r\n" );
		(*pcprintf)( "setflags <pgno>:<iline> <flags>  -  set flags on a node\r\n" );
		(*pcprintf)( "exthdr <pgno> <data>  -  set external header\r\n" );
		(*pcprintf)( "pgnonext <pgno> <pgnonext>  -  set pgnonext on a page\r\n" );
		(*pcprintf)( "pgnoprev <pgno> <pgnoprev>  -  set pgnoprev on a page\r\n" );
		(*pcprintf)( "pageflags <pgno> <flags>  -  set flags on a page\r\n" );
		}
	else
		{
		(*pcprintf)( "unknown command \"%s\"\r\n", rgszCommand[0] );
		return ErrERRCheck( JET_errInvalidParameter );
		}

	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLDumpOneColumn( PIB * ppib, FUCB * pfucbCatalog, VOID * pfnCallback, VOID * pvCallback )
//  ================================================================
	{
	JET_RETRIEVECOLUMN	rgretrievecolumn[10];
	COLUMNDEF			columndef;
	ERR					err				= JET_errSuccess;
	INT					iretrievecolumn	= 0;

	memset( rgretrievecolumn, 0, sizeof( rgretrievecolumn ) );
	memset( &columndef, 0, sizeof( columndef ) );

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Name;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)columndef.szName;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( columndef.szName );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Id;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&( columndef.columnid );
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( columndef.columnid );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Coltyp;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&( columndef.coltyp );
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( columndef.coltyp );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Localization;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&( columndef.cp );
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( columndef.cp );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Flags;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&( columndef.fFlags );
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( columndef.fFlags );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_SpaceUsage;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&( columndef.cbLength );
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( columndef.cbLength );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_RecordOffset;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&( columndef.ibRecordOffset );
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( columndef.ibRecordOffset );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Callback;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&( columndef.szCallback );
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( columndef.szCallback );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_CallbackData;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&( columndef.rgbCallbackData );
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( columndef.rgbCallbackData );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_DefaultValue;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)columndef.rgbDefaultValue;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( columndef.rgbDefaultValue );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	CallR( ErrIsamRetrieveColumns(
				(JET_SESID)ppib,
				(JET_TABLEID)pfucbCatalog,
				rgretrievecolumn,
				iretrievecolumn ) );

	// WARNING: if the order of rgretrievecolumn initialization is changed above this must change too
	columndef.cbDefaultValue 	= rgretrievecolumn[iretrievecolumn-1].cbActual;
	columndef.cbCallbackData 	= rgretrievecolumn[iretrievecolumn-2].cbActual;

	columndef.fFixed 			= !!FFixedFid( FidOfColumnid( columndef.columnid ) );
	columndef.fVariable 		= !!FVarFid( FidOfColumnid( columndef.columnid ) );
	columndef.fTagged			= !!FTaggedFid( FidOfColumnid( columndef.columnid ) );

	const FIELDFLAG	ffield		= FIELDFLAG( columndef.fFlags );
	columndef.fVersion 			= !!FFIELDVersion( ffield );
	columndef.fNotNull 			= !!FFIELDNotNull( ffield );
	columndef.fMultiValue 		= !!FFIELDMultivalued( ffield );
	columndef.fAutoIncrement	= !!FFIELDAutoincrement( ffield );
	columndef.fDefaultValue		= !!FFIELDDefault( ffield );
	columndef.fEscrowUpdate		= !!FFIELDEscrowUpdate( ffield );
	columndef.fVersioned		= !!FFIELDVersioned( ffield );
	columndef.fDeleted			= !!FFIELDDeleted( ffield );
	columndef.fFinalize			= !!FFIELDFinalize( ffield );
	columndef.fDeleteOnZero		= !!FFIELDDeleteOnZero( ffield );
	columndef.fUserDefinedDefault		= !!FFIELDUserDefinedDefault( ffield );
	columndef.fTemplateColumnESE98		= !!FFIELDTemplateColumnESE98( ffield );
	columndef.fPrimaryIndexPlaceholder	= !!FFIELDPrimaryIndexPlaceholder( ffield );

	PFNCOLUMN const	pfncolumn	= (PFNCOLUMN)pfnCallback;
	return (*pfncolumn)( &columndef, pvCallback );
	}


//  ================================================================
LOCAL ERR ErrDBUTLDumpOneCallback( PIB * ppib, FUCB * pfucbCatalog, VOID * pfnCallback, VOID * pvCallback )
//  ================================================================
	{
	JET_RETRIEVECOLUMN	rgretrievecolumn[3];
	CALLBACKDEF			callbackdef;
	ERR					err				= JET_errSuccess;
	INT					iretrievecolumn	= 0;

	memset( rgretrievecolumn, 0, sizeof( rgretrievecolumn ) );
	memset( &callbackdef, 0, sizeof( callbackdef ) );

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Name;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)callbackdef.szName;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( callbackdef.szName );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Flags;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&( callbackdef.cbtyp );
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( callbackdef.cbtyp );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Callback;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)callbackdef.szCallback;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( callbackdef.szCallback );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	CallR( ErrIsamRetrieveColumns(
				(JET_SESID)ppib,
				(JET_TABLEID)pfucbCatalog,
				rgretrievecolumn,
				iretrievecolumn ) );

	PFNCALLBACKFN const	pfncallback	= (PFNCALLBACKFN)pfnCallback;
	return (*pfncallback)( &callbackdef, pvCallback );
	}


//  ================================================================
LOCAL ERR ErrDBUTLDumpPage( PIB * ppib, IFMP ifmp, PGNO pgno, PFNPAGE pfnpage, VOID * pvCallback )
//  ================================================================
	{
	ERR	err = JET_errSuccess;
	CSR	csr;	
	Call( csr.ErrGetReadPage( ppib, ifmp, pgno, bflfNoTouch ) );

	PAGEDEF	pagedef;

	pagedef.dbtime		= csr.Cpage().Dbtime();
	pagedef.pgno		= csr.Cpage().Pgno();
	pagedef.objidFDP	= csr.Cpage().ObjidFDP();
	pagedef.pgnoNext	= csr.Cpage().PgnoNext();
	pagedef.pgnoPrev	= csr.Cpage().PgnoPrev();
	
	pagedef.pbRawPage	= reinterpret_cast<BYTE *>( csr.Cpage().PvBuffer() );

	pagedef.cbFree		= csr.Cpage().CbFree();
	pagedef.cbUncommittedFree	= csr.Cpage().CbUncommittedFree();
	pagedef.clines		= SHORT( csr.Cpage().Clines() );

	pagedef.fFlags			= csr.Cpage().FFlags();

	pagedef.fLeafPage		= !!csr.Cpage().FLeafPage();
	pagedef.fInvisibleSons	= !!csr.Cpage().FInvisibleSons();
	pagedef.fRootPage		= !!csr.Cpage().FRootPage();
	pagedef.fPrimaryPage	= !!csr.Cpage().FPrimaryPage();
	pagedef.fParentOfLeaf	= !!csr.Cpage().FParentOfLeaf();

	if( pagedef.fInvisibleSons )
		{
		Assert( !pagedef.fLeafPage );
		
		INT iline;
		for( iline = 0; iline < pagedef.clines; iline++ )
			{
			KEYDATAFLAGS	kdf;
			
			csr.SetILine( iline );
			NDIGetKeydataflags( csr.Cpage(), csr.ILine(), &kdf );

			Assert( kdf.data.Cb() == sizeof( PGNO ) );
			pagedef.rgpgnoChildren[iline] = *((UnalignedLittleEndian< PGNO > *)kdf.data.Pv() );
			}
		pagedef.rgpgnoChildren[pagedef.clines] = pgnoNull;
		}
	else
		{
		Assert( pagedef.fLeafPage );
		}

	Call( (*pfnpage)( &pagedef, pvCallback ) );

HandleError:
	csr.ReleasePage();
	return err;
	}

//  ================================================================
LOCAL INT PrintCallback( const CALLBACKDEF * pcallbackdef, void * )
//  ================================================================
	{
	//  this will only compile if the signatures match
	PFNCALLBACKFN pfncallback = PrintCallback;
	
	char szCbtyp[255];
	szCbtyp[0] = 0;

	if( JET_cbtypNull == pcallbackdef->cbtyp )
		{
		strcat( szCbtyp, "NULL" );
		}
	if(	pcallbackdef->cbtyp & JET_cbtypFinalize )
		{
		strcat( szCbtyp, "Finalize|" );
		}
	if(	pcallbackdef->cbtyp & JET_cbtypBeforeInsert )
		{
		strcat( szCbtyp, "BeforeInsert|" );
		}
	if(	pcallbackdef->cbtyp & JET_cbtypAfterInsert )
		{
		strcat( szCbtyp, "AfterInsert|" );
		}
	if(	pcallbackdef->cbtyp & JET_cbtypBeforeReplace )
		{
		strcat( szCbtyp, "BeforeReplace|" );
		}
	if(	pcallbackdef->cbtyp & JET_cbtypAfterReplace )
		{
		strcat( szCbtyp, "AfterReplace|" );
		}
	if(	pcallbackdef->cbtyp & JET_cbtypBeforeDelete )
		{
		strcat( szCbtyp, "BeforeDelete|" );
		}
	if(	pcallbackdef->cbtyp & JET_cbtypAfterDelete )
		{
		strcat( szCbtyp, "AfterDelete|" );
		}
	szCbtyp[strlen( szCbtyp ) - 1] = 0;

	printf( "    %2.2d (%s)   %s\n", pcallbackdef->cbtyp, szCbtyp, pcallbackdef->szCallback );
	return 0;
	}


//  ================================================================
LOCAL INT PrintIndexMetaData( const INDEXDEF * pindexdef, void * )
//  ================================================================
	{
	//  this will only compile if the signatures match
	PFNINDEX pfnindex = PrintIndexMetaData;
	
	Assert( pindexdef );
	
	printf( "    %-15.15s  ", pindexdef->szName );
	DBUTLPrintfIntN( pindexdef->pgnoFDP, 8 );
	printf( "  " );
	DBUTLPrintfIntN( pindexdef->objidFDP, 8 );
	printf( "  " );
	DBUTLPrintfIntN( pindexdef->density, 6 );
	printf( "%%\n" );

	if ( pindexdef->fUnique )					
		printf( "        Unique=yes\n" );		
	if ( pindexdef->fPrimary )
		printf( "        Primary=yes\n" );
	if ( pindexdef->fTemplateIndex )
		printf( "        Template=yes\n" );
	if ( pindexdef->fDerivedIndex )
		printf( "        Derived=yes\n" );
	if ( pindexdef->fNoNullSeg )
		printf( "        Disallow Null=yes\n" );
	if ( pindexdef->fAllowAllNulls )
		printf( "        Allow All Nulls=yes\n" );
	if ( pindexdef->fAllowFirstNull )
		printf( "        Allow First Null=yes\n" );
	if ( pindexdef->fAllowSomeNulls )
		printf( "        Allow Some Nulls=yes\n" );
	if ( pindexdef->fSortNullsHigh )
		printf( "        Sort Nulls High=yes\n" );
	if ( pindexdef->fMultivalued )
		printf( "        Multivalued=yes\n" );
	if ( pindexdef->fTuples )
		{
		printf( "        Tuples=yes\n" );
		printf( "            LengthMin=%d\n", pindexdef->le_tuplelimits.le_chLengthMin );
		printf( "            LengthMax=%d\n", pindexdef->le_tuplelimits.le_chLengthMax );
		printf( "            ToIndexMax=%d\n", pindexdef->le_tuplelimits.le_chToIndexMax );
		}
	if ( pindexdef->fLocalizedText )
		{
		QWORD	qwCurrSortVersion;

		printf( "        Localized Text=yes\n" );
		printf( "            Locale Id=%d\n", pindexdef->lcid );
		printf( "            LCMap flags=0x%08x\n", pindexdef->dwMapFlags );

		//	try to report current sort version
		//
		if ( JET_errSuccess == ErrNORMGetSortVersion( pindexdef->lcid, &qwCurrSortVersion ) )
			{
			printf( "            NLSVersion=%d (current OS: %d)\n", pindexdef->dwNLSVersion, DWORD( ( qwCurrSortVersion >> 32 ) & 0xFFFFFFFF ) );
			printf( "            DefinedVersion=%d (current OS: %d)\n", pindexdef->dwDefinedVersion, DWORD( qwCurrSortVersion & 0xFFFFFFFF ) );
			}
		else
			{
			printf( "            NLSVersion=%d (current OS: <unknown>)\n", pindexdef->dwNLSVersion );
			printf( "            DefinedVersion=%d (current OS: <unknown>)\n", pindexdef->dwDefinedVersion );
			}

		if( pindexdef->fUnicodeFixupOn )
			{
			printf( "            Unicode fixup enabled\n" );
			}
		}
	if ( pindexdef->fExtendedColumns )
		printf( "        Extended Columns=yes\n" );
	printf( "        Flags=0x%08x\n", pindexdef->fFlags );

	UINT isz;		

	Assert( pindexdef->ccolumnidDef > 0 );
	if ( pindexdef->fExtendedColumns )
		{
		printf( "        Key Segments (%d)\n", pindexdef->ccolumnidDef );
		printf(	"        -----------------\n" );
		}
	else
		{
		printf( "        Key Segments (%d - ESE97 format)\n", pindexdef->ccolumnidDef );
		printf(	"        --------------------------------\n" );
		}
	for( isz = 0; isz < pindexdef->ccolumnidDef; isz++ )
		{
		printf( "            %-15.15s (0x%08x)\n", pindexdef->rgszIndexDef[isz], pindexdef->rgidxsegDef[isz].Columnid() );
		}

	if( pindexdef->ccolumnidConditional > 0 )
		{
		if ( pindexdef->fExtendedColumns )
			{
			printf( "        Conditional Columns (%d)\n", pindexdef->ccolumnidConditional );
			printf(	"        ------------------------\n" );
			}
		else
			{
			printf( "        Conditional Columns (%d - ESE97 format)\n", pindexdef->ccolumnidConditional );
			printf(	"        ---------------------------------------\n" );
			}
		for( isz = 0; isz < pindexdef->ccolumnidConditional; isz++ )
			{
			printf( "            %-15.15s (0x%08x,%s)\n",
					( pindexdef->rgszIndexConditional[isz] ) + 1,
					pindexdef->rgidxsegConditional[isz].Columnid(),
					( pindexdef->rgidxsegConditional[isz] ).FMustBeNull() ? "JET_bitIndexColumnMustBeNull" : "JET_bitIndexColumnMustBeNonNull" );
			}
		}

	return 0;
	}

	
//  ================================================================
LOCAL INT PrintColumn( const COLUMNDEF * pcolumndef, void * )
//  ================================================================
	{
	//  this will only compile if the signatures match
	PFNCOLUMN pfncolumn = PrintColumn;	

	Assert( pcolumndef );
	
	printf( "    %-15.15s ", pcolumndef->szName );
	DBUTLPrintfIntN( pcolumndef->columnid, 9 );

	const CHAR * szType;
	const CHAR * szFVT;
	CHAR szUnknown[50];

	if( pcolumndef->fFixed )
		{
		szFVT = "(F)";
		}
	else if( pcolumndef->fTagged )
		{
		szFVT = "(T)";
		}
	else
		{
		szFVT = "";
		}
		
	switch ( pcolumndef->coltyp )
		{
		case JET_coltypBit:
			szType = "Bit";
			break;
			
		case JET_coltypUnsignedByte:
			szType = "UnsignedByte";
			break;

		case JET_coltypShort:
			szType = "Short";
			break;

		case JET_coltypLong:
			szType = "Long";
			break;
			
		case JET_coltypCurrency:
			szType = "Currency";
			break;

		case JET_coltypIEEESingle:
			szType = "IEEESingle";
			break;
			
		case JET_coltypIEEEDouble:
			szType = "IEEEDouble";
			break;
			
		case JET_coltypDateTime:
			szType = "DateTime";
			break;
			
		case JET_coltypBinary:
			szType = "Binary";
			break;

		case JET_coltypText:
			szType = "Text";
			break;

		case JET_coltypLongBinary:
			szType = "LongBinary";
			break;

		case JET_coltypLongText:
			szType = "LongText";
			break;

		case JET_coltypSLV:
			szType = "SLV";
			break;

		case JET_coltypNil:
			szType = "Deleted";
			break;
			
		default:
			LOSSTRFormatA( szUnknown, "???(%d)", pcolumndef->coltyp );
			szType = szUnknown;
			break;
		}

		printf("  %-12.12s%3.3s ", szType, szFVT );
		DBUTLPrintfIntN( pcolumndef->cbLength, 7 );
		
		if ( 0 != pcolumndef->cbDefaultValue )
			{
			printf( "  Yes" );
			}
		printf( "\n" );
		
		if ( FRECTextColumn( pcolumndef->coltyp ) )
			{
			printf( "        Code Page=%d\n", pcolumndef->cp );
			}
			
		if ( pcolumndef->fVersion )
			printf( "        Version=yes\n" );
		if ( pcolumndef->fNotNull )
			printf( "        Disallow Null=yes\n" );
		if ( pcolumndef->fMultiValue )
			printf( "        Multi-value=yes\n" );
		if ( pcolumndef->fAutoIncrement )
			printf( "        Auto-increment=yes\n" );
		if ( pcolumndef->fEscrowUpdate )
			printf( "        EscrowUpdate=yes\n" );
		if ( pcolumndef->fFinalize )
			printf( "        Finalize=yes\n" );
		if ( pcolumndef->fDeleteOnZero )
			printf( "        DeleteOnZero=yes\n" );
		if ( pcolumndef->fDefaultValue )
			{
			printf( "        DefaultValue=yes\n" );
			printf( "                Length=%d bytes\n", pcolumndef->cbDefaultValue );        
			}
		if ( pcolumndef->fUserDefinedDefault )
			{
			printf( "        User-defined Default=yes\n" );
			printf( "                Callback=%s\n", pcolumndef->szCallback );        
			printf( "                CallbackData=%d bytes\n", pcolumndef->cbCallbackData );        
			}
		if ( pcolumndef->fTemplateColumnESE98 )
			printf( "        TemplateColumnESE98=yes\n" );
		if ( pcolumndef->fPrimaryIndexPlaceholder )
			printf( "        PrimaryIndexPlaceholder=yes\n" );

		printf( "        Flags=0x%x\n", pcolumndef->fFlags );

	return 0;
	}


//  ================================================================
LOCAL INT PrintTableMetaData( const TABLEDEF * ptabledef, void * pv )
//  ================================================================
	{
	//  this will only compile if the signatures match
	PFNTABLE pfntable = PrintTableMetaData;

	Assert( ptabledef );
	JET_DBUTIL * pdbutil = (JET_DBUTIL *)pv;

	printf( "Table Name        PgnoFDP  ObjidFDP    PgnoLV   ObjidLV     Pages  Density\n"
			"==========================================================================\n"
			"%-15.15s  ", ptabledef->szName );
	DBUTLPrintfIntN( ptabledef->pgnoFDP, 8 );
	printf( "  " );
	DBUTLPrintfIntN( ptabledef->objidFDP, 8 );
	printf( "  " );
	DBUTLPrintfIntN( ptabledef->pgnoFDPLongValues, 8 );
	printf( "  " );
	DBUTLPrintfIntN( ptabledef->objidFDPLongValues, 8 );
	printf( "  " );
	DBUTLPrintfIntN( ptabledef->pages, 8 );
	printf( "  " );
	DBUTLPrintfIntN( ptabledef->density, 6 );
	printf( "%%\n" );

	if ( ptabledef->fFlags & JET_bitObjectSystem )
		printf( "    System Table=yes\n" );
	if ( ptabledef->fFlags & JET_bitObjectTableFixedDDL )
		printf( "    FixedDDL=yes\n" );
	if ( ptabledef->fFlags & JET_bitObjectTableTemplate )
		printf( "    Template=yes\n" );

	if ( NULL != ptabledef->szTemplateTable
		&& '\0' != ptabledef->szTemplateTable[0] )
		{
		Assert( ptabledef->fFlags & JET_bitObjectTableDerived );
		printf( "    Derived From: %5s\n", ptabledef->szTemplateTable );
		}
	else
		{
		Assert( !( ptabledef->fFlags & JET_bitObjectTableDerived ) );
		}

	JET_DBUTIL	dbutil;
	ERR			err 	= JET_errSuccess;

	printf( "    Column Name     Column Id  Column Type      Length  Default\n"
			"    -----------------------------------------------------------\n" );

	memset( &dbutil, 0, sizeof( dbutil ) );
	
	dbutil.cbStruct		= sizeof( dbutil );
	dbutil.op 			= opDBUTILEDBDump;
	dbutil.sesid		= pdbutil->sesid;
	dbutil.dbid			= pdbutil->dbid;	
	dbutil.pgno			= ptabledef->objidFDP;
	dbutil.pfnCallback	= (void *)PrintColumn;
	dbutil.pvCallback	= &dbutil;
	dbutil.edbdump		= opEDBDumpColumns;

	err = ErrDBUTLDump( pdbutil->sesid, &dbutil );

	printf( "    Index Name        PgnoFDP  ObjidFDP  Density\n"
			"    --------------------------------------------\n" );

	memset( &dbutil, 0, sizeof( dbutil ) );
	
	dbutil.cbStruct		= sizeof( dbutil );
	dbutil.op 			= opDBUTILEDBDump;
	dbutil.sesid		= pdbutil->sesid;
	dbutil.dbid			= pdbutil->dbid;	
	dbutil.pgno			= ptabledef->objidFDP;
	dbutil.pfnCallback	= (void *)PrintIndexMetaData;
	dbutil.pvCallback	= &dbutil;
	dbutil.edbdump		= opEDBDumpIndexes;

	err = ErrDBUTLDump( pdbutil->sesid, &dbutil );

	printf( "    Callback Type        Callback\n"
			"    --------------------------------------------\n" );

	memset( &dbutil, 0, sizeof( dbutil ) );
	
	dbutil.cbStruct		= sizeof( dbutil );
	dbutil.op 			= opDBUTILEDBDump;
	dbutil.sesid		= pdbutil->sesid;
	dbutil.dbid			= pdbutil->dbid;	
	dbutil.pgno			= ptabledef->objidFDP;
	dbutil.pfnCallback	= (void *)PrintCallback;
	dbutil.pvCallback	= &dbutil;
	dbutil.edbdump		= opEDBDumpCallbacks;

	err = ErrDBUTLDump( pdbutil->sesid, &dbutil );

	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLDumpNode( IFileSystemAPI *const pfsapi, const CHAR * const szFile, const PGNO pgno, const INT iline, const  JET_GRBIT grbit )
//  ================================================================
	{
	ERR 			err			= JET_errSuccess;
	KEYDATAFLAGS	kdf;
	CPAGE 			cpage;
	IFileAPI*		pfapi		= NULL;
	QWORD			ibOffset	= OffsetOfPgno( pgno );
	VOID*			pvPage		= NULL;
	CHAR*			szBuf		= NULL;
	const INT		cbWidth		= UtilCprintfStdoutWidth() >= 116 ? 32 : 16;

	pvPage = PvOSMemoryPageAlloc( g_cbPage, NULL );
	if( NULL == pvPage )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	err = pfsapi->ErrFileOpen( szFile, &pfapi, fTrue );
	if ( err < 0 )
		{
		printf( "Cannot open file %s.\n\n", szFile );
		Call( err );
		}
	Call( pfapi->ErrIORead( ibOffset, g_cbPage, (BYTE* const)pvPage ) );

	cpage.LoadPage( pvPage );

	if ( iline < 0 || iline >= cpage.Clines() )
		{
		printf( "Invalid iline: %d\n\n", iline );
		Call( ErrERRCheck( JET_errInvalidParameter ) );
		}

	if ( !cpage.FNewRecordFormat()
		&& cpage.FPrimaryPage()
		&& !cpage.FRepairedPage()
		&& cpage.FLeafPage()
		&& !cpage.FSpaceTree()
		&& !cpage.FLongValuePage()
		&& !cpage.FSLVAvailPage()
		&& !cpage.FSLVOwnerMapPage() )
		{
		VOID *	pvBuf	= PvOSMemoryPageAlloc( g_cbPage, NULL );

		if( NULL == pvBuf )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}

		err = ErrUPGRADEConvertNode( &cpage, iline, pvBuf );
		OSMemoryPageFree( pvBuf );
		Call( err );
		}

	NDIGetKeydataflags( cpage, iline, &kdf );

	printf( "     Flags:  0x%4.4x\n", kdf.fFlags );
	printf( "===========\n" );
	if( FNDVersion( kdf ) )
		{
		printf( "            Versioned\n" );
		}
	if( FNDDeleted( kdf ) )
		{
		printf( "            Deleted\n" );
		}
	if( FNDCompressed( kdf ) )
		{
		printf( "            Compressed\n" );
		}
	printf( "\n" );

	szBuf = (CHAR *)PvOSMemoryPageAlloc( g_cbPage * 8, NULL );
	if( NULL == szBuf )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	printf( "Key Prefix:  %4d bytes\n", kdf.key.prefix.Cb() );
	printf( "===========\n" );
	szBuf[0] = 0;
	DBUTLSprintHex( szBuf, reinterpret_cast<BYTE *>( kdf.key.prefix.Pv() ), kdf.key.prefix.Cb(), cbWidth );
	printf( "%s\n", szBuf );
	printf( "Key Suffix:  %4d bytes\n", kdf.key.suffix.Cb() );
	printf( "===========\n" );
	szBuf[0] = 0;
	DBUTLSprintHex( szBuf, reinterpret_cast<BYTE *>( kdf.key.suffix.Pv() ), kdf.key.suffix.Cb(), cbWidth );
	printf( "%s\n", szBuf );
	printf( "      Data:  %4d bytes\n", kdf.data.Cb() );
	printf( "===========\n" );
	szBuf[0] = 0;
	DBUTLSprintHex( szBuf, reinterpret_cast<BYTE *>( kdf.data.Pv() ), kdf.data.Cb(), cbWidth );
	printf( "%s\n", szBuf );

	printf( "\n\n" );

	if( !cpage.FLeafPage() )
		{
		if( sizeof( PGNO ) == kdf.data.Cb() )
			{
			const PGNO pgno = *(reinterpret_cast<UnalignedLittleEndian< PGNO > *>( kdf.data.Pv() ) );
			printf( "pgnoChild = %d (0x%x)\n", pgno, pgno );
			}
		}
	else if( cpage.FSpaceTree() )
		{
		PGNO pgno;
		LongFromKey( &pgno, kdf.key );
		const CPG cpg = *(reinterpret_cast<UnalignedLittleEndian< CPG > *>( kdf.data.Pv() ) );
		printf( "%d (0x%x) pages ending at %d (0x%x)\n", cpg, cpg, pgno, pgno );
		}
	else if( cpage.FPrimaryPage() )
		{
		if( cpage.FLongValuePage() )
			{
			//  UNDONE: dump this
			}
		else if( cpage.FSLVAvailPage() )
			{
#ifdef DISABLE_SLV
			Call( ErrERRCheck( JET_wrnNyi ) );
#else
#define SLVAVAIL_PAGESTATUS_PER_ROW  32
			char * 	szState[] 	= { "F", "R", "D", "C" };			
			PGNO 	pgnoLast 	= pgnoNull;
			PGNO 	pgnoFirst 	= pgnoNull;

			Assert( sizeof( SLVSPACENODE ) == kdf.data.Cb() );
			SLVSPACENODE * const pslvspacenode = (SLVSPACENODE *)kdf.data.Pv();
			ASSERT_VALID( pslvspacenode );
			
			LongFromKey( &pgnoLast, kdf.key );
			printf( "SLV-Avail node: %d pages ending at %d, %d free",
						SLVSPACENODE::cpageMap,
						pgnoLast,
						pslvspacenode->CpgAvail() );
			Assert ( pgnoLast >= SLVSPACENODE::cpageMap);
			pgnoFirst = pgnoLast - SLVSPACENODE::cpageMap + 1;

			for (CPG cpg = 0; SLVSPACENODE::cpageMap > cpg ; cpg++ )
				{
				const SLVSPACENODE::STATE state = pslvspacenode->GetState( cpg );					
				if ( 0 == cpg % SLVAVAIL_PAGESTATUS_PER_ROW)
					{
					printf( "\n%6d -%6d : ", pgnoFirst + cpg, pgnoFirst + cpg + SLVAVAIL_PAGESTATUS_PER_ROW - 1);
					}
				printf( "%s", szState[ state ] );				
				}
#endif	//	DISABLE_SLV
			}
		else if( cpage.FSLVOwnerMapPage() )
			{
#ifdef DISABLE_SLV
			Call( ErrERRCheck( JET_wrnNyi ) );
#else
			KEYDATAFLAGS * pNode = &kdf;

			PGNO pgno;
			Assert ( sizeof(PGNO) == pNode->key.Cb() );
			LongFromKey( &pgno, pNode->key);

			SLVOWNERMAP slvownermapT;
			slvownermapT.Retrieve( pNode->data );
			
			const BYTE * pvKey = (const BYTE *)slvownermapT.PvKey();

			if ( slvownermapT.FValidChecksum() )
				{
				printf(
					"SLV-SpaceMap node: pgno:%u objid:%d fid:%d checksum:%lX cb:%d pv:",
					pgno,
					slvownermapT.Objid(), 
					slvownermapT.Columnid(), 
					slvownermapT.UlChecksum(), 
					slvownermapT.CbKey() );	
				}
			else
				{
				printf(
					"SLV-SpaceMap node: pgno:%u objid:%d fid:%d checksum:<invalid> cb:%d pv:",
					pgno, 
					slvownermapT.Objid(), 
					slvownermapT.Columnid(), 
					slvownermapT.CbKey() );
				}
				
			for ( ULONG i = 0; i < slvownermapT.CbKey(); i++)
				{
				printf( "%02X ", pvKey[i] );
				}
#endif	//	DISABLE_SLV
			}
		else
			{
			DBUTLDumpRec( kdf.data.Pv(), kdf.data.Cb(), CPRINTFSTDOUT::PcprintfInstance(), cbWidth );
			}
		}
	
HandleError:
	cpage.UnloadPage();
	OSMemoryPageFree( szBuf );
	OSMemoryPageFree( pvPage );
	delete pfapi;
	return err;
	}


LOCAL BOOL FDBUTLConvertHexDigit_(
	const CHAR		cHexDigit,
	CHAR * const	pcHexValue )
	{
	if ( cHexDigit >= '0' && cHexDigit <= '9' )
		{
		*pcHexValue = cHexDigit - '0';
		return fTrue;
		}
	else if ( cHexDigit >= 'A' && cHexDigit <= 'F' )
		{
		*pcHexValue = cHexDigit - 'A' + 0xa;
		return fTrue;
		}
	else if ( cHexDigit >= 'a' && cHexDigit <= 'f' )
		{
		*pcHexValue = cHexDigit - 'a' + 0xa;
		return fTrue;
		}
	else
		{
		return fFalse;
		}
	}

LOCAL BOOL FDBUTLPrintedKeyToRealKey(
	const CHAR * const	szPrintedKey,
	CHAR * const		szKey,
	const ULONG			cbKey )
	{
	for ( ULONG i = 0; i < cbKey; i++ )
		{
		const ULONG		j			 = i * 2;
		CHAR			cHighNibble;
		CHAR			cLowNibble;

		if ( 0 == i )
			{
			printf( "%c%c", szPrintedKey[j], szPrintedKey[j+1] );
			}
		else
			{
			printf( " %c%c", szPrintedKey[j], szPrintedKey[j+1] );
			}

		if ( !FDBUTLConvertHexDigit_( szPrintedKey[j], &cHighNibble )
			|| !FDBUTLConvertHexDigit_( szPrintedKey[j+1], &cLowNibble ) )
			{
			return fFalse;
			}

		szKey[i] = ( cHighNibble << 4 ) + cLowNibble;
		}

	return fTrue;
	}

LOCAL ERR ErrDBUTLSeekToKey_(
	IFileAPI *			pfapi,
	CPAGE&				cpage,
	VOID * const		pvPageBuf,
	const CHAR * const	szPrintedKey,
	const CHAR * const	szPrintedData )
	{
	ERR					err;
	CHAR				szKey[JET_cbKeyMost];
	CHAR				szData[JET_cbKeyMost];
	const ULONG			cbPrintedKey		= (ULONG)strlen( szPrintedKey );
	const ULONG			cbPrintedData		= ( NULL != szPrintedData ? (ULONG)strlen( szPrintedData ) : 0 );
	BOOKMARK			bm;
	INT					compare;
	INT					iline;

	//	validate key length
	//
	if ( cbPrintedKey % 2 != 0
		|| cbPrintedKey > ( JET_cbKeyMost * 2 )
		|| cbPrintedData % 2 != 0
		|| cbPrintedData > ( JET_cbKeyMost * 2 ) )
		{
		return ErrERRCheck( JET_errInvalidBookmark );
		}

	printf( " Seek bookmark: \"" );

	bm.Nullify();
	bm.key.suffix.SetPv( szKey );
	bm.key.suffix.SetCb( cbPrintedKey / 2 );

	//	only use data portion of bookmark if we're on a btree
	//	with non-unique keys
	//
	if ( cpage.FNonUniqueKeys() && 0 != cbPrintedData )
		{
		bm.data.SetPv( szData );
		bm.data.SetCb( cbPrintedData / 2 );
		}

	//	first, convert the printed key to a real key
	//
	if ( !FDBUTLPrintedKeyToRealKey(
				szPrintedKey,
				szKey,
				bm.key.suffix.Cb() ) )
		{
		printf( "...\"\n\n" );
		return ErrERRCheck( JET_errInvalidBookmark );
		}

	//	next, convert the printed data (if any) to a real data
	//
	if ( bm.data.Cb() > 0 )
		{
		//	print a key/data separator
		//
		printf( " | " );

		if ( !FDBUTLPrintedKeyToRealKey(
					szPrintedData,
					szData,
					bm.data.Cb() ) )
			{
			printf( "...\"\n\n" );
			return ErrERRCheck( JET_errInvalidBookmark );
			}
		}

	printf( "\"\n" );

	//	now seek down the btree for the bookmark
	//
	while ( !cpage.FLeafPage() )
		{
		iline = IlineNDISeekGEQInternal( cpage, bm, &compare );

		if ( 0 == compare )
			{
			//	see ErrNDISeekInternalPage() for an
			//	explanation of why we increment by 1 here
			//
			iline++;
			}

		printf( "    pgno/iline: %d-%d  (", cpage.Pgno(), iline );
		if ( cpage.FRootPage() )
			printf( "root," );
		if ( cpage.FParentOfLeaf() )
			printf( "parent-of-leaf" );
		else
			printf( "internal" );
		printf( ")\n" );

		KEYDATAFLAGS	kdf;
		NDIGetKeydataflags( cpage, iline, &kdf );

		if ( sizeof(PGNO) != kdf.data.Cb() )
			{
			printf( "\n" );
			return ErrERRCheck( JET_errBadPageLink );
			}

		const PGNO	pgnoChild	= *(UnalignedLittleEndian< PGNO > *)kdf.data.Pv();

		cpage.UnloadPage();

		err = pfapi->ErrIORead( OffsetOfPgno( pgnoChild ), g_cbPage, (BYTE* const)pvPageBuf );
		if ( err < 0 )
			{
			printf( "\n" );
			return err;
			}

		cpage.LoadPage( pvPageBuf );
		}

	//	find the first node in the leaf page that's
	//	greater than or equal to the specified bookmark
	//
	iline = IlineNDISeekGEQ( cpage, bm, !cpage.FNonUniqueKeys(), &compare );
	Assert( iline < cpage.Clines( ) );
	if ( iline < 0 )
		{
		//	all nodes in page are less than key
		//
		iline = cpage.Clines( ) - 1;
		}

	printf( "    pgno/iline: %d-%d  (%sleaf)\n\n", cpage.Pgno(), iline, ( cpage.FRootPage() ? "root," : "" ) );

	return JET_errSuccess;
	}

#endif	//	DEBUG


//  ================================================================
LOCAL ERR ErrDBUTLDumpPage(
	IFileSystemAPI * const	pfsapi,
	const CHAR *			szFile,
	const PGNO				pgno,
	const CHAR * const		szPrintedKeyToSeek,
	const CHAR * const		szPrintedDataToSeek,
	const JET_GRBIT			grbit )
//  ================================================================
	{
	ERR 					err			= JET_errSuccess;
	IFileAPI *				pfapi		= NULL;
	CPAGE 					cpage;

	VOID * const pvPage = PvOSMemoryPageAlloc( g_cbPage, NULL );
	if( NULL == pvPage )
		{
		CallR( ErrERRCheck( JET_errOutOfMemory ) );
		}

	err = pfsapi->ErrFileOpen( szFile, &pfapi, fTrue );
	if ( err < 0 )
		{
		printf( "Cannot open file %s.\n\n", szFile );
		Call( err );
		}
	Call( pfapi->ErrIORead( OffsetOfPgno( pgno ), g_cbPage, (BYTE* const)pvPage ) );

	cpage.LoadPage( pvPage );

#ifdef DEBUG
	if ( NULL != szPrintedKeyToSeek && 0 != cpage.Clines() )
		{
		Call( ErrDBUTLSeekToKey_( pfapi, cpage, pvPage, szPrintedKeyToSeek, szPrintedDataToSeek ) );
		}
#endif

#ifdef DEBUGGER_EXTENSION
	(VOID)cpage.DumpHeader( CPRINTFSTDOUT::PcprintfInstance() );
	printf( "\n" );
	(VOID)cpage.DumpTags( CPRINTFSTDOUT::PcprintfInstance() );
	printf( "\n" );
#endif	

#ifdef DEBUG
	if( grbit & JET_bitDBUtilOptionDumpVerbose )
		{
		(VOID)cpage.DumpAllocMap( CPRINTFSTDOUT::PcprintfInstance() );
		printf( "\n" );

		const INT cbWidth = UtilCprintfStdoutWidth() >= 116 ? 32 : 16;

		CHAR * szBuf = new CHAR[g_cbPage * 8];
		if( NULL == szBuf )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}

		DBUTLSprintHex( szBuf, reinterpret_cast<BYTE *>( pvPage ), g_cbPage, cbWidth );
		printf( "%s\n", szBuf );

		delete [] szBuf;
		}
#endif		
		
HandleError:
	cpage.UnloadPage();
	delete pfapi;
	OSMemoryPageFree( pvPage );
	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLPrintSLVSpace(
	PIB* const	 	ppib,
	const IFMP		ifmp,
	CPRINTF* const	pcprintf )
//  ================================================================
	{
#ifdef DISABLE_SLV
	return ErrERRCheck( JET_wrnNyi );
#else
	ERR				err					= JET_errSuccess;
	FUCB*			pfucbSLVAvail		= pfucbNil;
	FCB* const		pfcbSLVAvail		= rgfmp[ifmp].PfcbSLVAvail();
	Assert( pfcbNil != pfcbSLVAvail );
	
	CPG				cpgTotalFree		= 0;
	CPG				cpgTotalReserved	= 0;
	CPG				cpgTotalDeleted		= 0;
	CPG				cpgTotalCommitted	= 0;
	CPG				cpgTotalUnknown		= 0;

	//  Open the SVLAvail Tree
	
	Call( ErrBTOpen( ppib, pfcbSLVAvail, &pfucbSLVAvail, fFalse ) );
	Assert( pfucbNil != pfucbSLVAvail );

	DIB dib;
	dib.pos 	= posFirst;
	dib.dirflag = fDIRNull;
	dib.pbm		= NULL;
	Call( ErrBTDown( pfucbSLVAvail, &dib, latchReadTouch ) );
	
	while( 1 )
		{
		if( sizeof( SLVSPACENODE ) != pfucbSLVAvail->kdfCurr.data.Cb() )
			{
			(*pcprintf)( "node %d:%d in the SLVAvail tree is corrupted\n",
							Pcsr( pfucbSLVAvail )->Pgno(),
							Pcsr( pfucbSLVAvail )->ILine() );
			Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
			}
			
		if( sizeof( PGNO ) != pfucbSLVAvail->kdfCurr.key.Cb() )
			{
			(*pcprintf)( "node %d:%d in the SLVAvail tree is corrupted\n",
							Pcsr( pfucbSLVAvail )->Pgno(),
							Pcsr( pfucbSLVAvail )->ILine() );
			Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
			}
		
		const SLVSPACENODE* const	pspacenode		= reinterpret_cast<SLVSPACENODE *>( pfucbSLVAvail->kdfCurr.data.Pv() );
		const CPG					cpgAvail		= pspacenode->CpgAvail();
		CPG							cpgFree			= 0;
		CPG							cpgReserved		= 0;
		CPG							cpgDeleted		= 0;
		CPG							cpgCommitted	= 0;
		CPG							cpgUnknown		= 0;
		PGNO						pgnoLast;
		UINT						i;

		for ( i = 0; i < SLVSPACENODE::cpageMap; i++ )
			{
			switch ( pspacenode->GetState( i ) )
				{
				case SLVSPACENODE::sFree:
					cpgFree++;
					cpgTotalFree++;
					break;
				case SLVSPACENODE::sReserved:
					cpgReserved++;
					cpgTotalReserved++;
					break;
				case SLVSPACENODE::sDeleted:
					cpgDeleted++;
					cpgTotalDeleted++;
					break;
				case SLVSPACENODE::sCommitted:
					cpgCommitted++;
					cpgTotalCommitted++;
					break;
				default:
					Assert( fFalse );
					cpgUnknown++;
					cpgTotalUnknown++;
					break;
				}
			}

		Assert( cpgFree == cpgAvail );
		Assert( cpgReserved + cpgDeleted + cpgCommitted == ( SLVSPACENODE::cpageMap - cpgAvail ) );
		
		LongFromKey( &pgnoLast, pfucbSLVAvail->kdfCurr.key );
		(*pcprintf)( "%-14d  %3d %3d %3d %3d  ", pgnoLast, cpgFree, cpgReserved, cpgDeleted, cpgCommitted );

		for( i = 0; i < ( SLVSPACENODE::cpageMap - cpgAvail ) / 16; ++i )
			{
			(*pcprintf)( "*" );
			}

 		(*pcprintf)( "\n" );

		err = ErrBTNext( pfucbSLVAvail, fDIRNull );
		if( JET_errNoCurrentRecord == err )
			{
			//  end of the tree
			err = JET_errSuccess;
			break;
			}
		Call( err );
		}

	printf( "============================================================================\n" );
	printf( "TOTALS:\n" );
	printf( "         Free: %12d\n", cpgTotalFree );
	printf( "     Reserved: %12d\n", cpgTotalReserved );
	printf( "      Deleted: %12d\n", cpgTotalDeleted );
	printf( "    Committed: %12d\n", cpgTotalCommitted );
	printf( "      Unknown: %12d\n", cpgTotalUnknown );
	printf( "              -------------\n" );
	printf( "               %12d\n", cpgTotalFree+cpgTotalReserved+cpgTotalDeleted+cpgTotalCommitted+cpgTotalUnknown );
	printf( "****************************************************************************\n" );


HandleError:
	if( pfucbNil != pfucbSLVAvail )
		{
		BTClose( pfucbSLVAvail );
		pfucbSLVAvail = pfucbNil;
		}
	return err;
#endif	//	DISABLE_SLV
	}

LOCAL ERR ErrDBUTLPrintSpace(
	PIB				*ppib,
	const IFMP		ifmp,
	const OBJID		objidFDP,
	const PGNO		pgnoFDP,
	CPRINTF * const	pcprintf )
	{
	ERR				err;
	FUCB			*pfucb			= pfucbNil;
	BOOL			fForceInit		= fFalse;
	SPACE_HEADER	*psph;
	CPG				rgcpgExtent[2];

	CallR( ErrBTOpen( ppib, pgnoFDP, ifmp, &pfucb ) );
	Assert( pfucbNil != pfucb );
	Assert( pfcbNil != pfucb->u.pfcb );

	if ( !pfucb->u.pfcb->FInitialized() )
		{
		Assert( pgnoSystemRoot != pgnoFDP );
		Assert( pgnoFDPMSO != pgnoFDP );
		Assert( pgnoFDPMSO_NameIndex != pgnoFDP );
		Assert( pgnoFDPMSO_RootObjectIndex != pgnoFDP );
		Assert( pfucb->u.pfcb->WRefCount() == 1 );

		//	must force FCB to initialized state to allow SPGetInfo() to
		//	open more cursors on the FCB -- this is safe because no
		//	other thread should be opening this FCB
		pfucb->u.pfcb->CreateComplete();
		fForceInit = fTrue;
		}
	else if ( pgnoSystemRoot == pgnoFDP
			|| pgnoFDPMSO == pgnoFDP
			|| pgnoFDPMSO_NameIndex == pgnoFDP
			|| pgnoFDPMSO_RootObjectIndex == pgnoFDP )
		{
		//	fine!
		}
	else
		{
		Assert( rgfmp[ifmp].FSLVAttached() );
		Assert( pfcbNil != rgfmp[ifmp].PfcbSLVAvail() );
		Assert( pfcbNil != rgfmp[ifmp].PfcbSLVOwnerMap() );
		Assert( rgfmp[ifmp].PfcbSLVAvail()->ObjidFDP() == objidFDP
			|| rgfmp[ifmp].PfcbSLVOwnerMap()->ObjidFDP() == objidFDP );
		Assert( rgfmp[ifmp].PfcbSLVAvail()->PgnoFDP() == pgnoFDP
			|| rgfmp[ifmp].PfcbSLVOwnerMap()->PgnoFDP() == pgnoFDP );
		}
	
	Call( ErrBTIGotoRoot( pfucb, latchReadNoTouch ) );
	
	NDGetExternalHeader ( pfucb );
	Assert( sizeof( SPACE_HEADER ) == pfucb->kdfCurr.data.Cb() );
	psph = reinterpret_cast <SPACE_HEADER *> ( pfucb->kdfCurr.data.Pv() );

	DBUTLPrintfIntN( objidFDP, 10 );
	printf( " " );
	DBUTLPrintfIntN( pgnoFDP, 10 );
	printf( " " );
	DBUTLPrintfIntN( psph->CpgPrimary(), 5 );
	printf( "-%c ", psph->FMultipleExtent() ? 'm' : 's' );
	BTUp( pfucb );

	Call( ErrSPGetInfo(
				ppib,
				ifmp,
				pfucb,
				(BYTE *)rgcpgExtent,
				sizeof(rgcpgExtent),
				fSPOwnedExtent|fSPAvailExtent ) );
//				pcprintf ) );
				
	DBUTLPrintfIntN( rgcpgExtent[0], 10 );
	printf( " " );
	DBUTLPrintfIntN( rgcpgExtent[1], 10 );
	printf( "\n" );

	cpgTotalAvailExt += rgcpgExtent[1];

HandleError:
	Assert( pfucbNil != pfucb );

	if ( fForceInit )
		{
		Assert( pfucb->u.pfcb->WRefCount() == 1 );

		//	force the FCB to be uninitialized so it will be purged by BTClose

		pfucb->u.pfcb->CreateComplete( errFCBUnusable );
		}
	BTClose( pfucb );

	return err;
	}

//  ================================================================
LOCAL INT PrintIndexSpace( const INDEXDEF * pindexdef, void * pv )
//  ================================================================
	{
	//  this will only compile if the signatures match
	PFNINDEX	pfnindex		= PrintIndexSpace;

	ERR			err				= JET_errSuccess;
	JET_DBUTIL	*pdbutil		= (JET_DBUTIL *)pv;
	PIB			*ppib			= (PIB *)pdbutil->sesid;
	const IFMP	ifmp			= (IFMP)pdbutil->dbid;
	
	Assert( pindexdef );

	if ( !pindexdef->fPrimary )		//	primary index dumped when table was dumped
		{
		CPRINTF * const pcprintf = ( pdbutil->grbitOptions & JET_bitDBUtilOptionDumpVerbose ) ?
			CPRINTFSTDOUT::PcprintfInstance() : NULL;
		printf( "  %-21.21s Idx ", pindexdef->szName );
		err = ErrDBUTLPrintSpace( ppib, ifmp, pindexdef->objidFDP, pindexdef->pgnoFDP, pcprintf );
		}

	return err;
	}

//  ================================================================
LOCAL INT PrintTableSpace( const TABLEDEF * ptabledef, void * pv )
//  ================================================================
	{
	//  this will only compile if the signatures match
	PFNTABLE pfntable = PrintTableSpace;

	ERR			err;
	JET_DBUTIL	*pdbutil		= (JET_DBUTIL *)pv;
	PIB			*ppib			= (PIB *)pdbutil->sesid;
	const IFMP	ifmp			= (IFMP)pdbutil->dbid;

	Assert( ptabledef );
	
	printf( "%-23.23s Tbl ", ptabledef->szName );

	if ( pgnoNull != ptabledef->pgnoFDPLongValues )
		{
		BFPrereadPageRange( ifmp, ptabledef->pgnoFDPLongValues, 1 );
		}

	CPRINTF * const pcprintf = ( pdbutil->grbitOptions & JET_bitDBUtilOptionDumpVerbose ) ?
		CPRINTFSTDOUT::PcprintfInstance() : NULL;

	CallR( ErrDBUTLPrintSpace(
				ppib,
				ifmp,
				ptabledef->objidFDP,
				ptabledef->pgnoFDP,
				pcprintf ) );

	if ( pgnoNull != ptabledef->pgnoFDPLongValues )
		{
		printf( "  %-21.21s LV  ", "<Long Values>" );
		CallR( ErrDBUTLPrintSpace(
					ppib,
					ifmp,
					ptabledef->objidFDPLongValues,
					ptabledef->pgnoFDPLongValues,
					pcprintf ) );
		}
	
	JET_DBUTIL	dbutil;	
	memset( &dbutil, 0, sizeof( dbutil ) );
	
	dbutil.cbStruct		= sizeof( dbutil );
	dbutil.op 			= opDBUTILEDBDump;
	dbutil.sesid		= pdbutil->sesid;
	dbutil.dbid			= pdbutil->dbid;	
	dbutil.pgno			= ptabledef->objidFDP;
	dbutil.pfnCallback	= (void *)PrintIndexSpace;
	dbutil.pvCallback	= &dbutil;
	dbutil.edbdump		= opEDBDumpIndexes;
	dbutil.grbitOptions	= pdbutil->grbitOptions;

	err = ErrDBUTLDump( pdbutil->sesid, &dbutil );
	return err;
	}


//  ================================================================
LOCAL INT PrintIndexBareMetaData( const INDEXDEF * pindexdef, void * pv )
//  ================================================================
	{
	//  this will only compile if the signatures match
	PFNINDEX	pfnindex		= PrintIndexBareMetaData;

	Assert( pindexdef );

	if ( !pindexdef->fPrimary )		//	primary index dumped when table was dumped
		{
		printf( "  %-49.49s Idx  ", pindexdef->szName );
		DBUTLPrintfIntN( pindexdef->objidFDP, 10 );
		printf( " " );
		DBUTLPrintfIntN( pindexdef->pgnoFDP, 10 );
		printf( "\n" );
		}

	return JET_errSuccess;
	}


//  ================================================================
LOCAL INT PrintTableBareMetaData( const TABLEDEF * ptabledef, void * pv )
//  ================================================================
	{
	//  this will only compile if the signatures match
	PFNTABLE	pfntable		= PrintTableBareMetaData;
	ERR			err;
	JET_DBUTIL	*pdbutil		= (JET_DBUTIL *)pv;

	Assert( ptabledef );
	
	printf( "%-51.51s Tbl  ", ptabledef->szName );
	DBUTLPrintfIntN( ptabledef->objidFDP, 10 );
	printf( " " );
	DBUTLPrintfIntN( ptabledef->pgnoFDP, 10 );
	printf( "\n" );

	if ( pgnoNull != ptabledef->pgnoFDPLongValues )
		{
		printf( "  %-49.49s LV   ", "<Long Values>" );
		DBUTLPrintfIntN( ptabledef->objidFDPLongValues, 10 );
		printf( " " );
		DBUTLPrintfIntN( ptabledef->pgnoFDPLongValues, 10 );
		printf( "\n" );
		}
	
	JET_DBUTIL	dbutil;	
	memset( &dbutil, 0, sizeof( dbutil ) );
	
	dbutil.cbStruct		= sizeof( dbutil );
	dbutil.op 			= opDBUTILEDBDump;
	dbutil.sesid		= pdbutil->sesid;
	dbutil.dbid			= pdbutil->dbid;	
	dbutil.pgno			= ptabledef->objidFDP;
	dbutil.pfnCallback	= (void *)PrintIndexBareMetaData;
	dbutil.pvCallback	= &dbutil;
	dbutil.edbdump		= opEDBDumpIndexes;
	dbutil.grbitOptions	= pdbutil->grbitOptions;

	err = ErrDBUTLDump( pdbutil->sesid, &dbutil );

	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLDumpOneIndex( PIB * ppib, FUCB * pfucbCatalog, VOID * pfnCallback, VOID * pvCallback )
//  ================================================================
	{
	JET_RETRIEVECOLUMN	rgretrievecolumn[12];
	BYTE				pbufidxseg[JET_ccolKeyMost*sizeof(IDXSEG)];
	BYTE				pbufidxsegConditional[JET_ccolKeyMost*sizeof(IDXSEG)];
	INDEXDEF			indexdef;
	ERR					err				= JET_errSuccess;
	INT					iretrievecolumn	= 0;
	OBJID				objidTable;

	QWORD qwSortVersion = 0;
	
	memset( &indexdef, 0, sizeof( indexdef ) );
	memset( rgretrievecolumn, 0, sizeof( rgretrievecolumn ) );

	//  objectId of owning table
	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_ObjidTable;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&objidTable;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof(objidTable);
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	//  pgnoFDP of index tree
	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_PgnoFDP;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&indexdef.pgnoFDP;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof(indexdef.pgnoFDP);
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	//  indexId (objidFDP of index tree)
	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Id;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&indexdef.objidFDP;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof(indexdef.objidFDP);
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Name;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)indexdef.szName;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof(indexdef.szName);
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	
	
	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_SpaceUsage;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&indexdef.density;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof(indexdef.density);
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Localization;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&indexdef.lcid;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof(indexdef.lcid);
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_LCMapFlags;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&indexdef.dwMapFlags;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof(indexdef.dwMapFlags);
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Flags;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&indexdef.fFlags;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof(indexdef.fFlags);
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	const INT iretcolTupleLimits					= iretrievecolumn;
	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_TupleLimits;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&indexdef.le_tuplelimits;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof(indexdef.le_tuplelimits);
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	const INT iretcolIdxsegConditional				= iretrievecolumn;
	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_ConditionalColumns;
	rgretrievecolumn[iretrievecolumn].pvData 		= pbufidxsegConditional;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof(pbufidxsegConditional);
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	const INT iretcolIdxseg							= iretrievecolumn;
	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_KeyFldIDs;
	rgretrievecolumn[iretrievecolumn].pvData 		= pbufidxseg;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof(pbufidxseg);
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Version;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&qwSortVersion;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof(qwSortVersion);
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	Assert( iretrievecolumn <= sizeof( rgretrievecolumn ) / sizeof( rgretrievecolumn[0] ) );
	
	CallR( ErrIsamRetrieveColumns(
				(JET_SESID)ppib,
				(JET_TABLEID)pfucbCatalog,
				rgretrievecolumn,
				iretrievecolumn ) );

	const IDBFLAG	idbflag		= (IDBFLAG)indexdef.fFlags;
	const IDXFLAG	idxflag		= (IDXFLAG)( indexdef.fFlags >> sizeof(IDBFLAG) * 8 );

	indexdef.fUnique			= !!FIDBUnique( idbflag );
	indexdef.fPrimary			= !!FIDBPrimary( idbflag );
	indexdef.fAllowAllNulls		= !!FIDBAllowAllNulls( idbflag );
	indexdef.fAllowFirstNull	= !!FIDBAllowFirstNull( idbflag );
	indexdef.fAllowSomeNulls	= !!FIDBAllowSomeNulls( idbflag );
	indexdef.fNoNullSeg			= !!FIDBNoNullSeg( idbflag );
	indexdef.fSortNullsHigh		= !!FIDBSortNullsHigh( idbflag );
	indexdef.fMultivalued		= !!FIDBMultivalued( idbflag );
	indexdef.fTuples			= ( JET_wrnColumnNull == rgretrievecolumn[iretcolTupleLimits].err ? fFalse : fTrue );
	indexdef.fLocaleId			= !!FIDBLocaleId( idbflag );
	indexdef.fLocalizedText		= !!FIDBLocalizedText( idbflag );
	indexdef.fTemplateIndex		= !!FIDBTemplateIndex( idbflag );
	indexdef.fDerivedIndex		= !!FIDBDerivedIndex( idbflag );
	indexdef.fExtendedColumns	= !!FIDXExtendedColumns( idxflag );
	indexdef.fUnicodeFixupOn	= !!FIDBUnicodeFixupOn( idbflag );

	indexdef.dwDefinedVersion	= DwDefinedVersionFromSortVersion( qwSortVersion );
	indexdef.dwNLSVersion		= DwNLSVersionFromSortVersion( qwSortVersion );
	
	Assert( rgretrievecolumn[iretcolIdxseg].cbActual > 0 );

	if ( indexdef.fExtendedColumns )
		{
		UINT	iidxseg;

		Assert( sizeof(IDXSEG) == sizeof(JET_COLUMNID) );

		Assert( rgretrievecolumn[iretcolIdxseg].cbActual <= sizeof(JET_COLUMNID) * JET_ccolKeyMost );
		Assert( rgretrievecolumn[iretcolIdxseg].cbActual % sizeof(JET_COLUMNID) == 0 );
		Assert( rgretrievecolumn[iretcolIdxseg].cbActual / sizeof(JET_COLUMNID) <= JET_ccolKeyMost );
		indexdef.ccolumnidDef = rgretrievecolumn[iretcolIdxseg].cbActual / sizeof(JET_COLUMNID);

		for ( iidxseg = 0; iidxseg < indexdef.ccolumnidDef; iidxseg++ )
			{
			const LE_IDXSEG		* const ple_idxseg	= (LE_IDXSEG *)pbufidxseg + iidxseg;
			//	Endian conversion
			indexdef.rgidxsegDef[iidxseg] = *ple_idxseg;
			Assert( FCOLUMNIDValid( indexdef.rgidxsegDef[iidxseg].Columnid() ) );
			}

		Assert( rgretrievecolumn[iretcolIdxsegConditional].cbActual <= sizeof(JET_COLUMNID) * JET_ccolKeyMost );
		Assert( rgretrievecolumn[iretcolIdxsegConditional].cbActual % sizeof(JET_COLUMNID) == 0 );
		Assert( rgretrievecolumn[iretcolIdxsegConditional].cbActual / sizeof(JET_COLUMNID) <= JET_ccolKeyMost );
		indexdef.ccolumnidConditional = rgretrievecolumn[iretcolIdxsegConditional].cbActual / sizeof(JET_COLUMNID);

		for ( iidxseg = 0; iidxseg < indexdef.ccolumnidConditional; iidxseg++ )
			{
			const LE_IDXSEG		* const ple_idxsegConditional	= (LE_IDXSEG *)pbufidxsegConditional + iidxseg;
			//	Endian conversion
			indexdef.rgidxsegConditional[iidxseg] = *ple_idxsegConditional;
			Assert( FCOLUMNIDValid( indexdef.rgidxsegConditional[iidxseg].Columnid() ) );
			}

		}
	else
		{
		Assert( sizeof(IDXSEG_OLD) == sizeof(FID) );

		Assert( rgretrievecolumn[iretcolIdxseg].cbActual <= sizeof(FID) * JET_ccolKeyMost );
		Assert( rgretrievecolumn[iretcolIdxseg].cbActual % sizeof(FID) == 0);
		Assert( rgretrievecolumn[iretcolIdxseg].cbActual / sizeof(FID) <= JET_ccolKeyMost );
		indexdef.ccolumnidDef = rgretrievecolumn[iretcolIdxseg].cbActual / sizeof( FID );

		SetIdxSegFromOldFormat(
			(UnalignedLittleEndian< IDXSEG_OLD > *)pbufidxseg,
			indexdef.rgidxsegDef,
			indexdef.ccolumnidDef,
			fFalse,
			fFalse,
			NULL );

		Assert( rgretrievecolumn[iretcolIdxsegConditional].cbActual <= sizeof(FID) * JET_ccolKeyMost );
		Assert( rgretrievecolumn[iretcolIdxsegConditional].cbActual % sizeof(FID) == 0);
		Assert( rgretrievecolumn[iretcolIdxsegConditional].cbActual / sizeof(FID) <= JET_ccolKeyMost );
		indexdef.ccolumnidConditional = rgretrievecolumn[iretcolIdxsegConditional].cbActual / sizeof( FID );

		SetIdxSegFromOldFormat(
			(UnalignedLittleEndian< IDXSEG_OLD > *)pbufidxsegConditional,
			indexdef.rgidxsegConditional,
			indexdef.ccolumnidConditional,
			fTrue,
			fFalse,
			NULL );
		}

	CallR( ErrCATGetIndexSegments(
					ppib,
					pfucbCatalog->u.pfcb->Ifmp(),
					objidTable,
					indexdef.rgidxsegDef,
					indexdef.ccolumnidDef,
					fFalse,
					!indexdef.fExtendedColumns,
					indexdef.rgszIndexDef ) );
					
	CallR( ErrCATGetIndexSegments(
					ppib,
					pfucbCatalog->u.pfcb->Ifmp(),
					objidTable,
					indexdef.rgidxsegConditional,
					indexdef.ccolumnidConditional,
					fTrue,
					!indexdef.fExtendedColumns,
					indexdef.rgszIndexConditional ) );

	PFNINDEX const pfnindex = (PFNINDEX)pfnCallback;
	return (*pfnindex)( &indexdef, pvCallback );
	}


//  ================================================================
LOCAL ERR ErrDBUTLDumpOneTable( PIB * ppib, FUCB * pfucbCatalog, PFNTABLE pfntable, VOID * pvCallback )
//  ================================================================
	{
	JET_RETRIEVECOLUMN	rgretrievecolumn[10];
	TABLEDEF			tabledef;
	ERR					err				= JET_errSuccess;
	INT					iretrievecolumn	= 0;

	memset( &tabledef, 0, sizeof( tabledef ) );
	memset( rgretrievecolumn, 0, sizeof( rgretrievecolumn ) );

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Name;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)tabledef.szName;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( tabledef.szName );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_TemplateTable;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)tabledef.szTemplateTable;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( tabledef.szTemplateTable );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_PgnoFDP;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&( tabledef.pgnoFDP );
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( tabledef.pgnoFDP );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Id;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&( tabledef.objidFDP );
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( tabledef.objidFDP );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Pages;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&( tabledef.pages );
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( tabledef.pages );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_SpaceUsage;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&( tabledef.density );
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( tabledef.density );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Flags;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&( tabledef.fFlags );
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( tabledef.fFlags );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	Call( ErrIsamRetrieveColumns(
				(JET_SESID)ppib,
				(JET_TABLEID)pfucbCatalog,
				rgretrievecolumn,
				iretrievecolumn ) );
				
	Call( ErrCATAccessTableLV(
				ppib,
				pfucbCatalog->u.pfcb->Ifmp(),
				tabledef.objidFDP,
				&tabledef.pgnoFDPLongValues,
				&tabledef.objidFDPLongValues ) );

	Call( (*pfntable)( &tabledef, pvCallback ) );

HandleError:
	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLDumpTables( PIB * ppib, IFMP ifmp, CHAR *szTableName, PFNTABLE pfntable, VOID * pvCallback )
//  ================================================================
	{
	ERR		err;
	FUCB	*pfucbCatalog	= pfucbNil;
	
	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );
	
	Call( ErrIsamSetCurrentIndex( ppib, pfucbCatalog, szMSORootObjectsIndex ) );

	if ( NULL != szTableName )
		{
		//  find the table we want and dump it
		const BYTE	bTrue	= 0xff;
		
		Call( ErrIsamMakeKey(
					ppib,
					pfucbCatalog,
					&bTrue,
					sizeof(bTrue),
					JET_bitNewKey ) );
		Call( ErrIsamMakeKey(
					ppib,
					pfucbCatalog,
					(BYTE *)szTableName,
					(ULONG)strlen(szTableName),
					NO_GRBIT ) );
		err = ErrIsamSeek( ppib, pfucbCatalog, JET_bitSeekEQ );
		if ( JET_errRecordNotFound == err )
			err = ErrERRCheck( JET_errObjectNotFound );
		Call( err );
		CallS( err );

		Call( ErrDBUTLDumpOneTable( ppib, pfucbCatalog, pfntable, pvCallback ) );
		}
	else
		{
		err = ErrIsamMove( ppib, pfucbCatalog, JET_MoveFirst, NO_GRBIT );
		while ( JET_errNoCurrentRecord != err )
			{
			Call( err );
			
			Call( ErrDBUTLDumpOneTable( ppib, pfucbCatalog, pfntable, pvCallback ) );
			err = ErrIsamMove( ppib, pfucbCatalog, JET_MoveNext, NO_GRBIT );
			}
		}
		
	err = JET_errSuccess;

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );

	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLDumpTableObjects(
	PIB				*ppib,
	const IFMP		ifmp,
	const OBJID		objidFDP,
	const SYSOBJ	sysobj,
	PFNDUMP			pfnDump,
	VOID			*pfnCallback,
	VOID			*pvCallback )
//  ================================================================
	{
	ERR				err;
	FUCB			*pfucbCatalog	= pfucbNil;

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );
	FUCBSetSequential( pfucbCatalog );

	Call( ErrIsamSetCurrentIndex( ppib, pfucbCatalog, szMSONameIndex ) );
	
	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)&objidFDP,
				sizeof(objidFDP),
				JET_bitNewKey ) );
	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)&sysobj,
				sizeof(sysobj),
				NO_GRBIT ) );

	err = ErrIsamSeek( ppib, pfucbCatalog, JET_bitSeekGT );
	if ( err < 0 )
		{
		if ( JET_errRecordNotFound != err )
			goto HandleError;
		}
	else
		{
		CallS( err );
		
		Call( ErrIsamMakeKey(
					ppib,
					pfucbCatalog,
					(BYTE *)&objidFDP,
					sizeof(objidFDP),
					JET_bitNewKey ) );
		Call( ErrIsamMakeKey(
					ppib,
					pfucbCatalog,
					(BYTE *)&sysobj,
					sizeof(sysobj),
					JET_bitStrLimit ) );
		err = ErrIsamSetIndexRange( ppib, pfucbCatalog, JET_bitRangeUpperLimit );
		Assert( err <= 0 );
		while ( JET_errNoCurrentRecord != err )
			{
			Call( err );
			
			Call( (*pfnDump)( ppib, pfucbCatalog, pfnCallback, pvCallback ) );
			err = ErrIsamMove( ppib, pfucbCatalog, JET_MoveNext, NO_GRBIT );
			}
		}

	err = JET_errSuccess;

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );

	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLDump( JET_SESID sesid, const JET_DBUTIL *pdbutil )
//  ================================================================
	{
	ERR		err;

	switch( pdbutil->edbdump )
		{
		case opEDBDumpTables:
			{
			PFNTABLE const pfntable = (PFNTABLE)( pdbutil->pfnCallback );
			err = ErrDBUTLDumpTables(
						(PIB *)sesid,
						IFMP( pdbutil->dbid ),
						pdbutil->szTable,
						pfntable,
						pdbutil->pvCallback );
			}
			break;
		case opEDBDumpIndexes:
			err = ErrDBUTLDumpTableObjects(
						(PIB *)sesid,
						IFMP( pdbutil->dbid ),
						(OBJID)pdbutil->pgno,
						sysobjIndex,
						&ErrDBUTLDumpOneIndex,
						pdbutil->pfnCallback,
						pdbutil->pvCallback );
			break;

#ifdef DEBUG			
		case opEDBDumpColumns:
			err = ErrDBUTLDumpTableObjects(
						(PIB *)sesid,
						IFMP( pdbutil->dbid ),
						OBJID( pdbutil->pgno ),
						sysobjColumn,
						&ErrDBUTLDumpOneColumn,
						pdbutil->pfnCallback,
						pdbutil->pvCallback );
			break;
		case opEDBDumpCallbacks:
			err = ErrDBUTLDumpTableObjects(
						(PIB *)sesid,
						IFMP( pdbutil->dbid ),
						OBJID( pdbutil->pgno ),
						sysobjCallback,
						&ErrDBUTLDumpOneCallback,
						pdbutil->pfnCallback,
						pdbutil->pvCallback );
			break;
		case opEDBDumpPage:
			{
			PFNPAGE const pfnpage = (PFNPAGE)( pdbutil->pfnCallback );
			err = ErrDBUTLDumpPage( (PIB *)sesid, (IFMP) pdbutil->dbid, pdbutil->pgno, pfnpage, pdbutil->pvCallback );
			}
			break;
#endif			

		default:
			Assert( fFalse );
			err = ErrERRCheck( JET_errFeatureNotAvailable );
			break;
		}
		
	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLDumpTables( DBCCINFO *pdbccinfo, PFNTABLE pfntable )
//  ================================================================
	{
	JET_SESID	sesid 			= (JET_SESID)pdbccinfo->ppib;
	JET_DBID	dbid 			= (JET_DBID)pdbccinfo->ifmp;
	JET_DBUTIL	dbutil;

	memset( &dbutil, 0, sizeof( dbutil ) );

	dbutil.cbStruct		= sizeof( dbutil );
	dbutil.op 			= opDBUTILEDBDump;
	dbutil.sesid		= sesid;
	dbutil.dbid			= dbid;
	dbutil.pfnCallback	= (void *)pfntable;
	dbutil.pvCallback	= &dbutil;
	dbutil.edbdump		= opEDBDumpTables;
	dbutil.grbitOptions	= pdbccinfo->grbitOptions;
	
	dbutil.szTable		= ( NULL == pdbccinfo->szTable || '\0' == pdbccinfo->szTable[0] ?
								NULL :
								pdbccinfo->szTable );

	return ErrDBUTLDump( sesid, &dbutil );
	}


#ifdef DISABLE_SLV
#else

LOCAL ERR ErrDBUTLDumpExchangeSLVInfo( DBCCINFO	*pdbccinfo )
	{
	ERR					err;
	PIB * const			ppib			= pdbccinfo->ppib;
	const IFMP			ifmp			= pdbccinfo->ifmp;
	const CHAR * const	szTableName		= "Msg";
	const CHAR * const	szSLVColumn		= "F6659";
	FUCB *				pfucb			= pfucbNil;
	FCB *				pfcb;
	FIELD *				pfield;
	COLUMNID			columnid;
	DIB					dib;
	DATA				dataRetrieved;
	const ULONG			cbBuf			= 65536;
	VOID * const		pvBuf			= PvOSMemoryPageAlloc( cbBuf, NULL );

	if ( NULL == pvBuf )
		return ErrERRCheck( JET_errOutOfMemory );

	printf( "         Table: %s\n", szTableName );

	Call( ErrFILEOpenTable(
				ppib,
				ifmp,
				&pfucb,
				szTableName,
				JET_bitTableDenyRead|JET_bitTableReadOnly|JET_bitTableSequential ) );

	pfcb = pfucb->u.pfcb;
				
	printf( "      ObjidFDP: 0x%08x (%d)\n", pfcb->ObjidFDP(), pfcb->ObjidFDP() );
	printf( "       PgnoFDP: 0x%08x (%d)\n", pfcb->PgnoFDP(), pfcb->PgnoFDP() );
	printf( "   Column Name: %s\n", szSLVColumn );
	pfcb->EnterDML();

	//	WARNING: The following function does a LeaveDML() on error
	Call( ErrFILEPfieldFromColumnName(
				ppib,
				pfcb,
				szSLVColumn,
				&pfield,
				&columnid ) );

	if ( pfieldNil == pfield )
		{
		Call( ErrERRCheck( JET_errColumnNotFound ) );
		}
	else if ( JET_coltypSLV != pfield->coltyp )
		{
		Call( ErrERRCheck( JET_errInvalidColumnType ) );
		}

	pfcb->LeaveDML();

	printf( "      Columnid: 0x%08x (%d)\n\n", columnid, columnid );

	//	verify preread enabled
	Assert( FFUCBSequential( pfucb ) );

	dib.pos 	= posFirst;
	dib.pbm 	= NULL;
	dib.dirflag = fDIRNull;

	FUCBSetPrereadForward( pfucb, cpgPrereadSequential );
	err = ErrBTDown( pfucb, &dib, latchReadTouch );
	Assert( JET_errNoCurrentRecord != err );
	if( JET_errRecordNotFound == err )
		{
		//  the tree is empty
		err = JET_errSuccess;
		goto HandleError;
		}

	do
		{
		BOOL	fSeparated	= fFalse;

		Call( err );

		Assert( Pcsr( pfucb )->FLatched() );

		Call( ErrRECIRetrieveTaggedColumn(
				pfcb,
				columnid,
				1,
				pfucb->kdfCurr.data,
				&dataRetrieved ) );
		Assert( Pcsr( pfucb )->FLatched() );
		Assert( wrnRECLongField != err );
		Assert( wrnRECUserDefinedDefault != err );
		Assert( wrnRECSeparatedLV != err );
		Assert( wrnRECIntrinsicLV != err );

		if ( wrnRECSeparatedSLV == err )
			{
			ULONG	cbActual;

			Call( ErrBTRelease( pfucb ) );
		
			Assert( sizeof(LID) == dataRetrieved.Cb() );
			Call( ErrRECIRetrieveSeparatedLongValue(
						pfucb,
						dataRetrieved,
						fTrue,
						0,
						pvBuf,
						cbBuf,
						&cbActual,
						NO_GRBIT ) );
			CallSx( err, JET_wrnBufferTruncated );
		
			//	must re-latch record
			Assert( !Pcsr( pfucb )->FLatched() );
			Call( ErrBTIRefresh( pfucb ) );
			CallS( err );
			Assert( Pcsr( pfucb )->FLatched() );

			dataRetrieved.SetPv( pvBuf );
			dataRetrieved.SetCb( cbActual );
			fSeparated = fTrue;
			}
		else
			{
			Assert( wrnRECIntrinsicSLV == err
				|| JET_wrnColumnNull == err );
			}

		printf( "\n" );
		for ( ULONG i = 0; i < pfucb->kdfCurr.key.prefix.Cb(); i++ )
			printf( "%02x ", *( (BYTE *)( pfucb->kdfCurr.key.prefix.Pv() ) + i ) );
		for ( i = 0; i < pfucb->kdfCurr.key.suffix.Cb(); i++ )
			printf( "%02x ", *( (BYTE *)( pfucb->kdfCurr.key.suffix.Pv() ) + i ) );

		if ( dataRetrieved.Cb() > 0 )
			{
			//	UNDONE: use CSLVInfo iterator instead of this manual hack
			CSLVInfo::HEADER*	pslvinfoHdr		= (CSLVInfo::HEADER *)( dataRetrieved.Pv() );
			CSLVInfo::_RUN*		prun			= (CSLVInfo::_RUN *)( pslvinfoHdr + 1 );
			QWORD				ibVirtualPrev	= 0;
			const QWORD			cRunsMax		= ( cbBuf - sizeof(CSLVInfo::HEADER) ) / sizeof(CSLVInfo::_RUN);
			const QWORD			cRuns			= min( pslvinfoHdr->cRun, cRunsMax );

			printf( ":\n" );
			printf( "    SLV size: 0x%I64x bytes, Runs: %I64d, Separated: %s, Recoverable: %s\n",
							pslvinfoHdr->cbSize,
							pslvinfoHdr->cRun,
							( fSeparated ? "YES" : "NO" ),
							( pslvinfoHdr->fDataRecoverable ? "YES" : "NO" ) );

			for ( ULONG irun = 1; irun <= cRuns; irun++ )
				{
				const PGNO	pgnoStart	= PGNO( ( prun->ibLogical / g_cbPage ) - cpgDBReserved + 1 );
				const PGNO	pgnoEnd		= PGNO( pgnoStart + ( ( prun->ibVirtualNext - ibVirtualPrev ) / g_cbPage ) - 1 );
				printf( "    Run %d: ibVirtualNext=0x%I64x, ibLogical=0x%I64x ",
									irun,
									prun->ibVirtualNext,
									prun->ibLogical );
				Assert( pgnoEnd >= pgnoStart );
				if ( pgnoStart == pgnoEnd )
					printf( "(page %d)\n", pgnoStart );
				else
					printf( "(pages %d-%d)\n", pgnoStart, pgnoEnd );

				ibVirtualPrev = prun->ibVirtualNext;
				prun++;
				}
			if ( cRuns < pslvinfoHdr->cRun )
				printf( "    ...\n" );
			}
		else
			{
			printf( ": (NULL)\n" );
			}


		err = ErrBTNext( pfucb, fDIRNull );
		}
	while ( JET_errNoCurrentRecord != err );

	printf( "\n" );

	Assert( JET_errNoCurrentRecord == err );
	err = JET_errSuccess;

HandleError:
	if ( pfucbNil != pfucb )
		CallS( ErrFILECloseTable( ppib, pfucb ) );

	OSMemoryPageFree( pvBuf );
	return err;
	}

#endif	//	DISABLE_SLV


//  ================================================================
ERR ISAMAPI ErrIsamDBUtilities( JET_SESID sesid, JET_DBUTIL *pdbutil )
//  ================================================================
	{
	ERR		err		= JET_errSuccess;
	INST	*pinst	= PinstFromPpib( (PIB*)sesid );

	//	verify input

	Assert( pdbutil );
	Assert( pdbutil->cbStruct == sizeof( JET_DBUTIL ) );

	if ( opDBUTILEDBDump != pdbutil->op )
		{

		//	the current operation requires szDatabase != NULL

		if ( NULL == pdbutil->szDatabase || '\0' == pdbutil->szDatabase[0] )
			{
			return ErrERRCheck( JET_errDatabaseInvalidName );
			}
		}

	//	dispatch the work

	switch ( pdbutil->op )
		{
		case opDBUTILDumpLogfile:
			return ErrDUMPLog( pinst, pdbutil->szDatabase, pdbutil->grbitOptions );

#ifdef DEBUG
		case opDBUTILDumpLogfileTrackNode:
			{
			NODELOC nodeloc( pdbutil->dbid, pdbutil->pgno, pdbutil->iline );
			LGPOS	lgpos;

			lgpos.lGeneration 	= pdbutil->lGeneration;
			lgpos.isec 			= (USHORT)pdbutil->isec;
			lgpos.ib			= (USHORT)pdbutil->ib;

			return ErrDUMPLogNode( pinst, pdbutil->szDatabase, nodeloc, lgpos );
			}			

		case opDBUTILEDBDump:
            return ErrDBUTLDump( sesid, pdbutil );
            
		case opDBUTILDumpNode:
			return ErrDBUTLDumpNode( pinst->m_pfsapi, pdbutil->szDatabase, pdbutil->pgno, pdbutil->iline, pdbutil->grbitOptions );

		case opDBUTILSetHeaderState:
			return ErrDUMPHeader( pinst, pdbutil->szDatabase, fTrue );
#endif	//	DEBUG

		case opDBUTILDumpPage:
			return ErrDBUTLDumpPage( pinst->m_pfsapi, pdbutil->szDatabase, pdbutil->pgno, pdbutil->szIndex, pdbutil->szTable, pdbutil->grbitOptions );

		case opDBUTILDumpHeader:
			return ErrDUMPHeader( pinst, pdbutil->szDatabase );

		case opDBUTILDumpCheckpoint:
			return ErrDUMPCheckpoint( pinst, pinst->m_pfsapi, pdbutil->szDatabase );

		case opDBUTILEDBRepair:
            return ErrDBUTLRepair( sesid, pdbutil, CPRINTFSTDOUT::PcprintfInstance() );

		case opDBUTILEDBScrub:
            return ErrDBUTLScrub( sesid, pdbutil );

		case opDBUTILDBConvertRecords:
			return ErrDBUTLConvertRecords( sesid, pdbutil );

		case opDBUTILDumpData:
			return ErrESEDUMPData( sesid, pdbutil );

		case opDBUTILDBDefragment:
			{
			ERR	errDetach;

			err = ErrIsamAttachDatabase(	sesid, 
											pdbutil->szDatabase, 
											pdbutil->szSLV, 
											NULL, 
											0, 
											JET_bitDbReadOnly );
			if ( JET_errSuccess != err )
				{
				return err;
				}

			err = ErrIsamCompact(			sesid, 
											pdbutil->szDatabase, 
											pinst->m_pfsapi, 
											pdbutil->szTable, 
											pdbutil->szIndex, 
											JET_PFNSTATUS( pdbutil->pfnCallback ), 
											NULL, 
											pdbutil->grbitOptions );

			errDetach = ErrIsamDetachDatabase( sesid, NULL, pdbutil->szDatabase );

			if ( err >= JET_errSuccess && errDetach < JET_errSuccess )
				{
				err = errDetach;
				}
			}
			return err;
		}


	DBCCINFO	dbccinfo;
	JET_DBID	dbid		= JET_dbidNil;
	JET_GRBIT	grbitAttach;

	//	setup DBCCINFO

	memset( &dbccinfo, 0, sizeof(DBCCINFO) );
	dbccinfo.tableidPageInfo 	= JET_tableidNil;
	dbccinfo.tableidSpaceInfo 	= JET_tableidNil;

	//	default to the consistency checker

	dbccinfo.op = opDBUTILConsistency;

	switch ( pdbutil->op )
		{
#ifdef DEBUG
		case opDBUTILMunge:
#endif	//	DEBUG
		case opDBUTILDumpMetaData:
		case opDBUTILDumpSpace:
		case opDBUTILDumpExchangeSLVInfo:
			dbccinfo.op = pdbutil->op;
			break;
		}

	//	copy object names

    Assert( NULL != pdbutil->szDatabase );
	strcpy( dbccinfo.szDatabase, pdbutil->szDatabase );

    if ( NULL != pdbutil->szSLV )
    	{
		strcpy( dbccinfo.szSLV, pdbutil->szSLV );
		}
	if ( NULL != pdbutil->szTable )
		{
		strcpy( dbccinfo.szTable, pdbutil->szTable );
		}
	if ( NULL != pdbutil->szIndex )
		{
		strcpy( dbccinfo.szIndex, pdbutil->szIndex );
		}

	//  propagate the grbit

	if ( pdbutil->grbitOptions & JET_bitDBUtilOptionStats )
		{
		dbccinfo.grbitOptions |= JET_bitDBUtilOptionStats;
		}
	if ( pdbutil->grbitOptions & JET_bitDBUtilOptionDumpVerbose )
		{
		dbccinfo.grbitOptions |= JET_bitDBUtilOptionDumpVerbose;
		}
		
	//	attach/open database, table and index

	grbitAttach = ( opDBUTILMunge == dbccinfo.op ) ? 0 : JET_bitDbReadOnly;
	CallR( ErrIsamAttachDatabase(	sesid, 
									dbccinfo.szDatabase, 
									( '\0' != dbccinfo.szSLV[0] ) ? dbccinfo.szSLV : NULL, 
									NULL, 
									0, 
									grbitAttach ) );
	Assert( JET_wrnDatabaseAttached != err );	// Since logging/recovery is disabled.

	Call( ErrIsamOpenDatabase(		sesid, 
									dbccinfo.szDatabase, 
									NULL, 
									&dbid, 
									JET_bitDbExclusive | grbitAttach ) );

	//	copy the session and database handles

	dbccinfo.ppib = (PIB*)sesid;
	dbccinfo.ifmp = dbid;

	//	check database according to command line args/flags

	switch ( dbccinfo.op )
		{
		case opDBUTILConsistency:
			Call( ErrERRCheck( JET_errFeatureNotAvailable ) );

#ifdef DEAD_CODE

		//
		//	NOTE: when removing this code, be sure to remove rgcolumndefPageInfoTable if it is not used
		//		  by anyone else
		//

			//	open temporary table
			if ( dbccinfo.grbitOptions & JET_bitDBUtilOptionPageDump )
				{
				Call( ErrIsamOpenTempTable(
					(JET_SESID)dbccinfo.ppib,
					rgcolumndefPageInfoTable, 
					ccolumndefPageInfoTable,
					0,
					JET_bitTTUpdatable|JET_bitTTIndexed, 
					&dbccinfo.tableidPageInfo, 
					rgcolumnidPageInfoTable
					) );

				/// UNDONE: page dump routine is missing
				/// Call( ??? );
					
				Call( ErrDBUTLPrintPageDump( &dbccinfo ) );
				}
#endif	//	DEAD_CODE
			break;

#ifdef DEBUG
		case opDBUTILMunge:
			Call( ErrDBUTLMungeDatabase(
					dbccinfo.ppib,
					dbccinfo.ifmp,
					(char **)(pdbutil->szBackup), // over loaded by JetEdit
					(long)(pdbutil->iline),
					CPRINTFSTDOUT::PcprintfInstance() ) );
			break;
#endif	//	DEBUG

		case opDBUTILDumpSpace:
			if( rgfmp[dbccinfo.ifmp].FSLVAttached() )
				{
				printf( "****************************** SLV SPACE DUMP ******************************\n" );
				printf( "Chunk          Free Res Del Com  |------------ Used ------------|           \n" );
				printf(	"============================================================================\n" );

				CPRINTF * const pcprintf = CPRINTFSTDOUT::PcprintfInstance();
				Call( ErrDBUTLPrintSLVSpace( dbccinfo.ppib, dbccinfo.ifmp, pcprintf ) );			

				printf( "\n\n" );
				}
				
			printf( "******************************** SPACE DUMP ***********************************\n" );
			printf( "Name                   Type   ObjidFDP    PgnoFDP  PriExt      Owned  Available\n" );
			printf(	"===============================================================================\n" );
			printf( "%-23.23s Db  ", dbccinfo.szDatabase );
			cpgTotalAvailExt = 0;

			{
			CPRINTF * const pcprintf = ( pdbutil->grbitOptions & JET_bitDBUtilOptionDumpVerbose ) ?
											CPRINTFSTDOUT::PcprintfInstance() :
											NULL;

			Call( ErrDBUTLPrintSpace( dbccinfo.ppib, dbccinfo.ifmp, objidSystemRoot, pgnoSystemRoot, pcprintf ) );

			if( rgfmp[dbccinfo.ifmp].FSLVAttached() )
				{
#ifdef DISABLE_SLV
				Call( ErrERRCheck( JET_wrnNyi ) );
#else
				PGNO	pgnoSLV;
				OBJID	objidSLV;

				printf( "%-23.23s SLV ", "<SLV Avail Map>" );
				Call( ErrCATAccessDbSLVAvail(
							dbccinfo.ppib,
							dbccinfo.ifmp,
							szSLVAvail,
							&pgnoSLV,
							&objidSLV ) );
				Call( ErrDBUTLPrintSpace( dbccinfo.ppib, dbccinfo.ifmp, objidSLV, pgnoSLV, pcprintf ) );

				printf( "%-23.23s SLV ", "<SLV Owner Map>" );
				Call( ErrCATAccessDbSLVOwnerMap(
							dbccinfo.ppib,
							dbccinfo.ifmp,
							szSLVOwnerMap,
							&pgnoSLV,
							&objidSLV ) );
				Call( ErrDBUTLPrintSpace( dbccinfo.ppib, dbccinfo.ifmp, objidSLV, pgnoSLV, pcprintf ) );
#endif	//	DISABLE_SLV				
				}
			}
			
			printf( "\n" );
			Call( ErrDBUTLDumpTables( &dbccinfo, PrintTableSpace ) );
			printf( "-------------------------------------------------------------------------------\n" );
			printf( "                                                                     " );
			DBUTLPrintfIntN( cpgTotalAvailExt, 10 );
			printf( "\n" );
			break;

		case opDBUTILDumpMetaData:
			printf( "******************************* META-DATA DUMP *******************************\n" );

#ifdef DEBUG
			if ( dbccinfo.grbitOptions & JET_bitDBUtilOptionDumpVerbose )
				{
				Call( ErrDBUTLDumpTables( &dbccinfo, PrintTableMetaData ) );
				}
			else
#endif			
				{
				printf( "Name                                               Type    ObjidFDP    PgnoFDP\n" );
				printf(	"==============================================================================\n" );
				printf( "%-51.51s Db   ", dbccinfo.szDatabase );
				DBUTLPrintfIntN( objidSystemRoot, 10 );
				printf( " " );
				DBUTLPrintfIntN( pgnoSystemRoot, 10 );

				if( rgfmp[dbccinfo.ifmp].FSLVAttached() )
					{
#ifdef DISABLE_SLV
					Call( ErrERRCheck( JET_wrnNyi ) );
#else
					PGNO	pgnoSLV;
					OBJID	objidSLV;

					printf( "\n%-51.51s SLV  ", "<SLV Avail Map>" );
					Call( ErrCATAccessDbSLVAvail(
								dbccinfo.ppib,
								dbccinfo.ifmp,
								szSLVAvail,
								&pgnoSLV,
								&objidSLV ) );
					DBUTLPrintfIntN( objidSLV, 10 );
					printf( " " );
					DBUTLPrintfIntN( pgnoSLV, 10 );

					printf( "\n%-51.51s SLV  ", "<SLV Owner Map>" );
					Call( ErrCATAccessDbSLVOwnerMap(
								dbccinfo.ppib,
								dbccinfo.ifmp,
								szSLVOwnerMap,
								&pgnoSLV,
								&objidSLV ) );
					DBUTLPrintfIntN( objidSLV, 10 );
					printf( " " );
					DBUTLPrintfIntN( pgnoSLV, 10 );
#endif	//	DISABLE_SLV
					}

				printf( "\n\n" );

				Call( ErrDBUTLDumpTables( &dbccinfo, PrintTableBareMetaData ) );
				}

			printf( "******************************************************************************\n" );
			break;

#ifdef DISABLE_SLV
#else
		case opDBUTILDumpExchangeSLVInfo:
			Call( ErrDBUTLDumpExchangeSLVInfo( &dbccinfo ) );
			break;
#endif

		default:
			err = ErrERRCheck( JET_errFeatureNotAvailable );
			Call( err );
			break;
		}

	//	terminate
HandleError:
	if ( JET_tableidNil != dbccinfo.tableidPageInfo )
		{
		Assert( dbccinfo.grbitOptions & JET_bitDBUtilOptionPageDump );
		CallS( ErrDispCloseTable( (JET_SESID)dbccinfo.ppib, dbccinfo.tableidPageInfo ) );
		dbccinfo.tableidPageInfo = JET_tableidNil;
		}
		
	if ( JET_dbidNil != dbid )
		{
		(VOID)ErrIsamCloseDatabase( sesid, dbid, 0 );
		}

	(VOID)ErrIsamDetachDatabase( sesid, NULL, dbccinfo.szDatabase );

	fflush( stdout );
	return err;
	}

#endif	//	MINIMAL_FUNCTIONALITY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\esedump.cxx ===
#include "std.hxx"

#ifdef MINIMAL_FUNCTIONALITY
#else

#include "_dump.hxx"
#include "_bt.hxx"


extern CPRINTFSTDOUT cprintfStdout;

CPRINTFINDENT cprintfIndent( &cprintfStdout);

const BYTE mpbb[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8',
					 '9', 'A', 'B', 'C', 'D', 'E', 'F' };

#define addPBI				cprintfIndent
#define flushPB( )			
#define addIndent() 		cprintfIndent.Indent()
#define delIndent() 		cprintfIndent.Unindent()


// numer of bytes to be displayed from the key of each node
#define MAX_KEY_SIZE_DISPLAY 8

// helps to don't pass as param the dumping mode (all nodes or visible ones)
// to all the function down the call stack

typedef char * (*PfnFormatNodeInfo)( KEYDATAFLAGS * pNode );

LOCAL ERR ErrESEDUMPOneTable(FUCB *, char *, JET_GRBIT);
LOCAL ERR ErrESEDUMPNodesForOneTree(FUCB *pfucbTable, JET_GRBIT grbitESEDUMPMode, PfnFormatNodeInfo pfnFormat = NULL);
LOCAL ERR ErrESEDUMPTables( JET_SESID , JET_DBID , char* , JET_GRBIT);
LOCAL ERR ErrESEDUMPIndexForOneTable(FUCB *, JET_GRBIT);
LOCAL ERR ErrESEDUMPCheckAndDumpSpaceInfo(FUCB *, JET_GRBIT);
LOCAL ERR ErrESEDUMPDatabaseInfo(PIB *, IFMP , JET_GRBIT);
LOCAL ERR ErrESEDUMPLVForOneTable(FUCB *, JET_GRBIT);
LOCAL VOID ESEDUMPSplitBufferDump(SPLIT_BUFFER & , FUCB * , JET_GRBIT);
LOCAL VOID ESEDUMPSingleSpaceHeaderDump(SPACE_HEADER &, FUCB * , JET_GRBIT);
LOCAL ERR ErrESEDUMPMultipleSpaceHeaderDump(SPACE_HEADER & , FUCB *, JET_GRBIT );

#ifdef DISABLE_SLV
#else
LOCAL ERR ErrESEDUMPSpecialFDP(FUCB *pfucbCatalog, PGNO pgnoFDP, const char *szName, JET_GRBIT grbitESEDUMPMode, PfnFormatNodeInfo pfnFormat = NULL);
LOCAL ERR ErrESEDUMPSpecialFDPs( JET_SESID sesid, JET_DBID ifmp, JET_GRBIT grbitESEDUMPMode );
#endif


// main function that dumps the nodes (it's called from the eseutil.cxx)
// the dump parameters are set according to the command line in pdbutil 
// Current options:	- dump only one table /{x|X}TableName
//					- dump visible nodes or all nodes 
//					  (including those marked as deleted)
ERR ErrESEDUMPData( JET_SESID sesid, JET_DBUTIL *pdbutil )
	{
	ERR			err;
	JET_DBID	ifmp				= JET_dbidNil;
	JET_GRBIT 	grbitESEDUMPMode	= 0;
	
	Assert( NULL != pdbutil);
	Assert( sizeof(JET_DBUTIL) == pdbutil->cbStruct );
	Assert( NULL != pdbutil->szDatabase );

	// attach to the database
	CallR( ErrIsamAttachDatabase(
				sesid,
				pdbutil->szDatabase,
				NULL,
				NULL,
				0,
				JET_bitDbReadOnly
				) );
	Call( ErrIsamOpenDatabase(
				sesid,
				pdbutil->szDatabase,
				NULL,
				&ifmp,
				JET_bitDbExclusive | JET_bitDbReadOnly
				) );
	Assert( JET_dbidNil != ifmp );
	
	grbitESEDUMPMode = pdbutil->grbitOptions;

	// just dump the database space info if not "one table dump"
	if (!pdbutil->szTable)
		Call ( ErrESEDUMPDatabaseInfo( (PIB *)sesid, ifmp, grbitESEDUMPMode ) );

	addIndent();

	if ( rgfmp[ifmp].FSLVAttached() )
		{
#ifdef DISABLE_SLV
		Call( ErrERRCheck( JET_wrnNyi ) );
#else
		Call( ErrESEDUMPSpecialFDPs( sesid, ifmp, grbitESEDUMPMode ) );
#endif
		}

	if (!pdbutil->szTable || ( pdbutil->szTable && pdbutil->szTable[0] ) )
		{
		// dump the tables, if ERR jump to CloseDb and DetachDb
		Call( ErrESEDUMPTables( sesid, ifmp, pdbutil->szTable, grbitESEDUMPMode ) );
		}
	


HandleError:
	if ( JET_dbidNil != ifmp )
		{
		(VOID)ErrIsamCloseDatabase( sesid, ifmp, NO_GRBIT );
		}
	
	(VOID)ErrIsamDetachDatabase( sesid, NULL, pdbutil->szDatabase );

	return err;		
	}


// Dumps all the tables with nodes, space info, indexes, LV's
// It makes a loop into the Catalog and
// for each table call a DumpOneTable function
LOCAL ERR ErrESEDUMPTables( JET_SESID sesid, JET_DBID ifmp, char *szTable, JET_GRBIT grbitESEDUMPMode )
	{
	ERR			err;
	FUCB		*pfucbCatalog = 	pfucbNil;
	const BYTE	bTrue = 			0xff;

	// opens the catalog
	CallR( ErrCATOpen( (PIB *)sesid, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	// set that index in order to "see" only the tables (user and system tabels)
	Call ( ErrIsamSetCurrentIndex(
				(PIB *)sesid,
				pfucbCatalog,
				szMSORootObjectsIndex ) );

	Assert( pfcbNil != pfucbCatalog->u.pfcb );
	Assert( pfucbCatalog->u.pfcb->FTypeTable() );
	Assert( pfucbCatalog->u.pfcb->FFixedDDL() );
	Assert( pfucbCatalog->u.pfcb->PgnoFDP() == pgnoFDPMSO );

	if (szTable)
		{
		// if table name specified
		// make the key and seek
		Call( ErrIsamMakeKey(
					pfucbCatalog->ppib,
					pfucbCatalog,
					&bTrue,
					sizeof(bTrue),
					JET_bitNewKey ) );
		Call( ErrIsamMakeKey(
					pfucbCatalog->ppib,
					pfucbCatalog,
					(BYTE *)szTable,
					(ULONG)strlen(szTable),
					NO_GRBIT ) );
		err = ErrIsamSeek( pfucbCatalog->ppib, pfucbCatalog, JET_bitSeekEQ );
		if ( JET_errRecordNotFound == err )
			{
			addPBI("\n Table %s not found.\n", szTable);
			flushPB();
			}
		Call( err );

		Call (ErrESEDUMPOneTable(pfucbCatalog, szTable, grbitESEDUMPMode));
		
		}
	else
		{
		// if no table specified
		// move to the first record
		// it must exist (also JET_errRecordNotFound is error)
		Call ( ErrIsamMove( pfucbCatalog->ppib,
					pfucbCatalog,
					JET_MoveFirst,
					NO_GRBIT ));
					
		do
			{
			DATA	dataField;
			CHAR	szTableName[JET_cbNameMost+1];
			
			Assert( !Pcsr( pfucbCatalog )->FLatched() );
			Call( ErrDIRGet( pfucbCatalog ) );
			Assert( Pcsr( pfucbCatalog )->FLatched() );
					
			const DATA&	dataRec	= pfucbCatalog->kdfCurr.data;
			

			// get the table name
			Call( ErrRECIRetrieveVarColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_Name,
					dataRec,
					&dataField ) );
			Assert( JET_errSuccess == err );
			Assert( dataField.Cb() > 0 && dataField.Cb() <= JET_cbNameMost );
			UtilMemCpy( szTableName, dataField.Pv(), dataField.Cb() );
			szTableName[dataField.Cb()] = '\0';

			Assert( Pcsr( pfucbCatalog )->FLatched() );
			Call ( ErrDIRRelease( pfucbCatalog ) );
			Assert( !Pcsr( pfucbCatalog )->FLatched() );

			// dump the table
			Call (ErrESEDUMPOneTable(pfucbCatalog, szTableName, grbitESEDUMPMode));

			// move to the next table
			err = ErrIsamMove( 
						pfucbCatalog->ppib,
						pfucbCatalog,
						JET_MoveNext,
						NO_GRBIT );
			}
		while ( err >= 0);
			
		if ( JET_errNoCurrentRecord == err )
			err = JET_errSuccess;
		}
		
HandleError:
	Assert(pfucbNil != pfucbCatalog);
	CallS(ErrCATClose( (PIB *)sesid, pfucbCatalog ));
	return err;
	}


#ifdef DISABLE_SLV
#else

CHAR * FormatNodeInfoForSLVOwnerMap( KEYDATAFLAGS * pNode )
	{
	static char szBuffer[1024];
	
	PGNO pgno;

	Assert ( pNode );
#ifdef DEBUG	
	pNode->AssertValid();
#endif // DEBUG
	Assert ( sizeof(PGNO) == pNode->key.Cb() );
	
	LongFromKey( &pgno, pNode->key);

	SLVOWNERMAP slvownermapT;
	slvownermapT.Retrieve( pNode->data );
	
	const BYTE * pvKey = (const BYTE *)slvownermapT.PvKey();
	
	sprintf(
		szBuffer,
		"pgno:%u objid:%d columnid:0x%X ValidChecksum:%s checksum:0x%x cbData:%d cbKey:%d pvKey:",
		pgno,
		slvownermapT.Objid(), 
		slvownermapT.Columnid(), 
		slvownermapT.FValidChecksum() ? "Y" : "N",
		slvownermapT.UlChecksum(),
		slvownermapT.CbDataChecksummed(),
		slvownermapT.CbKey() );

	BYTE *	pbT		= (BYTE *)szBuffer + strlen( szBuffer );

	for ( ULONG i = 0; i < min( slvownermapT.CbKey(), MAX_KEY_SIZE_DISPLAY ); i++)
		{
		const BYTE	b	= pvKey[i];

		*pbT++ = mpbb[b >> 4];
		*pbT++ = mpbb[b & 0x0f];
		*pbT++ = ' ';
		}
	*pbT = 0;
		
	return szBuffer;
	}

LOCAL ERR ErrESEDUMPSpecialFDP(FUCB *pfucbCatalog, PGNO pgnoFDP, const char *szName, JET_GRBIT grbitESEDUMPMode, PfnFormatNodeInfo pfnFormat)
	{
	ERR	 		err 	= JET_errSuccess;
	FUCB * 		pfucb 	= pfucbNil;
	
	// open the directory

	CallR ( ErrDIROpen( pfucbCatalog->ppib, pgnoFDP, pfucbCatalog->ifmp, &pfucb ) );
	
	Assert( pfucbNil != pfucb );
	Assert( pfcbNil != pfucb->u.pfcb );
	Assert( pfucb->u.pfcb->FTypeSLVAvail() || pfucb->u.pfcb->FTypeSLVOwnerMap());


	// print the information about ifmp,
	// page and table name for this table (pageFDP)
	addPBI("\n");
	addPBI("[%d , %d] %s (Special)\n",
				pfucbCatalog->ifmp,
				pfucb->u.pfcb->PgnoFDP(),
				szName);
	flushPB();

	Call (ErrESEDUMPCheckAndDumpSpaceInfo(pfucb, grbitESEDUMPMode));


	// the function that dumps the nodes and must conserve
	// the table root page unlached
	Call (ErrESEDUMPNodesForOneTree(pfucb, grbitESEDUMPMode, pfnFormat));
		
HandleError:
	Assert( pfucbNil != pfucb );
	DIRClose( pfucb );	
	return err;
	}

// Dumps all the tables with nodes, space info, indexes, LV's
// It makes a loop into the Catalog and
// for each table call a DumpOneTable function
LOCAL ERR ErrESEDUMPSpecialFDPs( JET_SESID sesid, JET_DBID ifmp, JET_GRBIT grbitESEDUMPMode )
	{
	ERR			err;
	FUCB		*pfucbCatalog = 	pfucbNil;
	PGNO 		pgno;
	OBJID		objid;

	// opens the catalog
	CallR( ErrCATOpen( (PIB *)sesid, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	Assert( pfcbNil != pfucbCatalog->u.pfcb );
	Assert( pfucbCatalog->u.pfcb->FTypeTable() );
	Assert( pfucbCatalog->u.pfcb->FFixedDDL() );
	Assert( pfucbCatalog->u.pfcb->PgnoFDP() == pgnoFDPMSO );

	Call ( ErrCATAccessDbSLVAvail( (PIB *)sesid, ifmp, szSLVAvail, &pgno, &objid ) ) ;
	Call ( ErrESEDUMPSpecialFDP(pfucbCatalog, pgno, szSLVAvail, grbitESEDUMPMode) );

	Call ( ErrCATAccessDbSLVOwnerMap( (PIB *)sesid, ifmp, szSLVOwnerMap, &pgno, &objid ) ) ;
	Call ( ErrESEDUMPSpecialFDP(pfucbCatalog, pgno, szSLVOwnerMap, grbitESEDUMPMode, (PfnFormatNodeInfo) FormatNodeInfoForSLVOwnerMap) );
		
HandleError:
	Assert(pfucbNil != pfucbCatalog);
	CallS(ErrCATClose( (PIB *)sesid, pfucbCatalog ));
	return err;
	}

#endif	//	DISABLE_SLV


// dumps one table with nodes, space info, indexes, LV's
// szTableName - is the table name
// pfucbCatalob - get the session and database
LOCAL ERR ErrESEDUMPOneTable(FUCB *pfucbCatalog, char *szTableName, JET_GRBIT grbitESEDUMPMode)
	{
	ERR	err = 			JET_errSuccess;
	FUCB *pfucbTable = 	pfucbNil;
	
	// open the table
	CallR( ErrFILEOpenTable(
				pfucbCatalog->ppib,
				pfucbCatalog->ifmp,
				&pfucbTable,
				szTableName,
				JET_bitTableSequential ) );
	Assert( pfucbNil != pfucbTable );
	Assert( pfcbNil != pfucbTable->u.pfcb );
	Assert( pfucbTable->u.pfcb->FTypeTable() );


	// print the information about ifmp,
	// page and table name for this table (pageFDP)
	addPBI("\n");
	addPBI("[%d , %d] %s (Table)\n",
				pfucbCatalog->ifmp,
				pfucbTable->u.pfcb->PgnoFDP(),
				szTableName);
	flushPB();

	Call (ErrESEDUMPCheckAndDumpSpaceInfo(pfucbTable, grbitESEDUMPMode));


	// the function that dumps the nodes and must conserve
	// the table root page unlached
	Call (ErrESEDUMPNodesForOneTree(pfucbTable, grbitESEDUMPMode));
	
	// the function that dumps all the secondary indexes and must conserve
	// the table root page unlached
	Call (ErrESEDUMPIndexForOneTable(pfucbTable, grbitESEDUMPMode));
		
	// dump the LV's, if any
	// the function that dumps all the secondary indexes and must conserve
	// the table root page unlached
	Call (ErrESEDUMPLVForOneTable(pfucbTable, grbitESEDUMPMode));
	
HandleError:
	Assert( pfucbNil != pfucbTable );
	CallS( ErrFILECloseTable( pfucbCatalog->ppib, pfucbTable ) );	
	return err;
	}

// dump the LV tree (if it exists) for a table
LOCAL ERR ErrESEDUMPLVForOneTable(FUCB *pfucbTable, JET_GRBIT grbitESEDUMPMode)
{
	ERR	err = 		JET_errSuccess;
	FUCB *pfucbLV =	pfucbNil;

	Assert(pfucbTable);
	Assert( Pcsr(pfucbTable ));
	Assert( !Pcsr(pfucbTable )->FLatched() );
	
	addIndent();
	
	// get the LV root page handle
	err = ErrFILEOpenLVRoot( pfucbTable, &pfucbLV, fFalse );
	if ( JET_errSuccess == err )
		{		
		Assert(pfucbLV);
		Assert( !Pcsr(pfucbLV )->FLatched() );

		addPBI("\n");
		addPBI("[%d , %d] LONG VALUES:\n",
					pfucbLV->ifmp,
					pfucbLV->u.pfcb->PgnoFDP());		
		
		flushPB();
		FUCBSetIndex(pfucbLV);

		Call (ErrESEDUMPCheckAndDumpSpaceInfo(pfucbLV, grbitESEDUMPMode));

		Call (ErrESEDUMPNodesForOneTree(pfucbLV, grbitESEDUMPMode));
		
		DIRClose(pfucbLV);
		pfucbLV = pfucbNil;
		}
	else
		// if other error than No LV tree, it's error for good
		if ( wrnLVNoLongValues != err)
			{
			Call (err);
			}
		else
		// if wrnLVNoLongValues, that's fine
			err = JET_errSuccess;
	
HandleError:
	delIndent();
	
	if( pfucbNil != pfucbLV )
		DIRClose( pfucbLV );	

	Assert(pfucbTable);
	Assert( Pcsr(pfucbTable ));
	Assert( !Pcsr(pfucbTable )->FLatched() );

	return err;
	}


// dump the indexes
// iterates trough the secondary index list, if any
LOCAL ERR ErrESEDUMPIndexForOneTable(FUCB *pfucbTable, JET_GRBIT grbitESEDUMPMode)
	{
	
	ERR	err = 			JET_errSuccess;
	FUCB *pfucbIndex = 	pfucbNil;
	FCB * pfcb =		pfcbNil;
	
	
	Assert(pfucbTable);
	Assert( Pcsr(pfucbTable ));
	Assert( !Pcsr(pfucbTable )->FLatched() );

	// get the first secondary index
	pfcb = pfucbTable->u.pfcb->PfcbNextIndex();
	
	addIndent();
	
	// if a secondary index still exists ...	
	while (pfcb)
		{
		// open it
		Call (ErrDIROpen(
					pfucbTable->ppib,
					pfcb->PgnoFDP(),
					pfucbTable->ifmp,
					&pfucbIndex ));
					
		Assert(pfucbIndex != pfucbNil );
		
		FUCBSetIndex( pfucbIndex );

		// print the name of the index, with ifmp and pageNo.
		USHORT indexNameTag = 0;
		char * szIndexName = (char *)0;
		FCB *pfcbT = pfucbTable->u.pfcb;
		
		Assert(pfcbT);	
		Assert(pfucbIndex->u.pfcb->Pidb());
		indexNameTag = pfucbIndex->u.pfcb->Pidb()->ItagIndexName();

		Assert( pfcbT->Ptdb() );
		szIndexName = pfcbT->Ptdb()->SzIndexName(indexNameTag,
													pfucbIndex->u.pfcb->FDerivedIndex()); 			
		Assert(szIndexName);
				
			
		addPBI("\n");
		addPBI("[%d , %d] INDEX %s:\n",
					pfucbIndex->ifmp,
					pfucbIndex->u.pfcb->PgnoFDP(),
					szIndexName);
		flushPB();
		Assert( !Pcsr( pfucbIndex )->FLatched() );

		// dump the space info for the Index tree himself
		Call (ErrESEDUMPCheckAndDumpSpaceInfo(pfucbIndex, grbitESEDUMPMode));
		
		// dumps the nodes for the index
		Call (ErrESEDUMPNodesForOneTree(pfucbIndex, grbitESEDUMPMode));

		// close the current index
		DIRClose(pfucbIndex);
		pfucbIndex = pfucbNil;			

		// move to the next index
		pfcb = pfcb->PfcbNextIndex();
		}
	
HandleError:
	delIndent();
	if ( pfucbNil != pfucbIndex)
		{
		DIRClose(pfucbIndex);
		}

	Assert(pfucbTable);
	Assert( Pcsr(pfucbTable ));
	Assert( !Pcsr(pfucbTable )->FLatched() );
	return err;
	}

// dumps nodes from Btree 
// If the Btree is a space tree (nodes contains info about extents),
// the node info is processed in order to show the pages of the extent
// If the Btree is of other kind (table records, table index, LV) the nodes
// are dumped adding only info about the page/line/flags/key size/data size
// and the first part of the key is dumped also (see MAX_KEY_SIZE_DISPLAY)
LOCAL ERR ErrESEDUMPNodesForOneTree(FUCB *pfucbTable, JET_GRBIT grbitESEDUMPMode, PfnFormatNodeInfo pfnFormat)
	{
	ERR	err = 			JET_errSuccess;
	int fSpaceTree = 	fFalse;
	DIB dib;

	Assert( pfucbTable );
	Assert( Pcsr( pfucbTable ) );
	Assert( !Pcsr( pfucbTable )->FLatched() );
	
	// start to dump from the first node
	dib.pos 	= posFirst;			
	dib.dirflag = (grbitESEDUMPMode & JET_bitDBUtilOptionAllNodes)?
						fDIRAllNode:fDIRNull;

	err = ErrDIRDown( pfucbTable, &dib );	

	if ( JET_errRecordNotFound == err )
		{
		addIndent();
		addPBI("NODES: none \n");
		delIndent();
		flushPB();
		
		Assert(pfucbTable);
		Assert( Pcsr(pfucbTable ));
		Assert( !Pcsr(pfucbTable )->FLatched() );
		return JET_errSuccess;
		}

	if ( JET_errSuccess != err )
		{
		Assert(pfucbTable);
		Assert( Pcsr(pfucbTable ));
		Assert( !Pcsr(pfucbTable )->FLatched() );
		CallR (err);
		}

	Assert (JET_errSuccess == err );
	Assert( Pcsr(pfucbTable )->FLatched() );

	fSpaceTree = Pcsr(pfucbTable)->Cpage().FSpaceTree();
	
	addIndent();
	addPBI("NODES:\n");
	
	// print the header, there are small differences between 
	// ordinary and space tree nodes
	addIndent();
	addPBI("********************************"
				"**********************************\n");

	if (pfnFormat)
		{
		addPBI("Page    | Line | Flags | KSize | DSize | Node info \n");
		}
	else if (fSpaceTree)
		{
		addPBI("Page    | Line | Flags | KSize | DSize | Pages\n");
		}
	else
		{
		addPBI("Page    | Line | Flags | KSize | DSize | Key value\n");
		}
		
	addPBI("********************************"
				"**********************************\n");

	flushPB();

	// goes to each node of the tree
	// Obs: ErrESEDUMPIsamMove will return with 
	// JET_errRecordDeleted on deleted records
	while ( JET_errSuccess == err )
		{

		char *pCustomFormat;
		char keyDataPrintBuffer[ max ( MAX_KEY_SIZE_DISPLAY * 3 /* = space for " %02X" */ + 1,
									2*12 + 3 /* = "%lu - %lu"*/ + 1) ];
		
		keyDataPrintBuffer[0] = 0;
		
		if (pfnFormat)
			{
			pCustomFormat = pfnFormat( &pfucbTable->kdfCurr );
			}
		// print the extent pages info for space trees
		// or the key for others
		else if (fSpaceTree)
			{
			ULONG lastPage;
			PGNO noPages;
			
			LongFromKey(&lastPage, pfucbTable->kdfCurr.key);	
			Assert( pfucbTable->kdfCurr.data.Cb() == sizeof( PGNO ) );
			noPages = *(UnalignedLittleEndian< PGNO > *) pfucbTable->kdfCurr.data.Pv();

			Assert(lastPage >= noPages);
			sprintf(keyDataPrintBuffer, "%lu - %lu", lastPage - noPages + 1, lastPage);
			}
		else
			{
			char keyBuffer[MAX_KEY_SIZE_DISPLAY];
			
			pfucbTable->kdfCurr.key.CopyIntoBuffer( keyBuffer, 
						min(MAX_KEY_SIZE_DISPLAY,
							pfucbTable->kdfCurr.key.Cb()) );

			BYTE * pbT	= (BYTE *)keyDataPrintBuffer;

			for( ULONG i = 0 ;
				i < min(MAX_KEY_SIZE_DISPLAY, pfucbTable->kdfCurr.key.Cb());
				i++)
				{
				const BYTE	b	= keyBuffer[i];

				*pbT++ = mpbb[b >> 4];
				*pbT++ = mpbb[b & 0x0f];
				*pbT++ = ' ';
				}
			*pbT = 0;
			}

		// print the common info of the node and the specific ones at the end
		addPBI("%7d | %4d |  %c%c%c  | %5ld | %5ld | %s\n", 
					pfucbTable->csr.Pgno(),
					pfucbTable->csr.ILine(), 
					pfucbTable->kdfCurr.fFlags & fNDCompressed ? 'c':' ',
					pfucbTable->kdfCurr.fFlags & fNDDeleted ? 'd':' ',
					pfucbTable->kdfCurr.fFlags & fNDVersion ? 'v':' ',					
					pfucbTable->kdfCurr.key.Cb(),
					pfucbTable->kdfCurr.data.Cb(),
					pfnFormat?pCustomFormat:keyDataPrintBuffer);
		
		Assert( Pcsr( pfucbTable )->FLatched() );
		Call (ErrDIRRelease( pfucbTable ));
		Assert( !Pcsr( pfucbTable )->FLatched() );

		// move to next node
		err = ErrDIRNext(pfucbTable, (grbitESEDUMPMode & JET_bitDBUtilOptionAllNodes)?
						fDIRAllNode:fDIRNull);
		
		}

	// chech for error, JET_errNoCurrentRecord is not an error
	if (JET_errNoCurrentRecord == err )
		{
		err = JET_errSuccess;
		}

HandleError:
	flushPB();
	delIndent();
	delIndent();

	if ( Pcsr( pfucbTable )->FLatched() )
		(VOID)ErrDIRRelease( pfucbTable );
		
	Assert(pfucbTable);
	Assert( Pcsr(pfucbTable ));
	Assert( !Pcsr(pfucbTable )->FLatched() );
	return err;
	}


// Check the split buffer (and dump it) for space tree root
// Call ErrESEDUMPSpaceInfoForOneTree for pages that have 
// space info (root of tree and not SpaceTrees), where the
// space header is checked and dumped, if MultiExtent also
// the Own and Avail trees are dumped
LOCAL ERR ErrESEDUMPCheckAndDumpSpaceInfo(FUCB *pfucb, JET_GRBIT grbitESEDUMPMode)
	{	
	ERR	err = 			JET_errSuccess;
	int fIsSpaceTree = 	fFalse;
	int fIsRoot =		fFalse;
	LINE line;
	
	Assert(pfucb);
	Assert( Pcsr(pfucb ));
	Assert( !Pcsr(pfucb )->FLatched() );

	// get the root page (read mode) so that
	// the flags and buffer/header are accesible
	CallR (ErrBTIGotoRoot( pfucb, latchReadNoTouch ));
	Assert( Pcsr(pfucb )->FLatched() );

	fIsSpaceTree = Pcsr(pfucb )->Cpage().FSpaceTree();
	fIsRoot =  Pcsr(pfucb )->Cpage().FRootPage();

	if (!fIsSpaceTree && !fIsRoot)
		{
		goto HandleError;
		}

	
	Pcsr(pfucb )->Cpage().GetPtrExternalHeader( &line );

	Assert ( (fIsSpaceTree &&	sizeof( SPLIT_BUFFER ) == line.cb) ||
			 (fIsRoot && sizeof( SPACE_HEADER ) == line.cb) );
	
	// for space trees (with SPLIT_BUFFER) dump info on that one
	if (fIsSpaceTree)
		{		
		if (sizeof( SPLIT_BUFFER ) == line.cb)
			{
			SPLIT_BUFFER spb;
			UtilMemCpy( &spb, line.pv, sizeof( SPLIT_BUFFER ) );
			ESEDUMPSplitBufferDump(spb, pfucb, grbitESEDUMPMode);
			}
		else
			{
			addIndent();
			addPBI("SPLIT BUFFER not found in tree.\n");
			delIndent();
			}
		}
	else
		{
		SPACE_HEADER sph;
		
		UtilMemCpy( &sph, line.pv, sizeof( SPACE_HEADER ) );

		addIndent();
		addPBI("\n");
		addPBI("SPACE INFO:\n");		
		addIndent();
		addPBI("Primary extent size: %ld page%s\n", sph.CpgPrimary(),
					sph.CpgPrimary() == 1 ? "" : "s" );

		if ( sph.FSingleExtent())
			{
			ESEDUMPSingleSpaceHeaderDump(sph, pfucb, grbitESEDUMPMode);
			}
		else
			{
			err = ErrESEDUMPMultipleSpaceHeaderDump(sph, pfucb, grbitESEDUMPMode);
			}
			
		delIndent();
		delIndent();
		}

HandleError:
	flushPB();
	Assert(pfucb);
	Assert( Pcsr(pfucb ));
	Assert( Pcsr(pfucb )->FLatched() );
	BTUp(pfucb);
	Assert( !Pcsr(pfucb )->FLatched() );
	return err;	
	}


// Used to check only the database header, print the pagenumber
// then call the space info function for this page
LOCAL ERR ErrESEDUMPDatabaseInfo(PIB *ppib, IFMP ifmp, JET_GRBIT grbitESEDUMPMode)
	{
	FUCB *pfucbDb = 	pfucbNil;
	ERR	err = 			JET_errSuccess;
	
	// open the table
	CallR (ErrDIROpen( 
				ppib, 
				pgnoSystemRoot,
				ifmp,
				&pfucbDb ));
	Assert( pfucbNil != pfucbDb );
	Assert( pfcbNil != pfucbDb->u.pfcb );
	Assert( pgnoSystemRoot == pfucbDb->u.pfcb->PgnoFDP());

	addPBI("\n");
	addPBI("[%d , %d] DATABASE ROOT\n", ifmp, pgnoSystemRoot);
	flushPB();

	Call (ErrESEDUMPCheckAndDumpSpaceInfo(pfucbDb, grbitESEDUMPMode));

HandleError:
	DIRClose(pfucbDb);
	return err;
	}


// just dumps a SPLIT_BUFFER
LOCAL VOID ESEDUMPSplitBufferDump(SPLIT_BUFFER & spb, FUCB * pfucb, JET_GRBIT grbitESEDUMPMode)
{
	Assert(pfucb);
	Assert(Pcsr(pfucb));
	Assert(Pcsr(pfucb)->Cpage().FSpaceTree());
	
	addIndent();
	addPBI("SPLIT BUFFER:\n");
	addIndent();
	addPBI("Buffer 1: Pgno = %ld, Count %ld\n",
				spb.PgnoLastBuffer1(),
				spb.CpgBuffer1());
	addPBI("Buffer 2: Pgno = %ld, Count %ld\n",
				spb.PgnoLastBuffer2(),
				spb.CpgBuffer2());
	delIndent();	
	delIndent();	
	flushPB();
}

// dumps a SPACE_HEADER with SingleExtent
LOCAL VOID ESEDUMPSingleSpaceHeaderDump(SPACE_HEADER & sph, FUCB * pfucb, JET_GRBIT grbitESEDUMPMode)
{
	Assert( sph.FSingleExtent());
	Assert(pfucb);
	
	// space info are in the same space_header as bit array
	addPBI("Single extent covering pages %d to %d\n",
				PgnoFDP(pfucb),
				PgnoFDP(pfucb) + sph.CpgPrimary() -1 );		

	
	UINT rgbAvailBitMask = sph.RgbitAvail();
	UINT rgbCurrentPageMask = 0x1;
	
	PGNO pageNo = PgnoFDP(pfucb) + 1;

	char pagesPrintBuffer[ 8*sizeof(UINT) * 12 /* " %lu"  */ + 1];
	pagesPrintBuffer[0] = 0;
	
	while(rgbCurrentPageMask)
		{
		if (rgbAvailBitMask & rgbCurrentPageMask)	
			sprintf(pagesPrintBuffer + strlen(pagesPrintBuffer)," %lu", pageNo);

		rgbCurrentPageMask = rgbCurrentPageMask << 1;
		pageNo++;
		}
	addPBI("Avail pages : %s\n", pagesPrintBuffer);	
	flushPB();
}


// dumps a SPACE_HEADER with MutipleExtent
LOCAL ERR ErrESEDUMPMultipleSpaceHeaderDump(SPACE_HEADER & sph, FUCB * pfucb, JET_GRBIT grbitESEDUMPMode)
	{
	FUCB *pfucbExtent = 	pfucbNil;
	ERR	err = 				JET_errSuccess;
	
	Assert(pfucb);
	Assert( Pcsr(pfucb ));
	Assert( Pcsr(pfucb )->FLatched() );
	
	
	Assert (sph.FMultipleExtent());
	addPBI("Multiple extents\n");
	addPBI("Own extent page number   : %d\n", sph.PgnoOE());
	addPBI("Avail extent page number : %d\n", sph.PgnoAE());
	flushPB();
	
	// for each of two trees (own and avail)
	// we must dump the space tree and the nodes
	// 2 steps: 0 - Own, 1 - Avail
	for(int step = 0; step < 2; step++)
		{
		addPBI(step?"[%d , %d] AVAIL EXTENT:\n":"[%d , %d] OWN EXTENT:\n",
					pfucb->ifmp,
					step?sph.PgnoAE():sph.PgnoOE());
		flushPB();

		// open the page of the coresponding space tree
		Call (ErrDIROpen( 
					pfucb->ppib,
					step?sph.PgnoAE():sph.PgnoOE(),
					pfucb->ifmp,
					&pfucbExtent ));
		FUCBSetIndex( pfucbExtent );
		Assert( pfucbExtent != pfucbNil);
		
		Call (ErrESEDUMPCheckAndDumpSpaceInfo(pfucbExtent, grbitESEDUMPMode));

		Call (ErrESEDUMPNodesForOneTree(pfucbExtent, grbitESEDUMPMode));

		DIRClose(pfucbExtent);
		pfucbExtent = pfucbNil;					
		}

HandleError:
	if ( pfucbNil != pfucbExtent)
		{
		DIRClose(pfucbExtent);
		}
	Assert( pfucb );
	Assert( Pcsr(pfucb ) );
	Assert( Pcsr(pfucb )->FLatched() );
	flushPB();
	return err;	
	}

#endif	//	MINIMAL_FUNCTIONALITY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\fldenum.cxx ===
#include "std.hxx"


//	=======================================================================
//	class CFixedColumnIter
//	-----------------------------------------------------------------------
//

ERR CFixedColumnIter::
ErrMoveNext()
	{
	ERR	err	= JET_errSuccess;
	FID	fid;

	if ( !m_prec )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}
	
	fid = FidOfColumnid( m_columnidCurr + 1 );

	if ( fid > m_prec->FidFixedLastInRec() )
		{
		m_columnidCurr	= m_prec->FidFixedLastInRec() + 1;
		m_errCurr		= JET_errNoCurrentRecord;
		}
	else
		{
		m_columnidCurr	= ColumnidOfFid( fid, m_pfcb->Ptdb()->FFixedTemplateColumn( fid ) );
		m_errCurr		= JET_errSuccess;

		if ( fid > m_pfcb->Ptdb()->FidFixedLastInitial() )
			{
			m_pfcb->EnterDML();
			}
		m_fieldCurr		= *m_pfcb->Ptdb()->PfieldFixed( m_columnidCurr );
		if ( fid > m_pfcb->Ptdb()->FidFixedLastInitial() )
			{
			m_pfcb->LeaveDML();
			}
		}

	if ( m_errCurr < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurr ) );
		}

HandleError:
	return err;
	}

ERR CFixedColumnIter::
ErrSeek( const COLUMNID columnid )
	{
	ERR	err	= JET_errSuccess;
	FID	fid;

	if ( !m_prec )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}
	
	fid = FidOfColumnid( columnid );

	if ( fid < fidFixedLeast )
		{
		m_columnidCurr	= fidFixedLeast - 1;
		m_errCurr		= JET_errNoCurrentRecord;

		Call( ErrERRCheck( JET_errRecordNotFound ) );
		}
	else if ( fid > m_prec->FidFixedLastInRec() )
		{
		m_columnidCurr	= m_prec->FidFixedLastInRec() + 1;
		m_errCurr		= JET_errNoCurrentRecord;

		Call( ErrERRCheck( JET_errRecordNotFound ) );
		}
	else
		{
		m_columnidCurr	= columnid;
		m_errCurr		= JET_errSuccess;

		if ( fid > m_pfcb->Ptdb()->FidFixedLastInitial() )
			{
			m_pfcb->EnterDML();
			}
		m_fieldCurr		= *m_pfcb->Ptdb()->PfieldFixed( m_columnidCurr );
		if ( fid > m_pfcb->Ptdb()->FidFixedLastInitial() )
			{
			m_pfcb->LeaveDML();
			}
		}

	if ( m_errCurr < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurr ) );
		}

HandleError:
	return err;
	}

ERR CFixedColumnIter::
ErrGetColumnValueCount( size_t* const pcColumnValue ) const
	{
	ERR		err			= JET_errSuccess;
	size_t	ifid;
	BYTE*	prgbitNullity;

	if ( m_errCurr < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurr ) );
		}

	ifid			= FidOfColumnid( m_columnidCurr ) - fidFixedLeast;
	prgbitNullity	= m_prec->PbFixedNullBitMap() + ifid / 8;

	*pcColumnValue = FFixedNullBit( prgbitNullity, ifid ) ? 0 : 1;

HandleError:
	return err;
	}

ERR CFixedColumnIter::
ErrGetColumnValue(	const size_t	iColumnValue,
					size_t* const	pcbColumnValue,
					void** const	ppvColumnValue,
					BOOL* const		pfColumnValueSeparated ) const
	{
	ERR err = JET_errSuccess;

	if ( m_errCurr < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurr ) );
		}

	if ( iColumnValue != 1 )
		{
		Call( ErrERRCheck( JET_errBadItagSequence ) );
		}

	*pcbColumnValue			= m_fieldCurr.cbMaxLen;
	*ppvColumnValue			= (BYTE*)m_prec + m_fieldCurr.ibRecordOffset;
	*pfColumnValueSeparated	= fFalse;

HandleError:
	return err;
	}

//	=======================================================================


//	=======================================================================
//	class CVariableColumnIter
//	-----------------------------------------------------------------------
//

ERR CVariableColumnIter::
ErrMoveNext()
	{
	ERR	err	= JET_errSuccess;
	FID	fid;

	if ( !m_prec )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}
	
	fid = FidOfColumnid( m_columnidCurr + 1 );

	if ( fid > m_prec->FidVarLastInRec() )
		{
		m_columnidCurr	= m_prec->FidVarLastInRec() + 1;
		m_errCurr		= JET_errNoCurrentRecord;
		}
	else
		{
		m_columnidCurr	= ColumnidOfFid( fid, m_pfcb->Ptdb()->FVarTemplateColumn( fid ) );
		m_errCurr		= JET_errSuccess;
		}

	if ( m_errCurr < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurr ) );
		}

HandleError:
	return err;
	}

ERR CVariableColumnIter::
ErrSeek( const COLUMNID columnid )
	{
	ERR	err	= JET_errSuccess;
	FID	fid;

	if ( !m_prec )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}
	
	fid = FidOfColumnid( columnid );

	if ( fid < fidVarLeast )
		{
		m_columnidCurr	= fidVarLeast - 1;
		m_errCurr		= JET_errNoCurrentRecord;

		Call( ErrERRCheck( JET_errRecordNotFound ) );
		}
	else if ( fid > m_prec->FidVarLastInRec() )
		{
		m_columnidCurr	= m_prec->FidVarLastInRec() + 1;
		m_errCurr		= JET_errNoCurrentRecord;

		Call( ErrERRCheck( JET_errRecordNotFound ) );
		}
	else
		{
		m_columnidCurr	= columnid;
		m_errCurr		= JET_errSuccess;
		}

	if ( m_errCurr < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurr ) );
		}

HandleError:
	return err;
	}

ERR CVariableColumnIter::
ErrGetColumnValueCount( size_t* const pcColumnValue ) const
	{
	ERR											err			= JET_errSuccess;
	size_t										ifid;
	UnalignedLittleEndian< REC::VAROFFSET >*	pibVarOffs;

	if ( m_errCurr < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurr ) );
		}

	ifid		= FidOfColumnid( m_columnidCurr ) - fidVarLeast;
	pibVarOffs	= m_prec->PibVarOffsets();

	*pcColumnValue = FVarNullBit( pibVarOffs[ ifid ] ) ? 0 : 1;

HandleError:
	return err;
	}


ERR CVariableColumnIter::
ErrGetColumnValue(	const size_t	iColumnValue,
					size_t* const	pcbColumnValue,
					void** const	ppvColumnValue,
					BOOL* const		pfColumnValueSeparated ) const
	{
	ERR											err				= JET_errSuccess;
	size_t										ifid;
	UnalignedLittleEndian< REC::VAROFFSET >*	pibVarOffs;
	REC::VAROFFSET								ibStartOfColumn;

	if ( m_errCurr < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurr ) );
		}

	if ( iColumnValue != 1 )
		{
		Call( ErrERRCheck( JET_errBadItagSequence ) );
		}

	ifid			= FidOfColumnid( m_columnidCurr ) - fidVarLeast;
	pibVarOffs		= m_prec->PibVarOffsets();
	ibStartOfColumn	= m_prec->IbVarOffsetStart( FidOfColumnid( m_columnidCurr ) );

	*pcbColumnValue = IbVarOffset( pibVarOffs[ ifid ] ) - ibStartOfColumn;
	if ( *pcbColumnValue == 0 )
		{
		*ppvColumnValue = NULL;
		}
	else
		{
		*ppvColumnValue = m_prec->PbVarData() + ibStartOfColumn;
		}
	*pfColumnValueSeparated = fFalse;

HandleError:
	return err;
	}

//	=======================================================================


//	=======================================================================
//	class CSingleValuedTaggedColumnValueIter
//	-----------------------------------------------------------------------
//

ERR CSingleValuedTaggedColumnValueIter::
ErrGetColumnValue(	const size_t	iColumnValue,
					size_t* const	pcbColumnValue,
					void** const	ppvColumnValue,
					BOOL* const		pfColumnValueSeparated ) const
	{
	ERR err = JET_errSuccess;

	if ( !m_rgbData )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}

	if ( iColumnValue != 1 )
		{
		Call( ErrERRCheck( JET_errBadItagSequence ) );
		}

	*pcbColumnValue			= m_cbData;
	*ppvColumnValue			= m_rgbData;
	*pfColumnValueSeparated	= m_fSeparated;

HandleError:
	return err;
	}

//	=======================================================================


//	=======================================================================
//	class CDualValuedTaggedColumnValueIter
//	-----------------------------------------------------------------------
//

ERR CDualValuedTaggedColumnValueIter::
ErrGetColumnValue(	const size_t	iColumnValue,
					size_t* const	pcbColumnValue,
					void** const	ppvColumnValue,
					BOOL* const		pfColumnValueSeparated ) const
	{
	ERR err = JET_errSuccess;

	if ( !m_ptwovalues )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}

	if ( iColumnValue < 1 || iColumnValue > 2 )
		{
		Call( ErrERRCheck( JET_errBadItagSequence ) );
		}

	if ( iColumnValue == 1 )
		{
		*pcbColumnValue	= m_ptwovalues->CbFirstValue();
		*ppvColumnValue	= m_ptwovalues->PbData();
		}
	else
		{
		*pcbColumnValue	= m_ptwovalues->CbSecondValue();
		*ppvColumnValue	= m_ptwovalues->PbData() + m_ptwovalues->CbFirstValue();
		}

	*pfColumnValueSeparated = fFalse;

HandleError:
	return err;
	}

//	=======================================================================


//	=======================================================================
//	class CMultiValuedTaggedColumnValueIter
//	-----------------------------------------------------------------------
//

ERR CMultiValuedTaggedColumnValueIter::
ErrGetColumnValue(	const size_t	iColumnValue,
					size_t* const	pcbColumnValue,
					void** const	ppvColumnValue,
					BOOL* const		pfColumnValueSeparated ) const
	{
	ERR err = JET_errSuccess;

	if ( !m_pmultivalues )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}

	if ( iColumnValue < 1 || iColumnValue > m_pmultivalues->CMultiValues() )
		{
		Call( ErrERRCheck( JET_errBadItagSequence ) );
		}

	*pcbColumnValue			= m_pmultivalues->CbData( iColumnValue - 1 );
	*ppvColumnValue			= m_pmultivalues->PbData( iColumnValue - 1 );
	*pfColumnValueSeparated	= m_pmultivalues->FSeparatedInstance( iColumnValue - 1 );

HandleError:
	return err;
	}

size_t CMultiValuedTaggedColumnValueIter::
CbESE97Format() const
	{
	const ULONG	cMultiValues	= m_pmultivalues->CMultiValues();
	const BOOL	fSeparatable	= ( m_pmultivalues->Pheader()->FColumnCanBeSeparated() );
	const ULONG cbMVOverhead	= sizeof(TAGFLD) + ( fSeparatable ? sizeof(BYTE) : 0 );		//	if separatable, long-value overhead required
	size_t		cbESE97Format	= cbMVOverhead * cMultiValues;	//	initialise with overhead for each multi-value

	for ( ULONG imv = 0; imv < cMultiValues; imv++ )
		{
		const ULONG		cbMV	= m_pmultivalues->CbData( imv );

		if ( fSeparatable )
			{
			//	if the column is separatable and the data is greater than sizeof(LID),
			//	we may force the data to an LV
			//
			cbESE97Format += min( cbMV, sizeof(LID) );
			}
		else
			{
			cbESE97Format += cbMV;
			}
		}

	return cbESE97Format;
	}

//	=======================================================================

ERR CTaggedColumnIter::
ErrMoveNext()
	{
	ERR			err		= JET_errSuccess;
	TAGFLD*		ptagfld;

	if ( !m_ptagfields )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}
	
	ptagfld = m_ptagfldCurr + 1;

	if ( ptagfld > m_ptagfields->Rgtagfld() + m_ptagfields->CTaggedColumns() - 1 )
		{
		m_ptagfldCurr	= m_ptagfields->Rgtagfld() + m_ptagfields->CTaggedColumns();
		m_errCurr		= JET_errNoCurrentRecord;
		}
	else
		{
		m_ptagfldCurr	= ptagfld;
		m_errCurr		= JET_errSuccess;
		
		Call( ErrCreateCVIter( &m_pcviterCurr ) );
		}

	if ( m_errCurr < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurr ) );
		}

HandleError:
	m_errCurr = err;
	return err;
	}

ERR CTaggedColumnIter::
ErrSeek( const COLUMNID columnid )
	{
	ERR			err				= JET_errSuccess;
	BOOL		fUseDerivedBit	= fFalse;
	FCB*		pfcb			= m_pfcb;
	FID			fid;
	size_t		itagfld;
	TAGFLD*		ptagfld;

	if ( !m_ptagfields )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}

	if ( FCOLUMNIDTemplateColumn( columnid ) )
		{
		if ( !pfcb->FTemplateTable() )
			{
			pfcb->Ptdb()->AssertValidDerivedTable();

			//	HACK: treat derived columns in original-format derived table as
			//	non-derived, because they don't have the fDerived bit set in the TAGFLD
			fUseDerivedBit = FRECUseDerivedBitForTemplateColumnInDerivedTable( columnid, pfcb->Ptdb() );

			// switch to template table
			pfcb = pfcb->Ptdb()->PfcbTemplateTable();
			}
		else
			{
			pfcb->Ptdb()->AssertValidTemplateTable();
			Assert( !fUseDerivedBit );
			}
		}
	else
		{
		Assert( !pfcb->FTemplateTable() );
		}

	fid		= FidOfColumnid( columnid );
	itagfld	= m_ptagfields->ItagfldFind( TAGFLD( fid, fUseDerivedBit ) );
	ptagfld	= m_ptagfields->Rgtagfld() + itagfld;

	if (	itagfld < m_ptagfields->CTaggedColumns() &&
			ptagfld->FIsEqual( fid, fUseDerivedBit ) )
		{
		m_ptagfldCurr	= ptagfld;
		m_errCurr		= JET_errSuccess;

		Call( ErrCreateCVIter( &m_pcviterCurr ) );
		}
	else
		{
		m_ptagfldCurr	= ptagfld - 1;
		m_errCurr		= JET_errNoCurrentRecord;

		Call( ErrERRCheck( JET_errRecordNotFound ) );
		}

	if ( m_errCurr < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurr ) );
		}

HandleError:
	m_errCurr = err;
	return err;
	}

ERR CTaggedColumnIter::
ErrCreateCVIter( IColumnValueIter** const ppcviter )
	{
	ERR err = JET_errSuccess;
	
	if ( m_ptagfldCurr->FNull() )
		{
		CNullValuedTaggedColumnValueIter* pcviterNV = new( m_rgbCVITER ) CNullValuedTaggedColumnValueIter();
		Call( pcviterNV->ErrInit() );
		*ppcviter = pcviterNV;
		}
	else
		{
		BYTE*	rgbData	= m_ptagfields->PbTaggedColumns() + m_ptagfldCurr->Ib();
		size_t	cbData	= m_ptagfields->CbData( ULONG( m_ptagfldCurr - m_ptagfields->Rgtagfld() ) );

		if ( !m_ptagfldCurr->FExtendedInfo() )
			{
			CSingleValuedTaggedColumnValueIter* pcviterSV = new( m_rgbCVITER ) CSingleValuedTaggedColumnValueIter();
			Call( pcviterSV->ErrInit( rgbData, cbData, fFalse, fFalse ) );
			*ppcviter = pcviterSV;
			}
		else
			{
			TAGFLD_HEADER* ptagfldhdr = (TAGFLD_HEADER*)rgbData;

			if ( ptagfldhdr->FTwoValues() )
				{
				CDualValuedTaggedColumnValueIter* pcviterDV = new( m_rgbCVITER ) CDualValuedTaggedColumnValueIter();
				Call( pcviterDV->ErrInit( rgbData, cbData ) );
				*ppcviter = pcviterDV;
				}
			else if ( ptagfldhdr->FMultiValues() )
				{
				CMultiValuedTaggedColumnValueIter* pcviterMV = new( m_rgbCVITER ) CMultiValuedTaggedColumnValueIter();
				Call( pcviterMV->ErrInit( rgbData, cbData ) );
				*ppcviter = pcviterMV;
				}
			else
				{
				//	only other reason we have extended info is because the column might be separated
				//
				Assert( ptagfldhdr->FColumnCanBeSeparated() );

				CSingleValuedTaggedColumnValueIter* pcviterSV = new( m_rgbCVITER ) CSingleValuedTaggedColumnValueIter();
				Call( pcviterSV->ErrInit(	rgbData + sizeof( TAGFLD_HEADER ),
											cbData - sizeof( TAGFLD_HEADER ),
											ptagfldhdr->FColumnCanBeSeparated(),
											ptagfldhdr->FSeparated() ) );
				*ppcviter = pcviterSV;
				}
			}
		}

HandleError:
	return err;
	}

//	=======================================================================


//	=======================================================================
//	class CUnionIter
//	-----------------------------------------------------------------------
//

ERR CUnionIter::
ErrGetWorstCaseColumnCount( size_t* const pcColumn ) const
	{
	ERR		err			= JET_errSuccess;
	size_t	cColumnLHS;
	size_t	cColumnRHS;

	if ( !m_pciterLHS )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}
	
	Call( m_pciterLHS->ErrGetWorstCaseColumnCount( &cColumnLHS ) );
	Call( m_pciterRHS->ErrGetWorstCaseColumnCount( &cColumnRHS ) );

	*pcColumn = cColumnLHS + cColumnRHS;

HandleError:
	return err;
	}


ERR CUnionIter::
ErrMoveBeforeFirst()
	{
	ERR err = JET_errSuccess;

	if ( !m_pciterLHS )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}

	Call( m_pciterLHS->ErrMoveBeforeFirst() );
	
	Call( m_pciterRHS->ErrMoveBeforeFirst() );
	err = m_pciterRHS->ErrMoveNext();
	Call( err == JET_errNoCurrentRecord ? JET_errSuccess : err );

	m_pciterCurr = m_pciterLHS;

HandleError:
	return err;
	}

ERR CUnionIter::
ErrMoveNext()
	{
	ERR			err			= JET_errSuccess;
	COLUMNID	columnidLHS;
	COLUMNID	columnidRHS;

	if ( !m_pciterLHS )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}

	err = m_pciterCurr->ErrMoveNext();
	Call( err == JET_errNoCurrentRecord ? JET_errSuccess : err );

	err = m_pciterLHS->ErrGetColumnId( &columnidLHS );
	if ( err == JET_errNoCurrentRecord )
		{
		err = JET_errSuccess;
		columnidLHS = ~fCOLUMNIDTemplate;
		}
	Call( err );
	
	err = m_pciterRHS->ErrGetColumnId( &columnidRHS );
	if ( err == JET_errNoCurrentRecord )
		{
		err = JET_errSuccess;
		columnidRHS = ~fCOLUMNIDTemplate;
		}
	Call( err );

	if ( ( columnidLHS ^ fCOLUMNIDTemplate ) < ( columnidRHS ^ fCOLUMNIDTemplate ) )
		{
		m_pciterCurr = m_pciterLHS;
		}
	else if ( ( columnidLHS ^ fCOLUMNIDTemplate ) > ( columnidRHS ^ fCOLUMNIDTemplate ) )
		{
		m_pciterCurr = m_pciterRHS;
		}
	else
		{
		if ( columnidLHS != ~fCOLUMNIDTemplate )
			{
			err = m_pciterRHS->ErrMoveNext();
			Call( err == JET_errNoCurrentRecord ? JET_errSuccess : err );

			m_pciterCurr = m_pciterLHS;
			}
		else
			{
			Call( ErrERRCheck( JET_errNoCurrentRecord ) );
			}
		}

HandleError:
	return err;
	}

ERR CUnionIter::
ErrSeek( const COLUMNID columnid )
	{
	ERR err = JET_errSuccess;

	if ( !m_pciterLHS )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}

	m_pciterCurr = m_pciterLHS;
	err = m_pciterCurr->ErrSeek( columnid );

	if ( err == JET_errRecordNotFound )
		{
		m_pciterCurr = m_pciterRHS;
		err = m_pciterCurr->ErrSeek( columnid );
		}

HandleError:
	return err;
	}

//	=======================================================================


//	=======================================================================

LOCAL ErrRECIFetchMissingLVs(
	FUCB*					pfucb,
	ULONG*					pcEnumColumn,
	JET_ENUMCOLUMN**		prgEnumColumn,
	JET_PFNREALLOC			pfnRealloc,
	void*					pvReallocContext,
	ULONG					cbDataMost,
	BOOL					fAfterImage )
	{
	ERR						err					= JET_errSuccess;
	ULONG					cEnumColumnT		= 0;
	ULONG&					cEnumColumn			= ( pcEnumColumn ? *pcEnumColumn : cEnumColumnT );
	JET_ENUMCOLUMN*			rgEnumColumnT		= NULL;
	JET_ENUMCOLUMN*&		rgEnumColumn		= ( prgEnumColumn ? *prgEnumColumn : rgEnumColumnT );
	size_t					iEnumColumn;
	size_t					iEnumColumnValue;

	//  release our page latch, if any
	
	if ( Pcsr( pfucb )->FLatched() )
		{
		CallS( ErrDIRRelease( pfucb ) );
		}
	AssertDIRNoLatch( pfucb->ppib );

	//  walk all column values looking for missing separated LVs
	
	for ( iEnumColumn = 0; iEnumColumn < cEnumColumn; iEnumColumn++ )
		{
		JET_ENUMCOLUMN* const pEnumColumn = &rgEnumColumn[ iEnumColumn ];

		if ( pEnumColumn->err != JET_wrnColumnSingleValue )
			{
			for (	iEnumColumnValue = 0;
					iEnumColumnValue < rgEnumColumn[ iEnumColumn ].cEnumColumnValue;
					iEnumColumnValue++ )
				{
				JET_ENUMCOLUMNVALUE* const pEnumColumnValue = &pEnumColumn->rgEnumColumnValue[ iEnumColumnValue ];

				//  if this isn't a missing separated LV then skip it

				if ( pEnumColumnValue->err != wrnRECSeparatedLV )
					{
					continue;
					}

				//  retrieve the LID from cbData

				const LID lid = pEnumColumnValue->cbData;
				
				pEnumColumnValue->err		= JET_errSuccess;
				pEnumColumnValue->cbData	= 0;

				//  fetch up to the requested maximum column value size of this
				//  LV.  note that in this mode, we are retrieving a pointer to
				//  a newly allocated buffer containing the LV data NOT the LV
				//  data itself

				Call( ErrRECRetrieveSLongField(	pfucb,
												lid,
												fAfterImage,
												0,
												(BYTE*)&pEnumColumnValue->pvData,
												cbDataMost,
										  		&pEnumColumnValue->cbData,
										  		pfnRealloc,
										  		pvReallocContext,
										  		prceNil ) );

				//  if the returned cbActual is larger than cbDataMost then we
				//  obviously only got cbDataMost bytes of data.  warn the caller
				//  that they didn't get all the data

				if ( pEnumColumnValue->cbData > cbDataMost )
					{
					pEnumColumnValue->err		= JET_wrnColumnTruncated;
					pEnumColumnValue->cbData	= cbDataMost;
					}
				}
			}
		}

HandleError:
	return err;
	}

LOCAL ErrRECEnumerateAllColumns(
	FUCB*					pfucb,
	ULONG*					pcEnumColumn,
	JET_ENUMCOLUMN**		prgEnumColumn,
	JET_PFNREALLOC			pfnRealloc,
	void*					pvReallocContext,
	ULONG					cbDataMost,
	JET_GRBIT				grbit )
	{
	ERR						err					= JET_errSuccess;
	ULONG					cEnumColumnT;
	ULONG&					cEnumColumn			= ( pcEnumColumn ? *pcEnumColumn : cEnumColumnT );
							cEnumColumn			= 0;
	JET_ENUMCOLUMN*			rgEnumColumnT;
	JET_ENUMCOLUMN*&		rgEnumColumn		= ( prgEnumColumn ? *prgEnumColumn : rgEnumColumnT );
							rgEnumColumn		= NULL;
	size_t					iEnumColumn;
	size_t					iEnumColumnValue;
	BOOL					fSeparatedLV		= fFalse;
	BOOL					fRecord				= fFalse;
	BOOL					fDefaultRecord		= fFalse;
	BOOL					fNonEscrowDefault	= fFalse;
	BOOL					fTaggedOnly			= fFalse;
	BOOL					fUseCopyBuffer		= fFalse;
	DATA*					pdataRec			= NULL;
	DATA*					pdataDefaultRec		= NULL;

	CFixedColumnIter		rgciterFC[ 2 ];
	size_t					iciterFC			= 0;
	CFixedColumnIter*		pciterFC			= NULL;
	CVariableColumnIter		rgciterVC[ 2 ];
	size_t					iciterVC			= 0;
	CVariableColumnIter*	pciterVC			= NULL;
	CTaggedColumnIter		rgciterTC[ 2 ];
	size_t					iciterTC			= 0;
	CTaggedColumnIter*		pciterTC			= NULL;
	CUnionIter				rgciterU[ 5 ];
	size_t					iciterU				= 0;
	CUnionIter*				pciterU				= NULL;

	IColumnIter*			pciterRec			= NULL;
	IColumnIter*			pciterDefaultRec	= NULL;
	IColumnIter*			pciterRoot			= NULL;

	size_t					cAlloc;
	size_t					cbAlloc;
	FIELD					fieldFC;
	size_t					cColumnValue		= 0;
	BOOL					fSeparated			= fFalse;
	size_t					cbData				= 0;
	void*					pvData				= NULL;

	//  validate parameters

	if ( !pcEnumColumn || !prgEnumColumn || !pfnRealloc )
		{
		Call( ErrERRCheck( JET_errInvalidParameter ) );
		}
	if ( grbit & ~(	JET_bitEnumerateCopy |
					JET_bitEnumerateIgnoreDefault |
					JET_bitEnumerateLocal |
					JET_bitEnumeratePresenceOnly |
					JET_bitEnumerateTaggedOnly |
					JET_bitEnumerateCompressOutput ) )
		{
		Call( ErrERRCheck( JET_errInvalidGrbit ) );
		}

	//  NOCODE:  JET_bitEnumerateLocal is NYI

	if ( grbit & JET_bitEnumerateLocal )
		{
		Call( ErrERRCheck( JET_errInvalidGrbit ) );
		}

	//  NOCODE:  integration with user-defined callbacks is NYI

	if ( pfucb->u.pfcb->Ptdb()->FTableHasUserDefinedDefault() )
		{
		Call( ErrERRCheck( JET_errCallbackFailed ) );
		}
	
	fRecord				= fTrue;
	fDefaultRecord		= !( grbit & JET_bitEnumerateIgnoreDefault ) && pfucb->u.pfcb->Ptdb()->FTableHasDefault();
	fNonEscrowDefault	= pfucb->u.pfcb->Ptdb()->FTableHasNonEscrowDefault();
	fTaggedOnly			= grbit & JET_bitEnumerateTaggedOnly;

	//  get access to the data we need
	//
	//  NOTE:  do not unlatch the page until we are done with the iterators!

	if ( fRecord )
		{
		fUseCopyBuffer = (	(	( grbit & JET_bitEnumerateCopy ) &&
								FFUCBUpdatePrepared( pfucb ) &&
								!FFUCBNeverRetrieveCopy( pfucb ) ) ||
							FFUCBAlwaysRetrieveCopy( pfucb ) );
			
		Call( ErrRECIGetRecord( pfucb, &pdataRec, fUseCopyBuffer ) );
		}
	if ( fDefaultRecord )
		{
		pdataDefaultRec = pfucb->u.pfcb->Ptdb()->PdataDefaultRecord();
		}

	//  build an iterator tree over all our input data
	//
	//  NOTE:  if no input data is needed then the root iterator will be NULL!
	//  NOTE:  make sure we have enough iterator storage to hold these iterators

	if ( fRecord )
		{
		if ( !fTaggedOnly )
			{
			pciterVC = &rgciterVC[ iciterVC++ ];
			Call( pciterVC->ErrInit( pfucb->u.pfcb, *pdataRec ) );
			if ( !pciterRec )
				{
				pciterRec = pciterVC;
				}
			else
				{
				pciterU = &rgciterU[ iciterU++ ];
				Call( pciterU->ErrInit( pciterVC, pciterRec ) );
				pciterRec = pciterU;
				}
			}

		if ( !fTaggedOnly )
			{
			pciterFC = &rgciterFC[ iciterFC++ ];
			Call( pciterFC->ErrInit( pfucb->u.pfcb, *pdataRec ) );
			if ( !pciterRec )
				{
				pciterRec = pciterFC;
				}
			else
				{
				pciterU = &rgciterU[ iciterU++ ];
				Call( pciterU->ErrInit( pciterFC, pciterRec ) );
				pciterRec = pciterU;
				}
			}

		pciterTC = &rgciterTC[ iciterTC++ ];
		Call( pciterTC->ErrInit( pfucb->u.pfcb, *pdataRec ) );
		if ( !pciterRec )
			{
			pciterRec = pciterTC;
			}
		else
			{
			pciterU = &rgciterU[ iciterU++ ];
			Call( pciterU->ErrInit( pciterTC, pciterRec ) );
			pciterRec = pciterU;
			}
		
		if ( !pciterRoot )
			{
			pciterRoot = pciterRec;
			}
		else
			{
			pciterU = &rgciterU[ iciterU++ ];
			Call( pciterU->ErrInit( pciterRoot, pciterRec ) );
			pciterRoot = pciterU;
			}
		}
	
	if ( fDefaultRecord )
		{
		if ( !fTaggedOnly && fNonEscrowDefault )
			{
			pciterVC = &rgciterVC[ iciterVC++ ];
			Call( pciterVC->ErrInit( pfucb->u.pfcb, *pdataDefaultRec ) );
			if ( !pciterDefaultRec )
				{
				pciterDefaultRec = pciterVC;
				}
			else
				{
				pciterU = &rgciterU[ iciterU++ ];
				Call( pciterU->ErrInit( pciterVC, pciterDefaultRec ) );
				pciterDefaultRec = pciterU;
				}
			}

		if ( !fTaggedOnly )
			{
			pciterFC = &rgciterFC[ iciterFC++ ];
			Call( pciterFC->ErrInit( pfucb->u.pfcb, *pdataDefaultRec ) );
			if ( !pciterDefaultRec )
				{
				pciterDefaultRec = pciterFC;
				}
			else
				{
				pciterU = &rgciterU[ iciterU++ ];
				Call( pciterU->ErrInit( pciterFC, pciterDefaultRec ) );
				pciterDefaultRec = pciterU;
				}
			}

		if ( fNonEscrowDefault )
			{
			pciterTC = &rgciterTC[ iciterTC++ ];
			Call( pciterTC->ErrInit( pfucb->u.pfcb, *pdataDefaultRec ) );
			if ( !pciterDefaultRec )
				{
				pciterDefaultRec = pciterTC;
				}
			else
				{
				pciterU = &rgciterU[ iciterU++ ];
				Call( pciterU->ErrInit( pciterTC, pciterDefaultRec ) );
				pciterDefaultRec = pciterU;
				}
			}

		if ( pciterDefaultRec )
			{
			if ( !pciterRoot )
				{
				pciterRoot = pciterDefaultRec;
				}
			else
				{
				pciterU = &rgciterU[ iciterU++ ];
				Call( pciterU->ErrInit( pciterRoot, pciterDefaultRec ) );
				pciterRoot = pciterU;
				}
			}
		}

	//  get worst case storage for the column array
	
	Call( pciterRoot->ErrGetWorstCaseColumnCount( &cAlloc ) );
	cbAlloc = cAlloc * sizeof( JET_ENUMCOLUMN );

	Alloc( rgEnumColumn = (JET_ENUMCOLUMN*)pfnRealloc(
			pvReallocContext,
			NULL,
			cbAlloc ) );

	cEnumColumn = (ULONG)cAlloc;
	memset( rgEnumColumn, 0, cbAlloc );

	//  walk all columns in the input data

	Call( pciterRoot->ErrMoveBeforeFirst() );
	for ( iEnumColumn = 0; iEnumColumn < cEnumColumn; iEnumColumn++ )
		{
		JET_ENUMCOLUMN* const pEnumColumn = &rgEnumColumn[ iEnumColumn ];

		//  if we have walked off the end of the input array then we are done
		
		err = pciterRoot->ErrMoveNext();
		if ( err == JET_errNoCurrentRecord )
			{
			err = JET_errSuccess;
			cEnumColumn = iEnumColumn;
			continue;
			}
		Call( err );

		//  if we do not have access to this column then do not include it
		//  in the output array
		
		Call( pciterRoot->ErrGetColumnId( &pEnumColumn->columnid ) );

		err = ErrRECIAccessColumn( pfucb, pEnumColumn->columnid, &fieldFC );
		if ( err == JET_errColumnNotFound )
			{
			err = JET_errSuccess;
			iEnumColumn--;
			continue;
			}
		Call( err );

		//  get the properties for this column

		Call( pciterRoot->ErrGetColumnValueCount( &cColumnValue ) );

		//  if the column is NULL then include it in the output array

		if ( !cColumnValue )
			{
			pEnumColumn->err = ErrERRCheck( JET_wrnColumnNull );
			continue;
			}

		//  if we are testing for the presence of a column value only then
		//  return that it is present but do not return any column values

		if ( grbit & JET_bitEnumeratePresenceOnly )
			{
			pEnumColumn->err = ErrERRCheck( JET_wrnColumnPresent );
			continue;
			}

		//  if there is only one column value and output compression was
		//  requested and the caller asked for all column values then we may be
		//  able to put the column value directly in the JET_ENUMCOLUMN struct

		if (	cColumnValue == 1 &&
				( grbit & JET_bitEnumerateCompressOutput ) )
			{
			//  get the properties for this column value

			Call( pciterRoot->ErrGetColumnValue( 1, &cbData, &pvData, &fSeparated ) );

			//  this column value is suitable for compression
			//
			//  NOTE:  currently, this criteria equals zero chance of needing
			//  to return a warning for this column

			if ( !fSeparated )
				{
				//  store the column value in the JET_ENUMCOLUMN struct

				pEnumColumn->err = ErrERRCheck( JET_wrnColumnSingleValue );
				Alloc( pEnumColumn->pvData = pfnRealloc( pvReallocContext, NULL, cbData ) );
				pEnumColumn->cbData = (ULONG)cbData;

				if ( !FHostIsLittleEndian() && FCOLUMNIDFixed( pEnumColumn->columnid ) )
					{
					switch ( fieldFC.cbMaxLen )
						{
						case 1:
							*((BYTE*)pEnumColumn->pvData) = *((UnalignedLittleEndian< BYTE >*)pvData);
							break;
							
						case 2:
							*((USHORT*)pEnumColumn->pvData) = *((UnalignedLittleEndian< USHORT >*)pvData);
							break;

						case 4:
							*((ULONG*)pEnumColumn->pvData) = *((UnalignedLittleEndian< ULONG >*)pvData);
							break;

						case 8:
							*((QWORD*)pEnumColumn->pvData) = *((UnalignedLittleEndian< QWORD >*)pvData);
							break;

						default:
							Assert( fFalse );
							Call( ErrERRCheck( JET_errInternalError ) );
							break;
						}
					}
				else
					{
					memcpy(	pEnumColumn->pvData,
							pvData,
							pEnumColumn->cbData );
					}

				//  if this is an escrow update column then adjust it

				if (	FCOLUMNIDFixed( pEnumColumn->columnid ) &&
						FFIELDEscrowUpdate( fieldFC.ffield ) &&
						!FFUCBInsertPrepared( pfucb ) )
					{
					Call( ErrRECAdjustEscrowedColumn(	pfucb,
														pEnumColumn->columnid,
														fieldFC.ibRecordOffset,
														pEnumColumn->pvData,
														pEnumColumn->cbData ) );
					}

				//  we're done with this column

				continue;
				}
			}

		//  get storage for the column value array

		cAlloc 	= cColumnValue;
		cbAlloc	= cAlloc * sizeof( JET_ENUMCOLUMNVALUE );

		Alloc( pEnumColumn->rgEnumColumnValue = (JET_ENUMCOLUMNVALUE*)pfnRealloc(
				pvReallocContext,
				NULL,
				cbAlloc ) );

		pEnumColumn->cEnumColumnValue = (ULONG)cAlloc;
		memset(	pEnumColumn->rgEnumColumnValue, 0, cbAlloc );

		//  walk all column values for this column in the input data

		for (	iEnumColumnValue = 0;
				iEnumColumnValue < pEnumColumn->cEnumColumnValue;
				iEnumColumnValue++ )
			{
			JET_ENUMCOLUMNVALUE* const pEnumColumnValue = &pEnumColumn->rgEnumColumnValue[ iEnumColumnValue ];

			pEnumColumnValue->itagSequence = (ULONG)( iEnumColumnValue + 1 );

			//  get the properties for this column value

			Call( pciterRoot->ErrGetColumnValue( pEnumColumnValue->itagSequence, &cbData, &pvData, &fSeparated ) );
			
			//  if this column value is a separated long value, then we must
			//  defer fetching it until after we have iterated the record. 
			//  we will do this by flagging the column value with
			//  wrnRECSeparatedLV and storing the LID in cbData

			if ( fSeparated )
				{
				pEnumColumnValue->err		= ErrERRCheck( wrnRECSeparatedLV );
				pEnumColumnValue->cbData	= LidOfSeparatedLV( (BYTE*)pvData );

				fSeparatedLV = fTrue;
				continue;
				}

			//  store the column value
			
			Alloc( pEnumColumnValue->pvData = pfnRealloc( pvReallocContext, NULL, cbData ) );
			pEnumColumnValue->cbData = (ULONG)cbData;

			if ( !FHostIsLittleEndian() && FCOLUMNIDFixed( pEnumColumn->columnid ) )
				{
				switch ( fieldFC.cbMaxLen )
					{
					case 1:
						*((BYTE*)pEnumColumnValue->pvData) = *((UnalignedLittleEndian< BYTE >*)pvData);
						break;
						
					case 2:
						*((USHORT*)pEnumColumnValue->pvData) = *((UnalignedLittleEndian< USHORT >*)pvData);
						break;

					case 4:
						*((ULONG*)pEnumColumnValue->pvData) = *((UnalignedLittleEndian< ULONG >*)pvData);
						break;

					case 8:
						*((QWORD*)pEnumColumnValue->pvData) = *((UnalignedLittleEndian< QWORD >*)pvData);
						break;

					default:
						Assert( fFalse );
						Call( ErrERRCheck( JET_errInternalError ) );
						break;
					}
				}
			else
				{
				memcpy(	pEnumColumnValue->pvData,
						pvData,
						pEnumColumnValue->cbData );
				}

			//  if this is an escrow update column then adjust it

			if (	FCOLUMNIDFixed( pEnumColumn->columnid ) &&
					FFIELDEscrowUpdate( fieldFC.ffield ) &&
					!FFUCBInsertPrepared( pfucb ) )
				{
				Call( ErrRECAdjustEscrowedColumn(	pfucb,
													pEnumColumn->columnid,
													fieldFC.ibRecordOffset,
													pEnumColumnValue->pvData,
													pEnumColumnValue->cbData ) );
				}
			}
		}

	//  we should have reached the end of the input data or else the "worst
	//  case" column count wasn't actually the worst case now was it?

	Assert( pciterRoot->ErrMoveNext() == JET_errNoCurrentRecord );

	//  we need to fixup some missing separated LVs
	//
	//  NOTE:  as soon as we do this our iterators are invalid

	if ( fSeparatedLV )
		{
		//  If we are retrieving an after-image or
		//	haven't replaced a LV we can simply go
		//	to the LV tree. Otherwise we have to
		//	perform a more detailed consultation of
		//	the version store with ErrRECGetLVImage
		const BOOL fAfterImage = fUseCopyBuffer
								|| !FFUCBUpdateSeparateLV( pfucb )
								|| !FFUCBReplacePrepared( pfucb );

		Call( ErrRECIFetchMissingLVs(	pfucb,
										pcEnumColumn,
										prgEnumColumn,
										pfnRealloc,
										pvReallocContext,
										cbDataMost,
										fAfterImage ) );
		}

	//  cleanup
	
HandleError:
	if ( Pcsr( pfucb )->FLatched() )
		{
		CallS( ErrDIRRelease( pfucb ) );
		}
	AssertDIRNoLatch( pfucb->ppib );

	if ( err < JET_errSuccess )
		{
		if ( prgEnumColumn )
			{
			for ( iEnumColumn = 0; iEnumColumn < cEnumColumn; iEnumColumn++ )
				{
				if ( rgEnumColumn[ iEnumColumn ].err != JET_wrnColumnSingleValue )
					{
					for (	iEnumColumnValue = 0;
							iEnumColumnValue < rgEnumColumn[ iEnumColumn ].cEnumColumnValue;
							iEnumColumnValue++ )
						{
						pfnRealloc(	pvReallocContext,
									rgEnumColumn[ iEnumColumn ].rgEnumColumnValue[ iEnumColumnValue ].pvData,
									0 );
						}
					pfnRealloc(	pvReallocContext,
								rgEnumColumn[ iEnumColumn ].rgEnumColumnValue,
								0 );
					}
				else
					{
					pfnRealloc(	pvReallocContext,
								rgEnumColumn[ iEnumColumn ].pvData,
								0 );
					}
				}
			pfnRealloc( pvReallocContext, rgEnumColumn, 0 );
			rgEnumColumn = NULL;
			}
		if ( pcEnumColumn )
			{
			cEnumColumn = 0;
			}
		}
	return err;
	}

LOCAL ErrRECEnumerateReqColumns(
	FUCB*					pfucb,
	ULONG					cEnumColumnId,
	JET_ENUMCOLUMNID*		rgEnumColumnId,
	ULONG*					pcEnumColumn,
	JET_ENUMCOLUMN**		prgEnumColumn,
	JET_PFNREALLOC			pfnRealloc,
	void*					pvReallocContext,
	ULONG					cbDataMost,
	JET_GRBIT				grbit )
	{
	ERR						err					= JET_errSuccess;
	ULONG					cEnumColumnT;
	ULONG&					cEnumColumn			= ( pcEnumColumn ? *pcEnumColumn : cEnumColumnT );
							cEnumColumn			= 0;
	JET_ENUMCOLUMN*			rgEnumColumnT;
	JET_ENUMCOLUMN*&		rgEnumColumn		= ( prgEnumColumn ? *prgEnumColumn : rgEnumColumnT );
							rgEnumColumn		= NULL;
	BOOL					fColumnIdError		= fFalse;
	BOOL					fRetColumnIdError	= fFalse;
	BOOL					fSeparatedLV		= fFalse;
	size_t					iEnumColumn			= 0;
	size_t					iEnumColumnValue	= 0;
	BOOL					fUseCopyBuffer		= fFalse;
	DATA*					pdataRec			= NULL;
	DATA*					pdataDefaultRec		= NULL;
	BOOL					fNonEscrowDefault	= fFalse;
	size_t					cAlloc;
	size_t					cbAlloc;
	FIELD					fieldFC;
	CTaggedColumnIter		rgciterTC[ 2 ];
	CTaggedColumnIter*		pciterTC			= NULL;
	CTaggedColumnIter*		pciterTCDefault		= NULL;
	CFixedColumnIter		rgciterFC[ 2 ];
	CFixedColumnIter*		pciterFC			= NULL;
	CFixedColumnIter*		pciterFCDefault		= NULL;
	CVariableColumnIter		rgciterVC[ 2 ];
	CVariableColumnIter*	pciterVC			= NULL;
	CVariableColumnIter*	pciterVCDefault		= NULL;
	IColumnIter*			pciter				= NULL;
	size_t					cColumnValue		= 0;
	BOOL					fSeparated			= fFalse;
	size_t					cbData				= 0;
	void*					pvData				= NULL;

	//  validate parameters

	if ( !pcEnumColumn || !prgEnumColumn || !pfnRealloc )
		{
		Call( ErrERRCheck( JET_errInvalidParameter ) );
		}
	if ( grbit & ~(	JET_bitEnumerateCopy |
					JET_bitEnumerateIgnoreDefault |
					JET_bitEnumerateLocal |
					JET_bitEnumeratePresenceOnly |
					JET_bitEnumerateCompressOutput ) )
		{
		Call( ErrERRCheck( JET_errInvalidGrbit ) );
		}

	//  NOCODE:  JET_bitEnumerateLocal is NYI

	if ( grbit & JET_bitEnumerateLocal )
		{
		Call( ErrERRCheck( JET_errInvalidGrbit ) );
		}

	//  NOCODE:  integration with user-defined callbacks is NYI

	if ( pfucb->u.pfcb->Ptdb()->FTableHasUserDefinedDefault() )
		{
		Call( ErrERRCheck( JET_errCallbackFailed ) );
		}

	//  get access to the data we need

	fUseCopyBuffer = (	(	( grbit & JET_bitEnumerateCopy ) &&
							FFUCBUpdatePrepared( pfucb ) &&
							!FFUCBNeverRetrieveCopy( pfucb ) ) ||
						FFUCBAlwaysRetrieveCopy( pfucb ) );
		
	Call( ErrRECIGetRecord( pfucb, &pdataRec, fUseCopyBuffer ) );

	if ( !( grbit & JET_bitEnumerateIgnoreDefault ) && pfucb->u.pfcb->Ptdb()->FTableHasDefault() )
		{
		pdataDefaultRec = pfucb->u.pfcb->Ptdb()->PdataDefaultRecord();
		fNonEscrowDefault = pfucb->u.pfcb->Ptdb()->FTableHasNonEscrowDefault();
		}

	//  allocate storage for the column array
	
	cAlloc 	= cEnumColumnId;
	cbAlloc	= cAlloc * sizeof( JET_ENUMCOLUMN );

	Alloc( rgEnumColumn = (JET_ENUMCOLUMN*)pfnRealloc(
			pvReallocContext,
			NULL,
			cbAlloc ) );
	
	cEnumColumn = (ULONG)cAlloc;
	memset( rgEnumColumn, 0, cbAlloc );

	//  walk all requested columns

	for ( iEnumColumn = 0; iEnumColumn < cEnumColumn; iEnumColumn++ )
		{
		JET_ENUMCOLUMN* const pEnumColumn = &rgEnumColumn[ iEnumColumn ];

		//  if the requested column id is zero then we should skip this column
		
		pEnumColumn->columnid = rgEnumColumnId[ iEnumColumn ].columnid;

		if ( !pEnumColumn->columnid )
			{
			pEnumColumn->err = ErrERRCheck( JET_wrnColumnSkipped );
			continue;
			}

		//  if we do not have access to the requested column then set the
		//  appropriate error for this column so that the caller can see
		//  which column ids were bad

		err = ErrRECIAccessColumn( pfucb, pEnumColumn->columnid, &fieldFC );
		if ( err == JET_errBadColumnId || err == JET_errColumnNotFound )
			{
			pEnumColumn->err = err;

			fColumnIdError = fTrue;
			
			err = JET_errSuccess;
			continue;
			}
		Call( err );

		//  lookup the value for this column in the record.  if we cannot find
		//  a value there and we are returning default values then lookup the
		//  value for this column in the default record

		if ( FCOLUMNIDTagged( pEnumColumn->columnid ) )
			{
			if ( !pciterTC )
				{
				pciterTC = &rgciterTC[ 0 ];
				Call( pciterTC->ErrInit( pfucb->u.pfcb, *pdataRec ) );
				}
			err = pciterTC->ErrSeek( pEnumColumn->columnid );
			pciter = pciterTC;
			if ( err == JET_errRecordNotFound && fNonEscrowDefault )
				{
				if ( !pciterTCDefault )
					{
					pciterTCDefault = &rgciterTC[ 1 ];
					Call( pciterTCDefault->ErrInit( pfucb->u.pfcb, *pdataDefaultRec ) );
					}
				err = pciterTCDefault->ErrSeek( pEnumColumn->columnid );
				pciter = pciterTCDefault;
				}
			}
		else if ( FCOLUMNIDFixed( pEnumColumn->columnid ) )
			{
			if ( !pciterFC )
				{
				pciterFC = &rgciterFC[ 0 ];
				Call( pciterFC->ErrInit( pfucb->u.pfcb, *pdataRec ) );
				}
			err = pciterFC->ErrSeek( pEnumColumn->columnid );
			pciter = pciterFC;
			if ( err == JET_errRecordNotFound && pdataDefaultRec )
				{
				if ( !pciterFCDefault )
					{
					pciterFCDefault = &rgciterFC[ 1 ];
					Call( pciterFCDefault->ErrInit( pfucb->u.pfcb, *pdataDefaultRec ) );
					}
				err = pciterFCDefault->ErrSeek( pEnumColumn->columnid );
				pciter = pciterFCDefault;
				}
			}
		else
			{
			if ( !pciterVC )
				{
				pciterVC = &rgciterVC[ 0 ];
				Call( pciterVC->ErrInit( pfucb->u.pfcb, *pdataRec ) );
				}
			err = pciterVC->ErrSeek( pEnumColumn->columnid );
			pciter = pciterVC;
			if ( err == JET_errRecordNotFound && fNonEscrowDefault )
				{
				if ( !pciterVCDefault )
					{
					pciterVCDefault = &rgciterVC[ 1 ];
					Call( pciterVCDefault->ErrInit( pfucb->u.pfcb, *pdataDefaultRec ) );
					}
				err = pciterVCDefault->ErrSeek( pEnumColumn->columnid );
				pciter = pciterVCDefault;
				}
			}

		//  if we couldn't find a value for the column then it is NULL

		if ( err == JET_errRecordNotFound )
			{
			pEnumColumn->err = ErrERRCheck( JET_wrnColumnNull );
			
			err = JET_errSuccess;
			continue;
			}
		Call( err );

		//  get the properties for this column

		Call( pciter->ErrGetColumnValueCount( &cColumnValue ) );
		
		//  if the column is explicitly set to NULL then report that

		if ( !cColumnValue )
			{
			pEnumColumn->err = ErrERRCheck( JET_wrnColumnNull );
			continue;
			}

		//  if we are testing for the presence of a column value only and
		//  the caller asked for all column values then return that the column
		//  is present but do not return any column values

		if (	( grbit & JET_bitEnumeratePresenceOnly ) &&
				!rgEnumColumnId[ iEnumColumn ].ctagSequence )
			{
			pEnumColumn->err = ErrERRCheck( JET_wrnColumnPresent );
			continue;
			}

		//  if there is only one column value and output compression was
		//  requested and the caller asked for all column values then we may be
		//  able to put the column value directly in the JET_ENUMCOLUMN struct

		if (	cColumnValue == 1 &&
				( grbit & JET_bitEnumerateCompressOutput ) &&
				!rgEnumColumnId[ iEnumColumn ].ctagSequence )
			{
			//  get the properties for this column value

			Call( pciter->ErrGetColumnValue( 1, &cbData, &pvData, &fSeparated ) );

			//  this column value is suitable for compression
			//
			//  NOTE:  currently, this criteria equals zero chance of needing
			//  to return a warning for this column

			if ( !fSeparated )
				{
				//  store the column value in the JET_ENUMCOLUMN struct

				pEnumColumn->err = ErrERRCheck( JET_wrnColumnSingleValue );
				Alloc( pEnumColumn->pvData = pfnRealloc( pvReallocContext, NULL, cbData ) );
				pEnumColumn->cbData = (ULONG)cbData;

				if ( !FHostIsLittleEndian() && FCOLUMNIDFixed( pEnumColumn->columnid ) )
					{
					switch ( fieldFC.cbMaxLen )
						{
						case 1:
							*((BYTE*)pEnumColumn->pvData) = *((UnalignedLittleEndian< BYTE >*)pvData);
							break;
							
						case 2:
							*((USHORT*)pEnumColumn->pvData) = *((UnalignedLittleEndian< USHORT >*)pvData);
							break;

						case 4:
							*((ULONG*)pEnumColumn->pvData) = *((UnalignedLittleEndian< ULONG >*)pvData);
							break;

						case 8:
							*((QWORD*)pEnumColumn->pvData) = *((UnalignedLittleEndian< QWORD >*)pvData);
							break;

						default:
							Assert( fFalse );
							Call( ErrERRCheck( JET_errInternalError ) );
							break;
						}
					}
				else
					{
					memcpy(	pEnumColumn->pvData,
							pvData,
							pEnumColumn->cbData );
					}

				//  if this is an escrow update column then adjust it

				if (	FCOLUMNIDFixed( pEnumColumn->columnid ) &&
						FFIELDEscrowUpdate( fieldFC.ffield ) &&
						!FFUCBInsertPrepared( pfucb ) )
					{
					Call( ErrRECAdjustEscrowedColumn(	pfucb,
														pEnumColumn->columnid,
														fieldFC.ibRecordOffset,
														pEnumColumn->pvData,
														pEnumColumn->cbData ) );
					}

				//  we're done with this column

				continue;
				}
			}

		//  get storage for the column value array

		cAlloc = rgEnumColumnId[ iEnumColumn ].ctagSequence;
		if ( !cAlloc )
			{
			cAlloc = cColumnValue;
			}
		cbAlloc = cAlloc * sizeof( JET_ENUMCOLUMNVALUE );

		Alloc( pEnumColumn->rgEnumColumnValue = (JET_ENUMCOLUMNVALUE*)pfnRealloc(
				pvReallocContext,
				NULL,
				cbAlloc ) );
		
		pEnumColumn->cEnumColumnValue = (ULONG)cAlloc;
		memset(	pEnumColumn->rgEnumColumnValue, 0, cbAlloc );

		//  walk all requested column values
		//  NOCODE:  JET_wrnColumnMoreTags is NYI
		
		for (	iEnumColumnValue = 0;
				iEnumColumnValue < pEnumColumn->cEnumColumnValue;
				iEnumColumnValue++ )
			{
			JET_ENUMCOLUMNVALUE* const pEnumColumnValue = &pEnumColumn->rgEnumColumnValue[ iEnumColumnValue ];

			//  if the requested itagSequence is zero then we should skip
			//  this column value

			if ( rgEnumColumnId[ iEnumColumn ].ctagSequence )
				{
				pEnumColumnValue->itagSequence = rgEnumColumnId[ iEnumColumn ].rgtagSequence[ iEnumColumnValue ];
				}
			else
				{
				pEnumColumnValue->itagSequence = (ULONG)( iEnumColumnValue + 1 );
				}

			if ( !pEnumColumnValue->itagSequence )
				{
				pEnumColumnValue->err = ErrERRCheck( JET_wrnColumnSkipped );
				continue;
				}

			//  if there is no corresponding column value for the requested
			//  itagSequence then the column value is NULL

			if ( pEnumColumnValue->itagSequence > cColumnValue )
				{
				pEnumColumnValue->err = ErrERRCheck( JET_wrnColumnNull );
				continue;
				}

			//  if we are testing for the presence of a column value only then
			//  return that it is present but do not return the column value

			if ( grbit & JET_bitEnumeratePresenceOnly )
				{
				pEnumColumnValue->err = ErrERRCheck( JET_wrnColumnPresent );
				continue;
				}

			//  get the properties for this column value

			Call( pciter->ErrGetColumnValue( pEnumColumnValue->itagSequence, &cbData, &pvData, &fSeparated ) );
			
			//  if this column value is a separated long value, then we must
			//  defer fetching it until after we have iterated the record. 
			//  we will do this by flagging the column value with
			//  wrnRECSeparatedLV and storing the LID in cbData

			if ( fSeparated )
				{
				pEnumColumnValue->err		= ErrERRCheck( wrnRECSeparatedLV );
				pEnumColumnValue->cbData	= LidOfSeparatedLV( (BYTE*)pvData );

				fSeparatedLV = fTrue;
				continue;
				}

			//  store the column value
			
			Alloc( pEnumColumnValue->pvData = pfnRealloc( pvReallocContext, NULL, cbData ) );
			pEnumColumnValue->cbData = (ULONG)cbData;

			if ( !FHostIsLittleEndian() && FCOLUMNIDFixed( pEnumColumn->columnid ) )
				{
				switch ( fieldFC.cbMaxLen )
					{
					case 1:
						*((BYTE*)pEnumColumnValue->pvData) = *((UnalignedLittleEndian< BYTE >*)pvData);
						break;
						
					case 2:
						*((USHORT*)pEnumColumnValue->pvData) = *((UnalignedLittleEndian< USHORT >*)pvData);
						break;

					case 4:
						*((ULONG*)pEnumColumnValue->pvData) = *((UnalignedLittleEndian< ULONG >*)pvData);
						break;

					case 8:
						*((QWORD*)pEnumColumnValue->pvData) = *((UnalignedLittleEndian< QWORD >*)pvData);
						break;

					default:
						Assert( fFalse );
						Call( ErrERRCheck( JET_errInternalError ) );
						break;
					}
				}
			else
				{
				memcpy(	pEnumColumnValue->pvData,
						pvData,
						pEnumColumnValue->cbData );
				}

			//  if this is an escrow update column then adjust it

			if (	FCOLUMNIDFixed( pEnumColumn->columnid ) &&
					FFIELDEscrowUpdate( fieldFC.ffield ) &&
					!FFUCBInsertPrepared( pfucb ) )
				{
				Call( ErrRECAdjustEscrowedColumn(	pfucb,
													pEnumColumn->columnid,
													fieldFC.ibRecordOffset,
													pEnumColumnValue->pvData,
													pEnumColumnValue->cbData ) );
				}
			}
		}

	//  we need to fixup some missing separated LVs

	if ( fSeparatedLV )
		{
		//  If we are retrieving an after-image or
		//	haven't replaced a LV we can simply go
		//	to the LV tree. Otherwise we have to
		//	perform a more detailed consultation of
		//	the version store with ErrRECGetLVImage
		const BOOL fAfterImage = fUseCopyBuffer
								|| !FFUCBUpdateSeparateLV( pfucb )
								|| !FFUCBReplacePrepared( pfucb );

		Call( ErrRECIFetchMissingLVs(	pfucb,
										pcEnumColumn,
										prgEnumColumn,
										pfnRealloc,
										pvReallocContext,
										cbDataMost,
										fAfterImage ) );
		}

	//  if there was a column id error then return the first one we see

	if ( fColumnIdError )
		{
		fRetColumnIdError = fTrue;
		for ( iEnumColumn = 0; iEnumColumn < cEnumColumn; iEnumColumn++ )
			{
			JET_ENUMCOLUMN* const pEnumColumn = &rgEnumColumn[ iEnumColumn ];
			if ( pEnumColumn->err < JET_errSuccess )
				{
				Call( ErrERRCheck( pEnumColumn->err ) );
				}
			}
		fRetColumnIdError = fFalse;
		err = JET_errSuccess;
		}

	//  cleanup
	
HandleError:
	if ( Pcsr( pfucb )->FLatched() )
		{
		CallS( ErrDIRRelease( pfucb ) );
		}
	AssertDIRNoLatch( pfucb->ppib );

	if ( err < JET_errSuccess )
		{
		if ( !fRetColumnIdError )
			{
			if ( prgEnumColumn )
				{
				for ( iEnumColumn = 0; iEnumColumn < cEnumColumn; iEnumColumn++ )
					{
					if ( rgEnumColumn[ iEnumColumn ].err != JET_wrnColumnSingleValue )
						{
						for (	iEnumColumnValue = 0;
								iEnumColumnValue < rgEnumColumn[ iEnumColumn ].cEnumColumnValue;
								iEnumColumnValue++ )
							{
							pfnRealloc(	pvReallocContext,
										rgEnumColumn[ iEnumColumn ].rgEnumColumnValue[ iEnumColumnValue ].pvData,
										0 );
							}
						pfnRealloc(	pvReallocContext,
									rgEnumColumn[ iEnumColumn ].rgEnumColumnValue,
									0 );
						}
					else
						{
						pfnRealloc(	pvReallocContext,
									rgEnumColumn[ iEnumColumn ].pvData,
									0 );
						}
					}
				pfnRealloc( pvReallocContext, rgEnumColumn, 0 );
				rgEnumColumn = NULL;
				}
			if ( pcEnumColumn )
				{
				cEnumColumn = 0;
				}
			}
		}
	return err;
	}

ERR VTAPI ErrIsamEnumerateColumns(
	JET_SESID				vsesid,
	JET_VTID				vtid,
	unsigned long			cEnumColumnId,
	JET_ENUMCOLUMNID*		rgEnumColumnId,
	unsigned long*			pcEnumColumn,
	JET_ENUMCOLUMN**		prgEnumColumn,
	JET_PFNREALLOC			pfnRealloc,
	void*					pvReallocContext,
	unsigned long			cbDataMost,
	JET_GRBIT				grbit )
	{
	ERR		err;
	PIB*	ppib				= (PIB *)vsesid;
	FUCB*	pfucb				= (FUCB *)vtid;
	BOOL	fTransactionStarted	= fFalse;

	CallR( ErrPIBCheck( ppib ) );
	CheckFUCB( ppib, pfucb );
	AssertDIRNoLatch( ppib );

	if ( 0 == ppib->level )
		{
		// Begin transaction for read consistency (in case page
		// latch must be released in order to validate column).
		Call( ErrDIRBeginTransaction( ppib, JET_bitTransactionReadOnly ) );
		fTransactionStarted = fTrue;
		}
		
	AssertDIRNoLatch( ppib );
	Assert( FFUCBSort( pfucb ) || FFUCBIndex( pfucb ) );

	//  if no column list is given then enumerate all columns

	if ( !cEnumColumnId )
		{
		Call( ErrRECEnumerateAllColumns(	pfucb,
											pcEnumColumn,
											prgEnumColumn,
											pfnRealloc,
											pvReallocContext,
											cbDataMost,
											grbit ) );
		}

	//  if an explicit column list is provided then enumerate those columns

	else
		{
		Call( ErrRECEnumerateReqColumns(	pfucb,
											cEnumColumnId,
											rgEnumColumnId,
											pcEnumColumn,
											prgEnumColumn,
											pfnRealloc,
											pvReallocContext,
											cbDataMost,
											grbit ) );
		}

HandleError:
	if ( fTransactionStarted )
		{
		//	No updates performed, so force success.
		CallS( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );
		}
	AssertDIRNoLatch( ppib );

	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\fileopen.cxx ===
#include "std.hxx"

extern CAutoResetSignal sigDoneFCB;

ERR VTAPI ErrIsamDupCursor( JET_SESID sesid, JET_VTID vtid, JET_TABLEID  *ptableid, ULONG grbit )
	{
 	PIB *ppib		= reinterpret_cast<PIB *>( sesid );
	FUCB *pfucbOpen = reinterpret_cast<FUCB *>( vtid );
	FUCB **ppfucb	= reinterpret_cast<FUCB **>( ptableid );

	ERR		err;
	FUCB 	*pfucb;

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucbOpen );

	//	allocate FUCB
	//
	Call( ErrDIROpen( ppib, pfucbOpen->u.pfcb, &pfucb ) );

	//	reset copy buffer
	//
	pfucb->pvWorkBuf = NULL;
	pfucb->dataWorkBuf.SetPv( NULL );
	Assert( !FFUCBUpdatePrepared( pfucb ) );

	//	reset key buffer
	//
	pfucb->dataSearchKey.Nullify();
	pfucb->cColumnsInSearchKey = 0;
	KSReset( pfucb );

	//	copy cursor flags
	//
	FUCBSetIndex( pfucb );
	if ( FFUCBUpdatable( pfucbOpen ) )
		{
		FUCBSetUpdatable( pfucb );
		Assert( !rgfmp[pfucb->ifmp].FReadOnlyAttach() );
		}
	else
		{
		FUCBResetUpdatable( pfucb );
		}

	Assert( !FFUCBMayCacheLVCursor( pfucb ) );	//	initialized to FALSE
	if ( FFUCBMayCacheLVCursor( pfucbOpen ) )
		{
		FUCBSetMayCacheLVCursor( pfucb );
		}

	//	move currency to the first record and ignore error if no records
	//
	RECDeferMoveFirst( ppib, pfucb );
	err = JET_errSuccess;

	pfucb->pvtfndef = &vtfndefIsam;
	*ppfucb = pfucb;

	return JET_errSuccess;

HandleError:
	return err;
	}


//+local
// ErrTDBCreate
// ========================================================================
// ErrTDBCreate(
//		TDB **pptdb,			// OUT	 receives new TDB
//		FID fidFixedLast,		// IN	   last fixed field id to be used
//		FID fidVarLast,			// IN	   last var field id to be used
//		FID fidTaggedLast )		// IN	   last tagged field id to be used
//
// Allocates a new TDB, initializing internal elements appropriately.
//
// PARAMETERS
//				pptdb			receives new TDB
//				fidFixedLast	last fixed field id to be used
//								(should be fidFixedLeast-1 if none)
//				fidVarLast		last var field id to be used
//								(should be fidVarLeast-1 if none)
//				fidTaggedLast	last tagged field id to be used
//								(should be fidTaggedLeast-1 if none)
// RETURNS		Error code, one of:
//					 JET_errSuccess				Everything worked.
//					-JET_errOutOfMemory	Failed to allocate memory.
// SEE ALSO		ErrRECAddFieldDef
//-

const ULONG	cbAvgName	= 16;

ERR ErrTDBCreate(
	INST	*pinst,
	TDB		**pptdb,
	TCIB	*ptcib,
	FCB		*pfcbTemplateTable,
	BOOL	fAllocateNameSpace )
	{
	ERR		err;					// standard error value
	WORD 	cfieldFixed;  			// # of fixed fields
	WORD 	cfieldVar;	  			// # of var fields
	WORD 	cfieldTagged; 			// # of tagged fields
	WORD	cfieldTotal;			// Fixed + Var + Tagged
	TDB   	*ptdb = ptdbNil;		// temporary TDB pointer
	FID		fidFixedFirst;
	FID		fidVarFirst;
	FID		fidTaggedFirst;
	WORD	ibEndFixedColumns;

	Assert( pptdb != NULL );
	Assert( ptcib->fidFixedLast <= fidFixedMost );
	Assert( ptcib->fidVarLast >= fidVarLeast-1 && ptcib->fidVarLast <= fidVarMost );
	Assert( ptcib->fidTaggedLast >= fidTaggedLeast-1 && ptcib->fidTaggedLast <= fidTaggedMost );

	if ( pfcbNil == pfcbTemplateTable )
		{
		fidFixedFirst = fidFixedLeast;
		fidVarFirst = fidVarLeast;
		fidTaggedFirst = fidTaggedLeast;
		ibEndFixedColumns = ibRECStartFixedColumns;
		}
	else
		{
		fidFixedFirst = FID( pfcbTemplateTable->Ptdb()->FidFixedLast() + 1 );
		if ( fidFixedLeast-1 == ptcib->fidFixedLast )
			{
			ptcib->fidFixedLast = FID( fidFixedFirst - 1 );
			}
		Assert( ptcib->fidFixedLast >= fidFixedFirst-1 );
			
		fidVarFirst = FID( pfcbTemplateTable->Ptdb()->FidVarLast() + 1 );
		if ( fidVarLeast-1 == ptcib->fidVarLast )
			{
			ptcib->fidVarLast = FID( fidVarFirst - 1 );
			}
		Assert( ptcib->fidVarLast >= fidVarFirst-1 );
			
		fidTaggedFirst = ( 0 != pfcbTemplateTable->Ptdb()->FidTaggedLastOfESE97Template() ?
							FID( pfcbTemplateTable->Ptdb()->FidTaggedLastOfESE97Template() + 1 ) :
							fidTaggedLeast );
		if ( fidTaggedLeast-1 == ptcib->fidTaggedLast )
			{
			ptcib->fidTaggedLast = FID( fidTaggedFirst - 1 );
			}
		Assert( ptcib->fidTaggedLast >= fidTaggedFirst-1 );
		
		ibEndFixedColumns = pfcbTemplateTable->Ptdb()->IbEndFixedColumns();
		}
		
	//	calculate how many of each field type to allocate
	//
	cfieldFixed = WORD( ptcib->fidFixedLast + 1 - fidFixedFirst );
	cfieldVar = WORD( ptcib->fidVarLast + 1 - fidVarFirst );
	cfieldTagged = WORD( ptcib->fidTaggedLast + 1 - fidTaggedFirst );
	cfieldTotal = WORD( cfieldFixed + cfieldVar + cfieldTagged );

	if ( ( ptdb = PtdbTDBAlloc( pinst ) ) == NULL )
		return ErrERRCheck( JET_errTooManyOpenTables );

	Assert( FAlignedForAllPlatforms( ptdb ) );

	memset( (BYTE *)ptdb, '\0', sizeof(TDB) );

	//	fill in max field id numbers
	new( ptdb ) TDB(
					fidFixedFirst,
					ptcib->fidFixedLast,
					fidVarFirst,
					ptcib->fidVarLast,
					fidTaggedFirst,
					ptcib->fidTaggedLast,
					ibEndFixedColumns,
					pfcbTemplateTable );

	//	propagate the SLVColumn flag from the template table
	
	if ( pfcbNil != pfcbTemplateTable
		&& pfcbTemplateTable->Ptdb()->FTableHasSLVColumn() )
		{
		ptdb->SetFTableHasSLVColumn();
		}

	// Allocate space for the FIELD structures.  In addition, allocate padding
	// in case there's index info
	if ( fAllocateNameSpace )
		{
		Call( ptdb->MemPool().ErrMEMPOOLInit(
			cbAvgName * ( cfieldTotal + 1 ),	// +1 for table name
			USHORT( cfieldTotal + 2 ),			// # tag entries = 1 per fieldname, plus 1 for all FIELD structures, plus 1 for table name
			fTrue ) );
		}
	else
		{
		//	this is a temp/sort table, so only allocate enough tags
		//	for the FIELD structures, table name, and IDXSEG
		Call( ptdb->MemPool().ErrMEMPOOLInit( cbFIELDPlaceholder, 3, fFalse ) );
		}

	//	add FIELD placeholder
	MEMPOOL::ITAG	itagNew;
	Call( ptdb->MemPool().ErrAddEntry( NULL, cbFIELDPlaceholder, &itagNew ) );
	Assert( itagNew == itagTDBFields );	// Should be the first entry in the buffer.

	const ULONG		cbFieldInfo		= cfieldTotal * sizeof(FIELD);
	if ( cbFieldInfo > 0 )
		{
		FIELD * const	pfieldInitial	= (FIELD *)PvOSMemoryHeapAlloc( cbFieldInfo );
		if ( NULL == pfieldInitial )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		memset( pfieldInitial, 0, cbFieldInfo );
		ptdb->SetPfieldInitial( pfieldInitial );
		}
	else
		{
		ptdb->SetPfieldInitial( NULL );
		}

	//	set output parameter and return
	//
	*pptdb = ptdb;
	return JET_errSuccess;

HandleError:
	Assert( ptdb != ptdbNil );
	ptdb->Delete( pinst );

	return err;
	}



//+API
// ErrRECAddFieldDef
// ========================================================================
// ErrRECAddFieldDef(
//		TDB *ptdb,		//	INOUT	TDB to add field definition to
//		FID fid );		//	IN		field id of new field
//
// Adds a field descriptor to an TDB.
//
// PARAMETERS	ptdb   			TDB to add new field definition to
//				fid	   			field id of new field (should be within
//					   			the ranges imposed by the parameters
//								supplied to ErrTDBCreate)
//				ftFieldType		data type of field
//				cbField			field length (only important when
//								defining fixed textual fields)
//				bFlags			field behaviour flags:
//				szFieldName		name of field
//
// RETURNS		Error code, one of:
//					 JET_errSuccess			Everything worked.
//					-ColumnInvalid	   		Field id given is greater than
//									   		the maximum which was given
//									   		to ErrTDBCreate.
//					-JET_errBadColumnId		A nonsensical field id was given.
//					-errFLDInvalidFieldType The field type given is either
//									   		undefined, or is not acceptable
//									   		for this field id.
// COMMENTS		When adding a fixed field, the fixed field offset table
//				in the TDB is recomputed.
// SEE ALSO		ErrTDBCreate
//-
ERR ErrRECAddFieldDef( TDB *ptdb, const COLUMNID columnid, FIELD *pfield )
	{
	FIELD *		pfieldNew;
	const FID	fid			= FidOfColumnid( columnid );
	
	Assert( ptdb != ptdbNil );
	Assert( pfield != pfieldNil );

	//	fixed field: determine length, either from field type
	//	or from parameter (for text/binary types)
	//
	Assert( FCOLUMNIDValid( columnid ) );

	if ( FCOLUMNIDTagged( columnid ) )
		{
		//	tagged field: any type is ok
		//
		if ( fid > ptdb->FidTaggedLast() || fid < ptdb->FidTaggedFirst() )
			return ErrERRCheck( JET_errColumnNotFound );

		if( JET_coltypSLV == pfield->coltyp )
			{
			//	set the SLV flag
			ptdb->SetFTableHasSLVColumn();
			}
			
		Assert( 0 == pfield->ibRecordOffset );
		pfieldNew = ptdb->PfieldTagged( columnid );
		}
	else if ( FCOLUMNIDFixed( columnid ) )
		{
		if ( fid > ptdb->FidFixedLast() || fid < ptdb->FidFixedFirst() )
			return ErrERRCheck( JET_errColumnNotFound );

		Assert( pfield->ibRecordOffset >= ibRECStartFixedColumns );
		pfieldNew = ptdb->PfieldFixed( columnid );
		}

	else
		{
		Assert( FCOLUMNIDVar( columnid ) );

		//	variable column.  Check for bogus numeric and long types
		//
		if ( fid > ptdb->FidVarLast() || fid < ptdb->FidVarFirst() )
			return ErrERRCheck( JET_errColumnNotFound );
		else if ( pfield->coltyp != JET_coltypBinary && pfield->coltyp != JET_coltypText )
			return ErrERRCheck( JET_errInvalidColumnType );
		
		Assert( 0 == pfield->ibRecordOffset );
		pfieldNew = ptdb->PfieldVar( columnid );
		}

	*pfieldNew = *pfield;

	return JET_errSuccess;
	}


ERR ErrFILEIGenerateIDB( FCB *pfcb, TDB *ptdb, IDB *pidb )
	{
	const IDXSEG*	pidxseg;
	const IDXSEG*	pidxsegMac;
	BOOL			fFoundUserDefinedDefault	= fFalse;
	
	Assert( pfcb != pfcbNil );
	Assert( ptdb != ptdbNil );
	Assert( pidb != pidbNil );

	Assert( (cbitFixed % 8) == 0 );
	Assert( (cbitVariable % 8) == 0 );
	Assert( (cbitTagged % 8) == 0 );

	Assert( pidb->Cidxseg() <= JET_ccolKeyMost );

	memset( pidb->RgbitIdx(), 0x00, 32 );

	//	check validity of each segment id and
	//	also set index mask bits
	//
	pidxseg = PidxsegIDBGetIdxSeg( pidb, ptdb );
	pidxsegMac = pidxseg + pidb->Cidxseg();

	if ( !pidb->FAllowFirstNull() )
		{
		//	HACK for existing databases that
		//	were corrupted by bug #108371
		pidb->ResetFAllowAllNulls();
		}


	//	SPARSE INDEXES
	//	--------------
	//	Sparse indexes are an attempt to
	//	optimise record insertion by not having to
	//	update indexes that are likely to be sparse
	//	(ie. there are enough unset columns in the
	//	record to cause the record to be excluded
	//	due to the Ignore*Null flags imposed on the
	//	index).  Sparse indexes exploit any Ignore*Null
	//	flags to check before index update that enough
	//	index columns were left unset to satisfy the
	//	Ignore*Null conditions and therefore not require
	//	that the index be updated. In order for an
	//	index to be labelled as sparse, the following
	//	conditions must be satisfied:
	//		1) this is not the primary index (can't
	//		   skip records in the primary index)
	//		2) null segments are permitted
	//		3) no index entry generated if any/all/first
	//		   index column(s) is/are null (ie. at
	//		   least one of the Ignore*Null flags
	//		   was used to create the index)
	//		4) all of the index columns may be set
	//		   to NULL
	//		5) none of the index columns has a default
	//		   value (because then the column would
	//		   be non-null)

	const BOOL	fIgnoreAllNull		= !pidb->FAllowAllNulls();
	const BOOL	fIgnoreFirstNull	= !pidb->FAllowFirstNull();
	const BOOL	fIgnoreAnyNull		= !pidb->FAllowSomeNulls();
	BOOL		fSparseIndex		= ( !pidb->FPrimary()
										&& !pidb->FNoNullSeg()
										&& ( fIgnoreAllNull || fIgnoreFirstNull || fIgnoreAnyNull ) );

	//	the primary index should not have had any of the Ignore*Null flags set
	Assert( !pidb->FPrimary()
		|| pidb->FNoNullSeg()
		|| ( pidb->FAllowAllNulls() && pidb->FAllowFirstNull() && pidb->FAllowSomeNulls() ) );

	const IDXSEG * const	pidxsegFirst	= pidxseg;
	for ( ; pidxseg < pidxsegMac; pidxseg++ )
		{
		//	field id is absolute value of segment id -- these should already
		//	have been validated, so just add asserts to verify integrity of
		//	fid's and their FIELD structures
		//
		const COLUMNID			columnid	= pidxseg->Columnid();
		const FIELD * const		pfield		= ptdb->Pfield( columnid );
		Assert( pfield->coltyp != JET_coltypNil );
		Assert( !FFIELDDeleted( pfield->ffield ) );

		if ( FFIELDUserDefinedDefault( pfield->ffield ) )
			{
			if ( !fFoundUserDefinedDefault )
				{
				//  UNDONE:  use the dependency list to optimize this
				memset( pidb->RgbitIdx(), 0xff, 32 );
				fFoundUserDefinedDefault = fTrue;
				}

			//	user-defined defaults may return a NULL or
			//	non-NULL default value for the column,
			//	so it is unclear whether the record would be
			//	present in the index
			//	SPECIAL CASE: if IgnoreFirstNull and this is
			//	not the first column, then it's still possible
			//	for this to be a sparse index
			if ( !fIgnoreFirstNull
				|| fIgnoreAnyNull
				|| pidxsegFirst == pidxseg )
				{
				fSparseIndex = fFalse;
				}
			}

		if ( FFIELDNotNull( pfield->ffield ) || FFIELDDefault( pfield->ffield ) )
			{
			//	if field can't be NULL or if there's a default value
			//	overriding NULL, this can't be a sparse index
			//	SPECIAL CASE: if IgnoreFirstNull and this is
			//	not the first column, then it's still possible
			//	for this to be a sparse index
			if ( !fIgnoreFirstNull
				|| fIgnoreAnyNull
				|| pidxsegFirst == pidxseg )
				{
				fSparseIndex = fFalse;
				}
			}

		if ( FCOLUMNIDTagged( columnid ) )
			{
			Assert( !FFIELDPrimaryIndexPlaceholder( pfield->ffield ) );

			if ( FFIELDMultivalued( pfield->ffield ) )
				{
				Assert( !pidb->FPrimary() );

				//	Multivalued flag was persisted in catalog as of 0x620,2
				if ( !pidb->FMultivalued() )
					{
					Assert( rgfmp[pfcb->Ifmp()].Pdbfilehdr()->le_ulVersion == 0x00000620 );
					Assert( rgfmp[pfcb->Ifmp()].Pdbfilehdr()->le_ulUpdate < 0x00000002 );
					}
						
				//	Must set the flag anyway to ensure backward
				//	compatibility.
				pidb->SetFMultivalued();
				}
			}
		else if ( FFIELDPrimaryIndexPlaceholder( pfield->ffield )
			&& pidb->FPrimary() )
			{
			//	must be first column in index
			Assert( PidxsegIDBGetIdxSeg( pidb, ptdb ) == pidxseg );

			//	must be fixed bitfield
			Assert( FCOLUMNIDFixed( columnid ) );
			Assert( JET_coltypBit == pfield->coltyp );
			pidb->SetFHasPlaceholderColumn();
			}

		if ( FRECTextColumn( pfield->coltyp ) && usUniCodePage == pfield->cp )
			{
			//	LocalizedText flag was persisted in catalog as of 0x620,2
			if ( !pidb->FLocalizedText() )
				{
				Assert( rgfmp[pfcb->Ifmp()].Pdbfilehdr()->le_ulVersion == 0x00000620 );
				Assert( rgfmp[pfcb->Ifmp()].Pdbfilehdr()->le_ulUpdate < 0x00000002 );
				}
						
			//	Must set the flag anyway to ensure backward
			//	compatibility.
			pidb->SetFLocalizedText();
			}

		pidb->SetColumnIndex( FidOfColumnid( columnid ) );
		Assert ( pidb->FColumnIndex( FidOfColumnid( columnid ) ) );
		}


	//	SPARSE CONDITIONAL INDEXES
	//	---------------------------
	//	Sparse conditional indexes are an attempt to
	//	optimise record insertion by not having to
	//	update conditional indexes that are likely to
	//	be sparse (ie. there are enough unset columns
	//	in the record to cause the record to be
	//	excluded due to the conditional columns imposed
	//	on the index).  We label a conditional index as
	//	sparse if there is AT LEAST ONE conditional
	//	column which, if unset, will cause the record
	//	to NOT be included in the index.  This means
	//	that if the condition is MustBeNull, the column
	//	must have a default value, and if the
	//	condition is MustBeNonNull, the column must
	//	NOT have a default value.

	BOOL	fSparseConditionalIndex		= fFalse;

	//	the primary index should not have any conditional columns
	Assert( !pidb->FPrimary()
		|| 0 == pidb->CidxsegConditional() );

	pidxseg = PidxsegIDBGetIdxSegConditional( pidb, ptdb );
	pidxsegMac = pidxseg + pidb->CidxsegConditional();
	for ( ; pidxseg < pidxsegMac; pidxseg++ )
		{
		const COLUMNID			columnid	= pidxseg->Columnid();
		const FIELD * const		pfield		= ptdb->Pfield( columnid );
		Assert( pfield->coltyp != JET_coltypNil );
		Assert( !FFIELDDeleted( pfield->ffield ) );

		if ( FFIELDUserDefinedDefault( pfield->ffield ) )
			{
			if ( !fFoundUserDefinedDefault )
				{
				//  UNDONE:  use the dependency list to optimize this
				memset( pidb->RgbitIdx(), 0xff, 32 );
				fFoundUserDefinedDefault = fTrue;
				}

			//	only reason to continue is to see if
			//	this might be a sparse conditional
			//	index, so if this has already been
			//	determined, then we can exit
			if ( fSparseConditionalIndex )
				break;
			}
		else if ( !fSparseConditionalIndex )
			{
			//	if there is a default value to force the
			//	column to be non-NULL by default
			//	(and thus NOT be present in the index),
			//	then we can treat this as a sparse column
			//	if there is no default value for this column,
			//	the column will be NULL by default (and
			//	thus be present in the index), so we can
			//	treat this as a sparse column
			const BOOL	fHasDefault	= FFIELDDefault( pfield->ffield );

			fSparseConditionalIndex = ( pidxseg->FMustBeNull() ?
											fHasDefault :
											!fHasDefault );
			}

		pidb->SetColumnIndex( FidOfColumnid( columnid ) );
		Assert( pidb->FColumnIndex( FidOfColumnid( columnid ) ) );
		}

	//	all requirements for sparse indexes are met
	//
	if ( fSparseIndex )
		{
		Assert( !pidb->FPrimary() );
		pidb->SetFSparseIndex();
		}
	else
		{
		pidb->ResetFSparseIndex();
		}

	if ( fSparseConditionalIndex )
		{
		Assert( !pidb->FPrimary() );
		pidb->SetFSparseConditionalIndex();
		}
	else
		{
		pidb->ResetFSparseConditionalIndex();
		}


	IDB	*pidbNew = PidbIDBAlloc( PinstFromIfmp( pfcb->Ifmp() ) );
	if ( pidbNil == pidbNew )
		return ErrERRCheck( JET_errTooManyOpenIndexes );

	Assert( FAlignedForAllPlatforms( pidbNew ) );

	*pidbNew = *pidb;

	pidbNew->InitRefcounts();
	
	pfcb->SetPidb( pidbNew );

	return JET_errSuccess;
	}


//  ================================================================
ERR VTAPI ErrIsamSetSequential(
	const JET_SESID sesid,
	const JET_VTID vtid,
	const JET_GRBIT )
//  ================================================================
	{
	ERR				err;
 	PIB * const		ppib		= reinterpret_cast<PIB *>( sesid );
	FUCB * const	pfucb		= reinterpret_cast<FUCB *>( vtid );

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );
	CheckSecondary( pfucb );
	AssertDIRNoLatch( ppib );

	FUCB * const	pfucbIdx	= ( pfucbNil != pfucb->pfucbCurIndex ?
										pfucb->pfucbCurIndex :
										pfucb );
	FUCBSetSequential( pfucbIdx );

	return JET_errSuccess;
	}


//  ================================================================
ERR VTAPI ErrIsamResetSequential(
	const JET_SESID sesid,
	const JET_VTID vtid,
	const JET_GRBIT )
//  ================================================================
	{
	ERR				err;
 	PIB * const		ppib		= reinterpret_cast<PIB *>( sesid );
	FUCB * const	pfucb		= reinterpret_cast<FUCB *>( vtid );

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );
	CheckSecondary( pfucb );
	AssertDIRNoLatch( ppib );

	FUCB * const	pfucbIdx	= ( pfucbNil != pfucb->pfucbCurIndex ?
										pfucb->pfucbCurIndex :
										pfucb );
	FUCBResetSequential( pfucbIdx );
	FUCBResetPreread( pfucbIdx );

	return JET_errSuccess;
	}


ERR VTAPI ErrIsamOpenTable(
	JET_SESID	vsesid,
	JET_DBID	vdbid,
	JET_TABLEID	*ptableid,
	CHAR		*szPath,
	JET_GRBIT	grbit )
	{
	ERR			err;
	PIB			*ppib	= (PIB *)vsesid;
	const IFMP	ifmp	= (IFMP)vdbid;
	FUCB		*pfucb	= pfucbNil;

	//	initialise return value
	Assert( ptableid );
	*ptableid = JET_tableidNil;
	
	//	check parameters
	//
	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrPIBCheckIfmp( ppib, ifmp ) );
	AssertDIRNoLatch( ppib );

	if ( grbit & ( JET_bitTableDelete | JET_bitTableCreate ) )
		{
		err = ErrERRCheck( JET_errInvalidGrbit );
		goto HandleError;
		}
	else if ( grbit & JET_bitTablePermitDDL )
		{
		if ( !( grbit & JET_bitTableDenyRead ) )
			{
			err = ErrERRCheck( JET_errInvalidGrbit );
			goto HandleError;
			}
		}

	Call( ErrFILEOpenTable( ppib, ifmp, &pfucb, szPath, grbit ) );

#ifdef DEBUG
	if ( rgfmp[ifmp].FReadOnlyAttach() || ( grbit & JET_bitTableReadOnly ) )
		Assert( !FFUCBUpdatable( pfucb ) );
	else
		Assert( FFUCBUpdatable( pfucb ) );
#endif		

	pfucb->pvtfndef = &vtfndefIsam;
	*(FUCB **)ptableid = pfucb;

	AssertDIRNoLatch( ppib );
	return JET_errSuccess;

HandleError:

	AssertDIRNoLatch( ppib );
	return err;
	}


// monitoring statistics 

PM_CEF_PROC LTableOpenCacheHitsCEFLPv;
PERFInstanceG<> cTableOpenCacheHits;
long LTableOpenCacheHitsCEFLPv( long iInstance, void *pvBuf )
	{
	cTableOpenCacheHits.PassTo( iInstance, pvBuf );
	return 0;
	}


PM_CEF_PROC LTableOpenCacheMissesCEFLPv;
PERFInstanceG<> cTableOpenCacheMisses;
long LTableOpenCacheMissesCEFLPv( long iInstance, void *pvBuf )
	{
	cTableOpenCacheMisses.PassTo( iInstance, pvBuf );
	return 0;
	}

PM_CEF_PROC LTableOpensCEFLPv;
long LTableOpensCEFLPv( long iInstance, void *pvBuf )
	{
	if ( NULL != pvBuf )
		{
		*(LONG*)pvBuf = cTableOpenCacheHits.Get( iInstance ) + cTableOpenCacheMisses.Get( iInstance );
		}
	return 0;
	}


//	set domain usage mode or return error.  Allow only one deny read
//	or one deny write.  Sessions that own locks may open other read
//	or read write cursors.
//
LOCAL ERR ErrFILEISetMode( FUCB *pfucb, const JET_GRBIT grbit )
	{
	ERR		wrn		= JET_errSuccess;
	PIB		*ppib	= pfucb->ppib;
	FCB		*pfcb	= pfucb->u.pfcb;
	FUCB	*pfucbT;

	Assert( !pfcb->FDeleteCommitted() );

	//	all cursors can read so check for deny read flag by other session.
	//
	if ( pfcb->FDomainDenyRead( ppib ) )
		{
		Assert( pfcb->PpibDomainDenyRead() != ppibNil );
		if ( pfcb->PpibDomainDenyRead() != ppib )
			{
			return ErrERRCheck( JET_errTableLocked );
			}
			
#ifdef DEBUG
		for ( pfucbT = pfcb->Pfucb(); pfucbT != pfucbNil; pfucbT = pfucbT->pfucbNextOfFile )
			{
			Assert( pfucbT->ppib == pfcb->PpibDomainDenyRead()
				|| FPIBSessionSystemCleanup( pfucbT->ppib ) );
			}
#endif
		}

	//	check for deny write flag by other session.  If deny write flag
	//	set then only cursors of that session or cleanup cursors may have
	//	write privileges.
	//
	if ( grbit & JET_bitTableUpdatable )
		{
		if ( pfcb->FDomainDenyWrite() )
			{
			for ( pfucbT = pfcb->Pfucb(); pfucbT != pfucbNil; pfucbT = pfucbT->pfucbNextOfFile )
				{
				if ( pfucbT->ppib != ppib && FFUCBDenyWrite( pfucbT ) )
					{
					return ErrERRCheck( JET_errTableLocked );
					}
				}
			}
		}

	//	if deny write lock requested, check for updatable cursor of
	//	other session.  If lock is already held, even by given session,
	//	then return error.
	//
	if ( grbit & JET_bitTableDenyWrite )
		{
		//	if any session has this table open deny write, including given
		//	session, then return error.
		//
		if ( pfcb->FDomainDenyWrite() )
			{
			return ErrERRCheck( JET_errTableInUse );
			}

		//	check is cursors with write mode on domain.
		//
		for ( pfucbT = pfcb->Pfucb(); pfucbT != pfucbNil; pfucbT = pfucbT->pfucbNextOfFile )
			{
			if ( pfucbT->ppib != ppib
				&& FFUCBUpdatable( pfucbT )
				&& !FPIBSessionSystemCleanup( pfucbT->ppib ) )
				{
				return ErrERRCheck( JET_errTableInUse );
				}
			}
		pfcb->SetDomainDenyWrite();
		FUCBSetDenyWrite( pfucb );
		}

	//	if deny read lock requested, then check for cursor of other
	//	session.  If lock is already held, return error.
	//
	if ( grbit & JET_bitTableDenyRead )
		{
		//	if other session has this table open deny read, return error
		//
		if ( pfcb->FDomainDenyRead( ppib ) )
			{
			return ErrERRCheck( JET_errTableInUse );
			}
			
		//	check if cursors belonging to another session
		//	are open on this domain.
		//
		BOOL	fOpenSystemCursor = fFalse;
		for ( pfucbT = pfcb->Pfucb(); pfucbT != pfucbNil; pfucbT = pfucbT->pfucbNextOfFile )
			{
			if ( pfucbT != pfucb )		// Ignore current cursor )
				{
				if ( FPIBSessionSystemCleanup( pfucbT->ppib ) )
					{
					fOpenSystemCursor = fTrue;
					}
				else if ( pfucbT->ppib != ppib
					|| ( ( grbit & JET_bitTableDelete ) && !FFUCBDeferClosed( pfucbT ) ) )
					{
					return ErrERRCheck( JET_errTableInUse );
					}
				}
			}

		if ( fOpenSystemCursor )
			{
			wrn = ErrERRCheck( JET_wrnTableInUseBySystem );
			}

		pfcb->SetDomainDenyRead( ppib );
		FUCBSetDenyRead( pfucb );

		if ( grbit & JET_bitTablePermitDDL )
			{
			if ( !pfcb->FTemplateTable() )
				{
				ENTERCRITICALSECTION	enterCritFCBRCE( &pfcb->CritRCEList() );
				if ( pfcb->PrceNewest() != prceNil )
					return ErrERRCheck( JET_errTableInUse );

				Assert( pfcb->PrceOldest() == prceNil );
				}

			FUCBSetPermitDDL( pfucb );
			}
		}

	return wrn;
	}


//	if opening domain for read, write or read write, and not with
//	deny read or deny write, and domain does not have deny read or
//	deny write set, then return JET_errSuccess, else call
//	ErrFILEISetMode to determine if lock is by other session or to
//	put lock on domain.			 
//
LOCAL ERR ErrFILEICheckAndSetMode( FUCB *pfucb, const ULONG grbit )
	{
	PIB	*ppib = pfucb->ppib;
	FCB	*pfcb = pfucb->u.pfcb;

	if ( grbit & JET_bitTableReadOnly )
		{
		if ( grbit & JET_bitTableUpdatable )
			{
			return ErrERRCheck( JET_errInvalidGrbit );
			}

		FUCBResetUpdatable( pfucb );
		}

	// table delete cannot be specified without DenyRead
	//
	Assert( !( grbit & JET_bitTableDelete )
		|| ( grbit & JET_bitTableDenyRead ) );
	
	// PermitDDL cannot be specified without DenyRead
	//
	Assert( !( grbit & JET_bitTablePermitDDL )
		|| ( grbit & JET_bitTableDenyRead ) );
	
	//	if table is scheduled for deletion, then return error
	//
	if ( pfcb->FDeletePending() )
		{
		// Normally, the FCB of a table to be deleted is protected by the
		// DomainDenyRead flag.  However, this flag is released during VERCommit,
		// while the FCB is not actually purged until RCEClean.  So to prevent
		// anyone from accessing this FCB after the DomainDenyRead flag has been
		// released but before the FCB is actually purged, check the DeletePending
		// flag, which is NEVER cleared after a table is flagged for deletion.
		//
		return ErrERRCheck( JET_errTableLocked );
		}

	//	if read/write restrictions specified, or other
	//	session has any locks, then must check further
	//
	if ( ( grbit & (JET_bitTableDenyRead|JET_bitTableDenyWrite) )
		|| pfcb->FDomainDenyRead( ppib )
		|| pfcb->FDomainDenyWrite() )
		{
		return ErrFILEISetMode( pfucb, grbit );
		}

	if( grbit & JET_bitTableNoCache )
		{
		pfcb->SetNoCache();
		}
	else
		{
		pfcb->ResetNoCache();
		}

	if( grbit & JET_bitTablePreread )
		{
		pfcb->SetPreread();
		}
	else
		{
		pfcb->ResetPreread();
		}

	return JET_errSuccess;
	}

				
	
//+local
//	ErrFILEOpenTable
//	========================================================================
//	ErrFILEOpenTable(
//		PIB *ppib,			// IN	 PIB of who is opening file
//		IFMP ifmp,			// IN	 database id
//		FUCB **ppfucb,		// OUT	 receives a new FUCB open on the file
//		CHAR *szName,		// IN	 path name of file to open
//		ULONG grbit );		// IN	 open flags
//	Opens a data file, returning a new
//	FUCB on the file.
//
// PARAMETERS
//				ppib	   	PIB of who is opening file
//				ifmp	   	database id
//				ppfucb		receives a new FUCB open on the file
//						   	( should NOT already be pointing to an FUCB )
//				szName		path name of file to open ( the node
//						   	corresponding to this path must be an FDP )
//				grbit	   	flags:
//						   	JET_bitTableDenyRead	open table in exclusive mode;
//						   	default is share mode
// RETURNS		Lower level errors, or one of:
//					 JET_errSuccess					Everything worked.
//					-TableInvalidName	 			The path given does not
//										 			specify a file.
//					-JET_errDatabaseCorrupted		The database directory tree
//										 			is corrupted.
//					-Various out-of-memory error codes.
//				In the event of a fatal ( negative ) error, a new FUCB
//				will not be returned.
// SIDE EFFECTS FCBs for the file and each of its secondary indexes are
//				created ( if not already in the global list ).  The file's
//				FCB is inserted into the global FCB list.  One or more
//				unused FCBs may have had to be reclaimed.
//				The currency of the new FUCB is set to "before the first item".
// SEE ALSO		ErrFILECloseTable
//-
ERR ErrFILEOpenTable(
	PIB			*ppib,
	IFMP		ifmp,
	FUCB		**ppfucb,
	const CHAR	*szName,
	ULONG		grbit,
	FDPINFO		*pfdpinfo )
	{
	ERR			err;
	FUCB		*pfucb					= pfucbNil;
	FCB			*pfcb;
	CHAR		szTable[JET_cbNameMost+1];
	BOOL		fOpeningSys;
	PGNO		pgnoFDP					= pgnoNull;
	OBJID		objidTable				= objidNil;
	BOOL		fInTransaction			= fFalse;
	BOOL		fInitialisedCursor		= fFalse;

	Assert( ppib != ppibNil );
	Assert( ppfucb != NULL );
	FMP::AssertVALIDIFMP( ifmp );

	//	initialize return value to Nil
	//
	*ppfucb = pfucbNil; 

#ifdef DEBUG
	CheckPIB( ppib );
	if( !Ptls()->fIsTaskThread
		&& !Ptls()->fIsTaskThread
		&& !Ptls()->fIsRCECleanup )
		{
		CheckDBID( ppib, ifmp );
		}
#endif	//	DEBUG
	CallR( ErrUTILCheckName( szTable, szName, JET_cbNameMost+1 ) );

	fOpeningSys = FCATSystemTable( szTable );

	if ( NULL == pfdpinfo )
		{
		if ( dbidTemp == rgfmp[ ifmp ].Dbid() )
			{
			// Temp tables should pass in PgnoFDP.
			AssertSz( fFalse, "Illegal dbid" );
			return ErrERRCheck( JET_errInvalidDatabaseId );
			}

		if ( fOpeningSys )
			{
			if ( grbit & JET_bitTableDelete )
				{
				return ErrERRCheck( JET_errCannotDeleteSystemTable );
				}
			pgnoFDP 	= PgnoCATTableFDP( szTable );
			objidTable 	= ObjidCATTable( szTable );
			}
		else
			{
			if ( 0 == ppib->level )
				{
				CallR( ErrDIRBeginTransaction( ppib, JET_bitTransactionReadOnly ) );
				fInTransaction = fTrue;
				}

			//	lookup the table in the catalog hash before seeking
			if ( !FCATHashLookup( ifmp, szTable, &pgnoFDP, &objidTable ) )
				{
				Call( ErrCATSeekTable( ppib, ifmp, szTable, &pgnoFDP, &objidTable ) );
				}
			}
		}
	else 
		{
		Assert( pgnoNull != pfdpinfo->pgnoFDP );
		Assert( objidNil != pfdpinfo->objidFDP );
		pgnoFDP = pfdpinfo->pgnoFDP;
		objidTable = pfdpinfo->objidFDP;

#ifdef DEBUG
		if( fOpeningSys )
			{
			Assert( fGlobalRepair );
			Assert( PgnoCATTableFDP( szTable ) == pgnoFDP );
			Assert( ObjidCATTable( szTable ) == objidTable );
			}
		else if ( dbidTemp != rgfmp[ ifmp ].Dbid() )
			{
			PGNO	pgnoT;
			OBJID	objidT;

			//	lookup the table in the catalog hash before seeking
			if ( !FCATHashLookup( ifmp, szTable, &pgnoT, &objidT ) )
				{
				CallR( ErrCATSeekTable( ppib, ifmp, szTable, &pgnoT, &objidT ) );
				}

			Assert( pgnoT == pgnoFDP );
			Assert( objidT == objidTable );
			}
#endif	//	DEBUG
		}

	Assert( pgnoFDP > pgnoSystemRoot );
	Assert( pgnoFDP <= pgnoSysMax );
	Assert( objidNil != objidTable );
	Assert( objidTable > objidSystemRoot );

	Call( ErrDIROpenNoTouch( ppib, ifmp, pgnoFDP, objidTable, fTrue, &pfucb ) );
	Assert( pfucbNil != pfucb );

	pfcb = pfucb->u.pfcb;
	Assert( objidTable == pfcb->ObjidFDP() );
	Assert( pgnoFDP == pfcb->PgnoFDP() );

	FUCBSetIndex( pfucb );

	if( grbit & JET_bitTablePreread 
		|| grbit & JET_bitTableSequential )
		{
		//  Preread the root page of the tree
		BFPrereadPageRange( ifmp, pgnoFDP, 1 );
		}

	//	if we're opening after table creation, the FCB shouldn't be initialised
	Assert( !( grbit & JET_bitTableCreate ) || !pfcb->FInitialized() );

	// Only one thread could possibly get to this point with an uninitialized
	// FCB, which is why we don't have to grab the FCB's critical section.
	if ( !pfcb->FInitialized() )
		{
		if ( fInTransaction )
			{
			//	if FCB is not initialised, access to is serialised
			//	at this point, so no more need for transaction
			Call( ErrDIRCommitTransaction( ppib,NO_GRBIT ) );
			fInTransaction = fFalse;
			}

		if ( fOpeningSys )
			{
			Call( ErrCATInitCatalogFCB( pfucb ) );
			}
		else if ( dbidTemp == rgfmp[ ifmp ].Dbid() )
			{
			Assert( !( grbit & JET_bitTableDelete ) );
			Call( ErrCATInitTempFCB( pfucb ) );
			}

			///	BUGFIX: 99457: always init the TDB because we need to know if there are SLV columns
#ifdef NEVER			
		else if ( grbit & JET_bitTableDelete )
			{
			//	opening a table for deletion.  Do not
			//	initialise but instead mark it as a sentinel.
			//
			pfcb->SetTypeSentinel();
			Assert( pfcb->Ptdb() == ptdbNil );
			}
#endif	//	NEVER

		else
			{
			//	initialize the table's FCB
			
			Call( ErrCATInitFCB( pfucb, objidTable ) );

			//	cache the table name in the catalog hash after it gets initialized
			if ( !( grbit & ( JET_bitTableCreate|JET_bitTableDelete) ) )
				{
				CATHashInsert( pfcb, pfcb->Ptdb()->SzTableName() );
				}

			//	only count "regular" table opens

			cTableOpenCacheMisses.Inc( PinstFromPpib( ppib ) );
			}

		Assert( pfcb->Ptdb() != ptdbNil || pfcb->FTypeSentinel() );

		//	insert the FCB into the global list

		pfcb->InsertList();

		//	we have a full-fledged initialised cursor
		//	(FCB will be marked initialised in CreateComplete()
		//	below, which is guaranteed to succeed)
		fInitialisedCursor = fTrue;

		//	allow other cursors to use this FCB

		pfcb->Lock();
		Assert( !pfcb->FTypeNull() );
		Assert( !pfcb->FInitialized() );
		Assert( pfcb == pfucb->u.pfcb );
		pfcb->CreateComplete();
		err = ErrFILEICheckAndSetMode( pfucb, grbit );
		pfcb->Unlock();

		//	check result of ErrFILEICheckAndSetMode
		Call( err );
		}
	else
		{
		if ( !fOpeningSys
			&& dbidTemp != rgfmp[ ifmp ].Dbid()
			&& !( grbit & JET_bitTableDelete ) )
			{
			//	only count "regular" table opens
			cTableOpenCacheHits.Inc( PinstFromPpib( ppib ) );
			}
			
		//	we have a full-fledged initialised cursor
		fInitialisedCursor = fTrue;

		//	set table usage mode
		//
		Assert( pfcb == pfucb->u.pfcb );
		pfcb->Lock();
		err = ErrFILEICheckAndSetMode( pfucb, grbit );
		pfcb->Unlock();

		//	check result of ErrFILEICheckAndSetMode
		Call( err );

		if ( fInTransaction )
			{
			Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );
			fInTransaction = fFalse;
			}
		}

	//	System cleanup threads (OLD and RCEClean) are permitted to open
	//	a cursor on a deleted table
	Assert( !pfcb->FDeletePending() || FPIBSessionSystemCleanup( ppib ) );
	Assert( !pfcb->FDeleteCommitted() || FPIBSessionSystemCleanup( ppib ) );

	//  set FUCB for sequential access if requested
	//
	if ( grbit & JET_bitTableSequential )
		FUCBSetSequential( pfucb );
	else
		FUCBResetSequential( pfucb );

#ifdef TABLES_PERF
	//  set the Table Class for this table and all its indexes
	//
	if ( pfcb->Ptdb() != ptdbNil )
		{
		Assert( !pfcb->FTypeSentinel() );

		pfcb->EnterDDL();
		pfcb->SetTableclass( TABLECLASS( ( grbit & JET_bitTableClassMask ) / JET_bitTableClass1 ) );
		for ( FCB *pfcbT = pfcb->PfcbNextIndex(); pfcbT != pfcbNil; pfcbT = pfcbT->PfcbNextIndex() )
			{
			pfcbT->SetTableclass( pfcb->Tableclass() );
			}
		pfcb->LeaveDDL();
		}
	else
		{
		Assert( pfcb->FTypeSentinel() );
		Assert( pfcbNil == pfcb->PfcbNextIndex() );
		}
#endif  //  TABLES_PERF

	//	reset copy buffer
	//
	pfucb->pvWorkBuf = NULL;
	pfucb->dataWorkBuf.SetPv( NULL );
	Assert( !FFUCBUpdatePrepared( pfucb ) );

	//	reset key buffer
	//
	pfucb->dataSearchKey.Nullify();
	pfucb->cColumnsInSearchKey = 0;
	KSReset( pfucb );

	FUCBSetMayCacheLVCursor( pfucb );

	//	move currency to the first record and ignore error if no records
	//
	RECDeferMoveFirst( ppib, pfucb );

#ifdef DEBUG
	if ( pfcb->Ptdb() != ptdbNil )
		{
		Assert( !pfcb->FTypeSentinel() );
	
		pfcb->EnterDDL();
		for ( FCB *pfcbT = pfcb->PfcbNextIndex(); pfcbT != pfcbNil; pfcbT = pfcbT->PfcbNextIndex() )
			{
			Assert( pfcbT->PfcbTable() == pfcb );
			}
		pfcb->LeaveDDL();
		}
	else
		{
		Assert( pfcb->FTypeSentinel() );
		Assert( pfcbNil == pfcb->PfcbNextIndex() );
		}
#endif

	Assert( !fInTransaction );
	AssertDIRNoLatch( ppib );
	*ppfucb = pfucb;

	//	Be sure to return the error from ErrFILEICheckAndSetMode()
	CallSx( err, JET_wrnTableInUseBySystem );
	return err;

HandleError:
	Assert( pfucbNil != pfucb || !fInitialisedCursor );
	if ( pfucbNil != pfucb )
		{
		if ( fInitialisedCursor )
			{
			CallS( ErrFILECloseTable( ppib, pfucb ) );
			}
		else
			{
			DIRClose( pfucb );
			}
		}

	if ( fInTransaction )
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}
	AssertDIRNoLatch( ppib );

	return err;
	}


ERR VTAPI ErrIsamCloseTable( JET_SESID sesid, JET_VTID vtid )
	{
 	PIB *ppib	= reinterpret_cast<PIB *>( sesid );
	FUCB *pfucb = reinterpret_cast<FUCB *>( vtid );

	ERR		err;

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );

	Assert( pfucb->pvtfndef == &vtfndefIsam );

	//	reset pfucb which was exported as tableid
	//	 
	pfucb->pvtfndef = &vtfndefInvalidTableid;
	err = ErrFILECloseTable( ppib, pfucb );
	return err;
	}


//+API
//	ErrFILECloseTable
//	========================================================================
//	ErrFILECloseTable( PIB *ppib, FUCB *pfucb )
//
//	Closes the FUCB of a data file, previously opened using FILEOpen.
//	Also closes the current secondary index, if any.
//
//	PARAMETERS	ppib	PIB of this user
//				pfucb	FUCB of file to close
//
//	RETURNS		JET_errSuccess
//				or lower level errors
//
//	SEE ALSO 	ErrFILEOpenTable
//-
ERR ErrFILECloseTable( PIB *ppib, FUCB *pfucb )
	{
	CheckPIB( ppib );
	CheckTable( ppib, pfucb );
	Assert( pfucb->pvtfndef == &vtfndefInvalidTableid );

	if ( FFUCBUpdatePrepared( pfucb ) )
		{
		CallS( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepCancel ) );
		}
	Assert( !FFUCBUpdatePrepared( pfucb ) );

	//  reset the index-range in case this cursor
	//  is used for a rollback
	DIRResetIndexRange( pfucb );
	
	//	release working buffer and search key
	//
	RECIFreeCopyBuffer( pfucb );

	RECReleaseKeySearchBuffer( pfucb );

	//	detach, close and free index/lv FUCB, if any
	//
	DIRCloseIfExists( &pfucb->pfucbCurIndex );
	DIRCloseIfExists( &pfucb->pfucbLV );

	//	if closing a temporary table, free resources if
	//	last one to close.
	//
	if ( pfucb->u.pfcb->FTypeTemporaryTable() )
		{
		FCB		*pfcb = pfucb->u.pfcb;
		INT		wRefCnt;
		FUCB	*pfucbT;

		Assert( rgfmp[ pfcb->Ifmp() ].Dbid() == dbidTemp );
		Assert( pfcb->Ptdb() != ptdbNil );
		Assert( pfcb->FFixedDDL() );
		DIRClose( pfucb );

		//	We may have deferred close cursors on the temporary table.
		//	If one or more cursors are open, then temporary table
		//	should not be deleted.
		//
		pfucbT = ppib->pfucbOfSession;
		wRefCnt = pfcb->WRefCount();
		while ( wRefCnt > 0 && pfucbT != pfucbNil )
			{
			Assert( pfucbT->ppib == ppib );	// We should be the only one with access to the temp. table.
			if ( pfucbT->u.pfcb == pfcb )
				{
				if ( !FFUCBDeferClosed( pfucbT ) )
					{
					break;
					}
				Assert( wRefCnt > 0 );
				wRefCnt--;
				}

			pfucbT = pfucbT->pfucbNextOfSession;
			}
		Assert( wRefCnt >= 0 );
		if ( wRefCnt == 0 )
			{
			Assert( ppibNil != ppib );
			
			// Shouldn't be any index FDP's to free, since we don't
			// currently support secondary indexes on temp. tables.
			Assert( pfcb->PfcbNextIndex() == pfcbNil );

			// We nullify temp table RCEs at commit time so there should be 
			// no RCEs on the FCBs except uncommitted ones
			
			Assert( pfcb->Ptdb() != ptdbNil );
			FCB	* const pfcbLV = pfcb->Ptdb()->PfcbLV();
			if ( pfcbNil != pfcbLV )
				{
				Assert( pfcbLV->PrceNewest() == prceNil || pfcbLV->PrceNewest()->TrxCommitted() == trxMax );
				Assert( pfcbLV->PrceOldest() == prceNil || pfcbLV->PrceOldest()->TrxCommitted() == trxMax );
				VERNullifyAllVersionsOnFCB( pfcbLV );
				FUCBCloseAllCursorsOnFCB( ppib, pfcbLV );
				
				Assert( !pfcbLV->FDeleteCommitted() );
				pfcbLV->SetDeleteCommitted();

				pfcbLV->PrepareForPurge( fFalse );
				}

			Assert( pfcb->PrceNewest() == prceNil || pfcb->PrceNewest()->TrxCommitted() == trxMax  );
			Assert( pfcb->PrceOldest() == prceNil || pfcb->PrceOldest()->TrxCommitted() == trxMax  );
			VERNullifyAllVersionsOnFCB( pfcb );
			FUCBCloseAllCursorsOnFCB( ppib, pfcb );
				
			Assert( !pfcb->FDeleteCommitted() );
			pfcb->SetDeleteCommitted();

			//	prepare the FCB to be purged
			//	this removes the FCB from the hash-table among other things
			//		so that the following case cannot happen:
			//			we free the space for this FCb
			//			someone else allocates it
			//			someone else BTOpen's the space
			//			we try to purge the table and find that the refcnt
			//				is not zero and the state of the FCB says it is
			//				currently in use! 
			//			result --> CONCURRENCY HOLE

			pfcb->PrepareForPurge( fFalse );

			//	if fail to delete temporary table, then lose space until
			//	termination.  Temporary database is deleted on termination
			//	and space is reclaimed.  This error should be rare, and
			//	can be caused by resource failure.
			
			// Under most circumstances, this should not fail.  Since we check
			// the RefCnt beforehand, we should never fail with JET_errTableLocked
			// or JET_errTableInUse.  If we do, it's indicative of a
			// concurrency problem.
			(VOID)ErrSPFreeFDP( ppib, pfcb, pgnoSystemRoot );

			pfcb->Purge();
			}
		return JET_errSuccess;
		}

	DIRClose( pfucb );
	return JET_errSuccess;
	}


ERR ErrFILEIInitializeFCB(
	PIB			*ppib,
	IFMP		ifmp,
	TDB			*ptdb,
	FCB			*pfcbNew,
	IDB			*pidb,
	BOOL		fPrimary,
	PGNO		pgnoFDP,
	ULONG_PTR	ul )	// Density of non-derived index, pfcbTemplateIndex if derived index
	{
	ERR		err = JET_errSuccess;

	Assert( pgnoFDP > pgnoSystemRoot );
	Assert( pgnoFDP <= pgnoSysMax );
	Assert( pfcbNew != pfcbNil );
	Assert( pfcbNew->Ifmp() == ifmp );
	Assert( pfcbNew->PgnoFDP() == pgnoFDP );

	Assert( pfcbNew->Ptdb() == ptdbNil );

	if ( fPrimary )
		{
		pfcbNew->SetPtdb( ptdb );
		pfcbNew->SetPrimaryIndex();
		Assert( !pfcbNew->FSequentialIndex() );
		if ( pidbNil == pidb )
			pfcbNew->SetSequentialIndex();
		}
	else
		{
		pfcbNew->SetTypeSecondaryIndex();
		}

	if  ( pidb != pidbNil && pidb->FDerivedIndex() )
		{
		FCB	*pfcbTemplateIndex = (FCB *)ul;

		Assert( pfcbTemplateIndex->FTemplateIndex() );
		Assert( pfcbTemplateIndex->Pidb() != pidbNil );
		Assert( pfcbTemplateIndex->Pidb()->FTemplateIndex() );
		pfcbNew->SetCbDensityFree( pfcbTemplateIndex->CbDensityFree() );
		pfcbNew->SetPidb( pfcbTemplateIndex->Pidb() );

		Assert( !pfcbNew->FTemplateIndex() );
		pfcbNew->SetDerivedIndex();
		}
	else
		{
		Assert( ul >= ulFILEDensityLeast );
		Assert( ul <= ulFILEDensityMost );
		Assert( ((( 100 - ul ) << g_shfCbPage ) / 100) < g_cbPage );
		pfcbNew->SetCbDensityFree( (SHORT)( ( ( 100 - ul ) << g_shfCbPage ) / 100 ) );

		Assert( pidb != pidbNil || fPrimary );
		if ( pidb != pidbNil )
			{
			if ( pidb->FTemplateIndex() )
				pfcbNew->SetTemplateIndex();
			Call( ErrFILEIGenerateIDB( pfcbNew, ptdb, pidb ) );
			}
		}

	Assert( err >= 0 );
	return err;
	
HandleError:	
	Assert( err < 0 );
	Assert( pfcbNew->Pidb() == pidbNil );		// Verify IDB not allocated.
	return err;
	}


INLINE VOID RECIForceTaggedColumnsAsDerived(
	const TDB			* const ptdb,
	DATA&				dataDefault )
	{
	TAGFIELDS			tagfields( dataDefault );
	tagfields.ForceAllColumnsAsDerived();
	tagfields.AssertValid( ptdb );
	}

// To build a default record, we need a fake FUCB and FCB for RECSetColumn().
// We also need to allocate a temporary buffer in which to store the default
// record.
VOID FILEPrepareDefaultRecord( FUCB *pfucbFake, FCB *pfcbFake, TDB *ptdb )
	{
	Assert( ptdbNil != ptdb );
	pfcbFake->SetPtdb( ptdb );			// Attach a real TDB and a fake FCB.
	pfucbFake->u.pfcb = pfcbFake;
	FUCBSetIndex( pfucbFake );

	pfcbFake->ResetFlags();
	pfcbFake->SetTypeTable();			// Ensures SetColumn doesn't need crit. sect.
	pfcbFake->SetFixedDDL();

	pfucbFake->pvWorkBuf = NULL;
	RECIAllocCopyBuffer( pfucbFake );

	if ( pfcbNil != ptdb->PfcbTemplateTable() )
		{
		ptdb->AssertValidDerivedTable();
		pfcbFake->SetDerivedTable();

		const TDB	* const ptdbTemplate = ptdb->PfcbTemplateTable()->Ptdb();

		// If template table exists, use its default record.
		Assert( ptdbTemplate != ptdbNil );
		Assert( NULL != ptdbTemplate->PdataDefaultRecord() );
		ptdbTemplate->PdataDefaultRecord()->CopyInto( pfucbFake->dataWorkBuf );

		//	update derived bit of all tagged columns
		RECIForceTaggedColumnsAsDerived( ptdb, pfucbFake->dataWorkBuf );
		}
	else
		{
		if ( ptdb->FTemplateTable() )
			{
			ptdb->AssertValidTemplateTable();
			pfcbFake->SetTemplateTable();
			}

		// Start with an empty record.
		REC::SetMinimumRecord( pfucbFake->dataWorkBuf );
		}
	}


LOCAL ERR ErrFILERebuildOneDefaultValue(
	FUCB			* pfucbFake,
	const COLUMNID	columnid,
	const COLUMNID	columnidToAdd,
	const DATA		* const pdataDefaultToAdd )
	{
	ERR				err;
	DATA			dataDefaultValue;

	if ( columnid == columnidToAdd )
		{
		Assert( pdataDefaultToAdd );
		dataDefaultValue = *pdataDefaultToAdd;
		}
	else
		{
		CallR( ErrRECIRetrieveDefaultValue(
						pfucbFake->u.pfcb,
						columnid,
						&dataDefaultValue ) );

		Assert( JET_wrnColumnNull != err );
		Assert( wrnRECUserDefinedDefault != err );
		Assert( wrnRECSeparatedSLV != err );
		Assert( wrnRECIntrinsicSLV != err );
		Assert( wrnRECSeparatedLV != err );

		Assert( wrnRECLongField != err );
		}

	Assert( dataDefaultValue.Pv() != NULL );
	Assert( dataDefaultValue.Cb() > 0 );
	CallR( ErrRECSetDefaultValue(
				pfucbFake,
				columnid,
				dataDefaultValue.Pv(),
				dataDefaultValue.Cb() ) );

	return err;
	}

ERR ErrFILERebuildDefaultRec(
	FUCB			* pfucbFake,
	const COLUMNID	columnidToAdd,
	const DATA		* const pdataDefaultToAdd )
	{
	ERR				err		= JET_errSuccess;
	TDB				* ptdb	= pfucbFake->u.pfcb->Ptdb();
	VOID			*pv		= NULL;
	FID				fid;

	Assert( ptdbNil != ptdb );

	for ( fid = ptdb->FidFixedFirst(); ;fid++ )
		{
		if ( ptdb->FidFixedLast() + 1 == fid )
			fid = ptdb->FidVarFirst();
		if ( ptdb->FidVarLast() + 1 == fid )
			fid = ptdb->FidTaggedFirst();
		if ( fid > ptdb->FidTaggedLast() )
			break;

		Assert( ( fid >= ptdb->FidFixedFirst() && fid <= ptdb->FidFixedLast() )
			|| ( fid >= ptdb->FidVarFirst() && fid <= ptdb->FidVarLast() )
			|| ( fid >= ptdb->FidTaggedFirst() && fid <= ptdb->FidTaggedLast() ) );

		const COLUMNID	columnid		= ColumnidOfFid( fid, ptdb->FTemplateTable() );
		const FIELD		* const pfield	= ptdb->Pfield( columnid );
		if ( FFIELDDefault( pfield->ffield )
			&& !FFIELDUserDefinedDefault( pfield->ffield )
			&& !FFIELDCommittedDelete( pfield->ffield ) )	//	make sure column not deleted
			{
			Assert( JET_coltypNil != pfield->coltyp );
			Call( ErrFILERebuildOneDefaultValue(
						pfucbFake,
						columnid,
						columnidToAdd,
						pdataDefaultToAdd ) );
			}
		}

	//	in case we have to chain together the buffers (to keep
	//	around copies of previous of old default records
	//	because other threads may have stale pointers),
	//	allocate a RECDANGLING buffer to preface the actual
	//	default record
	//
	RECDANGLING *	precdangling;

	precdangling = (RECDANGLING *)PvOSMemoryHeapAlloc( sizeof(RECDANGLING) + pfucbFake->dataWorkBuf.Cb() );
	if ( NULL == precdangling )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		goto HandleError;
		}

	precdangling->precdanglingNext = NULL;
	precdangling->data.SetPv( (BYTE *)precdangling + sizeof(RECDANGLING) );
	pfucbFake->dataWorkBuf.CopyInto( precdangling->data );
	ptdb->SetPdataDefaultRecord( &( precdangling->data ) );

HandleError:
	return err;
	}


//	combines all index column masks into a single per table
//	index mask, used for index update check skip.
//
VOID FILESetAllIndexMask( FCB *pfcbTable )
	{
	Assert( ptdbNil != pfcbTable->Ptdb() );

	FCB *					pfcbT;
	TDB *					ptdb		= pfcbTable->Ptdb();
	const LONG_PTR * const	plMax		= (LONG_PTR *)ptdb->RgbitAllIndex()
											+ ( cbRgbitIndex / sizeof(LONG_PTR) );

	//	initialize mask to primary index, or to 0s for sequential file.
	//
	if ( pfcbTable->Pidb() != pidbNil )
		{
		ptdb->SetRgbitAllIndex( pfcbTable->Pidb()->RgbitIdx() );
		}
	else
		{
		ptdb->ResetRgbitAllIndex();
		}

	//	for each secondary index, combine index mask with all index
	//	mask.  Also, combine has tagged flag.
	//
	for ( pfcbT = pfcbTable->PfcbNextIndex();
		pfcbT != pfcbNil;
		pfcbT = pfcbT->PfcbNextIndex() )
		{
		Assert( pfcbT->Pidb() != pidbNil );

		// Only process non-deleted indexes (or deleted but versioned).
		//
		if ( !pfcbT->Pidb()->FDeleted() || pfcbT->Pidb()->FVersioned() )
			{
			LONG_PTR *			plAll	= (LONG_PTR *)ptdb->RgbitAllIndex();
			const LONG_PTR *	plIndex	= (LONG_PTR *)pfcbT->Pidb()->RgbitIdx();
			for ( ; plAll < plMax; plAll++, plIndex++ )
				{
				*plAll |= *plIndex;
				}
			}
		}

	return;
	}

ERR ErrIDBSetIdxSeg(
	IDB				* const pidb,
	TDB				* const ptdb,
	const IDXSEG	* const rgidxseg )
	{
	ERR				err;

	if ( pidb->FIsRgidxsegInMempool() )
		{
		USHORT	itag;

		// Array is too big to fit into IDB, so put into TDB's byte pool instead.
		CallR( ptdb->MemPool().ErrAddEntry(
				(BYTE *)rgidxseg,
				pidb->Cidxseg() * sizeof(IDXSEG),
				&itag ) );

		pidb->SetItagRgidxseg( itag );
		}
	else
		{
		UtilMemCpy( pidb->rgidxseg, rgidxseg, pidb->Cidxseg() * sizeof(IDXSEG) );
		err = JET_errSuccess;
		}

	return err;
	}
ERR ErrIDBSetIdxSegConditional(
	IDB				* const pidb,
	TDB				* const ptdb,
	const IDXSEG 	* const rgidxseg )
	{
	ERR		err;

	if ( pidb->FIsRgidxsegConditionalInMempool() )
		{
		USHORT	itag;

		// Array is too big to fit into IDB, so put into TDB's byte pool instead.
		CallR( ptdb->MemPool().ErrAddEntry(
				(BYTE *)rgidxseg,
				pidb->CidxsegConditional() * sizeof(IDXSEG),
				&itag ) );
		pidb->SetItagRgidxsegConditional( itag );
		}
	else
		{
		UtilMemCpy( pidb->rgidxsegConditional, rgidxseg, pidb->CidxsegConditional() * sizeof(IDXSEG) );
		err = JET_errSuccess;
		}

	return err;
	}

ERR ErrIDBSetIdxSeg(
	IDB			* const pidb,
	TDB			* const ptdb,
	const BOOL	fConditional,
	const		LE_IDXSEG* const le_rgidxseg )
	{
	IDXSEG		rgidxseg[JET_ccolKeyMost];
	const ULONG	cidxseg		= ( fConditional ? pidb->CidxsegConditional() : pidb->Cidxseg() );

	if ( 0 == cidxseg )
		{
		Assert( fConditional );
		return JET_errSuccess;
		}

	//	If it is on little endian machine, we still copy it into
	//	the stack array which is aligned.
	//	If it is on big endian machine, we always need to convert first.
	
	for ( UINT iidxseg = 0; iidxseg < cidxseg; iidxseg++ )
		{
		//	Endian conversion
		rgidxseg[ iidxseg ] = (LE_IDXSEG &) le_rgidxseg[iidxseg];
		Assert( FCOLUMNIDValid( rgidxseg[iidxseg].Columnid() ) );
		}

	return ( fConditional ?
				ErrIDBSetIdxSegConditional( pidb, ptdb, rgidxseg ) :
				ErrIDBSetIdxSeg( pidb, ptdb, rgidxseg ) );
	}

VOID SetIdxSegFromOldFormat(
	const UnalignedLittleEndian< IDXSEG_OLD >	* const le_rgidxseg,
	IDXSEG			* const rgidxseg,
	const ULONG		cidxseg,
	const BOOL		fConditional,
	const BOOL		fTemplateTable,
	const TCIB		* const ptcibTemplateTable )
	{
	FID				fid;

	for ( UINT iidxseg = 0; iidxseg < cidxseg; iidxseg++ )
		{
		rgidxseg[iidxseg].ResetFlags();
///		rgidxseg[iidxseg].SetFOldFormat();

		if ( le_rgidxseg[iidxseg] < 0 )
			{
			if ( fConditional )
				{
				rgidxseg[iidxseg].SetFMustBeNull();
				}
			else
				{
				rgidxseg[iidxseg].SetFDescending();
				}
			fid = FID( -le_rgidxseg[iidxseg] );
			}
		else
			{
			fid = le_rgidxseg[iidxseg];
			}

		if ( NULL != ptcibTemplateTable )
			{
			Assert( !fTemplateTable );

			//	WARNING: the fidLast's were set based on what was found
			//	in the derived table, so if any are equal to fidLeast-1,
			//	it actually means there were no columns in the derived
			//	table and hence the column must belong to the template
			if ( FTaggedFid( fid ) )
				{
				if ( fidTaggedLeast-1 == ptcibTemplateTable->fidTaggedLast
					|| fid <= ptcibTemplateTable->fidTaggedLast )
					rgidxseg[iidxseg].SetFTemplateColumn();
				}
			else if ( FFixedFid( fid ) )
				{
				if ( fidFixedLeast-1 == ptcibTemplateTable->fidFixedLast
					|| fid <= ptcibTemplateTable->fidFixedLast )
					rgidxseg[iidxseg].SetFTemplateColumn();
				}
			else
				{
				Assert( FVarFid( fid ) );
				if ( fidVarLeast-1 == ptcibTemplateTable->fidVarLast
					|| fid <= ptcibTemplateTable->fidVarLast )
					rgidxseg[iidxseg].SetFTemplateColumn();
				}
			}

		else if ( fTemplateTable )
			{
			Assert( NULL == ptcibTemplateTable );
			Assert( !rgidxseg[iidxseg].FTemplateColumn() );
			rgidxseg[iidxseg].SetFTemplateColumn();
			}
		
		rgidxseg[iidxseg].SetFid( fid );
		Assert( FCOLUMNIDValid( rgidxseg[iidxseg].Columnid() ) );
		}
	}

ERR ErrIDBSetIdxSegFromOldFormat(
	IDB 		* const pidb,
	TDB			* const ptdb,
	const BOOL	fConditional,
	const UnalignedLittleEndian< IDXSEG_OLD >	* const le_rgidxseg )
	{
	IDXSEG		rgidxseg[JET_ccolKeyMost];
	const ULONG	cidxseg						= ( fConditional ? pidb->CidxsegConditional() : pidb->Cidxseg() );
	TCIB		tcibTemplateTable			= { FID( ptdb->FidFixedFirst()-1 ),
												FID( ptdb->FidVarFirst()-1 ),
												FID( ptdb->FidTaggedFirst()-1 ) };
#ifdef DEBUG
	if ( ptdb->FDerivedTable() )
		{
		Assert( ptdb->FESE97DerivedTable() );
		ptdb->AssertValidDerivedTable();
		}
	else if ( ptdb->FTemplateTable() )
		{
		Assert( ptdb->FESE97TemplateTable() );
		ptdb->AssertValidTemplateTable();
		}
#endif		

	if ( 0 == cidxseg )
		{
		Assert( fConditional );
		return JET_errSuccess;
		}

	SetIdxSegFromOldFormat(
			le_rgidxseg,
			rgidxseg,
			cidxseg,
			fConditional,
			ptdb->FTemplateTable(),
			( ptdb->FDerivedTable() ? &tcibTemplateTable : NULL ) );

	return ( fConditional ?
				ErrIDBSetIdxSegConditional( pidb, ptdb, rgidxseg ) :
				ErrIDBSetIdxSeg( pidb, ptdb, rgidxseg ) );
	}


const IDXSEG* PidxsegIDBGetIdxSeg( const IDB * const pidb, const TDB * const ptdb )
	{
	const IDXSEG* pidxseg;

	if ( pidb->FTemplateIndex() )
		{
		if ( pfcbNil != ptdb->PfcbTemplateTable() )
			{
			// Must retrieve from the template table's TDB.
			ptdb->AssertValidDerivedTable();
			pidxseg = PidxsegIDBGetIdxSeg( pidb, ptdb->PfcbTemplateTable()->Ptdb() );
			return pidxseg;
			}

		// If marked as a template index, but pfcbTemplateTable is NULL,
		// then this must already be the TDB for the template table.
		}
	
	if ( pidb->FIsRgidxsegInMempool() )
		{
		Assert( pidb->ItagRgidxseg() != 0 );
		Assert( ptdb->MemPool().CbGetEntry( pidb->ItagRgidxseg() ) == pidb->Cidxseg() * sizeof(IDXSEG) );
		pidxseg = (IDXSEG*)ptdb->MemPool().PbGetEntry( pidb->ItagRgidxseg() );
		}
	else
		{
		Assert( pidb->Cidxseg() > 0 );		// Must be at least one segment.
		pidxseg = pidb->rgidxseg;
		}

	return pidxseg;
	}

const IDXSEG* PidxsegIDBGetIdxSegConditional( const IDB * const pidb, const TDB * const ptdb )
	{
	const IDXSEG* pidxseg;

	if ( pidb->FTemplateIndex() )
		{
		if ( pfcbNil != ptdb->PfcbTemplateTable() )
			{
			// Must retrieve from the template table's TDB.
			ptdb->AssertValidDerivedTable();
			pidxseg = PidxsegIDBGetIdxSegConditional( pidb, ptdb->PfcbTemplateTable()->Ptdb() );
			return pidxseg;
			}

		// If marked as a template index, but pfcbTemplateTable is NULL,
		// then this must already be the TDB for the template table.
		}
	
	if ( pidb->FIsRgidxsegConditionalInMempool() )
		{
		Assert( pidb->ItagRgidxsegConditional() != 0 );
		Assert( ptdb->MemPool().CbGetEntry( pidb->ItagRgidxsegConditional() ) == pidb->CidxsegConditional() * sizeof(IDXSEG) );
		pidxseg = (IDXSEG*)ptdb->MemPool().PbGetEntry( pidb->ItagRgidxsegConditional() );
		}
	else
		{
		pidxseg = pidb->rgidxsegConditional;
		}

	return pidxseg;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\fcb.cxx ===
#include "std.hxx"


//	performance counters

//	"asynchronous" purging in FCB::ErrAlloc_ and 
//		FCB::FCheckFreeAndTryToLockForPurge_

PERFInstanceG<> cFCBAsyncScan;
PERFInstanceG<> cFCBAsyncPurge;
PERFInstanceG<> cFCBAsyncThresholdScan;
PERFInstanceG<> cFCBAsyncThresholdPurge;
PERFInstanceG<> cFCBAsyncPurgeConflict;

//	synchronous purging in FCB::LockForPurge_

PERFInstanceG<> cFCBSyncPurge;
PERFInstanceG<> cFCBSyncPurgeStalls;
PERFInstanceG<> cFCBAllocWaitForRCEClean;

//	FCB cache activity

PERFInstanceG<> cFCBCacheHits;
PERFInstanceG<> cFCBCacheRequests;
PERFInstanceG<> cFCBCacheStalls;

//	FCB cache sizes

PERFInstance<> cFCBCacheMax;
PERFInstance<> cFCBCachePreferred;
PERFInstanceG<> cFCBCacheAlloc;
PERFInstanceG<> cFCBCacheAllocAvail;


//	perf counter function declarations

PM_CEF_PROC LFCBAsyncScanCEFLPv;
PM_CEF_PROC LFCBAsyncPurgeCEFLPv;
PM_CEF_PROC LFCBAsyncThresholdScanCEFLPv;
PM_CEF_PROC LFCBAsyncThresholdPurgeCEFLPv;
PM_CEF_PROC LFCBAsyncPurgeConflictCEFLPv;
PM_CEF_PROC LFCBSyncPurgeCEFLPv;
PM_CEF_PROC LFCBSyncPurgeStallsCEFPLv;
PM_CEF_PROC LFCBAllocWaitForRCECleanCEFLPv;
PM_CEF_PROC LFCBCacheHitsCEFPLv;
PM_CEF_PROC LFCBCacheRequestsCEFLPv;
PM_CEF_PROC LFCBCacheStallsCEFLPv;
PM_CEF_PROC LFCBCacheMaxCEFLPv;
PM_CEF_PROC LFCBCachePreferredCEFLPv;
PM_CEF_PROC LFCBCacheAllocCEFLPv;
PM_CEF_PROC LFCBCacheAllocAvailCEFLPv;


//	perf counter function bodies

long LFCBAsyncScanCEFLPv( long iInstance, void* pvBuf )
	{
	cFCBAsyncScan.PassTo( iInstance, pvBuf );
	return 0;
	}

long LFCBAsyncPurgeCEFLPv( long iInstance, void* pvBuf )
	{
	cFCBAsyncPurge.PassTo( iInstance, pvBuf );
	return 0;
	}

long LFCBAsyncThresholdScanCEFLPv( long iInstance, void* pvBuf )
	{
	cFCBAsyncThresholdScan.PassTo( iInstance, pvBuf );
	return 0;
	}

long LFCBAsyncThresholdPurgeCEFLPv( long iInstance, void* pvBuf )
	{
	cFCBAsyncThresholdPurge.PassTo( iInstance, pvBuf );
	return 0;
	}

long LFCBAsyncPurgeConflictCEFLPv( long iInstance, void* pvBuf )
	{
	cFCBAsyncPurgeConflict.PassTo( iInstance, pvBuf );
	return 0;
	}

long LFCBSyncPurgeCEFLPv( long iInstance, void* pvBuf )
	{
	cFCBSyncPurge.PassTo( iInstance, pvBuf );
	return 0;
	}

long LFCBSyncPurgeStallsCEFLPv( long iInstance, void* pvBuf )
	{
	cFCBSyncPurgeStalls.PassTo( iInstance, pvBuf );
	return 0;
	}

long LFCBAllocWaitForRCECleanCEFLPv( long iInstance, void* pvBuf )
	{
	cFCBAllocWaitForRCEClean.PassTo( iInstance, pvBuf );
	return 0;
	}

long LFCBCacheHitsCEFLPv( long iInstance, void* pvBuf )
	{
	cFCBCacheHits.PassTo( iInstance, pvBuf );
	return 0;
	}

long LFCBCacheRequestsCEFLPv( long iInstance, void* pvBuf )
	{
	cFCBCacheRequests.PassTo( iInstance, pvBuf );
	return 0;
	}

long LFCBCacheStallsCEFLPv( long iInstance, void* pvBuf )
	{
	cFCBCacheStalls.PassTo( iInstance, pvBuf );
	return 0;
	}

long LFCBCacheMaxCEFLPv( long iInstance, void* pvBuf )
	{
	if ( NULL != pvBuf && perfinstGlobal == iInstance )
		{
		*(LONG*)pvBuf = g_lOpenTablesMax*2;
		}
	else
		{
		cFCBCacheMax.PassTo( iInstance, pvBuf );
		}
	return 0;
	}

long LFCBCachePreferredCEFLPv( long iInstance, void* pvBuf )
	{
	if ( NULL != pvBuf && perfinstGlobal == iInstance )
		{
		*(LONG*)pvBuf = g_lOpenTablesPreferredMax*2;
		}
	else
		{
		cFCBCachePreferred.PassTo( iInstance, pvBuf );
		}
	return 0;
	}

long LFCBCacheAllocCEFLPv( long iInstance, void* pvBuf )
	{
	cFCBCacheAlloc.PassTo( iInstance, pvBuf );
	return 0;
	}

long LFCBCacheAllocAvailCEFLPv( long iInstance, void* pvBuf )
	{
	cFCBCacheAllocAvail.PassTo( iInstance, pvBuf );
	return 0;
	}



//	check parameters before calling FCB::ErrFCBInit

BOOL FCB::FCheckParams( const INST * const pinst )
	{
	if ( pinst->m_lOpenTablesMax < pinst->m_lOpenTablesPreferredMax )
		{
		CHAR			szCFCB[32];
		CHAR			szPreferred[32];
		const CHAR *	rgszT[2]			= { szCFCB, szPreferred };

		_itoa( pinst->m_lOpenTablesMax, szCFCB, 10 );
		_itoa( pinst->m_lOpenTablesPreferredMax, szPreferred, 10 );

		UtilReportEvent( eventError,
				SYSTEM_PARAMETER_CATEGORY,
				SYS_PARAM_CFCB_PREFER_ID, 
				2, 
				rgszT,
				0,
				NULL,
				pinst );
		return fFalse;
		}

	return fTrue;
	}


//	verifies that the FCB is in the correct avail list

#ifdef DEBUG
INLINE VOID FCB::AssertFCBAvailList_( const BOOL fPurging )
	{
	INST *pinst = PinstFromIfmp( Ifmp() );
	Assert( pinst->m_critFCBList.FOwner() );
	Assert( IsLocked() || fPurging );

	//	the FCB should be in both the avail-LRU list and the global list

	Assert( FInLRU() );

	//	we only allow table FCBs in the avail-LRU list
	
	Assert( FTypeTable() );

	//	get the list pointer

	FCB **ppfcbAvailMRU = pinst->PpfcbAvailMRU( FAboveThreshold() );
	FCB **ppfcbAvailLRU = pinst->PpfcbAvailLRU( FAboveThreshold() );

	//	verify the consistency of the list (it should not be empty)

	Assert( pinst->m_cFCBAvail > 0 );
	Assert( *ppfcbAvailMRU != pfcbNil );
	Assert( *ppfcbAvailLRU != pfcbNil );
	Assert( (*ppfcbAvailMRU)->PfcbMRU() == pfcbNil );
	Assert( (*ppfcbAvailLRU)->PfcbLRU() == pfcbNil );

	//	scan for the FCB

	FCB *pfcbThis = *ppfcbAvailMRU;
	while ( pfcbThis != pfcbNil )
		{
		if ( pfcbThis == this )
			break;
		pfcbThis = pfcbThis->PfcbLRU();
		}
	Assert( pfcbThis == this );
	}
#endif	//	DEBUG


//	initialize the FCB manager (per-instance initialization)

ERR FCB::ErrFCBInit( INST *pinst, INT cSession, INT cFCB, INT cTempTable, INT cFCBPreferredThreshold )
	{
	ERR				err;
	CRES 			*pcresTDBPool = NULL;
	CRES 			*pcresIDBPool = NULL;
	CRES 			*pcresFCBPool = NULL;
	BYTE			*rgbFCBHash;
	FCBHash::ERR 	errFCBHash;

	Assert( IbAlignForAllPlatforms( sizeof(TDB) ) == sizeof(TDB) );
	Assert( IbAlignForAllPlatforms( sizeof(IDB) ) == sizeof(IDB) );
	Assert( IbAlignForAllPlatforms( sizeof(FCB) ) == sizeof(FCB) );
#ifdef PCACHE_OPTIMIZATION
#ifdef _WIN64
	//	UNDONE: cache alignment for 64 bit build
#else
	Assert( sizeof(TDB) % 32 == 0 );
	Assert( sizeof(IDB) % 32 == 0 );
	Assert( sizeof(FCB) % 32 == 0 );
#endif
#endif

	//	init perf counters

	cFCBAsyncScan.Clear( pinst );
	cFCBAsyncPurge.Clear( pinst );
	cFCBAsyncThresholdScan.Clear( pinst );
	cFCBAsyncThresholdPurge.Clear( pinst );
	cFCBAsyncPurgeConflict.Clear( pinst );
	cFCBSyncPurge.Clear( pinst );
	cFCBSyncPurgeStalls.Clear( pinst );
	cFCBAllocWaitForRCEClean.Clear( pinst );
	cFCBCacheHits.Clear( pinst );
	cFCBCacheRequests.Clear( pinst );
	cFCBCacheStalls.Clear( pinst );
	cFCBCacheMax.Set( pinst, cFCB );
	cFCBCachePreferred.Set( pinst, cFCBPreferredThreshold );
	cFCBCacheAlloc.Clear( pinst );
	cFCBCacheAllocAvail.Clear( pinst );

	//	allocate memory pools for TDBs, IDBs, and FCBs

	pcresTDBPool = new CRES( pinst, residTDB, sizeof( TDB ), cFCB + cTempTable, &err );
	if ( NULL == pcresTDBPool && err >= 0 )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		}
	Call( err );

	pcresIDBPool = new CRES( pinst, residIDB, sizeof( IDB ), cFCB + cTempTable, &err );
	if ( NULL == pcresIDBPool && err >= 0 )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		}
	Call( err );

	pcresFCBPool = new CRES( pinst, residFCB, sizeof( FCB ), cFCB, &err );
	if ( NULL == pcresFCBPool && err >= 0 )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		}
	Call( err );

	rgbFCBHash = (BYTE*)PvOSMemoryHeapAllocAlign( sizeof( FCBHash ), cbCacheLine );
	if ( NULL == rgbFCBHash  )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		}
	Call( err );
	pinst->m_pfcbhash = new( rgbFCBHash ) FCBHash( rankFCBHash );

	//	setup the preferred limit on TDBs, IDBs, and FCBs

	if ( cFCBPreferredThreshold == 0 )
		{

		//	no preferred limit
		
		cFCBPreferredThreshold = cFCB;
		}

	if ( cFCBPreferredThreshold < cFCB )
		{
		pcresTDBPool->SetPreferredThreshold( cFCBPreferredThreshold );
		pcresIDBPool->SetPreferredThreshold( cFCBPreferredThreshold );
		pcresFCBPool->SetPreferredThreshold( cFCBPreferredThreshold );
		}

	Assert( pfcbNil == (FCB *)0 );
	Assert( pinst->m_pfcbList == pfcbNil );
	Assert( pinst->m_pfcbAvailBelowMRU == pfcbNil );
	Assert( pinst->m_pfcbAvailBelowLRU == pfcbNil );
	Assert( pinst->m_pfcbAvailAboveMRU == pfcbNil );
	Assert( pinst->m_pfcbAvailAboveLRU == pfcbNil );
	pinst->m_cFCBAvail = 0;

	pinst->m_pcresTDBPool = pcresTDBPool;
	pinst->m_pcresIDBPool = pcresIDBPool;
	pinst->m_pcresFCBPool = pcresFCBPool;
	pinst->m_cFCBPreferredThreshold = cFCBPreferredThreshold;
	pinst->m_cFCBAboveThresholdSinceLastPurge = 0;

	//	initialize the FCB hash-table
	//		5.0 entries/bucket (average)
	//		uniformity ==> 1.0 (perfectly uniform)

	errFCBHash = pinst->m_pfcbhash->ErrInit( 5.0, 1.0 );
	if ( errFCBHash != FCBHash::errSuccess )
		{
		Assert( errFCBHash == FCBHash::errOutOfMemory );
		CallJ( ErrERRCheck( JET_errOutOfMemory ), FreeFCBHash );
		}

	return err;

FreeFCBHash:
	pinst->m_pfcbhash->Term();
	pinst->m_pfcbhash->FCBHash::~FCBHash();
	OSMemoryHeapFreeAlign( pinst->m_pfcbhash );
	pinst->m_pfcbhash = NULL;
	
HandleError:
	delete pcresFCBPool;
	delete pcresIDBPool;
	delete pcresTDBPool;

	return err;
	}


//	term the FCB manager (per-instance termination)

VOID FCB::Term( INST *pinst )
	{
	cFCBAsyncScan.Clear( pinst );
	cFCBAsyncPurge.Clear( pinst );
	cFCBAsyncThresholdScan.Clear( pinst );
	cFCBAsyncThresholdPurge.Clear( pinst );
	cFCBAsyncPurgeConflict.Clear( pinst );
	cFCBSyncPurge.Clear( pinst );
	cFCBSyncPurgeStalls.Clear( pinst );
	cFCBAllocWaitForRCEClean.Clear( pinst );
	cFCBCacheHits.Clear( pinst );
	cFCBCacheRequests.Clear( pinst );
	cFCBCacheStalls.Clear( pinst );
	cFCBCacheMax.Clear( pinst );
	cFCBCachePreferred.Clear( pinst );
	cFCBCacheAlloc.Clear( pinst );
	cFCBCacheAllocAvail.Clear( pinst );

	pinst->m_pfcbList = pfcbNil;
	pinst->m_pfcbAvailBelowMRU = pfcbNil;
	pinst->m_pfcbAvailBelowLRU = pfcbNil;
	pinst->m_pfcbAvailAboveMRU = pfcbNil;
	pinst->m_pfcbAvailAboveLRU = pfcbNil;

	if ( pinst->m_pfcbhash )
		{
		pinst->m_pfcbhash->Term();
		pinst->m_pfcbhash->FCBHash::~FCBHash();
		OSMemoryHeapFreeAlign( pinst->m_pfcbhash );
		pinst->m_pfcbhash = NULL;
		}

	delete pinst->m_pcresFCBPool;
	delete pinst->m_pcresIDBPool;
	delete pinst->m_pcresTDBPool;
	}


//	allocate an FCB from the memory pool

#define PfcbFCBAlloc( pinst ) reinterpret_cast<FCB*>( pinst->m_pcresFCBPool->PbAlloc( __FILE__, __LINE__ ) )

//	free an FCB back to the memory pool

INLINE VOID FCBReleasePfcb( INST *pinst, FCB *pfcb )
	{
	pinst->m_pcresFCBPool->Release( (BYTE *)pfcb );
	}


BOOL FCB::FValid( INST *pinst ) const
	{
	return ( this >= PfcbFCBMin( pinst )
		&& this < PfcbFCBMax( pinst )
		&& 0 == ( ( (BYTE *)this - (BYTE *)PfcbFCBMin( pinst ) ) % sizeof(FCB) ) );
	}


VOID FCB::UnlinkIDB( FCB *pfcbTable )
	{
	Assert( pfcbNil != pfcbTable );
	Assert( ptdbNil != pfcbTable->Ptdb() );
	Assert( pfcbTable->FPrimaryIndex() );

	pfcbTable->AssertDDL();
	
	// If index and table FCB's are the same, then it's the primary index FCB.
	if ( pfcbTable == this )
		{
		Assert( !pfcbTable->FSequentialIndex() );
		}
	else
		{
		// Temp/sort tables don't have secondary indexes
		Assert( pfcbTable->FTypeTable() );
		
		// Only way IDB could have been linked in is if already set FCB type.
		Assert( FTypeSecondaryIndex() );
		}
		
	IDB	*pidb = Pidb();
	Assert( pidbNil != pidb );

	Assert( !pidb->FTemplateIndex() );
	Assert( !pidb->FDerivedIndex() );

	// Wait for lazy version checkers.  Verify flags set to Deleted and non-Versioned
	// to prevent future version checkers while we're waiting for the lazy ones to finish.
	Assert( pidb->FDeleted() );
	Assert( !pidb->FVersioned() );
	while ( pidb->CrefVersionCheck() > 0 )
		{
		// Since we reset the Versioned flag, there should be no further
		// version checks on this IDB.
		pfcbTable->LeaveDDL();
		UtilSleep( cmsecWaitGeneric );
		pfcbTable->EnterDDL();
		
		Assert( pidb == Pidb() );		// Verify pointer.
		}
		
	// Free index name and idxseg array, if any.
	if ( pidb->ItagIndexName() != 0 )
		{
		pfcbTable->Ptdb()->MemPool().DeleteEntry( pidb->ItagIndexName() );
		}
	if ( pidb->FIsRgidxsegInMempool() )
		{
		Assert( pidb->ItagRgidxseg() != 0 );
		pfcbTable->Ptdb()->MemPool().DeleteEntry( pidb->ItagRgidxseg() );
		}
	if ( pidb->FIsRgidxsegConditionalInMempool() )
		{
		Assert( pidb->ItagRgidxsegConditional() != 0 );
		pfcbTable->Ptdb()->MemPool().DeleteEntry( pidb->ItagRgidxsegConditional() );
		}

	ReleasePidb();
	}


//	lookup an FCB by ifmp/pgnoFDP using the FCB hash-table and pin it by
//		adding 1 to the refcnt
//
//	returns pfcbNil if the FCB does not exist (or exists but is not visible)
//
//	for FCBs that are being initialized but are not finished, this code will
//		retry repeatedly until the initialization finished with success or
//		an error-code
//
//	for FCBs that failed to initialize, they are left in place until they
//		can be purged and recycled
//
//	NOTE: this is the proper channel for accessing an FCB; it uses the locking
//		protocol setup by the FCB hash-table and FCB latch

FCB *FCB::PfcbFCBGet( IFMP ifmp, PGNO pgnoFDP, INT *pfState, const BOOL fIncrementRefCount )
	{
	INT				fState = fFCBStateNull;
	INST			*pinst = PinstFromIfmp( ifmp );
	FCB				*pfcbT;
	BOOL			fDoIncRefCount = fFalse;
	FCBHash::ERR	errFCBHash;
	FCBHash::CLock	lockFCBHash;
	FCBHashKey		keyFCBHash( ifmp, pgnoFDP );
	FCBHashEntry	entryFCBHash;
	CSXWLatch::ERR	errSXWLatch;

RetrieveFCB:

	//	lock the hash table

	pinst->m_pfcbhash->ReadLockKey( keyFCBHash, &lockFCBHash );

	//	update performance counter

	cFCBCacheRequests.Inc( pinst );

	//	try to retrieve the entry

	errFCBHash = pinst->m_pfcbhash->ErrRetrieveEntry( &lockFCBHash, &entryFCBHash );
	if ( errFCBHash == FCBHash::errSuccess )
		{

		//	update performance counter

		cFCBCacheHits.Inc( pinst );

		//	the entry exists

		Assert( entryFCBHash.m_pgnoFDP == pgnoFDP );
		pfcbT = entryFCBHash.m_pfcb;
		Assert( pfcbNil != pfcbT );
		
		//	we must declare ourselves as an owner/waiter on the exclusive latch
		//		to prevent the FCB from randomly disappearing (via the purge code)

		errSXWLatch = pfcbT->m_sxwl.ErrAcquireExclusiveLatch();
		}

	//	unlock the hash table

	pinst->m_pfcbhash->ReadUnlockKey( &lockFCBHash );

	if ( errFCBHash != FCBHash::errSuccess )
		{

		//	set the state

		if ( pfState )
			{
			*pfState = fState;
			}

		return pfcbNil;
		}

	if ( errSXWLatch == CSXWLatch::errWaitForExclusiveLatch )
		{

		//	wait to acquire the exclusive latch
		
		pfcbT->m_sxwl.WaitForExclusiveLatch();
		}

	//	we now have the FCB pinned via the latch

	if ( pfcbT->FInitialized() )
		{

		//	FCB is initialized

		CallS( pfcbT->ErrErrInit() );
		Assert( pfcbT->Ifmp() == ifmp );
		Assert( pfcbT->PgnoFDP() == pgnoFDP );

		if ( !fIncrementRefCount )
			{

			//	there is no state when "checking" the presence of the FCB
			
			Assert( pfState == NULL );
			}
		else if ( dbidTemp == rgfmp[ ifmp ].Dbid() || !pfcbT->FTypeSentinel() )
			{			
			fState = fFCBStateInitialized;

			//	increment the reference count
			
			fDoIncRefCount = fTrue;
			}
		else
			{

			//	sentinel FCBs do not get refcounted
			//	this avoids us blocking whoever created it from
			//		deleting it later

			fState = fFCBStateSentinel;
			}
		}
	else
		{

		//	the FCB is not initialized meaning it is either being 
		//		initialized now or failed somewhere in the middle
		//		of initialization

		Assert( !pinst->m_plog->m_fRecovering );

		const ERR	errInit		= pfcbT->ErrErrInit();

		//	release exclusive latch
		pfcbT->m_sxwl.ReleaseExclusiveLatch();

		if ( JET_errSuccess != errInit )
			{

			//	FCB init failed with an error code

			Assert( errInit < JET_errSuccess );
			pfcbT = pfcbNil;
			}
		else
			{

			//	FCB is not finished initializing

			//	update performance counter

			cFCBCacheStalls.Inc( pinst );

			//	wait

			UtilSleep( 10 );

			//	try to get the FCB again

			goto RetrieveFCB;
			}
		}

	if ( pfcbT != pfcbNil )
		{
		//	we found the FCB and have it locked exclusively 
		
		Assert( pfcbT->m_sxwl.FNotOwnSharedLatch() );
		Assert( pfcbT->m_sxwl.FOwnExclusiveLatch() );
		Assert( pfcbT->m_sxwl.FNotOwnWriteLatch() );

		//	increment refcount if necessary
		const BOOL	fMoveFromAvailList	= ( fDoIncRefCount ?
												pfcbT->FIncrementRefCount_() :
												fFalse );

		//	unlock the FCB
		pfcbT->m_sxwl.ReleaseExclusiveLatch();

		if ( fMoveFromAvailList )
			{
			pfcbT->MoveFromAvailList_();
			}
		}

	//	set the state

	if ( pfState )
		{
		*pfState = fState;	
		}

	//	return the FCB

	return pfcbT;
	}


//	create a new FCB
//
//	this function allocates an FCB from CRES and possibly recycles unused
//		FCBs to CRES for later use
//	once an FCB is allocated, this code uses the proper locking protocls to
//		insert it into the hash-table; no one will be able to look it up
//		until the initialization is completed successfully or with an error
//
//	WARNING: we leave this function holding the FCB lock (IsLocked() == fTrue);
//			 this is so the caller can perform further initialization before 
//			     anyone else can touch the FCB including PfcbFCBGet (this is 
//				 not currently used for anything except some Assert()s even 
//				 though it could be)

ERR FCB::ErrCreate( PIB *ppib, IFMP ifmp, PGNO pgnoFDP, FCB **ppfcb )
	{
	ERR		err;
	INST	*pinst = PinstFromPpib( ppib );

	//	prepare output

	*ppfcb = pfcbNil;

	//	acquire the creation mutex (used critical section for deadlock-detect info)

	pinst->m_critFCBCreate.Enter();

	if ( !FInHashTable( ifmp, pgnoFDP ) )
		{

		//	the entry does not yet exist, so we are guaranteed
		//		to be the first user to create this FCB

		//	try to allocate a new FCB
	
		err = ErrAlloc_( ppib, ppfcb );
		CallSx( err, JET_errTooManyOpenTables );

		if ( JET_errTooManyOpenTables == err )
			{
			//	signal version cleanup to try to free some FCB's
			//
			VERSignalCleanup( ppib );

			pinst->m_critFCBCreate.Leave();

			//	ensure RCE clean was performed recently (if our wait times out, it
			//	means something is horribly wrong and blocking version cleanup)
			//
			const BOOL	fCleanupWasRun		= PverFromPpib( ppib )->m_msigRCECleanPerformedRecently.FWait( cmsecAsyncBackgroundCleanup );

			cFCBAllocWaitForRCEClean.Inc( pinst );

			pinst->m_critFCBCreate.Enter();

			//	retry if no one else beat us to it
			//
			if ( !FInHashTable( ifmp, pgnoFDP ) )
				{
				err = ErrAlloc_( ppib, ppfcb );
				CallSx( err, JET_errTooManyOpenTables );
				if ( JET_errTooManyOpenTables == err && !fCleanupWasRun )
					{
					err = ErrERRCheck( JET_errTooManyOpenTablesAndCleanupTimedOut );
					}
				}
			else
				{
				//	someone beat us to it
				//
				err = ErrERRCheck( errFCBExists );
				}
			}

		if ( err >= JET_errSuccess )
			{
			Assert( *ppfcb != pfcbNil );
			
			FCBHash::ERR	errFCBHash;
			FCBHash::CLock	lockFCBHash;
			FCBHashKey		keyFCBHash( ifmp, pgnoFDP );
			FCBHashEntry	entryFCBHash( pgnoFDP, *ppfcb );

			//	lock the hash-table

			pinst->m_pfcbhash->WriteLockKey( keyFCBHash, &lockFCBHash );

			//	try to insert the entry

			errFCBHash = pinst->m_pfcbhash->ErrInsertEntry( &lockFCBHash, entryFCBHash );
			if ( errFCBHash == FCBHash::errSuccess )
				{

				//	the FCB is now in the hash table

				//	construct the FCB

				new( *ppfcb ) FCB( ifmp, pgnoFDP );

				//	verify the FCB

				Assert( pgnoNull == (*ppfcb)->PgnoNextAvailSE() );
				Assert( NULL == (*ppfcb)->Psplitbufdangling_() );
				Assert( (*ppfcb)->PrceOldest() == prceNil );
				
				//	set the threshold position

				Assert( !(*ppfcb)->FAboveThreshold() );
				if ( *ppfcb >= PfcbFCBPreferredThreshold( pinst ) )
					{
					(*ppfcb)->SetAboveThreshold();
					}

				Assert( (*ppfcb)->IsUnlocked() );
				if ( (*ppfcb)->FNeedLock_() )
					{

					//	declare ourselves as an owner/waiter on the exclusive latch
					//	we should immediately become the owner since we just
					//		constructed this latch AND since we are the only ones
					//		with access to it

					CSXWLatch::ERR errSXWLatch = (*ppfcb)->m_sxwl.ErrAcquireExclusiveLatch();
					Assert( errSXWLatch == CSXWLatch::errSuccess );
					}
				Assert( (*ppfcb)->IsLocked() );

				err = JET_errSuccess;
				}
			else
				{

				//	we were unable to insert the FCB into the hash table

				Assert( errFCBHash == FCBHash::errOutOfMemory );

				//	release the FCB

				FCBReleasePfcb( pinst, *ppfcb );
				*ppfcb = pfcbNil;

				//	update performance counter

				cFCBCacheAlloc.Dec( pinst );

				//	NOTE: we should never get errKeyDuplicate because only 1 person
				//		  can create FCBs at a time (that's us right now), and we
				//		  made sure that the entry did not exist when we started!

				err = ErrERRCheck( JET_errOutOfMemory );
				}

			//	unlock the hash table

			pinst->m_pfcbhash->WriteUnlockKey( &lockFCBHash );
			}
		}
	else
		{

		//	the FCB was already in the hash-table

		err = ErrERRCheck( errFCBExists );
		}

	//	unlock the creation mutex

	pinst->m_critFCBCreate.Leave();

	Assert( ( err >= JET_errSuccess && *ppfcb != pfcbNil ) ||
			( err < JET_errSuccess && *ppfcb == pfcbNil ) );
		
	return err;
	}
	

//	finish the FCB creation process by assigning an error code to the FCB
//		and setting/resetting the FInitialized flag
//
//	if the FCB is completing with error, it will be !FInitialized() and
//		the error-code will be stored in the FCB; this signals PfcbFCBGet
//		that the FCB is not "visible" even though it exists

VOID FCB::CreateComplete( ERR err )
	{
	CallSx( err, errFCBUnusable );

	//	set the initialization result

	SetErrInit( err );

	if ( JET_errSuccess == err )
		{
		Assert( !FInitialized() );

		//	initialization succeeded

		SetInitialized_();
		}
	else
		{
		//	initializtion failed

		ResetInitialized_();
		}
	}


//	allocate an FCB for FCB::ErrCreate
//
//	when an above-threshold FCB is allocated,
//		this code cycles through the avail-LRU list starts purging FCBs
//		that are available (there are 2 version of this purge loop: the 
//		purge-one-FCB version and the purge-as-many-as-possible version;
//		the latter only gets called once in a great while)

ERR FCB::ErrAlloc_( PIB *ppib, FCB **ppfcb )
	{
	FCB		*pfcbCandidate;
	FCB		*pfcbAboveThreshold = pfcbNil;
	INST	*pinst = PinstFromPpib( ppib );

	Assert( pinst->m_critFCBCreate.FOwner() );

	//	try to allocate an entry from the CRES pool of FCBs

	pfcbCandidate = PfcbFCBAlloc( pinst );
	if ( pfcbNil != pfcbCandidate )
		{
		Assert( FAlignedForAllPlatforms( pfcbCandidate ) );
		
		//	update performance counter

		cFCBCacheAlloc.Inc( pinst );
		
		if ( pfcbCandidate >= PfcbFCBPreferredThreshold( pinst ) )
			{

			//	the FCB we allocated from CRES is above the preferred threshold

			//	ideally, we want an FCB below the threshold; to get one, we try
			//		to recycle existing FCBs and hope that this recycling process 
			//		will release an FCB below the threshold

			Assert( PfcbFCBPreferredThreshold( pinst ) < PfcbFCBMax( pinst ) );
			pfcbAboveThreshold = pfcbCandidate;
			
			//	we are allowed re-use existing FCBs so that we may find one
			//		below the threshold; fall through to that code below

			//	mark the fact that we allocated an above-threshold FCB
			
			pinst->m_cFCBAboveThresholdSinceLastPurge++;
			}
		else
			{

			//	we got an FCB and it is below the threshold
			
			goto InitFCB;
			}
		}

	//	we were unable to get an FCB below the threshold
	//		(we may have one above the threshold)

	//	try to re-use existing FCBs

	if ( PfcbFCBPreferredThreshold( pinst ) < PfcbFCBMax( pinst ) &&
		 pinst->m_cFCBAboveThresholdSinceLastPurge > cFCBPurgeAboveThresholdInterval )
		{
		FCB *pfcbNextMRU;

		//	we have allocated a lot of FCBs above the preferred threshold 
		//		and need to recycle them to reduce the working-set size

		//	we will cycle through the avail-above list and free as many FCBs 
		//		as we can
		//	we will then free one FCB from the avail-below list

		//	reset the number of allocated FCBs

		pinst->m_cFCBAboveThresholdSinceLastPurge = 0;

		//	lock the FCB list

		pinst->m_critFCBList.Enter();

		//	examine each FCB in the avail-above and try to free it
	
		for ( pfcbCandidate = *( pinst->PpfcbAvailLRU( fTrue ) ); 
			  pfcbCandidate != pfcbNil; 
			  pfcbCandidate = pfcbNextMRU )
			{
			Assert( pfcbCandidate->FInLRU() );

			//	trap for bug x5:100491
			AssertRTL( pfcbCandidate->FTypeTable() );
			
			//	update performance counter
			
			cFCBAsyncThresholdScan.Inc( pinst );
			
			//	read the ptr to the next FCB now
			//	if we release the current FCB, this ptr will be destroyed

			pfcbNextMRU = pfcbCandidate->PfcbMRU();

			if ( pfcbCandidate->FCheckFreeAndTryToLockForPurge_( ppib ) )
				{
				Assert( pfcbCandidate->FTypeTable() );
				Assert( pfcbCandidate->FAboveThreshold() );
				Assert( FAlignedForAllPlatforms( pfcbCandidate ) );

				//	the FCB is available; release it

				pfcbCandidate->Purge( fFalse );

				//	update performance counter

				cFCBAsyncThresholdPurge.Inc( pinst );
				}
			}

		//	release the first available FCB in the avail-below list

		for ( pfcbCandidate = *( pinst->PpfcbAvailLRU( fFalse ) );
			  pfcbCandidate != pfcbNil;
			  pfcbCandidate = pfcbCandidate->PfcbMRU() )
			{
			Assert( pfcbCandidate->FInLRU() );

			//	trap for bug x5:100491
			AssertRTL( pfcbCandidate->FTypeTable() );

			//	update performance counter
			
			cFCBAsyncThresholdScan.Inc( pinst );

			if ( pfcbCandidate->FCheckFreeAndTryToLockForPurge_( ppib ) )
				{
				Assert( pfcbCandidate->FTypeTable() );
				Assert( !pfcbCandidate->FAboveThreshold() );
				Assert( FAlignedForAllPlatforms( pfcbCandidate ) );

				//	the FCB is available; release it

				pfcbCandidate->Purge( fFalse );

				//	update performance counter
			
				cFCBAsyncThresholdPurge.Inc( pinst );

				//	stop after releasing one below-threshold FCB

				break;
				}
			}
	
		//	unlock the list

		pinst->m_critFCBList.Leave();
		}
	else
		{

		//	we have not allocated very many FCBs above the preferred 
		//		threshold (OR there is no preferred threshold at all)

		//	lock the list

		pinst->m_critFCBList.Enter();

		//	scan for the first available LRU FCB we can find

		//	start scanning the avail-above list
		
		for ( pfcbCandidate = *( pinst->PpfcbAvailLRU( fTrue ) );
			  pfcbCandidate != pfcbNil;
			  pfcbCandidate = pfcbCandidate->PfcbMRU() )
			{
			Assert( pfcbCandidate->FInLRU() );

			//	trap for bug x5:100491
			AssertRTL( pfcbCandidate->FTypeTable() );

			//	update performance counter
			
			cFCBAsyncScan.Inc( pinst );

			if ( pfcbCandidate->FCheckFreeAndTryToLockForPurge_( ppib ) )
				{
				Assert( pfcbCandidate->FTypeTable() );
				Assert( pfcbCandidate->FAboveThreshold() );
				Assert( FAlignedForAllPlatforms( pfcbCandidate ) );

				//	the FCB is available; release it

				pfcbCandidate->Purge( fFalse );

				//	update performance counter
			
				cFCBAsyncPurge.Inc( pinst );

				//	stop after releasing one FCB

				goto GotOneFCB;
				}
			}

		//	we did not find an available FCB in the above-avail LRU list
		//	we must now look in the below-avail LRU list

		for ( pfcbCandidate = *( pinst->PpfcbAvailLRU( fFalse ) );
			  pfcbCandidate != pfcbNil;
			  pfcbCandidate = pfcbCandidate->PfcbMRU() )
			{
			Assert( pfcbCandidate->FInLRU() );

			//	trap for bug x5:100491
			AssertRTL( pfcbCandidate->FTypeTable() );

			//	update performance counter
			
			cFCBAsyncScan.Inc( pinst );
			
			if ( pfcbCandidate->FCheckFreeAndTryToLockForPurge_( ppib ) )
				{
				Assert( pfcbCandidate->FTypeTable() );
				Assert( !pfcbCandidate->FAboveThreshold() );
				Assert( FAlignedForAllPlatforms( pfcbCandidate ) );

				//	the FCB is available; release it

				pfcbCandidate->Purge( fFalse );

				//	update performance counter
			
				cFCBAsyncPurge.Inc( pinst );

				//	stop after releasing one FCB

				break;
				}
			}

GotOneFCB:

		//	unlock the list

		pinst->m_critFCBList.Leave();
		}

	//	try to allocate an FCB from CRES again

	pfcbCandidate = PfcbFCBAlloc( pinst );
	if ( pfcbCandidate != pfcbNil )
		{
		Assert( FAlignedForAllPlatforms( pfcbCandidate ) );

		//	update performance counter

		cFCBCacheAlloc.Inc( pinst );

		//	we got an FCB from CRES (either via version cleanup
		//		or via our re-use code)

		if ( pfcbAboveThreshold != pfcbNil )
			{

			//	we had an FCB from before, so we need to free 
			//		one of them now; free the one that is closest
			//		to the threshold

			if ( pfcbCandidate < pfcbAboveThreshold )
				{
				FCBReleasePfcb( pinst, pfcbAboveThreshold );

				//	update performance counter

				cFCBCacheAlloc.Dec( pinst );
				}
			else
				{
				FCBReleasePfcb( pinst, pfcbCandidate );

				//	update performance counter

				cFCBCacheAlloc.Dec( pinst );
				
				pfcbCandidate = pfcbAboveThreshold;
				}
			}
		}
	else if ( pfcbAboveThreshold != pfcbNil )
		{

		//	we did not get an FCB from CRES, but we had an FCB
		//		which we allocated at the start of this function

		pfcbCandidate = pfcbAboveThreshold;
		}
	else
		{

		//	we were not able to allocate any FCBs

		//	UNDONE: synchronous version-cleanup here? 
		//			OR, set a signal to start version-cleanup?

		return ErrERRCheck( JET_errTooManyOpenTables );
		}

InitFCB:	

	//	initialize the FCB
	
	FCBInitFCB( pfcbCandidate );

	//	return a ptr to the FCB

	*ppfcb = pfcbCandidate;
	
	return JET_errSuccess;
	}


//	used by ErrAlloc_ to passively check an FCB to see if it can be recycled
//
//	this will only block on the hash-table -- and since hash-table locks
//		are brief, it shouldn't block too long; locking the FCB itself
//		will not block because we only "Try" the lock
//	
//	if the FCB is available and we were able to lock it, we remove it from 
//		the hash-table (making it completely invisible); then, ErrAlloc_
//		will purge the FCB
//
//	HOW IT BECOMES COMPLETELY INVISIBLE:
//		we locked the hash-table meaning no one could hash to the FCB
//		it also means that anyone else hashing to the FCB has already
//			declared themselves as an owner/waiter on the FCB lock
//		we then TRIED locked the FCB itself
//		since we got that lock without blocking, it means no one else was
//			an owner/waiter on the FCB lock meaning no one else was looking
//			at the FCB
//		thus, if the FCB has refcnt == 0, and no outstanding versions, and
//			etc... (everything that makes it free), we can purge the FCB

BOOL FCB::FCheckFreeAndTryToLockForPurge_( PIB *ppib )
	{
	INST			*pinst = PinstFromPpib( ppib );

	Assert( pinst->m_critFCBList.FOwner() );
	Assert( FInLRU() );

	FCBHash::ERR	errFCBHash;
	FCBHash::CLock	lockFCBHash;
	FCBHashKey		keyFCBHash( Ifmp(), PgnoFDP() );
	CSXWLatch::ERR	errSXWLatch;
	BOOL			fAvail = fFalse;

	//	lock the hash table to protect the SXW latch

	pinst->m_pfcbhash->WriteLockKey( keyFCBHash, &lockFCBHash );

	//	try to acquire a write latch on the FCB

	errSXWLatch = m_sxwl.ErrTryAcquireWriteLatch();
	if ( errSXWLatch == CSXWLatch::errSuccess )
		{

		//	we have the write latch meaning there were no owners/waiters
		//		on the shared or the exclusive latch
		//	if the FCB is free, we can delete it from the hash-table and 
		//		know that no one will be touching the it

#ifdef DEBUG
		BOOL	fAbove = fFalse;
#endif	//	DEBUG

		//	check the condition of this FCB

		if ( WRefCount() == 0 &&
			 PgnoFDP() != pgnoSystemRoot &&
			 !FTypeSentinel() &&			//	sentinel FCBs are freed by RCEClean
			 !FDeletePending() &&			//	FCB with pending "delete-table" is freed by RCEClean
			 !FTemplateTable() &&
			 !FDomainDenyRead( ppib ) &&
			 !FOutstandingVersions_() &&
			 0 == CTasksActive() &&
			 !FHasCallbacks_( pinst ) )
			{
			FCB	*pfcbIndex;

			//	check each secondary-index FCB

			for ( pfcbIndex = this; pfcbIndex != pfcbNil; pfcbIndex = pfcbIndex->PfcbNextIndex() )
				{
				if ( pfcbIndex->Pidb() != pidbNil )
					{
					// Since there is no cursor on the table,
					// no one should be doing a version check on the index
					// or setting a current secondary index.
					Assert( pfcbIndex->Pidb()->CrefVersionCheck() == 0 );
					Assert( pfcbIndex->Pidb()->CrefCurrentIndex() == 0 );
					}

				//	should never get the case where there are no table cursors and
				//	no outstanding versions on the secondary index, but there is
				//	an outstanding cursor on the secondary index
				//	UNDONE: How to check for this?
				if ( pfcbIndex->FOutstandingVersions_()
					|| pfcbIndex->CTasksActive() > 0
					|| pfcbIndex->WRefCount() > 0 )
					{
					break;
					}

#ifdef DEBUG
				if ( pfcbIndex >= PfcbFCBPreferredThreshold( pinst ) )
					fAbove = fTrue;
#endif	//	DEBUG				
				}

			//	check the LV-tree FCB

			if ( pinst->m_plog->m_fRecovering && Ptdb() == ptdbNil )
				{
				Assert( pfcbNil == pfcbIndex );
				fAvail = fTrue;
				}
			else if ( pfcbNil == pfcbIndex )
				{
				Assert( Ptdb() != ptdbNil );
				FCB	*pfcbLV = Ptdb()->PfcbLV();
				if ( pfcbNil == pfcbLV )
					{
					fAvail = fTrue;
					}
				else if ( pfcbLV->FOutstandingVersions_()
					|| pfcbLV->CTasksActive() > 0
					|| pfcbLV->WRefCount() > 0 )
					{
					//	should never get the case where there are no table cursors and
					//	no outstanding versions on the LV tree, but there is an
					//	outstanding cursor on the LV tree
					//	UNDONE: How to check for this?
					}
				else
					{
					fAvail = fTrue;
#ifdef DEBUG
					if ( pfcbLV >= PfcbFCBPreferredThreshold( pinst ) )
						fAbove = fTrue;
#endif	//	DEBUG
					}
				}

			//	verify the threshold position

			Assert( FAboveThreshold() == fAbove );
			}

		if ( fAvail )
			{
			FCB *pfcbT;

			//	the FCB is ready to be purged

			//	delete the FCB from the hash table

			errFCBHash = pinst->m_pfcbhash->ErrDeleteEntry( &lockFCBHash );

			//	FCB must be in the hash table unless FDeleteCommitted is set
			
			Assert( errFCBHash == FCBHash::errSuccess || 
					( errFCBHash == FCBHash::errNoCurrentEntry && FDeleteCommitted() ) );

			//	mark all children as uninitialized so no one can hash to them
			//
			//	this will prevent the following concurrency hole:
			//		thread 1: table A is being pitched
			//		thread 1: table A's table-FCB is removed from the hash-table
			//		thread 2: table A gets reloaded from disk
			//		thread 2: when loading table A's secondary index FCBs, we see
			//				  that they alrady exist (not yet purged by thread 1)
			//				  and try to link to them even though thread 1 will
			//				  soon be purging them
			//	NOTE: since we have the table-FCB all to ourselves, no one else
			//		  should be trying to load the table or touch any of its
			//		  children FCBs -- thus, we do not need to lock them!

			pfcbT = PfcbNextIndex();
			while ( pfcbT != pfcbNil )
				{
				Assert( 0 == pfcbT->WRefCount() );
				pfcbT->CreateComplete( errFCBUnusable );
				pfcbT = pfcbT->PfcbNextIndex();
				}
			if ( Ptdb() )
				{
				if ( Ptdb()->PfcbLV() )
					{
					Assert( 0 == Ptdb()->PfcbLV()->WRefCount() );
					Ptdb()->PfcbLV()->CreateComplete( errFCBUnusable );
					}
				}
			}

		if ( errSXWLatch == CSXWLatch::errSuccess )
			{

			//	release the write latch

			m_sxwl.ReleaseWriteLatch();
			}
		}
	else
		{

		//	update performance counter

		cFCBAsyncPurgeConflict.Inc( pinst );
		}

	//	unlock hash table

	pinst->m_pfcbhash->WriteUnlockKey( &lockFCBHash );

	if ( fAvail )
		{
		FCB	*pfcbT;

		//	prepare the children of this FCB for purge
		//	NOTE: no one will be touching them because we have marked them
		//		  all as being uninitialized due to an error

		pfcbT = PfcbNextIndex();
		while ( pfcbT != pfcbNil )
			{
			Assert( !pfcbT->FInitialized() );
			Assert( errFCBUnusable == pfcbT->ErrErrInit() );
			pfcbT->PrepareForPurge( fFalse );
			pfcbT = pfcbT->PfcbNextIndex();
			}
		if ( Ptdb() )
			{
			if ( Ptdb()->PfcbLV() )
				{
				Assert( !Ptdb()->PfcbLV()->FInitialized() );
				Assert( errFCBUnusable == Ptdb()->PfcbLV()->ErrErrInit() );
				Ptdb()->PfcbLV()->PrepareForPurge( fFalse );
				}

			//	remove the entry for this table from the catalog hash
			//	NOTE: there is the possibility that after this FCB is removed from the FCB hash
			//		    someone could get to its pgno/objid from the catalog hash; this is ok
			//		    because the pgno/objid are still valid (they will be until the space
			//			they occupy is released to the space-tree)

			if ( FCATHashActive( pinst ) )
				{
				CHAR szTable[JET_cbNameMost+1];

				//	catalog hash is active so we can delete the entry 

				//	read the table name

				EnterDML();
				strcpy( szTable, Ptdb()->SzTableName() );
				LeaveDML();

				//	delete the hash-table entry

				CATHashIDelete( this, szTable );
				}
			}
		}

	return fAvail;
	}


//	remove all RCEs and close all cursors on this FCB

INLINE VOID FCB::CloseAllCursorsOnFCB_( const BOOL fTerminating )
	{
	if ( fTerminating )
		{
		//	version-clean was already attempted as part of shutdown
		//	ignore any outstanding versions and continue

		m_prceNewest = prceNil;
		m_prceOldest = prceNil;
		}

	Assert( PrceNewest() == prceNil );
	Assert( PrceOldest() == prceNil );

	//	close all cursors on this FCB
		
	FUCBCloseAllCursorsOnFCB( ppibNil, this );
	}


//	close all cursors on this FCB and its children FCBs

VOID FCB::CloseAllCursors( const BOOL fTerminating )
	{
#ifdef DEBUG	
	if ( FTypeDatabase() )
		{
		Assert( PgnoFDP() == pgnoSystemRoot );
		Assert( Ptdb() == ptdbNil );
		Assert( PfcbNextIndex() == pfcbNil );
		}
	else if ( FTypeTable() )
		{
		Assert( PgnoFDP() > pgnoSystemRoot );
		if ( Ptdb() == ptdbNil )
			{
			LOG *plog = PinstFromIfmp( Ifmp() )->m_plog;
			Assert( plog->m_fRecovering
				|| ( fTerminating && plog->m_fHardRestore ) );
			}
		}
	else if ( FTypeSentinel() )
		{
		Assert( PgnoFDP() > pgnoSystemRoot );
		Assert( Ptdb() == ptdbNil );
		Assert( PfcbNextIndex() == pfcbNil );
		}
	else if ( FTypeTemporaryTable() )
		{
		Assert( PgnoFDP() > pgnoSystemRoot );
		Assert( Ptdb() != ptdbNil );
		Assert( PfcbNextIndex() == pfcbNil );
		}
	else
		{
		Assert( FTypeSLVAvail() || FTypeSLVOwnerMap() );
		Assert( ptdbNil == Ptdb() );
		Assert( pfcbNil == PfcbNextIndex() );
		}
#endif	//	DEBUG

	if ( Ptdb() != ptdbNil )
		{
		FCB	* const pfcbLV = Ptdb()->PfcbLV();
		if ( pfcbNil != pfcbLV )
			{
			pfcbLV->CloseAllCursorsOnFCB_( fTerminating );
			}
		}

	FCB	*pfcbNext;
	for ( FCB *pfcbT = this; pfcbNil != pfcbT; pfcbT = pfcbNext )
		{
		pfcbNext = pfcbT->PfcbNextIndex();
		Assert( pfcbNil == pfcbNext
			|| ( FTypeTable()
				&& pfcbNext->FTypeSecondaryIndex()
				&& pfcbNext->PfcbTable() == this ) );

		pfcbT->CloseAllCursorsOnFCB_( fTerminating );
		}
	}


//	finish cleaning up an FCB and return it to the CRES pool
//
//	NOTE: this assumes the FCB has been locked for purging via
//		FCheckFreeAndTryToLockForPurge or PrepareForPurge

VOID FCB::Delete_( INST *pinst )
	{
	Assert( IsUnlocked() );

	//	this FCB should no longer be in either of the lists

#if defined( DEBUG ) && defined( SYNC_DEADLOCK_DETECTION )
	const BOOL fDEBUGLockList = pinst->m_critFCBList.FNotOwner();
	if ( fDEBUGLockList )
		{
		pinst->m_critFCBList.Enter();
		}
	Assert( pinst->m_critFCBList.FOwner() );
	Assert( !FInList() );
	Assert( pfcbNil == PfcbNextList() );
	Assert( pfcbNil == PfcbPrevList() );
	Assert( !FInLRU() );
	Assert( pfcbNil == PfcbMRU() );
	Assert( pfcbNil == PfcbLRU() );
	if ( fDEBUGLockList )
		{
		pinst->m_critFCBList.Leave();
		}
#endif	//	DEBUG && SYNC_DEADLOCK_DETECTION

	//	this FCB should not be in the hash table

#ifdef DEBUG
	FCB *pfcbT;
	Assert( !FInHashTable( Ifmp(), PgnoFDP(), &pfcbT ) || pfcbT != this );
#endif

	//	verify the contents of this FCB

	Assert( Ptdb() == ptdbNil );
	Assert( Pidb() == pidbNil );
	Assert( Pfucb() == pfucbNil );
	Assert( WRefCount() == 0 );
	Assert( PrceNewest() == prceNil );
	Assert( PrceOldest() == prceNil );

	//	finish cleaning up the FCB

	if ( NULL != Precdangling() )
		{
		RECDANGLING		*precdangling	= Precdangling();
		while ( NULL != precdangling )
			{
			RECDANGLING	*precToFree		= precdangling;
			
			precdangling = precdangling->precdanglingNext;

			OSMemoryHeapFree( precToFree );
			}
		}

	if ( NULL != Psplitbufdangling_() )
		{
		//	UNDONE: all space in the splitbuf is lost
		OSMemoryHeapFree( Psplitbufdangling_() );
		}


	if ( JET_LSNil != m_ls )
		{
		JET_CALLBACK	pfn		= pinst->m_pfnRuntimeCallback;

		Assert( NULL != pfn );
		(*pfn)(
			JET_sesidNil,
			JET_dbidNil,
			JET_tableidNil,
			JET_cbtypFreeTableLS,
			(VOID *)m_ls,
			NULL,
			NULL,
			NULL );
		}

	//	destruct the FCB

	this->~FCB();

	//	release the FCB to CRES

	FCBReleasePfcb( pinst, this );

	//	update performance counter

	cFCBCacheAlloc.Dec( pinst );
	}


//	force the FCB to disappear such that we can purge it without fear that
//		we will be pulling the FCB out from underneath anyone else
//
//	the FCB disappears by being removed from the hash-table using the
//		same locking protocol as FCheckFreeAndTryToLockForPurge; however,
//		this routine will block when locking the FCB to make sure that all
//		other owner/waiters will be done (we will be the last owner/waiter)

VOID FCB::PrepareForPurge( const BOOL fPrepareChildren )
	{
	INST			*pinst = PinstFromIfmp( Ifmp() );
	FCBHash::ERR	errFCBHash;
	FCBHash::CLock	lockFCBHash;
	FCBHashKey		keyFCBHash( Ifmp(), PgnoFDP() );
	CSXWLatch::ERR	errSXWLatch;

#if defined( DEBUG ) && defined( SYNC_DEADLOCK_DETECTION )

	//	lock the FCB list

	const BOOL fDBGONLYLockList = pinst->m_critFCBList.FNotOwner();

	if ( fDBGONLYLockList )
		{
		pinst->m_critFCBList.Enter();
		}

	if ( FInList() )
		{
			
		//	verify that this FCB is in the global list

		Assert( pinst->m_pfcbList != pfcbNil );

		FCB *pfcbT = pinst->m_pfcbList;
		while ( pfcbT->PgnoFDP() != PgnoFDP() || pfcbT->Ifmp() != Ifmp() )
			{
			Assert( pfcbNil != pfcbT );
			pfcbT = pfcbT->PfcbNextList();
			}
		
		if ( pfcbT != this )
			{
			Assert( rgfmp[ pfcbT->Ifmp() ].Dbid() == dbidTemp );

			//	Because we delete the table at close time when it is from Temp DB,
			//	the pgnoFDP may be reused by other threads several time already
			//	and the Purge table for each thread may not be called in LRU order.
			//	So continue search for it.

			while ( pfcbT->PgnoFDP() != PgnoFDP() || pfcbT->Ifmp() != Ifmp() || pfcbT != this )
				{
				Assert( pfcbNil != pfcbT );
				pfcbT = pfcbT->PfcbNextList();
				}

			//	Must be found
			
			Assert( pfcbT == this );
			}
		}

	//	unlock the FCB list

	if ( fDBGONLYLockList )
		{
		pinst->m_critFCBList.Leave();
		}

#endif	//	DEBUG && SYNC_DEADLOCK_DETECTION

	//	update performance counter

	cFCBSyncPurge.Inc( pinst );

#ifdef DEBUG
	DWORD cStalls = 0;
#endif	//	DEBUG

RetryLock:

	//	lock the hash table to protect the SXW latch

	pinst->m_pfcbhash->WriteLockKey( keyFCBHash, &lockFCBHash );

	//	try to acquire a write latch on the FCB

	errSXWLatch = m_sxwl.ErrTryAcquireWriteLatch();

	if ( CSXWLatch::errSuccess == errSXWLatch )
		{

		//	we got the write-latch
		//	we can now be sure that we are the only ones who can see this FCB

		//	remove the entry from the hash table regardless of whether or not
		//		we got the write latch

		errFCBHash = pinst->m_pfcbhash->ErrDeleteEntry( &lockFCBHash );

		//	FCB must be in the hash table unless FDeleteCommitted is set
			
		Assert( errFCBHash == FCBHash::errSuccess || FDeleteCommitted() );

		//	mark all children as uninitialized so no one can hash to them
		//
		//	this will prevent the following concurrency hole:
		//		thread 1: table A is being pitched
		//		thread 1: table A's table-FCB is removed from the hash-table
		//		thread 2: table A gets reloaded from disk
		//		thread 2: when loading table A's secondary index FCBs, we see
		//				  that they alrady exist (not yet purged by thread 1)
		//				  and try to link to them even though thread 1 will
		//				  soon be purging them
		//	NOTE: since we have the table-FCB all to ourselves, no one else
		//		  should be trying to load the table or touch any of its
		//		  children FCBs -- thus, we do not need to lock them!

		if ( fPrepareChildren )
			{
			FCB *pfcbT;

			pfcbT = PfcbNextIndex();
			while ( pfcbT != pfcbNil )
				{
				pfcbT->CreateComplete( errFCBUnusable );
				pfcbT = pfcbT->PfcbNextIndex();
				}
			if ( Ptdb() )
				{
				Assert( !FTypeSentinel() );
				if ( Ptdb()->PfcbLV() )
					{
					Ptdb()->PfcbLV()->CreateComplete( errFCBUnusable );
					}
				}
			}
		}

	//	unlock hash table

	pinst->m_pfcbhash->WriteUnlockKey( &lockFCBHash );

	if ( CSXWLatch::errLatchConflict == errSXWLatch )
		{

		//	we were unable to get the write-latch
		//	someone else is touching with this FCB

#ifdef DEBUG
		cStalls++;
		Assert( cStalls < 100 );
#endif	//	DEBUG

		//	update performance counter

		cFCBSyncPurgeStalls.Inc( pinst );

		//	wait

		UtilSleep( 10 );

		//	try to lock the FCB again

		goto RetryLock;
		}

	//	we have the write latch meaning there were no owners/waiters
	//		on the shared or the exclusive latch

	//	release the write latch

	m_sxwl.ReleaseWriteLatch();

	//	the FCB is now invisible and so are its children FCBs

	if ( fPrepareChildren )
		{
		if ( FTypeDatabase() || FTypeTable() || FTypeTemporaryTable() || FTypeSentinel() )
			{
			FCB *pfcbT;

			pfcbT = PfcbNextIndex();
			while ( pfcbT != pfcbNil )
				{
				Assert( !pfcbT->FInitialized() );
				Assert( errFCBUnusable == pfcbT->ErrErrInit() );
				pfcbT->PrepareForPurge( fFalse );
				pfcbT = pfcbT->PfcbNextIndex();
				}
			if ( Ptdb() )
				{
				Assert( !FTypeSentinel() );
				
				if ( Ptdb()->PfcbLV() )
					{
					Assert( !Ptdb()->PfcbLV()->FInitialized() );
					Assert( errFCBUnusable == Ptdb()->PfcbLV()->ErrErrInit() );
					Ptdb()->PfcbLV()->PrepareForPurge( fFalse );
					}
				}
			}
		}

	if ( FTypeTable() )
		{
		if ( Ptdb() )
			{

			//	remove the entry for this table from the catalog hash
			//	NOTE: there is the possibility that after this FCB is removed from the FCB hash
			//		    someone could get to its pgno/objid from the catalog hash; this is ok,
			//		    because the pgno/objid are still valid -- they become invalid AFTER the
			//			space they occupy has been released (ErrSPFreeFDP) and that NEVER happens
			//			until after the FCB is prepared for purge [ie: this function is called]

			if ( FCATHashActive( pinst ) )
				{
				CHAR szTable[JET_cbNameMost+1];

				//	catalog hash is active so we can delete the entry 

				//	read the table name

				EnterDML();
				strcpy( szTable, Ptdb()->SzTableName() );
				LeaveDML();

				//	delete the hash-table entry

				CATHashIDelete( this, szTable );
				}
			}
		}
	}


//	purge any FCB that has previously locked down via PrepareForPurge or
//		FCheckFreeAndTryToLockForPurge

VOID FCB::Purge( const BOOL fLockList, const BOOL fTerminating )
	{
	INST 	*pinst = PinstFromIfmp( Ifmp() );
#ifdef DEBUG
	FCB		*pfcbInHash;
#endif	//	DEBUG
	FCB 	*pfcbT;
	FCB		*pfcbNextT;

	if ( fLockList )
		{
		Assert( pinst->m_critFCBList.FNotOwner() );
		}
	else
		{
		//	either we already have the list locked,
		//	or this is an error during FCB creation,
		//	in which case it's guaranteed not to be
		//	in the avail or global lists
		Assert( pinst->m_critFCBList.FOwner()
			|| ( !FInLRU() && !FInList() ) );
		}
	Assert( IsUnlocked() );

	//	the refcount should be zero by now
	//		(enforce this in retail builds because those are the only
	//		 places this condition will likely arise)

	Enforce( WRefCount() == 0 );

	//	this FCB should not be in the catalog hash table

#ifdef DEBUG
	if ( FTypeTable() && Ptdb() != ptdbNil )
		{
		CHAR	szName[JET_cbNameMost+1];
		PGNO	pgnoT;
		OBJID	objidT;

		EnterDML();
		strcpy( szName, Ptdb()->SzTableName() );
		LeaveDML();
		Assert( !FCATHashLookup( Ifmp(), szName, &pgnoT, &objidT ) );
		}
#endif

	//	this FCB should not be in the FCB hash table

	Assert( !FInHashTable( Ifmp(), PgnoFDP(), &pfcbInHash ) || pfcbInHash != this );

	//	verify the members of this FCB

	Assert( WRefCount() == 0 );
	Assert( Pfucb() == pfucbNil );
	Assert( PrceOldest() == prceNil );
	Assert( PrceNewest() == prceNil );

	if ( FTypeTable() )
		{

		//	unlink the secondary-index chain

		pfcbT = PfcbNextIndex();
		SetPfcbNextIndex( pfcbNil );
		while ( pfcbT != pfcbNil )
			{

	//	ASSUME: no one will be touching these FCBs so we do not
	//			need to lock pfcbT for each one

//	we cannot make assumption about the initialized state of the FCB
//	if we are purging an FCB that was lingering due to an initialization error,
//		the error-code could be anything! also, the member data could be garbled!
//	the assumption below only accounts for initialized FCBs and FCBs which were
//		prepared-for-purge
//
//			Assert( pfcbT->FInitialized() || errFCBUnusable == pfcbT->ErrErrInit() );

			Assert( !pfcbT->FInitialized() || pfcbT->FTypeSecondaryIndex() );
			Assert( ptdbNil == pfcbT->Ptdb() );
			Assert( !pfcbT->FInitialized() || pfcbT->PfcbTable() == this );
			Assert( !FInHashTable( pfcbT->Ifmp(), pfcbT->PgnoFDP(), &pfcbInHash ) ||
					pfcbInHash != pfcbT );
			
			// Return the memory used. No need to explicitly free index
			// name or idxseg array, since memory pool will be freed when
			// TDB is deleted below.
			if ( pidbNil != pfcbT->Pidb() )
				{
				pfcbT->ReleasePidb( fTerminating );
				}
			pfcbNextT = pfcbT->PfcbNextIndex();
			pfcbT->Delete_( pinst );
			pfcbT = pfcbNextT;
			}
		}
	else
		{
		Assert( !FTypeDatabase()		|| pfcbNil == PfcbNextIndex() );
		Assert( !FTypeTemporaryTable()	|| pfcbNil == PfcbNextIndex() );
		Assert( !FTypeSort()			|| pfcbNil == PfcbNextIndex() );
		Assert( !FTypeSentinel()		|| pfcbNil == PfcbNextIndex() );
		Assert( !FTypeLV()				|| pfcbNil == PfcbNextIndex() );
		Assert( !FTypeSLVAvail()		|| pfcbNil == PfcbNextIndex() );
		Assert(	!FTypeSLVOwnerMap()		|| pfcbNil == PfcbNextIndex() );
		}

	//	delete the TDB

	if ( Ptdb() != ptdbNil )
		{
		Assert( FTypeTable() || FTypeTemporaryTable() );

		//	delete the LV-tree FCB

		pfcbT = Ptdb()->PfcbLV();
		Ptdb()->SetPfcbLV( pfcbNil );
		if ( pfcbT != pfcbNil )
			{

			//	verify the LV-tree FCB

//	we cannot make assumptions about the initialized state of the FCB
//	the FCB could have failed to be initialized because of a disk error
//		and it was left lingering meaning its member data would be garbled!
//
//			Assert( pfcbT->FInitialized() );

			Assert( !pfcbT->FInitialized() || pfcbT->FTypeLV() );
			Assert( !pfcbT->FInitialized() || pfcbT->PfcbTable() == this );
			Assert( !FInHashTable( pfcbT->Ifmp(), pfcbT->PgnoFDP(), &pfcbInHash ) ||
					pfcbInHash != pfcbT );

			pfcbT->Delete_( pinst );
			}

		Ptdb()->Delete( pinst );
		SetPtdb( ptdbNil );
		}

	//	unlink the IDB

	if ( Pidb() != pidbNil )
		{
		Assert( FTypeTable() || FTypeTemporaryTable() );

		// No need to explicitly free index name or idxseg array, since
		// memory pool was freed when TDB was deleted above.
		ReleasePidb();
		}

	if ( fLockList )
		{

		//	lock the list

		pinst->m_critFCBList.Enter();
		}

	if ( FInLRU() )
		{

		//	remove this FCB from the avail list

#ifdef DEBUG
		RemoveAvailList_( fTrue );
#else	//	!DEBUG
		RemoveAvailList_();
#endif	//	DEBUG
		}

	if ( FInList() )
		{

		//	remove this FCB from the global list

		RemoveList_();
		}

	if ( fLockList )
		{

		//	unlock the list

		pinst->m_critFCBList.Leave();
		}

	//	delete this FCB

	Delete_( pinst );
	}


//	returns fTrue when this FCB has temporary callbacks

INLINE BOOL FCB::FHasCallbacks_( INST *pinst )
	{
	if ( pinst->m_plog->m_fRecovering || g_fCallbacksDisabled )
		{
		return fFalse;
		}
		
	const CBDESC *pcbdesc = m_ptdb->Pcbdesc();
	while ( pcbdesc != NULL )
		{
		if ( !pcbdesc->fPermanent )
			{
			return fTrue;
			}
		pcbdesc = pcbdesc->pcbdescNext;
		}

	//  no callbacks, or all callbacks are in the catalog

	return fFalse;
	}



//	returns fTrue when this FCB has atlease one outstanding version

INLINE BOOL FCB::FOutstandingVersions_()
	{
	//	if we're checking the RCE list with the intent to free the FCB, we must grab
	//	the critical section first, otherwise we can get into the state where version
	//	cleanup has freed the last RCE for the FCB, but has yet to leave the critical
	//	section when we suddenly free the FCB (and hence the critical section) out
	//	from underneath him.
	ENTERCRITICALSECTION	enterCritRCEList( &CritRCEList() );
	return ( prceNil != PrceOldest() );
	}



//	free all FCBs belonging to a particular database (matching IFMP)

VOID FCB::DetachDatabase( const IFMP ifmp, BOOL fDetaching )
	{
//	Assert( dbidTemp != rgfmp[ifmp].Dbid() );
	Assert( !fDetaching ||					//	shutdown with attached db
			rgfmp[ifmp].FDetachingDB() ||	//	called by detaching db
			fGlobalRepair );				//	repair

	INST 	*pinst = PinstFromIfmp( ifmp );
	FCB		*pfcbNext;
	FCB		*pfcbThis;

	Assert( pinst->m_critFCBList.FNotOwner() );
	
	//	lock the FCB list

	pinst->m_critFCBList.Enter();

	//	scan the list for any FCB whose Ifmp() matches the given ifmp

	pfcbThis = pinst->m_pfcbList;
	while ( pfcbThis != pfcbNil )
		{

		//	get the next FCB
		
		pfcbNext = pfcbThis->PfcbNextList();

		if ( pfcbThis->Ifmp() == ifmp )
			{

			//	this FCB belongs to the IFMP that is being detached

			Assert( pfcbThis->FTypeDatabase() 		||
					pfcbThis->FTypeTable() 			||
					pfcbThis->FTypeTemporaryTable()	||
					pfcbThis->FTypeSentinel() );

			//	lock this FCB for purging

			pfcbThis->PrepareForPurge();

			//	purge this FCB

			pfcbThis->CloseAllCursors( fFalse );
			pfcbThis->Purge( fFalse );
			}

		//	move next

		pfcbThis = pfcbNext;
		}

	//	unlock the FCB list

	pinst->m_critFCBList.Leave();

#ifdef DEBUG

	//	make sure all entries for the IFMP are gone

	CATHashAssertCleanIfmp( ifmp );

#endif	//	DEBUG
	}


//	free all FCBs (within the current instance)

VOID FCB::PurgeAllDatabases( INST *pinst )
	{
	FCB 	*pfcbNext;
	FCB 	*pfcbThis;

	Assert( pinst->m_critFCBList.FNotOwner() );

	//	lock the FCB list

	pinst->m_critFCBList.Enter();

	//	scan the list for any FCB whose Ifmp() matches the given ifmp

	pfcbThis = pinst->m_pfcbList;
	while ( pfcbThis != pfcbNil )
		{

		//	get the next FCB
		
		pfcbNext = pfcbThis->PfcbNextList();

		Assert( pfcbThis->FTypeDatabase() 		||
				pfcbThis->FTypeTable() 			||
				pfcbThis->FTypeTemporaryTable()	||
				pfcbThis->FTypeSentinel() );

		//	lock this FCB for purging

		pfcbThis->PrepareForPurge();

		//	purge this FCB

		pfcbThis->CloseAllCursors( fTrue );
		pfcbThis->Purge( fFalse, fTrue );

		//	move next

		pfcbThis = pfcbNext;
		}

	//	reset the list

	pinst->m_pfcbList = pfcbNil;
	
	//	unlock the FCB list

	pinst->m_critFCBList.Leave();


	for ( DBID dbidT = dbidMin; dbidT < dbidMax; dbidT++ )
		{
		const IFMP	ifmpT	= pinst->m_mpdbidifmp[dbidT];
		if ( ifmpT < ifmpMax )
			{
#ifdef DISABLE_SLV
#else
			//	can't wait for SLVClose() to free SLV FCB's
			//	because all FUCB's are about to be returned
			//	to CRES
			SLVAvailMapTerm( ifmpT, fTrue );
			SLVOwnerMapTerm( ifmpT, fTrue );
#endif

#ifdef DEBUG
			//	make sure all catalog-hash entries are gone for all IFMPs 
			//	used by the current instance
			CATHashAssertCleanIfmp( ifmpT );
#endif
			}
		}
	}



//	insert this FCB into the hash-table
//		(USED ONLY BY SCBInsertHashTable!!!)

VOID FCB::InsertHashTable()
	{	
	Assert( IsLocked() || FTypeSort() );

	//	make sure this FCB is not in the hash-table

	Assert( !FInHashTable( Ifmp(), PgnoFDP() ) );
	
	INST 			*pinst = PinstFromIfmp( Ifmp() );
	FCBHash::ERR	errFCBHash;
	FCBHash::CLock	lockFCBHash;
	FCBHashKey		keyFCBHash( Ifmp(), PgnoFDP() );
	FCBHashEntry	entryFCBHash( PgnoFDP(), this );

	//	lock the key

	pinst->m_pfcbhash->WriteLockKey( keyFCBHash, &lockFCBHash );

	//	insert the entry

	errFCBHash = pinst->m_pfcbhash->ErrInsertEntry( &lockFCBHash, entryFCBHash );
	Assert( errFCBHash == FCBHash::errSuccess );

	//	unlock the key

	pinst->m_pfcbhash->WriteUnlockKey( &lockFCBHash );

#ifdef DEBUG

	//	this FCB should now be in the hash-table

	FCB *pfcbT;
	Assert( FInHashTable( Ifmp(), PgnoFDP(), &pfcbT ) );
	Assert( pfcbT == this );
#endif	//	DEBUG
	}


//	delete this FCB from the hash-table

VOID FCB::DeleteHashTable()
	{
#ifdef DEBUG

	//	make sure this FCB is in the hash-table

	FCB *pfcbT;
	Assert( FInHashTable( Ifmp(), PgnoFDP(), &pfcbT ) );
	Assert( pfcbT == this );
#endif	//	DEBUG

	INST 			*pinst = PinstFromIfmp( Ifmp() );
	FCBHash::ERR	errFCBHash;
	FCBHash::CLock	lockFCBHash;
	FCBHashKey		keyFCBHash( Ifmp(), PgnoFDP() );

	//	lock the key

	pinst->m_pfcbhash->WriteLockKey( keyFCBHash, &lockFCBHash );

	//	delete the entry

	errFCBHash = pinst->m_pfcbhash->ErrDeleteEntry( &lockFCBHash );
	Assert( errFCBHash == FCBHash::errSuccess );

	//	unlock the key

	pinst->m_pfcbhash->WriteUnlockKey( &lockFCBHash );

	//	make sure this FCB is not in the hash-table

	Assert( !FInHashTable( Ifmp(), PgnoFDP() ) );
	}


//	validate the refcount of the FCB

INLINE VOID FCB::AssertRefCount()
	{
#ifdef DEBUG
	Assert( IsLocked() );

	ULONG			cfcb	= 0;
	const ULONG		refcnt	= WRefCount();
	FUCB *			pfucbT;

	for ( pfucbT = Pfucb(); pfucbT != pfucbNil; pfucbT = pfucbT->pfucbNextOfFile )
		{
		Assert( cfcb < refcnt );
		cfcb++;
		}

	//	the refcount may actually be higher than the number of cursors on this FCB because sometimes we
	//	artificially increase the refcnt when we just want to pin the FCB momentarily.

	Assert( cfcb <= refcnt );
	Assert( refcnt == WRefCount() );
#endif	//	DEBUG
	}


INLINE VOID FCB::Link_( FUCB * const pfucb )
	{
	Assert( IsLocked() );

	//	link to FCB
	//
	pfucb->u.pfcb = this;

	//	update current head of list
	//
	if ( pfucbNil != Pfucb() )
		{
		Assert( pfucbNil == Pfucb()->pfucbPrevOfFile );
		Pfucb()->pfucbPrevOfFile = pfucb;
		}

	//	set new cursor as new head of list
	//
	pfucb->pfucbNextOfFile = Pfucb();
	pfucb->pfucbPrevOfFile = pfucbNil;
	SetPfucb( pfucb );

	//	verify the refcount again
	//
	Assert( WRefCount() > 0 );
	AssertRefCount();
	}

//	link an FUCB to this FCB

VOID FCB::Link( FUCB *pfucb )
	{
	Assert( pfucb != pfucbNil );
	Assert( IsUnlocked() );

#ifdef DEBUG
	if ( rgfmp[ Ifmp() ].Dbid() == dbidTemp && !FTypeNull() )
		{
		if ( PgnoFDP() == pgnoSystemRoot )
			{
			Assert( FTypeDatabase() );
			}
		else
			{
		 	Assert( FTypeTemporaryTable() || FTypeSort() || FTypeSLVAvail() || FTypeSLVOwnerMap() );
		 	}
		 }

	//	if this FCB has a refcount of 0, it should not be purgable
	//	otherwise, it could be purged while we are trying to link an FUCB to it!

	INST *pinst = PinstFromIfmp( Ifmp() );
	Assert( pinst->m_critFCBList.FNotOwner() );

	pinst->m_critFCBList.Enter();
	if ( FInLRU() )
		{

		//	FCB is in the avail-LRU list meaning it has the potential to be purged

		Lock();
		if ( WRefCount() == 0 &&
			 PgnoFDP() != pgnoSystemRoot &&
			 !FTypeSentinel() &&			//	sentinel FCBs are freed by RCEClean
			 !FDeletePending() &&			//	FCB with pending "delete-table" is freed by RCEClean
			 !FTemplateTable() &&
			 //!FDomainDenyRead( ppib ) &&
			 !FOutstandingVersions_() &&
			 0 == CTasksActive() &&
			 !FHasCallbacks_( pinst ) )
			{

			//	FCB is ready to be purged -- this is very bad
			//
			//	whoever the caller is, they are calling Link() on an FCB which
			//		could disappear at any moment because its in the avail-LRU
			//		list and its purge-able
			//
			//	this is a bug in the caller...

			//	NOTE: this may have been reached in error!
			//		  if the FCB's FDomainDenyRead counter is set, this is a bad
			//			 assert (I couldn't call FDomainDenyRead without a good ppib)

			AssertTracking();
			}
		Unlock();
		}
	pinst->m_critFCBList.Leave();

#endif	//	DEBUG

	//	lock the FCB

	Lock();

	//	verify the refcount

	AssertRefCount();

	//	increment the refcount

	const BOOL	fMoveFromAvailList	= FIncrementRefCount_();

	if ( !fMoveFromAvailList )
		{
		//	we did not defer the refcount of this FCB
		//
		//	link the FUCB
		//
		Link_( pfucb );
		}

	//	unlock the FCB

	Unlock();

	if ( fMoveFromAvailList )
		{
		INST *pinst = PinstFromIfmp( Ifmp() );
		Assert( pinst->m_critFCBList.FNotOwner() );

		//	lock the list

		pinst->m_critFCBList.Enter();

		//	lock the FCB again

		Lock();

		//	link the FUCB
		//
		Link_( pfucb );

		//	refcnt just went from 0 to 1 so this FCB should be removed
		//		from the avail-LRU list
		//	NOTE: if the FCB was just created, it will not be in the list

		if ( FInLRU() )
			{
			//	remove this FCB from the avail list
			RemoveAvailList_();
			}

		//	unlock the FCB

		Unlock();

		//	unlock the list
				
		pinst->m_critFCBList.Leave();
		}
	}



//  ================================================================
VOID FCB::AttachRCE( RCE * const prce )
//  ================================================================
//
//  Add a newly created RCE to the head of the RCE queue. Increments
//  the version refcount on the FCB
//
//-
	{
	Assert( CritRCEList().FOwner() );

	Assert( prce->Ifmp() == Ifmp() );
	Assert( prce->PgnoFDP() == PgnoFDP() );

	if ( prce->Oper() != operAddColumn )
		{
		// UNDONE: Don't hold pfcb->CritFCB() over versioning of AddColumn
		Assert( IsUnlocked() );
		}
	
	Assert( (prceNil == m_prceNewest) == (prceNil == m_prceOldest) );

	prce->SetPrceNextOfFCB( prceNil );
	prce->SetPrcePrevOfFCB( m_prceNewest );
	if( prceNil != m_prceNewest )
		{
		Assert( m_prceNewest->PrceNextOfFCB() == prceNil );
		m_prceNewest->SetPrceNextOfFCB( prce );
		}
	m_prceNewest = prce;
	if( prceNil == m_prceOldest )
		{
		m_prceOldest = prce;
		}

	Assert( PrceOldest() != prceNil );
	Assert( prceNil != m_prceNewest );
	Assert( prceNil != m_prceOldest );
	Assert( m_prceNewest == prce );
	Assert( this == prce->Pfcb() );
	}


//  ================================================================
VOID FCB::DetachRCE( RCE * const prce )
//  ================================================================
//
//  Removes the RCE from the queue of RCEs held in the FCB. Decrements
//  the version count of the FCB
//
//-
	{
	Assert( CritRCEList().FOwner() );
	Assert( IsUnlocked() );
	
	Assert( this == prce->Pfcb() );
	Assert( prce->Ifmp() == Ifmp() );
	Assert( prce->PgnoFDP() == PgnoFDP() );

	Assert( PrceOldest() != prceNil );
	Assert( prceNil != m_prceNewest );
	Assert( prceNil != m_prceOldest );

	if( prce == m_prceNewest || prce == m_prceOldest )
		{
		//  at the head/tail of the list
		Assert( prceNil == prce->PrceNextOfFCB() || prceNil == prce->PrcePrevOfFCB() );
		if( prce == m_prceNewest )
			{
			Assert( prce->PrceNextOfFCB() == prceNil );
			m_prceNewest = prce->PrcePrevOfFCB();
			if( prceNil != m_prceNewest )
				{
				m_prceNewest->SetPrceNextOfFCB( prceNil );
				}
			}
		if( prce == m_prceOldest )
			{
			Assert( prce->PrcePrevOfFCB() == prceNil );
			m_prceOldest = prce->PrceNextOfFCB();
			if ( prceNil != m_prceOldest )
				{
				m_prceOldest->SetPrcePrevOfFCB( prceNil );
				}
			}
		}
	else
		{
		//  in the middle of the list
		Assert( prceNil != prce->PrceNextOfFCB() );
		Assert( prceNil != prce->PrcePrevOfFCB() );

		RCE * const prceNext = prce->PrceNextOfFCB();
		RCE * const prcePrev = prce->PrcePrevOfFCB();
		
		prceNext->SetPrcePrevOfFCB( prcePrev );
		prcePrev->SetPrceNextOfFCB( prceNext );
		}
		
	prce->SetPrceNextOfFCB( prceNil );
	prce->SetPrcePrevOfFCB( prceNil );

	Assert( ( prceNil == m_prceNewest ) == ( prceNil == m_prceOldest ) );
	Assert( prce->PrceNextOfFCB() == prceNil );
	Assert( prce->PrcePrevOfFCB() == prceNil );
	}
	

//	unlink an FUCB from this FCB

INLINE VOID FCB::Unlink( FUCB *pfucb, const BOOL fPreventMoveToAvail )
	{
	Assert( pfucb != pfucbNil );
	Assert( pfucb->u.pfcb != pfcbNil );
	Assert( this == pfucb->u.pfcb );

#ifdef DEBUG

	//	we do not need CritFCB() to check these flags because they are immutable
	
	if ( rgfmp[ Ifmp() ].Dbid() == dbidTemp && !FTypeNull() )
		{
		if ( PgnoFDP() == pgnoSystemRoot )
			{
			Assert( FTypeDatabase() );
			}
		else
			{
		 	Assert( FTypeTemporaryTable() || FTypeSort() || FTypeSLVAvail() || FTypeSLVOwnerMap() );
		 	}
		 }
#endif	//	DEBUG

	//	lock this FCB

	Lock();

	//	verify the refcount
	
	Assert( WRefCount() > 0 );
	AssertRefCount();

	//	unlink the FCB backpointer from the FUCB 

	pfucb->u.pfcb = pfcbNil;

	//	scan the list of FUCBs linked to this FCB and
	//		remove the given FUCB from that list

	Assert( Pfucb() != pfucbNil );

#ifdef DEBUG
	FUCB *pfucbCurrDBG = Pfucb();
	FUCB *pfucbPrevDBG = pfucbNil;
	while ( pfucbCurrDBG != pfucb )
		{
		if ( pfucbNil == pfucbCurrDBG )
			{
			//	FUCB is linked to this FCB, but FCB has no record of this cursor in
			//	its cursor chain.
			FireWall();

			//	unlock the FCB

			Unlock();

			return;
			}

		pfucbPrevDBG = pfucbCurrDBG;
		pfucbCurrDBG = pfucbCurrDBG->pfucbNextOfFile;
		Assert( pfucbNil != pfucbCurrDBG );
		}

	Assert( pfucbPrevDBG == pfucb->pfucbPrevOfFile );
#endif	//	DEBUG

	FUCB * const	pfucbNext	= pfucb->pfucbNextOfFile;
	FUCB * const	pfucbPrev	= pfucb->pfucbPrevOfFile;

	if ( pfucbNil != pfucbPrev )
		{
		pfucbPrev->pfucbNextOfFile = pfucbNext;
		}
	else
		{
		SetPfucb( pfucbNext );
		}

	if ( pfucbNil != pfucbNext )
		{
		pfucbNext->pfucbPrevOfFile = pfucbPrev;
		}

	//	decrement the refcount of this FCB

	const BOOL fMoveToAvailList = FDecrementRefCount_( fPreventMoveToAvail );

	//	verify the refcount
	
	Assert( WRefCount() >= 0 );
	AssertRefCount();

	//	unlock this FCB 
	
	Unlock();

	if ( fMoveToAvailList )
		{
		INST *pinst = PinstFromIfmp( Ifmp() );
		Assert( pinst->m_critFCBList.FNotOwner() );

		//	lock the list

		pinst->m_critFCBList.Enter();

		//	the FCB should not already be in the avail-LRU list because it has
		//		atleast one outstanding refcnt decrement (this one)

		Assert( !FInLRU() );

		//	lock the FCB

		Lock();

		//	decrement the refcount

		DeferredDecrementRefCount_();

		//	verify the refcount
	
		Assert( WRefCount() >= 0 );
		AssertRefCount();

		if ( WRefCount() == 0 )
			{

			//	the refcnt just went from 1 to 0 so it will be moving into the
			//		avail-LRU list (should not already be there)
			
			//	insert this FCB into the avail list at the MRU position

			InsertAvailListMRU_();
			}
		else
			{
			//	the refcnt did not get incremented from 0 and should not be in the
			//		avail-LRU list
			}

		//	unlock the FCB

		Unlock();

		//	unlock the list
		
		pinst->m_critFCBList.Leave();
		}
	}


//	unlink an FUCB from its FCB and possibly move the FCB into
//		the avail LRU list

VOID FCBUnlink( FUCB *pfucb )
	{
	Assert( pfucbNil != pfucb );
	Assert( pfcbNil != pfucb->u.pfcb );
	pfucb->u.pfcb->Unlink( pfucb, fFalse );
	}


//	unlink an FUCB from its FCB and do not move the FCB to
//		the avail LRU list

VOID FCBUnlinkWithoutMoveToAvailList( FUCB *pfucb )
	{
	Assert( pfucbNil != pfucb );
	Assert( pfcbNil != pfucb->u.pfcb );
	pfucb->u.pfcb->Unlink( pfucb, fTrue );
	}


ERR FCB::ErrSetUpdatingAndEnterDML( PIB *ppib, BOOL fWaitOnConflict )
	{
	ERR	err = JET_errSuccess;
	
	Assert( IsUnlocked() );
	
	// If DDL is fixed, then there's no contention with CreateIndex
	if ( !FFixedDDL() )
		{
		Assert( FTypeTable() );				// Sorts and temp tables have fixed DDL.
		Assert( !FTemplateTable() );
		Assert( Ptdb() != ptdbNil );
		
CheckIndexing:
		Ptdb()->EnterUpdating();
		EnterDML_();

		// SPECIAL CASE: Cannot update an uncommitted primary index if
		// it doesn't belong to us.
		if ( Pidb() != pidbNil && Pidb()->FVersionedCreate() )
			{
			err = ErrFILEIAccessIndex( ppib, this, this );
			if ( JET_errIndexNotFound == err )
				{
				LeaveDML_();
				ResetUpdating_();

				if ( fWaitOnConflict )
					{
					// Abort update and wait for primary index to commit or
					// rollback.  We're guaranteed the FCB will still exist
					// because we have a cursor open on it.
					UtilSleep( cmsecWaitGeneric );
					err = JET_errSuccess;
					goto CheckIndexing;
					}
				else
					{
					err = ErrERRCheck( JET_errWriteConflictPrimaryIndex );
					}
				}
			}
		}
		
	return err;
	}



ERR FCB::ErrSetDeleteIndex( PIB *ppib )
	{
	Assert( FTypeSecondaryIndex() );
	Assert( !FDeletePending() );
	Assert( !FDeleteCommitted() );
	Assert( PfcbTable() != pfcbNil );
	Assert( PfcbTable()->FTypeTable() );
	Assert( Pidb() != pidbNil );
	Assert( !Pidb()->FDeleted() );
	PfcbTable()->AssertDDL();

	Assert( Pidb()->CrefCurrentIndex() <= WRefCount() );

	if ( Pidb()->CrefCurrentIndex() > 0 )
		{
		return ErrERRCheck( JET_errIndexInUse );
		}

	Assert( !PfcbTable()->FDomainDenyRead( ppib ) );
	if ( !PfcbTable()->FDomainDenyReadByUs( ppib ) )
		{
		Pidb()->SetFVersioned();
		}
	Pidb()->SetFDeleted();
	
	SetDomainDenyRead( ppib );
	SetDeletePending();

	return JET_errSuccess;
	}



ERR VTAPI ErrIsamRegisterCallback(
	JET_SESID 		vsesid,
	JET_VTID		vtid,
	JET_CBTYP		cbtyp, 
	JET_CALLBACK	pCallback,
	VOID			*pvContext,
	JET_HANDLE		*phCallbackId )
	{	
 	PIB		* const ppib	= reinterpret_cast<PIB *>( vsesid );
	FUCB	* const pfucb	= reinterpret_cast<FUCB *>( vtid );

	Assert( pfucb != pfucbNil );
	CheckTable( ppib, pfucb );

	ERR	err = JET_errSuccess;

	if( JET_cbtypNull == cbtyp
		|| NULL == pCallback
		|| NULL == phCallbackId )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrIsamBeginTransaction( vsesid, NO_GRBIT ) );
	
	CBDESC * const pcbdescInsert = new CBDESC;
	if( NULL != pcbdescInsert )
		{
		FCB * const pfcb = pfucb->u.pfcb;
		Assert( NULL != pfcb );
		TDB * const ptdb = pfcb->Ptdb();
		Assert( NULL != ptdb );

		*phCallbackId = (JET_HANDLE)pcbdescInsert;
		
		pcbdescInsert->pcallback 	= pCallback;
		pcbdescInsert->cbtyp 		= cbtyp;
		pcbdescInsert->pvContext	= pvContext;
		pcbdescInsert->cbContext	= 0;
		pcbdescInsert->ulId			= 0;
		pcbdescInsert->fPermanent	= fFalse;

#ifdef VERSIONED_CALLBACKS
		pcbdescInsert->fVersioned	= !rgfmp[pfucb->ifmp].FVersioningOff();

		pcbdescInsert->trxRegisterBegin0	=	ppib->trxBegin0;
		pcbdescInsert->trxRegisterCommit0	=	trxMax;
		pcbdescInsert->trxUnregisterBegin0	=	trxMax;
		pcbdescInsert->trxUnregisterCommit0	=	trxMax;

		VERCALLBACK vercallback;
		vercallback.pcallback 	= pcbdescInsert->pcallback;
		vercallback.cbtyp 		= pcbdescInsert->cbtyp;
		vercallback.pvContext 	= pcbdescInsert->pvContext;
		vercallback.pcbdesc 	= pcbdescInsert;	

		if( pcbdescInsert->fVersioned )
			{
			VER *pver = PverFromIfmp( pfucb->ifmp );
			err = pver->ErrVERFlag( pfucb, operRegisterCallback, &vercallback, sizeof( VERCALLBACK ) );
			}
#else
		pcbdescInsert->fVersioned	= fFalse;
#endif	//	DYNAMIC_CALLBACKS		

		if( err >= 0 )
			{
			pfcb->EnterDDL();
			ptdb->RegisterPcbdesc( pcbdescInsert );		
			pfcb->LeaveDDL();		
			}
		}
	else
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		*phCallbackId = 0xFFFFFFFA;
		}	

	if( err >= 0 )
		{
		err = ErrIsamCommitTransaction( vsesid, NO_GRBIT );
		}
	if( err < 0 )
		{
		CallS( ErrIsamRollback( vsesid, NO_GRBIT ) );
		}
	return err;
	}
	

ERR VTAPI ErrIsamUnregisterCallback(
	JET_SESID 		vsesid,
	JET_VTID		vtid,
	JET_CBTYP		cbtyp, 
	JET_HANDLE		hCallbackId )
	{
 	PIB		* const ppib 	= reinterpret_cast<PIB *>( vsesid );
	FUCB	* const pfucb 	= reinterpret_cast<FUCB *>( vtid );
	
	ERR		err = JET_errSuccess;

	//	check input
	CallR( ErrPIBCheck( ppib ) );
	Assert( pfucb != pfucbNil );
	CheckTable( ppib, pfucb );

	//	the callback id is a pointer to the CBDESC to remove
	
	FCB * const pfcb = pfucb->u.pfcb;
	Assert( NULL != pfcb );
	TDB * const ptdb = pfcb->Ptdb();
	Assert( NULL != ptdb );

	CBDESC * const pcbdescRemove = (CBDESC *)hCallbackId;
	Assert( !pcbdescRemove->fPermanent );
	Assert( JET_cbtypNull != pcbdescRemove->cbtyp );
	Assert( NULL != pcbdescRemove->pcallback );

	CallR( ErrIsamBeginTransaction( vsesid, NO_GRBIT ) );

#ifndef VERSIONED_CALLBACKS
	Assert( !pcbdescRemove->fVersioned );
#else	//	!VERSIONED_CALLBACKS

	VERCALLBACK vercallback;
	vercallback.pcallback 	= pcbdescRemove->pcallback;
	vercallback.cbtyp 		= pcbdescRemove->cbtyp;
	vercallback.pvContext 	= pcbdescRemove->pvContext;
	vercallback.pcbdesc 	= pcbdescRemove;	

	if( pcbdescRemove->fVersioned )
		{
		VER *pver = PverFromIfmp( pfucb->ifmp );
		err = pver->ErrVERFlag( pfucb, operUnregisterCallback, &vercallback, sizeof( VERCALLBACK ) );
		if( err >= 0 )
			{
			pfcb->EnterDDL();
			pcbdescRemove->trxUnregisterBegin0 = ppib->trxBegin0;		
			pfcb->LeaveDDL();		
			}
		}
	else
		{
#endif	//	VERSIONED_CALLBACKS

		//  unversioned
		pfcb->EnterDDL();
		ptdb->UnregisterPcbdesc( pcbdescRemove );
		pfcb->LeaveDDL();		
		delete pcbdescRemove;

#ifdef VERSIONED_CALLBACKS
		}
#endif	//	VERSIONED_CALLBACKS

	if( err >= 0 )
		{
		err = ErrIsamCommitTransaction( vsesid, NO_GRBIT );
		}
	if( err < 0 )
		{
		CallS( ErrIsamRollback( vsesid, NO_GRBIT ) );
		}
	return err;
	}

	
#ifdef DEBUG
VOID FCBAssertAllClean( INST *pinst )
	{
	FCB	*pfcbT;

	//	lock the FCB list

	pinst->m_critFCBList.Enter();

	//	verify that all FCB's have been cleaned and there are no outstanding versions.
	
	for ( pfcbT = pinst->m_pfcbList; pfcbT != pfcbNil; pfcbT = pfcbT->PfcbNextList() )
		{
		Assert( pfcbT->PrceOldest() == prceNil );
		}

	//	unlock the FCB list

	pinst->m_critFCBList.Leave();
	}
#endif


//	public API to increment the refcount of an FCB directly
//
//	this allows you to bypass PfcbFCBGet (the proper lookup function)
//		under the assumption that the FCB you are refcounting will
//		not suddenly disappear (e.g. you own a cursor on it or know 
//		for a fact that someone else does and they will not close it)
VOID FCB::IncrementRefCount()
	{
	Assert( IsUnlocked() );

	//	lock the FCB
	Lock();

	//	increment the refcount
	const BOOL	fMoveFromAvailList	= FIncrementRefCount_();

	//	unlock the FCB
	Unlock();


	//	if necessary, move to AvailList (requires entering
	//	critFCBList, which is why we have to leave the
	//	FCB Lock first)
	if ( fMoveFromAvailList )
		{
		MoveFromAvailList_();
		}
	}


// public API to Move FCB from Available List
//	================================================================
VOID FCB::MoveFromAvailList_()
//	================================================================
	{
	INST* const		pinst = PinstFromIfmp( Ifmp() );

	//	lock the list
	Assert( pinst->m_critFCBList.FNotOwner() );
	pinst->m_critFCBList.Enter();

	//	lock the FCB
	Lock();

	//	verify the refcount again
	Assert( WRefCount() > 0 );
	AssertRefCount();

	//	refcnt went from 0 to 1 so this FCB should be removed
	//		from the avail-LRU list
	if ( FInLRU() )
		{
		//	remove this FCB from the avail list
		RemoveAvailList_();
		}
	else
		{
		//	this is the case where the FCB was just created and its
		//		refcount == 0
		//	NOTE: this should be impossible to hit because every FCB
		//		that gets created will have a refcount of 1 when
		//		it is finished with CreateComplete; therefore, every 
		//		FCB whose refcount == 0 got that way due to a 
		//		refcnt-- meaning that FCB is in the avail-LRU list
		AssertTracking();
		}

	//	unlock the FCB
	Unlock();

	//	unlock the list
	pinst->m_critFCBList.Leave();
	}


//	decrement the refcount of an FCB directly
//
//	if refcnt goes from 1 to 0, the FCB is moved into the avail-LRU list
//
//	this is only used by FCB::Release (though other forms are used elsewhere
//		such as in FCB::Unlink())

VOID FCB::DecrementRefCount_()
	{
	Assert( IsUnlocked() );

	//	lock the FCB

	Lock();

	//	increment the refcount

	const BOOL	fMoveToAvailList	= FDecrementRefCount_( fFalse );

	//	unlock the FCB

	Unlock();

	if ( fMoveToAvailList )
		{
		INST *pinst = PinstFromIfmp( Ifmp() );
		Assert( pinst->m_critFCBList.FNotOwner() );

		//	lock the list

		pinst->m_critFCBList.Enter();

		//	the FCB should not already be in the avail-LRU list because it has
		//		atleast one outstanding refcnt decrement (this one)

		Assert( !FInLRU() );

		//	lock the FCB

		Lock();

		//	decrement the refcount (deferred from FDecrementRefCount_)

		DeferredDecrementRefCount_();
		
		if ( WRefCount() == 0 )
			{

			//	the refcnt just went from 1 to 0 so it will be moving into the
			//		avail-LRU list (should not already be there)
			
			//	insert this FCB into the avail list at the MRU position

			InsertAvailListMRU_();
			}
		else
			{
			//	the refcnt did not get incremented from 0 and should not be in the
			//		avail-LRU list
			}

		//	unlock the FCB

		Unlock();

		//	unlock the list
		
		pinst->m_critFCBList.Leave();
		}
	}


//	increment the refcount of the FCB
//
//	if the FCB's refcnt went from 0 to 1 and the FCB is of type 
//		table/database/sentinel, fTrue will be returned
//	otherwise, fFalse will be returned
//
//	the return value fTrue means the refcount operation has changed the
//		availability of the FCB (e.g. the FCB could be in the avail-LRU
//		list but it is no longer "available" because it has a refcount);
//		thus, it is the signal to the caller that the FCB should be 
//		removed from the avail-LRU list immediately
//

INLINE BOOL FCB::FIncrementRefCount_()
	{
	Assert( IsLocked() );

	const LONG	lRefCountInitial	= m_wRefCount;
	Assert( lRefCountInitial == WRefCount() );

	//	do the increment now

	Assert( WRefCount() >= 0 );
	m_wRefCount++;
	Assert( WRefCount() > 0 );

	//	no one should be updating the refcount without the FCB lock
	Assert( WRefCount() == lRefCountInitial + 1 );

	return ( 0 == lRefCountInitial && FTypeTable() );
	}


//	try to decrement the refcount of the FCB
//
//	if the FCB's current refcnt == 0 and the FCB is of type 
//		table/database/sentinel and fWillMoveToAvailList is set, 
//		the refcount will NOT be decremented and fTrue will be returned
//	otherwise, the refcnt will be decremented and fFalse will be returned
//
//	the return value fTrue means the refcount operation was deferred
//		so that the avail-LRU list could be locked to insert the FCB
//		at the exact moment its refcount changes from 1 to 0
//
//	the predicate fWillMoveToAvailList tell this function whether or not
//		the FCB being decremented will in fact be moving to the avail-LRU
//		list or not; in the case where the FCB is NOT moving to the
//		avail-LRU list (for whatever reason), this code will not defer
//		the decrement because there is no need to lock the avail-LRU list

INLINE BOOL FCB::FDecrementRefCount_( const BOOL fPreventMoveToAvailList )
	{
	Assert( IsLocked() );

	if ( fPreventMoveToAvailList || WRefCount() != 1 || !FTypeTable() )
		{
	
		//	decrement the refcount now

		Assert( WRefCount() > 0 );
		m_wRefCount--;
		Assert( WRefCount() >= 0 );

		return fFalse;
		}

	//	defer the decrement until we lock the avail-LRU list

	return fTrue;
	}


//	do the deferred refcount decrement from a previous call to 
//		FDecrementRefCount_
//
//	NOTE: this should only be called with the avail-LRU list locked
//		  also, it should only be called by FCBs that can enter/leave
//		      the avail-LRU list

INLINE VOID FCB::DeferredDecrementRefCount_()
	{
	Assert( PinstFromIfmp( Ifmp() )->m_critFCBList.FOwner() );
	Assert( IsLocked() );
	Assert( FTypeTable() );

	Assert( WRefCount() >= 1 );
	m_wRefCount--;
	Assert( WRefCount() >= 0 );
	}


//	remove this FCB from the avail-LRU list

VOID FCB::RemoveAvailList_( 
#ifdef DEBUG
	const BOOL fPurging
#endif	//	DEBUG
	)
	{
	INST *pinst = PinstFromIfmp( Ifmp() );
	Assert( pinst->m_critFCBList.FOwner() );
	Assert( IsLocked() || fPurging );

	//	trap for bug x5:100491
	AssertRTL( FTypeTable() );

#ifdef DEBUG

	//	verify that the FCB is in the avail list

	AssertFCBAvailList_( fPurging );
#endif	//	DEBUG

	//	get the list pointers

	FCB **ppfcbAvailMRU = pinst->PpfcbAvailMRU( FAboveThreshold() );
	FCB **ppfcbAvailLRU = pinst->PpfcbAvailLRU( FAboveThreshold() );

	//	verify the consistency of the list (it should not be empty)

	Assert( pinst->m_cFCBAvail > 0 );
	Assert( *ppfcbAvailMRU != pfcbNil );
	Assert( *ppfcbAvailLRU != pfcbNil );
	Assert( (*ppfcbAvailMRU)->PfcbMRU() == pfcbNil );
	Assert( (*ppfcbAvailLRU)->PfcbLRU() == pfcbNil );

	//	remove the FCB

	if ( PfcbMRU() != pfcbNil )
		{
		Assert( *ppfcbAvailMRU != this );
		Assert( PfcbMRU()->PfcbLRU() == this );		//	verify that this FCB is in the LRU list
		PfcbMRU()->SetPfcbLRU( PfcbLRU() );
		}
	else
		{
		Assert( *ppfcbAvailMRU == this );			//	verify that this FCB is in the LRU list
		*ppfcbAvailMRU = PfcbLRU();
		}
	if ( PfcbLRU() != pfcbNil )
		{
		Assert( *ppfcbAvailLRU != this );
		Assert( PfcbLRU()->PfcbMRU() == this );		//	verify that this FCB is in the LRU list
		PfcbLRU()->SetPfcbMRU( PfcbMRU() );
		}
	else
		{
		Assert( *ppfcbAvailLRU == this );			//	verify that this FCB is in the LRU list
		*ppfcbAvailLRU = PfcbMRU();
		}
	ResetInLRU();
	SetPfcbMRU( pfcbNil );
	SetPfcbLRU( pfcbNil );
	Assert( pinst->m_cFCBAvail > 0 );
	pinst->m_cFCBAvail--;

	//	update performance counter

	cFCBCacheAllocAvail.Dec( pinst );

	//	verify the consistency of the list (it may be empty)

	Assert( *ppfcbAvailMRU == pfcbNil ||
			(*ppfcbAvailMRU)->PfcbMRU() == pfcbNil );
	Assert( *ppfcbAvailLRU == pfcbNil ||
			(*ppfcbAvailLRU)->PfcbLRU() == pfcbNil );
	}


//	insert this FCB into the avail list at the MRU position

VOID FCB::InsertAvailListMRU_()
	{
	INST *pinst = PinstFromIfmp( Ifmp() );
	Assert( pinst->m_critFCBList.FOwner() );
	Assert( IsLocked() );
	
	//	trap for bug x5:100491
	AssertRTL( FTypeTable() );

	//	get the list pointers

	FCB **ppfcbAvailMRU = pinst->PpfcbAvailMRU( FAboveThreshold() );
	FCB **ppfcbAvailLRU = pinst->PpfcbAvailLRU( FAboveThreshold() );

	//	verify the consistency of the list (it may be empty)

	Assert( *ppfcbAvailMRU == pfcbNil ||
			(*ppfcbAvailMRU)->PfcbMRU() == pfcbNil );
	Assert( *ppfcbAvailLRU == pfcbNil ||
			(*ppfcbAvailLRU)->PfcbLRU() == pfcbNil );

	//	verify that this FCB is not in the LRU list
	
	Assert( !FInLRU() );
	Assert( PfcbMRU() == pfcbNil );
	Assert( PfcbLRU() == pfcbNil );

	//	insert the FCB at the MRU end of the avail list

	if ( *ppfcbAvailMRU != pfcbNil )
		{
		(*ppfcbAvailMRU)->SetPfcbMRU( this );
		}
	//SetPfcbMRU( pfcbNil );
	SetPfcbLRU( *ppfcbAvailMRU );
	*ppfcbAvailMRU = this;
	if ( *ppfcbAvailLRU == pfcbNil )
		{
		*ppfcbAvailLRU = this;
		}
	SetInLRU();
	pinst->m_cFCBAvail++;

	//	update performance counter

	cFCBCacheAllocAvail.Inc( pinst );
	
	//	verify the consistency of the list (it should not be empty)

	Assert( *ppfcbAvailMRU != pfcbNil );
	Assert( *ppfcbAvailLRU != pfcbNil );
	Assert( (*ppfcbAvailMRU)->PfcbMRU() == pfcbNil );
	Assert( (*ppfcbAvailLRU)->PfcbLRU() == pfcbNil );

#ifdef DEBUG

	//	verify that this FCB is in the avail list

	AssertFCBAvailList_();
#endif	//	DEBUG
	}


//	insert this FCB into the global list

VOID FCB::InsertList()
	{
	INST *pinst = PinstFromIfmp( Ifmp() );
	Assert( pinst->m_critFCBList.FNotOwner() );

	//	lock the global list

	pinst->m_critFCBList.Enter();

	//	verify that this FCB is not yet in the list

	Assert( !FInList() );
	Assert( PfcbNextList() == pfcbNil );
	Assert( PfcbPrevList() == pfcbNil );

	//	verify the consistency of the list (it may be empty)

	Assert( pinst->m_pfcbList == pfcbNil ||
			pinst->m_pfcbList->PfcbPrevList() == pfcbNil );

	//	insert the FCB at the MRU end of the avail list

	if ( pinst->m_pfcbList != pfcbNil )
		{
		pinst->m_pfcbList->SetPfcbPrevList( this );
		}
	//SetPfcbPrevList( pfcbNil );
	SetPfcbNextList( pinst->m_pfcbList );
	pinst->m_pfcbList = this;
	SetInList();

	//	verify the consistency of the list (it should not be empty)

	Assert( pinst->m_pfcbList != pfcbNil );
	Assert( pinst->m_pfcbList->PfcbPrevList() == pfcbNil );

	//	unlock the global list

	pinst->m_critFCBList.Leave();
	}


//	remove this FCB from the global list

VOID FCB::RemoveList_()
	{
	INST *pinst = PinstFromIfmp( Ifmp() );
	
	Assert( pinst->m_critFCBList.FOwner() );

	//	verify that this FCB is in the list

	Assert( FInList() );

	//	verify the consistency of the list (it will not be empty)

	Assert( pinst->m_pfcbList != pfcbNil );
	Assert( pinst->m_pfcbList->PfcbPrevList() == pfcbNil );

	//	remove the FCB

	if ( PfcbPrevList() != pfcbNil )
		{
		Assert( pinst->m_pfcbList != this );
		Assert( PfcbPrevList()->PfcbNextList() == this );	//	verify that this FCB is in the list
		PfcbPrevList()->SetPfcbNextList( PfcbNextList() );
		}
	else
		{
		Assert( pinst->m_pfcbList == this );				//	verify that this FCB is in the list
		pinst->m_pfcbList = PfcbNextList();
		}
	if ( PfcbNextList() != pfcbNil )
		{
		Assert( PfcbNextList()->PfcbPrevList() == this );	//	verify that this FCB is in the list
		PfcbNextList()->SetPfcbPrevList( PfcbPrevList() );
		}
	ResetInList();
	SetPfcbNextList( pfcbNil );
	SetPfcbPrevList( pfcbNil );

	//	verify the consistency of the list (it may be empty)

	Assert( pinst->m_pfcbList == pfcbNil ||
			pinst->m_pfcbList->PfcbPrevList() == pfcbNil );
	}


//	re-evaluate and possibly update the avail-LRU list position of this FCB 
//		due to a change in the threshold position of the FCB
//
//	when an FCB gains or loses children FCBs (e.g. secondary index FCBs, 
//		LV FCBs, ...), the avail-LRU list position of the FCB could change;
//		this function is called to check for and handle such a condition
//
//	NOTE: at the time of calling this, FAboveThreshold() reports the current
//		avail-LRU list position, but the FCB has gained/lost children; this
//		gain/loss will show up when we scan the FCB to determine its real
//		avail-LRU list position

VOID FCB::UpdateAvailListPosition()
	{
	INST 	*pinst = PinstFromIfmp( Ifmp() );
	BOOL	fAboveBefore;
	BOOL	fAboveAfter = fFalse;

	Assert( pinst->m_critFCBList.FNotOwner() );

	//	trap for bug x5:100491
	AssertRTL( FTypeTable() );

	//	lock the list

	pinst->m_critFCBList.Enter();

	Lock();
	fAboveBefore = ( FAboveThreshold() ? fTrue : fFalse );
	Unlock();

#ifdef DEBUG
	if ( FInLRU() )
		{

		//	assert the current avail-LRU list position based on the current
		//		FAboveThrehsold() flag
		
		AssertFCBAvailList_();
		}
#endif	//	DEBUG

	//	recalculate the above-threshold flag

	if ( this >= PfcbFCBPreferredThreshold( pinst ) )
		{
		fAboveAfter = fTrue;
		}
	else
		{
		FCB *pfcbT;

		EnterDML();
		for ( pfcbT = PfcbNextIndex(); pfcbT != pfcbNil; pfcbT = pfcbT->PfcbNextIndex() )
			{
			if ( pfcbT >= PfcbFCBPreferredThreshold( pinst ) )
				{
				fAboveAfter = fTrue;
				break;
				}
			}
		if ( Ptdb()->PfcbLV() >= PfcbFCBPreferredThreshold( pinst ) )
			{
			fAboveAfter = fTrue;
			}
		LeaveDML();
		}

	Assert( fTrue == fAboveBefore || fFalse == fAboveBefore );
	Assert( fTrue == fAboveAfter || fFalse == fAboveAfter );
	if ( fAboveAfter == fAboveBefore )
		{

		//	the avail-LRU list position has not changed

		//	unlock the list

		pinst->m_critFCBList.Leave();

		return;
		}

	//	lock the FCB

	Lock();

	//	update the threshold position

	if ( fAboveAfter )
		{
		Assert( !FAboveThreshold() );
		SetAboveThreshold();
		}
	else
		{
		Assert( FAboveThreshold() );
		ResetAboveThreshold();
		}

	//	unlock the FCB

	Unlock();

	//	update the avail-LRU list position (may not be in avail-LRU list)

	if ( FInLRU() )
		{

		//	this FCB is in the LRU list
		//		remove the FCB from its current avail list
		//		insert the FCB into the new avail list


		//	REMOVE FROM OLD LIST -------------------------------

		//	get the list pointers of the current list

		FCB **ppfcbAvailMRU = pinst->PpfcbAvailMRU( fAboveBefore );
		FCB **ppfcbAvailLRU = pinst->PpfcbAvailLRU( fAboveBefore );

		//	verify the consistency of the list (it should not be empty)

		Assert( *ppfcbAvailMRU != pfcbNil );
		Assert( *ppfcbAvailLRU != pfcbNil );
		Assert( (*ppfcbAvailMRU)->PfcbMRU() == pfcbNil );
		Assert( (*ppfcbAvailLRU)->PfcbLRU() == pfcbNil );

		//	remove the FCB

		if ( PfcbMRU() != pfcbNil )
			{
			Assert( *ppfcbAvailMRU != this );
			Assert( PfcbMRU()->PfcbLRU() == this );		//	verify that this FCB is in the LRU list
			PfcbMRU()->SetPfcbLRU( PfcbLRU() );
			}
		else
			{
			Assert( *ppfcbAvailMRU == this );			//	verify that this FCB is in the LRU list
			*ppfcbAvailMRU = PfcbLRU();
			}
		if ( PfcbLRU() != pfcbNil )
			{
			Assert( *ppfcbAvailLRU != this );
			Assert( PfcbLRU()->PfcbMRU() == this );		//	verify that this FCB is in the LRU list
			PfcbLRU()->SetPfcbMRU( PfcbMRU() );
			}
		else
			{
			Assert( *ppfcbAvailLRU == this );			//	verify that this FCB is in the LRU list
			*ppfcbAvailLRU = PfcbMRU();
			}

		//	verify the consistency of the list (it may be empty)

		Assert( *ppfcbAvailMRU == pfcbNil ||
				(*ppfcbAvailMRU)->PfcbMRU() == pfcbNil );
		Assert( *ppfcbAvailLRU == pfcbNil ||
				(*ppfcbAvailLRU)->PfcbLRU() == pfcbNil );


		//	INSERT INTO NEW LIST -------------------------------

		//	get the list pointers of the new list

		ppfcbAvailMRU = pinst->PpfcbAvailMRU( fAboveAfter );
		ppfcbAvailLRU = pinst->PpfcbAvailLRU( fAboveAfter );

		//	verify the consistency of the list (it may be empty)

		Assert( *ppfcbAvailMRU == pfcbNil ||
				(*ppfcbAvailMRU)->PfcbMRU() == pfcbNil );
		Assert( *ppfcbAvailLRU == pfcbNil ||
				(*ppfcbAvailLRU)->PfcbLRU() == pfcbNil );

		//	insert the FCB at the MRU end of the avail list

		if ( *ppfcbAvailMRU != pfcbNil )
			{
			(*ppfcbAvailMRU)->SetPfcbMRU( this );
			}
		SetPfcbMRU( pfcbNil );
		SetPfcbLRU( *ppfcbAvailMRU );
		*ppfcbAvailMRU = this;
		if ( *ppfcbAvailLRU == pfcbNil )
			{
			*ppfcbAvailLRU = this;
			}

		//	verify the consistency of the list (it should not be empty)

		Assert( *ppfcbAvailMRU != pfcbNil );
		Assert( *ppfcbAvailLRU != pfcbNil );
		Assert( (*ppfcbAvailMRU)->PfcbMRU() == pfcbNil );
		Assert( (*ppfcbAvailLRU)->PfcbLRU() == pfcbNil );

#ifdef DEBUG
		//	verify the avail list position

		AssertFCBAvailList_();
#endif	//	DEBUG
		}

	//	unlock the list

	pinst->m_critFCBList.Leave();
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\fcreate.cxx ===
#include "std.hxx"

///#define SHOW_INDEX_PERF
#ifdef SHOW_INDEX_PERF
const OSTraceLevel	ostlIndexPerf	= ostlLow;
#endif

// UNDONE:  TEMPORARY HACK to get around unversioned AddColumn/CreateIndex.

CCriticalSection	critUnverCol( CLockBasicInfo( CSyncBasicInfo( szFILEUnverCol ), rankFILEUnverCol, 0 ) );
CCriticalSection	critUnverIndex( CLockBasicInfo( CSyncBasicInfo( szFILEUnverIndex ), rankFILEUnverIndex, 0 ) );

struct UNVER_DDL
	{
	AGENT		agentUnverDDL;
	OBJID		objidTable;
	CHAR		szName[JET_cbNameMost+4];	// +1 for null-terminator, +3 for 4-byte alignment
	UNVER_DDL	*punverNext;
	};

UNVER_DDL	*punvercolGlobal = NULL;
UNVER_DDL	*punveridxGlobal = NULL;


//  ================================================================
ERR ErrFILEGetPfieldAndEnterDML(
	PIB			* ppib,
	FCB			* pfcb,
	const CHAR	* szColumnName,
	FIELD		** ppfield,
	COLUMNID	* pcolumnid,
	BOOL		* pfColumnWasDerived,
	const BOOL	fLockColumn )
//  ================================================================
	{
	ERR			err;

	*pfColumnWasDerived = fFalse;

	//	CONSIDER: Look in template table first because we don't
	//	have to grab DML/DDL latch (since DDL is fixed).  However,
	//	we used to do this, but we found that for Exchange,
	//	GetTableColumnInfo() calls would be very expensive because
	//	it is typically only called for derived columns and we
	//	first end up searching the 400+ columns of the template
	//	table

	//	WARNING: This function does a EnterDML() for the derived table only
	//	and stays in the latch if the requested field is found.  If the
	//	field is in the template table, the latch is not held.

	if ( fLockColumn )
		{
		Assert( ppib->level > 0 );
		Assert( !pfcb->Ptdb()->FTemplateTable() );
		Assert( !pfcb->FDomainDenyReadByUs( ppib ) );

		err = ErrCATAccessTableColumn(
					ppib,
					pfcb->Ifmp(),
					pfcb->ObjidFDP(),
					szColumnName,
					pcolumnid,
					fTrue );			//	read-lock the column in the catalog to ensure it doesn't disappear
		if ( err < 0 )
			{
			if ( JET_errColumnNotFound != err )
				return err;

			//	force retrieval from template table
			*ppfield = pfieldNil;
			err = JET_errSuccess;
			}
		else
			{
			CallS( err );	//	warnings not expected

			//	shouldn't be a template table if it needs,
			//	to be locked, and besides, we don't persist
			//	the template bit anyways
			Assert( !FCOLUMNIDTemplateColumn( *pcolumnid ) );
			Assert( !*pfColumnWasDerived );

			pfcb->EnterDML();
			*ppfield = pfcb->Ptdb()->Pfield( *pcolumnid );
			}
		}
	else
		{
		pfcb->EnterDML();

		//	WARNING: The following function does a LeaveDML() on error
		CallR( ErrFILEPfieldFromColumnName(
					ppib,
					pfcb,
					szColumnName,
					ppfield,
					pcolumnid ) );

			//	not expecting warnings
		CallS( err );

		if ( pfieldNil == *ppfield )
			pfcb->LeaveDML();
		}

	CallS( err );

	if ( pfieldNil == *ppfield )
		{
		FCB		* const pfcbTemplate	= pfcb->Ptdb()->PfcbTemplateTable();
		if ( pfcbNil != pfcbTemplate )
			{
			pfcb->Ptdb()->AssertValidDerivedTable();
			CallS( ErrFILEPfieldFromColumnName(
						ppib,
						pfcbTemplate,
						szColumnName,
						ppfield,
						pcolumnid ) );
			}

		if ( pfieldNil != *ppfield )
			{
			//	must have found it in the template table
			Assert( pfcbNil != pfcbTemplate );
			Assert( FCOLUMNIDTemplateColumn( *pcolumnid ) );
			*pfColumnWasDerived = fTrue;
			}
		else
			{
			err = ErrERRCheck( JET_errColumnNotFound );
			}
		}
	else if ( FCOLUMNIDTemplateColumn( *pcolumnid ) )
		{
		Assert( pfcb->FTemplateTable() );
		pfcb->Ptdb()->AssertValidTemplateTable();
		}

	return err;
	}


LOCAL BOOL FFILEIUnverColumnExists(
	TDB			*ptdb,
	const FID	fidFirst,
	const FID	fidLast,
	const CHAR	*szColumnName )
	{
	Assert( fidFirst == ptdb->FidFixedFirst()
		|| fidFirst == ptdb->FidVarFirst()
		|| fidFirst == ptdb->FidTaggedFirst() );

	if ( fidLast >= fidFirst )
		{
		const STRHASH strhash = StrHashValue( szColumnName );
		FIELD	*pfield;
		FIELD	*pfieldLast = ptdb->Pfield( ColumnidOfFid( fidLast, ptdb->FTemplateTable() ) );

		Assert( pfieldLast >= ptdb->Pfield( ColumnidOfFid( fidFirst, ptdb->FTemplateTable() ) ) );
		for ( pfield = ptdb->Pfield( ColumnidOfFid( fidFirst, ptdb->FTemplateTable() ) );
			pfield <= pfieldLast;
			pfield++ )
			{
			if ( !FFIELDVersioned( pfield->ffield ) && !FFIELDDeleted( pfield->ffield ) )
				{
				if (	strhash == pfield->strhashFieldName &&
						!UtilCmpName( szColumnName, ptdb->SzFieldName( pfield->itagFieldName, fFalse ) ) )
					{
					return fTrue;
					}
				}
			}
		}

	return fFalse;
	}

INLINE BOOL FFILEUnverColumnExists( FCB *pfcb, const CHAR *szColumnName )
	{
	TDB			*ptdb			= pfcb->Ptdb();
	BOOL		fExists			= fFalse;

	pfcb->EnterDML();

	fExists = FFILEIUnverColumnExists(
							ptdb,
							ptdb->FidTaggedFirst(),
							ptdb->FidTaggedLast(),
							szColumnName )
			|| FFILEIUnverColumnExists(
							ptdb,
							ptdb->FidFixedFirst(),
							ptdb->FidFixedLast(),
							szColumnName )
			|| FFILEIUnverColumnExists(
							ptdb,
							ptdb->FidVarFirst(),
							ptdb->FidVarLast(),
							szColumnName );

	pfcb->LeaveDML();

	return fExists;
	}


INLINE ERR ErrFILEInsertIntoUnverColumnList( FCB *pfcbTable, const CHAR *szColumnName )
	{
	ERR			err			= JET_errSuccess;
	const OBJID	objidTable	= pfcbTable->ObjidFDP();
	UNVER_DDL	*punvercol;

	critUnverCol.Enter();

FindColumn:
	for ( punvercol = punvercolGlobal; NULL != punvercol; punvercol = punvercol->punverNext )
		{
		if ( objidTable == punvercol->objidTable
			&& 0 == UtilCmpName( punvercol->szName, szColumnName ) )
			{
			punvercol->agentUnverDDL.Wait( critUnverCol );

			if ( FFILEUnverColumnExists( pfcbTable, szColumnName ) )
				{
				critUnverCol.Leave();
				err = ErrERRCheck( JET_errColumnDuplicate );
				return err;
				}
			goto FindColumn;
			}
		}

	punvercol = (UNVER_DDL *)PvOSMemoryHeapAlloc( sizeof( UNVER_DDL ) );
	if ( NULL == punvercol )
		err = ErrERRCheck( JET_errOutOfMemory );
	else
		{
		memset( (BYTE *)punvercol, 0, sizeof( UNVER_DDL ) );
		new( &punvercol->agentUnverDDL ) AGENT;
		punvercol->objidTable = objidTable;
		Assert( strlen( szColumnName ) <= JET_cbNameMost );
		strcpy( punvercol->szName, szColumnName );
		punvercol->punverNext = punvercolGlobal;
		punvercolGlobal = punvercol;
		}

	critUnverCol.Leave();

	return err;
	}

INLINE BOOL FFILEUnverIndexExists( FCB *pfcbTable, const CHAR *szIndexName )
	{
	TDB		*ptdb = pfcbTable->Ptdb();
	FCB		*pfcb;
	BOOL	fExists = fFalse;

	pfcbTable->EnterDML();

	for ( pfcb = pfcbTable; pfcbNil != pfcb; pfcb = pfcb->PfcbNextIndex() )
		{
		const IDB	* const pidb	= pfcb->Pidb();
		if ( pidbNil != pidb && !pidb->FDeleted() )
			{
			if ( UtilCmpName(
					szIndexName,
					ptdb->SzIndexName( pidb->ItagIndexName(), pfcb->FDerivedIndex() ) ) == 0 )
				{
				fExists = fTrue;
				break;
				}
			}
		}

	pfcbTable->LeaveDML();

	return fExists;
	}

INLINE ERR ErrFILEInsertIntoUnverIndexList( FCB *pfcbTable, const CHAR *szIndexName )
	{
	ERR			err			= JET_errSuccess;
	const OBJID	objidTable	= pfcbTable->ObjidFDP();
	UNVER_DDL	*punveridx;

	critUnverIndex.Enter();

FindIndex:
	for ( punveridx = punveridxGlobal; NULL != punveridx; punveridx = punveridx->punverNext )
		{
		if ( objidTable == punveridx->objidTable
			&& 0 == UtilCmpName( punveridx->szName, szIndexName ) )
			{
			punveridx->agentUnverDDL.Wait( critUnverIndex );

			if ( FFILEUnverIndexExists( pfcbTable, szIndexName ) )
				{
				critUnverIndex.Leave();
				err = ErrERRCheck( JET_errIndexDuplicate );
				return err;
				}
			goto FindIndex;
			}
		}

	punveridx = (UNVER_DDL *)PvOSMemoryHeapAlloc( sizeof( UNVER_DDL ) );
	if ( NULL == punveridx )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		}
	else
		{
		memset( (BYTE *)punveridx, 0, sizeof( UNVER_DDL ) );
		new( &punveridx->agentUnverDDL ) AGENT;
		punveridx->objidTable = objidTable;
		Assert( strlen( szIndexName ) <= JET_cbNameMost );
		strcpy( punveridx->szName, szIndexName );
		punveridx->punverNext = punveridxGlobal;
		punveridxGlobal = punveridx;
		}

	critUnverIndex.Leave();

	return err;
	}


LOCAL VOID FILERemoveFromUnverList(
	UNVER_DDL	**ppunverGlobal,
	CCriticalSection&		critUnver,
	const OBJID	objidTable,
	const CHAR	*szName )
	{
	UNVER_DDL	**ppunver;

	critUnver.Enter();

	Assert( NULL != *ppunverGlobal );
	for ( ppunver = ppunverGlobal; *ppunver != NULL; ppunver = &( (*ppunver)->punverNext ) )
		{
		if ( objidTable == (*ppunver)->objidTable
			&& 0 == UtilCmpName( (*ppunver)->szName, szName ) )
			{
			UNVER_DDL	*punverToRemove;
			(*ppunver)->agentUnverDDL.Release( critUnver );
			punverToRemove = *ppunver;
			*ppunver = (*ppunver)->punverNext;
			punverToRemove->agentUnverDDL.~AGENT();
			OSMemoryHeapFree( punverToRemove );
			critUnver.Leave();
			return;
			}
		}

	Assert( fFalse );
	critUnver.Leave();
	}


ERR VTAPI ErrIsamCreateTable2( JET_SESID vsesid, JET_DBID vdbid, JET_TABLECREATE2 *ptablecreate )
	{
	ERR				err;
	PIB				*ppib = (PIB *)vsesid;
	FUCB 			*pfucb;
	IFMP			ifmp = (IFMP) vdbid;

	//	check parameters
	//
	CallR( ErrPIBCheck( ppib ) );

	if ( ifmp >= ifmpMax || dbidTemp == rgfmp[ ifmp ].Dbid() )
		{
		err = ErrERRCheck( JET_errInvalidDatabaseId );
		return err;
		}

	// UNDONE: Supported nesting of hierarchical DDL.
	if ( ptablecreate->grbit & JET_bitTableCreateTemplateTable )
		{
		if ( ptablecreate->szTemplateTableName != NULL )
			{
			err = ErrERRCheck( JET_errCannotNestDDL );
			return err;
			}
		}
	else if ( ptablecreate->grbit & JET_bitTableCreateNoFixedVarColumnsInDerivedTables )
		{
		//	this grbit must be used in conjunction with JET_bitTableCreateTemplateTable
		err = ErrERRCheck( JET_errInvalidGrbit );
		return err;
		}

	if ( ptablecreate->grbit & JET_bitTableCreateSystemTable )		//	internal use only
		{
		err = ErrERRCheck( JET_errInvalidGrbit );
		return err;
		}

	//	create the table, and open it
	//
	CallR( ErrFILECreateTable( ppib, ifmp, ptablecreate ) );
	pfucb = (FUCB *)(ptablecreate->tableid);
	pfucb->pvtfndef = &vtfndefIsam;

	Assert( ptablecreate->cCreated <= 1 + ptablecreate->cColumns + ptablecreate->cIndexes + ( ptablecreate->szCallback ? 1 : 0 ) );

	return err;
	}


//  ================================================================
ERR VTAPI ErrIsamCreateTable( JET_SESID vsesid, JET_DBID vdbid, JET_TABLECREATE *ptablecreate )
//  ================================================================
	{
	Assert( ptablecreate );

	JET_TABLECREATE2 tablecreate;

	tablecreate.cbStruct 				= sizeof( JET_TABLECREATE2 );
	tablecreate.szTableName				= ptablecreate->szTableName;
	tablecreate.szTemplateTableName		= ptablecreate->szTemplateTableName;
	tablecreate.ulPages					= ptablecreate->ulPages;
	tablecreate.ulDensity				= ptablecreate->ulDensity;
	tablecreate.rgcolumncreate			= ptablecreate->rgcolumncreate;
	tablecreate.cColumns				= ptablecreate->cColumns;
	tablecreate.rgindexcreate			= ptablecreate->rgindexcreate;
	tablecreate.cIndexes				= ptablecreate->cIndexes;
	tablecreate.szCallback				= NULL;
	tablecreate.cbtyp					= 0;
	tablecreate.grbit					= ptablecreate->grbit;
	tablecreate.tableid					= ptablecreate->tableid;
	tablecreate.cCreated				= ptablecreate->cCreated;

	const ERR err = ErrIsamCreateTable2( vsesid, vdbid, &tablecreate );

	ptablecreate->tableid 	= tablecreate.tableid;
	ptablecreate->cCreated 	= tablecreate.cCreated;

	return err;
	}


//	return fTrue if the column type specified has a fixed length
//
INLINE BOOL FCOLTYPFixedLength( JET_COLTYP coltyp )
	{
	switch( coltyp )
		{
		case JET_coltypBit:
		case JET_coltypUnsignedByte:
		case JET_coltypShort:
		case JET_coltypLong:
		case JET_coltypCurrency:
		case JET_coltypIEEESingle:
		case JET_coltypIEEEDouble:
		case JET_coltypDateTime:
			return fTrue;

		default:
			return fFalse;
		}
	}


LOCAL ERR ErrFILEIScanForColumnName(
	PIB				*ppib,
	FCB				*pfcb,
	const CHAR		*szColumnName,
	FIELD			**ppfield,
	COLUMNID		*pcolumnid,
	const COLUMNID	columnidLastInitial,
	const COLUMNID	columnidLast )
	{
	ERR				err;
	TDB				*ptdb		= pfcb->Ptdb();
	FIELD			*pfield;
	const STRHASH	strhash		= StrHashValue( szColumnName );
	const BOOL		fDerived	= fFalse;		//	only looking at columns in this TDB (ie. no derived columns)

	Assert( FidOfColumnid( *pcolumnid ) == ptdb->FidFixedFirst()
		|| FidOfColumnid( *pcolumnid ) == ptdb->FidVarFirst()
		|| FidOfColumnid( *pcolumnid ) == ptdb->FidTaggedFirst() );

	Assert( pfieldNil == *ppfield );

	pfcb->AssertDML();

	Assert( FidOfColumnid( columnidLast ) >= FidOfColumnid( *pcolumnid ) );

	for ( pfield = ptdb->Pfield( *pcolumnid );
		*pcolumnid <= columnidLast;
		pfield++, (*pcolumnid)++ )
		{
		if ( *pcolumnid == columnidLastInitial + 1 )
			{
			//	refresh in case the FIELD structures were
			//	partitioned into initial/dynamic fields
			pfield = ptdb->Pfield( *pcolumnid );
			}

		Assert( !pfcb->FFixedDDL() || !FFIELDVersioned( pfield->ffield ) );
		if ( !FFIELDCommittedDelete( pfield->ffield ) )
			{
			Assert( JET_coltypNil != pfield->coltyp );
			Assert( 0 != pfield->itagFieldName );
			if ( strhash == pfield->strhashFieldName
				&& 0 == UtilCmpName( szColumnName, ptdb->SzFieldName( pfield->itagFieldName, fDerived ) ) )
				{
				if ( FFIELDVersioned( pfield->ffield ) )
					{
					COLUMNID	columnidT;

					pfcb->LeaveDML();

					//	no versioned operations on template table
					Assert( !ptdb->FTemplateTable() );
					Assert( !FCOLUMNIDTemplateColumn( *pcolumnid ) );

					//	must consult catalog.
					CallR( ErrCATAccessTableColumn(
								ppib,
								pfcb->Ifmp(),
								pfcb->ObjidFDP(),
								szColumnName,
								&columnidT ) );
					CallS( err );		//	shouldn't return warnings.

					pfcb->EnterDML();

					//	WARNING: the columnid returned
					//	from the catalog lookup (columnidT)
					//	may be different from the original
					//	columnid (*pcolumnid) if the column
					//	got deleted then re-added with the
					//	same name
					*pcolumnid = columnidT;

					*ppfield = ptdb->Pfield( columnidT );
					}
				else
					{
					Assert( !FFIELDDeleted( pfield->ffield ) );
					Assert( ptdb->Pfield( *pcolumnid ) == pfield );
					*ppfield = pfield;
					}

				Assert( pfieldNil != *ppfield );
				return JET_errSuccess;
				}
			}
		}

	Assert( pfieldNil == *ppfield );	// Scan was successful, but seek failed.
	return JET_errSuccess;
	}

ERR ErrFILEPfieldFromColumnName(
	PIB			*ppib,
	FCB			*pfcb,
	const CHAR	*szColumnName,
	FIELD		**ppfield,
	COLUMNID	*pcolumnid )
	{
	ERR			err;
	TDB			*ptdb			= pfcb->Ptdb();
	const BOOL	fTemplateTable	= ptdb->FTemplateTable();

	pfcb->AssertDML();

	*ppfield = pfieldNil;

	if ( ptdb->FidTaggedLast() >= ptdb->FidTaggedFirst() )
		{
		*pcolumnid = ColumnidOfFid( ptdb->FidTaggedFirst(), fTemplateTable );
		CallR( ErrFILEIScanForColumnName(
					ppib,
					pfcb,
					szColumnName,
					ppfield,
					pcolumnid,
					ColumnidOfFid( ptdb->FidTaggedLastInitial(), fTemplateTable ),
					ColumnidOfFid( ptdb->FidTaggedLast(), fTemplateTable ) ) );

		if ( pfieldNil != *ppfield )
			return JET_errSuccess;
		}


	if ( ptdb->FidFixedLast() >= ptdb->FidFixedFirst() )
		{
		*pcolumnid = ColumnidOfFid( ptdb->FidFixedFirst(), fTemplateTable );
		CallR( ErrFILEIScanForColumnName(
					ppib,
					pfcb,
					szColumnName,
					ppfield,
					pcolumnid,
					ColumnidOfFid( ptdb->FidFixedLastInitial(), fTemplateTable ),
					ColumnidOfFid( ptdb->FidFixedLast(), fTemplateTable ) ) );

		if ( pfieldNil != *ppfield )
			return JET_errSuccess;
		}

	if ( ptdb->FidVarLast() >= ptdb->FidVarFirst() )
		{
		*pcolumnid = ColumnidOfFid( ptdb->FidVarFirst(), fTemplateTable );
		CallR( ErrFILEIScanForColumnName(
					ppib,
					pfcb,
					szColumnName,
					ppfield,
					pcolumnid,
					ColumnidOfFid( ptdb->FidVarLastInitial(), fTemplateTable ),
					ColumnidOfFid( ptdb->FidVarLast(), fTemplateTable ) ) );
		}

	return JET_errSuccess;
	}


LOCAL BOOL FFILEIColumnExists(
	const TDB * const	ptdb,
	const CHAR * const	szColumn,
	const FIELD * const	pfieldStart,
	const ULONG			cfields )
	{
	const STRHASH		strhash		= StrHashValue( szColumn );
	const FIELD * const	pfieldMax	= pfieldStart + cfields;

	//	caller ensures there must be at least one column
	Assert( pfieldNil != pfieldStart );
	Assert( pfieldStart < pfieldMax );

	for ( const FIELD * pfield = pfieldStart; pfield < pfieldMax; pfield++ )
		{
		//	field may have been marked as deleted if an AddColumn rolled back
		if ( !FFIELDDeleted( pfield->ffield )
			&& ( strhash == pfield->strhashFieldName )
			&& ( 0 == UtilCmpName( szColumn, ptdb->SzFieldName( pfield->itagFieldName, fFalse ) ) ) )
			{
			return fTrue;
			}
		}

	return fFalse;
	}

LOCAL BOOL FFILEITemplateTableColumn(
	const FCB * const	pfcbTemplateTable,
	const CHAR * const	szColumn )
	{
	Assert( pfcbNil != pfcbTemplateTable );
	Assert( pfcbTemplateTable->FTemplateTable() );
	Assert( pfcbTemplateTable->FFixedDDL() );

	const TDB * const	ptdbTemplateTable	= pfcbTemplateTable->Ptdb();
	Assert( ptdbTemplateTable != ptdbNil );
	ptdbTemplateTable->AssertValidTemplateTable();

	const ULONG			cInitialCols		= ptdbTemplateTable->CInitialColumns();
	const ULONG			cDynamicCols		= ptdbTemplateTable->CDynamicColumns();

	if ( cInitialCols > 0 )
		{
		if ( FFILEIColumnExists(
					ptdbTemplateTable,
					szColumn,
					ptdbTemplateTable->PfieldsInitial(),
					cInitialCols ) )
			return fTrue;
		}

	if ( cDynamicCols > 0 )
		{
		//	shouldn't be any dynamic columns in the template table
		Assert( fFalse );

		if ( FFILEIColumnExists(
					ptdbTemplateTable,
					szColumn,
					(FIELD *)ptdbTemplateTable->MemPool().PbGetEntry( itagTDBFields ),
					cDynamicCols ) )
			return fTrue;
		}

	return fFalse;
	}

LOCAL BOOL FFILEITemplateTableIndex( const FCB * const pfcbTemplateTable, const CHAR *szIndex )
	{
	Assert( pfcbNil != pfcbTemplateTable );
	Assert( pfcbTemplateTable->FTemplateTable() );
	Assert( pfcbTemplateTable->FFixedDDL() );

	const TDB	* const ptdbTemplateTable = pfcbTemplateTable->Ptdb();
	Assert( ptdbTemplateTable != ptdbNil );

	const FCB	*pfcbIndex;
	for ( pfcbIndex = pfcbTemplateTable;
		pfcbIndex != pfcbNil;
		pfcbIndex = pfcbIndex->PfcbNextIndex() )
		{
		const IDB	* const pidb = pfcbIndex->Pidb();
		if ( pfcbIndex == pfcbTemplateTable )
			{
			Assert( pidbNil == pidb || pidb->FPrimary() );
			}
		else
			{
			Assert( pfcbIndex->FTypeSecondaryIndex() );
			Assert( pidbNil != pidb );
			Assert( !pidb->FPrimary() );
			}
		if ( pidbNil != pidb
			&& UtilCmpName( szIndex, ptdbTemplateTable->SzIndexName( pidb->ItagIndexName() ) ) == 0 )
			{
			return fTrue;
			}
		}

	return fFalse;
	}


LOCAL ERR ErrFILEIValidateAddColumn(
	const CHAR		*szName,
	CHAR			*szColumnName,
	FIELD			*pfield,
	const JET_GRBIT	grbit,
	const INT		cbDefaultValue,
	const BOOL		fExclusiveLock,
	FCB				*pfcbTemplateTable )
	{
	ERR				err;
	const	BOOL	fDefaultValue = ( cbDefaultValue > 0 );

	pfield->ffield = 0;

	// Duplicate column names will get detected when catalog
	// insertion is attempted.
	CallR( ErrUTILCheckName( szColumnName, szName, ( JET_cbNameMost + 1 ) ) );
	if ( pfcbNil != pfcbTemplateTable
		&& FFILEITemplateTableColumn( pfcbTemplateTable, szColumnName ) )
		{
		err = ErrERRCheck( JET_errColumnDuplicate );
		return err;
		}


//	OLD
//	if ( pfield->coltyp == 0 || pfield->coltyp > JET_coltypLongText )
// 	NEW - because of the new column type
	if ( pfield->coltyp == 0 || pfield->coltyp >= JET_coltypMax )
		{
		return ErrERRCheck( JET_errInvalidColumnType );
		}

	//	if column type is text then check code page
	//
	if ( FRECTextColumn( pfield->coltyp ) )
		{
		//	check code page
		//
		if ( 0 == pfield->cp )
			{
			//	force text column to always have a code page
			pfield->cp = usEnglishCodePage;
			}
		else if ( pfield->cp != usEnglishCodePage && pfield->cp != usUniCodePage )
			{
			return ErrERRCheck( JET_errInvalidCodePage );
			}
		}
	else
		pfield->cp = 0;

	// check conflicting Tagged column options
	if ( grbit & JET_bitColumnTagged || FRECLongValue( pfield->coltyp ) || FRECSLV( pfield->coltyp ) )
		{
		if ( grbit & JET_bitColumnNotNULL )
			return ErrERRCheck( JET_errTaggedNotNULL );

		if ( grbit & JET_bitColumnFixed )
			return ErrERRCheck( JET_errInvalidGrbit );

		if ( fDefaultValue && FRECSLV( pfield->coltyp ) )
			return ErrERRCheck( JET_errSLVColumnDefaultValueNotAllowed );
		}
	else if ( grbit & JET_bitColumnMultiValued )
		{
		return ErrERRCheck( JET_errMultiValuedColumnMustBeTagged );
		}

	if ( grbit & JET_bitColumnEscrowUpdate )
		{
		//  Escrow columns can be updated by different sessions in a concurrent fashion
		//  in order for that to be possible the column must always be present in the record
		//  otherwise we will end up in a situation where a column must be inserted into the
		//  record before we escrow it. It would be extremely difficult to insert a column
		//  into a record concurrently (a replace would be required).
		//
		//  Thus, Escrow columns _must_ have a default value and must be fixed so that they
		//  will be burst into any new records. One alternative is to disallow default values
		//  for escrow columns so that they will have to be set before they can be escrowed --
		//  that would probably reduce their usefullness though..
		//
		//  This also means that an escrow column cannot be added to a table with any records
		//  aleady in it because the column will not be present in those records (the alternative
		//  is to syncronously insert the default-value of the column into all of the records).
		if ( pfield->coltyp != JET_coltypLong )
			return ErrERRCheck( JET_errInvalidGrbit );
		if ( grbit & JET_bitColumnTagged )
			return ErrERRCheck( JET_errCannotBeTagged );
		if ( grbit & JET_bitColumnVersion )
			return ErrERRCheck( JET_errInvalidGrbit );
		if ( grbit & JET_bitColumnAutoincrement )
			return ErrERRCheck( JET_errInvalidGrbit );

		if ( !fDefaultValue )
			return ErrERRCheck( JET_errInvalidGrbit );

		if ( !fExclusiveLock )
			return ErrERRCheck( JET_errExclusiveTableLockRequired );

		FIELDSetEscrowUpdate( pfield->ffield );
		if ( grbit & JET_bitColumnFinalize )
			{
			FIELDSetFinalize( pfield->ffield );
			}
		if ( grbit & JET_bitColumnDeleteOnZero )
			{
			FIELDSetDeleteOnZero( pfield->ffield );
			}
		}
	else if ( grbit & (JET_bitColumnFinalize|JET_bitColumnDeleteOnZero) )
		{
		return ErrERRCheck( JET_errInvalidGrbit );
		}
	else if ( grbit & (JET_bitColumnVersion|JET_bitColumnAutoincrement) )
		{
		//	if any special column properties have been set,
		//	then check parameters and set column attributes.
		//
		if ( grbit & JET_bitColumnAutoincrement )
			{
			if ( pfield->coltyp != JET_coltypLong && pfield->coltyp != JET_coltypCurrency )
				return ErrERRCheck( JET_errInvalidGrbit );
			}
		else if ( pfield->coltyp != JET_coltypLong )
			return ErrERRCheck( JET_errInvalidGrbit );

		if ( grbit & JET_bitColumnTagged )
			return ErrERRCheck( JET_errCannotBeTagged );

		if ( grbit & JET_bitColumnVersion )
			{
			if ( grbit & (JET_bitColumnAutoincrement|JET_bitColumnEscrowUpdate) )
				return ErrERRCheck( JET_errInvalidGrbit );
			FIELDSetVersion( pfield->ffield );
			}

		else if ( grbit & JET_bitColumnAutoincrement )
			{
			Assert( !( grbit & JET_bitColumnVersion ) );
			if ( grbit & JET_bitColumnEscrowUpdate )
				return ErrERRCheck( JET_errInvalidGrbit );

			// For AutoInc or EscrowUpdate columns, we first need
			// exclusive use of the table.
			if ( !fExclusiveLock )
				return ErrERRCheck( JET_errExclusiveTableLockRequired );

			FIELDSetAutoincrement( pfield->ffield );
			}
		}

	//  Check FOR user-defined default value
	if( grbit & JET_bitColumnUserDefinedDefault )
		{
		if( grbit & JET_bitColumnFixed )
			return ErrERRCheck( JET_errInvalidGrbit );
		if( grbit & JET_bitColumnNotNULL )
			return ErrERRCheck( JET_errInvalidGrbit );
		if( grbit & JET_bitColumnVersion )
			return ErrERRCheck( JET_errInvalidGrbit );
		if( grbit & JET_bitColumnAutoincrement )
			return ErrERRCheck( JET_errInvalidGrbit );
		if( grbit & JET_bitColumnUpdatable )
			return ErrERRCheck( JET_errInvalidGrbit );
		if( grbit & JET_bitColumnEscrowUpdate )
			return ErrERRCheck( JET_errInvalidGrbit );
		if( grbit & JET_bitColumnFinalize )
			return ErrERRCheck( JET_errInvalidGrbit );
		if( grbit & JET_bitColumnDeleteOnZero )
			return ErrERRCheck( JET_errInvalidGrbit );
		if( grbit & JET_bitColumnMaybeNull )
			return ErrERRCheck( JET_errInvalidGrbit );

		//  The column must be tagged. If it is fixed/variable
		//  we may have to copy the default value into the record
		//  this won't work for calculated defaults
		if( !( grbit & JET_bitColumnTagged )
			&& !FRECLongValue( pfield->coltyp ) )
			return ErrERRCheck( JET_errInvalidGrbit );

		if( sizeof( JET_USERDEFINEDDEFAULT ) != cbDefaultValue )
			return ErrERRCheck( JET_errInvalidParameter );

		//	SLV's should have been caught above by the tagged column check
		Assert( !FRECSLV( pfield->coltyp ) );

		FIELDSetUserDefinedDefault( pfield->ffield );
		}

	if ( grbit & JET_bitColumnNotNULL )
		{
		FIELDSetNotNull( pfield->ffield );
		}

	if ( grbit & JET_bitColumnMultiValued )
		{
		FIELDSetMultivalued( pfield->ffield );
		}

	if ( fDefaultValue )
		{
		FIELDSetDefault( pfield->ffield );
		}

	BOOL	fMaxTruncated = fFalse;
	pfield->cbMaxLen = UlCATColumnSize( pfield->coltyp, pfield->cbMaxLen, &fMaxTruncated );

	return ( fMaxTruncated ? ErrERRCheck( JET_wrnColumnMaxTruncated ) : JET_errSuccess );
	}


//  ================================================================
LOCAL ERR ErrFILEIAddColumns(
	PIB					* const ppib,
	const IFMP			ifmp,
	JET_TABLECREATE2	* const ptablecreate,
	const OBJID			objidTable,
	FCB					* const pfcbTemplateTable )
//  ================================================================
//
//  User-defined-default columns can be dependant on other columns
//  we need to know the columnids of all the normal columns in order
//  to be able to create user-defined-default columns. We make two
//  passes through the columns to do this -- once for the normal ones
//  and once for the user-defined defaults
//
//  OPTIMIZATION: on the first pass note if there are any user-defined defaults
//  and only make the second pass if there are
//
//-
	{
	ERR					err;
	FUCB				*pfucbCatalog		= pfucbNil;
	CHAR				szColumnName[ JET_cbNameMost+1 ];
	JET_COLUMNCREATE	*pcolcreate;
	JET_COLUMNCREATE	*plastcolcreate;
	BOOL				fSetColumnError 	= fFalse;
	TCIB				tcib				= { fidFixedLeast-1, fidVarLeast-1, fidTaggedLeast-1 };
	USHORT				ibNextFixedOffset	= ibRECStartFixedColumns;
	FID					fidVersion			= 0;
	FID					fidAutoInc			= 0;
	const BOOL			fTemplateTable		= ( ptablecreate->grbit & JET_bitTableCreateTemplateTable );

	Assert( rgfmp[ ifmp ].Dbid() != dbidTemp );

	//	table has been created
	Assert( 1 == ptablecreate->cCreated );

	if ( ptablecreate->rgcolumncreate == NULL )
		{
		err = ErrERRCheck( JET_errInvalidParameter );
		return err;
		}

	if ( pfcbNil != pfcbTemplateTable )
		{
		TDB	*ptdbTemplateTable = pfcbTemplateTable->Ptdb();

		Assert( pfcbTemplateTable->FTemplateTable() );
		Assert( pfcbTemplateTable->FFixedDDL() );
		ptdbTemplateTable->AssertValidTemplateTable();

		// Can't have same fidAutoInc and fidVersion.
		fidAutoInc = ptdbTemplateTable->FidAutoincrement();
		Assert( 0 == fidAutoInc || ptdbTemplateTable->FidVersion() != fidAutoInc );

		fidVersion = ptdbTemplateTable->FidVersion();
		Assert( 0 == fidVersion || ptdbTemplateTable->FidAutoincrement() != fidVersion );

		//	fixed and variable columns continue column space started by template table
		//	tagged columns start their own column space
		tcib.fidFixedLast = ptdbTemplateTable->FidFixedLast();
		tcib.fidVarLast = ptdbTemplateTable->FidVarLast();
		ibNextFixedOffset = ptdbTemplateTable->IbEndFixedColumns();
		}

	Assert( fidTaggedLeast-1 == tcib.fidTaggedLast );

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	Assert( ptablecreate->rgcolumncreate != NULL );

	plastcolcreate = ptablecreate->rgcolumncreate + ptablecreate->cColumns;


#ifdef ACCOUNT_FOR_CALLBACK_DEPENDENCIES
	for ( pcolcreate = ptablecreate->rgcolumncreate;
		pcolcreate < plastcolcreate;
		pcolcreate++ )
		{
		Assert( pcolcreate != NULL );
		Assert( pcolcreate < ptablecreate->rgcolumncreate + ptablecreate->cColumns );

		//  this is the data that will actually be inserted into the catalog
		const VOID		*pvDefaultAdd 	= NULL;
		ULONG			cbDefaultAdd 	= 0;
		CHAR			*szCallbackAdd 	= NULL;
		const VOID		*pvUserDataAdd 	= NULL;
		ULONG			cbUserDataAdd 	= 0;

		if ( pcolcreate->cbStruct != sizeof(JET_COLUMNCREATE) )
			{
			err = ErrERRCheck( JET_errInvalidParameter );
			goto HandleError;
			}

		pvDefaultAdd = pcolcreate->pvDefault;
		cbDefaultAdd = pcolcreate->cbDefault;

		FIELD			field;
		memset( &field, 0, sizeof(FIELD) );
		field.coltyp = FIELD_COLTYP( pcolcreate->coltyp );
		field.cbMaxLen = pcolcreate->cbMax;
		field.cp = (USHORT)pcolcreate->cp;

		//	UNDONE:	interpret pbDefault of NULL for NULL value, and
		//			cbDefault == 0 and pbDefault != NULL as set to
		//			zero length.
		Assert( pcolcreate->cbDefault == 0 || pcolcreate->pvDefault != NULL );

		fSetColumnError = fTrue;

		// May return a warning.  Hold warning in pcolcreate->err unless
		// error encountered.
		Call( ErrFILEIValidateAddColumn(
					pcolcreate->szColumnName,
					szColumnName,
					&field,
					pcolcreate->grbit,
					( pcolcreate->pvDefault ? pcolcreate->cbDefault : 0 ),
					fTrue,
					pfcbTemplateTable ) );

		if( FFIELDUserDefinedDefault( field.ffield ) )
			{
			//  don't process user-defined-defaults on this pass
			//  the loop below will process them
			pcolcreate->columnid = 0;
			pcolcreate->err = JET_errSuccess;
			fSetColumnError = fFalse;
			continue;
			}

		if ( FRECSLV( field.coltyp ) && !rgfmp[ifmp].FSLVAttached() )
			{
			Call( ErrERRCheck( JET_errSLVStreamingFileNotCreated ) );
			}

		//	for fixed-length columns, make sure record not too big
		//
		Assert( tcib.fidFixedLast >= fidFixedLeast ?
			ibNextFixedOffset > ibRECStartFixedColumns :
			ibNextFixedOffset == ibRECStartFixedColumns );
		if ( ( ( pcolcreate->grbit & JET_bitColumnFixed ) || FCOLTYPFixedLength( field.coltyp ) )
			&& ibNextFixedOffset + pcolcreate->cbMax > cbRECRecordMost )
			{
			err = ErrERRCheck( JET_errRecordTooBig );
			goto HandleError;
			}
		else
			{
			Call( ErrFILEGetNextColumnid(
						field.coltyp,
						pcolcreate->grbit,
						fTemplateTable,
						&tcib,
						&pcolcreate->columnid ) );
			}


		//	update TDB
		//
		Assert( 0 == field.ibRecordOffset );
		if ( FCOLUMNIDFixed( pcolcreate->columnid ) )
			{
			Assert( FidOfColumnid( pcolcreate->columnid ) == tcib.fidFixedLast );
			field.ibRecordOffset = ibNextFixedOffset;
			ibNextFixedOffset = USHORT( ibNextFixedOffset + field.cbMaxLen );
			}
		else if ( FCOLUMNIDTagged( pcolcreate->columnid ) )
			{
			Assert( FidOfColumnid( pcolcreate->columnid ) == tcib.fidTaggedLast );
			}
		else
			{
			Assert( FCOLUMNIDVar( pcolcreate->columnid ) );
			Assert( FidOfColumnid( pcolcreate->columnid ) == tcib.fidVarLast );
			}

		if ( FFIELDVersion( field.ffield ) )
			{
			Assert( !FFIELDAutoincrement( field.ffield ) );
			Assert( !FFIELDEscrowUpdate( field.ffield ) );
			Assert( field.coltyp == JET_coltypLong );
			Assert( FCOLUMNIDFixed( pcolcreate->columnid ) );
			if ( 0 != fidVersion )
				{
				err = ErrERRCheck( JET_errColumnRedundant );
				goto HandleError;
				}
			fidVersion = FidOfColumnid( pcolcreate->columnid );
			}
		else if ( FFIELDAutoincrement( field.ffield ) )
			{
			Assert( !FFIELDVersion( field.ffield ) );
			Assert( !FFIELDEscrowUpdate( field.ffield ) );
			Assert( field.coltyp == JET_coltypLong || field.coltyp == JET_coltypCurrency );
			Assert( FCOLUMNIDFixed( pcolcreate->columnid ) );
			if ( 0 != fidAutoInc )
				{
				err = ErrERRCheck( JET_errColumnRedundant );
				goto HandleError;
				}
			fidAutoInc = FidOfColumnid( pcolcreate->columnid );
			}
		else if ( FFIELDEscrowUpdate( field.ffield ) )
			{
			Assert( !FFIELDVersion( field.ffield ) );
			Assert( !FFIELDAutoincrement( field.ffield ) );
			Assert( field.coltyp == JET_coltypLong );
			Assert( FFixedFid( (FID)pcolcreate->columnid ) );
			}

		fSetColumnError = fFalse;
		pcolcreate->err = JET_errSuccess;

		ptablecreate->cCreated++;
		Assert( ptablecreate->cCreated <= 1 + ptablecreate->cColumns );

		if ( fTemplateTable )
			{
			FIELDSetTemplateColumnESE98( field.ffield );
			}

		Call( ErrCATAddTableColumn(
					ppib,
					pfucbCatalog,
					objidTable,
					szColumnName,
					pcolcreate->columnid,
					&field,
					pvDefaultAdd,
					cbDefaultAdd,
					szCallbackAdd,
					pvUserDataAdd,
					cbUserDataAdd ) );
		}	// for


	//  go through a second time to create all the user-defined-default columns
	for ( pcolcreate = ptablecreate->rgcolumncreate;
		pcolcreate < plastcolcreate;
		pcolcreate++ )
		{
		Assert( pcolcreate != NULL );
		Assert( pcolcreate < ptablecreate->rgcolumncreate + ptablecreate->cColumns );

		//  this is the data that will actually be inserted into the catalog
		const VOID			*pvDefaultAdd 	= pcolcreate->pvDefault;
		ULONG				cbDefaultAdd 	= pcolcreate->cbDefault;
		CHAR				*szCallbackAdd 	= NULL;
		const VOID			*pvUserDataAdd 	= NULL;
		ULONG				cbUserDataAdd 	= 0;

		//  this was checked in the first loop
		Assert( pcolcreate->cbStruct == sizeof(JET_COLUMNCREATE) );

		FIELD				field;
		memset( &field, 0, sizeof(FIELD) );
		field.coltyp = FIELD_COLTYP( pcolcreate->coltyp );
		field.cbMaxLen = pcolcreate->cbMax;
		field.cp = (USHORT)pcolcreate->cp;

		fSetColumnError = fTrue;

		// This was called above so any errors should have been caught there
		err = ErrFILEIValidateAddColumn(
					pcolcreate->szColumnName,
					szColumnName,
					&field,
					pcolcreate->grbit,
					( pcolcreate->pvDefault ? pcolcreate->cbDefault : 0 ),
					fTrue,
					pfcbTemplateTable );
		Assert( 0 <= err );

		if( !FFIELDUserDefinedDefault( field.ffield ) )
			{
			//  we should not be here if the creation of this column failed
			Assert( 0 <= pcolcreate->err );
			fSetColumnError = fFalse;
			continue;
			}

		Assert( 0 == pcolcreate->columnid );
		Assert( JET_errSuccess == pcolcreate->err );
		Assert( !FRECSLV( field.coltyp ) );
		Assert( pcolcreate->grbit & JET_bitColumnTagged );

		Call( ErrFILEGetNextColumnid(
					field.coltyp,
					pcolcreate->grbit,
					fTemplateTable,
					&tcib,
					&pcolcreate->columnid ) );

		//	update TDB
		//

		//	UDD's must be tagged columns
		Assert( 0 == field.ibRecordOffset );
		Assert( !FCOLUMNIDFixed( pcolcreate->columnid ) );
		Assert( !FCOLUMNIDVar( pcolcreate->columnid ) );
		Assert( FCOLUMNIDTagged( pcolcreate->columnid ) );
		Assert( FidOfColumnid( pcolcreate->columnid ) == tcib.fidTaggedLast );

		Assert( !FFIELDVersion( field.ffield ) );
		Assert( !FFIELDAutoincrement( field.ffield ) );
		Assert( !FFIELDEscrowUpdate( field.ffield ) );

			{
			JET_USERDEFINEDDEFAULT * const pudd = (JET_USERDEFINEDDEFAULT *)(pcolcreate->pvDefault);

			//  the table will be opened from the catalog later so we don't need to deal with registering
			//  a CBDESC right now. Make sure that it can be resolved though
			JET_CALLBACK callback;
			Call( ErrCALLBACKResolve( pudd->szCallback, &callback ) );

			//  for user-defined-defaults we don't store a default value at all
			pvDefaultAdd 	= NULL;
			cbDefaultAdd 	= 0;
			szCallbackAdd	= pudd->szCallback;
			pvUserDataAdd 	= pudd->pbUserData;
			cbUserDataAdd 	= pudd->cbUserData;
			}

		fSetColumnError = fFalse;
		pcolcreate->err = JET_errSuccess;

		ptablecreate->cCreated++;
		Assert( ptablecreate->cCreated <= 1 + ptablecreate->cColumns );

		if ( fTemplateTable )
			{
			FIELDSetTemplateColumnESE98( field.ffield );
			}

		Call( ErrCATAddTableColumn(
					ppib,
					pfucbCatalog,
					objidTable,
					szColumnName,
					pcolcreate->columnid,
					&field,
					pvDefaultAdd,
					cbDefaultAdd,
					szCallbackAdd,
					pvUserDataAdd,
					cbUserDataAdd ) );
		}	// for

#else	//	!ACCOUNT_FOR_CALLBACK_DEPENDENCIES

	for ( pcolcreate = ptablecreate->rgcolumncreate;
		pcolcreate < plastcolcreate;
		pcolcreate++ )
		{
		Assert( pcolcreate != NULL );
		Assert( pcolcreate < ptablecreate->rgcolumncreate + ptablecreate->cColumns );

		//  this is the data that will actually be inserted into the catalog
		const VOID		*pvDefaultAdd 	= NULL;
		ULONG			cbDefaultAdd 	= 0;
		CHAR			*szCallbackAdd 	= NULL;
		const VOID		*pvUserDataAdd 	= NULL;
		ULONG			cbUserDataAdd 	= 0;

		if ( pcolcreate->cbStruct != sizeof(JET_COLUMNCREATE) )
			{
			err = ErrERRCheck( JET_errInvalidParameter );
			goto HandleError;
			}

		pvDefaultAdd = pcolcreate->pvDefault;
		cbDefaultAdd = pcolcreate->cbDefault;

		FIELD			field;
		memset( &field, 0, sizeof(FIELD) );
		field.coltyp = FIELD_COLTYP( pcolcreate->coltyp );
		field.cbMaxLen = pcolcreate->cbMax;
		field.cp = (USHORT)pcolcreate->cp;

		//	UNDONE:	interpret pbDefault of NULL for NULL value, and
		//			cbDefault == 0 and pbDefault != NULL as set to
		//			zero length.
		Assert( pcolcreate->cbDefault == 0 || pcolcreate->pvDefault != NULL );

		fSetColumnError = fTrue;

		// May return a warning.  Hold warning in pcolcreate->err unless
		// error encountered.
		Call( ErrFILEIValidateAddColumn(
					pcolcreate->szColumnName,
					szColumnName,
					&field,
					pcolcreate->grbit,
					( pcolcreate->pvDefault ? pcolcreate->cbDefault : 0 ),
					fTrue,
					pfcbTemplateTable ) );

		if ( FRECSLV( field.coltyp ) && !rgfmp[ifmp].FSLVAttached() )
			{
			Call( ErrERRCheck( JET_errSLVStreamingFileNotCreated ) );
			}

		//	for fixed-length columns, make sure record not too big
		//
		Assert( tcib.fidFixedLast >= fidFixedLeast ?
			ibNextFixedOffset > ibRECStartFixedColumns :
			ibNextFixedOffset == ibRECStartFixedColumns );
		if ( ( ( pcolcreate->grbit & JET_bitColumnFixed ) || FCOLTYPFixedLength( field.coltyp ) )
			&& ibNextFixedOffset + pcolcreate->cbMax > cbRECRecordMost )
			{
			err = ErrERRCheck( JET_errRecordTooBig );
			goto HandleError;
			}

		Call( ErrFILEGetNextColumnid(
					field.coltyp,
					pcolcreate->grbit,
					fTemplateTable,
					&tcib,
					&pcolcreate->columnid ) );

		//	update TDB
		//
		Assert( 0 == field.ibRecordOffset );
		if ( FCOLUMNIDFixed( pcolcreate->columnid ) )
			{
			Assert( FidOfColumnid( pcolcreate->columnid ) == tcib.fidFixedLast );
			field.ibRecordOffset = ibNextFixedOffset;
			ibNextFixedOffset = USHORT( ibNextFixedOffset + field.cbMaxLen );
			}
		else if ( FCOLUMNIDTagged( pcolcreate->columnid ) )
			{
			Assert( FidOfColumnid( pcolcreate->columnid ) == tcib.fidTaggedLast );
			}
		else
			{
			Assert( FCOLUMNIDVar( pcolcreate->columnid ) );
			Assert( FidOfColumnid( pcolcreate->columnid ) == tcib.fidVarLast );
			}

		if ( FFIELDVersion( field.ffield ) )
			{
			Assert( !FFIELDAutoincrement( field.ffield ) );
			Assert( !FFIELDEscrowUpdate( field.ffield ) );
			Assert( field.coltyp == JET_coltypLong );
			Assert( FCOLUMNIDFixed( pcolcreate->columnid ) );
			if ( 0 != fidVersion )
				{
				err = ErrERRCheck( JET_errColumnRedundant );
				goto HandleError;
				}
			fidVersion = FidOfColumnid( pcolcreate->columnid );
			}
		else if ( FFIELDAutoincrement( field.ffield ) )
			{
			Assert( !FFIELDVersion( field.ffield ) );
			Assert( !FFIELDEscrowUpdate( field.ffield ) );
			Assert( field.coltyp == JET_coltypLong || field.coltyp == JET_coltypCurrency );
			Assert( FCOLUMNIDFixed( pcolcreate->columnid ) );
			if ( 0 != fidAutoInc )
				{
				err = ErrERRCheck( JET_errColumnRedundant );
				goto HandleError;
				}
			fidAutoInc = FidOfColumnid( pcolcreate->columnid );
			}
		else if ( FFIELDEscrowUpdate( field.ffield ) )
			{
			Assert( !FFIELDVersion( field.ffield ) );
			Assert( !FFIELDAutoincrement( field.ffield ) );
			Assert( field.coltyp == JET_coltypLong );
			Assert( FFixedFid( (FID)pcolcreate->columnid ) );
			}
		else if ( FFIELDUserDefinedDefault( field.ffield ) )
			{
			JET_USERDEFINEDDEFAULT * const pudd = (JET_USERDEFINEDDEFAULT *)(pcolcreate->pvDefault);

			//  the table will be opened from the catalog later so we don't need to deal with registering
			//  a CBDESC right now. Make sure that it can be resolved though
			JET_CALLBACK callback;
			Call( ErrCALLBACKResolve( pudd->szCallback, &callback ) );

			//  for user-defined-defaults we don't store a default value at all
			pvDefaultAdd 	= NULL;
			cbDefaultAdd 	= 0;
			szCallbackAdd	= pudd->szCallback;
			pvUserDataAdd 	= pudd->pbUserData;
			cbUserDataAdd 	= pudd->cbUserData;
			}

		fSetColumnError = fFalse;
		pcolcreate->err = JET_errSuccess;

		ptablecreate->cCreated++;
		Assert( ptablecreate->cCreated <= 1 + ptablecreate->cColumns );

		if ( fTemplateTable )
			{
			FIELDSetTemplateColumnESE98( field.ffield );
			}

		Call( ErrCATAddTableColumn(
					ppib,
					pfucbCatalog,
					objidTable,
					szColumnName,
					pcolcreate->columnid,
					&field,
					pvDefaultAdd,
					cbDefaultAdd,
					szCallbackAdd,
					pvUserDataAdd,
					cbUserDataAdd ) );
		}	// for

#endif	//	ACCOUNT_FOR_CALLBACK_DEPENDENCIES

	err = JET_errSuccess;

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );

	if ( fSetColumnError )
		{
		Assert( err < 0 );
		Assert( pcolcreate != NULL );
		Assert( pcolcreate->cbStruct == sizeof(JET_COLUMNCREATE) );
		pcolcreate->err = err;
		}

	return err;
	}


//	WARNING: This function will modify lcid as necessary
ERR ErrFILEICheckUserDefinedUnicode( INST * const pinst, IDXUNICODE * const pidxunicode )
	{
	ERR		err;

	if ( NULL == pidxunicode )
		{
		return ErrERRCheck( JET_errIndexInvalidDef );
		}

	CallR( ErrNORMCheckLcid( pinst, &pidxunicode->lcid ) );
	CallR( ErrNORMCheckLCMapFlags( pinst, &pidxunicode->dwMapFlags ) );

	return JET_errSuccess;
	}


LOCAL ERR ErrFILEIValidateCreateIndex(
	INST * const					pinst,
	IDB *							pidb,
	const CHAR *					rgszColumns[],
	BYTE * const					rgfbDescending,
	const JET_INDEXCREATE * const	pidxcreate,
	const ULONG						ulDensity )
	{
	ERR								err;
	const JET_GRBIT					grbit				= pidxcreate->grbit;
	const CHAR *					szKey				= pidxcreate->szKey;
	const ULONG						cchKey				= pidxcreate->cbKey;
	const IDXUNICODE * const		pidxunicode			= pidxcreate->pidxunicode;

	const BOOL						fConditional		= ( pidxcreate->cConditionalColumn > 0 );
	const BOOL						fPrimary			= ( grbit & JET_bitIndexPrimary );
	const BOOL						fUnique				= ( grbit & ( JET_bitIndexUnique|JET_bitIndexPrimary ) );
	const BOOL						fDisallowNull		= ( grbit & JET_bitIndexDisallowNull );
	const BOOL						fIgnoreNull			= ( grbit & JET_bitIndexIgnoreNull );
	const BOOL						fIgnoreAnyNull		= ( grbit & JET_bitIndexIgnoreAnyNull );
	const BOOL						fIgnoreFirstNull	= ( grbit & JET_bitIndexIgnoreFirstNull );
	const BOOL						fEmptyIndex			= ( grbit & JET_bitIndexEmpty );
	const BOOL						fSortNullsHigh		= ( grbit & JET_bitIndexSortNullsHigh );
	const BOOL						fUserDefinedUnicode	= ( grbit & JET_bitIndexUnicode );
	const BOOL						fCustomTupleLimits	= ( grbit & JET_bitIndexTupleLimits );
	const BOOL						fTuples				= ( ( grbit & JET_bitIndexTuples )
															|| fCustomTupleLimits );

	const CHAR *					pch					= szKey;
	ULONG							cFields				= 0;
	USHORT							cbVarSegMac			= USHORT( fCustomTupleLimits || 0 == pidxcreate->cbVarSegMac ?
																KEY::CbKeyMost( fPrimary ) :
																pidxcreate->cbVarSegMac );

	pidb->ResetFlags();

	//	do not allow primary indexes with any ignore bits on
	//
	if ( fPrimary && ( fIgnoreNull || fIgnoreAnyNull || fIgnoreFirstNull ) )
		{
		err = ErrERRCheck( JET_errInvalidGrbit );
		return err;
		}

	if ( fPrimary && fConditional )
		{
		err = ErrERRCheck( JET_errIndexInvalidDef );
		return err;
		}

	if ( fEmptyIndex && !fIgnoreAnyNull )
		{
		err = ErrERRCheck( JET_errInvalidGrbit );
		return err;
		}

	if ( fUserDefinedUnicode )
		{
		*( pidb->Pidxunicode() ) = *pidxunicode;
		}
	else
		{
		pidb->SetLcid( LCID( DWORD_PTR( pidxunicode ) ) );
		pidb->SetDwLCMapFlags( pinst->m_idxunicodeDefault.dwMapFlags );
		}

	//	check index description for required format
	//
	if ( cchKey == 0 )
		{
		err = ErrERRCheck( JET_errInvalidParameter );
		return err;
		}

	if ( ( szKey[0] != '+' && szKey[0] != '-' ) ||
		szKey[cchKey - 1] != '\0' ||
		szKey[cchKey - 2] != '\0' )
		{
		err = ErrERRCheck( JET_errIndexInvalidDef );
		return err;
		}
	Assert( szKey[cchKey - 1] == '\0' );
	Assert( szKey[cchKey - 2] == '\0' );

	if ( ulDensity < ulFILEDensityLeast || ulDensity > ulFILEDensityMost )
		{
		err = ErrERRCheck( JET_errDensityInvalid );
		return err;
		}

	pch = szKey;
	while ( *pch != '\0' )
		{
		if ( cFields >= JET_ccolKeyMost )
			{
			err = ErrERRCheck( JET_errIndexInvalidDef );
			return err;
			}
		if ( *pch == '-' )
			{
			rgfbDescending[cFields] = fTrue;
			pch++;
			}
		else
			{
			rgfbDescending[cFields] = fFalse;
			if ( *pch == '+' )
				pch++;
			}
		rgszColumns[cFields++] = pch;
		pch += strlen( pch ) + 1;
		}
	if ( cFields == 0 )
		{
		err = ErrERRCheck( JET_errIndexInvalidDef );
		return err;
		}

	//	number of columns should not exceed maximum
	//
	Assert( cFields <= JET_ccolKeyMost );

	//	get locale from end of szKey if present
	//
	pch++;
	Assert( pch > szKey );
	if ( (unsigned)( pch - szKey ) < cchKey )
		{
		const SIZE_T	cbKeyOnly = pch - szKey;
		const SIZE_T	cbDoubleNullTerm = sizeof(BYTE) * 2;	// "\0\0"
		const SIZE_T	cbKeyAndLangid = cbKeyOnly + sizeof(LANGID) + cbDoubleNullTerm;
		const SIZE_T	cbKeyAndLangidAndCbVarSegMac = cbKeyAndLangid + sizeof(BYTE) + cbDoubleNullTerm;
		LANGID		langid;

		if ( cbKeyAndLangid == cchKey )
			{
			AssertSz( lcidNone == pidb->Lcid() && !fUserDefinedUnicode, "langid specified in index string _and_ JET_INDEXCREATE structure" );
			if( lcidNone != pidb->Lcid() || fUserDefinedUnicode )
				{
				err = ErrERRCheck( JET_errIndexInvalidDef );
				return err;
				}

			langid = *( Unaligned< LANGID > *)( szKey + cbKeyOnly );
			}
		else if ( cbKeyAndLangidAndCbVarSegMac == cchKey )
			{
			AssertSz( fCustomTupleLimits || 0 == pidxcreate->cbVarSegMac, "cbVarSegMac specified in index string _and_ JET_INDEXCREATE structure" );
			if( 0 != pidxcreate->cbVarSegMac && !fCustomTupleLimits )
				{
				err = ErrERRCheck( JET_errIndexInvalidDef );
				return err;
				}
			AssertSz( lcidNone == pidb->Lcid() && !fUserDefinedUnicode, "langid specified in index string _and_ JET_INDEXCREATE structure" );
			if( lcidNone != pidb->Lcid() || fUserDefinedUnicode )
				{
				err = ErrERRCheck( JET_errIndexInvalidDef );
				return err;
				}

			langid = *( Unaligned< LANGID > *)(pch);
			cbVarSegMac = USHORT( *( szKey + cbKeyAndLangid ) );
			}
		else
			{
			err = ErrERRCheck( JET_errIndexInvalidDef );
			return err;
			}

		pidb->SetLcid( LcidFromLangid( langid ) );
		}

	if ( cbVarSegMac <= 0 || cbVarSegMac > KEY::CbKeyMost( fPrimary ) )
		{
		err = ErrERRCheck( JET_errIndexInvalidDef );
		return err;
		}

	if ( fUserDefinedUnicode )
		{
		CallR( ErrFILEICheckUserDefinedUnicode( pinst, pidb->Pidxunicode() ) );
		pidb->SetFLocaleId();
		}
	else
		{
		Assert( JET_errSuccess == ErrNORMCheckLCMapFlags( pinst, pidb->DwLCMapFlags() ) );
		if ( lcidNone != pidb->Lcid() )
			{
			LCID	lcidT	= pidb->Lcid();
			CallR( ErrNORMCheckLcid( pinst, &lcidT ) );
			pidb->SetLcid( lcidT );
			pidb->SetFLocaleId();
			}
		else
			{
			Assert( !pidb->FLocaleId() );
			pidb->SetLcid( pinst->m_idxunicodeDefault.lcid );
			}
		}

	if ( fTuples )
		{
		if ( fPrimary )
			return ErrERRCheck( JET_errIndexTuplesSecondaryIndexOnly );

		if ( cFields > 1 )
			return ErrERRCheck( JET_errIndexTuplesOneColumnOnly );

		if ( fUnique )
			return ErrERRCheck( JET_errIndexTuplesNonUniqueOnly );

		if ( cbVarSegMac < JET_cbSecondaryKeyMost )
			return ErrERRCheck( JET_errIndexTuplesVarSegMacNotAllowed );

		pidb->SetFTuples();
		pidb->SetCbVarSegMac( JET_cbSecondaryKeyMost );
		pidb->SetCidxseg( 1 );

		const ULONG	chLengthMin		= ( fCustomTupleLimits ?
												pidxcreate->ptuplelimits->chLengthMin :
												pinst->m_chIndexTuplesLengthMin );
		const ULONG	chLengthMax		= ( fCustomTupleLimits ?
												pidxcreate->ptuplelimits->chLengthMax :
												pinst->m_chIndexTuplesLengthMax );
		const ULONG	chToIndexMax	= ( fCustomTupleLimits ?
														pidxcreate->ptuplelimits->chToIndexMax :
														pinst->m_chIndexTuplesToIndexMax );

		pidb->SetChTuplesLengthMin( USHORT( 0 != chLengthMin ? chLengthMin : chIDXTuplesLengthMinDefault ) );
		pidb->SetChTuplesLengthMax( USHORT( 0 != chLengthMax ? chLengthMax : chIDXTuplesLengthMaxDefault ) );
		pidb->SetChTuplesToIndexMax( USHORT( 0 != chToIndexMax ? chToIndexMax : chIDXTuplesToIndexMaxDefault ) );

		if ( pidb->ChTuplesLengthMin() < chIDXTuplesLengthMinAbsolute
			|| pidb->ChTuplesLengthMin() > chIDXTuplesLengthMaxAbsolute
			|| pidb->ChTuplesLengthMax() < chIDXTuplesLengthMinAbsolute
			|| pidb->ChTuplesLengthMax() > chIDXTuplesLengthMaxAbsolute
			|| pidb->ChTuplesLengthMin() > pidb->ChTuplesLengthMax()
			|| pidb->ChTuplesToIndexMax() > chIDXTuplesToIndexMaxAbsolute )
			{
			return ErrERRCheck( JET_errIndexTuplesInvalidLimits );
			}

		}
	else
		{
		pidb->SetCbVarSegMac( (BYTE)cbVarSegMac );
		pidb->SetCidxseg( (BYTE)cFields );
		}

	if ( !fDisallowNull && !fIgnoreAnyNull )
		{
		pidb->SetFAllowSomeNulls();
		if ( !fIgnoreFirstNull )
			{
			pidb->SetFAllowFirstNull();
			if ( !fIgnoreNull )
				pidb->SetFAllowAllNulls();
			}
		}

	if ( fUnique )
		{
		pidb->SetFUnique();
		}
	if ( fPrimary )
		{
		pidb->SetFPrimary();
		}
	if ( fDisallowNull )
		{
		pidb->SetFNoNullSeg();
		}
	else if ( fSortNullsHigh )
		{
		pidb->SetFSortNullsHigh();
		}

#ifdef DEBUG
	IDB		idbT;
	idbT.SetFlagsFromGrbit( grbit );
	if ( pidb->FLocaleId() )
		idbT.SetFLocaleId();
	Assert( idbT.FPersistedFlags() == pidb->FPersistedFlags() );
#endif

	return JET_errSuccess;
	}


LOCAL ERR ErrFILEICreateIndexes(
	PIB				*ppib,
	IFMP			ifmp,
	JET_TABLECREATE2*ptablecreate,
	PGNO			pgnoTableFDP,
	OBJID			objidTable,
	ULONG			ulTableDensity,
	FCB				*pfcbTemplateTable )
	{
	ERR				err = JET_errSuccess;
	FUCB			*pfucbTableExtent		= pfucbNil;
	FUCB			*pfucbCatalog			= pfucbNil;
	CHAR			szIndexName[ JET_cbNameMost+1 ];
	const CHAR		*rgsz[JET_ccolKeyMost];
	BYTE			rgfbDescending[JET_ccolKeyMost];
	IDXSEG			rgidxseg[JET_ccolKeyMost];
	IDXSEG			rgidxsegConditional[JET_ccolKeyMost];
	JET_INDEXCREATE	*pidxcreate;
	INT				iIndex;
	PGNO			pgnoIndexFDP;
	OBJID			objidIndex;
	IDB				idb;
	BOOL			fProcessedPrimary		= fFalse;
	BOOL			fSetIndexError			= fFalse;
	const BOOL		fTemplateTable			= ( ptablecreate->grbit & JET_bitTableCreateTemplateTable );

	JET_INDEXCREATE	idxcreate;
	JET_INDEXCREATEOLD	* pidxcreateold = NULL;
	JET_INDEXCREATE	* pidxcreateNext = NULL;

	Assert( rgfmp[ ifmp ].Dbid() != dbidTemp );
	Assert( !FCATSystemTable( pgnoTableFDP ) );

	Assert( ptablecreate->cIndexes > 0 );
	Assert( ptablecreate->cCreated == 1 + ptablecreate->cColumns );

	if ( ptablecreate->rgindexcreate == NULL
		|| ptablecreate->rgcolumncreate == NULL )	// must have columns in order to create indexes
		{
		//	if an invalid structure is encountered, get out right away
		//
		err = ErrERRCheck( JET_errInvalidCreateIndex );
		return err;
		}

	// Open cursor for space navigation
	CallR( ErrDIROpen( ppib, pgnoTableFDP, ifmp, &pfucbTableExtent ) );
	Assert( pfucbNil != pfucbTableExtent );
	Assert( !FFUCBVersioned( pfucbTableExtent ) );	// Verify won't be deferred closed.
	Assert( pfcbNil != pfucbTableExtent->u.pfcb );
	Assert( !pfucbTableExtent->u.pfcb->FInitialized() );
	Assert( pfucbTableExtent->u.pfcb->Pidb() == pidbNil );

	//	force the FCB to be initialized successfully

	pfucbTableExtent->u.pfcb->Lock();
	pfucbTableExtent->u.pfcb->CreateComplete();
	pfucbTableExtent->u.pfcb->Unlock();

	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	if ( pfcbNil != pfcbTemplateTable )
		{
		Assert( !fTemplateTable );
		Assert( pfcbTemplateTable->FTemplateTable() );
		Assert( pfcbTemplateTable->FTypeTable() );
		Assert( pfcbTemplateTable->FFixedDDL() );
		if ( pfcbTemplateTable->FSequentialIndex() )
			{
			Assert( pfcbTemplateTable->Pidb() == pidbNil );
			}
		else
			{
			Assert( pfcbTemplateTable->Pidb() != pidbNil );
			Assert( pfcbTemplateTable->Pidb()->FPrimary() );
			Assert( pfcbTemplateTable->Pidb()->FTemplateIndex() );
			fProcessedPrimary = fTrue;
			}
		}

	pidxcreate 		= ptablecreate->rgindexcreate;
	for( iIndex = 0; iIndex < ptablecreate->cIndexes; iIndex++, pidxcreate = pidxcreateNext )
		{
		pidxcreateNext	= (JET_INDEXCREATE *)((BYTE *)( pidxcreate ) + pidxcreate->cbStruct);
		pidxcreateold 	= NULL;

		Assert( pidxcreate < ptablecreate->rgindexcreate + ptablecreate->cIndexes );

		if ( sizeof(JET_INDEXCREATEOLD) == pidxcreate->cbStruct )
			{
			pidxcreateold 		= (JET_INDEXCREATEOLD *)pidxcreate;
			pidxcreateold->err 	= JET_errSuccess;

			memset( &idxcreate, 0, sizeof( JET_INDEXCREATE ) );

			idxcreate.cbStruct		= sizeof( JET_INDEXCREATE );
			idxcreate.szIndexName 	= pidxcreateold->szIndexName;
			idxcreate.szKey			= pidxcreateold->szKey;
			idxcreate.cbKey			= pidxcreateold->cbKey;
			idxcreate.grbit			= pidxcreateold->grbit;
			idxcreate.ulDensity		= pidxcreateold->ulDensity;
			Assert( 0 == idxcreate.lcid );
			Assert( NULL == idxcreate.pidxunicode );
			Assert( 0 == idxcreate.cbVarSegMac );
			Assert( NULL == idxcreate.rgconditionalcolumn );
			Assert( 0 == idxcreate.cConditionalColumn );
			Assert( JET_errSuccess == idxcreate.err );
			pidxcreate = &idxcreate;
			}
		else if ( pidxcreate->cbStruct != sizeof(JET_INDEXCREATE) )
			{
			//	if an invalid structure is encountered, get out right away
			//
			err = ErrERRCheck( JET_errInvalidCreateIndex );
			goto HandleError;
			}

		pidxcreate->err = JET_errSuccess;

		fSetIndexError = fTrue;

		Call( ErrUTILCheckName( szIndexName, pidxcreate->szIndexName, JET_cbNameMost+1 ) );

		//	if density not specified, use density of table
		const ULONG	ulDensity	= ( 0 == pidxcreate->ulDensity ?
									ulTableDensity :
									pidxcreate->ulDensity );

		Call( ErrFILEIValidateCreateIndex(
					PinstFromPpib( ppib ),
					&idb,
					rgsz,
					rgfbDescending,
					pidxcreate,
					ulDensity ) );

		for ( ULONG iidxseg = 0 ; iidxseg < idb.Cidxseg(); iidxseg++ )
			{
			COLUMNID				columnidT;
			BOOL					fEscrow;
			BOOL					fMultivalued;
			BOOL					fSLV;
			BOOL					fText;
			BOOL					fLocalizedText;
			const JET_COLUMNCREATE	* pcolcreate			= ptablecreate->rgcolumncreate;
			const JET_COLUMNCREATE	* const plastcolcreate	= pcolcreate + ptablecreate->cColumns;

			Assert( NULL != pcolcreate );
			for ( ; pcolcreate < plastcolcreate; pcolcreate++ )
				{
				Assert( pcolcreate->cbStruct == sizeof(JET_COLUMNCREATE) );
				Assert( pcolcreate->err >= 0 );		// must have been created successfully
				if ( UtilCmpName( rgsz[iidxseg], pcolcreate->szColumnName ) == 0 )
					break;
				}

			if ( plastcolcreate != pcolcreate )
				{
				columnidT = pcolcreate->columnid;
				Assert( ( fTemplateTable && FCOLUMNIDTemplateColumn( columnidT ) )
					|| ( !fTemplateTable && !FCOLUMNIDTemplateColumn( columnidT ) ) );
				fEscrow = ( pcolcreate->grbit & JET_bitColumnEscrowUpdate );
				fSLV = FRECSLV( pcolcreate->coltyp );
				fMultivalued = ( pcolcreate->grbit & JET_bitColumnMultiValued );
				fText = FRECTextColumn( pcolcreate->coltyp );
				fLocalizedText = ( fText && usUniCodePage == (USHORT)pcolcreate->cp );
				}
			else
				{
				FIELD	*pfield	= pfieldNil;

				//	column is not in table, so check template table (if any)
				if ( pfcbNil != pfcbTemplateTable )
					{
					Assert( !fTemplateTable );
					CallS( ErrFILEPfieldFromColumnName(
								ppib,
								pfcbTemplateTable,
								rgsz[iidxseg],
								&pfield,
								&columnidT ) );
					}

				if ( pfieldNil != pfield )
					{
					//	must be a template column
					Assert( FCOLUMNIDTemplateColumn( columnidT ) );
					Assert( pfcbNil != pfcbTemplateTable );
					fEscrow = FFIELDEscrowUpdate( pfield->ffield );
					fSLV = FRECSLV( pfield->coltyp );
					fMultivalued = FFIELDMultivalued( pfield->ffield );
					fText = FRECTextColumn( pfield->coltyp );
					fLocalizedText = ( fText && usUniCodePage == pfield->cp );
					}
				else
					{
					err = ErrERRCheck( JET_errColumnNotFound );
					goto HandleError;
					}
				}

			if ( fEscrow || fSLV )			//lint !e644
				{
				err = ErrERRCheck( JET_errCannotIndex );
				goto HandleError;
				}

			if ( fMultivalued )		//lint !e644
				{
				if ( idb.FPrimary() )
					{
					//	primary index cannot be multivalued
					//
					err = ErrERRCheck( JET_errIndexInvalidDef );
					goto HandleError;
					}

				idb.SetFMultivalued();
				}

			if ( idb.FTuples() )
				{
				if ( !fText )
					{
					err = ErrERRCheck( JET_errIndexTuplesTextColumnsOnly );
					goto HandleError;
					}
				}

			if ( fLocalizedText )	//lint !e644
				{
				idb.SetFLocalizedText();
				if( FNORMStringHasUndefinedCharsIsSupported() )
					{
					idb.SetFUnicodeFixupOn();
					}
				}

			rgidxseg[iidxseg].ResetFlags();

			if ( rgfbDescending[iidxseg] )
				rgidxseg[iidxseg].SetFDescending();

			rgidxseg[iidxseg].SetColumnid( columnidT );
			}

 		if( JET_ccolKeyMost < pidxcreate->cConditionalColumn )
			{
			err = ErrERRCheck( JET_errIndexInvalidDef );
			Call( err );
			}

		idb.SetCidxsegConditional( BYTE( pidxcreate->cConditionalColumn ) );
		for ( iidxseg = 0 ; iidxseg < idb.CidxsegConditional(); iidxseg++ )
			{
			COLUMNID				columnidT;
			const CHAR				* const szColumnName	= pidxcreate->rgconditionalcolumn[iidxseg].szColumnName;
			BOOL					fColumnWasDerived		= fFalse;
			const JET_GRBIT			grbit					= pidxcreate->rgconditionalcolumn[iidxseg].grbit;
			const JET_COLUMNCREATE	* pcolcreate 			= ptablecreate->rgcolumncreate;
			const JET_COLUMNCREATE	* const plastcolcreate 	= pcolcreate + ptablecreate->cColumns;

			Assert( sizeof( rgidxsegConditional ) / sizeof( rgidxsegConditional[0] ) == JET_ccolKeyMost );

			if( sizeof( JET_CONDITIONALCOLUMN ) != pidxcreate->rgconditionalcolumn[iidxseg].cbStruct )
				{
				err = ErrERRCheck( JET_errIndexInvalidDef );
				Call( err );
				}

			if( JET_bitIndexColumnMustBeNonNull != grbit
				&& JET_bitIndexColumnMustBeNull != grbit )
				{
				err = ErrERRCheck( JET_errInvalidGrbit );
				Call( err );
				}

			Assert( NULL != pcolcreate );
			for ( ; pcolcreate < plastcolcreate; pcolcreate++ )
				{
				Assert( pcolcreate->cbStruct == sizeof(JET_COLUMNCREATE) );
				Assert( pcolcreate->err >= 0 );		// must have been created successfully
				if ( UtilCmpName( szColumnName, pcolcreate->szColumnName ) == 0 )
					break;
				}

			if ( plastcolcreate != pcolcreate )
				{
				columnidT = pcolcreate->columnid;
				Assert( ( fTemplateTable && FCOLUMNIDTemplateColumn( columnidT ) )
					|| ( !fTemplateTable && !FCOLUMNIDTemplateColumn( columnidT ) ) );
				}
			else
				{
				FIELD	*pfield	= pfieldNil;

				//	column is not in table, so check template table (if any)
				if ( pfcbNil != pfcbTemplateTable )
					{
					Assert( !fTemplateTable );
					CallS( ErrFILEPfieldFromColumnName(
								ppib,
								pfcbTemplateTable,
								szColumnName,
								&pfield,
								&columnidT ) );
					}

				if ( pfieldNil == pfield )
					{
					err = ErrERRCheck( JET_errColumnNotFound );
					goto HandleError;
					}
				else
					{
					Assert( FCOLUMNIDTemplateColumn( columnidT ) );
					}
				}

			Assert( FCOLUMNIDValid( columnidT ) );

			rgidxsegConditional[iidxseg].ResetFlags();

			if ( JET_bitIndexColumnMustBeNull == grbit )
				{
				rgidxsegConditional[iidxseg].SetFMustBeNull();
				}

			rgidxsegConditional[iidxseg].SetColumnid( columnidT );
			}

		if ( idb.FPrimary() )
			{
			if ( fProcessedPrimary )
				{
				err = ErrERRCheck( JET_errIndexHasPrimary );
				goto HandleError;
				}

			fProcessedPrimary = fTrue;
			pgnoIndexFDP = pgnoTableFDP;
			objidIndex = objidTable;
			}
		else
			{
			Call( ErrDIRCreateDirectory(
						pfucbTableExtent,
						(CPG)0,
						&pgnoIndexFDP,
						&objidIndex,
						CPAGE::fPageIndex | ( idb.FUnique() ? 0 : CPAGE::fPageNonUniqueKeys ),
						fSPUnversionedExtent | ( idb.FUnique() ? 0 : fSPNonUnique ) ) );
			Assert( pgnoIndexFDP != pgnoTableFDP );
			Assert( objidIndex > objidSystemRoot );

			//	objids are monotonically increasing, so an index should
			//	always have higher objid than its table
			Assert( objidIndex > objidTable );
			}

		ptablecreate->cCreated++;
		Assert( ptablecreate->cCreated <= 1 + ptablecreate->cColumns + ptablecreate->cIndexes );

		fSetIndexError = fFalse;

		if ( fTemplateTable )
			{
			Assert( NULL == ptablecreate->szTemplateTableName );

			// If we're creating a template table, this must be a template index.
			idb.SetFTemplateIndex();
			}

		Assert( !idb.FVersioned() );
		Assert( !idb.FVersionedCreate() );

		Call( ErrCATAddTableIndex(
					ppib,
					pfucbCatalog,
					objidTable,
					szIndexName,
					pgnoIndexFDP,
					objidIndex,
					&idb,
					rgidxseg,
					rgidxsegConditional,
					ulDensity ) );
		}

HandleError:
	if ( pfucbNil != pfucbCatalog )
		{
		CallS( ErrCATClose( ppib, pfucbCatalog ) );
		}

	Assert( pfucbTableExtent != pfucbNil );
	Assert( pfucbTableExtent->u.pfcb->WRefCount() == 1 );

	//	force the FCB to be uninitialized so it will be purged by DIRClose

	pfucbTableExtent->u.pfcb->Lock();
	pfucbTableExtent->u.pfcb->CreateComplete( errFCBUnusable );
	pfucbTableExtent->u.pfcb->Unlock();

	//	verify that this FUCB will not be defer-closed

	Assert( !FFUCBVersioned( pfucbTableExtent ) );

	//	close the FUCB

	DIRClose( pfucbTableExtent );

	if ( fSetIndexError )
		{
		Assert( err < 0 );
		Assert( pidxcreate != NULL );
		Assert( sizeof( JET_INDEXCREATE ) == pidxcreate->cbStruct );
		Assert( JET_errSuccess == pidxcreate->err );
		pidxcreate->err = err;	//lint !e644
		if( NULL != pidxcreateold )
			{
			// pidxcreateold points to the real structure. return the error value in it.
			Assert( sizeof( JET_INDEXCREATEOLD ) == pidxcreateold->cbStruct );
			Assert( JET_errSuccess == pidxcreateold->err );
			pidxcreateold->err = err;
			}
		}

	return err;
	}


LOCAL ERR ErrFILEIInheritIndexes(
	PIB				*ppib,
	const IFMP		ifmp,
	JET_TABLECREATE2*ptablecreate,
	const PGNO		pgnoTableFDP,
	const OBJID		objidTable,
	FCB				*pfcbTemplateTable )
	{
	ERR				err = JET_errSuccess;
	FUCB			*pfucbTableExtent	= pfucbNil;
	FUCB			*pfucbCatalog		= pfucbNil;
	TDB				*ptdbTemplateTable;
	FCB				*pfcbIndex;
	PGNO			pgnoIndexFDP;
	OBJID			objidIndex;

	// Temp tables and catalogs don't use hierarchical DDL.
	Assert( rgfmp[ ifmp ].Dbid() != dbidTemp );
	Assert( !FCATSystemTable( pgnoTableFDP ) );

	Assert( pfcbTemplateTable->FPrimaryIndex() );
	Assert( pfcbTemplateTable->FTypeTable() );
	Assert( pfcbTemplateTable->FFixedDDL() );
	Assert( pfcbTemplateTable->FTemplateTable() );

	// Open cursor for space navigation
	CallR( ErrDIROpen( ppib, pgnoTableFDP, ifmp, &pfucbTableExtent ) );
	Assert( pfucbNil != pfucbTableExtent );
	Assert( !FFUCBVersioned( pfucbTableExtent ) );	// Verify won't be deferred closed.
	Assert( pfcbNil != pfucbTableExtent->u.pfcb );
	Assert( !pfucbTableExtent->u.pfcb->FInitialized() );
	Assert( pfucbTableExtent->u.pfcb->Pidb() == pidbNil );

	//	force the FCB to be initialized successfully

	pfucbTableExtent->u.pfcb->Lock();
	pfucbTableExtent->u.pfcb->CreateComplete();
	pfucbTableExtent->u.pfcb->Unlock();

	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	ptdbTemplateTable = pfcbTemplateTable->Ptdb();
	Assert( ptdbNil != ptdbTemplateTable );


	if ( pfcbTemplateTable->Pidb() == pidbNil )
		{
		Assert( pfcbTemplateTable->FSequentialIndex() );
		pfcbIndex = pfcbTemplateTable->PfcbNextIndex();
		}
	else
		{
		Assert( !pfcbTemplateTable->FSequentialIndex() );
		pfcbIndex = pfcbTemplateTable;
		}

	for ( ; pfcbIndex != pfcbNil; pfcbIndex = pfcbIndex->PfcbNextIndex() )
		{
		Assert( pfcbIndex == pfcbTemplateTable || pfcbIndex->FTypeSecondaryIndex() );
		Assert( pfcbIndex->FTemplateIndex() );
		Assert( pfcbIndex->Pidb() != pidbNil );

		IDB	idb = *pfcbIndex->Pidb();

		Assert( idb.FTemplateIndex() );
		Assert( !idb.FDerivedIndex() );
		idb.SetFDerivedIndex();
		idb.ResetFTemplateIndex();

		if ( idb.FPrimary() )
			{
			Assert( pfcbIndex == pfcbTemplateTable );
			pgnoIndexFDP = pgnoTableFDP;
			objidIndex = objidTable;
			}
		else
			{
			Call( ErrDIRCreateDirectory(
						pfucbTableExtent,
						(CPG)0,
						&pgnoIndexFDP,
						&objidIndex,
						CPAGE::fPageIndex | ( idb.FUnique() ? 0 : CPAGE::fPageNonUniqueKeys ),
						fSPUnversionedExtent | ( idb.FUnique() ? 0 : fSPNonUnique ) ) );
			Assert( pgnoIndexFDP != pgnoTableFDP );
			Assert( objidIndex > objidSystemRoot );

			//	objids are monotonically increasing, so an index should
			//	always have higher objid than its table
			Assert( objidIndex > objidTable );
			}


		// Can hold pointers into the TDB's memory pool because the
		// template table has fixed DDL (and therefore, a fixed memory pool).
		Assert( pfcbTemplateTable->FFixedDDL() );

		const IDXSEG*	rgidxseg;
		const IDXSEG*	rgidxsegConditional;
		CHAR*			szIndexName;

		Assert( idb.Cidxseg() > 0 );
		rgidxseg = PidxsegIDBGetIdxSeg( pfcbIndex->Pidb(), pfcbTemplateTable->Ptdb() );
		rgidxsegConditional = PidxsegIDBGetIdxSegConditional( pfcbIndex->Pidb(), pfcbTemplateTable->Ptdb() );
		szIndexName = ptdbTemplateTable->SzIndexName( idb.ItagIndexName() );

		Assert( !idb.FVersioned() );
		Assert( !idb.FVersionedCreate() );

		Call( ErrCATAddTableIndex(
					ppib,
					pfucbCatalog,
					objidTable,
					szIndexName,
					pgnoIndexFDP,
					objidIndex,
					&idb,
					rgidxseg,
					rgidxsegConditional,
					pfcbIndex->UlDensity() ) );
		}

HandleError:
	if ( pfucbNil != pfucbCatalog )
		{
		CallS( ErrCATClose( ppib, pfucbCatalog ) );
		}

	Assert( pfucbTableExtent != pfucbNil );
	Assert( pfucbTableExtent->u.pfcb->WRefCount() == 1 );

	//	force the FCB to be uninitialized so it will be purged by DIRClose

	pfucbTableExtent->u.pfcb->Lock();
	pfucbTableExtent->u.pfcb->CreateComplete( errFCBUnusable );
	pfucbTableExtent->u.pfcb->Unlock();

	//	verify that this FUCB will not be defer-closed

	Assert( !FFUCBVersioned( pfucbTableExtent ) );

	//	close the FUCB

	DIRClose( pfucbTableExtent );

	return err;
	}


//  ================================================================
LOCAL ERR ErrFILEIValidateCallback(
	const PIB * const ppib,
	const IFMP ifmp,
	const OBJID objidTable,
	const JET_CBTYP cbtyp,
	const CHAR * const szCallback )
//  ================================================================
	{
	if( 0 == cbtyp )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}
	if( NULL == szCallback )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}
	if( strlen( szCallback ) >= JET_cbColumnMost )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}
	return JET_errSuccess;
	}


//  ================================================================
LOCAL ERR ErrFILEICreateCallbacks(
	PIB * const ppib,
	const IFMP ifmp,
	JET_TABLECREATE2 * const ptablecreate,
	const OBJID objidTable )
//  ================================================================
	{
	Assert( sizeof( JET_TABLECREATE2 ) == ptablecreate->cbStruct );

	ERR	err = JET_errSuccess;

	Call( ErrFILEIValidateCallback( ppib, ifmp, objidTable, ptablecreate->cbtyp, ptablecreate->szCallback ) );
	if( !g_fCallbacksDisabled )
		{
		JET_CALLBACK callback = NULL;
		Call( ErrCALLBACKResolve( ptablecreate->szCallback, &callback ) );
		Assert( NULL != callback );
		}
	Call( ErrCATAddTableCallback( ppib, ifmp, objidTable, ptablecreate->cbtyp, ptablecreate->szCallback ) );
	++(ptablecreate->cCreated);
	Assert( ptablecreate->cCreated <= 1 + ptablecreate->cColumns + ptablecreate->cIndexes + 1 );

HandleError:
	return err;
	}


//+API
// ErrFILECreateTable
// =========================================================================
// ERR ErrFILECreateTable( PIB *ppib, IFMP ifmp, CHAR *szName,
//		ULONG ulPages, ULONG ulDensity, FUCB **ppfucb )
//
// Create file with pathname szName.  Created file will have no fields or
// indexes defined (and so will be a "sequential" file ).
//
// PARAMETERS
//					ppib   			PIB of user
//					ifmp   			database id
//					szName			path name of new file
//					ulPages			initial page allocation for file
//					ulDensity		initial loading density
//					ppfucb			Exclusively locked FUCB on new file
// RETURNS		Error codes from DIRMAN or
//					 JET_errSuccess		Everything worked OK
//					-DensityInvalid	  	Density parameter not valid
//					-TableDuplicate   	A file already exists with the path given
// COMMENTS		A transaction is wrapped around this function.	Thus, any
//			 	work done will be undone if a failure occurs.
// SEE ALSO		ErrIsamAddColumn, ErrIsamCreateIndex, ErrIsamDeleteTable
//-
ERR ErrFILECreateTable( PIB *ppib, IFMP ifmp, JET_TABLECREATE2 *ptablecreate )
	{
	ERR		  	err;
	CHAR	  	szTable[JET_cbNameMost+1];
	FUCB	  	*pfucb;
	FDPINFO		fdpinfo;
	VER			*pver;
	BOOL		fOpenedTable	= fFalse;

	FMP::AssertVALIDIFMP( ifmp );
	Assert( sizeof(JET_TABLECREATE2) == ptablecreate->cbStruct );

	ptablecreate->cCreated = 0;

	//	check parms
	//
	CheckPIB(ppib );
	CheckDBID( ppib, ifmp );
	CallR( ErrUTILCheckName( szTable, ptablecreate->szTableName, JET_cbNameMost+1 ) );

	Assert( !( ptablecreate->grbit & JET_bitTableCreateSystemTable )
		|| FOLDSystemTable( szTable ) || FCATUnicodeFixupTable( szTable ) );

	ULONG		ulTableDensity		= ptablecreate->ulDensity;
	if ( 0 == ulTableDensity )
		{
		ulTableDensity = ulFILEDefaultDensity;
		}
	else if ( ulTableDensity < ulFILEDensityLeast || ulTableDensity > ulFILEDensityMost )
		{
		return ErrERRCheck( JET_errDensityInvalid );
		}

	const BOOL	fTemplateTable		= ( ptablecreate->grbit & JET_bitTableCreateTemplateTable );
	const BOOL	fDerived			= ( ptablecreate->szTemplateTableName != NULL );
	FCB			*pfcbTemplateTable	= pfcbNil;
	if ( fDerived )
		{
		FUCB	*pfucbTemplateTable;

		Assert( dbidTemp != rgfmp[ ifmp ].Dbid() );

		//	UNDONE:	nested hierarchical DDL not yet supported
		//
		Assert( !fTemplateTable );

		//	bring base table FCB into memory
		//
		CallR( ErrFILEOpenTable(
			ppib,
			ifmp,
			&pfucbTemplateTable,
			ptablecreate->szTemplateTableName,
			JET_bitTableReadOnly ) );

		Assert( pfcbNil == pfcbTemplateTable );
		if ( pfucbTemplateTable->u.pfcb->FTemplateTable() )
			{
			Assert( pfucbTemplateTable->u.pfcb->FFixedDDL() );
			pfcbTemplateTable = pfucbTemplateTable->u.pfcb;
			}

		//	close cursor.  FCB will be pinned in memory because
		//	FAvail_() checks for the TemplateTable flag.
		//
		CallS( ErrFILECloseTable( ppib, pfucbTemplateTable ) );

		if ( pfcbNil == pfcbTemplateTable )
			return ErrERRCheck( JET_errDDLNotInheritable );
		}

	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );

	//	allocate cursor
	//
	Call( ErrDIROpen( ppib, pgnoSystemRoot, ifmp, &pfucb ) );
	Call( ErrDIRCreateDirectory(
				pfucb,
				max( (CPG)ptablecreate->ulPages, cpgTableMin ),
				&fdpinfo.pgnoFDP,
				&fdpinfo.objidFDP,
				CPAGE::fPagePrimary,
				dbidTemp == rgfmp[ ifmp ].Dbid() ? fSPUnversionedExtent : 0 ) );	// For temp. tables, create unversioned extents
	DIRClose( pfucb );

	Assert( ptablecreate->cCreated == 0 );
	ptablecreate->cCreated = 1;

	if ( dbidTemp == rgfmp[ ifmp ].Dbid() )
		{
		//	don't currently support creation of columns/indexes for temp.
		//	tables via this API.
		Assert( 0 == ptablecreate->cColumns );
		Assert( 0 == ptablecreate->cIndexes );
		Assert( NULL == ptablecreate->szCallback );
		}

	else
		{
		Assert( !FCATSystemTable( fdpinfo.pgnoFDP ) );
		Assert( fdpinfo.objidFDP > objidSystemRoot );

		//	insert record in MSysObjects
		//
		JET_GRBIT	grbit;
		if ( fTemplateTable )
			{
			Assert( !fDerived );	// UNDONE: Nested hierarchical DDL not yet supported
			Assert( !( ptablecreate->grbit & JET_bitTableCreateSystemTable ) );
			grbit = ( JET_bitObjectTableTemplate | JET_bitObjectTableFixedDDL );
			}
		else
			{
			Assert( !( ptablecreate->grbit & JET_bitTableCreateNoFixedVarColumnsInDerivedTables ) );
			grbit = 0;
			if ( fDerived )
				grbit |= JET_bitObjectTableDerived;
			if ( ptablecreate->grbit & JET_bitTableCreateFixedDDL )
				grbit |= JET_bitObjectTableFixedDDL;
			if ( ptablecreate->grbit & JET_bitTableCreateSystemTable )
				{
				//	if calling CreateTable(), this must be a dynamic system table
				grbit |= JET_bitObjectSystemDynamic;
				Assert( FOLDSystemTable( szTable ) || FCATUnicodeFixupTable( szTable ) );
				}
			}

#ifdef DEBUG
		if ( fDerived )
			{
			Assert( pfcbNil != pfcbTemplateTable );
			Assert( NULL != ptablecreate->szTemplateTableName );
			}
		else
			{
			Assert( pfcbNil == pfcbTemplateTable );
			Assert( NULL == ptablecreate->szTemplateTableName );
			}
#endif

		Call( ErrCATAddTable(
					ppib,
					ifmp,
					fdpinfo.pgnoFDP,
					fdpinfo.objidFDP,
					szTable,
					ptablecreate->szTemplateTableName,
					ptablecreate->ulPages,
					ulTableDensity,
					grbit ) );


		//	create columns and indexes as necessary.

		if ( fDerived )
			{
			Call( ErrFILEIInheritIndexes(
					ppib,
					ifmp,
					ptablecreate,
					fdpinfo.pgnoFDP,
					fdpinfo.objidFDP,
					pfcbTemplateTable ) );
			}
		if ( ptablecreate->cColumns > 0 )
			{
			Call( ErrFILEIAddColumns(
					ppib,
					ifmp,
					ptablecreate,
					fdpinfo.objidFDP,
					pfcbTemplateTable ) );
			}
		Assert( ptablecreate->cCreated == 1 + ptablecreate->cColumns );

		if ( ptablecreate->cIndexes > 0 )
			{
			Call( ErrFILEICreateIndexes(
					ppib,
					ifmp,
					ptablecreate,
					fdpinfo.pgnoFDP,
					fdpinfo.objidFDP,
					ulTableDensity,
					pfcbTemplateTable ) );
			}

		if ( NULL != ptablecreate->szCallback )
			{
			Call( ErrFILEICreateCallbacks(
					ppib,
					ifmp,
					ptablecreate,
					fdpinfo.objidFDP ) );
			}

		}


	Assert( ptablecreate->cCreated == 1 + ptablecreate->cColumns + ptablecreate->cIndexes + ( ptablecreate->szCallback ? 1 : 0 ) );


	//	open table in exclusive mode, for output parameter
	//
	Call( ErrFILEOpenTable(
			ppib,
			ifmp,
			&pfucb,
			szTable,
			JET_bitTableCreate|JET_bitTableDenyRead,
			&fdpinfo ) );
	fOpenedTable = fTrue;

#ifdef DEBUG
	if ( 0 == ptablecreate->cColumns )
		{
		TDB	*ptdb = pfucb->u.pfcb->Ptdb();
		Assert( ptdb->FidFixedLast() == ptdb->FidFixedFirst()-1 );
		Assert( ptdb->FidVarLast() == ptdb->FidVarFirst()-1 );
		Assert( ptdb->FidTaggedLast() == ptdb->FidTaggedFirst()-1 );
		}
#endif

	// Allow DDL until table (cursor) is closed.
	if ( pfucb->u.pfcb->FFixedDDL() && !fTemplateTable )
		FUCBSetPermitDDL( pfucb );

	Assert( pfucb->u.pfcb->FInitialized() );
	Assert( pfucb->u.pfcb->FTypeTable() || pfucb->u.pfcb->FTypeTemporaryTable() );
	Assert( pfucb->u.pfcb->FPrimaryIndex() );

	pver = PverFromIfmp( pfucb->ifmp );
	Call( pver->ErrVERFlag( pfucb, operCreateTable, NULL, 0 ) );

	Call( ErrDIRCommitTransaction( ppib, 0 ) );

	/*	internally, we use tableid and pfucb interchangeably
	/**/
	ptablecreate->tableid = (JET_TABLEID)pfucb;

	return JET_errSuccess;

HandleError:
	if ( fOpenedTable )
		{
		CallS( ErrFILECloseTable( ppib, pfucb ) );
		}

	//	pfucb is closed by rollback if necessary
	//
	CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );

	//	reset return variable if close table via rollback
	//
	ptablecreate->tableid = JET_tableidNil;

	return err;
	}


//====================================================
// Determine field "mode" as follows:
// if ("long" textual || JET_bitColumnTagged given ) ==> TAGGED
// else if (numeric type || JET_bitColumnFixed given ) ==> FIXED
// else ==> VARIABLE
//====================================================
ERR ErrFILEGetNextColumnid(
	const JET_COLTYP	coltyp,
	const JET_GRBIT		grbit,
	const BOOL			fTemplateTable,
	TCIB				*ptcib,
	COLUMNID			*pcolumnid )
	{
	FID					fid;
	FID					fidMost;

	if ( ( grbit & JET_bitColumnTagged ) || FRECLongValue( coltyp ) || FRECSLV( coltyp ) )
		{
		Assert( fidTaggedLeast-1 == ptcib->fidTaggedLast || FTaggedFid( ptcib->fidTaggedLast ) );
		fid = ++(ptcib->fidTaggedLast);
		fidMost = fidTaggedMost;
		}
	else if ( ( grbit & JET_bitColumnFixed ) || FCOLTYPFixedLength( coltyp ) )
		{
		Assert( fidFixedLeast-1 == ptcib->fidFixedLast || FFixedFid( ptcib->fidFixedLast ) );
		fid = ++(ptcib->fidFixedLast);
		fidMost = fidFixedMost;
		}
	else
		{
		Assert( !( grbit & JET_bitColumnTagged ) );
		Assert( !( grbit & JET_bitColumnFixed ) );
		Assert( JET_coltypText == coltyp || JET_coltypBinary == coltyp );
		Assert( fidVarLeast-1 == ptcib->fidVarLast || FVarFid( ptcib->fidVarLast ) );
		fid = ++(ptcib->fidVarLast);
		fidMost = fidVarMost;
		}
	if ( fid > fidMost )
		{
		return ErrERRCheck( JET_errTooManyColumns );
		}
	*pcolumnid = ColumnidOfFid( fid, fTemplateTable );
	return JET_errSuccess;
	}

INLINE ERR ErrFILEIUpdateAutoInc( PIB *ppib, FUCB *pfucb )
	{
	ERR				err;
	QWORD			qwT				= 1;
	TDB				* const ptdb	= pfucb->u.pfcb->Ptdb();
	const BOOL		f8BytesAutoInc	= ptdb->F8BytesAutoInc();
	const BOOL		fTemplateColumn	= ptdb->FFixedTemplateColumn( ptdb->FidAutoincrement() );
	const COLUMNID	columnidT		= ColumnidOfFid( ptdb->FidAutoincrement(), fTemplateColumn );

	// set column does not allow sets over an
	// autoincrement column.  To work around this,
	// temporarily disable AutoInc column.
	Assert( pfucb->u.pfcb->FDomainDenyReadByUs( ppib ) );
	ptdb->ResetFidAutoincrement();

	err = ErrIsamMove( ppib, pfucb, JET_MoveFirst, NO_GRBIT );
	Assert( err <= 0 );
	while ( JET_errSuccess == err )
		{
		Call( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepReplaceNoLock ) );

		if ( !f8BytesAutoInc )
			{
			ULONG ulT;
			ulT = (ULONG)qwT;
			Call( ErrIsamSetColumn( ppib,
					pfucb,
					columnidT,
					(BYTE *)&ulT,
			  		sizeof(ulT),
					NO_GRBIT,
					NULL ) );
			}
		else
			{
			Call( ErrIsamSetColumn( ppib,
					pfucb,
					columnidT,
					(BYTE *)&qwT,
			  		sizeof(qwT),
					NO_GRBIT,
					NULL ) );
			}
		Call( ErrIsamUpdate( ppib, pfucb, NULL, 0, NULL, NO_GRBIT ) );

		qwT++;
		err = ErrIsamMove( ppib, pfucb, JET_MoveNext, NO_GRBIT );
		Assert( err <= 0 );
		}

	Assert( err < 0 );
	if ( JET_errNoCurrentRecord == err )
		{
		//	we have exclusive use of the table, so we should always succeed
		ptdb->SetFidAutoincrement( FidOfColumnid( columnidT ), f8BytesAutoInc );
		Assert( ptdb->QwAutoincrement() == 0 );
		ptdb->InitAutoincrement( qwT );
		Assert( ptdb->QwAutoincrement() == qwT );
		err = JET_errSuccess;
		}
	else
		{
HandleError:
		ptdb->SetFidAutoincrement( FidOfColumnid( columnidT ), f8BytesAutoInc );
		}

	return err;
	}


//+API
// ErrIsamAddColumn
// ========================================================================
// ERR ErrIsamAddColumn(
//		PIB				*ppib;			// IN PIB of user
//		FUCB			*pfucb;	 		// IN Exclusively opened FUCB on file
//		CHAR			*szName;		// IN name of new field
//		JET_COLUMNDEF	*pcolumndef		// IN definition of column added
//		BYTE			*pvDefault		// IN Default value of column
//		ULONG			cbDefault		// IN length of Default value
//		JET_COLUMNID	*pcolumnid )	// OUT columnid of added column
//
// Creates a new field definition for a file.
//
// PARAMETERS
//				pcolumndef->coltyp			data type of new field, see jet.h
//				pcolumndef->grbit  			field describing flags:
//					VALUE				MEANING
//					========================================
//					JET_bitColumnNotNULL		 	Indicates that the field may
//													not take on NULL values.
//					JET_bitColumnTagged		 		The field is a "tagged" field.
//					JET_bitColumnVersion		 	The field is a version field
//
// RETURNS		JET_errSuccess			Everything worked OK.
//					-TaggedDefault			A default value was specified
//												for a tagged field.
//					-ColumnDuplicate		There is already a field
//												defined for the name given.
// COMMENTS
//		There must not be anyone currently using the file, unless
//		the ErrIsamAddColumn is at level 0 [when non-exclusive ErrIsamAddColumn works].
//		A transaction is wrapped around this function.	Thus, any
//		work done will be undone if a failure occurs.
//		Transaction logging is turned off for temporary files.
//
// SEE ALSO		ErrIsamCreateTable, ErrIsamCreateIndex
//-
ERR VTAPI ErrIsamAddColumn(
	JET_SESID			sesid,
	JET_VTID			vtid,
	const CHAR		  	* const szName,
	const JET_COLUMNDEF	* const pcolumndef,
	const VOID		  	* const pvDefault,
	ULONG			  	cbDefault,
	JET_COLUMNID		* const pcolumnid )
	{
	ERR					err;
 	PIB					* const ppib				= reinterpret_cast<PIB *>( sesid );
	FUCB				* const pfucb				= reinterpret_cast<FUCB *>( vtid );
	TCIB				tcib;
	CHAR				szFieldName[JET_cbNameMost+1];
	FCB					*pfcb;
	TDB					*ptdb;
	JET_COLUMNID		columnid;
	VERADDCOLUMN		veraddcolumn;
	FIELD				field;
	BOOL		  		fMaxTruncated;
	ULONG				cFixed, cVar, cTagged;
	ULONG				cbFieldsTotal, cbFieldsUsed;
	BOOL				fInCritDDL					= fFalse;
	FIELD				*pfieldNew					= pfieldNil;
	BOOL				fUnversioned				= fFalse;
	BOOL				fSetVersioned				= fFalse;
	BOOL				fOverrideFixedDDL			= fFalse;
	VER					*pver;

	//  this is the data that will actually be inserted into the catalog
	const VOID			*pvDefaultAdd 				= pvDefault;
	ULONG				cbDefaultAdd 				= cbDefault;
	CHAR				*szCallbackAdd				= NULL;
	const VOID			*pvUserDataAdd				= NULL;
	ULONG				cbUserDataAdd				= 0;

	//	check paramaters
	//
	CallR( ErrPIBCheck( ppib ) );
	Assert( pfucb != pfucbNil );
	CheckTable( ppib, pfucb );
	FMP::AssertVALIDIFMP( pfucb->ifmp );

	//	ensure that table is updatable
	//
	CallR( ErrFUCBCheckUpdatable( pfucb ) );
	CallR( ErrPIBCheckUpdatable( ppib ) );

	pfcb = pfucb->u.pfcb;
	Assert( pfcb->WRefCount() > 0 );
	Assert( pfcb->FTypeTable() );	// Temp. tables have fixed DDL.

	ptdb = pfcb->Ptdb();
	Assert( ptdbNil != ptdb );

	if ( pfcb->FFixedDDL() )
		{
		// Check FixedDDL override.
		if ( !FFUCBPermitDDL( pfucb ) )
			return ErrERRCheck( JET_errFixedDDL );

		// If DDL temporarily permitted, we must have exclusive use of the table.
		Assert( pfcb->FDomainDenyReadByUs( ppib ) );

		fOverrideFixedDDL = fTrue;
		}

	if ( pcolumndef->cbStruct < sizeof(JET_COLUMNDEF) )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	if ( pcolumndef->grbit & JET_bitColumnUnversioned )
		{
		if ( !FFUCBDenyRead( pfucb ) )
			{
			if ( ppib->level != 0 )
				{
				AssertSz( fFalse, "Must not be in transaction for unversioned AddColumn." );
				err = ErrERRCheck( JET_errInTransaction );
				return err;
				}
			fUnversioned = fTrue;
			}
		}

	//	UNDONE:	interpret pvDefault of NULL for NULL value, and
	//			cbDefault == 0 and pvDefault != NULL as set to
	//			zero length.
	Assert( cbDefault == 0 || pvDefault != NULL );

	memset( &field, 0, sizeof(FIELD) );
	field.coltyp = FIELD_COLTYP( pcolumndef->coltyp );
	field.cbMaxLen = pcolumndef->cbMax;
	field.cp = pcolumndef->cp;

	CallR( ErrFILEIValidateAddColumn(
				szName,
				szFieldName,
				&field,
				pcolumndef->grbit,
				( pvDefault ? cbDefault : 0 ),
				pfcb->FDomainDenyReadByUs( ppib ),
				ptdb->PfcbTemplateTable() ) );
	fMaxTruncated = ( JET_wrnColumnMaxTruncated == err );

	if ( FRECSLV( field.coltyp ) && !rgfmp[pfucb->ifmp].FSLVAttached() )
		{
		err = ErrERRCheck( JET_errSLVStreamingFileNotCreated );
		return err;
		}

	if ( fUnversioned )
		{
		CallR( ErrFILEInsertIntoUnverColumnList( pfcb, szFieldName ) );
		}

	if ( FFIELDEscrowUpdate( field.ffield ) )
		{
		//  see the comment int ErrFILEIValidateAddColumn to find out why we
		//  cannot add an escrow column to a table with any records in it
		Assert( pfcb->FDomainDenyReadByUs( ppib ) );
		Assert( FFIELDDefault( field.ffield ) );

		//	check for any node there, even if it is deleted.  This
		//	is too strong since it may be deleted and committed,
		//	but this strong check ensures that no potentially there
		//	records exist.
		DIB dib;
		dib.dirflag = fDIRAllNode;
		dib.pos		= posFirst;
		DIRGotoRoot( pfucb );
		if ( ( err = ErrDIRDown( pfucb, &dib ) ) != JET_errRecordNotFound )
			{
			if ( JET_errSuccess == err )
				{
				err = ErrERRCheck( JET_errTableNotEmpty );
				DIRUp( pfucb );
				DIRDeferMoveFirst( pfucb );
				}
			return err;
			}
		DIRGotoRoot( pfucb );
		}

	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );

	const PGNO	pgnoFDP			= pfcb->PgnoFDP();
	const OBJID	objidTable		= pfcb->ObjidFDP();
	FUCB		fucbFake;		// for rebuilding default record
	FCB			fcbFake( pfucb->ifmp, pgnoFDP );

	if ( FFIELDDefault( field.ffield ) && !FFIELDUserDefinedDefault( field.ffield ) )
		{
		// pre-allocate buffer for rebuilding default record
		//
		FILEPrepareDefaultRecord( &fucbFake, &fcbFake, ptdb );
		Assert( fucbFake.pvWorkBuf != NULL );
		}
	else
		{
		fucbFake.pvWorkBuf = NULL;
		}

	//	move to FDP root and update FDP timestamp
	//
	Assert( ppib->level < levelMax );
	DIRGotoRoot( pfucb );

	pfcb->EnterDDL();
	fInCritDDL = fTrue;

	//	set tcib
	//
	tcib.fidFixedLast = ptdb->FidFixedLast();
	tcib.fidVarLast = ptdb->FidVarLast();
	tcib.fidTaggedLast = ptdb->FidTaggedLast();

	//******************************************************
	//	Determine maximum field length as follows:
	//	switch field type
	//		case numeric:
	//			max = <exact length of specified type>;
	//		case "short" textual ( Text || Binary ):
	//			if (specified max == 0 ) max = JET_cbColumnMost
	//			else max = MIN( JET_cbColumnMost, specified max )
	//		case "long" textual (Memo || Graphic ):
	//			max = specified max (if 0, unlimited )
	//*****************************************************
	//
	Assert( field.coltyp != JET_coltypNil );

	//	for fixed-length columns, make sure record not too big
	//
	Assert( ptdb->FidFixedLast() >= fidFixedLeast ?
		ptdb->IbEndFixedColumns() > ibRECStartFixedColumns :
		ptdb->IbEndFixedColumns() == ibRECStartFixedColumns );
	if ( ( ( pcolumndef->grbit & JET_bitColumnFixed ) || FCOLTYPFixedLength( field.coltyp ) )
		&& ptdb->IbEndFixedColumns() + field.cbMaxLen > cbRECRecordMost )
		{
		err = ErrERRCheck( JET_errRecordTooBig );
		goto HandleError;
		}

	Call( ErrFILEGetNextColumnid(
			field.coltyp,
			pcolumndef->grbit,
			ptdb->FTemplateTable(),
			&tcib,
			&columnid ) );

	if ( pcolumnid != NULL )
		{
		*pcolumnid = columnid;
		}

	//	version and autoincrement are mutually exclusive
	//
	if ( FFIELDVersion( field.ffield ) )
		{
		if ( ptdb->FidVersion() != 0 )
			{
			err = ErrERRCheck( JET_errColumnRedundant );
			goto HandleError;
			}
		ptdb->SetFidVersion( FidOfColumnid( columnid ) );
		}
	else if ( FFIELDAutoincrement( field.ffield ) )
		{
		if ( ptdb->FidAutoincrement() != 0 )
			{
			err = ErrERRCheck( JET_errColumnRedundant );
			goto HandleError;
			}
		ptdb->SetFidAutoincrement( FidOfColumnid( columnid ), field.coltyp == JET_coltypCurrency );
		}

	//	update TDB and default record value
	//
	cFixed = ptdb->CDynamicFixedColumns();
	cVar = ptdb->CDynamicVarColumns();
	cTagged = ptdb->CDynamicTaggedColumns();
	cbFieldsUsed = ( cFixed + cVar + cTagged ) * sizeof(FIELD);
	cbFieldsTotal = ptdb->MemPool().CbGetEntry( itagTDBFields );

	//	WARNING: if cbFieldsTotal is less than even one FIELD,
	//	this is the special-case where we just stuck in a
	//	placeholder in the MEMPOOL for the FIELD structures
	if ( cbFieldsTotal < sizeof(FIELD) )
		{
		Assert( cbFIELDPlaceholder == cbFieldsTotal );
		Assert( 0 == cbFieldsUsed );
		cbFieldsTotal = 0;
		}

	Assert( cbFieldsTotal >= cbFieldsUsed );

	// Is there enough space to add another FIELD?
	if ( sizeof(FIELD) > ( cbFieldsTotal - cbFieldsUsed ) )
		{
		//	add space for another 10 columns
		//
		Call( ptdb->MemPool().ErrReplaceEntry(
			itagTDBFields,
			NULL,
			cbFieldsTotal + ( sizeof(FIELD) * 10 )
			) );
		}

	//	add the column name to the buffer
	//
	Call( ptdb->MemPool().ErrAddEntry(
							reinterpret_cast<BYTE *>( szFieldName ),
							(ULONG)strlen( szFieldName ) + 1,
							&field.itagFieldName ) );
	field.strhashFieldName = StrHashValue( szFieldName );
	Assert( field.itagFieldName != 0 );

	veraddcolumn.columnid = columnid;

	Assert( NULL != ptdb->PdataDefaultRecord() );
	if ( FFIELDDefault( field.ffield )
		&& !FFIELDUserDefinedDefault( field.ffield ) )
		{
		//	note that if AddColumn rolls back, the memory may end up
		//	on the FCB RECDANGLING list,
		veraddcolumn.pbOldDefaultRec = (BYTE *)ptdb->PdataDefaultRecord();
		}
	else
		{
		veraddcolumn.pbOldDefaultRec = NULL;
		}

	pver = PverFromIfmp( pfucb->ifmp );
	err = pver->ErrVERFlag( pfucb, operAddColumn, (VOID *)&veraddcolumn, sizeof(VERADDCOLUMN) );
	if ( err < 0 )
		{
		ptdb->MemPool().DeleteEntry( field.itagFieldName );
		field.itagFieldName = 0;
		goto HandleError;
		}

	// If we have the table exclusively locked, then there's no need to
	// set the Versioned bit.
	Assert( !pfcb->FDomainDenyRead( ppib ) );
	if ( !pfcb->FDomainDenyReadByUs( ppib ) )
		{
		FIELDSetVersioned( field.ffield );
		FIELDSetVersionedAdd( field.ffield );
		fSetVersioned = fTrue;
		}

	if ( pfcb->FTemplateTable() )
		{
		Assert( FCOLUMNIDTemplateColumn( columnid ) );
		FIELDSetTemplateColumnESE98( field.ffield );
		}
	else
		{
		Assert( !FCOLUMNIDTemplateColumn( columnid ) );
		}

	//	incrementing fidFixed/Var/TaggedLast guarantees that a new FIELD structure
	//	was added -- rollback checks for this.
	//
	Assert( pfieldNil == pfieldNew );
	if ( FCOLUMNIDFixed( columnid ) )
		{
		Assert( FidOfColumnid( columnid ) == ptdb->FidFixedLast() + 1 );
		ptdb->IncrementFidFixedLast();
		Assert( FFixedFid( ptdb->FidFixedLast() ) );
		pfieldNew = ptdb->PfieldFixed( columnid );

		//	Adjust the location of the FIELD structures for tagged and variable
		//	columns to accommodate the insertion of a fixed column FIELD structure
		//	and its associated entry in the fixed offsets table.
		//	Thus, the new fixed column FIELD structure is now located where
		//	the variable column FIELD structures used to start.
		memmove(
			(BYTE *)pfieldNew + sizeof(FIELD),
			pfieldNew,
			sizeof(FIELD) * ( cVar + cTagged )
			);

		field.ibRecordOffset = ptdb->IbEndFixedColumns();

		Assert( ptdb->Pfield( columnid ) == pfieldNew );
		*pfieldNew = field;

		Assert( field.ibRecordOffset + field.cbMaxLen <= cbRECRecordMost );
		ptdb->SetIbEndFixedColumns( (WORD)( field.ibRecordOffset + field.cbMaxLen ), ptdb->FidFixedLast() );
		}
	else
		{
		if ( FCOLUMNIDTagged( columnid ) )
			{
			Assert( FidOfColumnid( columnid ) == ptdb->FidTaggedLast() + 1 );

			// Append the new FIELD structure to the end of the tagged column
			// FIELD structures.
			ptdb->IncrementFidTaggedLast();
			Assert( FTaggedFid( ptdb->FidTaggedLast() ) );
			pfieldNew = ptdb->PfieldTagged( columnid );

			//	WARNING:	if the add-column rolls back this flag will not be unset

			if( JET_coltypSLV == field.coltyp )
				{
				//	set the SLV flag
				ptdb->SetFTableHasSLVColumn();
				}
			}
		else
			{
			// The new variable column FIELD structure, now located where
			// the tagged column FIELD structures used to start.
			Assert( FCOLUMNIDVar( columnid ) );
			Assert( FidOfColumnid( columnid ) == ptdb->FidVarLast() + 1 );
			ptdb->IncrementFidVarLast();
			Assert( FVarFid( ptdb->FidVarLast() ) );
			pfieldNew = ptdb->PfieldVar( columnid );

			//	adjust the location of the FIELD structures for tagged columns to
			//	accommodate the insertion of the variable column FIELD structure.
			memmove( pfieldNew + 1, pfieldNew, sizeof(FIELD) * cTagged );
			}

		Assert( ptdb->Pfield( columnid ) == pfieldNew );
		*pfieldNew = field;
		}


	Assert( field.itagFieldName != 0 );
	field.itagFieldName = 0;	// From this point on, version cleanup
								// will reclaim name space on rollback.

	if ( FFIELDUserDefinedDefault( field.ffield ) )
		{
		//  the size of the structure should have been checked by ErrFILEIValidateAddColumn
		Assert( NULL != pvDefault );
		Assert( sizeof( JET_USERDEFINEDDEFAULT ) == cbDefault );

		JET_USERDEFINEDDEFAULT * const pudd = (JET_USERDEFINEDDEFAULT *)pvDefault;

		JET_CALLBACK callback;
		Call( ErrCALLBACKResolve( pudd->szCallback, &callback ) );

		CBDESC * const pcbdesc = new CBDESC;
		BYTE * const pbUserData = ( ( pudd->cbUserData > 0 ) ?
						(BYTE *)PvOSMemoryHeapAlloc( pudd->cbUserData ) : NULL );

		if( NULL == pcbdesc
			|| ( NULL == pbUserData && pudd->cbUserData > 0 ) )
			{
			delete pcbdesc;
			OSMemoryHeapFree( pbUserData );
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}

		//  we should not fail between this point and registering the CBDESC in the TDB
		//  once the CBDESC is in the TDB it will be freed by TDB::Delete

		memcpy( pbUserData, pudd->pbUserData, pudd->cbUserData );

		pcbdesc->pcallback 	= callback;
		pcbdesc->cbtyp 		= JET_cbtypUserDefinedDefaultValue;
		pcbdesc->pvContext 	= pbUserData;
		pcbdesc->cbContext 	= pudd->cbUserData;
		pcbdesc->ulId 		= columnid;
		pcbdesc->fPermanent = 1;
		pcbdesc->fVersioned = 0;

		//  for user-defined-defaults we don't store a default value at all
		pvDefaultAdd 	= NULL;
		cbDefaultAdd 	= 0;
		szCallbackAdd	= pudd->szCallback;
		pvUserDataAdd 	= pudd->pbUserData;
		cbUserDataAdd 	= pudd->cbUserData;

		pfcb->AssertDDL();
		ptdb->RegisterPcbdesc( pcbdesc );

		ptdb->SetFTableHasUserDefinedDefault();
		ptdb->SetFTableHasNonEscrowDefault();
		ptdb->SetFTableHasDefault();
		}
	else if ( FFIELDDefault( field.ffield ) )
		{
		DATA	dataDefault;

		Assert( cbDefault > 0 );
		Assert( pvDefault != NULL );
		dataDefault.SetCb( cbDefault );
		dataDefault.SetPv( (VOID *)pvDefault );

		Assert( fucbFake.pvWorkBuf != NULL );
		Assert( fucbFake.u.pfcb == &fcbFake );
		Assert( fcbFake.Ptdb() == ptdb );
		Call( ErrFILERebuildDefaultRec( &fucbFake, columnid, &dataDefault ) );

		Assert( NULL != veraddcolumn.pbOldDefaultRec );
		Assert( veraddcolumn.pbOldDefaultRec != (BYTE *)ptdb->PdataDefaultRecord() );
		if ( rgfmp[pfucb->ifmp].FVersioningOff() )
			{
			//	versioning disabled, but we normally rely on version cleanup
			//	to take clean up pbOldDefaultRec, so instead we need to
			//	manually put it on the RECDANGLING list
			for ( RECDANGLING * precdangling = pfcb->Precdangling();
				;
				precdangling = precdangling->precdanglingNext )
				{
				if ( NULL == precdangling )
					{
					//	not in list, so add it;
					//	assumes that the memory pointed to by pmemdangling is always at
					//	least sizeof(ULONG_PTR) bytes
					Assert( NULL == ( (RECDANGLING *)veraddcolumn.pbOldDefaultRec )->precdanglingNext );
					( (RECDANGLING *)veraddcolumn.pbOldDefaultRec )->precdanglingNext = pfcb->Precdangling();
					pfcb->SetPrecdangling( (RECDANGLING *)veraddcolumn.pbOldDefaultRec );
					break;
					}
				else if ( (BYTE *)precdangling == veraddcolumn.pbOldDefaultRec )
					{
					//	pointer is already in the list, just get out
					AssertTracking();
					break;
					}
				}
			}

		if ( !FFIELDEscrowUpdate( field.ffield ) )
			{
			ptdb->SetFTableHasNonEscrowDefault();
			}
		ptdb->SetFTableHasDefault();
		}

	pfcb->LeaveDDL();
	fInCritDDL = fFalse;

	//	set currency before first
	//
	DIRBeforeFirst( pfucb );
	if ( pfucb->pfucbCurIndex != pfucbNil )
		{
		DIRBeforeFirst( pfucb->pfucbCurIndex );
		}

	// Insert record into MSysColumns.
	Call( ErrCATAddTableColumn(
				ppib,
				pfucb->ifmp,
				objidTable,
				szFieldName,
				columnid,
				&field,
				pvDefaultAdd,
				cbDefaultAdd,
				szCallbackAdd,
				pvUserDataAdd,
				cbUserDataAdd ) );

	if ( ( pcolumndef->grbit & JET_bitColumnAutoincrement ) != 0 )
		{
		Call( ErrFILEIUpdateAutoInc( ppib, pfucb ) );
		}

	Call( ErrDIRCommitTransaction( ppib, 0 ) );

	FILEFreeDefaultRecord( &fucbFake );

	if ( fMaxTruncated )
		return ErrERRCheck( JET_wrnColumnMaxTruncated );

	AssertDIRNoLatch( ppib );

	if ( fUnversioned )
		{
		if ( fSetVersioned )
			{
			// On success, reset versioned bit (on error, bit reset by rollback)
			FIELD	*pfieldT;
			pfcb->EnterDDL();
			Assert( pfcb->Ptdb() == ptdb );
			pfieldT = ptdb->Pfield( columnid );
			FIELDResetVersioned( pfieldT->ffield );
			FIELDResetVersionedAdd( pfieldT->ffield );
			pfcb->LeaveDDL();
			}

		FILERemoveFromUnverList( &punvercolGlobal, critUnverCol, objidTable, szFieldName );
		}

	return JET_errSuccess;

HandleError:
	//	For FixedDDL tables, we assume such tables NEVER have deleted columns,
	//	so we can't tolerate the hack where we set the FIELD of the rolled-back
	//	column to deleted

	// Verify name space has been reclaimed.
	Assert( field.itagFieldName == 0 );

	if ( fInCritDDL )
		{
		pfcb->LeaveDDL();
		}

	FILEFreeDefaultRecord( &fucbFake );

	CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );

	if ( fUnversioned )
		{
		FILERemoveFromUnverList( &punvercolGlobal, critUnverCol, objidTable, szFieldName );
		}

	AssertDIRNoLatch( ppib );

	return err;
	}


LOCAL ERR ErrFILEIAddSecondaryIndexEntriesForPrimaryKey(
	FUCB			* const pfucbTable,
	FCB				* const pfcbIndex,
	DATA&			dataRec,
	const DATA&		dataPrimaryBM,
	FUCB			* const pfucbSort,
	KEY&			keyBuffer,
	const BOOL		fPermitUnicodeFixup,
	LONG			*pcEntriesAdded
	)
	{
	ERR				err;
	IDB				* const pidb			= pfcbIndex->Pidb();
	BOOL			fNullKey				= fFalse;
	BOOL			fUndefinedUnicodeChars	= fFalse;
	ULONG			itagSequence;

#ifdef DEBUG
	//	latch status shouldn't change during this function
	const BOOL		fLatched	= Pcsr( pfucbTable )->FLatched();
#endif

	*pcEntriesAdded = 0;

	for ( itagSequence = 1; ; itagSequence++ )
		{
		//	latch status shouldn't change during this function
		Assert( ( fLatched && Pcsr( pfucbTable )->FLatched() )
			|| ( !fLatched && !Pcsr( pfucbTable )->FLatched() ) );

		CallR( ErrRECIRetrieveKey(
				pfucbTable,
				pidb,
				dataRec,
				&keyBuffer,
				itagSequence,
				0,
				&fUndefinedUnicodeChars,
				fFalse,
				prceNil ) );

		//	latch status shouldn't change during this function
		Assert( ( fLatched && Pcsr( pfucbTable )->FLatched() )
			|| ( !fLatched && !Pcsr( pfucbTable )->FLatched() ) );

		CallS( ErrRECValidIndexKeyWarning( err ) );

		const ERR	errRetrieveKey	= err;		//	for debugging

		if ( JET_errSuccess == err )
			{
			//	insert key (below)
			}

		else if ( wrnFLDOutOfKeys == err )
			{
			Assert( itagSequence > 1 );
			break;
			}

		else if ( wrnFLDOutOfTuples == err )
			{
			//	try next itagSequence
			Assert( pidb->FTuples() );
			if ( pidb->FMultivalued() )
				continue;
			else
				break;
			}

		else if ( wrnFLDNotPresentInIndex == err )
			{
			Assert( 1 == itagSequence );
			break;
			}

		else
			{
			//	should not receive any other type of warnings
			//	if this is a tuple index (because there's
			//	only one column in the index)
			Assert( !pidb->FTuples() );

			Assert( wrnFLDNullSeg == err
				|| wrnFLDNullFirstSeg == err
				|| wrnFLDNullKey == err );

			if ( pidb->FNoNullSeg() )
				{
				err = ErrERRCheck( JET_errNullKeyDisallowed );
				return err;
				}

			if ( wrnFLDNullKey == err )
				{
				Assert( 1 == itagSequence );	//	nulls beyond itagSequence 1 would have generated wrnFLDOutOfKeys
				if ( !pidb->FAllowAllNulls() )
					{
					//	do not insert NULL key as indicated
					break;
					}
				fNullKey = fTrue;
				}
			else if ( wrnFLDNullFirstSeg == err )
				{
				if ( !pidb->FAllowFirstNull() )
					{
					//	do not insert keys with NULL first
					//	segment as indicated
					break;
					}
				}
			else
				{
				Assert( wrnFLDNullSeg == err );
				if ( !pidb->FAllowSomeNulls() )
					{
					//	do not insert keys with null
					//	segment as indicated
					break;
					}
				}
			}

		Assert( keyBuffer.Cb() <= JET_cbSecondaryKeyMost );
		CallR( ErrSORTInsert( pfucbSort, keyBuffer, dataPrimaryBM ) );
		(*pcEntriesAdded)++;

		if( fUndefinedUnicodeChars )
			{
			const OBJID objidTable 	= pfucbTable->u.pfcb->ObjidFDP();
			const OBJID	objidIndex	= pfcbIndex->ObjidFDP();
			const LCID	lcid		= pidb->Lcid();
			const INT	itag		= itagSequence;
			const INT	ichOffset	= 0;

			KEY	primaryKey;
			primaryKey.prefix.Nullify();
			primaryKey.suffix = dataPrimaryBM;

			RECReportUndefinedUnicodeEntry(
				objidTable,
				objidIndex,
				primaryKey,
				keyBuffer,
				lcid,
				itag,
				ichOffset,
				fTrue );

			if( pidb->FUnicodeFixupOn() )
				{
				if ( fPermitUnicodeFixup )
					{
					CallR( ErrCATInsertMSURecord(
								pfucbTable->ppib,
								pfucbTable->ifmp,
								pfucbNil,
								objidTable,
								objidIndex,
								primaryKey,
								keyBuffer,
								lcid,
								itag,
								ichOffset ) );
					}
				else
					{
					//	UNDONE: we're potentially building
					//	an index concurrently, and it's too
					//	complicated to try to update the
					//	fixup table in a correctly-versioned
					//	manner, so just flag the index as
					//	having fixups disabled
					//
					pidb->ResetFUnicodeFixupOn();
					}
				}
			}

		if ( pidb->FTuples() )
			{
			//	if we received a warning on the first tuple,
			//	the logic above should ensure we don't
			//	try to create further tuples
			CallS( errRetrieveKey );

			for ( ULONG ichOffset = 1; ichOffset < pidb->ChTuplesToIndexMax(); ichOffset++ )
				{
				//	latch status shouldn't change during this function
				Assert( ( fLatched && Pcsr( pfucbTable )->FLatched() )
					|| ( !fLatched && !Pcsr( pfucbTable )->FLatched() ) );

				CallR( ErrRECIRetrieveKey(
						pfucbTable,
						pidb,
						dataRec,
						&keyBuffer,
						itagSequence,
						ichOffset,
						&fUndefinedUnicodeChars,
						fFalse,
						prceNil ) );

				//	latch status shouldn't change during this function
				Assert( ( fLatched && Pcsr( pfucbTable )->FLatched() )
					|| ( !fLatched && !Pcsr( pfucbTable )->FLatched() ) );

				//	all other warnings should have been detected
				//	when we retrieved with ichOffset==0
				CallSx( err, wrnFLDOutOfTuples );
				if ( JET_errSuccess != err )
					break;

				Assert( keyBuffer.Cb() <= JET_cbSecondaryKeyMost );
				CallR( ErrSORTInsert( pfucbSort, keyBuffer, dataPrimaryBM ) );
				(*pcEntriesAdded)++;

				if( fUndefinedUnicodeChars )
					{
					const OBJID objidTable 	= pfucbTable->u.pfcb->ObjidFDP();
					const OBJID	objidIndex	= pfcbIndex->ObjidFDP();
					const LCID	lcid		= pidb->Lcid();
					const INT	itag		= itagSequence;

					KEY	primaryKey;
					primaryKey.prefix.Nullify();
					primaryKey.suffix = dataPrimaryBM;

					RECReportUndefinedUnicodeEntry(
						objidTable,
						objidIndex,
						primaryKey,
						keyBuffer,
						lcid,
						itag,
						ichOffset,
						fTrue );

					if( pidb->FUnicodeFixupOn() )
						{
						if ( fPermitUnicodeFixup )
							{
							CallR( ErrCATInsertMSURecord(
										pfucbTable->ppib,
										pfucbTable->ifmp,
										pfucbNil,
										objidTable,
										objidIndex,
										primaryKey,
										keyBuffer,
										lcid,
										itag,
										ichOffset ) );
							}
						else
							{
							//	UNDONE: we're potentially building
							//	an index concurrently, and it's too
							//	complicated to try to update the
							//	fixup table in a correctly-versioned
							//	manner, so just flag the index as
							//	having fixups disabled
							//
							pidb->ResetFUnicodeFixupOn();
							}
						}
					}
				}
			}

		if ( !pidb->FMultivalued() || fNullKey )
			{
			//	if no multivalues in this index, there's no point going beyond first itagSequence
			//	if key is null, this implies there are no further multivalues
			Assert( 1 == itagSequence );	//	nulls beyond itagSequence 1 would have generated wrnFLDOutOfKeys
			break;
			}
		}

	//	latch status shouldn't change during this function
	Assert( ( fLatched && Pcsr( pfucbTable )->FLatched() )
		|| ( !fLatched && !Pcsr( pfucbTable )->FLatched() ) );

	return JET_errSuccess;
	}

INLINE ERR ErrFILEIndexProgress( STATUSINFO	* const pstatus )
	{
	JET_SNPROG	snprog;

	Assert( pstatus->pfnStatus );
	Assert( pstatus->snt == JET_sntProgress );

	pstatus->cunitDone += pstatus->cunitPerProgression;

	Assert( pstatus->cunitProjected <= pstatus->cunitTotal );
	if ( pstatus->cunitDone > pstatus->cunitProjected )
		{
		Assert( fGlobalRepair );
		pstatus->cunitPerProgression = 0;
		pstatus->cunitDone = pstatus->cunitProjected;
		}

	Assert( pstatus->cunitDone <= pstatus->cunitTotal );

	snprog.cbStruct = sizeof( JET_SNPROG );
	snprog.cunitDone = pstatus->cunitDone;
	snprog.cunitTotal = pstatus->cunitTotal;

	return ( ERR )( *pstatus->pfnStatus )(
		pstatus->sesid,
		pstatus->snp,
		pstatus->snt,
		&snprog );
	}


ERR ErrFILEIndexBatchInit(
	PIB			* const ppib,
	FUCB		** const rgpfucbSort,
	FCB			* const pfcbIndexesToBuild,
	INT			* const pcIndexesToBuild,
	ULONG		* const rgcRecInput,
	FCB			**ppfcbNextBuildIndex,
	const ULONG	cIndexBatchMax )
	{
	ERR			err;
	FCB			*pfcbIndex;
	INT			iindex;

	Assert( pfcbNil != pfcbIndexesToBuild );
	Assert( cIndexBatchMax > 0 );

	iindex = 0;
	for ( pfcbIndex = pfcbIndexesToBuild;
		pfcbIndex != pfcbNil;
		pfcbIndex = pfcbIndex->PfcbNextIndex() )
		{
		Assert( pfcbIndex->Pidb() != pidbNil );
		Assert( pfcbIndex->FTypeSecondaryIndex() );
		Assert( pfcbIndex->FInitialized() );

		//	open sort
		//
		CallR( ErrSORTOpen( ppib, &rgpfucbSort[iindex], pfcbIndex->Pidb()->FUnique(), fTrue ) );

		rgcRecInput[iindex] = 0;

		iindex++;

		if ( cIndexBatchMax == iindex )
			{
			break;
			}
		}

	*pcIndexesToBuild = iindex;
	Assert( *pcIndexesToBuild > 0 );

	if ( NULL != ppfcbNextBuildIndex )
		{
		if ( cIndexBatchMax == *pcIndexesToBuild )
			*ppfcbNextBuildIndex = pfcbIndex->PfcbNextIndex();
		else
			*ppfcbNextBuildIndex = pfcbNil;
		}

	return JET_errSuccess;
	}

ERR ErrFILEIndexBatchAddEntry(
	FUCB			** const rgpfucbSort,
	FUCB			* const pfucbTable,
	const BOOKMARK	* const pbmPrimary,
	DATA&			dataRec,
	FCB				* const pfcbIndexesToBuild,
	const INT		cIndexesToBuild,
	ULONG			* const rgcRecInput,
	KEY&			keyBuffer )
	{
	ERR				err;
	FCB				*pfcbIndex;
	INT				iindex;
	LONG			cSecondaryIndexEntriesAdded;

	Assert( pfcbNil != pfcbIndexesToBuild );
	Assert( cIndexesToBuild > 0 );

	Assert( pbmPrimary->key.prefix.FNull() );
	Assert( pbmPrimary->data.FNull() );

	pfcbIndex = pfcbIndexesToBuild;
	for ( iindex = 0; iindex < cIndexesToBuild; iindex++, pfcbIndex = pfcbIndex->PfcbNextIndex() )
		{
		Assert( pfcbNil != pfcbIndex );
		Assert( pidbNil != pfcbIndex->Pidb() );
		CallR( ErrFILEIAddSecondaryIndexEntriesForPrimaryKey(
					pfucbTable,
					pfcbIndex,
					dataRec,
					pbmPrimary->key.suffix,
					rgpfucbSort[iindex],
					keyBuffer,
					fTrue,
					&cSecondaryIndexEntriesAdded
					) );

		Assert( cSecondaryIndexEntriesAdded >= 0 );
		rgcRecInput[iindex] += cSecondaryIndexEntriesAdded;
		}

	return JET_errSuccess;
	}


INLINE ERR ErrFILEIAppendToIndex(
	FUCB		* const pfucbSort,
	FUCB		* const pfucbIndex,
	ULONG		*pcRecOutput,
	const BOOL	fLogged )
	{
	ERR				err;
	const INT		fDIRFlags	= ( fDIRNoVersion | fDIRAppend | ( fLogged ? 0 : fDIRNoLog ) );
	INST * const	pinst		= PinstFromPfucb( pfucbIndex );

	CallR( ErrDIRInitAppend( pfucbIndex ) );
	do
		{
		//	this loop can take some time, so see if we need
		//	to terminate because of shutdown
		//
		CallR( pinst->ErrCheckForTermination() );

		//	don't want to fill up reserve logs with index entries,
		//	so bail out if we're in the reserve logs (or out
		//	of log disk entirely)
		//
		//	NOTE: must check even if fLogged is FALSE
		//	because we may be in the pseudo-logging-disabled
		//	state where logging is actually enabled, but
		//	we're not logging batch index creation, but
		//	we are still logging space operations, so we may
		//	end up filling the logs with that
		//
		CallR( ErrLGCheckState( pinst->m_plog ) );

		CallR( ErrDIRAppend(
					pfucbIndex,
					pfucbSort->kdfCurr.key,
					pfucbSort->kdfCurr.data,
					fDIRFlags ) );
		Assert( Pcsr( pfucbIndex )->FLatched() );
		(*pcRecOutput)++;

		err = ErrSORTNext( pfucbSort );
		}
	while ( err >= 0 );

	if ( JET_errNoCurrentRecord == err )
		err = ErrDIRTermAppend( pfucbIndex );

	return err;
	}


// Don't make this INLINE, since it's just error-handling code.
LOCAL VOID FILEIReportIndexCorrupt( FUCB * const pfucbIndex, CPRINTF * const pcprintf )
	{

	FCB			*pfcbIndex = pfucbIndex->u.pfcb;
	Assert( pfcbNil != pfcbIndex );
	Assert( pfcbIndex->FTypeSecondaryIndex() );
	Assert( pfcbIndex->Pidb() != pidbNil );

	FCB			*pfcbTable = pfcbIndex->PfcbTable();
	Assert( pfcbNil != pfcbTable );
	Assert( pfcbTable->FTypeTable() );
	Assert( pfcbTable->Ptdb() != ptdbNil );

	// Strictly speaking, EnterDML() is not needed because this
	// function only gets executed by the consistency-checker,
	// which is single-threaded.  However, make the call anyway
	// to avoid potential bugs in the future if this function
	// ever gets used in multi-threaded situations.
	pfcbTable->EnterDML();
	(*pcprintf)(
		"Table \"%s\", Index \"%s\"%s:  ",
		pfcbTable->Ptdb()->SzTableName(),
		pfcbTable->Ptdb()->SzIndexName( pfcbIndex->Pidb()->ItagIndexName(), pfcbIndex->FDerivedIndex() ),
		pfcbIndex->Pidb()->FLocalizedText() ? " (localized text)" : "" );
	pfcbTable->LeaveDML();
	}


INLINE ERR ErrFILEICheckIndex(
	FUCB	* const pfucbSort,
	FUCB	* const pfucbIndex,
	ULONG	*pcRecSeen,
	BOOL	*pfCorruptedIndex,
	CPRINTF	* const pcprintf )
	{
	ERR		err;
	DIB 	dib;
	dib.dirflag = fDIRNull;
	dib.pos		= posFirst;

	Assert( NULL != pfCorruptedIndex );

	FUCBSetPrereadForward( pfucbIndex, cpgPrereadSequential );

	Call( ErrBTDown( pfucbIndex, &dib, latchReadTouch ) );

	do
		{
		(*pcRecSeen)++;

		Assert( Pcsr( pfucbIndex )->FLatched() );

		INT cmp = CmpKeyData( pfucbIndex->kdfCurr, pfucbSort->kdfCurr );
		if( 0 != cmp )
			{
			FILEIReportIndexCorrupt( pfucbIndex, pcprintf );
			(*pcprintf)(	"index entry %d [%d:%d] (objid %d) inconsistent\r\n",
							*pcRecSeen,
							Pcsr( pfucbIndex )->Pgno(),
							Pcsr( pfucbIndex )->ILine(),
							Pcsr( pfucbIndex )->Cpage().ObjidFDP() );

			BYTE rgbBuf[JET_cbKeyMost+1];
			CHAR rgchBuf[1024];

			INT ib;
			INT ibMax;
			const BYTE * pb;
			CHAR * pchBuf;

			pfucbIndex->kdfCurr.key.CopyIntoBuffer( rgbBuf, sizeof( rgbBuf ) );
			pb = rgbBuf;
			ibMax = pfucbIndex->kdfCurr.key.Cb();
			pchBuf = rgchBuf;
			for( ib = 0; ib < ibMax; ++ib )
				{
				pchBuf += sprintf( pchBuf, " %2.2x", pb[ib] );
				}
			(*pcprintf)( "\tkey in database (%d bytes):%s\r\n", ibMax, rgchBuf );

			pb = (BYTE*)pfucbIndex->kdfCurr.data.Pv();
			ibMax = pfucbIndex->kdfCurr.data.Cb();
			pchBuf = rgchBuf;
			for( ib = 0; ib < ibMax; ++ib )
				{
				pchBuf += sprintf( pchBuf, " %2.2x", pb[ib] );
				}
			(*pcprintf)( "\tdata in database (%d bytes):%s\r\n", ibMax, rgchBuf );

			pfucbSort->kdfCurr.key.CopyIntoBuffer( rgbBuf, sizeof( rgbBuf ) );
			pb = rgbBuf;
			ibMax = pfucbSort->kdfCurr.key.Cb();
			pchBuf = rgchBuf;
			for( ib = 0; ib < ibMax; ++ib )
				{
				pchBuf += sprintf( pchBuf, " %2.2x", pb[ib] );
				}
			(*pcprintf)( "\tcalculated key (%d bytes):%s\r\n", ibMax, rgchBuf );

			pb = (BYTE*)pfucbSort->kdfCurr.data.Pv();
			ibMax = pfucbSort->kdfCurr.data.Cb();
			pchBuf = rgchBuf;
			for( ib = 0; ib < ibMax; ++ib )
				{
				pchBuf += sprintf( pchBuf, " %2.2x", pb[ib] );
				}
			(*pcprintf)( "\tcalculated data (%d bytes):%s\r\n", ibMax, rgchBuf );

			*pfCorruptedIndex = fTrue;
			break;
			}

		err = ErrBTNext( pfucbIndex, fDIRNull );
		if( err < 0 )
			{
			if ( JET_errNoCurrentRecord == err
				&& JET_errNoCurrentRecord != ErrSORTNext( pfucbSort ) )
				{
				FILEIReportIndexCorrupt( pfucbIndex, pcprintf );
				(*pcprintf)( "real index has fewer (%d) srecords\r\n", *pcRecSeen );
				*pfCorruptedIndex = fTrue;
				break;
				}
			}
		else
			{
			err = ErrSORTNext( pfucbSort );
			if( JET_errNoCurrentRecord == err )
				{
				FILEIReportIndexCorrupt( pfucbIndex, pcprintf );
				(*pcprintf)( "generated index has fewer (%d) srecords\r\n", *pcRecSeen );
				*pfCorruptedIndex = fTrue;
				break;
				}
			}
		}
	while ( err >= 0 );

	err = ( JET_errNoCurrentRecord == err ? JET_errSuccess : err );

HandleError:
	FUCBResetPreread( pfucbIndex );
	BTUp( pfucbIndex );
	return err;
	}


#ifdef PARALLEL_BATCH_INDEX_BUILD

LOCAL ERR ErrFILESingleIndexTerm(
	PIB			* const ppib,
	FUCB		** const rgpfucbSort,
	FCB			* const pfcbIndex,
	ULONG		* const rgcRecInput,
	const ULONG	iindex,
	BOOL		*pfCorruptionEncountered,
	CPRINTF		* const pcprintf,
	const BOOL	fLogged )
	{
	Assert( pfcbNil != pfcbIndex );

	ERR			err				= JET_errSuccess;
	FUCB		*pfucbIndex		= pfucbNil;
	const BOOL	fUnique			= pfcbIndex->Pidb()->FUnique();
	ULONG		cRecOutput		= 0;
	BOOL		fEntriesExist	= fTrue;
	BOOL		fCorruptedIndex	= fFalse;

	Assert( pfcbIndex->FTypeSecondaryIndex() );
	Assert( pidbNil != pfcbIndex->Pidb() );

#ifdef SHOW_INDEX_PERF
	const TICK	tickStart		= TickOSTimeCurrent();

	OSTrace( ostlIndexPerf, OSFormat( "About to sort keys for index %d.\n", iindex+1 ) );
#endif

	Call( ErrSORTEndInsert( rgpfucbSort[iindex] ) );

#ifdef SHOW_INDEX_PERF
	OSTrace( ostlIndexPerf, OSFormat(	"Sorted keys for index %d in %d msecs.\n",
										iindex+1,
										TickOSTimeCurrent() - tickStart ) );
#endif

	//	transfer index entries to actual index
	//	insert first one in normal method!
	//
	err = ErrSORTNext( rgpfucbSort[iindex] );
	if ( err < 0 )
		{
		if ( JET_errNoCurrentRecord != err )
			goto HandleError;

		err = JET_errSuccess;

		Assert( rgcRecInput[iindex] == 0 );
		fEntriesExist = fFalse;
		}

	if ( fEntriesExist )
		{

		//	open cursor on index
		//
		Assert( pfucbNil == pfucbIndex );
		Call( ErrDIROpen( ppib, pfcbIndex, &pfucbIndex ) );
		FUCBSetIndex( pfucbIndex );
		FUCBSetSecondary( pfucbIndex );
		DIRGotoRoot( pfucbIndex );

		if ( NULL != pfCorruptionEncountered )
			{
			Assert( NULL != pcprintf );
			Call( ErrFILEICheckIndex(
						rgpfucbSort[iindex],
						pfucbIndex,
						&cRecOutput,
						&fCorruptedIndex,
						pcprintf ) );
			if ( fCorruptedIndex )
				*pfCorruptionEncountered = fTrue;
			}
		else
			{
#ifdef SHOW_INDEX_PERF
			const TICK	tickStart	= TickOSTimeCurrent();
#endif

			Call( ErrFILEIAppendToIndex(
						rgpfucbSort[iindex],
						pfucbIndex,
						&cRecOutput,
						fLogged ) );

#ifdef SHOW_INDEX_PERF
			OSTraceIndent( ostlIndexPerf, +1 );
			OSTrace( ostlIndexPerf, OSFormat(	"Appended %d keys for index %d in %d msecs.\n",
												cRecOutput,
												iindex+1,
												TickOSTimeCurrent() - tickStart ) );
			OSTraceIndent( ostlIndexPerf, -1 );
#endif
			}

		DIRClose( pfucbIndex );
		pfucbIndex = pfucbNil;
		}
	else
		{
#ifdef SHOW_INDEX_PERF
		OSTraceIndent( ostlIndexPerf, +1 );
		OSTrace( ostlIndexPerf, OSFormat( "No keys generated for index %d.\n", iindex+1 ) );
		OSTraceIndent( ostlIndexPerf, -1 );
#endif
		}

	SORTClose( rgpfucbSort[iindex] );
	rgpfucbSort[iindex] = pfucbNil;

	Assert( cRecOutput <= rgcRecInput[iindex] );
	if ( cRecOutput != rgcRecInput[iindex] )
		{
		if ( cRecOutput < rgcRecInput[iindex] && !fUnique )
			{
			//	duplicates over multi-valued columns must have been removed
			}

		else if ( NULL != pfCorruptionEncountered )
			{
			*pfCorruptionEncountered = fTrue;

			// Only report this error if we haven't
			// encountered corruption on this index already.
			if ( !fCorruptedIndex )
				{
				if ( cRecOutput > rgcRecInput[iindex] )
					{
					(*pcprintf)( "Too many index keys generated\n" );
					}
				else
					{
					Assert( fUnique );
					(*pcprintf)( "%d duplicate key(s) on unique index\n", rgcRecInput[iindex] - cRecOutput );
					}
				}
			}

		else if ( cRecOutput > rgcRecInput[iindex] )
			{
			err = ErrERRCheck( JET_errIndexBuildCorrupted );
			goto HandleError;
			}

		else
			{
			Assert( cRecOutput < rgcRecInput[iindex] );
			Assert( fUnique );

			//	If we got dupes and the index was NOT unique, it must have been
			//	dupes over multi-value columns, in which case the dupes
			//	get properly eliminated.
			err = ErrERRCheck( JET_errKeyDuplicate );
			goto HandleError;
			}
		}

HandleError:
	if ( pfucbNil != pfucbIndex )
		{
		Assert( err < 0 );
		DIRClose( pfucbIndex );
		}

	return err;
	}


ERR ErrFILEIndexBatchTerm(
	PIB			* const ppib,
	FUCB		** const rgpfucbSort,
	FCB			* const pfcbIndexesToBuild,
	const INT	cIndexesToBuild,
	ULONG		* const rgcRecInput,
	STATUSINFO	* const pstatus,
	BOOL		*pfCorruptionEncountered,
	CPRINTF		* const pcprintf )
	{
	ERR			err = JET_errSuccess;
	FCB			*pfcbIndex = pfcbIndexesToBuild;
	INT			iindex;

	Assert( pfcbNil != pfcbIndexesToBuild );
	Assert( cIndexesToBuild > 0 );

	for ( iindex = 0; iindex < cIndexesToBuild; iindex++, pfcbIndex = pfcbIndex->PfcbNextIndex() )
		{
		CallR( ErrFILESingleIndexTerm(
						ppib,
						rgpfucbSort,
						pfcbIndex,
						rgcRecInput,
						iindex,
						pfCorruptionEncountered,
						pcprintf,
						fFalse ) );		//	only called by defrag, which has logging disabled

		if ( pstatus )
			{
			CallR( ErrFILEIndexProgress( pstatus ) );
			}
		}

	return err;
	}


struct CREATEINDEXCONTEXT
	{
	CTaskManager	taskmgrCreateIndex;
	ULONG			iindexStart;
	ULONG			cIndexesToBuild;
	FCB *			pfcbIndexesToBuild;
	FUCB *			pfucbTable;
	FUCB **			rgpfucbSort;
	ULONG *			rgcRecInput;
	DATA			dataBMBuffer;
	KEY				keyBuffer;
	STATUSINFO	* 	pstatus;
	CPRINTF	* 		pcprintf;
	ERR				err;

	union
		{
		ULONG		ulFlags;
		struct
			{
			BOOL	fAllocatedTaskManager:1;
			BOOL	fLogged:1;
			BOOL	fCheckOnly:1;
			BOOL	fCorruptionEncountered:1;
			};
		};
	};

struct FCBINDEXCONTEXT
	{
	FCB *		pfcbIndex;
	ULONG		iindex;
	};

LOCAL VOID ErrFILEIndexDispatchAddEntries(
	const DWORD_PTR				dwParam1,
	const DWORD					dwParam2,
	const DWORD_PTR				dwParam3 )
	{
	CREATEINDEXCONTEXT * const	pidxcontext		= (CREATEINDEXCONTEXT *)dwParam1;
	CSR * const					pcsr			= (CSR *)dwParam3;
	KEYDATAFLAGS				kdf;
	LONG						cEntriesAdded;

	//	only proceed if previous tasks did not encounter an error
	//
	if ( JET_errSuccess == pidxcontext->err )
		{
		const INT	ilineMax	= pcsr->Cpage().Clines();

		for ( pcsr->SetILine( 0 ); pcsr->ILine() < ilineMax; pcsr->IncrementILine() )
			{
			Assert( pcsr->FLatched() );
			NDIGetKeydataflags( pcsr->Cpage(), pcsr->ILine(), &kdf );

			//	WARNING! WARNING! WARNING!
			//	Batch index creation is only performed when we have
			//	exclusive use of the table, so we don't need to worry
			//	about versioning and can therefore get away with just
			//	checking the fDeleted flag
			//
			if ( FNDDeleted( kdf ) )
				{
				continue;
				}

			//	must copy key to a buffer because the routines that use it
			//	 are not prepared to deal with prefix/suffix
			//
			kdf.key.CopyIntoBuffer( pidxcontext->dataBMBuffer.Pv(), JET_cbPrimaryKeyMost );
			pidxcontext->dataBMBuffer.SetCb( kdf.key.Cb() );

			FCB * 		pfcbIndex	= pidxcontext->pfcbIndexesToBuild;
			const ULONG	iindexMax	= pidxcontext->iindexStart + pidxcontext->cIndexesToBuild;

			for ( ULONG iindex = pidxcontext->iindexStart;
				iindex < iindexMax;
				iindex++, pfcbIndex = pfcbIndex->PfcbNextIndex() )
				{
				Assert( pfcbNil != pfcbIndex );
				Assert( pidbNil != pfcbIndex->Pidb() );
				const ERR	errT	= ErrFILEIAddSecondaryIndexEntriesForPrimaryKey(
											pidxcontext->pfucbTable,
											pfcbIndex,
											kdf.data,
											pidxcontext->dataBMBuffer,
											pidxcontext->rgpfucbSort[iindex],
											pidxcontext->keyBuffer,
											pidxcontext->fCheckOnly,
											&cEntriesAdded );
				if ( errT < JET_errSuccess )
					{
					pidxcontext->err = errT;
					break;
					}

				Assert( cEntriesAdded >= 0 );
				pidxcontext->rgcRecInput[iindex] += cEntriesAdded;
				}
			}
		}

	pcsr->ReleasePage();
	delete pcsr;
	}

LOCAL VOID ErrFILEIndexDispatchSortTerm(
	const DWORD_PTR				dwParam1,
	const DWORD					dwParam2,
	const DWORD_PTR				dwParam3
	)
	{
	CREATEINDEXCONTEXT * const	pidxcontext		= (CREATEINDEXCONTEXT *)dwParam1;
	FCBINDEXCONTEXT * const		pfcbcontext		= (FCBINDEXCONTEXT *)dwParam3;

	//	only proceed if previous tasks did not encounter an error
	//
	if ( JET_errSuccess == pidxcontext->err )
		{
		BOOL	fCorrupt	= fFalse;
		ERR		errT		= ErrFILESingleIndexTerm(
										pidxcontext->pfucbTable->ppib,
										pidxcontext->rgpfucbSort,
										pfcbcontext->pfcbIndex,
										pidxcontext->rgcRecInput,
										pfcbcontext->iindex,
										pidxcontext->fCheckOnly ? &fCorrupt : NULL,
										pidxcontext->pcprintf,
										pidxcontext->fLogged );
		if ( errT >= JET_errSuccess )
			{
			if ( fCorrupt )
				{
				pidxcontext->fCorruptionEncountered = fTrue;
				}

			if ( pidxcontext->pstatus )
				{
				//	HACK: use DDL/DML latch to serialize progress meter update
				//
				pidxcontext->pfucbTable->u.pfcb->EnterDDL();
				errT = ErrFILEIndexProgress( pidxcontext->pstatus );
				pidxcontext->pfucbTable->u.pfcb->LeaveDDL();
				}
			}
		if ( errT < JET_errSuccess )
			{
			pidxcontext->err = errT;
			}
		}
	}

LOCAL ERR ErrFILEITerminateSorts(
	CREATEINDEXCONTEXT **	rgpidxcreate,
	FCB *					pfcbIndexes,
	const ULONG				cIndexes,
	const ULONG				cProcs )
	{
	ERR						err;
	CTaskManager			taskmgrTerminateSorts;
	FCBINDEXCONTEXT *		rgfcbcontext		= NULL;

#ifdef SHOW_INDEX_PERF
	OSTrace( ostlIndexPerf, OSFormat( "About to terminate sorts using %d threads.\n", cProcs ) );
#endif

	CallR( taskmgrTerminateSorts.ErrTMInit( cProcs, (DWORD_PTR *)rgpidxcreate, 0, NULL, fTrue ) );

	rgfcbcontext = (FCBINDEXCONTEXT *)PvOSMemoryHeapAlloc( sizeof(FCBINDEXCONTEXT) * cIndexes );
	if ( NULL == rgfcbcontext )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//	sort and generate index keys
	//
	for ( ULONG iindex = 0; iindex < cIndexes; iindex++, pfcbIndexes = pfcbIndexes->PfcbNextIndex() )
		{
		rgfcbcontext[iindex].pfcbIndex = pfcbIndexes;
		rgfcbcontext[iindex].iindex = iindex;
		Call( taskmgrTerminateSorts.ErrTMPost( ErrFILEIndexDispatchSortTerm, 0, (DWORD_PTR)( rgfcbcontext + iindex ) ) );
		}

	err = JET_errSuccess;

HandleError:
	taskmgrTerminateSorts.TMTerm();

	if ( NULL != rgfcbcontext )
		{
		OSMemoryHeapFree( rgfcbcontext );
		}

	return err;
	}

INLINE VOID FILEIPossiblyWaitForDispatchedTasks( const CREATEINDEXCONTEXT * const pidxcontext, const ULONG iProc )
	{
	//	if we're latching too many pages, wait for some tasks to complete
	//
	extern LONG_PTR		cbfCache;
	const LONG_PTR		cbfCacheT		= cbfCache;		//	snapshot current buffer manager size
	ULONG				cTasksPending	= pidxcontext->taskmgrCreateIndex.CPostedTasks();

	//	tasks implicitly match to page latches, so we'll
	//	compare the number of pending tasks to the current
	//	buffer manager size to determine if we need to wait
	//
	//	if this thread is hogging over half the cached pages,
	//	wait for it to finish some work
	//
	if ( cTasksPending > cbfCacheT * 2 / 3 )
		{
		ULONG	csecWait	= 1;
		for ( ULONG citer = 1; cTasksPending > cbfCacheT / 3; citer++ )
			{
#ifdef SHOW_INDEX_PERF
			OSTrace( ostlIndexPerf, OSFormat(	"Pausing scanning thread for %d seconds to wait for task manager %d (retry #%d, %d tasks pending, cbfCache==%d).\n",
												csecWait,
												iProc+1,
												citer,
												cTasksPending,
												cbfCacheT ) );
#endif

			UtilSleep( csecWait * 1000 );

			//	increment wait if we have to retry again
			//	(capping the wait time at 30 seconds)
			//
			if ( csecWait < 30 )
				csecWait *= 2;

			cTasksPending = pidxcontext->taskmgrCreateIndex.CPostedTasks();
			}
		}
	}

ERR ErrFILEBuildAllIndexes(
	PIB * const				ppib,
	FUCB * const			pfucbTable,
	FCB * const				pfcbIndexes,
	STATUSINFO * const		pstatus,
	const ULONG				cIndexBatchMaxRequested,
	const BOOL				fCheckOnly,
	CPRINTF * const			pcprintf )
	{
	ERR	 	 				err;
	DIB						dib;
	INST *					pinst					= PinstFromPpib( ppib );
	ULONG					cIndexBatchMax			= min( cIndexBatchMaxRequested, ULONG( pinst->m_pcresSCBPool->CBlocksTotalAvail() * 0.9 ) );	//	just to be safe, don't use up all available sorts
	CSR *					pcsrTable				= Pcsr( pfucbTable );
	CREATEINDEXCONTEXT *	rgidxcontext			= NULL;
	FUCB **					rgpfucbSort				= NULL;
	FCB *					pfcbIndexesToBuild;
	FCB *					pfcbNextBuildIndex;
	KEY						keyBuffer;
	INT						cIndexesToBuild;
	PGNO					pgnoCurr;
	BOOL					fTransactionStarted		= fFalse;
	BOOL					fCorruptionEncountered	= fFalse;
	CSR * 					pcsrT					= pcsrNil;
	ULONG					iProc;
	ULONG_PTR				ulCacheSizeMaxSave;
	ULONG_PTR				ulStartFlushThresholdSave;
	ULONG_PTR				ulStopFlushThresholdSave;
	CPG						cpgTable;
	const					cpgDbExtensionSizeSave	= pinst->m_cpgSESysMin;
	const BOOL				fLogged					= ( !pinst->m_plog->m_fLGCircularLogging
														&& rgfmp[pfucbTable->ifmp].FLogOn() );

	Assert( !fLogged || !pinst->m_plog->m_fLogDisabled );

	//	save off current buffer settings as we will be resizing
	//	the buffer manager during the index rebuild
	//
	CallR( ErrBFGetCacheSizeMax( &ulCacheSizeMaxSave ) );
	CallR( ErrBFGetStartFlushThreshold( &ulStartFlushThresholdSave ) );
	CallR( ErrBFGetStopFlushThreshold( &ulStopFlushThresholdSave ) );

	if ( 0 == ppib->level )
		{
		//	only reason we need a transaction is to ensure read-consistency of primary data
		CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
		fTransactionStarted = fTrue;
		}

	const ULONG_PTR		ulStartFlushThresholdForIndexCreate		= 5 * ulCacheSizeMaxSave / 100;
	const ULONG_PTR		ulStopFlushThresholdForIndexCreate		= 6 * ulCacheSizeMaxSave / 100;

	//	have to do this comparison to ensure
	//	settings are always valid
	//
	if ( ulStopFlushThresholdForIndexCreate > ulStopFlushThresholdSave )
		{
		CallS( ErrBFSetStopFlushThreshold( ulStopFlushThresholdForIndexCreate ) );
		CallS( ErrBFSetStartFlushThreshold( ulStartFlushThresholdForIndexCreate ) );
		}
	else
		{
		CallS( ErrBFSetStartFlushThreshold( ulStartFlushThresholdForIndexCreate ) );
		CallS( ErrBFSetStopFlushThreshold( ulStopFlushThresholdForIndexCreate ) );
		}

	//	set DB extension size to 1% of the current size of the table, up to
	//	a limit (I somewhat arbitrarily chose the limit to be a number of pages
	//	equal to the page size)
	//
	Call( ErrSPGetInfo(
				ppib,
				pfucbTable->ifmp,
				pfucbTable,
				(BYTE *)&cpgTable,
				sizeof(cpgTable),
				fSPOwnedExtent ) );
	pinst->m_cpgSESysMin = max( cpgDbExtensionSizeSave, (CPG)min( g_cbPage, cpgTable / 100 ) );

	//	if we have a lot of indices to rebuild, make sure we
	//	have enough temp disk space to accommodate the request
	//
	if ( cIndexBatchMax > cFILEIndexBatchSizeDefault )
		{
		const QWORD		cbTable			= QWORD( cpgTable ) * QWORD( g_cbPage );
		CPG				cpgFreeTempDb;
		QWORD			cbFreeTempDisk;

		//	first check if we have enough free space for potential temp. database growth
		//
		Call( pinst->m_pfsapi->ErrDiskSpace( pinst->m_szTempDatabase, &cbFreeTempDisk ) );

		//	add on any free space in the temp. db, since that's potentially re-usable
		//
		Call( ErrSPGetInfo(
					ppib,
					pinst->m_mpdbidifmp[ dbidTemp ],
					pfucbNil,
					(BYTE *)&cpgFreeTempDb,
					sizeof(cpgFreeTempDb),
					fSPAvailExtent ) );
		cbFreeTempDisk += ( cpgFreeTempDb * g_cbPage );

		if ( cbFreeTempDisk > QWORD( cbTable * 0.75 ) )
			{
			//	plenty of disk space for the temp database to grow (relative
			//	to the size of the table), so permit building as many indices
			//	as requested
			//
			NULL;
			}
		else
			{
			//	assume that on average, each index is going to be about 1%
			//	of the size of the table, so use that assumption to come
			//	up with an index batch size to use
			//
			cIndexBatchMax = min( cIndexBatchMax, ULONG( cbFreeTempDisk * 100 / cbTable ) );

			//	if more than 75%, should have been permitted to build all indices
			//
			Assert( cIndexBatchMax <= 75 );

			//	enforce minimum batch size
			//
			cIndexBatchMax = max( cIndexBatchMax, cFILEIndexBatchSizeDefault );
			}
		}

	//	now check if we have enough free space for potential log disk growth
	//
	if ( cIndexBatchMax > cFILEIndexBatchSizeDefault
		&& rgfmp[pfucbTable->ifmp].FLogOn() )
		{
		if ( pinst->m_plog->m_fLGCircularLogging )
			{
			const QWORD		cbTable			= QWORD( cpgTable ) * QWORD( g_cbPage );
			QWORD			cbFreeLogDisk;

			//	if circular logging enabled, then we're not going to log
			//	the actual index entries, but we are actually going to log
			//	space operations, so need a small amount of log disk space
			//
			Call( pinst->m_pfsapi->ErrDiskSpace( pinst->m_plog->m_szLogFilePath, &cbFreeLogDisk ) );
			if ( cbFreeLogDisk > QWORD( cbTable * 0.001 ) )
				{
				//	plenty of disk space for logging space operations (relative
				//	to the size of the table), so permit building as many indices
				//	as requested
				//
				NULL;
				}
			else
				{
				//	there's a really small amount of free log disk space relative
				//	to the size of the table, so rather than try to come up with
				//	a formula for this, I'm just going to set the batch size to
				//	the default batch size
				//
				cIndexBatchMax = cFILEIndexBatchSizeDefault;
				}
			}
		else
			{
			//	if circular logging is disabled, we'll use the same amount of
			//	log disk space regardless of batch size, so don't bother trimming
			//	the index batch size
			//
			NULL;
			}
		}

	//	use all procs unless there are more procs than indices to build
	//
	const ULONG	cProcs	= min( CUtilProcessProcessor(), cIndexBatchMax );

	//	open LV root so the async threads don't do it
	//
	if( pfcbNil == pfucbTable->u.pfcb->Ptdb()->PfcbLV() )
		{
		FUCB *	pfucbT	= pfucbNil;
		Call( ErrFILEOpenLVRoot( pfucbTable, &pfucbT, fFalse ) );	//	UNDONE: use ErrDIROpenLongRoot instead
		if ( pfucbNil != pfucbT )	//	may be NULL if no LV tree
			DIRClose( pfucbT );
		}

	Assert( cIndexBatchMax > 0 );

	ppib->SetFBatchIndexCreation();

	if ( !fLogged )
		{
		for ( FCB * pfcbT = pfcbIndexes; pfcbNil != pfcbT; pfcbT = pfcbT->PfcbNextIndex() )
			{
			Assert( !pfcbT->FDontLogSpaceOps() );
			pfcbT->SetDontLogSpaceOps();
			}
		}

	//	allocate space for index contexts, index context pointers, primary key buffers, and secondary key buffers
	rgidxcontext	= (CREATEINDEXCONTEXT *)PvOSMemoryHeapAlloc( ( sizeof(CREATEINDEXCONTEXT) + sizeof(CREATEINDEXCONTEXT *) + JET_cbPrimaryKeyMost + JET_cbSecondaryKeyMost ) * cProcs );
	if ( NULL == rgidxcontext )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	memset( rgidxcontext, 0, sizeof(CREATEINDEXCONTEXT) * cProcs );

	//	allocate space for sort cursors and entry counts
	rgpfucbSort = (FUCB **)PvOSMemoryHeapAlloc( ( sizeof(FUCB *) + sizeof(ULONG) ) * cIndexBatchMax );
	if ( NULL == rgpfucbSort )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	memset( rgpfucbSort, 0, sizeof(FUCB *) * cIndexBatchMax );

	//	arrays of index context pointers, primary key buffers, and secondary key buffers
	//	hangs off the end of the array of index contexts
	CREATEINDEXCONTEXT **	rgpidxcontext	= (CREATEINDEXCONTEXT **)( (BYTE *)rgidxcontext + ( sizeof(CREATEINDEXCONTEXT) * cProcs ) );
	BYTE * const			rgbBMBuffer		= (BYTE *)rgpidxcontext + ( sizeof(CREATEINDEXCONTEXT *) * cProcs );
	BYTE * const			rgbKeyBuffer	= rgbBMBuffer + ( JET_cbPrimaryKeyMost * cProcs );

	//	array of entry counts hangs off the end of the array of sort cursors
	ULONG *					rgcRecInput		= (ULONG *)( (BYTE *)rgpfucbSort + ( sizeof(FUCB *) * cIndexBatchMax ) );


	dib.pos 	= posFirst;
	dib.pbm 	= NULL;
	dib.dirflag = fDIRNull;

	FUCBSetPrereadForward( pfucbTable, cpgPrereadSequential );
	err = ErrBTDown( pfucbTable, &dib, latchReadTouch );
	Assert( JET_errNoCurrentRecord != err );
	if ( err < JET_errSuccess )
		{
		if ( JET_errRecordNotFound == err )
			{
			//  the tree is empty
			err = JET_errSuccess;
			}
		goto HandleError;
		}

	// Cursor building index should only be navigating primary index.
	Assert( pfucbNil == pfucbTable->pfucbCurIndex );

	// Don't waste time by calling this function when unneeded.
	Assert( pfcbNil != pfcbIndexes );


	for ( iProc = 0; iProc < cProcs; iProc++ )
		{
		CREATEINDEXCONTEXT *	pidxcontext		= rgidxcontext + iProc;
		FUCB *					pfucbT;

		new( &pidxcontext->taskmgrCreateIndex ) CTaskManager;
		pidxcontext->fAllocatedTaskManager = fTrue;

		if ( fLogged )
			pidxcontext->fLogged = fTrue;

		if ( fCheckOnly )
			pidxcontext->fCheckOnly = fTrue;

		//	open session/cursor for this thread and place it at
		//	the beginning of the table
		//
		Call( ErrDIROpen( ppib, pfucbTable->u.pfcb, &pfucbT ) );
		FUCBSetIndex( pfucbT );
		FUCBSetMayCacheLVCursor( pfucbT );

		pidxcontext->pfucbTable = pfucbT;
		pidxcontext->rgpfucbSort = rgpfucbSort;
		pidxcontext->rgcRecInput = rgcRecInput;
		pidxcontext->dataBMBuffer.SetCb( JET_cbPrimaryKeyMost );
		pidxcontext->dataBMBuffer.SetPv( rgbBMBuffer + ( JET_cbPrimaryKeyMost * iProc ) );
		pidxcontext->keyBuffer.suffix.SetCb( JET_cbSecondaryKeyMost );
		pidxcontext->keyBuffer.suffix.SetPv( rgbKeyBuffer + ( JET_cbSecondaryKeyMost * iProc ) );

		pidxcontext->pstatus = pstatus;
		pidxcontext->pcprintf = pcprintf;

		rgpidxcontext[iProc] = pidxcontext;
		}

	pfcbNextBuildIndex = pfcbIndexes;

NextBuild:
#ifdef SHOW_INDEX_PERF
	ULONG	cRecs, cPages;
	TICK	tickStart;
	cRecs = 0;
	cPages	= 0;
	tickStart	= TickOSTimeCurrent();
#endif

	//	HACK: force locLogical to OnCurBM to silence
	//	RECIRetrieveKey(), which will make DIR-level
	//	calls using this cursor
	pfucbTable->locLogical = locOnCurBM;

	pfcbIndexesToBuild = pfcbNextBuildIndex;
	pfcbNextBuildIndex = pfcbNil;

	Call( ErrFILEIndexBatchInit(
				ppib,
				rgpfucbSort,
				pfcbIndexesToBuild,
				&cIndexesToBuild,
				rgcRecInput,
				&pfcbNextBuildIndex,
				cIndexBatchMax ) );

	// This is either a full batch or the last batch of indexes to build.
	Assert( cIndexBatchMax == cIndexesToBuild
		|| pfcbNil == pfcbNextBuildIndex );

	//	re-initialise task manager with new index batch
	//
	ULONG	cProcsCurrBatch;
	ULONG	iindexNext;
	FCB *	pfcbIndexesRemaining;

	cProcsCurrBatch = min( cProcs, cIndexesToBuild );
	iindexNext = 0;
	pfcbIndexesRemaining = pfcbIndexesToBuild;

	for ( iProc = 0; iProc < cProcsCurrBatch; iProc++ )
		{
		Assert( iindexNext < cIndexesToBuild );

		const ULONG				cIndexesRemaining	= cIndexesToBuild - iindexNext;
		const ULONG				cProcsRemaining		= cProcsCurrBatch - iProc;
		ULONG					cIndexesThisProc	= ( cIndexesRemaining + cProcsRemaining - 1 ) / cProcsRemaining;
		CREATEINDEXCONTEXT *	pidxcontext			= rgidxcontext + iProc;

		Assert( cIndexesThisProc > 0 );

		Call( pidxcontext->taskmgrCreateIndex.ErrTMInit( 1, (DWORD_PTR *)( rgpidxcontext + iProc ) ) );

		pidxcontext->iindexStart = iindexNext;
		pidxcontext->cIndexesToBuild = cIndexesThisProc;
		pidxcontext->pfcbIndexesToBuild = pfcbIndexesRemaining;

		iindexNext += cIndexesThisProc;

		for ( ULONG iindex = 0; iindex < cIndexesThisProc; iindex++ )
			{
			pfcbIndexesRemaining = pfcbIndexesRemaining->PfcbNextIndex();
			}

		DIRUp( pidxcontext->pfucbTable );
		pidxcontext->err = JET_errSuccess;
		}

#ifdef SHOW_INDEX_PERF
	OSTrace( ostlIndexPerf, OSFormat(	"Beginning scan of records to rebuild %d indexes with %d task managers.\n", cIndexesToBuild, cProcsCurrBatch ) );
	OSTraceIndent( ostlIndexPerf, +1 );

	FCB *	pfcbIndexT;
	ULONG	iindexT;
	for ( pfcbIndexT = pfcbIndexesToBuild, iindexT = 0; iindexT < cIndexesToBuild; pfcbIndexT = pfcbIndexT->PfcbNextIndex(), iindexT++ )
		{
		TDB *	ptdbT	= pfucbTable->u.pfcb->Ptdb();
		IDB *	pidbT	= pfcbIndexT->Pidb();

		OSTrace( ostlIndexPerf, OSFormat(	"Index #%d: %s\n",
											iindexT+1,
											ptdbT->SzIndexName( pidbT->ItagIndexName() ) ) );
		}
	OSTraceIndent( ostlIndexPerf, -1 );
#endif

	//	build up new index in a sort file
	//
	CallS( err );
	while ( JET_errNoCurrentRecord != err )
		{
		Call( err );

#ifdef SHOW_INDEX_PERF
		cPages++;
		cRecs += pcsrTable->Cpage().Clines();	//	this is an estimate because we don't know how many are deleted		cPages++;
#endif

		Assert( pcsrTable->FLatched() );
		Assert( locOnCurBM == pfucbTable->locLogical );

		for ( iProc = 0; iProc < cProcsCurrBatch; iProc++ )
			{
			CREATEINDEXCONTEXT * const	pidxcontext		= rgidxcontext + iProc;

			//	verify no errors encountered on previous tasks
			//
			Call( pidxcontext->err );

			//	this loop can take some time, so see if we need
			//	to terminate because of shutdown
			//
			Call( pinst->ErrCheckForTermination() );

			//	check if the log disk is full, because even
			//	though we're still in the scanning phase,
			//	we won't be able to insert keys into the
			//	index if we can't log the insertion
			//
			//	NOTE: must check even if fLogged is FALSE
			//	because we may be in the pseudo-logging-disabled
			//	state where logging is actually enabled, but
			//	we're not logging batch index creation, but
			//	we are still logging space operations, so we may
			//	end up filling the logs with that
			//
			Call( ErrLGCheckState( pinst->m_plog ) );

			//	create a new CSR for this task
			//
			pcsrT = new CSR;
			if ( NULL == pcsrT )
				{
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}

			//	latch the page for the task
			//
			Call( pcsrT->ErrGetReadPage(
							ppib,
							pfucbTable->ifmp,
							pcsrTable->Pgno(),
							bflfNoTouch,
							pfucbTable->u.pfcb->Tableclass(),
							pcsrTable->Cpage().PBFLatch() ) );

			//	post the task with the page latched to
			//	ensure it doesn't go away
			//
			Call( pidxcontext->taskmgrCreateIndex.ErrTMPost(
									ErrFILEIndexDispatchAddEntries,
									0,
									(DWORD_PTR)pcsrT ) );

			//	memory will be freed after task has been dispatched
			//
			pcsrT = pcsrNil;

			FILEIPossiblyWaitForDispatchedTasks( pidxcontext,iProc );
			}

		//	HACK! HACK! HACK!
		//	Force currency to the last node on the page so that the subsequent call
		//	to ErrBTNext() will skip to the next page.  The individual nodes on the
		//	current page will be handled by the dispatched tasks.
		//
		pcsrTable->SetILine( pcsrTable->Cpage().Clines() - 1 );
#ifdef DEBUG
		NDGet( pfucbTable );
#endif

		Assert( pcsrTable->FLatched() );
		err = ErrBTNext( pfucbTable, fDIRNull );
		}
	Assert( JET_errNoCurrentRecord == err );

#ifdef SHOW_INDEX_PERF
	OSTrace( ostlIndexPerf, OSFormat(	"Scanned %d records (%d pages) and dispatched all tasks in %d msecs.\n",
										cRecs,
										cPages,
										TickOSTimeCurrent() - tickStart ) );
#endif

	FUCBResetPreread( pfucbTable );
	BTUp( pfucbTable );

	//	wait for sorts to finish
	//
	for ( iProc = 0; iProc < cProcsCurrBatch; iProc++ )
		{
		CREATEINDEXCONTEXT *	pidxcontext		= rgidxcontext + iProc;

		pidxcontext->taskmgrCreateIndex.TMTerm();

		DIRUp( pidxcontext->pfucbTable );
		Call( pidxcontext->err );

#ifdef SHOW_INDEX_PERF
		ULONG	cTotalKeys	= 0;
		for ( ULONG iindex = pidxcontext->iindexStart;
			iindex < pidxcontext->iindexStart + pidxcontext->cIndexesToBuild;
			iindex++ )
			{
			if ( rgpfucbSort[iindex]->u.pscb->crun > 0 )
				{
				OSTrace( ostlIndexPerf, OSFormat(	"Index #%d used sort runs [objid:0x%x,pgnoFDP:0x%x].\n",
													iindex+1,
													rgpfucbSort[iindex]->u.pscb->fcb.ObjidFDP(),
													rgpfucbSort[iindex]->u.pscb->fcb.PgnoFDP() ) );
				}
			else
				{
				OSTrace( ostlIndexPerf, OSFormat(	"Index #%d did not use sort runs.\n",
													iindex+1 ) );
				}

			cTotalKeys += rgcRecInput[iindex];
			}
		OSTrace( ostlIndexPerf, OSFormat( "Task manager %d generated %d total keys.\n", iProc+1, cTotalKeys ) );
#endif
		}

	Call( ErrFILEITerminateSorts( rgpidxcontext, pfcbIndexesToBuild, cIndexesToBuild, cProcsCurrBatch ) );

	//	check for errors and set corruption flag if necessary
	//
	for ( iProc = 0; iProc < cProcsCurrBatch; iProc++ )
		{
		CREATEINDEXCONTEXT *	pidxcontext		= rgidxcontext + iProc;

		Call( pidxcontext->err );

		if ( fCheckOnly && pidxcontext->fCorruptionEncountered )
			{
			fCorruptionEncountered = fTrue;
			}
		}

	if ( pfcbNil != pfcbNextBuildIndex )
		{
		//	reseek to beginning of data (must succeed since it succeeded the first time)
		FUCBSetPrereadForward( pfucbTable, cpgPrereadSequential );
		err = ErrBTDown( pfucbTable, &dib, latchReadTouch );
		CallS( err );
		Call( err );

		goto NextBuild;
		}

	if ( fCorruptionEncountered )
		{
		err = ErrERRCheck( JET_errDatabaseCorrupted );
		}
	else if ( !fLogged
		&& rgfmp[pfucbTable->ifmp].FLogOn() )
		{
		//	index creation wasn't logged, but
		//	logging in general is enabled, so must
		//	force-flush database and guarantee it
		//	succeeded
		//
#ifdef SHOW_INDEX_PERF
		OSTrace( ostlIndexPerf, "About to force-flush entire database after index creation.\n" );
#endif

		Call( ErrBFFlush( pfucbTable->ifmp, fTrue ) )
		Enforce( JET_errSuccess == err );

		//	HACK: must force a dummy logged update anywhere in this
		//	database to ensure that after recovery, the dbtime in the
		//	db header is greater than any of the dbtimes in the non-
		//	logged indexes
		//
		Call( ErrSPDummyUpdate( pfucbTable ) );

#ifdef SHOW_INDEX_PERF
		OSTrace( ostlIndexPerf, "Finished force-flush of entire database after index creation.\n" );
#endif
		}
	else
		{
		err = JET_errSuccess;
		}

HandleError:
#ifdef SHOW_INDEX_PERF
	OSTrace( ostlIndexPerf, OSFormat( "Completed batch index build with error %d.\n", err ) );
#endif

	Assert ( err != errDIRNoShortCircuit );

	if ( NULL != rgidxcontext )
		{
		for ( iProc = 0; iProc < cProcs; iProc++ )
			{
			CREATEINDEXCONTEXT * const	pidxcontext		= rgidxcontext + iProc;

			if ( pidxcontext->fAllocatedTaskManager )
				{
				pidxcontext->taskmgrCreateIndex.TMTerm();
				pidxcontext->taskmgrCreateIndex.~CTaskManager();
				}
			if ( pfucbNil != pidxcontext->pfucbTable )
				{
				DIRCloseIfExists( &pidxcontext->pfucbTable->pfucbLV );
				DIRClose( pidxcontext->pfucbTable );
				}
			}
		OSMemoryHeapFree( rgidxcontext );
		}

	if ( err < 0 )
		{
		if ( pcsrNil != pcsrT )
			{
			pcsrT->ReleasePage();
			delete pcsrT;
			}

		if ( NULL != rgpfucbSort )
			{
			for ( ULONG iindex = 0; iindex < cIndexBatchMax; iindex++ )
				{
				if ( pfucbNil != rgpfucbSort[iindex] )
					{
					SORTClose( rgpfucbSort[iindex] );
					rgpfucbSort[iindex] = pfucbNil;
					}
				}
			}

		FUCBResetPreread( pfucbTable );
		BTUp( pfucbTable );
		}
	else
		{
#ifdef DEBUG
		Assert( pcsrNil == pcsrT );
		for ( ULONG iindex = 0; iindex < cIndexBatchMax; iindex++ )
			{
			Assert( pfucbNil == rgpfucbSort[iindex] );
			}
#endif
		}

	if ( NULL != rgpfucbSort )
		{
		OSMemoryHeapFree( rgpfucbSort );
		}

	if ( fTransactionStarted )
		{
		//	read-only transaction, so should never fail
		CallS( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );
		}


	//	restore original buffer manager thresholds
	//
	if ( ulStopFlushThresholdSave > ulStopFlushThresholdForIndexCreate )
		{
		CallS( ErrBFSetStopFlushThreshold( ulStopFlushThresholdSave ) );
		CallS( ErrBFSetStartFlushThreshold( ulStartFlushThresholdSave ) );
		}
	else
		{
		CallS( ErrBFSetStartFlushThreshold( ulStartFlushThresholdSave ) );
		CallS( ErrBFSetStopFlushThreshold( ulStopFlushThresholdSave ) );
		}

	if ( !fLogged )
		{
		for ( FCB * pfcbT = pfcbIndexes; pfcbNil != pfcbT; pfcbT = pfcbT->PfcbNextIndex() )
			{
			pfcbT->ResetDontLogSpaceOps();
			}
		}

	//	restore original DB extension size
	//
	pinst->m_cpgSESysMin = cpgDbExtensionSizeSave;

	ppib->ResetFBatchIndexCreation();

	return err;
	}

#else

ERR ErrFILEIndexBatchTerm(
	PIB			* const ppib,
	FUCB		** const rgpfucbSort,
	FCB			* const pfcbIndexesToBuild,
	const INT	cIndexesToBuild,
	ULONG		* const rgcRecInput,
	STATUSINFO	* const pstatus,
	BOOL		*pfCorruptionEncountered,
	CPRINTF		* const pcprintf )
	{
	ERR			err = JET_errSuccess;
	FUCB		*pfucbIndex = pfucbNil;
	FCB			*pfcbIndex = pfcbIndexesToBuild;
	INT			iindex;

	Assert( pfcbNil != pfcbIndexesToBuild );
	Assert( cIndexesToBuild > 0 );

	for ( iindex = 0; iindex < cIndexesToBuild; iindex++, pfcbIndex = pfcbIndex->PfcbNextIndex() )
		{
		const BOOL	fUnique			= pfcbIndex->Pidb()->FUnique();
		ULONG		cRecOutput		= 0;
		BOOL		fEntriesExist	= fTrue;
		BOOL		fCorruptedIndex	= fFalse;

		Assert( pfcbNil != pfcbIndex );
		Assert( pfcbIndex->FTypeSecondaryIndex() );
		Assert( pidbNil != pfcbIndex->Pidb() );

#ifdef SHOW_INDEX_PERF
		const TICK	tickStart		= TickOSTimeCurrent();

		OSTrace( ostlIndexPerf, OSFormat( "About to sort keys for index %d.\n", iindex+1 ) );
#endif

		Call( ErrSORTEndInsert( rgpfucbSort[iindex] ) );

#ifdef SHOW_INDEX_PERF
		OSTrace( ostlIndexPerf, OSFormat(	"Sorted keys for index %d in %d msecs.\n",
											iindex+1,
											TickOSTimeCurrent() - tickStart ) );
#endif

		//	transfer index entries to actual index
		//	insert first one in normal method!
		//
		err = ErrSORTNext( rgpfucbSort[iindex] );
		if ( err < 0 )
			{
			if ( JET_errNoCurrentRecord != err )
				goto HandleError;

			err = JET_errSuccess;

			Assert( rgcRecInput[iindex] == 0 );
			fEntriesExist = fFalse;
			}

		if ( fEntriesExist )
			{

			//	open cursor on index
			//
			Assert( pfucbNil == pfucbIndex );
			Call( ErrDIROpen( ppib, pfcbIndex, &pfucbIndex ) );
			FUCBSetIndex( pfucbIndex );
			FUCBSetSecondary( pfucbIndex );
			DIRGotoRoot( pfucbIndex );

			if ( NULL != pfCorruptionEncountered )
				{
				Assert( NULL != pcprintf );
				Call( ErrFILEICheckIndex(
							rgpfucbSort[iindex],
							pfucbIndex,
							&cRecOutput,
							&fCorruptedIndex,
							pcprintf ) );
				if ( fCorruptedIndex )
					*pfCorruptionEncountered = fTrue;
				}
			else
				{
#ifdef SHOW_INDEX_PERF
				const TICK	tickStart	= TickOSTimeCurrent();
#endif

				Call( ErrFILEIAppendToIndex(
							rgpfucbSort[iindex],
							pfucbIndex,
							&cRecOutput,
							rgfmp[pfucbIndex->ifmp].FLogOn() ) );

#ifdef SHOW_INDEX_PERF
				OSTraceIndent( ostlIndexPerf, +1 );
				OSTrace( ostlIndexPerf, OSFormat(	"Appended %d keys for index %d in %d msecs.\n",
													cRecOutput,
													iindex+1,
													TickOSTimeCurrent() - tickStart ) );
				OSTraceIndent( ostlIndexPerf, -1 );
#endif
				}

			DIRClose( pfucbIndex );
			pfucbIndex = pfucbNil;
			}
		else
			{
#ifdef SHOW_INDEX_PERF
			OSTraceIndent( ostlIndexPerf, +1 );
			OSTrace( ostlIndexPerf, OSFormat( "No keys generated for index %d.\n", iindex+1 ) );
			OSTraceIndent( ostlIndexPerf, -1 );
#endif
			}

		SORTClose( rgpfucbSort[iindex] );
		rgpfucbSort[iindex] = pfucbNil;

		Assert( cRecOutput <= rgcRecInput[iindex] );
		if ( cRecOutput != rgcRecInput[iindex] )
			{
			if ( cRecOutput < rgcRecInput[iindex] && !fUnique )
				{
				//	duplicates over multi-valued columns must have been removed
				}

			else if ( NULL != pfCorruptionEncountered )
				{
				*pfCorruptionEncountered = fTrue;

				// Only report this error if we haven't
				// encountered corruption on this index already.
				if ( !fCorruptedIndex )
					{
					if ( cRecOutput > rgcRecInput[iindex] )
						{
						(*pcprintf)( "Too many index keys generated\n" );
						}
					else
						{
						Assert( fUnique );
						(*pcprintf)( "%d duplicate key(s) on unique index\n", rgcRecInput[iindex] - cRecOutput );
						}
					}
				}

			else if ( cRecOutput > rgcRecInput[iindex] )
				{
				err = ErrERRCheck( JET_errIndexBuildCorrupted );
				goto HandleError;
				}

			else
				{
				Assert( cRecOutput < rgcRecInput[iindex] );
				Assert( fUnique );

				//	If we got dupes and the index was NOT unique, it must have been
				//	dupes over multi-value columns, in which case the dupes
				//	get properly eliminated.
				err = ErrERRCheck( JET_errKeyDuplicate );
				goto HandleError;
				}
			}

		if ( pstatus )
			{
			Call( ErrFILEIndexProgress( pstatus ) );
			}
		}

HandleError:
	if ( pfucbNil != pfucbIndex )
		{
		Assert( err < 0 );
		DIRClose( pfucbIndex );
		}

	return err;
	}


ERR ErrFILEBuildAllIndexes(
	PIB			* const ppib,
	FUCB		* const pfucbTable,
	FCB			* const pfcbIndexes,
	STATUSINFO	* const pstatus,
	const ULONG	cIndexBatchMax,
	const BOOL	fCheckOnly,
	CPRINTF		* const pcprintf )
	{
	ERR	 	 	err;
	DIB			dib;
	FUCB 	  	*rgpfucbSort[cFILEIndexBatchSizeDefault];
	FCB			*pfcbIndexesToBuild;
	FCB			*pfcbNextBuildIndex;
	KEY			keyBuffer;
	BYTE  	 	rgbKey[JET_cbSecondaryKeyMost];
	ULONG		rgcRecInput[cFILEIndexBatchSizeDefault];
	INT			cIndexesToBuild;
	INT			iindex;
	BOOL		fTransactionStarted		= fFalse;
	BOOL		fCorruptionEncountered	= fFalse;
	const BOOL	fLogged					= rgfmp[pfucbTable->ifmp].FLogOn();
	INST		* const	pinst			= PinstFromPpib( ppib );

	if ( 0 == ppib->level )
		{
		//	only reason we need a transaction is to ensure read-consistency of primary data
		CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
		fTransactionStarted = fTrue;
		}

	Assert( cIndexBatchMax > 0 );
	Assert( cIndexBatchMax <= cFILEIndexBatchSizeDefault );
	for ( iindex = 0; iindex < cIndexBatchMax; iindex++ )
		rgpfucbSort[iindex] = pfucbNil;

	keyBuffer.prefix.Nullify();
	keyBuffer.suffix.SetCb( sizeof( rgbKey ) );
	keyBuffer.suffix.SetPv( rgbKey );

	dib.pos 	= posFirst;
	dib.pbm 	= NULL;
	dib.dirflag = fDIRNull;

	FUCBSetPrereadForward( pfucbTable, cpgPrereadSequential );
	err = ErrBTDown( pfucbTable, &dib, latchReadTouch );
	Assert( JET_errNoCurrentRecord != err );
	if( JET_errRecordNotFound == err )
		{
		//  the tree is empty
		err = JET_errSuccess;
		goto HandleError;
		}

	// Cursor building index should only be navigating primary index.
	Assert( pfucbNil == pfucbTable->pfucbCurIndex );

	// Don't waste time by calling this function when unneeded.
	Assert( pfcbNil != pfcbIndexes );

	pfcbNextBuildIndex = pfcbIndexes;

NextBuild:
#ifdef SHOW_INDEX_PERF
	ULONG	cRecs, cPages;
	TICK	tickStart;
	PGNO	pgnoLast;
	cRecs = 0;
	cPages	= 1;
	pgnoLast = Pcsr( pfucbTable )->Pgno();
	tickStart	= TickOSTimeCurrent();
#endif

	//	HACK: force locLogical to OnCurBM to silence
	//	RECIRetrieveKey(), which will make DIR-level
	//	calls using this cursor
	pfucbTable->locLogical = locOnCurBM;

	pfcbIndexesToBuild = pfcbNextBuildIndex;
	pfcbNextBuildIndex = pfcbNil;

	Assert( cIndexBatchMax <= cFILEIndexBatchSizeDefault );
	err = ErrFILEIndexBatchInit(
				ppib,
				rgpfucbSort,
				pfcbIndexesToBuild,
				&cIndexesToBuild,
				rgcRecInput,
				&pfcbNextBuildIndex,
				cIndexBatchMax );

	// This is either a full batch or the last batch of indexes to build.
	Assert( err < 0
		|| cIndexBatchMax == cIndexesToBuild
		|| pfcbNil == pfcbNextBuildIndex );

#ifdef SHOW_INDEX_PERF
	OSTrace( ostlIndexPerf, OSFormat(	"Beginning scan of records to rebuild %d indexes.\n", cIndexesToBuild ) );
	OSTraceIndent( ostlIndexPerf, +1 );

	FCB *	pfcbIndexT;
	for ( pfcbIndexT = pfcbIndexesToBuild, iindex = 0; iindex < cIndexesToBuild; pfcbIndexT = pfcbIndexT->PfcbNextIndex(), iindex++ )
		{
		TDB *	ptdbT	= pfcb->Ptdb();
		IDB *	pidbT	= pfcbIndexT->Pidb();

		OSTrace( ostlIndexPerf, OSFormat(	"Index #%d: %s\n",
											iindex+1,
											ptdbT->SzIndexName( pidbT->ItagIndexName() ) ) );
		}
	OSTraceIndent( ostlIndexPerf, -1 );
#endif

	//	build up new index in a sort file
	//
	do
		{
		Call( err );

		//	this loop can take some time, so see if we need
		//	to terminate because of shutdown
		//
		Call( pinst->ErrCheckForTermination() );

		if ( fLogged )
			{
			//	check if the log disk is full, because even
			//	though we're still in the scanning phase,
			//	we won't be able to insert keys into the
			//	index if we can't log the insertion
			//
			Call( ErrLGCheckState( pinst->m_plog ) );
			}

#ifdef SHOW_INDEX_PERF
		cRecs++;

		if ( Pcsr( pfucbTable )->Pgno() != pgnoLast )
			{
			cPages++;
			pgnoLast = Pcsr( pfucbTable )->Pgno();
			}
#endif

		//	get bookmark of primary index node
		//
		Assert( Pcsr( pfucbTable )->FLatched() );
		Assert( locOnCurBM == pfucbTable->locLogical );
		Call( ErrBTISaveBookmark( pfucbTable ) );

		Call( ErrFILEIndexBatchAddEntry(
					rgpfucbSort,
					pfucbTable,
					&pfucbTable->bmCurr,
					pfucbTable->kdfCurr.data,
					pfcbIndexesToBuild,
					cIndexesToBuild,
					rgcRecInput,
					keyBuffer ) );

		Assert( Pcsr( pfucbTable )->FLatched() );
		err = ErrBTNext( pfucbTable, fDIRNull );
		}
	while ( JET_errNoCurrentRecord != err );
	Assert( JET_errNoCurrentRecord == err );

#ifdef SHOW_INDEX_PERF
	OSTrace( ostlIndexPerf, OSFormat(	"Scanned %d records (%d pages) and formulated all keys in %d msecs.\n",
										cRecs,
										cPages,
										TickOSTimeCurrent() - tickStart ) );
#endif

	FUCBResetPreread( pfucbTable );
	BTUp( pfucbTable );

	Call( ErrFILEIndexBatchTerm(
				ppib,
				rgpfucbSort,
				pfcbIndexesToBuild,
				cIndexesToBuild,
				rgcRecInput,
				pstatus,
				fCheckOnly ? &fCorruptionEncountered : NULL,
				pcprintf ) );

	if ( pfcbNil != pfcbNextBuildIndex )
		{
		//	reseek to beginning of data (must succeed since it succeeded the first time)
		FUCBSetPrereadForward( pfucbTable, cpgPrereadSequential );
		err = ErrBTDown( pfucbTable, &dib, latchReadTouch );
		CallS( err );
		Call( err );

		goto NextBuild;
		}

	err = ( fCorruptionEncountered ?
				ErrERRCheck( JET_errDatabaseCorrupted ) :
				JET_errSuccess );

HandleError:
#ifdef SHOW_INDEX_PERF
	OSTrace( ostlIndexPerf, OSFormat( "Completed batch index build with error %d.\n", err ) );
#endif

	Assert ( err != errDIRNoShortCircuit );
	if ( err < 0 )
		{
		for ( iindex = 0; iindex < cIndexBatchMax; iindex++ )
			{
			if ( pfucbNil != rgpfucbSort[iindex] )
				{
				SORTClose( rgpfucbSort[iindex] );
				rgpfucbSort[iindex] = pfucbNil;
				}
			}

		FUCBResetPreread( pfucbTable );
		BTUp( pfucbTable );
		}

	if ( fTransactionStarted )
		{
		//	read-only transaction, so should never fail
		CallS( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );
		}

	return err;
	}

#endif	//	PARALLEL_BATCH_INDEX_BUILD


//	resume logging on an index build for which logging was initially suspended
//
LOCAL VOID FILEIEnableCreateIndexLogging( PIB * ppib, FCB * const pfcbIdx )
	{
	INST * const	pinst			= PinstFromPpib( ppib );
	const ULONG		cbTraceBuffer	= 127;
	CHAR			szTraceBuffer[cbTraceBuffer + 1];

	Assert( rgfmp[pfcbIdx->Ifmp()].FLogOn() );
	Assert( !pinst->m_plog->m_fLogDisabled );

	//	reset flag
	//
	pfcbIdx->ResetDontLogSpaceOps();

	//	decrement count of non-logged index creators to
	//	release backup
	//
	pinst->DecrementCNonLoggedIndexCreators();

	szTraceBuffer[cbTraceBuffer] = 0;
	_snprintf(
		szTraceBuffer,
		cbTraceBuffer,
		"CreateIndex logging prematurely enabled [objid:0x%x,pgnoFDP:0x%x]",
		pfcbIdx->ObjidFDP(),
		pfcbIdx->PgnoFDP() );
	CallS( pinst->m_plog->ErrLGTrace( ppib, szTraceBuffer ) );
	}


//+API
// BuildIndex
// ========================================================================
// ERR BuildIndex( PIB *ppib, FUCB *pfucb, CHAR *szIndex )
//
// Builds a new index for a file from scratch;  szIndex gives the
// name of an index definition.
//
// PARAMETERS	ppib						PIB of user
//		   		pfucb						Exclusively opened FUCB on file
//		   		szIndex 					name of index to build
//
// RETURNS		Error code from DIRMAN or SORT or
//					JET_errSuccess	  		Everything worked OK.
// COMMENTS
//			A transaction is wrapped around this function at the callee.
//
// SEE ALSO		ErrIsamCreateIndex
//-
LOCAL ERR ErrFILEIBuildIndex(
	PIB *			ppib,
	FUCB *			pfucbTable,
	FUCB *			pfucbIndex,
	BOOL * const	pfIndexLogged )
	{
	ERR				err;
	INST * const	pinst			= PinstFromPpib( ppib );
	LOG * const		plog			= pinst->m_plog;
	FCB * const		pfcbIdx			= pfucbIndex->u.pfcb;
	INT				fDIRFlags		= ( fDIRNoVersion | fDIRAppend | ( *pfIndexLogged ? 0 : fDIRNoLog ) );
	FUCB *			pfucbSort		= pfucbNil;
	IDB *			pidb;
	DIB				dib;
	KEY				keyBuffer;
	BYTE			rgbKey[JET_cbSecondaryKeyMost];
	INT				fUnique;
	LONG			cRecInput		= 0;
	LONG			cRecOutput;

	// Cursor building index should only be navigating primary index.
	Assert( pfucbNil == pfucbTable->pfucbCurIndex );

	// Work buffer is not used when building index.
	Assert( NULL == pfucbIndex->pvWorkBuf );

	Assert( FFUCBSecondary( pfucbIndex ) );
	Assert( pfcbNil != pfcbIdx );
	Assert( pfcbIdx->Pidb() != pidbNil );
	Assert( pfcbIdx->FTypeSecondaryIndex() );
	Assert( pfcbIdx->FInitialized() );

	// Index has not yet been linked into table's index list.
	Assert( pfcbIdx->PfcbTable() == pfcbNil );
	Assert( pfcbIdx->PfcbNextIndex() == pfcbNil );

	pidb = pfcbIdx->Pidb();
	fUnique = pidb->FUnique();

	dib.pos 	= posFirst;
	dib.pbm 	= NULL;
	dib.dirflag = fDIRNull;

	FUCBSetPrereadForward( pfucbTable, cpgPrereadSequential );
	err = ErrBTDown( pfucbTable, &dib, latchReadTouch );
	Assert( JET_errNoCurrentRecord != err );
	if( JET_errRecordNotFound == err )
		{
		//  the tree is empty
		err = JET_errSuccess;
		goto HandleError;
		}

	Call( err );

	//	HACK: force locLogical to OnCurBM to silence
	//	RECIRetrieveKey(), which will make DIR-level
	//	calls using this cursor
	pfucbTable->locLogical = locOnCurBM;

	keyBuffer.prefix.Nullify();
	keyBuffer.suffix.SetCb( sizeof( rgbKey ) );
	keyBuffer.suffix.SetPv( rgbKey );

	//	open sort
	//
	err = ErrSORTOpen( ppib, &pfucbSort, fUnique, fTrue );

#ifdef SHOW_INDEX_PERF
	ULONG	cRecs, cPages;
	TICK	tickStart;
	PGNO	pgnoLast;
	cRecs = 0;
	cPages	= 1;
	pgnoLast = Pcsr( pfucbTable )->Pgno();
	tickStart	= TickOSTimeCurrent();
#endif

	//	build up new index in a sort file
	//
	do
		{
		Call( err );

		//	this loop can take some time, so see if we need
		//	to terminate because of shutdown
		//
		Call( pinst->ErrCheckForTermination() );

		//	check if the log disk is full, because even
		//	though we're still in the scanning phase,
		//	we won't be able to insert keys into the
		//	index if we can't log the insertion
		//
		//	NOTE: must check even if fIndexLogged is FALSE
		//	because we may be in the pseudo-logging-disabled
		//	state where logging is actually enabled, but
		//	we're not logging index creation, but we are
		//	still logging space operations, so we may end
		//	up filling the logs with that, and even if
		//	logging is truly disabled, we're just doing
		//	an extra check of a couple of members of LOG
		//
		Call( ErrLGCheckState( plog ) );

		//	if we've suspended logging on this btree,
		//	but a backup is in progress, we're going
		//	to have to enable logging to ensure
		//	the backup set is created properly
		//
		if ( plog->m_fBackupInProgress
			&& !( *pfIndexLogged )
			&& rgfmp[pfucbTable->ifmp].FLogOn() )
			{
			Assert( !plog->m_fLogDisabled );
			Assert( fDIRFlags & fDIRNoLog );
			fDIRFlags &= ~fDIRNoLog;

			//	NOTE: we don't need to force-flush here
			//	(as we do below) because at this point,
			//	we're just scanning and building the
			//	sort, so we haven't written anything
			//	non-logged to the database yet

			//	re-enable logging
			//
			*pfIndexLogged = fTrue;
			FILEIEnableCreateIndexLogging( ppib, pfcbIdx );
			}

#ifdef SHOW_INDEX_PERF
		cRecs++;

		if ( Pcsr( pfucbTable )->Pgno() != pgnoLast )
			{
			cPages++;
			pgnoLast = Pcsr( pfucbTable )->Pgno();
			}
#endif

		//	get bookmark of primary index node
		//
		Assert( Pcsr( pfucbTable )->FLatched() );
		Assert( locOnCurBM == pfucbTable->locLogical );
		Call( ErrBTISaveBookmark( pfucbTable ) );

		Assert( pfucbTable->bmCurr.key.prefix.FNull() );
		Assert( pfucbTable->bmCurr.data.FNull() );

		LONG	cSecondaryIndexEntriesAdded;
		Call( ErrFILEIAddSecondaryIndexEntriesForPrimaryKey(
					pfucbTable,
					pfcbIdx,
					pfucbTable->kdfCurr.data,
					pfucbTable->bmCurr.key.suffix,
					pfucbSort,
					keyBuffer,
					fFalse,
					&cSecondaryIndexEntriesAdded
					) );

		cRecInput += cSecondaryIndexEntriesAdded;

		Assert( Pcsr( pfucbTable )->FLatched() );
		err = ErrBTNext( pfucbTable, fDIRNull );
		}
	while ( JET_errNoCurrentRecord != err );
	Assert( JET_errNoCurrentRecord == err );

#ifdef SHOW_INDEX_PERF
	OSTrace( ostlIndexPerf, OSFormat(	"Scanned %d records (%d pages) and formed %d keys in %d msecs.\n",
										cRecs,
										cPages,
										cRecInput,
										TickOSTimeCurrent() - tickStart ) );
#endif

	FUCBResetPreread( pfucbTable );
	BTUp( pfucbTable );

#ifdef SHOW_INDEX_PERF
	tickStart	= TickOSTimeCurrent();
#endif

	Call( ErrSORTEndInsert( pfucbSort ) );

#ifdef SHOW_INDEX_PERF
	OSTrace( ostlIndexPerf, OSFormat(	"Sorted keys in %d msecs.\n",
										TickOSTimeCurrent() - tickStart ) );
#endif

	//	transfer index entries to actual index
	//	insert first one in normal method!
	//
	err = ErrSORTNext( pfucbSort );
	if ( err < 0 )
		{
		if ( JET_errNoCurrentRecord == err )
			{
			SORTClose( pfucbSort );
			err = JET_errSuccess;
			}
		goto HandleError;
		}

	//	move to FDP root
	//
	DIRGotoRoot( pfucbIndex );
	Call( ErrDIRInitAppend( pfucbIndex ) );

#ifdef SHOW_INDEX_PERF
	tickStart = TickOSTimeCurrent();
#endif

	Call( ErrDIRAppend( pfucbIndex,
						pfucbSort->kdfCurr.key,
						pfucbSort->kdfCurr.data,
						fDIRFlags ) );
	Assert( Pcsr( pfucbIndex )->FLatched() );
	cRecOutput = 1;

	//	from now on, try short circuit first
	//
	forever
		{
		err = ErrSORTNext( pfucbSort );
		if ( JET_errNoCurrentRecord == err )
			break;
		Call( err );

		//	this loop can take some time, so see if we need
		//	to terminate because of shutdown
		//
		Call( pinst->ErrCheckForTermination() );

		//	don't want to fill up reserve logs with index entries,
		//	so bail out if we're in the reserve logs (or out
		//	of log disk entirely)
		//
		//	NOTE: must check even if fIndexLogged is FALSE
		//	because we may be in the pseudo-logging-disabled
		//	state where logging is actually enabled, but
		//	we're not logging index creation, but we are
		//	still logging space operations, so we may end
		//	up filling the logs with that, and even if
		//	logging is truly disabled, we're just doing
		//	an extra check of a couple of members of LOG
		//
		Call( ErrLGCheckState( plog ) );

		//	if we've suspended logging on this btree,
		//	but a backup is in progress, we're going
		//	to have to enable logging to ensure
		//	the backup set is created properly
		//
		if ( plog->m_fBackupInProgress
			&& !( *pfIndexLogged )
			&& rgfmp[pfucbTable->ifmp].FLogOn() )
			{
			Assert( !plog->m_fLogDisabled );
			Assert( fDIRFlags & fDIRNoLog );
			fDIRFlags &= ~fDIRNoLog;

			//	flush all the work we've done so for to
			//	ensure it makes it into the backup set
			//
			Call( ErrBFFlush( pfucbTable->ifmp, fTrue, pfcbIdx->ObjidFDP() ) );

			//	re-enable logging
			//
			*pfIndexLogged = fTrue;
			FILEIEnableCreateIndexLogging( ppib, pfcbIdx );
			}

		Call( ErrDIRAppend( pfucbIndex,
							pfucbSort->kdfCurr.key,
							pfucbSort->kdfCurr.data,
							fDIRFlags ) );
		Assert( Pcsr( pfucbIndex )->FLatched() );
		cRecOutput++;
		}

#ifdef SHOW_INDEX_PERF
	OSTraceIndent( ostlIndexPerf, +1 );
	OSTrace( ostlIndexPerf, OSFormat(	"Appended %d records to secondary index in %d msecs.\n",
										cRecOutput,
										TickOSTimeCurrent() - tickStart ) );
	OSTraceIndent( ostlIndexPerf, -1 );
#endif

	Call( ErrDIRTermAppend( pfucbIndex ) );

	//	If we got dupes and the index was NOT unique, it must have been
	//	dupes over multi-value columns, in which case the dupes
	//	get properly eliminated.
	Assert( cRecOutput <= cRecInput );
	if ( cRecOutput != cRecInput )
		{
		if ( cRecOutput < cRecInput )
			{
			if ( fUnique )
				{
				err = ErrERRCheck( JET_errKeyDuplicate );
				goto HandleError;
				}
			else
				{
				//	duplicates over multi-valued columns must have been removed
				}
			}
		else
			{
			err = ErrERRCheck( JET_errIndexBuildCorrupted );
			goto HandleError;
			}
		}

	SORTClose( pfucbSort );
	err = JET_errSuccess;

HandleError:
	Assert ( err != errDIRNoShortCircuit );
	if ( err < 0 )
		{
		if ( pfucbSort != pfucbNil )
			{
			SORTClose( pfucbSort );
			}

		FUCBResetPreread( pfucbTable );
		BTUp( pfucbTable );
		}

	// Work buffer is not used when building index.
	Assert( NULL == pfucbIndex->pvWorkBuf );

	return err;
	}

LOCAL ERR ErrFILEIProcessRCE( PIB *ppib, FUCB *pfucbTable, FUCB *pfucbIndex, RCE *prce )
	{
	ERR			err;
	FCB			*pfcbTable = pfucbTable->u.pfcb;
	FCB			*pfcbIndex = pfucbIndex->u.pfcb;
	const OPER	oper = prce->Oper();
	BOOKMARK	bookmark;
	BOOL		fUncommittedRCE = fFalse;
	PIB			*ppibProxy = ppibNil;

	Assert( pfcbTable != pfcbNil );
	Assert( pfcbIndex != pfcbNil );

	Assert( pfcbTable->CritRCEList().FOwner() );

	Assert( prceNil != prce );
	if ( prce->TrxCommitted() == trxMax )
		{
		Assert( prce->Pfucb() != pfucbNil );
		Assert( !prce->FRolledBack() );

		ppibProxy = prce->Pfucb()->ppib;
		Assert( ppibNil != ppibProxy );
		Assert( ppibProxy != ppib );

		Assert( crefVERCreateIndexLock >= 0 );
		AtomicIncrement( const_cast<LONG *>( &crefVERCreateIndexLock ) );
		Assert( crefVERCreateIndexLock >= 0 );

		fUncommittedRCE = fTrue;
		}

	prce->GetBookmark( &bookmark );
	Assert( bookmark.key.prefix.FNull() );
	Assert( bookmark.key.Cb() > 0 );

	pfcbTable->CritRCEList().Leave();

	// Find node and obtain read latch.
	err = ErrBTGotoBookmark( pfucbTable, bookmark, latchReadNoTouch );
	if ( err < 0 )
		{
		Assert( JET_errRecordDeleted != err );
		AssertDIRNoLatch( pfucbTable->ppib );

		if ( fUncommittedRCE )
			{
			Assert( crefVERCreateIndexLock >= 0 );
			AtomicDecrement( const_cast<LONG *>( &crefVERCreateIndexLock ) );
			Assert( crefVERCreateIndexLock >= 0 );
			}

		// Must re-enter CritRCEList() before leaving, to get to the
		// next RCE on this FCB.
		pfcbTable->CritRCEList().Enter();
		return err;
		}

	Assert( Pcsr( pfucbTable )->FLatched() );	// Read-latch obtained.

	// Must extract proper data-record image with which to update secondary index.
	// In order to obtain proper image, must scan future RCE's on this node.
	prce->CritChain().Enter();

	RCE	*prceNextReplace;
	for ( prceNextReplace = prce->PrceNextOfNode();
		prceNextReplace != prceNil && prceNextReplace->Oper() != operReplace;
		prceNextReplace = prceNextReplace->PrceNextOfNode() )
		{
		// Shouldn't be NULL, since our transaction will block cleanup.
		Assert( !prceNextReplace->FOperNull() );
		}

	if ( prceNextReplace != prceNil )
		{
		Assert( prceNextReplace->Oper() == operReplace );
		pfucbTable->dataWorkBuf.SetPv(
			const_cast<BYTE *>( prceNextReplace->PbData() ) + cbReplaceRCEOverhead );
		pfucbTable->dataWorkBuf.SetCb(
			prceNextReplace->CbData() - cbReplaceRCEOverhead );
		prce->CritChain().Leave();
		}
	else
		{
		prce->CritChain().Leave();

		// Set dataWorkBuf.pv to point to pvWorkBuf, in case it was reset.
		Assert ( NULL != pfucbTable->pvWorkBuf );
		pfucbTable->dataWorkBuf.SetPv( (BYTE*)pfucbTable->pvWorkBuf );

		// Go to database for record.
		pfucbTable->kdfCurr.data.CopyInto( pfucbTable->dataWorkBuf );
		}

	// Table's cursor now contains (in dataWorkBuf) the data record used to generate
	// the secondary index key to be inserted (for operInsert or operReplace)
	// or deleted (for operDeleted).
	// Read-latch may now be freed.
	BTUp( pfucbTable );

	// RCE's can only be removed by two routines: RCEClean and rollback.  Since
	// we're in a transaction and this RCE is active, the RCE is blocked from
	// being cleaned up.  This leaves just rollback, which we handle using
	// the crefVERCreateIndexLock global variable.
	// If this count is non-zero, anyone trying to rollback an update (ie. insert,
	// delete, or replace) on any primary index will fail and retry.
	if ( fUncommittedRCE )
		{

		// This ensures that the RCE is not committed from underneath us.
		// Note that even if the RCE has since been committed and the
		// PIB freed, we are still able to use the critTrx member of
		// the PIB because we never actually release the PIB memory
		// (we just put it on the free PIB list).
		// UNDONE: Optimise by blocking only Commit, not all other CreateIndex
		// threads working on an RCE belonging to this session as well.
		ppibProxy->critTrx.Enter();

		// Decrement PreventRollback count.  The RCEChain critical section now
		// protects the RCE from being deleted.
		Assert( crefVERCreateIndexLock >= 0 );
		AtomicDecrement( const_cast<LONG *>( &crefVERCreateIndexLock ) );
		Assert( crefVERCreateIndexLock >= 0 );

		// See if the RCE committed or rolled back in the time when we lost
		// the FCB critical section and when we gained the PIB critical section.
		if ( prce->TrxCommitted() == trxMax )
			{
			if ( prce->FRolledBack() )
				{
				err = JET_errSuccess;	// RCE rolled back, so nothing to do.
				goto HandleError;
				}
			}
		else
			{
			Assert( TrxCmp( prce->TrxCommitted(), ppib->trxBegin0 ) > 0 );

			ppibProxy->critTrx.Leave();
			fUncommittedRCE = fFalse;
			}
		}

	Assert( ::FOperAffectsSecondaryIndex( oper ) );
	Assert( prce->TrxCommitted() != trxMax || !prce->FRolledBack() );

	if ( oper == operInsert )
		{
		Call( ErrRECIAddToIndex( pfucbTable, pfucbIndex, &bookmark, fDIRNull, prce ) );
		}
	else if ( oper == operFlagDelete )
		{
		Call( ErrRECIDeleteFromIndex( pfucbTable, pfucbIndex, &bookmark, prce ) );
		}
	else
		{
		Assert( oper == operReplace );
		Call( ErrRECIReplaceInIndex( pfucbTable, pfucbIndex, &bookmark, prce ) );
		}

	// Must version operations committed after the indexer began his
	// transaction is to ensure that the indexer himself will have a
	// consistent view of the secondary index.  Additionally, we must
	// provide an RCE for write-conflict detection.

HandleError:
	AssertDIRNoLatch( pfucbTable->ppib );

	pfcbTable->CritRCEList().Enter();

	if ( fUncommittedRCE )
		{
		Assert( ppibNil != ppibProxy );
		ppibProxy->critTrx.Leave();
		}

	return err;
	}


// This routine updates the index being created with the versioned up
LOCAL ERR ErrFILEIUpdateIndex( PIB *ppib, FUCB *pfucbTable, FUCB *pfucbIndex )
	{
	ERR			err			= JET_errSuccess;
	FCB			*pfcbTable	= pfucbTable->u.pfcb;
	FCB			*pfcbIndex	= pfucbIndex->u.pfcb;
	const TRX	trxSession	= ppib->trxBegin0;

	Assert( trxSession != trxMax );

	Assert( pfcbTable->FInitialized() );
	Assert( pfcbTable->FPrimaryIndex() );
	Assert( pfcbTable->FTypeTable() );
	Assert( pfcbTable->FInitialized() );

	Assert( FFUCBSecondary( pfucbIndex ) );
	Assert( pfcbIndex->FInitialized() );
	Assert( pfcbIndex->FTypeSecondaryIndex() );
	Assert( pfcbIndex->PfcbTable() == pfcbNil );	// Index FCB should not be linked in yet.
	Assert( pfcbIndex->Pidb() != pidbNil );

	//	allocate working buffer
	//
	Assert( NULL == pfucbTable->pvWorkBuf );
	RECIAllocCopyBuffer( pfucbTable );

	// Set dirty cursor isolation model to allow unversioned
	// access to secondary index by proxy.
	Assert( !FPIBDirty( pfucbIndex->ppib ) );
	PIBSetCIMDirty( pfucbIndex->ppib );


	BOOL	fUpdatesQuiesced	= fFalse;
	RCE		*prceLastProcessed	= prceNil;
	RCE		*prce;

	pfcbTable->CritRCEList().Enter();
	prce = pfcbTable->PrceOldest();

	forever
		{
		//	scan RCE's for next one to process
		while ( prceNil != prce
				&& ( !prce->FOperAffectsSecondaryIndex()
					|| prce->FRolledBack()
					|| !prce->FActiveNotByMe( ppib, trxSession ) ) )
			{
			Assert( prce->FActiveNotByMe( ppib, trxSession ) || prce->TrxCommitted() != trxSession );
			prce = prce->PrceNextOfFCB();
			}

		if ( prceNil == prce )
			{
			if ( fUpdatesQuiesced )
				break;

			// Reached end of RCE list for this FCB.  Quiesce further updates
			// (letting current updates complete), then re-read RCE list in
			// case more RCE's entered while we were quiescing.  The RCE we
			// last processed is guaranteed to remain because we block rollbacks.
			Assert( prceNil == prceLastProcessed || !prceLastProcessed->FOperNull() );
			Assert( crefVERCreateIndexLock >= 0 );
			AtomicIncrement( const_cast<LONG *>( &crefVERCreateIndexLock ) );
			Assert( crefVERCreateIndexLock >= 0 );

			pfcbTable->CritRCEList().Leave();
			pfcbTable->SetIndexing();
			pfcbTable->CritRCEList().Enter();

			Assert( crefVERCreateIndexLock >= 0 );
			AtomicDecrement( const_cast<LONG *>( &crefVERCreateIndexLock ) );
			Assert( crefVERCreateIndexLock >= 0 );

			fUpdatesQuiesced = fTrue;

			Assert( prceNil == prceLastProcessed || !prceLastProcessed->FOperNull() );
			prce = ( prceNil == prceLastProcessed ? pfcbTable->PrceOldest() : prceLastProcessed->PrceNextOfFCB() );
			}

		else
			{
			Assert( prce->FOperAffectsSecondaryIndex() );
			Assert( !prce->FRolledBack() );
			Assert( prce->FActiveNotByMe( ppib, trxSession ) );
			Call( ErrFILEIProcessRCE( ppib, pfucbTable, pfucbIndex, prce ) );

			prceLastProcessed = prce;
			prce = prce->PrceNextOfFCB();
			}
		}

	pfcbTable->CritRCEList().Leave();

	//	link new FCB and update index mask
	Assert( fUpdatesQuiesced );

	pfcbTable->EnterDDL();
	pfcbTable->LinkSecondaryIndex( pfcbIndex );
	FILESetAllIndexMask( pfcbTable );
	pfcbTable->LeaveDDL();

	//	since we have a cursor open on pfcbTable, the FCB
	//		cannot be in the avail list; thus, we can directly
	//		set the above-threshold flag

	if ( pfcbIndex >= PfcbFCBPreferredThreshold( PinstFromPpib( ppib ) ) )
		{
		pfcbTable->Lock();
		pfcbTable->SetAboveThreshold();
		pfcbTable->Unlock();
		}

	pfcbTable->ResetIndexing();
	goto ResetCursor;

HandleError:
	pfcbTable->CritRCEList().Leave();
	if ( fUpdatesQuiesced )
		{
		pfcbTable->ResetIndexing();
		}

ResetCursor:
	Assert( FPIBDirty( pfucbIndex->ppib ) );
	PIBResetCIMDirty( pfucbIndex->ppib );

	Assert ( NULL != pfucbTable->pvWorkBuf );
	RECIFreeCopyBuffer( pfucbTable );

	return err;
	}


LOCAL ERR ErrFILEIPrepareOneIndex(
	PIB				* const ppib,
	FUCB			* const pfucbTable,
	FUCB			** ppfucbIdx,
	JET_INDEXCREATE	* const pidxcreate,
	const CHAR		* const szIndexName,
	const CHAR		* rgszColumns[],
	const BYTE		* rgfbDescending,
	IDB				* const pidb,
	const ULONG		ulDensity )
	{
	ERR				err;
	const IFMP		ifmp					= pfucbTable->ifmp;
	FCB				* const pfcb			= pfucbTable->u.pfcb;
	FCB			 	* pfcbIdx 				= pfcbNil;
	PGNO			pgnoIndexFDP;
	OBJID			objidIndex;
	FIELD			* pfield;
	COLUMNID		columnid;
	IDXSEG			rgidxseg[JET_ccolKeyMost];
	IDXSEG			rgidxsegConditional[JET_ccolKeyMost];
	const BOOL		fLockColumn				= !pfcb->FDomainDenyReadByUs( ppib );
	const BOOL		fPrimary				= pidb->FPrimary();
	BOOL			fColumnWasDerived;
	BOOL			fMultivalued;
	BOOL			fText;
	BOOL			fLocalizedText;
	BOOL			fCleanupIDB 			= fFalse;
	USHORT			iidxseg;

	//	if we don't have exclusive use of the table, we have
	//	to lock all columns in the index to ensure they don't
	//	get deleted out from underneath us
	Assert( !fLockColumn || !pfcb->FTemplateTable() );

	for ( iidxseg = 0; iidxseg < pidb->Cidxseg(); iidxseg++ )
		{
		Call( ErrFILEGetPfieldAndEnterDML(
					ppib,
					pfcb,
					rgszColumns[iidxseg],
					&pfield,
					&columnid,
					&fColumnWasDerived,
					fLockColumn ) );

		fMultivalued = FFIELDMultivalued( pfield->ffield );
		fText = FRECTextColumn( pfield->coltyp );
		fLocalizedText = ( fText && usUniCodePage == pfield->cp );

		if ( FFIELDEscrowUpdate( pfield->ffield ) || FRECSLV( pfield->coltyp ) )
			{
			err = ErrERRCheck( JET_errCannotIndex );
			}
		else if ( fPrimary && fMultivalued )
			{
			//	primary index cannot be multivalued
			//
			err = ErrERRCheck( JET_errIndexInvalidDef );
			}
		else if ( ( pidxcreate->grbit & JET_bitIndexEmpty ) && FFIELDDefault( pfield->ffield ) )
			{
			//	can't build empty index over column with default value
			err = ErrERRCheck( JET_errIndexInvalidDef );
			}

		if ( !fColumnWasDerived )
			{
			pfcb->LeaveDML();
			}

		Call( err );

		if ( pidb->FTuples() )
			{
			if ( !fText )
				{
				err = ErrERRCheck( JET_errIndexTuplesTextColumnsOnly );
				goto HandleError;
				}
			}

		if ( fMultivalued )
			pidb->SetFMultivalued();
		if ( fLocalizedText )
			{
			pidb->SetFLocalizedText();
			if( FNORMStringHasUndefinedCharsIsSupported() )
				{
				pidb->SetFUnicodeFixupOn();
				}
			}


		rgidxseg[iidxseg].ResetFlags();

		if ( rgfbDescending[iidxseg] )
			rgidxseg[iidxseg].SetFDescending();

		rgidxseg[iidxseg].SetColumnid( columnid );
		}

	if( pidxcreate->cConditionalColumn > JET_ccolKeyMost )
		{
		err = ErrERRCheck( JET_errIndexInvalidDef );
		Call( err );
		}

	pidb->SetCidxsegConditional( BYTE( pidxcreate->cConditionalColumn ) );
	for ( iidxseg = 0; iidxseg < pidb->CidxsegConditional(); iidxseg++ )
		{
		Assert( !pidb->FPrimary() );

		const CHAR			* const szColumnName	= pidxcreate->rgconditionalcolumn[iidxseg].szColumnName;
		const JET_GRBIT		grbit					= pidxcreate->rgconditionalcolumn[iidxseg].grbit;

		if( sizeof( JET_CONDITIONALCOLUMN ) != pidxcreate->rgconditionalcolumn[iidxseg].cbStruct )
			{
			err = ErrERRCheck( JET_errIndexInvalidDef );
			Call( err );
			}

		if( JET_bitIndexColumnMustBeNonNull != grbit
			&& JET_bitIndexColumnMustBeNull != grbit )
			{
			err = ErrERRCheck( JET_errInvalidGrbit );
			Call( err );
			}

		Call( ErrFILEGetPfieldAndEnterDML(
				ppib,
				pfcb,
				szColumnName,
				&pfield,
				&columnid,
				&fColumnWasDerived,
				fLockColumn ) );
		if ( !fColumnWasDerived )
			{
			pfcb->LeaveDML();
			}

		rgidxsegConditional[iidxseg].ResetFlags();

		if ( JET_bitIndexColumnMustBeNull == grbit )
			{
			rgidxsegConditional[iidxseg].SetFMustBeNull();
			}

		rgidxsegConditional[iidxseg].SetColumnid( columnid );
		}

	pfcb->EnterDDL();

	USHORT	itag;
	err = pfcb->Ptdb()->MemPool().ErrAddEntry(
				(BYTE *)szIndexName,
				(ULONG)strlen( szIndexName ) + 1,
				&itag );
	if ( err < JET_errSuccess )
		{
		pfcb->LeaveDDL();
		goto HandleError;
		}
	Assert( 0 != itag );
	pidb->SetItagIndexName( itag );

	err = ErrIDBSetIdxSeg( pidb, pfcb->Ptdb(), rgidxseg );
	if ( err < JET_errSuccess )
		{
		pfcb->Ptdb()->MemPool().DeleteEntry( pidb->ItagIndexName() );
		pfcb->LeaveDDL();
		goto HandleError;
		}
	err = ErrIDBSetIdxSegConditional( pidb, pfcb->Ptdb(), rgidxsegConditional );
	if ( err < JET_errSuccess )
		{
		if ( pidb->Cidxseg() > cIDBIdxSegMax )
			pfcb->Ptdb()->MemPool().DeleteEntry( pidb->ItagRgidxseg() );
		pfcb->Ptdb()->MemPool().DeleteEntry( pidb->ItagIndexName() );
		pfcb->LeaveDDL();
		goto HandleError;
		}
	fCleanupIDB = fTrue;

	Assert( !pfcb->FDomainDenyRead( ppib ) );
	if ( !pfcb->FDomainDenyReadByUs( ppib ) )
		{
		pidb->SetFVersioned();
		pidb->SetFVersionedCreate();
		}

	//	currently on Table FDP
	//
	DIRGotoRoot( pfucbTable );
	if ( fPrimary )
		{
		pfcb->AssertDDL();

		if ( pfcb->FSequentialIndex() )
			{
			Assert( pfcb->Pidb() == pidbNil );
			}
		else
			{
			// Primary index exists, or is in the process of being created (thus,
			// IDB may or may not be linked in).
			Assert( pfcb->Pidb() != pidbNil );
			pfcb->LeaveDDL();
			err = ErrERRCheck( JET_errIndexHasPrimary );
			goto HandleError;
			}

		// Block other threads from also creating primary index.
		pfcb->ResetSequentialIndex();

		pfcb->LeaveDDL();

		//	primary indexes are in same FDP as table
		//
		pgnoIndexFDP = pfcb->PgnoFDP();
		objidIndex = pfcb->ObjidFDP();

		// Must quiesce all updates in order to check that table is empty and
		// then link IDB in.
		pfcb->SetIndexing();

		//	check for records
		//
		DIRGotoRoot( pfucbTable );

		//	check for any node there, even if it is deleted.
		//	UNDONE: This is too strong since it may be deleted and
		//	committed, but this strong check ensures that no
		//	potentially there records exist.
		//
		DIB	dib;
		dib.dirflag = fDIRAllNode;
		dib.pos = posFirst;

		err = ErrDIRDown( pfucbTable, &dib );
		Assert( err <= 0 );		// Shouldn't get warnings.
		if ( JET_errRecordNotFound != err )
			{
			if ( JET_errSuccess == err )
				{
				err = ErrERRCheck( JET_errTableNotEmpty );
				DIRUp( pfucbTable );
				DIRDeferMoveFirst( pfucbTable );
				}

			pfcb->ResetIndexing();
			goto HandleError;
			}

		DIRGotoRoot( pfucbTable );

		pfcb->EnterDDL();

		Assert( !pfcb->FSequentialIndex() );
		err = ErrFILEIGenerateIDB( pfcb, pfcb->Ptdb(), pidb );
		if ( err < 0 )
			{
			pfcb->LeaveDDL();
			pfcb->ResetIndexing();
			goto HandleError;
			}

		Assert( pidbNil != pfcb->Pidb() );
		Assert( !pfcb->FSequentialIndex() );

		Assert( pfcb->PgnoFDP() == pgnoIndexFDP );
		Assert( ((( 100 - ulDensity ) << g_shfCbPage ) / 100) < g_cbPage );
		pfcb->SetCbDensityFree( (SHORT)( ( ( 100 - ulDensity ) << g_shfCbPage ) / 100 ) );

		// update all index mask
		FILESetAllIndexMask( pfcb );

		pfcb->LeaveDDL();

		pfcb->ResetIndexing();

		//	set currency to before first
		//
		DIRBeforeFirst( pfucbTable );

		Assert( pfucbNil == *ppfucbIdx );
		Assert( pfcbIdx == pfcbNil );
		}
	else
		{
		pfcb->LeaveDDL();

		Call( ErrDIRCreateDirectory(
				pfucbTable,
				(CPG)0,
				&pgnoIndexFDP,
				&objidIndex,
				CPAGE::fPageIndex | ( pidb->FUnique() ? 0 : CPAGE::fPageNonUniqueKeys ),
				( pidb->FUnique() ? 0 : fSPNonUnique ) ) );
		Assert( pgnoIndexFDP != pfcb->PgnoFDP() );
		Assert( objidIndex > objidSystemRoot );

		//	objids are monotonically increasing, so an index should
		//	always have higher objid than its table
		Assert( objidIndex > pfcb->ObjidFDP() );

		//	get pfcb of index directory
		//
		Call( ErrDIROpen( ppib, pgnoIndexFDP, ifmp, ppfucbIdx ) );
		Assert( *ppfucbIdx != pfucbNil );
		Assert( !FFUCBVersioned( *ppfucbIdx ) );	// Verify won't be deferred closed.
		pfcbIdx = (*ppfucbIdx)->u.pfcb;
		Assert( !pfcbIdx->FInitialized() );
		Assert( pfcbIdx->Pidb() == pidbNil );

		//	make an FCB for this index
		//
		pfcb->EnterDDL();
		err = ErrFILEIInitializeFCB(
			ppib,
			ifmp,
			pfcb->Ptdb(),
			pfcbIdx,
			pidb,
			fFalse,
			pgnoIndexFDP,
			ulDensity );
		pfcb->LeaveDDL();
		Call( err );

		Assert( pidbNil != pfcbIdx->Pidb() );

		//	finish the initialization of the secondary index

		pfcbIdx->CreateComplete();
		}

	Assert( pgnoIndexFDP > pgnoSystemRoot );
	Assert( pgnoIndexFDP <= pgnoSysMax );

	//	create index is flagged in version store so that
	//	DDL will be undone.  If flag fails then pfcbIdx
	//	must be released.
	//
	err = PverFromIfmp( ifmp )->ErrVERFlag( pfucbTable, operCreateIndex, &pfcbIdx, sizeof( pfcbIdx ) );
	if ( err < 0 )
		{
		if ( fPrimary )
			{
			pfcb->EnterDDL();
			pfcb->SetSequentialIndex();
			pfcb->LeaveDDL();
			}
		else
			{

			//	force the FCB to be uninitialized so that it will
			//		eventually be purged by DIRClose

			pfcbIdx->Lock();
			pfcbIdx->CreateComplete( errFCBUnusable );
			pfcbIdx->Unlock();

			//	verify that the FUCB will not be defer-closed

			Assert( !FFUCBVersioned( *ppfucbIdx ) );
			}
		goto HandleError;
		}

	fCleanupIDB = fFalse;	// FCB and IDB now in version store, so rollback will clean up.

	// Insert record into MSysIndexes.
	Call( ErrCATAddTableIndex(
				ppib,
				ifmp,
				pfcb->ObjidFDP(),
				szIndexName,
				pgnoIndexFDP,
				objidIndex,
				pidb,
				rgidxseg,
				rgidxsegConditional,
				ulDensity ) );

HandleError:
	if ( fCleanupIDB )
		{
		// We failed before we could properly version the index's FCB, so we'll
		// have to clean up the IDB ourself.
		Assert( err < 0 );

		pfcb->Ptdb()->MemPool().DeleteEntry( pidb->ItagIndexName() );
		if ( pidb->FIsRgidxsegInMempool() )
			pfcb->Ptdb()->MemPool().DeleteEntry( pidb->ItagRgidxseg() );
		if ( pidb->FIsRgidxsegConditionalInMempool() )
			pfcb->Ptdb()->MemPool().DeleteEntry( pidb->ItagRgidxsegConditional() );
		if ( pfcbNil != pfcbIdx && pidbNil != pfcbIdx->Pidb() )
			{
			pfcbIdx->ReleasePidb();
			}
		}

	return err;
	}


// ErrFILEICreateIndex
// ========================================================================
// ERR ErrFILEICreateIndex(
//		PIB		*ppib;			// IN	PIB of user
//		FUCB  	*pfucb;   		// IN	Exclusively opened FUCB of file
//		JET_INDEXCREATE * pindexcreate )
//
//	Defines an index on a file.
//
// PARAMETERS
//		ppib			PIB of user
//		pfucb			Exclusively opened FUCB of file
//		pindexcreate	Pointer to index create structure
//
//
// RETURNS	Error code from DIRMAN or
//			JET_errSuccess			Everything worked OK.
//			-JET_errColumnNotFound 	The index key specified
//									contains an undefined field.
//			-IndexHasPrimary 		The primary index for this
//							 		Insertfile is already defined.
// 			-IndexDuplicate  		An index on this file is
//	   								already defined with the
//									given name.
// 			-IndexInvalidDef 		There are too many segments
//							 		in the key.
// 			-TableNotEmpty	 		A primary index may not be
// 									defined because there is at
// 									least one record already in
// 									the file.
// COMMENTS
//		If transaction level > 0, there must not be anyone currently
//		using the file.
//		A transaction is wrapped around this function.	Thus, any
//		work done will be undone if a failure occurs.
//
// SEE ALSO		ErrIsamAddColumn, ErrIsamCreateTable, ErrIsamCreateIndex
//-
LOCAL ERR VTAPI ErrFILEICreateIndex(
	PIB					* ppib,
	FUCB				* pfucbTable,
	JET_INDEXCREATE		* pidxcreate )
	{
	ERR					err;
	INST * const		pinst						= PinstFromPpib( ppib );
	FUCB				* pfucb						= pfucbNil;
	FUCB				* pfucbIdx 					= pfucbNil;
	FCB					* const pfcb				= pfucbTable->u.pfcb;
	FCB					* pfcbIdx					= pfcbNil;
	IDB					idb;
	CHAR				szIndexName[ JET_cbNameMost+1 ];
	const CHAR			* rgszColumns[JET_ccolKeyMost];
	BYTE				rgfbDescending[JET_ccolKeyMost];
	const ULONG			ulDensity					= ( 0 == pidxcreate->ulDensity ) ? pfcb->UlDensity() : pidxcreate->ulDensity;
	BOOL				fInTransaction				= fFalse;
	BOOL				fUnversioned 				= fFalse;
	BOOL				fResetVersionedOnSuccess	= fFalse;

	//	check parms
	//
	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucbTable );

	if( sizeof( JET_INDEXCREATE ) != pidxcreate->cbStruct )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	Assert( dbidTemp != rgfmp[ pfucbTable->ifmp ].Dbid() );	// Don't currently support DDL on temp. tables.

	if ( pidxcreate->grbit & JET_bitIndexUnversioned )
		{
		if ( !FFUCBDenyRead( pfucbTable ) )
			{
			if ( ppib->level != 0 )
				{
				AssertSz( fFalse, "Must not be in transaction for unversioned CreateIndex." );
				err = ErrERRCheck( JET_errInTransaction );
				return err;
				}
			fUnversioned = fTrue;
			}
		}


	//	ensure that table is updatable
	//
	CallR( ErrFUCBCheckUpdatable( pfucbTable ) );
	CallR( ErrPIBCheckUpdatable( ppib ) );

	if ( pfcb->FFixedDDL() )
		{
		// Check FixedDDL override.
		if ( !FFUCBPermitDDL( pfucbTable ) || pfcb->FTemplateTable() )
			{
			err = ErrERRCheck( JET_errFixedDDL );
			return err;
			}

		// If DDL temporarily permitted, we must have exclusive use of the table.
		Assert( pfcb->FDomainDenyReadByUs( ppib ) );
		}

	CallR( ErrUTILCheckName( szIndexName, pidxcreate->szIndexName, JET_cbNameMost+1 ) );

	Assert( pfcb->Ptdb() != ptdbNil );
	CallR( ErrFILEIValidateCreateIndex(
				PinstFromPpib( ppib ),
				&idb,
				rgszColumns,
				rgfbDescending,
				pidxcreate,
				ulDensity ) );

	if ( fUnversioned )
		{
		CallR( ErrFILEInsertIntoUnverIndexList( pfcb, szIndexName ) );
		fResetVersionedOnSuccess = !pfcb->FDomainDenyReadByUs( ppib );
		}

	const BOOL	fPrimary	= idb.FPrimary();

	// Temporarily open new table cursor.
	Call( ErrDIROpen( ppib, pfcb, &pfucb ) );
	FUCBSetIndex( pfucb );
	FUCBSetMayCacheLVCursor( pfucb );

	Assert( pfucb->u.pfcb != pfcbNil );
	Assert( pfcb == pfucbTable->u.pfcb );
	Assert( pfcb->WRefCount() > 0 );
	Assert( pfcb->FTypeTable() );	// Temp. tables have fixed DDL.
	Assert( pfcb->Ptdb() != ptdbNil );

	Assert( !FFUCBSecondary( pfucb ) );
	Assert( !FCATSystemTable( pfcb->PgnoFDP() ) );

	Call( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	fInTransaction = fTrue;

#ifdef SHOW_INDEX_PERF
	OSTrace( ostlIndexPerf, OSFormat(	"Starting build of index '%s' with log at generation %d.\n",
										szIndexName,
										PinstFromPpib( ppib )->m_plog->m_plgfilehdr->lgfilehdr.le_lGeneration ) );
#endif

	Call( ErrFILEIPrepareOneIndex(
			ppib,
			pfucb,
			&pfucbIdx,
			pidxcreate,
			szIndexName,
			rgszColumns,
			rgfbDescending,
			&idb,
			ulDensity ) );

	if ( fPrimary )
		{
		Assert( pfucbNil == pfucbIdx );
		Assert( pfcbNil == pfcbIdx );
		}
	else
		{
		Assert( pfucbNil != pfucbIdx );
		pfcbIdx = pfucbIdx->u.pfcb;

		Assert( pfcbNil != pfcbIdx );
		Assert( pfcbIdx->FTypeSecondaryIndex() );

		if ( fUnversioned )
			{
			// Must reset trxBegin0 to oldest outstanding transaction
			// in order to get index properly versioned for all sessions.
			PIBSetTrxBegin0ToTrxOldest( ppib );
			}

		if ( pidxcreate->grbit & JET_bitIndexEmpty )
			{
			// UNDONE: This is a VERY dangerous flag.  The client had better
			// really know what he's doing, or the index could be easily
			// corrupted.  Ideally, the CreateIndex() should be wrapped in
			// a transaction along with the AddColumn() calls for the columns
			// in the index, and no records should be added between the
			// AddColumn() and the CreateIndex().  By putting the AddColumn()
			// in the same transaction as the CreateIndex(), you ensure that
			// other sessions won't be adding records with values over the
			// indexed columns.
			Assert( !idb.FNoNullSeg() );		// JET_bitIndexIgnoreAnyNull must also be specified.
			Assert( !idb.FAllowSomeNulls() );
			Assert( !idb.FAllowFirstNull() );
			Assert( !idb.FAllowAllNulls() );

			// link new FCB and update all index mask
			pfcb->EnterDDL();
			pfcb->LinkSecondaryIndex( pfcbIdx );
			FILESetAllIndexMask( pfcb );
			pfcb->LeaveDDL();

			//	since we have a cursor open on pfcbTable, the FCB
			//		cannot be in the avail list; thus, we can directly
			//		set the above-threshold flag

			if ( pfcbIdx >= PfcbFCBPreferredThreshold( PinstFromPpib( ppib ) ) )
				{
				pfcb->Lock();
				pfcb->SetAboveThreshold();
				pfcb->Unlock();
				}
			}
		else
			{
			const ULONG	cbTraceBuffer	= 127;
			CHAR 		szTraceBuffer[cbTraceBuffer + 1];

			//	we're not going to log this index creation if logging
			//	itself is disabled or if logging is enabled, but we're
			//	using circular logging and no backup is in progress
			//
			BOOL		fIndexLogged	= ( rgfmp[pfucbTable->ifmp].FLogOn()
											&& ( !pinst->m_plog->m_fLGCircularLogging
												|| pinst->m_plog->m_fBackupInProgress ) );

			Assert( !fIndexLogged || !pinst->m_plog->m_fLogDisabled );

			//	at this point the index has been added to the catalog
			//	it is possible that the FUnicodeFixupFlag() may be reset
			//	during index build, a change which will have to be propagated
			//	to the catalog
			//
			const IDBFLAG	idbflagPersisted	= idb.FPersistedFlags();

			FUCBSetIndex( pfucbIdx );
			FUCBSetSecondary( pfucbIdx );

			if ( !fIndexLogged && rgfmp[pfucbTable->ifmp].FLogOn() )
				{
				//	logging of this index is disabled, but logging
				//	in general is enabled, so we must block backup
				//
				pinst->IncrementCNonLoggedIndexCreators();

				//	disable logging of space operations on this index
				//
				Assert( !pfcbIdx->FDontLogSpaceOps() );
				pfcbIdx->SetDontLogSpaceOps();
				}

			//	ignore errors if trace fails
			//
			szTraceBuffer[cbTraceBuffer] = 0;
			_snprintf(
				szTraceBuffer,
				cbTraceBuffer,
				"Begin %s CreateIndex: %s [objid:0x%x,pgnoFDP:0x%x]",
				( fIndexLogged ? "" : "NON-LOGGED" ),
				szIndexName,
				pfcbIdx->ObjidFDP(),
				pfcbIdx->PgnoFDP() );
			CallS( pinst->m_plog->ErrLGTrace( ppib, szTraceBuffer ) );

			//	build index using our versioned view of the table
			//
			err = ErrFILEIBuildIndex( ppib, pfucb, pfucbIdx, &fIndexLogged );

			_snprintf(
				szTraceBuffer,
				cbTraceBuffer,
				"End CreateIndex scan phase [objid:0x%x,pgnoFDP:0x%x,error:0x%x]",
				pfcbIdx->ObjidFDP(),
				pfcbIdx->PgnoFDP(),
				err );
			CallS( pinst->m_plog->ErrLGTrace( ppib, szTraceBuffer ) );

			if ( !fIndexLogged && rgfmp[pfucbTable->ifmp].FLogOn() )
				{
				//	if logging of this index build was disabled, but
				//	logging in general is enabled, we need to force-flush
				//	because we're going to begin logging again
				//
				if ( err >= JET_errSuccess )
					{
					err = ErrBFFlush( pfucbTable->ifmp, fTrue, pfcbIdx->ObjidFDP() );
					}

				//	must reset flag and count regardless of error
				//
				pfcbIdx->ResetDontLogSpaceOps();
				pinst->DecrementCNonLoggedIndexCreators();

				//	HACK: must force a dummy logged update anywhere in this
				//	database to ensure that after recovery, the dbtime in the
				//	db header is greater than any of the dbtimes in the non-
				//	logged index
				//
				if ( err >= JET_errSuccess )
					{
					err = ErrSPDummyUpdate( pfucbIdx );
					}
				}

			//	process error
			//
			Call( err );

			Assert( !FFUCBVersioned( pfucbIdx ) );	// no versioned operations should have occurred on this cursor
			DIRBeforeFirst( pfucb );

			//	update the index with operations happening concurrently
			//
			err = ErrFILEIUpdateIndex( ppib, pfucb, pfucbIdx );

			_snprintf(
				szTraceBuffer,
				cbTraceBuffer,
				"End CreateIndex update phase [objid:0x%x,pgnoFDP:0x%x,error:0x%x]",
				pfcbIdx->ObjidFDP(),
				pfcbIdx->PgnoFDP(),
				err );
			CallS( pinst->m_plog->ErrLGTrace( ppib, szTraceBuffer ) );

			Call( err );

			//	the FUnicodeFixupFlag() may be reset during index build,
			//	so propagate any possible changes to the catalog
			//
			if ( idbflagPersisted != pfcbIdx->Pidb()->FPersistedFlags() )
				{
				//	ONLY the fidbUnicodeFixupOn flag should be changing
				//
				AssertRTL( idbflagPersisted == ( pfcbIdx->Pidb()->FPersistedFlags() | fidbUnicodeFixupOn ) );
				Call( ErrCATChangeIndexFlags(
								ppib,
								pfucbTable->ifmp,
								ObjidFDP( pfucbTable ),
								szIndexName,
								pfcbIdx->Pidb()->FPersistedFlags() ) );
				}
			}

		// FCB now linked into table's index list, which guarantees that
		// it will be available at Commit/Rollback time, so we can dispose
		// of the index cursor.
		Assert( !FFUCBVersioned( pfucbIdx ) );	// no versioned operations should have occurred on this cursor
		Assert( pfucbNil != pfucbIdx );
		DIRClose( pfucbIdx );
		pfucbIdx = pfucbNil;
		}

	Call( ErrDIRCommitTransaction( ppib, ( pidxcreate->grbit & JET_bitIndexLazyFlush ) ? JET_bitCommitLazyFlush : 0 ) );
	fInTransaction = fFalse;

HandleError:
#ifdef SHOW_INDEX_PERF
	OSTrace( ostlIndexPerf, OSFormat(	"Ending build of index '%s' (error %d) with log at generation %d.\n",
										szIndexName,
										err,
										PinstFromPpib( ppib )->m_plog->m_plgfilehdr->lgfilehdr.le_lGeneration ) );
#endif

	if ( fInTransaction )
		{
		Assert( err < 0 );		// Must have hit an error.

		Assert( pfucbNil != pfucb );
		DIRCloseIfExists( &pfucb->pfucbLV );

		if ( pfucbNil != pfucbIdx )
			{
			//	no versioned operations should have been performed,
			//	so this FUCB will not be defer-closed
			Assert( !FFUCBVersioned( pfucbIdx ) );
			DIRClose( pfucbIdx );
			}

		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );

		DIRClose( pfucb );
		}
	else if ( pfucbNil != pfucb )
		{
		Assert( pfucbNil == pfucbIdx );
		DIRCloseIfExists( &pfucb->pfucbLV );
		DIRClose( pfucb );
		}
	else
		{
		Assert( pfucbNil == pfucbIdx );
		}

	AssertDIRNoLatch( ppib );

	if ( fUnversioned )
		{
		if ( fResetVersionedOnSuccess && err >= 0 )
			{
			IDB		* pidbT;

			//	for primary index, FUCB is not opened
			//	for secondary index, FUCB is closed on success
			Assert( pfucbNil == pfucbIdx );

			// On success, reset versioned bit (on error, bit reset by rollback)
			pfcb->EnterDDL();
			if ( fPrimary )
				{
				Assert( pfcbNil == pfcbIdx );
				pidbT = pfcb->Pidb();
				}
			else
				{
				Assert( pfcbNil != pfcbIdx );
				pidbT = pfcbIdx->Pidb();
				}
			Assert( pidbNil != pidbT );
			pidbT->ResetFVersioned();
			pidbT->ResetFVersionedCreate();
			pfcb->LeaveDDL();
			}

		FILERemoveFromUnverList( &punveridxGlobal, critUnverIndex, pfcb->ObjidFDP(), szIndexName );
		}

	return err;
	}


LOCAL ERR VTAPI ErrFILEIBatchCreateIndex(
	PIB					*ppib,
	FUCB				*pfucbTable,
	JET_INDEXCREATE		*pidxcreate,
	const ULONG			cIndexes )
	{
	ERR					err;
	FUCB				* pfucb						= pfucbNil;
	FCB					* const pfcb				= pfucbTable->u.pfcb;
	FCB					* pfcbIndexes				= pfcbNil;
	IDB					idb;
	CHAR				szIndexName[ JET_cbNameMost+1 ];
	const CHAR			*rgszColumns[JET_ccolKeyMost];
	BYTE				rgfbDescending[JET_ccolKeyMost];
	BOOL				fInTransaction				= fFalse;
	BOOL				fLazyCommit					= fTrue;
	ULONG				iindex;

#ifdef PARALLEL_BATCH_INDEX_BUILD
	FUCB 				** rgpfucbIdx				= NULL;
#else
	FUCB 			  	* rgpfucbIdx[cFILEIndexBatchSizeDefault];
#endif

	//	check parms
	//
	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucbTable );

	Assert( dbidTemp != rgfmp[ pfucbTable->ifmp ].Dbid() );	// Don't currently support DDL on temp. tables.

	//	ensure that table is updatable
	//
	CallR( ErrFUCBCheckUpdatable( pfucbTable ) );
	CallR( ErrPIBCheckUpdatable( ppib ) );

	if ( 0 != ppib->level )
		{
		//	batch mode requires level 0
		err = ErrERRCheck( JET_errInTransaction );
		return err;
		}

	if ( !pfcb->FDomainDenyReadByUs( ppib ) )
		{
		//	batch mode requires
		err = ErrERRCheck( JET_errExclusiveTableLockRequired );
		return err;
		}

	if ( pfcb->FFixedDDL() )
		{
		// Check FixedDDL override.
		if ( !FFUCBPermitDDL( pfucbTable ) || pfcb->FTemplateTable() )
			{
			err = ErrERRCheck( JET_errFixedDDL );
			return err;
			}

		// If DDL temporarily permitted, we must have exclusive use of the table.
		Assert( pfcb->FDomainDenyReadByUs( ppib ) );
		}

#ifdef PARALLEL_BATCH_INDEX_BUILD
	rgpfucbIdx = (FUCB **)PvOSMemoryHeapAlloc( sizeof(FUCB *) * cIndexes );
	if ( NULL == rgpfucbIdx )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		return err;
		}
	memset( rgpfucbIdx, 0, sizeof(FUCB *) * cIndexes );
#else
	if ( cIndexes > cFILEIndexBatchSizeDefault )
		{
		err = ErrERRCheck( JET_errTooManyIndexes );
		return err;
		}

	for ( iindex = 0; iindex < cIndexes; iindex++ )
		rgpfucbIdx[iindex] = pfucbNil;
#endif

	// Temporarily open new table cursor.
	CallR( ErrDIROpen( ppib, pfcb, &pfucb ) );
	FUCBSetIndex( pfucb );
	FUCBSetMayCacheLVCursor( pfucb );

	Assert( pfucb->u.pfcb != pfcbNil );
	Assert( pfcb == pfucb->u.pfcb );
	Assert( pfcb->WRefCount() > 0 );
	Assert( pfcb->FTypeTable() );	// Temp. tables have fixed DDL.
	Assert( pfcb->Ptdb() != ptdbNil );

	Assert( !FFUCBSecondary( pfucb ) );
	Assert( !FCATSystemTable( pfcb->PgnoFDP() ) );

	Call( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	fInTransaction = fTrue;

	for ( iindex = 0; iindex < cIndexes; iindex++ )
		{
		JET_INDEXCREATE		* const pidxcreateT	= pidxcreate + iindex;
		FCB					* pfcbIndexT;

		if( sizeof( JET_INDEXCREATE ) != pidxcreateT->cbStruct )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}
		if ( pidxcreateT->grbit & ( JET_bitIndexPrimary | JET_bitIndexUnversioned | JET_bitIndexEmpty ) )
			{
			//	currently unsupported in batch mode
			return ErrERRCheck( JET_errInvalidGrbit );
			}

		if ( fLazyCommit && !( pidxcreateT->grbit & JET_bitIndexLazyFlush ) )
			{
			//	if even one of the indexes cannot be lazily flushed,
			//	then none of them can
			fLazyCommit = fFalse;
			}

		const ULONG		ulDensity	= ( 0 == pidxcreateT->ulDensity ) ?
											pfcb->UlDensity() :
											pidxcreateT->ulDensity;

		Call( ErrUTILCheckName( szIndexName, pidxcreateT->szIndexName, JET_cbNameMost+1 ) );

		Call( ErrFILEIValidateCreateIndex(
					PinstFromPpib( ppib ),
					&idb,
					rgszColumns,
					rgfbDescending,
					pidxcreateT,
					ulDensity ) );

		Call( ErrFILEIPrepareOneIndex(
				ppib,
				pfucb,
				&rgpfucbIdx[iindex],
				pidxcreateT,
				szIndexName,
				rgszColumns,
				rgfbDescending,
				&idb,
				ulDensity ) );

		pfcbIndexT = rgpfucbIdx[iindex]->u.pfcb;
		Assert( pfcbIndexT->FTypeSecondaryIndex() );
		pfcbIndexT->SetPfcbNextIndex( pfcbIndexes );
		pfcbIndexT->SetPfcbTable( pfcb );

		pfcbIndexes = pfcbIndexT;
		}

	Call( ErrFILEBuildAllIndexes(
				ppib,
				pfucb,
				pfcbIndexes,
				NULL,
				cIndexes ) );

	pfcb->EnterDDL();

	Assert( pfcbNil == rgpfucbIdx[0]->u.pfcb->PfcbNextIndex() );
	Assert( pfcbIndexes == rgpfucbIdx[cIndexes-1]->u.pfcb );
	rgpfucbIdx[0]->u.pfcb->SetPfcbNextIndex( pfcb->PfcbNextIndex() );
	pfcb->SetPfcbNextIndex( pfcbIndexes );

	FILESetAllIndexMask( pfcb );

	pfcb->LeaveDDL();

	for ( iindex = 0; iindex < cIndexes; iindex++ )
		{
		FUCB * const	pfucbIndexT		= rgpfucbIdx[iindex];
		Assert( pfucbNil != pfucbIndexT );

		FCB * const		pfcbIndexT		= pfucbIndexT->u.pfcb;
		Assert( pfcbNil != pfcbIndexT );
		Assert( pfcbIndexT->FTypeSecondaryIndex() );

		pfcbIndexT->ResetDontLogSpaceOps();

		//	since we have a cursor open on pfcbTable, the FCB
		//		cannot be in the avail list; thus, we can directly
		//		set the above-threshold flag
		if ( pfcbIndexT >= PfcbFCBPreferredThreshold( PinstFromPpib( ppib ) ) )
			{
			pfcb->Lock();
			pfcb->SetAboveThreshold();
			pfcb->Unlock();
			}

		Assert( !FFUCBVersioned( pfucbIndexT ) );	// No versioned operations should have been performed, so won't be defer-closed.
		DIRClose( pfucbIndexT );
		}

	Call( ErrDIRCommitTransaction( ppib, fLazyCommit ? JET_bitCommitLazyFlush : 0 ) );
	fInTransaction = fFalse;

HandleError:
	Assert( pfucbNil != pfucb );
	DIRCloseIfExists( &pfucb->pfucbLV );

	if ( fInTransaction )
		{
		Assert( err < 0 );		// Must have hit an error.

		if ( NULL != rgpfucbIdx )
			{
			for ( iindex = 0; iindex < cIndexes; iindex++ )
				{
				if ( pfucbNil != rgpfucbIdx[iindex] )
					{
					Assert( !FFUCBVersioned( rgpfucbIdx[iindex] ) );	// No versioned operations should have been performed, so won't be defer-closed.
					DIRClose( rgpfucbIdx[iindex] );
					}
				}
			}

		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}

	DIRClose( pfucb );
	AssertDIRNoLatch( ppib );

#ifdef PARALLEL_BATCH_INDEX_BUILD
	if ( NULL != rgpfucbIdx )
		{
		OSMemoryHeapFree( rgpfucbIdx );
		}
#endif

	return err;
	}

//+API
// ErrIsamCreateIndex
// ========================================================================
// ERR ErrIsamCreateIndex(
//		SESID	sesid;			// IN	PIB of user
//		TABLEID tableid;   		// IN	Exclusively opened FUCB of file
//		JET_INDEXCREATE * pindexcreate;	// IN	Array of indexes to create
//		unsigned long cIndexCreate );	// IN	Number of indexes to create
//
//	Creates indexes on a table
//
//
// RETURNS	Error code from ErrFILEICreateIndex or
//			JET_errSuccess			Everything worked OK.
//			-JET_errColumnNotFound 	The index key specified
//									contains an undefined field.
//			-IndexHasPrimary 		The primary index for this
//							 		Insertfile is already defined.
// 			-IndexDuplicate  		An index on this file is
//	   								already defined with the
//									given name.
// 			-IndexInvalidDef 		There are too many segments
//							 		in the key.
// 			-TableNotEmpty	 		A primary index may not be
// 									defined because there is at
// 									least one record already in
// 									the file.
// COMMENTS
//		If transaction level > 0, there must not be anyone currently
//		using the file.
//		A transaction is wrapped around this function.	Thus, any
//		work done will be undone if a failure occurs.
//
// SEE ALSO		ErrIsamAddColumn, ErrIsamCreateTable, ErrFILEICreateTable
//-
ERR VTAPI ErrIsamCreateIndex(
	JET_SESID			sesid,
	JET_VTID			vtid,
	JET_INDEXCREATE		*pindexcreate,
	unsigned long		cIndexCreate )
	{
	ERR					err;
 	PIB					* const ppib 		= reinterpret_cast<PIB *>( sesid );
	FUCB				* const pfucbTable 	= reinterpret_cast<FUCB *>( vtid );

#ifdef SHOW_INDEX_PERF
	const TICK			tickStart			= TickOSTimeCurrent();
	OSTrace( ostlIndexPerf, OSFormat( "About to rebuild %d indexes.\n", cIndexCreate ) );
	OSTraceIndent( ostlIndexPerf, +1 );
#endif

	if ( 1 == cIndexCreate )
		{
		err = ErrFILEICreateIndex( ppib, pfucbTable, pindexcreate );
		}
	else
		{
		err = ErrFILEIBatchCreateIndex( ppib, pfucbTable, pindexcreate, cIndexCreate );
		}

#ifdef SHOW_INDEX_PERF
	OSTraceIndent( ostlIndexPerf, -1 );
	OSTrace( ostlIndexPerf, OSFormat(	"Finished rebuild of %d indexes in %d msecs with error %d.\n",
										cIndexCreate,
										TickOSTimeCurrent() - tickStart,
										err ) );
#endif

	return err;
	}


//+API
// ErrIsamDeleteTable
// ========================================================================
// ERR ErrIsamDeleteTable( JET_SESID vsesid, JET_DBID vdbid, CHAR *szName )
//
// Calls ErrFILEIDeleteTable to
// delete a file and all indexes associated with it.
//
// RETURNS		JET_errSuccess or err from called routine.
//
// SEE ALSO		ErrIsamCreateTable
//-
ERR VTAPI ErrIsamDeleteTable( JET_SESID vsesid, JET_DBID vdbid, const CHAR *szName )
	{
	ERR		err;
	PIB		*ppib = (PIB *)vsesid;
	IFMP	ifmp = (IFMP)vdbid;

	//	check parameters
	//
	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrPIBCheckIfmp( ppib, ifmp ) );
	CallR( ErrPIBCheckUpdatable( ppib ) );

	if ( dbidTemp == rgfmp[ ifmp ].Dbid() )
		{
		// Cannot use DeleteTable on temporary tables.
		// Must use CloseTable insetad.
		err = ErrERRCheck( JET_errCannotDeleteTempTable );
		}
	else
		{
		err = ErrFILEDeleteTable( ppib, ifmp, szName );
		}

	return err;
	}


// ErrFILEDeleteTable
// ========================================================================
// ERR ErrFILEDeleteTable( PIB *ppib, IFMP ifmp, CHAR *szName )
//
// Deletes a file and all indexes associated with it.
//
// RETURNS		JET_errSuccess or err from called routine.
//

// COMMENTS
//	Acquires an exclusive lock on the file [FCBSetDelete].
//	A transaction is wrapped around this function.	Thus,
//	any work done will be undone if a failure occurs.
//	Transaction logging is turned off for temporary files.
//
// SEE ALSO		ErrIsamCreateTable
//-
ERR ErrFILEDeleteTable( PIB *ppib, IFMP ifmp, const CHAR *szName )
	{
	ERR   	err;
	FUCB  	*pfucb				= pfucbNil;
	FUCB	*pfucbParent		= pfucbNil;
	FCB	  	*pfcb				= pfcbNil;
	PGNO	pgnoFDP;
	OBJID	objidTable;
	CHAR	szTable[JET_cbNameMost+1];
	BOOL	fInUseBySystem;
	BOOL	fSentinel			= fFalse;
	VER		*pver;

	CheckPIB( ppib );
	CheckDBID( ppib, ifmp );

	//	must normalise for CAT hash deletion
	//	PERF UNDONE: the name will be normalised again in FILEOpenTable()
	CallR( ErrUTILCheckName( szTable, szName, JET_cbNameMost+1 ) );

	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );

	//	open cursor on database and seek to table without locking
	//
	Call( ErrDIROpen( ppib, pgnoSystemRoot, ifmp, &pfucbParent ) );

	Assert( dbidTemp != rgfmp[ ifmp ].Dbid() );	// Don't call DeleteTable on temp. tables -- use CloseTable instead.

	Call( ErrFILEOpenTable(
				ppib,
				ifmp,
				&pfucb,
				szName,
				JET_bitTableDelete|JET_bitTableDenyRead ) );
	fInUseBySystem = ( JET_wrnTableInUseBySystem == err );

	// We should now have exclusive use of the table.
    pfcb = pfucb->u.pfcb;
	pgnoFDP = pfcb->PgnoFDP();
	objidTable = pfcb->ObjidFDP();

	Assert( pfcb->FTypeTable() || pfcb->FTypeSentinel() );
	if ( pfcb->FTemplateTable() )
		{
		// UNDONE: Deletion of template table not currently supported.
		// However, if the template table is opened as a sentinel,
		// then the TemplateTable flag will not be set, in which
		// case the table will be allowed to be deleted.  Any existing
		// inherited tables will fail if an attempt is made to open
		// them.
		err = ErrERRCheck( JET_errCannotDeleteTemplateTable );
		goto HandleError;
		}

	if( pfcb->Ptdb()->FTableHasSLVColumn() )
		{
		//	Deleting of tables with SLV columns and records is not supported
		//	as we will orphan the space.

		DIB dib;
		dib.dirflag = fDIRNull;
		dib.pos		= posFirst;
		DIRGotoRoot( pfucb );
		if ( ( err = ErrDIRDown( pfucb, &dib ) ) != JET_errRecordNotFound )
			{
			if ( JET_errSuccess == err )
				{
				Call( ErrERRCheck( JET_errSLVColumnCannotDelete ) );
				}
			Call( err );
			}
		}

	//	the following assert(s) goes off when we reuse a cursor that
	//	was defer closed by us -- it has been disabled for now
	//
//	Assert( !FFUCBVersioned( pfucb ) );
	Assert( pfcb->FDomainDenyReadByUs( ppib ) );

	// If sentinel was allocated, it will be freed by commit/rollback, unless
	// versioning failed, it which case we'll free it.
	fSentinel = pfcb->FTypeSentinel();
	Assert( !fSentinel || !FFUCBVersioned( pfucb ) );

	pver = PverFromIfmp( pfucb->ifmp );
	err = pver->ErrVERFlag( pfucbParent, operDeleteTable, &pgnoFDP, sizeof(pgnoFDP) );
	if ( err < 0 )
		{
		// Must close FUCB first in case sentinel exists.  Set to pfucbNil
		// afterwards so HandleError doesn't try to close FUCB again.
//		Assert( !FFUCBVersioned( pfucb ) );		// Verifies FUCB is not deferred closed.
		Assert( !fSentinel || !FFUCBVersioned( pfucb ) );
		DIRClose( pfucb );
		pfucb = pfucbNil;

		if ( fSentinel )
			{
			// No one else has access to this FCB, so pfcb should still be valid.
			pfcb->PrepareForPurge();
			pfcb->Purge();
			}
		goto HandleError;
		}

	Assert( pfcb->PgnoFDP() == pgnoFDP );
	Assert( pfcb->Ifmp() == ifmp );

	// UNDONE: Is it necessary to grab critical section, since we have
	// exclusive use of the table?
	if ( pfcb->Ptdb() != ptdbNil )
		{
		Assert( !fSentinel );

		pfcb->EnterDDL();

		for ( FCB *pfcbT = pfcb; pfcbT != pfcbNil; pfcbT = pfcbT->PfcbNextIndex() )
			{
			Assert( pfcbT->Ifmp() == ifmp );
			Assert( pfcbT == pfcb
				|| ( pfcbT->FTypeSecondaryIndex()
					&& pfcbT->PfcbTable() == pfcb ) );
			pfcbT->SetDeletePending();
			}

		if ( pfcb->Ptdb()->PfcbLV() != pfcbNil )
			pfcb->Ptdb()->PfcbLV()->SetDeletePending();

		pfcb->LeaveDDL();
		}
	else
		{
		Assert( fSentinel );
		Assert( !fInUseBySystem );
		Assert( pfcbNil == pfcb->PfcbNextIndex() );
		pfcb->SetDeletePending();
		}


	if ( fInUseBySystem )
		{
		pfcb->Lock();

		do
			{
			fInUseBySystem = fFalse;

			for ( FUCB * pfucbT = pfcb->Pfucb(); pfucbT != pfucbNil; pfucbT = pfucbT->pfucbNextOfFile )
				{
				Assert( pfucbT->ppib == ppib || FPIBSessionSystemCleanup( pfucbT->ppib ) );

				//	don't care about RCE clean, because any outstanding versions will be cleaned
				//	before the DeleteTable version is cleaned.
				if ( pfucbT->ppib->FSessionOLD() )
					{
					//	the DeletePending flag for this table has now been set, forcing
					//	OLD to exit at its earliest convenience.  Wait for it.
					Assert( !fSentinel );
					fInUseBySystem = fTrue;
					pfcb->Unlock();
					UtilSleep( 500 );
					pfcb->Lock();
					break;
					}
#ifdef DEBUG
				else if ( !FPIBSessionSystemCleanup( pfucbT->ppib ) )
					{
					Assert( pfucbT->ppib == ppib );
					Assert( pfucbT == pfucb || FFUCBDeferClosed( pfucbT ) );
					}
#endif
				}
			}
		while ( fInUseBySystem );

		pfcb->Unlock();
		}

#ifdef DEBUG
	if ( pfcb->Ptdb() != ptdbNil )
		{
		Assert( !fSentinel );
		}
	else
		{
		Assert( fSentinel );
		Assert( !FFUCBVersioned( pfucb ) );
		}
#endif

	DIRClose( pfucb );
	pfucb = pfucbNil;

	DIRClose( pfucbParent );
	pfucbParent = pfucbNil;

	//	remove table record from MSysObjects before committing.
	Call( ErrCATDeleteTable( ppib, ifmp, objidTable ) );
	CATHashDelete( pfcb, const_cast< CHAR * >( szTable ) );

	if( 0 != UtilCmpName( szMSU, szTable ) )
		{
		Call( ErrCATDeleteMSUEntriesForTable(
				ppib,
				ifmp,
				pfucbNil,
				objidTable ) );
		}

	Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );

	AssertDIRNoLatch( ppib );
	return err;

HandleError:
	if ( pfucb != pfucbNil )
		{
		Assert( !fSentinel || !FFUCBVersioned( pfucb ) );
		DIRClose( pfucb );
		}
	if ( pfucbParent != pfucbNil )
		DIRClose( pfucbParent );

	CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );

	AssertDIRNoLatch( ppib );

	return err;
	}


//+API
// DeleteIndex
// ========================================================================
// ERR DeleteIndex( PIB *ppib, FUCB *pfucb, CHAR *szIndex )
//
// Deletes an index definition and all index entries it contains.
//
// PARAMETERS	ppib						PIB of user
// 				pfucb						Exclusively opened FUCB on file
// 				szName						name of index to delete
// RETURNS		Error code from DIRMAN or
//					JET_errSuccess		  	 Everything worked OK.
//					-TableInvalid			 There is no file corresponding
// 											 to the file name given.
//					-TableNoSuchIndex		 There is no index corresponding
// 											 to the index name given.
//					-IndexMustStay			 The primary index of a file may
// 											 not be deleted.
// COMMENTS
//		There must not be anyone currently using the file.
//		A transaction is wrapped around this function.	Thus,
//		any work done will be undone if a failure occurs.
//		Transaction logging is turned off for temporary files.
// SEE ALSO		DeleteTable, CreateTable, CreateIndex
//-
ERR VTAPI ErrIsamDeleteIndex(
	JET_SESID		sesid,
	JET_VTID		vtid,
	const CHAR		*szName
	)
	{
 	PIB *ppib			= reinterpret_cast<PIB *>( sesid );
	FUCB *pfucbTable	= reinterpret_cast<FUCB *>( vtid );

	ERR		err;
	CHAR	szIndex[ (JET_cbNameMost + 1) ];
	FCB		*pfcbTable;
	FCB		*pfcbIdx;
	FUCB	*pfucb;
	PGNO	pgnoIndexFDP;
	BOOL	fInTransaction = fFalse;
	VER		*pver;

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucbTable );
	CallR( ErrUTILCheckName( szIndex, szName, ( JET_cbNameMost + 1 ) ) );

	//	ensure that table is updatable
	//
	CallR( ErrFUCBCheckUpdatable( pfucbTable )  );
	CallR( ErrPIBCheckUpdatable( ppib ) );

	Assert( ppib != ppibNil );
	Assert( pfucbTable != pfucbNil );
	Assert( pfucbTable->u.pfcb != pfcbNil );
	pfcbTable = pfucbTable->u.pfcb;

	Assert( pfcbTable->FTypeTable() );		// Temp. tables have fixed DDL.

	if ( pfcbTable->FFixedDDL() )
		{

//	UNDONE: Cannot currently permit DDL deletes even if PermitDDL flag is
//	specified because DDL deletes will leave RCE's that have to be cleaned
//	up and modify the FCB while doing so.  This will mess up cursors
//	opened normally after the PermitDDL cursor closes.
#ifdef PERMIT_DDL_DELETE
		// Check FixedDDL override.
		if ( !FFUCBPermitDDL( pfucbTable ) )
			{
			err = ErrERRCheck( JET_errFixedDDL );
			return err;
			}

		// If DDL temporarily permitted, we must have exclusive use of the table.
		Assert( pfcbTable->FDomainDenyReadByUs( ppib ) );
#else
		err = ErrERRCheck( JET_errFixedDDL );
		return err;
#endif
		}

	Assert( pfcbTable->Ptdb() != ptdbNil );
	if ( pfcbTable->Ptdb()->PfcbTemplateTable() != pfcbNil
		&& FFILEITemplateTableIndex( pfcbTable->Ptdb()->PfcbTemplateTable(), szIndex ) )
		{
		err = ErrERRCheck( JET_errFixedInheritedDDL );
		return err;
		}

	//	create new cursor -- to leave user's cursor unmoved
	//
	CallR( ErrDIROpen( ppib, pfcbTable, &pfucb ) );

	Call( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	fInTransaction = fTrue;

	//	remove index record from MSysIndexes, preventing other threads from
	//	trying to delete the same index.
	//
	Assert( rgfmp[ pfcbTable->Ifmp() ].Dbid() != dbidTemp );	// Don't currently support DDL operations on temp tables.
	Call( ErrCATDeleteTableIndex(
				ppib,
				pfcbTable->Ifmp(),
				pfcbTable->ObjidFDP(),
				szIndex,
				&pgnoIndexFDP ) );

	// Can't delete primary index.
	Assert( pfcbTable->PgnoFDP() != pgnoIndexFDP );

	// Find index's FCB in the table's index list.
	pfcbTable->EnterDDL();
	for ( pfcbIdx = pfcbTable->PfcbNextIndex(); pfcbIdx != pfcbNil; pfcbIdx = pfcbIdx->PfcbNextIndex() )
		{
		Assert( pfcbIdx->Pidb() != pidbNil );
		if ( pfcbIdx->PgnoFDP() == pgnoIndexFDP )
			{
#ifdef DEBUG
			// Verify no one else is deleting this index (if so, conflict would
			// have been detected when updating catalog above).
			Assert( !pfcbIdx->FDeletePending() );
			Assert( !pfcbIdx->FDeleteCommitted() );
			Assert( !pfcbIdx->Pidb()->FDeleted() );

			// verify that no other FCB has the same FDP -- would never happen
			// because the FCB is deallocated before the space is freed.
			FCB	*pfcbT;
			for ( pfcbT = pfcbIdx->PfcbNextIndex(); pfcbT != pfcbNil; pfcbT = pfcbT->PfcbNextIndex() )
				{
				Assert( pfcbT->PgnoFDP() != pgnoIndexFDP );
				}
#endif
			break;
			}
		}
	pfcbTable->AssertDDL();

	if ( pfcbIdx == pfcbNil )
		{
		Assert( fFalse );		// If index in catalog, FCB must exist.
		pfcbTable->LeaveDDL();
		err = ErrERRCheck( JET_errIndexNotFound );
		goto HandleError;
		}

	Assert( !pfcbIdx->FTemplateIndex() );
	Assert( !pfcbIdx->FDerivedIndex() );
	Assert( pfcbIdx->PfcbTable() == pfcbTable );

	err = pfcbIdx->ErrSetDeleteIndex( ppib );
	pfcbTable->LeaveDDL();
	Call( err );

	if( pfcbIdx->Pidb()->FUnicodeFixupOn() )
		{
		Call( ErrCATDeleteMSUEntriesForTableIndex(
					ppib,
					pfcbTable->Ifmp(),
					pfucbNil,
					pfcbTable->ObjidFDP(),
					pfcbIdx->ObjidFDP() ) );
		}
	else
		{
		//	UNDONE: assert there are no fixup entries for this index
		}

	// Assert not deleting current secondary index.
	if ( pfucb->pfucbCurIndex != pfucbNil )
		{
		Assert( pfucb->pfucbCurIndex->u.pfcb != pfcbNil );
		Assert( pfucb->pfucbCurIndex->u.pfcb->PfcbTable() == pfcbTable );
		Assert( pfucb->pfucbCurIndex->u.pfcb->Pidb() != pidbNil );
		Assert( pfucb->pfucbCurIndex->u.pfcb->Pidb()->CrefCurrentIndex() > 0
			|| pfucb->pfucbCurIndex->u.pfcb->Pidb()->FTemplateIndex() );
		Assert( pgnoIndexFDP != pfucb->pfucbCurIndex->u.pfcb->PgnoFDP() );
		}

	pver = PverFromIfmp( pfucb->ifmp );
	err = pver->ErrVERFlag( pfucb, operDeleteIndex, &pfcbIdx, sizeof(pfcbIdx) );
	if ( err < 0 )
		{
		pfcbIdx->ResetDeleteIndex();
		goto HandleError;
		}

	// Ensure consistent view of table's space tree (to prevent doubly-freed space).
	Assert( pfcbIdx->PfcbTable() == pfcbTable );
	Assert( pfcbIdx->FDeletePending() );
	Assert( !pfcbIdx->FDeleteCommitted() );
//	Call( ErrDIRDeleteDirectory( pfucb, pfcbIdx->PgnoFDP() ) );

	Call( ErrDIRCommitTransaction( ppib, 0 ) );
	fInTransaction = fFalse;

	//	set currency to before first
	//
	DIRBeforeFirst( pfucb );
	CallS( err );

HandleError:
	if ( fInTransaction )
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );

	DIRClose( pfucb );
	AssertDIRNoLatch( ppib );
	return err;
	}


// Ensures the column doesn't belong to any non-deleted indexes, or indexes
// version-deleted by someone else (because the delete may roll back).
BOOL FFILEIsIndexColumn( PIB *ppib, FCB *pfcbTable, const COLUMNID columnid )
	{
	FCB*			pfcbIndex;
	ULONG			iidxseg;
	const IDXSEG*	rgidxseg;

	Assert( pfcbNil != pfcbTable );
	for ( pfcbIndex = pfcbTable; pfcbIndex != pfcbNil; pfcbIndex = pfcbIndex->PfcbNextIndex() )
		{
		const IDB * const pidb = pfcbIndex->Pidb();
		if ( pidbNil == pidb )
			{
			Assert( pfcbIndex == pfcbTable );	// Only sequential index has no IDB
			continue;
			}

		if ( pidb->FDeleted() )
			{
			if ( pidb->FVersioned() )
				{
				// The cursor that deletes the index will set DomainDenyRead
				// on the FCB.  If it's us, we can bypass the index check (because
				// this operation will only commit if the DeleteIndex commits),
				// otherwise we can't (because the DeleteIndex may roll back).
				Assert( pfcbIndex->FDomainDenyRead( ppib )
					|| pfcbIndex->FDomainDenyReadByUs( ppib ) );
				if ( pfcbIndex->FDomainDenyReadByUs( ppib ) )
					{
					continue;
					}
				}
			else
				{
				// Index is unversioned deleted, meaning the delete has committed
				// or we have exclusive use of the table and we deleted the index.
				// In either case, we can bypass the index check.
				continue;
				}
			}

		rgidxseg = PidxsegIDBGetIdxSeg( pidb, pfcbTable->Ptdb() );
		for ( iidxseg = 0; iidxseg < pidb->Cidxseg(); iidxseg++ )
			{
			if ( rgidxseg[iidxseg].FIsEqual( columnid ) )
				{
				//	found the column in an index
				//
				return fTrue;
				}
			}

		rgidxseg = PidxsegIDBGetIdxSegConditional( pidb, pfcbTable->Ptdb() );
		for ( iidxseg = 0; iidxseg < pidb->CidxsegConditional(); iidxseg++ )
			{
			if ( rgidxseg[iidxseg].FIsEqual( columnid ) )
				{
				//	column is used for a condition
				//
				return fTrue;
				}
			}
		}
	return fFalse;
	}



ERR VTAPI ErrIsamDeleteColumn(
	JET_SESID		sesid,
	JET_VTID		vtid,
	const CHAR		*szName,
	const JET_GRBIT	grbit )
	{
 	PIB 			*ppib = reinterpret_cast<PIB *>( sesid );
	FUCB			*pfucb = reinterpret_cast<FUCB *>( vtid );
	ERR				err;
	CHAR			szColumn[ (JET_cbNameMost + 1) ];
	FCB				*pfcb;
	TDB				*ptdb;
	COLUMNID		columnidColToDelete;
	FIELD			*pfield;
	BOOL			fIndexColumn;
#ifdef DELETE_SLV_COLS
#else // DELETE_SLV_COLS
	BOOL			fSLVColumn;
#endif // DELETE_SLV_COLS
	VER				*pver;

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );
	CallR( ErrUTILCheckName( szColumn, szName, (JET_cbNameMost + 1) ) );

	//	ensure that table is updatable
	//
	CallR( ErrFUCBCheckUpdatable( pfucb ) );
	CallR( ErrPIBCheckUpdatable( ppib ) );

	Assert( ppib != ppibNil );
	Assert( pfucb != pfucbNil );
	Assert( pfucb->u.pfcb != pfcbNil );
	pfcb = pfucb->u.pfcb;
	Assert( pfcb->WRefCount() > 0 );
	Assert( pfcb->FTypeTable() );		// Temp. tables have fixed DDL.
	Assert( pfcb->FPrimaryIndex() );

	if ( pfcb->FFixedDDL() )
		{
//	UNDONE: Cannot currently permit DDL deletes even if PermitDDL flag is
//	specified because DDL deletes will leave RCE's that have to be cleaned
//	up and modify the FCB while doing so.  This will mess up cursors
//	opened normally after the PermitDDL cursor closes.
#ifdef PERMIT_DDL_DELETE
		// Check FixedDDL override.
		if ( !FFUCBPermitDDL( pfucb ) )
			{
			err = ErrERRCheck( JET_errFixedDDL );
			return err;
			}

		// If DDL temporarily permitted, we must have exclusive use of the table.
		Assert( pfcb->FDomainDenyReadByUs( ppib ) );
#else
		err = ErrERRCheck( JET_errFixedDDL );
		return err;
#endif
		}

	if ( pfcb->Ptdb()->PfcbTemplateTable() != pfcbNil
		&& !( grbit & JET_bitDeleteColumnIgnoreTemplateColumns )
		&& FFILEITemplateTableColumn( pfcb->Ptdb()->PfcbTemplateTable(), szColumn ) )
		{
		return ErrERRCheck( JET_errFixedInheritedDDL );
		}


	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );

	// Flag-delete in the catalog.
	// Also has the effect of properly reconciling concurrent
	// CreateIndexes over this column.
	Call( ErrCATDeleteTableColumn(
				ppib,
				pfcb->Ifmp(),
				pfcb->ObjidFDP(),
				szColumn,
				&columnidColToDelete ) );

#ifdef PERMIT_DDL_DELETE
	if ( pfcb->FTemplateTable() )
		{
		Assert( !COLUMNIDTemplateColumn( columnidColToDelete ) );	//	Template flag is not persisted
		COLUMNIDSetFTemplateColumn( columnidColToDelete );
		}
#endif

	// Search for column in use.  For indexes being concurrently created,
	// conflict would have been detected by catalog update above.
	pfcb->EnterDML();
	fIndexColumn = FFILEIsIndexColumn( ppib, pfcb, columnidColToDelete );
#ifdef DELETE_SLV_COLS
#else // DELETE_SLV_COLS
	fSLVColumn = ( JET_coltypSLV == pfcb->Ptdb()->Pfield( columnidColToDelete )->coltyp );
#endif // DELETE_SLV_COLS
	pfcb->LeaveDML();

	if ( fIndexColumn )
		{
		err = ErrERRCheck( JET_errColumnInUse );
		goto HandleError;
		}
#ifdef DELETE_SLV_COLS
#else // DELETE_SLV_COLS
	else if ( fSLVColumn )
		{
		err = ErrERRCheck( JET_errSLVColumnCannotDelete );
		goto HandleError;
		}
#endif // DELETE_SLV_COLS

	pver = PverFromIfmp( pfucb->ifmp );
	Call( pver->ErrVERFlag( pfucb, operDeleteColumn, (VOID *)&columnidColToDelete, sizeof(COLUMNID) ) );

	pfcb->EnterDDL();

	ptdb = pfcb->Ptdb();
	pfield = ptdb->Pfield( columnidColToDelete );

	// If we have the table exclusively locked, then there's no need to
	// set the Versioned bit.
	Assert( !pfcb->FDomainDenyRead( ppib ) );
	if ( !pfcb->FDomainDenyReadByUs( ppib ) )
		{
		FIELDSetVersioned( pfield->ffield );
		}
	FIELDSetDeleted( pfield->ffield );

	pfcb->LeaveDDL();

	//	move to FDP root, then set currencies to BeforeFirst and remove unused CSR
	DIRGotoRoot( pfucb );
	Assert( Pcsr( pfucb ) != pcsrNil );
	DIRBeforeFirst( pfucb );
	if ( pfucb->pfucbCurIndex != pfucbNil )
		{
		DIRBeforeFirst( pfucb->pfucbCurIndex );
		}

	Call( ErrDIRCommitTransaction( ppib, 0 ) );

	return JET_errSuccess;

HandleError:
	CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );

	return err;
	}


//  ================================================================
ERR VTAPI ErrIsamRenameTable( JET_SESID sesid, JET_DBID dbid, const CHAR *szName, const CHAR *szNameNew )
//  ================================================================
//
//  WARNINGS:
//    This doesn't version the name properly. Its instantly visible in the TDB, but versioned in the catalog
//    You can't rename a template table (derived tables are not updated).
//
//
	{
	ERR 	err;
 	PIB 	* const ppib = reinterpret_cast<PIB *>( sesid );
 	IFMP	ifmp = (IFMP) dbid;

	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrPIBCheckUpdatable( ppib ) );
	CallR( ErrDBCheckUserDbid( ifmp ) );
	CallR( ErrPIBCheckIfmp( ppib, ifmp ) );

	if( NULL == szName )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	if( NULL == szNameNew )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	CHAR	szTableOld[JET_cbNameMost+1];
	CHAR	szTableNew[JET_cbNameMost+1];

	CallR( ErrUTILCheckName( szTableOld, szName, JET_cbNameMost+1 ) );
	CallR( ErrUTILCheckName( szTableNew, szNameNew, JET_cbNameMost+1 ) );

	CallR( ErrCATRenameTable( ppib, ifmp, szTableOld, szTableNew ) );

	return err;
	}


ERR VTAPI ErrIsamRenameObject( JET_SESID vsesid, JET_DBID	vdbid, const CHAR *szName, const CHAR  *szNameNew )
	{
	Assert( fFalse );
	return JET_errSuccess;
	}


//  ================================================================
ERR VTAPI ErrIsamRenameColumn(
	JET_SESID		vsesid,
	JET_VTID		vtid,
	const CHAR		*szName,
	const CHAR		*szNameNew,
	const JET_GRBIT	grbit )
//  ================================================================
//
//  WARNINGS:
//    This doesn't version the name properly. Its instantly visible in the FIELD, but versioned in the catalog
//    You can't rename an inherited column.
//
//
	{
	ERR 	err;
 	PIB 	* const ppib	= reinterpret_cast<PIB *>( vsesid );
	FUCB	* const pfucb	= reinterpret_cast<FUCB *>( vtid );

	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrPIBCheckUpdatable( ppib ) );
	CheckTable( ppib, pfucb );

	if( NULL == szName )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	if( NULL == szNameNew )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	if( 0 != ppib->level )
		{
		return ErrERRCheck( JET_errInTransaction );
		}

	CHAR	szColumnOld[JET_cbNameMost+1];
	CHAR	szColumnNew[JET_cbNameMost+1];

	CallR( ErrUTILCheckName( szColumnOld, szName, JET_cbNameMost+1 ) );
	CallR( ErrUTILCheckName( szColumnNew, szNameNew, JET_cbNameMost+1 ) );

	CallR( ErrCATRenameColumn( ppib, pfucb, szColumnOld, szColumnNew, grbit ) );

	return err;
	}


ERR VTAPI ErrIsamRenameIndex( JET_SESID vsesid, JET_VTID vtid, const CHAR *szName, const CHAR *szNameNew )
	{
	Assert( fFalse );
	return JET_errSuccess;
	}


VOID IDB::SetFlagsFromGrbit( const JET_GRBIT grbit )
	{
	const BOOL	fPrimary			= ( grbit & JET_bitIndexPrimary );
	const BOOL	fUnique				= ( grbit & JET_bitIndexUnique );
	const BOOL	fDisallowNull		= ( grbit & JET_bitIndexDisallowNull );
	const BOOL	fIgnoreNull			= ( grbit & JET_bitIndexIgnoreNull );
	const BOOL	fIgnoreAnyNull		= ( grbit & JET_bitIndexIgnoreAnyNull );
	const BOOL	fIgnoreFirstNull	= ( grbit & JET_bitIndexIgnoreFirstNull );
	const BOOL	fSortNullsHigh		= ( grbit & JET_bitIndexSortNullsHigh );
	const BOOL	fTuples				= ( grbit & JET_bitIndexTuples );

	ResetFlags();

	if ( !fDisallowNull && !fIgnoreAnyNull )
		{
		SetFAllowSomeNulls();
		if ( !fIgnoreFirstNull )
			{
			SetFAllowFirstNull();
			if ( !fIgnoreNull )
				SetFAllowAllNulls();
			}
		}

	if ( fPrimary )
		{
		SetFUnique();
		SetFPrimary();
		}
	else if ( fUnique )
		{
		SetFUnique();
		}

	if ( fTuples )
		{
		SetFTuples();
		}

	if ( fDisallowNull )
		{
		SetFNoNullSeg();
		}
	else if ( fSortNullsHigh )
		{
		SetFSortNullsHigh();
		}
	}

JET_GRBIT IDB::GrbitFromFlags() const
	{
	JET_GRBIT	grbit = 0;

	if ( FPrimary() )
		grbit |= JET_bitIndexPrimary;
	if ( FUnique() )
		grbit |= JET_bitIndexUnique;
	if( FTuples() )
		grbit |= JET_bitIndexTuples;
	if ( FNoNullSeg() )
		grbit |= JET_bitIndexDisallowNull;
	else
		{
		if ( !FAllowAllNulls() )
			grbit |= JET_bitIndexIgnoreNull;
		if ( !FAllowFirstNull() )
			grbit |= JET_bitIndexIgnoreFirstNull;
		if ( !FAllowSomeNulls() )
			grbit |= JET_bitIndexIgnoreAnyNull;
		if ( FSortNullsHigh() )
			grbit |= JET_bitIndexSortNullsHigh;
		}

	if ( FTuples() )
		{
		grbit |= JET_bitIndexTuples;
		}

	return grbit;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\dir.cxx ===
#include "std.hxx"

//	prototypes of DIR internal routines
//
LOCAL ERR ErrDIRICheckIndexRange( FUCB *pfucb, const KEY& key );
LOCAL ERR ErrDIRIIRefresh( FUCB * const pfucb );
INLINE ERR ErrDIRIRefresh( FUCB * const pfucb )
	{
 	return ( locDeferMoveFirst != pfucb->locLogical ?
				JET_errSuccess :
				ErrDIRIIRefresh( pfucb ) );
	}

extern CCriticalSection	critCommit0;


//  perf stats

PM_CEF_PROC LDIRUserROTrxCommit0CEFLPv;
PERFInstanceG<> cDIRUserROTrxCommit0;
long LDIRUserROTrxCommit0CEFLPv(long iInstance,void *pvBuf)
{
	cDIRUserROTrxCommit0.PassTo( iInstance, pvBuf );
	return 0;
}


PM_CEF_PROC LDIRUserRWTrxCommit0CEFLPv;
PERFInstanceG<> cDIRUserRWTrxCommit0;
long LDIRUserRWTrxCommit0CEFLPv(long iInstance,void *pvBuf)
{
	cDIRUserRWTrxCommit0.PassTo( iInstance, pvBuf );
	return 0;
}


PM_CEF_PROC LDIRUserTrxCommit0CEFLPv;
long LDIRUserTrxCommit0CEFLPv(long iInstance,void *pvBuf)
{
	if ( NULL != pvBuf )
		{
		*((LONG *)pvBuf) = cDIRUserROTrxCommit0.Get( iInstance )+ cDIRUserRWTrxCommit0.Get( iInstance );
		}
	return 0;
}


PM_CEF_PROC LDIRUserROTrxRollback0CEFLPv;
PERFInstanceG<> cDIRUserROTrxRollback0;
long LDIRUserROTrxRollback0CEFLPv(long iInstance,void *pvBuf)
{
	cDIRUserROTrxRollback0.PassTo( iInstance, pvBuf );
	return 0;
}


PM_CEF_PROC LDIRUserRWTrxRollback0CEFLPv;
PERFInstanceG<> cDIRUserRWTrxRollback0;
long LDIRUserRWTrxRollback0CEFLPv(long iInstance,void *pvBuf)
{
	cDIRUserRWTrxRollback0.PassTo( iInstance, pvBuf );
	return 0;
}


PM_CEF_PROC LDIRUserTrxRollback0CEFLPv;
long LDIRUserTrxRollback0CEFLPv(long iInstance,void *pvBuf)
{
	if ( NULL != pvBuf )
		{
		*((LONG *)pvBuf) = cDIRUserROTrxRollback0.Get( iInstance ) + cDIRUserRWTrxRollback0.Get( iInstance );
		}
	return 0;
}


PM_CEF_PROC LDIRSystemROTrxCommit0CEFLPv;
PERFInstanceG<> cDIRSystemROTrxCommit0;
long LDIRSystemROTrxCommit0CEFLPv(long iInstance,void *pvBuf)
{
	cDIRSystemROTrxCommit0.PassTo( iInstance, pvBuf );
	return 0;
}


PM_CEF_PROC LDIRSystemRWTrxCommit0CEFLPv;
PERFInstanceG<> cDIRSystemRWTrxCommit0;
long LDIRSystemRWTrxCommit0CEFLPv(long iInstance,void *pvBuf)
{
	cDIRSystemRWTrxCommit0.PassTo( iInstance, pvBuf );

	return 0;
}


PM_CEF_PROC LDIRSystemTrxCommit0CEFLPv;
long LDIRSystemTrxCommit0CEFLPv(long iInstance,void *pvBuf)
{
	if ( NULL != pvBuf )
		{
		*((LONG *)pvBuf) = cDIRSystemROTrxCommit0.Get( iInstance ) + cDIRSystemRWTrxCommit0.Get( iInstance );
		}
	return 0;
}


PM_CEF_PROC LDIRSystemROTrxRollback0CEFLPv;
PERFInstanceG<> cDIRSystemROTrxRollback0;
long LDIRSystemROTrxRollback0CEFLPv(long iInstance,void *pvBuf)
{
	cDIRSystemROTrxRollback0.PassTo( iInstance, pvBuf );
	return 0;
}


PM_CEF_PROC LDIRSystemRWTrxRollback0CEFLPv;
PERFInstanceG<> cDIRSystemRWTrxRollback0;
long LDIRSystemRWTrxRollback0CEFLPv(long iInstance,void *pvBuf)
{
	cDIRSystemRWTrxRollback0.PassTo( iInstance, pvBuf );
	return 0;
}


PM_CEF_PROC LDIRSystemTrxRollback0CEFLPv;
long LDIRSystemTrxRollback0CEFLPv(long iInstance,void *pvBuf)
{
	if ( NULL != pvBuf )
		{
		*((LONG *)pvBuf) = cDIRSystemROTrxRollback0.Get( iInstance ) + cDIRSystemRWTrxRollback0.Get( iInstance );
		}
	return 0;
}


//	*****************************************
//	DIR API functions
//

// *********************************************************
// ******************** DIR API Routines ********************
//

//	***********************************************
//	constructor/destructor routines
//

//	creates a directory
//	get a new extent from space that is initialized to a directory
//
ERR ErrDIRCreateDirectory(
	FUCB	*pfucb,
	CPG		cpgMin,
	PGNO	*ppgnoFDP,
	OBJID	*pobjidFDP,
	UINT	fPageFlags,
	BOOL	fSPFlags )
	{
	ERR		err;
	CPG		cpgRequest = cpgMin;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( NULL != ppgnoFDP );
	Assert( NULL != pobjidFDP );

	//	check currency is on "parent" FDP
	//
	Assert( !Pcsr( pfucb )->FLatched( ) );
	Assert( locOnFDPRoot == pfucb->locLogical );

	fSPFlags |= fSPNewFDP;

	// WARNING: Should only create an unversioned extent if its parent was
	// previously created and versioned in the same transaction as the
	// creation of this extent.
	Assert( ( fSPFlags & fSPUnversionedExtent )
		|| dbidTemp != rgfmp[ pfucb->ifmp ].Dbid() );		// Don't version creation of temp. table.

	//	create FDP
	//
	*ppgnoFDP = pgnoNull;
	Call( ErrSPGetExt(
		pfucb,
		PgnoFDP( pfucb ),
		&cpgRequest,
		cpgMin,
		ppgnoFDP,
		fSPFlags,
		fPageFlags,
		pobjidFDP ) );
	Assert( *ppgnoFDP > pgnoSystemRoot );
	Assert( *ppgnoFDP <= pgnoSysMax );
	Assert( *pobjidFDP > objidSystemRoot );

HandleError:
	return err;
	}


//	***********************************************
//	Open/Close routines
//

//	opens a cursor on given ifmp, pgnoFDP
//
ERR ErrDIROpen( PIB *ppib, PGNO pgnoFDP, IFMP ifmp, FUCB **ppfucb )
	{
	ERR		err;
	FUCB	*pfucb;

	CheckPIB( ppib );

#ifdef DEBUG
	INST *pinst = PinstFromPpib( ppib );
	if ( !pinst->m_plog->m_fRecovering
		 && pinst->m_fSTInit == fSTInitDone
		 && !Ptls()->fIsTaskThread
		 && !Ptls()->fIsRCECleanup )
		{
		CheckDBID( ppib, ifmp );
		}
#endif

	CallR( ErrBTOpen( ppib, pgnoFDP, ifmp, &pfucb ) );
	DIRInitOpenedCursor( pfucb, pfucb->ppib->level );

	//	set return pfucb
	//
	*ppfucb = pfucb;
	return JET_errSuccess;
	}

//	open cursor, don't touch root page
ERR ErrDIROpenNoTouch( PIB *ppib, IFMP ifmp, PGNO pgnoFDP, OBJID objidFDP, BOOL fUnique, FUCB **ppfucb )
	{
	ERR		err;
	FUCB	*pfucb;

	CheckPIB( ppib );

#ifdef DEBUG
	INST *pinst = PinstFromPpib( ppib );
	if ( !pinst->m_plog->m_fRecovering
		 && pinst->m_fSTInit == fSTInitDone
		 && !Ptls()->fIsTaskThread
		 && !Ptls()->fIsRCECleanup )
		{
		CheckDBID( ppib, ifmp );
		}
#endif

	CallR( ErrBTOpenNoTouch( ppib, ifmp, pgnoFDP, objidFDP, fUnique, &pfucb ) );
	DIRInitOpenedCursor( pfucb, pfucb->ppib->level );

	//	set return pfucb
	//
	*ppfucb = pfucb;
	return JET_errSuccess;
	}

//	open cursor on given FCB
//
ERR	ErrDIROpen( PIB *ppib, FCB *pfcb, FUCB **ppfucb )
	{
	ERR		err;
	FUCB	*pfucb;

	CheckPIB( ppib );

#ifdef DEBUG
	INST *pinst = PinstFromPpib( ppib );
	if ( !pinst->m_plog->m_fRecovering
		&& pinst->m_fSTInit == fSTInitDone
		&& !Ptls()->fIsTaskThread
		&& !Ptls()->fIsRCECleanup )
		{
		CheckDBID( ppib, pfcb->Ifmp() );
		}
#endif

	Assert( pfcbNil != pfcb );
	CallR( ErrBTOpen( ppib, pfcb, &pfucb ) );
	DIRInitOpenedCursor( pfucb, pfucb->ppib->level );

	//	set return pfucb
	//
	*ppfucb = pfucb;
	return JET_errSuccess;
	}

//	open cursor on given FCB on behalf of another session
//
ERR	ErrDIROpenByProxy( PIB *ppib, FCB *pfcb, FUCB **ppfucb, LEVEL level )
	{
	ERR		err;
	FUCB	*pfucb;

	CheckPIB( ppib );

#ifdef DEBUG
	INST *pinst = PinstFromPpib( ppib );
	if ( !pinst->m_plog->m_fRecovering
		&& pinst->m_fSTInit == fSTInitDone
		&& !Ptls()->fIsTaskThread
	 	&& !Ptls()->fIsRCECleanup )
		{
		CheckDBID( ppib, pfcb->Ifmp() );
		}
#endif

	Assert( pfcbNil != pfcb );
	Assert( level > 0 );
	CallR( ErrBTOpenByProxy( ppib, pfcb, &pfucb, level ) );
	DIRInitOpenedCursor( pfucb, level );

	//	set return pfucb
	//
	*ppfucb = pfucb;
	return JET_errSuccess;
	}


//	closes cursor
//	frees space allocated for logical currency
//
VOID DIRClose( FUCB *pfucb )
	{
	//	this cursor should not be already defer closed
	//
	Assert( PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering || !FFUCBDeferClosed(pfucb) );

	RECReleaseKeySearchBuffer( pfucb );
	FILEReleaseCurrentSecondary( pfucb );

	BTClose( pfucb );
	}


//	***************************************************
//	RETRIEVE OPERATIONS
//

//	currency is implemented at BT level,
//	so DIRGet just does a BTRefresh()
//	returns a latched page iff the node access is successful
//
ERR ErrDIRGet( FUCB *pfucb )
	{
	ERR		err;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( !FFUCBSpace( pfucb ) );

	//	UNDONE: special case
	// 		if on current BM and page cached and
	// 		timestamp not changed and
	// 		node has not been versioned
	//
	if ( locOnCurBM == pfucb->locLogical )
		{
		Call( ErrBTGet( pfucb ) );
		Assert( Pcsr( pfucb )->FLatched() );
		return err;
		}

	CallR( ErrDIRIRefresh( pfucb ) );

	//	check logical currency status
	//
	switch ( pfucb->locLogical )
		{
		case locOnCurBM:
			Call( ErrBTGet( pfucb ) );
			return err;

		case locAfterSeekBM:
		case locBeforeSeekBM:
		case locOnFDPRoot:
		case locDeferMoveFirst:
			Assert( fFalse );
			break;

///		case locOnSeekBM:
///			return ErrERRCheck( JET_errRecordDeleted );
///			break;

		default:
			Assert( pfucb->locLogical == locAfterLast
					|| pfucb->locLogical == locOnSeekBM
					|| pfucb->locLogical == locBeforeFirst );
			return ErrERRCheck( JET_errNoCurrentRecord );
		}

	Assert( fFalse );
	return err;

HandleError:
	BTUp( pfucb );
	Assert( !Pcsr( pfucb )->FLatched() );
	return err;
	}


ERR ErrDIRFReplace( FUCB *pfucb, BOOL *pfReplace )
{
	ERR		err;

	Assert( !FFUCBSpace( pfucb ) );
	CheckFUCB( pfucb->ppib, pfucb );

	//	check currency and refresh if necessary.
	//
	Call( ErrDIRIRefresh( pfucb ) );

	if ( locOnCurBM != pfucb->locLogical )
		{
		Assert( !Pcsr( pfucb )->FLatched( ) );
		err = ErrERRCheck( JET_errNoCurrentRecord );
		return err;
		}

	Call( ErrBTFReplace( pfucb, pfReplace ) );
	Assert( locOnCurBM == pfucb->locLogical );

HandleError:
	CallS( ErrBTRelease( pfucb ) );
	Assert( !Pcsr( pfucb )->FLatched( ) );
	return err;
}

//	gets fractional postion of current node in directory
//
ERR ErrDIRGetPosition( FUCB *pfucb, ULONG *pulLT, ULONG *pulTotal )
	{
	ERR		err;
	ULONG	ulLT;
	ULONG	ulTotal;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( !Pcsr( pfucb )->FLatched() );
	Assert( !FFUCBSpace( pfucb ) );

	//	refresh logical currency
	//
	Call( ErrDIRIRefresh( pfucb ) );

	//	return error if not on a record
	//
	switch ( pfucb->locLogical )
		{
		case locOnCurBM:
		case locOnSeekBM:
			break;
		default:
			return ErrERRCheck( JET_errNoCurrentRecord );
		}

	//	get approximate position of node.
	//
	Call( ErrBTGetPosition( pfucb, &ulLT, &ulTotal ) );
	CallS( err );

	Assert( ulLT <= ulTotal );
	*pulLT = ulLT;
	*pulTotal = ulTotal;

HandleError:
	Assert( !Pcsr( pfucb )->FLatched() );
	return err;
	}


//	reverses a DIRGet() operation
//	releases latch on page after recording bm of node or seek in pfucb
//
ERR	ErrDIRRelease( FUCB *pfucb )
	{
	ERR		err;

	Assert( pfucb->locLogical == locOnCurBM ||
			pfucb->locLogical == locAfterSeekBM ||
			pfucb->locLogical == locBeforeSeekBM );
	Assert( !FFUCBSpace( pfucb ) );

	switch ( pfucb->locLogical )
		{
		case locOnCurBM:
///			AssertDIRGet( pfucb );
			Call( ErrBTRelease( pfucb ) );
			break;

		case locAfterSeekBM:
		case locBeforeSeekBM:
			{
			BOOKMARK	bm;

			FUCBAssertValidSearchKey( pfucb );
			bm.Nullify();

			//	first byte is segment counter
			//
			bm.key.suffix.SetPv( pfucb->dataSearchKey.Pv() );
			bm.key.suffix.SetCb( pfucb->dataSearchKey.Cb() );
			Call( ErrBTDeferGotoBookmark( pfucb, bm, fFalse/*no touch*/ ) );
			pfucb->locLogical = locOnSeekBM;
			break;
			}

		default:
			//	should be impossible, but return success just in case
			//	(okay to return success because we shouldn't have a latch
			//	even if the locLogical is an unexpected value)
			AssertSz( fFalse, "Unexpected locLogical" );
			err = JET_errSuccess;
			break;
		}

	Assert( !Pcsr( pfucb )->FLatched() );
	return err;

HandleError:
	Assert( err < 0 );

	//	bookmark could not be saved
	//	move up
	//
	Assert( JET_errOutOfMemory == err );
	DIRUp( pfucb );

	Assert( !Pcsr( pfucb )->FLatched() );
	return err;
	}

//	***************************************************
//	POSITIONING OPERATIONS
//

//	called from JetGotoBookmark
//		bookmark may not be valid
//		therefore, logical currency of cursor can be changed
//		only after we move to bookmark successfully
//		also, save bookmark and release latch
//
ERR	ErrDIRGotoJetBookmark( FUCB *pfucb, const BOOKMARK& bm )
	{
	ERR		err;

	Assert( !Pcsr( pfucb )->FLatched() );
	ASSERT_VALID( &bm );
	Assert( !FFUCBSpace( pfucb ) );

	if( !FFUCBSequential( pfucb ) )
		{
		FUCBResetPreread( pfucb );
		}

	Call( ErrBTGotoBookmark( pfucb, bm, latchReadNoTouch, fTrue ) );

	Assert( Pcsr( pfucb )->FLatched() );
	Assert( Pcsr( pfucb )->Cpage().FLeafPage() );

	Call( ErrBTGet( pfucb ) );
	pfucb->locLogical = locOnCurBM;

	Call( ErrBTRelease( pfucb ) );
	Assert( 0 == CmpBM( pfucb->bmCurr, bm ) );

	return err;

HandleError:
	BTUp( pfucb );
	return err;
	}


//	go to given bookmark
//	saves bookmark in cursor
//	next DIRGet() call will return an error if bookmark is not valid
//		this is an internal bookmark [possibly on/from a secondary index]
//		so bookmark should be valid
//
ERR	ErrDIRGotoBookmark( FUCB *pfucb, const BOOKMARK& bm )
	{
	ERR		err;

	ASSERT_VALID( &bm );
	Assert( !Pcsr( pfucb )->FLatched() );
	Assert( !FFUCBSpace( pfucb ) );

	if( !FFUCBSequential( pfucb ) )
		{
		FUCBResetPreread( pfucb );
		}

	//	copy given bookmark to cursor, we will need to touch the data page buffer
	//
	CallR( ErrBTDeferGotoBookmark( pfucb, bm, fTrue/*Touch*/ ) );
	pfucb->locLogical = locOnCurBM;

#ifdef DEBUG
	//	check that bookmark is valid
	//
	err = ErrBTGotoBookmark( pfucb, pfucb->bmCurr, latchReadNoTouch );
	switch( err )
		{
		case JET_errSuccess:
			//	if we suddenly lost visibility on the node, it must mean
			//	that we're at level 0 and the node deletion was suddenly
			//	committed underneath us
			if ( 0 != pfucb->ppib->level )
				{
				BOOL fVisible;
				CallS( ErrNDVisibleToCursor( pfucb, &fVisible ) );
				Assert( fVisible );
				}
			break;

		case JET_errRecordDeleted:
			//	node must have gotten expunged by RCEClean (only possible
			//	if we're at level 0)
			Assert( 0 == pfucb->ppib->level );
			break;

		case JET_errDiskIO:					//	(#48313 -- RFS testing causes JET_errDiskIO)
		case JET_errReadVerifyFailure:		//	(#86323 -- Repair testing causes JET_errReadVerifyFailure )
		case JET_errOutOfMemory:			//	(#146720 -- RFS testing causes JET_errOutOfMemory)
		case JET_errOutOfBuffers:
			break;

		default:
			//	force an assert
			CallS( err );
		}

	BTUp( pfucb );
#endif

	Assert( !Pcsr( pfucb )->FLatched() );
	return JET_errSuccess;
	}


//	goes to fractional position in directory
//
ERR ErrDIRGotoPosition( FUCB *pfucb, ULONG ulLT, ULONG ulTotal )
	{
	ERR		err;
	DIB		dib;
	FRAC	frac;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( !Pcsr( pfucb )->FLatched() );
	Assert( !FFUCBSpace( pfucb ) );

	if( !FFUCBSequential( pfucb ) )
		{
		FUCBResetPreread( pfucb );
		}

	//	set cursor navigation level for rollback support
	//
	FUCBSetLevelNavigate( pfucb, pfucb->ppib->level );

	//	UNDONE: do we need to refresh here???

	//	refresh logical currency
	//
	Call( ErrDIRIRefresh( pfucb ) );

	dib.dirflag = fDIRNull;
	dib.pos		= posFrac;
	dib.pbm		= reinterpret_cast<BOOKMARK *>( &frac );

	Assert( ulLT <= ulTotal );

	frac.ulLT		= ulLT;
	frac.ulTotal	= ulTotal;

	//	position fractionally on node.  Move up preserving currency
	//	in case down fails.
	//
	Call( ErrBTDown( pfucb, &dib, latchReadNoTouch ) );

	pfucb->locLogical = locOnCurBM;
	AssertDIRGet( pfucb );
	return err;

HandleError:
	Assert( !Pcsr( pfucb )->FLatched() );
	return err;
	}


//	seek down to a key or position in the directory
//		returns errSuccess, wrnNDFoundGreater or wrnNDFoundLess
//
ERR ErrDIRDown( FUCB *pfucb, DIB *pdib )
	{
	ERR		err;

	Assert( !Pcsr( pfucb )->FLatched() );
	Assert( pdib->pos != posFrac );
	Assert( !FFUCBSpace( pfucb ) );

	CheckFUCB( pfucb->ppib, pfucb );

	if( !FFUCBSequential( pfucb ) && !pfucb->u.pfcb->FTypeLV() )
		{
		FUCBResetPreread( pfucb );
		}

	//	set cursor navigation level for rollback support
	//
	FUCBSetLevelNavigate( pfucb, pfucb->ppib->level );

	err = ErrBTDown( pfucb, pdib, latchReadTouch );
	if ( err < 0 )
		{
		if( ( JET_errRecordNotFound == err )
			&& ( posDown == pdib->pos ) )
			{
			//  we didn't find the record we were looking for. save the bookmark
			//  so that a DIRNext/DIRPrev will work properly
			Call( ErrBTDeferGotoBookmark( pfucb, *(pdib->pbm), fFalse ) );
			pfucb->locLogical = locOnSeekBM;

			err = ErrERRCheck( JET_errRecordNotFound );
			}

		goto HandleError;
		}

	Assert( Pcsr( pfucb )->FLatched() );

	//	bookmark in pfucb has not been set to bm of current node
	//	but that will be done at the time of latch release
	//
	//	save physical position of cursor with respect to node
	//
	switch ( err )
		{
		case wrnNDFoundGreater:
			pfucb->locLogical = locAfterSeekBM;
			break;

		case wrnNDFoundLess:
			pfucb->locLogical = locBeforeSeekBM;
			break;

		default:
			err = JET_errSuccess;
			//	FALL THROUGH to set locLogical
		case JET_wrnUniqueKey:
			pfucb->locLogical = locOnCurBM;
			break;
		}

	return err;

HandleError:
	Assert( err < 0 );
	Assert( !Pcsr( pfucb )->FLatched() );
	Assert( err != JET_errNoCurrentRecord );
	return err;
	}


//	seeks secondary index record corresponding to NC key + primary key
//
ERR ErrDIRDownKeyData(
	FUCB 			*pfucb,
	const KEY& 		key,
	const DATA&		data )
	{
	ERR				err;
	BOOKMARK		bm;

	//	this routine should only be called with secondary indexes.
	//
	ASSERT_VALID( &key );
	ASSERT_VALID( &data );
	Assert( FFUCBSecondary( pfucb ) );
	Assert( locOnFDPRoot == pfucb->locLogical );
	Assert( !FFUCBSpace( pfucb ) );

	if( !FFUCBSequential( pfucb ) )
		{
		FUCBResetPreread( pfucb );
		}

	//	set cursor navigation level for rollback support
	//
	FUCBSetLevelNavigate( pfucb, pfucb->ppib->level );

	//	goto bookmark pointed by NC key + primary key
	//
	bm.key = key;
	if ( FFUCBUnique( pfucb ) )
		{
		bm.data.Nullify();
		}
	else
		{
		bm.data = data;
		}
	Call( ErrDIRGotoBookmark( pfucb, bm ) );
	CallS( err );

	return JET_errSuccess;

HandleError:
	Assert( JET_errNoCurrentRecord != err );
	Assert( !Pcsr( pfucb )->FLatched() );
	return err;
	}


//	CONSIDER: not needed for one-level trees?
//
//	moves cursor to root -- releases latch, if any
//
VOID DIRUp( FUCB *pfucb )
	{
	BTUp( pfucb );
	Assert( !Pcsr( pfucb )->FLatched() );

	pfucb->locLogical = locOnFDPRoot;
	}


//	moves cursor to node after current bookmark
//	if cursor is after current bookmark, gets current record
//
ERR ErrDIRNext( FUCB *pfucb, DIRFLAG dirflag )
	{
	ERR		err;
	ERR		wrn = JET_errSuccess;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( !FFUCBSpace( pfucb ) );

	//  set preread flags if we are navigating sequentially
	if( FFUCBSequential( pfucb ) )
		{
		FUCBSetPrereadForward( pfucb, cpgPrereadSequential );
		}
#ifdef PREDICTIVE_PREREAD
	else
		{
		if( FFUCBPrereadForward( pfucb ) )
			{
			if( !FFUCBPreread( pfucb )
				&& FFUCBIndex( pfucb )
				&& pfucb->cbSequentialDataRead >= cbSequentialDataPrereadThreshold
				&& locOnCurBM == pfucb->locLogical )	//	can't call DIRRelease() if locBefore/AfterSeekBM because there may not be a bookmark available
				{
				FUCBSetPrereadForward( pfucb, cpgPrereadPredictive );
				//  release to save bookmark and nullify csr to force a BTDown
				Call( ErrDIRRelease( pfucb ) );
				BTUp( pfucb );
				}
			}
		else
			{
			FUCBResetPreread( pfucb );
			pfucb->fPrereadForward = fTrue;
			}
		}
#endif	//	PREDICTIVE_PREREAD

	//	set cursor navigation level for rollback support
	//
	FUCBSetLevelNavigate( pfucb, pfucb->ppib->level );

Refresh:
	//	check currency and refresh if necessary
	//
	Call( ErrDIRIRefresh( pfucb ) );

	//	switch action based on logical cursor location
	//
	switch( pfucb->locLogical )
		{
		case locOnCurBM:
		case locBeforeSeekBM:
			break;

		case locOnSeekBM:
			{
			//	re-seek to key and if foundLess, fall through to MoveNext
			//
			Call( ErrBTPerformOnSeekBM( pfucb, fDIRFavourNext ) );
			Assert( Pcsr( pfucb )->FLatched() );

			if ( wrnNDFoundGreater == err )
				{
				pfucb->locLogical = locOnCurBM;
				return JET_errSuccess;
				}
			else
				{
				Assert( wrnNDFoundLess == err );
				}
			break;
			}

		case locOnFDPRoot:
			return( ErrERRCheck( JET_errNoCurrentRecord ) );

		case locAfterLast:
			return( ErrERRCheck( JET_errNoCurrentRecord ) );

		case locAfterSeekBM:
			Assert( Pcsr( pfucb )->FLatched() );

			//	set currency on current
			//
			pfucb->locLogical = locOnCurBM;
			Assert( Pcsr( pfucb )->FLatched( ) );

			return err;

		default:
			{
			DIB	dib;
			Assert( locBeforeFirst == pfucb->locLogical );

			//	move to root.
			//
			DIRGotoRoot( pfucb );
			dib.dirflag	= fDIRNull;
			dib.pos		= posFirst;
			err = ErrDIRDown( pfucb, &dib );
			if ( err < 0 )
				{
				//	retore currency.
				//
				pfucb->locLogical = locBeforeFirst;
				Assert( !Pcsr( pfucb )->FLatched() );

				//	polymorph error code.
				//
				if ( err == JET_errRecordNotFound )
					{
					err = ErrERRCheck( JET_errNoCurrentRecord );
					}
				}

			return err;
			}
		}

	Assert( locOnCurBM == pfucb->locLogical ||
			locBeforeSeekBM == pfucb->locLogical ||
			locOnSeekBM == pfucb->locLogical && err != wrnNDFoundGreater );

	err = ErrBTNext( pfucb, dirflag );

	if ( err < 0 )
		{
		if ( JET_errNoCurrentRecord == err )
			{
			//	moved past last node
			//
			pfucb->locLogical = locAfterLast;
			}
		else if ( JET_errRecordDeleted == err )
			{
			//	node was deleted from under the cursor
			//	reseek to logical bm and move to next node
			//
			BTSetupOnSeekBM( pfucb );
			goto Refresh;
			}
		goto HandleError;
		}

	pfucb->locLogical = locOnCurBM;
	wrn = err;

	//	check index range
	//
	if ( FFUCBLimstat( pfucb ) &&
		 FFUCBUpper( pfucb ) &&
		 JET_errSuccess == err )
		{
		Call( ErrDIRICheckIndexRange( pfucb, pfucb->kdfCurr.key ) );
		}

#ifdef PREDICTIVE_PREREAD
	Assert( FFUCBSequential( pfucb ) || FFUCBPrereadForward( pfucb ) );
	pfucb->cbSequentialDataRead += pfucb->kdfCurr.data.Cb();
#endif	//	PREDICTIVE_PREREAD

	return wrn != JET_errSuccess ? wrn : err;

HandleError:
	Assert( err < 0 );
	BTUp( pfucb );
	if ( JET_errRecordNotFound == err )
		{
		err = ErrERRCheck( JET_errNoCurrentRecord );
		}
	Assert( !Pcsr( pfucb )->FLatched() );
	return err;
	}


//	moves cursor to node before current bookmark
//
ERR ErrDIRPrev( FUCB *pfucb, DIRFLAG dirflag )
	{
	ERR		err;
	ERR		wrn = JET_errSuccess;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( !FFUCBSpace( pfucb ) );

	//  set preread flags if we are navigating sequentially
	if( FFUCBSequential( pfucb ) )
		{
		FUCBSetPrereadBackward( pfucb, cpgPrereadSequential );
		}
#ifdef PREDICTIVE_PREREAD
	else
		{
		if( FFUCBPrereadBackward( pfucb ) )
			{
			if( !FFUCBPreread( pfucb )
				&& FFUCBIndex( pfucb )
				&& pfucb->cbSequentialDataRead >= cbSequentialDataPrereadThreshold
				&& locOnCurBM == pfucb->locLogical )	//	can't call DIRRelease() if locBefore/AfterSeekBM because there may not be a bookmark available
				{
				FUCBSetPrereadBackward( pfucb, cpgPrereadPredictive );
				//  release to save bookmark and nullify csr to force a BTDown
				Call( ErrDIRRelease( pfucb ) );
				BTUp( pfucb );
				}
			}
		else
			{
			FUCBResetPreread( pfucb );
			pfucb->fPrereadBackward = fTrue;
			}
		}
#endif	//	PREDICTIVE_PREREAD

	//	set cursor navigation level for rollback support
	//
	FUCBSetLevelNavigate( pfucb, pfucb->ppib->level );

Refresh:
	//	check currency and refresh if necessary
	//
	Call( ErrDIRIRefresh( pfucb ) );

	//	switch action based on logical cursor location
	//
	switch( pfucb->locLogical )
		{
		case locOnCurBM:
		case locAfterSeekBM:
			break;

		case locOnSeekBM:
			{
			//	re-seek to key and if foundGreater, fall through to MovePrev
			//
			Call( ErrBTPerformOnSeekBM( pfucb, fDIRFavourPrev ) );
			Assert( Pcsr( pfucb )->FLatched() );

			if ( wrnNDFoundLess == err )
				{
				pfucb->locLogical = locOnCurBM;
				return JET_errSuccess;
				}
			else
				{
				Assert( wrnNDFoundGreater == err );
				}
			break;
			}

		case locOnFDPRoot:
			return( ErrERRCheck( JET_errNoCurrentRecord ) );

		case locBeforeFirst:
			return( ErrERRCheck( JET_errNoCurrentRecord ) );

		case locBeforeSeekBM:
			Assert( Pcsr( pfucb )->FLatched() );

			//	set currency on current
			//
			pfucb->locLogical = locOnCurBM;
			Assert( Pcsr( pfucb )->FLatched( ) );

			return err;

		default:
			{
			DIB	dib;
			Assert( locAfterLast == pfucb->locLogical );

			//	move to root.
			//
			DIRGotoRoot( pfucb );
			dib.dirflag = fDIRNull;
			dib.pos		= posLast;
			err = ErrDIRDown( pfucb, &dib );
			if ( err < 0 )
				{
				//	retore currency.
				//
				pfucb->locLogical = locAfterLast;
				Assert( !Pcsr( pfucb )->FLatched() );

				//	polymorph error code.
				//
				if ( err == JET_errRecordNotFound )
					{
					err = ErrERRCheck( JET_errNoCurrentRecord );
					}
				}

			return err;
			}
		}

	Assert( locOnCurBM == pfucb->locLogical ||
			locAfterSeekBM == pfucb->locLogical ||
			locOnSeekBM == pfucb->locLogical && wrnNDFoundGreater == err );

	err = ErrBTPrev( pfucb, dirflag );

	if ( err < 0 )
		{
		if ( JET_errNoCurrentRecord == err )
			{
			//	moved past first node
			//
			pfucb->locLogical = locBeforeFirst;
			}
		else if ( JET_errRecordDeleted == err )
			{
			//	node was deleted from under the cursor
			//	reseek to logical bm and move to next node
			//
			BTSetupOnSeekBM( pfucb );
			goto Refresh;
			}

		goto HandleError;
		}

	pfucb->locLogical = locOnCurBM;
	wrn = err;

	//	check index range
	//
	if ( FFUCBLimstat( pfucb ) &&
		 !FFUCBUpper( pfucb ) &&
		 JET_errSuccess == err )
		{
		Call( ErrDIRICheckIndexRange( pfucb, pfucb->kdfCurr.key ) );
		}

#ifdef PREDICTIVE_PREREAD
	Assert( FFUCBSequential( pfucb ) || FFUCBPrereadBackward( pfucb ) );
	pfucb->cbSequentialDataRead += pfucb->kdfCurr.data.Cb();
#endif	//	PREDICTIVE_PREREAD

	return wrn != JET_errSuccess ? wrn : err;

HandleError:
	Assert( err < 0 );
	BTUp( pfucb );
	if ( JET_errRecordNotFound == err )
		{
		err = ErrERRCheck( JET_errNoCurrentRecord );
		}
	Assert( !Pcsr( pfucb )->FLatched() );
	return err;
	}


//	************************************************
//	INDEX RANGE OPERATIONS
//
//	could become part of BT
//
ERR ErrDIRCheckIndexRange( FUCB *pfucb )
	{
	ERR		err;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( !FFUCBSpace( pfucb ) );

	//	check currency and refresh if necessary
	//
	CallR( ErrDIRIRefresh( pfucb ) );

	//	get key of node for check index range
	//  we don't need to latch the page, we just need the logical bookmark
	//  if we were locDeferMoveFirst the ErrDIRIRefresh above should have
	//  straightened us out
	//
	if( locOnCurBM == pfucb->locLogical
		|| locOnSeekBM == pfucb->locLogical )
		{
		Call( ErrDIRICheckIndexRange( pfucb, pfucb->bmCurr.key ) );
		}
	else
		{
		//  UNDONE: deal with locBeforeSeekBM, locAfterSeekBM, locBeforeFirst etc.
		Call( ErrERRCheck( JET_errNoCurrentRecord ) );
		}

HandleError:
	Assert( !Pcsr( pfucb )->FLatched() );
	return err;
	}



//	************************************************
//	UPDATE OPERATIONS
//

//	insert key-data-flags into tree
//	cursor should be at FDP root
//		and have no physical currency
//
ERR ErrDIRInsert( FUCB 			*pfucb,
				  const KEY& 	key,
				  const DATA& 	data,
				  DIRFLAG		dirflag,
				  RCE			*prcePrimary )
	{
	ERR		err;

	ASSERT_VALID( &key );
	ASSERT_VALID( &data );
	CheckFUCB( pfucb->ppib, pfucb );
	Assert( !FFUCBSpace( pfucb ) );

	//	set cursor navigation level for rollback support
	//
	FUCBSetLevelNavigate( pfucb, pfucb->ppib->level );

	Assert( !Pcsr( pfucb )->FLatched() );

	Call( ErrBTInsert( pfucb, key, data, dirflag, prcePrimary ) );

	if ( dirflag & fDIRBackToFather )
		{
		//	no need to save bookmark
		//
		DIRUp( pfucb );
		Assert( locOnFDPRoot == pfucb->locLogical );
		}
	else
		{
		//	save bookmark
		//
		Call( ErrBTRelease( pfucb ) );
		pfucb->locLogical = locOnCurBM;
		}

HandleError:
	Assert( !Pcsr( pfucb )->FLatched() );
	return err;
	}


//	the following three calls provide an API for inserting secondary keys
//	at Index creation time
//	DIRAppend is used instead of DIRInit for performance reasons
//
ERR ErrDIRInitAppend( FUCB *pfucb )
	{
	Assert( !FFUCBSpace( pfucb ) );

	//	set cursor navigation level for rollback support
	//
	FUCBSetLevelNavigate( pfucb, pfucb->ppib->level );

	return JET_errSuccess;
	}


//	appends key-data at the end of page
//	leaves page latched
//
ERR ErrDIRAppend( FUCB 			*pfucb,
				  const KEY& 	key,
				  const DATA& 	data,
				  DIRFLAG		dirflag )
	{
	ERR		err;

	ASSERT_VALID( &key );
	ASSERT_VALID( &data );
	Assert( !FFUCBSpace( pfucb ) );
	Assert( !data.FNull() );
	Assert( !key.FNull() || FFUCBRepair( pfucb ) );
	Assert( LevelFUCBNavigate( pfucb ) == pfucb->ppib->level );

	if ( locOnFDPRoot == pfucb->locLogical )
		{
		CallR( ErrBTInsert( pfucb, key, data, dirflag ) );
		Assert( Pcsr( pfucb )->FLatched() );
		pfucb->locLogical = locOnCurBM;
		return err;
		}

	Assert( Pcsr( pfucb )->FLatched() );
	Assert( locOnCurBM == pfucb->locLogical );
	AssertDIRGet( pfucb );

	//	if key-data same as current node, must be
	//	trying to insert duplicate keys into a
	//	multi-valued index.
	if ( FKeysEqual( pfucb->kdfCurr.key, key )
		&& FDataEqual( pfucb->kdfCurr.data, data ) )
		{
		Assert( FFUCBSecondary( pfucb ) );
		Assert( pfcbNil != pfucb->u.pfcb );
		Assert( rgfmp[ pfucb->u.pfcb->Ifmp() ].Dbid() != dbidTemp );
		Assert( pfucb->u.pfcb->FTypeSecondaryIndex() );
		Assert( pfucb->u.pfcb->Pidb() != pidbNil );
		Assert( !pfucb->u.pfcb->Pidb()->FPrimary() );
		Assert( !pfucb->u.pfcb->Pidb()->FUnique() );
		Assert( pfucb->u.pfcb->Pidb()->FMultivalued() );
		//	must have been record with multi-value column
		//	with sufficiently similar values (ie. the
		//	indexed portion of the multi-values were
		//	identical) to produce redundant index
		//	entries -- this is okay, we simply have
		//	one index key pointing to multiple multi-values
		err = JET_errSuccess;
		return err;
		}

	Assert( FFUCBRepair( pfucb ) && key.FNull()
			|| CmpKey( pfucb->kdfCurr.key, key ) < 0
			|| CmpData( pfucb->kdfCurr.data, data ) < 0 );

	Call( ErrBTAppend( pfucb, key, data, dirflag ) );

	//	set logical currency on inserted node.
	//
	pfucb->locLogical = locOnCurBM;
	Assert( Pcsr( pfucb )->FLatched() );
	return err;

HandleError:
	Assert( !Pcsr( pfucb )->FLatched() );
	return err;
	}


ERR ErrDIRTermAppend( FUCB *pfucb )
	{
	ERR		err = JET_errSuccess;

	DIRUp( pfucb );
	return err;
	}


//	flag delete node
//	release latch
//
ERR ErrDIRDelete( FUCB *pfucb, DIRFLAG dirflag, RCE *prcePrimary )
	{
	ERR		err;

	Assert( !FFUCBSpace( pfucb ) );
	CheckFUCB( pfucb->ppib, pfucb );

	//	refresh logical currency
	//
	//	UNDONE: should this be a call to ErrDIRGet() instead??
	//	Currently, we're relying on whatever precedes a call
	//	to ErrDIRDelete() to perform visibility checks
	//	(eg. if the same session performs two consecutive
	//	JetDelete() calls on the same record, the only thing
	//	saving us is the call in ErrIsamDelete() to
	//	ErrRECDereferenceLongFieldsInRecord() just before the
	//	call to ErrDIRDelete())
	//
	Call( ErrDIRIRefresh( pfucb ) );

	if ( locOnCurBM == pfucb->locLogical )
		{
		err = ErrBTFlagDelete( pfucb, dirflag, prcePrimary );
///		if( err >= JET_errSuccess )
///			{
///			pfucb->locLogical = locOnSeekBM;
///			}
		}
	else
		{
		Assert( !Pcsr( pfucb )->FLatched() );
		err = ErrERRCheck( JET_errNoCurrentRecord );
		return err;
		}

HandleError:
	CallS( ErrBTRelease( pfucb ) );
	Assert( !Pcsr( pfucb )->FLatched() );
	return err;
	}


//	replaces data portion of current node
//	releases latch after recording bm of node in pfucb
//
ERR ErrDIRReplace( FUCB *pfucb, const DATA& data, DIRFLAG dirflag )
	{
	ERR		err;

	ASSERT_VALID( &data );
	Assert( !FFUCBSpace( pfucb ) );
	CheckFUCB( pfucb->ppib, pfucb );

	//	check currency and refresh if necessary.
	//
	Call( ErrDIRIRefresh( pfucb ) );

	if ( locOnCurBM != pfucb->locLogical )
		{
		Assert( !Pcsr( pfucb )->FLatched( ) );
		err = ErrERRCheck( JET_errNoCurrentRecord );
		return err;
		}

	Call( ErrBTReplace( pfucb, data, dirflag ) );
	Assert( locOnCurBM == pfucb->locLogical );

HandleError:
	CallS( ErrBTRelease( pfucb ) );
	Assert( !Pcsr( pfucb )->FLatched( ) );
	return err;
	}


//	lock record	by calling BTLockRecord
//
ERR ErrDIRGetLock( FUCB *pfucb, DIRLOCK dirlock )
	{
	ERR     err = JET_errSuccess;

	Assert( !FFUCBSpace( pfucb ) );
	Assert( pfucb->ppib->level > 0 );
	Assert( !Pcsr( pfucb )->FLatched() );

	//	check currency and refresh if necessary.
	//
	Call( ErrDIRIRefresh( pfucb ) );

	//	check cursor location
	//
	switch ( pfucb->locLogical )
		{
		case locOnCurBM:
			break;

		case locOnFDPRoot:
		case locDeferMoveFirst:
			Assert( fFalse );

		default:
			Assert( pfucb->locLogical == locBeforeSeekBM ||
					pfucb->locLogical == locAfterSeekBM ||
					pfucb->locLogical == locAfterLast ||
					pfucb->locLogical == locBeforeFirst ||
					pfucb->locLogical == locOnSeekBM );
			return( ErrERRCheck( JET_errNoCurrentRecord ) );
		}

	Call( ErrBTLock( pfucb, dirlock ) );
	CallS( err );

	return err;

HandleError:
	Assert( !Pcsr( pfucb )->FLatched() );
	return err;
	}


//	called by Lv.c
//	calls ErrBTDelta
//
ERR ErrDIRDelta(
		FUCB		*pfucb,
		INT			cbOffset,
		const VOID	*pv,
		ULONG		cbMax,
		VOID		*pvOld,
		ULONG		cbMaxOld,
		ULONG		*pcbOldActual,
		DIRFLAG		dirflag )
	{
	ERR		err;

	Assert( !FFUCBSpace( pfucb ) );
	CheckFUCB( pfucb->ppib, pfucb );

	//	check currency and refresh if necessary.
	//
	Call( ErrDIRIRefresh( pfucb ) );
	Assert( locOnCurBM == pfucb->locLogical );

	Call( ErrBTDelta( pfucb, cbOffset, pv, cbMax, pvOld, cbMaxOld, pcbOldActual, dirflag ) );

HandleError:
	CallS( ErrBTRelease( pfucb ) );
	Assert( !Pcsr( pfucb )->FLatched() );
	return err;
	}


//	****************************************************************
//	STATISTICAL ROUTINES
//

//	counts nodes from current to limit or end of table
//
ERR ErrDIRIndexRecordCount( FUCB *pfucb, ULONG *pulCount, ULONG ulCountMost, BOOL fNext )
	{
	ERR		err;
	INST *	pinst	= PinstFromPfucb( pfucb );
	CPG		cpgPreread;
	BOOKMARK bm;
	BYTE	*pb = NULL;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( !Pcsr( pfucb )->FLatched() );

	//	intialize count variable
	//
	*pulCount = 0;

	//  there is no record count limit or the record count limit is larger than
	//  the maximum fanout of the maximum preread

	if ( 0 == ulCountMost )
		{
		//  turn on maximum preread

		cpgPreread = cpgPrereadSequential;

		ulCountMost = ULONG_MAX;
		}
	else if ( ulCountMost > ULONG( cpgPrereadSequential * cpgPrereadSequential ) )
		{
		//  turn on maximum preread

		cpgPreread = cpgPrereadSequential;
		}

	//  we have a small record count limit

	else
		{
		//  preread two pages so that we can use the first page to estimate
		//  the true number of pages to preread and use the second page to
		//  trigger the preread without taking another cache miss

		cpgPreread = 2;
		}

	//  turn on preread

	if ( fNext )
		{
		FUCBSetPrereadForward( pfucb, cpgPreread );
		}
	else
		{
		FUCBSetPrereadBackward( pfucb, cpgPreread );
		}

	//	refresh logical currency
	//
	err = ErrDIRIRefresh( pfucb );
	if ( JET_errNoCurrentRecord == err && pfucb->locLogical == locDeferMoveFirst )
		{
		//	special-case: empty table
		//
		err = JET_errSuccess;
		goto HandleError;
		}
	else
		{
		Call( err );
		}

	//	return error if not on a record
	//
	if ( locOnCurBM != pfucb->locLogical )
		{
		Call( ErrERRCheck( JET_errNoCurrentRecord ) );
		}

	Assert( pfucb->bmCurr.key.Cb() + pfucb->bmCurr.data.Cb() > 0 );
	pb = new BYTE[ pfucb->bmCurr.key.Cb() + pfucb->bmCurr.data.Cb() ];
	if ( pb == NULL )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	bm.Nullify();
	if ( pfucb->bmCurr.key.Cb() > 0 )
		{
		bm.key.suffix.SetPv( pb );
		pfucb->bmCurr.key.CopyIntoBuffer( pb );
		bm.key.suffix.SetCb( pfucb->bmCurr.key.Cb() );
		}
	if ( pfucb->bmCurr.data.Cb() > 0 )
		{
		bm.data.SetPv( pb + bm.key.Cb() );
		pfucb->bmCurr.data.CopyInto( bm.data );
		}

	Call( ErrBTGet( pfucb ) );

	//  if we have a small record count limit, use the current page to make an
	//  estimate at how much we should preread and set our preread limit to that
	//  amount
	//
	//  CONSIDER:  sample and account for percentage of visible nodes

	if ( cpgPreread == 2 )
		{
		cpgPreread = min(	CPG(	(	( ulCountMost + Pcsr( pfucb )->ILine() ) /
										max( Pcsr( pfucb )->Cpage().Clines(), 1 ) ) -
									cpgPreread ),
							cpgPrereadSequential );

		if ( fNext )
			{
			FUCBSetPrereadForward( pfucb, cpgPreread );
			}
		else
			{
			FUCBSetPrereadBackward( pfucb, cpgPreread );
			}
		}

	//	count nodes from current to limit or end of table
	//
	forever
		{
		err = pinst->ErrCheckForTermination();
		if ( err < JET_errSuccess )
			{
			BTUp( pfucb );
			break;
			}

		if ( ++(*pulCount) == ulCountMost )
			{
			BTUp( pfucb );
			break;
			}

		if ( fNext )
			{
			err = ErrBTNext( pfucb, fDIRNull );
			}
		else
			{
			err = ErrBTPrev( pfucb, fDIRNull );
			}

		if ( err < 0 )
			{
			BTUp( pfucb );
			break;
			}

		//	check index range
		//
		if ( FFUCBLimstat( pfucb ) )
			{
			err = ErrDIRICheckIndexRange( pfucb, pfucb->kdfCurr.key );
			if ( err < 0 )
				{
				Assert( !Pcsr( pfucb )->FLatched() );
				break;
				}
			}
		}

	//	common exit loop processing
	//
	if ( err >= 0 || err == JET_errNoCurrentRecord )
		{
		err = JET_errSuccess;
		}

HandleError:
	if ( pb != NULL )
		{
		if ( err == JET_errSuccess )
			{
			FUCBResetLimstat( pfucb );
			err = ErrDIRGotoBookmark( pfucb, bm );
			}
		else
			{
			// Keep the existing err code, even if hit the error. At least we did our best
			(VOID)ErrDIRGotoBookmark( pfucb, bm );
			}
		bm.Nullify();
		delete[] pb;
		pb = NULL;
		}
	Assert( pb == NULL );
	Assert( !Pcsr( pfucb )->FLatched() );
	FUCBResetPreread( pfucb );
	return err;
	}


//	computes statistics on directory by calling BT level function
//
ERR ErrDIRComputeStats( FUCB *pfucb, INT *pcnode, INT *pckey, INT *pcpage )
	{
	ERR		err;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( !FFUCBLimstat( pfucb ) );
	Assert( locOnFDPRoot == pfucb->locLogical );

	CallR( ErrBTComputeStats( pfucb, pcnode, pckey, pcpage ) );
	return err;
	}


//	********************************************************
//	************** DIR Transaction Routines ******************
//

//	begins a transaction
//	gets transaction id
//	logs trqansaction
//	records lgpos of begin in ppib [VERBeginTransaction]
//
ERR ErrDIRBeginTransaction( PIB *ppib, const JET_GRBIT grbit )
	{
	ERR			err			= JET_errSuccess;
	BOOL		fInCritTrx	= fFalse;
	INST		* pinst		= PinstFromPpib( ppib );

	//	The critical section ensure that the deferred begin trx level
	//	issued by indexer for a updater will not be changed till the indexer
	//	finish changing for the updater's RCEs that need be updated by indexer.

	//	log begin transaction.
	//	Must be called first so that lgpos and trx used in ver are consistent.
	//
	if ( ppib->level == 0 )
		{
		//	UNDONE: if we can guarantee that our clients are well-behaved, we don't
		//	need this check
		PIBSetTrxContext( ppib );

		Assert( prceNil == ppib->prceNewest );
		if ( grbit & JET_bitTransactionReadOnly )
			ppib->SetFReadOnlyTrx();
		else
			ppib->ResetFReadOnlyTrx();

#ifdef NO_BEGIN0_COMMIT0_LOCK
		PIBSetTrxBegin0( ppib );
#else
		INST::PLS* const ppls = pinst->Ppls();
		ppls->m_blBegin0Commit0.Enter1();
		PIBSetTrxBegin0( ppib );
		ppls->m_blBegin0Commit0.Leave1();
#endif
		}
	else if( prceNil != ppib->prceNewest )
		{
		ppib->critTrx.Enter();
		Assert( !( ppib->FReadOnlyTrx() ) );
		fInCritTrx = fTrue;
		}
	else
		{
		Assert( FPIBCheckTrxContext( ppib ) );
		}

	//	UNDONE: if we can guarantee that our clients are well-behaved, we don't
	//	need this check
	if ( ppib->level != 0 && !FPIBCheckTrxContext( ppib ) )
		{
		PIBReportSessionSharingViolation( ppib );
		FireWall();
		Call( ErrERRCheck( JET_errSessionSharingViolation ) );
		}
	else
		{
#ifdef DTC
		if ( grbit & JET_bitDistributedTransaction )
			{
			if ( 0 == ppib->level )
				{
				if ( NULL != pinst->m_pfnRuntimeCallback )
					{
					ppib->SetFDistributedTrx();
					}
				else
					{
					Call( ErrERRCheck( JET_errDTCMissingCallback ) );
					}
				}
			else
				{
				Call( ErrERRCheck( JET_errCannotNestDistributedTransactions ) );
				}
			}
#else
		//	should have been filtered out at ISAM level
		Assert( !( grbit & JET_bitDistributedTransaction ) );
#endif	//	DTC

		CallS( ErrLGBeginTransaction( ppib ) );
		VERBeginTransaction( ppib );
		}

HandleError:
	if ( fInCritTrx )
		{
		Assert( prceNil != ppib->prceNewest );
		Assert( !( ppib->FReadOnlyTrx() ) );
		ppib->critTrx.Leave();
		}

	return err;
	}


#ifdef DTC
ERR ErrDIRPrepareToCommitTransaction(
	PIB			* const ppib,
	const VOID	* const pvData,
	const ULONG	cbData )
	{
	ERR			err;

	CheckPIB( ppib );
	Assert( 1 == ppib->level );		//	distributed transactions are not nestable

	//	UNDONE: if we can guarantee that our clients are well-behaved, we don't
	//	need this check
	if ( !FPIBCheckTrxContext( ppib ) )
		{
		PIBReportSessionSharingViolation( ppib );
		FireWall();
		Call( ErrERRCheck( JET_errSessionSharingViolation ) );
		}

	Call( ErrLGPrepareToCommitTransaction( ppib, pvData, cbData ) );

	ppib->SetFPreparedToCommitTrx();

HandleError:
	return err;
	}
#endif	//	DTC


//	commits transaction
//
ERR ErrDIRCommitTransaction( PIB *ppib, JET_GRBIT grbit )
	{
	ERR		err = JET_errSuccess;
	FUCB	*pfucb;

	const BOOL	fCommit0		= ( 1 == ppib->level );
	const BOOL	fRWTrx			= ppib->FBegin0Logged();
	const BOOL	fSessionHasRCE	= ( prceNil != ppib->prceNewest );
#ifdef NO_BEGIN0_COMMIT0_LOCK
#else
	const BOOL	fModeCommit0	= ( fCommit0 && fSessionHasRCE );
#endif
	TRX			trxCommit0Hint	= trxMax;

	CheckPIB( ppib );
	Assert( ppib->level > 0 );

	INST * const pinst = PinstFromPpib( ppib );
	LOG  * const plog = pinst->m_plog;

	//	UNDONE: if we can guarantee that our clients are well-behaved, we don't
	//	need this check
	if ( !FPIBCheckTrxContext( ppib ) )
		{
		PIBReportSessionSharingViolation( ppib );
		FireWall();
		return ErrERRCheck( JET_errSessionSharingViolation );
		}

	// This critical section ensures that we don't commit RCE's from
	// underneath CreateIndex.
	if( fSessionHasRCE )
		{
		ppib->critTrx.Enter();
		}

	//  perf stats

	if ( fCommit0 )
		{
		if ( ppib->FDistributedTrx() && !ppib->FPreparedToCommitTrx() )
			{
			Call( ErrERRCheck( JET_errDistributedTransactionNotYetPreparedToCommit ) );
			}
		if ( fRWTrx )
			{
			ppib->FUserSession() ? cDIRUserRWTrxCommit0.Inc( pinst ) : cDIRSystemRWTrxCommit0.Inc( pinst );
			}
		else
			{
			ppib->FUserSession() ? cDIRUserROTrxCommit0.Inc( pinst ) : cDIRSystemROTrxCommit0.Inc( pinst );
			}

		//  get a snapshot of our approximate trxCommi0. This doesn't have to be exact
		//	because it will only be used for logging the Commit0 and on recovery
		//	we do not need an exact trxCommit0 because visibility is not an
		//	issue during recovery
		//
		trxCommit0Hint = ( pinst->m_trxNewest + 2 );
#ifdef NO_BEGIN0_COMMIT0_LOCK
#else
		ppib->trxCommit0 = trxCommit0Hint;
#endif
		}

	LGPOS	lgposCommitRec;
	Call( ErrLGCommitTransaction(
				ppib,
				LEVEL( ppib->level - 1 ),
				trxCommit0Hint,
				&lgposCommitRec ) );

	if ( fCommit0 )
		{
#ifdef NO_BEGIN0_COMMIT0_LOCK
		Assert( trxMax == ppib->trxCommit0 );
		Assert( trxMax != trxCommit0Hint );

		//	if this transaction actually versioned something, then
		//	must use accurate Commit0 to ensure correct visibility
		//	by other sessions, otherwise the hint is fine because
		//	no other session will care
		//
		ppib->trxCommit0 = ( fSessionHasRCE ?
								TRX( AtomicExchangeAdd( (LONG *)&pinst->m_trxNewest, 2 ) ) + 2 :
								trxCommit0Hint );
		Assert( !( ppib->trxCommit0 & 1 ) );
#endif

		ppib->lgposCommit0 = lgposCommitRec;

		//	for distributed transactions, the PrepareToCommit is always force-flushed,
		//	so never any need to force-flush the Commit0
		if( fRWTrx && !ppib->FDistributedTrx() )
			{
			const JET_GRBIT grbitT = grbit | ppib->grbitsCommitDefault;

			//  UNDONE:  if we are a read-only transaction we don't need to
			//  call ErrLGWaitCommit0Flush, which enters critLGBuf
			if ( !( grbitT & JET_bitCommitLazyFlush ) )
				{
				//	remember the minimum requirement to flush. It is ok to use the beginning
				//	of commit log record lgposLogRec we flush up to
				//	the end of all flushable log records and the whole log record will be
				//	flushed.
				err = plog->ErrLGWaitCommit0Flush( ppib );
				Assert( err >= 0  ||
						( plog->m_fLGNoMoreLogWrite  &&
						  err == JET_errLogWriteFail ) );

				//  CONSIDER:  if ErrLGWaitCommit0Flush fails, are we sure our commit record wasn't logged?
				Call( err );
				}
			}

#ifdef NO_BEGIN0_COMMIT0_LOCK
#else
		if ( fModeCommit0 )
			{
			for ( size_t iProc = 0; iProc < OSSyncGetProcessorCountMax(); iProc++ )
				{
				INST::PLS* const ppls = pinst->Ppls( iProc );
				ppls->m_blBegin0Commit0.Enter2();	//  so no-one else can see partially completed transactions
				}
			ppib->trxCommit0 = TRX( AtomicExchangeAdd( (LONG *)&pinst->m_trxNewest, 2 ) ) + 2;
			Assert( !( ppib->trxCommit0 & 1 ) );
			}
#endif
		}

	VERCommitTransaction( ppib );

#ifdef NO_BEGIN0_COMMIT0_LOCK
	if ( fCommit0 && fSessionHasRCE )
		{
		//	if committing to level 0, ppib should have no more
		//	outstanding versions
		Assert( 0 == ppib->level );
		Assert( prceNil == ppib->prceNewest );
		}
#else
	if ( fModeCommit0 )
		{
		//	if committing to level 0, ppib should have no more
		//	outstanding versions
		Assert( 0 == ppib->level );
		Assert( prceNil == ppib->prceNewest );
		for ( size_t iProc = 0; iProc < OSSyncGetProcessorCountMax(); iProc++ )
			{
			INST::PLS* const ppls = pinst->Ppls( iProc );
			ppls->m_blBegin0Commit0.Leave2();
			}
		}
#endif

	//	set all open cursor transaction levels to new level
	//
	FUCB	*pfucbNext;
	for ( pfucb = ppib->pfucbOfSession; pfucb != pfucbNil; pfucb = pfucbNext )
		{
		pfucbNext = pfucb->pfucbNextOfSession;

		if ( pfucb->levelOpen > ppib->level )
			{
			pfucb->levelOpen = ppib->level;
			}

		if ( FFUCBUpdatePrepared( pfucb ) )
			{
			// If update was prepared during this transaction, migrate the
			// update to the next lower level.
			Assert( pfucb->levelPrep <= ppib->level + 1 );
			if ( ppib->level + 1 == pfucb->levelPrep )
				{
				pfucb->levelPrep = ppib->level;
				}

			//	LV updates no longer allowed at level 0.  This assert detects
			//	any of the following illegal client actions:
			//		--	calling PrepareUpdate() at level 1, doing some
			//			LV operations, then calling CommitTransaction()
			//			before calling Update(), effectively causing the
			//			update to migrate to level 0.
			// 		--	called Update(), but the Update() failed
			//			(eg. errWriteConflict) and the client continued
			//			to commit the transaction anyway with the update
			//			still pending
			//		--	beginning a transaction at level 0 AFTER calling
			//			PrepareUpdate(), then committing the transaction
			//			BEFORE calling Update().
			AssertSz(
				ppib->level > 0 || !FFUCBInsertReadOnlyCopyPrepared( pfucb ),
				"Illegal attempt to migrate read-only copy to level 0." );
			AssertSz(
				ppib->level > 0 || !FFUCBUpdateSeparateLV( pfucb ),
				"Illegal attempt to migrate outstanding LV update(s) to level 0." );
			AssertSz(
				ppib->level > 0 || !rgfmp[pfucb->ifmp].FSLVAttached() || !pfucb->u.pfcb->Ptdb()->FTableHasSLVColumn(),
				"Illegal attempt to migrate update(s) to level 0 with SLV column present." );
			}

		//	set cursor navigation level for rollback support
		//
		Assert( PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering || LevelFUCBNavigate( pfucb ) <= ppib->level + 1 );
		if ( LevelFUCBNavigate( pfucb ) > ppib->level )
			{
			FUCBSetLevelNavigate( pfucb, ppib->level );
			}

		if ( fCommit0 )
			{
			//	if committing to level 0, ppib should have no more
			//	outstanding versions
			Assert( 0 == ppib->level );
			Assert( prceNil == ppib->prceNewest );
			FUCBResetVersioned( pfucb );

			if ( FFUCBDeferClosed( pfucb ) )
				FUCBCloseDeferredClosed( pfucb );
			}
		else
			{
			Assert( ppib->level > 0 );
			}
		}

	if ( fCommit0 )
		{
		PIBResetTrxBegin0( ppib );
		if ( !ppib->FUseSessionContextForTrxContext() )
			{
			PIBResetTrxContext( ppib );
			}
		}

HandleError:
	if( fSessionHasRCE )
		{
		ppib->critTrx.Leave();
		}

#ifdef DEBUG
	if ( fCommit0 )
		{
		Assert( err < 0 || 0 == ppib->level );
		}
	else
		{
		Assert( ppib->level > 0 );
		}
#endif

	return err;
	}


//	rolls back a transaction
//
ERR ErrDIRRollback( PIB *ppib )
	{
	ERR   		err = JET_errSuccess;
	FUCB		*pfucb;
	const BOOL	fRollbackToLevel0	= ( 1 == ppib->level );

	CheckPIB( ppib );
	Assert( ppib->level > 0 );
	INST		*pinst = PinstFromPpib( ppib );

	//	UNDONE: if we can guarantee that our clients are well-behaved, we don't
	//	need this check
	if ( !FPIBCheckTrxContext( ppib ) )
		{
		PIBReportSessionSharingViolation( ppib );
		FireWall();
		return ErrERRCheck( JET_errSessionSharingViolation );
		}

	if ( JET_errSuccess != ppib->ErrRollbackFailure() )
		{
		//	previous rollback error encountered, no further rollbacks permitted
		return ErrERRCheck( JET_errRollbackError );
		}

	//  perf stats

	if ( fRollbackToLevel0 )
		{
		if ( ppib->FBegin0Logged() )
			{
			ppib->FUserSession() ? cDIRUserRWTrxRollback0.Inc( pinst ) : cDIRSystemRWTrxRollback0.Inc( pinst );
			}
		else
			{
			ppib->FUserSession() ? cDIRUserROTrxRollback0.Inc( pinst ) : cDIRSystemROTrxRollback0.Inc( pinst );
			}
		}

	for ( pfucb = ppib->pfucbOfSession; pfucb != pfucbNil; pfucb = pfucb->pfucbNextOfSession )
		{
		Assert( pinst->FRecovering() || LevelFUCBNavigate( pfucb ) <= ppib->level );
		if ( LevelFUCBNavigate( pfucb ) == ppib->level )
			{
			FUCBSetLevelNavigate( pfucb, LEVEL( ppib->level - 1 ) );
			DIRBeforeFirst( pfucb );

			Assert( !FFUCBUpdatePrepared( pfucb ) ||
					pfucb->levelPrep == ppib->level );
			}

		//	reset copy buffer if prepared at transaction level
		//	which is being rolled back.
		//
		Assert( !FFUCBUpdatePrepared( pfucb ) ||
			pfucb->levelPrep <= ppib->level );
		if ( FFUCBUpdatePreparedLevel( pfucb, ppib->level ) )
			{
			//	reset update separate LV and copy buffer status
			//	all long value resources will be freed as a result of
			//	rollback and copy buffer status is reset
			//
			//	UNDONE: all updates should have already been cancelled
			//	in ErrIsamRollback(), but better to be safe than sorry,
			//	so just leave this code here
			RECIFreeCopyBuffer( pfucb );
			FUCBResetUpdateFlags( pfucb );
			}

		//	if LV cursor was opened at this level, close it
		//	UNDONE: identical logic exists at the IsamRollback
		//	level, but that didn't catch the case where we're
		//	in ErrRECSetLongField(), we create the LV tree,
		//	but the subsequent LV operation rolls back.  For
		//	now, it was just safest to duplicate the check in
		//	IsamRollback, but since the check is now done
		//	here, can I simply remove it from IsamRollback??
		if ( pfucbNil != pfucb->pfucbLV
			&& pfucb->pfucbLV->levelOpen >= ppib->level )
			{
			DIRClose( pfucb->pfucbLV );
			pfucb->pfucbLV = pfucbNil;
			}
		}

	//	UNDONE:	rollback may fail from resource failure so
	//			we must retry in order to assure success

	//	rollback changes made in transaction
	//
	err = ErrVERRollback( ppib );
	CallSx( err, JET_errRollbackError );
	CallR ( err );

	//	log rollback. Must be called after VERRollback to record
	//  the UNDO operations.  Do not handle error.
	//
	// during a force detach we don;t log the rollback as we haven't log
	// the undo operations
#ifdef INDEPENDENT_DB_FAILURE
	if ( ppib->m_ifmpForceDetach == ifmpMax )
#endif
		{
		err = ErrLGRollback( ppib, 1 );
		if ( err == JET_errLogWriteFail || err == JET_errDiskFull )
			{
			//	these error codes will lead to crash recovery which will
			//	rollback transaction.
			//
			err = JET_errSuccess;
			}
		CallS( err );
		}

#ifdef DEBUG
	if ( fRollbackToLevel0 )
		{
		Assert( 0 == ppib->level );

		//	if rolling back to level 0, ppib should have no more
		//	outstanding versions
		Assert( prceNil == ppib->prceNewest );
		}
	else
		{
		Assert( ppib->level > 0 );
		}
#endif

	//	if recovering then we are done. No need to close fucb since they are faked and
	//	not the same behavior as regular fucb which could be deferred.
	//
	if ( !pinst->FRecovering() )
		{
		//	if rollback to level 0 then close deferred closed cursors
		//	if cursor was opened at this level, close it
		//
		ENTERCRITICALSECTION	enterCritTrx( &ppib->critTrx );
		for ( pfucb = ppib->pfucbOfSession; pfucb != pfucbNil; )
			{
			FUCB * const	pfucbNext					= pfucb->pfucbNextOfSession;
			const BOOL		fOpenedInThisTransaction	= ( pfucb->levelOpen > ppib->level );
			const BOOL		fDeferClosed				= FFUCBDeferClosed( pfucb );

			if ( fRollbackToLevel0 )
				{
				//	if rolling back to level 0, ppib should have no more
				//	outstanding versions
				Assert( 0 == ppib->level );
				Assert( prceNil == ppib->prceNewest );
				FUCBResetVersioned( pfucb );
				}
			else
				{
				Assert( ppib->level > 0 );
				}

			if ( fOpenedInThisTransaction || fDeferClosed )
				{
				// A bookmark may still be outstanding if:
				//   1) Cursor opened in this transaction was
				//      not closed before rolling back.
				//   2) Bookmark was allocated by ErrVERIUndoLoggedOper()
				//		on a deferred-closed cursor.
				BTReleaseBM( pfucb );

				if ( fOpenedInThisTransaction || fRollbackToLevel0 )
					{
					//	pfucbTable is only set for LV and index cursors,
					//	and it should be impossible to get here with
					//	non-deferred-closed index cursors because they
					//	would have been closed in IsamRollback (it's
					//	possible to get here with open LV cursors
					//	because an internal transaction in which the
					//	LV cursor was opened may have failed)
					if ( !fDeferClosed
						&& FFUCBLongValue( pfucb )
						&& pfucbNil != pfucb->pfucbTable )
						{
						//	unlink table from LV cursor
						//
						Assert( pfcbNil != pfucb->u.pfcb );
						Assert( pfucb->u.pfcb->FTypeLV() );
						Assert( !Pcsr( pfucb )->FLatched() );
						Enforce( pfucb->pfucbTable->pfucbLV == pfucb );
						pfucb->pfucbTable->pfucbLV = pfucbNil;
						}
					else if ( pfucbNil != pfucb->pfucbTable )
						{
						Assert( fDeferClosed );
						Assert( FFUCBSecondary( pfucb )
							|| FFUCBLongValue( pfucb ) );
						}

					// Force-close cursor if it was open at this level (or higher).
					// or if we're dropping to level 0 and there are still deferred-
					// closed cursors.
					FUCBCloseDeferredClosed( pfucb );
					}
				}

			pfucb = pfucbNext;
			}
		}

	if ( fRollbackToLevel0 )
		{
		if ( pinst->FRecovering() )
			{
			for ( pfucb = ppib->pfucbOfSession; pfucb != pfucbNil; pfucb = pfucb->pfucbNextOfSession )
				{
				FUCBResetVersioned( pfucb );
				}
			}

		PIBResetTrxBegin0( ppib );
		if ( !ppib->FUseSessionContextForTrxContext() )
			{
			PIBResetTrxContext( ppib );
			}
		}

	return err;
	}


//	**********************************************************
//	******************* DIR Internal *************************
//	**********************************************************
//
//	*******************************************
//	DIR internal routines
//

//	checks index range
//	and sets currency if cursor is beyond boundaries
//
LOCAL ERR ErrDIRICheckIndexRange( FUCB *pfucb, const KEY& key )
	{
	ERR		err;

	err = ErrFUCBCheckIndexRange( pfucb, key );

	Assert( err >= 0 || err == JET_errNoCurrentRecord );
	if ( err == JET_errNoCurrentRecord )
		{
		if( Pcsr( pfucb )->FLatched() )
			{
			//  if we are called from ErrDIRCheckIndexRange the page may not be latched
			//  (we use the logical bookmark instead)
			DIRUp( pfucb );
			}

		if ( FFUCBUpper( pfucb ) )
			{
			DIRAfterLast( pfucb );
			}
		else
			{
			DIRBeforeFirst( pfucb );
			}
		}

	return err;
	}


//	cursor is refreshed
//	if cursor status is DeferMoveFirst,
//		go to first node in the CurrentIdx
//	refresh for other cases is handled at BT-level
//
LOCAL ERR ErrDIRIIRefresh( FUCB * const pfucb )
	{
	ERR		err;
	DIB		dib;
	FUCB 	* pfucbIdx;

 	Assert( locDeferMoveFirst == pfucb->locLogical );
	Assert( !Pcsr( pfucb )->FLatched() );

	if ( pfucb->pfucbCurIndex )
		{
		pfucbIdx = pfucb->pfucbCurIndex;
		}
	else
		{
		pfucbIdx = pfucb;
		}

	//	go to root of index
	//
	DIRGotoRoot( pfucbIdx );

	//	move to first child
	//
	dib.dirflag = fDIRNull;
	dib.pos		= posFirst;
	err = ErrBTDown( pfucbIdx, &dib, latchReadNoTouch );
	if ( err < 0 )
		{
		Assert( err != JET_errNoCurrentRecord );
		if ( JET_errRecordNotFound == err )
			{
			err = ErrERRCheck( JET_errNoCurrentRecord );
			}

		Assert( !Pcsr( pfucb )->FLatched() );
		pfucb->locLogical = locDeferMoveFirst;

		goto HandleError;
		}

	Assert( JET_errSuccess == err ||
			wrnBFPageFault == err ||
			wrnBFPageFlushPending == err ||
			wrnBFBadLatchHint == err );

	pfucbIdx->locLogical = locOnCurBM;

	if ( pfucbNil != pfucb->pfucbCurIndex )
		{
		//	go to primary key on primary index
		//
		BOOKMARK	bm;

		bm.data.Nullify();
		bm.key.prefix.Nullify();
		bm.key.suffix = pfucbIdx->kdfCurr.data;

		Call( ErrDIRGotoBookmark( pfucb, bm ) );
		}

	Call( ErrBTRelease( pfucbIdx ) );
	CallS( err );

HandleError:
	Assert( !Pcsr( pfucb )->FLatched() );
	Assert( JET_errRecordDeleted != err );
	Assert( JET_errRecordNotFound != err );
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\fldmod.cxx ===
#include "std.hxx"


LOCAL ERR ErrRECISetAutoincrement( FUCB *pfucb )
	{
	ERR				err				= JET_errSuccess;
	FUCB			* pfucbT		= pfucbNil;
	FCB				* pfcbT			= pfucb->u.pfcb;
	TDB				* const ptdbT	= pfcbT->Ptdb();
	const BOOL		fTemplateColumn	= ptdbT->FFixedTemplateColumn( ptdbT->FidAutoincrement() );
	const COLUMNID	columnidT		= ColumnidOfFid( ptdbT->FidAutoincrement(), fTemplateColumn );
	QWORD			qwT				= 0;
	ULONG			ulT;
	const BOOL		f8BytesAutoInc	= ptdbT->F8BytesAutoInc();
	ULONG			cbT;
	DATA			dataT;

	Assert( pfucb != pfucbNil );
	Assert( pfcbT != pfcbNil );

	Assert( !( pfcbT->FTypeSort()
			|| pfcbT->FTypeTemporaryTable() ) );	// Don't currently support autoinc with sorts/temp. tables

	//	If autoincrement is not yet initialized, query table to
	//	initialize autoincrement value.
	//
	if  ( ptdbT->QwAutoincrement() == 0 )
		{
		BOOL	fAbleToUseIndex		= fFalse;
		QWORD	qwAutoincrement		= 0;
		FDPINFO	fdpinfo				= { pfcbT->PgnoFDP(), pfcbT->ObjidFDP() };
		CHAR	szObjectName[JET_cbNameMost+1];

		Assert( 0 != columnidT );

		pfcbT->EnterDML();
		Assert( strlen( ptdbT->SzTableName() ) <= JET_cbNameMost );
		strcpy( szObjectName, ptdbT->SzTableName() );
		pfcbT->LeaveDML();

		//	Get new table cursor.
		//
		Call( ErrFILEOpenTable(
			pfucb->ppib,
			pfucb->ifmp,
			&pfucbT,
			szObjectName,
			NO_GRBIT,
			&fdpinfo ) );

		// Set updating latch, to freeze index list.
		Call( pfcbT->ErrSetUpdatingAndEnterDML( pfucb->ppib ) );

		//	Look for autoincrement column.  If found, look for index with
		//	first column as autoincrement column and seek on index to find
		//	maximum existing autoincrement column.  If no such index can be
		//	found, scan table for maximum existing autoincrement column.
		//
		FCB		*pfcbIdx;
		BOOL	fDescending = fFalse;
		
		pfcbT->AssertDML();
		for ( pfcbIdx = pfcbT->Pidb() == pidbNil ? pfcbT->PfcbNextIndex() : pfcbT;
			pfcbIdx != pfcbNil;
			pfcbIdx = pfcbIdx->PfcbNextIndex() )
			{
			if ( !pfcbIdx->FDeletePending() )
				{
				Assert( pfcbIdx->Pidb() != pidbNil );
				const IDXSEG*	rgidxseg = PidxsegIDBGetIdxSeg( pfcbIdx->Pidb(), ptdbT );
				if ( rgidxseg[0].Columnid() == columnidT )
					{
					if ( rgidxseg[0].FDescending() )
						fDescending = fTrue;
					break;
					}
				}
			}

		if  ( pfcbIdx != pfcbNil )
			{
			//	Seek on found index for maximum autoincrement value.
			//
			Assert( pfcbIdx->Pidb() != pidbNil );
			Assert( strlen( ptdbT->SzIndexName( pfcbIdx->Pidb()->ItagIndexName(), pfcbIdx->FDerivedIndex() ) ) <= JET_cbNameMost );
			strcpy(
				szObjectName,
				ptdbT->SzIndexName( pfcbIdx->Pidb()->ItagIndexName(), pfcbIdx->FDerivedIndex() ) );
			pfcbT->LeaveDML();

			// May not be able to use index if it's versioned.  In that case,
			// revert to clustered index scan.
			err = ErrIsamSetCurrentIndex(
						(JET_SESID)pfucb->ppib,
						(JET_VTID)pfucbT,
						szObjectName );

			// The open cursor in the index will prevent the index from being
			// deleted, so we no longer need the updating latch.
			pfcbT->ResetUpdating();

			if ( err < 0 )
				{
				if ( JET_errIndexNotFound != err )
					{
					goto HandleError;
					}
				}
			else
				{
				err = ErrIsamMove(
							(JET_SESID)pfucb->ppib,
							(JET_VTID)pfucbT,
							fDescending ? JET_MoveFirst : JET_MoveLast,
							NO_GRBIT );
				if	( err < 0 )
					{
					if ( err != JET_errNoCurrentRecord )
						goto HandleError;
						
					Assert( qwAutoincrement == 0 );
					}
				else
					{
					if ( !f8BytesAutoInc )
						{
						ULONG ulAutoincrement;
						ulAutoincrement = (ULONG)qwAutoincrement;
						Call( ErrIsamRetrieveColumn(
								(JET_SESID)pfucb->ppib,
								(JET_VTID)pfucbT,
								columnidT,
								&ulAutoincrement,
								sizeof(ulAutoincrement),
								&cbT,
								JET_bitRetrieveFromIndex,
								NULL ) );
						qwAutoincrement = ulAutoincrement;
						Assert( cbT == sizeof(ulAutoincrement) );
						}
					else
						{
						Call( ErrIsamRetrieveColumn(
								(JET_SESID)pfucb->ppib,
								(JET_VTID)pfucbT,
								columnidT,
								&qwAutoincrement,
								sizeof(qwAutoincrement),
								&cbT,
								JET_bitRetrieveFromIndex,
								NULL ) );
						Assert( cbT == sizeof(qwAutoincrement) );
						}
					}
				fAbleToUseIndex = fTrue;
				}
			}

		else
			{
			pfcbT->ResetUpdatingAndLeaveDML();
			}

		if ( !fAbleToUseIndex )
			{
			//	Scan clustered index for maximum autoincrement value.
			//
			Assert( 0 == qwAutoincrement );
			err = ErrIsamMove(
						(JET_SESID)pfucb->ppib,
						(JET_VTID)pfucbT,
						JET_MoveFirst,
						NO_GRBIT );
			while ( err >= 0 )
				{
				if ( !f8BytesAutoInc )
					{
					Call( ErrIsamRetrieveColumn(
								(JET_SESID)pfucb->ppib,
								(JET_VTID)pfucbT,
								columnidT,
								&ulT,
								sizeof(ulT),
								&cbT,
								NO_GRBIT,
								NULL ) );
					Assert( sizeof(ulT) == cbT );
					qwT = ulT;
					}
				else
					{
					Call( ErrIsamRetrieveColumn(
								(JET_SESID)pfucb->ppib,
								(JET_VTID)pfucbT,
								columnidT,
								&qwT,
								sizeof(qwT),
								&cbT,
								NO_GRBIT,
								NULL ) );
					Assert( sizeof(qwT) == cbT );
					}
				if	( qwT > qwAutoincrement )
					qwAutoincrement = qwT;
				err = ErrIsamMove(
							(JET_SESID)pfucb->ppib,
							(JET_VTID)pfucbT,
							JET_MoveNext,
							NO_GRBIT );
				}
			Assert( JET_errRecordNotFound != err );
			if ( JET_errNoCurrentRecord != err )
				goto HandleError;

			// error code will get cannibalised by SetColumn below
			}

		//	if there are no records in the table, then the first
		//	autoincrement value is 1.  Otherwise, set autoincrement
		//	to next value after maximum found.
		//
	   	qwAutoincrement++;

		//	at this point, we have a candidate ulAutoincrement for the table
		//	but we must record it in the table very carefully to avoid
		//	timing errors.
		//
		ptdbT->InitAutoincrement( qwAutoincrement );
		}

	//	set auto increment column in record
	//
	Call( ptdbT->ErrGetAndIncrAutoincrement( &qwT ) );
	Assert( qwT > 0 );

	if ( !f8BytesAutoInc )
		{
		ulT = (ULONG)qwT;
		dataT.SetPv( &ulT );
		dataT.SetCb( sizeof(ulT) );
		}
	else
		{
		dataT.SetPv( &qwT );
		dataT.SetCb( sizeof(qwT) );
		}
	
	if ( fTemplateColumn )
		{
		Assert( FCOLUMNIDTemplateColumn( columnidT ) );
		if ( !pfcbT->FTemplateTable() )
			{
			// Switch to template table.
			pfcbT->Ptdb()->AssertValidDerivedTable();
			pfcbT = pfcbT->Ptdb()->PfcbTemplateTable();
			}
		else
			{
			pfcbT->Ptdb()->AssertValidTemplateTable();
			}
		}
	else
		{
		Assert( !FCOLUMNIDTemplateColumn( columnidT ) );
		Assert( !pfcbT->FTemplateTable() );
		}

	pfcbT->EnterDML();
	err = ErrRECISetFixedColumn(
				pfucb,
				pfcbT->Ptdb(),
				columnidT,
				&dataT );
	pfcbT->LeaveDML();

HandleError:
	if ( pfucbT != pfucbNil )
		{
		CallS( ErrFILECloseTable( pfucbT->ppib, pfucbT ) );
		}

	return err;
	}

#ifdef RTM
#else // RTM
ERR ErrRECSessionWriteConflict( FUCB *pfucb )
	{
	FUCB	*pfucbT;

	AssertDIRNoLatch( pfucb->ppib );
	for ( pfucbT = pfucb->ppib->pfucbOfSession; pfucbT != pfucbNil; pfucbT = pfucbT->pfucbNextOfSession )
		{
		//	all cursors in the list should be owned by the same session
		Assert( pfucbT->ppib == pfucb->ppib );
		
		if ( pfucbT->ifmp == pfucb->ifmp
			&& FFUCBReplacePrepared( pfucbT )
			&& PgnoFDP( pfucbT ) == PgnoFDP( pfucb )
			&& pfucbT != pfucb
			&& 0 == CmpBM( pfucbT->bmCurr, pfucb->bmCurr ) )
			{
			CHAR		szSession[32];
			CHAR		szThreadID[16];
			CHAR		szDatabaseName[JET_cbNameMost+1];
			CHAR		szTableName[JET_cbNameMost+1];
			CHAR		szConflictTableID1[32];
			CHAR		szConflictTableID2[32];
			CHAR		szBookmarkLength[32];
			CHAR		pchBookmark[JET_cbBookmarkMost];
			DWORD 		cbRawData			= 0;
			const CHAR	* rgszT[7]			= { szSession, 
												szThreadID, 
												szDatabaseName, 
												szTableName,
												szConflictTableID1, 
												szConflictTableID2, 
												szBookmarkLength };

			sprintf( szSession, "0x%p", pfucb->ppib );
			sprintf( szThreadID, "0x%08lX", DwUtilThreadId() );
			sprintf( szDatabaseName, "%s", rgfmp[pfucb->ifmp].SzDatabaseName() );
			sprintf( szTableName, "%s", pfucb->u.pfcb->Ptdb()->SzTableName() );
			sprintf( szConflictTableID1, "0x%p", pfucb );
			sprintf( szConflictTableID2, "0x%p", pfucbT );
			sprintf( szBookmarkLength, "0x%lX/0x%lX",
				pfucb->bmCurr.key.prefix.Cb(), pfucb->bmCurr.key.suffix.Cb() );

			Assert( pfucb->bmCurr.key.Cb() < sizeof( pchBookmark ) );
			Assert( pfucb->bmCurr.data.FNull() );
			pfucb->bmCurr.key.CopyIntoBuffer(pchBookmark, sizeof(pchBookmark) );
			cbRawData = pfucb->bmCurr.key.Cb();
			
			UtilReportEvent(
					eventError,
					TRANSACTION_MANAGER_CATEGORY,
					SESSION_WRITE_CONFLICT_ID,
					7,
					rgszT,
					cbRawData,
					pchBookmark,
					PinstFromPfucb( pfucb ) );
			FireWall();
			return ErrERRCheck( JET_errSessionWriteConflict );
			}
		}

	return JET_errSuccess;
	}
#endif // RTM


ERR VTAPI ErrIsamPrepareUpdate( JET_SESID sesid, JET_VTID vtid, ULONG grbit )
	{
	ERR		err;
 	PIB *	ppib				= reinterpret_cast<PIB *>( sesid );
	FUCB *	pfucb				= reinterpret_cast<FUCB *>( vtid );
	BOOL	fFreeCopyBufOnErr	= fFalse;

	CallR( ErrPIBCheck( ppib ) );
	CheckFUCB( ppib, pfucb );
	Assert( ppib->level < levelMax );
	AssertDIRNoLatch( ppib );

	switch ( grbit )
		{
		case JET_prepCancel:
			if ( !FFUCBUpdatePrepared( pfucb ) )
				return ErrERRCheck( JET_errUpdateNotPrepared );

			if( FFUCBUpdateSeparateLV( pfucb ) )
				{
				//  rollback the operations we did while the update was prepared.
				//	on insert copy, also rollback refcount increments.
				Assert( updateidNil != pfucb->updateid );
				Assert( pfucb->ppib->level > 0 );
				err = ErrVERRollback( pfucb->ppib, pfucb->updateid );
				CallSx( err, JET_errRollbackError );
				Call ( err );
				}

			// Ensure empty LV buffer.  Don't put this check inside the
			// FFUCBUpdateSeparateLV() check above because we may have created
			// a copy buffer, but cancelled the SetColumn() (eg. write conflict)
			// before the LV was actually updated (before FUCBSetUpdateSeparateLV()
			// could be called).
			RECIFreeCopyBuffer( pfucb );
			FUCBResetUpdateFlags( pfucb );
			break;

		case JET_prepInsert:
			//	ensure that table is updatable
			//
			CallR( ErrFUCBCheckUpdatable( pfucb ) );
			CallR( ErrPIBCheckUpdatable( ppib ) );
			if ( FFUCBUpdatePrepared( pfucb ) )
				return ErrERRCheck( JET_errAlreadyPrepared );
			Assert( !FFUCBUpdatePrepared( pfucb ) );

			RECIAllocCopyBuffer( pfucb );
			fFreeCopyBufOnErr = fTrue;
			Assert( pfucb->pvWorkBuf != NULL );

			//	initialize record
			//
			Assert( pfucb != pfucbNil );
			Assert( pfucb->dataWorkBuf.Pv() != NULL );
			Assert( FFUCBIndex( pfucb ) || FFUCBSort( pfucb ) );

#ifdef PREREAD_INDEXES_ON_PREPINSERT
			if( pfucb->u.pfcb->FPreread() )
				{
				BTPrereadIndexesOfFCB( pfucb->u.pfcb );
				}
#endif	//	PREREAD_INDEXES_ON_PREPINSERT

			Assert( pfucb->u.pfcb != pfcbNil );
			pfucb->u.pfcb->EnterDML();
			
			if ( NULL == pfucb->u.pfcb->Ptdb()->PdataDefaultRecord() )
				{
				// Only temporary tables and system tables don't have default records
				// (ie. all "regular" tables have at least a minimal default record).
				Assert( ( FFUCBSort( pfucb ) && pfucb->u.pfcb->FTypeSort() )
					|| pfucb->u.pfcb->FTypeTemporaryTable()
					|| FCATSystemTable( pfucb->u.pfcb->Ptdb()->SzTableName() ) );
				pfucb->u.pfcb->LeaveDML();

				REC::SetMinimumRecord( pfucb->dataWorkBuf );
				}
			else
				{
				TDB		*ptdbT = pfucb->u.pfcb->Ptdb();
				BOOL	fBurstDefaultRecord;

				// Temp/sort tables and system tables don't have default records.
				Assert( !FFUCBSort( pfucb ) );
				Assert( !pfucb->u.pfcb->FTypeSort() );
				Assert( !pfucb->u.pfcb->FTypeTemporaryTable() );
				Assert( !FCATSystemTable( ptdbT->SzTableName() ) );

				Assert( ptdbT->PdataDefaultRecord()->Cb() >= REC::cbRecordMin );
				Assert( ptdbT->PdataDefaultRecord()->Cb() <= REC::CbRecordMax() );
				REC	*precDefault = (REC *)ptdbT->PdataDefaultRecord()->Pv();

				Assert( precDefault->FidFixedLastInRec() <= ptdbT->FidFixedLast() );
				Assert( precDefault->FidVarLastInRec() <= ptdbT->FidVarLast() );

				// May only burst default record if last fixed and
				// var columns in the default record are committed.
				// If they are versioned, there's a risk they might
				// be rolled back from underneath us.
				fBurstDefaultRecord = fTrue;
				if ( precDefault->FidFixedLastInRec() >= fidFixedLeast )
					{
					const FID	fid				= precDefault->FidFixedLastInRec();
					const BOOL	fTemplateColumn	= ptdbT->FFixedTemplateColumn( fid );
					FIELD		*pfield			= ptdbT->PfieldFixed( ColumnidOfFid( fid, fTemplateColumn ) );
					if ( FFIELDVersioned( pfield->ffield ) )
						fBurstDefaultRecord = fFalse;
					}
				if ( precDefault->FidVarLastInRec() >= fidVarLeast )
					{
					const FID	fid				= precDefault->FidVarLastInRec();
					const BOOL	fTemplateColumn	= ptdbT->FVarTemplateColumn( fid );
					FIELD		*pfield			= ptdbT->PfieldVar( ColumnidOfFid( fid, fTemplateColumn ) );
					if ( FFIELDVersioned( pfield->ffield ) )
						fBurstDefaultRecord = fFalse;
					}

				if ( fBurstDefaultRecord )
					{
					// Only burst fixed and variable column defaults.
					pfucb->dataWorkBuf.SetCb( precDefault->PbTaggedData() - (BYTE *)precDefault );
					Assert( pfucb->dataWorkBuf.Cb() >= REC::cbRecordMin );
					Assert( pfucb->dataWorkBuf.Cb() <= ptdbT->PdataDefaultRecord()->Cb() );
					UtilMemCpy( pfucb->dataWorkBuf.Pv(),
							(BYTE *)precDefault,
							pfucb->dataWorkBuf.Cb() );
					pfucb->u.pfcb->LeaveDML();
					}
				else
					{
					// Try bursting just the fixed columns.

					FID fidBurst;
					for ( fidBurst = precDefault->FidFixedLastInRec();
						fidBurst >= fidFixedLeast;
						fidBurst-- )
						{
						const BOOL	fTemplateColumn	= ptdbT->FFixedTemplateColumn( fidBurst );
						const FIELD	*pfield			= ptdbT->PfieldFixed( ColumnidOfFid( fidBurst, fTemplateColumn ) );
						if ( !FFIELDVersioned( pfield->ffield )
							&& !FFIELDDeleted( pfield->ffield ) )
							{
							break;
							}
						}
					if ( fidBurst >= fidFixedLeast )
						{
						BYTE	*pbRec	= (BYTE *)pfucb->dataWorkBuf.Pv();
						REC		*prec	= (REC *)pbRec;

						//  there is at least one non-versioned column. burst it
						Assert( fidBurst <= fidFixedMost );
						const INT	cFixedColumnsToBurst = fidBurst - fidFixedLeast + 1;
						Assert( cFixedColumnsToBurst > 0 );
						
						//  get the starting offset of the column ahead of this one
						//  add space for the column bitmap
						Assert( !ptdbT->FInitialisingDefaultRecord() );
						const INT	ibFixEnd = ptdbT->IbOffsetOfNextColumn( fidBurst );
						const INT	cbBitMap = ( cFixedColumnsToBurst + 7 ) / 8;
						const INT	cbFixedBurst = ibFixEnd + cbBitMap;
						pfucb->dataWorkBuf.SetCb( cbFixedBurst );

						Assert( pfucb->dataWorkBuf.Cb() >= REC::cbRecordMin );
						Assert( pfucb->dataWorkBuf.Cb() <= ptdbT->PdataDefaultRecord()->Cb() );

						//  copy the default record values
						UtilMemCpy( pbRec, (BYTE *)precDefault, cbFixedBurst );

						prec->SetFidFixedLastInRec( fidBurst );
						prec->SetFidVarLastInRec( fidVarLeast-1 );
						prec->SetIbEndOfFixedData( (USHORT)cbFixedBurst );

						//  set the fixed column bitmap
						BYTE	*pbDefaultBitMap	= precDefault->PbFixedNullBitMap();
						Assert( pbDefaultBitMap - (BYTE *)precDefault ==
							ptdbT->IbOffsetOfNextColumn( precDefault->FidFixedLastInRec() ) );
							
						UtilMemCpy( pbRec + ibFixEnd, pbDefaultBitMap, cbBitMap );

						//	must nullify bits for columns not in this record
						BYTE	*pbitNullity = pbRec + cbFixedBurst - 1;
						Assert( pbitNullity == pbRec + ibFixEnd + ( ( fidBurst - fidFixedLeast ) / 8 ) );
						
						for ( FID fidT = FID( fidBurst + 1 ); ; fidT++ )
							{
							const UINT	ifid = fidT - fidFixedLeast;

							if ( ( pbRec + ibFixEnd + ifid/8 ) != pbitNullity )
								{
								Assert( ( pbRec + ibFixEnd + ifid/8 ) == ( pbitNullity + 1 ) );
								break;
								}

							Assert( pbitNullity - pbRec < cbFixedBurst );
							Assert( fidT < fidBurst + 8 );
							SetFixedNullBit( pbitNullity, ifid );
							}

						pfucb->u.pfcb->LeaveDML();
						}
					else
						{
						// all fixed columns are versioned, or no fixed columns
						pfucb->u.pfcb->LeaveDML();

						// Start with an empty record.  Columns will be
						// burst on an as-needed basis.
						REC::SetMinimumRecord( pfucb->dataWorkBuf );
						}
					}
				}
				
			FUCBResetColumnSet( pfucb );

			//	if table has an autoincrement column, then set column
			//	value now so that it can be retrieved from copy buffer.
			//
			if ( pfucb->u.pfcb->Ptdb()->FidAutoincrement() != 0 )
				{
				Call( ErrRECISetAutoincrement( pfucb ) );
				}
			err = JET_errSuccess;
			PrepareInsert( pfucb );
			break;

		case JET_prepReplace:
			//	ensure that table is updatable
			//
			CallR( ErrFUCBCheckUpdatable( pfucb ) );
			CallR( ErrPIBCheckUpdatable( ppib ) );
			if ( FFUCBUpdatePrepared( pfucb ) )
				return ErrERRCheck( JET_errAlreadyPrepared );
			Assert( !FFUCBUpdatePrepared( pfucb ) );

			//	write lock node.  Note that ErrDIRGetLock also
			//	gets the current node, so no additional call to ErrDIRGet
			//	is required.
			//
			//	if locking at level 0 then goto JET_prepReplaceNoLock
			//	since lock cannot be acquired at level 0 and lock flag
			//	in fucb will prevent locking in update operation required
			//	for rollback.
			//
			if ( pfucb->ppib->level == 0 )
				{
				if( pfucb->u.pfcb->Ptdb()->FTableHasSLVColumn() )
					{
					AssertSz( fFalse, "cannot replace at level 0 with SLVs" );
					return ErrERRCheck( JET_errNotInTransaction );
					}
				goto ReplaceNoLock;
				}

			//	put assert to catch client's misbehavior. Make sure that
			//	no such sequence:
			//		PrepUpdate(t1) PrepUpdate(t2) Update(t1) Update(t2)
			//	where t1 and t2 happen to be on the same record and on the
			//	the same table. Client will experience lost update of t1 if
			//	they have such calling sequence.
			//
			Call( ErrRECSessionWriteConflict( pfucb ) );

			// Ensure we don't mistakenly set rceidBeginReplace.
			Assert( !FFUCBUpdateSeparateLV( pfucb ) );

			Call( ErrDIRGetLock( pfucb, writeLock ) );
			Call( ErrDIRGet( pfucb ) );

			if( prceNil != pfucb->ppib->prceNewest )
				pfucb->rceidBeginUpdate = pfucb->ppib->prceNewest->Rceid();
			else
				{
				Assert( rgfmp[pfucb->ifmp].FVersioningOff() );
				pfucb->rceidBeginUpdate = rceidNull;
				}

			RECIAllocCopyBuffer( pfucb );
			fFreeCopyBufOnErr = fTrue;
			Assert( pfucb->pvWorkBuf != NULL );
			pfucb->kdfCurr.data.CopyInto( pfucb->dataWorkBuf );

			Call( ErrDIRRelease( pfucb ) );
			FUCBResetColumnSet( pfucb );
			PrepareReplace( pfucb );
			break;

		case JET_prepReplaceNoLock:
			//	ensure that table is updatable
			//
			CallR( ErrFUCBCheckUpdatable( pfucb ) );
			CallR( ErrPIBCheckUpdatable( ppib ) );
			if ( FFUCBUpdatePrepared( pfucb ) )
				return ErrERRCheck( JET_errAlreadyPrepared );

ReplaceNoLock:
			Assert( !FFUCBUpdatePrepared( pfucb ) );
			
			//	put assert to catch client's misbehavior. Make sure that
			//	no such sequence:
			//		PrepUpdate(t1) PrepUpdate(t2) Update(t1) Update(t2)
			//	where t1 and t2 happen to be on the same record and on the
			//	the same table. Client will experience lost update of t1 if
			//	they have such calling sequence.
			//
			Call( ErrRECSessionWriteConflict( pfucb ) );

			Call( ErrDIRGet( pfucb ) );

			RECIAllocCopyBuffer( pfucb );
			fFreeCopyBufOnErr = fTrue;
			Assert( pfucb->pvWorkBuf != NULL );
			pfucb->kdfCurr.data.CopyInto( pfucb->dataWorkBuf );

			pfucb->rceidBeginUpdate = RCE::RceidLast();

			FUCBResetColumnSet( pfucb );

			if ( pfucb->ppib->level == 0 )
				{
				StoreChecksum( pfucb );
				}
			else
				{
				FUCBSetDeferredChecksum( pfucb );
				}

			Call( ErrDIRRelease( pfucb ) );
			PrepareReplaceNoLock( pfucb );
			break;

		case JET_prepInsertCopy:
		case JET_prepInsertCopyWithoutSLVColumns:
		case JET_prepInsertCopyDeleteOriginal:
			//	ensure that table is updatable
			//
			CallR( ErrFUCBCheckUpdatable( pfucb ) );
			CallR( ErrPIBCheckUpdatable( ppib ) );
			if ( FFUCBUpdatePrepared( pfucb ) )
				return ErrERRCheck( JET_errAlreadyPrepared );
			Assert( !FFUCBUpdatePrepared( pfucb ) );

			if( JET_prepInsertCopyDeleteOriginal == grbit )
				{
				Call( ErrDIRGetLock( pfucb, writeLock ) );
				}
			
			Call( ErrDIRGet( pfucb ) );

			RECIAllocCopyBuffer( pfucb );
			fFreeCopyBufOnErr = fTrue;
			Assert( pfucb->pvWorkBuf != NULL );
			pfucb->kdfCurr.data.CopyInto( pfucb->dataWorkBuf );
			Assert( !pfucb->dataWorkBuf.FNull() );

			Call( ErrDIRRelease( pfucb ) );
			FUCBResetColumnSet( pfucb );

			//	if table has an autoincrement column, then set column
			//	value now so that it can be retrieved from copy
			//	buffer.
			//
			if ( pfucb->u.pfcb->Ptdb()->FidAutoincrement() != 0 )
				{
				Call( ErrRECISetAutoincrement( pfucb ) );
				}
				
			if ( grbit == JET_prepInsertCopyDeleteOriginal )
				{
				PrepareInsertCopyDeleteOriginal( pfucb );
				}
			else
				{
				PrepareInsertCopy( pfucb );

				//	increment reference count on long values
				//	and remove all SLVs
				//
				Assert( updateidNil == ppib->updateid );		// should not be nested
				PIBSetUpdateid( ppib, pfucb->updateid );
				err = ErrRECAffectLongFieldsInWorkBuf( pfucb, lvaffectReferenceAll );
#ifdef DISABLE_SLV
#else
				if ( err >= 0 && JET_prepInsertCopyWithoutSLVColumns != grbit )
					{
					err = ErrRECCopySLVsInRecord( pfucb );
					}
#endif
				PIBSetUpdateid( ppib, updateidNil );
				if ( err < 0 )
					{
					FUCBResetUpdateFlags( pfucb );
					goto HandleError;
					}
				}
			break;

		case JET_prepReadOnlyCopy:
			if ( FFUCBUpdatePrepared( pfucb ) )
				return ErrERRCheck( JET_errAlreadyPrepared );
			Assert( !FFUCBUpdatePrepared( pfucb ) );

			if( 0 == pfucb->ppib->level )
				{
				return ErrERRCheck( JET_errNotInTransaction );
				}

				
			Call( ErrDIRGet( pfucb ) );

			RECIAllocCopyBuffer( pfucb );
			fFreeCopyBufOnErr = fTrue;
			Assert( pfucb->pvWorkBuf != NULL );
			pfucb->kdfCurr.data.CopyInto( pfucb->dataWorkBuf );
			Assert( !pfucb->dataWorkBuf.FNull() );

			Call( ErrDIRRelease( pfucb ) );
			FUCBResetColumnSet( pfucb );
			
			PrepareInsertReadOnlyCopy( pfucb );
			break;

		default:
			err = ErrERRCheck( JET_errInvalidParameter );
			goto HandleError;
		}

	CallS( err );
	AssertDIRNoLatch( ppib );
	return err;

HandleError:
	Assert( err < 0 );
	if ( fFreeCopyBufOnErr )
		{
		RECIFreeCopyBuffer( pfucb );
		}
	AssertDIRNoLatch( ppib );
	return err;
	}

	
ERR ErrRECICheckUniqueNormalizedTaggedRecordData(
	const FIELD *				pfield,
	const DATA&					dataFieldNorm,
	const DATA&					dataRecRaw,
	const IDXUNICODE * const	pidxunicode,
	const BOOL					fNormDataFieldTruncated )
	{
	ERR							err;
	DATA						dataRecNorm;
	BYTE						rgbRecNorm[KEY::cbKeyMax];
	BOOL						fNormDataRecTruncated;

	Assert( NULL != pfield );

	dataRecNorm.SetPv( rgbRecNorm );
	CallR( ErrFLDNormalizeTaggedData(
				pfield,
				dataRecRaw,
				dataRecNorm,
				pidxunicode,
				&fNormDataRecTruncated ) );

	CallS( err );		//	shouldn't get warnings

	if ( FDataEqual( dataFieldNorm, dataRecNorm ) )
		{
		//	since data is equal, they should either both be truncated or both not truncated
		if ( fNormDataFieldTruncated || fNormDataRecTruncated )
			{
			Assert( fNormDataFieldTruncated );
			Assert( fNormDataRecTruncated );
			err = ErrERRCheck( JET_errMultiValuedDuplicateAfterTruncation );
			}
		else
			{
			Assert( !fNormDataFieldTruncated );
			Assert( !fNormDataRecTruncated );
			err = ErrERRCheck( JET_errMultiValuedDuplicate );
			}
		}

	return err;
	}


LOCAL ERR ErrRECICheckUniqueLVMultiValues(
	FUCB			* const pfucb,
	const COLUMNID	columnid,
	const ULONG		itagSequence,
	const DATA&		dataToSet,
	BYTE			* rgbLVData = NULL,
	const BOOL		fNormalizedDataToSetIsTruncated = fFalse )
	{
	ERR				err;
	FCB				* const pfcb	= pfucb->u.pfcb;
	const BOOL		fNormalize		= ( NULL != rgbLVData );
	DATA			dataRetrieved;
	ULONG			itagSequenceT	= 0;

	Assert( FCOLUMNIDTagged( columnid ) );
	Assert( pfcbNil != pfcb );
	Assert( ptdbNil != pfcb->Ptdb() );

#ifdef DEBUG
	pfcb->EnterDML();
	Assert( FRECLongValue( pfcb->Ptdb()->PfieldTagged( columnid )->coltyp ) );
	pfcb->LeaveDML();
#endif

	forever
		{
		itagSequenceT++;
		if ( itagSequenceT != itagSequence )
			{
			CallR( ErrRECIRetrieveTaggedColumn(
					pfcb,
					columnid,
					itagSequenceT,
					pfucb->dataWorkBuf,
					&dataRetrieved,
					JET_bitRetrieveIgnoreDefault | grbitRetrieveColumnDDLNotLocked ) );

			if ( wrnRECSeparatedLV == err )
				{
				if ( fNormalize )
					{
					ULONG	cbActual;
					CallR( ErrRECRetrieveSLongField(
								pfucb,
								LidOfSeparatedLV( dataRetrieved ),
								fTrue,
								0,
								rgbLVData,
								KEY::cbKeyMax,
								&cbActual ) );
					dataRetrieved.SetPv( rgbLVData );
					dataRetrieved.SetCb( min( cbActual, KEY::cbKeyMax ) );

					pfcb->EnterDML();
					err = ErrRECICheckUniqueNormalizedTaggedRecordData(
									pfcb->Ptdb()->PfieldTagged( columnid ),
									dataToSet,
									dataRetrieved,
									&PinstFromPfucb( pfucb )->m_idxunicodeDefault,
									fNormalizedDataToSetIsTruncated );
					pfcb->LeaveDML();
					CallR( err );
					}
				else
					{
					CallR( ErrRECRetrieveSLongField(
								pfucb,
								LidOfSeparatedLV( dataRetrieved ),
								fTrue,
								0,
								(BYTE *)dataToSet.Pv(),
								dataToSet.Cb(),
								NULL ) );				//	pass NULL to force comparison instead of retrieval
					}
				}
			else if ( wrnRECIntrinsicLV == err )
				{
				if ( fNormalize )
					{
					pfcb->EnterDML();
					err = ErrRECICheckUniqueNormalizedTaggedRecordData(
									pfcb->Ptdb()->PfieldTagged( columnid ),
									dataToSet,
									dataRetrieved,
									&PinstFromPfucb( pfucb )->m_idxunicodeDefault,
									fNormalizedDataToSetIsTruncated );
					pfcb->LeaveDML();
					CallR( err );
					}
				else if ( FDataEqual( dataToSet, dataRetrieved ) )
					{
					return ErrERRCheck( JET_errMultiValuedDuplicate );
					}
				}
			else
				{
				Assert( JET_wrnColumnNull == err
					|| ( wrnRECUserDefinedDefault == err && 1 == itagSequenceT ) );
				break;
				}
			}
		}

	return JET_errSuccess;
	}

LOCAL ERR ErrRECICheckUniqueNormalizedLVMultiValues(
	FUCB			* const pfucb,
	const COLUMNID	columnid,
	const ULONG		itagSequence,
	const DATA&		dataToSet )
	{
	ERR				err;
	FCB				* const pfcb				= pfucb->u.pfcb;
	DATA			dataToSetNorm;
	BYTE			rgbDataToSetNorm[KEY::cbKeyMax];
	BYTE			rgbLVData[KEY::cbKeyMax];
	BOOL			fNormalizedDataToSetIsTruncated;

	Assert( FCOLUMNIDTagged( columnid ) );
	Assert( pfcbNil != pfcb );
	Assert( ptdbNil != pfcb->Ptdb() );

	dataToSetNorm.SetPv( rgbDataToSetNorm );

	pfcb->EnterDML();
	Assert( FRECLongValue( pfcb->Ptdb()->PfieldTagged( columnid )->coltyp ) );
	err = ErrFLDNormalizeTaggedData(
				pfcb->Ptdb()->PfieldTagged( columnid ),
				dataToSet,
				dataToSetNorm,
				&PinstFromPfucb( pfucb )->m_idxunicodeDefault,
				&fNormalizedDataToSetIsTruncated );
	pfcb->LeaveDML();

	CallR( err );

	return ErrRECICheckUniqueLVMultiValues(
				pfucb,
				columnid,
				itagSequence,
				dataToSetNorm,
				rgbLVData,
				fNormalizedDataToSetIsTruncated );
	}


LOCAL ERR ErrFLDSetOneColumn(
	FUCB 		*pfucb,
	COLUMNID	columnid,
	DATA		*pdataField,
	ULONG		itagSequence,
	ULONG		ibLongValue,
	ULONG		grbit )
	{
	ERR			err;
	FCB			*pfcb						= pfucb->u.pfcb;
	BOOL		fEnforceUniqueMultiValues	= fFalse;

	if ( grbit & ( JET_bitSetUniqueMultiValues|JET_bitSetUniqueNormalizedMultiValues) )
		{
		if ( grbit & ( JET_bitSetAppendLV|JET_bitSetOverwriteLV|JET_bitSetSizeLV ) )
			{
			//	cannot currently combine JET_bitSetUniqueMultiValues with other grbits
			err = ErrERRCheck( JET_errInvalidGrbit );
			return err;
			}
		else if ( NULL == pdataField->Pv() || 0 == pdataField->Cb() )
			{
			if ( grbit & JET_bitSetZeroLength )
				fEnforceUniqueMultiValues = fTrue;
			}
		else
			{
			fEnforceUniqueMultiValues = fTrue;
			}
		}

	if ( ( grbit & grbitSetColumnInternalFlagsMask )
		|| ( grbit & JET_bitSetSLVFromSLVInfo ) )		// JET_bitSetSLVFromSLVInfo is for internal use only

		{
		err = ErrERRCheck( JET_errInvalidGrbit );
		return err;
		}
		
	Assert( !(grbit & JET_bitSetSLVFromSLVInfo) );

		// Verify column is visible to us.
	CallR( ErrRECIAccessColumn( pfucb, columnid ) );

	// If pv is NULL, cb should be 0, except if SetSizeLV is specified.
	if ( pdataField->Pv() == NULL && !( grbit & JET_bitSetSizeLV ) )
		pdataField->SetCb( 0 );

	//	Return error if version or autoinc column is being set.  We don't
	//	need to grab the FCB critical section -- since we can see the
	//	column, we're guaranteed the FID won't be deleted or rolled back.
	if ( FCOLUMNIDFixed( columnid ) )
		{
#ifdef DEBUG
		FIELDFLAG	ffield;

		pfcb->EnterDML();
		ffield = pfcb->Ptdb()->PfieldFixed( columnid )->ffield;
		pfcb->LeaveDML();

		Assert( !( FFIELDVersion( ffield ) && FFIELDAutoincrement( ffield ) ) );
#endif

		if ( pfcb->Ptdb()->FidVersion() == FidOfColumnid( columnid ) )
			{
			Assert( pfcb->Ptdb()->FidAutoincrement() != FidOfColumnid( columnid ) );	// Assert mutual-exclusivity.
			Assert( FFIELDVersion( ffield ) );

			// Cannot set a Version field during a replace.
			if ( FFUCBReplacePrepared( pfucb ) )
				return ErrERRCheck( JET_errInvalidColumnType );
			}
		else if ( pfcb->Ptdb()->FidAutoincrement() == FidOfColumnid( columnid ) )
			{
			Assert( FFIELDAutoincrement( ffield ) );

			// Can never set an AutoInc field.
			return ErrERRCheck( JET_errInvalidColumnType );
			}
		}

	else if ( FCOLUMNIDTagged( columnid ) )		// check for long value
		{
		pfcb->EnterDML();
		
		const FIELD	*pfield				= pfcb->Ptdb()->PfieldTagged( columnid );
		const BOOL	fLongValue			= FRECLongValue( pfield->coltyp );
		const BOOL	fSLV				= FRECSLV( pfield->coltyp );
		const ULONG	cbMaxLen			= pfield->cbMaxLen;

		pfcb->LeaveDML();
		
		if ( fSLV )
			{
			//	UniqueMultiValues check over SLV columns is currently not supported
			//	in RETAIL, ErrSLVSetColumn() will err out with JET_errInvalidGrbit
			Assert( !fEnforceUniqueMultiValues );

			//  set the SLV column

			err = ErrSLVSetColumn(	pfucb,
									columnid,
									itagSequence,
									ibLongValue,
									grbit,
									pdataField );

			//  we're done
			
			goto HandleError;
			}
			
		if ( fLongValue )
			{
			if ( FFUCBInsertCopyDeleteOriginalPrepared( pfucb ) )
				{
				//	UNDONE:	cannot currently update LV's in an
				//	InsertCopyDeleteOriginal because of LV visibility
				//	problems (similar to Replace - we would need
				//	an rceidBeginUpdate in the RCE of the insert
				//	so that concurrent create index would be
				//	able to find the proper LV before-image)
				AssertSz( fFalse, "Illegal attempt to update a Long Value column in an InsertCopyDeleteOriginal update." );
				Call( ErrERRCheck( JET_errColumnNotUpdatable ) );
				}

			if ( fEnforceUniqueMultiValues )
				{
				if ( grbit & JET_bitSetUniqueNormalizedMultiValues )
					{
					Call( ErrRECICheckUniqueNormalizedLVMultiValues(
								pfucb,
								columnid,
								itagSequence,
								*pdataField ) );
					}
				else
					{
					Call( ErrRECICheckUniqueLVMultiValues(
								pfucb,
								columnid,
								itagSequence,
								*pdataField ) );
					}
				}


			err = ErrRECSetLongField(
				pfucb,
				columnid,
				itagSequence,
				pdataField,
				grbit,
				ibLongValue,
				cbMaxLen );

			//	if column does not fit then try to separate long values
			//	and try to set column again.
			//
			if ( JET_errRecordTooBig == err )
				{
				Call( ErrRECAffectLongFieldsInWorkBuf( pfucb, lvaffectSeparateAll ) );
				err = ErrRECSetLongField(
					pfucb,
					columnid,
					itagSequence,
					pdataField,
					grbit,
					ibLongValue,
					cbMaxLen );
				}

			goto HandleError;
			}
		}


	//	do the actual column operation
	//

	//	setting value to NULL
	//
	if ( pdataField->Cb() == 0 && !( grbit & JET_bitSetZeroLength ) )
		pdataField = NULL;

	Assert( !( grbit & grbitSetColumnInternalFlagsMask ) );

	err = ErrRECSetColumn( pfucb, columnid, itagSequence, pdataField, grbit );
	if ( err == JET_errRecordTooBig )
		{
		Call( ErrRECAffectLongFieldsInWorkBuf( pfucb, lvaffectSeparateAll ) );
		err = ErrRECSetColumn( pfucb, columnid, itagSequence, pdataField, grbit );
		}

HandleError:
	AssertDIRNoLatch( pfucb->ppib );
	return err;
	}



//+API
//	ErrIsamSetColumn
//	========================================================================
//	ErrIsamSetColumn( PIB *ppib, FUCB *pfucb, FID fid, ULONG itagSequence, DATA *pdataField, JET_GRBIT grbit )
//
//	Adds or changes a column value in the record being worked on.
//	Fixed and variable columns are replaced if they already have values.
//	A sequence number must be given for tagged columns.  If this is zero,
//	a new tagged column occurance is added to the record.  If not zero, it
//	specifies the occurance to change.
//	A working buffer is allocated if there isn't one already.
//	If fNewBuf == fTrue, the buffer is initialized with the default values
//	for the columns in the record.  If fNewBuf == fFalse, and there was
//	already a working buffer, it is left unaffected;	 if a working buffer
//	had to be allocated, then this new working buffer will be initialized
//	with either the column values of the current record, or the default column
//	values (if the user's currency is not on a record).
//
//	PARAMETERS	ppib			PIB of user
//				pfucb			FUCB of data file to which this record
//								is being added/updated.
//				fid				column id: which column to set
//				itagSequence 	Occurance number (for tagged columns):
//								which occurance of the column to change
//								If zero, it means "add a new occurance"
//				pdataField		column data to use
//				grbit 			If JET_bitSetZeroLength, the column is set to size 0.
//
//	RETURNS		Error code, one of:
//					 JET_errSuccess				Everything worked.
//					-JET_errOutOfBuffers		Failed to allocate a working
//												buffer
//					-JET_errInvalidBufferSize
//
//					-ColumnInvalid				The column id given does not
//												corresponding to a defined column
//					-NullInvalid			  	An attempt was made to set a
//												column to NULL which is defined
//												as NotNull.
//					-JET_errRecordTooBig		There is not enough room in
//												the record for new column.
//	COMMENTS 	The GET and DELETE commands discard the working buffer
//				without writing it to the database.	 The REPLACE and INSERT
//				commands may be used to write the working buffer to the
//				database, but they also discard it when finished (the INSERT
//				command can be told not to discard it, though;	this is
//				useful for adding several similar records).
//				For tagged columns, if the data given is NULL-valued, then the
//				tagged column occurance specified is deleted from the record.
//				If there is no tagged column occurance corresponding to the
//				specified occurance number, a new tagged column is added to
//				the record, and assumes the new highest occurance number
//				(unless the data given is NULL-valued, in which case the
//				record is unaffected).
//-
ERR VTAPI ErrIsamSetColumn(
	JET_SESID		sesid,
	JET_VTID		vtid,
	JET_COLUMNID	columnid,
	const VOID*		pvData,
	const ULONG 	cbData,
	ULONG	  		grbit,
	JET_SETINFO*	psetinfo )
	{
	ERR				err;
 	PIB*			ppib		= reinterpret_cast<PIB *>( sesid );
	FUCB*			pfucb		= reinterpret_cast<FUCB *>( vtid );
	DATA	  		dataField;
	ULONG	  		itagSequence;
	ULONG			ibLongValue;

	// check for updatable table
	//
	CallR( ErrFUCBCheckUpdatable( pfucb ) );
	CallR( ErrPIBCheckUpdatable( ppib ) );

	CallR( ErrPIBCheck( ppib ) );
	CheckFUCB( ppib, pfucb );
	AssertDIRNoLatch( ppib );

	if ( !FFUCBSetPrepared( pfucb ) )
		return ErrERRCheck( JET_errUpdateNotPrepared );

	//  remember which update we are part of (save off session's current
	//	updateid because we may be nested if the top-level SetColumn()
	//	causes catalog updates when creating LV tree).
	const UPDATEID	updateidSave	= ppib->updateid;
	PIBSetUpdateid( ppib, pfucb->updateid );

	if ( psetinfo != NULL )
		{
		if ( psetinfo->cbStruct < sizeof(JET_SETINFO) )
			{
			err = ErrERRCheck( JET_errInvalidParameter );
			goto HandleError;
			}
		itagSequence = psetinfo->itagSequence;
		ibLongValue = psetinfo->ibLongValue;
		}
	else
		{
		itagSequence = 1;
		ibLongValue = 0;
		}

	dataField.SetPv( (VOID *)pvData );
	dataField.SetCb( cbData );

	err = ErrFLDSetOneColumn(
				pfucb,
				columnid,
				&dataField,
				itagSequence,
				ibLongValue,
				grbit );

HandleError:
	PIBSetUpdateid( ppib, updateidSave );
	AssertDIRNoLatch( ppib );
	return err;
	}


ERR VTAPI ErrIsamSetColumns(
	JET_SESID		vsesid,
	JET_VTID		vtid,
	JET_SETCOLUMN	*psetcols,
	unsigned long	csetcols )
	{
	ERR	 			err;
	PIB				*ppib = (PIB *)vsesid;
	FUCB			*pfucb = (FUCB *)vtid;
	ULONG			ccols;
	DATA			dataField;
	JET_SETCOLUMN	*psetcolcurr;

	// check for updatable table
	//
	CallR( ErrFUCBCheckUpdatable( pfucb ) );
	CallR( ErrPIBCheckUpdatable( ppib ) );

	CallR( ErrPIBCheck( ppib ) );
	AssertDIRNoLatch( ppib );
	CheckFUCB( ppib, pfucb );

	if ( !FFUCBSetPrepared( pfucb ) )
		return ErrERRCheck( JET_errUpdateNotPrepared );

	//  remember which update we are part of (save off session's current
	//	updateid because we may be nested if the top-level SetColumn()
	//	causes catalog updates when creating LV tree).
	const UPDATEID	updateidSave	= ppib->updateid;
	PIBSetUpdateid( ppib, pfucb->updateid );

	for ( ccols = 0; ccols < csetcols ; ccols++ )
		{
		psetcolcurr = psetcols + ccols;

		dataField.SetPv( (VOID *)psetcolcurr->pvData );
		dataField.SetCb( psetcolcurr->cbData );

		Call( ErrFLDSetOneColumn(
			pfucb,
			psetcolcurr->columnid,
			&dataField,
			psetcolcurr->itagSequence,
			psetcolcurr->ibLongValue,
			psetcolcurr->grbit ) );
		psetcolcurr->err = err;
		}

HandleError:
	PIBSetUpdateid( ppib, updateidSave );

	AssertDIRNoLatch( ppib );
	return err;
	}


ERR ErrRECSetDefaultValue( FUCB *pfucbFake, const COLUMNID columnid, VOID *pvDefault, ULONG cbDefault )
	{
	ERR		err;
	DATA	dataField;
	TDB		*ptdb		= pfucbFake->u.pfcb->Ptdb();

	Assert( pfucbFake->u.pfcb->FTypeTable() );
	Assert( pfucbFake->u.pfcb->FFixedDDL() );

	dataField.SetPv( pvDefault );
	dataField.SetCb( cbDefault );

	if ( FRECLongValue( ptdb->Pfield( columnid )->coltyp ) )
		{
		Assert( FCOLUMNIDTagged( columnid ) );
		Assert( FidOfColumnid( columnid ) <= ptdb->FidTaggedLast() );

		//	max. default long value is cbLVIntrinsicMost-1 (one byte
		//	reserved for fSeparated flag).
		Assert( JET_cbLVDefaultValueMost < cbLVIntrinsicMost );

		if ( cbDefault > JET_cbLVDefaultValueMost )
			{
			err = ErrERRCheck( JET_errDefaultValueTooBig );
			}
		else
			{
			DATA dataNullT;
			dataNullT.Nullify();

#ifdef INTRINSIC_LV
			BYTE rgb[JET_cbLVDefaultValueMost];
			err = ErrRECAOIntrinsicLV(
						pfucbFake,
						columnid,
						NO_ITAG,		// itagSequence == 0 to force new column
						&dataNullT,
						&dataField,
						0,
						lvopInsert,
						rgb );
#else // INTRINSIC_LV
			err = ErrRECAOIntrinsicLV(
						pfucbFake,
						columnid,
						NO_ITAG,		// itagSequence == 0 to force new column
						&dataNullT,
						&dataField,
						0,
						lvopInsert );
#endif // INTRINSIC_LV						
			}
		}
	else
		{
		err = ErrRECSetColumn( pfucbFake, columnid, NO_ITAG, &dataField );
		if ( JET_errColumnTooBig == err )
			{
			err = ErrERRCheck( JET_errDefaultValueTooBig );
			}
		}

	return err;
	}


ERR ErrRECISetFixedColumn(
	FUCB			* const pfucb,
	TDB				* const ptdb,
	const COLUMNID	columnid,
	DATA			*pdataField )
	{
	const FID		fid			= FidOfColumnid( columnid );

	Assert( FFixedFid( fid ) );

	Assert( pfucbNil != pfucb );
	Assert( FFUCBIndex( pfucb ) || FFUCBSort( pfucb ) );

	INT			cbRec = pfucb->dataWorkBuf.Cb();
	Assert( cbRec >= REC::cbRecordMin );
	Assert( cbRec <= REC::CbRecordMax() );

	BYTE		*pbRec = (BYTE *)pfucb->dataWorkBuf.Pv();
	REC			*prec = (REC *)pbRec;
	Assert( precNil != prec );

	if ( fid > ptdb->FidFixedLast() || fid < ptdb->FidFixedFirst() )
		{
		//	this should be impossible, because the columnid
		//	should already have been validated by this point
		//
		Assert( fFalse );
		return ErrERRCheck( JET_errColumnNotFound );
		}

	FIELD		*pfield = ptdb->PfieldFixed( columnid );
	Assert( pfieldNil != pfield );
	if ( JET_coltypNil == pfield->coltyp )
		{
		//	this should be impossible, because the columnid
		//	should already have been validated by this point
		//
		Assert( fFalse );
		return ErrERRCheck( JET_errColumnNotFound );
		}

	//	record the fact that this column has been changed
	//
	FUCBSetColumnSet( pfucb, fid );

	//	column not represented in record? Make room, make room
	//
	if ( fid > prec->FidFixedLastInRec() )
		{
		const FID	fidFixedLastInRec		= prec->FidFixedLastInRec();
		FID			fidLastDefaultToBurst;
		FID			fidT;
		
		if ( ( NULL == pdataField || pdataField->FNull() )
			&& FFIELDNotNull( pfield->ffield ) )
			{
			return ErrERRCheck( JET_errNullInvalid );
			}

		// Verify there's at least one more fid beyond fidFixedLastInRec,
		// thus enabling us to reference the FIELD structure of the fid
		// beyond fidFixedLastInRec.
		Assert( fidFixedLastInRec < ptdb->FidFixedLast() );

		//	compute room needed for new column and bitmap
		//
		const WORD	ibOldFixEnd		= WORD( prec->PbFixedNullBitMap() - pbRec );
		const WORD	ibOldBitMapEnd	= prec->IbEndOfFixedData();
		const INT	cbOldBitMap		= ibOldBitMapEnd - ibOldFixEnd;
		Assert( ibOldBitMapEnd >= ibOldFixEnd );
		Assert(	ibOldFixEnd == ptdb->IbOffsetOfNextColumn( fidFixedLastInRec ) );
		Assert( ibOldBitMapEnd == ibOldFixEnd + cbOldBitMap );
		Assert( cbOldBitMap == prec->CbFixedNullBitMap() );

		const WORD	ibNewFixEnd		= WORD( pfield->ibRecordOffset + pfield->cbMaxLen );
		const INT	cbNewBitMap		= ( ( fid - fidFixedLeast + 1 ) + 7 ) / 8;
		const WORD	ibNewBitMapEnd	= WORD( ibNewFixEnd + cbNewBitMap );
		const INT	cbShift			= ibNewBitMapEnd - ibOldBitMapEnd;
		Assert( ibNewFixEnd == ptdb->IbOffsetOfNextColumn( fid ) );
		Assert( ibNewFixEnd > ibOldFixEnd );
		Assert( cbNewBitMap >= cbOldBitMap );
		Assert( ibNewBitMapEnd > ibOldBitMapEnd );
		Assert( cbShift > 0 );

		if ( cbRec + cbShift > cbRECRecordMost )
			return ErrERRCheck( JET_errRecordTooBig );

		//	shift rest of record over to make room
		//
		Assert( cbRec >= ibOldBitMapEnd );
		memmove(
			pbRec + ibNewBitMapEnd,
			pbRec + ibOldBitMapEnd,
			cbRec - ibOldBitMapEnd );

#ifdef DEBUG
		memset( pbRec + ibOldBitMapEnd, chRECFill, cbShift );
#endif

		pfucb->dataWorkBuf.DeltaCb( cbShift );
		cbRec = pfucb->dataWorkBuf.Cb();

		// set new location of variable/tagged data
		prec->SetIbEndOfFixedData( ibNewBitMapEnd );
		
		//	shift fixed column bitmap over
		//
		memmove(
			pbRec + ibNewFixEnd,
			pbRec + ibOldFixEnd,
			cbOldBitMap );

#ifdef DEBUG
		memset( pbRec + ibOldFixEnd, chRECFill, ibNewFixEnd - ibOldFixEnd );
#endif

		//	clear all new bitmap bits
		//

		// If there's at least one fixed column currently in the record,
		// find the nullity bit for the last fixed column and clear the
		// rest of the bits in that byte.
		BYTE	*prgbitNullity;
		if ( fidFixedLastInRec >= fidFixedLeast )
			{
			UINT	ifid	= fidFixedLastInRec - fidFixedLeast;	// Fid converted to an index.

			prgbitNullity = pbRec + ibNewFixEnd + ifid/8;
			
			for ( fidT = FID( fidFixedLastInRec + 1 ); fidT <= fid; fidT++ )
				{
				ifid = fidT - fidFixedLeast;
				if ( ( pbRec + ibNewFixEnd + ifid/8 ) != prgbitNullity )
					{
					Assert( ( pbRec + ibNewFixEnd + ifid/8 ) == ( prgbitNullity + 1 ) );
					break;
					}
				SetFixedNullBit( prgbitNullity, ifid );
				}

			prgbitNullity++;		// Advance to next nullity byte.
			Assert( prgbitNullity <= pbRec + ibNewBitMapEnd );
			}
		else
			{
			prgbitNullity = pbRec + ibNewFixEnd;
			Assert( prgbitNullity < pbRec + ibNewBitMapEnd );
			}

		// set all NULL bits at once
		memset( prgbitNullity, 0xff, pbRec + ibNewBitMapEnd - prgbitNullity );


		// Default values may have to be burst if there are default value columns
		// between the last one currently in the record and the one we are setting.
		// (note that if the column being set also has a default value, we have
		// to set the default value first in case the actual set fails.
		const REC * const	precDefault = ( NULL != ptdb->PdataDefaultRecord() ?
													(REC *)ptdb->PdataDefaultRecord()->Pv() :
													NULL );
		Assert( NULL == precDefault		// temp/system tables have no default record.
			|| ptdb->PdataDefaultRecord()->Cb() >= REC::cbRecordMin );

		fidLastDefaultToBurst = ( NULL != precDefault ?
										precDefault->FidFixedLastInRec() :
										FID( fidFixedLeast - 1 ) );
		Assert( fidLastDefaultToBurst >= fidFixedLeast-1 );
		Assert( fidLastDefaultToBurst <= ptdb->FidFixedLast() );

		if ( fidLastDefaultToBurst > fidFixedLastInRec )
			{
			const FID	fidLastDefaultToCheck	= min( fid, fidLastDefaultToBurst );

			Assert( !ptdb->FInitialisingDefaultRecord() );
			Assert( fidFixedLastInRec < fid );
			for ( fidT = FID( fidFixedLastInRec + 1 ); fidT <= fidLastDefaultToCheck; fidT++ )
				{
				const BOOL	fTemplateColumn	= ptdb->FFixedTemplateColumn( fidT );
				const FIELD	*pfieldFixed 	= ptdb->PfieldFixed( ColumnidOfFid( fidT, fTemplateColumn ) );

				Assert( fidT <= ptdb->FidFixedLast() );

				if ( FFIELDDefault( pfieldFixed->ffield )
					&& !FFIELDCommittedDelete( pfieldFixed->ffield ) )
					{
					UINT	ifid	= fidT - fidFixedLeast;

					Assert( pfieldFixed->coltyp != JET_coltypNil );

					// Update nullity bit.  Assert that it's currently
					// set to null, then set it to non-null in preparation
					// of the bursting of the default value.
					prgbitNullity = pbRec + ibNewFixEnd + (ifid/8);
					Assert( FFixedNullBit( prgbitNullity, ifid ) );
					ResetFixedNullBit( prgbitNullity, ifid );
					fidLastDefaultToBurst = fidT;
					}
				}

			// Only burst default values between the last fixed
			// column currently in the record and the column now
			// being set.
			Assert( fidLastDefaultToBurst > fidFixedLastInRec );
			if ( fidLastDefaultToBurst <= fid )
				{
				const WORD	ibLastDefaultToBurst	= ptdb->IbOffsetOfNextColumn( fidLastDefaultToBurst );
				Assert( ibLastDefaultToBurst > ibOldFixEnd );
				UtilMemCpy(
					pbRec + ibOldFixEnd,
					(BYTE *)precDefault + ibOldFixEnd,
					ibLastDefaultToBurst - ibOldFixEnd );
				}
			}

		//	increase fidFixedLastInRec
		//
		prec->SetFidFixedLastInRec( fid );
		}

	//	fid is now definitely represented in
	//	the record; its data can simply be replaced
	//

	//	adjust fid to an index
	//
	const UINT	ifid			= fid - fidFixedLeast;

	//	byte containing bit representing column's nullity
	//
	BYTE		*prgbitNullity	= prec->PbFixedNullBitMap() + ifid/8;

	//	adding NULL: clear bit (or maybe error)
	//
	if ( NULL == pdataField || pdataField->FNull() )
		{
		if ( FFIELDNotNull( pfield->ffield ) )
			return ErrERRCheck( JET_errNullInvalid );
		SetFixedNullBit( prgbitNullity, ifid );
		}

	else
		{
		//	adding non-NULL value: set bit, copy value into slot
		//
		const JET_COLTYP	coltyp = pfield->coltyp;
		ULONG				cbCopy = pfield->cbMaxLen;

		Assert( pfield->cbMaxLen == UlCATColumnSize( coltyp, cbCopy, NULL ) );

		if ( pdataField->Cb() != cbCopy )
			{
			switch ( coltyp )
				{
				case JET_coltypBit:
				case JET_coltypUnsignedByte:
				case JET_coltypShort:
				case JET_coltypLong:
				case JET_coltypCurrency:
				case JET_coltypIEEESingle:
				case JET_coltypIEEEDouble:
				case JET_coltypDateTime:
					return ErrERRCheck( JET_errInvalidBufferSize );

				case JET_coltypBinary:
					if ( pdataField->Cb() > cbCopy )
						return ErrERRCheck( JET_errInvalidBufferSize );
					else
						{
						memset(
							pbRec + pfield->ibRecordOffset + pdataField->Cb(),
							0,
							cbCopy - pdataField->Cb() );
						}
					cbCopy = pdataField->Cb();
					break;

				default:
					Assert( JET_coltypText == coltyp );
					if ( pdataField->Cb() > cbCopy )
						return ErrERRCheck( JET_errInvalidBufferSize );
					else
						{
						memset(
							pbRec + pfield->ibRecordOffset + pdataField->Cb(),
							' ',
							cbCopy - pdataField->Cb() );
						}
					cbCopy = pdataField->Cb();
					break;
				}
			}

		ResetFixedNullBit( prgbitNullity, ifid );

		if ( JET_coltypBit == coltyp )
			{
			if ( *( (BYTE *)pdataField->Pv() ) == 0 )
				*( pbRec + pfield->ibRecordOffset ) = 0x00;
			else
				*( pbRec + pfield->ibRecordOffset ) = 0xFF;
			}
		else
			{
			BYTE	rgb[8];
			BYTE	*pbDataField;
			
			SetPbDataField( &pbDataField, pdataField, rgb, coltyp );
			
			//	If the data is converted, then the cbCopy must be the same as pdataField->Cb()
			Assert( pbDataField != pdataField->Pv() || cbCopy == pdataField->Cb() );
	
			UtilMemCpy( pbRec + pfield->ibRecordOffset, pbDataField, cbCopy );
			}
		}

	Assert( pfucb->dataWorkBuf.Cb() <= REC::CbRecordMax() );
	return JET_errSuccess;
	}
	

INLINE ULONG CbBurstVarDefaults( TDB *ptdb, FID fidVarLastInRec, FID fidSet, FID *pfidLastDefault )
	{
	ULONG				cbBurstDefaults		= 0;
	const REC * const	precDefault			= ( NULL != ptdb->PdataDefaultRecord() ?
														(REC *)ptdb->PdataDefaultRecord()->Pv() :
														NULL );

	// Compute space needed to burst default values.
	// Default values may have to be burst if there are default value columns
	// between the last one currently in the record and the one we are setting.
	// (note that if the column being set also has a default value, we don't
	// bother setting it, since it will be overwritten).
	Assert( NULL == precDefault		// temp/system tables have no default record.
		|| ptdb->PdataDefaultRecord()->Cb() >= REC::cbRecordMin );

	*pfidLastDefault = ( NULL != precDefault ?
							precDefault->FidVarLastInRec() :
							FID( fidVarLeast - 1 ) );
	Assert( *pfidLastDefault >= fidVarLeast-1 );
	Assert( *pfidLastDefault <= ptdb->FidVarLast() );

	if ( *pfidLastDefault > fidVarLastInRec )
		{
		Assert( ptdb->PdataDefaultRecord()->Cb() >= REC::cbRecordMin );
		Assert( fidVarLastInRec < fidSet );
		Assert( fidSet <= ptdb->FidVarLast() );

		const UnalignedLittleEndian<REC::VAROFFSET>	*pibDefaultVarOffs = precDefault->PibVarOffsets();

		for ( FID fidT = FID( fidVarLastInRec + 1 ); fidT < fidSet; fidT++ )
			{
			const BOOL	fTemplateColumn	= ptdb->FVarTemplateColumn( fidT );
			const FIELD	*pfieldVar		= ptdb->PfieldVar( ColumnidOfFid( fidT, fTemplateColumn ) );
			if ( FFIELDDefault( pfieldVar->ffield )
				&& !FFIELDCommittedDelete( pfieldVar->ffield ) )
				{
				const UINT	ifid = fidT - fidVarLeast;
				Assert( pfieldVar->coltyp != JET_coltypNil );

				// Don't currently support NULL default values.
				Assert( !FVarNullBit( pibDefaultVarOffs[ifid] ) );
				
				//	beginning of current column is end of previous column
				const WORD	ibVarOffset = ( fidVarLeast == fidT ?
												(WORD)0 :
												IbVarOffset( pibDefaultVarOffs[ifid-1] ) );

				Assert( IbVarOffset( pibDefaultVarOffs[ifid] ) > ibVarOffset );
				Assert( precDefault->PbVarData() + IbVarOffset( pibDefaultVarOffs[ifid] )
							<= (BYTE *)ptdb->PdataDefaultRecord()->Pv() + ptdb->PdataDefaultRecord()->Cb() );

				cbBurstDefaults += ( IbVarOffset( pibDefaultVarOffs[ifid] ) - ibVarOffset );
				Assert( cbBurstDefaults > 0 );

				*pfidLastDefault = fidT;
				}
			}
		}

	Assert( cbBurstDefaults == 0  ||
		( *pfidLastDefault > fidVarLastInRec && *pfidLastDefault < fidSet ) );

	return cbBurstDefaults;
	}


ERR ErrRECISetVarColumn(
	FUCB			* const pfucb,
	TDB				* const ptdb,
	const COLUMNID	columnid,
	DATA			*pdataField )
	{
	ERR				err				= JET_errSuccess;
	const FID		fid				= FidOfColumnid( columnid );

	Assert( FVarFid( fid ) );

	Assert( pfucbNil != pfucb );
	Assert( FFUCBIndex( pfucb ) || FFUCBSort( pfucb ) );

	INT			cbRec = pfucb->dataWorkBuf.Cb();
	Assert( cbRec >= REC::cbRecordMin );
	Assert( cbRec <= REC::CbRecordMax() );

	BYTE		*pbRec = (BYTE *)pfucb->dataWorkBuf.Pv();
	REC			*prec = (REC *)pbRec;
	Assert( precNil != prec );

	if ( fid > ptdb->FidVarLast() || fid < ptdb->FidVarFirst() )
		{
		//	this should be impossible, because the columnid
		//	should already have been validated by this point
		//
		Assert( fFalse );
		return ErrERRCheck( JET_errColumnNotFound );
		}

	FIELD		*pfield = ptdb->PfieldVar( columnid );
	Assert( pfieldNil != pfield );
	if ( JET_coltypNil == pfield->coltyp )
		{
		//	this should be impossible, because the columnid
		//	should already have been validated by this point
		//
		Assert( fFalse );
		return ErrERRCheck( JET_errColumnNotFound );
		}

	//	record the fact that this column has been changed
	//
	FUCBSetColumnSet( pfucb, fid );

	//	NULL-value check
	//
	INT		cbCopy;				// Number of bytes to copy from user's buffer
	if ( NULL == pdataField )
		{
		if ( FFIELDNotNull( pfield->ffield ) )
			return ErrERRCheck( JET_errNullInvalid );
		else
			cbCopy = 0;
		}
	else if ( NULL == pdataField->Pv() )
		{
		cbCopy = 0;
		}
	else if ( pdataField->Cb() > pfield->cbMaxLen )
		{
		//	column too long
		//
		cbCopy = pfield->cbMaxLen;
		err = ErrERRCheck( JET_wrnColumnMaxTruncated );
		}
	else
		{
		cbCopy = pdataField->Cb();
		}
	Assert( cbCopy >= 0 );

	//	variable column offsets
	//
	UnalignedLittleEndian<REC::VAROFFSET>	*pib;
	UnalignedLittleEndian<REC::VAROFFSET>	*pibLast;
	UnalignedLittleEndian<REC::VAROFFSET>	*pibVarOffs;
	
	//	column not represented in record?  Make room, make room
	//
	const BOOL		fBurstRecord = ( fid > prec->FidVarLastInRec() );
	if ( fBurstRecord )
		{
		const FID	fidVarLastInRec = prec->FidVarLastInRec();
		FID			fidLastDefault;

		Assert( !( pdataField == NULL && FFIELDNotNull( pfield->ffield ) ) );

		//	compute space needed for new var column offsets
		//
		const INT	cbNeed = ( fid - fidVarLastInRec ) * sizeof(REC::VAROFFSET);
		const INT	cbBurstDefaults = CbBurstVarDefaults(
											ptdb,
											fidVarLastInRec,
											fid,
											&fidLastDefault );
											
		if ( cbRec + cbNeed + cbBurstDefaults + cbCopy > cbRECRecordMost )
			return ErrERRCheck( JET_errRecordTooBig );

		pibVarOffs = prec->PibVarOffsets();

		//	shift rest of record over to make room
		//
		BYTE	*pbVarOffsEnd = prec->PbVarData();
		Assert( pbVarOffsEnd >= (BYTE *)pibVarOffs );
		memmove(
				pbVarOffsEnd + cbNeed,
				pbVarOffsEnd,
				pbRec + cbRec - pbVarOffsEnd );

#ifdef DEBUG
		memset( pbVarOffsEnd, chRECFill, cbNeed );
#endif

		
		//	set new var offsets to tag offset, making them NULL
		//
		pib = (UnalignedLittleEndian<REC::VAROFFSET> *)pbVarOffsEnd;
		pibLast	= pibVarOffs + ( fid - fidVarLeast );
		
		WORD			ibTagFields	= prec->IbEndOfVarData();
		SetVarNullBit( ibTagFields );
		
		Assert( pib == pibVarOffs + ( fidVarLastInRec+1-fidVarLeast ) );
		Assert( prec->PbVarData() + IbVarOffset( ibTagFields ) - pbRec <= cbRec );
		Assert( pib <= pibLast );
		Assert( pibLast - pib + 1 == cbNeed / sizeof(REC::VAROFFSET) );
		while( pib <= pibLast )
			*pib++ = ibTagFields;
		Assert( pib == pibVarOffs + ( fid+1-fidVarLeast ) );

		//	increase record size to reflect addition of entries in the
		//	variable offsets table.
		//
		Assert( prec->FidVarLastInRec() == fidVarLastInRec );
		prec->SetFidVarLastInRec( fid );
		Assert( pfucb->dataWorkBuf.Cb() == cbRec );
		cbRec += cbNeed;

		Assert( prec->PibVarOffsets() == pibVarOffs );
		Assert( pibVarOffs[fid-fidVarLeast] == ibTagFields );	// Includes null-bit comparison.

		// Burst default values if required.
		Assert( cbBurstDefaults == 0
			|| ( fidLastDefault > fidVarLastInRec && fidLastDefault < fid ) );
		if ( cbBurstDefaults > 0 )
			{
			Assert( NULL != ptdb->PdataDefaultRecord() );

			BYTE			*pbVarData			= prec->PbVarData();
			const REC		*precDefault		= (REC *)ptdb->PdataDefaultRecord()->Pv();
			const BYTE		*pbVarDataDefault	= precDefault->PbVarData();
			UnalignedLittleEndian<REC::VAROFFSET>	*pibDefaultVarOffs;
			UnalignedLittleEndian<REC::VAROFFSET>	*pibDefault;

			// Should have changed since last time, since we added
			// some columns.
			Assert( pbVarData > pbVarOffsEnd );
			Assert( pbVarData > pbRec );
			Assert( pbVarData <= pbRec + cbRec );

			pibDefaultVarOffs = precDefault->PibVarOffsets();

			// Make room for the default values to be burst.
			Assert( FVarNullBit( ibTagFields ) );
			Assert( cbRec >= pbVarData + IbVarOffset( ibTagFields ) - pbRec );
			const ULONG		cbTaggedData = cbRec - ULONG( pbVarData + IbVarOffset( ibTagFields ) - pbRec );
			memmove(
				pbVarData + IbVarOffset( ibTagFields ) + cbBurstDefaults,
				pbVarData + IbVarOffset( ibTagFields ),
				cbTaggedData );

			Assert( fidVarLastInRec < fidLastDefault );
			
			Assert( fidVarLastInRec == fidVarLeast-1
				|| IbVarOffset( pibDefaultVarOffs[fidVarLastInRec-fidVarLeast] )
						< IbVarOffset( pibDefaultVarOffs[fidLastDefault-fidVarLeast] ) );
			Assert( pbVarDataDefault + IbVarOffset( pibDefaultVarOffs[fidLastDefault-fidVarLeast] ) - (BYTE *)precDefault
					<= ptdb->PdataDefaultRecord()->Cb() );

			pib = pibVarOffs + ( fidVarLastInRec + 1 - fidVarLeast );
			Assert( *pib == ibTagFields );	// Null bit also compared.
			pibDefault = pibDefaultVarOffs + ( fidVarLastInRec + 1 - fidVarLeast );

#ifdef DEBUG
			ULONG	cbBurstSoFar		= 0;
#endif			
			
			for ( FID fidT = FID( fidVarLastInRec + 1 );
				fidT <= fidLastDefault;
				fidT++, pib++, pibDefault++ )
				{
				const BOOL	fTemplateColumn	= ptdb->FVarTemplateColumn( fidT );
				const FIELD *pfieldVar		= ptdb->PfieldVar( ColumnidOfFid( fidT, fTemplateColumn ) );

				// Null bit is initially set when the offsets
				// table is expanded above.
				Assert( FVarNullBit( *pib ) );

				if ( FFIELDDefault( pfieldVar->ffield )
					&& !FFIELDCommittedDelete( pfieldVar->ffield ) )
					{
					Assert( JET_coltypNil != pfieldVar->coltyp );

					// Update offset entry in preparation for the default value.
					Assert( !FVarNullBit( *pibDefault ) );

					if ( fidVarLeast == fidT )
						{
						Assert( IbVarOffset( *pibDefault ) > 0 );
						const USHORT	cb	= IbVarOffset( *pibDefault );
						*pib = cb;
						UtilMemCpy( pbVarData, pbVarDataDefault, cb );
#ifdef DEBUG
						cbBurstSoFar += cb;
#endif					
						}
					else
						{
						Assert( IbVarOffset( *pibDefault ) > IbVarOffset( *(pibDefault-1) ) );
						const USHORT	cb	= USHORT( IbVarOffset( *pibDefault )
												- IbVarOffset( *(pibDefault-1) ) );
						const USHORT	ib	= USHORT( IbVarOffset( *(pib-1) ) + cb );
						*pib = ib;
						UtilMemCpy( pbVarData + IbVarOffset( *(pib-1) ),
								pbVarDataDefault + IbVarOffset( *(pibDefault-1) ),
								cb );
#ifdef DEBUG
						cbBurstSoFar += cb;
#endif					
						}
						
//					Null bit gets reset when cb is set
//					ResetVarNullBit( *pib );
					Assert( !FVarNullBit( *pib ) );
					}
				else if ( fidT > fidVarLeast )
					{
					*pib = IbVarOffset( *(pib-1) );
					
//					Null bit gets reset when cb is set
					Assert( !FVarNullBit( *pib ) );
					SetVarNullBit( *(UnalignedLittleEndian< WORD >*)(pib) );
					}
				else
					{
					Assert( fidT == fidVarLeast );
					Assert( FVarNullBit( *pib ) );
					Assert( 0 == IbVarOffset( *pib ) );
					}
				}

#ifdef DEBUG
			Assert( cbBurstDefaults == cbBurstSoFar );
#endif			

			Assert( FVarNullBit( *pib ) );
			Assert( *pib == ibTagFields );
			if ( fidVarLastInRec >= fidVarLeast )
				{
				Assert( IbVarOffset( pibVarOffs[fidVarLastInRec-fidVarLeast] )
					== IbVarOffset( ibTagFields ) );
				Assert( IbVarOffset( *(pib-1) ) -
						IbVarOffset( pibVarOffs[fidVarLastInRec-fidVarLeast] )
					== (WORD)cbBurstDefaults );
				}
			else
				{
				Assert( IbVarOffset( *(pib-1) ) == (WORD)cbBurstDefaults );
				}

			// Offset entries up to the last default have been set.
			// Update the entries between the last default and the
			// column being set.
			pibLast = pibVarOffs + ( fid - fidVarLeast );
			for ( ; pib <= pibLast; pib++ )
				{
				Assert( FVarNullBit( *pib ) );
				Assert( *pib == ibTagFields );

				*pib = REC::VAROFFSET( *pib + cbBurstDefaults );
				}

#ifdef DEBUG
			// Verify null bits vs. offsets.
			pibLast = pibVarOffs + ( fid - fidVarLeast );
			for ( pib = pibVarOffs+1; pib <= pibLast; pib++ )
				{
				Assert( IbVarOffset( *pib ) >= IbVarOffset( *(pib-1) ) );
				if ( FVarNullBit( *pib ) )
					{
					Assert( pib != pibVarOffs + ( fidLastDefault - fidVarLeast ) );
					Assert( IbVarOffset( *pib ) == IbVarOffset( *(pib-1) ) );
					}
				else
					{
					Assert( pib <= pibVarOffs + ( fidLastDefault - fidVarLeast ) );
					Assert( IbVarOffset( *pib ) > IbVarOffset( *(pib-1) ) );
					}
				}
#endif
			}

		Assert( pfucb->dataWorkBuf.Cb() == cbRec - cbNeed );
		cbRec += cbBurstDefaults;
		pfucb->dataWorkBuf.SetCb( cbRec );
		
		Assert( prec->FidVarLastInRec() == fid );
		}

	//	fid is now definitely represented in the record;
	//	its data can be replaced, shifting remainder of record,
	//	either to the right or left (if expanding/shrinking)
	//

	Assert( JET_errSuccess == err || JET_wrnColumnMaxTruncated == err );


	//	compute change in column size and value of null-bit in offset
	//
	pibVarOffs = prec->PibVarOffsets();
	pib = pibVarOffs + ( fid - fidVarLeast );

	// Calculate size change of column data
	REC::VAROFFSET	ibStartOfColumn;
	if( fidVarLeast == fid )
		{
		ibStartOfColumn = 0;
		}
	else
		{
		ibStartOfColumn = IbVarOffset( *(pib-1) );
		}
		
	const REC::VAROFFSET	ibEndOfColumn	= IbVarOffset( *pib );
	const INT				dbFieldData		= cbCopy - ( ibEndOfColumn - ibStartOfColumn );

	//	size changed: must shift rest of record data
	//
	if ( 0 != dbFieldData )
		{
		BYTE	*pbVarData = prec->PbVarData();
		
		//	shift data
		//
		if ( cbRec + dbFieldData > cbRECRecordMost )
			{
			Assert( !fBurstRecord );		// If record had to be extended, space
											// consumption was already checked.
			return ErrERRCheck( JET_errRecordTooBig );
			}

		Assert( cbRec >= pbVarData + ibEndOfColumn - pbRec );
		memmove(
			pbVarData + ibEndOfColumn + dbFieldData,
			pbVarData + ibEndOfColumn,
			cbRec - ( pbVarData + ibEndOfColumn - pbRec ) );

#ifdef DEBUG
		if ( dbFieldData > 0 )
			memset( pbVarData + ibEndOfColumn, chRECFill, dbFieldData );
#endif

		pfucb->dataWorkBuf.DeltaCb( dbFieldData );
		cbRec = pfucb->dataWorkBuf.Cb();

		//	bump affected var column offsets
		//
		Assert( fid <= prec->FidVarLastInRec() );
		Assert( prec->FidVarLastInRec() >= fidVarLeast );
		pibLast = pibVarOffs + ( prec->FidVarLastInRec() - fidVarLeast );
		for ( pib = pibVarOffs + ( fid - fidVarLeast ); pib <= pibLast; pib++ )
			{
			*pib = WORD( *pib + dbFieldData );
			}

		// Reset for setting of null bit below.
		pib = pibVarOffs + ( fid - fidVarLeast );
		}

	//	data shift complete, if any;  copy new column value in
	//
	Assert( cbCopy >= 0 );
	if ( cbCopy > 0 )
		{
		UtilMemCpy(
			prec->PbVarData() + ibStartOfColumn,
			pdataField->Pv(),
			cbCopy );
		}

	//	set value of null-bit in offset
	//
	if ( NULL == pdataField )
		{
		SetVarNullBit( *( UnalignedLittleEndian< WORD >*)pib );
		}
	else
		{
		ResetVarNullBit( *( UnalignedLittleEndian< WORD >*)pib );
		}

	Assert( pfucb->dataWorkBuf.Cb() <= cbRECRecordMost );
	Assert( JET_errSuccess == err || JET_wrnColumnMaxTruncated == err );
	return err;
	}


ERR ErrRECISetTaggedColumn(
	FUCB			* const pfucb,
	TDB				* const ptdb,
	const COLUMNID	columnid,
	const ULONG		itagSequence,
	const DATA		* const pdataToSet,
	const BOOL		fUseDerivedBit,
	const JET_GRBIT	grbit )
	{
	const FID		fid					= FidOfColumnid( columnid );
	Assert( FCOLUMNIDTagged( columnid ) );

	Assert( pfucbNil != pfucb );
	Assert( FFUCBIndex( pfucb ) || FFUCBSort( pfucb ) );

	if ( fid > ptdb->FidTaggedLast() || fid < ptdb->FidTaggedFirst() )
		{
		//	this should be impossible, because the columnid
		//	should already have been validated by this point
		//
		Assert( fFalse );
		return ErrERRCheck( JET_errColumnNotFound );
		}

	const FIELD		*const pfield		= ptdb->PfieldTagged( columnid );
	Assert( pfieldNil != pfield );
	if ( JET_coltypNil == pfield->coltyp )
		{
		//	this should be impossible, because the columnid
		//	should already have been validated by this point
		//
		Assert( fFalse );
		return ErrERRCheck( JET_errColumnNotFound );
		}

	//	record the fact that this column has been changed
	//
	FUCBSetColumnSet( pfucb, fid );

	//	check for column too long
	//
	if ( pfield->cbMaxLen > 0
		&& NULL != pdataToSet
		&& pdataToSet->Cb() > pfield->cbMaxLen )
		{
		return ErrERRCheck( JET_errColumnTooBig );
		}

	//	check fixed size column size
	//
	if ( NULL != pdataToSet
		&& pdataToSet->Cb() > 0 )
		{
		switch ( pfield->coltyp )
			{
			case JET_coltypBit:
			case JET_coltypUnsignedByte:
				if ( pdataToSet->Cb() != 1 )
					{
					return ErrERRCheck( JET_errInvalidBufferSize );
					}
				break;
			case JET_coltypShort:
				if ( pdataToSet->Cb() != 2 )
					{
					return ErrERRCheck( JET_errInvalidBufferSize );
					}
				break;
			case JET_coltypLong:
			case JET_coltypIEEESingle:
				if ( pdataToSet->Cb() != 4 )
					{
					return ErrERRCheck( JET_errInvalidBufferSize );
					}
				break;
			case JET_coltypCurrency:
			case JET_coltypIEEEDouble:
			case JET_coltypDateTime:
				if ( pdataToSet->Cb() != 8 )
					{
					return ErrERRCheck( JET_errInvalidBufferSize );
					}
				break;
			default:
				Assert( JET_coltypText == pfield->coltyp
					|| JET_coltypBinary == pfield->coltyp
					|| FRECLongValue( pfield->coltyp )
					|| FRECSLV( pfield->coltyp) );
				break;
			}
		}

	//	cannot set column more than cbLVIntrinsicMost bytes
	//
	if ( NULL != pdataToSet
		&& pdataToSet->Cb() > cbLVIntrinsicMost )
		{
		return ErrERRCheck( JET_errColumnLong );
		}

#ifdef DEBUG
	VOID			* pvDBGCopyOfRecord;
	const ULONG		cbDBGCopyOfRecord		= pfucb->dataWorkBuf.Cb();
	BFAlloc( &pvDBGCopyOfRecord );
	UtilMemCpy( pvDBGCopyOfRecord, pfucb->dataWorkBuf.Pv(), cbDBGCopyOfRecord );
#endif
								
	TAGFIELDS	tagfields( pfucb->dataWorkBuf );
	const ERR	errT		= tagfields.ErrSetColumn(
									pfucb,
									pfield,
									columnid,
									itagSequence,
									pdataToSet,
									grbit | ( fUseDerivedBit ? grbitSetColumnUseDerivedBit : 0 ) );

#ifdef DEBUG
	BFFree( pvDBGCopyOfRecord );
#endif

	return errT;
	}


//	change default value of a non-derived column
ERR VTAPI ErrIsamSetColumnDefaultValue(
	JET_SESID	vsesid,
	JET_DBID	vdbid,
	const CHAR	*szTableName,
	const CHAR	*szColumnName,
	const VOID	*pvData,
	const ULONG	cbData,
	const ULONG	grbit )
	{
	ERR			err;
	PIB			*ppib				= (PIB *)vsesid;
	IFMP		ifmp				= (IFMP)vdbid;
	FUCB		*pfucb				= pfucbNil;
	FCB			*pfcb				= pfcbNil;
	TDB			*ptdb				= ptdbNil;
	BOOL		fInTrx				= fFalse;
	BOOL		fNeedToSetFlag		= fFalse;
	BOOL		fResetFlagOnErr		= fFalse;
	BOOL		fRestorePrevOnErr	= fFalse;
	DATA		dataDefault;
	DATA *		pdataDefaultPrev;
	OBJID		objidTable;
	FIELD		*pfield;
	COLUMNID	columnid;
	CHAR		szColumn[JET_cbNameMost+1];

	//	check parameters
	//
	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrPIBCheckIfmp( ppib, ifmp ) );
	Assert( dbidTemp != rgfmp[ ifmp ].Dbid() );

	CallR( ErrUTILCheckName( szColumn, szColumnName, JET_cbNameMost+1 ) );

	if ( NULL == pvData || 0 == cbData )
		{
		err = ErrERRCheck( JET_errNullInvalid );
		return err;
		}

	CallR( ErrFILEOpenTable(
				ppib,
				ifmp,
				&pfucb,
				szTableName,
				JET_bitTableDenyRead ) );
	CallSx( err, JET_wrnTableInUseBySystem );
	Assert( pfucbNil != pfucb );

	// We should now have exclusive use of the table.
    pfcb = pfucb->u.pfcb;
	objidTable = pfcb->ObjidFDP();
    Assert( pfcbNil != pfcb );

    ptdb = pfcb->Ptdb();
    Assert( ptdbNil != ptdb );

	//	save off old default record in case we have to restore it on error
	Assert( NULL != ptdb->PdataDefaultRecord() );
	pdataDefaultPrev = ptdb->PdataDefaultRecord();
	Assert( NULL != pdataDefaultPrev );
	Assert( !pdataDefaultPrev->FNull() );

	Assert( cbData > 0 );
	Assert( pvData != NULL );
	dataDefault.SetCb( cbData );
	dataDefault.SetPv( (VOID *)pvData );

	FUCB	fucbFake;
	FCB		fcbFake( pfcb->Ifmp(), pfcb->PgnoFDP() );
	FILEPrepareDefaultRecord( &fucbFake, &fcbFake, ptdb );
	Assert( fucbFake.pvWorkBuf != NULL );
	
	Call( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	fInTrx = fTrue;


	//	NOTE: Can only change the default value of non-derived columns
	//	so don't even bother looking for the column in the template
	//	table's column space

	pfcb->EnterDML();
	err = ErrFILEPfieldFromColumnName(
			ppib,
			pfcb,
			szColumn,
			&pfield,
			&columnid );
	if ( err >= 0 )
		{
		if ( pfieldNil == pfield )
			{
			err = ErrERRCheck( JET_errColumnNotFound );
			}
		else if ( FFILEIsIndexColumn( ppib, pfcb, columnid ) )
			{
			err = ErrERRCheck( JET_errColumnInUse );
			}
		else
			{
			fNeedToSetFlag = !FFIELDDefault( pfield->ffield );
			}
		}
	pfcb->LeaveDML();

	Call( err );

	Call( ErrCATChangeColumnDefaultValue(
				ppib,
				ifmp,
				objidTable,
				szColumn,
				dataDefault ) )

	Assert( fucbFake.pvWorkBuf != NULL );
	Assert( fucbFake.u.pfcb == &fcbFake );
	Assert( fcbFake.Ptdb() == ptdb );

	//	if adding a default value, the default value
	//	flag will not be set, so must set it now
	//	before rebuilding the default record (because
	//	the rebuild code checks that flag)
	if ( fNeedToSetFlag )
		{
		pfcb->EnterDDL();
		FIELDSetDefault( ptdb->Pfield( columnid )->ffield );
		if ( !FFIELDEscrowUpdate( ptdb->Pfield( columnid )->ffield ) )
			{
			ptdb->SetFTableHasNonEscrowDefault();
			}
		ptdb->SetFTableHasDefault();
		pfcb->LeaveDDL();

		fResetFlagOnErr = fTrue;
		}

	Call( ErrFILERebuildDefaultRec( &fucbFake, columnid, &dataDefault ) );
	Assert( NULL != ptdb->PdataDefaultRecord() );
	Assert( !ptdb->PdataDefaultRecord()->FNull() );
	Assert( ptdb->PdataDefaultRecord() != pdataDefaultPrev );
	fRestorePrevOnErr = fTrue;

	Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );
	fInTrx = fFalse;

	Assert( NULL != pdataDefaultPrev );
	OSMemoryHeapFree( pdataDefaultPrev );

HandleError:
	if ( err < 0 )
		{
		Assert( ptdbNil != ptdb );

		if ( fResetFlagOnErr )
			{
			Assert( fNeedToSetFlag );
			pfcb->EnterDDL();
			FIELDResetDefault( ptdb->Pfield( columnid )->ffield );
			pfcb->LeaveDDL();
			}

		if ( fRestorePrevOnErr )
			{
			Assert( NULL != ptdb->PdataDefaultRecord() );
			OSMemoryHeapFree( ptdb->PdataDefaultRecord() );
			ptdb->SetPdataDefaultRecord( pdataDefaultPrev );
			}
		
		if ( fInTrx )
			{
			CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
			}
		}
	else
		{
		Assert( !fInTrx );
		}
	
	FILEFreeDefaultRecord( &fucbFake );

	Assert( pfucbNil != pfucb );
	DIRClose( pfucb );

	AssertDIRNoLatch( ppib );

	return err;
	}

ERR ErrRECIFColumnSet(
	FUCB			* const pfucb,
	TDB				* const ptdb,
	const COLUMNID	columnid,
	const ULONG		itagSequence,
	RCE				*prcePrimary,
	const BOOL		fCheckForNullOnly,
	BOOL			*pfColumnSet )
	{
	ERR				err = JET_errSuccess;
	ERR				errRec = JET_errSuccess;
	ERR				errCopy = JET_errSuccess;
	DATA*			pdataCopy = &pfucb->dataWorkBuf;
	DATA*			pdataRec = NULL;
	DATA			dataRec;
	const BOOL		fReplaceByProxy = ( prceNil != prcePrimary );
	DATA			dataCopyRetrieved;
	DATA			dataRecRetrieved;

	AssertDIRNoLatch( pfucb->ppib );

	Assert( FFUCBSort( pfucb ) || FFUCBIndex( pfucb ) );
	
	//	set ptdb.  ptdb is same for indexes and for sorts.
	//
	Assert( pfucb->u.pfcb->Ptdb() == pfucb->u.pscb->fcb.Ptdb() );
	Assert( pfucb->u.pfcb->Ptdb() != ptdbNil );

	//	pdataCopy is already set to cursor copy buffer
	//
	if ( FCOLUMNIDTagged( columnid ) )
		{
		Call( ErrRECRetrieveTaggedColumn(
				pfucb->u.pfcb,
				columnid,
				itagSequence,
				*pdataCopy,
				&dataCopyRetrieved,
				NO_GRBIT ) );
		}
	else
		{
		Call( ErrRECRetrieveNonTaggedColumn(
				pfucb->u.pfcb,
				columnid,
				*pdataCopy,
				&dataCopyRetrieved,
				pfieldNil ) );
		}
	Assert( wrnRECLongField != err );		//	obsolete error code
	Assert( JET_wrnColumnSetNull != err );	//	only returned when scanning
	errCopy = err;

	if ( fReplaceByProxy )
		{
		//	before-image of record is stored in RCE
		//
		Assert( operReplace == prcePrimary->Oper() );
		dataRec.SetPv( const_cast<BYTE *>( prcePrimary->PbData() ) + cbReplaceRCEOverhead );
		dataRec.SetCb( prcePrimary->CbData() - cbReplaceRCEOverhead );
		pdataRec = &dataRec;
		}
	else
		{
		//	get pointer and length of record to update
		//
		Call( ErrRECIGetRecord( pfucb, &pdataRec, fFalse ) );
		}
	
	if ( FCOLUMNIDTagged( columnid ) )
		{
		Call( ErrRECRetrieveTaggedColumn(
				pfucb->u.pfcb,
				columnid,
				itagSequence,
				*pdataRec,
				&dataRecRetrieved,
				0 ) );
		}
	else
		{
		Call( ErrRECRetrieveNonTaggedColumn(
				pfucb->u.pfcb,
				columnid,
				*pdataRec,
				&dataRecRetrieved,
				pfieldNil ) );
		}
	Assert( wrnRECLongField != err );		//	obsolete error code
	Assert( JET_wrnColumnSetNull != err );	//	only returned when scanning
	errRec = err;

	//	if error code returned from record and copy buffer retrievals are not the same then
	//	assume that this column has been changed.  Note that in some rare cases,
	//	a long value can become separated due to an update on a neighboring column.
	//
	if ( errRec != errCopy )
		{
		*pfColumnSet = fTrue;
		}

	//	special case both column NULL so proper error code can be returned to calling function
	//
	else if ( JET_wrnColumnNull == errRec )
		{
		Assert( JET_wrnColumnNull == errCopy );
		*pfColumnSet = fFalse;
		err = ErrERRCheck( JET_wrnColumnNull );
		goto HandleError;
		}

	//	if column length has changed then return that this column has been set.
	//
	else if ( dataRecRetrieved.Cb() != dataCopyRetrieved.Cb() )
		{
		//	indicate that there was a difference unless
		//	we were only checking for NULL, in which case
		//	we only care that both values are non-NULL
		//
		*pfColumnSet = !fCheckForNullOnly;
		}

	//	if column is default value in both record and copy buffer
	//	then data pointer and counts will be the same.
	//
	else if ( dataRecRetrieved.Pv() == dataCopyRetrieved.Pv() )
		{
		Assert( dataRecRetrieved.Cb() == dataCopyRetrieved.Cb() );
		*pfColumnSet = fFalse;
		}

	//	column warning code and length are same.  Check for other differences indcating column set.
	//
	else
		{
		switch ( errRec )
			{
			case wrnRECIntrinsicSLV:
			case wrnRECSeparatedSLV:
				{
				//	SLVs cannot be indexed
				//
				Assert( fFalse );
				*pfColumnSet = fTrue;
				break;
				}
			case wrnRECIntrinsicLV:
				//	return column set if intrinsic LV data different
				//	and not checking for NULL only
				//
				Assert( dataRecRetrieved.Cb() == dataCopyRetrieved.Cb() );
				*pfColumnSet = ( !fCheckForNullOnly 
								&& 0 != memcmp( (BYTE *)dataRecRetrieved.Pv(), (BYTE *)dataCopyRetrieved.Pv(), dataRecRetrieved.Cb() ) );
				break;
			case wrnRECSeparatedLV:
				{
				//	FUTURE: extend optimization to look for version on LV even in case of proxy record
				//
				//	return fTrue if separated long value ids are different or if version by this transaction found on long value
				//
				if ( fCheckForNullOnly )
					{
					//	only interested in knowing that both values are non-NULL
					//
					*pfColumnSet = fFalse;
					}
				else if ( !fReplaceByProxy && ( LidOfSeparatedLV( dataRecRetrieved ) == LidOfSeparatedLV( dataCopyRetrieved ) ) )
					{
					//	save LID of record long value before release latch on record page
					//
					LID	lidRec = LidOfSeparatedLV( dataRecRetrieved );
					
					//	release latch on record before performing long value operation
					//
					Call( ErrDIRRelease( pfucb ) );
					
					//	check if long value has been updated
					//
					Call( ErrRECFSetLV( pfucb, lidRec, pfColumnSet ) );
					}
				else
					{
					//	separate long value ids are different, or record is a proxy
					//
					*pfColumnSet = fTrue;
					}
				break;
				}
			case wrnRECUserDefinedDefault:
				//	both record and copy buffer have default value for column, 
				//	but user defined column may be different since other columns 
				//	have been set.  Conservatively assume this column is effectively set.
				//
				*pfColumnSet = fTrue;
				break;		
			default:
				CallS( err );

				//	return column set if intrinsic data different
				//	and not checking for NULL only
				//
				Assert( dataRecRetrieved.Cb() == dataCopyRetrieved.Cb() );
				*pfColumnSet = ( !fCheckForNullOnly
								&& 0 != memcmp( (BYTE *)dataRecRetrieved.Pv(), (BYTE *)dataCopyRetrieved.Pv(), dataRecRetrieved.Cb() ) );
				break;
			}
		}

	//	remove JET_wrnColumnNull from err.  It can only be returned when both copy and record columns are NULL.
	//
	err = JET_errSuccess;
		
HandleError:
	if ( Pcsr( pfucb )->FLatched() )
		{
		ERR errT;
		errT = ErrDIRRelease( pfucb );
		CallSx( errT, JET_errOutOfMemory );
		if ( errT < JET_errSuccess && err >= JET_errSuccess )
			{
			err = errT;
			}
		}

	//	should only return warning of JET_wrnColumnNull
	//
	if ( err >= 0 )
		{
		CallSx( err, JET_wrnColumnNull );
		}
	AssertDIRNoLatch( pfucb->ppib );
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\fucb.cxx ===
#include "std.hxx"


#ifdef DEBUG
BOOL FFUCBValidTableid( const JET_SESID sesid, const JET_TABLEID tableid )
	{
	const INST	*pinst		= PinstFromPpib( (PIB *)sesid );
	const FUCB	*pfucb		= (FUCB *)tableid;
	const FUCB	*pfucbMin	= PfucbMEMMin( pinst );

	// Validate that pfucb is in the global FUCB pool
	return (	( pfucb >= pfucbMin ) &&
				( pfucb < PfucbMEMMax( pinst ) ) &&
				( ( ( (BYTE *)pfucb - (BYTE *)pfucbMin ) % sizeof( FUCB ) ) == 0 ) );
	}
#endif


//  ================================================================
INLINE FUCB * PIB::PfucbGetCachedCursor()
//  ================================================================
	{
	FUCB *	pfucbT;

	//	must grab mutex because concurrent create-index and
	//	parallel index rebuild have hacks to allow multiple
	//	threads to use the same session
	//
	critCursors.Enter();

	if ( pfucbNil != m_pfucbCache )
		{
		Assert( !m_pinst->FRecovering() );		//	caching disabled during recovery
		Assert( m_cfucbCache > 0 );
		pfucbT = m_pfucbCache;
		m_pfucbCache = pfucbT->pfucbCacheNext;
		m_cfucbCache--;
		pfucbT->pfucbCacheNext = NULL;

		critCursors.Leave();
		}
	else
		{
		critCursors.Leave();

		//	no cached cursors, so must go to CRES
		//
		pfucbT = PfucbMEMAlloc( m_pinst );
		}

	return pfucbT;
	}

//  ================================================================
INLINE VOID PIB::CacheFreedCursor( FUCB * pfucb )
//  ================================================================
	{
	//	cap the number of freed cursors cached by this session
	//	to prevent a session from hoarding all cursors after
	//	spikes in cursor use 
	//
	const ULONG		cfucbCacheMax		= 16;

	//	must grab mutex because concurrent create-index and
	//	parallel index rebuild have hacks to allow multiple
	//	threads to use the same session
	//
	critCursors.Enter();

	//	don't cache during recovery (recovery does its own
	//	caching of cursors)
	//
	if ( m_cfucbCache < cfucbCacheMax && !m_pinst->FRecovering() )
		{
		pfucb->pfucbCacheNext = m_pfucbCache;
		m_pfucbCache = pfucb;
		m_cfucbCache++;

		critCursors.Leave();
		}
	else
		{
		critCursors.Leave();

		//	too many freed cursors cached already,
		//	so just free to CRES
		//
		Assert( cfucbCacheMax == m_cfucbCache || m_pinst->FRecovering() );
		MEMReleasePfucb( m_pinst, pfucb );
		}
	}

//+api
//	ErrFUCBOpen
//	------------------------------------------------------------------------
//	ERR ErrFUCBOpen( PIB *ppib, IFMP ifmp, FUCB **ppfucb );
//
//	Creates an open FUCB. At this point, no FCB is assigned yet.
//
//	PARAMETERS	ppib	PIB of this user
//				ifmp	Database Id
//				ppfucb	Address of pointer to FUCB.	 If *ppfucb == NULL, 
//						an FUCB is allocated and **ppfucb is set to its
//						address.  Otherwise, *ppfucb is assumed to be
//						pointing at a closed FUCB, to be reused in the open.
//
//	RETURNS		JET_errSuccess if successful.
//					JET_errOutOfCursors
//
//	SIDE EFFECTS	links the newly opened FUCB into the chain of open FUCBs
//					for this session.
//
//	SEE ALSO		ErrFUCBClose
//-
ERR ErrFUCBOpen( PIB *ppib, IFMP ifmp, FUCB **ppfucb, const LEVEL level )
	{
	ERR err;
	FUCB *pfucb;

	Assert( ppfucb );
	Assert( pfucbNil == *ppfucb );

	//	if no fucb allocate new fucb and initialize it
	//	and allocate csr
	//
	pfucb = ppib->PfucbGetCachedCursor();
	if ( pfucbNil == pfucb )
		{
		err = ErrERRCheck( JET_errOutOfCursors );
		return err;
		}

	Assert( FAlignedForAllPlatforms( pfucb ) );

	//	ensure bit array is aligned for LONG_PTR traversal
	Assert( (LONG_PTR)pfucb->rgbitSet % sizeof(LONG_PTR) == 0 );

	//	memset implicitly clears pointer cache
	//
	memset( (BYTE *)pfucb, 0, sizeof( FUCB ) );

	pfucb->pvtfndef = &vtfndefInvalidTableid;	// invalide dispatch table.

	Assert( !FFUCBUpdatable( pfucb ) );
	if ( !rgfmp[ ifmp ].FReadOnlyAttach() )
		{
		FUCBSetUpdatable( pfucb );
		}

	//	set ppib and ifmp
	//
	pfucb->ifmp = ifmp;
	pfucb->ppib = ppib;

	pfucb->ls = JET_LSNil;

	//	initialize CSR in fucb
	//	this allocates page structure
	//
	new( Pcsr( pfucb ) ) CSR;

	// If level is non-zero, this indicates we're opening the FUCB via a proxy
	// (ie. concurrent CreateIndex).
	if ( level > 0 )
		{
		// If opening by proxy, then proxy should already have obtained critTrx.
		Assert( ppib->critTrx.FOwner() );
		pfucb->levelOpen = level;
		
		// Must have these flags set BEFORE linking into session list to
		// ensure rollback doesn't close the FUCB prematurely.
		FUCBSetIndex( pfucb );
		FUCBSetSecondary( pfucb );
		}
	else
		{
		pfucb->levelOpen = ppib->level;
		}
		
	//	link new FUCB into user chain, only when success is sure
	//	as unlinking NOT handled in error
	//
	*ppfucb = pfucb;
		
	//	link the fucb now
	//
	//	NOTE: The only concurrency involved is when concurrent create
	//	index must create an FUCB for the session.  This is always
	//	at the head of the FUCB list.  Note that the concurrent create
	//	index thread doesn't remove the FUCB from the session list, 
	//	except on error.  The original session will normally close the
	//	FUCB created by proxy.
	//	So, only need a mutex wherever the head of the list is modified
	//	or if scanning and we want to look at secondary index FUCBs.
	ppib->critCursors.Enter();
	pfucb->pfucbNextOfSession = ( FUCB * )ppib->pfucbOfSession;
	ppib->pfucbOfSession = pfucb;
	ppib->critCursors.Leave();
		
	return JET_errSuccess;
	}


//+api
//	FUCBClose
//	------------------------------------------------------------------------
//	FUCBClose( FUCB *pfucb )
//
//	Closes an active FUCB, optionally returning it to the free FUCB pool.
//	All the pfucb->pcsr are freed.
//
//	PARAMETERS		pfucb		FUCB to close.	Should be open. pfucb->ssib should
//									hold no page.
//
//	SIDE EFFECTS	Unlinks the closed FUCB from the FUCB chain of its
//					   associated PIB and FCB.
//
//	SEE ALSO		ErrFUCBOpen
//-
VOID FUCBClose( FUCB *pfucb )
	{
	FUCB		*pfucbPrev;
	PIB			*ppib = pfucb->ppib;

	Assert( pfcbNil == pfucb->u.pfcb );
	
	//	free CSR
	//
	Assert( !Pcsr( pfucb )->FLatched() );
//	delete( &Pcsr( pfucb )->Cpage() );

	// Current secondary index should already have been closed.
	Assert( !FFUCBCurrentSecondary( pfucb ) );

	//	bookmark should have already been released
	//
	Assert( NULL == pfucb->pvBMBuffer );
	Assert( NULL == pfucb->pvRCEBuffer );
	Assert( 0 == pfucb->cbBMBuffer );
	
	ppib->critCursors.Enter();
	
	//	locate the pfucb in this thread and take it out of the fucb list
	//
	pfucbPrev = (FUCB *)( (BYTE *)&ppib->pfucbOfSession - (BYTE *)&( (FUCB *)0 )->pfucbNextOfSession );
	while ( pfucbPrev->pfucbNextOfSession != pfucb )
		{
		pfucbPrev = pfucbPrev->pfucbNextOfSession;
		Assert( pfucbPrev != pfucbNil );
		}
	pfucbPrev->pfucbNextOfSession = pfucb->pfucbNextOfSession;

	//	set ppibNil to detect bogus reusage.
	//
#ifdef DEBUG
	pfucb->ppib = ppibNil;
#endif

	ppib->critCursors.Leave();
	
	//	release key buffer if one was allocated.
	//
	RECReleaseKeySearchBuffer( pfucb );

	// release the fucb
	//
	pfucb->pvtfndef = &vtfndefInvalidTableid;	// invalide dispatch table.

	if ( JET_LSNil != pfucb->ls )
		{
		JET_CALLBACK	pfn		= PinstFromPpib( ppib )->m_pfnRuntimeCallback;

		Assert( NULL != pfn );
		(*pfn)(
			JET_sesidNil,
			JET_dbidNil,
			JET_tableidNil,
			JET_cbtypFreeCursorLS,
			(VOID *)pfucb->ls,
			NULL,
			NULL,
			NULL );
		}

	ppib->CacheFreedCursor( pfucb );
	}


VOID FUCBCloseAllCursorsOnFCB(
	PIB			* const ppib,	// pass ppibNil when closing cursors because we're terminating
	FCB			* const pfcb )
	{
	while( pfcb->Pfucb() )
		{
		FUCB * const pfucbT = pfcb->Pfucb();

		// This function only called for temp. tables, for
		// table being rolled back, or when purging database (in
		// which case ppib is ppibNil), so no other session should
		// have open cursor on it.
		Assert( pfucbT->ppib == ppib || ppibNil == ppib );
		if ( ppibNil == ppib )
			{
			// If terminating, may have to manually clean up some FUCB resources.
			RECReleaseKeySearchBuffer( pfucbT );
			FILEReleaseCurrentSecondary( pfucbT );
			BTReleaseBM( pfucbT );
			RECIFreeCopyBuffer( pfucbT );
			}
		
		Assert( pfucbT->u.pfcb == pfcb );

		//	unlink the FCB without moving it to the avail LRU list because
		//		we will be synchronously purging the FCB shortly
		
		FCBUnlinkWithoutMoveToAvailList( pfucbT );

		//	close the FUCB

		FUCBClose( pfucbT );
		}
	Assert( pfcb->WRefCount() == 0 );
	}


VOID FUCBSetIndexRange( FUCB *pfucb, JET_GRBIT grbit )
	{
	//	set limstat
	//  also set the preread flags
	
	FUCBResetPreread( pfucb );
	FUCBSetLimstat( pfucb );
	if ( grbit & JET_bitRangeUpperLimit )
		{
		FUCBSetPrereadForward( pfucb, cpgPrereadSequential );
		FUCBSetUpper( pfucb );
		}
	else
		{
		FUCBSetPrereadBackward( pfucb, cpgPrereadSequential );
		FUCBResetUpper( pfucb );
		}
	if ( grbit & JET_bitRangeInclusive )
		{
		FUCBSetInclusive( pfucb );
		}
	else
		{
		FUCBResetInclusive( pfucb );
		}

	return;
	}


VOID FUCBResetIndexRange( FUCB *pfucb )
	{
	if ( pfucb->pfucbCurIndex )
		{
		FUCBResetLimstat( pfucb->pfucbCurIndex );
		FUCBResetPreread( pfucb->pfucbCurIndex );
		}

	FUCBResetLimstat( pfucb );
	FUCBResetPreread( pfucb );
	}


INLINE INT CmpPartialKeyKey( const KEY& key1, const KEY& key2 )
	{
	INT		cmp;

	if ( key1.FNull() || key2.FNull() )
		{
		cmp = key1.Cb() - key2.Cb();
		}
	else
		{
		cmp = CmpKey( key1, key2 );
		}

	return cmp;
	}

ERR ErrFUCBCheckIndexRange( FUCB *pfucb, const KEY& key )
	{
	KEY		keyLimit;

	FUCBAssertValidSearchKey( pfucb );
	keyLimit.prefix.Nullify();
	keyLimit.suffix.SetPv( pfucb->dataSearchKey.Pv() );
	keyLimit.suffix.SetCb( pfucb->dataSearchKey.Cb() );
	
	const INT	cmp				= CmpPartialKeyKey( key, keyLimit );
	BOOL		fOutOfRange;

	if ( cmp > 0 )
		{
		fOutOfRange = FFUCBUpper( pfucb );
		}
	else if ( cmp < 0 )
		{
		fOutOfRange = !FFUCBUpper( pfucb );
		}
	else
		{
		fOutOfRange = !FFUCBInclusive( pfucb );
		}

	ERR		err;
	if ( fOutOfRange )
		{
		FUCBResetLimstat( pfucb );
		FUCBResetPreread( pfucb );
		err = ErrERRCheck( JET_errNoCurrentRecord );
		}
	else
		{
		err = JET_errSuccess;
		}

	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\fldnorm.cxx ===
#include "std.hxx"

const BYTE	bPrefixNull			= 0x00;
const BYTE	bPrefixZeroLength	= 0x40;
const BYTE	bPrefixNullHigh		= 0xc0;
const BYTE	bPrefixData			= 0x7f;
const BYTE	bSentinel			= 0xff;


LOCAL ERR ErrFLDNormalizeTextSegment(
	BYTE *						pbField,
	const ULONG					cbField,
	BYTE *						rgbSeg,
	INT *						pcbSeg,
	const ULONG					cbKeyAvail,
	const ULONG					cbKeyMost,
	const ULONG					cbVarSegMac,
	const USHORT				cp,
	const IDXUNICODE * const	pidxunicode,
	BOOL * const				pfUndefinedUnicode )
	{
	ERR							err;

	if( pfUndefinedUnicode )
		{
		*pfUndefinedUnicode = fFalse;
		}
	
	// Null column handled elsewhere.
	Assert( NULL != pbField );
	Assert( cbField > 0 );

	Assert( cbKeyAvail > 0 );
	Assert( cbVarSegMac > 0 );

	// If cbVarSegMac == cbKeyMost, that implies that it
	// was never set.  However, to detect this, the caller
	// artificially increments it to cbKeyMost+1.
	Assert( cbVarSegMac <= cbKeyMost+1 );
	Assert( cbKeyMost != cbVarSegMac );
				
	// if cbVarSegMac was not set (ie. it is cbKeyMost+1),
	// then cbKeyAvail will always be less than it.
	Assert( cbVarSegMac < cbKeyMost || cbKeyAvail < cbVarSegMac );
	INT	cbT = min( cbKeyAvail, cbVarSegMac );

	//	cbT is the max size of the key segment data,
	//	and does not include the header byte which indicates
	//	NULL key, zero length key, or non-NULL key.
	cbT--;

	//	unicode support
	//
	if ( cp == usUniCodePage )
		{
		//	cbField may have been truncated to an odd number
		//	of bytes, so enforce even.
		//
		//	either we are at cbFieldMax or we are using tuple indexing
		//
		//	an example:
		//		insert a unicode column of > 255 bytes
		//		ErrRECIRetrieveKey truncates the column to 255 bytes
		//		the tuple index tries to index 10 characters, the offset is 118 characters
		//		cbOffset = 236, to there are only 19 bytes left when we actually want 20.
		//

		const INT cbFieldEven = ( cbField / 2 ) * 2;

		if( pfUndefinedUnicode )
			{		
			*pfUndefinedUnicode = FNORMStringHasUndefinedChars( pbField, cbFieldEven );
			}
			
		err = ErrNORMMapString(
					pidxunicode->lcid,
					pidxunicode->dwMapFlags,
					pbField,
					cbFieldEven,
					rgbSeg + 1,
					cbT,
					pcbSeg );
		if ( err < 0 )
			{
#ifdef DEBUG
			switch ( err )
				{
				case JET_errInvalidLanguageId:
				case JET_errOutOfMemory:
				case JET_errUnicodeNormalizationNotSupported:
					break;
				default:
					//	report unexpected error
					CallS( err );
				}
#endif
			return err;
			}
		}
	else
		{
		err = ErrUtilNormText(
					(CHAR *)pbField,
					cbField,
					cbT,
					(CHAR *)rgbSeg + 1,
					pcbSeg );
		}
					
	Assert( JET_errSuccess == err || wrnFLDKeyTooBig == err );
	if ( wrnFLDKeyTooBig == err )
		{
		const INT	cbVarSegMacNoHeader = cbVarSegMac - 1;	// account for header byte
					
		// If not truncated on purpose, set flag
		Assert( cbKeyMost != cbVarSegMac );
		Assert( *pcbSeg <= cbVarSegMacNoHeader );
		if ( cbVarSegMac > cbKeyMost || *pcbSeg < cbVarSegMacNoHeader )
			{
			Assert( *pcbSeg + 1 == cbKeyAvail );
			}
		else
			{
			// Truncated on purpose, so suppress warning.
			Assert( cbVarSegMac < cbKeyMost );
			Assert( cbVarSegMacNoHeader == *pcbSeg );
			err = JET_errSuccess;
			}
		}

	Assert( *pcbSeg >= 0 );
	Assert( *pcbSeg <= cbT );

	//	put the prefix there
	//
	*rgbSeg = bPrefixData;
	(*pcbSeg)++;

	return err;
	}


#ifndef RTM
//  ================================================================
VOID FLDNormUnitTest()
//  ================================================================
//
//	Call ErrFLDNormalizeTextSegment with defined and undefined strings
//	to make sure the correct results are returned
//
//-
	{
	const wchar_t wszUndefined[] 	= L"\x1f5\x217\x348\x40c\x8c0";
	const INT cbUndefined			= sizeof( wszUndefined );
	const wchar_t wszDefined[]		= L"abcDEF123$%^;,.";
	const INT cbDefined				= sizeof( wszDefined );

	BYTE rgbNormalized[255];
	INT cbNormalized = sizeof( rgbNormalized );

	BOOL fUndefinedUnicode = fFalse;
	
	ERR err;

	err = ErrFLDNormalizeTextSegment(
			(BYTE *)wszDefined,
			cbDefined,
			rgbNormalized,
			&cbNormalized,
			KEY::cbKeyMax,
			KEY::cbKeyMax,
			KEY::cbKeyMax+1,
			usUniCodePage,
			&g_idxunicodeDefault,
			&fUndefinedUnicode );

	Enforce( JET_errSuccess == err );
	Enforce( !fUndefinedUnicode );
	
	err = ErrFLDNormalizeTextSegment(
			(BYTE *)wszUndefined,
			cbUndefined,
			rgbNormalized,
			&cbNormalized,
			KEY::cbKeyMax,
			KEY::cbKeyMax,
			KEY::cbKeyMax+1,
			usUniCodePage,
			&g_idxunicodeDefault,
			&fUndefinedUnicode );

	Enforce( JET_errSuccess == err );
	if( FNORMStringHasUndefinedCharsIsSupported() )
		{
		Enforce( fUndefinedUnicode );
		}
	else
		{
///		Enforce( !fUndefinedUnicode );
		}
	}
#endif	//	!RTM

LOCAL VOID FLDNormalizeBinarySegment(
	const BYTE		* const pbField,
	const ULONG		cbField,
	BYTE			* const rgbSeg,
	INT				* const pcbSeg,
	const ULONG		cbKeyAvail,
	const ULONG		cbKeyMost,
	const ULONG		cbVarSegMac,
	const BOOL		fFixedField,
	BOOL			* const pfColumnTruncated,
	ULONG			* pibBinaryColumnDelimiter )
	{
	ULONG			cbSeg;

	Assert( NULL == pibBinaryColumnDelimiter
		|| 0 == *pibBinaryColumnDelimiter );		//	either NULL or initialised to 0
	
	// Null column handled elsewhere.
	Assert( NULL != pbField );
	Assert( cbField > 0 );

	Assert( cbKeyAvail > 0 );
	Assert( cbVarSegMac > 0 );

	// If cbVarSegMac == cbKeyMost, that implies that it
	// was never set.  However, to detect this, the caller
	// artificially increments it to cbKeyMost+1.
	Assert( cbVarSegMac <= cbKeyMost+1 );
	Assert( cbKeyMost != cbVarSegMac );
				
	// if cbVarSegMac was not set (ie. it is cbKeyMost+1),
	// then cbKeyAvail will always be less than it.
	Assert( cbVarSegMac < cbKeyMost || cbKeyAvail < cbVarSegMac );

	rgbSeg[0] = bPrefixData;
			
	if ( fFixedField )
		{
		// calculate size of the normalized column, including header byte
		cbSeg = cbField + 1;

		// First check if we exceeded the segment maximum.
		if ( cbVarSegMac < cbKeyMost && cbSeg > cbVarSegMac )
			{
			cbSeg = cbVarSegMac;
			}
			
		// Once we've fitted the field into the segment
		// maximum, may need to resize further to fit
		// into the total key space.
		if ( cbSeg > cbKeyAvail )
			{
			cbSeg = cbKeyAvail;
			*pfColumnTruncated = fTrue;
			}

		Assert( cbSeg > 0 );
		UtilMemCpy( rgbSeg+1, pbField, cbSeg-1 );
		}
	else
		{
		// The difference between fNormalisedEntireColumn and
		// fColumnTruncated is that fNormaliseEntiredColumn is
		// set to FALSE if we had to truncate the column because
		// of either limited key space or we exceeded the
		// limitation imposed by cbVarSegMac.  fColumnTruncated
		// is only set to TRUE if the column was truncated due
		// to limited key space.
		BOOL			fNormalisedEntireColumn		= fTrue;
		const ULONG		cChunks						= ( cbField + ( cbFLDBinaryChunk-1 ) ) / cbFLDBinaryChunk;
		
		cbSeg = ( cChunks * cbFLDBinaryChunkNormalized ) + 1;		// +1 for header byte
		
		// First check if we exceeded the segment maximum.
		if ( cbVarSegMac < cbKeyMost && cbSeg > cbVarSegMac )
			{
			cbSeg = cbVarSegMac;
			fNormalisedEntireColumn = fFalse;
			}

		// Once we've fitted the field into the segment
		// maximum, may need to resize further to fit
		// into the total key space.
		if ( cbSeg > cbKeyAvail )
			{
			cbSeg = cbKeyAvail;
			fNormalisedEntireColumn = fFalse;
			*pfColumnTruncated = fTrue;
			}

		// At least one chunk, unless truncated.
		Assert( cbSeg > 0 );
		Assert( cbSeg > cbFLDBinaryChunkNormalized || !fNormalisedEntireColumn );
		
		INT 		cbSegRemaining = cbSeg - 1;	// account for header byte
		INT			cbFieldRemaining = cbField;
		BYTE		*pbSeg = rgbSeg + 1;	// skip header byte
		const BYTE	*pbNextChunk = pbField;
		while ( cbSegRemaining >= cbFLDBinaryChunkNormalized )
			{
			Assert( cbFieldRemaining > 0 );
			Assert( pbNextChunk + cbFieldRemaining == pbField + cbField );
	
			if ( cbFieldRemaining <= cbFLDBinaryChunk )
				{
				// This is the last chunk.
				Assert( cbSegRemaining - cbFLDBinaryChunkNormalized == 0 );
				UtilMemCpy( pbSeg, pbNextChunk, cbFieldRemaining );
				pbSeg += cbFieldRemaining;

				if ( NULL != pibBinaryColumnDelimiter )
					{
					Assert( 0 == *pibBinaryColumnDelimiter );
					*pibBinaryColumnDelimiter = ULONG( pbSeg - rgbSeg );
					}

				if ( cbFieldRemaining == cbFLDBinaryChunk )
					{
					// This allows us to differentiate between a
					// a column that is entirely normalised and ends
					// at the end of a chunk and one that is truncated
					// at the end of a chunk.
					if ( fNormalisedEntireColumn )
						*pbSeg++ = cbFLDBinaryChunkNormalized-1;
					else
						*pbSeg++ = cbFLDBinaryChunkNormalized;
					}
				else
					{
					// Zero out rest of chunk.
					memset( pbSeg, 0, cbFLDBinaryChunk - cbFieldRemaining );
					pbSeg += ( cbFLDBinaryChunk - cbFieldRemaining );
					*pbSeg++ = (BYTE)cbFieldRemaining;

					}
					
#ifdef DEBUG
				cbFieldRemaining = 0;
#endif				
				}
			else
				{
				UtilMemCpy( pbSeg, pbNextChunk, cbFLDBinaryChunk );
			
				pbNextChunk += cbFLDBinaryChunk;
				pbSeg += cbFLDBinaryChunk;
				*pbSeg++ = cbFLDBinaryChunkNormalized;

				cbFieldRemaining -= cbFLDBinaryChunk;
				}
				
			cbSegRemaining -= cbFLDBinaryChunkNormalized;
			}

		
		if ( cbSeg >= 1 + cbFLDBinaryChunkNormalized )
			{
			// Able to fit at least one chunk in.
			Assert( pbSeg >= rgbSeg + 1 + cbFLDBinaryChunkNormalized );
			Assert( pbSeg[-1] > 0 );
			Assert( pbSeg[-1] <= cbFLDBinaryChunkNormalized );
			
			// Must have ended up at the end of a chunk.
			Assert( ( pbSeg - ( rgbSeg + 1 ) ) % cbFLDBinaryChunkNormalized == 0 );
			}
		else
			{
			// Couldn't accommodate any chunks.
			Assert( pbSeg == rgbSeg + 1 );
			}

		Assert( cbSegRemaining >= 0 );
		Assert( cbSegRemaining < cbFLDBinaryChunkNormalized );
		if ( cbSegRemaining > 0 )
			{
			Assert( !fNormalisedEntireColumn );
			Assert( cbFieldRemaining > 0 );

			if ( cbFieldRemaining >= cbSegRemaining )
				{
				// Fill out remaining key space.
				UtilMemCpy( pbSeg, pbNextChunk, cbSegRemaining );
				}
			else
				{
				if ( NULL != pibBinaryColumnDelimiter )
					{
					Assert( 0 == *pibBinaryColumnDelimiter );
					*pibBinaryColumnDelimiter = ULONG( pbSeg + cbFieldRemaining - rgbSeg );
					}

				// Entire column will fit, but last bytes don't form
				// a complete chunk.  Pad with zeroes to end of available
				// key space.
				UtilMemCpy( pbSeg, pbNextChunk, cbFieldRemaining );
				memset( pbSeg+cbFieldRemaining, 0, cbSegRemaining - cbFieldRemaining );
				}
			}
		}

	Assert( cbSeg > 0 );
	*pcbSeg = cbSeg;
	}


INLINE VOID FLDNormalizeFixedSegment(
	const BYTE			*pbField,
	const ULONG			cbField,
	BYTE				*rgbSeg,
	INT					*pcbSeg,
	const JET_COLTYP	coltyp,
	BOOL				fDataPassedFromUser = fFalse )	// data in machine format, not necessary little endian format
	{
	WORD				wSrc;
	DWORD				dwSrc;
	QWORD				qwSrc;
	
	rgbSeg[0] = bPrefixData;
	switch ( coltyp )
		{
		//	BIT: prefix with 0x7f, flip high bit
		//
		case JET_coltypBit:
			Assert( 1 == cbField );
			*pcbSeg = 2;
			
			rgbSeg[1] = BYTE( pbField[0] == 0 ? 0x00 : 0xff );
			break;
			
		//	UBYTE: prefix with 0x7f
		//
		case JET_coltypUnsignedByte:
			Assert( 1 == cbField );
			*pcbSeg = 2;
			
			rgbSeg[1] = pbField[0];
			break;

		//	SHORT: prefix with 0x7f, flip high bit
		//
		case JET_coltypShort:
			Assert( 2 == cbField );
			*pcbSeg = 3;
			
			if ( fDataPassedFromUser )
				{
				wSrc = *(Unaligned< WORD >*)pbField;
				}
			else
				{
				wSrc = *(UnalignedLittleEndian< WORD >*)pbField;
				}
				
			*( (UnalignedBigEndian< WORD >*) &rgbSeg[ 1 ] ) = wFlipHighBit( wSrc );
			break;

		//*	LONG: prefix with 0x7f, flip high bit
		//
		//	works because of 2's complement *
		case JET_coltypLong:
			Assert( 4 == cbField );
			*pcbSeg = 5;
			
			if ( fDataPassedFromUser )
				{
				dwSrc = *(Unaligned< DWORD >*)pbField;
				}
			else
				{
				dwSrc = *(UnalignedLittleEndian< DWORD >*)pbField;
				}

			*( (UnalignedBigEndian< DWORD >*) &rgbSeg[ 1 ] ) = dwFlipHighBit( dwSrc );
			break;

		//	REAL: First swap bytes.  Then, if positive:
		//	flip sign bit, else negative: flip whole thing.
		//	Then prefix with 0x7f.
		//
		case JET_coltypIEEESingle:
			Assert( 4 == cbField );
			*pcbSeg = 5;
			
			if ( fDataPassedFromUser )
				{
				dwSrc = *(Unaligned< DWORD >*)pbField;
				}
			else
				{
				dwSrc = *(UnalignedLittleEndian< DWORD >*)pbField;
				}

			if ( dwSrc & maskDWordHighBit )
				{
				*( (UnalignedBigEndian< DWORD >*) &rgbSeg[ 1 ] ) = ~dwSrc;
				}
			else
				{
				*( (UnalignedBigEndian< DWORD >*) &rgbSeg[ 1 ] ) = dwFlipHighBit( dwSrc );
				}
			break;

		//	CURRENCY: First swap bytes.  Then, flip the sign bit
		//
		case JET_coltypCurrency:
			Assert( 8 == cbField );
			*pcbSeg = 9;
			
			if ( fDataPassedFromUser )
				{
				qwSrc = *(Unaligned< QWORD >*)pbField;
				}
			else
				{
				qwSrc = *(UnalignedLittleEndian< QWORD >*)pbField;
				}

			*( (UnalignedBigEndian< QWORD >*) &rgbSeg[ 1 ] ) = qwFlipHighBit( qwSrc );
			break;
		
		//	LONGREAL: First swap bytes.  Then, if positive:
		//	flip sign bit, else negative: flip whole thing.
		//	Then prefix with 0x7f.
		//
		//	Same for DATETIME
		//
		case JET_coltypIEEEDouble:
		case JET_coltypDateTime:
			Assert( 8 == cbField );
			*pcbSeg = 9;
			
			if ( fDataPassedFromUser )
				{
				qwSrc = *(Unaligned< QWORD >*)pbField;
				}
			else
				{
				qwSrc = *(UnalignedLittleEndian< QWORD >*)pbField;
				}

			if ( qwSrc & maskQWordHighBit )
				{
				*( (UnalignedBigEndian< QWORD >*) &rgbSeg[ 1 ] ) = ~qwSrc;
				}
			else
				{
				*( (UnalignedBigEndian< QWORD >*) &rgbSeg[ 1 ] ) = qwFlipHighBit( qwSrc );
				}
			break;

		default:
			Assert( !FRECTextColumn( coltyp ) );	// These types handled elsewhere.
			Assert( !FRECBinaryColumn( coltyp ) );
			Assert( fFalse );
			break;
		}
	}


INLINE VOID FLDNormalizeNullSegment(
	BYTE				*rgbSeg,
	const JET_COLTYP	coltyp,
	const BOOL			fZeroLength,
	const BOOL			fSortNullsHigh )
	{
	const BYTE			bPrefixNullT	= ( fSortNullsHigh ? bPrefixNullHigh : bPrefixNull );
	
	switch ( coltyp )
		{
		//	most nulls are represented by 0x00
		//	zero-length columns are represented by 0x40
		case JET_coltypBit:
		case JET_coltypUnsignedByte:
		case JET_coltypShort:
		case JET_coltypLong:
		case JET_coltypCurrency:
		case JET_coltypIEEESingle:
		case JET_coltypIEEEDouble:
		case JET_coltypDateTime:
			rgbSeg[0] = bPrefixNullT;
			break;
				
		default:
			Assert( FRECTextColumn( coltyp ) || FRECBinaryColumn( coltyp ) );
			rgbSeg[0] = ( fZeroLength ? bPrefixZeroLength : bPrefixNullT );
			break;
		}
	}


ERR ErrFLDNormalizeTaggedData(
	const FIELD *				pfield,
	const DATA&					dataRaw,
	DATA&						dataNorm,
	const IDXUNICODE * const	pidxunicode,
	BOOL *						pfDataTruncated )
	{
	ERR							err			= JET_errSuccess;

	*pfDataTruncated = fFalse;

	if ( 0 == dataRaw.Cb() )
		{
		FLDNormalizeNullSegment(
				(BYTE *)dataNorm.Pv(),
				pfield->coltyp,
				fTrue,				//	cannot normalize NULL via this function
				fFalse );
		dataNorm.SetCb( 1 );
		}
	else
		{
		INT			cb		= 0;
		switch ( pfield->coltyp )
			{
			//	case-insensitive TEXT: convert to uppercase.
			//	If fixed, prefix with 0x7f;  else affix with 0x00
			//
			case JET_coltypText:
			case JET_coltypLongText:
				CallR( ErrFLDNormalizeTextSegment(
							(BYTE *)dataRaw.Pv(),
							dataRaw.Cb(),
							(BYTE *)dataNorm.Pv(),
							&cb,
							KEY::cbKeyMax,
							KEY::cbKeyMax,
							KEY::cbKeyMax+1,
							pfield->cp,
							pidxunicode,
							NULL ) );			//	we don't care if there are undefined chars
				dataNorm.SetCb( cb );
				if ( wrnFLDKeyTooBig == err )
					{
					*pfDataTruncated = fTrue;
					err = JET_errSuccess;
					}
				CallS( err );
				Assert( dataNorm.Cb() > 0 );
				break;

			//	BINARY data: if fixed, prefix with 0x7f;
			//	else break into chunks of 8 bytes, affixing each
			//	with 0x09, except for the last chunk, which is
			//	affixed with the number of bytes in the last chunk.
			//
			case JET_coltypBinary:
			case JET_coltypLongBinary:
				FLDNormalizeBinarySegment(
						(BYTE *)dataRaw.Pv(),
						dataRaw.Cb(),
						(BYTE *)dataNorm.Pv(),
						&cb,
						KEY::cbKeyMax,
						KEY::cbKeyMax,
						KEY::cbKeyMax+1,
						fFalse,					//	only called for tagged columns
						pfDataTruncated,
						NULL );
				dataNorm.SetCb( cb );
				break;

			default:
				FLDNormalizeFixedSegment(
						(BYTE *)dataRaw.Pv(),
						dataRaw.Cb(),
						(BYTE *)dataNorm.Pv(),
						&cb,
						pfield->coltyp );
				dataNorm.SetCb( cb );
				break;
			}
		}

	return err;
	}


//+API
//	ErrRECIRetrieveKey
//	========================================================
//	ErrRECIRetrieveKey( FUCB *pfucb, TDB *ptdb, IDB *pidb, DATA *plineRec, KEY *pkey, ULONG itagSequence )
//
//	Retrieves the normalized key from a record, based on an index descriptor.
//
//	PARAMETERS
//		pfucb			cursor for record
//	 	ptdb		  	column info for index
// 		pidb		  	index key descriptor
// 		plineRec	  	data record to retrieve key from
// 		pkey		  	buffer to put retrieve key in; pkey->pv must
//						point to a large enough buffer, cbKeyMost bytes.
// 		itagSequence  	A secondary index whose key contains a tagged
//						column segment will have an index entry made for
//						each value of the tagged column, each refering to
//						the same record.  This parameter specifies which
//						occurance of the tagged column should be included
//						in the retrieve key.
//
//	RETURNS	Error code, one of:
//		JET_errSuccess		success
//		+wrnFLDNullKey	   	key has all NULL segments
//		+wrnFLDNullSeg	   	key has NULL segment
//
//	COMMENTS
//		Key formation is as follows:  each key segment is retrieved
//		from the record, transformed into a normalized form, and
//		complemented if it is "descending" in the key.	The key is
//		formed by concatenating each such transformed segment.
//-
ERR ErrRECIRetrieveKey(
	FUCB	  			*pfucb,
	const IDB			* const pidb,
	DATA&				lineRec,
	KEY	 				*pkey,
	const ULONG			itagSequence,
	const ULONG			ichOffset,
	BOOL * const 		pfUndefinedUnicodeChars,
	const BOOL			fRetrieveLVBeforeImage,
	RCE					*prce )
	{
	ERR	 				err							= JET_errSuccess;
	FCB					* const pfcbTable			= pfucb->u.pfcb;
	FCB	 				* pfcb						= pfcbTable;
	BOOL	  			fAllNulls					= fTrue;	// Assume all null, until proven otherwise
	BOOL	  			fNullFirstSeg				= fFalse; 	// Assume no null first segment
	BOOL	  			fNullSeg					= fFalse;	// Assume no null segments
	BOOL	  			fColumnTruncated			= fFalse;
	BOOL	  			fKeyTruncated				= fFalse;
	BOOL	  			fSawMultivalue				= fFalse;
	BOOL				fUndefinedUnicode			= fFalse;
	const BOOL			fPageInitiallyLatched		= Pcsr( pfucb )->FLatched();
	const BOOL			fTupleIndex					= pidb->FTuples();
	BOOL				fPageLatched				= fPageInitiallyLatched;

	BYTE	  			*pbSeg;					  				// Pointer to current segment
	ULONG 				cbKeyAvail;				  				// Space remaining in key buffer
	const IDXSEG 		*pidxseg;
	const IDXSEG 		*pidxsegMac;
	IDXSEG				rgidxseg[JET_ccolKeyMost];
	IDXSEG				rgidxsegConditional[JET_ccolKeyMost];
	const BOOL			fOnRecord					= ( lineRec == pfucb->kdfCurr.data );
	BOOL				fTransactionStarted			= fFalse;
	const BOOL			fRetrieveBasedOnRCE			= ( prceNil != prce );
	BYTE				rgbLV[KEY::cbKeyMax];					// long value support

	Assert( pkey != NULL );
	Assert( !pkey->FNull() );
	Assert( pfcb->Ptdb() != ptdbNil );
	Assert( pidb != pidbNil );
	Assert( pidb->Cidxseg() > 0 );

	if( pfUndefinedUnicodeChars )
		{
		*pfUndefinedUnicodeChars = fFalse;
		}

	//	page is only latched if we're coming from CreateIndex
	if ( fPageInitiallyLatched )
		{
		Assert( fOnRecord );
		Assert( locOnCurBM == pfucb->locLogical );
		Assert( !fRetrieveLVBeforeImage );
		Assert( !fRetrieveBasedOnRCE );
		Assert( pfucb->ppib->level > 0 );
		}

	//	check cbVarSegMac and set to key most plus one if no column
	//	truncation enabled.  This must be done for subsequent truncation
	// 	checks.
	//
	const ULONG	cbKeyMost		= KEY::CbKeyMost( pidb->FPrimary() );

	Assert( pidb->CbVarSegMac() > 0 );
	Assert( pidb->CbVarSegMac() <= cbKeyMost );

	const ULONG cbVarSegMac		= ( cbKeyMost == pidb->CbVarSegMac() ?
										cbKeyMost+1 :
										pidb->CbVarSegMac() );
	Assert( cbVarSegMac > 0 );
	Assert( cbVarSegMac < cbKeyMost || cbVarSegMac == cbKeyMost+1 );

	const BOOL	fSortNullsHigh	= pidb->FSortNullsHigh();


	//	start at beginning of buffer, with max size remaining.
	//
	Assert( pkey->prefix.FNull() );
	pbSeg = (BYTE *)pkey->suffix.Pv();
	cbKeyAvail = cbKeyMost;

	//	fRetrieveFromLVBuf flags whether or not we have to check in the LV buffer.
	//	We only check in the LV buffer if one exists, and if we are looking for the
	//	before-image (as specified by the parameter passed in).  Assert that this
	//	only occurs during a Replace.
	//
	Assert( fRetrieveBasedOnRCE
		|| !fRetrieveLVBeforeImage
		|| FFUCBReplacePrepared( pfucb ) );

	//	retrieve each segment in key description
	//
	if ( pidb->FTemplateIndex() )
		{
		Assert( pfcb->FDerivedTable() || pfcb->FTemplateTable() );
		if ( pfcb->FDerivedTable() )
			{
			// switch to template table
			pfcb = pfcb->Ptdb()->PfcbTemplateTable();
			Assert( pfcbNil != pfcb );
			Assert( pfcb->FTemplateTable() );
			}
		else
			{
			Assert( pfcb->Ptdb()->PfcbTemplateTable() == pfcbNil );
			}
		}

	pfcb->EnterDML();
	UtilMemCpy( rgidxseg, PidxsegIDBGetIdxSeg( pidb, pfcb->Ptdb() ), pidb->Cidxseg() * sizeof(IDXSEG) );
	UtilMemCpy( rgidxsegConditional, PidxsegIDBGetIdxSegConditional( pidb, pfcb->Ptdb() ), pidb->CidxsegConditional() * sizeof(IDXSEG) );
	pfcb->LeaveDML();

	//	if we're looking at a record, then make sure we're in
	//	a transaction to ensure read consistency
	if ( fOnRecord && 0 == pfucb->ppib->level )
		{
		Assert( !fPageInitiallyLatched );
		Assert( !Pcsr( pfucb )->FLatched() );

		//	UNDONE: only time we're not in a transaction is if we got
		//	here via ErrRECIGotoBookmark() -- can it be eliminated??
		CallR( ErrDIRBeginTransaction( pfucb->ppib, JET_bitTransactionReadOnly ) );
		fTransactionStarted = fTrue;
		}

	//  if the idxsegConditional doesn't match return wrnFLDRecordNotPresentInIndex
	pidxseg = rgidxsegConditional;	
	pidxsegMac = pidxseg + pidb->CidxsegConditional();
	for ( ; pidxseg < pidxsegMac; pidxseg++ )
		{		
		const COLUMNID	columnidConditional 	= pidxseg->Columnid();
		const BOOL		fMustBeNull				= pidxseg->FMustBeNull();
		BOOL			fColumnIsNull			= fFalse;
		DATA   			dataField;

		if ( fOnRecord && !fPageLatched )
			{
			Assert( !fPageInitiallyLatched || locOnCurBM == pfucb->locLogical );
			Call( ErrDIRGet( pfucb ) );
			fPageLatched = fTrue;
			}

#ifdef DEBUG
		//	page should be latched iff key is retrieved from record
		if ( fOnRecord )
			{
			Assert( Pcsr( pfucb )->FLatched() );
			}
		else
			{
			Assert( !Pcsr( pfucb )->FLatched() );
			}
#endif	//	DEBUG

		//	get segment value:
		Assert( !lineRec.FNull() );
		if ( FCOLUMNIDTagged( columnidConditional ) )
			{
			err = ErrRECRetrieveTaggedColumn(
						pfcbTable,
						columnidConditional,
						1,
						lineRec,
						&dataField );

			if( wrnRECUserDefinedDefault == err )
				{
				//  if this is a user-defined default we should execute the callback
				//  and let the callback possibly return JET_wrnColumnNull
				
				//  release the page and retrieve the appropriate copy of the user-defined-default
				if ( fPageLatched )
					{
					Assert( !fPageInitiallyLatched || locOnCurBM == pfucb->locLogical );
					CallS( ErrDIRRelease( pfucb ) );
					fPageLatched = fFalse;
					}

				//  if we aren't on the record we'll point the copy buffer to the record and
				//  retrieve from there. save off the old value
				DATA	dataSaved	= pfucb->dataWorkBuf;

				const BOOL fAlwaysRetrieveCopy 	= FFUCBAlwaysRetrieveCopy( pfucb );
				const BOOL fNeverRetrieveCopy	= FFUCBNeverRetrieveCopy( pfucb );

				Assert( !( fAlwaysRetrieveCopy && fNeverRetrieveCopy ) );

				if( fOnRecord )
					{
					FUCBSetNeverRetrieveCopy( pfucb );
					}
				else
					{
					pfucb->dataWorkBuf = lineRec;
					FUCBSetAlwaysRetrieveCopy( pfucb );
					}

#ifdef SYNC_DEADLOCK_DETECTION
				//  At this point we have the Indexing/Updating latch
				//  turn off the checks to avoid asserts
				COwner * pownerSaved;
				UtilAssertCriticalSectionCanDoIO();
				pownerSaved = Pcls()->pownerLockHead;
#endif	//	SYNC_DEADLOCK_DETECTION

				ULONG	cbActual	= sizeof( rgbLV );
				err = ErrRECCallback(
					pfucb->ppib,		
					pfucb,
					JET_cbtypUserDefinedDefaultValue,
					columnidConditional,
					NULL,
					&cbActual,
					columnidConditional );

#ifdef SYNC_DEADLOCK_DETECTION
				Assert( Pcls()->pownerLockHead == pownerSaved );
#endif	//	SYNC_DEADLOCK_DETECTION

				pfucb->dataWorkBuf = dataSaved;
				FUCBResetAlwaysRetrieveCopy( pfucb );
				FUCBResetNeverRetrieveCopy( pfucb );

				if( fAlwaysRetrieveCopy )
					{
					FUCBSetAlwaysRetrieveCopy( pfucb );
					}
				else if ( fNeverRetrieveCopy )
					{
					FUCBSetNeverRetrieveCopy( pfucb );
					}

				Call( err );
				}
			}
		else
			{
			err = ErrRECRetrieveNonTaggedColumn(
						pfcbTable,
						columnidConditional,
						lineRec,
						&dataField,
						pfieldNil );
			}
		Assert( err >= 0 );

		fColumnIsNull = ( JET_wrnColumnNull == err );
		
		if( fMustBeNull && !fColumnIsNull )
			{
			err = ErrERRCheck( wrnFLDNotPresentInIndex );
			goto HandleError;
			}
		else if( !fMustBeNull && fColumnIsNull )
			{
			err = ErrERRCheck( wrnFLDNotPresentInIndex );
			goto HandleError;
			}
		}
		
	pidxseg = rgidxseg;	
	pidxsegMac = pidxseg + pidb->Cidxseg();
	for ( ; pidxseg < pidxsegMac; pidxseg++ )
		{
		FIELD 			field;
		BYTE   			*pbField = 0;					// pointer to column data.
		ULONG			cbField = 0xffffffff;			// length of column data.
		BYTE   			rgbSeg[ KEY::cbKeyMax ]; 		// segment buffer.
		DATA 	  		dataField;
		INT				cbSeg		= 0;				// length of segment.
		const COLUMNID	columnid	= pidxseg->Columnid();
		const BOOL		fDescending	= pidxseg->FDescending();
		const BOOL		fFixedField	= FCOLUMNIDFixed( columnid );

		// No need to check column access -- since the column belongs
		// to an index, it MUST be available.  It can't be deleted, or
		// even versioned deleted.
		pfcb->EnterDML();
		field = *( pfcb->Ptdb()->Pfield( columnid ) );
		pfcb->LeaveDML();

		//	Determine the offsets for the tuple indexing
		//	When retrieveing a long-value, we retrieve data starting at the offset,
		//	otherwise we have to index into the data. fTupleAdjusted keeps track of
		//	whether the adjustment has been done
		//	If fTupleAdjust is true then dataField.Pv() points to the ibTupleOffset
		//	offset in the data

		ULONG		ibTupleOffset		= 0;
		BOOL		fTupleAdjusted		= fFalse;	
		
		if ( fTupleIndex )
			{
			Assert( FRECTextColumn( field.coltyp ) );

			//	caller should have verified whether we've
			//	exceeded maximum allowable characters to
			//	index in this string 
			Assert( ichOffset < pidb->ChTuplesToIndexMax() );

			//	normalise counts to account for Unicode
			ibTupleOffset		= ( usUniCodePage == field.cp ? ichOffset * 2 : ichOffset );
			}
		
		Assert( !FFIELDDeleted( field.ffield ) );
		Assert( JET_coltypNil != field.coltyp );
		Assert( !FCOLUMNIDVar( columnid ) || field.coltyp == JET_coltypBinary || field.coltyp == JET_coltypText );
		Assert( !FFIELDMultivalued( field.ffield ) || FCOLUMNIDTagged( columnid ) );

		if ( fOnRecord && !fPageLatched )
			{
			// Obtain latch only if we're retrieving from the record and
			// this is the first time through, or if we had to give
			// up the latch on a previous iteration.
			Assert( !fPageInitiallyLatched || locOnCurBM == pfucb->locLogical );
			Call( ErrDIRGet( pfucb ) );
			fPageLatched = fTrue;
			}

		//	page should be latched iff key is retrieved from record
		//
		if ( fOnRecord )
			{
			Assert( Pcsr( pfucb )->FLatched() );
			}
		else
			{
			Assert( !Pcsr( pfucb )->FLatched() );
			}

		//	get segment value:
		Assert( !lineRec.FNull() );
		if ( FCOLUMNIDTagged( columnid ) )
			{
			err = ErrRECRetrieveTaggedColumn(
						pfcbTable,
						columnid,
						( FFIELDMultivalued( field.ffield ) && !fSawMultivalue ) ? itagSequence : 1,
						lineRec,
						&dataField );
			}
		else
			{
			err = ErrRECRetrieveNonTaggedColumn(
						pfcbTable,
						columnid,
						lineRec,
						&dataField,
						&field );
			}
		Assert( err >= 0 );

		//	with no space left in the key buffer we cannot insert any more 
		//	normalised keys
		//
		if ( cbKeyAvail == 0 )
			{
			fKeyTruncated = fTrue;

			//	only one column in a tuple index, so we're guaranteed
			//	to always have available key space
			Assert( !pidb->FTuples() );

			//	check if column is NULL for tagged column support
			//
			if ( JET_wrnColumnNull == err )
				{
				//	cannot be all NULL and cannot be first NULL
				//	since key truncated.
				//
				Assert( itagSequence >= 1 );
				if ( itagSequence > 1
					&& FFIELDMultivalued( field.ffield )
					&& !fSawMultivalue )
					{
					err = ErrERRCheck( wrnFLDOutOfKeys );
					goto HandleError;
					}
				else
					{
					if ( pidxseg == rgidxseg )
						fNullFirstSeg = fTrue;
					fNullSeg = fTrue;
					}
				}

			Assert( JET_errSuccess == err
				|| wrnRECSeparatedLV == err
				|| wrnRECIntrinsicLV == err
				|| wrnRECUserDefinedDefault == err
				|| JET_wrnColumnNull == err );
			err = JET_errSuccess;
			
			if ( FFIELDMultivalued( field.ffield ) )
				fSawMultivalue = fTrue;
				
			continue;
			}

		Assert( cbKeyAvail > 0 );
		if ( wrnRECUserDefinedDefault == err )
			{
			//  release the page and retrieve the appropriate copy of the user-defined-default
			if ( fPageLatched )
				{
				Assert( !fPageInitiallyLatched || locOnCurBM == pfucb->locLogical );
				CallS( ErrDIRRelease( pfucb ) );
				fPageLatched = fFalse;
				}

			//  if we aren't on the record we'll point the copy buffer to the record and
			//  retrieve from there. save off the old value
			DATA dataSaved = pfucb->dataWorkBuf;

			const BOOL fAlwaysRetrieveCopy 	= FFUCBAlwaysRetrieveCopy( pfucb );
			const BOOL fNeverRetrieveCopy	= FFUCBNeverRetrieveCopy( pfucb );

			Assert( !( fAlwaysRetrieveCopy && fNeverRetrieveCopy ) );
			
			if( fOnRecord )
				{
				FUCBSetNeverRetrieveCopy( pfucb );
				}
			else
				{
				pfucb->dataWorkBuf = lineRec;
				FUCBSetAlwaysRetrieveCopy( pfucb );
				}

#ifdef SYNC_DEADLOCK_DETECTION
			//  At this point we have the Indexing/Updating latch
			//  turn off the checks to avoid asserts
			COwner * pownerSaved;
			UtilAssertCriticalSectionCanDoIO();
			pownerSaved = Pcls()->pownerLockHead;
#endif	//	SYNC_DEADLOCK_DETECTION

			ULONG cbActual;
			cbActual = sizeof( rgbLV );
			err = ErrRECCallback(
				pfucb->ppib,		
				pfucb,
				JET_cbtypUserDefinedDefaultValue,
				columnid,
				rgbLV,
				&cbActual,
				columnid );

#ifdef SYNC_DEADLOCK_DETECTION
			Assert( Pcls()->pownerLockHead == pownerSaved );
#endif	//	SYNC_DEADLOCK_DETECTION

			pfucb->dataWorkBuf = dataSaved;
			FUCBResetAlwaysRetrieveCopy( pfucb );
			FUCBResetNeverRetrieveCopy( pfucb );

			if( fAlwaysRetrieveCopy )
				{
				FUCBSetAlwaysRetrieveCopy( pfucb );
				}
			else if ( fNeverRetrieveCopy )
				{
				FUCBSetNeverRetrieveCopy( pfucb );
				}

			Call( err );

			dataField.SetPv( rgbLV );
			dataField.SetCb( min( cbActual, sizeof(rgbLV) ) );

			if ( JET_wrnBufferTruncated == err )
				err = JET_errSuccess;
			}

		else if ( wrnRECSeparatedLV == err )
			{
			const LID	lid				= LidOfSeparatedLV( dataField );
			const BOOL	fAfterImage		= !fRetrieveLVBeforeImage;
			ULONG		cbActual;

			if ( fRetrieveBasedOnRCE )
				{
				Assert( !fOnRecord );
				Assert( !fPageLatched );
				Assert( !fPageInitiallyLatched );
				Assert( !Pcsr( pfucb )->FLatched() );

				Assert( prceNil != prce );
				Assert( prce->TrxCommitted() != trxMax
						|| ppibNil != prce->Pfucb()->ppib );

				Call( ErrRECRetrieveSLongField( 
							pfucb,
							lid,
							fAfterImage,
							ibTupleOffset,
							rgbLV,
							sizeof( rgbLV ),
							&cbActual,
							NULL,
							NULL,
							prce ) );

				// Verify all latches released after LV call.
				Assert( !Pcsr( pfucb )->FLatched() );
					
				dataField.SetPv( rgbLV );
				dataField.SetCb( cbActual );
				}
			
			// First check in the LV buffer (if allowed).
			else
				{
				Assert( prceNil == prce );

				if ( fPageLatched )
					{
					Assert( !fPageInitiallyLatched || locOnCurBM == pfucb->locLogical );
					CallS( ErrDIRRelease( pfucb ) );
					fPageLatched = fFalse;
					}

				Call( ErrRECRetrieveSLongField( 
							pfucb,
							lid,
							fAfterImage,
							ibTupleOffset,
							rgbLV,
							sizeof( rgbLV ),
							&cbActual,
							NULL,
							NULL ) );

				// Verify all latches released after LV call.
				Assert( !Pcsr( pfucb )->FLatched() );

				dataField.SetPv( rgbLV );
				dataField.SetCb( cbActual );
				}

			if( fTupleIndex )
				{				
				//	dataField now points to the correct offset in the long-value
				
				fTupleAdjusted = fTrue;
				}
			
			// Trim returned value if necessary.
			if ( dataField.Cb() > cbKeyMost )
				{
				dataField.SetCb( cbKeyMost );
				}

			Assert( JET_wrnColumnNull != err );
			err = JET_errSuccess;
			}
		else if ( wrnRECIntrinsicLV == err )
			{
			if ( fTupleIndex )
				{
				//	fixup the data to take the tupleOffset into account
				const INT cbDelta = min( dataField.Cb(), ibTupleOffset );
				dataField.DeltaPv( cbDelta );
				dataField.DeltaCb( -cbDelta );

				// dataField now points to the correct offset in the long-value
				fTupleAdjusted = fTrue;				
				}
			
			// Trim returned value if necessary.
			if ( dataField.Cb() > cbKeyMost )
				{
				dataField.SetCb( cbKeyMost );
				}
			
			err = JET_errSuccess;
			}
		else
			{
			CallSx( err, JET_wrnColumnNull );
			}

		if ( FFIELDMultivalued( field.ffield ) && !fSawMultivalue )
			{
			if ( itagSequence > 1 && JET_wrnColumnNull == err )
				{
				err = ErrERRCheck( wrnFLDOutOfKeys );
				goto HandleError;
				}
			fSawMultivalue = fTrue;
			}

		CallSx( err, JET_wrnColumnNull );
		Assert( dataField.Cb() <= cbKeyMost );

		if ( fTupleIndex )
			{
			//	normalise counts to account for Unicode
			//	return wrnFLDOutOfTuples if we don't have enough data

			const BYTE *  	pbFieldT	= (BYTE *)dataField.Pv();
			const ULONG		cbFieldT	= dataField.Cb();
			const ULONG		cbFieldMax	= ( usUniCodePage == field.cp ? pidb->ChTuplesLengthMax() * 2 : pidb->ChTuplesLengthMax() );
			const ULONG		cbFieldMin	= ( usUniCodePage == field.cp ? pidb->ChTuplesLengthMin() * 2 : pidb->ChTuplesLengthMin() );
			
			if ( JET_wrnColumnNull == err )
				{
				//	we didn't get any data
				
				dataField.SetPv( NULL );
				dataField.SetCb( 0 );
				}
			else if( fTupleAdjusted )
				{
				//	dataField.Pv() is already offset to the appropriate position
				//	dataField.Cb() is min( dataRemaining, sizeof( rgbLV ) )
				}
			else if( pbFieldT + ibTupleOffset <= pbFieldT + cbFieldT )
				{
				//	we have at least some of the data we want to index
				
				dataField.DeltaPv( ibTupleOffset );				
				dataField.DeltaCb( -ibTupleOffset );				
				}
			else
				{
				//	the data we got is all beyond the end of the (non-adjusted) buffer
				
				dataField.SetPv( NULL );
				dataField.SetCb( 0 );
				}

			dataField.SetCb( min( dataField.Cb(), cbFieldMax ) );
			if( dataField.Cb() < cbFieldMin )
				{
				//	this means that we are at the end of the data and are trying to index a tuple that is too small (possibly 0 bytes)
				err = ErrERRCheck( wrnFLDOutOfTuples );
				goto HandleError;
				}
			}

		cbField = dataField.Cb();
		pbField = (BYTE *)dataField.Pv();

		//	segment transformation: check for null column or zero-length columns first
		//	err == JET_wrnColumnNull => Null column
		//	zero-length column otherwise,
		//
		Assert( cbKeyAvail > 0 );
		if ( JET_wrnColumnNull == err || pbField == NULL || cbField == 0 )
			{
			if ( JET_wrnColumnNull == err )
				{
				if ( pidxseg == rgidxseg )
					fNullFirstSeg = fTrue;
				fNullSeg = fTrue;
				}
			else
				{
				// Only variable-length binary and text columns
				// can be zero-length.
				Assert( !fFixedField );
				Assert( FRECTextColumn( field.coltyp ) || FRECBinaryColumn( field.coltyp ) );
				fAllNulls = fFalse;
				}

			FLDNormalizeNullSegment(
					rgbSeg,
					field.coltyp,
					JET_wrnColumnNull != err,
					fSortNullsHigh );
			cbSeg = 1;
			}

		else
			{
			//	column is not null-valued: perform transformation
			//
			fAllNulls = fFalse;

			switch ( field.coltyp )
				{
				//	case-insensetive TEXT: convert to uppercase.
				//	If fixed, prefix with 0x7f;  else affix with 0x00
				//
				case JET_coltypText:
				case JET_coltypLongText:

					//	we only need to know if any segment had undefined
					//	chars, so we stop checking as soon as we find one
					
					Call( ErrFLDNormalizeTextSegment(
								pbField,
								cbField,
								rgbSeg,
								&cbSeg,
								cbKeyAvail,
								cbKeyMost,
								cbVarSegMac,
								field.cp,
								pidb->Pidxunicode(),
								( !pfUndefinedUnicodeChars || fUndefinedUnicode ) ? NULL : &fUndefinedUnicode ) );
					Assert( JET_errSuccess == err || wrnFLDKeyTooBig == err );
					if ( wrnFLDKeyTooBig == err )
						{
						fColumnTruncated = fTrue;
						err = JET_errSuccess;
						}
					Assert( cbSeg > 0 );
					break;

				//	BINARY data: if fixed, prefix with 0x7f;
				//	else break into chunks of 8 bytes, affixing each
				//	with 0x09, except for the last chunk, which is
				//	affixed with the number of bytes in the last chunk.
				//
				case JET_coltypBinary:
				case JET_coltypLongBinary:
					FLDNormalizeBinarySegment(
							pbField,
							cbField,
							rgbSeg,
							&cbSeg,
							cbKeyAvail,
							cbKeyMost,
							cbVarSegMac,
							fFixedField,
							&fColumnTruncated,
							NULL );
					break;

				default:
					FLDNormalizeFixedSegment(
							pbField,
							cbField,
							rgbSeg,
							&cbSeg,
							field.coltyp );
					break;
				}
			}

		//	if key has not already been truncated, then append
		//	normalized key segment.  If insufficient room in key
		//	for key segment, then set key truncated to fTrue.  No
		//	additional key data will be appended after this append.
		//
		if ( !fKeyTruncated )
			{
			//	if column truncated or insufficient room in key
			//	for key segment, then set key truncated to fTrue.
			//	Append variable size column keys only.
			//
			if ( fColumnTruncated )
				{
				fKeyTruncated = fTrue;

				Assert( FRECTextColumn( field.coltyp ) || FRECBinaryColumn( field.coltyp ) );

				// If truncating, in most cases, we fill up as much
				// key space as possible.  The only exception is
				// for non-fixed binary columns, which are
				// broken up into chunks.
				if ( cbSeg != cbKeyAvail )
					{
					Assert( cbSeg < cbKeyAvail );
					Assert( !fFixedField );
					Assert( FRECBinaryColumn( field.coltyp ) );
					Assert( cbKeyAvail - cbSeg < cbFLDBinaryChunkNormalized );
					}
				}
			else if ( cbSeg > cbKeyAvail )
				{
				fKeyTruncated = fTrue;

				// Put as much as possible into the key space.
				cbSeg = cbKeyAvail;
				}

			//	if descending, flip all bits of transformed segment
			//
			if ( fDescending && cbSeg > 0 )
				{
				BYTE *pb;

				for ( pb = rgbSeg + cbSeg - 1; pb >= (BYTE*)rgbSeg; pb-- )
					*pb ^= 0xff;
				}

			Assert( cbKeyAvail >= cbSeg );
			UtilMemCpy( pbSeg, rgbSeg, cbSeg );
			pbSeg += cbSeg;
			cbKeyAvail -= cbSeg;
			}
			
		}	// for

	//	compute length of key and return error code
	//
	Assert( pkey->prefix.FNull() );
	pkey->suffix.SetCb( pbSeg - (BYTE *) pkey->suffix.Pv() );
	if ( fAllNulls )
		err = ErrERRCheck( wrnFLDNullKey );
	else if ( fNullFirstSeg )
		err = ErrERRCheck( wrnFLDNullFirstSeg );
	else if ( fNullSeg )
		err = ErrERRCheck( wrnFLDNullSeg );

	if( pfUndefinedUnicodeChars && fUndefinedUnicode )
		{
		*pfUndefinedUnicodeChars = fTrue;
		}
	
#ifdef DEBUG
	switch ( err )
		{
		case wrnFLDNullKey:
		case wrnFLDNullFirstSeg:
		case wrnFLDNullSeg:
			break;
		default:
			CallS( err );
		}
#endif		
		
HandleError:
	if ( fPageLatched )
		{
		if ( !fPageInitiallyLatched )
			{
			CallS( ErrDIRRelease( pfucb ) );
			}
		}
	else if ( fPageInitiallyLatched && err >= 0 )
		{
		const ERR	errT	= ErrBTGet( pfucb );
		if ( errT < 0 )
			err = errT;
		}
	Assert( !fPageInitiallyLatched || locOnCurBM == pfucb->locLogical );

	if ( fTransactionStarted )
		{
		//	No updates performed, so force success.
		Assert( fOnRecord );
		Assert( !fPageInitiallyLatched );
		CallS( ErrDIRCommitTransaction( pfucb->ppib, NO_GRBIT ) );
		}
	
	return err;
	}


INLINE VOID FLDISetFullColumnLimit(
	DATA		* const plineNorm,
	const ULONG	cbAvailWithSuffix,
	const BOOL	fNeedSentinel )
	{
	if ( fNeedSentinel )
		{
		Assert( cbAvailWithSuffix > 0 );
		Assert( cbAvailWithSuffix <= cbKeyMostWithOverhead );
		Assert( plineNorm->Cb() < cbAvailWithSuffix );

		BYTE	* const pbNorm				= (BYTE *)plineNorm->Pv() + plineNorm->Cb();
		const	ULONG	cbSentinelPadding	= cbAvailWithSuffix - plineNorm->Cb();

		//	pad rest of key space with 0xff
		memset( pbNorm, bSentinel, cbSentinelPadding );
		plineNorm->DeltaCb( cbSentinelPadding );
		}
	}

INLINE VOID FLDISetPartialColumnLimitOnTextColumn(
	DATA			*plineNorm,
	const ULONG		cbAvailWithSuffix,
	const BOOL		fDescending,
	const BOOL		fNeedSentinel,
	const USHORT	cp )
	{
	ULONG			ibT;
	const ULONG		ibSuffix			= cbAvailWithSuffix - 1; 
	BYTE			* const pbNorm		= (BYTE *)plineNorm->Pv();

	Assert( plineNorm->Cb() > 0 );		//	must be at least a prefix byte
	Assert( cbAvailWithSuffix > 0 );					//	Always have a suffix byte reserved for limit purposes
	Assert( cbAvailWithSuffix <= cbKeyMostWithOverhead );
	Assert( plineNorm->Cb() < cbAvailWithSuffix );

	if ( plineNorm->Cb() < 2 )
		{
		//	cannot effect partial column limit,
		//	so set full column limit instead
		FLDISetFullColumnLimit( plineNorm, cbAvailWithSuffix, fNeedSentinel );
		return;
		}

	if ( usUniCodePage == cp )
		{
		const BYTE	bUnicodeDelimiter	= BYTE( fDescending ? 0xfe : 0x01 );

		//	find end of base char weight and truncate key
		//	Append 0xff as first byte of next character as maximum
		//	possible value.
		//
		for ( ibT = 1;		//	skip header byte
			pbNorm[ibT] != bUnicodeDelimiter && ibT < ibSuffix;
			ibT += 2 )
			;
		}
	else
		{
		const BYTE	bTerminator			= BYTE( fDescending ? 0xff : 0x00 );

		ibT = plineNorm->Cb();

		if ( bTerminator == pbNorm[ibT-1] )
			{
			// Strip off null-terminator.
			ibT--;
			Assert( plineNorm->Cb() >= 1 );
			}
		else
			{
			//	must be at the end of key space
			Assert( plineNorm->Cb() == ibSuffix );
			}

		Assert( ibT <= ibSuffix );
		}

	ibT = min( ibT, ibSuffix );
	if ( fNeedSentinel )
		{
		//	starting at the delimiter, fill the rest of key
		//	space with the sentinel
		memset(
			pbNorm + ibT,
			bSentinel,
			ibSuffix - ibT + 1 );
		plineNorm->SetCb( cbAvailWithSuffix );
		}
	else
		{
		//	just strip off delimeter (or suffix byte if we spilled over it)
		plineNorm->SetCb( ibT );
		}
	}


//	try to set partial column limit, but set full column limit if can't
INLINE VOID FLDITrySetPartialColumnLimitOnBinaryColumn(
	DATA			* const plineNorm,
	const ULONG		cbAvailWithSuffix,
	const ULONG		ibBinaryColumnDelimiter,
	const BOOL		fNeedSentinel )
	{
	Assert( plineNorm->Cb() > 0 );		//	must be at least a prefix byte
	Assert( cbAvailWithSuffix > 0 );					//	Always have a suffix byte reserved for limit purposes
	Assert( cbAvailWithSuffix <= cbKeyMostWithOverhead );
	Assert( plineNorm->Cb() < cbAvailWithSuffix );

#ifdef DEBUG
	if ( 0 != ibBinaryColumnDelimiter )
		{
		Assert( plineNorm->Cb() > 1 );
		Assert( ibBinaryColumnDelimiter > 1 );
		Assert( ibBinaryColumnDelimiter < plineNorm->Cb() );
		}
#endif		

	if ( 0 == ibBinaryColumnDelimiter )
		{
		//	cannot effect partial column limit,
		//	so set full column limit instead
		FLDISetFullColumnLimit( plineNorm, cbAvailWithSuffix, fNeedSentinel );
		}
	else if ( fNeedSentinel )
		{
		//	starting at the delimiter, fill up to the end
		//	of the chunk with the sentinel
		//	UNDONE (jliem): go one past just to be safe, but I
		//	couldn't prove whether or not it is really needed
		plineNorm->DeltaCb( 1 );
		memset(
			(BYTE *)plineNorm->Pv() + ibBinaryColumnDelimiter,
			bSentinel,
			plineNorm->Cb() - ibBinaryColumnDelimiter );
		}
	else
		{
		//	just strip off delimiting bytes
		plineNorm->SetCb( ibBinaryColumnDelimiter );
		}
	}


LOCAL ERR ErrFLDNormalizeSegment(
	FUCB				* const pfucb,
	IDB					* const pidb,
	DATA				* const plineColumn,
	DATA				* const plineNorm,
	const JET_COLTYP	coltyp,
	const USHORT		cp,
	const ULONG			cbAvail,
	const BOOL			fDescending,
	const BOOL			fFixedField,
	const JET_GRBIT		grbit )
	{
	INT	 	  			cbColumn;
	BYTE 				* pbColumn;
	BYTE				* const pbNorm				= (BYTE *)plineNorm->Pv();
	ULONG				ibBinaryColumnDelimiter		= 0;

		
	//	check cbVarSegMac and set to key most plus one if no column
	//	truncation enabled.  This must be done for subsequent truncation
	// 	checks.
	//
	const ULONG	cbKeyMost		= KEY::CbKeyMost( pidb->FPrimary() );
	
	Assert( pidb->CbVarSegMac() > 0 );
	Assert( pidb->CbVarSegMac() <= cbKeyMost );
	
	const ULONG cbVarSegMac		= ( cbKeyMost == pidb->CbVarSegMac() ?
										cbKeyMost+1 :
										pidb->CbVarSegMac() );
	Assert( cbVarSegMac > 0 );
	Assert( cbVarSegMac < cbKeyMost || cbVarSegMac == cbKeyMost+1 );

	const BOOL	fSortNullsHigh	= pidb->FSortNullsHigh();


	//	check for null or zero-length column first
	//	plineColumn == NULL implies null-column,
	//	zero-length otherwise
	//
	Assert( !FKSTooBig( pfucb ) );
	Assert( cbAvail > 0 );
	if ( NULL == plineColumn || NULL == plineColumn->Pv() || 0 == plineColumn->Cb() )
		{
		if ( pidb->FTuples() )
			{
			Assert( FRECTextColumn( coltyp ) );
			Assert( pidb->ChTuplesLengthMin() > 0 );
			return ErrERRCheck( JET_errIndexTuplesKeyTooSmall );
			}
		else
			{
			// Only variable binary and text columns can be zero-length.
			Assert( !( grbit & JET_bitKeyDataZeroLength ) || !fFixedField );
			
			const BOOL	fZeroLength = !fFixedField && ( grbit & JET_bitKeyDataZeroLength );
			Assert( FRECTextColumn( coltyp )
				|| FRECBinaryColumn( coltyp )
				|| !fZeroLength );
			FLDNormalizeNullSegment(
					pbNorm,
					coltyp,
					fZeroLength,
					fSortNullsHigh );
			plineNorm->SetCb( 1 );
			}
		}
		
	else
		{
		INT		cbSeg	= 0;

		cbColumn = plineColumn->Cb();
		pbColumn = (BYTE *)plineColumn->Pv();

		switch ( coltyp )
			{
			//	case-insensetive TEXT:	convert to uppercase.
			//	If fixed, prefix with 0x7f;  else affix with 0x00
			//
			case JET_coltypText:
			case JET_coltypLongText:
				{
				if ( pidb->FTuples() )
					{
					Assert( FRECTextColumn( coltyp ) );

					//	normalise counts to account for Unicode
					Assert( usUniCodePage != cp || cbColumn % 2 == 0 );
					const ULONG		chColumn	= ( usUniCodePage == cp ? cbColumn / 2 : cbColumn );
					const ULONG		cbColumnMax	= ( usUniCodePage == cp ? pidb->ChTuplesLengthMax() * 2 : pidb->ChTuplesLengthMax() );

					//	if data is not large enough, bail out
					if ( chColumn < pidb->ChTuplesLengthMin() )
						{
						return ErrERRCheck( JET_errIndexTuplesKeyTooSmall );
						}
					else
						{
						cbColumn = min( cbColumn, cbColumnMax );
						}
					}
				
				const ERR	errNorm		= ErrFLDNormalizeTextSegment(
												pbColumn,
												cbColumn,
												pbNorm,
												&cbSeg,
												cbAvail,
												cbKeyMost,
												cbVarSegMac,
												cp,
												pidb->Pidxunicode(),
												NULL );	// don't care about undefined chars
				if ( errNorm < 0 )
					return errNorm;
				else if ( wrnFLDKeyTooBig == errNorm )
					KSSetTooBig( pfucb );
				else
					CallS( errNorm );

				Assert( cbSeg > 0 );
				break;
				}

			//	BINARY data: if fixed, prefix with 0x7f;
			//	else break into chunks of 8 bytes, affixing each
			//	with 0x09, except for the last chunk, which is
			//	affixed with the number of bytes in the last chunk.
			//
			case JET_coltypBinary:
			case JET_coltypLongBinary:
				{
				BOOL	fColumnTruncated = fFalse;
				Assert( FRECBinaryColumn( coltyp ) );
				FLDNormalizeBinarySegment(
						pbColumn,
						cbColumn,
						pbNorm,
						&cbSeg,
						cbAvail,
						cbKeyMost,
						cbVarSegMac,
						fFixedField,
						&fColumnTruncated,
						&ibBinaryColumnDelimiter );
				if ( fColumnTruncated )
					{
					KSSetTooBig( pfucb );
					}
				break;
				}

			default:
				FLDNormalizeFixedSegment(
						pbColumn,
						cbColumn,
						pbNorm,
						&cbSeg,
						coltyp,
						fTrue /* data is passed by user, in machine format */);
				if ( cbSeg > cbAvail )
					{
					cbSeg = cbAvail;
					KSSetTooBig( pfucb );
					}
				break;
			}
			
		Assert( cbSeg <= cbAvail );
		plineNorm->SetCb( cbSeg );
		}


	if ( fDescending )
		{
		BYTE *pbMin = (BYTE *)plineNorm->Pv();
		BYTE *pb = pbMin + plineNorm->Cb() - 1;
		while ( pb >= pbMin )
			*pb-- ^= 0xff;
		}

	//	string and substring limit key support
	//	NOTE:  The difference between the two is that StrLimit appends 0xff to the end of
	//	key space for any column type, while SubStrLimit only works on text columns and
	//	will strip the trailing null terminator of the string before appending 0xff to the
	//	end of key space.
	//
	Assert( plineNorm->Cb() < cbAvail + 1 );	//	should always be room for suffix byte
	switch ( grbit & JET_maskLimitOptions )
		{
		case JET_bitFullColumnStartLimit:
		case JET_bitFullColumnEndLimit:
			FLDISetFullColumnLimit( plineNorm, cbAvail + 1, grbit & JET_bitFullColumnEndLimit );
			KSSetLimit( pfucb );
			break;
		case JET_bitPartialColumnStartLimit:
		case JET_bitPartialColumnEndLimit:
			if ( FRECTextColumn( coltyp ) )
				{
				FLDISetPartialColumnLimitOnTextColumn(
						plineNorm,
						cbAvail + 1,		//	+1 for suffix byte
						fDescending,
						grbit & JET_bitPartialColumnEndLimit,
						cp );
				}
			else
				{
				FLDITrySetPartialColumnLimitOnBinaryColumn(
						plineNorm,
						cbAvail + 1,		//	+1 for suffix byte
						ibBinaryColumnDelimiter,
						grbit & JET_bitPartialColumnEndLimit );
				}
			KSSetLimit( pfucb );
			break;
		default:
			{
			Assert( !( grbit & JET_maskLimitOptions ) );
			if ( ( grbit & JET_bitSubStrLimit )
				&& FRECTextColumn( coltyp ) )
				{
				FLDISetPartialColumnLimitOnTextColumn(
						plineNorm,
						cbAvail + 1,		//	+1 for suffix byte
						fDescending,
						fTrue,
						cp );
				KSSetLimit( pfucb );
				}
			else if ( grbit & JET_bitStrLimit )
				{
				FLDITrySetPartialColumnLimitOnBinaryColumn(
						plineNorm,
						cbAvail + 1,		//	+1 for suffix byte
						ibBinaryColumnDelimiter,
						fTrue );
				KSSetLimit( pfucb );
				}
			break;
			}
		}

	return JET_errSuccess;
	}


LOCAL VOID RECINormalisePlaceholder(
	FUCB	* const pfucb,
	FCB		* const pfcbTable,
	IDB		* const pidb )
	{
	Assert( !FKSPrepared( pfucb ) );

	//	there must be more than just this column in the index
	Assert( pidb->FHasPlaceholderColumn() );
	Assert( pidb->Cidxseg() > 1 );
	Assert( pidb->FPrimary() );

	pfcbTable->EnterDML();

	const TDB		* const ptdb	= pfcbTable->Ptdb();
	const IDXSEG	idxseg			= PidxsegIDBGetIdxSeg( pidb, ptdb )[0];
	const BOOL		fDescending		= idxseg.FDescending();

#ifdef DEBUG	
	//	HACK: placeholder column MUST be fixed bitfield
	Assert( FCOLUMNIDFixed( idxseg.Columnid() ) );
	const FIELD		* pfield		= ptdb->PfieldFixed( idxseg.Columnid() );

	Assert( FFIELDPrimaryIndexPlaceholder( pfield->ffield ) );
	Assert( JET_coltypBit == pfield->coltyp );
#endif	

	pfcbTable->LeaveDML();


	const BYTE		bPrefix			= BYTE( fDescending ? ~bPrefixData : bPrefixData );
	const BYTE		bData			= BYTE( fDescending ? 0xff : 0x00 );
	BYTE			* pbSeg			= (BYTE *)pfucb->dataSearchKey.Pv();

	pbSeg[0] = bPrefix;
	pbSeg[1] = bData;
	pfucb->dataSearchKey.SetCb( 2 );
	pfucb->cColumnsInSearchKey = 1;
	}

ERR VTAPI ErrIsamMakeKey(
	JET_SESID		sesid,
	JET_VTID		vtid,
	const VOID*		pvKeySeg,
	const ULONG		cbKeySeg,
	JET_GRBIT		grbit )
	{
	ERR				err;
 	PIB*			ppib			= reinterpret_cast<PIB *>( sesid );
	FUCB*			pfucbTable		= reinterpret_cast<FUCB *>( vtid );
	FUCB*			pfucb;
	FCB*			pfcbTable;
	BYTE*			pbKeySeg		= const_cast<BYTE *>( reinterpret_cast<const BYTE *>( pvKeySeg ) ); 
	IDB*			pidb;
	BOOL			fInitialIndex	= fFalse;
	INT				iidxsegCur;
	DATA			lineNormSeg;
	BYTE			rgbNormSegBuf[ cbKeyMostWithOverhead ];
	BYTE			rgbFixedColumnKeyPadded[ JET_cbColumnMost ];
	BOOL			fFixedField;
	DATA			lineKeySeg;
	ULONG			cbKeyMost;

	CallR( ErrPIBCheck( ppib ) );
	CheckFUCB( ppib, pfucbTable );
	AssertDIRNoLatch( ppib );

	if ( pfucbNil != pfucbTable->pfucbCurIndex )
		{
		pfucb = pfucbTable->pfucbCurIndex;
		Assert( pfucb->u.pfcb->FTypeSecondaryIndex() );
		Assert( pfucb->u.pfcb->Pidb() != pidbNil );
		Assert( !pfucb->u.pfcb->Pidb()->FPrimary() );
		cbKeyMost = JET_cbSecondaryKeyMost;
		}
	else
		{
		pfucb = pfucbTable;
		Assert( pfucb->u.pfcb->FPrimaryIndex() );
		Assert( pfucb->u.pfcb->Pidb() == pidbNil
			|| pfucb->u.pfcb->Pidb()->FPrimary() );
		cbKeyMost = JET_cbPrimaryKeyMost;
		}

						
	//	set efficiency variables
	//
	lineNormSeg.SetPv( rgbNormSegBuf );
	lineKeySeg.SetPv( pbKeySeg );
	lineKeySeg.SetCb( min( cbKeyMost, cbKeySeg ) );

	//	allocate key buffer if needed
	//
	if ( NULL == pfucbTable->dataSearchKey.Pv() )
		{
		Assert( !FKSPrepared( pfucbTable ) );
		Assert( !FKSPrepared( pfucb ) );

		pfucbTable->dataSearchKey.SetPv( PvOSMemoryHeapAlloc( cbKeyMostWithOverhead ) );
		if ( NULL == pfucbTable->dataSearchKey.Pv() )
			return ErrERRCheck( JET_errOutOfMemory );

		pfucbTable->dataSearchKey.SetCb( 0 );
		pfucbTable->cColumnsInSearchKey = 0;
		KSReset( pfucbTable );
		}

	//	hijack table's search key buffer
	
	if ( NULL == pfucb->dataSearchKey.Pv() )
		{
		pfucbTable->cColumnsInSearchKey = 0;
		KSReset( pfucbTable );

		Assert( !FKSPrepared( pfucb ) );
		pfucb->dataSearchKey.SetPv( pfucbTable->dataSearchKey.Pv() );
		pfucb->dataSearchKey.SetCb( 0 );
		pfucb->cColumnsInSearchKey = 0;
		FUCBSetUsingTableSearchKeyBuffer( pfucb );

		KSReset( pfucb );
		}

	Assert( !( grbit & JET_bitKeyDataZeroLength )
		|| 0 == cbKeySeg );

	//	if key is already normalized, then copy directly to
	//	key buffer and return.
	//
	if ( grbit & JET_bitNormalizedKey )
		{
		if ( cbKeySeg > cbKeyMostWithOverhead )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}

		//	ensure previous key is wiped out
		KSReset( pfucb );

		//	set key segment counter to any value
		//	regardless of the number of key segments.
		//
		pfucb->cColumnsInSearchKey = 1;
		UtilMemCpy( (BYTE *)pfucb->dataSearchKey.Pv(), pbKeySeg, cbKeySeg );
		pfucb->dataSearchKey.SetCb( cbKeySeg );

		KSSetPrepare( pfucb );
		if ( cbKeySeg > cbKeyMost )
			KSSetLimit( pfucb );

		return JET_errSuccess;
		}

	//	start new key if requested
	//
	else if ( grbit & JET_bitNewKey )
		{
		//	ensure previous key is wiped out
		KSReset( pfucb );

		pfucb->dataSearchKey.SetCb( 0 );
		pfucb->cColumnsInSearchKey = 0;
		}

	else if ( FKSLimit( pfucb ) )
		{
		return ErrERRCheck( JET_errKeyIsMade );
		}
	else if ( !FKSPrepared( pfucb ) )
		{
		return ErrERRCheck( JET_errKeyNotMade );
		}

	//	get pidb
	//
	pfcbTable = pfucbTable->u.pfcb;
	if ( FFUCBIndex( pfucbTable ) )
		{
		if ( pfucbTable->pfucbCurIndex != pfucbNil )
			{
			Assert( pfucb == pfucbTable->pfucbCurIndex );
			Assert( pfucb->u.pfcb->FTypeSecondaryIndex() );
			pidb = pfucb->u.pfcb->Pidb();
			fInitialIndex = pfucb->u.pfcb->FInitialIndex();
			if ( pfucb->u.pfcb->FDerivedIndex() )
				{
				// If secondary index is inherited, use FCB of template table.
				Assert( pidb->FTemplateIndex() );
				Assert( pfcbTable->Ptdb() != ptdbNil );
				pfcbTable = pfcbTable->Ptdb()->PfcbTemplateTable();
				Assert( pfcbNil != pfcbTable );
				}
			}
		else
			{
			BOOL	fPrimaryIndexTemplate	= fFalse;

			Assert( pfcbTable->FPrimaryIndex() );
			if ( pfcbTable->FDerivedTable() )
				{
				Assert( pfcbTable->Ptdb() != ptdbNil );
				Assert( pfcbTable->Ptdb()->PfcbTemplateTable() != pfcbNil );
				if ( !pfcbTable->Ptdb()->PfcbTemplateTable()->FSequentialIndex() )
					{
					// If template table has a primary index, we must have inherited it,
					// so use FCB of template table instead.
					fPrimaryIndexTemplate = fTrue;
					pfcbTable = pfcbTable->Ptdb()->PfcbTemplateTable();
					pidb = pfcbTable->Pidb();
					Assert( pidbNil != pidb );
					Assert( pfcbTable->Pidb()->FTemplateIndex() );
					fInitialIndex = fTrue;
					}
				else
					{
					Assert( pfcbTable->Ptdb()->PfcbTemplateTable()->Pidb() == pidbNil );
					}
				}

			if ( !fPrimaryIndexTemplate )
				{
				if ( pfcbTable->FInitialIndex() )
					{
					//	since the primary index can't be deleted,
					//	no need to check visibility
					pidb = pfcbTable->Pidb();
					fInitialIndex = fTrue;
					}
				else
					{
					pfcbTable->EnterDML();

					pidb = pfcbTable->Pidb();

					//	must check whether we have a primary or sequential index and
					//	whether we have visibility on it

					const ERR	errT	= ( pidbNil != pidb ?
												ErrFILEIAccessIndex( pfucbTable->ppib, pfcbTable, pfcbTable ) :
												ErrERRCheck( JET_errNoCurrentIndex ) );

					pfcbTable->LeaveDML();

					if ( errT < JET_errSuccess )
						{
						return ( JET_errIndexNotFound == errT ?
									ErrERRCheck( JET_errNoCurrentIndex ) :
									errT );
						}
					}
				}
			}
		}
	else
		{
		pidb = pfucbTable->u.pscb->fcb.Pidb();
		Assert( pfcbTable == &pfucbTable->u.pscb->fcb );
		}

	Assert( pidb != pidbNil );
	Assert( pidb->Cidxseg() > 0 );

	if ( !FKSPrepared( pfucb )
		&& pidb->FHasPlaceholderColumn()
		&& !( grbit & JET_bitKeyOverridePrimaryIndexPlaceholder ) )
		{
		//	HACK: first column is placeholder
		RECINormalisePlaceholder( pfucb, pfcbTable, pidb );
		}

	iidxsegCur = pfucb->cColumnsInSearchKey;
	if ( iidxsegCur >= pidb->Cidxseg() )
		return ErrERRCheck( JET_errKeyIsMade );

	const BOOL		fUseDMLLatch	= ( !fInitialIndex
										|| pidb->FIsRgidxsegInMempool() );

	if ( fUseDMLLatch )
		pfcbTable->EnterDML();

	const TDB		* const ptdb	= pfcbTable->Ptdb();
	const IDXSEG	idxseg			= PidxsegIDBGetIdxSeg( pidb, ptdb )[iidxsegCur];
	const BOOL		fDescending		= idxseg.FDescending();
	const COLUMNID	columnid		= idxseg.Columnid();
	const FIELD		* pfield;
	
	if ( fFixedField = FCOLUMNIDFixed( columnid ) )
		{
		Assert( fUseDMLLatch
				|| idxseg.FTemplateColumn()
				|| FidOfColumnid( columnid ) <= ptdb->FidFixedLastInitial() );
		pfield = ptdb->PfieldFixed( columnid );

		//	check that length of key segment matches fixed column length
		//
		Assert( pfield->cbMaxLen <= JET_cbColumnMost );
		if ( cbKeySeg > 0 && cbKeySeg != pfield->cbMaxLen )
			{
			//	if column is fixed text and buffer size is less
			//	than fixed size then pad with spaces.
			//
			Assert( pfield->coltyp != JET_coltypLongText );
			if ( pfield->coltyp == JET_coltypText && cbKeySeg < pfield->cbMaxLen )
				{
				Assert( cbKeySeg == lineKeySeg.Cb() );
				UtilMemCpy( rgbFixedColumnKeyPadded, lineKeySeg.Pv(), lineKeySeg.Cb() );
				memset( rgbFixedColumnKeyPadded + lineKeySeg.Cb(), ' ', pfield->cbMaxLen - lineKeySeg.Cb() );
				lineKeySeg.SetPv( rgbFixedColumnKeyPadded );
				lineKeySeg.SetCb( pfield->cbMaxLen );
				}
			else
				{
				if ( fUseDMLLatch )
					pfcbTable->LeaveDML();
				return ErrERRCheck( JET_errInvalidBufferSize );
				}
			}
		}
	else if ( FCOLUMNIDTagged( columnid ) )
		{
		Assert( fUseDMLLatch
				|| idxseg.FTemplateColumn()
				|| FidOfColumnid( columnid ) <= ptdb->FidTaggedLastInitial() );
		pfield = ptdb->PfieldTagged( columnid );
		}
	else
		{
		Assert( FCOLUMNIDVar( columnid ) );
		Assert( fUseDMLLatch
				|| idxseg.FTemplateColumn()
				|| FidOfColumnid( columnid ) <= ptdb->FidVarLastInitial() );
		pfield = ptdb->PfieldVar( columnid );
		}

	const JET_COLTYP	coltyp		= pfield->coltyp;
	const USHORT		cp			= pfield->cp;
	
	if ( fUseDMLLatch )
		pfcbTable->LeaveDML();

	switch ( grbit & JET_maskLimitOptions )
		{
		case JET_bitPartialColumnStartLimit:
		case JET_bitPartialColumnEndLimit:
			if ( !FRECTextColumn( coltyp )
				&& ( fFixedField || !FRECBinaryColumn( coltyp ) ) )
				{
				//	partial column limits can only be done
				//	on text columns and non-fixed binary columns
				//	(because they are the only ones that have
				//	delimiters that need to be stripped off)
				return ErrERRCheck( JET_errInvalidGrbit );
				}
		case 0:
		case JET_bitFullColumnStartLimit:
		case JET_bitFullColumnEndLimit:
			break;

		default:
			return ErrERRCheck( JET_errInvalidGrbit );
		}

	Assert( KEY::CbKeyMost( pidb->FPrimary() ) == cbKeyMost );
	
	Assert( pfucb->dataSearchKey.Cb() < cbKeyMostWithOverhead );

	if ( !FKSTooBig( pfucb )
		&& pfucb->dataSearchKey.Cb() < cbKeyMost )
		{
		const ERR	errNorm		= ErrFLDNormalizeSegment(
										pfucb,
										pidb,
										( cbKeySeg != 0 || ( grbit & JET_bitKeyDataZeroLength ) ) ? &lineKeySeg : NULL,
										&lineNormSeg,
										coltyp,
										cp,
										cbKeyMost - pfucb->dataSearchKey.Cb(),
										fDescending,
										fFixedField,
										grbit );
		if ( errNorm < 0 )
			{
			Assert( FRECTextColumn( coltyp ) );
#ifdef DEBUG
			switch ( errNorm )
				{
				case JET_errInvalidLanguageId:
				case JET_errOutOfMemory:
				case JET_errUnicodeNormalizationNotSupported:
					Assert( usUniCodePage == cp );
					break;
				case JET_errIndexTuplesKeyTooSmall:
					Assert( pidb->FTuples() );
					break;
				default:
					//	report unexpected error
					CallS( errNorm );
				}
#endif
			return errNorm;
			}
		CallS( errNorm );
		}
	else
		{
		lineNormSeg.SetCb( 0 );
		}

	//	increment segment counter
	//
	pfucb->cColumnsInSearchKey++;

	//	UNDONE:	normalized segment should already be sized properly to ensure we
	//	don't overrun key buffer.  Assert this, but leave the check in for now
	//	just in case.
	Assert( pfucb->dataSearchKey.Cb() + lineNormSeg.Cb() <= cbKeyMostWithOverhead );
	if ( pfucb->dataSearchKey.Cb() + lineNormSeg.Cb() > cbKeyMostWithOverhead )
		{
		lineNormSeg.SetCb( cbKeyMostWithOverhead - pfucb->dataSearchKey.Cb() );
		//	no warning returned when key exceeds most size
		//
		}

	UtilMemCpy(
		(BYTE *)pfucb->dataSearchKey.Pv() + pfucb->dataSearchKey.Cb(),
		lineNormSeg.Pv(),
		lineNormSeg.Cb() );
	pfucb->dataSearchKey.DeltaCb( lineNormSeg.Cb() );
	KSSetPrepare( pfucb );
	AssertDIRNoLatch( ppib );

	CallS( err );
	return err;
	}


//+API
//	ErrRECIRetrieveColumnFromKey
//	========================================================================
//	ErrRECIRetrieveColumnFromKey(
//		TDB *ptdb,				// IN	 column info for index
//		IDB *pidb,				// IN	 IDB of index defining key
//		KEY *pkey,				// IN	 key in normalized form
//		DATA *plineColumn ); 	// OUT	 receives value list
//
//	PARAMETERS	
//		ptdb			column info for index
//		pidb			IDB of index defining key
//		pkey			key in normalized form
//		plineColumn		plineColumn->pv must point to a buffer large
//						enough to hold the denormalized column.  A buffer
//						of cbKeyMost bytes is sufficient.
//
//	RETURNS		JET_errSuccess
//
//-
ERR ErrRECIRetrieveColumnFromKey(
	TDB 					* ptdb,
	IDB						* pidb,
	const KEY				* pkey,
	const COLUMNID			columnid,
	DATA					* plineColumn )
	{
	ERR						err			= JET_errSuccess;
	const IDXSEG* pidxseg;
	const IDXSEG* pidxsegMac;

	Assert( ptdb != ptdbNil );
	Assert( pidb != pidbNil );
	Assert( pidb->Cidxseg() > 0 );
	Assert( !pkey->FNull() );
	Assert( plineColumn != NULL );
	Assert( plineColumn->Pv() != NULL );

	BYTE				rgbKey[ KEY::cbKeyMax ];
	BYTE  				*pbKey		= rgbKey;				// runs through key bytes
	const BYTE		 	*pbKeyMax	= pbKey + pkey->Cb();	// end of key
	pkey->CopyIntoBuffer( pbKey );
	Assert( pbKeyMax <= pbKey + KEY::cbKeyMax );

	pidxseg = PidxsegIDBGetIdxSeg( pidb, ptdb );
	pidxsegMac = pidxseg + pidb->Cidxseg();

	const BYTE	bPrefixNullT	= ( pidb->FSortNullsHigh() ? bPrefixNullHigh : bPrefixNull );

	for ( ; pidxseg < pidxsegMac && pbKey < pbKeyMax; pidxseg++ )
		{
		JET_COLTYP 		coltyp;				  	 	// Type of column.
		ULONG 			cbField;			   		// Length of column data.
		FIELD			*pfield;
		BOOL 	   		fFixedField		= fFalse;	// Current column is fixed-length?


		//	negative column id means descending in the key
		//
		const BOOL		fDescending		= pidxseg->FDescending();
		const COLUMNID	columnidT		= pidxseg->Columnid();
		const BYTE		bMask			= BYTE( fDescending ? ~BYTE( 0 ) : BYTE( 0 ) );
		const WORD		wMask			= WORD( fDescending ? ~WORD( 0 ) : WORD( 0 ) );
		const DWORD		dwMask			= DWORD( fDescending ? ~DWORD( 0 ) : DWORD( 0 ) );
		const QWORD		qwMask			= QWORD( fDescending ? ~QWORD( 0 ) : QWORD( 0 ) );

		err = JET_errSuccess;				// reset error code

		//	determine column type from TDB
		//
		if ( FCOLUMNIDTagged( columnidT ) )
			{
			pfield = ptdb->PfieldTagged( columnidT );
			}
		else if ( FCOLUMNIDFixed( columnidT ) )
			{
			pfield = ptdb->PfieldFixed( columnidT );
			fFixedField = fTrue;
			}
		else
			{
			Assert( FCOLUMNIDVar( columnidT ) );
			pfield = ptdb->PfieldVar( columnidT );
			Assert( pfield->coltyp == JET_coltypBinary || pfield->coltyp == JET_coltypText );
			}
		coltyp = pfield->coltyp;

		Assert( coltyp != JET_coltypNil );
		BYTE		* const pbDataColumn = (BYTE *)plineColumn->Pv();		//	efficiency variable

		switch ( coltyp )
			{
			default:
				Assert( coltyp == JET_coltypBit );
				if ( *pbKey++ == (BYTE)(bMask ^ bPrefixNullT) )
					{
					plineColumn->SetCb( 0 );
					err = ErrERRCheck( JET_wrnColumnNull );
					}
				else 
					{
					Assert( pbKey[-1] == (BYTE)(bMask ^ bPrefixData) );
					plineColumn->SetCb( 1 );
					
					*( (BYTE *)plineColumn->Pv() ) = BYTE( ( ( bMask ^ pbKey[ 0 ] ) == 0 ) ? 0x00 : 0xff );

					pbKey++;
					}
				break;

			case JET_coltypUnsignedByte:
				if ( *pbKey++ == (BYTE)(bMask ^ bPrefixNullT) )
					{
					plineColumn->SetCb( 0 );
					err = ErrERRCheck( JET_wrnColumnNull );
					}
				else
					{
					Assert( pbKey[-1] == (BYTE)(bMask ^ bPrefixData) );
					plineColumn->SetCb( 1 );
					
					*( (BYTE *)plineColumn->Pv() ) = BYTE( bMask ^ pbKey[ 0 ] );
					
					pbKey++;
					}
				break;

			case JET_coltypShort:
				if ( *pbKey++ == (BYTE)(bMask ^ bPrefixNullT) )
					{
					plineColumn->SetCb( 0 );
					err = ErrERRCheck( JET_wrnColumnNull );
					}
				else
					{
					Assert( pbKey[-1] == (BYTE)(bMask ^ bPrefixData) );
					plineColumn->SetCb( 2 );
					
					*( (Unaligned< WORD > *)plineColumn->Pv() ) =
							WORD( wMask ^ wFlipHighBit( *( (UnalignedBigEndian< WORD >*) &pbKey[ 0 ] ) ) );
					
					pbKey += 2;
					}
				break;

			case JET_coltypLong:
				if ( *pbKey++ == (BYTE)(bMask ^ bPrefixNullT) )
					{
					plineColumn->SetCb( 0 );
					err = ErrERRCheck( JET_wrnColumnNull );
					}
				else
					{
					Assert(pbKey[-1] == (BYTE)(bMask ^ bPrefixData) );
					plineColumn->SetCb( 4 );
					
					*( (Unaligned< DWORD >*) plineColumn->Pv() ) = dwMask ^ dwFlipHighBit( *( (UnalignedBigEndian< DWORD >*) &pbKey[ 0 ] ) );
					
					pbKey += 4;
					}
				break;

			case JET_coltypIEEESingle:
				if ( *pbKey++ == (BYTE)(bMask ^ bPrefixNullT) )
					{
					plineColumn->SetCb( 0 );
					err = ErrERRCheck( JET_wrnColumnNull );
					}
				else
					{
					Assert(pbKey[-1] == (BYTE)(bMask ^ bPrefixData) );
					plineColumn->SetCb( 4 );

					DWORD dwT = dwMask ^ *( (UnalignedBigEndian< DWORD >*) &pbKey[ 0 ] );

					if ( dwT & maskDWordHighBit )
						{
						dwT = dwFlipHighBit( dwT );
						}
					else
						{
						dwT = ~dwT;
						}
					
					*( (Unaligned< DWORD >*) plineColumn->Pv() ) = dwT;
					
					pbKey += 4;
					}
				break;

			case JET_coltypCurrency:
				if ( *pbKey++ == (BYTE)(bMask ^ bPrefixNullT) )
					{
					plineColumn->SetCb( 0 );
					err = ErrERRCheck( JET_wrnColumnNull );
					}
				else
					{
					Assert(pbKey[-1] == (BYTE)(bMask ^ bPrefixData) );
					plineColumn->SetCb( 8 );
					
					*( (Unaligned< QWORD >*) plineColumn->Pv() ) = qwMask ^ qwFlipHighBit( *( (UnalignedBigEndian< QWORD >*) &pbKey[ 0 ] ) );
					
					pbKey += 8;
					}
				break;
				
			case JET_coltypIEEEDouble:
			case JET_coltypDateTime:
				if ( *pbKey++ == (BYTE)(bMask ^ bPrefixNullT) )
					{
					plineColumn->SetCb( 0 );
					err = ErrERRCheck( JET_wrnColumnNull );
					}
				else
					{
					Assert(pbKey[-1] == (BYTE)(bMask ^ bPrefixData) );
					plineColumn->SetCb( 8 );

					QWORD qwT = qwMask ^ *( (UnalignedBigEndian< QWORD >*) &pbKey[ 0 ] );

					if ( qwT & maskQWordHighBit )
						{
						qwT = qwFlipHighBit( qwT );
						}
					else
						{
						qwT = ~qwT;
						}
					
					*( (Unaligned< QWORD >*) plineColumn->Pv() ) = qwT;
					
					pbKey += 8;
					}
				break;

			case JET_coltypText:
			case JET_coltypLongText:
				//	Can only de-normalise text column for the purpose of skipping
				//	over it (since normalisation doesn't alter the length of
				//	the string).  Can't return the string to the caller because
				//	we have no way of restoring the original case.
				AssertSz( columnidT != columnid, "Can't de-normalise text strings (due to case)." );

				//	FALL THROUGH (fixed text handled the same as fixed binary,
				//	non-fixed text special-cased below):

			case JET_coltypBinary:
			case JET_coltypLongBinary:
				if ( fDescending )
					{
					if ( fFixedField )
						{
						if ( *pbKey++ == (BYTE)~bPrefixData )
							{
							cbField = pfield->cbMaxLen;
							Assert( cbField <= pbKeyMax - pbKey );	// wouldn't call this function if key possibly truncated
							plineColumn->SetCb( cbField );
							for ( ULONG ibT = 0; ibT < cbField; ibT++ )
								{
								Assert( pbDataColumn == (BYTE *)plineColumn->Pv() );
								pbDataColumn[ibT] = (BYTE)~*pbKey++;
								}
							}
//						// zero-length strings -- only for non-fixed columns
//						//	
//						else if ( pbKey[-1] == (BYTE)~bPrefixZeroLength )
//							{
//							plineColumn->cb = 0;
//							Assert( FRECTextColumn( coltyp ) );
//							}
						else
							{
							Assert( pbKey[-1] == (BYTE)~bPrefixNullT );
							plineColumn->SetCb( 0 );
							err = ErrERRCheck( JET_wrnColumnNull );
							}
						}
					else
						{
						cbField = 0;
						if ( *pbKey++ == (BYTE)~bPrefixData )
							{
							Assert( pbDataColumn == (BYTE *)plineColumn->Pv() );
							if ( FRECBinaryColumn( coltyp ) )
								{
								BYTE	*pbColumn = pbDataColumn;
								do {
									Assert( pbKey + cbFLDBinaryChunkNormalized <= pbKeyMax );
									
									BYTE	cbChunk = (BYTE)~pbKey[cbFLDBinaryChunkNormalized-1];
									if ( cbFLDBinaryChunkNormalized == cbChunk )
										cbChunk = cbFLDBinaryChunkNormalized-1;
										
									for ( BYTE ib = 0; ib < cbChunk; ib++ )
										pbColumn[ib] = (BYTE)~pbKey[ib];
										
									cbField += cbChunk;
									pbKey += cbFLDBinaryChunkNormalized;
									pbColumn += cbChunk;
									}
								while ( pbKey[-1] == (BYTE)~cbFLDBinaryChunkNormalized );
								}
								
							else
								{
								Assert( FRECTextColumn( coltyp ) );
								//	we are guaranteed to hit the NULL terminator, because
								//	we never call this function if we hit the end
								//	of key space
								for ( ; *pbKey != (BYTE)~0; cbField++)
									{
									Assert( pbKey < pbKeyMax );
									pbDataColumn[cbField] = (BYTE)~*pbKey++;
									}
								pbKey++;	// skip null-terminator
								}
							}
						else if ( pbKey[-1] == (BYTE)~bPrefixNullT )
							{
							err = ErrERRCheck( JET_wrnColumnNull );
							}
						else
							{
							Assert( pbKey[-1] == (BYTE)~bPrefixZeroLength );
							}
						Assert( cbField <= KEY::cbKeyMax );
						plineColumn->SetCb( cbField );
						}
					}
				else
					{
					if ( fFixedField )
						{
						if ( *pbKey++ == bPrefixData )
							{
							cbField = pfield->cbMaxLen;
							Assert( cbField <= pbKeyMax - pbKey );	// wouldn't call this function if key possibly truncated
							plineColumn->SetCb( cbField );
							UtilMemCpy( plineColumn->Pv(), pbKey, cbField );
							pbKey += cbField;
							}
//						// zero-length strings -- only for non-fixed columns
//						//	
//						else if ( pbKey[-1] == bPrefixZeroLength )
//							{
//							Assert( FRECTextColumn( coltyp ) );
//							plineColumn->SetCb( 0 );
//							}
						else
							{
							Assert( pbKey[-1] == bPrefixNullT );
							plineColumn->SetCb( 0 );
							err = ErrERRCheck( JET_wrnColumnNull );
							}
						}
					else
						{
						cbField = 0;
						if ( *pbKey++ == bPrefixData )
							{
							Assert( pbDataColumn == (BYTE *)plineColumn->Pv() );
							if ( FRECBinaryColumn( coltyp ) )
								{
								BYTE	*pbColumn = pbDataColumn;
								do {
									Assert( pbKey + cbFLDBinaryChunkNormalized <= pbKeyMax );
									
									BYTE	cbChunk = pbKey[cbFLDBinaryChunkNormalized-1];
									if ( cbFLDBinaryChunkNormalized == cbChunk )
										cbChunk = cbFLDBinaryChunkNormalized-1;
										
									UtilMemCpy( pbColumn, pbKey, cbChunk );
									
									cbField += cbChunk;
									pbKey += cbFLDBinaryChunkNormalized;
									pbColumn += cbChunk;
									}
								while ( pbKey[-1] == cbFLDBinaryChunkNormalized );
								}
								
							else
								{
								Assert( FRECTextColumn( coltyp ) );
								//	we are guaranteed to hit the NULL terminator, because
								//	we never call this function if we hit the end
								//	of key space
								for ( ; *pbKey != (BYTE)0; cbField++ )
									{
									Assert( pbKey < pbKeyMax );
									pbDataColumn[cbField] = (BYTE)*pbKey++;
									}
								pbKey++;	// skip null-terminator
								}
							}
						else if ( pbKey[-1] == bPrefixNullT )
							{
							err = ErrERRCheck( JET_wrnColumnNull );
							}
						else
							{
							Assert( pbKey[-1] == bPrefixZeroLength );
							}
						Assert( cbField <= KEY::cbKeyMax );
						plineColumn->SetCb( cbField );
						}
					}
				break;
			}
		
		//	if just retrieved field requested then break
		//
		if ( columnidT == columnid )
			break;
		}

	CallSx( err, JET_wrnColumnNull );
	return err;
	}


ERR VTAPI ErrIsamRetrieveKey(
	JET_SESID		sesid,
	JET_VTID		vtid,
	VOID*			pv,
	const ULONG		cbMax,
	ULONG*			pcbActual,
	JET_GRBIT		grbit )
	{
	ERR				err;
 	PIB*			ppib		= reinterpret_cast<PIB *>( sesid );
	FUCB*			pfucb		= reinterpret_cast<FUCB *>( vtid );
	FUCB*			pfucbIdx;
	FCB*			pfcbIdx;
	ULONG			cbKeyReturned;
			  	
	CallR( ErrPIBCheck( ppib ) );
	CheckFUCB( ppib, pfucb );
	AssertDIRNoLatch( ppib );

	//	retrieve key from key buffer
	//
	if ( grbit & JET_bitRetrieveCopy )
		{
		if ( pfucb->pfucbCurIndex != pfucbNil )
			pfucb = pfucb->pfucbCurIndex;
	
		//	UNDONE:	support JET_bitRetrieveCopy for inserted record
		//			by creating key on the fly.
		if ( pfucb->dataSearchKey.FNull()
			|| NULL == pfucb->dataSearchKey.Pv() )
			{
			return ErrERRCheck( JET_errKeyNotMade );
			}
		if ( pv != NULL )
			{
			UtilMemCpy( pv, 
					pfucb->dataSearchKey.Pv(),
					min( (ULONG)pfucb->dataSearchKey.Cb(), cbMax ) );
			}
		if ( pcbActual )
			*pcbActual = pfucb->dataSearchKey.Cb();
		return JET_errSuccess;
		}

	//	retrieve current index value
	//
	if ( FFUCBIndex( pfucb ) )
		{
		pfucbIdx = pfucb->pfucbCurIndex != pfucbNil ? pfucb->pfucbCurIndex : pfucb;
		Assert( pfucbIdx != pfucbNil );
		pfcbIdx = pfucbIdx->u.pfcb;
		Assert( pfcbIdx != pfcbNil );
		CallR( ErrDIRGet( pfucbIdx ) );
		}
	else
		{
		pfucbIdx = pfucb;
		pfcbIdx = (FCB *)pfucb->u.pscb; // first element of an SCB is an FCB
		Assert( pfcbIdx != pfcbNil );
		}

	//	set err to JET_errSuccess.
	//
	err = JET_errSuccess;

	cbKeyReturned = pfucbIdx->kdfCurr.key.Cb();
	if ( pcbActual )
		*pcbActual = cbKeyReturned;
	if ( cbKeyReturned > cbMax )
		{
		err = ErrERRCheck( JET_wrnBufferTruncated );
		cbKeyReturned = cbMax;
		}

	if ( pv != NULL )
		{
		UtilMemCpy( pv, pfucbIdx->kdfCurr.key.prefix.Pv(),
				min( (ULONG)pfucbIdx->kdfCurr.key.prefix.Cb(), cbKeyReturned ) );
		UtilMemCpy( (BYTE *)pv+pfucbIdx->kdfCurr.key.prefix.Cb(), 
				pfucbIdx->kdfCurr.key.suffix.Pv(),
				min( (ULONG)pfucbIdx->kdfCurr.key.suffix.Cb(), cbKeyReturned -
														pfucbIdx->kdfCurr.key.prefix.Cb() ) );
		}

	if ( FFUCBIndex( pfucb ) )
		{
		Assert( Pcsr( pfucbIdx )->FLatched( ) );
		CallS( ErrDIRRelease( pfucbIdx ) );
		}
		
	AssertDIRNoLatch( ppib );
	return err;
	}


ERR VTAPI ErrIsamGetBookmark(
	JET_SESID		sesid,
	JET_VTID		vtid,
	VOID * const	pvBookmark,
	const ULONG		cbMax,
	ULONG * const	pcbActual )
	{
	ERR				err;
 	PIB *			ppib		= reinterpret_cast<PIB *>( sesid );
	FUCB *			pfucb		= reinterpret_cast<FUCB *>( vtid );
	ULONG			cb;
	ULONG			cbReturned;
	BOOKMARK *		pbm;

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );
	AssertDIRNoLatch( ppib );
	Assert( NULL != pvBookmark || 0 == cbMax );

	//	retrieve bookmark
	//
	CallR( ErrDIRGetBookmark( pfucb, &pbm ) );
	Assert( !Pcsr( pfucb )->FLatched() );

	Assert( pbm->key.prefix.FNull() );
	Assert( pbm->data.FNull() );

	cb = pbm->key.Cb();

	//	set return values
	//
	if ( pcbActual )
		*pcbActual = cb;
		
	if ( cb <= cbMax )
		{
		cbReturned = cb;
		}
	else
		{
		cbReturned = cbMax;
		err = ErrERRCheck( JET_errBufferTooSmall );
		}

	pbm->key.CopyIntoBuffer( pvBookmark, cbReturned );

	AssertDIRNoLatch( ppib );
	return err;
	}

ERR VTAPI ErrIsamGetIndexBookmark(
	JET_SESID		sesid,
	JET_VTID		vtid,
	VOID * const	pvSecondaryKey,
	const ULONG		cbSecondaryKeyMax,
	ULONG * const	pcbSecondaryKeyActual,
	VOID * const	pvPrimaryBookmark,
	const ULONG		cbPrimaryBookmarkMax,
	ULONG *	const	pcbPrimaryBookmarkActual )
	{
	ERR				err;
 	PIB *			ppib		= reinterpret_cast<PIB *>( sesid );
	FUCB *			pfucb		= reinterpret_cast<FUCB *>( vtid );
	FUCB * const	pfucbIdx	= pfucb->pfucbCurIndex;
	ULONG			cb;
	ULONG			cbReturned;
	BOOKMARK *		pbm;

	CallR( ErrPIBCheck( ppib ) );
	AssertDIRNoLatch( ppib );
	CheckTable( ppib, pfucb );
	Assert( FFUCBIndex( pfucb ) );
	Assert( FFUCBPrimary( pfucb ) );
	Assert( pfucb->u.pfcb->FPrimaryIndex() );

	Assert( NULL != pvSecondaryKey || 0 == cbSecondaryKeyMax );
	Assert( NULL != pvPrimaryBookmark || 0 == cbPrimaryBookmarkMax );

	if ( pfucbNil == pfucbIdx )
		{
		return ErrERRCheck( JET_errNoCurrentIndex );
		}

	Assert( FFUCBSecondary( pfucbIdx ) );
	Assert( pfucbIdx->u.pfcb->FTypeSecondaryIndex() );

	//	retrieve bookmark
	//
	CallR( ErrDIRGetBookmark( pfucbIdx, &pbm ) );
	Assert( !Pcsr( pfucbIdx )->FLatched() );

	Assert( pbm->key.prefix.FNull() );

	//	set secondary index key return value
	//
	cb = pbm->key.Cb();
	if ( NULL != pcbSecondaryKeyActual )
		*pcbSecondaryKeyActual = cb;
		
	if ( cb <= cbSecondaryKeyMax )
		{
		cbReturned = cb;
		}
	else
		{
		cbReturned = cbSecondaryKeyMax;
		err = ErrERRCheck( JET_errBufferTooSmall );
		}

	pbm->key.CopyIntoBuffer( pvSecondaryKey, cbReturned );

	//	set primary bookmark return value
	//
	cb = pbm->data.Cb();
	if ( NULL != pcbPrimaryBookmarkActual )
		*pcbPrimaryBookmarkActual = cb;

	if ( cb <= cbPrimaryBookmarkMax )
		{
		cbReturned = cb;
		}
	else
		{
		cbReturned = cbPrimaryBookmarkMax;
		err = ErrERRCheck( JET_errBufferTooSmall );
		}

	UtilMemCpy( pvPrimaryBookmark, pbm->data.Pv(), cbReturned );

	AssertDIRNoLatch( ppib );
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\io.cxx ===
#include "std.hxx"


//  perfmon support
PM_CEF_PROC LIODatabaseFileExtensionStallCEFLPv;
PERFInstanceG<> cIODatabaseFileExtensionStall;
long LIODatabaseFileExtensionStallCEFLPv( long iInstance, void* pvBuf )
	{
	cIODatabaseFileExtensionStall.PassTo( iInstance, pvBuf );
	return 0;
	}


/******************************************************************/
/*				FMP Routines			                          */
/******************************************************************/

FMP	*	rgfmp		= NULL;						/* database file map */
IFMP	ifmpMax		= cMaxInstancesSingleInstanceDefault * cMaxDatabasesPerInstanceDefault;

CCriticalSection FMP::critFMPPool( CLockBasicInfo( CSyncBasicInfo( szFMPGlobal ), rankFMPGlobal, 0 ) );

/*	The folowing functions only deal with the following fields in FMP
 *		critFMPPool & pfmp->szDatabaseName	- protect fmp id (szDatabaseName field)
 *		pfmp->critLatch - protect any fields except szDatabaseName.
 *		pfmp->fWriteLatch
 *		pfmp->gateWriteLatch
 *		pfmp->cPin - when getting fmp pointer for read, the cPin must > 0
 */

VOID FMP::GetWriteLatch( PIB *ppib )
	{
	//	At least pinned (except dbidTemp which always sit
	//	in memory) or latched by the caller.

	Assert( ( m_cPin || Dbid() == dbidTemp ) || this->FWriteLatchByMe(ppib) );

	m_critLatch.Enter();

Start:
	Assert( m_critLatch.FOwner() );
	if ( !( this->FWriteLatchByOther(ppib) ) )
		{
		this->SetWriteLatch( ppib );
		m_critLatch.Leave();
		}
	else
		{
		m_gateWriteLatch.Wait( m_critLatch );
		m_critLatch.Enter();
		goto Start;
		}
	}


VOID FMP::ReleaseWriteLatch( PIB *ppib )
	{
	m_critLatch.Enter();

	/*	Free write latch.
	 */
	this->ResetWriteLatch( ppib );
	if ( m_gateWriteLatch.CWait() > 0 )
		{
		m_gateWriteLatch.Release( m_critLatch );
		}
	else
		{
		m_critLatch.Leave();
		}
	}


//  ================================================================
ERR FMP::RegisterTask()
//  ================================================================
	{
	AtomicIncrement( (LONG *)&m_ctasksActive );
	return JET_errSuccess;
	}


//  ================================================================
ERR FMP::UnregisterTask()
//  ================================================================
	{
	AtomicDecrement( (LONG *)&m_ctasksActive );
	return JET_errSuccess;
	}


//  ================================================================
ERR FMP::ErrWaitForTasksToComplete()
//  ================================================================
	{
	//  very ugly, but hopefully we don't detach often
	while( 0 != m_ctasksActive )
		{
		UtilSleep( cmsecWaitGeneric );
		}
	return JET_errSuccess;
	}


/*	ErrFMPWriteLatchByNameSz returns the ifmp of the database with the
 *	given name if return errSuccess, otherwise, it return DatabaseNotFound.
 */
ERR FMP::ErrWriteLatchByNameSz( const CHAR *szFileName, IFMP *pifmp, PIB *ppib )
	{
	IFMP	ifmp;
	BOOL	fFound = fFalse;

Start:
	critFMPPool.Enter();
	for ( ifmp = IfmpMinInUse(); ifmp <= IfmpMacInUse(); ifmp++ )
		{
		FMP *pfmp = &rgfmp[ ifmp ];

		if ( pfmp->FInUse()
			&& UtilCmpFileName( szFileName, pfmp->SzDatabaseName() ) == 0 &&
			// there can be 2 FMP's with same name recovering
			pfmp->Pinst() == PinstFromPpib( ppib ) )
			{
			pfmp->CritLatch().Enter();
			if ( pfmp->FWriteLatchByOther(ppib) )
				{
				/*	found an entry and the entry is write latched.
				 */
				critFMPPool.Leave();
				pfmp->GateWriteLatch().Wait( pfmp->CritLatch() );
				goto Start;
				}

			/*	found an entry and the entry is not write latched.
			 */
			*pifmp = ifmp;
			pfmp->SetWriteLatch( ppib );
			pfmp->CritLatch().Leave();
			fFound = fTrue;
			break;
			}
		}

	critFMPPool.Leave();

	return ( fFound ? JET_errSuccess : ErrERRCheck( JET_errDatabaseNotFound ) );
	}

IFMP FMP::ErrSearchAttachedByNameSz( CHAR *szFileName )
	{
	IFMP	ifmp;

	critFMPPool.Enter();
	for ( ifmp = IfmpMinInUse(); ifmp <= IfmpMacInUse(); ifmp++ )
		{
		FMP *pfmp = &rgfmp[ ifmp ];

		if ( pfmp->FInUse()
			&& UtilCmpFileName( szFileName, pfmp->SzDatabaseName() ) == 0
			&& pfmp->FAttached() )
			{
			Assert ( !pfmp->FSkippedAttach() );
			critFMPPool.Leave();
			return ifmp;
			}
		}

	critFMPPool.Leave();

	// not found
	return ( ifmpMax );
	}



ERR FMP::ErrWriteLatchBySLVNameSz( CHAR *szSLVFileName, IFMP *pifmp, PIB *ppib )
	{
	IFMP	ifmp;
	BOOL	fFound = fFalse;

Start:
	critFMPPool.Enter();
	for ( ifmp = IfmpMinInUse(); ifmp <= IfmpMacInUse(); ifmp++ )
		{
		FMP *pfmp = &rgfmp[ ifmp ];

		if ( pfmp->FInUse() && pfmp->SzSLVName()
			&& UtilCmpFileName( szSLVFileName, pfmp->SzSLVName() ) == 0 &&
			// there can be 2 FMP's with same name recovering
			pfmp->Pinst() == PinstFromPpib( ppib ) )
			{
			pfmp->CritLatch().Enter();
			if ( pfmp->FWriteLatchByOther(ppib) )
				{
				/*	found an entry and the entry is write latched.
				 */
				critFMPPool.Leave();
				pfmp->GateWriteLatch().Wait( pfmp->CritLatch() );
				goto Start;
				}

			/*	found an entry and the entry is not write latched.
			 */
			*pifmp = ifmp;
			pfmp->SetWriteLatch( ppib );
			pfmp->CritLatch().Leave();
			fFound = fTrue;
			break;
			}
		}

	critFMPPool.Leave();

	return ( fFound ? JET_errSuccess : ErrERRCheck( JET_errDatabaseNotFound ) );
	}



ERR FMP::ErrWriteLatchByIfmp( IFMP ifmp, PIB *ppib )
	{
	FMP *pfmp = &rgfmp[ ifmp ];

Start:
	critFMPPool.Enter();

	//	If no identity for this FMP, return.

	if ( !pfmp->FInUse() || PinstFromPpib( ppib ) != pfmp->Pinst() )
		{
		critFMPPool.Leave();
		return ErrERRCheck( JET_errDatabaseNotFound );
		}

	//	check if it is latchable.

	pfmp->CritLatch().Enter();
	if ( pfmp->FWriteLatchByOther(ppib) )
		{
		/*	found an entry and the entry is write latched.
		 */
		critFMPPool.Leave();
		pfmp->GateWriteLatch().Wait( pfmp->CritLatch() );
		goto Start;
		}

	//	found an entry and the entry is not write latched.

	pfmp->SetWriteLatch( ppib );
	pfmp->CritLatch().Leave();

	critFMPPool.Leave();

	return JET_errSuccess;
	}


VOID FMP::GetExtendingDBLatch()
	{
	//  wait to own extending the database

	SemExtendingDB().Acquire();
	}


VOID FMP::ReleaseExtendingDBLatch()
	{
	//  release ownership of extending the database

	SemExtendingDB().Release();
	}


VOID FMP::GetShortReadLatch( PIB *ppib )
	{
Start:
	this->CritLatch().Enter();
	Assert( this->CritLatch().FOwner() );
	if ( ( this->FWriteLatchByOther(ppib) ) )
		{
		this->GateWriteLatch().Wait( this->CritLatch() );
		goto Start;
		}

	return;
	}


VOID FMP::ReleaseShortReadLatch()
	{
	this->CritLatch().Leave();
	}

LOCAL VOID FMPIBuildRelocatedDbPath(
	IFileSystemAPI * const	pfsapi,
	const CHAR * const		szOldPath,
	const CHAR * const		szNewDir,
	CHAR * const			szNewPath )
	{
	CHAR					szDirT[ IFileSystemAPI::cchPathMax ];
	CHAR					szFileBaseT[ IFileSystemAPI::cchPathMax ];
	CHAR					szFileExtT[ IFileSystemAPI::cchPathMax ];

	CallS( pfsapi->ErrPathParse(
						szOldPath,
						szDirT,
						szFileBaseT,
						szFileExtT ) );

	CallS( pfsapi->ErrPathBuild(
						szNewDir,
						szFileBaseT,
						szFileExtT,
						szNewPath ) );
	}

ERR FMP::ErrStoreDbAndSLVNames(
	const INST * const		pinst,
	IFileSystemAPI * const	pfsapi,
	const CHAR *			szDbName,
	const CHAR *			szSLVName,
	const CHAR *			szSLVRoot,
	const BOOL				fValidatePaths )
	{
	ERR						err;
	const LOG * const		plog				= pinst->m_plog;
	CHAR *					szRelocatedDb		= NULL;
	CHAR *					szRelocatedSLV		= NULL;
	CHAR 	 				rgchDbFullName[IFileSystemAPI::cchPathMax];
	CHAR  					rgchSLVFullName[IFileSystemAPI::cchPathMax];

	Assert( NULL != szDbName );
	Assert( NULL == szSLVRoot || NULL != szSLVName );
	Assert( NULL != plog );

	if ( plog->m_fAlternateDbDirDuringRecovery )
		{
		FMPIBuildRelocatedDbPath(
					pfsapi,
					szDbName,
					plog->m_szAlternateDbDirDuringRecovery,
					rgchDbFullName );
		szRelocatedDb = rgchDbFullName;

		if ( NULL != szSLVName )
			{
			FMPIBuildRelocatedDbPath(
						pfsapi,
						szSLVName,
						plog->m_szAlternateDbDirDuringRecovery,
						rgchSLVFullName );
			szRelocatedSLV = rgchSLVFullName;
			}
		}

	else if ( fValidatePaths )
		{
		err = pfsapi->ErrPathComplete( szDbName, rgchDbFullName );
		CallR( err == JET_errInvalidPath ? ErrERRCheck( JET_errDatabaseInvalidPath ) : err );
		szDbName = rgchDbFullName;

		if ( NULL != szSLVName )
			{
			err = pfsapi->ErrPathComplete( szSLVName, rgchSLVFullName );
			CallR( JET_errInvalidPath == err ? ErrERRCheck( JET_errSLVInvalidPath ) : err );
			szSLVName = rgchSLVFullName;
			}
		}

	const SIZE_T	cbRelocatedDb	= ( plog->m_fAlternateDbDirDuringRecovery ? strlen( szRelocatedDb ) + 1 : 0 );
	const SIZE_T	cbRelocatedSLV	= ( NULL != szSLVName && plog->m_fAlternateDbDirDuringRecovery ? strlen( szRelocatedSLV ) + 1 : 0 );
	const SIZE_T	cbDbName		= cbRelocatedDb + strlen( szDbName ) + 1;
	const SIZE_T	cbSLVName		= cbRelocatedSLV + ( NULL != szSLVName ? strlen( szSLVName ) + 1 : 0 );
	const SIZE_T	cbSLVRoot		= ( NULL != szSLVRoot ? strlen( szSLVRoot ) + 1 : 0 );
	const SIZE_T	cbAllocate		= cbRelocatedDb + cbDbName + cbRelocatedSLV + cbSLVName + cbSLVRoot;
	CHAR *			pch				= static_cast<CHAR *>( PvOSMemoryHeapAlloc( cbAllocate ) );
	CHAR *			pchNext			= pch;

	if ( NULL == pch )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}

	Assert( NULL == SzDatabaseName() );
	Assert( NULL == SzSLVName() );
	Assert( NULL == SzSLVRoot() );

	SetSzDatabaseName( pch );

	if ( plog->m_fAlternateDbDirDuringRecovery )
		{
		strcpy( pchNext, szRelocatedDb );
		pchNext += cbRelocatedDb;
		}

	strcpy( pchNext, szDbName );
	pchNext += cbDbName;

	if ( NULL != szSLVName )
		{
		SetSzSLVName( pchNext );

		if ( plog->m_fAlternateDbDirDuringRecovery )
			{
			strcpy( pchNext, szRelocatedSLV );
			pchNext += cbRelocatedSLV;
			}

		strcpy( pchNext, szSLVName );
		pchNext += cbSLVName;

		Assert( SzSLVName() > pch );
		Assert( NULL != szSLVRoot );
		Assert( pchNext < pch + cbAllocate );
		}
	else
		{
		SetSzSLVName( NULL );
		Assert( NULL == szSLVRoot );
		Assert( 0 == cbSLVRoot );
		Assert( pch + cbAllocate == pchNext );
		}

	if ( NULL != szSLVRoot )
		{
		Assert( NULL != szSLVName );
		Assert( cbSLVName > 0 );
		SetSzSLVRoot( pchNext );
		strcpy( SzSLVRoot(), szSLVRoot );
		Assert( SzSLVRoot() > pch );
		Assert( SzSLVRoot() + cbSLVRoot == pch + cbAllocate );
		}
	else
		{
		SetSzSLVRoot( NULL );
		Assert( NULL == szSLVName );
		Assert( 0 == cbSLVRoot );
		Assert( pch + cbAllocate == pchNext );
		}

	return JET_errSuccess;
	}


ERR FMP::ErrCopyAtchchk()
	{
	if ( NULL == PatchchkRestored() )
		{
		ATCHCHK *patchchkRestored;

		patchchkRestored = static_cast<ATCHCHK *>( PvOSMemoryHeapAlloc( sizeof( ATCHCHK ) ) );
		if ( NULL == patchchkRestored )
			{
			return ErrERRCheck( JET_errOutOfMemory );
			}
		memset( patchchkRestored, 0, sizeof( ATCHCHK ) );
		SetPatchchkRestored( patchchkRestored );
		}

	*PatchchkRestored() = *Patchchk();

	return JET_errSuccess;
	}


IFMP FMP::ifmpMinInUse = ifmpMax;
IFMP FMP::ifmpMacInUse = 0;
/*
 *	NewAndWriteLatch
 *		IFMP *pifmp				returned fmp entry
 *		CHAR *szDatabaseName	used to check if an entry has the same database name and instance
 *		PIB ppib				used to set the latch
 *		INST *pinst				instance that request this latch
 *
 *	This function look for an entry for setting up the database of the given instance.
 *	During recovery, we may allocate one entry and fill the database name. In that case,
 *	the database name is null, and ppib is ppibSurrogate.
 */
ERR FMP::ErrNewAndWriteLatch(
	IFMP						*pifmp,
	const CHAR					*szDatabaseName,
	const CHAR					*szSLVName,
	const CHAR					*szSLVRoot,
	PIB							*ppib,
	INST						*pinst,
	IFileSystemAPI * const		pfsapi,
	DBID						dbidGiven )
	{
	ERR			err				= JET_errSuccess;
	IFMP		ifmp;
	CHAR		szRestoreDestDbName = NULL;
	BOOL		fSkippedAttach 	= fFalse;
	BOOL		fDeferredAttach	= fFalse;

	Assert( NULL != szDatabaseName );

	//	verify that the database and SLV file are NOT the same file

	if ( szSLVName != NULL )
		{
		if ( UtilCmpFileName( szDatabaseName, szSLVName ) == 0 )
			{
			//	they are the same file -- the database wins and SLV file loses
			return ErrERRCheck( JET_errSLVStreamingFileInUse );
			}
		}

	// if we are restoring in a different location that the usage collison check must be
	// done between existing entries in fmp array and the new destination name.
	if ( pinst->FRecovering() )
		{
		Assert( pinst->m_plog );
		LOG *plog = pinst->m_plog;

		// build the destination file name
		if ( plog->m_fExternalRestore || ( plog->m_irstmapMac > 0 && !plog->m_fHardRestore ) )
			{
			INT  irstmap = plog->IrstmapLGGetRstMapEntry( szDatabaseName );
			if ( 0 > plog->IrstmapSearchNewName( szDatabaseName ) )
				{
				fSkippedAttach = fTrue;
				}
			}
		}

	//	lock the IFMP pool

	critFMPPool.Enter();

	//	look for unused file map entry
	//	and make sure that the SLV file is not in use by anyone else
	//	except the matching database

	for ( ifmp = IfmpMinInUse(); ifmp <= IfmpMacInUse(); ifmp++ )
		{
		FMP	*pfmp = &rgfmp[ ifmp ];

		if ( pfmp->FInUse() )
			{
			if ( 0 == UtilCmpFileName( pfmp->SzDatabaseName(), szDatabaseName ) )
				{
				if ( pfmp->Pinst() == pinst )
					{
					pfmp->CritLatch().Enter();

					if ( pfmp->FAttached()
						|| pfmp->FWriteLatchByOther( ppib )
						|| pfmp->CPin() )
						{
						err = ErrERRCheck( JET_wrnDatabaseAttached );
						}
					else
						{
						//	Same database, different stream file in use?
						if ( ( NULL == szSLVName && NULL != pfmp->SzSLVName() )
							|| ( NULL != szSLVName
								&& ( NULL == pfmp->SzSLVName()
									|| 0 != UtilCmpFileName( szSLVName, pfmp->SzSLVName() ) ) ) )
							{
							Call( ErrERRCheck( JET_errSLVStreamingFileInUse ) );
							}

						pfmp->SetWriteLatch( ppib );
						Assert( !( pfmp->FExclusiveOpen() ) );
						*pifmp = ifmp;
						CallS( err );
						}

					pfmp->CritLatch().Leave();
					}
				else
					{
					// check if one of the 2 members just compared is in SkippedAttach mode
					if ( fSkippedAttach
						|| pfmp->FSkippedAttach() )
						{
						continue;
						}
					else if ( pinst->FRecovering() )
						{
						fDeferredAttach = fTrue;
						continue;
						}

					err = ErrERRCheck( JET_errDatabaseSharingViolation );
					}

				goto HandleError;
				}
			//	Different databases, check against stream files
			else
				{
				if (	NULL != szSLVName &&
						(	0 == UtilCmpFileName( pfmp->SzDatabaseName(), szSLVName ) ||
							(	NULL != pfmp->SzSLVName() &&
								0 == UtilCmpFileName( szSLVName, pfmp->SzSLVName() ) ) ) )
					{
					Call( ErrERRCheck( JET_errSLVStreamingFileInUse ) );
					}
				if ( NULL != pfmp->SzSLVName() && UtilCmpFileName( szDatabaseName, pfmp->SzSLVName() ) == 0 )
					{
					Call( ErrERRCheck( JET_errDatabaseSharingViolation ) );
					}
				}
			}
		}

	//	Allocate entry from pinst->m_mpdbidifmp

	if ( dbidGiven >= dbidMax )
		{
		DBID dbid;

		for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
			{
			if ( pinst->m_mpdbidifmp[ dbid ] >= ifmpMax )
				break;
			}

		if ( dbid >= dbidMax )
			{
			err = ErrERRCheck( JET_errTooManyAttachedDatabases );
			goto HandleError;
			}

		dbidGiven = dbid;
		}

	//	Allocate entry from rgfmp

	for ( ifmp = IfmpMinInUse(); ifmp < IfmpMacInUse(); ifmp++ )
		{
		if ( !rgfmp[ifmp].FInUse() )
			{
			// found empty fmp
			break;
			}
		}

	//	there is no FMPs at all
	if ( IfmpMacInUse() < ifmp )
		{
		Assert( IfmpMinInUse() > IfmpMacInUse() );
		ifmp = 0;
		ifmpMinInUse = ifmp;
		ifmpMacInUse = ifmp;
		}
	//	all FMPs in Min, Mac range are in use
	else if ( IfmpMacInUse() == ifmp && rgfmp[ifmp].FInUse() )
		{
		Assert( IfmpMinInUse() <= IfmpMacInUse() );
		if ( IfmpMinInUse() > 0 )
			{
			ifmp = IfmpMinInUse() - 1;
			ifmpMinInUse = ifmp;
			}
		else if ( IfmpMacInUse()+1 < ifmpMax )
			{
			ifmp = IfmpMacInUse() + 1;
			ifmpMacInUse = ifmp;
			}
		else
			{
			ifmp = ifmpMax;
			}
		}
	else
		{
		Assert( IfmpMacInUse() >= ifmp );
		Assert( !rgfmp[ifmp].FInUse() );
		}

	if ( ifmp < ifmpMax )
		{

		//	Partially AssertVALIDIFMP
		Assert( IfmpMinInUse() <= ifmp );
		Assert( IfmpMacInUse() >= ifmp );
		FMP	*pfmp = &rgfmp[ ifmp ];

		//	if we can find one entry here, latch it.

		Assert( !pfmp->FInUse() );
		Call( pfmp->ErrStoreDbAndSLVNames( pinst, pfsapi, szDatabaseName, szSLVName, szSLVRoot, fFalse ) );

		pfmp->SetPinst( pinst );
		pfmp->SetDbid( dbidGiven );
		pinst->m_mpdbidifmp[ dbidGiven ] = ifmp;

		pfmp->CritLatch().Enter();

		pfmp->ResetFlags();

		if ( fDeferredAttach )
			{
			Assert( pinst->FRecovering() );
			pfmp->SetDeferredAttach();
			pfmp->SetLogOn();
			}

		//	set trxOldestTarget to trxMax to make these
		//	variables unusable until they get reset
		//	by Create/AttachDatabase
		pfmp->SetDbtimeOldestGuaranteed( 0 );
		pfmp->SetDbtimeOldestCandidate( 0 );
		pfmp->SetDbtimeOldestTarget( 0 );
		pfmp->SetTrxOldestCandidate( trxMax );
		pfmp->SetTrxOldestTarget( trxMax );
		pfmp->SetTrxNewestWhenDiscardsLastReported( trxMin );

		pfmp->SetWriteLatch( ppib );
		pfmp->SetLgposAttach( lgposMin );
		pfmp->SetLgposDetach( lgposMin );
		Assert( !pfmp->FExclusiveOpen() );

		pfmp->CritLatch().Leave();

		*pifmp = ifmp;
		err = JET_errSuccess;
		}
	else
		{
		err = ErrERRCheck( JET_errTooManyAttachedDatabases );
		}

HandleError:
	critFMPPool.Leave();
	return err;
	}


VOID FMP::ReleaseWriteLatchAndFree( PIB *ppib )
	{
	Assert ( critFMPPool.FOwner() );
	CritLatch().Enter();

	/*	Identity must exists. It was just newed, so
	 *	if it is exclusively opened, it must be opened by me
	 */
	Assert( !FExclusiveOpen() || PpibExclusiveOpen() == ppib );
	IFMP ifmp = PinstFromPpib( ppib )->m_mpdbidifmp[ Dbid() ];
	FMP::AssertVALIDIFMP( ifmp );
	OSMemoryHeapFree( SzDatabaseName() );
	SetSzDatabaseName( NULL );
	SetSzSLVName( NULL );
	SetSzSLVRoot( NULL );

	SetPinst( NULL );
	PinstFromPpib( ppib )->m_mpdbidifmp[ Dbid() ] = ifmpMax;
	SetDbid( dbidMax );

	Assert( !FExclusiveOpen() );

	ResetFlags();
	if ( IfmpMinInUse() == ifmp )
		{

		IFMP ifmpT = IfmpMinInUse() + 1;
		for ( ; ifmpT <= IfmpMacInUse(); ifmpT++ )
			{
			if ( NULL != rgfmp[ ifmpT ].SzDatabaseName() )
				{
				break;
				}
			}

		if ( ifmpT > IfmpMacInUse() )	//	no more ocupied FMPs
			{
			Assert( IfmpMacInUse()+1 == ifmpT );
			ifmpMacInUse = 0;
			ifmpMinInUse = ifmpMax;
			}
		else
			{
			ifmpMinInUse = ifmpT;
			}
		}
	else if ( IfmpMacInUse() == ifmp )
		{
		IFMP ifmpT = ifmp - 1;
		for ( ; ifmpT > IfmpMinInUse(); ifmpT-- )
			{
			if ( NULL != rgfmp[ ifmpT ].SzDatabaseName() )
				{
				break;
				}
			}
		ifmpMacInUse = ifmpT;
		}

	/*	Free write latch.
	 */
	ResetWriteLatch( ppib );
	if ( GateWriteLatch().CWait() > 0 )
		{
		GateWriteLatch().Release( CritLatch() );
		}
	else
		{
		CritLatch().Leave();
		}
	}


ERR FMP::ErrFMPInit( )
	{
	ERR		err;
	IFMP	ifmp	= 0;

	/* initialize the file map array */

	if ( !( rgfmp = new FMP[ ifmpMax ] ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	ifmpMinInUse = ifmpMax;
	ifmpMacInUse = 0;

	for ( ifmp = 0; ifmp < ifmpMax; ifmp++ )
		{
#ifdef DEBUG
		rgfmp[ ifmp ].SetDatabaseSizeMax( 0xFFFFFFFF );
#endif  //  DEBUG

		//  initialize sentry range locks
		//  CONSIDER:  make default number of ranges bigger based on backup's needs

		SIZE_T crangeMax	= 1;
		SIZE_T cbrangelock	= sizeof( RANGELOCK ) + crangeMax * sizeof( RANGE );

		if (	!( rgfmp[ ifmp ].m_rgprangelock[ 0 ] = (RANGELOCK*)PvOSMemoryHeapAlloc( cbrangelock ) ) ||
				!( rgfmp[ ifmp ].m_rgprangelock[ 1 ] = (RANGELOCK*)PvOSMemoryHeapAlloc( cbrangelock ) ) )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}

		rgfmp[ ifmp ].m_rgprangelock[ 0 ]->crange		= 0;
		rgfmp[ ifmp ].m_rgprangelock[ 0 ]->crangeMax	= crangeMax;

		rgfmp[ ifmp ].m_rgprangelock[ 1 ]->crange		= 0;
		rgfmp[ ifmp ].m_rgprangelock[ 1 ]->crangeMax	= crangeMax;
		}

	return JET_errSuccess;

HandleError:
	if ( rgfmp )
		{
		for ( ifmp = 0; ifmp < ifmpMax; ifmp++ )
			{
			OSMemoryHeapFree( rgfmp[ ifmp ].m_rgprangelock[ 0 ] );
			OSMemoryHeapFree( rgfmp[ ifmp ].m_rgprangelock[ 1 ] );
			}

		delete[] rgfmp;
		rgfmp = NULL;
		}
	return err;
	}


VOID FMP::Term( )
	{
	INT	ifmp;

	for ( ifmp = 0; ifmp < ifmpMax; ifmp++ )
		{
		FMP *pfmp = &rgfmp[ifmp];

		OSMemoryHeapFree( pfmp->SzDatabaseName() );
		OSMemoryPageFree( pfmp->Pdbfilehdr() );
		OSMemoryHeapFree( pfmp->Patchchk() );
		OSMemoryHeapFree( pfmp->PatchchkRestored() );
		OSMemoryHeapFree( pfmp->SzPatchPath() );
		OSMemoryHeapFree( pfmp->m_rgprangelock[ 0 ] );
		OSMemoryHeapFree( pfmp->m_rgprangelock[ 1 ] );
		}

	/*	free FMP
	/**/
	delete [] rgfmp;
	rgfmp = NULL;
	}


//  waits until the given PGNO range can no longer be written to by the buffer
//  manager.  this is used to provide a coherent view of the underlying file
//  for this PGNO range for backup purposes

ERR FMP::ErrRangeLock( PGNO pgnoStart, PGNO pgnoEnd )
	{
	ERR err = JET_errSuccess;

	//  prevent others from modifying the range lock while we are modifying the
	//  range lock

	m_semRangeLock.Acquire();

	//  get the pointers to the pointers to the current and new range locks so
	//  that we can manipulate them easily

	RANGELOCK** pprangelockCur = &m_rgprangelock[ m_msRangeLock.ActiveGroup() ];
	RANGELOCK** pprangelockNew = &m_rgprangelock[ 1 - m_msRangeLock.ActiveGroup() ];

	//  the new range lock doesn't have enough room to store all the ranges we need

	if ( (*pprangelockNew)->crangeMax < (*pprangelockCur)->crange + 1 )
		{
		//  double the size of the new range lock

		SIZE_T crangeMax	= 2 * (*pprangelockNew)->crangeMax;
		SIZE_T cbrangelock	= sizeof( RANGELOCK ) + crangeMax * sizeof( RANGE );

		RANGELOCK* prangelock = (RANGELOCK*)PvOSMemoryHeapAlloc( cbrangelock );
		if ( !prangelock )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}

		prangelock->crangeMax = crangeMax;

		OSMemoryHeapFree( *pprangelockNew );

		*pprangelockNew = prangelock;
		}

	//  copy the state of the current range lock to the new range lock

	SIZE_T irange;
	for ( irange = 0; irange < (*pprangelockCur)->crange; irange++ )
		{
		(*pprangelockNew)->rgrange[ irange ].pgnoStart	= (*pprangelockCur)->rgrange[ irange ].pgnoStart;
		(*pprangelockNew)->rgrange[ irange ].pgnoEnd	= (*pprangelockCur)->rgrange[ irange ].pgnoEnd;
		}

	//  append the new range to the new range lock

	(*pprangelockNew)->rgrange[ irange ].pgnoStart	= pgnoStart;
	(*pprangelockNew)->rgrange[ irange ].pgnoEnd	= pgnoEnd;

	//  set the number of ranges in the new range lock

	(*pprangelockNew)->crange = (*pprangelockCur)->crange + 1;

	//  cause new writers to see the new range lock and wait until all writers
	//  that saw the old range lock are done writing

	m_msRangeLock.Partition();

	//  allow others to modify the range lock now that it is set

HandleError:
	m_semRangeLock.Release();
	return err;
	}

//  permits writes to resume to the given PGNO range locked using FMP::ErrRangeLock

void FMP::RangeUnlock( PGNO pgnoStart, PGNO pgnoEnd )
	{
	//  prevent others from modifying the range lock while we are modifying the
	//  range lock

	m_semRangeLock.Acquire();

	//  get the pointers to the pointers to the current and new range locks so
	//  that we can manipulate them easily

	RANGELOCK** pprangelockCur = &m_rgprangelock[ m_msRangeLock.ActiveGroup() ];
	RANGELOCK** pprangelockNew = &m_rgprangelock[ 1 - m_msRangeLock.ActiveGroup() ];

	//  we should always have enough room to store all the ranges we need because
	//  we only add or remove one range at a time

	Assert( (*pprangelockNew)->crangeMax >= (*pprangelockCur)->crange - 1 );

	//  copy all ranges but the specified range to the new range lock

	for ( SIZE_T irangeSrc = 0, irangeDest = 0; irangeSrc < (*pprangelockCur)->crange; irangeSrc++ )
		{
		if (	(*pprangelockCur)->rgrange[ irangeSrc ].pgnoStart != pgnoStart ||
				(*pprangelockCur)->rgrange[ irangeSrc ].pgnoEnd != pgnoEnd )
			{
			(*pprangelockNew)->rgrange[ irangeDest ].pgnoStart	= (*pprangelockCur)->rgrange[ irangeSrc ].pgnoStart;
			(*pprangelockNew)->rgrange[ irangeDest ].pgnoEnd	= (*pprangelockCur)->rgrange[ irangeSrc ].pgnoEnd;

			irangeDest++;
			}
		}

	//  we had better have found the range specified!!!!!

	Assert( irangeDest == irangeSrc - 1 );

	//  set the number of ranges in the new range lock

	(*pprangelockNew)->crange = irangeDest;

	//  cause new writers to see the new range lock and wait until all writers
	//  that saw the old range lock are done writing

	m_msRangeLock.Partition();

	//  allow others to modify the range lock now that it is set

	m_semRangeLock.Release();
	}

//  enters the range lock, returning the active range lock

int FMP::EnterRangeLock()
	{
	return m_msRangeLock.Enter();
	}

//  tests the given pgno against the specified range lock.  if fTrue is returned,
//  that pgno cannot be written at this time and the caller must LeaveRangeLock().
//  if fFalse is returned, that pgno may be written.  if the caller decides to
//  write that pgno, the caller must not call LeaveRangeLock() until the write
//  has completed.  if the caller decides not to write that pgno, the caller
//  must still LeaveRangeLock()

BOOL FMP::FRangeLocked( int irangelock, PGNO pgno )
	{
	//  get a pointer to the specified range lock.  because the caller called
	//  EnterRangeLock() to get this range lock, it will be stable until they
	//  call LeaveRangeLock()

	RANGELOCK* prangelock = m_rgprangelock[ irangelock ];

	//  scan all ranges looking for this pgno

	for ( SIZE_T irange = 0; irange < prangelock->crange; irange++ )
		{
		//  the current range contains this pgno

		if (	prangelock->rgrange[ irange ].pgnoStart <= pgno &&
				prangelock->rgrange[ irange ].pgnoEnd >= pgno )
			{
			//  this pgno is range locked

			return fTrue;
			}
		}

	//  we did not find a range that contains this pgno, so the pgno is not
	//  range locked

	return fFalse;
	}

//  leaves the specified range lock

void FMP::LeaveRangeLock( int irangelock )
	{
	m_msRangeLock.Leave( irangelock );
	}

ERR FMP::ErrSnapshotStart( IFileSystemAPI *const pfsapi, BKINFO * pbkInfo )
	{
	ERR err = JET_errSuccess;

	DBFILEHDR_FIX *pdbfilehdr	= Pdbfilehdr();
	Assert( pdbfilehdr );
	PGNO pgnoMost = PgnoLast();

	Assert ( FInUse() && FLogOn() && FAttached() );

	if ( FInBackupSession() || FDuringSnapshot() )
		{
		return ErrERRCheck ( JET_errInvalidBackupSequence );
		}

	Assert ( !FInBackupSession() );
	Assert ( !FDuringSnapshot() );

	Assert( !FSkippedAttach() );
	Assert( !FDeferredAttach() );

	CallR ( ErrRangeLock( 0, pgnoMost ) );

	Assert ( 0 == PgnoMost() );
	SetPgnoMost( pgnoMost );
	Assert ( 0 < PgnoMost() );

	// set the start log position
	pdbfilehdr->bkinfoSnapshotCur = *pbkInfo;

	Call ( ErrUtilWriteShadowedHeader(	pfsapi,
										SzDatabaseName(),
										fTrue,
										(BYTE *)pdbfilehdr,
										g_cbPage,
										Pfapi() ) );

	// after the db header is updated, we don't error out
	// in any way. If we do, we need to reset the db header
	// If this fails, we need to stop the backup session.

	SetInBackupSession();
	SetDuringSnapshot();

	return err;

HandleError:

	Assert ( !FInBackupSession() );
	Assert ( !FDuringSnapshot() );

	memset ( &(pdbfilehdr->bkinfoSnapshotCur), 0, sizeof( BKINFO ) );

	Assert ( PgnoMost() );
	RangeUnlock( 0, PgnoMost() );
	SetPgnoMost( 0 );

	return err;
	}

ERR FMP::ErrSnapshotStop( IFileSystemAPI *const pfsapi )
	{

	ERR err = JET_errSuccess;

	DBFILEHDR_FIX *pdbfilehdr	= Pdbfilehdr();
	Assert( pdbfilehdr );
	PGNO pgnoMost = PgnoLast();

	Assert ( FInUse() && FLogOn() && FAttached() );

	if ( !FInBackupSession() || !FDuringSnapshot() )
		{
		return ErrERRCheck ( JET_errInvalidBackupSequence );
		}

	Assert ( 0 != CmpLgpos ( &(pdbfilehdr->bkinfoSnapshotCur.le_lgposMark), &lgposMin) );
	memset ( &(pdbfilehdr->bkinfoSnapshotCur), 0, sizeof( BKINFO ) );

	Assert ( PgnoMost() );
	RangeUnlock( 0, PgnoMost() );
	SetPgnoMost( 0 );

	Assert ( SzDatabaseName() );
	Assert ( Pfapi() );

	// we want to reset the DuringSnapshot flag anyway so the db can flush
 	err = ErrUtilWriteShadowedHeader( pfsapi, SzDatabaseName(), fTrue, (BYTE *) pdbfilehdr, g_cbPage, Pfapi() );

	Assert ( FInBackupSession() );
	ResetDuringSnapshot();

	return err;
	}

ERR FMP::ErrSetPdbfilehdr(DBFILEHDR_FIX * pdbfilehdr)
	{
	ERR err = JET_errSuccess;

	Assert( NULL == m_pdbfilehdr || NULL == pdbfilehdr );

	if ( NULL != pdbfilehdr && !FReadOnlyAttach() )
		{
		const INST * 	pinst 		= Pinst();
		DBID			dbid;

		Assert ( SzDatabaseName() );
		Assert ( !FSkippedAttach() );

		EnterCritFMPPool();
		for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
			{
			if ( pinst->m_mpdbidifmp[ dbid ] >= ifmpMax || dbid == m_dbid )
				continue;

			FMP	*pfmpT;

			pfmpT = &rgfmp[ pinst->m_mpdbidifmp[ dbid ] ];

			if ( pfmpT->Pdbfilehdr()
				&& !pfmpT->FReadOnlyAttach()
				&& 0 == memcmp( &( pdbfilehdr->signDb), &(pfmpT->Pdbfilehdr()->signDb), sizeof( SIGNATURE ) ) )
				{
				LeaveCritFMPPool();
				Call( ErrERRCheck ( JET_errDatabaseSignInUse ) );
				}
			}

		LeaveCritFMPPool();
		CallS( err );
		}
	m_pdbfilehdr = pdbfilehdr;
HandleError:
	return err;
	}

VOID FMP::UpdateDbtimeOldest()
	{
	const DBTIME	dbtimeLast	= DbtimeGet();	//	grab current dbtime before next trx begins

	Assert( critFMPPool.FOwner() );

	//	don't call this function during recovery
	//	or when we're terminating
	//	UNDONE: is there a better way to tell if we're
	//	terminating besides this m_ppibGlobal check?
	Assert( !m_pinst->FRecovering() );
	Assert( ppibNil != m_pinst->m_ppibGlobal );

	for ( size_t iProc = 0; iProc < OSSyncGetProcessorCountMax(); iProc++ )
		{
		INST::PLS* const ppls = m_pinst->Ppls( iProc );
		ppls->m_critPIBTrxOldest.Enter();
		}
	TRX trxOldest	= trxMax;
	TRX trxNewest	= m_pinst->m_trxNewest;
	for ( iProc = 0; iProc < OSSyncGetProcessorCountMax(); iProc++ )
		{
		INST::PLS* const ppls = m_pinst->Ppls( iProc );
		PIB* const ppibTrxOldest = ppls->m_ilTrxOldest.PrevMost();
		if ( ppibTrxOldest && TrxCmp( ppibTrxOldest->trxBegin0, trxOldest ) < 0 )
			{
			trxOldest = ppibTrxOldest->trxBegin0;
			}
		}
	for ( iProc = 0; iProc < OSSyncGetProcessorCountMax(); iProc++ )
		{
		INST::PLS* const ppls = m_pinst->Ppls( iProc );
		ppls->m_critPIBTrxOldest.Leave();
		}

	//	if we've reached the target trxOldest, then we
	//	can update the guaranteed dbtimeOldest
	const TRX		trxOldestCandidate	= TrxOldestCandidate();
	const TRX		trxOldestTarget		= TrxOldestTarget();

	Assert( trxMax == trxOldestTarget
		|| TrxCmp( trxOldestCandidate, trxOldestTarget ) <= 0 );

	if ( trxMax == trxOldestTarget )
		{
		//	need to wait until the current candidate is
		//	older than the oldest transaction before
		//	we can establish a new target
		if ( TrxCmp( trxOldestCandidate, trxOldest ) < 0 )
			{
			SetDbtimeOldestTarget( dbtimeLast );
			SetTrxOldestTarget( trxNewest );
			}
		}
	else if ( TrxCmp( trxOldestTarget, trxOldest ) < 0 )
		{
		//	the target trxOldest has now been reached
		//	(ie. it is older than the oldest transaction,
		//	so the candidate dbtimeOldest is now the
		//	guaranteed dbtimeOldest
		//	UNDONE: need a better explanation than
		//	that to explain this complicated logic
		const DBTIME	dbtimeOldestGuaranteed	= DbtimeOldestGuaranteed();
		const DBTIME	dbtimeOldestCandidate	= DbtimeOldestCandidate();
		const DBTIME	dbtimeOldestTarget		= DbtimeOldestTarget();

		Assert( dbtimeOldestGuaranteed <= dbtimeOldestCandidate );
		Assert( dbtimeOldestCandidate <= dbtimeOldestTarget );
		Assert( dbtimeOldestTarget <= dbtimeLast );

		SetDbtimeOldestGuaranteed( dbtimeOldestCandidate );
		SetDbtimeOldestCandidate( dbtimeOldestTarget );
		SetDbtimeOldestTarget( dbtimeLast );
		SetTrxOldestCandidate( trxOldestTarget );
		SetTrxOldestTarget( trxMax );

		//	we know oldest transaction has advanced, so take this
		//	opportunity to signal version cleanup as well if it
		//	hasn't been signalled in a while
		//
		if ( TickOSTimeCurrent() - Pinst()->m_pver->m_tickLastRCEClean > VER::dtickRCECleanPeriod )
			{
			Pinst()->m_pver->VERSignalCleanup();
			}
		}
	}

ERR FMP::ErrObjidLastIncrementAndGet( OBJID *pobjid )
	{
	Assert( NULL != pobjid );

	if ( !FAtomicIncrementMax( &m_objidLast, pobjid, objidFDPMax ) )
		{
		const _TCHAR *rgpszT[1] = { SzDatabaseName() };
		UtilReportEvent(
				eventError,
				GENERAL_CATEGORY,
				OUT_OF_OBJID,
				1,
				rgpszT,
				0,
				NULL,
				Pinst() );
		return ErrERRCheck( JET_errOutOfObjectIDs );
		}

	//	FAtomicIncrementMax() returns the objid before the increment
	(*pobjid)++;

	// Notify user to defrag database if neccessary
	if ( objidFDPThreshold == *pobjid )
		{
		const _TCHAR *rgpszT[1] = { SzDatabaseName() };
		UtilReportEvent(
				eventWarning,
				GENERAL_CATEGORY,
				ALMOST_OUT_OF_OBJID,
				1,
				rgpszT,
				0,
				NULL,
				Pinst() );
		}

	return JET_errSuccess;
	}


/******************************************************************/
/*				IO                                                */
/******************************************************************/

ERR ErrIOInit( INST *pinst )
	{
	//	Set up ifmp fmp maps

	pinst->m_plog->m_fLGFMPLoaded = fFalse;

#ifdef UNLIMITED_DB
	pinst->m_plog->LGIInitDbListBuffer();
#endif

	return JET_errSuccess;
	}

/*	go through FMP closing files.
/**/
ERR ErrIOTerm( INST *pinst, IFileSystemAPI *const pfsapi, BOOL fNormal )
	{
	ERR			err, errT = JET_errSuccess;
	DBID		dbid;
	LGPOS		lgposShutDownMarkRec = lgposMin;
	LOG			*plog = pinst->m_plog;

	//	Reset global variables.
	//
	Assert( pinst->m_ppibGlobal == ppibNil );

	/*	update checkpoint before fmp is cleaned if m_plog->m_fFMPLoaded is true.
	 */
	err = plog->ErrLGUpdateCheckpointFile( pfsapi, fTrue );

	//	There should be no attaching/detaching/creating going on
	Assert( err != JET_errDatabaseSharingViolation );

	if ( err < 0 && plog->m_fRecovering )
		{
		//	disable log writing but clean fmps
		plog->SetFNoMoreLogWrite( err );
		}

	/*	No more checkpoint update from now on. Now I can safely clean up the
	 *	rgfmp.
	 */
	plog->m_fLGFMPLoaded = fFalse;

	/*	Set proper shut down mark.
	 */
	if ( fNormal && !plog->m_fLogDisabled )
		{
		//	If we are doing recovering and
		//	if it is in redo mode or
		//	if it is in undo mode but last record seen is shutdown mark, then no
		//	need to log and set shutdown mark again. Note the latter case (undo mode)
		//	is to prevent to log two shutdown marks in a row after recovery and
		//	invalidate the previous one which the attached database have used as
		//	the consistent point.

		if ( plog->m_fRecovering
			&& ( plog->m_fRecoveringMode == fRecoveringRedo
				|| ( plog->m_fRecoveringMode == fRecoveringUndo && plog->m_fLastLRIsShutdown ) ) )
			{
			lgposShutDownMarkRec = plog->m_lgposRedoShutDownMarkGlobal;
			}
		else
			{
			errT = ErrLGShutDownMark( pinst->m_plog, &lgposShutDownMarkRec );
			if ( errT < 0 )
				{
				fNormal = fFalse;
				}
			}
		}

	if ( errT < 0 && err >= 0 )
		{
		err = errT;
		}
	for ( dbid = dbidMin; dbid < dbidMax; dbid++ )
		{
		//	maintain the attach checker.
		IFMP ifmp = pinst->m_mpdbidifmp[ dbid ];
		if ( ifmp >= ifmpMax )
			continue;

		FMP *pfmp = &rgfmp[ ifmp ];

		pfmp->RwlDetaching().EnterAsWriter();
		pfmp->SetDetachingDB( );
		pfmp->RwlDetaching().LeaveAsWriter();

		if ( fNormal && plog->m_fRecovering )
			{
			Assert( !pfmp->FReadOnlyAttach() );
			if ( pfmp->Patchchk() )
				{
				Assert( dbidTemp != pfmp->Dbid() );
				pfmp->Patchchk()->lgposConsistent = lgposShutDownMarkRec;
				}
			}

		/*	free file handle and pdbfilehdr
		 */
		Assert( pfmp->Pfapi()
				|| NULL == pfmp->Pdbfilehdr()
				|| !fNormal );		//	on error, may have dbfilehdr and no file handle
		if ( pfmp->Pfapi() )
			{
			Assert( NULL != pfmp->Pdbfilehdr() );

			if ( pfmp->FSLVAttached() )
				{
				SLVClose( ifmp );
				}

			delete pfmp->Pfapi();
			pfmp->SetPfapi( NULL );

			if ( fNormal
				&& pfmp->Dbid() != dbidTemp
				&& !pfmp->FReadOnlyAttach() )
				{
				DBFILEHDR	*pdbfilehdr	= pfmp->Pdbfilehdr();

				/*	Update database header.
				 */
				pdbfilehdr->SetDbstate( JET_dbstateConsistent );
				pdbfilehdr->le_dbtimeDirtied = pfmp->DbtimeLast();
				Assert( pdbfilehdr->le_dbtimeDirtied != 0 );
				pdbfilehdr->le_objidLast = pfmp->ObjidLast();
				Assert( pdbfilehdr->le_objidLast != 0 );

				if ( plog->m_fRecovering )
					{
					BKINFO * pbkInfoToCopy;

					if ( plog->FSnapshotRestore() )
						{
						pbkInfoToCopy = &(pfmp->Pdbfilehdr()->bkinfoSnapshotCur);
						}
					else
						{
						pbkInfoToCopy = &(pfmp->Pdbfilehdr()->bkinfoFullCur);
						}

					if ( pbkInfoToCopy->le_genLow != 0 )
						{
						Assert(pbkInfoToCopy->le_genHigh != 0 );
						pfmp->Pdbfilehdr()->bkinfoFullPrev = (*pbkInfoToCopy);
						memset(	&pfmp->Pdbfilehdr()->bkinfoFullCur, 0, sizeof( BKINFO ) );
						memset(	&pfmp->Pdbfilehdr()->bkinfoSnapshotCur, 0, sizeof( BKINFO ) );
						memset(	&pfmp->Pdbfilehdr()->bkinfoIncPrev, 0, sizeof( BKINFO ) );
						}

#ifdef BKINFO_DELETE_ON_HARD_RECOVERY
					// BUG: 175058: delete the previous backup info on any hard recovery
					// this will prevent a incremental backup and log truncation problems
					// UNDONE: the above logic to copy bkinfoFullPrev is probably not needed
					// (we may consider this and delete it)
					if ( plog->m_fHardRestore )
						{
						memset(	&pfmp->Pdbfilehdr()->bkinfoFullPrev, 0, sizeof( BKINFO ) );
						}
#endif // BKINFO_DELETE_ON_HARD_RECOVERY

					}

				Assert( !pfmp->FLogOn() || !plog->m_fLogDisabled );
				if ( pfmp->FLogOn() )
					{
					Assert( 0 != CmpLgpos( &lgposShutDownMarkRec, &lgposMin ) );

					Assert( FSIGSignSet( &pdbfilehdr->signLog ) );
					pdbfilehdr->le_lgposConsistent = lgposShutDownMarkRec;
					pdbfilehdr->le_lgposDetach = lgposShutDownMarkRec;
					}

				LGIGetDateTime( &pdbfilehdr->logtimeConsistent );

				pdbfilehdr->logtimeDetach = pdbfilehdr->logtimeConsistent;

				Assert( pdbfilehdr->le_objidLast );
				ERR errT2 = JET_errSuccess;
				if ( !fGlobalRepair )
					{
					if ( pdbfilehdr->FSLVExists() )
						{
						errT2 = ErrSLVSyncHeader(	pfsapi,
													rgfmp[ifmp].FReadOnlyAttach(),
													rgfmp[ifmp].SzSLVName(),
													pdbfilehdr );
						}
					}
				if ( errT2 >= 0 )
					{
					errT2 = ErrUtilWriteShadowedHeader(
							pfsapi,
							pfmp->SzDatabaseName(),
							fTrue,
							(BYTE*)pdbfilehdr,
							g_cbPage );
					}
				if ( errT >= 0 && errT2 < 0 )
					{
					errT = errT2;
					}
				}
			}

		if ( pfmp->Pdbfilehdr() )
			{
			pfmp->FreePdbfilehdr();
			}

		// memory leak fix: if the backup was stoped (JetTerm with grbit JET_bitTermStopBackup)
		// the backup header may be still allocated
		if ( pfmp->Ppatchhdr() )
			{
			OSMemoryPageFree( pfmp->Ppatchhdr() );
			pfmp->SetPpatchhdr( NULL );
			}
		}

	if ( errT < 0 && err >= 0 )
		{
		err = errT;
		}

	//	no longer persist attachments
	Assert( !pinst->m_pbAttach );

	for ( dbid = dbidMin; dbid < dbidMax; dbid++ )
		{
		//	maintain the attach checker.
		IFMP ifmp = pinst->m_mpdbidifmp[ dbid ];
		if ( ifmp >= ifmpMax )
			continue;

		//	purge all the buffers

		BFPurge( ifmp );
		BFPurge( ifmp | ifmpSLV );

		FMP *pfmp = &rgfmp[ ifmp ];

		//	reset fmp fields

		pfmp->RwlDetaching().EnterAsWriter();

		DBResetFMP( pfmp, plog, fFalse );

		pfmp->ResetFlags();

		//	free the fmp entry

		if ( pfmp->SzDatabaseName() )
			{
			//	SLV name, if any, is allocated in same space as db name
			OSMemoryHeapFree( pfmp->SzDatabaseName() );
			pfmp->SetSzDatabaseName( NULL );
			pfmp->SetSzSLVName( NULL );
			pfmp->SetSzSLVRoot( NULL );
			}
		else
			{
			Assert( NULL == pfmp->SzSLVName() );
			}

		pfmp->Pinst()->m_mpdbidifmp[ pfmp->Dbid() ] = ifmpMax;
		pfmp->SetDbid( dbidMax );
		pfmp->SetPinst( NULL );
		pfmp->SetCPin( 0 );		// User may term without close the db
		pfmp->RwlDetaching().LeaveAsWriter();

		}

	return err;
	}


#ifdef ASYNC_DB_EXTENSION

LOCAL ERR ErrIODispatchAsyncExtension(
	const IFMP				ifmp,
	const QWORD				cbSize )
	{
	ERR						err;
	INST *					pinst			= PinstFromIfmp( ifmp );
	DBEXTENDTASK * const	ptaskDbExtend	= new DBEXTENDTASK( ifmp, cbSize );

	if( NULL == ptaskDbExtend )
		{
		//	release semaphore and err out
		//
		err = ErrERRCheck( JET_errOutOfMemory );
		}

	else if ( pinst->m_pver->m_fSyncronousTasks || rgfmp[ifmp].FDetachingDB() )
		{
		//	no longer dispatching tasks
		//
		delete ptaskDbExtend;
		err = JET_errSuccess;
		}

	else
		{
		err = pinst->Taskmgr().ErrTMPost( TASK::DispatchGP, ptaskDbExtend );
		if( err < JET_errSuccess )
			{
			//	the task was not enqueued sucessfully.
			//
			delete ptaskDbExtend;
			}
		}

	return err;
	}

#endif	//	ASYNC_DB_EXTENSION


ERR ErrIONewSize( IFMP ifmp, CPG cpg, const CPG cpgAsyncExtension )
	{
	ERR			err			= JET_errSuccess;
	FMP *		pfmp		= rgfmp + ifmp;

	//	set new EOF pointer
	//
	QWORD		cbSize		= OffsetOfPgno( cpg + 1 );

#ifdef DONT_ZERO_TEMP_DB
	const BOOL	fFastExt	= ( dbidTemp == pfmp->Dbid() );
#else
	const BOOL	fFastExt	= fFalse;
#endif

	pfmp->SemIOExtendDB().Acquire();

#ifdef ASYNC_DB_EXTENSION
	if ( cbSize <= pfmp->CbAsyncExtendedTrueFileSize() )
		{
		//	there is an async extent for us to consume, so just
		//	set database size in FMP -- this value should NOT
		//	include the reserved pages
		//
		pfmp->SetFileSize( QWORD( cpg ) * g_cbPage );
		Assert( pfmp->CbTrueFileSize() <= pfmp->CbAsyncExtendedTrueFileSize() );

		if ( cpgAsyncExtension > 0 )
			{
			const QWORD		cbAsyncExtension	= QWORD( cpgAsyncExtension ) << g_shfCbPage;
			const QWORD		cbAsyncTargetSize	= cbSize + cbAsyncExtension;

			if ( cbAsyncTargetSize > pfmp->CbAsyncExtendedTrueFileSize() )
				{
				//	now see if we can dispatch an async task to extend the db further
				//	for future requests
				//
				err = ErrIODispatchAsyncExtension( ifmp, cbAsyncTargetSize );
				}
			}
		}
	else
		{
		//	must synchronously extend db
		//
		cIODatabaseFileExtensionStall.Inc( PinstFromIfmp( ifmp ) );

		pfmp->SetCbAsyncExtendedTrueFileSize( 0 );

		//	no async extent, so must sync extend
		//
		err = pfmp->Pfapi()->ErrSetSize( cbSize, fFastExt );
		if ( JET_errSuccess == err )
			{
			//	set database size in FMP -- this value should NOT include the reserved pages
			//
			pfmp->SetFileSize( QWORD( cpg ) * g_cbPage );

			if ( cpgAsyncExtension > 0 )
				{
				const QWORD		cbAsyncExtension	= QWORD( cpgAsyncExtension ) << g_shfCbPage;
				const QWORD		cbAsyncTargetSize	= cbSize + cbAsyncExtension;

				//	now see if we can dispatch an async task to extend the db further
				//	for future requests
				//
				err = ErrIODispatchAsyncExtension( ifmp, cbAsyncTargetSize );
				}
			}
		else
			{
			Assert( err < JET_errSuccess );
			}
		}

#else
	//	must synchronously extend db
	//
	cIODatabaseFileExtensionStall.Inc( PinstFromIfmp( ifmp ) );

	err = pfmp->Pfapi()->ErrSetSize( cbSize );
	if ( JET_errSuccess == err )
		{
		//	set database size in FMP -- this value should NOT include the reserved pages
		//
		pfmp->SetFileSize( QWORD( cpg ) * g_cbPage );
		}
	else
		{
		Assert( err < JET_errSuccess );		//	warnings not expected
		}
#endif	//	ASYNC_DB_EXTENSION

	pfmp->SemIOExtendDB().Release();

	return err;
	}


/*
 *  opens database file, returns JET_errSuccess if file is already open
 */
ERR ErrIOOpenDatabase( IFileSystemAPI *const pfsapi, IFMP ifmp, CHAR *szDatabaseName )
	{
	FMP::AssertVALIDIFMP( ifmp );

	if ( FIODatabaseOpen( ifmp ) )
		{
		return JET_errSuccess;
		}

	ERR				err;
	IFileAPI	*pfapi;
	FMP				*pfmp 		= &rgfmp[ ifmp ];
	BOOL	fReadOnly	= pfmp->FReadOnlyAttach();
	CallR( pfsapi->ErrFileOpen( szDatabaseName, &pfapi, fReadOnly ) );

	QWORD cbSize;
	// just opened the file, so the file size must be correctly buffered
	Call( pfapi->ErrSize( &cbSize ) );

	pfmp->SetPfapi( pfapi );
	pfmp->SetFileSize( cbSize - cpgDBReserved * g_cbPage );

	return err;

HandleError:
	delete pfapi;
	return err;
	}


VOID IOCloseDatabase( IFMP ifmp )
	{
	FMP::AssertVALIDIFMP( ifmp );
	FMP *pfmp = &rgfmp[ ifmp ];

	if ( pfmp->FSLVAttached() )
		{
		SLVClose( ifmp );
		}

//	Assert( PinstFromIfmp( ifmp )->m_plog->m_fRecovering || FDBIDWriteLatch(ifmp) == fTrue );
	Assert( pfmp->Pfapi() );

	delete pfmp->Pfapi();
	pfmp->SetPfapi( NULL );
	}


ERR ErrIODeleteDatabase( IFileSystemAPI *const pfsapi, IFMP ifmp )
	{
	ERR err;

	FMP::AssertVALIDIFMP( ifmp );
//	Assert( FDBIDWriteLatch(ifmp) == fTrue );

	CallR( pfsapi->ErrFileDelete( rgfmp[ ifmp ].SzDatabaseName() ) );
	return JET_errSuccess;
	}


/*
the function return an inside allocated array of structures.
It will be one structure for each runnign instance.
For each isstance it will exist information about instance name and attached databases

We compute in advence the needed memory for all the returned data: array, databases and names
so that everythink is alocated in one chunk and can be freed with JetFreeBuffer()
*/

ERR ISAMAPI ErrIsamGetInstanceInfo(
	unsigned long *			pcInstanceInfo,
	JET_INSTANCE_INFO **	paInstanceInfo,
	const BOOL				fSnapshot )
	{
	Assert( pcInstanceInfo && paInstanceInfo);

	if ( NULL == pcInstanceInfo || NULL == paInstanceInfo )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	// protected by critInst
	CHAR*		pMemoryBuffer 		= NULL;
	CHAR*		pCurrentPosArrays	= NULL;
	CHAR*		pCurrentPosNames	= NULL;
	SIZE_T		cbMemoryBuffer	 	= 0;

	JET_ERR		err 				= JET_errSuccess;

	ULONG		cInstances		 	= 0;
	ULONG		cDatabasesTotal	 	= 0;
	SIZE_T		cbNamesSize		 	= 0;

	ULONG		ipinst			 	= 0;
	IFMP		ifmp			 	= ifmpMax;

	// during snapshot, we already own those critical sections
	// in the snapshot thread
	if ( !fSnapshot )
		{
		INST::EnterCritInst();
		FMP::EnterCritFMPPool();
		}

	if ( 0 == ipinstMac )
		{
		*pcInstanceInfo = 0;
		*paInstanceInfo = NULL;
		goto HandleError;
		}

	// we count the number of instances, of databases
	// and of characters to be used by all names
	for ( ipinst = 0; ipinst < ipinstMax; ipinst++ )
		{
		INST * 	pinst = g_rgpinst[ ipinst ];
		if ( pinstNil == pinst )
			continue;

		if ( NULL != pinst->m_szInstanceName )
			{
			cbNamesSize += strlen( pinst->m_szInstanceName ) + 1;
			}
		cInstances++;
		}
	Assert( cInstances == ipinstMac );

	for ( ifmp = FMP::IfmpMinInUse(); ifmp <= FMP::IfmpMacInUse(); ifmp++ )
		{
		FMP * 	pfmp = &rgfmp[ ifmp ];
		if ( !pfmp->FInUse() )
			continue;

		if ( !pfmp->FLogOn() || !pfmp->FAttached() )
			continue;

		Assert( !pfmp->FSkippedAttach() );
		Assert( !pfmp->FDeferredAttach() );

		cbNamesSize += strlen(pfmp->SzDatabaseName()) + 1;
		if ( NULL != pfmp->SzSLVName() )
			{
			cbNamesSize += strlen(pfmp->SzSLVName()) + 1;
			}
		cDatabasesTotal++;
		}

	// we allocate memory for the result in one chunck
	cbMemoryBuffer = 0;
	// memory for the array of structures
	cbMemoryBuffer += cInstances * sizeof(JET_INSTANCE_INFO);
	// memory for pointers to database names (file name, display name, slv file name)
	cbMemoryBuffer += 3 * cDatabasesTotal * sizeof(CHAR *);
	// memory for all names (database names and instance names)
	cbMemoryBuffer += cbNamesSize * sizeof(CHAR);

	pMemoryBuffer = (char *) PvOSMemoryHeapAlloc ( cbMemoryBuffer );
	if ( NULL == pMemoryBuffer )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		goto HandleError;
		}

	memset( pMemoryBuffer, '\0', cbMemoryBuffer );

	*pcInstanceInfo = cInstances;
	*paInstanceInfo = (JET_INSTANCE_INFO *)pMemoryBuffer;

	pCurrentPosArrays = pMemoryBuffer + ( cInstances * sizeof(JET_INSTANCE_INFO) );
	Assert( pMemoryBuffer + cbMemoryBuffer >= pCurrentPosArrays );

	pCurrentPosNames = pCurrentPosArrays + ( 3 * cDatabasesTotal * sizeof(CHAR *) );

	for ( ipinst = 0, cInstances = 0; ipinst < ipinstMax; ipinst++ )
		{
		INST * 				pinst				= g_rgpinst[ ipinst ];
		JET_INSTANCE_INFO *	pInstInfo			= &(*paInstanceInfo)[cInstances];
		ULONG				cDatabasesCurrInst;
		DBID 				dbid;

		if ( pinstNil == pinst )
			continue;

		pInstInfo->hInstanceId = (JET_INSTANCE) pinst;
		Assert( NULL == pInstInfo->szInstanceName );
		if ( NULL != pinst->m_szInstanceName )
			{
			strcpy( pCurrentPosNames, pinst->m_szInstanceName );
			pInstInfo->szInstanceName = pCurrentPosNames;
			pCurrentPosNames += strlen( pCurrentPosNames ) + 1;
			Assert( pMemoryBuffer + cbMemoryBuffer >= pCurrentPosNames );
			}

		cDatabasesCurrInst = 0;
		for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
			{
			if ( pinst->m_mpdbidifmp[ dbid ] >= ifmpMax )
				continue;

			const FMP * const	pfmp	= &rgfmp[pinst->m_mpdbidifmp[ dbid ] ];
			Assert( pfmp );
			Assert( pfmp->FInUse() );
			Assert( 0 < strlen ( pfmp->SzDatabaseName() ) );

			if ( !pfmp->FLogOn() || !pfmp->FAttached() )
				continue;

			Assert( !pfmp->FSkippedAttach() );
			Assert( !pfmp->FDeferredAttach() );

			cDatabasesCurrInst++;
			}

		pInstInfo->cDatabases = cDatabasesCurrInst;
		Assert( NULL == pInstInfo->szDatabaseFileName);
		Assert( NULL == pInstInfo->szDatabaseDisplayName);
		Assert( NULL == pInstInfo->szDatabaseSLVFileName);

		if ( 0 != pInstInfo->cDatabases )
			{
			pInstInfo->szDatabaseFileName = (CHAR **)pCurrentPosArrays;
			pCurrentPosArrays += pInstInfo->cDatabases * sizeof(CHAR *);
			Assert( pMemoryBuffer + cbMemoryBuffer >= pCurrentPosArrays );

			pInstInfo->szDatabaseDisplayName = (CHAR **)pCurrentPosArrays;
			pCurrentPosArrays += pInstInfo->cDatabases * sizeof(CHAR *);
			Assert( pMemoryBuffer + cbMemoryBuffer >= pCurrentPosArrays );

			pInstInfo->szDatabaseSLVFileName = (CHAR **)pCurrentPosArrays;
			pCurrentPosArrays += pInstInfo->cDatabases * sizeof(CHAR *);
			Assert( pMemoryBuffer + cbMemoryBuffer >= pCurrentPosArrays );
			}

		cDatabasesCurrInst = 0;
		for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
			{
			if ( pinst->m_mpdbidifmp[ dbid ] >= ifmpMax )
				continue;

			const FMP * const	pfmp	= &rgfmp[pinst->m_mpdbidifmp[ dbid ] ];
			Assert( pfmp );
			Assert( pfmp->FInUse() );
			Assert( 0 < strlen ( pfmp->SzDatabaseName() ) );

			if ( !pfmp->FLogOn() || !pfmp->FAttached() )
				continue;

			Assert( !pfmp->FSkippedAttach() );
			Assert( !pfmp->FDeferredAttach() );

			Assert( NULL == pInstInfo->szDatabaseFileName[cDatabasesCurrInst] );
			strcpy( pCurrentPosNames, pfmp->SzDatabaseName() );
			pInstInfo->szDatabaseFileName[cDatabasesCurrInst] = pCurrentPosNames;
			pCurrentPosNames += strlen( pCurrentPosNames ) + 1;
			Assert( pMemoryBuffer + cbMemoryBuffer >= pCurrentPosNames );

			Assert( NULL == pInstInfo->szDatabaseSLVFileName[cDatabasesCurrInst] );
			if ( NULL != pfmp->SzSLVName() )
				{
				strcpy( pCurrentPosNames, pfmp->SzSLVName() );
				pInstInfo->szDatabaseSLVFileName[cDatabasesCurrInst] = pCurrentPosNames;
				pCurrentPosNames += strlen( pCurrentPosNames ) + 1;
				Assert( pMemoryBuffer + cbMemoryBuffer >= pCurrentPosNames );
				}

			//	currently unused
			pInstInfo->szDatabaseDisplayName[cDatabasesCurrInst] = NULL;

			cDatabasesCurrInst++;
			}
		Assert( pInstInfo->cDatabases == cDatabasesCurrInst );

		cInstances++;
		}

	Assert( cInstances == *pcInstanceInfo );
	Assert( pMemoryBuffer
				+ ( cInstances * sizeof(JET_INSTANCE_INFO) )
				+ ( 3 * cDatabasesTotal * sizeof(CHAR *) )
			== pCurrentPosArrays );
	Assert( pMemoryBuffer + cbMemoryBuffer == pCurrentPosNames );

HandleError:

	if ( !fSnapshot )
		{
		FMP::LeaveCritFMPPool();
		INST::LeaveCritInst();
		}

	if ( err < JET_errSuccess )
		{
		*pcInstanceInfo = 0;
		*paInstanceInfo = NULL;

		if ( NULL != pMemoryBuffer )
			{
	 		OSMemoryHeapFree( pMemoryBuffer );
			}
		}

	return err;
	}

//  ================================================================
void INST::WaitForDBAttachDetach( )
//  ================================================================
	{
	BOOL fDetachAttach = fTrue;

	// we check this only during backup
	Assert ( m_plog->m_fBackupInProgress );

	while ( fDetachAttach )
		{
		fDetachAttach = fFalse;
		for ( DBID dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
			{
			IFMP ifmp = m_mpdbidifmp[ dbid ];
			if ( ifmp >= ifmpMax )
				continue;

			if ( ( fDetachAttach = rgfmp[ifmp].CrefWriteLatch() != 0 ) != fFalse )
				break;
			}

		if ( fDetachAttach )
			{
			UtilSleep( cmsecWaitGeneric );
			}
		}
	}

#ifdef OS_SNAPSHOT

//#define OS_SNAPSHOT_TRACE


// Class describing the status of a snapshot operation
class CESESnapshotSession
	{
// Constructors and destructors
public:
	CESESnapshotSession():
		m_state( stateStart ),
		m_thread( 0 ),
		m_errFreeze ( JET_errSuccess ),
		m_asigSnapshotThread( CSyncBasicInfo( _T( "asigSnapshotThread" ) ) ),
		m_asigSnapshotStarted( CSyncBasicInfo( _T( "asigSnapshotStarted" ) ) )
		{ }

	typedef enum { stateStart, statePrepare, stateFreeze, stateEnd, stateTimeOut } SNAPSHOT_STATE;

public:
	BOOL	FCanSwitchTo( const SNAPSHOT_STATE stateNew ) const ;
	SNAPSHOT_STATE	State( ) const { return m_state; }
	BOOL	FFreeze( ) const { return stateFreeze == m_state; }
	BOOL	FCheckId( const JET_OSSNAPID snapId )	const;

	JET_OSSNAPID	GetId( );
	void	SwitchTo( const SNAPSHOT_STATE stateNew );

	// start the snapshot thread
	ERR 	ErrStartSnapshotThreadProc( );

	// signal the thread to stop
	void 	StopSnapshotThreadProc( const BOOL fWait = fFalse );

	// snapshot thread: the only that moves the state to Ended or TimeOut
	void 	SnapshotThreadProc( const ULONG ulTimeOut );

private:
	ERR 	ErrFreeze();
	void 	Thaw();

	// freeze/thaw operations on ALL instances
	ERR 	ErrFreezeInstance();
	void 	ThawInstance(const BOOL fFullStop = fTrue, const int ipinstLast = ipinstMax );


	// freeze/thaw operations on ALL databases
	ERR 	ErrFreezeDatabase();
	void 	ThawDatabase( const IFMP ifmpLast = ifmpMax );

private:
	SNAPSHOT_STATE 		m_state;		// state of the snapshot session
	THREAD 				m_thread;
	ERR 				m_errFreeze;	// error at freeze start-up

	CAutoResetSignal	m_asigSnapshotThread;
	CAutoResetSignal	m_asigSnapshotStarted;

// static members
public:
	void 	SnapshotCritEnter() { CESESnapshotSession::m_critOSSnapshot.Enter(); }
	void 	SnapshotCritLeave() { CESESnapshotSession::m_critOSSnapshot.Leave(); }

	ULONG	GetTimeout() const;
	void 	SetTimeout( const ULONG ulTimeOut ) ;

private:
	//  critical section protecting all OS level snapshot information
	static CCriticalSection m_critOSSnapshot;

	// counter used to keep a global identifer of the snapshots
	static unsigned int m_idSnapshot;

	// timeout for the freeze in ms
	static ULONG m_ulTimeOut;

	};

CCriticalSection CESESnapshotSession::m_critOSSnapshot( CLockBasicInfo( CSyncBasicInfo( "OSSnapshot" ), rankOSSnapshot, 0 ) );
unsigned int CESESnapshotSession::m_idSnapshot = 0;
ULONG CESESnapshotSession::m_ulTimeOut = 20 * 1000; // default is 20 ms


// At this moment the implementation will allow one snapshot
// session at a time. This is the global object describing the
// snapshot session status
CESESnapshotSession g_SnapshotSession;

BOOL CESESnapshotSession::FCheckId( const JET_OSSNAPID snapId )	const
	{
	return ( snapId == (JET_OSSNAPID)m_idSnapshot );
	}

JET_OSSNAPID CESESnapshotSession::GetId( )
	{
	Assert ( m_critOSSnapshot.FOwner() );
	m_idSnapshot++;
	return (JET_OSSNAPID)m_idSnapshot;
	}

void CESESnapshotSession::SetTimeout( const ULONG ulTimeOut )
	{
	Assert ( m_critOSSnapshot.FOwner() );
	CESESnapshotSession::m_ulTimeOut = ulTimeOut;
	}

ULONG CESESnapshotSession::GetTimeout() const
	{
	return CESESnapshotSession::m_ulTimeOut;
	}

ERR CESESnapshotSession::ErrFreezeInstance( )
	{
	int 	ipinst 	= 0;
	ERR 	err 	= JET_errSuccess;

	INST::EnterCritInst();

	for ( ipinst = 0; ipinst < ipinstMax; ipinst++ )
		{
		if ( pinstNil == g_rgpinst[ ipinst ] )
			{
			continue;
			}

		LOG * pLog;
		pLog = g_rgpinst[ ipinst ]->m_plog;
		Assert ( pLog );

		pLog->m_critLGFlush.Enter(); // protect the recovery flag
		pLog->m_critBackupInProgress.Enter();

		if ( pLog->m_fBackupInProgress || pLog->m_fRecovering )
			{
			pLog->m_critBackupInProgress.Leave();
			pLog->m_critLGFlush.Leave();
			Call ( ErrERRCheck( JET_errOSSnapshotNotAllowed ) );
			}

		pLog->m_fStopBackup = fFalse;
		pLog->m_fBackupInProgress = fTrue;

		// marked as during backup: will prevent attach/detach
		pLog->m_critBackupInProgress.Leave();

		// leave LGFlush to allow attach/detach in progress to complete
		pLog->m_critLGFlush.Leave();

		while ( g_rgpinst[ ipinst ]->CNonLoggedIndexCreators() > 0 )
			{
			//	wait for non-logged index creators
			//	to begin logging again
			//
			UtilSleep( cmsecWaitGeneric );
			}

		g_rgpinst[ ipinst ]->WaitForDBAttachDetach();
		}


	// all set, now stop log flushing
	// then stop checkpoint (including db headers update)
	for ( ipinst = 0; ipinst < ipinstMax; ipinst++ )
		{
		if ( pinstNil == g_rgpinst[ ipinst ] )
			{
			continue;
			}

		Assert ( g_rgpinst[ ipinst ]->m_plog );
		g_rgpinst[ ipinst ]->m_plog->m_critLGFlush.Enter();
		}

	// UNDONE: consider not entering m_critCheckpoint and
	// keeping it during the snapshot (this will prevent
	// db header and checkpoint update) but instead
	// enter() set m_fLogDisable leavr()
	// and reset the same way on Thaw
	for ( ipinst = 0; ipinst < ipinstMax; ipinst++ )
		{
		if ( pinstNil == g_rgpinst[ ipinst ] )
			{
			continue;
			}

		Assert ( g_rgpinst[ ipinst ]->m_plog );
		g_rgpinst[ ipinst ]->m_plog->m_critCheckpoint.Enter();
		}
		
	CallS( err );
	
HandleError:
	if ( err < JET_errSuccess )
		{
		ThawInstance( fFalse, ipinst );
		}
	return err;
	}

void CESESnapshotSession::ThawInstance( const BOOL fFullStop, const int ipinstLast )
	{
	int ipinst;

	// if Thaw all, we have to leave LGFlush, critCheckpoint
	if ( fFullStop )
		{
		for ( ipinst = 0; ipinst < ipinstMax; ipinst++ )
			{
			if ( pinstNil == g_rgpinst[ ipinst ] )
				{
				continue;
				}

			Assert ( g_rgpinst[ ipinst ]->m_plog );
			g_rgpinst[ ipinst ]->m_plog->m_critCheckpoint.Leave();
			}

		for ( ipinst = 0; ipinst < ipinstMax; ipinst++ )
			{
			if ( pinstNil == g_rgpinst[ ipinst ] )
				{
				continue;
				}

			Assert ( g_rgpinst[ ipinst ]->m_plog );
			g_rgpinst[ ipinst ]->m_plog->m_critLGFlush.Leave();
			}
		}

	for ( ipinst = 0; ipinst < ipinstLast; ipinst++ )
		{
		if ( pinstNil == g_rgpinst[ ipinst ] )
			{
			continue;
			}

		LOG * pLog;
		pLog = g_rgpinst[ ipinst ]->m_plog;
		Assert ( pLog );

		pLog->m_critBackupInProgress.Enter();
		Assert ( pLog->m_fBackupInProgress );
		pLog->m_fBackupInProgress = fFalse;
		pLog->m_fStopBackup = fFalse;
		pLog->m_critBackupInProgress.Leave();
		}

	INST::LeaveCritInst();

	}

ERR CESESnapshotSession::ErrFreezeDatabase( )
	{
	ERR 	err 		= JET_errSuccess;
	IFMP 	ifmp 		= 0;

	// not needed as the already have all instances set "during backup"
	// which will prevent new attach/detach and we have waited for
	// all attache/detach in progress
//	FMP::EnterCritFMPPool();

	for ( ifmp = FMP::IfmpMinInUse(); ifmp <= FMP::IfmpMacInUse(); ifmp++ )
		{
		FMP	* pfmp = &rgfmp[ ifmp ];

		if ( !pfmp->FInUse() )
			{
			continue;
			}

		if ( dbidTemp == pfmp->Dbid() )
			{
			continue;
			}

		Assert ( pfmp->Dbid() >= dbidUserLeast );
		Assert ( pfmp->Dbid() < dbidMax );

		Assert ( PinstFromIfmp(ifmp)->m_plog->m_fBackupInProgress );
		Assert ( pfmp->FAttached() );

		// prevent database size changes
		pfmp->SemIOExtendDB().Acquire();
		}

	for ( ifmp = FMP::IfmpMinInUse(); ifmp <= FMP::IfmpMacInUse(); ifmp++ )
		{
		FMP	* pfmp = &rgfmp[ ifmp ];

		if ( !pfmp->FInUse() )
			{
			continue;
			}

		if ( dbidTemp == pfmp->Dbid() )
			{
			continue;
			}

		Assert ( pfmp->Dbid() >= dbidUserLeast );
		Assert ( pfmp->Dbid() < dbidMax );

		// use PgnoLast() as we have ExtendingDBLatch
		// so that the database can't change size
		Call( pfmp->ErrRangeLock( 0, pfmp->PgnoLast() ) );
		}

	CallS( err );

HandleError:

	if ( err < JET_errSuccess )
		{
		ThawDatabase( ifmp );
		}

	return err;
	}

void CESESnapshotSession::ThawDatabase( const IFMP ifmpLast )
	{
	const IFMP	ifmpRealLast	= ( ifmpLast < ifmpMax ? ifmpLast : FMP::IfmpMacInUse() + 1 );

	for ( IFMP ifmp = FMP::IfmpMinInUse(); ifmp < ifmpRealLast; ifmp++ )
		{
		FMP	* pfmp = &rgfmp[ ifmp ];

		if ( !pfmp->FInUse() )
			{
			continue;
			}

		if ( dbidTemp == pfmp->Dbid() )
			{
			continue;
			}

		Assert ( pfmp->Dbid() >= dbidUserLeast );
		Assert ( pfmp->Dbid() < dbidMax );

		Assert ( PinstFromIfmp(ifmp)->m_plog->m_fBackupInProgress );
		Assert ( pfmp->FAttached() );

		pfmp->RangeUnlock( 0, pfmp->PgnoLast() );
		}

	for ( ifmp = FMP::IfmpMinInUse(); ifmp <= FMP::IfmpMacInUse(); ifmp++ )
		{
		FMP	* pfmp = &rgfmp[ ifmp ];

		if ( !pfmp->FInUse() )
			{
			continue;
			}

		if ( dbidTemp == pfmp->Dbid() )
			{
			continue;
			}

		Assert ( pfmp->Dbid() >= dbidUserLeast );
		Assert ( pfmp->Dbid() < dbidMax );

		pfmp->SemIOExtendDB().Release();
		}

//	FMP::LeaveCritFMPPool();
	}

ERR CESESnapshotSession::ErrFreeze( )
	{
	ERR err = JET_errSuccess;

	CallR ( ErrFreezeInstance() );

	Call ( ErrFreezeDatabase() );

	CallS( err );

HandleError:

	if ( err < JET_errSuccess )
		{
		ThawInstance();
		}

	return err;
	}

void CESESnapshotSession::Thaw( )
	{
	ThawDatabase();
	ThawInstance();
	}

void CESESnapshotSession::SnapshotThreadProc( const ULONG ulTimeOut )
	{

	CHAR szSnap[12];
	CHAR szError[12];
	const _TCHAR* rgszT[2] = { szSnap, szError };

	sprintf( szSnap, "%lu", m_idSnapshot );

	UtilReportEvent( eventInformation, OS_SNAPSHOT_BACKUP, OS_SNAPSHOT_FREEZE_START_ID, 1, rgszT );

	m_errFreeze = ErrFreeze();

	if ( JET_errSuccess > m_errFreeze )
		{
		UtilThreadEnd( m_thread );
		m_thread = 0;

		// signal the starting thread that snapshot couldn't start
		m_asigSnapshotStarted.Set();

		sprintf( szError, "%d", m_errFreeze );
		UtilReportEvent( eventError, OS_SNAPSHOT_BACKUP, OS_SNAPSHOT_FREEZE_START_ERROR_ID, 2, rgszT );
		return;
		}

	// signal the starting thread that snapshot did started
	// so that the Freeze API returns
	m_asigSnapshotStarted.Set();


	BOOL fTimeOut = !m_asigSnapshotThread.FWait( ulTimeOut );
	SNAPSHOT_STATE newState = fTimeOut?stateTimeOut:stateEnd;

	Thaw();

	SnapshotCritEnter();
	Assert ( stateFreeze == State() );
	Assert ( FCanSwitchTo( newState ) );
	SwitchTo ( newState );

	// on time-out, we need to close the thread handle
	if ( fTimeOut )
		{
		UtilThreadEnd( m_thread );
		m_thread = 0;

#ifdef OS_SNAPSHOT_TRACE
		{
		CHAR szError[12];
		const _TCHAR* rgszT[2] = { "thread SnapshotThreadProc", szError };
		_itoa( JET_errOSSnapshotTimeOut, szError, 10 );

		UtilReportEvent( eventError, OS_SNAPSHOT_BACKUP, OS_SNAPSHOT_TRACE_ID, 2, rgszT );
		}
#endif // OS_SNAPSHOT_TRACE
		}
	SnapshotCritLeave();

	if ( fTimeOut )
		{
		sprintf( szError, "%lu", ulTimeOut );
		UtilReportEvent( eventError, OS_SNAPSHOT_BACKUP, OS_SNAPSHOT_TIME_OUT_ID, 2, rgszT );
		}
	else
		{
		UtilReportEvent( eventInformation, OS_SNAPSHOT_BACKUP, OS_SNAPSHOT_FREEZE_STOP_ID, 1, rgszT );
		}
	}

DWORD DwSnapshotThreadProc( DWORD_PTR lpParameter )
	{
	CESESnapshotSession * pSession = (CESESnapshotSession *)lpParameter;
	Assert ( pSession == &g_SnapshotSession );

	pSession->SnapshotThreadProc( pSession->GetTimeout() );

	return 0;
	}

ERR CESESnapshotSession::ErrStartSnapshotThreadProc( )
	{
	ERR err = JET_errSuccess;

	Assert ( CESESnapshotSession::m_critOSSnapshot.FOwner() );
	Assert ( statePrepare == State() );

	m_asigSnapshotStarted.Reset();
	Call ( ErrUtilThreadCreate(	DwSnapshotThreadProc,
								OSMemoryPageReserveGranularity(),
								priorityNormal,
								&m_thread,
								DWORD_PTR( this ) ) );

	// wait until snapshot thread is starting
	m_asigSnapshotStarted.Wait();

	// freeze start failed
	if (  m_errFreeze < JET_errSuccess )
		{
		// thread is gone
		Assert ( 0 == m_thread);
		Call ( m_errFreeze );
		Assert ( fFalse );
		}

	SwitchTo( CESESnapshotSession::stateFreeze );

	CallS( err );
	
HandleError:
	// QUESTION: on error, return in Start or leave it in Prepare ?
	if ( err < JET_errSuccess )
		{
		// don't FCanSwitchTo which is not allowed
		SwitchTo( CESESnapshotSession::stateStart );
		}

	return err;
	}


void CESESnapshotSession::StopSnapshotThreadProc( const BOOL fWait )
	{
	m_asigSnapshotThread.Set();

	if ( fWait )
		{
		(void) UtilThreadEnd( m_thread );
		m_thread = 0;
		}

	return;
	}


BOOL CESESnapshotSession::FCanSwitchTo( const SNAPSHOT_STATE stateNew ) const
	{
	Assert ( CESESnapshotSession::m_critOSSnapshot.FOwner() );

	switch ( stateNew )
		{
		case stateStart:
			if ( m_state != stateEnd && 	// normal Thaw
				m_state != stateTimeOut )	// time-out end
				{
				return fFalse;
				}
			break;

		case statePrepare:
			if ( m_state != stateStart && 	// normal start
				m_state != stateTimeOut && 	// re-start after a time-out without Thaw call
				m_state != statePrepare ) 	// we can get a prepare, then nothing else (coordinator died), then restarts
				{
				return fFalse;
				}
			break;

		case stateFreeze:
			if ( m_state != statePrepare )	// just after prepare
				{
				return fFalse;
				}
			break;

		case stateEnd:
			if ( m_state != stateFreeze )		// normal end
				{
				return fFalse;
				}
			break;

		case stateTimeOut:
			if ( m_state != stateFreeze )	// timeout only from the freeze state
				{
				return fFalse;
				}
			break;

		default:
			Assert ( fFalse );
			return fFalse;
		}

	return fTrue;
	}

void CESESnapshotSession::SwitchTo( const SNAPSHOT_STATE stateNew )
	{
	Assert ( CESESnapshotSession::m_critOSSnapshot.FOwner() );
	m_state = stateNew;

	// do special action depending on the new state
	switch ( m_state )
		{
		case stateStart:
		case statePrepare:
			m_asigSnapshotThread.Reset();
			break;
		default:
			break;
		}

	}

ERR ISAMAPI ErrIsamOSSnapshotPrepare( JET_OSSNAPID * psnapId, const JET_GRBIT	grbit )
	{
	ERR 					err 		= JET_errSuccess;
	CESESnapshotSession * 	pSession 	= &g_SnapshotSession;

	if ( !psnapId )
		{
		CallR ( ErrERRCheck( JET_errInvalidParameter ) );
		}
	pSession->SnapshotCritEnter();

	if ( !pSession->FCanSwitchTo( CESESnapshotSession::statePrepare ) )
		{
		pSession->SnapshotCritLeave();
		Call ( ErrERRCheck( JET_errOSSnapshotInvalidSequence ) );
		}

	pSession->SwitchTo( CESESnapshotSession::statePrepare );
	*psnapId = pSession->GetId( );

	pSession->SnapshotCritLeave();

	CallS( err );
	
HandleError:
#ifdef OS_SNAPSHOT_TRACE
	{
	CHAR szError[12];
	const _TCHAR* rgszT[2] = { "JetOSSnapshotPrepare", szError };
	_itoa( err, szError, 10 );
	
	UtilReportEvent(
			( err < JET_errSuccess ? eventError : eventInformation ),
			OS_SNAPSHOT_BACKUP,
			OS_SNAPSHOT_TRACE_ID,
			2,
			rgszT );
	}
#endif // OS_SNAPSHOT_TRACE
	return err;
	}

ERR ISAMAPI ErrIsamOSSnapshotFreeze( const JET_OSSNAPID snapId, unsigned long *pcInstanceInfo, JET_INSTANCE_INFO ** paInstanceInfo, const	JET_GRBIT grbit )
	{
	CESESnapshotSession * 	pSession 		= &g_SnapshotSession;
	ERR 					err 			= JET_errSuccess;

	if ( NULL == pcInstanceInfo || NULL == paInstanceInfo )
		{
		CallR ( ErrERRCheck(JET_errInvalidParameter ) );
		}
	*pcInstanceInfo = 0;
	*paInstanceInfo = NULL;

	pSession->SnapshotCritEnter();

	// we allow Freeze/Thaw calls (without error) if we missed the Prepare
	// because we were not registered when snapshot started moment)
	if ( CESESnapshotSession::stateStart == pSession->State() )
		{
		CallS( err );
		goto HandleError;
		}

	if ( !pSession->FCanSwitchTo( CESESnapshotSession::stateFreeze ) )
		{
		Call ( ErrERRCheck( JET_errOSSnapshotInvalidSequence ) );
		}

	AssertRTL( pSession->FCheckId( snapId ) );

	Call ( pSession->ErrStartSnapshotThreadProc() );

	Assert ( CESESnapshotSession::stateFreeze == pSession->State() );
	CallS( err );

	err = ErrIsamGetInstanceInfo( pcInstanceInfo, paInstanceInfo, fTrue /* in snapshot */);
	if ( err < JET_errSuccess )
		{
		// need to thaw as we got an error at this point
		pSession->SnapshotCritLeave();		
		CallS( ErrIsamOSSnapshotThaw( snapId, grbit ) );
		pSession->SnapshotCritEnter();
		}
		
	Call( err );
	CallS( err );
	
HandleError:		
	pSession->SnapshotCritLeave();

#ifdef OS_SNAPSHOT_TRACE
	{
	CHAR szError[12];
	const _TCHAR* rgszT[2] = { "JetOSSnapshotFreeze", szError };
	_itoa( err, szError, 10 );
	
	UtilReportEvent(
			( err < JET_errSuccess ? eventError : eventInformation ),
			OS_SNAPSHOT_BACKUP,
			OS_SNAPSHOT_TRACE_ID,
			2,
			rgszT );
	}
#endif // OS_SNAPSHOT_TRACE

	return err;
	}

ERR ErrOSSnapshotThaw_(	const JET_OSSNAPID snapId, const BOOL fAbort )
	{
	CESESnapshotSession * 	pSession 	= &g_SnapshotSession;
	ERR 					err 		= JET_errSuccess;

	pSession->SnapshotCritEnter();

	switch ( pSession->State() )
		{
		case CESESnapshotSession::stateFreeze:		//	normal end from freeze
		case CESESnapshotSession::stateTimeOut:		//	we already got the time-out
			AssertRTL( pSession->FCheckId( snapId ) );
			break;

		case CESESnapshotSession::stateStart:
			// we allow Freeze/Thaw calls (without error) if we missed the Prepare
			// because we were not registered when snapshot started moment)
			CallS( err );
			goto HandleError;

		case CESESnapshotSession::statePrepare:
			if ( fAbort )
				{
				//	freeze not yet initiated, so we can just transition
				//	back to the Start state
				AssertRTL( pSession->FCheckId( snapId ) );
				pSession->SwitchTo( CESESnapshotSession::stateStart );
				CallS( err );
				goto HandleError;
				}
			else
				{
				//	FALL THROUGH and report usage error
				}

		case CESESnapshotSession::stateEnd:		//	should be impossible, because we haven't signaled the thread
		default:
			Assert( fFalse );
			Call( ErrERRCheck( JET_errOSSnapshotInvalidSequence ) );
			break;

		}

	// the state can't be End as long as we haven't signaled the thread
	Assert ( CESESnapshotSession::stateFreeze == pSession->State() ||
			CESESnapshotSession::stateTimeOut == pSession->State() );

	forever
		{
		Assert ( CESESnapshotSession::stateFreeze == pSession->State() || 
				CESESnapshotSession::stateEnd == pSession->State() ||
				CESESnapshotSession::stateTimeOut == pSession->State() );

		if ( CESESnapshotSession::stateEnd == pSession->State() )
			{
			CallS( err );
			break;
			}
		else if ( CESESnapshotSession::stateTimeOut == pSession->State() )
			{
			if ( fAbort )
				{
				CallS( err );
				}
			else
				{
				err = ErrERRCheck( JET_errOSSnapshotTimeOut );
				}
			break;
			}
		else
			{
			// thread is signaled but not ended yet ... 
			Assert ( CESESnapshotSession::stateFreeze == pSession->State() ); 	

			// let the thread change the status and wait for its completion
			pSession->SnapshotCritLeave();

			// signal thread to stop and wait thread complition
			pSession->StopSnapshotThreadProc( fTrue /* wait thread completion */ );

			// re-enter critical section and retry
			pSession->SnapshotCritEnter();
			}
		}

	Assert ( pSession->FCanSwitchTo( CESESnapshotSession::stateStart ) );
	pSession->SwitchTo( CESESnapshotSession::stateStart );

HandleError:
	pSession->SnapshotCritLeave();

#ifdef OS_SNAPSHOT_TRACE
	{
	CHAR szError[12];
	const _TCHAR* rgszT[2] = { ( fAbort ? "JetOSSnapshotAbort" : "JetOSSnapshotThaw" ), szError };
	_itoa( err, szError, 10 );
	
	UtilReportEvent(
			( err < JET_errSuccess ? eventError : eventInformation ),
			OS_SNAPSHOT_BACKUP,
			OS_SNAPSHOT_TRACE_ID,
			2,
			rgszT );
	}
#endif // OS_SNAPSHOT_TRACE

	return err;
	}

ERR ISAMAPI ErrIsamOSSnapshotThaw( const JET_OSSNAPID snapId, const JET_GRBIT grbit )
	{
	return ErrOSSnapshotThaw_( snapId, fFalse );
	}

ERR ISAMAPI ErrIsamOSSnapshotAbort( const JET_OSSNAPID snapId, const JET_GRBIT grbit )
	{
	return ErrOSSnapshotThaw_( snapId, fTrue );
	}

// functions to set the timeout using JetSetSystemParam with JET_paramOSSnapshotTimeout
ERR ErrOSSnapshotSetTimeout( const ULONG_PTR ms )
	{
	CESESnapshotSession * 	pSession 	= &g_SnapshotSession;
	ERR 					err 		= JET_errSuccess;

	//	UNDONE: impose a realistic cap on the timeout value
	if ( ms >= LONG_MAX )
		return ErrERRCheck( JET_errInvalidParameter );

	pSession->SnapshotCritEnter();

	// can't set the timeout unless we can start a new snapshot
	// we can eventualy relax this condition but probably it is fine
	if ( !pSession->FCanSwitchTo( CESESnapshotSession::statePrepare ) )
		{
		pSession->SnapshotCritLeave();
		CallR ( ErrERRCheck( JET_errOSSnapshotInvalidSequence ) );
		}

	pSession->SetTimeout( (ULONG)ms );
	pSession->SnapshotCritLeave();

	return JET_errSuccess;
	}

// functions to get the timeout using JetGetSystemParam with JET_paramOSSnapshotTimeout
ERR ErrOSSnapshotGetTimeout( ULONG_PTR * pms )
	{
	CESESnapshotSession * 	pSession 	= &g_SnapshotSession;

	if ( pms == NULL )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	pSession->SnapshotCritEnter();

	Assert ( pms );
	*pms = pSession->GetTimeout();

	pSession->SnapshotCritLeave();
	return JET_errSuccess;
	}

#else // OS_SNAPSHOT

ERR ISAMAPI ErrIsamOSSnapshotPrepare( JET_OSSNAPID * psnapId, const JET_GRBIT	grbit )
	{
	return ErrERRCheck( JET_wrnNyi );
	}

ERR ISAMAPI ErrIsamOSSnapshotFreeze( const JET_OSSNAPID snapId, unsigned long *pcInstanceInfo, JET_INSTANCE_INFO ** paInstanceInfo,const	JET_GRBIT grbit )
	{
	return ErrERRCheck( JET_wrnNyi );
	}

ERR ISAMAPI ErrIsamOSSnapshotThaw(	const JET_OSSNAPID snapId, const JET_GRBIT grbit )
	{
	return ErrERRCheck( JET_wrnNyi );
	}

ERR ISAMAPI ErrIsamOSSnapshotAbort(	const JET_OSSNAPID snapId, const JET_GRBIT grbit )
	{
	return ErrERRCheck( JET_wrnNyi );
	}

ERR ErrOSSnapshotSetTimeout( const ULONG_PTR ms )
	{
	return ErrERRCheck( JET_wrnNyi );
	}

ERR ErrOSSnapshotGetTimeout( ULONG_PTR * pms )
	{
	return ErrERRCheck( JET_wrnNyi );
	}

#endif // OS_SNAPSHOT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\fldext.cxx ===
#include "std.hxx"


INLINE ERR ErrRECIGetRecord(
	FUCB	*pfucb,
	DATA	**ppdataRec,
	BOOL	fUseCopyBuffer )
	{
	ERR		err = JET_errSuccess;

	Assert( ppdataRec );
	Assert( FFUCBSort( pfucb ) || FFUCBIndex( pfucb ) );

	//	retrieving from copy buffer?
	//
	if ( fUseCopyBuffer )
		{
		//	only index cursors have copy buffers.
		//
		Assert( FFUCBIndex( pfucb ) );
		Assert( !Pcsr( pfucb )->FLatched() );
		*ppdataRec = &pfucb->dataWorkBuf;
		}
	else
		{
		if ( FFUCBIndex( pfucb ) )
			{
			err = ErrDIRGet( pfucb );
			}
		else
			{
			//	sorts always have current data cached.
			Assert( pfucb->locLogical == locOnCurBM
				|| pfucb->locLogical == locBeforeFirst
				|| pfucb->locLogical == locAfterLast );
			if ( pfucb->locLogical != locOnCurBM )
				{
				err = ErrERRCheck( JET_errNoCurrentRecord );
				}
			else
				{
				Assert( pfucb->kdfCurr.data.Cb() != 0 );
				}
			}

		*ppdataRec = &pfucb->kdfCurr.data;
		}
		
	return err;
	}

ERR ErrRECIAccessColumn( FUCB *pfucb, COLUMNID columnid, FIELD * const pfieldFixed )
	{
	ERR 		err		= JET_errSuccess;
	PIB *		ppib	= pfucb->ppib;
	FCB *		pfcb	= pfucb->u.pfcb;
	TDB *		ptdb	= pfcb->Ptdb();
	const FID	fid		= FidOfColumnid( columnid );

	Assert( 0 != columnid );
	if ( !FCOLUMNIDValid( columnid ) )
		{
		return ErrERRCheck( JET_errBadColumnId );
		}

	if ( FCOLUMNIDTemplateColumn( columnid ) )
		{
		if ( pfcb->FTemplateTable() )
			{
			ptdb->AssertValidTemplateTable();
			}
		else if ( pfcbNil != ptdb->PfcbTemplateTable() )
			{
			ptdb->AssertValidDerivedTable();
			ptdb = ptdb->PfcbTemplateTable()->Ptdb();
			}
		else
			{
			return ErrERRCheck( JET_errColumnNotFound );
			}

		BOOL	fCopyField	= fFalse;
		FID		fidFirst;
		FID		fidLast;

		if ( FTaggedFid( fid ) )
			{
			fidFirst = ptdb->FidTaggedFirst();
			fidLast = ptdb->FidTaggedLast();
			}
		else if ( FFixedFid( fid ) )
			{
			fidFirst = ptdb->FidFixedFirst();
			fidLast = ptdb->FidFixedLast();
			if ( pfieldNil != pfieldFixed )
				fCopyField = fTrue;
			}
		else
			{
			Assert( FVarFid( fid ) );
			fidFirst = ptdb->FidVarFirst();
			fidLast = ptdb->FidVarLast();
			}

		Assert( JET_errSuccess == err );
		if ( fid > fidLast || fid < fidFirst )
			{
			err = ErrERRCheck( JET_errColumnNotFound );
			}
		else
			{
#ifdef DEBUG
			const FIELD * const	pfieldT	= ptdb->Pfield( columnid );
			Assert( JET_coltypNil != pfieldT->coltyp );
			Assert( !FFIELDVersioned( pfieldT->ffield ) );
			Assert( !FFIELDDeleted( pfieldT->ffield ) );
#endif
			CallS( err );
			if ( fCopyField )
				*pfieldFixed = *( ptdb->PfieldFixed( columnid ) );
			}

		return err;
		}

	else if ( pfcb->FTemplateTable() )
		{
		return ErrERRCheck( JET_errColumnNotFound );
		}


	BOOL		fUseDMLLatch	= fFalse;
	FIELDFLAG	ffield;

	if ( FTaggedFid( fid ) )
		{
		if ( fid > ptdb->FidTaggedLastInitial() )
			{
			pfcb->EnterDML();
			if ( fid > ptdb->FidTaggedLast() )
				{
				pfcb->LeaveDML();
				return ErrERRCheck( JET_errColumnNotFound );
				}
			fUseDMLLatch = fTrue;
			}
		else if ( fid < ptdb->FidTaggedFirst () )
			{
			return ErrERRCheck( JET_errColumnNotFound );
			}

		ffield = ptdb->PfieldTagged( columnid )->ffield;
		}
	else if ( FFixedFid( fid ) )
		{
		if ( fid > ptdb->FidFixedLastInitial() )
			{
			pfcb->EnterDML();
			if ( fid > ptdb->FidFixedLast() )
				{
				pfcb->LeaveDML();
				return ErrERRCheck( JET_errColumnNotFound );
				}
			fUseDMLLatch = fTrue;
			}
		else if ( fid < ptdb->FidFixedFirst () )
			{
			return ErrERRCheck( JET_errColumnNotFound );
			}

		FIELD * const	pfieldT		= ptdb->PfieldFixed( columnid );
		if ( pfieldNil != pfieldFixed )
			{
			*pfieldFixed = *pfieldT;

			//	use the snapshotted FIELD, because the real one
			//	could be being modified
			ffield = pfieldFixed->ffield;
			}
		else
			{
			ffield = pfieldT->ffield;
			}
		}
	else
		{
		Assert( FVarFid( fid ) );

		if ( fid > ptdb->FidVarLastInitial() )
			{
			pfcb->EnterDML();
			if ( fid > ptdb->FidVarLast() )
				{
				pfcb->LeaveDML();
				return ErrERRCheck( JET_errColumnNotFound );
				}
			fUseDMLLatch = fTrue;
			}
		else if ( fid < ptdb->FidVarFirst () )
			{
			return ErrERRCheck( JET_errColumnNotFound );
			}

		ffield = ptdb->PfieldVar( columnid )->ffield;
		}

	if ( fUseDMLLatch )
		pfcb->AssertDML();

	//	check if the FIELD has been versioned or deleted
	//	(note that we took only a snapshot of the flags
	//	above, so by now the FIELD may be different), 
	if ( FFIELDVersioned( ffield ) )
		{
		Assert( !pfcb->FFixedDDL() );
		Assert( !pfcb->FTemplateTable() );

		if ( fUseDMLLatch )
			pfcb->LeaveDML();

		const BOOL	fLatchHeld	= Pcsr( pfucb )->FLatched();
		if ( fLatchHeld )
			{
			// UNDONE:  Move latching logic to caller.
			CallS( ErrDIRRelease( pfucb ) );
			}

		// Inherited columns are never versioned.
		Assert( !FCOLUMNIDTemplateColumn( columnid ) );
			
		err = ErrCATAccessTableColumn(
					ppib,
					pfcb->Ifmp(),
					pfcb->ObjidFDP(),
					NULL,
					&columnid );
		Assert( err <= 0 );		// No warning should be generated.
		
		if ( fLatchHeld )
			{
			ERR	errT = ErrDIRGet( pfucb );
			if ( errT < 0 )
				{
				//	if error encountered while re-latching record, return the error
				//	only if no unexpected errors from catalog consultation.
				if ( err >= 0 || JET_errColumnNotFound == err )
					err = errT;
				}
			}
		}
		
	else
		{
		if ( FFIELDDeleted( ffield ) )
			{
			//	may get deleted columns in FixedDDL tables if an AddColumn() in those
			//	tables rolled back
//			Assert( !pfcb->FFixedDDL() );
//			Assert( !FCOLUMNIDTemplateColumn( columnid ) );
			err = ErrERRCheck( JET_errColumnNotFound );
			}

		if ( fUseDMLLatch )
			pfcb->LeaveDML();
		}

	return err;
	}

ERR ErrRECIRetrieveFixedColumn(
	FCB				* const pfcb,		// pass pfcbNil to bypass EnterDML()
	const TDB		*ptdb,
	const COLUMNID	columnid,
	const DATA&		dataRec,
	DATA			* pdataField,
	const FIELD		* const pfieldFixed )
	{
	ERR				err;
	const FID		fid		= FidOfColumnid( columnid );
	
	Assert( ptdb != ptdbNil );
	Assert( pfcbNil == pfcb || pfcb->Ptdb() == ptdb );
	Assert( FCOLUMNIDFixed( columnid ) );
	Assert( !dataRec.FNull() );
	Assert( dataRec.Cb() >= REC::cbRecordMin );
	Assert( dataRec.Cb() <= REC::CbRecordMax() );
	Assert( pdataField != NULL );
	
	const REC	*prec = (REC *)dataRec.Pv();
	
	Assert( prec->FidFixedLastInRec() >= fidFixedLeast-1 );
	Assert( prec->FidFixedLastInRec() <= fidFixedMost );

#ifdef DEBUG
	const BOOL	fUseDMLLatchDBG		= ( pfcbNil != pfcb && fid > ptdb->FidFixedLastInitial() );
#else
	const BOOL	fUseDMLLatchDBG		= fFalse;
#endif

	if ( fUseDMLLatchDBG )
		pfcb->EnterDML();

	// RECIAccessColumn() should have already been called to verify FID.
	Assert( fid <= ptdb->FidFixedLast() );
	Assert( pfieldNil != ptdb->PfieldFixed( columnid ) );
	Assert( JET_coltypNil != ptdb->PfieldFixed( columnid )->coltyp );
	Assert( ptdb->PfieldFixed( columnid )->ibRecordOffset >= ibRECStartFixedColumns );
	Assert( ptdb->PfieldFixed( columnid )->ibRecordOffset < ptdb->IbEndFixedColumns() );
	Assert( !FFIELDUserDefinedDefault( ptdb->PfieldFixed( columnid )->ffield ) );

	// Don't forget to LeaveDML() before exitting this function.

	//	column not represented in record, retrieve from default
	//	or null column.
	//
	if ( fid > prec->FidFixedLastInRec() )
		{
		// if DEBUG, then EnterDML() was already done at the top of this function
		const BOOL	fUseDMLLatch	= ( !fUseDMLLatchDBG
										&& pfcbNil != pfcb
										&& fid > ptdb->FidFixedLastInitial() );
		
		if ( fUseDMLLatch )
			pfcb->EnterDML();

		//	assert no infinite recursion
		Assert( dataRec.Pv() != ptdb->PdataDefaultRecord() );
		
		//	if default value set, then retrieve default
		//
		if ( FFIELDDefault( ptdb->PfieldFixed( columnid )->ffield ) )
			{
			err = ErrRECIRetrieveFixedDefaultValue( ptdb, columnid, pdataField );
			}
		else
			{
			pdataField->Nullify();
			err = ErrERRCheck( JET_wrnColumnNull );
			}

		if ( fUseDMLLatch || fUseDMLLatchDBG )
			pfcb->LeaveDML();

		return err;
		}

	Assert( prec->FidFixedLastInRec() >= fidFixedLeast );
	Assert( ptdb->PfieldFixed( columnid )->ibRecordOffset < prec->IbEndOfFixedData() );
	
	// check nullity

	const UINT	ifid			= fid - fidFixedLeast;
	const BYTE	*prgbitNullity	= prec->PbFixedNullBitMap() + ifid/8;

	//	bit is not set: column is NULL
	//
	if ( FFixedNullBit( prgbitNullity, ifid ) )
		{
		pdataField->Nullify();
		err = ErrERRCheck( JET_wrnColumnNull );

		}
	else
		{
		// if DEBUG, then EnterDML() was already done at the top of this function
		const BOOL	fUseDMLLatch	= ( !fUseDMLLatchDBG
										&& pfcbNil != pfcb
										&& pfieldNil == pfieldFixed
										&& fid > ptdb->FidFixedLastInitial() );

		if ( fUseDMLLatch )
			pfcb->EnterDML();

		//	set output parameter to length and address of column
		//
		const FIELD	* const pfield = ( pfieldNil != pfieldFixed ? pfieldFixed : ptdb->PfieldFixed( columnid ) );
		Assert( pfield->cbMaxLen == UlCATColumnSize( pfield->coltyp, pfield->cbMaxLen, NULL ) );
		pdataField->SetCb( pfield->cbMaxLen );
		pdataField->SetPv( (BYTE *)prec + pfield->ibRecordOffset );

		if ( fUseDMLLatch )
			pfcb->LeaveDML();

		err = JET_errSuccess;
		}
		

	if ( fUseDMLLatchDBG )
		pfcb->LeaveDML();
		
	return err;
	}


ERR ErrRECIRetrieveVarColumn(
	FCB				* const pfcb,		// pass pfcbNil to bypass EnterDML()
	const TDB		* ptdb,
	const COLUMNID	columnid,
	const DATA&		dataRec,
	DATA			* pdataField )
	{
	const FID		fid			= FidOfColumnid( columnid );

	Assert( ptdbNil != ptdb );
	Assert( pfcbNil == pfcb || pfcb->Ptdb() == ptdb );
	Assert( FCOLUMNIDVar( columnid ) );
	Assert( !dataRec.FNull() );
	Assert( dataRec.Cb() >= REC::cbRecordMin );
	Assert( dataRec.Cb() <= REC::CbRecordMax() );
	Assert( pdataField != NULL );
	
	const REC	*prec = (REC *)dataRec.Pv();
	
	Assert( prec->FidVarLastInRec() >= fidVarLeast-1 );
	Assert( prec->FidVarLastInRec() <= fidVarMost );

#ifdef DEBUG
	const BOOL	fUseDMLLatchDBG		= ( pfcbNil != pfcb && fid > ptdb->FidVarLastInitial() );
#else
	const BOOL	fUseDMLLatchDBG		= fFalse;
#endif

	if ( fUseDMLLatchDBG )
		pfcb->EnterDML();

	// RECIAccessColumn() should have already been called to verify FID.
	Assert( fid <= ptdb->FidVarLast() );
	Assert( JET_coltypNil != ptdb->PfieldVar( columnid )->coltyp );
	Assert( !FFIELDUserDefinedDefault( ptdb->PfieldVar( columnid )->ffield ) );

	//	column not represented in record: column is NULL
	//
	if ( fid > prec->FidVarLastInRec() )
		{
		// if DEBUG, then EnterDML() was already done at the top of this function
		ERR			err;
		const BOOL	fUseDMLLatch	= ( !fUseDMLLatchDBG
										&& pfcbNil != pfcb
										&& fid > ptdb->FidVarLastInitial() );
		
		if ( fUseDMLLatch )
			pfcb->EnterDML();
		
		//	assert no infinite recursion
		Assert( dataRec.Pv() != ptdb->PdataDefaultRecord() );

		//	if default value set, then retrieve default
		//
		if ( FFIELDDefault( ptdb->PfieldVar( columnid )->ffield ) )
			{
			err = ErrRECIRetrieveVarDefaultValue( ptdb, columnid, pdataField );
			}
		else
			{
			pdataField->Nullify();
			err = ErrERRCheck( JET_wrnColumnNull );
			}

		if ( fUseDMLLatch || fUseDMLLatchDBG )
			pfcb->LeaveDML();

		return err;
		}

	if ( fUseDMLLatchDBG )
		pfcb->LeaveDML();

	Assert( prec->FidVarLastInRec() >= fidVarLeast );

	UnalignedLittleEndian<REC::VAROFFSET>	*pibVarOffs		= prec->PibVarOffsets();

	//	adjust fid to an index
	//
	const UINT				ifid			= fid - fidVarLeast;

	//	beginning of current column is end of previous column
	const REC::VAROFFSET	ibStartOfColumn	= prec->IbVarOffsetStart( fid );

	Assert( IbVarOffset( pibVarOffs[ifid] ) == prec->IbVarOffsetEnd( fid ) );
	Assert( IbVarOffset( pibVarOffs[ifid] ) >= ibStartOfColumn );
	
	//	column is set to Null
	//
	if ( FVarNullBit( pibVarOffs[ifid] ) )
		{
		Assert( IbVarOffset( pibVarOffs[ifid] ) - ibStartOfColumn == 0 );
		pdataField->Nullify();
		return ErrERRCheck( JET_wrnColumnNull );
		}

	pdataField->SetCb( IbVarOffset( pibVarOffs[ifid] ) - ibStartOfColumn );
	Assert( pdataField->Cb() < dataRec.Cb() );
	
	if ( pdataField->Cb() == 0 )
		{
		// length is zero: return success [zero-length non-null
		// values are allowed]
		pdataField->SetPv( NULL );
		}
	else
		{
		//	set output parameter: column address
		//
		BYTE	*pbVarData = prec->PbVarData();
		Assert( pbVarData + IbVarOffset( pibVarOffs[prec->FidVarLastInRec()-fidVarLeast] )
					<= (BYTE *)dataRec.Pv() + dataRec.Cb() );
		pdataField->SetPv( pbVarData + ibStartOfColumn );
		Assert( pdataField->Pv() >= (BYTE *)prec );
		Assert( pdataField->Pv() <= (BYTE *)prec + dataRec.Cb() );
		}
		
	return JET_errSuccess;
	}


ERR ErrRECIRetrieveTaggedColumn(
	FCB				* pfcb,
	const COLUMNID	columnid,
	const ULONG		itagSequence,
	const DATA&		dataRec,
	DATA			* const pdataRetrieveBuffer,
	const ULONG		grbit )
	{
	BOOL			fUseDerivedBit		= fFalse;
	Assert( !( grbit & grbitRetrieveColumnUseDerivedBit ) );	//	fDerived check is made below
	
	Assert( FCOLUMNIDTagged( columnid ) );
	Assert( itagSequence > 0 );
	Assert( !dataRec.FNull() );
	Assert( dataRec.Cb() >= REC::cbRecordMin );
	Assert( dataRec.Cb() <= REC::CbRecordMax() );
	Assert( NULL != pdataRetrieveBuffer );

	if ( FCOLUMNIDTemplateColumn( columnid ) )
		{
		if ( !pfcb->FTemplateTable() )
			{
			pfcb->Ptdb()->AssertValidDerivedTable();

			//	HACK: treat derived columns in original-format derived table as
			//	non-derived, because they don't have the fDerived bit set in the TAGFLD
			fUseDerivedBit = FRECUseDerivedBitForTemplateColumnInDerivedTable( columnid, pfcb->Ptdb() );

			// switch to template table
			pfcb = pfcb->Ptdb()->PfcbTemplateTable();
			}
		else
			{
			pfcb->Ptdb()->AssertValidTemplateTable();
			Assert( !fUseDerivedBit );
			}
		}
	else
		{
		Assert( !pfcb->FTemplateTable() );
		}

	TAGFIELDS	tagfields( dataRec );
	return tagfields.ErrRetrieveColumn(
				pfcb,
				columnid,
				itagSequence,
				dataRec,
				pdataRetrieveBuffer,
				grbit | ( fUseDerivedBit ? grbitRetrieveColumnUseDerivedBit : 0  ) );
	}

INLINE ULONG UlRECICountTaggedColumnInstances(
	FCB				* pfcb,
	const COLUMNID	columnid,
	const DATA&		dataRec )
	{
	BOOL			fUseDerivedBit		= fFalse;

	Assert( FCOLUMNIDTagged( columnid ) );
	Assert( !dataRec.FNull() );
	Assert( dataRec.Cb() >= REC::cbRecordMin );
	Assert( dataRec.Cb() <= REC::CbRecordMax() );

	if ( FCOLUMNIDTemplateColumn( columnid ) )
		{
		if ( !pfcb->FTemplateTable() )
			{
			pfcb->Ptdb()->AssertValidDerivedTable();

			//	HACK: treat derived columns in original-format derived table as
			//	non-derived, because they don't have the fDerived bit set in the TAGFLD
			fUseDerivedBit = FRECUseDerivedBitForTemplateColumnInDerivedTable( columnid, pfcb->Ptdb() );

			// switch to template table
			pfcb = pfcb->Ptdb()->PfcbTemplateTable();
			}
		else
			{
			pfcb->Ptdb()->AssertValidTemplateTable();
			Assert( !fUseDerivedBit );
			}
		}
	else
		{
		Assert( !pfcb->FTemplateTable() );
		}

	TAGFIELDS	tagfields( dataRec );
	return tagfields.UlColumnInstances(
				pfcb,
				columnid,
				fUseDerivedBit );
	}


ERR ErrRECIRetrieveSeparatedLongValue(
	FUCB		*pfucb,
	const DATA&	dataField,
	BOOL		fAfterImage,
	ULONG		ibLVOffset,
	VOID		*pv,
	ULONG		cbMax,
	ULONG		*pcbActual,
	JET_GRBIT 	grbit )
	{
	Assert( NULL != pv || 0 == cbMax );

	const LID	lid			= LidOfSeparatedLV( dataField );
	ERR			err;
	ULONG		cbActual;

	Assert( FFUCBIndex( pfucb ) );		// Sorts don't have separated LV's.

	if ( grbit & JET_bitRetrieveLongId )
		{
		Assert( ibLVOffset == 0 );
		if ( cbMax < sizeof(LID) )
			return ErrERRCheck( JET_errInvalidBufferSize );
			
		cbActual = sizeof(LID);
		UtilMemCpy( pv, (BYTE *)&lid, cbActual );
		err = ErrERRCheck( JET_wrnSeparateLongValue );
		}

	else
		{
		//	Must release any latch held.
		//
		if ( Pcsr( pfucb )->FLatched() )
			{
			CallS( ErrDIRRelease( pfucb ) );
			}
		AssertDIRNoLatch( pfucb->ppib );

		if ( grbit & JET_bitRetrieveLongValueRefCount )
			{
			Assert( 0 == ibLVOffset );
		
			Call( ErrRECRetrieveSLongFieldRefCount(
					pfucb,
					lid,
					reinterpret_cast<BYTE *>( pv ),
					cbMax,
			  		&cbActual ) );		  		
			err = ErrERRCheck( JET_wrnSeparateLongValue );
			}

		else
			{
			Call( ErrRECRetrieveSLongField( pfucb,
					lid,
					fAfterImage,
					ibLVOffset,
					reinterpret_cast<BYTE *>( pv ),
					cbMax,
			  		&cbActual ) );
			CallS( err );			// Don't expect any warnings.
		
			if ( cbActual > cbMax )
				err = ErrERRCheck( JET_wrnBufferTruncated );
			}
		}
		
	if ( pcbActual )
		*pcbActual = cbActual;

HandleError:
	return err;
	}


COLUMNID ColumnidRECFirstTaggedForScanOfDerivedTable( const TDB * const ptdb )
	{
	COLUMNID	columnidT;

	ptdb->AssertValidDerivedTable();
	const TDB	* ptdbTemplate	= ptdb->PfcbTemplateTable()->Ptdb();

	if ( ptdb->FESE97DerivedTable()
		&& 0 != ptdbTemplate->FidTaggedLastOfESE97Template() )
		{
		if ( ptdbTemplate->FidTaggedLast() > ptdbTemplate->FidTaggedLastOfESE97Template() )
			{
			//	HACK: scan starts with first ESE98 template column
			columnidT = ColumnidOfFid(
							FID( ptdbTemplate->FidTaggedLastOfESE97Template() + 1 ),
							fTrue );
			}
		else
			{
			//	no ESE98 template columns, go to first ESE97 template column (at least one
			//	must exist)
			Assert( ptdbTemplate->FidTaggedLast() >= ptdbTemplate->FidTaggedFirst() );
			columnidT = ColumnidOfFid( ptdbTemplate->FidTaggedFirst(), fTrue );
			}
		}
	else
		{
		//	since no ESE97 tagged columns in template, template and derived tables
		//	must both start numbering at same place
		Assert( ptdbTemplate->FidTaggedFirst() == ptdb->FidTaggedFirst() );
		if ( ptdbTemplate->FidTaggedLast() >= fidTaggedLeast )
			{
			columnidT = ColumnidOfFid( ptdbTemplate->FidTaggedFirst(), fTrue );
			}
		else
			{
			//	no template columns, go to derived columns
			columnidT = ColumnidOfFid( ptdb->FidTaggedFirst(), fFalse );
			}
		}

	return columnidT;
	}

COLUMNID ColumnidRECNextTaggedForScanOfDerivedTable( const TDB * const ptdb, const COLUMNID columnid )
	{
	COLUMNID	columnidT	= columnid + 1;

	Assert( FCOLUMNIDTemplateColumn( columnidT ) );
	
	ptdb->AssertValidDerivedTable();
	const TDB	* const ptdbTemplate	= ptdb->PfcbTemplateTable()->Ptdb();
	
	Assert( FidOfColumnid( columnid ) <= ptdbTemplate->FidTaggedLast() );
	if ( ptdb->FESE97DerivedTable()
		&& 0 != ptdbTemplate->FidTaggedLastOfESE97Template() )
		{
		Assert( ptdbTemplate->FidTaggedLastOfESE97Template() <= ptdbTemplate->FidTaggedLast() );
		if ( FidOfColumnid( columnidT ) == ptdbTemplate->FidTaggedLastOfESE97Template() + 1 )
			{
			Assert( ptdbTemplate->FidTaggedLastOfESE97Template() + 1 == ptdb->FidTaggedFirst() );
			columnidT = ColumnidOfFid( ptdb->FidTaggedFirst(), fFalse );
			}
		else if ( FidOfColumnid( columnidT ) > ptdbTemplate->FidTaggedLast() )
			{
			//	move to ESE97 template column space (at least one must exist)
			Assert( ptdbTemplate->FidTaggedLast() >= ptdbTemplate->FidTaggedFirst() );
			columnidT = ColumnidOfFid( ptdbTemplate->FidTaggedFirst(), fTrue );
			}
		else
			{
			//	still in template table column space, so do nothing special
			}
		}
	else if ( FidOfColumnid( columnidT ) > ptdbTemplate->FidTaggedLast() )
		{
		//	move to derived table column space
		columnidT = ColumnidOfFid( ptdb->FidTaggedFirst(), fFalse );
		}
	else
		{
		//	still in template table column space, so do nothing special
		}

	return columnidT;
	}


LOCAL ERR ErrRECIScanTaggedColumns(
			FUCB            *pfucb,
			const ULONG     itagSequence,
			const DATA&     dataRec,
			DATA            *pdataField,
			COLUMNID        *pcolumnidRetrieved,
			ULONG           *pitagSequenceRetrieved,
			JET_GRBIT       grbit )
	{
	TAGFIELDS tagfields( dataRec );
	return tagfields.ErrScan(
				pfucb,
				itagSequence,
				dataRec,
				pdataField,
				pcolumnidRetrieved,
				pitagSequenceRetrieved,
				grbit );
	}

	
JET_COLTYP ColtypFromColumnid( FUCB *pfucb, const COLUMNID columnid )
	{
	FCB			*pfcbTable;
	TDB			*ptdb;
	FIELD		*pfield;
	JET_COLTYP	coltyp;

	pfcbTable = pfucb->u.pfcb;
	ptdb = pfcbTable->Ptdb();
	
	pfcbTable->EnterDML();
	
	if ( FCOLUMNIDTagged( columnid ) )
		{
		pfield = ptdb->PfieldTagged( columnid );
		}
	else if ( FCOLUMNIDFixed( columnid ) )
		{
		pfield = ptdb->PfieldFixed( columnid );
		Assert( !FRECLongValue( pfield->coltyp ) );
		}
	else
		{
		Assert( FCOLUMNIDVar( columnid ) );
		pfield = ptdb->PfieldVar( columnid );
		Assert( !FRECLongValue( pfield->coltyp ) );
		}
		
	coltyp = pfield->coltyp;
	
	pfcbTable->LeaveDML();
	
	return coltyp;
	}

LOCAL ERR ErrRECIRetrieveFromIndex(
	FUCB		*pfucb,
	COLUMNID	columnid,
	ULONG		*pitagSequence,
	BYTE		*pb,
	ULONG		cbMax,
	ULONG		*pcbActual,
	ULONG		ibGraphic,
	JET_GRBIT	grbit )
	{
	ERR			err;
	FUCB   		*pfucbIdx;
	FCB			*pfcbTable;
	TDB			*ptdb;
	IDB			*pidb;
	BOOL		fInitialIndex;
	BOOL		fDerivedIndex;
	BOOL		fLatched				= fFalse;
	BOOL   		fText					= fFalse;
	BOOL	   	fLongValue				= fFalse;
	BOOL		fBinaryChunks			= fFalse;
	BOOL		fSawMultiValued			= fFalse;
	BOOL		fFirstMultiValued		= fFalse;
	BOOL		fVarSegMac				= fFalse;
	INT			iidxseg;
	DATA   		dataColumn;
	BOOL		fRetrieveFromPrimaryBM;
	ULONG		cbKeyMost;
	BYTE   		rgb[JET_cbKeyMost];
	KEY			keyT;
	KEY			*pkey;
	FIELD		*pfield;
	const IDXSEG*	rgidxseg;

	Assert( NULL != pitagSequence );
	AssertDIRNoLatch( pfucb->ppib );

	//	caller checks for these grbits
	Assert( grbit & ( JET_bitRetrieveFromIndex|JET_bitRetrieveFromPrimaryBookmark ) );

	//	RetrieveFromIndex and RetrieveFromPrimaryBookmark are mutually exclusive
	if ( ( grbit & JET_bitRetrieveFromIndex )
		&& ( grbit & JET_bitRetrieveFromPrimaryBookmark ) )
		return ErrERRCheck( JET_errInvalidGrbit );
	
	if ( !FCOLUMNIDValid( columnid ) )
		return ErrERRCheck( JET_errBadColumnId );
		
	//	if on primary index, then return code indicating that
	//	retrieve should be from record.  Note, sequential files
	//	having no indexes, will be natually handled this way.
	//
	if ( pfucbNil == pfucb->pfucbCurIndex )
		{
		pfucbIdx = pfucb;
		
		Assert( pfcbNil != pfucb->u.pfcb );
		Assert( pfucb->u.pfcb->FTypeTable()
			|| pfucb->u.pfcb->FTypeTemporaryTable()
			|| pfucb->u.pfcb->FTypeSort() );

		Assert( ( pfucb->u.pfcb->FSequentialIndex() && pidbNil == pfucb->u.pfcb->Pidb() )
			|| ( !pfucb->u.pfcb->FSequentialIndex() && pidbNil != pfucb->u.pfcb->Pidb() ) );

		//	if currency is not locOnCurBM, we have to go to the record anyway,
		//		so it's pointless to continue
		//	for a sequential index, must go to the record
		//	for a sort, data is always cached anyway so just retrieve normally
		if ( locOnCurBM != pfucb->locLogical
			|| pfucb->u.pfcb->FSequentialIndex()
			|| FFUCBSort( pfucb ) )
			{
			//	can't have multi-valued column in a primary index,
			//	so itagSequence must be 1
			*pitagSequence = 1;
			return ErrERRCheck( errDIRNoShortCircuit );
			}

		Assert( pidbNil != pfucbIdx->u.pfcb->Pidb() );
		Assert( pfucbIdx->u.pfcb->Pidb()->FPrimary() );

		//	force RetrieveFromIndex, strip off RetrieveTag
		grbit = JET_bitRetrieveFromIndex;
		fRetrieveFromPrimaryBM = fFalse;
		cbKeyMost = JET_cbPrimaryKeyMost;
		}
	else
		{
		pfucbIdx = pfucb->pfucbCurIndex;
		Assert( pfucbIdx->u.pfcb->FTypeSecondaryIndex() );
		Assert( pidbNil != pfucbIdx->u.pfcb->Pidb() );
		Assert( !pfucbIdx->u.pfcb->Pidb()->FPrimary() );
		fRetrieveFromPrimaryBM = ( grbit & JET_bitRetrieveFromPrimaryBookmark );
		cbKeyMost = ( fRetrieveFromPrimaryBM ? JET_cbPrimaryKeyMost : JET_cbSecondaryKeyMost );
		}
	
	//	find index segment for given column id
	//
	pfcbTable = pfucb->u.pfcb;
	Assert( pfcbNil != pfcbTable );
	Assert( pfcbTable->Ptdb() != ptdbNil );

	if ( fRetrieveFromPrimaryBM )
		{
		Assert( !pfucbIdx->u.pfcb->Pidb()->FPrimary() );
		if ( pfcbTable->FSequentialIndex() )
			{
			//	no columns in a sequential index
			Assert( pidbNil == pfcbTable->Pidb() );
 			return ErrERRCheck( JET_errColumnNotFound );
			}
			
		pidb = pfcbTable->Pidb();
		Assert( pidbNil != pidb );

		fInitialIndex = pfcbTable->FInitialIndex();
		fDerivedIndex = pfcbTable->FDerivedIndex();
		}
	else
		{
		const FCB * const	pfcbIdx		= pfucbIdx->u.pfcb;

		pidb = pfcbIdx->Pidb();
		fInitialIndex = pfcbIdx->FInitialIndex();
		fDerivedIndex = pfcbIdx->FDerivedIndex();
		}

	if ( fDerivedIndex )
		{
		Assert( pidb->FTemplateIndex() );
		Assert( pfcbTable->Ptdb() != ptdbNil );
		pfcbTable = pfcbTable->Ptdb()->PfcbTemplateTable();
		Assert( pfcbNil != pfcbTable );
		Assert( pfcbTable->FTemplateTable() );
		Assert( pfcbTable->Ptdb() != ptdbNil );
		}
	
	ptdb = pfcbTable->Ptdb();

	const BOOL		fUseDMLLatch	= ( !fInitialIndex
										|| pidb->FIsRgidxsegInMempool() );

	if ( fUseDMLLatch )
		pfcbTable->EnterDML();

	rgidxseg = PidxsegIDBGetIdxSeg( pidb, ptdb );
	for ( iidxseg = 0; iidxseg < pidb->Cidxseg(); iidxseg++ )
		{
		const COLUMNID	columnidT	= rgidxseg[iidxseg].Columnid();
		if ( columnidT == columnid )
			{
			break;
			}
		else if ( pidb->FMultivalued()
			&& !fSawMultiValued
			&& FCOLUMNIDTagged( columnidT ) )
			{
			pfield = ptdb->PfieldTagged( columnidT );
			fSawMultiValued = FFIELDMultivalued( pfield->ffield );
			}
		}
	Assert( iidxseg <= pidb->Cidxseg() );
	if ( iidxseg == pidb->Cidxseg() )
		{
		if ( fUseDMLLatch )
			pfcbTable->LeaveDML();
		return ErrERRCheck( JET_errColumnNotFound );
		}

	if ( pidb->FTuples() )
		{
		if ( fUseDMLLatch )
			pfcbTable->LeaveDML();
		return ErrERRCheck( JET_errIndexTuplesCannotRetrieveFromIndex );
		}

	Assert( pidb->CbVarSegMac() > 0 );
	Assert( pidb->CbVarSegMac() <= cbKeyMost );
	fVarSegMac = ( pidb->CbVarSegMac() < cbKeyMost );

	// Since the column belongs to an active index, we are guaranteed
	// that the column is accessible.
	if ( FCOLUMNIDTagged( columnid ) )
		{
		pfield = ptdb->PfieldTagged( columnid );
		fLongValue = FRECLongValue( pfield->coltyp );
		fBinaryChunks = FRECBinaryColumn( pfield->coltyp );

		Assert( !FFIELDMultivalued( pfield->ffield )
			|| ( pidb->FMultivalued() && !pidb->FPrimary() ) );		//	primary index can't be over multi-valued column
		fFirstMultiValued = ( !fSawMultiValued && FFIELDMultivalued( pfield->ffield ) );
		}
	else if ( FCOLUMNIDFixed( columnid ) )
		{
		pfield = ptdb->PfieldFixed( columnid );
		Assert( !FRECLongValue( pfield->coltyp ) );
		}
	else
		{
		Assert( FCOLUMNIDVar( columnid ) );
 		pfield = ptdb->PfieldVar( columnid );
		Assert( !FRECLongValue( pfield->coltyp ) );
		fBinaryChunks = FRECBinaryColumn( pfield->coltyp );
		}
		
	fText = FRECTextColumn( pfield->coltyp );
	Assert( pfield->cp != usUniCodePage || fText );		// Can't be Unicode unless it's text.

	if ( fUseDMLLatch )
		pfcbTable->LeaveDML();

	//	if not locOnCurBM, must go to record
	//
	//	if locOnCurBM and retrieving from the index, we can just retrieve from bmCurr
	//
	//  if locOnCurBM and retrieveing from the primary bookmark we can use the bmCurr
	//  of the FUCB of the table -- unless the table is not locOnCurBM. The table can
	//  not be on locCurBM if (iff?) we call JetSetCurrentIndex( JET_bitMoveFirst ) and
	//  then call JetRetrieveColumn() -- the FUCB of the index will be updated, but not the
	//  table. We could optimize this case by noting that on a non-unique secondary index
	//  we could get the primary key from the data of the bmCurr of the pfucbIdx
	if ( locOnCurBM != pfucbIdx->locLogical
		|| ( fRetrieveFromPrimaryBM && ( locOnCurBM != pfucb->locLogical ) ) )
		{
		CallR( ErrDIRGet( pfucbIdx ) );
		fLatched = fTrue;

		if ( fRetrieveFromPrimaryBM )
			{
			keyT.prefix.Nullify();
			keyT.suffix.SetCb( pfucbIdx->kdfCurr.data.Cb() );
			keyT.suffix.SetPv( pfucbIdx->kdfCurr.data.Pv() );
			pkey = &keyT;
			}
		else
			{
			pkey = &pfucbIdx->kdfCurr.key;
			}
		}
	else if ( fRetrieveFromPrimaryBM )
		{
		//  the key in the primary index is in sync with the secondary
		Assert( pfucbIdx != pfucb );
		Assert( locOnCurBM == pfucb->locLogical );
		pkey = &pfucb->bmCurr.key;
		}
	else
		{
		pkey = &pfucbIdx->bmCurr.key;
		}

	//	If key is text, then can't de-normalise (due to case).
	//	If key may have been truncated, then return code indicating
	//	that retrieve should be from record.  Note that since we
	//	always consume as much keyspace as possible, the key would
	//	only have been truncated if the size of the key is cbKeyMost.
	//	If key is variable/tagged binary and cbVarSegMac specified,
	//	then key may also have been truncated.
	Assert( pkey->Cb() <= cbKeyMost );
	if ( fText
		|| pkey->Cb() == cbKeyMost
		|| ( fBinaryChunks && fVarSegMac ) )
		{
		err = ErrERRCheck( errDIRNoShortCircuit );
		goto ComputeItag;
		}

	dataColumn.SetPv( rgb );
	pfcbTable->EnterDML();
	Assert( pfcbTable->Ptdb() == ptdb );
	Call( ErrRECIRetrieveColumnFromKey( ptdb, pidb, pkey, columnid, &dataColumn ) );
	pfcbTable->LeaveDML();

	Assert( locOnCurBM == pfucbIdx->locLogical );
	if ( fLatched )
		{
		AssertDIRGet( pfucbIdx );
		}

	//	if long value then effect offset
	//
	if ( fLongValue )
		{
		if ( ibGraphic >= dataColumn.Cb() )
			{
			dataColumn.SetCb( 0 );
			}
		else
			{
			dataColumn.DeltaPv( ibGraphic );
			dataColumn.DeltaCb( -ibGraphic );
			}
		}

	//	set return values
	//
	if ( pcbActual )
		*pcbActual = dataColumn.Cb();

	if ( 0 == dataColumn.Cb() )
		{
		//	either NULL, zero-length, or
		//	LV with ibOffset out-of-range
		CallSx( err, JET_wrnColumnNull );
		}
	else
		{
		ULONG	cbReturned;
		if ( dataColumn.Cb() <= cbMax )
			{
			cbReturned = dataColumn.Cb();
			CallS( err );
			}
		else
			{
			cbReturned = cbMax;
			err = ErrERRCheck( JET_wrnBufferTruncated );
			}

		UtilMemCpy( pb, dataColumn.Pv(), (size_t)cbReturned );
		}

ComputeItag:
	if ( errDIRNoShortCircuit == err || ( grbit & JET_bitRetrieveTag ) )
		{
		ERR		errT			= err;
		ULONG	itagSequence	= 1;		// return 1 for non-tagged columns

		Assert( JET_errSuccess == err
			|| JET_wrnColumnNull == err
			|| JET_wrnBufferTruncated == err
			|| errDIRNoShortCircuit == err );

		//	- retrieve keys from record and compare against current key
		//	to compute itag for tagged column instance, responsible for
		//	this index key.
		//	- if column is NULL, then there must only be one itagsequence
		if ( fFirstMultiValued
			&& JET_wrnColumnNull != err )
			{
			keyT.prefix.Nullify();
			keyT.suffix.SetCb( sizeof( rgb ) );
			keyT.suffix.SetPv( rgb );

			if ( fLatched )
				{
				CallR( ErrDIRRelease( pfucbIdx ) );
				fLatched = fFalse;
				}

			Assert( 1 == itagSequence );
			for ( ; ;itagSequence++ )
				{
				Call( ErrRECRetrieveKeyFromRecord(
								pfucb,
								pidb,
								&keyT,
								itagSequence,
								0,
								NULL,
								fFalse ) );
				CallS( ErrRECValidIndexKeyWarning( err ) );
				Assert( wrnFLDOutOfTuples != err );
				Assert( wrnFLDNotPresentInIndex != err );
				if ( wrnFLDOutOfKeys == err )
					{
					//	index entry cannot be formulated from primary record
					err = ErrERRCheck( JET_errSecondaryIndexCorrupted );
					goto HandleError;
					}

				Assert( !fLatched );
				Call( ErrDIRGet( pfucbIdx ) );
				fLatched = fTrue;
				
				if ( FKeysEqual( pfucbIdx->kdfCurr.key, keyT ) )
					break;

				Assert( fLatched );
				Call( ErrDIRRelease( pfucbIdx ) );
				fLatched = fFalse;
				}
			}
			
		*pitagSequence = itagSequence;
			
		err = errT;	
		}

HandleError:
	if ( fLatched )
		{
		Assert( Pcsr( pfucbIdx )->FLatched() );
		CallS( ErrDIRRelease( pfucbIdx ) );
		}
	AssertDIRNoLatch( pfucbIdx->ppib );
	return err;
	}


//  ================================================================
INLINE ERR ErrRECAdjustEscrowedColumn(
	FUCB * 			pfucb,
	const COLUMNID	columnid,
	const ULONG		ibRecordOffset,
	VOID *			pv,
	const INT		cb )
//  ================================================================
//  
//  if this is an escrowed column, get the compensating delta from the version
//  store and apply it to the buffer
//
//-
	{
	//	UNDONE: remove columnid param because it's only
	//	used for DEBUG purposes
	Assert( 0 != columnid );
	Assert( FCOLUMNIDFixed( columnid ) );

	if ( sizeof(LONG) != cb )
		return ErrERRCheck( JET_errInvalidBufferSize );
	
	const LONG	lDelta	= LDeltaVERGetDelta( pfucb, pfucb->bmCurr, ibRecordOffset );
	*(LONG *)pv += lDelta;

	return JET_errSuccess;
	}


ERR VTAPI ErrIsamRetrieveColumn(
	JET_SESID		sesid,
	JET_VTID		vtid,
	JET_COLUMNID	columnid,
	VOID*			pv,
	const ULONG	  	cbMax,
	ULONG*			pcbActual,
	JET_GRBIT		grbit,
	JET_RETINFO*	pretinfo )
	{
	ERR				err;
 	PIB*			ppib				= reinterpret_cast<PIB *>( sesid );
	FUCB*			pfucb				= reinterpret_cast<FUCB *>( vtid );
	DATA*			pdataRec;
	DATA			dataRetrieved;
	ULONG			itagSequence;
	ULONG			ibLVOffset;
	FIELD			fieldFixed;
	BOOL			fScanTagged			= fFalse;
	BOOL			fTransactionStarted	= fFalse;
	BOOL			fSetReturnValue		= fTrue;
	BOOL			fUseCopyBuffer		= fFalse;

	CallR( ErrPIBCheck( ppib ) );
	CheckFUCB( ppib, pfucb );
	AssertDIRNoLatch( ppib );

	//	set ptdb.  ptdb is same for indexes and for sorts.
	//
	Assert( pfucb->u.pfcb->Ptdb() == pfucb->u.pscb->fcb.Ptdb() );
	Assert( pfucb->u.pfcb->Ptdb() != ptdbNil );

	if ( pretinfo != NULL )
		{
		if ( pretinfo->cbStruct < sizeof(JET_RETINFO) )
			return ErrERRCheck( JET_errInvalidParameter );
		ibLVOffset = pretinfo->ibLongValue;
		itagSequence = pretinfo->itagSequence;
		}
	else
		{
		itagSequence = 1;
		ibLVOffset = 0;
		}

	if ( grbit & grbitRetrieveColumnInternalFlagsMask )
		{
		err = ErrERRCheck( JET_errInvalidGrbit );
		return err;
		}

	if ( pfucb->cbstat == fCBSTATInsertReadOnlyCopy )
		{
		grbit = grbit & ~( JET_bitRetrieveFromIndex | JET_bitRetrieveFromPrimaryBookmark );
		}

	if ( ppib->level == 0 )
		{
		// Begin transaction for read consistency (in case page
		// latch must be released in order to validate column).
		CallR( ErrDIRBeginTransaction( ppib, JET_bitTransactionReadOnly ) );
		fTransactionStarted = fTrue;
		}
		
	AssertDIRNoLatch( ppib );

	Assert( FFUCBSort( pfucb ) || FFUCBIndex( pfucb ) );
	
	if ( grbit & ( JET_bitRetrieveFromIndex|JET_bitRetrieveFromPrimaryBookmark ) )
		{
		if ( FFUCBAlwaysRetrieveCopy( pfucb )
			|| FFUCBNeverRetrieveCopy( pfucb ) )
			{
			//	insde a callback, so cannot use RetrieveFromIndex/PrimaryBookmark
			Call( ErrERRCheck( JET_errInvalidGrbit ) );
			}

		err = ErrRECIRetrieveFromIndex(
					pfucb,
					columnid,
					&itagSequence,
					reinterpret_cast<BYTE *>( pv ),
					cbMax,
					pcbActual,
					ibLVOffset,
					grbit );
		
		//	return itagSequence if requested
		//
		if ( pretinfo != NULL
			&& ( grbit & JET_bitRetrieveTag )
			&& ( errDIRNoShortCircuit == err || err >= 0 ) )
			{
			pretinfo->itagSequence = itagSequence;
			}
			
		if ( err != errDIRNoShortCircuit )
			{
			goto HandleError;
		 	}
		}
		
	AssertDIRNoLatch( ppib );

	fieldFixed.ffield = 0;
	if ( 0 != columnid )
		{
		Assert( !fScanTagged );
		Call( ErrRECIAccessColumn( pfucb, columnid, &fieldFixed ) );
		AssertDIRNoLatch( ppib );
		}
	else
		{
		fScanTagged = fTrue;
		}

	fUseCopyBuffer = ( ( ( grbit & JET_bitRetrieveCopy ) && FFUCBUpdatePrepared( pfucb ) && !FFUCBNeverRetrieveCopy( pfucb ) )
						|| FFUCBAlwaysRetrieveCopy( pfucb ) );
		
	Call( ErrRECIGetRecord( pfucb, &pdataRec, fUseCopyBuffer ) );
	
	if ( fScanTagged )
		{
		const ULONG	icolumnToRetrieve	= itagSequence;

		Assert( 0 == columnid );
		if ( 0 == itagSequence )
			{
			//	must use RetrieveColumns() in order to count columns
			err = ErrERRCheck( JET_errBadItagSequence );
			goto HandleError;
			}
			
		Call( ErrRECIScanTaggedColumns(
				pfucb,
				icolumnToRetrieve,
				*pdataRec,
				&dataRetrieved,
				&columnid,
				&itagSequence,
				grbit ) );
		Assert( 0 != columnid || JET_wrnColumnNull == err );
		}
	else if ( FCOLUMNIDTagged( columnid ) )
		{
		Call( ErrRECRetrieveTaggedColumn(
				pfucb->u.pfcb,
				columnid,
				itagSequence,
				*pdataRec,
				&dataRetrieved,
				grbit ) );
		}
	else
		{
		Call( ErrRECRetrieveNonTaggedColumn(
				pfucb->u.pfcb,
				columnid,
				*pdataRec,
				&dataRetrieved,
				&fieldFixed ) );
		}

	if ( wrnRECUserDefinedDefault == err )
		{
		Assert( FCOLUMNIDTagged( columnid ) );
		Assert( dataRetrieved.Cb() == 0 );

		if ( Pcsr( pfucb )->FLatched() )
			{
			CallS( ErrDIRRelease( pfucb ) );
			}

		const BOOL fAlwaysRetrieveCopy 	= FFUCBAlwaysRetrieveCopy( pfucb );
		const BOOL fNeverRetrieveCopy	= FFUCBNeverRetrieveCopy( pfucb );

		Assert( !( fAlwaysRetrieveCopy && fNeverRetrieveCopy ) );
		
		if( fUseCopyBuffer )
			{
			FUCBSetAlwaysRetrieveCopy( pfucb );
			}
		else
			{
			FUCBSetNeverRetrieveCopy( pfucb );
			}
			
		*pcbActual = cbMax;
		err =  ErrRECCallback(
					ppib,		
					pfucb,
					JET_cbtypUserDefinedDefaultValue,
					columnid,
					pv,
					(VOID *)pcbActual,
					columnid );
		if( JET_errSuccess == err && *pcbActual > cbMax )
			{
			//  the callback function may not set this correctly.
			err = ErrERRCheck( JET_wrnBufferTruncated );
			}

		FUCBResetAlwaysRetrieveCopy( pfucb );
		FUCBResetNeverRetrieveCopy( pfucb );

		if( fAlwaysRetrieveCopy )
			{
			FUCBSetAlwaysRetrieveCopy( pfucb );
			}
		else if( fNeverRetrieveCopy )
			{
			FUCBSetNeverRetrieveCopy( pfucb );
			}

		Call( err );
		
		fSetReturnValue = fFalse;
		}

	else
		{
		Assert( wrnRECLongField != err );		//	obsolete error code
		switch ( err )
			{
			case wrnRECSeparatedSLV:
			case wrnRECIntrinsicSLV:
				{
				DATA	dataRetrieveBuffer;
				dataRetrieveBuffer.SetCb( cbMax );
				dataRetrieveBuffer.SetPv( pv );
		
				Call( ErrSLVRetrieveColumn(
							pfucb,
							columnid,
							itagSequence,
							( wrnRECSeparatedSLV == err ),
							ibLVOffset,
							grbit,
							dataRetrieved,
							&dataRetrieveBuffer,
							pcbActual ) );
				fSetReturnValue = fFalse;
				break;
				}
			case wrnRECSeparatedLV:
				{
				//  If we are retrieving an after-image or
				//	haven't replaced a LV we can simply go
				//	to the LV tree. Otherwise we have to
				//	perform a more detailed consultation of
				//	the version store with ErrRECGetLVImage
				const BOOL fAfterImage = fUseCopyBuffer
										|| !FFUCBUpdateSeparateLV( pfucb )
										|| !FFUCBReplacePrepared( pfucb );
				Call( ErrRECIRetrieveSeparatedLongValue(
						pfucb,
						dataRetrieved,
						fAfterImage,
						ibLVOffset,
						pv,
						cbMax,
						pcbActual,
						grbit ) );
				fSetReturnValue = fFalse;
				break;
				}

			case wrnRECIntrinsicLV:
				if ( ibLVOffset >= dataRetrieved.Cb() )
					dataRetrieved.SetCb( 0 );
				else
					{
					dataRetrieved.DeltaPv( ibLVOffset );
					dataRetrieved.DeltaCb( -ibLVOffset );
					}
				err = JET_errSuccess;
				break;
			case JET_wrnColumnSetNull:
				Assert( fScanTagged );
				break;
			default:
				CallSx( err, JET_wrnColumnNull );
			}
		}

	//	these should have been handled and mapped
	//	to an appropriate return value
	Assert( wrnRECUserDefinedDefault != err );
	Assert( wrnRECSeparatedLV != err );
	Assert( wrnRECIntrinsicLV != err );
	Assert( wrnRECSeparatedSLV != err );
	Assert( wrnRECIntrinsicSLV != err );

	//** Set return values **
	if ( fSetReturnValue )
		{
		ULONG	cbCopy;
		BYTE	rgb[8];
		
		if ( 0 != columnid && dataRetrieved.Cb() <= 8 && dataRetrieved.Cb() && !FHostIsLittleEndian() )
			{
			Assert( dataRetrieved.Pv() );
			
			//	Depends on coltyp, we may need to reverse the bytes
			JET_COLTYP coltyp = ColtypFromColumnid( pfucb, columnid );
			if ( coltyp == JET_coltypShort )
				{
			 	*(USHORT*)rgb = ReverseBytesOnBE( *(USHORT*)dataRetrieved.Pv() );
				dataRetrieved.SetPv( rgb );
				}
			else if ( coltyp == JET_coltypLong ||
					  coltyp == JET_coltypIEEESingle )
				{
				*(ULONG*)rgb = ReverseBytesOnBE( *(ULONG*)dataRetrieved.Pv() );
				dataRetrieved.SetPv( rgb );
				}
			else if ( coltyp == JET_coltypCurrency	||
					  coltyp == JET_coltypIEEEDouble	||
				 	  coltyp == JET_coltypDateTime )
				{
				*(QWORD*)rgb = ReverseBytesOnBE( *(QWORD*)dataRetrieved.Pv() );
				dataRetrieved.SetPv( rgb );
				}
			}

		if ( pcbActual )
			*pcbActual = dataRetrieved.Cb();

		if ( dataRetrieved.Cb() <= cbMax )
			{
			cbCopy = dataRetrieved.Cb();
			}
		else
			{
			cbCopy = cbMax;
			err = ErrERRCheck( JET_wrnBufferTruncated );
			}

		if ( cbCopy )
			UtilMemCpy( pv, dataRetrieved.Pv(), cbCopy );

		//  if we are inserting a new record there can't be any versions on the 
		//  escrow column. we also don't know the bookmark of the new record yet...
		if ( FFIELDEscrowUpdate( fieldFixed.ffield ) && !FFUCBInsertPrepared( pfucb ) )
			{
			const ERR	errT	= ErrRECAdjustEscrowedColumn(
										pfucb,
										columnid,
										fieldFixed.ibRecordOffset,
										pv,
										cbCopy );
			if ( errT < 0 )
				{
				Call( errT );
				}
			}
		}
	
	if ( pretinfo != NULL )
		pretinfo->columnidNextTagged = columnid;

HandleError:
	if ( Pcsr( pfucb )->FLatched() )
		{
		ERR errT;
		Assert( !fUseCopyBuffer );
		errT = ErrDIRRelease( pfucb );
		CallSx( errT, JET_errOutOfMemory );
		if ( errT < JET_errSuccess && err >= JET_errSuccess )
			{
			err = errT;
			}
		}
		
	if ( fTransactionStarted )
		{
		//	No updates performed, so force success.
		CallS( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );
		}

	AssertDIRNoLatch( ppib );
	return err;
	}


INLINE VOID RECICountColumn(
	FCB				*pfcb,
	const COLUMNID	columnid,
	const DATA&		dataRec,
	ULONG			*pulNumOccurrences )
	{
	Assert( 0 != columnid );

	if ( FCOLUMNIDTagged( columnid ) )
		{
		*pulNumOccurrences = UlRECICountTaggedColumnInstances(
					pfcb,
					columnid,
					dataRec );
		}
	else
		{
		ERR		errT;
		BOOL	fNull;
		
		if ( FCOLUMNIDTemplateColumn( columnid ) && !pfcb->FTemplateTable() )
			{
			if ( !pfcb->FTemplateTable() )
				{
				pfcb->Ptdb()->AssertValidDerivedTable();
				pfcb = pfcb->Ptdb()->PfcbTemplateTable();
				}
			else
				{
				pfcb->Ptdb()->AssertValidTemplateTable();
				}
			}

		if ( FCOLUMNIDFixed( columnid ) )
			{
			//	columnid should already have been validated
			Assert( FidOfColumnid( columnid ) >= pfcb->Ptdb()->FidFixedFirst() );
			Assert( FidOfColumnid( columnid ) <= pfcb->Ptdb()->FidFixedLast() );
				
			errT = ErrRECIFixedColumnInRecord( columnid, pfcb, dataRec );

			if ( JET_errColumnNotFound == errT )
				{
				// Column not in record -- it's null if there's no default value.
				const TDB * const	ptdb	= pfcb->Ptdb();
				if ( FidOfColumnid( columnid ) > ptdb->FidFixedLastInitial() )
					{
					pfcb->EnterDML();
					fNull = !FFIELDDefault( ptdb->PfieldFixed( columnid )->ffield );
					pfcb->LeaveDML();
					}
				else
					{
					fNull = !FFIELDDefault( ptdb->PfieldFixed( columnid )->ffield );
					}
				}
			else
				{
				CallSx( errT, JET_wrnColumnNull );
				fNull = ( JET_wrnColumnNull == errT );
				}
			}
		else
			{
			Assert( FCOLUMNIDVar( columnid ) );

			//	columnid should already have been validated
			Assert( FidOfColumnid( columnid ) >= pfcb->Ptdb()->FidVarFirst() );
			Assert( FidOfColumnid( columnid ) <= pfcb->Ptdb()->FidVarLast() );
			
			errT = ErrRECIVarColumnInRecord( columnid, pfcb, dataRec );
						
			if ( JET_errColumnNotFound == errT )
				{
				// Column not in record -- it's null if there's no default value.
				const TDB * const	ptdb	= pfcb->Ptdb();
				if ( FidOfColumnid( columnid ) > ptdb->FidVarLastInitial() )
					{
					pfcb->EnterDML();
					fNull = !FFIELDDefault( ptdb->PfieldVar( columnid )->ffield );
					pfcb->LeaveDML();
					}
				else
					{
					fNull = !FFIELDDefault( ptdb->PfieldVar( columnid )->ffield );
					}
				}
			else
				{
				CallSx( errT, JET_wrnColumnNull );
				fNull = ( JET_wrnColumnNull == errT );
				}
			}

		*pulNumOccurrences = ( fNull ? 0 : 1 );
		}
	}


LOCAL ERR ErrRECRetrieveColumns(
	FUCB				*pfucb,
	JET_RETRIEVECOLUMN	*pretcol,
	ULONG				cretcol,
	BOOL				*pfBufferTruncated )
	{
	ERR					err;
	const DATA			* pdataRec;

	Assert( !( FFUCBAlwaysRetrieveCopy( pfucb ) && FFUCBNeverRetrieveCopy( pfucb ) ) );
			
	//	set ptdb, ptdb is same for indexes and for sorts
	//
	Assert( pfucb->u.pfcb->Ptdb() == pfucb->u.pscb->fcb.Ptdb() );
	Assert( pfucb->u.pfcb->Ptdb() != ptdbNil );
	AssertDIRNoLatch( pfucb->ppib );

	*pfBufferTruncated = fFalse;

	//	get current data
	//
	if ( FFUCBSort( pfucb ) )
		{
		//	sorts always have current data cached.
		if ( pfucb->locLogical != locOnCurBM )
			{
			Assert( locBeforeFirst == pfucb->locLogical
				|| locAfterLast == pfucb->locLogical );
			Call( ErrERRCheck( JET_errNoCurrentRecord ) );
			}
		else
			{
			Assert( pfucb->kdfCurr.data.Cb() != 0 );
			}

		pdataRec = &pfucb->kdfCurr.data;
		}

	for ( ULONG i = 0; i < cretcol; i++ )
		{
		// efficiency variables
		//
		JET_RETRIEVECOLUMN	* pretcolT		= pretcol + i;
		JET_GRBIT			grbit			= pretcolT->grbit;
		COLUMNID			columnid		= pretcolT->columnid;
		FIELD				fieldFixed;
		DATA 				dataRetrieved;
		BOOL				fSetReturnValue = fTrue;

		fieldFixed.ffield = 0;

		if ( grbit & grbitRetrieveColumnInternalFlagsMask )
			{
			Call( ErrERRCheck( JET_errInvalidGrbit ) );
			}

		if ( pfucb->cbstat == fCBSTATInsertReadOnlyCopy )
			{
			grbit = grbit & ~( JET_bitRetrieveFromIndex | JET_bitRetrieveFromPrimaryBookmark );
			}

		if ( FFUCBIndex( pfucb ) )
			{
			// UNDONE: No copy buffer with sorts, and don't currently support
			// secondary indexes with sorts, so RetrieveFromIndex reduces to
			// a record retrieval.
			if ( grbit & ( JET_bitRetrieveFromIndex|JET_bitRetrieveFromPrimaryBookmark ) )
				{
				if ( Pcsr( pfucb )->FLatched() )
					{
					Call( ErrDIRRelease( pfucb ) );
					}

				if ( FFUCBAlwaysRetrieveCopy( pfucb )
					|| FFUCBNeverRetrieveCopy( pfucb ) )
					{
					//	insde a callback, so cannot use RetrieveFromIndex/PrimaryBookmark
					Call( ErrERRCheck( JET_errInvalidGrbit ) );
					}

				err = ErrRECIRetrieveFromIndex(
							pfucb,
							columnid,
							&pretcolT->itagSequence,
							reinterpret_cast<BYTE *>( pretcolT->pvData ),
							pretcolT->cbData,
							&pretcolT->cbActual,
							pretcolT->ibLongValue,
							grbit );
						AssertDIRNoLatch( pfucb->ppib );

				if ( errDIRNoShortCircuit == err )
					{
					//	UNDONE: this is EXTREMELY expensive because we
					//	will go to the record and formulate all keys
					//	for the record to try to determine the itagSequence
					//	of the current index entry
					Assert( pretcolT->itagSequence > 0 );
					}
				else
					{
					if ( err < 0 )
						goto HandleError;

					pretcolT->columnidNextTagged = columnid;
					pretcolT->err = err;
					if ( JET_wrnBufferTruncated == err )
						*pfBufferTruncated = fTrue;
								
					continue;
					}
				}
					
			if ( ( ( grbit & JET_bitRetrieveCopy ) && FFUCBUpdatePrepared( pfucb ) && !FFUCBNeverRetrieveCopy( pfucb ) )
				|| FFUCBAlwaysRetrieveCopy( pfucb ) )
				{
				//	if we obtained the latch on a previous pass,
				//	we don't relinquish it because we want to
				//	avoid excessive latching/unlatching
				Assert( !Pcsr( pfucb )->FLatched()
					|| !FFUCBAlwaysRetrieveCopy( pfucb ) );
				pdataRec = &pfucb->dataWorkBuf;
				}
			else
				{
				if ( !Pcsr( pfucb )->FLatched() )
					{
					Call( ErrDIRGet( pfucb ) );
					}
				pdataRec = &pfucb->kdfCurr.data;
				}
			}
		else
			{
			Assert( FFUCBSort( pfucb ) );
			Assert( pdataRec == &pfucb->kdfCurr.data );
			Assert( !Pcsr( pfucb )->FLatched() );
			}


		ULONG	itagSequence	= pretcolT->itagSequence;

		if ( 0 == columnid )
			{
			if ( 0 == itagSequence )		// Are we counting all tagged columns?
				{
				Call( ErrRECIScanTaggedColumns(
						pfucb,
						0,
						*pdataRec,
						&dataRetrieved,
						&columnid,
						&pretcolT->itagSequence,	// Store count in itagSequence
						grbit ) );
				Assert( 0 == columnid );
				Assert( JET_wrnColumnNull == err );
				pretcolT->cbActual = 0;
				pretcolT->columnidNextTagged = 0;
				pretcolT->err = JET_errSuccess;
				continue;
				}
			else
				{
				Call( ErrRECIScanTaggedColumns(
						pfucb,
						pretcolT->itagSequence,
						*pdataRec,
						&dataRetrieved,
						&columnid,
						&itagSequence,
						grbit ) );
				Assert( 0 != columnid || JET_wrnColumnNull == err );
				}
			}
		else
			{
			// Verify column is accessible and that we're in a transaction
			// (for read consistency).
			Assert( pfucb->ppib->level > 0 );
			Call( ErrRECIAccessColumn( pfucb, columnid, &fieldFixed ) );
			
			if ( 0 == itagSequence )
				{
				RECICountColumn(
						pfucb->u.pfcb,
						columnid,
						*pdataRec,
						&pretcolT->itagSequence );	// Store count in itagSequence
				pretcolT->cbActual = 0;
				pretcolT->columnidNextTagged = columnid;
				pretcolT->err = JET_errSuccess;
				continue;
				}
			else if ( FCOLUMNIDTagged( columnid ) )
				{
				Call( ErrRECRetrieveTaggedColumn(
						pfucb->u.pfcb,
						columnid,
						itagSequence,
						*pdataRec,
						&dataRetrieved,
						grbit ) );
				}
			else
				{
				Call( ErrRECRetrieveNonTaggedColumn(
						pfucb->u.pfcb,
						columnid,
						*pdataRec,
						&dataRetrieved,
						&fieldFixed ) );
				}
			}

		if ( wrnRECUserDefinedDefault == err )
			{
			Assert( FCOLUMNIDTagged( columnid ) );
			Assert( dataRetrieved.Cb() == 0 );

			if ( Pcsr( pfucb )->FLatched() )
				{
				Call( ErrDIRRelease( pfucb ) );
				}

			Assert( pretcolT->columnid == columnid );
			
			VOID * const pvArg1 = pretcolT->pvData;
			pretcolT->cbActual = pretcolT->cbData;
			VOID * const pvArg2 = &(pretcolT->cbActual);

			const BOOL fAlwaysRetrieveCopy 	= FFUCBAlwaysRetrieveCopy( pfucb );
			const BOOL fNeverRetrieveCopy	= FFUCBNeverRetrieveCopy( pfucb );

			Assert( !( fAlwaysRetrieveCopy && fNeverRetrieveCopy ) );

			if( ( ( grbit & JET_bitRetrieveCopy) || FFUCBAlwaysRetrieveCopy( pfucb ) )
				&& FFUCBUpdatePrepared( pfucb ) )
				{
				FUCBSetAlwaysRetrieveCopy( pfucb );
				}
			else
				{
				FUCBSetNeverRetrieveCopy( pfucb );
				}

			err = ErrRECCallback(
						pfucb->ppib,		
						pfucb,
						JET_cbtypUserDefinedDefaultValue,
						columnid,
						pvArg1,
						pvArg2,
						columnid );
			if( JET_errSuccess == err && pretcolT->cbActual > pretcolT->cbData )
				{
				//  the callback function may not set this correctly.
				err = ErrERRCheck( JET_wrnBufferTruncated );
				}

			FUCBResetAlwaysRetrieveCopy( pfucb );
			FUCBResetNeverRetrieveCopy( pfucb );

			if( fAlwaysRetrieveCopy )
				{
				FUCBSetAlwaysRetrieveCopy( pfucb );
				}
			else if ( fNeverRetrieveCopy )
				{
				FUCBSetNeverRetrieveCopy( pfucb );
				}
				
			Call( err );
			
			pretcolT->err = err;
			fSetReturnValue = fFalse;

			Assert( !Pcsr( pfucb )->FLatched() );
			}

		else
			{
			Assert( wrnRECLongField != err );		//	obsolete error code

			switch ( err )
				{
				case wrnRECSeparatedSLV:
				case wrnRECIntrinsicSLV:
					{
					DATA	dataRetrieveBuffer;
					dataRetrieveBuffer.SetCb( pretcolT->cbData );
					dataRetrieveBuffer.SetPv( pretcolT->pvData );
				
					Call( ErrSLVRetrieveColumn(
								pfucb,
								columnid,
								itagSequence,
								( wrnRECSeparatedSLV == err ),
								pretcolT->ibLongValue,
								grbit,
								dataRetrieved,
								&dataRetrieveBuffer,
								&pretcolT->cbActual ) );

					pretcolT->err = err;
					fSetReturnValue = fFalse;
					break;
					}
				case wrnRECSeparatedLV:
					{
					//  If we are retrieving a copy, go ahead
					//	and do a normal retrieval. Otherwise
					//	we have to consult the version store
					const BOOL fRetrieveBeforeImage = 
						( FFUCBNeverRetrieveCopy( pfucb ) || !( grbit & JET_bitRetrieveCopy ) ) 
						&& FFUCBReplacePrepared( pfucb )
						&& FFUCBUpdateSeparateLV( pfucb )
						&& !FFUCBAlwaysRetrieveCopy( pfucb );
			
					Call( ErrRECIRetrieveSeparatedLongValue(
								pfucb,
								dataRetrieved,
								!fRetrieveBeforeImage,
								pretcolT->ibLongValue,
								pretcolT->pvData,
								pretcolT->cbData,
								&pretcolT->cbActual,
								grbit ) );
					pretcolT->err = err;
					fSetReturnValue = fFalse;
					break;
					}

				case wrnRECIntrinsicLV:
					if ( pretcolT->ibLongValue >= dataRetrieved.Cb() )
						dataRetrieved.SetCb( 0 );
					else
						{
						dataRetrieved.DeltaPv( pretcolT->ibLongValue );
						dataRetrieved.DeltaCb( -( pretcolT->ibLongValue ) );
						}
					err = JET_errSuccess;
					break;
				case JET_wrnColumnSetNull:
					Assert( 0 == pretcolT->columnid );
					break;
				default:
					CallSx( err, JET_wrnColumnNull );
				}
			}

		//	these should have been handled and mapped
		//	to an appropriate return value
		Assert( wrnRECUserDefinedDefault != err );
		Assert( wrnRECSeparatedLV != err );
		Assert( wrnRECIntrinsicLV != err );
		Assert( wrnRECSeparatedSLV != err );
		Assert( wrnRECIntrinsicSLV != err );

		if ( fSetReturnValue )
			{
			ULONG	cbCopy;
			BYTE	rgb[8];
		
			if ( 0 != columnid && dataRetrieved.Cb() <= 8 && dataRetrieved.Cb() && !FHostIsLittleEndian() )
				{
				Assert( dataRetrieved.Pv() );
				
				//	Depends on coltyp, we may need to reverse the bytes
				JET_COLTYP coltyp = ColtypFromColumnid( pfucb, columnid );
				if ( coltyp == JET_coltypShort )
					 {
					 *(USHORT*)rgb = ReverseBytesOnBE( *(USHORT*)dataRetrieved.Pv() );
					 dataRetrieved.SetPv( rgb );
					 }
				else if ( coltyp == JET_coltypLong ||
						  coltyp == JET_coltypIEEESingle )
					 {
					 *(ULONG*)rgb = ReverseBytesOnBE( *(ULONG*)dataRetrieved.Pv() );
					 dataRetrieved.SetPv( rgb );
					 }
				else if ( coltyp == JET_coltypCurrency	||
						  coltyp == JET_coltypIEEEDouble	||
					 	  coltyp == JET_coltypDateTime )
					 {
					 *(QWORD*)rgb = ReverseBytesOnBE( *(QWORD*)dataRetrieved.Pv() );
					 dataRetrieved.SetPv( rgb );
					 }
				}

			pretcolT->cbActual = dataRetrieved.Cb();

			if ( dataRetrieved.Cb() <= pretcolT->cbData )
				{
				pretcolT->err = err;
				cbCopy = dataRetrieved.Cb();
				}
			else
				{
				pretcolT->err = ErrERRCheck( JET_wrnBufferTruncated );
				cbCopy = pretcolT->cbData;
				}

			UtilMemCpy( pretcolT->pvData, dataRetrieved.Pv(), cbCopy );

			//  if we are inserting a new record there can't be any versions on the 
			//  escrow column. we also don't know the bookmark of the new record yet...
			if ( FFIELDEscrowUpdate( fieldFixed.ffield ) && !FFUCBInsertPrepared( pfucb ) )
				{
				const ERR	errT	= ErrRECAdjustEscrowedColumn(
											pfucb,
											columnid,
											fieldFixed.ibRecordOffset,
											pretcolT->pvData,
											cbCopy );
				//	only assign to err if there was an error
				if ( errT < 0 )
					{
					Call( errT );
					}
				}
			}

		pretcolT->columnidNextTagged = columnid;

		if ( JET_wrnBufferTruncated == pretcolT->err )
			*pfBufferTruncated = fTrue;

		Assert( pretcolT->err != JET_errNullInvalid );
		}	// for

	err = JET_errSuccess;

HandleError:
	if ( Pcsr( pfucb )->FLatched() )
		{
		CallS( ErrDIRRelease( pfucb ) );
		}
		
	AssertDIRNoLatch( pfucb->ppib );

	return err;
	}

ERR VTAPI ErrIsamRetrieveColumns(
	JET_SESID				vsesid,
	JET_VTID				vtid,
	JET_RETRIEVECOLUMN		*pretcol,
	ULONG					cretcol )
	{
	ERR						err;
	PIB						*ppib				= (PIB *)vsesid;
	FUCB					*pfucb				= (FUCB *)vtid;
	BOOL					fBufferTruncated;
	BOOL					fTransactionStarted = fFalse;

	CallR( ErrPIBCheck( ppib ) );
	CheckFUCB( ppib, pfucb );
	AssertDIRNoLatch( ppib );

	if ( 0 == ppib->level )
		{
		// Begin transaction for read consistency (in case page
		// latch must be released in order to validate column).
		Call( ErrDIRBeginTransaction( ppib, JET_bitTransactionReadOnly ) );
		fTransactionStarted = fTrue;
		}
		
	AssertDIRNoLatch( ppib );
	Assert( FFUCBSort( pfucb ) || FFUCBIndex( pfucb ) );

	Call( ErrRECRetrieveColumns(
				pfucb,
				pretcol,
				cretcol,
				&fBufferTruncated ) );
	if ( fBufferTruncated )
		err = ErrERRCheck( JET_wrnBufferTruncated );

HandleError:
	if ( fTransactionStarted )
		{
		//	No updates performed, so force success.
		CallS( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );
		}
	AssertDIRNoLatch( ppib );

	return err;
	}


INLINE VOID RECIAddTaggedColumnListEntry(
	TAGCOLINFO					* const ptagcolinfo,
	const TAGFIELDS_ITERATOR	* const piterator,
	const TDB					* const ptdb,
	const BOOL					fDefaultValue )
	{
	const BOOL			fDerived	= ( piterator->FDerived()
										|| ( ptdb->FESE97DerivedTable()
											&& piterator->Fid() < ptdb->FidTaggedFirst() ) );

	ptagcolinfo->columnid			= piterator->Columnid( ptdb );
	ptagcolinfo->cMultiValues		= static_cast<USHORT>( piterator->TagfldIterator().Ctags() );				
	ptagcolinfo->usFlags			= 0;
	ptagcolinfo->fLongValue			= USHORT( piterator->FLV() ? fTrue : fFalse );
	ptagcolinfo->fDefaultValue		= USHORT( fDefaultValue ? fTrue : fFalse );
	ptagcolinfo->fNullOverride		= USHORT( piterator->FNull() ? fTrue : fFalse );
	ptagcolinfo->fDerived			= USHORT( fDerived ? fTrue : fFalse );
	}


LOCAL ERR ErrRECIBuildTaggedColumnList(
	FUCB				* const pfucb,
	const DATA&			dataRec,
	TAGCOLINFO			* const rgtagcolinfo,
	ULONG				* const pcentries,
	const ULONG			centriesMax,
	const JET_COLUMNID	columnidStart,
	const JET_GRBIT		grbit )
	{
	ERR					err = JET_errSuccess;
	
	FCB					* const pfcb		= pfucb->u.pfcb;
	TDB					* const ptdb		= pfcb->Ptdb();
	
	const BOOL			fCountOnly			= ( NULL == rgtagcolinfo );
	const BOOL			fRetrieveNulls		= ( grbit & JET_bitRetrieveNull );
	const BOOL			fRetrieveDefaults	= ( !( grbit & JET_bitRetrieveIgnoreDefault )
												&& ptdb->FTableHasNonEscrowDefault() );
	
	const BOOL			fNeedToRefresh		= ( dataRec.Pv() == pfucb->kdfCurr.data.Pv() );

	INT centriesCurr = 0;

	TAGFIELDS_ITERATOR * precordIterator		= NULL;
	TAGFIELDS_ITERATOR * pdefaultValuesIterator	= NULL;

	VOID * pvBuf	= NULL;

	//	initialize return values

	*pcentries = 0;

	//	create the iterators
		
	precordIterator = new TAGFIELDS_ITERATOR( dataRec );
	if( NULL == precordIterator )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		goto HandleError;
		}
	precordIterator->MoveBeforeFirst();
	if( JET_errNoCurrentRecord == ( err = precordIterator->ErrMoveNext() ) )
		{
		//	no tagged columns;
		delete precordIterator;
		precordIterator = NULL;
		err = JET_errSuccess;
		}
	Call( err );

	if( fRetrieveDefaults )
		{
		pdefaultValuesIterator = new TAGFIELDS_ITERATOR( *ptdb->PdataDefaultRecord() );
		if( NULL == pdefaultValuesIterator )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		pdefaultValuesIterator->MoveBeforeFirst();
		if( JET_errNoCurrentRecord == ( err = pdefaultValuesIterator->ErrMoveNext() ) )
			{
			//	no tagged columns;
			delete pdefaultValuesIterator;
			pdefaultValuesIterator = NULL;
			err = JET_errSuccess;
			}
		Call( err );
		}

	//	if necessary, advance to starting column
	
	if ( FTaggedFid( (FID)columnidStart ) )		//	can't use FCOLUMNIDTagged() because it assumes a valid columnid
		{
		if ( precordIterator )
			{
			while( CmpFid(
					precordIterator->Fid(),
					precordIterator->FDerived(),
					FidOfColumnid( columnidStart ),
					FRECUseDerivedBit( columnidStart, ptdb ) ) < 0 )
				{
				if( JET_errNoCurrentRecord == ( err = precordIterator->ErrMoveNext() ) )
					{
					delete precordIterator;
					precordIterator = NULL;			
					err = JET_errSuccess;
					break;
					}
				Call( err );
				}
			}

		if ( pdefaultValuesIterator )
			{
			while( CmpFid(
					pdefaultValuesIterator->Fid(),
					pdefaultValuesIterator->FDerived(),
					FidOfColumnid( columnidStart ),
					FRECUseDerivedBit( columnidStart, ptdb ) ) < 0 )
				{
				if( JET_errNoCurrentRecord == ( err = pdefaultValuesIterator->ErrMoveNext() ) )
					{
					delete pdefaultValuesIterator;
					pdefaultValuesIterator = NULL;			
					err = JET_errSuccess;
					break;
					}
				Call( err );
				}
			}
		}

	//	iterate

	TAGFIELDS_ITERATOR *pIteratorCur;
	INT ExistingIterators;
	FID fidRecordFID;
	BOOL fRecordDerived;
	FID fidDefaultFID;
	BOOL fDefaultDerived;
	INT cmp;
	
	pIteratorCur = NULL;
	ExistingIterators = 0;
	if ( NULL != pdefaultValuesIterator )
		{
		ExistingIterators++;
		pIteratorCur = pdefaultValuesIterator;
		cmp = 1;
		}
	if ( NULL != precordIterator )
		{
		ExistingIterators++;
		pIteratorCur = precordIterator;
		cmp = -1;
		// we have both iterators, assume that we were starting with recordIterator
		if ( 2 == ExistingIterators )
			{
			fidRecordFID = 0;
			fRecordDerived = fFalse;
			fidDefaultFID = pdefaultValuesIterator->Fid();
			fDefaultDerived = pdefaultValuesIterator->FDerived();
			}
		}

	while ( ExistingIterators > 0 )
		{
		if ( 2 == ExistingIterators )
			{
			if ( pIteratorCur == precordIterator )
				{
				fidRecordFID = pIteratorCur->Fid();
				fRecordDerived = pIteratorCur->FDerived();
				if ( 0 == cmp )
					{
					// skip this because we've alread picked up this column from record
					pIteratorCur = pdefaultValuesIterator;
					goto NextIteration;
					}
				}
			else
				{
				Assert( pIteratorCur == pdefaultValuesIterator );
				fidDefaultFID = pIteratorCur->Fid();
				fDefaultDerived = pIteratorCur->FDerived();
				}
			//	there are both record and default tagged column values
			//	find which one is first
			cmp = CmpFid( fidRecordFID, fRecordDerived, fidDefaultFID, fDefaultDerived );
			if ( cmp > 0 )
				{
				//	the column is less than the current column in the record
				pIteratorCur = pdefaultValuesIterator;
				}
			else 
				{
				//	columns are equal or the default value is greater
				//	select the one in the record
				pIteratorCur = precordIterator;
				}
			}
			
		err = ErrRECIAccessColumn(
					pfucb,
					pIteratorCur->Columnid( ptdb ) );
		if ( err < 0 )
			{
			if ( JET_errColumnNotFound != err )
				{
				Call( err );
				}
			}
		else
			{
			//	column is visible to us
			if( !fCountOnly )
				{
				RECIAddTaggedColumnListEntry(
					rgtagcolinfo + centriesCurr,
					pIteratorCur,
					ptdb,
					fFalse );
				}
			++centriesCurr;
			if( centriesMax == centriesCurr )
				{
				break;
				}							
			}

NextIteration:
		err = pIteratorCur->ErrMoveNext();
		if ( JET_errNoCurrentRecord == err )
			{
			ExistingIterators--;
			if ( pIteratorCur == precordIterator )
				{
				pIteratorCur = pdefaultValuesIterator;
				if ( 0 == cmp )
					{
					goto NextIteration;
					}
				}
			else
				{
				Assert( pIteratorCur == pdefaultValuesIterator );
				pIteratorCur = precordIterator;
				}
			err = JET_errSuccess;
			}
		Call( err );
		CallS( err );
		}
	CallS( err );
	*pcentries = centriesCurr;

HandleError:
	if ( NULL != precordIterator )
		{
		delete precordIterator;
		}
	if ( NULL != pdefaultValuesIterator )
		{
		delete pdefaultValuesIterator;
		}

	return err;
	}

ERR VTAPI ErrIsamRetrieveTaggedColumnList(
	JET_SESID			vsesid,
	JET_VTID			vtid,
	ULONG				*pcentries,
	VOID				*pv,
	const ULONG			cbMax,
	const JET_COLUMNID	columnidStart,
	const JET_GRBIT		grbit )
	{
	ERR					err;
 	PIB					*ppib				= reinterpret_cast<PIB *>( vsesid );
	FUCB				*pfucb				= reinterpret_cast<FUCB *>( vtid );
	DATA				*pdataRec;
	BOOL				fTransactionStarted	= fFalse;

	CallR( ErrPIBCheck( ppib ) );
	CheckFUCB( ppib, pfucb );
	AssertDIRNoLatch( ppib );

	//	must always provide facility to return number of entries in the list
	if ( NULL == pcentries )
		{
		err = ErrERRCheck( JET_errInvalidParameter );
		return err;
		}

	//	set ptdb.  ptdb is same for indexes and for sorts.
	//
	Assert( pfucb->u.pfcb->Ptdb() == pfucb->u.pscb->fcb.Ptdb() );
	Assert( pfucb->u.pfcb->Ptdb() != ptdbNil );

	if ( 0 == ppib->level )
		{
		// Begin transaction for read consistency (in case page
		// latch must be released in order to validate column).
		CallR( ErrDIRBeginTransaction( ppib, JET_bitTransactionReadOnly ) );
		fTransactionStarted = fTrue;
		}
		
	AssertDIRNoLatch( ppib );

	Assert( FFUCBSort( pfucb ) || FFUCBIndex( pfucb ) );

	const BOOL	fUseCopyBuffer	= ( ( ( grbit & JET_bitRetrieveCopy ) && FFUCBUpdatePrepared( pfucb ) && !FFUCBNeverRetrieveCopy( pfucb ) )
									|| FFUCBAlwaysRetrieveCopy( pfucb ) );

	Call( ErrRECIGetRecord( pfucb, &pdataRec, fUseCopyBuffer ) );

	Call( ErrRECIBuildTaggedColumnList(
				pfucb,
				*pdataRec,
				reinterpret_cast<TAGCOLINFO *>( pv ),
				pcentries,
				cbMax / sizeof(TAGCOLINFO),
				columnidStart,
				grbit ) );

HandleError:
	if ( Pcsr( pfucb )->FLatched() )
		{
		Assert( !fUseCopyBuffer );
		CallS( ErrDIRRelease( pfucb ) );
		}
		
	if ( fTransactionStarted )
		{
		//	No updates performed, so force success.
		CallS( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );
		}

	AssertDIRNoLatch( ppib );

	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\info.cxx ===
#include "std.hxx"


/*	local data types
/**/

typedef struct						/* returned by INFOGetTableColumnInfo */
	{
	JET_COLUMNID	columnid;
	JET_COLTYP		coltyp;
	USHORT			wCountry;
	LANGID			langid;
	USHORT			cp;
	USHORT			wCollate;
	ULONG			cbMax;
	JET_GRBIT		grbit;
	ULONG			cbDefault;
	BYTE			*pbDefault;
	CHAR			szName[JET_cbNameMost + 1];
	} INFOCOLUMNDEF;


/* Static data for ErrIsamGetObjectInfo */

CODECONST( JET_COLUMNDEF ) rgcolumndefGetObjectInfo[] =
	{
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, JET_bitColumnTTKey },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, JET_bitColumnTTKey },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypDateTime, 0, 0, 0, 0, 0, JET_bitColumnFixed },	//  XXX -- to be deleted
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypDateTime, 0, 0, 0, 0, 0, JET_bitColumnFixed },	//  XXX -- to be deleted
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed }
	};

const ULONG ccolumndefGetObjectInfoMax	= ( sizeof(rgcolumndefGetObjectInfo) / sizeof(JET_COLUMNDEF) );

/* column indexes for rgcolumndefGetObjectInfo */
#define iContainerName		0
#define iObjectName			1
#define iObjectType			2
//  #define iDtCreate			3	//  XXX -- to be deleted
//  #define iDtUpdate			4	//  XXX -- to be deleted
#define iCRecord			5
#define iCPage				6
#define iGrbit				7
#define iFlags				8


/* static data for ErrIsamGetColumnInfo
/**/
CODECONST( JET_COLUMNDEF ) rgcolumndefGetColumnInfo[] =
	{
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed | JET_bitColumnTTKey },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, JET_bitColumnTTKey },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLongBinary, 0, 0, 0, 0, 0, 0 },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, 0 },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, 0 }
	};

CODECONST( JET_COLUMNDEF ) rgcolumndefGetColumnInfoCompact[] =
	{
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, 0 },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypBinary, 0, 0, 0, 0, 0, 0 },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, 0 },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, 0 }
	};

const ULONG ccolumndefGetColumnInfoMax	= ( sizeof( rgcolumndefGetColumnInfo ) / sizeof( JET_COLUMNDEF ) );

#define iColumnPOrder		0
#define iColumnName			1
#define iColumnId  			2
#define iColumnType			3
#define iColumnCountry		4
#define iColumnLangid		5
#define iColumnCp			6
#define iColumnCollate		7
#define iColumnSize			8
#define iColumnGrbit  		9
#define iColumnDefault		10
#define iColumnTableName	11
#define iColumnColumnName	12


/*	static data for ErrIsamGetIndexInfo
/**/
CODECONST( JET_COLUMNDEF ) rgcolumndefGetIndexInfo[] =
	{
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, JET_bitColumnTTKey },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed | JET_bitColumnTTKey },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, 0 },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed }
	};

const ULONG ccolumndefGetIndexInfoMax	= ( sizeof( rgcolumndefGetIndexInfo ) / sizeof( JET_COLUMNDEF ) );

#define iIndexName			0
#define iIndexGrbit			1
#define iIndexCKey			2
#define iIndexCEntry		3
#define iIndexCPage			4
#define iIndexCCol			5
#define iIndexICol			6
#define iIndexColId			7
#define iIndexColType		8
#define iIndexCountry		9
#define iIndexLangid		10
#define iIndexCp			11
#define iIndexCollate		12
#define iIndexColBits		13
#define iIndexColName		14
#define iIndexLCMapFlags	15

extern const ULONG	cbIDXLISTNewMembersSinceOriginalFormat	= 4;	// for LCMapFlags


/*	internal function prototypes
/**/
/*=================================================================
INFOGetTableColumnInfo

Parameters:	pfucb				pointer to FUCB for table containing columns
			szColumnName		column name or NULL for next column
			pcolumndef			output buffer containing column info

Return Value: Column id of column found ( fidTaggedMost if none )

Errors/Warnings:

Side Effects:
=================================================================*/
LOCAL ERR ErrINFOGetTableColumnInfo(
	FUCB			*pfucb, 			/* FUCB for table containing columns */
	const CHAR		*szColumnName, 		/* column name */
	INFOCOLUMNDEF	*pcolumndef )	 	/* output buffer for column info */
	{
	ERR				err;
	FCB				*pfcb					= pfucb->u.pfcb;
	TDB				*ptdb					= pfcb->Ptdb();
	FCB				* const pfcbTemplate	= ptdb->PfcbTemplateTable();
	COLUMNID		columnidT;
	FIELD			*pfield					= pfieldNil;	/* first element of specific field type */
	JET_GRBIT 		grbit;					/* flags for the field */

	Assert( pcolumndef != NULL );

	Assert( szColumnName != NULL || pcolumndef->columnid != 0 );
	if ( szColumnName != NULL )
		{
		//	quick failure for empty column name
		if ( *szColumnName == '\0' )
			return ErrERRCheck( JET_errColumnNotFound );

		BOOL	fColumnWasDerived;
		CallR( ErrFILEGetPfieldAndEnterDML(
					pfucb->ppib,
					pfcb,
					szColumnName,
					&pfield,
					&columnidT,
					&fColumnWasDerived,
					fFalse ) );
		if ( fColumnWasDerived )
			{
			ptdb->AssertValidDerivedTable();

			Assert( FCOLUMNIDTemplateColumn( columnidT ) );
			pfcb = pfcbTemplate;
			ptdb = pfcbTemplate->Ptdb();
			pfcb->EnterDML();				//	to match LeaveDML() at the end of this function
			}
		else
			{
			//	if column was not derived, then this can't be a template
			//	column, unless we are querying the template table itself
			if ( FCOLUMNIDTemplateColumn( columnidT ) )
				{
				Assert( pfcb->FTemplateTable() );
				}
			else
				{
				Assert( !pfcb->FTemplateTable() );
				}
			}
		}
	else	// szColumnName == NULL
		{
		const FID	fid	= FidOfColumnid( pcolumndef->columnid );

		columnidT = pcolumndef->columnid;

		if ( FCOLUMNIDTemplateColumn( columnidT ) && !pfcb->FTemplateTable() )
			{
			pfcb->Ptdb()->AssertValidDerivedTable();
			
			// switch to template table
			pfcb = pfcbTemplate;
			Assert( pfcbNil != pfcb );
			Assert( pfcb->FTemplateTable() );
			
			ptdb = pfcbTemplate->Ptdb();
			Assert( ptdbNil != ptdb );
			}
			
		pfcb->EnterDML();

		//	special case of TDB::Pfield( fidT )
		pfield = pfieldNil;
		if ( FCOLUMNIDTagged( columnidT ) )
			{
			if ( fid >= ptdb->FidTaggedFirst() && fid <= ptdb->FidTaggedLast() )
				pfield = ptdb->PfieldTagged( columnidT );
			}
		else if ( FCOLUMNIDFixed( columnidT ) )
			{
			if ( fid >= ptdb->FidFixedFirst() && fid <= ptdb->FidFixedLast() )
				pfield = ptdb->PfieldFixed( columnidT );
			}
		else if ( FCOLUMNIDVar( columnidT ) )
			{
			if ( fid >= ptdb->FidVarFirst() && fid <= ptdb->FidVarLast() )
				pfield = ptdb->PfieldVar( columnidT );
			}

		if ( pfieldNil == pfield )
			{
			pfcb->LeaveDML();
			return ErrERRCheck( JET_errColumnNotFound );
			}
		Assert( !FFIELDCommittedDelete( pfield->ffield ) );
		}

	pfcb->AssertDML();
	Assert( ptdb->Pfield( columnidT ) == pfield );
	
	/*	if a field was found, then return the information about it
	/**/
	if ( FCOLUMNIDTagged( columnidT ) )	//lint !e644
		{
		grbit = JET_bitColumnTagged;
		}
	else if ( FCOLUMNIDVar( columnidT ) )
		{
		grbit = 0;
		}
	else
		{
		Assert( FCOLUMNIDFixed( columnidT ) );
		grbit = JET_bitColumnFixed;
		}
		
	if ( FFUCBUpdatable( pfucb ) )
		grbit |= JET_bitColumnUpdatable;

	if ( FFIELDNotNull( pfield->ffield ) )
		grbit |= JET_bitColumnNotNULL;

	if ( FFIELDAutoincrement( pfield->ffield ) )
		grbit |= JET_bitColumnAutoincrement;

	if ( FFIELDVersion( pfield->ffield ) )
		grbit |= JET_bitColumnVersion;

	if ( FFIELDMultivalued( pfield->ffield ) )
		grbit |= JET_bitColumnMultiValued;

	if ( FFIELDEscrowUpdate( pfield->ffield ) )
		grbit |= JET_bitColumnEscrowUpdate;

	if ( FFIELDFinalize( pfield->ffield ) )
		grbit |= JET_bitColumnFinalize;

	if ( FFIELDDeleteOnZero( pfield->ffield ) )
		grbit |= JET_bitColumnDeleteOnZero;

	if ( FFIELDUserDefinedDefault( pfield->ffield ) )
		grbit |= JET_bitColumnUserDefinedDefault;

	if ( FFIELDPrimaryIndexPlaceholder( pfield->ffield ) )
		grbit |= JET_bitColumnRenameConvertToPrimaryIndexPlaceholder;

	pcolumndef->columnid 	= columnidT;
	pcolumndef->coltyp		= pfield->coltyp;
	pcolumndef->wCountry	= countryDefault;
	pcolumndef->langid		= LangidFromLcid( PinstFromPfucb( pfucb )->m_idxunicodeDefault.lcid );
	pcolumndef->cp			= pfield->cp;
//	UNDONE:	support collation order
	pcolumndef->wCollate	= 0;
	pcolumndef->grbit    	= grbit;
	pcolumndef->cbMax      	= pfield->cbMaxLen;
	pcolumndef->cbDefault	= 0;

	strcpy( pcolumndef->szName,	ptdb->SzFieldName( pfield->itagFieldName, fFalse ) );

	//  only retrieve the default value if we are passed in a buffer to place it into
	if( NULL != pcolumndef->pbDefault )
		{
		if ( FFIELDUserDefinedDefault( pfield->ffield ) )
			{
			//  We need to build up a JET_USERDEFINEDDEFAULT structure
			//  in the pvDefault.

			CHAR		szCallback[JET_cbNameMost+1];
			ULONG		cchSzCallback			= 0;
			BYTE		rgbUserData[cbDefaultValueMost];
			ULONG		cbUserData				= 0;
			CHAR		szDependantColumns[ (JET_ccolKeyMost*(JET_cbNameMost+1)) + 1 ];
			ULONG		cchDependantColumns		= 0;
			COLUMNID	columnidCallback		= columnidT;

			pfcb->LeaveDML();

			//	Template bit is not persisted
			COLUMNIDResetFTemplateColumn( columnidCallback );

			err = ErrCATGetColumnCallbackInfo(
					pfucb->ppib,
					pfucb->ifmp,
					pfcb->ObjidFDP(),
					( NULL == pfcbTemplate ? objidNil : pfcbTemplate->ObjidFDP() ),
					columnidCallback,
					szCallback,
					sizeof( szCallback ),
					&cchSzCallback,
					rgbUserData,
					sizeof( rgbUserData ),
					&cbUserData,
					szDependantColumns,
					sizeof( szDependantColumns ),
					&cchDependantColumns );
			if( err < 0 )
				{
				return err;
				}

			Assert( cchSzCallback <= sizeof( szCallback ) );
			Assert( cbUserData <= sizeof( rgbUserData ) );
			Assert( cchDependantColumns <= sizeof( szDependantColumns ) );
			Assert( '\0' == szCallback[cchSzCallback-1] );
			Assert( 0 == cchDependantColumns || 
					( '\0' == szDependantColumns[cchDependantColumns-1]
					&& '\0' == szDependantColumns[cchDependantColumns-2] ) );

			BYTE * const pbMin					= pcolumndef->pbDefault;
			BYTE * const pbUserdefinedDefault 	= pbMin;
			BYTE * const pbSzCallback 			= pbUserdefinedDefault + sizeof( JET_USERDEFINEDDEFAULT );
			BYTE * const pbUserData 			= pbSzCallback + cchSzCallback;
			BYTE * const pbDependantColumns		= pbUserData + cbUserData;
			BYTE * const pbMax					= pbDependantColumns + cchDependantColumns;
			
			JET_USERDEFINEDDEFAULT * const puserdefineddefault = (JET_USERDEFINEDDEFAULT *)pbUserdefinedDefault;
			memcpy( pbSzCallback, szCallback, cchSzCallback );
			memcpy( pbUserData, rgbUserData, cbUserData );
			memcpy( pbDependantColumns, szDependantColumns, cchDependantColumns );
			
			puserdefineddefault->szCallback 		= (CHAR *)pbSzCallback;
			puserdefineddefault->pbUserData 		= rgbUserData;
			puserdefineddefault->cbUserData 		= cbUserData;
			if( 0 != cchDependantColumns )
				{
				puserdefineddefault->szDependantColumns = (CHAR *)pbDependantColumns;
				}
			else
				{
				puserdefineddefault->szDependantColumns = NULL;
				}

			//  REMEMBER: to pass this into JetAddColumn the cbDefault must be set to sizeof( JET_USERDEFINEDDEFAULT )
			pcolumndef->cbDefault = ULONG( pbMax - pbMin );

			//  re-enter because we will try and leave at the end of this routine
			pfcb->EnterDML();
			}
		else if ( FFIELDDefault( pfield->ffield ) )
			{
			DATA	dataT;

			Assert( pfcb->Ptdb() == ptdb );
			err = ErrRECIRetrieveDefaultValue( pfcb, columnidT, &dataT );
			Assert( err >= JET_errSuccess );
			Assert( wrnRECSeparatedSLV != err );
			Assert( wrnRECIntrinsicSLV != err );
			Assert( wrnRECSeparatedLV != err );
			Assert( wrnRECLongField != err );

			pcolumndef->cbDefault = dataT.Cb();
			UtilMemCpy( pcolumndef->pbDefault, dataT.Pv(), dataT.Cb() );
			}
		}

	pfcb->LeaveDML();

	return JET_errSuccess;
	}


LOCAL ERR ErrInfoGetObjectInfo(
	PIB					*ppib,
	const IFMP			ifmp,
	const CHAR			*szObjectName,
	VOID				*pv,
	const ULONG			cbMax,
	const BOOL			fStats );
LOCAL ERR ErrInfoGetObjectInfoList(
	PIB					*ppib,
	const IFMP			ifmp,
	const JET_OBJTYP	objtyp,
	VOID				*pv,
	const ULONG			cbMax,
	const BOOL			fStats );

LOCAL ERR ErrInfoGetTableColumnInfo(
	PIB					*ppib,
	FUCB				*pfucb,
	const CHAR			*szColumnName,
	const JET_COLUMNID	*pcolid,
	VOID				*pv,
	const ULONG			cbMax );
LOCAL ERR ErrInfoGetTableColumnInfoList(
	PIB					*ppib,
	FUCB				*pfucb,
	VOID				*pv,
	const ULONG			cbMax,
	const BOOL			fCompacting,
	const BOOL			fOrderByColid );
LOCAL ERR ErrInfoGetTableColumnInfoBase(
	PIB					*ppib,
	FUCB				*pfucb,
	const CHAR			*szColumnName,
	VOID				*pv,
	const ULONG			cbMax );

LOCAL ERR ErrINFOGetTableIndexInfo(
	PIB					*ppib,
	FUCB				*pfucb,
	const CHAR			*szIndexName,
	VOID				*pv,
	const ULONG			cbMax );
LOCAL ERR ErrINFOGetTableIndexIdInfo(
	PIB					* ppib,
	FUCB				* pfucb,
	const CHAR			* szIndexName,
	INDEXID				* pindexid );


LOCAL const CHAR	szTcObject[]	= "Tables";		//	currently the only valid "container" object

/*=================================================================
ErrIsamGetObjectInfo

Description: Returns information about all objects or a specified object

Parameters:		ppib		   	pointer to PIB for current session
				ifmp		   	database id containing objects
				objtyp			type of object or objtypNil for all objects
				szContainer		container name or NULL for all objects
				szObjectName	object name or NULL for all objects
				pout		   	output buffer
				lInfoLevel		level of information ( 0, 1, or 2 )

Return Value:	JET_errSuccess if the oubput buffer is valid

Errors/Warnings:

Side Effects:
=================================================================*/
ERR VDBAPI ErrIsamGetObjectInfo(
	JET_SESID		vsesid, 			/* pointer to PIB for current session */
	JET_DBID		vdbid, 	  			/* database id containing objects */
	JET_OBJTYP		objtyp,				/* type of object or objtypNil for all */
	const CHAR		*szContainer, 		/* container name or NULL for all */
	const CHAR		*szObject, 			/* object name or NULL for all */
	VOID			*pv,
	ULONG			cbMax,
	ULONG 			lInfoLevel ) 		/* information level */
	{
	ERR				err;
	PIB				*ppib			= (PIB *) vsesid;
	const IFMP   	ifmp			= (IFMP)vdbid;
	CHAR   			szObjectName[JET_cbNameMost+1];

	/*	check parameters
	/**/
	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrPIBCheckIfmp( ppib, ifmp ) );

	if ( NULL != szContainer && '\0' != *szContainer )
		{
		CHAR	szContainerName[JET_cbNameMost+1];
		CallR( ErrUTILCheckName( szContainerName, szContainer, JET_cbNameMost+1 ) );
		if ( 0 != _stricmp( szContainerName, szTcObject ) )
			{
			//	UNDONE: currently only support "Tables" container
			err = ErrERRCheck( JET_errObjectNotFound );
			return err;
			}
		}
		
	if ( szObject == NULL || *szObject == '\0' )
		*szObjectName = '\0';
	else
		CallR( ErrUTILCheckName( szObjectName, szObject, JET_cbNameMost+1 ) );

	switch ( lInfoLevel )
		{
		case JET_ObjInfo:
		case JET_ObjInfoNoStats:
			err = ErrInfoGetObjectInfo(
				ppib,
				ifmp,
				szObjectName,
				pv,
				cbMax,
				JET_ObjInfo == lInfoLevel );
			break;
			
		case JET_ObjInfoList:
		case JET_ObjInfoListNoStats:
			err = ErrInfoGetObjectInfoList(
				ppib,
				ifmp,
				objtyp,
				pv,
				cbMax,
				JET_ObjInfoList == lInfoLevel );
			break;
			
		case JET_ObjInfoSysTabCursor:
		case JET_ObjInfoSysTabReadOnly:
		case JET_ObjInfoListACM:
		case JET_ObjInfoRulesLoaded:
		default:
			Assert( fFalse );		// should be impossible (filtered out by JetGetObjectInfo())
			err = ErrERRCheck( JET_errInvalidParameter );
			break;
		}

	return err;
	}


LOCAL ERR ErrInfoGetObjectInfo(
	PIB				*ppib,
	const IFMP		ifmp,
	const CHAR		*szObjectName,
	VOID			*pv,
	const ULONG		cbMax,
	const BOOL		fStats )
	{
	ERR				err;
	FUCB			*pfucbInfo;
	JET_OBJECTINFO	objectinfo;
	
	/*	return error if the output buffer is too small
	/**/
	if ( cbMax < sizeof( JET_OBJECTINFO ) )
		{
		return ErrERRCheck( JET_errBufferTooSmall );
		}

	CallR( ErrCATGetTableInfoCursor( ppib, ifmp, szObjectName, &pfucbInfo ) );

	/*	set cbStruct
	/**/
	objectinfo.cbStruct	= sizeof( JET_OBJECTINFO );
	objectinfo.objtyp	= JET_objtypTable;

	/*	set base table capability bits
	/**/
	objectinfo.grbit = JET_bitTableInfoBookmark | JET_bitTableInfoRollback;
	
	// UNDONE: How to set updatable (currently, use catalog's Updatable flag)
	if ( FFUCBUpdatable( pfucbInfo ) )
		{
		objectinfo.grbit |= JET_bitTableInfoUpdatable;
		}

	ULONG	cbActual;
	Call( ErrIsamRetrieveColumn(
				ppib,
				pfucbInfo,
				fidMSO_Flags,
				&objectinfo.flags,
				sizeof( objectinfo.flags ),
				&cbActual,
				NO_GRBIT,
				NULL ) );
	CallS( err );
	Assert( sizeof(ULONG) == cbActual );

	/*	set stats
	/**/
	if ( fStats )
		{
		LONG	cRecord, cPage;
		Call( ErrSTATSRetrieveTableStats(
					ppib,
					ifmp,
					(CHAR *)szObjectName,
					&cRecord,
					NULL,
					&cPage ) );
					
		objectinfo.cRecord	= cRecord;
		objectinfo.cPage	= cPage;
		}
	else
		{
		objectinfo.cRecord	= 0;
		objectinfo.cPage	= 0;
		}

	memcpy( pv, &objectinfo, sizeof( JET_OBJECTINFO ) );
	err = JET_errSuccess;

HandleError:
	CallS( ErrCATClose( ppib, pfucbInfo ) );
	return err;
	}


LOCAL ERR ErrInfoGetObjectInfoList(
	PIB					*ppib,
	const IFMP			ifmp,
	const JET_OBJTYP	objtyp,
	VOID				*pv,
	const ULONG			cbMax,
	const BOOL			fStats )
	{
	ERR					err;
	const JET_SESID		sesid			= (JET_SESID)ppib;
	JET_TABLEID			tableid;
	JET_COLUMNID		rgcolumnid[ccolumndefGetObjectInfoMax];
	FUCB				*pfucbCatalog	= pfucbNil;
	const JET_OBJTYP	objtypTable		= JET_objtypTable;
	JET_GRBIT			grbitTable;
	ULONG				ulFlags;
	LONG  				cRecord			= 0;		/* count of records in table */
	LONG  				cPage			= 0;		/* count of pages in table */
	ULONG  				cRows			= 0;		/* count of objects found */
	ULONG				cbActual;
	CHAR				szObjectName[JET_cbNameMost+1];
	JET_OBJECTLIST		objectlist;
	
	/* Open the temporary table which will be returned to the caller
	/**/
	CallR( ErrIsamOpenTempTable(
				sesid,
				(JET_COLUMNDEF *)rgcolumndefGetObjectInfo,
				ccolumndefGetObjectInfoMax,
				NULL,
				JET_bitTTScrollable|JET_bitTTIndexed,
				&tableid,
				rgcolumnid ) );

	if ( JET_objtypNil != objtyp && JET_objtypTable != objtyp )
		{
		//	the only objects currently supported are Table objects
		//	(or objtypNil, which means scan all objects)
		goto ResetTempTblCursor;
		}

	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	Call( ErrIsamSetCurrentIndex( ppib, pfucbCatalog, szMSORootObjectsIndex ) );
	
	//	set base table capability bits
	grbitTable = JET_bitTableInfoBookmark|JET_bitTableInfoRollback;
	
	//	UNDONE: How to set updatable (currently, use catalog's Updatable flag)
	if ( FFUCBUpdatable( pfucbCatalog ) )
		grbitTable |= JET_bitTableInfoUpdatable;
		

	err = ErrIsamMove( ppib, pfucbCatalog, JET_MoveFirst, NO_GRBIT );
	while ( JET_errNoCurrentRecord != err )
		{
		Call( err );
		CallS( err );

		
#ifdef DEBUG	
		//	verify this is a Table object
		SYSOBJ	sysobj;
		Call( ErrIsamRetrieveColumn(
					ppib,
					pfucbCatalog,
					fidMSO_Type,
					(BYTE *)&sysobj,
					sizeof(sysobj),
					&cbActual,
					NO_GRBIT,
					NULL ) );
		CallS( err );
		Assert( sizeof(SYSOBJ) == cbActual );
		Assert( sysobjTable == sysobj );
#endif

		// get object name
		//
		Call( ErrIsamRetrieveColumn(
					ppib,
					pfucbCatalog,
					fidMSO_Name,
					szObjectName,
					JET_cbNameMost,
					&cbActual,
					NO_GRBIT,
					NULL ) );
		CallS( err );
		Assert( cbActual > 0 );
		Assert( cbActual <= JET_cbNameMost );
		szObjectName[cbActual] = 0;

		//	get flags
		//
		Call( ErrIsamRetrieveColumn(
					ppib,
					pfucbCatalog,
					fidMSO_Flags,
					&ulFlags,
					sizeof(ulFlags),
					&cbActual,
					NO_GRBIT,
					NULL ) );
		CallS( err );
		Assert( sizeof(ULONG) == cbActual );

		//	get statistics (if requested)
		//
		if ( fStats )
			{
			Call( ErrSTATSRetrieveTableStats(
						ppib,
						ifmp,
						szObjectName,
						&cRecord,
						NULL,
						&cPage ) );
			}
		else
			{
			Assert( 0 == cRecord );
			Assert( 0 == cPage );
			}

		// add the current object info to the temporary table
		//
		Call( ErrDispPrepareUpdate(
					sesid, 
					tableid, 
					JET_prepInsert ) );
					
		Call( ErrDispSetColumn(
					sesid, 
					tableid,
					rgcolumnid[iContainerName], 
					szTcObject,
					(ULONG)strlen(szTcObject),
					NO_GRBIT, 
					NULL ) );
		Call( ErrDispSetColumn(
					sesid, 
					tableid,
					rgcolumnid[iObjectType], 
					&objtypTable,
					sizeof(objtypTable), 
					NO_GRBIT, 
					NULL ) );
		Call( ErrDispSetColumn(
					sesid, 
					tableid,
					rgcolumnid[iObjectName], 
					szObjectName,
					(ULONG)strlen(szObjectName),
					NO_GRBIT,
					NULL ) );
		Call( ErrDispSetColumn(
					sesid,
					tableid,
					rgcolumnid[iFlags],
					&ulFlags,
					sizeof(ulFlags),
					NO_GRBIT,
					NULL ) );
		Call( ErrDispSetColumn(
					sesid,
					tableid,
					rgcolumnid[iCRecord],
					&cRecord,
					sizeof(cRecord),
					NO_GRBIT,
					NULL ) );
		Call( ErrDispSetColumn(
					sesid,
					tableid,
					rgcolumnid[iCPage],
					&cPage,
					sizeof(cPage),
					NO_GRBIT,
					NULL ) );
		Call( ErrDispSetColumn(
					sesid,
					tableid,
					rgcolumnid[iGrbit],
					&grbitTable,
					sizeof(grbitTable),
					NO_GRBIT,
					NULL ) );
					
		Call( ErrDispUpdate(
					sesid,
					tableid,
					NULL,
					0,
					NULL,
					NO_GRBIT ) );

		//	set the number of objects found
		//
		cRows++;

		/* move to the next record
		/**/
		err = ErrIsamMove( ppib, pfucbCatalog, JET_MoveNext, NO_GRBIT );
		}

	CallS( ErrCATClose( ppib, pfucbCatalog ) );
	pfucbCatalog = pfucbNil;
	

ResetTempTblCursor:
	/* move to first record in the temporary table
	/**/
	err = ErrDispMove( sesid, tableid, JET_MoveFirst, NO_GRBIT );
	if ( err < 0 )
		{
		if ( JET_errNoCurrentRecord != err )
			goto HandleError;
		}

	/* set the return structure
	/**/
	objectlist.cbStruct					= sizeof(JET_OBJECTLIST);
	objectlist.tableid					= tableid;
	objectlist.cRecord					= cRows;
	objectlist.columnidcontainername	= rgcolumnid[iContainerName];
	objectlist.columnidobjectname		= rgcolumnid[iObjectName];
	objectlist.columnidobjtyp			= rgcolumnid[iObjectType];
	objectlist.columnidgrbit			= rgcolumnid[iGrbit];
	objectlist.columnidflags			= rgcolumnid[iFlags];
	objectlist.columnidcRecord			= rgcolumnid[iCRecord];
	objectlist.columnidcPage			= rgcolumnid[iCPage];

	AssertDIRNoLatch( ppib );
	Assert( pfucbNil == pfucbCatalog );

	memcpy( pv, &objectlist, sizeof( JET_OBJECTLIST ) );
	return JET_errSuccess;

HandleError:
	Assert( err < 0 );
	AssertDIRNoLatch( ppib );

	if ( pfucbNil != pfucbCatalog )
		{
		CallS( ErrCATClose( ppib, pfucbCatalog ) );
		}

	//	ignore errors returned while destroying temp table.
	(VOID)ErrDispCloseTable( sesid, tableid );
	
	return err;
	}


//  ================================================================
LOCAL ERR ErrInfoGetTableAvailSpace(
	PIB * const ppib,
	FUCB * const pfucb,
	void * const pvResult,
	const ULONG cbMax )
//  ================================================================
//
//  Count the number of available pages in a table, its indexes and its
//  LV tree
//
//-
	{
	ERR err = JET_errSuccess;
	
	if( sizeof( CPG ) != cbMax )
		{
		return ErrERRCheck( JET_errInvalidBufferSize );
		}

	CPG cpgT;
	CPG * const pcpg = (CPG *)pvResult;
	*pcpg = 0;

	FCB * pfcbT		= pfcbNil;
	FUCB * pfucbT 	= pfucbNil;

	//  first, the table
	Call( ErrSPGetInfo( ppib, pfucb->ifmp, pfucb, (BYTE *)&cpgT, sizeof( cpgT ), fSPAvailExtent ) );
	*pcpg += cpgT;

	//  then, the indexes of the table
	for( pfcbT = pfucb->u.pfcb->PfcbNextIndex(); pfcbNil != pfcbT; pfcbT = pfcbT->PfcbNextIndex() )
		{
		Call( ErrDIROpen( ppib, pfcbT, &pfucbT ) );
		Call( ErrSPGetInfo( ppib, pfucbT->ifmp, pfucbT, (BYTE *)&cpgT, sizeof( cpgT ), fSPAvailExtent ) );
		*pcpg += cpgT;
		DIRClose( pfucbT );
		pfucbT = pfucbNil;
		}

	//  finally, the LV tree
	err = ErrFILEOpenLVRoot( pfucb, &pfucbT, fFalse );
	if( JET_errSuccess == err )
		{
		//  the LV tree exists
		Call( ErrSPGetInfo( ppib, pfucbT->ifmp, pfucbT, (BYTE *)&cpgT, sizeof( cpgT ), fSPAvailExtent ) );
		*pcpg += cpgT;
		DIRClose( pfucbT );
		pfucbT = pfucbNil;
		}
	else
		{
		Call( err );
		//  don't want to return wrnLVNoLongValues
		err = JET_errSuccess;
		}
	
HandleError:
	if( pfucbNil != pfucbT )
		{
		DIRClose( pfucbT );
		}
	return err;
	}

	
ERR VTAPI ErrIsamGetTableInfo(
	JET_SESID		vsesid,
	JET_VTID	 	vtid,
	void		 	*pvResult,
	unsigned long	cbMax,
	unsigned long	lInfoLevel )
	{
	ERR	 			err;
	PIB				*ppib		= (PIB *)vsesid;
	FUCB		 	*pfucb		= (FUCB *)vtid;
	CHAR			szTableName[JET_cbNameMost+1];

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );

	/* if OLCStats info/reset can be done now 
	/**/
	switch( lInfoLevel )
		{
		case JET_TblInfo:
		case JET_TblInfoName:
		case JET_TblInfoTemplateTableName:
			break;

		case JET_TblInfoOLC:
		case JET_TblInfoResetOLC:
			return ErrERRCheck( JET_errFeatureNotAvailable );

		case JET_TblInfoSpaceAlloc:
			/*	number of pages and density
			/**/
			Assert( cbMax >= sizeof(ULONG) * 2);
			err = ErrCATGetTableAllocInfo(
					ppib,
					pfucb->ifmp,
					pfucb->u.pfcb->ObjidFDP(),
					(ULONG *)pvResult, 
					((ULONG *)pvResult) + 1);
			return err;

		case JET_TblInfoSpaceUsage:
			{
			BYTE	fSPExtents = fSPOwnedExtent|fSPAvailExtent;

			if ( cbMax > 2 * sizeof(CPG) )
				fSPExtents |= fSPExtentList;

			err = ErrSPGetInfo(
						ppib,
						pfucb->ifmp,
						pfucb,
						static_cast<BYTE *>( pvResult ),
						cbMax,
						fSPExtents );
			return err;
			}

		case JET_TblInfoSpaceOwned:
			err = ErrSPGetInfo(
						ppib,
						pfucb->ifmp,
						pfucb,
						static_cast<BYTE *>( pvResult ),
						cbMax,
						fSPOwnedExtent );
			return err;

		case JET_TblInfoSpaceAvailable:
			err = ErrInfoGetTableAvailSpace(
					ppib,
					pfucb,
					pvResult,
					cbMax );
			return err;

		case JET_TblInfoDumpTable:
			Assert( fFalse );
			return ErrERRCheck( JET_errFeatureNotAvailable );

		default:
			Assert( fFalse );
		}

		
	Assert( pfucb->u.pfcb->Ptdb() != ptdbNil );
	pfucb->u.pfcb->EnterDML();
	Assert( strlen( pfucb->u.pfcb->Ptdb()->SzTableName() ) <= JET_cbNameMost );
	strcpy( szTableName, pfucb->u.pfcb->Ptdb()->SzTableName() );
	pfucb->u.pfcb->LeaveDML();
	
	switch ( lInfoLevel )
		{
		case JET_TblInfo:
			{
			JET_OBJECTINFO	objectinfo;
			LONG			cRecord;
			LONG			cPage;
			
			/* check buffer size
			/**/
			if ( cbMax < sizeof( JET_OBJECTINFO ) )
				{
				err = ErrERRCheck( JET_errBufferTooSmall );
				goto HandleError;
				}

			if ( pfucb->u.pfcb->FTypeTemporaryTable() )
				{
				err = ErrERRCheck( JET_errObjectNotFound );
				goto HandleError;
				}

			Assert( rgfmp[ pfucb->u.pfcb->Ifmp() ].Dbid() != dbidTemp );

			/* set data to return
			/**/
			objectinfo.cbStruct	= sizeof(JET_OBJECTINFO);
			objectinfo.objtyp	= JET_objtypTable;
			objectinfo.flags	= 0;
			
			if ( FCATSystemTable( pfucb->u.pfcb->PgnoFDP() ) )
				objectinfo.flags |= JET_bitObjectSystem;
			else if ( FOLDSystemTable( szTableName ) )
				objectinfo.flags |= JET_bitObjectSystemDynamic;
			else if ( FCATUnicodeFixupTable( szTableName ) )
				objectinfo.flags |= JET_bitObjectSystemDynamic;

			if ( pfucb->u.pfcb->FFixedDDL() )
				objectinfo.flags |= JET_bitObjectTableFixedDDL;

			//	hierarchical DDL not currently nestable
			Assert( !( pfucb->u.pfcb->FTemplateTable() && pfucb->u.pfcb->FDerivedTable() ) );
			if ( pfucb->u.pfcb->FTemplateTable() )
				objectinfo.flags |= JET_bitObjectTableTemplate;
			else if ( pfucb->u.pfcb->FDerivedTable() )
				objectinfo.flags |= JET_bitObjectTableDerived;

			/*	set base table capability bits
			/**/
			objectinfo.grbit = JET_bitTableInfoBookmark | JET_bitTableInfoRollback;
			if ( FFUCBUpdatable( pfucb ) )
				objectinfo.grbit |= JET_bitTableInfoUpdatable;

			Call( ErrSTATSRetrieveTableStats(
						pfucb->ppib,
						pfucb->ifmp,
						szTableName,
						&cRecord,
						NULL,
						&cPage ) );
						
			objectinfo.cRecord	= cRecord;
			objectinfo.cPage	= cPage;

			memcpy( pvResult, &objectinfo, sizeof( JET_OBJECTINFO ) );

			break;
			}

		case JET_TblInfoRvt:
			err = ErrERRCheck( JET_errQueryNotSupported );
			break;

		case JET_TblInfoName:
		case JET_TblInfoMostMany:
			//	UNDONE:	add support for most many
			if ( pfucb->u.pfcb->FTypeTemporaryTable() )
				{
				err = ErrERRCheck( JET_errInvalidOperation );
				goto HandleError;
				}
			if ( strlen( szTableName ) >= cbMax )
				err = ErrERRCheck( JET_errBufferTooSmall );
			else
				{
				strcpy( static_cast<CHAR *>( pvResult ), szTableName );
				}
			break;

		case JET_TblInfoDbid:
			if ( pfucb->u.pfcb->FTypeTemporaryTable() )
				{
				err = ErrERRCheck( JET_errInvalidOperation );
				goto HandleError;
				}
			/* check buffer size
			/**/
			if ( cbMax < sizeof(JET_DBID) + sizeof(JET_DBID) )
				{
				err = ErrERRCheck( JET_errBufferTooSmall );
				goto HandleError;
				}
			else
				{
				JET_DBID	jifmp = (JET_DBID) pfucb->ifmp;

				*(JET_DBID *)pvResult = jifmp;
				*(JET_DBID *)((CHAR *)pvResult + sizeof(JET_DBID)) = (JET_DBID)pfucb->ifmp;
				}
			break;

		case JET_TblInfoTemplateTableName:
			if ( pfucb->u.pfcb->FTypeTemporaryTable() )
				{
				err = ErrERRCheck( JET_errInvalidOperation );
				goto HandleError;
				}

			// Need at least JET_cbNameMost, plus 1 for null-terminator.
			if ( cbMax <= JET_cbNameMost )
				err = ErrERRCheck( JET_errBufferTooSmall );
			else if ( pfucb->u.pfcb->FDerivedTable() )
				{
				FCB		*pfcbTemplateTable = pfucb->u.pfcb->Ptdb()->PfcbTemplateTable();
				Assert( pfcbNil != pfcbTemplateTable );
				Assert( pfcbTemplateTable->FFixedDDL() );
				Assert( strlen( pfcbTemplateTable->Ptdb()->SzTableName() ) <= JET_cbNameMost );
				strcpy( (CHAR *)pvResult, pfcbTemplateTable->Ptdb()->SzTableName() );
				}
			else
				{
				//	table was not derived from a template -- return NULL
				*( (CHAR *)pvResult ) = '\0';
				}
			break;

		default:
			err = ErrERRCheck( JET_errInvalidParameter );
		}

HandleError:
	return err;
	}


/*=================================================================
ErrIsamGetColumnInfo

Description: Returns information about all columns for the table named

Parameters:
			ppib				pointer to PIB for current session
			ifmp				id of database containing the table
			szTableName			table name
			szColumnName		column name or NULL for all columns
			pv					pointer to results
			cbMax				size of result buffer
			lInfoLevel			level of information ( 0, 1, or 2 )

Return Value: JET_errSuccess

Errors/Warnings:

Side Effects:
=================================================================*/
ERR VDBAPI ErrIsamGetColumnInfo(
	JET_SESID		vsesid, 				/* pointer to PIB for current session */
	JET_DBID  		vdbid, 					/* id of database containing the table */
	const CHAR		*szTable, 				/* table name */
	const CHAR		*szColumnName,   		/* column name or NULL for all columns except when pcolid set */
	JET_COLUMNID	*pcolid,				/* used when szColumnName is null or "" AND lInfoLevel == JET_ColInfoByColid */
	VOID			*pv,
	unsigned long	cbMax,
	unsigned long	lInfoLevel )
	{
	PIB				*ppib = (PIB *) vsesid;
	ERR				err;
	IFMP	 		ifmp;
	CHAR	 		szTableName[ JET_cbNameMost+1 ];
	FUCB	 		*pfucb;

	/*	check parameters
	/**/
	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrPIBCheckIfmp( ppib, (IFMP)vdbid ) );
	ifmp = (IFMP) vdbid;
	if ( szTable == NULL )
		return ErrERRCheck( JET_errInvalidParameter );
	CallR( ErrUTILCheckName( szTableName, szTable, JET_cbNameMost+1 ) );

	CallR( ErrFILEOpenTable( ppib, ifmp, &pfucb, szTableName, NO_GRBIT ) );
	Assert( pfucbNil != pfucb );

	Assert( ( rgfmp[ifmp].FReadOnlyAttach() && !FFUCBUpdatable( pfucb ) )
		|| ( !rgfmp[ifmp].FReadOnlyAttach() && FFUCBUpdatable( pfucb ) ) );
	FUCBResetUpdatable( pfucb );

	Call( ErrIsamGetTableColumnInfo(
				(JET_SESID)ppib,
				(JET_VTID)pfucb,
				szColumnName,
				pcolid,
				pv,
				cbMax,
				lInfoLevel ) );

HandleError:
	CallS( ErrFILECloseTable( ppib, pfucb ) );
	return err;
	}


/*=================================================================
ErrIsamGetTableColumnInfo

Description: Returns column information for the table id passed

Parameters: 	ppib				pointer to PIB for the current session
				pfucb				pointer to FUCB for the table
				szColumnName		column name or NULL for all columns
				pcolid				retrieve info by colid, JET_colInfo only
				pv					pointer to result buffer
				cbMax				size of result buffer
				lInfoLevel			level of information

Return Value: JET_errSuccess

Errors/Warnings:

Side Effects:
=================================================================*/
	ERR VTAPI
ErrIsamGetTableColumnInfo(
	JET_SESID			vsesid,			/* pointer to PIB for current session */
	JET_VTID			vtid, 			/* pointer to FUCB for the table */
	const CHAR			*szColumn, 		/* column name or NULL for all columns */
	const JET_COLUMNID	*pcolid,		/* except if colid is set, then retrieve column info of ths col */
	void   				*pb,
	unsigned long		cbMax,
	unsigned long		lInfoLevel )	/* information level ( 0, 1, or 2 ) */
	{
	ERR			err;
	PIB			*ppib = (PIB *)vsesid;
	FUCB		*pfucb = (FUCB *)vtid;
	CHAR		szColumnName[ (JET_cbNameMost + 1) ];

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );
	if ( szColumn == NULL || *szColumn == '\0' )
		{
		szColumnName[0] = '\0';
		}
	else
		{
		CallR( ErrUTILCheckName( szColumnName, szColumn, ( JET_cbNameMost + 1 ) ) );
		}

	CallR( ErrIsamBeginTransaction( (JET_SESID)ppib, NO_GRBIT ) );
	
	switch ( lInfoLevel )
		{
		case JET_ColInfo:
		case JET_ColInfoByColid:
			err = ErrInfoGetTableColumnInfo( ppib, pfucb, szColumnName, pcolid, pb, cbMax );
			break;
		case JET_ColInfoList:
			err = ErrInfoGetTableColumnInfoList( ppib, pfucb, pb, cbMax, fFalse, fFalse );
			break;
		case JET_ColInfoListSortColumnid:
			err = ErrInfoGetTableColumnInfoList( ppib, pfucb, pb, cbMax, fFalse, fTrue );
			break;
		case JET_ColInfoBase:
			err = ErrInfoGetTableColumnInfoBase( ppib, pfucb, szColumnName, pb, cbMax );
			break;
		case JET_ColInfoListCompact:
			err = ErrInfoGetTableColumnInfoList( ppib, pfucb, pb, cbMax, fTrue, fFalse );
			break;
			
		case JET_ColInfoSysTabCursor:
		default:
			Assert( fFalse );		// should be impossible (filtered out by JetGetTableColumnInfo())
			err = ErrERRCheck( JET_errInvalidParameter );
		}

	if( err >= 0 )
		{
		err = ErrIsamCommitTransaction( (JET_SESID)ppib, NO_GRBIT );
		}
		
	if( err < 0 )
		{
		const ERR	errT	= ErrIsamRollback( (JET_SESID)ppib, NO_GRBIT );
		if ( JET_errSuccess != errT )
			{
			Assert( errT < 0 );
			Assert( PinstFromPpib( ppib )->FInstanceUnavailable() );
			Assert( JET_errSuccess != ppib->ErrRollbackFailure() );
			}
		}
		
	return err;
	}


LOCAL ERR ErrInfoGetTableColumnInfo(
	PIB					*ppib,
	FUCB				*pfucb,
	const CHAR			*szColumnName,
	const JET_COLUMNID	*pcolid,
	VOID				*pv,
	const ULONG			cbMax )
	{
	ERR			err;	
	INFOCOLUMNDEF	columndef;
	columndef.pbDefault	= NULL;

	if ( cbMax < sizeof(JET_COLUMNDEF) || szColumnName == NULL )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	//	do lookup by columnid, not column name
	if ( szColumnName[0] == '\0' )
		{
		if ( pcolid )
			{
			columndef.columnid = *pcolid;
			szColumnName = NULL;
			}
		else
			columndef.columnid = 0;
		}

	CallR( ErrINFOGetTableColumnInfo( pfucb, szColumnName, &columndef ) );

	((JET_COLUMNDEF *)pv)->cbStruct	= sizeof(JET_COLUMNDEF);
	((JET_COLUMNDEF *)pv)->columnid	= columndef.columnid;
	((JET_COLUMNDEF *)pv)->coltyp  	= columndef.coltyp;
	((JET_COLUMNDEF *)pv)->cbMax   	= columndef.cbMax;
	((JET_COLUMNDEF *)pv)->grbit   	= columndef.grbit;
	((JET_COLUMNDEF *)pv)->wCollate	= 0;
	((JET_COLUMNDEF *)pv)->cp	   	= columndef.cp;
	((JET_COLUMNDEF *)pv)->wCountry	= columndef.wCountry;
	((JET_COLUMNDEF *)pv)->langid  	= columndef.langid;

	return JET_errSuccess;
	}


LOCAL ERR ErrINFOSetTableColumnInfoList(
	PIB				*ppib,
	JET_TABLEID		tableid,
	const CHAR		*szTableName,
	COLUMNID		*rgcolumnid,
	INFOCOLUMNDEF	*pcolumndef,
	const BOOL		fOrderByColid )
	{
	ERR				err;

	Call( ErrDispPrepareUpdate( (JET_SESID)ppib, tableid, JET_prepInsert ) );

	if ( fOrderByColid )
		{
		Call( ErrDispSetColumn( 
					(JET_SESID)ppib, 
					tableid,
					rgcolumnid[iColumnPOrder], 
					(BYTE *)&pcolumndef->columnid,
					sizeof(pcolumndef->columnid), 
					NO_GRBIT,
					NULL ) );
		}

	Call( ErrDispSetColumn( 
				(JET_SESID)ppib, 
				tableid,
				rgcolumnid[iColumnName], 
				pcolumndef->szName,
				(ULONG)strlen( pcolumndef->szName ), 
				NO_GRBIT,
				NULL ) );
	Call( ErrDispSetColumn(
				(JET_SESID)ppib,
				tableid,
				rgcolumnid[iColumnId], 
				(BYTE *)&pcolumndef->columnid,
				sizeof(pcolumndef->columnid), 
				NO_GRBIT,
				NULL ) );
	Call( ErrDispSetColumn(
				(JET_SESID)ppib,
				tableid,
				rgcolumnid[iColumnType], 
				(BYTE *)&pcolumndef->coltyp,
				sizeof(pcolumndef->coltyp), 
				NO_GRBIT, 
				NULL ) );
	Call( ErrDispSetColumn( 
				(JET_SESID)ppib, 
				tableid,
				rgcolumnid[iColumnCountry], 
				&pcolumndef->wCountry,
				sizeof( pcolumndef->wCountry ), 
				NO_GRBIT, 
				NULL ) );
	Call( ErrDispSetColumn( 
				(JET_SESID)ppib, 
				tableid,
				rgcolumnid[iColumnLangid], 
				&pcolumndef->langid,
				sizeof( pcolumndef->langid ),
				NO_GRBIT,
				NULL ) );
	Call( ErrDispSetColumn( 
				(JET_SESID)ppib, 
				tableid,
				rgcolumnid[iColumnCp], 
				&pcolumndef->cp,
				sizeof(pcolumndef->cp), 
				NO_GRBIT, 
				NULL ) );
	Call( ErrDispSetColumn( 
				(JET_SESID)ppib, 
				tableid,
				rgcolumnid[iColumnSize], 
				(BYTE *)&pcolumndef->cbMax,
				sizeof(pcolumndef->cbMax), 
				NO_GRBIT,
				NULL ) );
	Call( ErrDispSetColumn( 
				(JET_SESID)ppib,
				tableid,
				rgcolumnid[iColumnGrbit], 
				&pcolumndef->grbit,
				sizeof(pcolumndef->grbit), 
				NO_GRBIT,
				NULL ) );

	Call( ErrDispSetColumn(
				(JET_SESID)ppib,
				tableid,
				rgcolumnid[iColumnCollate],
				&pcolumndef->wCollate,
				sizeof(pcolumndef->wCollate),
				NO_GRBIT,
				NULL ) );

	if ( pcolumndef->cbDefault > 0 )
		{
		Call( ErrDispSetColumn(
				(JET_SESID)ppib,
				tableid,
				rgcolumnid[iColumnDefault],
				pcolumndef->pbDefault,
				pcolumndef->cbDefault, 
				NO_GRBIT,
				NULL ) );
		}

	Call( ErrDispSetColumn(
				(JET_SESID)ppib,
				tableid,
				rgcolumnid[iColumnTableName],
				szTableName,
				(ULONG)strlen( szTableName ),
				NO_GRBIT,
				NULL ) );
	Call( ErrDispSetColumn(
				(JET_SESID)ppib,
				tableid,
				rgcolumnid[iColumnColumnName], 
				pcolumndef->szName,
				(ULONG)strlen( pcolumndef->szName ),
				NO_GRBIT,
				NULL ) );

	Call( ErrDispUpdate( (JET_SESID)ppib, tableid, NULL, 0, NULL, NO_GRBIT ) );

HandleError:
	return err;
	}


BOOL g_fCompactTemplateTableColumnDropped = fFalse;	//	LAURIONB_HACK

LOCAL ERR ErrInfoGetTableColumnInfoList(
	PIB				*ppib,
	FUCB			*pfucb,
	VOID			*pv,
	const ULONG		cbMax,
	const BOOL		fCompacting,
	const BOOL		fOrderByColid )
	{
	ERR				err;
	JET_TABLEID		tableid;
	COLUMNID		rgcolumnid[ccolumndefGetColumnInfoMax];
	FCB				*pfcb				= pfucb->u.pfcb;
	TDB				*ptdb				= pfcb->Ptdb();
	FID				fid;
	FID				fidFixedFirst;
	FID				fidFixedLast;
	FID				fidVarFirst;
	FID				fidVarLast;
	FID				fidTaggedFirst;
	FID				fidTaggedLast;
	CHAR			szTableName[JET_cbNameMost+1];
	INFOCOLUMNDEF	columndef;
	ULONG		  	cRows				= 0;
	const BOOL		fTemplateTable		= pfcb->FTemplateTable();

	columndef.pbDefault = NULL;

	/*	initialize variables
	/**/
	if ( cbMax < sizeof(JET_COLUMNLIST) )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	/*	create temporary table
	/**/
	CallR( ErrIsamOpenTempTable(
				(JET_SESID)ppib,
				(JET_COLUMNDEF *)( fCompacting ? rgcolumndefGetColumnInfoCompact : rgcolumndefGetColumnInfo ),
				ccolumndefGetColumnInfoMax,
				NULL,
				JET_bitTTScrollable|JET_bitTTIndexed,
				&tableid,
				rgcolumnid ) );

#ifdef INTRINSIC_LV
	columndef.pbDefault = (BYTE *)PvOSMemoryHeapAlloc( cbDefaultValueMost * 64 );
#else // INTRINSIC_LV	
	columndef.pbDefault = (BYTE *)PvOSMemoryHeapAlloc( cbLVIntrinsicMost * 64 );
#endif // INTRINSIC_LV	
	if( NULL == columndef.pbDefault )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	pfcb->EnterDML();
		
	fidFixedLast = ptdb->FidFixedLast();
	fidVarLast = ptdb->FidVarLast();
	fidTaggedLast = ptdb->FidTaggedLast();

	Assert( fidFixedLast == fidFixedLeast-1 || FFixedFid( fidFixedLast ) );
	Assert( fidVarLast == fidVarLeast-1 || FVarFid( fidVarLast ) );
	Assert( fidTaggedLast == fidTaggedLeast-1 || FTaggedFid( fidTaggedLast ) );

	Assert( strlen( ptdb->SzTableName() ) <= JET_cbNameMost );
	strcpy( szTableName, ptdb->SzTableName() );
	
	pfcb->LeaveDML();

	if ( !fCompacting && pfcbNil != ptdb->PfcbTemplateTable() )
		{
		ptdb->AssertValidDerivedTable();
		Assert( !fTemplateTable );

		const FID	fidTemplateFixedLast	= ptdb->PfcbTemplateTable()->Ptdb()->FidFixedLast();
		const FID	fidTemplateVarLast		= ptdb->PfcbTemplateTable()->Ptdb()->FidVarLast();
		const FID	fidTemplateTaggedLast	= ptdb->PfcbTemplateTable()->Ptdb()->FidTaggedLast();

		Assert( fidTemplateFixedLast == fidFixedLeast-1 || FFixedFid( fidTemplateFixedLast ) );
		Assert( fidTemplateVarLast == fidVarLeast-1 || FVarFid( fidTemplateVarLast ) );
		Assert( fidTemplateTaggedLast == fidTaggedLeast-1 || FTaggedFid( fidTemplateTaggedLast ) );

		for ( fid = fidFixedLeast; ; fid++ )
			{
			if ( fidTemplateFixedLast+1 == fid )
				fid = fidVarLeast;
			if ( fidTemplateVarLast+1 == fid )
				fid = fidTaggedLeast;
			if ( fid > fidTemplateTaggedLast )
				break;

			columndef.columnid = ColumnidOfFid( fid, fTrue );
			CallS( ErrINFOGetTableColumnInfo( pfucb, NULL, &columndef ) );

			Call( ErrINFOSetTableColumnInfoList(
					ppib,
					tableid,
					szTableName,
					rgcolumnid,
					&columndef,
					fOrderByColid ) );
			
			cRows++;
			}
		}

	fidFixedFirst = ptdb->FidFixedFirst();
	fidVarFirst = ptdb->FidVarFirst();
	fidTaggedFirst = ptdb->FidTaggedFirst();

	for ( fid = fidFixedFirst; ; fid++ )
		{
		if ( fidFixedLast+1 == fid )
			fid = fidVarFirst;
		if ( fidVarLast+1 == fid )
			fid = fidTaggedFirst;
		if ( fid > fidTaggedLast )
			break;


		if ( fTemplateTable )
			{
			columndef.columnid = ColumnidOfFid( fid, fTrue );
			}
		else
			{
			columndef.columnid = ColumnidOfFid( fid, fFalse );
			err = ErrRECIAccessColumn( pfucb, columndef.columnid );
			if ( err < 0 )
				{
				if ( JET_errColumnNotFound == err )
					continue;
				goto HandleError;
				}
			}
			
		CallS( ErrINFOGetTableColumnInfo( pfucb, NULL, &columndef ) );
			
		//	if compacting, ignore placeholder
		if ( !fCompacting || !( columndef.grbit & JET_bitColumnRenameConvertToPrimaryIndexPlaceholder ) )
			{
			Call( ErrINFOSetTableColumnInfoList(
					ppib,
					tableid,
					szTableName,
					rgcolumnid,
					&columndef,
					fOrderByColid ) );

			cRows++;
			}
		else if ( fCompacting && ( columndef.grbit & JET_bitColumnRenameConvertToPrimaryIndexPlaceholder ) )
			{

			//	LAURIONB_HACK
			
			g_fCompactTemplateTableColumnDropped = fTrue;
			}
			
		}	// for

	/*	move temporary table cursor to first row and return column list
	/**/
	err = ErrDispMove( (JET_SESID)ppib, tableid, JET_MoveFirst, NO_GRBIT );
	if ( err < 0  )
		{
		if ( err != JET_errNoCurrentRecord )
			goto HandleError;
		err = JET_errSuccess;
		}

	JET_COLUMNLIST	*pcolumnlist;
	pcolumnlist = reinterpret_cast<JET_COLUMNLIST *>( pv );
	pcolumnlist->cbStruct = sizeof(JET_COLUMNLIST);
	pcolumnlist->tableid = tableid;
	pcolumnlist->cRecord = cRows;
	pcolumnlist->columnidPresentationOrder = rgcolumnid[iColumnPOrder];
	pcolumnlist->columnidcolumnname = rgcolumnid[iColumnName];
	pcolumnlist->columnidcolumnid = rgcolumnid[iColumnId];
	pcolumnlist->columnidcoltyp = rgcolumnid[iColumnType];
	pcolumnlist->columnidCountry = rgcolumnid[iColumnCountry];
	pcolumnlist->columnidLangid = rgcolumnid[iColumnLangid];
	pcolumnlist->columnidCp = rgcolumnid[iColumnCp];
	pcolumnlist->columnidCollate = rgcolumnid[iColumnCollate];
	pcolumnlist->columnidcbMax = rgcolumnid[iColumnSize];
	pcolumnlist->columnidgrbit = rgcolumnid[iColumnGrbit];
	pcolumnlist->columnidDefault =	rgcolumnid[iColumnDefault];
	pcolumnlist->columnidBaseTableName = rgcolumnid[iColumnTableName];
	pcolumnlist->columnidBaseColumnName = rgcolumnid[iColumnColumnName];
 	pcolumnlist->columnidDefinitionName = rgcolumnid[iColumnName];

	Assert( NULL != columndef.pbDefault );
	OSMemoryHeapFree( columndef.pbDefault );
	
	return JET_errSuccess;

HandleError:
	(VOID)ErrDispCloseTable( (JET_SESID)ppib, tableid );
	
	//  columndef.pbDefault may be NULL
	OSMemoryHeapFree( columndef.pbDefault );
	
	return err;
	}


LOCAL ERR ErrInfoGetTableColumnInfoBase(
	PIB				*ppib,
	FUCB			*pfucb,
	const CHAR		*szColumnName,
	VOID			*pv,
	const ULONG		cbMax )
	{
	ERR				err;
	INFOCOLUMNDEF	columndef;
	columndef.pbDefault = NULL;

	if ( cbMax < sizeof(JET_COLUMNBASE) || szColumnName == NULL )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	CallR( ErrINFOGetTableColumnInfo( pfucb, szColumnName, &columndef ) );

	Assert( pfucb->u.pfcb->Ptdb() != ptdbNil );

	((JET_COLUMNBASE *)pv)->cbStruct		= sizeof(JET_COLUMNBASE);
	((JET_COLUMNBASE *)pv)->columnid		= columndef.columnid;
	((JET_COLUMNBASE *)pv)->coltyp			= columndef.coltyp;
	((JET_COLUMNBASE *)pv)->wFiller			= 0;
	((JET_COLUMNBASE *)pv)->cbMax			= columndef.cbMax;
	((JET_COLUMNBASE *)pv)->grbit			= columndef.grbit;
	strcpy( ( ( JET_COLUMNBASE *)pv )->szBaseColumnName, szColumnName );
	((JET_COLUMNBASE *)pv)->wCountry		= columndef.wCountry;
	((JET_COLUMNBASE *)pv)->langid  		= columndef.langid;
	((JET_COLUMNBASE *)pv)->cp	   			= columndef.cp;

	pfucb->u.pfcb->EnterDML();
	strcpy( ( ( JET_COLUMNBASE *)pv )->szBaseTableName,
		pfucb->u.pfcb->Ptdb()->SzTableName() );
	pfucb->u.pfcb->LeaveDML();
		
	return JET_errSuccess;
	}


/*=================================================================
ErrIsamGetIndexInfo

Description: Returns a temporary file containing index definition

Parameters:		ppib		   		pointer to PIB for the current session
				ifmp		   		id of database containing the table
				szTableName	 		name of table owning the index
				szIndexName	 		index name
				pv					pointer to result buffer
				cbMax				size of result buffer
				lInfoLevel	 		level of information ( 0, 1, or 2 )

Return Value: JET_errSuccess

Errors/Warnings:

Side Effects:
=================================================================*/
	ERR VDBAPI
ErrIsamGetIndexInfo(
	JET_SESID		vsesid,					/* pointer to PIB for current session */
	JET_DBID		vdbid, 	 				/* id of database containing table */
	const CHAR		*szTable, 				/* name of table owning the index */
	const CHAR		*szIndexName, 			/* index name */
	VOID			*pv,
	unsigned long	cbMax,
	unsigned long	lInfoLevel ) 			/* information level ( 0, 1, or 2 ) */
	{
	ERR				err;
	PIB				*ppib = (PIB *)vsesid;
	IFMP			ifmp;
	CHAR			szTableName[ JET_cbNameMost+1 ];
	FUCB 			*pfucb;

	/*	check parameters
	/**/
	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrPIBCheckIfmp( ppib, (IFMP)vdbid ) );
	ifmp = (IFMP) vdbid;
	CallR( ErrUTILCheckName( szTableName, szTable, ( JET_cbNameMost + 1 ) ) );

	CallR( ErrFILEOpenTable( ppib, ifmp, &pfucb, szTableName, NO_GRBIT ) );
	Assert( pfucbNil != pfucb );
	
	Assert( ( rgfmp[ifmp].FReadOnlyAttach() && !FFUCBUpdatable( pfucb ) )
		|| ( !rgfmp[ifmp].FReadOnlyAttach() && FFUCBUpdatable( pfucb ) ) );
	FUCBResetUpdatable( pfucb );
		
	Call( ErrIsamGetTableIndexInfo(
				(JET_SESID)ppib,
				(JET_VTID)pfucb,
				szIndexName, 
				pv, 
				cbMax, 
				lInfoLevel ) );

HandleError:
	CallS( ErrFILECloseTable( ppib, pfucb ) );
	return err;
	}


/*=================================================================
ErrIsamGetTableIndexInfo

Description: Returns a temporary table containing the index definition

Parameters:		ppib		   		pointer to PIB for the current session
				pfucb		   		FUCB for table owning the index
				szIndexName			index name
				pv					pointer to result buffer
				cbMax				size of result buffer
				lInfoLevel			level of information

Return Value: JET_errSuccess

Errors/Warnings:

Side Effects:
=================================================================*/
	ERR VTAPI
ErrIsamGetTableIndexInfo(
	JET_SESID		vsesid,					/* pointer to PIB for current session */
	JET_VTID		vtid, 					/* FUCB for the table owning the index */
	const CHAR		*szIndex, 				/* index name */
	void			*pb,
	unsigned long	cbMax,
	unsigned long	lInfoLevel )			/* information level ( 0, 1, or 2 ) */
	{
	ERR				err;
	PIB				*ppib			= (PIB *) vsesid;
	FUCB			*pfucb			= (FUCB *) vtid;
	CHAR			szIndexName[JET_cbNameMost+1];

	/*	validate the arguments
	/**/
	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );
	if ( szIndex == NULL || *szIndex == '\0' )
		{
		*szIndexName = '\0';
		}
	else
		{
		CallR( ErrUTILCheckName( szIndexName, szIndex, ( JET_cbNameMost + 1 ) ) );
		}

	switch ( lInfoLevel )
		{
		case JET_IdxInfo:
		case JET_IdxInfoList:
			err = ErrINFOGetTableIndexInfo( ppib, pfucb, szIndexName, pb, cbMax );
			break;
		case JET_IdxInfoIndexId:
			Assert( sizeof(JET_INDEXID) == cbMax );
			err = ErrINFOGetTableIndexIdInfo( ppib, pfucb, szIndexName, (INDEXID *)pb );
			break;
		case JET_IdxInfoSpaceAlloc:
			Assert( sizeof(ULONG) == cbMax );
			err = ErrCATGetIndexAllocInfo(
						ppib,
						pfucb->ifmp,
						pfucb->u.pfcb->ObjidFDP(),
						szIndexName,
						(ULONG *)pb );
			break;
		case JET_IdxInfoLCID:
			{
			LCID	lcid	= lcidNone;
			Assert( sizeof(LANGID) == cbMax
				|| sizeof(LCID) == cbMax );
			CallR( ErrCATGetIndexLcid(
						ppib,
						pfucb->ifmp,
						pfucb->u.pfcb->ObjidFDP(),
						szIndexName,
						&lcid ) );
			if ( cbMax < sizeof(LCID) )
				{
				*(LANGID *)pb = LangidFromLcid( lcid );
				}
			else
				{
				*(LCID *)pb = lcid;
				}
			}
			break;
		case JET_IdxInfoVarSegMac:
			Assert( sizeof(USHORT) == cbMax );
			err = ErrCATGetIndexVarSegMac(
						ppib,
						pfucb->ifmp,
						pfucb->u.pfcb->ObjidFDP(), 
						szIndexName,
						(USHORT *)pb );
			break;
		case JET_IdxInfoCount:
			{
			INT	cIndexes = 1;		// the first index is the primary/sequential index
			FCB	*pfcbT;
			FCB	* const pfcbTable = pfucb->u.pfcb;

			pfcbTable->EnterDML();
			for ( pfcbT = pfcbTable->PfcbNextIndex();
				pfcbT != pfcbNil;
				pfcbT = pfcbT->PfcbNextIndex() )
				{
				err = ErrFILEIAccessIndex( pfucb->ppib, pfcbTable, pfcbT );
				if ( err < 0 )
					{
					if ( JET_errIndexNotFound != err )
						{
						pfcbTable->LeaveDML();
						return err;
						}
					}
				else
					{
					cIndexes++;
					}
				}
			pfcbTable->LeaveDML();

			Assert( sizeof(INT) == cbMax );
			*( (INT *)pb ) = cIndexes;

			err = JET_errSuccess;
			break;
			}

		case JET_IdxInfoSysTabCursor:
		case JET_IdxInfoOLC:
		case JET_IdxInfoResetOLC:
		default:
			Assert( fFalse );		// should be impossible (filtered out by JetGetTableIndexInfo())
			err = ErrERRCheck( JET_errInvalidParameter );
			break;
		}

	return err;
	}


LOCAL ERR ErrINFOGetTableIndexInfo(
	PIB				*ppib,
	FUCB 			*pfucb,
	const CHAR 		*szIndexName,
	VOID			*pv,
	const ULONG		cbMax )
	{
	ERR				err;			/* return code from internal functions */
	FCB				*pfcbTable;
	FCB				*pfcbIndex;		/* file control block for the index */
	TDB				*ptdb;			/* field descriptor block for column */

	LONG			cRecord;		/* number of index entries */
	LONG			cKey;			/* number of unique index entries */
	LONG			cPage;			/* number of pages in the index */
	LONG			cRows;			/* number of index definition records */

	JET_TABLEID		tableid;  		/* table id for the VT */
	JET_COLUMNID	columnid;		/* column id of the current column */
	JET_GRBIT		grbit = 0;		/* flags for the current index */
	JET_GRBIT		grbitColumn;	/* flags for the current column */
	JET_COLUMNID	rgcolumnid[ccolumndefGetIndexInfoMax];

	WORD			wCollate = 0;
	WORD			wT;
	LANGID			langid;			/* langid for the current index */
	DWORD			dwMapFlags;		/* LCMapString() flags for the current index */

	Assert( NULL != szIndexName );
	BOOL			fIndexList = ( '\0' == *szIndexName );
	BOOL			fUpdatingLatchSet = fFalse;

	/*	return nothing if the buffer is too small
	/**/
	if ( cbMax < sizeof(JET_INDEXLIST) - cbIDXLISTNewMembersSinceOriginalFormat )
		return ErrERRCheck( JET_wrnBufferTruncated );

	const ULONG		cbIndexList		= sizeof(JET_INDEXLIST) -
										( cbMax < sizeof(JET_INDEXLIST) ? cbIDXLISTNewMembersSinceOriginalFormat : 0 );

	/*	open the temporary table ( fills in the column ids in rgcolumndef )
	/**/
	CallR( ErrIsamOpenTempTable(
				(JET_SESID)ppib,
				(JET_COLUMNDEF *)rgcolumndefGetIndexInfo,
				ccolumndefGetIndexInfoMax,
				NULL,
				JET_bitTTScrollable|JET_bitTTIndexed,
				&tableid,
				rgcolumnid ) );

	cRows = 0;
	
	/*	set the pointer to the field definitions for the table
	/**/
	pfcbTable = pfucb->u.pfcb;
	Assert( pfcbTable != pfcbNil );

	ptdb = pfcbTable->Ptdb();
	Assert( ptdbNil != ptdb );

	// Treat this as an update (but ignore write conflicts), to freeze index list.
	Call( pfcbTable->ErrSetUpdatingAndEnterDML( ppib, fTrue ) );
	fUpdatingLatchSet = fTrue;

	/*	locate the FCB for the specified index ( if null name, get list of indexes )
	/**/
	pfcbTable->AssertDML();
	for ( pfcbIndex = pfcbTable; pfcbIndex != pfcbNil; pfcbIndex = pfcbIndex->PfcbNextIndex() )
		{
		// Only primary index may not have an IDB.
		Assert( pfcbIndex->Pidb() != pidbNil || pfcbIndex == pfcbTable );
		
		if ( pfcbIndex->Pidb() != pidbNil )
			{
			if ( fIndexList )
				{
				err = ErrFILEIAccessIndex( ppib, pfcbTable, pfcbIndex );
				}
			else
				{
				Assert( NULL != szIndexName );
				err = ErrFILEIAccessIndexByName( ppib, pfcbTable, pfcbIndex, szIndexName );
				}
			if ( err < 0 )
				{
				if ( JET_errIndexNotFound != err )
					{
					pfcbTable->LeaveDML();
					goto HandleError;
					}
				}
			else
				break;		// The index is accessible
			}
		}
		
	pfcbTable->AssertDML();
	
	if ( pfcbNil == pfcbIndex && !fIndexList )
		{
		pfcbTable->LeaveDML();
		err = ErrERRCheck( JET_errIndexNotFound );
		goto HandleError;
		}
	
	/*	as long as there is a valid index, add its definition to the VT
	/**/
	while ( pfcbIndex != pfcbNil )
		{
		CHAR	szCurrIndex[JET_cbNameMost+1];
		IDXSEG	rgidxseg[JET_ccolKeyMost];
		
		pfcbTable->AssertDML();
		
		const IDB		*pidb = pfcbIndex->Pidb();
		Assert( pidbNil != pidb );

		Assert( pidb->ItagIndexName() != 0 );
		strcpy(
			szCurrIndex,
			pfcbTable->Ptdb()->SzIndexName( pidb->ItagIndexName(), pfcbIndex->FDerivedIndex() ) );

		const LONG		cColumn	= pidb->Cidxseg();		/* get number of columns in the key */
		UtilMemCpy( rgidxseg, PidxsegIDBGetIdxSeg( pidb, pfcbTable->Ptdb() ), cColumn * sizeof(IDXSEG) );

		/*	set the index flags
		/**/
		grbit = pidb->GrbitFromFlags();
		langid = LangidFromLcid( pidb->Lcid() );
		dwMapFlags = pidb->DwLCMapFlags();
				
		pfcbTable->LeaveDML();

		/*	process each column in the index key
		/**/
		for ( ULONG iidxseg = 0; iidxseg < cColumn; iidxseg++ )
			{
			FIELD	field;
			CHAR	szFieldName[JET_cbNameMost+1];
			
			Call( ErrDispPrepareUpdate( (JET_SESID)ppib, tableid, JET_prepInsert ) );

			/* index name
			/**/
			Call( ErrDispSetColumn(
						(JET_SESID)ppib,
						tableid,
						rgcolumnid[iIndexName],
						szCurrIndex,
						(ULONG)strlen( szCurrIndex ),
						NO_GRBIT,
						NULL ) );

			/*	index flags
			/**/
			Call( ErrDispSetColumn(
						(JET_SESID)ppib,
						tableid,
						rgcolumnid[iIndexGrbit], 
						&grbit, 
						sizeof( grbit ), 
						NO_GRBIT,
						NULL ) );

			/*	get statistics
			/**/
			Call( ErrSTATSRetrieveIndexStats(
						pfucb,
						szCurrIndex, 
						pfcbIndex->FPrimaryIndex(), 
						&cRecord, 
						&cKey, 
						&cPage ) );
			Call( ErrDispSetColumn(
						(JET_SESID)ppib, 
						tableid,
						rgcolumnid[iIndexCKey], 
						&cKey, 
						sizeof( cKey ), 
						NO_GRBIT,
						NULL ) );
			Call( ErrDispSetColumn( 
						(JET_SESID)ppib, 
						tableid,
						rgcolumnid[iIndexCEntry], 
						&cRecord, 
						sizeof( cRecord ), 
						NO_GRBIT, 
						NULL ) );
			Call( ErrDispSetColumn( 
						(JET_SESID)ppib, 
						tableid,
						rgcolumnid[iIndexCPage], 
						&cPage, 
						sizeof( cPage ), 
						NO_GRBIT,
						NULL ) );

			/*	number of key columns
			/**/
			Call( ErrDispSetColumn( 
						(JET_SESID)ppib, 
						tableid,
						rgcolumnid[iIndexCCol], 
						&cColumn, 
						sizeof( cColumn ), 
						NO_GRBIT, 
						NULL ) );

 			/*	column number within key
			/*	required by CLI and JET spec
			/**/
			Call( ErrDispSetColumn(
						(JET_SESID)ppib, 
						tableid,
						rgcolumnid[iIndexICol], 
						&iidxseg, 
						sizeof( iidxseg ), 
						NO_GRBIT,
						NULL ) );

			/*	get the ascending/descending flag
			/**/
			grbitColumn = ( rgidxseg[iidxseg].FDescending() ?
								JET_bitKeyDescending :
								JET_bitKeyAscending );

			/*	column id
			/**/
			columnid  = rgidxseg[iidxseg].Columnid();
			Call( ErrDispSetColumn(
						(JET_SESID)ppib, 
						tableid,
						rgcolumnid[iIndexColId], 
						&columnid, 
						sizeof( columnid ),
						0, 
						NULL ) );

			/*	make copy of column definition
			/**/
			if ( FCOLUMNIDTemplateColumn( columnid ) && !ptdb->FTemplateTable() )
				{
				ptdb->AssertValidDerivedTable();
				
				const TDB	* const ptdbTemplateTable = ptdb->PfcbTemplateTable()->Ptdb();
				
				field = *( ptdbTemplateTable->Pfield( columnid ) );
				strcpy( szFieldName, ptdbTemplateTable->SzFieldName( field.itagFieldName, fFalse ) );
				}
			else
				{
				pfcbTable->EnterDML();
				field = *( ptdb->Pfield( columnid ) );
				strcpy( szFieldName, ptdb->SzFieldName( field.itagFieldName, fFalse ) );
				pfcbTable->LeaveDML();
				}

			/*	column type
			/**/
				{
				JET_COLTYP coltyp = field.coltyp; // just to resize the variable from 2 to 4 bytes width
				Call( ErrDispSetColumn(
							(JET_SESID)ppib, 
							tableid,
							rgcolumnid[iIndexColType], 
							&coltyp, 
							sizeof( coltyp ), 
							NO_GRBIT,
							NULL ) );
				}

			/*	Country
			/**/
			wT = countryDefault;
			Call( ErrDispSetColumn(
						(JET_SESID)ppib, 
						tableid,
						rgcolumnid[iIndexCountry], 
						&wT, 
						sizeof( wT ), 
						NO_GRBIT, 
						NULL ) );

			/*	Langid
			/**/
			Call( ErrDispSetColumn( 
						(JET_SESID)ppib, 
						tableid,
						rgcolumnid[iIndexLangid], 
						&langid, 
						sizeof( langid ),
						NO_GRBIT,
						NULL ) );

			/*	LCMapStringFlags
			/**/
			Call( ErrDispSetColumn( 
						(JET_SESID)ppib, 
						tableid,
						rgcolumnid[iIndexLCMapFlags], 
						&dwMapFlags, 
						sizeof( dwMapFlags ),
						NO_GRBIT,
						NULL ) );

			/*	Cp
			/**/
			Call( ErrDispSetColumn( 
						(JET_SESID)ppib, 
						tableid,
						rgcolumnid[iIndexCp], 
						&field.cp, 
						sizeof(field.cp), 
						NO_GRBIT,
						NULL ) );

			/* Collate
			/**/
			Call( ErrDispSetColumn( 
						(JET_SESID)ppib, 
						tableid,
						rgcolumnid[iIndexCollate], 
						&wCollate, 
						sizeof(wCollate), 
						NO_GRBIT,
						NULL ) );

			/* column flags
			/**/
			Call( ErrDispSetColumn( 
						(JET_SESID)ppib, 
						tableid,
						rgcolumnid[iIndexColBits], 
						&grbitColumn,
						sizeof( grbitColumn ), 
						NO_GRBIT,
						NULL ) );

			/*	column name
			/**/
			Call( ErrDispSetColumn(
						(JET_SESID)ppib, 
						tableid,
						rgcolumnid[iIndexColName], 
						szFieldName,
						(ULONG)strlen( szFieldName ), 
						NO_GRBIT,
						NULL ) );

			Call( ErrDispUpdate( (JET_SESID)ppib, tableid, NULL, 0, NULL, NO_GRBIT ) );

			/* count the number of VT rows
			/**/
			cRows++;
			}

		/*	quit if an index name was specified; otherwise do the next index
		/**/
		pfcbTable->EnterDML();
		if ( fIndexList )
			{
			for ( pfcbIndex = pfcbIndex->PfcbNextIndex(); pfcbIndex != pfcbNil; pfcbIndex = pfcbIndex-> PfcbNextIndex() )
				{
				err = ErrFILEIAccessIndex( ppib, pfcbTable, pfcbIndex );
				if ( err < 0 )
					{
					if ( JET_errIndexNotFound != err )
						{
						pfcbTable->LeaveDML();
						goto HandleError;
						}
					}
				else
					break;	// The index is accessible.
				}
			}
		else
			{
			pfcbIndex = pfcbNil;
			}
		}	// while ( pfcbIndex != pfcbNil )
		
	pfcbTable->ResetUpdatingAndLeaveDML();
	fUpdatingLatchSet = fFalse;

	/*	position to the first entry in the VT ( ignore error if no rows )
	/**/
	err = ErrDispMove( (JET_SESID)ppib, tableid, JET_MoveFirst, NO_GRBIT );
	if ( err < 0  )
		{
		if ( err != JET_errNoCurrentRecord )
			goto HandleError;
		err = JET_errSuccess;
		}

	/*	set up the return structure
	/**/
	((JET_INDEXLIST *)pv)->cbStruct = cbIndexList;
	((JET_INDEXLIST *)pv)->tableid = tableid;
	((JET_INDEXLIST *)pv)->cRecord = cRows;
	((JET_INDEXLIST *)pv)->columnidindexname = rgcolumnid[iIndexName];
	((JET_INDEXLIST *)pv)->columnidgrbitIndex = rgcolumnid[iIndexGrbit];
	((JET_INDEXLIST *)pv)->columnidcEntry = rgcolumnid[iIndexCEntry];
	((JET_INDEXLIST *)pv)->columnidcKey = rgcolumnid[iIndexCKey];
	((JET_INDEXLIST *)pv)->columnidcPage = rgcolumnid[iIndexCPage];
	((JET_INDEXLIST *)pv)->columnidcColumn = rgcolumnid[iIndexCCol];
	((JET_INDEXLIST *)pv)->columnidiColumn = rgcolumnid[iIndexICol];
	((JET_INDEXLIST *)pv)->columnidcolumnid = rgcolumnid[iIndexColId];
	((JET_INDEXLIST *)pv)->columnidcoltyp = rgcolumnid[iIndexColType];
	((JET_INDEXLIST *)pv)->columnidCountry = rgcolumnid[iIndexCountry];
	((JET_INDEXLIST *)pv)->columnidLangid = rgcolumnid[iIndexLangid];
	((JET_INDEXLIST *)pv)->columnidCp = rgcolumnid[iIndexCp];
	((JET_INDEXLIST *)pv)->columnidCollate = rgcolumnid[iIndexCollate];
	((JET_INDEXLIST *)pv)->columnidgrbitColumn = rgcolumnid[iIndexColBits];
	((JET_INDEXLIST *)pv)->columnidcolumnname = rgcolumnid[iIndexColName];

	if ( cbIndexList < sizeof(JET_INDEXLIST) )
		{
		Assert( cbMax >= sizeof(JET_INDEXLIST) - cbIDXLISTNewMembersSinceOriginalFormat );
		}
	else
		{
		Assert( cbMax >= sizeof(JET_INDEXLIST) );
		((JET_INDEXLIST *)pv)->columnidLCMapFlags = rgcolumnid[iIndexLCMapFlags];
		}

	return JET_errSuccess;

HandleError:
	if ( fUpdatingLatchSet )
		{
		pfcbTable->ResetUpdating();
		}
	(VOID)ErrDispCloseTable( (JET_SESID)ppib, tableid );
	return err;
	}

LOCAL ERR ErrINFOGetTableIndexIdInfo(
	PIB					* ppib,
	FUCB				* pfucb,
	const CHAR			* szIndexName,
	INDEXID				* pindexid )
	{
	ERR					err;
	FCB					* const pfcbTable	= pfucb->u.pfcb;
	FCB					* pfcbIndex;

	Assert( NULL != szIndexName );

	/*	set the pointer to the field definitions for the table
	/**/
	Assert( pfcbTable != pfcbNil );

	// Treat this as an update (but ignore write conflicts), to freeze index list.
	CallR( pfcbTable->ErrSetUpdatingAndEnterDML( ppib, fTrue ) );

	/*	locate the FCB for the specified index ( if null name, get list of indexes )
	/**/
	pfcbTable->AssertDML();
	for ( pfcbIndex = pfcbTable; pfcbIndex != pfcbNil; pfcbIndex = pfcbIndex->PfcbNextIndex() )
		{
		// Only primary index may not have an IDB.
		Assert( pfcbIndex->Pidb() != pidbNil || pfcbIndex == pfcbTable );
		
		if ( pfcbIndex->Pidb() != pidbNil )
			{
			err = ErrFILEIAccessIndexByName(
						ppib,
						pfcbTable,
						pfcbIndex,
						szIndexName );
			if ( err < 0 )
				{
				if ( JET_errIndexNotFound != err )
					{
					goto HandleError;
					}
				}
			else
				{
				CallS( err );
				break;		// The index is accessible
				}
			}
		}

	pfcbTable->AssertDML();

	if ( pfcbNil == pfcbIndex )
		{
		err = ErrERRCheck( JET_errIndexNotFound );
		}
	else
		{
		CallS( err );

		Assert( pfcbIndex->FValid( PinstFromPpib( ppib ) ) );

		Assert( sizeof(INDEXID) == sizeof(JET_INDEXID) );
		pindexid->cbStruct = sizeof(INDEXID);
		pindexid->pfcbIndex = pfcbIndex;
		pindexid->objidFDP = pfcbIndex->ObjidFDP();
		pindexid->pgnoFDP = pfcbIndex->PgnoFDP();
		}

HandleError:
	pfcbTable->AssertDML();
	pfcbTable->ResetUpdatingAndLeaveDML();

	return err;
	}


ERR VDBAPI ErrIsamGetDatabaseInfo(
	JET_SESID		vsesid,
	JET_DBID		vdbid,
	VOID			*pvResult,
	const ULONG		cbMax,
	const ULONG		ulInfoLevel )
	{
	PIB				*ppib = (PIB *)vsesid;
	ERR				err;
	IFMP			ifmp;
	//	UNDONE:	support these fields;
	WORD 			cp			= usEnglishCodePage;
	WORD			wCountry	= countryDefault;
	WORD			wCollate	= 0;

	/*	check parameters
	/**/
	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrPIBCheckIfmp( ppib, (IFMP)vdbid ) );
	ifmp = (IFMP) vdbid;
	
	Assert ( cbMax == 0 || pvResult != NULL );

	//	UNDONE:	move access to FMP internals into io.c for proper MUTEX.
	//			Please note that below is a bug.

	/*	returns database name and connect string given ifmp
	/**/
	if ( ifmp >= ifmpMax || !rgfmp[ifmp].FInUse()  )
		{
		err = ErrERRCheck( JET_errInvalidParameter );
		goto HandleError;
		}

	switch ( ulInfoLevel )
		{
		case JET_DbInfoFilename:
			if ( strlen( rgfmp[ifmp].SzDatabaseName() ) + 1UL > cbMax )
				{
				err = ErrERRCheck( JET_errBufferTooSmall );
				goto HandleError;
				}
			strcpy( (CHAR  *)pvResult, rgfmp[ifmp].SzDatabaseName() );
			break;

		case JET_DbInfoConnect:
			if ( 1UL > cbMax )
				{
				err = ErrERRCheck( JET_errBufferTooSmall );
				goto HandleError;
				}
			*(CHAR *)pvResult = '\0';
			break;

		case JET_DbInfoCountry:
			 if ( cbMax != sizeof(long) )
			    return ErrERRCheck( JET_errInvalidBufferSize );
			*(long  *)pvResult = wCountry;
			break;

		case JET_DbInfoLCID:
			if ( cbMax != sizeof(long) )
	  			return ErrERRCheck( JET_errInvalidBufferSize );
			*(long  *)pvResult = PinstFromPpib( ppib )->m_idxunicodeDefault.lcid;
			break;

		case JET_DbInfoCp:
			if ( cbMax != sizeof(long) )
				return ErrERRCheck( JET_errInvalidBufferSize );
			*(long  *)pvResult = cp;
			break;

		case JET_DbInfoCollate:
	 		/*	check the buffer size
			/**/
	 		if ( cbMax != sizeof(long) )
	    		return ErrERRCheck( JET_errInvalidBufferSize );
     		*(long *)pvResult = wCollate;
     		break;

		case JET_DbInfoOptions:
	 		/*	check the buffer size
			/**/
	 		if ( cbMax != sizeof(JET_GRBIT) )
	    		return ErrERRCheck( JET_errInvalidBufferSize );

			/*	return the open options for the current database
			/**/
			*(JET_GRBIT *)pvResult = rgfmp[ifmp].FExclusiveBySession( ppib ) ? JET_bitDbExclusive : 0;
     		break;

		case JET_DbInfoTransactions:
	 		/*	check the buffer size
			/**/
	 		if ( cbMax != sizeof(long) )
	    		return ErrERRCheck( JET_errInvalidBufferSize );

			*(long*)pvResult = levelUserMost;
     		break;

		case JET_DbInfoVersion:
	 		/*	check the buffer size
			/**/
	 		if ( cbMax != sizeof(long) )
	    		return ErrERRCheck( JET_errInvalidBufferSize );

			*(long *)pvResult = ulDAEVersion;
     		break;

		case JET_DbInfoIsam:
	 		/*	check the buffer size
			/**/
    		return ErrERRCheck( JET_errFeatureNotAvailable );

	    case JET_DbInfoMisc:
	    	if ( sizeof( JET_DBINFOMISC ) != cbMax )
		    		return ErrERRCheck( JET_errInvalidBufferSize );
	    	FillClientBuffer( pvResult, cbMax );
			UtilLoadDbinfomiscFromPdbfilehdr( (JET_DBINFOMISC *) pvResult, rgfmp[ ifmp ].Pdbfilehdr() );
			break;
			
		case JET_DbInfoPageSize:
			if ( sizeof( ULONG ) != cbMax )
				{
				err = ErrERRCheck( JET_errBufferTooSmall );
				goto HandleError;
				}
			
			*(ULONG *)pvResult = ( 0 != rgfmp[ifmp].Pdbfilehdr()->le_cbPageSize ?
											rgfmp[ifmp].Pdbfilehdr()->le_cbPageSize :
											cbPageDefault );
			break;

		case JET_DbInfoFilesize:
		case JET_DbInfoSpaceOwned:
			// Return file size in terms of 4k pages.
			if ( cbMax != sizeof(ULONG) )
				return ErrERRCheck( JET_errInvalidBufferSize );

#ifdef DEBUG
			// FMP should store agree with database's OwnExt tree.
			CallS( ErrSPGetInfo(
						ppib,
						ifmp,
						pfucbNil,
						static_cast<BYTE *>( pvResult ),
						cbMax,
						fSPOwnedExtent ) );
			Assert( *(ULONG *)pvResult == ULONG( rgfmp[ifmp].PgnoLast() ) );
#endif			

			// If filesize, add DB header.
			*(ULONG *)pvResult =
				ULONG( rgfmp[ifmp].PgnoLast() ) +
				( ulInfoLevel == JET_DbInfoFilesize ? cpgDBReserved : 0 );
			break;

		case JET_DbInfoSpaceAvailable:
			err = ErrSPGetInfo(
						ppib,
						ifmp,
						pfucbNil,
						static_cast<BYTE *>( pvResult ),
						cbMax,
						fSPAvailExtent );
			return err;
		case JET_DbInfoHasSLVFile:
			if ( sizeof( BOOL ) != cbMax )
				{
				err = ErrERRCheck( JET_errBufferTooSmall );
				goto HandleError;
				}
			*(BOOL *)pvResult = !!rgfmp[ ifmp ].Pdbfilehdr()->FSLVExists();
			break;

/* UNDONE: remove on code scrub
		case JET_DbInfoStreamingFileSpace:
			if ( sizeof( JET_STREAMINGFILESPACEINFO ) != cbMax )
				{
				return ErrERRCheck( JET_errInvalidBufferSize );
				}
			{
			JET_STREAMINGFILESPACEINFO *const pssi = static_cast< JET_STREAMINGFILESPACEINFO* >( pvResult );
			Call( ErrSLVGetSpaceInformation(	ppib, 
												ifmp, 
												(CPG*)&pssi->cpageOwned, 
												(CPG*)&pssi->cpageAvail ) );
			}
			break;
*/
		default:
			 return ErrERRCheck( JET_errInvalidParameter );
		}

	err = JET_errSuccess;
HandleError:
	return err;
	}


ERR VTAPI ErrIsamGetCursorInfo(
	JET_SESID 		vsesid,
	JET_VTID   		vtid,
	void 	   		*pvResult,
	unsigned long 	cbMax,
	unsigned long 	InfoLevel )
	{
	ERR				err;
	PIB				*ppib	= (PIB *)vsesid;
	FUCB			*pfucb	= (FUCB *)vtid;
	VS				vs;

	CallR( ErrPIBCheck( ppib ) );
	CheckFUCB( pfucb->ppib, pfucb );

	if ( cbMax != 0 || InfoLevel != 0 )
		return ErrERRCheck( JET_errInvalidParameter );

	if ( pfucb->locLogical != locOnCurBM )
		return ErrERRCheck( JET_errNoCurrentRecord );

	//	check if this record is being updated by another cursor
	//
	Assert( !Pcsr( pfucb )->FLatched() );
	
	Call( ErrDIRGet( pfucb ) );
	if ( FNDVersion( pfucb->kdfCurr ) )
		{
		vs = VsVERCheck( pfucb, pfucb->bmCurr );
		if ( vs == vsUncommittedByOther )
			{
			CallS( ErrDIRRelease( pfucb ) );
			return ErrERRCheck( JET_errWriteConflict );
			}
		}

	CallS( ErrDIRRelease( pfucb ) );

	//	temporary tables are never visible to other sessions
	//
	if ( pfucb->u.pfcb->FTypeTemporaryTable() )
		err = JET_errSuccess;

HandleError:
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\logapi.cxx ===
#include "std.hxx"
#include <ctype.h>

//	global log disabled flag
//

BOOL	g_fLGIgnoreVersion = fFalse;

ERR ErrLGIMacroBegin( PIB *ppib, DBTIME dbtime );
ERR ErrLGIMacroEnd( PIB *ppib, DBTIME dbtime, LRTYP lrtyp, LGPOS *plgpos );

//********************************************************
//****     deferred begin transactions                ****
//********************************************************

LOCAL ERR ErrLGIDeferBeginTransaction( PIB *ppib );

INLINE ERR ErrLGDeferBeginTransaction( PIB *ppib )
	{
	Assert( ppib->level > 0 );
	const ERR	err		= ( 0 != ppib->clevelsDeferBegin ?
									ErrLGIDeferBeginTransaction( ppib ) :
									JET_errSuccess );
	return err;
	}


//********************************************************
//****     Page Oriented Operations                   ****
//********************************************************

//	WARNING: If fVersion bit needs to be set, ensure it's set before
//	calling this function, as it will be reset if necessary.
INLINE VOID LGISetTrx( PIB *ppib, LRPAGE_ *plrpage, const VERPROXY * const pverproxy = NULL )
	{
	if ( NULL == pverproxy )
		{
		plrpage->le_trxBegin0 = ppib->trxBegin0;
		plrpage->level = ppib->level;
		}
	else
		{
		Assert( prceNil != pverproxy->prcePrimary );
		plrpage->le_trxBegin0 = pverproxy->prcePrimary->TrxBegin0();
		if ( trxMax == pverproxy->prcePrimary->TrxCommitted() )
			{
			Assert( pverproxy->prcePrimary->Level() > 0 );
			plrpage->level = pverproxy->prcePrimary->Level();
			}
		else
			{
			plrpage->level = 0;
			
			//	for redo, don't version proxy operations if they have
			//	already committed (at do time, we still need to version
			//	them for visibility reasons -- the indexer may not be
			//	able to see them once he's finished building the index)
			plrpage->ResetFVersioned();
			}
		}
	}

INLINE ERR ErrLGSetDbtimeBeforeAndDirty(
	CSR									* const pcsr,
	UnalignedLittleEndian< DBTIME >		* ple_dbtimeBefore,
	UnalignedLittleEndian< DBTIME >		* ple_dbtime,
	const BOOL							fDirty )
	{
	ERR									err			= JET_errSuccess;

	Assert ( NULL != pcsr );
	Assert ( NULL != ple_dbtimeBefore );
	Assert ( NULL != ple_dbtime );
	
	if ( fDirty )
		{
		*ple_dbtimeBefore = pcsr->Dbtime();
		pcsr->Dirty();

		if ( pcsr->Dbtime() <= *ple_dbtimeBefore )
			{
			pcsr->RevertDbtime( *ple_dbtimeBefore );
			FireWall();
			err = ErrERRCheck( JET_errDbTimeCorrupted );
			}
		}
	else
		{
		*ple_dbtimeBefore = dbtimeNil;
		}
		
	*ple_dbtime = pcsr->Dbtime();
	Assert( pcsr->Dbtime() == pcsr->Cpage().Dbtime() );

	return err;
	}
	
ERR ErrLGInsert( const FUCB				* const pfucb,
				 CSR					* const pcsr,
				 const KEYDATAFLAGS&	kdf,
				 const RCEID			rceid,
				 const DIRFLAG			dirflag,
				 LGPOS					* const plgpos,
				 const VERPROXY			* const pverproxy,
				 const BOOL				fDirtyCSR ) 	// true - if we must dirty the page inside (in witch case dbtime before is in the CSR
			 											// false - record dbtimeInvalid for dbtimeBefore (insert part of split operations)
	{
	ERR				err;
	DATA			rgdata[4];
	LRINSERT		lrinsert;

	INST *pinst = PinstFromIfmp( pfucb->ifmp );
	LOG *plog = pinst->m_plog;
	
	Assert( !plog->m_fRecovering );
	
	Assert( fDirtyCSR || pcsr->FDirty() );
	
	if ( plog->m_fLogDisabled )
		{
		if ( fDirtyCSR )
			{
			pcsr->Dirty();
			}
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	Assert( !( dirflag & fDIRNoLog ) );
	Assert( rgfmp[pfucb->ifmp].FLogOn() );

	PIB	* const ppib = pverproxy != NULL &&
					trxMax == pverproxy->prcePrimary->TrxCommitted() ?
						pverproxy->prcePrimary->Pfucb()->ppib :
						pfucb->ppib;
	Assert( NULL == pverproxy ||
			prceNil != pverproxy->prcePrimary &&
			( pverproxy->prcePrimary->TrxCommitted() != trxMax ||
			  pfucbNil != pverproxy->prcePrimary->Pfucb() &&
			  ppibNil != pverproxy->prcePrimary->Pfucb()->ppib ) );
						
	//	must be in a transaction since we will not redo level 0 modifications
	//
	Assert( ppib->level > 0 );

	CallR( ErrLGDeferBeginTransaction( ppib ) );

	lrinsert.lrtyp		= lrtypInsert;

	Assert( pcsr->ILine() >= 0 );
	Assert( pcsr->ILine() < ( 1 << 10 ) );
	lrinsert.SetILine( (USHORT)pcsr->ILine() );

	Assert( !lrinsert.FVersioned() );
	Assert( !lrinsert.FDeleted() );
	Assert( !lrinsert.FUnique() );
	Assert( !lrinsert.FSpace() );
	Assert( !lrinsert.FConcCI() );

	if ( !( dirflag & fDIRNoVersion ) )
		lrinsert.SetFVersioned();
	if ( pfucb->u.pfcb->FUnique() )
		lrinsert.SetFUnique();
	if ( FFUCBSpace( pfucb ) )
		lrinsert.SetFSpace();
	if ( NULL != pverproxy )
		lrinsert.SetFConcCI();

	lrinsert.le_rceid		= rceid;
	lrinsert.le_pgnoFDP		= PgnoFDP( pfucb );
	lrinsert.le_objidFDP	= ObjidFDP( pfucb );

	lrinsert.le_procid 	= ppib->procid;

	CallR( ErrLGSetDbtimeBeforeAndDirty( pcsr, &lrinsert.le_dbtimeBefore, &lrinsert.le_dbtime, fDirtyCSR ) )

	lrinsert.dbid			= rgfmp[ pfucb->ifmp ].Dbid();
	lrinsert.le_pgno		= pcsr->Pgno();

	LGISetTrx( ppib, &lrinsert, pverproxy );

	lrinsert.SetCbSuffix( USHORT( kdf.key.suffix.Cb() ) );
	lrinsert.SetCbPrefix( USHORT( kdf.key.prefix.Cb() ) );
	lrinsert.SetCbData( USHORT( kdf.data.Cb() ) );

	rgdata[0].SetPv( (BYTE *)&lrinsert );
	rgdata[0].SetCb( sizeof(LRINSERT) );
	
	rgdata[1].SetPv( kdf.key.prefix.Pv() );
	rgdata[1].SetCb( kdf.key.prefix.Cb() );
	
	rgdata[2].SetPv( kdf.key.suffix.Pv() );
	rgdata[2].SetCb( kdf.key.suffix.Cb() );
	
	rgdata[3].SetPv( kdf.data.Pv() );
	rgdata[3].SetCb( kdf.data.Cb() );

	err = plog->ErrLGLogRec( rgdata, 4, fLGNoNewGen, plgpos );

	// on error, return to before dirty dbtime on page
	if ( JET_errSuccess > err && fDirtyCSR )
		{
		Assert ( dbtimeInvalid !=  lrinsert.le_dbtimeBefore && dbtimeNil != lrinsert.le_dbtimeBefore);
		Assert ( pcsr->Dbtime() > lrinsert.le_dbtimeBefore );
		pcsr->RevertDbtime( lrinsert.le_dbtimeBefore );
		}
		
	return err;
	}


ERR ErrLGFlagInsertAndReplaceData( const FUCB		 	* const pfucb, 
								   CSR			* const pcsr, 
								   const KEYDATAFLAGS&	kdf, 
								   const RCEID			rceidInsert,
								   const RCEID			rceidReplace,
								   const DIRFLAG		dirflag, 
								   LGPOS				* const plgpos,
								   const VERPROXY		* const pverproxy, 
								 const BOOL				fDirtyCSR ) 	// true - if we must dirty the page inside (in witch case dbtime before is in the CSR
			 															// false - record dbtimeInvalid for dbtimeBefore (insert part of split operations)
								   
	{
	ERR							err;
	DATA						rgdata[4];
	LRFLAGINSERTANDREPLACEDATA	lrfiard;

	INST *pinst = PinstFromIfmp( pfucb->ifmp );
	LOG *plog = pinst->m_plog;
	
	Assert( !plog->m_fRecovering );

	Assert( fDirtyCSR || pcsr->FDirty() );
	
	if ( plog->m_fLogDisabled )
		{
		if ( fDirtyCSR )
			{
			pcsr->Dirty();
			}				
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	Assert( !( dirflag & fDIRNoLog ) );
	Assert( rgfmp[pfucb->ifmp].FLogOn() );

	PIB	* const ppib = pverproxy != NULL && 
					trxMax == pverproxy->prcePrimary->TrxCommitted() ?
						pverproxy->prcePrimary->Pfucb()->ppib :
						pfucb->ppib;
	Assert( NULL == pverproxy ||
			prceNil != pverproxy->prcePrimary &&
			( pverproxy->prcePrimary->TrxCommitted() != trxMax ||
			  pfucbNil != pverproxy->prcePrimary->Pfucb() &&
			  ppibNil != pverproxy->prcePrimary->Pfucb()->ppib ) );

	//	must be in a transaction since we will not redo level 0 modifications
	//
	Assert( ppib->level > 0 );

	CallR( ErrLGDeferBeginTransaction( ppib ) );

	lrfiard.lrtyp		= lrtypFlagInsertAndReplaceData;

	Assert( pcsr->ILine() >= 0 );
	Assert( pcsr->ILine() < ( 1 << 10 ) );
	lrfiard.SetILine( (USHORT)pcsr->ILine() );

	Assert( !lrfiard.FVersioned() );
	Assert( !lrfiard.FDeleted() );
	Assert( !lrfiard.FUnique() );
	Assert( !lrfiard.FSpace() );
	Assert( !lrfiard.FConcCI() );

	if ( !( dirflag & fDIRNoVersion ) )
		lrfiard.SetFVersioned();
	if ( pfucb->u.pfcb->FUnique() )
		lrfiard.SetFUnique();
	if ( FFUCBSpace( pfucb ) )
		lrfiard.SetFSpace();
	if ( NULL != pverproxy )
		lrfiard.SetFConcCI();

	lrfiard.le_rceid			= rceidInsert;
	lrfiard.le_rceidReplace		= rceidReplace;
	lrfiard.le_pgnoFDP			= PgnoFDP( pfucb );
	lrfiard.le_objidFDP			= ObjidFDP( pfucb );
	
	lrfiard.le_procid 		= ppib->procid;

	CallR( ErrLGSetDbtimeBeforeAndDirty( pcsr, &lrfiard.le_dbtimeBefore, &lrfiard.le_dbtime, fDirtyCSR ) );
								
	lrfiard.dbid		= rgfmp[ pfucb->ifmp ].Dbid();
	lrfiard.le_pgno		= pcsr->Pgno();

	LGISetTrx( ppib, &lrfiard, pverproxy );
	
	Assert( !kdf.key.FNull() );
	lrfiard.SetCbKey( USHORT( kdf.key.Cb() ) );
	lrfiard.SetCbData( USHORT( kdf.data.Cb() ) );

	rgdata[0].SetPv( (BYTE *)&lrfiard );
	rgdata[0].SetCb( sizeof(LRFLAGINSERTANDREPLACEDATA) );

	rgdata[1].SetPv( kdf.key.prefix.Pv() );
	rgdata[1].SetCb( kdf.key.prefix.Cb() );
	
	rgdata[2].SetPv( kdf.key.suffix.Pv() );
	rgdata[2].SetCb( kdf.key.suffix.Cb() );
	
	rgdata[3].SetPv( kdf.data.Pv() );
	rgdata[3].SetCb( kdf.data.Cb() );

	err = plog->ErrLGLogRec( rgdata, 4, fLGNoNewGen, plgpos );

	// on error, return to before dirty dbtime on page
	if ( JET_errSuccess > err && fDirtyCSR )
		{
		Assert ( dbtimeInvalid !=  lrfiard.le_dbtimeBefore && dbtimeNil != lrfiard.le_dbtimeBefore);
		Assert ( pcsr->Dbtime() > lrfiard.le_dbtimeBefore );
		pcsr->RevertDbtime( lrfiard.le_dbtimeBefore );
		}

	return err;
	}
	
	
ERR ErrLGFlagInsert( const FUCB 			* const pfucb, 
					 CSR					* const pcsr,
					 const KEYDATAFLAGS& 	kdf,
					 const RCEID			rceid,
					 const DIRFLAG			dirflag, 
					 LGPOS					* const plgpos,
					 const VERPROXY			* const pverproxy ,
					 const BOOL				fDirtyCSR ) 	// true - if we must dirty the page inside (in witch case dbtime before is in the CSR
				 											// false - record dbtimeInvalid for dbtimeBefore (insert part of split operations)			 
	{
	ERR				err;
	DATA			rgdata[4];
	LRFLAGINSERT	lrflaginsert;

	INST *pinst = PinstFromIfmp( pfucb->ifmp );
	LOG *plog = pinst->m_plog;
	
	Assert( !plog->m_fRecovering );
	Assert( fDirtyCSR || pcsr->FDirty() );
	
	if ( plog->m_fLogDisabled )
		{
		if ( fDirtyCSR )
			{
			pcsr->Dirty();
			}		
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	Assert( !( dirflag & fDIRNoLog ) );
	Assert( rgfmp[pfucb->ifmp].FLogOn() );

	Assert( NULL == pverproxy ||
			prceNil != pverproxy->prcePrimary &&
			( pverproxy->prcePrimary->TrxCommitted() != trxMax ||
			  pfucbNil != pverproxy->prcePrimary->Pfucb() &&
			  ppibNil != pverproxy->prcePrimary->Pfucb()->ppib ) );
			  
	PIB	* const ppib = pverproxy != NULL && 
					trxMax == pverproxy->prcePrimary->TrxCommitted() ?
						pverproxy->prcePrimary->Pfucb()->ppib :
						pfucb->ppib;
			  
	//	must be in a transaction since we will not redo level 0 modifications
	//
	Assert( ppib->level > 0 );

	CallR( ErrLGDeferBeginTransaction( ppib ) );
	
	lrflaginsert.lrtyp		= lrtypFlagInsert;

	Assert( pcsr->ILine() >= 0 );
	Assert( pcsr->ILine() < ( 1 << 10 ) );
	lrflaginsert.SetILine( (USHORT)pcsr->ILine() );

	Assert( !lrflaginsert.FVersioned() );
	Assert( !lrflaginsert.FDeleted() );
	Assert( !lrflaginsert.FUnique() );
	Assert( !lrflaginsert.FSpace() );
	Assert( !lrflaginsert.FConcCI() );

	if ( !( dirflag & fDIRNoVersion ) )
		lrflaginsert.SetFVersioned();
	if ( pfucb->u.pfcb->FUnique() )
		lrflaginsert.SetFUnique();
	if ( FFUCBSpace( pfucb ) )
		lrflaginsert.SetFSpace();
	if ( NULL != pverproxy )
		lrflaginsert.SetFConcCI();

	lrflaginsert.le_rceid		= rceid;
	lrflaginsert.le_pgnoFDP		= PgnoFDP( pfucb );
	lrflaginsert.le_objidFDP	= ObjidFDP( pfucb );
	
	lrflaginsert.le_procid 	= ppib->procid;

	CallR( ErrLGSetDbtimeBeforeAndDirty( pcsr, &lrflaginsert.le_dbtimeBefore, &lrflaginsert.le_dbtime, fDirtyCSR ) );

	lrflaginsert.dbid			= rgfmp[ pfucb->ifmp ].Dbid();
	lrflaginsert.le_pgno		= pcsr->Pgno();

	LGISetTrx( ppib, &lrflaginsert, pverproxy );
	
	Assert( !kdf.key.FNull() );
	lrflaginsert.SetCbKey( USHORT( kdf.key.Cb() ) );
	lrflaginsert.SetCbData(	USHORT( kdf.data.Cb() ) );

	rgdata[0].SetPv( (BYTE *)&lrflaginsert );
	rgdata[0].SetCb( sizeof(LRFLAGINSERT) );

	rgdata[1].SetPv( kdf.key.prefix.Pv() );
	rgdata[1].SetCb( kdf.key.prefix.Cb() );
	
	rgdata[2].SetPv( kdf.key.suffix.Pv() );
	rgdata[2].SetCb( kdf.key.suffix.Cb() );
	
	rgdata[3].SetPv( kdf.data.Pv() );
	rgdata[3].SetCb( kdf.data.Cb() );

	err = plog->ErrLGLogRec( rgdata, 4, fLGNoNewGen, plgpos );

	// on error, return to before dirty dbtime on page
	if ( JET_errSuccess > err && fDirtyCSR )
		{
		Assert ( dbtimeInvalid !=  lrflaginsert.le_dbtimeBefore && dbtimeNil != lrflaginsert.le_dbtimeBefore);
		Assert ( pcsr->Dbtime() > lrflaginsert.le_dbtimeBefore );
		pcsr->RevertDbtime( lrflaginsert.le_dbtimeBefore );
		}

	return err;
	}
	
ERR ErrLGSetExternalHeader( const FUCB 	*pfucb, 
							CSR 	*pcsr, 
							const DATA&	data, 
							LGPOS		*plgpos,
						const BOOL		fDirtyCSR ) 	// true - if we must dirty the page inside (in witch case dbtime before is in the CSR
						 								// false - record dbtimeInvalid for dbtimeBefore (insert part of split operations)
				 
	{
	ERR					err;
	LRSETEXTERNALHEADER	lrsetextheader;
	DATA				rgdata[2];

	INST *pinst = PinstFromIfmp( pfucb->ifmp );
	LOG *plog = pinst->m_plog;
	
	Assert( !plog->m_fRecovering );
	Assert( fDirtyCSR || pcsr->FDirty() );
	
	if ( plog->m_fLogDisabled )
		{
		if ( fDirtyCSR )
			{
			pcsr->Dirty();
			}		
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	Assert( rgfmp[pfucb->ifmp].FLogOn() );

	PIB		*ppib	= pfucb->ppib;

	Assert( ppib->level > 0 );

	//	Redo only operation
	
	CallR( ErrLGDeferBeginTransaction( ppib ) );

	lrsetextheader.lrtyp = lrtypSetExternalHeader;
	
	lrsetextheader.le_procid	= ppib->procid;
	lrsetextheader.dbid			= rgfmp[ pfucb->ifmp ].Dbid();
	lrsetextheader.le_pgno		= pcsr->Pgno();
	lrsetextheader.le_pgnoFDP	= PgnoFDP( pfucb );
	lrsetextheader.le_objidFDP	= ObjidFDP( pfucb );

	Assert( !lrsetextheader.FVersioned() );
	Assert( !lrsetextheader.FDeleted() );
	Assert( !lrsetextheader.FUnique() );
	Assert( !lrsetextheader.FSpace() );
	Assert( !lrsetextheader.FConcCI() );

	if ( pfucb->u.pfcb->FUnique() )
		lrsetextheader.SetFUnique();
	if ( FFUCBSpace( pfucb ) )
		lrsetextheader.SetFSpace();

	CallR( ErrLGSetDbtimeBeforeAndDirty( pcsr, &lrsetextheader.le_dbtimeBefore, &lrsetextheader.le_dbtime, fDirtyCSR ) );
	
	LGISetTrx( ppib, &lrsetextheader );
	
	lrsetextheader.SetCbData( USHORT( data.Cb() ) );

	rgdata[0].SetPv( (BYTE *)&lrsetextheader );
	rgdata[0].SetCb( sizeof(LRSETEXTERNALHEADER) );

	rgdata[1].SetPv( data.Pv() );
	rgdata[1].SetCb( data.Cb() );

	err = plog->ErrLGLogRec( rgdata, 2, fLGNoNewGen, plgpos );

	// on error, return to before dirty dbtime on page
	if ( JET_errSuccess > err && fDirtyCSR )
		{
		Assert ( dbtimeInvalid !=  lrsetextheader.le_dbtimeBefore && dbtimeNil != lrsetextheader.le_dbtimeBefore);
		Assert ( pcsr->Dbtime() > lrsetextheader.le_dbtimeBefore );
		pcsr->RevertDbtime( lrsetextheader.le_dbtimeBefore );
		}

	return err;
	}

ERR ErrLGReplace( const FUCB 	* const pfucb, 
				  CSR		* const pcsr,
				  const	DATA&	dataOld, 
				  const DATA&	dataNew,
				  const DATA	* const pdataDiff,
				  const RCEID	rceid,
				  const DIRFLAG	dirflag, 
				  LGPOS			* const plgpos,
				 const BOOL				fDirtyCSR ) 	// true - if we must dirty the page inside (in witch case dbtime before is in the CSR
			 															// false - record dbtimeInvalid for dbtimeBefore (insert part of split operations)
				  
	{
	ERR			err;
	DATA		rgdata[2];
	LRREPLACE	lrreplace;

	INST *pinst = PinstFromIfmp( pfucb->ifmp );
	LOG *plog = pinst->m_plog;
	
	Assert( !plog->m_fRecovering );
	Assert( fDirtyCSR || pcsr->FDirty() );
	
	if ( plog->m_fLogDisabled )
		{
		if ( fDirtyCSR )
			{
			pcsr->Dirty();
			}				
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	Assert( !( dirflag & fDIRNoLog ) );
	Assert( rgfmp[pfucb->ifmp].FLogOn() );
			  
	PIB	* const ppib = pfucb->ppib;
			  
	//	must be in a transaction since we will not redo level 0 modifications
	//
	Assert( ppib->level > 0 );
	
	CallR( ErrLGDeferBeginTransaction( ppib ) );

	Assert( pcsr->ILine() >= 0 );
	Assert( pcsr->ILine() < ( 1 << 10 ) );
	lrreplace.SetILine( (USHORT)pcsr->ILine() );

	Assert( !lrreplace.FVersioned() );
	Assert( !lrreplace.FDeleted() );
	Assert( !lrreplace.FUnique() );
	Assert( !lrreplace.FSpace() );
	Assert( !lrreplace.FConcCI() );

	if ( !( dirflag & fDIRNoVersion ) )
		lrreplace.SetFVersioned();
	if ( pfucb->u.pfcb->FUnique() )
		lrreplace.SetFUnique();
	if ( FFUCBSpace( pfucb ) )
		lrreplace.SetFSpace();

	lrreplace.le_rceid		= rceid;
	lrreplace.le_pgnoFDP	= PgnoFDP( pfucb );
	lrreplace.le_objidFDP	= ObjidFDP( pfucb );

	lrreplace.le_procid	= ppib->procid;

	CallR( ErrLGSetDbtimeBeforeAndDirty( pcsr, &lrreplace.le_dbtimeBefore, &lrreplace.le_dbtime, fDirtyCSR ) );
							
	lrreplace.dbid			= rgfmp[ pfucb->ifmp ].Dbid();
	lrreplace.le_pgno		= pcsr->Pgno();

	LGISetTrx( ppib, &lrreplace );
	
	lrreplace.SetCbOldData( USHORT( dataOld.Cb() ) );
	lrreplace.SetCbNewData( USHORT( dataNew.Cb() ) );

	rgdata[0].SetPv( (BYTE *)&lrreplace );
	rgdata[0].SetCb( sizeof(LRREPLACE) );

	if ( NULL != pdataDiff )
		{
		lrreplace.lrtyp		= lrtypReplaceD;
		lrreplace.SetCb( (USHORT)pdataDiff->Cb() );
		rgdata[1].SetCb( pdataDiff->Cb() );
		rgdata[1].SetPv( pdataDiff->Pv() );
		}
	else
		{
		lrreplace.lrtyp 	= lrtypReplace;
		lrreplace.SetCb( (USHORT)dataNew.Cb() );
		rgdata[1].SetCb( dataNew.Cb() );
		rgdata[1].SetPv( dataNew.Pv() );
		}

	err = plog->ErrLGLogRec( rgdata, 2, fLGNoNewGen, plgpos );

	// on error, return to before dirty dbtime on page
	if ( JET_errSuccess > err && fDirtyCSR )
		{
		Assert ( dbtimeInvalid !=  lrreplace.le_dbtimeBefore && dbtimeNil != lrreplace.le_dbtimeBefore);
		Assert ( pcsr->Dbtime() > lrreplace.le_dbtimeBefore );
		pcsr->RevertDbtime( lrreplace.le_dbtimeBefore );
		}

	Assert(	lrreplace.Cb() <= lrreplace.CbNewData() );
	Assert( lrreplace.CbNewData() == lrreplace.Cb()
		|| lrreplace.lrtyp == lrtypReplaceD );
	return err;
	}

ERR ErrLGAtomicReplaceAndCommit(
		const FUCB 	* const pfucb, 
		CSR		* const pcsr,
		const	DATA&	dataOld, 
		const DATA&	dataNew,
		const DATA	* const pdataDiff,
		const DIRFLAG	dirflag, 
		LGPOS			* const plgpos,
		const BOOL				fDirtyCSR ) 	// true - if we must dirty the page inside (in witch case dbtime before is in the CSR
			 															// false - record dbtimeInvalid for dbtimeBefore (insert part of split operations)				  
	{
	ERR			err;
	DATA		rgdata[3];
	LRREPLACE	lrreplace;
	LRCOMMIT0	lrcommit0;

	INST *pinst = PinstFromIfmp( pfucb->ifmp );
	LOG *plog = pinst->m_plog;
	
	Assert( !plog->m_fRecovering );
	Assert( fDirtyCSR || pcsr->FDirty() );
	
	if ( plog->m_fLogDisabled )
		{
		if ( fDirtyCSR )
			{
			pcsr->Dirty();
			}				
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	Assert( !( dirflag & fDIRNoLog ) );
	Assert( rgfmp[pfucb->ifmp].FLogOn() );
			  
	PIB	* const ppib = pfucb->ppib;
			  
	//	must be in a transaction since we will not redo level 0 modifications
	//
	Assert( ppib->level > 0 );
	
	CallR( ErrLGDeferBeginTransaction( ppib ) );

	Assert( pcsr->ILine() >= 0 );
	Assert( pcsr->ILine() < ( 1 << 10 ) );
	lrreplace.SetILine( (USHORT)pcsr->ILine() );

	Assert( !lrreplace.FVersioned() );
	Assert( !lrreplace.FDeleted() );
	Assert( !lrreplace.FUnique() );
	Assert( !lrreplace.FSpace() );
	Assert( !lrreplace.FConcCI() );

	Assert( !FFUCBSpace( pfucb ) );
	Assert( pfucb->u.pfcb->FUnique() );
	
	lrreplace.SetFUnique();

	lrreplace.le_rceid		= rceidNull;
	lrreplace.le_pgnoFDP	= PgnoFDP( pfucb );
	lrreplace.le_objidFDP	= ObjidFDP( pfucb );

	lrreplace.le_procid		= ppib->procid;

	CallR( ErrLGSetDbtimeBeforeAndDirty( pcsr, &lrreplace.le_dbtimeBefore, &lrreplace.le_dbtime, fDirtyCSR ) );
							
	lrreplace.dbid			= rgfmp[ pfucb->ifmp ].Dbid();
	lrreplace.le_pgno		= pcsr->Pgno();

	LGISetTrx( ppib, &lrreplace );
	
	lrreplace.SetCbOldData( USHORT( dataOld.Cb() ) );
	lrreplace.SetCbNewData( USHORT( dataNew.Cb() ) );

	rgdata[0].SetPv( (BYTE *)&lrreplace );
	rgdata[0].SetCb( sizeof(LRREPLACE) );

	if ( NULL != pdataDiff )
		{
		lrreplace.lrtyp		= lrtypReplaceD;
		lrreplace.SetCb( (USHORT)pdataDiff->Cb() );
		rgdata[1].SetCb( pdataDiff->Cb() );
		rgdata[1].SetPv( pdataDiff->Pv() );
		}
	else
		{
		lrreplace.lrtyp 	= lrtypReplace;
		lrreplace.SetCb( (USHORT)dataNew.Cb() );
		rgdata[1].SetCb( dataNew.Cb() );
		rgdata[1].SetPv( dataNew.Pv() );
		}

	Assert( ppib->procid < 64000 );
	Assert( ppib->trxCommit0 != trxMax );
	Assert( 1 == ppib->level );	//  this can only be used to commit from level 1 to level 0
	
	lrcommit0.le_trxCommit0 = ppib->trxCommit0;
	lrcommit0.lrtyp 		= lrtypCommit0;
	lrcommit0.le_procid 	= (USHORT) ppib->procid;
	lrcommit0.levelCommitTo	= 0;

	rgdata[2].SetPv( (BYTE *)&lrcommit0 );
	rgdata[2].SetCb( sizeof(LRCOMMIT0) );

	err = plog->ErrLGLogRec( rgdata, 3, fLGNoNewGen, plgpos );

	// on error, return to before dirty dbtime on page
	if ( JET_errSuccess > err && fDirtyCSR )
		{
		Assert ( dbtimeInvalid !=  lrreplace.le_dbtimeBefore && dbtimeNil != lrreplace.le_dbtimeBefore);
		Assert ( pcsr->Dbtime() > lrreplace.le_dbtimeBefore );
		pcsr->RevertDbtime( lrreplace.le_dbtimeBefore );
		}

	Assert(	lrreplace.Cb() <= lrreplace.CbNewData() );
	Assert( lrreplace.CbNewData() == lrreplace.Cb()
		|| lrreplace.lrtyp == lrtypReplaceD );
	return err;
	}


//	log Deferred Undo Info of given RCE.
 
ERR ErrLGIUndoInfo( const RCE *prce, LGPOS *plgpos, const BOOL fRetry )
	{
	ERR				err;
	FUCB   			* pfucb			= prce->Pfucb();
	const PGNO		pgnoUndoInfo	= prce->PgnoUndoInfo();
	INST			* pinst			= PinstFromIfmp( pfucb->ifmp );
	LOG				* plog			= pinst->m_plog;
	LRUNDOINFO		lrundoinfo;
	DATA   			rgdata[4];

	*plgpos = lgposMin;
	
	//	NOTE: even during recovering, we might want to record it if
	//	NOTE: it is logging during undo in LGEndAllSession.
	//
	Assert( !rgfmp[pfucb->ifmp].FLogOn() || !plog->m_fLogDisabled );
	if ( !rgfmp[pfucb->ifmp].FLogOn() )
		{		
		return JET_errSuccess;
		}

	//	Multiple threads may be trying to log UndoInfo (BF when it flushes or
	//	original thread when transaction is rolled back)
	//	It doesn't actually matter if multiple UndoInfo's are logged (on
	//	recovery, any UndoInfo log records beyond the first will cause
	//	be ignored because version creation will err out with JET_errPreviousVersion).
	if ( pgnoNull == pgnoUndoInfo )
		{
		//	someone beat us to it, so just bail out
		return JET_errSuccess;
		}

	if ( plog->m_fLogDisabledDueToRecoveryFailure )
		{
		return ErrERRCheck( JET_errLogDisabledDueToRecoveryFailure );
		}
		
	if ( plog->m_fRecovering && plog->m_fRecoveringMode == fRecoveringRedo )
		{
		return ErrERRCheck( JET_errCannotLogDuringRecoveryRedo );
		}

	Assert( pfucb->ppib->level > 0 );

	lrundoinfo.lrtyp		= lrtypUndoInfo;
	lrundoinfo.le_procid	= pfucb->ppib->procid;
	lrundoinfo.dbid			= rgfmp[ pfucb->ifmp ].Dbid();

	Assert( !lrundoinfo.FVersioned() );
	Assert( !lrundoinfo.FDeleted() );
	Assert( !lrundoinfo.FUnique() );
	Assert( !lrundoinfo.FSpace() );
	Assert( !lrundoinfo.FConcCI() );

	if ( pfucb->u.pfcb->FUnique() )
		lrundoinfo.SetFUnique();

	Assert( !FFUCBSpace( pfucb ) );

	lrundoinfo.le_dbtime		= dbtimeNil;
	lrundoinfo.le_dbtimeBefore 	= dbtimeNil;

	Assert( rceidNull != prce->Rceid() );
	lrundoinfo.le_rceid		= prce->Rceid();
	lrundoinfo.le_pgnoFDP	= prce->PgnoFDP();
	lrundoinfo.le_objidFDP	= prce->ObjidFDP();

	lrundoinfo.le_pgno		= pgnoUndoInfo;
	lrundoinfo.level	= prce->Level();
	lrundoinfo.le_trxBegin0 = prce->TrxBegin0();
	lrundoinfo.le_oper		= USHORT( prce->Oper() );
	if ( prce->FOperReplace() )
		{
		Assert( prce->CbData() > cbReplaceRCEOverhead );
		lrundoinfo.le_cbData	= USHORT( prce->CbData() - cbReplaceRCEOverhead );

		VERREPLACE* const pverreplace = (VERREPLACE*)prce->PbData();
		lrundoinfo.le_cbMaxSize = (SHORT) pverreplace->cbMaxSize;
		lrundoinfo.le_cbDelta	= (SHORT) pverreplace->cbDelta;
		}
	else
		{
		Assert( prce->CbData() == 0 );
		lrundoinfo.le_cbData = 0;
		}

	BOOKMARK	bm;
	prce->GetBookmark( &bm );
	Assert( bm.key.prefix.FNull() );
	lrundoinfo.SetCbBookmarkData( USHORT( bm.data.Cb() ) );
	lrundoinfo.SetCbBookmarkKey( USHORT( bm.key.suffix.Cb() ) );

	rgdata[0].SetPv( (BYTE *)&lrundoinfo );
	rgdata[0].SetCb( sizeof(LRUNDOINFO) );

	Assert( 0 == bm.key.prefix.Cb() );
	rgdata[1].SetPv( bm.key.suffix.Pv() );
	rgdata[1].SetCb( lrundoinfo.CbBookmarkKey() );

	rgdata[2].SetPv( bm.data.Pv() );
	rgdata[2].SetCb( lrundoinfo.CbBookmarkData() );
	
	rgdata[3].SetPv( const_cast<BYTE *>( prce->PbData() ) + cbReplaceRCEOverhead );
	rgdata[3].SetCb( lrundoinfo.le_cbData );

	forever
		{
		err = plog->ErrLGTryLogRec( rgdata, 4, fLGNoNewGen, plgpos );
		if ( errLGNotSynchronous != err || !fRetry )
			break;

		UtilSleep( cmsecWaitLogFlush );
		}

	return err;
	}


ERR ErrLGFlagDelete( const FUCB * const pfucb, 
					 CSR	* const pcsr,
					 const RCEID	rceid,
					 const DIRFLAG 	dirflag,
					 LGPOS		* const plgpos,
					 const VERPROXY	* const pverproxy,
					 const BOOL				fDirtyCSR ) 	// true - if we must dirty the page inside (in witch case dbtime before is in the CSR
				 											// false - record dbtimeInvalid for dbtimeBefore (insert part of split operations)
				 	
	{
	ERR				err;
	LRFLAGDELETE	lrflagdelete;
	DATA			rgdata[1];

	INST *pinst = PinstFromIfmp( pfucb->ifmp );
	LOG *plog = pinst->m_plog;
	
	Assert( !plog->m_fRecovering );
	Assert( fDirtyCSR || pcsr->FDirty() );
	
	if ( plog->m_fLogDisabled )
		{
		if ( fDirtyCSR )
			{
			pcsr->Dirty();
			}				
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	Assert( !( dirflag & fDIRNoLog ) );
	Assert( rgfmp[pfucb->ifmp].FLogOn() );

	Assert( NULL == pverproxy ||
			prceNil != pverproxy->prcePrimary &&
			( pverproxy->prcePrimary->TrxCommitted() != trxMax ||
			  pfucbNil != pverproxy->prcePrimary->Pfucb() &&
			  ppibNil != pverproxy->prcePrimary->Pfucb()->ppib ) );
			  
	PIB	* const ppib = pverproxy != NULL && 
					trxMax == pverproxy->prcePrimary->TrxCommitted() ?
						pverproxy->prcePrimary->Pfucb()->ppib :
						pfucb->ppib;
			  
	//	assert in a transaction since will not redo level 0 modifications
	//
	Assert( ppib->level > 0 );
	
	CallR( ErrLGDeferBeginTransaction( ppib ) );
	
	lrflagdelete.lrtyp		= lrtypFlagDelete;

	Assert( pcsr->ILine() >= 0 );
	Assert( pcsr->ILine() < ( 1 << 10 ) );
	lrflagdelete.SetILine( (USHORT)pcsr->ILine() );
	lrflagdelete.le_procid		= ppib->procid;

	CallR( ErrLGSetDbtimeBeforeAndDirty( pcsr, &lrflagdelete.le_dbtimeBefore, &lrflagdelete.le_dbtime, fDirtyCSR ) );
	
	lrflagdelete.dbid			= rgfmp[ pfucb->ifmp ].Dbid();
	lrflagdelete.le_pgno		= pcsr->Pgno();

	Assert( !lrflagdelete.FVersioned() );
	Assert( !lrflagdelete.FDeleted() );
	Assert( !lrflagdelete.FUnique() );
	Assert( !lrflagdelete.FSpace() );
	Assert( !lrflagdelete.FConcCI() );

	if ( !( dirflag & fDIRNoVersion ) )
		lrflagdelete.SetFVersioned();
	if ( pfucb->u.pfcb->FUnique() )
		lrflagdelete.SetFUnique();
	if ( FFUCBSpace( pfucb ) )
		lrflagdelete.SetFSpace();
	if ( NULL != pverproxy )
		lrflagdelete.SetFConcCI();

	LGISetTrx( ppib, &lrflagdelete, pverproxy );

	lrflagdelete.le_rceid		= rceid;
	lrflagdelete.le_pgnoFDP	= PgnoFDP( pfucb );
	lrflagdelete.le_objidFDP	= ObjidFDP( pfucb );
	
	rgdata[0].SetPv( (BYTE *)&lrflagdelete );
	rgdata[0].SetCb( sizeof(LRFLAGDELETE) );

	err = plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, plgpos );

	// on error, return to before dirty dbtime on page
	if ( JET_errSuccess > err && fDirtyCSR )
		{
		Assert ( dbtimeInvalid !=  lrflagdelete.le_dbtimeBefore && dbtimeNil != lrflagdelete.le_dbtimeBefore);
		Assert ( pcsr->Dbtime() > lrflagdelete.le_dbtimeBefore );
		pcsr->RevertDbtime( lrflagdelete.le_dbtimeBefore );
		}

	return err;
	}

	
ERR ErrLGDelete( 	const FUCB 		*pfucb,
					CSR 			*pcsr,
					LGPOS 			*plgpos , 
					const BOOL		fDirtyCSR ) 	// true - if we must dirty the page inside (in witch case dbtime before is in the CSR
							 								// false - record dbtimeInvalid for dbtimeBefore (insert part of split operations)
	{
	ERR			err;
	LRDELETE	lrdelete;
	DATA		rgdata[1];

	INST *pinst = PinstFromIfmp( pfucb->ifmp );
	LOG *plog = pinst->m_plog;

	Assert( fDirtyCSR || pcsr->FDirty() );
	if ( plog->m_fRecovering || plog->m_fLogDisabled )
		{
		if ( fDirtyCSR )
			{
			pcsr->Dirty();
			}
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	Assert( rgfmp[pfucb->ifmp].FLogOn() );

	//	assert in a transaction since will not redo level 0 modifications
	//
	PIB		*ppib	= pfucb->ppib;
	Assert( ppib->level > 0 );


	//	Redo only operation

	CallR( ErrLGDeferBeginTransaction( ppib ) );

	lrdelete.lrtyp		= lrtypDelete;

	Assert( pcsr->ILine() >= 0 );
	Assert( pcsr->ILine() < ( 1 << 10 ) );
	lrdelete.SetILine( (USHORT)pcsr->ILine() );
	lrdelete.le_procid		= ppib->procid;

	CallR( ErrLGSetDbtimeBeforeAndDirty( pcsr, &lrdelete.le_dbtimeBefore, &lrdelete.le_dbtime, fDirtyCSR ) );

	lrdelete.le_pgnoFDP	= PgnoFDP( pfucb );
	lrdelete.le_objidFDP	= ObjidFDP( pfucb );
	
	lrdelete.le_pgno		= pcsr->Pgno();
	lrdelete.dbid			= rgfmp[ pfucb->ifmp ].Dbid();

	Assert( !lrdelete.FVersioned() );
	Assert( !lrdelete.FDeleted() );
	Assert( !lrdelete.FUnique() );
	Assert( !lrdelete.FSpace() );
	Assert( !lrdelete.FConcCI() );

	if ( pfucb->u.pfcb->FUnique() )
		lrdelete.SetFUnique();
	if ( FFUCBSpace( pfucb ) )
		lrdelete.SetFSpace();

	LGISetTrx( ppib, &lrdelete );
	
	rgdata[0].SetPv( (BYTE *)&lrdelete );
	rgdata[0].SetCb( sizeof(LRDELETE) );

	err = plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, plgpos );

	// on error, return to before dirty dbtime on page
	if ( JET_errSuccess > err && fDirtyCSR )
		{
		Assert ( dbtimeInvalid !=  lrdelete.le_dbtimeBefore && dbtimeNil != lrdelete.le_dbtimeBefore);
		Assert ( pcsr->Dbtime() > lrdelete.le_dbtimeBefore );
		pcsr->RevertDbtime( lrdelete.le_dbtimeBefore );
		}

	return err;
	}


ERR ErrLGUndo( 	RCE 			*prce,
				CSR 			*pcsr,
				const BOOL		fDirtyCSR ) 	// true - if we must dirty the page inside (in witch case dbtime before is in the CSR
				 								// false - record dbtimeInvalid for dbtimeBefore (insert part of split operations)
	{
	ERR				err;
	FUCB * 			pfucb 			= prce->Pfucb();
	LRUNDO			lrundo;
	DATA   			rgdata[3];
	LGPOS			lgpos;

	INST *pinst = PinstFromIfmp( pfucb->ifmp );
	LOG *plog = pinst->m_plog;

	Assert( fDirtyCSR );
	
	//	NOTE: even during recovering, we want to record it
	//
	if ( plog->m_fLogDisabled || ( plog->m_fRecovering && plog->m_fRecoveringMode != fRecoveringUndo ) )
		{
		pcsr->Dirty();
		Assert( pcsr->Dbtime() == pcsr->Cpage().Dbtime() );

		// During ForceDetach we may crash after we did some undo's
		// To avoid replaying those we change dbtime on the page with 
		// a new dbtime that will be check if we retry the undo
		if ( rgfmp[pfucb->ifmp].FUndoForceDetach() )
			{
			pcsr->SetDbtime( rgfmp[pfucb->ifmp].DbtimeUndoForceDetach() - prce->Rceid() );
			// update the dbtime of the db after the redo phase (dbtimeCurrent)
			Assert ( pcsr->Dbtime() > rgfmp[ pfucb->ifmp ].DbtimeCurrentDuringRecovery() );
			rgfmp[ pfucb->ifmp ].SetDbtimeCurrentDuringRecovery( pcsr->Dbtime() );
			}
		return JET_errSuccess;
		}
		
	Assert ( !rgfmp[pfucb->ifmp].FUndoForceDetach() );

	if ( !rgfmp[pfucb->ifmp].FLogOn() )
		{
		pcsr->Dirty();
		Assert( pcsr->Dbtime() == pcsr->Cpage().Dbtime() );
		return JET_errSuccess;
		}

	// only undo during normal operations must go this way
	// in this case the CSR must be the same as in the FUCB (from RCE)
	Assert ( Pcsr( pfucb ) == pcsr );

	
	//	must be in a transaction since we will not redo level 0 modifications
	//
	PIB		*ppib	= pfucb->ppib;
	Assert( ppib->level > 0 );
	
	Assert( pcsr->FLatched() );
	Assert( fDirtyCSR || pcsr->FDirty() );

	CallR( ErrLGDeferBeginTransaction( ppib ) );
	
	lrundo.lrtyp		= lrtypUndo;
	
	lrundo.level		= prce->Level();
	lrundo.le_procid		= ppib->procid;

	CallR( ErrLGSetDbtimeBeforeAndDirty( pcsr, &lrundo.le_dbtimeBefore, &lrundo.le_dbtime, fDirtyCSR ) );

	lrundo.dbid				= rgfmp[prce->Pfucb()->ifmp].Dbid();
	lrundo.le_oper			= USHORT( prce->Oper() );
	Assert( lrundo.le_oper == prce->Oper() );		// regardless the size 
	Assert( lrundo.le_oper != operMaskNull );
	
	Assert( pcsr->ILine() >= 0 );
	Assert( pcsr->ILine() < ( 1 << 10 ) );
	lrundo.SetILine( (USHORT)pcsr->ILine() );
	lrundo.le_pgno			= pcsr->Pgno();

	Assert( !lrundo.FVersioned() );
	Assert( !lrundo.FDeleted() );
	Assert( !lrundo.FUnique() );
	Assert( !lrundo.FSpace() );
	Assert( !lrundo.FConcCI() );

	if ( pfucb->u.pfcb->FUnique() )
		lrundo.SetFUnique();

	Assert( !FFUCBSpace( pfucb ) );

	LGISetTrx( ppib, &lrundo );
	
	lrundo.le_rceid		= prce->Rceid();
	lrundo.le_pgnoFDP 	= PgnoFDP( pfucb );
	lrundo.le_objidFDP 	= ObjidFDP( pfucb );

	BOOKMARK	bm;
	prce->GetBookmark( &bm );

	Assert( bm.key.prefix.FNull() );
	lrundo.SetCbBookmarkKey( USHORT( bm.key.Cb() ) );
	lrundo.SetCbBookmarkData( USHORT( bm.data.Cb() ) );
	
	rgdata[0].SetPv( (BYTE *)&lrundo );
	rgdata[0].SetCb( sizeof(LRUNDO) );

	rgdata[1].SetPv( bm.key.suffix.Pv() );
	rgdata[1].SetCb( lrundo.CbBookmarkKey() );

	rgdata[2].SetPv( bm.data.Pv() );
	rgdata[2].SetCb( bm.data.Cb() );
	Assert( !lrundo.FUnique() || bm.data.FNull() );

	Call( plog->ErrLGLogRec( rgdata, 3, fLGNoNewGen, &lgpos ) );
	CallS( err );
	Assert( pcsr->Latch() == latchWrite );

	pcsr->Cpage().SetLgposModify( lgpos );

	Assert ( JET_errSuccess <= err );

HandleError:
	// on error, return to before dirty dbtime on page
	if ( JET_errSuccess > err && fDirtyCSR )
		{
		Assert ( dbtimeInvalid !=  lrundo.le_dbtimeBefore && dbtimeNil != lrundo.le_dbtimeBefore);
		Assert ( pcsr->Dbtime() > lrundo.le_dbtimeBefore );
		pcsr->RevertDbtime( lrundo.le_dbtimeBefore );
		}

	return err;
	}


ERR ErrLGDelta( const FUCB 		*pfucb, 
				CSR		*pcsr,
				const BOOKMARK&	bm,
				INT				cbOffset,
				LONG	 		lDelta, 
				RCEID			rceid,
				DIRFLAG			dirflag,
				LGPOS			*plgpos,
			 	const BOOL		fDirtyCSR ) 	// true - if we must dirty the page inside (in witch case dbtime before is in the CSR
				 								// false - record dbtimeInvalid for dbtimeBefore (insert part of split operations)
				 
	{
	DATA		rgdata[4];
	LRDELTA		lrdelta;
	ERR			err;

	INST *pinst = PinstFromIfmp( pfucb->ifmp );
	LOG *plog = pinst->m_plog;
	
	Assert( !plog->m_fRecovering );
	Assert( fDirtyCSR || pcsr->FDirty() );
	
	if ( plog->m_fLogDisabled )
		{
		if ( fDirtyCSR )
			{
			pcsr->Dirty();
			}				
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	Assert( rgfmp[pfucb->ifmp].FLogOn() );
			  
	PIB		* const ppib = pfucb->ppib;
			  
	//	must be in a transaction since we will not redo level 0 modifications
	//
	Assert( ppib->level > 0 );

	CallR( ErrLGDeferBeginTransaction( ppib ) );

	lrdelta.lrtyp		= lrtypDelta;

	Assert( pcsr->ILine() >= 0 );
	Assert( pcsr->ILine() < ( 1 << 10 ) );
	lrdelta.SetILine( (USHORT)pcsr->ILine() );
	lrdelta.le_procid		= ppib->procid;

	CallR( ErrLGSetDbtimeBeforeAndDirty( pcsr, &lrdelta.le_dbtimeBefore, &lrdelta.le_dbtime, fDirtyCSR ) );

	lrdelta.dbid		= rgfmp[ pfucb->ifmp ].Dbid();
	lrdelta.le_pgno		= pcsr->Pgno();

	Assert( !lrdelta.FVersioned() );
	Assert( !lrdelta.FDeleted() );
	Assert( !lrdelta.FUnique() );
	Assert( !lrdelta.FSpace() );
	Assert( !lrdelta.FConcCI() );

	if ( !( dirflag & fDIRNoVersion ) )
		lrdelta.SetFVersioned();
	if ( pfucb->u.pfcb->FUnique() )
		lrdelta.SetFUnique();

	Assert( !FFUCBSpace( pfucb ) );

	LGISetTrx( ppib, &lrdelta );
	
	lrdelta.le_rceid		= rceid;
	lrdelta.le_pgnoFDP		= PgnoFDP( pfucb );
	lrdelta.le_objidFDP	= ObjidFDP( pfucb );

	lrdelta.SetCbBookmarkKey( USHORT( bm.key.Cb() ) );
	lrdelta.SetCbBookmarkData( USHORT( bm.data.Cb() ) );
	Assert( 0 == bm.data.Cb() );
	
	lrdelta.SetLDelta( lDelta );

	Assert( cbOffset < g_cbPage );
	lrdelta.SetCbOffset( USHORT( cbOffset ) );
	
	rgdata[0].SetPv( (BYTE *)&lrdelta );
	rgdata[0].SetCb( sizeof( LRDELTA ) );

	rgdata[1].SetPv( bm.key.prefix.Pv() );
	rgdata[1].SetCb( bm.key.prefix.Cb() );

	rgdata[2].SetPv( bm.key.suffix.Pv() );
	rgdata[2].SetCb( bm.key.suffix.Cb() );

	rgdata[3].SetPv( bm.data.Pv() );
	rgdata[3].SetCb( bm.data.Cb() );
	
	err = plog->ErrLGLogRec( rgdata, 4, fLGNoNewGen, plgpos );

	// on error, return to before dirty dbtime on page
	if ( JET_errSuccess > err && fDirtyCSR )
		{
		Assert ( dbtimeInvalid !=  lrdelta.le_dbtimeBefore && dbtimeNil != lrdelta.le_dbtimeBefore);
		Assert ( pcsr->Dbtime() > lrdelta.le_dbtimeBefore );
		pcsr->RevertDbtime( lrdelta.le_dbtimeBefore );
		}

	return err;
	}


#ifdef DISABLE_SLV
#else
ERR ErrLGSLVSpace( 	const FUCB 			* const pfucb, 
					CSR					* const pcsr,
					const BOOKMARK&		bm,
					const SLVSPACEOPER 	oper,
					const LONG			ipage,
					const LONG			cpages,
					const RCEID			rceid,
					const DIRFLAG		dirflag,
					LGPOS				* const plgpos,
					const BOOL			fDirtyCSR ) 	// true - if we must dirty the page inside (in witch case dbtime before is in the CSR
							 							// false - record dbtimeInvalid for dbtimeBefore (insert part of split operations)
	{
	DATA		rgdata[4];
	LRSLVSPACE	lrslvspace;
	ERR			err;

	INST * const pinst 	= PinstFromIfmp( pfucb->ifmp );
	LOG * const plog 	= pinst->m_plog;
	
	Assert( !plog->m_fRecovering );
	Assert( fDirtyCSR || pcsr->FDirty() );
	
	if ( plog->m_fLogDisabled )
		{
		if ( fDirtyCSR )
			{
			pcsr->Dirty();
			}
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	Assert( rgfmp[pfucb->ifmp].FLogOn() );
			  
	PIB		* const ppib = pfucb->ppib;
			  
	//	must be in a transaction since we will not redo level 0 modifications
	//
	Assert( ppib->level > 0 );

	CallR( ErrLGDeferBeginTransaction( ppib ) );

	lrslvspace.lrtyp		= lrtypSLVSpace;

	Assert( pcsr->ILine() >= 0 );
	Assert( pcsr->ILine() < ( 1 << 10 ) );
	lrslvspace.SetILine( (USHORT)pcsr->ILine() );
	lrslvspace.le_procid		= ppib->procid;

	CallR( ErrLGSetDbtimeBeforeAndDirty( pcsr, &lrslvspace.le_dbtimeBefore, &lrslvspace.le_dbtime, fDirtyCSR ) );
	
	lrslvspace.dbid			= rgfmp[ pfucb->ifmp ].Dbid();
	lrslvspace.le_pgno		= pcsr->Pgno();

	Assert( !lrslvspace.FVersioned() );
	Assert( !lrslvspace.FDeleted() );
	Assert( !lrslvspace.FUnique() );
	Assert( !lrslvspace.FSpace() );
	Assert( !lrslvspace.FConcCI() );

	if ( !( dirflag & fDIRNoVersion ) )
		lrslvspace.SetFVersioned();
	if ( pfucb->u.pfcb->FUnique() )
		lrslvspace.SetFUnique();

	Assert( !FFUCBSpace( pfucb ) );

	LGISetTrx( ppib, &lrslvspace );
	
	lrslvspace.le_rceid		= rceid;
	lrslvspace.le_pgnoFDP		= PgnoFDP( pfucb );
	lrslvspace.le_objidFDP	= ObjidFDP( pfucb );

	lrslvspace.le_cbBookmarkKey = USHORT( bm.key.Cb() );
	lrslvspace.le_cbBookmarkData = USHORT( bm.data.Cb() );
	Assert( 0 == bm.data.Cb() );

	Assert( oper >= 0 );
	Assert( oper <= 0xff );
	lrslvspace.oper			= BYTE( oper );
	Assert( ipage >= 0 );
	Assert( ipage <= 0xffff );
	lrslvspace.le_ipage		= USHORT( ipage );
	Assert( cpages >= 0 );
	Assert( cpages <= 0xffff );
	lrslvspace.le_cpages	= USHORT( cpages );

	rgdata[0].SetPv( (BYTE *)&lrslvspace );
	rgdata[0].SetCb( sizeof( lrslvspace ) );

	rgdata[1].SetPv( bm.key.prefix.Pv() );
	rgdata[1].SetCb( bm.key.prefix.Cb() );

	rgdata[2].SetPv( bm.key.suffix.Pv() );
	rgdata[2].SetCb( bm.key.suffix.Cb() );

	rgdata[3].SetPv( bm.data.Pv() );
	rgdata[3].SetCb( bm.data.Cb() );
	
	err = plog->ErrLGLogRec( rgdata, 4, fLGNoNewGen, plgpos );

	// on error, return to before dirty dbtime on page
	if ( JET_errSuccess > err && fDirtyCSR )
		{
		Assert ( dbtimeInvalid !=  lrslvspace.le_dbtimeBefore && dbtimeNil != lrslvspace.le_dbtimeBefore);
		Assert ( pcsr->Dbtime() > lrslvspace.le_dbtimeBefore );
		pcsr->RevertDbtime( lrslvspace.le_dbtimeBefore );
		}

	return err;
	}

#endif	//	DISABLE_SLV


		//**************************************************
		//     Transaction Operations                       
		//**************************************************


//	logs deferred open transactions.  No error returned since
//	failure to log results in termination.
//
LOCAL ERR ErrLGIDeferBeginTransaction( PIB *ppib )
	{
	ERR	   		err;
	DATA		rgdata[1];
	LRBEGINDT	lrbeginDT;

	INST *pinst = PinstFromPpib( ppib );
	LOG *plog = pinst->m_plog;
	
	ENTERCRITICALSECTION	enterCritLogDeferBeginTrx( &ppib->critLogDeferBeginTrx );

	//	check again, because if a proxy existed, it may have logged
	//	the defer-begin for us
	if ( 0 == ppib->clevelsDeferBegin )
		{
		return JET_errSuccess;
		}

	Assert( !plog->m_fLogDisabled );
	Assert( ppib->clevelsDeferBegin > 0 );
	Assert( !plog->m_fRecovering );

	//	if using reserve log space, try to allocate more space
	//	to resume normal logging.

	//	HACK: use the file-system stored in the INST
	//		  (otherwise, we will need to drill a pfsapi down through to EVERY logged operation that 
	//		   begins a deferred operation and that means ALL the B-Tree code will be touched among
	//		   other things)
	CallR( ErrLGCheckState( plog ) );

	//	begin transaction may be logged during rollback if
	//	rollback is from a higher transaction level which has
	//	not performed any updates.
	//
	Assert( ppib->procid < 64000 );
	lrbeginDT.le_procid = (USHORT) ppib->procid;

	lrbeginDT.levelBeginFrom = ppib->levelBegin;
	Assert(	lrbeginDT.levelBeginFrom >= 0 );
	Assert( lrbeginDT.levelBeginFrom <= levelMax );
	lrbeginDT.clevelsToBegin = (BYTE)ppib->clevelsDeferBegin;
	Assert(	lrbeginDT.clevelsToBegin >= 0 );
	Assert( lrbeginDT.clevelsToBegin <= levelMax );

	rgdata[0].SetPv( (BYTE *) &lrbeginDT );
	if ( 0 == lrbeginDT.levelBeginFrom )
		{
		Assert( ppib->trxBegin0 != trxMax );
///		Assert( ppib->trxBegin0 != trxMin );	//	wrap-around can make this true
		lrbeginDT.le_trxBegin0 = ppib->trxBegin0;

		if ( ppib->FDistributedTrx() )
			{
			lrbeginDT.lrtyp = lrtypBeginDT;
			rgdata[0].SetCb( sizeof(LRBEGINDT) );
			}
		else
			{
			lrbeginDT.lrtyp = lrtypBegin0;
			rgdata[0].SetCb( sizeof(LRBEGIN0) );
			}
		}
	else
		{
		lrbeginDT.lrtyp = lrtypBegin;
		rgdata[0].SetCb( sizeof(LRBEGIN) );
		}

	LGPOS lgposLogRec;
	err = plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, &lgposLogRec );

	//	reset deferred open transaction count
	//	Also set the ppib->lgposStart if it is begin for level 0.
	//
	if ( err >= 0 )
		{
		ppib->clevelsDeferBegin = 0;
		if ( 0 == lrbeginDT.levelBeginFrom )
			{	
			ppib->SetFBegin0Logged();
			ppib->lgposStart = lgposLogRec;
			}
		}

	return err;
	}

#ifdef DEBUG
VOID LGJetOp( JET_SESID sesid, INT op )
	{
	DATA		rgdata[1];
	PIB			*ppib = (PIB *) sesid;
	LRJETOP		lrjetop;

	if ( sesid == (JET_SESID)0xffffffff )
		return;

	INST *pinst = PinstFromPpib( ppib );
	LOG *plog = pinst->m_plog;
	
	if ( !plog->m_fLogDisabled && !plog->m_fRecovering )
		{
		Assert( plog->m_fLogDisabled == fFalse );
		Assert( plog->m_fRecovering == fFalse );

		lrjetop.lrtyp = lrtypJetOp;
		Assert( ppib->procid < 64000 );
		lrjetop.le_procid = (USHORT) ppib->procid;
		lrjetop.op = (BYTE)op;
		rgdata[0].SetPv( (BYTE *) &lrjetop );
		rgdata[0].SetCb( sizeof(LRJETOP) );
	
		plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, pNil );
		}
	}
#endif

ERR ErrLGBeginTransaction( PIB * const ppib )
	{
	const INST	* const pinst	= PinstFromPpib( ppib );
	const LOG	* const plog	= pinst->m_plog;
	
	if ( plog->m_fLogDisabled || plog->m_fRecovering )
		return JET_errSuccess;

	if ( 0 == ppib->clevelsDeferBegin )
		{
		ppib->levelBegin = ppib->level;
		}

	ppib->clevelsDeferBegin++;
	Assert( ppib->clevelsDeferBegin < levelMax );

	return JET_errSuccess;
	}


ERR ErrLGRefreshTransaction( PIB *ppib )
	{
	ERR			err;
	LRREFRESH	lrrefresh;
	DATA		rgdata[1];
	
	INST *pinst = PinstFromPpib( ppib );
	LOG *plog = pinst->m_plog;
	
	if ( plog->m_fLogDisabled || plog->m_fRecovering )
		return JET_errSuccess;

	//	Dead code
	
	CallR( ErrLGDeferBeginTransaction( ppib ) );

	//	log refresh operation
	//
	rgdata[0].SetPv( (BYTE *) &lrrefresh );
	rgdata[0].SetCb( sizeof ( LRREFRESH ) );
	lrrefresh.lrtyp = lrtypRefresh;
	Assert( ppib->procid < 64000 );
	lrrefresh.le_procid = (USHORT) ppib->procid;
	lrrefresh.le_trxBegin0 = (ppib)->trxBegin0;		

	plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, pNil );

	return JET_errSuccess;
	}

ERR ErrLGCommitTransaction( PIB *ppib, const LEVEL levelCommitTo, const TRX trxCommit0, LGPOS *plgposRec )
	{
	ERR			err;
	DATA		rgdata[1];
	LRCOMMIT0	lrcommit0;

	INST *pinst = PinstFromPpib( ppib );
	LOG *plog = pinst->m_plog;

	*plgposRec = lgposMax;
	
	if ( plog->m_fLogDisabled || ( plog->m_fRecovering && plog->m_fRecoveringMode != fRecoveringUndo ) )
		return JET_errSuccess;

	if ( ppib->clevelsDeferBegin > 0 )
		{
		Assert( !plog->m_fRecovering );
		ppib->clevelsDeferBegin--;
		if ( levelCommitTo == 0 )
			{
			Assert( 0 == ppib->clevelsDeferBegin );
			Assert( !ppib->FBegin0Logged() );
			*plgposRec = lgposMin;
			}
		return JET_errSuccess;
		}

	Assert( ppib->procid < 64000 );
	lrcommit0.le_procid = (USHORT) ppib->procid;
	lrcommit0.levelCommitTo = levelCommitTo;

	rgdata[0].SetPv( (BYTE *)&lrcommit0 );

	if ( levelCommitTo == 0 )
		{
		Assert( trxCommit0 != trxMax );
///		Assert( trxCommit0 != trxMin );	//	wrap-around can make this true
		lrcommit0.le_trxCommit0 = trxCommit0;
		lrcommit0.lrtyp = lrtypCommit0;
		rgdata[0].SetCb( sizeof(LRCOMMIT0) );
		}
	else
		{
		lrcommit0.lrtyp = lrtypCommit;
		rgdata[0].SetCb( sizeof(LRCOMMIT) );
		}

	err = plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, plgposRec );
	Assert( err >= 0 || plog->m_fLGNoMoreLogWrite );

	if ( 0 == levelCommitTo
		&& err >= 0 )
		{
		ppib->ResetFBegin0Logged();
		}

	return err;
	}

ERR ErrLGRollback( PIB *ppib, LEVEL levelsRollback )
	{
	ERR			err;
	DATA		rgdata[1];
	LRROLLBACK	lrrollback;
	INST		* pinst		= PinstFromPpib( ppib );
	LOG			* plog		= pinst->m_plog;
	
	if ( plog->m_fLogDisabled || ( plog->m_fRecovering && plog->m_fRecoveringMode != fRecoveringUndo ) )
		return JET_errSuccess;

	if ( ppib->clevelsDeferBegin > 0 )
		{
		Assert( !plog->m_fRecovering );
		if ( ppib->clevelsDeferBegin >= levelsRollback )
			{
			ppib->clevelsDeferBegin = LEVEL( ppib->clevelsDeferBegin - levelsRollback );
			return JET_errSuccess;
			}
		levelsRollback = LEVEL( levelsRollback - ppib->clevelsDeferBegin );
		ppib->clevelsDeferBegin = 0;
		}

	Assert( levelsRollback > 0 );
	lrrollback.lrtyp = lrtypRollback;
	Assert( ppib->procid < 64000 );
	lrrollback.le_procid = (USHORT) ppib->procid;
	lrrollback.levelRollback = levelsRollback;

	rgdata[0].SetPv( (BYTE *)&lrrollback );
	rgdata[0].SetCb( sizeof(LRROLLBACK) );
	
	err = plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, pNil );
		
	if ( 0 == ppib->level )
		{
		//	transaction is no longee outstanding,
		//	so MUST reset flag, even on failure
		//	(otherwise subsequent transaction
		//	will still have the flag set)
		ppib->ResetFBegin0Logged();
		}

 	return err;
	}

#ifdef DTC
ERR ErrLGPrepareToCommitTransaction(
	PIB				* const ppib,
	const VOID		* const pvData,
	const ULONG		cbData )
	{
	ERR				err;
	DATA			rgdata[2];
	INST			* const pinst	= PinstFromPpib( ppib );
	LOG				* const plog	= pinst->m_plog;
	LGPOS			lgposRec;
	LRPREPCOMMIT	lrprepcommit;

	if ( plog->m_fLogDisabled || plog->m_fRecovering )
		{
		Assert( !plog->m_fRecovering );		//	shouldn't be called during recovery
		return JET_errSuccess;
		}

	if ( ppib->clevelsDeferBegin > 0 )
		{
		Assert( 1 == ppib->clevelsDeferBegin );
		Assert( !ppib->FBegin0Logged() );
		return JET_errSuccess;
		}

	lrprepcommit.lrtyp = lrtypPrepCommit;

	Assert( ppib->procid < 64000 );
	lrprepcommit.le_procid = (USHORT)ppib->procid;

	lrprepcommit.le_cbData = cbData;

	rgdata[0].SetPv( &lrprepcommit );
	rgdata[0].SetCb( sizeof(lrprepcommit) );

	rgdata[1].SetPv( (VOID *)pvData );
	rgdata[1].SetCb( cbData );

	err = plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, &lgposRec );
	Assert( err >= 0 || plog->m_fLGNoMoreLogWrite );
	Call( err );

	ppib->lgposCommit0 = lgposRec;
	err = plog->ErrLGWaitCommit0Flush( ppib );
	CallSx( err, JET_errLogWriteFail );
	Assert( JET_errSuccess == err || plog->m_fLGNoMoreLogWrite );
	Call( err );

HandleError:
	return err;
	}

ERR ErrLGPrepareToRollback( PIB * const ppib )
	{
	DATA			rgdata[1];
	LRPREPROLLBACK	lrpreprollback;
	INST		* pinst		= PinstFromPpib( ppib );
	LOG			* plog		= pinst->m_plog;
	
	if ( plog->m_fLogDisabled || ( plog->m_fRecovering && plog->m_fRecoveringMode != fRecoveringUndo ) )
		{
		Assert( fFalse );	// should only be called during RecoveryUndo
		return JET_errSuccess;
		}

	lrpreprollback.lrtyp = lrtypPrepRollback;
	Assert( ppib->procid < 64000 );
	lrpreprollback.le_procid = (USHORT) ppib->procid;

	rgdata[0].SetPv( (BYTE *)&lrpreprollback );
	rgdata[0].SetCb( sizeof(LRPREPROLLBACK) );
	
	return plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, pNil );
	}
#endif	//	DTC


//**************************************************
//     Database Operations		                    
//**************************************************

INLINE ERR ErrLGWaitForFlush( PIB *ppib, LGPOS *plgposLogRec )
	{
	ERR err;

	INST *pinst = PinstFromPpib( ppib );
	LOG *plog = pinst->m_plog;
	
	if ( plog->m_fLogDisabled || ( plog->m_fRecovering && plog->m_fRecoveringMode != fRecoveringUndo ) )
		return JET_errSuccess;

	ppib->lgposCommit0 = *plgposLogRec;

	plog->LGSignalFlush();
	err = plog->ErrLGWaitCommit0Flush( ppib );

	Assert( err >= 0 || ( plog->m_fLGNoMoreLogWrite && JET_errLogWriteFail == err ) );
	return err;
	}

ERR ErrLGCreateDB(
	PIB				*ppib,
	const IFMP		ifmp,
	const JET_GRBIT	grbit,
	LGPOS			*plgposRec
	)
	{
	ERR				err;
	FMP				*pfmp			= &rgfmp[ifmp];
	Assert( NULL != pfmp->Pdbfilehdr() );
	const BOOL		fCreateSLV		= ( NULL != pfmp->SzSLVName() );
	const USHORT	cbDbName		= USHORT( strlen( pfmp->SzDatabaseName() ) + 1 );
	const USHORT	cbSLVName		= USHORT( fCreateSLV ? strlen( pfmp->SzSLVName() ) + 1 : 0 );
	const ULONG		cbSLVRoot		= ( fCreateSLV ? strlen( pfmp->SzSLVRoot() ) + 1 : 0 );
	DATA			rgdata[4];
	ULONG			cdata			= ( fCreateSLV ? 4 : 2 );
	LRCREATEDB		lrcreatedb;
	INST			*pinst			= PinstFromPpib( ppib );
	LOG				*plog			= pinst->m_plog;

	Assert( 0 == CmpLgpos( lgposMin, pfmp->LgposDetach() ) );
	Assert( !pfmp->FLogOn() || !plog->m_fLogDisabled );
	if ( plog->m_fRecovering || !pfmp->FLogOn() )
		{
		if ( plog->m_fRecovering )
			{
			//	UNDONE: in theory, lgposAttach should already have been set
			//	when the ATCHCHK was setup, but ivantrin says he's not 100%
			//	sure, so to be safe, we definitely set the lgposAttach here
			Assert( 0 == CmpLgpos( pfmp->LgposAttach(), plog->m_lgposRedo ) );
			pfmp->SetLgposAttach( plog->m_lgposRedo );
			}
		*plgposRec = lgposMin;
		return JET_errSuccess;
		}

	Assert( 0 == CmpLgpos( lgposMin, pfmp->LgposAttach() ) );
	//	HACK: use the file-system stored in the INST
	//		  (otherwise, we will need to drill a pfsapi down through to EVERY logged operation that 
	//		   begins a deferred operation and that means ALL the B-Tree code will be touched among
	//		   other things)
	CallR( ErrLGCheckState( plog ) );

	//	insert database attachment in log attachments
	//
	lrcreatedb.lrtyp = lrtypCreateDB;
	Assert( ppib->procid < 64000 );
	lrcreatedb.le_procid = (USHORT) ppib->procid;
	FMP::AssertVALIDIFMP( ifmp );
	lrcreatedb.dbid = pfmp->Dbid();

	Assert( !lrcreatedb.FCreateSLV() );
	if ( fCreateSLV )
		lrcreatedb.SetFCreateSLV();

	lrcreatedb.le_grbit = grbit;
	lrcreatedb.signDb = pfmp->Pdbfilehdr()->signDb;
	lrcreatedb.le_cpgDatabaseSizeMax = pfmp->CpgDatabaseSizeMax();

	if ( !pinst->FSLVProviderEnabled() )
		lrcreatedb.SetFSLVProviderNotEnabled();

	Assert( cbDbName > 1 );
	lrcreatedb.SetCbPath( USHORT( cbDbName + ( fCreateSLV ? cbSLVName + cbSLVRoot : 0 ) ) );

	rgdata[0].SetPv( (BYTE *)&lrcreatedb );
	rgdata[0].SetCb( sizeof(LRCREATEDB) );
	rgdata[1].SetPv( (BYTE *)pfmp->SzDatabaseName() );
	rgdata[1].SetCb( cbDbName );
	
	if ( fCreateSLV )
		{
		Assert( cbSLVName > 1 );
		rgdata[2].SetPv( (BYTE *)pfmp->SzSLVName() );
		rgdata[2].SetCb( cbSLVName );
		Assert( cbSLVRoot > 1 );
		rgdata[3].SetPv( (BYTE *)pfmp->SzSLVRoot() );
		rgdata[3].SetCb( cbSLVRoot );
		}

	Assert( pfmp->RwlDetaching().FNotWriter() );
	Assert( pfmp->RwlDetaching().FNotReader() );

#ifdef UNLIMITED_DB
	CallR( plog->ErrLGLogRec( rgdata, cdata, fLGNoNewGen|fLGInterpretLR, pfmp->PlgposAttach() ) );
	*plgposRec = pfmp->LgposAttach();
#else	
	pfmp->RwlDetaching().EnterAsWriter();
	while ( errLGNotSynchronous == ( err = plog->ErrLGTryLogRec( rgdata, cdata, fLGNoNewGen, plgposRec ) ) )
		{
		pfmp->RwlDetaching().LeaveAsWriter();
		UtilSleep( cmsecWaitLogFlush );
		pfmp->RwlDetaching().EnterAsWriter();
		}
	if ( err >= JET_errSuccess )
		{
		pfmp->SetLgposAttach( *plgposRec );
		}
	pfmp->RwlDetaching().LeaveAsWriter();
	CallR( err );
#endif	

	//	make sure the log is flushed before we change the state
	//	We must wait on the last log record added, not necessarily the LGPOS returned from
	//	ErrLGLogRec(), when adding multiple log records in one call.
	LGPOS	lgposStartOfLastRec = *plgposRec;
	plog->AddLgpos( &lgposStartOfLastRec, rgdata[0].Cb() + rgdata[1].Cb() + ( fCreateSLV ? ( rgdata[2].Cb() + rgdata[3].Cb() ) : 0 ) - 1 );
	err = ErrLGWaitForFlush( ppib, &lgposStartOfLastRec );
	return err;
	}

	
ERR ErrLGAttachDB(
	PIB				*ppib,
	const IFMP		ifmp,
	LGPOS			*plgposRec )
	{
	ERR				err;
	FMP				*pfmp			= &rgfmp[ifmp];
	Assert( NULL != pfmp->Pdbfilehdr() );
	const BOOL		fSLVExists		= ( NULL != pfmp->SzSLVName() );
	const ULONG		cbDbName		= (ULONG)strlen( pfmp->SzDatabaseName() ) + 1;
	const ULONG		cbSLVName		= ( fSLVExists ? strlen( pfmp->SzSLVName() ) + 1 : 0 );
	const ULONG		cbSLVRoot		= ( fSLVExists ? strlen( pfmp->SzSLVRoot() ) + 1 : 0 );
	DATA			rgdata[4];
	ULONG			cdata			= ( fSLVExists ? 4 : 2 );
	LRATTACHDB		lrattachdb;
	INST			*pinst			= PinstFromPpib( ppib );
	LOG				*plog			= pinst->m_plog;
	
	Assert( 0 == CmpLgpos( lgposMin, pfmp->LgposDetach() ) );
	Assert( !pfmp->FLogOn() || !plog->m_fLogDisabled );
	Assert( !plog->m_fRecovering );
	if ( ( plog->m_fRecovering && plog->m_fRecoveringMode != fRecoveringUndo )
		|| !pfmp->FLogOn() )
		{
		if ( plog->m_fRecovering )
			{
			//	UNDONE: in theory, lgposAttach should already have been set
			//	when the ATCHCHK was setup, but ivantrin says he's not 100%
			//	sure, so to be safe, we definitely set the lgposAttach here
			Assert( 0 == CmpLgpos( pfmp->LgposAttach(), plog->m_lgposRedo ) );
			pfmp->SetLgposAttach( plog->m_lgposRedo );
			}
		*plgposRec = lgposMin;
		return JET_errSuccess;
		}

	Assert( 0 == CmpLgpos( lgposMin, pfmp->LgposAttach() ) );
	// BUG_125831	
	// we should not start the attachement if we are low on disk space
	CallR( ErrLGCheckState( plog ) );
	// BUG_125831	

	//	insert database attachment in log attachments
	//
	lrattachdb.lrtyp = lrtypAttachDB;
	Assert( ppib->procid < 64000 );
	lrattachdb.le_procid = (USHORT) ppib->procid;
	lrattachdb.dbid = pfmp->Dbid();

	Assert( !lrattachdb.FSLVExists() );

	if ( fSLVExists )
		{
		lrattachdb.SetFSLVExists();
		}
	Assert( !rgfmp[ifmp].FReadOnlyAttach() );
	if ( !pinst->FSLVProviderEnabled() )
		{
		lrattachdb.SetFSLVProviderNotEnabled();
		}
		
	lrattachdb.signDb = pfmp->Pdbfilehdr()->signDb;
	lrattachdb.le_cpgDatabaseSizeMax = pfmp->CpgDatabaseSizeMax();
	lrattachdb.signLog = pfmp->Pdbfilehdr()->signLog;
	lrattachdb.lgposConsistent = pfmp->Pdbfilehdr()->le_lgposConsistent;

	Assert( cbDbName > 1 );
	lrattachdb.SetCbPath( USHORT( cbDbName + ( fSLVExists ? cbSLVName + cbSLVRoot : 0 ) ) );

	rgdata[0].SetPv( (BYTE *)&lrattachdb );
	rgdata[0].SetCb( sizeof(LRATTACHDB) );
	rgdata[1].SetPv( (BYTE *)pfmp->SzDatabaseName() );
	rgdata[1].SetCb( cbDbName );
	
	if ( fSLVExists )
		{
		Assert( cbSLVName > 1 );
		rgdata[2].SetPv( (BYTE *)pfmp->SzSLVName() );
		rgdata[2].SetCb( cbSLVName );
		Assert( cbSLVRoot > 1 );
		rgdata[3].SetPv( (BYTE *)pfmp->SzSLVRoot() );
		rgdata[3].SetCb( cbSLVRoot );
		}

	Assert( pfmp->RwlDetaching().FNotWriter() );
	Assert( pfmp->RwlDetaching().FNotReader() );

#ifdef UNLIMITED_DB
	CallR( plog->ErrLGLogRec( rgdata, cdata, fLGNoNewGen|fLGInterpretLR, pfmp->PlgposAttach() ) );
	*plgposRec = pfmp->LgposAttach();
#else
	pfmp->RwlDetaching().EnterAsWriter();
	while ( errLGNotSynchronous == ( err = plog->ErrLGTryLogRec( rgdata, cdata, fLGNoNewGen, plgposRec ) ) )
		{
		pfmp->RwlDetaching().LeaveAsWriter();
		UtilSleep( cmsecWaitLogFlush );
		pfmp->RwlDetaching().EnterAsWriter();
		}
	if ( err >= JET_errSuccess )
		{
		pfmp->SetLgposAttach( *plgposRec );
		}
	pfmp->RwlDetaching().LeaveAsWriter();
	CallR( err );
#endif

	//	make sure the log is flushed before we change the state
	//	We must wait on the last log record added, not necessarily the LGPOS returned from
	//	ErrLGLogRec(), when adding multiple log records in one call.
	LGPOS	lgposStartOfLastRec = *plgposRec;
	plog->AddLgpos( &lgposStartOfLastRec, rgdata[0].Cb() + rgdata[1].Cb() + ( fSLVExists ? rgdata[2].Cb() + rgdata[3].Cb() : 0 ) - 1 );
	err = ErrLGWaitForFlush( ppib, &lgposStartOfLastRec );
	return err;
	}


	
ERR ErrLGForceFlushLog( PIB * ppib )
	{
	ERR						err;
	DATA					rgdata[1];
	LRFORCEFLUSHLOG		lrForceFlushLog;
	LGPOS					lgposStartOfLastRec;
	
	INST * 					pinst				= PinstFromPpib( ppib );
	LOG * 					plog				= pinst->m_plog;
	
	Assert( !plog->m_fRecovering );
	if ( ( plog->m_fRecovering && plog->m_fRecoveringMode != fRecoveringUndo ) )
		{
		return JET_errSuccess;
		}

	lrForceFlushLog.lrtyp = lrtypForceFlushLog;
	Assert( ppib->procid < 64000 );
	lrForceFlushLog.le_procid = (USHORT) ppib->procid;

	rgdata[0].SetPv( (BYTE *)&lrForceFlushLog );
	rgdata[0].SetCb( sizeof(lrForceFlushLog) );
	
	while ( errLGNotSynchronous == ( err = plog->ErrLGTryLogRec( rgdata, sizeof(rgdata) / sizeof(rgdata[0]), fLGNoNewGen, &lgposStartOfLastRec ) ) )
		{
		UtilSleep( cmsecWaitLogFlush );
		}
	CallR( err );

	//	make sure the log is flushed before we return
	plog->AddLgpos( &lgposStartOfLastRec, rgdata[0].Cb() - 1 );
	return ErrLGWaitForFlush( ppib, &lgposStartOfLastRec );
	}

ERR ErrLGForceDetachDB(
	PIB			*ppib,
	const IFMP	ifmp,
	BYTE		flags,
	LGPOS		*plgposRec )
	{
	ERR			err;
	FMP			*pfmp		= &rgfmp[ifmp];
	const ULONG	cbDbName	= (ULONG)strlen(pfmp->SzDatabaseName() ) + 1;
	DATA		rgdata[2];
	LRFORCEDETACHDB	lrdetachdb;
	INST		*pinst		= PinstFromPpib( ppib );
	LOG			*plog		= pinst->m_plog;
	
	Assert( !pfmp->FLogOn() || !plog->m_fLogDisabled );
	if ( ( plog->m_fRecovering && plog->m_fRecoveringMode != fRecoveringUndo )
		|| !pfmp->FLogOn() )
		{
		if ( plog->m_fRecovering )
			{
			Assert( 0 == CmpLgpos( lgposMin, pfmp->LgposDetach() ) );
			pfmp->SetLgposDetach( pinst->m_plog->m_lgposRedo );
			}
		*plgposRec = lgposMin;
		return JET_errSuccess;
		}

	Assert( 0 != CmpLgpos( lgposMin, pfmp->LgposAttach() ) || NULL == pfmp->Pdbfilehdr() );
	Assert( !pfmp->FReadOnlyAttach() ); 

	//	delete database attachment in log attachments
	//
	lrdetachdb.lrtyp = lrtypForceDetachDB;
	Assert( ppib->procid < 64000 );
	lrdetachdb.le_procid = (USHORT) ppib->procid;
	lrdetachdb.dbid = pfmp->Dbid();
	lrdetachdb.SetCbPath( cbDbName );
	lrdetachdb.le_dbtime = pfmp->DbtimeLast();	
#ifdef IGNORE_BAD_ATTACH
	if ( plog->m_fRecovering ) 
		{
		lrdetachdb.le_rceidMax = ++plog->m_rceidLast;
		}
	else
		{
		lrdetachdb.le_rceidMax = RCE::RceidLastIncrement();
		}
#else // IGNORE_BAD_ATTACH
	lrdetachdb.le_rceidMax = RCE::RceidLastIncrement();
#endif // IGNORE_BAD_ATTACH
	lrdetachdb.m_fFlags = 0;
	lrdetachdb.SetFlags( flags );

	rgdata[0].SetPv( (BYTE *)&lrdetachdb );
	rgdata[0].SetCb( sizeof(LRFORCEDETACHDB) );
	rgdata[1].SetPv( (BYTE *)pfmp->SzDatabaseName() );
	rgdata[1].SetCb( cbDbName );

	Assert( pfmp->RwlDetaching().FNotWriter() );
	Assert( pfmp->RwlDetaching().FNotReader() );

	// disable logging twice detach/force detach record
	if ( 0 != CmpLgpos( lgposMin, pfmp->LgposDetach() ) )
		{
		*plgposRec = pfmp->LgposDetach();
		}
	else
		{
#ifdef UNLIMITED_DB
		CallR( plog->ErrLGLogRec( rgdata, 2, fLGNoNewGen|fLGInterpretLR, pfmp->PlgposDetach() ) );
		*plgposRec = pfmp->LgposDetach();
#else
		pfmp->RwlDetaching().EnterAsWriter();
		while ( errLGNotSynchronous == ( err = plog->ErrLGTryLogRec( rgdata, 2, fLGNoNewGen, plgposRec ) ) )
			{
			pfmp->RwlDetaching().LeaveAsWriter();
			UtilSleep( cmsecWaitLogFlush );
			pfmp->RwlDetaching().EnterAsWriter();
			}
		if ( err >= JET_errSuccess )
			{
			Assert( 0 != CmpLgpos( lgposMin, pfmp->LgposAttach() ) );
			Assert( 0 == CmpLgpos( lgposMin, pfmp->LgposDetach() ) );
			pfmp->SetLgposDetach( *plgposRec );
			}
		pfmp->RwlDetaching().LeaveAsWriter();
		CallR( err );
#endif		
		}

	//	make sure the log is flushed before we change the state
	//	We must wait on the last log record added, not necessarily the LGPOS returned from
	//	ErrLGLogRec(), when adding multiple log records in one call.
	LGPOS	lgposStartOfLastRec = *plgposRec;
	plog->AddLgpos( &lgposStartOfLastRec, rgdata[0].Cb() + rgdata[1].Cb() - 1 );
	err = ErrLGWaitForFlush( ppib, &lgposStartOfLastRec );
	return err;
	}



ERR ErrLGDetachDB(
	PIB			*ppib,
	const IFMP	ifmp,
	BYTE 		flags,
	LGPOS		*plgposRec )
	{
	ERR			err;
	FMP			*pfmp		= &rgfmp[ifmp];
	INST		*pinst		= PinstFromPpib( ppib );
	LOG			*plog		= pinst->m_plog;

	char * 		szDatabaseName = pfmp->SzDatabaseName();
	Assert ( szDatabaseName );
			
	if ( plog->m_fRecovering )
		{
		INT irstmap = plog->IrstmapSearchNewName( szDatabaseName );

		if ( 0 <= irstmap )
			{
			szDatabaseName = pinst->m_plog->m_rgrstmap[irstmap].szDatabaseName;
			}
		}
	Assert ( szDatabaseName );

	const ULONG	cbDbName	= (ULONG)strlen( szDatabaseName ) + 1;
	DATA		rgdata[2];
	LRDETACHDB	lrdetachdb;
	
	Assert( !pfmp->FLogOn() || !plog->m_fLogDisabled );
	if ( ( plog->m_fRecovering && plog->m_fRecoveringMode != fRecoveringUndo )
		|| !pfmp->FLogOn() )
		{
		if ( plog->m_fRecovering )
			{
			Assert( 0 == CmpLgpos( lgposMin, pfmp->LgposDetach() ) );
			pfmp->SetLgposDetach( plog->m_lgposRedo );
			}
		*plgposRec = lgposMin;
		return JET_errSuccess;
		}

	Assert( !pfmp->FReadOnlyAttach() );
	Assert( 0 != CmpLgpos( lgposMin, pfmp->LgposAttach() ) || NULL == pfmp->Pdbfilehdr() );

	//	delete database attachment in log attachments
	//
	lrdetachdb.lrtyp = lrtypDetachDB;
	Assert( ppib->procid < 64000 );
	lrdetachdb.le_procid = (USHORT) ppib->procid;
	lrdetachdb.dbid = pfmp->Dbid();
	lrdetachdb.SetCbPath( cbDbName );
	if ( flags & fLRForceDetachCreateSLV )
		{
		lrdetachdb.SetFCreateSLV();
		}

	rgdata[0].SetPv( (BYTE *)&lrdetachdb );
	rgdata[0].SetCb( sizeof(LRDETACHDB) );
	rgdata[1].SetPv( (BYTE *)szDatabaseName );
	rgdata[1].SetCb( cbDbName );
	
	Assert( pfmp->RwlDetaching().FNotWriter() );
	Assert( pfmp->RwlDetaching().FNotReader() );

	// disable logging twice detach/force detach record
	if ( 0 != CmpLgpos( lgposMin, pfmp->LgposDetach() ) )
		{
		*plgposRec = pfmp->LgposDetach();
		}
	else
		{
#ifdef UNLIMITED_DB
		CallR( plog->ErrLGLogRec( rgdata, 2, fLGNoNewGen|fLGInterpretLR, pfmp->PlgposDetach() ) );
		*plgposRec = pfmp->LgposDetach();
#else
		pfmp->RwlDetaching().EnterAsWriter();
		while ( errLGNotSynchronous == ( err = plog->ErrLGTryLogRec( rgdata, 2, fLGNoNewGen, plgposRec ) ) )
			{
			pfmp->RwlDetaching().LeaveAsWriter();
			UtilSleep( cmsecWaitLogFlush );
			pfmp->RwlDetaching().EnterAsWriter();
			}
		if ( err >= JET_errSuccess )
			{
			Assert( 0 != CmpLgpos( lgposMin, pfmp->LgposAttach() ) );
			Assert( 0 == CmpLgpos( lgposMin, pfmp->LgposDetach() ) );
			pfmp->SetLgposDetach( *plgposRec );
			}
		pfmp->RwlDetaching().LeaveAsWriter();
		CallR( err );
#endif		
		}

	//	make sure the log is flushed before we change the state
	//	We must wait on the last log record added, not necessarily the LGPOS returned from
	//	ErrLGLogRec(), when adding multiple log records in one call.
	LGPOS	lgposStartOfLastRec = *plgposRec;
	plog->AddLgpos( &lgposStartOfLastRec, rgdata[0].Cb() + rgdata[1].Cb() - 1 );
	err = ErrLGWaitForFlush( ppib, &lgposStartOfLastRec );
	return err;
	}



//********************************************************
//****     Split Operations			                  ****
//********************************************************

//	logs the following
//		-- 	begin macro
//			for every split in the split chain [top-down order]
//				log LRSPLIT
//			leaf-level node operation to be performed atomically with split
//			end macro
//	returns lgpos of last log operation
//
ERR ErrLGSplit( const FUCB			* const pfucb,
				SPLITPATH		* const psplitPathLeaf,
				const KEYDATAFLAGS&	kdfOper,
				const RCEID			rceid1,
				const RCEID			rceid2,
				const DIRFLAG		dirflag,
				LGPOS				* const plgpos,
				const VERPROXY		* const pverproxy )
	{
	ERR			err = JET_errSuccess;

	INST *pinst = PinstFromIfmp( pfucb->ifmp );
	LOG *plog = pinst->m_plog;
	
	Assert( !plog->m_fRecovering );
	if ( plog->m_fLogDisabled )
		{
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	Assert( rgfmp[pfucb->ifmp].FLogOn() );
	Assert( NULL == pverproxy ||
			prceNil != pverproxy->prcePrimary &&
			( pverproxy->prcePrimary->TrxCommitted() != trxMax ||
			  pfucbNil != pverproxy->prcePrimary->Pfucb() &&
			  ppibNil != pverproxy->prcePrimary->Pfucb()->ppib ) );
			  
	PIB	* const ppib = pverproxy != NULL && 
					trxMax == pverproxy->prcePrimary->TrxCommitted() ?
						pverproxy->prcePrimary->Pfucb()->ppib :
						pfucb->ppib;
			  
	Assert( rgfmp[pfucb->ifmp].Dbid() != dbidTemp );
	Assert( ppib->level > 0 );

	//	Redo only operation
	
	CallR( ErrLGDeferBeginTransaction( ppib ) );

	DBTIME	dbtime = psplitPathLeaf->csr.Dbtime();
	CallR( ErrLGIMacroBegin( ppib, dbtime ) );

	//	log splits top-down
	//
	const SPLITPATH	*psplitPath = psplitPathLeaf;
	for ( ; psplitPath->psplitPathParent != NULL; psplitPath = psplitPath->psplitPathParent )
		{
		}

	for ( ; psplitPath != NULL; psplitPath = psplitPath->psplitPathChild )
		{
		DATA		rgdata[5];
		USHORT		idata = 0;
		LRSPLIT		lrsplit;

		lrsplit.lrtyp 					= lrtypSplit;

		//	dbtime should have been validated in ErrBTISplitUpgradeLatches()
		Assert( dbtime > psplitPath->dbtimeBefore );
		
		lrsplit.le_dbtime 				= dbtime;
		Assert ( dbtimeNil != psplitPath->dbtimeBefore);
		lrsplit.le_dbtimeBefore 		= psplitPath->dbtimeBefore;
		Assert( dbtime == psplitPath->csr.Dbtime() );
		Assert( psplitPath->csr.FDirty() );
		
		lrsplit.dbid					= (BYTE) rgfmp[pfucb->ifmp].Dbid();
		lrsplit.le_procid				= ppib->procid;
		
		lrsplit.le_pgno	 			= psplitPath->csr.Pgno();
		lrsplit.le_pgnoParent 		= psplitPath->psplitPathParent != NULL ? psplitPath->psplitPathParent->csr.Pgno() : pgnoNull;
		lrsplit.le_dbtimeParentBefore      = psplitPath->psplitPathParent != NULL ? psplitPath->psplitPathParent->dbtimeBefore : dbtimeNil;
		lrsplit.le_pgnoFDP			= PgnoFDP( pfucb );
		lrsplit.le_objidFDP			= ObjidFDP( pfucb );

		lrsplit.SetILine( 0 );				//	iline member of LRPAGE is unused by split -- see iline members of LRSPLIT instead

		Assert( !lrsplit.FVersioned() );	//	version flag will get properly set by node operation causing the split
		Assert( !lrsplit.FDeleted() );
		Assert( !lrsplit.FUnique() );
		Assert( !lrsplit.FSpace() );
		Assert( !lrsplit.FConcCI() );

		if ( pfucb->u.pfcb->FUnique() )
			lrsplit.SetFUnique();
		if ( NULL != pverproxy )
			lrsplit.SetFConcCI();

		LGISetTrx( ppib, &lrsplit, pverproxy );
		
		rgdata[idata].SetPv( (BYTE *) &lrsplit );
		rgdata[idata++].SetCb( sizeof (LRSPLIT) );

		if ( psplitPath->psplit == NULL )
			{
			//	UNDONE:	spin off separate log operation for parent page
			//
			lrsplit.le_pgnoNew		= pgnoNull;
			lrsplit.le_ilineOper	= USHORT( psplitPath->csr.ILine() );

			lrsplit.le_cbKeyParent		= 0;
			lrsplit.le_cbPrefixSplitOld	= 0;
			lrsplit.le_cbPrefixSplitNew	= 0;
			lrsplit.le_dbtimeRightBefore       = dbtimeNil;
			}
		else
			{
			const SPLIT	*psplit = psplitPath->psplit;
			Assert( psplit->csrNew.Dbtime() == lrsplit.le_dbtime );
			Assert( psplit->csrNew.FDirty() );

		//	dbtime should have been validated in ErrBTISplitUpgradeLatches()
			Assert( pgnoNull == psplit->csrRight.Pgno()
				|| dbtime > psplit->dbtimeRightBefore );

			lrsplit.le_dbtimeRightBefore	= psplit->dbtimeRightBefore;
			
			lrsplit.le_pgnoNew 			= psplit->csrNew.Pgno();
			lrsplit.le_pgnoRight	 	= psplit->csrRight.Pgno();
			Assert( lrsplit.le_pgnoNew != pgnoNull );
	
			lrsplit.splittype 			= BYTE( psplit->splittype );
			lrsplit.splitoper 			= BYTE( psplit->splitoper );

			lrsplit.le_ilineOper		= USHORT( psplit->ilineOper );
			lrsplit.le_ilineSplit		= USHORT( psplit->ilineSplit );
			lrsplit.le_clines			= USHORT( psplit->clines );
			Assert( lrsplit.le_clines < g_cbPage );

			lrsplit.le_fNewPageFlags 	= psplit->fNewPageFlags;
			lrsplit.le_fSplitPageFlags	= psplit->fSplitPageFlags;

			lrsplit.le_cbUncFreeSrc		= psplit->cbUncFreeSrc;
			lrsplit.le_cbUncFreeDest	= psplit->cbUncFreeDest;
			
			lrsplit.le_ilinePrefixSplit	= psplit->prefixinfoSplit.ilinePrefix;
			lrsplit.le_ilinePrefixNew	= psplit->prefixinfoNew.ilinePrefix;
			
			lrsplit.le_cbKeyParent		= (USHORT) psplit->kdfParent.key.Cb();
			rgdata[idata].SetPv( psplit->kdfParent.key.prefix.Pv() );
			rgdata[idata++].SetCb( psplit->kdfParent.key.prefix.Cb() );
			
			rgdata[idata].SetPv( psplit->kdfParent.key.suffix.Pv() );
			rgdata[idata++].SetCb( psplit->kdfParent.key.suffix.Cb() );

			lrsplit.le_cbPrefixSplitOld	= USHORT( psplit->prefixSplitOld.Cb() );
			rgdata[idata].SetPv( psplit->prefixSplitOld.Pv() );
			rgdata[idata++].SetCb( lrsplit.le_cbPrefixSplitOld );

			lrsplit.le_cbPrefixSplitNew	= USHORT( psplit->prefixSplitNew.Cb() );
			rgdata[idata].SetPv( psplit->prefixSplitNew.Pv() );
			rgdata[idata++].SetCb( lrsplit.le_cbPrefixSplitNew );
			}

		Call( plog->ErrLGLogRec( rgdata, idata, fLGNoNewGen, plgpos ) );
		}
		
	//	log leaf-level operation
	//
	if ( psplitPathLeaf->psplit != NULL &&
		 psplitPathLeaf->psplit->splitoper != splitoperNone )
		{
		const SPLIT	*psplit = psplitPathLeaf->psplit;
		Assert( psplitPathLeaf->csr.Cpage().FLeafPage() );
		
		switch ( psplit->splitoper )
			{
			//	log the appropriate operation
			//
			case splitoperInsert:
				Assert( rceidNull == rceid2 );
				Call( ErrLGInsert( pfucb, 
								   &psplitPathLeaf->csr, 
								   kdfOper,
								   rceid1,
								   dirflag, 
								   plgpos, 
								   pverproxy,
								   fDontDirtyCSR ) );
				break;

			case splitoperFlagInsertAndReplaceData:
				Call( ErrLGFlagInsertAndReplaceData( pfucb,
													 &psplitPathLeaf->csr,
													 kdfOper,
													 rceid1,
													 rceid2,
													 dirflag,
													 plgpos,
													 pverproxy,
													 fDontDirtyCSR ) );
				break;

			//	UNDONE:	get the correct dataOld!!!
			//
			case splitoperReplace:
				Assert( rceidNull == rceid2 );
				Assert( NULL == pverproxy );
				Call( ErrLGReplace( pfucb, 
									&psplitPathLeaf->csr,
									psplit->rglineinfo[psplit->ilineOper].kdf.data,
									kdfOper.data,
									NULL,			// UNDONE: logdiff for split
									rceid1,
									dirflag,
									plgpos,
									fDontDirtyCSR ) );
				break;

			default:
				Assert( fFalse );
			}
		}
	
	Call( ErrLGIMacroEnd( ppib, dbtime, lrtypMacroCommit, plgpos ) );

HandleError:
	return err;
	}


//	logs the following
//		-- 	begin macro
//			for every split in the split chain
//				log LRSPLIT
//			end macro
//	returns lgpos of last log operation
//
ERR ErrLGMerge( const FUCB *pfucb, MERGEPATH *pmergePathLeaf, LGPOS *plgpos )
	{
	ERR		err = JET_errSuccess;

	INST *pinst = PinstFromIfmp( pfucb->ifmp );
	LOG *plog = pinst->m_plog;
	
	Assert( !plog->m_fRecovering );
	Assert( !rgfmp[pfucb->ifmp].FLogOn() || !plog->m_fLogDisabled );

	if ( !rgfmp[pfucb->ifmp].FLogOn() )
		{
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	//	merge always happens at level 1
	Assert( pfucb->ppib->level == 1 );
	Assert( dbidTemp != rgfmp[pfucb->ifmp].Dbid() );

	//	Redo only operations
	
	CallR( ErrLGDeferBeginTransaction( pfucb->ppib ) );

	MERGEPATH		*pmergePath = pmergePathLeaf;
	const DBTIME	dbtime = pmergePath->csr.Dbtime();
	
	CallR( ErrLGIMacroBegin( pfucb->ppib, dbtime ) );

	Assert( pmergePathLeaf->pmerge != NULL );
	
	for ( ; pmergePath->pmergePathParent != NULL && latchWrite == pmergePath->pmergePathParent->csr.Latch();
			pmergePath = pmergePath->pmergePathParent )
		{
		}
			
	for ( ; pmergePath != NULL; pmergePath = pmergePath->pmergePathChild )
		{
		Assert( latchWrite == pmergePath->csr.Latch() );

		const MERGE	*pmerge = pmergePath->pmerge;
		DATA		rgdata[2];
		USHORT		idata = 0;
		LRMERGE		lrmerge;

		lrmerge.lrtyp 			= lrtypMerge;
		lrmerge.le_dbtime 		= dbtime;
		lrmerge.le_dbtimeBefore = pmergePath->dbtimeBefore;
		Assert( pmergePath->csr.FDirty() );
		
		lrmerge.le_procid		= pfucb->ppib->procid;
		lrmerge.dbid			= (BYTE) rgfmp[ pfucb->ifmp ].Dbid();

		lrmerge.le_pgno	 		= pmergePath->csr.Pgno();
		lrmerge.SetILine( pmergePath->iLine );

		Assert( !lrmerge.FVersioned() );
		Assert( !lrmerge.FDeleted() );
		Assert( !lrmerge.FUnique() );
		Assert( !lrmerge.FSpace() );
		Assert( !lrmerge.FConcCI() );
		Assert( !lrmerge.FKeyChange() );
		Assert( !lrmerge.FDeleteNode() );
		Assert( !lrmerge.FEmptyPage() );

		if ( pfucb->u.pfcb->FUnique() )
			lrmerge.SetFUnique();
		if ( FFUCBSpace( pfucb ) )
			lrmerge.SetFSpace();
		if ( pmergePath->fKeyChange )
			lrmerge.SetFKeyChange();
		if ( pmergePath->fDeleteNode )
			lrmerge.SetFDeleteNode();
		if ( pmergePath->fEmptyPage )
			lrmerge.SetFEmptyPage();

		LGISetTrx( pfucb->ppib, &lrmerge );
		
		lrmerge.le_pgnoParent 	= pmergePath->pmergePathParent != NULL ? pmergePath->pmergePathParent->csr.Pgno() : pgnoNull;
		lrmerge.le_dbtimeParentBefore = pmergePath->pmergePathParent != NULL ? pmergePath->pmergePathParent->dbtimeBefore : dbtimeNil;
		
		lrmerge.le_pgnoFDP		= PgnoFDP( pfucb );
		lrmerge.le_objidFDP		= ObjidFDP( pfucb );

		rgdata[idata].SetPv( (BYTE *) &lrmerge );
		rgdata[idata++].SetCb( sizeof (LRMERGE) );

		if ( pmerge != NULL )
			{
			Assert( pgnoNull == pmerge->csrLeft.Pgno() || 
					pmerge->csrLeft.FDirty() );
			Assert( pgnoNull == pmerge->csrRight.Pgno() || 
					pmerge->csrRight.FDirty() );
			Assert( 0 == pmerge->ilineMerge || 
					mergetypePartialRight == pmerge->mergetype );

			lrmerge.SetILineMerge( USHORT( pmerge->ilineMerge ) );
			
			lrmerge.le_pgnoLeft 	= pmerge->csrLeft.Pgno();
			lrmerge.le_pgnoRight 	= pmerge->csrRight.Pgno();

			lrmerge.le_dbtimeRightBefore = pmerge->dbtimeRightBefore;
			lrmerge.le_dbtimeLeftBefore = pmerge->dbtimeLeftBefore;

			Assert( mergetypeNone != pmerge->mergetype );
			lrmerge.mergetype 			= BYTE( pmerge->mergetype );
			lrmerge.le_cbSizeTotal		= USHORT( pmerge->cbSizeTotal );
			lrmerge.le_cbSizeMaxTotal	= USHORT( pmerge->cbSizeMaxTotal );
			lrmerge.le_cbUncFreeDest	= USHORT( pmerge->cbUncFreeDest );

			lrmerge.le_cbKeyParentSep	= (USHORT) pmerge->kdfParentSep.key.suffix.Cb();
			Assert( pmerge->kdfParentSep.key.prefix.FNull() );
			
			rgdata[idata].SetPv( pmerge->kdfParentSep.key.suffix.Pv() );
			rgdata[idata++].SetCb( pmerge->kdfParentSep.key.suffix.Cb() );
			}
		else
			{
			lrmerge.le_dbtimeRightBefore = dbtimeNil;
			lrmerge.le_dbtimeLeftBefore = dbtimeNil;
			}

		Call( plog->ErrLGLogRec( rgdata, idata, fLGNoNewGen, plgpos ) );
		}
		
	Call( ErrLGIMacroEnd( pfucb->ppib, dbtime, lrtypMacroCommit, plgpos ) );

HandleError:
	return err;
	}


ERR ErrLGEmptyTree(
	FUCB			* const pfucb,
	CSR				* const pcsrRoot,
	EMPTYPAGE		* const rgemptypage,
	const CPG		cpgToFree,
	LGPOS			* const plgpos )
	{
	ERR				err;
	INST 			* const pinst	= PinstFromIfmp( pfucb->ifmp );
	LOG				* const plog	= pinst->m_plog;
	DATA			rgdata[2];
	LREMPTYTREE		lremptytree;

	Assert( !pinst->FRecovering() );
	Assert( pcsrRoot->Pgno() == PgnoRoot( pfucb ) );

	if ( plog->m_fLogDisabled
		|| !rgfmp[pfucb->ifmp].FLogOn() )
		{
		pcsrRoot->Dirty();
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	Assert( pfucb->ppib->level > 0 );
	CallR( ErrLGDeferBeginTransaction( pfucb->ppib ) );

	lremptytree.lrtyp 				= lrtypEmptyTree;
	lremptytree.le_procid 			= pfucb->ppib->procid;
	lremptytree.dbid 				= rgfmp[ pfucb->ifmp ].Dbid();
	lremptytree.le_pgno				= pcsrRoot->Pgno();
	lremptytree.SetILine( 0 );

	Assert( !lremptytree.FVersioned() );
	Assert( !lremptytree.FDeleted() );
	Assert( !lremptytree.FUnique() );
	Assert( !lremptytree.FSpace() );
	Assert( !lremptytree.FConcCI() );
	if ( pfucb->u.pfcb->FUnique() )
		lremptytree.SetFUnique();
	if ( FFUCBSpace( pfucb ) )
		lremptytree.SetFSpace();

	CallR( ErrLGSetDbtimeBeforeAndDirty( pcsrRoot, &lremptytree.le_dbtimeBefore, &lremptytree.le_dbtime, fTrue ) );
	LGISetTrx( pfucb->ppib, &lremptytree );

	Assert( cpgToFree > 0 );
	Assert( cpgToFree <= cBTMaxDepth );
	const USHORT	cbEmptyPageList		= USHORT( sizeof(EMPTYPAGE) * cpgToFree );

	lremptytree.le_rceid = rceidNull;
	lremptytree.le_pgnoFDP = PgnoFDP( pfucb );
	lremptytree.le_objidFDP = ObjidFDP( pfucb );

	lremptytree.SetCbEmptyPageList( cbEmptyPageList );

	rgdata[0].SetPv( (BYTE *)&lremptytree );
	rgdata[0].SetCb( sizeof(lremptytree) );

	rgdata[1].SetPv( (BYTE *)rgemptypage );
	rgdata[1].SetCb( cbEmptyPageList );
	
	err = plog->ErrLGLogRec( rgdata, 2, fLGNoNewGen, plgpos );

	//	on logging failure, must revert dbtime to ensure page doesn't
	//	get erroneously flushed with wrong dbtime
	if ( err < 0 )
		{
		Assert( dbtimeInvalid !=  lremptytree.le_dbtimeBefore );
		Assert( dbtimeNil != lremptytree.le_dbtimeBefore );
		Assert( pcsrRoot->Dbtime() > lremptytree.le_dbtimeBefore );
		pcsrRoot->RevertDbtime( lremptytree.le_dbtimeBefore );
		}

	return err;
	}


		//**************************************************
		//     Miscellaneous Operations
		//**************************************************


ERR ErrLGCreateMultipleExtentFDP( 
	const FUCB			*pfucb,
	const CSR 			*pcsr,
	const SPACE_HEADER	*psph,
	const ULONG			fPageFlags,
	LGPOS	  			*plgpos )
	{
	ERR					err;
	DATA				rgdata[1];
	LRCREATEMEFDP		lrcreatemefdp;

	INST *pinst = PinstFromIfmp( pfucb->ifmp );
	LOG *plog = pinst->m_plog;
	
	Assert( pcsr->FDirty() );
	Assert( !rgfmp[pfucb->ifmp].FLogOn() || !plog->m_fLogDisabled );

	if ( !rgfmp[pfucb->ifmp].FLogOn() )
		{
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	Assert( !plog->m_fRecovering );
	Assert( 0 < pfucb->ppib->level );

	//	HACK: use the file-system stored in the INST
	//		  (otherwise, we will need to drill a pfsapi down through to EVERY logged operation that 
	//		   begins a deferred operation and that means ALL the B-Tree code will be touched among
	//		   other things)
	CallR( ErrLGCheckState( plog ) );

	//	Redo only operation
	
	CallR( ErrLGDeferBeginTransaction( pfucb->ppib ) );

	Assert( psph->FMultipleExtent() );

	lrcreatemefdp.lrtyp 			= lrtypCreateMultipleExtentFDP;
	lrcreatemefdp.le_procid 			= pfucb->ppib->procid;
	lrcreatemefdp.le_pgno				= PgnoFDP( pfucb );
	lrcreatemefdp.le_objidFDP			= ObjidFDP( pfucb );
	lrcreatemefdp.le_pgnoFDPParent 	= psph->PgnoParent();
	lrcreatemefdp.le_pgnoOE			= PgnoOE( pfucb );
	lrcreatemefdp.le_pgnoAE			= PgnoAE( pfucb );
	lrcreatemefdp.le_fPageFlags		= fPageFlags;
	
	lrcreatemefdp.dbid 				= rgfmp[ pfucb->ifmp ].Dbid();
	lrcreatemefdp.le_dbtime			= pcsr->Dbtime();
	// new page, dbtimeBefore has no meaning
	lrcreatemefdp.le_dbtimeBefore = dbtimeNil;
	lrcreatemefdp.le_cpgPrimary		= psph->CpgPrimary();

	Assert( !lrcreatemefdp.FVersioned() );
	Assert( !lrcreatemefdp.FDeleted() );
	Assert( !lrcreatemefdp.FUnique() );
	Assert( !lrcreatemefdp.FSpace() );
	Assert( !lrcreatemefdp.FConcCI() );

	if ( psph->FUnique() )
		lrcreatemefdp.SetFUnique();

	LGISetTrx( pfucb->ppib, &lrcreatemefdp );
	
	rgdata[0].SetPv( (BYTE *)&lrcreatemefdp );
	rgdata[0].SetCb( sizeof(lrcreatemefdp) );
	
	err = plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, plgpos );

	return err;
	}


ERR ErrLGCreateSingleExtentFDP( 
	const FUCB			*pfucb,
	const CSR 			*pcsr,
	const SPACE_HEADER	*psph,
	const ULONG			fPageFlags,
	LGPOS	  			*plgpos )
	{
	ERR					err;
	DATA				rgdata[1];
	LRCREATESEFDP		lrcreatesefdp;

	INST *pinst = PinstFromIfmp( pfucb->ifmp );
	LOG *plog = pinst->m_plog;
	
	Assert( !plog->m_fRecovering );
	Assert( pcsr->FDirty() );
	Assert( !rgfmp[pfucb->ifmp].FLogOn() || !plog->m_fLogDisabled );
	if ( !rgfmp[pfucb->ifmp].FLogOn() )
		{
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	Assert( 0 < pfucb->ppib->level );

	//	HACK: use the file-system stored in the INST
	//		  (otherwise, we will need to drill a pfsapi down through to EVERY logged operation that 
	//		   begins a deferred operation and that means ALL the B-Tree code will be touched among
	//		   other things)
	CallR( ErrLGCheckState( plog ) );

	//	Redo only operation
	
	CallR( ErrLGDeferBeginTransaction( pfucb->ppib ) );

	Assert( psph->FSingleExtent() );

	lrcreatesefdp.lrtyp 			= lrtypCreateSingleExtentFDP;
	lrcreatesefdp.le_procid 			= pfucb->ppib->procid;
	lrcreatesefdp.le_pgnoFDPParent 	= psph->PgnoParent();

	Assert( pcsr->Pgno() == PgnoFDP( pfucb ) );
	lrcreatesefdp.le_pgno				= pcsr->Pgno();
	lrcreatesefdp.le_objidFDP			= ObjidFDP( pfucb );
	lrcreatesefdp.le_fPageFlags		= fPageFlags;
	
	lrcreatesefdp.dbid 				= rgfmp[ pfucb->ifmp ].Dbid();
	lrcreatesefdp.le_dbtime			= pcsr->Dbtime();
	// new page, dbtimeBefore has no meaning
	lrcreatesefdp.le_dbtimeBefore = dbtimeNil;
	lrcreatesefdp.le_cpgPrimary		= psph->CpgPrimary();

	Assert( !lrcreatesefdp.FVersioned() );
	Assert( !lrcreatesefdp.FDeleted() );
	Assert( !lrcreatesefdp.FUnique() );
	Assert( !lrcreatesefdp.FSpace() );
	Assert( !lrcreatesefdp.FConcCI() );

	if ( psph->FUnique() )
		lrcreatesefdp.SetFUnique();

	LGISetTrx( pfucb->ppib, &lrcreatesefdp );
	
	rgdata[0].SetPv( (BYTE *)&lrcreatesefdp );
	rgdata[0].SetCb( sizeof(lrcreatesefdp) );
	
	err = plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, plgpos );

	return err;
	}


ERR ErrLGConvertFDP( 
	const FUCB			*pfucb,
	const CSR 			*pcsr,
	const SPACE_HEADER	*psph,
	const PGNO			pgnoSecondaryFirst,
	const CPG			cpgSecondary,
	const DBTIME 		dbtimeBefore,
	LGPOS	  			*plgpos )
	{
	ERR					err;
	DATA				rgdata[1];
	LRCONVERTFDP		lrconvertfdp;

	INST *pinst = PinstFromIfmp( pfucb->ifmp );
	LOG *plog = pinst->m_plog;
	
	Assert( !plog->m_fRecovering );
	Assert( pcsr->FDirty() );
	Assert( !FFUCBSpace( pfucb ) );
	Assert( !rgfmp[pfucb->ifmp].FLogOn() || !plog->m_fLogDisabled );
	if ( !rgfmp[pfucb->ifmp].FLogOn() )
		{
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	Assert( 0 < pfucb->ppib->level );

	//	HACK: use the file-system stored in the INST
	//		  (otherwise, we will need to drill a pfsapi down through to EVERY logged operation that 
	//		   begins a deferred operation and that means ALL the B-Tree code will be touched among
	//		   other things)
	CallR( ErrLGCheckState( plog ) );

	//	Redo only operation
	
	CallR( ErrLGDeferBeginTransaction( pfucb->ppib ) );

	lrconvertfdp.lrtyp 			= lrtypConvertFDP;
	lrconvertfdp.le_procid 	  	= pfucb->ppib->procid;
	lrconvertfdp.le_pgnoFDPParent 	= psph->PgnoParent();
	lrconvertfdp.le_pgno			= PgnoFDP( pfucb );
	lrconvertfdp.le_objidFDP		= ObjidFDP( pfucb );
	lrconvertfdp.le_pgnoOE			= PgnoOE( pfucb );
	lrconvertfdp.le_pgnoAE			= PgnoAE( pfucb );
	
	lrconvertfdp.dbid 			  	= rgfmp[ pfucb->ifmp ].Dbid();
	lrconvertfdp.le_dbtime			= pcsr->Dbtime();
	lrconvertfdp.le_dbtimeBefore 	= dbtimeBefore;
	lrconvertfdp.le_cpgPrimary		= psph->CpgPrimary();
	lrconvertfdp.le_cpgSecondary	= cpgSecondary;
	lrconvertfdp.le_pgnoSecondaryFirst = pgnoSecondaryFirst;

	Assert( !lrconvertfdp.FVersioned() );
	Assert( !lrconvertfdp.FDeleted() );
	Assert( !lrconvertfdp.FUnique() );
	Assert( !lrconvertfdp.FSpace() );
	Assert( !lrconvertfdp.FConcCI() );

	if ( psph->FUnique() )
		lrconvertfdp.SetFUnique();

	LGISetTrx( pfucb->ppib, &lrconvertfdp );
	
	rgdata[0].SetPv( (BYTE *)&lrconvertfdp );
	rgdata[0].SetCb( sizeof(lrconvertfdp) );
	
	err = plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, plgpos );

	return err;
	}


ERR ErrLGStart( INST *pinst )
	{
	ERR		err;
	DATA	rgdata[1];
	LRINIT2	lr;
	LOG		*plog = pinst->m_plog;

	if ( plog->m_fLogDisabled || ( plog->m_fRecovering && plog->m_fRecoveringMode != fRecoveringUndo ) )
		return JET_errSuccess;

	// BUG_125831	
	// we should not start if we are low on disk space
	CallR( ErrLGCheckState( plog ) );
	// BUG_125831	

	lr.lrtyp = lrtypInit2;
	LGIGetDateTime( &lr.logtime );
	pinst->SaveDBMSParams( &lr.dbms_param );

	rgdata[0].SetPv( (BYTE *)&lr );
	rgdata[0].SetCb( sizeof(lr) );

	err = plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, pNil );

	plog->m_lgposStart = plog->m_lgposLogRec;
	
	return err;
	}
	

ERR ErrLGIMacroBegin( PIB *ppib, DBTIME dbtime )
	{
	ERR				err;
	DATA			rgdata[1];
	LRMACROBEGIN	lrMacroBegin;

	INST *pinst = PinstFromPpib( ppib );
	LOG *plog = pinst->m_plog;
	
	Assert( !plog->m_fRecovering );
	
	if ( plog->m_fLogDisabled )
		return JET_errSuccess;

	lrMacroBegin.lrtyp 	= lrtypMacroBegin;
	lrMacroBegin.le_procid = ppib->procid;
	lrMacroBegin.le_dbtime = dbtime;

	rgdata[0].SetPv( (BYTE *)&lrMacroBegin );
	rgdata[0].SetCb( sizeof(lrMacroBegin) );

	err = plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, pNil );

	return err;
	}
	

ERR ErrLGIMacroEnd( PIB *ppib, DBTIME dbtime, LRTYP lrtyp, LGPOS *plgpos )
	{
	ERR			err;
	DATA		rgdata[1];
	LRMACROEND	lrMacroEnd;

	INST *pinst = PinstFromPpib( ppib );
	LOG *plog = pinst->m_plog;
	
	Assert( !plog->m_fRecovering || plog->m_fRecoveringMode == fRecoveringUndo );
	
	if ( plog->m_fLogDisabled )
		{
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	Assert( lrtyp == lrtypMacroCommit || lrtyp == lrtypMacroAbort );
	lrMacroEnd.lrtyp	= lrtyp;
	lrMacroEnd.le_procid	= ppib->procid;
	lrMacroEnd.le_dbtime	= dbtime;

	rgdata[0].SetPv( (BYTE *)&lrMacroEnd );
	rgdata[0].SetCb( sizeof(lrMacroEnd) );

	err = plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, plgpos );

	return err;
	}


ERR ErrLGMacroAbort( PIB *ppib, DBTIME dbtime, LGPOS *plgpos )
	{
	return ErrLGIMacroEnd( ppib, dbtime, lrtypMacroAbort, plgpos );
	}

ERR ErrLGShutDownMark( LOG *plog, LGPOS *plgposRec )
	{
	ERR				err;
	DATA			rgdata[1];
	LRSHUTDOWNMARK	lr;

	//	record even during recovery
	//
	if ( plog->m_fLogDisabled || ( plog->m_fRecovering && plog->m_fRecoveringMode != fRecoveringUndo ) )
		{
		*plgposRec = lgposMin;
		return JET_errSuccess;
		}

	lr.lrtyp = lrtypShutDownMark;

	rgdata[0].SetPv( (BYTE *)&lr );
	rgdata[0].SetCb( sizeof(lr) );

	CallR( plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, plgposRec ) );

	//	Continue to make sure it is flushed

SendSignal:
	plog->LGSignalFlush();
		
	plog->m_critLGBuf.Enter();
	const INT	cmp = CmpLgpos( plgposRec, &plog->m_lgposToFlush );
	plog->m_critLGBuf.Leave();
	if ( cmp >= 0 )
		{
		if ( plog->m_fLGNoMoreLogWrite )
			{
			err = ErrERRCheck( JET_errLogWriteFail );
			return err;
			}
		else
			{
			UtilSleep( cmsecWaitLogFlush );
			goto SendSignal;
			}
		}
		
	return err;
	}

	
ERR ErrLGRecoveryUndo( LOG *plog )
	{
	ERR				err;
	DATA			rgdata[1];
	LRRECOVERYUNDO2	lr;

	//	should only be called during undo phase of recovery
	Assert( plog->m_fRecovering );
	Assert( fRecoveringUndo == plog->m_fRecoveringMode );

	if ( plog->m_fLogDisabled || ( plog->m_fRecovering && plog->m_fRecoveringMode != fRecoveringUndo ) )
		{
		return JET_errSuccess;
		}

	lr.lrtyp = lrtypRecoveryUndo2;
	LGIGetDateTime( &lr.logtime );

	rgdata[0].SetPv( (BYTE *)&lr );
	rgdata[0].SetCb( sizeof(lr) );

	err = plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, pNil );

	return err;
	}


ERR ErrLGQuitRec( LOG *plog, LRTYP lrtyp, const LE_LGPOS *ple_lgpos, const LE_LGPOS *ple_lgposRedoFrom, BOOL fHard )
	{
	ERR			err;
	DATA		rgdata[1];
	LRTERMREC2	lr;

	//	record even during recovery
	//
	if ( plog->m_fLogDisabled || ( plog->m_fRecovering && plog->m_fRecoveringMode != fRecoveringUndo ) )
		return JET_errSuccess;

	lr.lrtyp = lrtyp;
	LGIGetDateTime( &lr.logtime );
	lr.lgpos = *ple_lgpos;
	if ( ple_lgposRedoFrom )
		{
		Assert( lrtyp == lrtypRecoveryQuit2 );
		lr.lgposRedoFrom = *ple_lgposRedoFrom;
		lr.fHard = BYTE( fHard );
		}
	rgdata[0].SetPv( (BYTE *)&lr );
	rgdata[0].SetCb( sizeof(lr) );

	err = plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, pNil );

	return err;
	}

	
ERR ErrLGLogBackup(
	LOG*							plog,
	LRLOGBACKUP::LRLOGBACKUP_TYPE	fBackupType,
	CHAR*							szLogRestorePath,
	const BOOL						fLGFlags,
	LGPOS*							plgposLogRec )
	{
	ERR								err;
	DATA							rgdata[2];
	LRLOGBACKUP						lr;
	
	//	record even during recovery
	//
	if ( plog->m_fLogDisabled || ( plog->m_fRecovering && plog->m_fRecoveringMode != fRecoveringUndo ) )
		{
		*plgposLogRec = lgposMin;
		return JET_errSuccess;
		}

	lr.lrtyp = lrtypBackup;

	Assert ( 	LRLOGBACKUP::fLGBackupFull == fBackupType ||
				LRLOGBACKUP::fLGBackupIncremental == fBackupType ||
				LRLOGBACKUP::fLGBackupSnapshotStart == fBackupType ||
				LRLOGBACKUP::fLGBackupSnapshotStop == fBackupType );

	lr.m_fBackupType = BYTE( fBackupType );
	lr.le_cbPath = USHORT( strlen( szLogRestorePath ) );

	rgdata[0].SetPv( (BYTE *)&lr );
	rgdata[0].SetCb( sizeof(lr) );
	rgdata[1].SetPv( reinterpret_cast<BYTE *>( szLogRestorePath ) );
	rgdata[1].SetCb( lr.le_cbPath );

	err = plog->ErrLGLogRec( rgdata, 2, fLGFlags, plgposLogRec );

	return err;
	}


#ifdef DISABLE_SLV
#else

ERR ErrLGSLVIPageAppendChecksum(
						PIB* const 		ppib,
						const IFMP		ifmp,
						const QWORD		ibLogical,
						const ULONG		cbData,
						VOID* const		pvData,
						SLVOWNERMAPNODE	*pOwnerMapNode )
	{
	ERR				err = JET_errSuccess;
	
	ASSERT_VALID( ppib );
	Assert( ifmp & ifmpSLV );
	Assert( cbData );
	Assert( cbData <= g_cbPage );
	Assert( pvData );
	Assert( pOwnerMapNode != NULL );

	//  get our instance and log instance

	INST*	pinst	= PinstFromIfmp( ifmp & ifmpMask );
	LOG*	plog	= pinst->m_plog;

	Assert ( pinst->FSLVProviderEnabled() );
	
	Assert ( 0 == ( ibLogical % sizeof(QWORD) ) );
	// we don't append in a SLV page for backdoor
	// so we have to start at a page boundary
	Assert ( 0 == ( ibLogical % SLVPAGE_SIZE ) );

	if ( rgfmp[ifmp & ifmpMask].PfcbSLVOwnerMap() )
		{		
		Assert ( !plog->m_fRecovering );		
		ULONG ulChecksum; 

		TRY
			{
			ulChecksum = UlChecksumSLV(
								(BYTE*)pvData,
								(BYTE*)pvData + cbData );
			}
		EXCEPT ( efaExecuteHandler )
			{
			CallR ( ErrERRCheck( JET_errSLVFileIO ) );
			}
		ENDEXCEPT

		pOwnerMapNode->AssertOnPage( PgnoOfOffset( ibLogical ) );
		CallR( pOwnerMapNode->ErrSetChecksum( ppib, ulChecksum, cbData ) );
		}

	return JET_errSuccess;
	}

// ErrLGSLVPageAppend			- logs a physical SLV append
//
// IN:
//		ppib					- session
//      ifmp					- SLV ifmp
//		ibLogical				- starting SLV file offset
//		cbData					- size
//		pvData					- data
//		fDataLogged				- fTrue if the data should be logged
//		plgpos					- buffer for receiving the LGPOS of this record
//
// RESULT:						ERR
//
// OUT:	
//		plgpos					- LGPOS of this record

ERR ErrLGSLVPageAppend(	PIB* const 		ppib,
						const IFMP		ifmp,
						const QWORD		ibLogical,
						const ULONG		cbData,
						VOID* const		pvData,
						const BOOL		fDataLogged,
						SLVOWNERMAPNODE	*pslvownermapNode,
						LGPOS* const	plgpos )
	{
	ERR				err = JET_errSuccess;
	DATA			rgdata[ 2 ];
	LRSLVPAGEAPPEND	lrSLVPageAppend;

//	UNDONE (see bug X5:143388): don't currently support appends if not on page boundary
///Assert( 0 == ( ibLogical % SLVPAGE_SIZE ) );	

	//  validate IN args

	ASSERT_VALID( ppib );
	Assert( ifmp & ifmpSLV );
	Assert( cbData );
	Assert( cbData <= g_cbPage );
	Assert( pvData );

	//  get our instance and log instance

	INST * const	pinst	= PinstFromIfmp( ifmp & ifmpMask );
	LOG * const		plog	= pinst->m_plog;

	//	we don't always need to log the data
	//	if
	//		- circular logging is on (i.e. we won't need to roll forward)
	//		- we are using IFS (i.e. the streaming file is write-through)
	//		- we aren't backing up the server
	//	we can avoid logging
	
	const BOOL fBackup 				= plog->m_fBackupInProgress;
	const BOOL fCircularLogging		= plog->m_fLGCircularLogging;
	const BOOL fSLVProviderEnabled 	= pinst->FSLVProviderEnabled();
	
	const BOOL fLogData 			= fDataLogged && ( fBackup || !fCircularLogging || !fSLVProviderEnabled );
	
	// on frontdoor, it is done in ErrSLVWriteRun
	if ( pinst->FSLVProviderEnabled() )
		{
		CallR ( ErrLGSLVIPageAppendChecksum( ppib, ifmp, ibLogical, cbData, pvData, pslvownermapNode ) );
		}
		
	//  forget it if logging is disabled globally or for this database or if we
	//  are recovering

	Assert( !rgfmp[ifmp & ifmpMask].FLogOn() || !plog->m_fLogDisabled );
	if ( !rgfmp[ ifmp & ifmpMask ].FLogOn() || plog->m_fRecovering )
		{
		if ( plgpos )
			{
			if ( plog->m_fRecovering )
				{
				*plgpos = plog->m_lgposRedo;
				}
			else
				{
				*plgpos = lgposMin;
				}
			}
		return JET_errSuccess;
		}

	//  perform our session's deferred begin transaction if necessary
	
	CallR( ErrLGDeferBeginTransaction( ppib ) );

	// fill the append record
	
	lrSLVPageAppend.lrtyp			= lrtypSLVPageAppend;
	lrSLVPageAppend.le_procid		= ppib->procid;
	lrSLVPageAppend.dbid			= rgfmp[ ifmp & ifmpMask ].Dbid();
	lrSLVPageAppend.le_ibLogical	= ibLogical;
	lrSLVPageAppend.le_cbData		= cbData;

	rgdata[0].SetPv( (BYTE*)&lrSLVPageAppend );
	rgdata[0].SetCb( sizeof( LRSLVPAGEAPPEND ) );

	Assert( !lrSLVPageAppend.FDataLogged() );
	if ( fLogData )
		{
		lrSLVPageAppend.SetFDataLogged();
		rgdata[1].SetPv( pvData );
		rgdata[1].SetCb( cbData );	
		}
	
	//  log the record
	err = plog->ErrLGLogRec( rgdata, fLogData ? 2 : 1, fLGNoNewGen, plgpos );

	return err;
	}

#endif	//	DISABLE_SLV

char const *szNOP 						= "NOP      ";
char const *szNOPEndOfList				= "NOPEnd   ";
char const *szInit						= "Init     ";
char const *szTerm						= "Term     ";
char const *szMS						= "MS       ";
char const *szEnd						= "End      ";

char const *szBegin						= "Begin    ";
char const *szCommit					= "Commit   ";
char const *szRollback					= "Rollback ";

char const *szCreateDB					= "CreateDB ";
char const *szAttachDB					= "AttachDB ";
char const *szDetachDB					= "DetachDB ";
char const *szDbList					= "DbList   ";

char const *szCreateMultipleExtentFDP	= "Create M ";
char const *szCreateSingleExtentFDP		= "Create S ";
char const *szConvertFDP				= "Convert  ";

char const *szSplit						= "Split    ";
char const *szEmptyPage					= "EmptyPage";
char const *szMerge						= "Merge    ";
char const *szEmptyTree					= "EmptyTree";

char const *szInsert					= "Insert   ";
char const *szFlagInsert				= "FInsert  ";
char const *szFlagInsertAndReplaceData	= "FInsertRD";
char const *szFlagDelete				= "FDelete  ";
char const *szReplace					= "Replace  ";
char const *szReplaceD					= "ReplaceD ";

char const *szLock						= "Lock     ";
char const *szUndoInfo					= "UndoInfo ";

char const *szDelta						= "Delta    ";
char const *szDelete					= "Delete   ";

char const *szUndo						= "Undo     ";

char const *szBegin0					= "Begin0   ";
char const *szBeginDT					= "BeginDT  ";
char const *szPrepCommit				= "PreCommit";
char const *szPrepRollback				= "PreRollbk";
char const *szCommit0					= "Commit0  ";
char const *szRefresh					= "Refresh  ";

char const *szRecoveryUndo				= "RcvUndo  ";
char const *szRecoveryQuit				= "RcvQuit  ";

char const *szFullBackup				= "FullBkUp ";
char const *szIncBackup					= "IncBkUp  ";
char const *szBackup					= "Backup   ";

char const *szJetOp						= "JetOp    ";
char const *szTrace						= "Trace    ";

char const *szShutDownMark				= "ShutDown ";

char const *szSetExternalHeader 		= "SetExtHdr";

char const *szMacroBegin				= "McroBegin";
char const *szMacroCommit				= "McroComit";
char const *szMacroAbort				= "McroAbort";

char const *szSLVPageAppend				= "SLVPgAppd";
char const *szSLVSpace					= "SLVSpace ";
char const *szSLVPageMove				= "SLVPgMove";

char const *szChecksum					= "Checksum ";

char const *szExtRestore 				= "ExtRest  ";
char const *szForceDetachDB				= "FDetachDB";
char const *szForceFlushLog			= "FFlushLog";

char const *szUnknown					= "*UNKNOWN*";

const char * SzLrtyp( LRTYP lrtyp )
	{
	switch ( lrtyp )
		{
		case lrtypNOP:			return szNOP;
		case lrtypInit:			return szInit;
		case lrtypInit2:		return szInit;
		case lrtypTerm:			return szTerm;
		case lrtypTerm2:		return szTerm;
		case lrtypMS:			return szMS;
		case lrtypEnd:			return szEnd;

		case lrtypBegin:		return szBegin;
		case lrtypCommit:		return szCommit;
		case lrtypRollback:		return szRollback;	
		case lrtypBegin0:		return szBegin0;
		case lrtypCommit0:		return szCommit0;
		case lrtypBeginDT:		return szBeginDT;
		case lrtypPrepCommit:	return szPrepCommit;
		case lrtypPrepRollback:	return szPrepRollback;
		case lrtypRefresh:		return szRefresh;
		case lrtypMacroBegin:	return szMacroBegin;
		case lrtypMacroCommit:	return szMacroCommit;
		case lrtypMacroAbort:	return szMacroAbort;
		
		case lrtypCreateDB:		return szCreateDB;
		case lrtypAttachDB:		return szAttachDB;
		case lrtypDetachDB:		return szDetachDB;
		case lrtypDbList:		return szDbList;
		
		//	debug log records
		//
		case lrtypRecoveryUndo:	return szRecoveryUndo;
		case lrtypRecoveryUndo2:	return szRecoveryUndo;
		case lrtypRecoveryQuit: return szRecoveryQuit;
		case lrtypRecoveryQuit2: return szRecoveryQuit;
		
		case lrtypFullBackup:	return szFullBackup;
		case lrtypIncBackup:	return szIncBackup;
		case lrtypBackup:		return szBackup;
		
		case lrtypJetOp:		return szJetOp;
		case lrtypTrace:		return szTrace;
		
		case lrtypShutDownMark:	return szShutDownMark;

		//	multi-page updaters
		//
		case lrtypCreateMultipleExtentFDP:	return szCreateMultipleExtentFDP;
		case lrtypCreateSingleExtentFDP:	return szCreateSingleExtentFDP;
		case lrtypConvertFDP:				return szConvertFDP;
	
		case lrtypSplit:		return szSplit;
		case lrtypMerge:	 	return szMerge;
		case lrtypEmptyTree:	return szEmptyTree;
		
		//	single-page updaters
		//
		case lrtypInsert:		return szInsert;
		case lrtypFlagInsert:	return szFlagInsert;
		case lrtypFlagInsertAndReplaceData:	
								return szFlagInsertAndReplaceData;
		case lrtypFlagDelete:	return szFlagDelete;
		case lrtypReplace:		return szReplace;
		case lrtypReplaceD:		return szReplaceD;
		case lrtypDelete:		return szDelete;
		
		case lrtypUndoInfo:	return szUndoInfo;

		case lrtypDelta:		return szDelta;
		
		case lrtypSetExternalHeader:
								return szSetExternalHeader;

		case lrtypUndo:			return szUndo;

		

		// SLV file changed
		case lrtypSLVPageAppend:
								return szSLVPageAppend;
		case lrtypSLVSpace:		return szSLVSpace;

		case lrtypSLVPageMove:	return szSLVPageMove;

		case lrtypChecksum:		return szChecksum;

		case lrtypExtRestore: 	return szExtRestore;
		case lrtypForceDetachDB: return szForceDetachDB;
		case lrtypForceFlushLog:	return szForceFlushLog;
		default:				return szUnknown;
		}
	Assert( fFalse );
	}
	
#ifdef DEBUG

const CHAR * const mpopsz[opMax] = {
	0,									//	0		
	"JetIdle",							//	1	
	"JetGetTableIndexInfo",				//	2	
	"JetGetIndexInfo",					//	3	
	"JetGetObjectInfo",					//	4	
	"JetGetTableInfo",					//	5	
	"JetCreateObject",					//	6	
	"JetDeleteObject",					//	7	
	"JetRenameObject",					//	8	
	"JetBeginTransaction",				//	9	
	"JetCommitTransaction",				//	10	
	"JetRollback",						//	11	
	"JetOpenTable",						//	12	
	"JetDupCursor",						//	13	
	"JetCloseTable",					//	14	
	"JetGetTableColumnInfo",			//	15	
	"JetGetColumnInfo",					//	16	
	"JetRetrieveColumn",				//	17	
	"JetRetrieveColumns",				//	18	
	"JetSetColumn",						//	19	
	"JetSetColumns",					//	20	
	"JetPrepareUpdate",					//	21	
	"JetUpdate",						//	22	
	"JetDelete",						//	23	
	"JetGetCursorInfo",					//	24	
	"JetGetCurrentIndex",				//	25	
	"JetSetCurrentIndex",				//	26	
	"JetMove",							// 	27	
	"JetMakeKey",						//	28	
	"JetSeek",							//	29	
	"JetGetBookmark",					//	30	
	"JetGotoBookmark",					//	31	
	"JetGetRecordPosition",				//	32	
	"JetGotoPosition",					//	33	
	"JetRetrieveKey",					//	34	
	"JetCreateDatabase",				//	35	
	"JetOpenDatabase",					//	36	
	"JetGetDatabaseInfo",				//	37	
	"JetCloseDatabase",					//	38	
	"JetCapability",					//	39	
	"JetCreateTable",					//	40	
	"JetRenameTable",					//	41	
	"JetDeleteTable",					//	42	
	"JetAddColumn",						//	43	
	"JetRenameColumn",					//	44	
	"JetDeleteColumn",					//	45	
	"JetCreateIndex",					//	46	
	"JetRenameIndex",					//	47	
	"JetDeleteIndex",					//	48	
	"JetComputeStats",					//	49	
	"JetAttachDatabase",				//	50	
	"JetDetachDatabase",				//	51	
	"JetOpenTempTable",					//	52	
	"JetSetIndexRange",					//	53	
	"JetIndexRecordCount",				//	54	
	"JetGetChecksum",					//	55	
	"JetGetObjidFromName",				//	56	
	"JetEscrowUpdate",					//	57
	"JetGetLock",						//	58
	"JetRetrieveTaggedColumnList",		//	59
	"JetCreateTableColumnIndex",		//	60
	"JetSetColumnDefaultValue",			//	61
	"JetPrepareToCommitTransaction",	//	62
	"JetSetTableSequential",			//  63
	"JetResetTableSequential",			//  64
	"JetRegisterCallback",				//  65
	"JetUnregisterCallback",			//  66
	"JetSetLS",							//  67
	"JetGetLS",							//  68
	"JetGetVersion",					//  69
	"JetBeginSession",					//  70
	"JetDupSession",					//  71
	"JetEndSession",					//  72
	"JetBackupInstance",				//  73
	"JetBeginExternalBackupInstance",	//  74
	"JetGetAttachInfoInstance",			//  75
	"JetOpenFileInstance",				//  76
	"JetReadFileInstance",				//  77
	"JetCloseFileInstance",				//  78
	"JetGetLogInfoInstance",			//  79
	"JetGetTruncateLogInfoInstance",	//  80
	"JetTruncateLogInstance",			//  81
	"JetEndExternalBackupInstance",		//  82
	"JetSnapshotStart",					//  83
	"JetSnapshotStJet",					//  84
	"JetResetCounter",					//  85
	"JetGetCounter",					//  86
	"JetCompact",						//  87
	"JetConvertDDL",					//  88
	"JetUpgradeDatabase",				//  89
	"JetDefragment",					//  90
	"JetSetDatabaseSize",				//  91
	"JetGrowDatabase",					//  92
	"JetSetSessionContext",				//  93
	"JetResetSessionContext",			//  94
	"JetSetSystemParameter",			//  95
	"JetGetSystemParameter",			//  96
	"JetTerm",							//  97
	"JetInit",							//  98
	"JetIntersectIndexes",				//  99
	"JetEnumerateColumns",				//  100
};

VOID SPrintSign( SIGNATURE *psign, char * sz )
	{
	LOGTIME tm = psign->logtimeCreate;
	sprintf( sz, "Create time:%d/%d/%d %d:%d:%d Rand:%lu Computer:%s",
						(short) tm.bMonth,
						(short) tm.bDay,
						(short) tm.bYear + 1900,
						(short) tm.bHours,
						(short) tm.bMinutes,
						(short) tm.bSeconds,
						(ULONG) psign->le_ulRandom,
						0 != psign->szComputerName[0] ? psign->szComputerName : "<None>" );
	}

const BYTE mpbb[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8',
					 '9', 'A', 'B', 'C', 'D', 'E', 'F' };

// In order to output 1 byte of raw data, need 3 bytes - two to
// represent the data and a trailing space.
// Also need a null-terminator to mark the end of the data stream.
// Finally, DWORD-align the buffer.
const INT	cbRawDataMax		= 16;
const INT	cbFormattedDataMax	= ( ( ( ( cbRawDataMax * 3 ) + 1 )
									+ (sizeof(DWORD)-1) ) / sizeof(DWORD) ) * sizeof(DWORD);

LOCAL VOID DataToSz ( const BYTE *pbData, INT cbData, CHAR * sz )
	{
	const BYTE	*pb;
	const BYTE	*pbMax;
	BYTE	*pbPrint = reinterpret_cast<BYTE *>( sz );

	if ( cbData > cbRawDataMax )
		pbMax = pbData + cbRawDataMax;
	else
		pbMax = pbData + cbData;

	for( pb = pbData; pb < pbMax; pb++ )
		{
		BYTE b = *pb;
		
		*pbPrint++ = mpbb[b >> 4];
		*pbPrint++ = mpbb[b & 0x0f];
		*pbPrint++ = ' ';
		
//		if ( isalnum( *pb ) )
//			DBGprintf( "%c", *pb );
//		else
//			DBGprintf( "%x", *pb );
		}

	*pbPrint='\0';
	}


VOID ShowData ( const BYTE *pbData, INT cbData )
	{
	CHAR	rgchPrint[cbFormattedDataMax];
	DataToSz( pbData, cbData, rgchPrint );
	DBGprintf( "%s", rgchPrint );
	}

	

//	Prints log record contents.  If pv == NULL, then data is assumed
//	to follow log record in contiguous memory.
//
// INT cNOP = 0;

const INT	cbLRBuf = 1024 + cbFormattedDataMax;

VOID ShowLR( const LR *plr, LOG * plog )
	{
	char rgchBuf[cbLRBuf];
	LrToSz( plr, rgchBuf, plog );
	DBGprintf( "%s\n", rgchBuf );
	}

VOID CheckEndOfNOPList( const LR *plr, LOG *plog )
	{
	const ULONG	cNOP	= plog->GetNOP();

	Assert( cNOP > 0 );
	if ( NULL == plr || lrtypNOP != plr->lrtyp )
		{
		if ( cNOP > 1 )
			{
			DBGprintf( ">                 %s (Total NOPs: %d)\n", szNOPEndOfList, cNOP );
			}
		plog->SetNOP(0);
		}
	else
		{
		plog->IncNOP();
		}
	}


VOID LrToSz( const LR *plr, char * szLR, LOG * plog )
	{
	LRTYP 	lrtyp;
	CHAR	rgchBuf[cbLRBuf];

	char const *szUnique 		= "U";
	char const *szNotUnique		= "NU";

	char const *szPrefix		= "P";
	char const *szNoPrefix		= "NP";

	char const *szVersion		= "V";
	char const *szNoVersion		= "NV";

	char const *szDeleted		= "D";
	char const *szNotDeleted	= "ND";

	char const *szEmptyPage		= "EP";
	char const *szNotEmptyPage	= "NEP";

	char const *szKeyChange		= "KC";
	char const *szNoKeyChange	= "NKC";

	char const *szConcCI		= "CI";
	char const *szNotConcCI		= "NCI";

	char const *szData			= "D";
	char const *szNoData		= "ND";

	char const *szSpaceTree		= "SP";
	char const *szNotSpaceTree	= "NSP";

	char const *rgszIO[]		= { "???", "SR", "SW", "AR", "AW", "???" };
	char const *rgszMergeType[]	= { "None", "EmptyPage", "FullRight", "PartialRight", "EmptyTree" };

 	if ( plr->lrtyp >= lrtypMax )
		lrtyp = lrtypMax;
	else
		lrtyp = plr->lrtyp;

	if ( !plog || plog->GetNOP() == 0 || lrtyp != lrtypNOP )
		{
		sprintf( szLR, " %s", SzLrtyp( lrtyp ) );
		}
		
	switch ( plr->lrtyp )
		{
		case lrtypNOP:
			if( plog )
				{
				Assert( 0 == plog->GetNOP() );
				plog->IncNOP();
				}
			break;

		case lrtypMS:
			{
			LRMS *plrms = (LRMS *)plr;

			sprintf( rgchBuf, " (%X,%X checksum %u)",
				(USHORT) plrms->le_isecForwardLink,
				(USHORT) plrms->le_ibForwardLink,
				(ULONG) plrms->le_ulCheckSum );
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypInsert:
			{
			LRINSERT	*plrinsert = (LRINSERT *)plr;
			BYTE		*pb;
			ULONG		cb;

			pb = (BYTE *) plr + sizeof( LRINSERT );
			cb = plrinsert->CbSuffix() + plrinsert->CbPrefix() + plrinsert->CbData();
			
			sprintf( rgchBuf, " %I64x,%I64x,%lx:%u(%x,[%u:%lu:%u],%s:%s:%s:%s,%u,%u,%u,rceid:%lu,objid:%lu)",
					(DBTIME) plrinsert->le_dbtime,
					(DBTIME) plrinsert->le_dbtimeBefore,
					(TRX) plrinsert->le_trxBegin0,
					(USHORT) plrinsert->level,
					(PROCID) plrinsert->le_procid,
					(USHORT) plrinsert->dbid,
					(PGNO) plrinsert->le_pgno,
					plrinsert->ILine(),
					plrinsert->FUnique() ? szUnique : szNotUnique,
					plrinsert->FVersioned() ? szVersion : szNoVersion,
					plrinsert->FDeleted() ? szDeleted : szNotDeleted,
					plrinsert->FConcCI() ? szConcCI : szNotConcCI,
 					plrinsert->CbPrefix(),
 					plrinsert->CbSuffix(),
					plrinsert->CbData(),
					(RCEID) plrinsert->le_rceid,
					(OBJID) plrinsert->le_objidFDP );
			strcat( szLR, rgchBuf );

			DataToSz( pb, cb, rgchBuf );
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypFlagInsert:
			{
			LRFLAGINSERT	*plrflaginsert = (LRFLAGINSERT *)plr;

			sprintf( rgchBuf, " %I64x,%I64x,%lx:%u(%x,[%u:%lu:%u],%s:%s:%s:%s,rceid:%lu,objid:%lu)",
					(DBTIME) plrflaginsert->le_dbtime,
					(DBTIME) plrflaginsert->le_dbtimeBefore,
					(TRX) plrflaginsert->le_trxBegin0,
					(USHORT) plrflaginsert->level,
					(PROCID) plrflaginsert->le_procid,
					(USHORT) plrflaginsert->dbid,
					(PGNO) plrflaginsert->le_pgno,
					plrflaginsert->ILine(),
					plrflaginsert->FUnique() ? szUnique : szNotUnique,
					plrflaginsert->FVersioned() ? szVersion : szNoVersion,
					plrflaginsert->FDeleted() ? szDeleted : szNotDeleted,
					plrflaginsert->FConcCI() ? szConcCI : szNotConcCI,
					(RCEID) plrflaginsert->le_rceid,
					(OBJID) plrflaginsert->le_objidFDP );
			strcat( szLR, rgchBuf );

			break;
			}

		case lrtypReplace:
		case lrtypReplaceD:
			{
			LRREPLACE *plrreplace = (LRREPLACE *)plr;
			BYTE	*pb;
			USHORT	cb;

			pb = (BYTE *) plrreplace + sizeof( LRREPLACE );
			cb = plrreplace->Cb();

			sprintf( rgchBuf, " %I64x,%I64x,%lx:%u(%x,[%u:%lu:%u],%s:%s:%s,%5u,%5u,%5u,rceid:%lu,objid:%lu)",
				(DBTIME) plrreplace->le_dbtime,
				(DBTIME) plrreplace->le_dbtimeBefore,
				(TRX) plrreplace->le_trxBegin0,
				(USHORT) plrreplace->level,
				(PROCID) plrreplace->le_procid,
				(USHORT) plrreplace->dbid,
				(PGNO) plrreplace->le_pgno,
				plrreplace->ILine(),
				plrreplace->FUnique() ? szUnique : szNotUnique,
				plrreplace->FVersioned() ? szVersion : szNoVersion,
				plrreplace->FConcCI() ? szConcCI : szNotConcCI,
				cb,
				plrreplace->CbNewData(),
				plrreplace->CbOldData(),
				(RCEID) plrreplace->le_rceid,
				(OBJID) plrreplace->le_objidFDP );
			strcat( szLR, rgchBuf );
			if ( plr->lrtyp == lrtypReplaceD )
				{
				LGDumpDiff(	pb, cb );
				}
			else
				{
				DataToSz( pb, cb, rgchBuf );
				strcat( szLR, rgchBuf );
				}
			break;
			}

		case lrtypFlagInsertAndReplaceData:
			{
			LRFLAGINSERTANDREPLACEDATA *plrfiard = (LRFLAGINSERTANDREPLACEDATA *)plr;
			BYTE	*pb;
			ULONG	cb;

			pb = (BYTE *) plrfiard + sizeof( LRFLAGINSERTANDREPLACEDATA );
			cb = plrfiard->CbKey() + plrfiard->CbData();

			sprintf( rgchBuf, " %I64x,%I64x,%lx:%u(%x,[%u:%lu:%u],%s:%s:%s,%5u,rceidInsert:%lu,rceidReplace:%lu,objid:%lu)",
				(DBTIME) plrfiard->le_dbtime,
				(DBTIME) plrfiard->le_dbtimeBefore,
				(TRX) plrfiard->le_trxBegin0,
				(USHORT) plrfiard->level,
				(PROCID) plrfiard->le_procid,
				(USHORT) plrfiard->dbid,
				(PGNO) plrfiard->le_pgno,
				plrfiard->ILine(),
				plrfiard->FUnique() ? szUnique : szNotUnique,
				plrfiard->FVersioned() ? szVersion : szNoVersion,
				plrfiard->FConcCI() ? szConcCI : szNotConcCI,
				cb,
				(RCEID) plrfiard->le_rceid,
				(RCEID) plrfiard->le_rceidReplace,
				(OBJID) plrfiard->le_objidFDP );
			strcat( szLR, rgchBuf );
			if ( plr->lrtyp == lrtypReplaceD )
				{
				LGDumpDiff(	pb, cb );
				}
			else
				{
				DataToSz( pb, cb, rgchBuf );
				strcat( szLR, rgchBuf );
				}
			break;
			}
			
		case lrtypFlagDelete:
			{
			LRFLAGDELETE *plrflagdelete = (LRFLAGDELETE *)plr;
			sprintf( rgchBuf, " %I64x,%I64x,%lx:%u(%x,[%u:%lu:%u],%s:%s:%s),rceid:%lu,objid:%lu",
				(DBTIME) plrflagdelete->le_dbtime,
				(DBTIME) plrflagdelete->le_dbtimeBefore,
				(TRX) plrflagdelete->le_trxBegin0,
				(USHORT) plrflagdelete->level,
				(PROCID) plrflagdelete->le_procid,
				(USHORT) plrflagdelete->dbid,
				(PGNO) plrflagdelete->le_pgno,
				plrflagdelete->ILine(),
				plrflagdelete->FUnique() ? szUnique : szNotUnique,
				plrflagdelete->FVersioned() ? szVersion : szNoVersion,
				plrflagdelete->FConcCI() ? szConcCI : szNotConcCI,
				(RCEID) plrflagdelete->le_rceid,
				(OBJID) plrflagdelete->le_objidFDP );
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypDelete:
			{
			LRDELETE *plrdelete = (LRDELETE *)plr;
			sprintf( rgchBuf, " %I64x,%I64x,%lx:%u(%x,[%u:%lu:%u],%s,objid:%lu)",
				(DBTIME) plrdelete->le_dbtime,
				(DBTIME) plrdelete->le_dbtimeBefore,
				(TRX) plrdelete->le_trxBegin0,
				(USHORT) plrdelete->level,
				(PROCID) plrdelete->le_procid,
				(USHORT) plrdelete->dbid,
				(PGNO) plrdelete->le_pgno,
				plrdelete->ILine(),
				plrdelete->FUnique() ? szUnique : szNotUnique,
				(OBJID) plrdelete->le_objidFDP );
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypUndoInfo:
			{
			LRUNDOINFO *plrundoinfo = (LRUNDOINFO *)plr;
			sprintf( rgchBuf, " %lx:%u(%x,[%u:%lu],%u,rceid:%lu,objid:%lu)",
				(TRX) plrundoinfo->le_trxBegin0,
				(USHORT) plrundoinfo->level,
				(PROCID) plrundoinfo->le_procid,
				(USHORT) plrundoinfo->dbid,
				(PGNO) plrundoinfo->le_pgno,
				(USHORT) plrundoinfo->le_cbData,
				(RCEID) plrundoinfo->le_rceid,
				(OBJID) plrundoinfo->le_objidFDP
				);
			strcat( szLR, rgchBuf );

			DataToSz( plrundoinfo->rgbData, plrundoinfo->le_cbData, rgchBuf );
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypDelta:
			{
			LRDELTA *plrdelta = (LRDELTA *)plr;

			sprintf( rgchBuf, " %I64x,%I64x,%lx:%u(%x,[%u:%lu:%u],%s:%s,%d,rceid:%lu,objid:%lu)",
				(DBTIME) plrdelta->le_dbtime,
				(DBTIME) plrdelta->le_dbtimeBefore,
				(TRX) plrdelta->le_trxBegin0,
				(USHORT) plrdelta->level,
				(PROCID) plrdelta->le_procid,
				(USHORT) plrdelta->dbid,
				(PGNO) plrdelta->le_pgno,
				plrdelta->ILine(),
				plrdelta->FVersioned() ? szVersion : szNoVersion,
				plrdelta->FConcCI() ? szConcCI : szNotConcCI,
				(SHORT) plrdelta->LDelta(),
				(RCEID) plrdelta->le_rceid,
				(OBJID) plrdelta->le_objidFDP );
			strcat( szLR, rgchBuf );
			break;
			}


		case lrtypJetOp:
			{
			LRJETOP *plrjetop = (LRJETOP *)plr;
	   		sprintf( rgchBuf, " (%x) -- %s",
	   			(PROCID) plrjetop->le_procid,
	   			mpopsz[ plrjetop->op ] );
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypBegin:
		case lrtypBegin0:
#ifdef DTC		
		case lrtypBeginDT:
#endif		
			{
			const LRBEGINDT		* const plrbeginDT	= (LRBEGINDT *)plr;
			Assert( plrbeginDT->levelBeginFrom >= 0 );
			Assert( plrbeginDT->clevelsToBegin <= levelMax );
	   		sprintf( rgchBuf, " (%x,from:%d,to:%d)",
	   			(PROCID) plrbeginDT->le_procid,
	   			(SHORT) plrbeginDT->levelBeginFrom,
	   			(SHORT) ( plrbeginDT->levelBeginFrom + plrbeginDT->clevelsToBegin ) );
			strcat( szLR, rgchBuf );
			if ( lrtypBegin != plr->lrtyp )
				{
				sprintf( rgchBuf, " %lx", (TRX) plrbeginDT->le_trxBegin0 );
				strcat( szLR, rgchBuf );
				}
			break;
			}

		case lrtypMacroBegin:
		case lrtypMacroCommit:
		case lrtypMacroAbort:
			{
			LRMACROBEGIN *plrmbegin = (LRMACROBEGIN *)plr;
	   		sprintf( rgchBuf, " (%x) %I64x", (PROCID) plrmbegin->le_procid, (DBTIME) plrmbegin->le_dbtime );
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypRefresh:
			{
			LRREFRESH *plrrefresh = (LRREFRESH *) plr;

			sprintf( rgchBuf, " (%x,%lx)",
	   			(PROCID) plrrefresh->le_procid,
	   			(TRX) plrrefresh->le_trxBegin0 );
			strcat( szLR, rgchBuf );

			break;
			}

		case lrtypCommit:
		case lrtypCommit0:
			{
			LRCOMMIT0 *plrcommit0 = (LRCOMMIT0 *)plr;
	   		sprintf( rgchBuf, " (%x,to:%d)",
	   			(PROCID) plrcommit0->le_procid,
	   			(USHORT) plrcommit0->levelCommitTo );
	   		strcat( szLR, rgchBuf );
			if ( plr->lrtyp == lrtypCommit0 )
				{
				sprintf( rgchBuf, " %lx", (TRX) plrcommit0->le_trxCommit0 );
				strcat( szLR, rgchBuf );
				}
			break;
			}

		case lrtypRollback:
			{
			LRROLLBACK *plrrollback = (LRROLLBACK *)plr;
			sprintf( rgchBuf, " (%x,%d)",
				(PROCID) plrrollback->le_procid,
				(USHORT) plrrollback->levelRollback );
			strcat( szLR, rgchBuf );
			break;
			}

#ifdef DTC
		case lrtypPrepCommit:
			{
			const LRPREPCOMMIT	* const plrprepcommit	= (LRPREPCOMMIT *)plr;

			sprintf( rgchBuf, " (%x)", (PROCID)plrprepcommit->le_procid );
			strcat( szLR, rgchBuf );

			DataToSz( plrprepcommit->rgbData, plrprepcommit->le_cbData, rgchBuf );
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypPrepRollback:
			{
			const LRPREPROLLBACK	* const plrpreprollback	= (LRPREPROLLBACK *)plr;

			sprintf( rgchBuf, " (%x)", (PROCID)plrpreprollback->le_procid );
			strcat( szLR, rgchBuf );
			break;			
			}
#endif	//	DTC

		case lrtypForceFlushLog:
			{
			const LRFORCEFLUSHLOG	* const plrforceflushlog	= (LRFORCEFLUSHLOG *)plr;

			sprintf( rgchBuf, " (%x)", (PROCID)plrforceflushlog->le_procid );
			strcat( szLR, rgchBuf );
			break;			
			}

		case lrtypCreateDB:
			{
			LRCREATEDB *plrcreatedb = (LRCREATEDB *) plr;
			CHAR *sz;

			sz = (CHAR *)( plr ) + sizeof(LRCREATEDB);
			sprintf( rgchBuf, " (%x,%s,%u)", (PROCID)plrcreatedb->le_procid, sz, (USHORT) plrcreatedb->dbid );
			strcat( szLR, rgchBuf );

			if ( plrcreatedb->FCreateSLV() )
				{
				sz += strlen(sz) + 1;		//	SLV name follows db name
				sprintf( rgchBuf, " SLV: %s", sz );
				strcat( szLR, rgchBuf );

				sz += strlen(sz) + 1;
				sprintf( rgchBuf, " SLVRoot: %s", sz );
				strcat( szLR, rgchBuf );
				}
			else
				{
				sprintf( rgchBuf, " SLV: <none>" );
				strcat( szLR, rgchBuf );
				sprintf( rgchBuf, " SLVRoot: <none>" );
				strcat( szLR, rgchBuf );
				}

			sprintf( rgchBuf, " SLV Provider: %s", plrcreatedb->FSLVProviderNotEnabled() ? "NO" : "YES" );
			strcat( szLR, rgchBuf );

			sprintf( rgchBuf, " cpgMax: %lu Sig: ", (ULONG) plrcreatedb->le_cpgDatabaseSizeMax );
			strcat( szLR, rgchBuf );
			SPrintSign( &plrcreatedb->signDb, rgchBuf );
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypAttachDB:
			{
			LRATTACHDB *plrattachdb = (LRATTACHDB *) plr;
			CHAR *sz;

			sz = reinterpret_cast<CHAR *>( plrattachdb ) + sizeof(LRATTACHDB);
			sprintf( rgchBuf, " (%x,%s,%u)", (PROCID)plrattachdb->le_procid, sz, (USHORT) plrattachdb->dbid );
			strcat( szLR, rgchBuf );

			if ( plrattachdb->FSLVExists() )
				{
				sz += strlen(sz) + 1;		//	SLV name follows db name
				sprintf( rgchBuf, " SLV: %s", sz );
				strcat( szLR, rgchBuf );

				sz += strlen(sz) + 1;
				sprintf( rgchBuf, " SLVRoot: %s", sz );
				strcat( szLR, rgchBuf );
				}
			else
				{
				sprintf( rgchBuf, " SLV: <none>" );
				strcat( szLR, rgchBuf );
				sprintf( rgchBuf, " SLVRoot: <none>" );
				strcat( szLR, rgchBuf );
				}

			sprintf( rgchBuf, " SLV Provider: %s", plrattachdb->FSLVProviderNotEnabled() ? "NO" : "YES" );
			strcat( szLR, rgchBuf );

			sprintf( rgchBuf, " cpgMax: %u", plrattachdb->le_cpgDatabaseSizeMax );
			strcat( szLR, rgchBuf );
			sprintf( rgchBuf, " consistent:(%X,%X,%X)   SigDb: ",
				(short) plrattachdb->lgposConsistent.le_lGeneration,
				(short) plrattachdb->lgposConsistent.le_isec,
				(short) plrattachdb->lgposConsistent.le_ib );
			strcat( szLR, rgchBuf );
			SPrintSign( &plrattachdb->signDb, rgchBuf );
			strcat( szLR, rgchBuf );
			sprintf( rgchBuf, "   SigLog: " );
			strcat( szLR, rgchBuf );
			SPrintSign( &plrattachdb->signLog, rgchBuf );
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypDetachDB:
			{
			LRDETACHDB *plrdetachdb = (LRDETACHDB *) plr;
			CHAR *sz;

			sz = reinterpret_cast<CHAR *>( plrdetachdb ) + sizeof(LRDETACHDB);
			sprintf( rgchBuf, " (%x,%s,%u)", (PROCID)plrdetachdb->le_procid, sz, (USHORT) plrdetachdb->dbid );
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypForceDetachDB:
			{
			LRFORCEDETACHDB *plrfdetachdb = (LRFORCEDETACHDB *) plr;
			CHAR *sz;

			sz = reinterpret_cast<CHAR *>( plrfdetachdb ) + sizeof(LRFORCEDETACHDB);
			sprintf( rgchBuf, " (%x,%s,%u) %I64x, %lu", (PROCID)plrfdetachdb->le_procid, sz, (USHORT) plrfdetachdb->dbid, plrfdetachdb->le_dbtime, plrfdetachdb->le_rceidMax );
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypDbList:
			{
			LRDBLIST* const		plrdblist		= (LRDBLIST *)plr;

			if ( plog )
				{
				const ATTACHINFO*	pattachinfo		= NULL;
				const BYTE*			pbT				= plrdblist->rgb;
				
				DBGprintf( " %s Total Attachments: %d", SzLrtyp( lrtyp ), plrdblist->CAttachments() );
				while ( 0 != *pbT )
					{
					const ATTACHINFO* const		pattachinfo 	= (ATTACHINFO *)pbT;

					Assert( pbT - plrdblist->rgb < plrdblist->CbAttachInfo() );

					DBGprintf( "\n    %d %s",
						(DBID)pattachinfo->Dbid(),
						pattachinfo->szNames );		//	first name is DB name

					pbT += sizeof(ATTACHINFO) + pattachinfo->CbNames();
					}

				sprintf( szLR, "\n[End of DbList]" );
				}
			else
				{
				sprintf( rgchBuf, " Total Attachments: %d", plrdblist->CAttachments() );
				strcat( szLR, rgchBuf );
				}
			break;
			}

		case lrtypCreateMultipleExtentFDP:
			{
			LRCREATEMEFDP *plrcreatemefdp = (LRCREATEMEFDP *)plr;
			
			sprintf( rgchBuf, " %I64x,%lx:%u(%x,FDP:[%u:%lu],OE:[%u:%lu],AE:[%u:%lu],FDPParent:[%u:%lu],Objid:[%lu],PageFlags:[0x%lx],%lu,%s)",
				(DBTIME) plrcreatemefdp->le_dbtime,
				(TRX) plrcreatemefdp->le_trxBegin0,
				(USHORT) plrcreatemefdp->level,
				(PROCID) plrcreatemefdp->le_procid,
				(USHORT) plrcreatemefdp->dbid,
				(PGNO) plrcreatemefdp->le_pgno,
				(USHORT) plrcreatemefdp->dbid,
				(PGNO) plrcreatemefdp->le_pgnoOE,
				(USHORT) plrcreatemefdp->dbid,
				(PGNO) plrcreatemefdp->le_pgnoAE,
				(USHORT) plrcreatemefdp->dbid,
				(PGNO) plrcreatemefdp->le_pgnoFDPParent,
				(OBJID) plrcreatemefdp->le_objidFDP,
				(ULONG) plrcreatemefdp->le_fPageFlags,
				(ULONG) plrcreatemefdp->le_cpgPrimary,
				plrcreatemefdp->FUnique() ? szUnique : szNotUnique );
			strcat( szLR, rgchBuf );

			break;
			}

		case lrtypCreateSingleExtentFDP:
			{
			LRCREATESEFDP *plrcreatesefdp = (LRCREATESEFDP *)plr;
			
			sprintf( rgchBuf, " %I64x,%lx:%u(%x,[%u:%lu],[%u:%lu],[%lu],PageFlags:[0x%lx]%lu,%s)",
				(DBTIME) plrcreatesefdp->le_dbtime,
				(TRX) plrcreatesefdp->le_trxBegin0,
				(USHORT) plrcreatesefdp->level,
				(PROCID) plrcreatesefdp->le_procid,
				(USHORT) plrcreatesefdp->dbid,
				(PGNO) plrcreatesefdp->le_pgno,
				(USHORT) plrcreatesefdp->dbid,
				(PGNO) plrcreatesefdp->le_pgnoFDPParent,
				(OBJID) plrcreatesefdp->le_objidFDP,
				(ULONG) plrcreatesefdp->le_fPageFlags,
				(ULONG) plrcreatesefdp->le_cpgPrimary,
				plrcreatesefdp->FUnique() ? szUnique : szNotUnique );
			strcat( szLR, rgchBuf );

			break;
			}

		case lrtypConvertFDP:
			{
			LRCONVERTFDP *plrconvertfdp = (LRCONVERTFDP *)plr;
			
			sprintf( rgchBuf, " %I64x,%I64x,%lx:%u(%x,[%u:%lu],[%u:%lu],[%lu],%lu)",
				(DBTIME) plrconvertfdp->le_dbtime,
				(DBTIME) plrconvertfdp->le_dbtimeBefore,
				(TRX) plrconvertfdp->le_trxBegin0,
				(USHORT) plrconvertfdp->level,
				(PROCID) plrconvertfdp->le_procid,
				(USHORT) plrconvertfdp->dbid,
				(PGNO) plrconvertfdp->le_pgno,
				(USHORT) plrconvertfdp->dbid,
				(PGNO) plrconvertfdp->le_pgnoFDPParent,
				(OBJID) plrconvertfdp->le_objidFDP,
				(ULONG) plrconvertfdp->le_cpgPrimary);
			strcat( szLR, rgchBuf );

			break;
			}

		case lrtypSplit:
			{
			LRSPLIT *plrsplit = (LRSPLIT *)plr;

			if ( pgnoNull == plrsplit->le_pgnoNew )
				{
				Assert( 0 == plrsplit->le_cbKeyParent );
				Assert( 0 == plrsplit->le_cbPrefixSplitOld );
				Assert( 0 == plrsplit->le_cbPrefixSplitNew );
				sprintf( rgchBuf, "%s %I64x,%I64x,%lx:%u(%x,parent:%I64x,[%u:%lu])",
						" ParentOfSplitPage",
						(DBTIME) plrsplit->le_dbtime,
						(DBTIME) plrsplit->le_dbtimeBefore,
						(TRX) plrsplit->le_trxBegin0,
						(USHORT) plrsplit->level,
						(PROCID) plrsplit->le_procid,
						(DBTIME) plrsplit->le_dbtimeParentBefore,
						(USHORT) plrsplit->dbid,
						(PGNO) plrsplit->le_pgno );
				strcat( szLR, rgchBuf );
				}
			else
				{
				switch( plrsplit->splittype )
					{
					case splittypeRight:
						if ( splitoperInsert == plrsplit->splitoper
							&& plrsplit->le_ilineSplit == plrsplit->le_ilineOper
							&& plrsplit->le_ilineSplit == plrsplit->le_clines - 1 )
							{
							sprintf( rgchBuf, " SplitHotpoint" );
							}
						else
							{
							sprintf( rgchBuf, " SplitRight" );
							}
						break;
					case splittypeVertical:
						sprintf( rgchBuf, " SplitVertical" );
						break;
					case splittypeAppend:
						sprintf( rgchBuf, " Append" );
						break;
					default:
						Assert( fFalse );
					}
				strcat( szLR, rgchBuf );

				const CHAR *	szSplitoper[4]	= {	"None",
										   			"Insert",
													"Replace",
													"FlagInsertAndReplaceData" };

				// Verify valid splitoper
				switch( plrsplit->splitoper )
					{
					case splitoperNone:
					case splitoperInsert:
					case splitoperReplace:
					case splitoperFlagInsertAndReplaceData:
						break;
					default:
						Assert( fFalse );
					}

				sprintf( rgchBuf, " %I64x,%I64x,%lx:%u(%x,split:[%u:%lu:%u],oper/last:[%u/%u],new:[%u:%lu],parent:%I64x,[%u:%lu],right:%I64x,[%u:%lu], objid:[%lu], %s, splitoper:%s)",
						(DBTIME) plrsplit->le_dbtime,
						(DBTIME) plrsplit->le_dbtimeBefore,
						(TRX) plrsplit->le_trxBegin0,
						(USHORT) plrsplit->level,
						(PROCID) plrsplit->le_procid,
						(USHORT) plrsplit->dbid,
						(PGNO) plrsplit->le_pgno,
						(USHORT) plrsplit->le_ilineSplit,
						(USHORT) plrsplit->le_ilineOper,
						(USHORT) plrsplit->le_clines-1,		// convert to iline
						(USHORT) plrsplit->dbid,
						(PGNO) plrsplit->le_pgnoNew,
						(DBTIME) (pgnoNull != (PGNO) plrsplit->le_pgnoParent ? (DBTIME) plrsplit->le_dbtimeParentBefore: 0),
						(USHORT) plrsplit->dbid,
						(PGNO) plrsplit->le_pgnoParent,
						(DBTIME) (pgnoNull != (PGNO) plrsplit->le_pgnoRight ? (DBTIME) plrsplit->le_dbtimeRightBefore: 0),
						(USHORT) plrsplit->dbid,
						(PGNO) plrsplit->le_pgnoRight,
						(OBJID) plrsplit->le_objidFDP,
						plrsplit->FConcCI() ? szConcCI : szNotConcCI,
						szSplitoper[plrsplit->splitoper] );
				strcat( szLR, rgchBuf );
				}

			break;
			}


		case lrtypMerge:
			{
			LRMERGE *plrmerge = (LRMERGE *)plr;
			BYTE 	*pb = &(plrmerge->rgb[0]);
			INT		cb = plrmerge->le_cbKeyParentSep;
			const INT mergetype = plrmerge->mergetype;

			sprintf( rgchBuf," %I64x,%I64x,%lx:%u(%x,merge:[%u:%lu:%u],right:%I64x,[%u:%lu],left:%I64x,[%u:%lu],parent:%I64x,[%u:%lu],%s:%s:%s:%s,size:%d,maxsize:%d,uncfree:%d)",
				(DBTIME) plrmerge->le_dbtime,
				(DBTIME) plrmerge->le_dbtimeBefore,
				(TRX) plrmerge->le_trxBegin0,
				(USHORT) plrmerge->level,
				(PROCID) plrmerge->le_procid,
				(USHORT) plrmerge->dbid,
				(PGNO) plrmerge->le_pgno,
				plrmerge->ILineMerge(),
				(DBTIME)  (pgnoNull != (PGNO) plrmerge->le_pgnoRight ? (DBTIME) plrmerge->le_dbtimeRightBefore: 0),
				(USHORT) plrmerge->dbid,
				(PGNO) plrmerge->le_pgnoRight,
				(DBTIME)  (pgnoNull != (PGNO) plrmerge->le_pgnoLeft ? (DBTIME) plrmerge->le_dbtimeLeftBefore: 0),
				(USHORT) plrmerge->dbid,
				(PGNO) plrmerge->le_pgnoLeft,
				(DBTIME)  (pgnoNull != (PGNO) plrmerge->le_pgnoParent ? (DBTIME) plrmerge->le_dbtimeParentBefore: 0),
				(USHORT) plrmerge->dbid,
				(PGNO) plrmerge->le_pgnoParent,
				plrmerge->FKeyChange() ? szKeyChange : szNoKeyChange,
				plrmerge->FEmptyPage() ? szEmptyPage : szNotEmptyPage,
				plrmerge->FDeleteNode() ? szDeleted : szNotDeleted,
				rgszMergeType[mergetype],
				(SHORT) plrmerge->le_cbSizeTotal,
				(SHORT) plrmerge->le_cbSizeMaxTotal,
				(SHORT) plrmerge->le_cbUncFreeDest );
			strcat( szLR, rgchBuf );

			DataToSz( pb, cb, rgchBuf );
			strcat( szLR, rgchBuf );

			break;
			}

		case lrtypEmptyTree:
			{
			LREMPTYTREE	*plremptytree	= (LREMPTYTREE *)plr;
			
			sprintf( rgchBuf, " %I64x,%I64x,%lx:%u(%x,[%u:%lu],objid:[%lu],%s,%s,%lu)",
				(DBTIME) plremptytree->le_dbtime,
				(DBTIME) plremptytree->le_dbtimeBefore,
				(TRX) plremptytree->le_trxBegin0,
				(USHORT) plremptytree->level,
				(PROCID) plremptytree->le_procid,
				(USHORT) plremptytree->dbid,
				(PGNO) plremptytree->le_pgno,
				plremptytree->le_objidFDP,
				plremptytree->FUnique() ? szUnique : szNotUnique,
				plremptytree->FSpace() ? szSpaceTree : szNotSpaceTree,
				plremptytree->CbEmptyPageList() );
			strcat( szLR, rgchBuf );

			DataToSz( plremptytree->rgb, plremptytree->CbEmptyPageList(), rgchBuf );
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypSetExternalHeader:
			{
			const LRSETEXTERNALHEADER * const 	plrsetexternalheader = (LRSETEXTERNALHEADER *)plr;
			const BYTE * const 					pb 	= plrsetexternalheader->rgbData;
			const INT 							cb	= plrsetexternalheader->CbData();
			sprintf( rgchBuf, " %I64x,%I64x,%lx:%u(%x,[%u:%lu],%5u)",
						(DBTIME) plrsetexternalheader->le_dbtime,
						(DBTIME) plrsetexternalheader->le_dbtimeBefore,
						(TRX) plrsetexternalheader->le_trxBegin0,
						(USHORT) plrsetexternalheader->level,
						(PROCID) plrsetexternalheader->le_procid,
						(USHORT) plrsetexternalheader->dbid,
						(PGNO) plrsetexternalheader->le_pgno,
						plrsetexternalheader->CbData() );
			strcat( szLR, rgchBuf );

			DataToSz( pb, cb, rgchBuf );
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypUndo:
			{
			LRUNDO *plrundo = (LRUNDO *)plr;
			sprintf( rgchBuf, " %I64x,%I64x,%lx:%u(%x,[%u:%lu:%u],%s,%u,%u,rceid:%u)",
				(DBTIME) plrundo->le_dbtime,
				(DBTIME) plrundo->le_dbtimeBefore,
				(TRX) plrundo->le_trxBegin0,
				(USHORT) plrundo->level,
				(PROCID) plrundo->le_procid,
				(USHORT) plrundo->dbid,
				(PGNO) plrundo->le_pgno,
				plrundo->ILine(),
				plrundo->FUnique() ? szVersion : szNoVersion,
				(USHORT) plrundo->level,
				(USHORT) plrundo->le_oper,
				(RCEID) plrundo->le_rceid );
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypInit:
		case lrtypInit2:
			{
			if ( lrtypInit2 == plr->lrtyp )
				{
				const LOGTIME &logtime = ((LRINIT2 *)plr)->logtime;
				sprintf( rgchBuf, " (%u/%u/%u %u:%02u:%02u)", 
					(INT) (logtime.bMonth),
					(INT) (logtime.bDay),
					(INT) (logtime.bYear+1900),
					(INT) (logtime.bHours),
					(INT) (logtime.bMinutes),
					(INT) (logtime.bSeconds) );
				strcat( szLR, rgchBuf );
				}
			DBMS_PARAM *pdbms_param = &((LRINIT2 *)plr)->dbms_param;
			sprintf( rgchBuf, "\n      Env SystemPath:%s\n",	pdbms_param->szSystemPath);
			strcat( szLR, rgchBuf );
			sprintf( rgchBuf, "      Env LogFilePath:%s\n", pdbms_param->szLogFilePath);
			strcat( szLR, rgchBuf );
			sprintf( rgchBuf, "      Env (CircLog,Session,Opentbl,VerPage,Cursors,LogBufs,LogFile,Buffers)\n");
			strcat( szLR, rgchBuf );
			sprintf( rgchBuf, "          (%s,%7lu,%7lu,%7lu,%7lu,%7lu,%7lu,%7lu)\n",
				( pdbms_param->fDBMSPARAMFlags & fDBMSPARAMCircularLogging ? "     on" : "    off" ),
				(ULONG) pdbms_param->le_lSessionsMax,
				(ULONG) pdbms_param->le_lOpenTablesMax,
				(ULONG) pdbms_param->le_lVerPagesMax,
				(ULONG) pdbms_param->le_lCursorsMax,
				(ULONG) pdbms_param->le_lLogBuffers,
				(ULONG) pdbms_param->le_lcsecLGFile,
				(ULONG) pdbms_param->le_ulCacheSizeMax );
			strcat( szLR, rgchBuf );
			}
			break;
			
		case lrtypTerm:
		case lrtypShutDownMark:
		case lrtypRecoveryUndo:
			break;
			
		case lrtypTerm2:
			{
			const LOGTIME &logtime = ((LRTERMREC2 *)plr)->logtime;
			sprintf( rgchBuf, " (%u/%u/%u %u:%02u:%02u)", 
				(INT) (logtime.bMonth),
				(INT) (logtime.bDay),
				(INT) (logtime.bYear+1900),
				(INT) (logtime.bHours),
				(INT) (logtime.bMinutes),
				(INT) (logtime.bSeconds) );
			strcat( szLR, rgchBuf );
			}
			break;
			
		case lrtypRecoveryUndo2:
			{
			const LOGTIME &logtime = ((LRRECOVERYUNDO2 *)plr)->logtime;
			sprintf( rgchBuf, " (%u/%u/%u %u:%02u:%02u)", 
				(INT) (logtime.bMonth),
				(INT) (logtime.bDay),
				(INT) (logtime.bYear+1900),
				(INT) (logtime.bHours),
				(INT) (logtime.bMinutes),
				(INT) (logtime.bSeconds) );
			strcat( szLR, rgchBuf );
			}
			break;
			
		case lrtypRecoveryQuit:
		case lrtypRecoveryQuit2:
			{
			LRTERMREC2 *plrquit = (LRTERMREC2 *) plr;

			if ( lrtypRecoveryQuit2 == plr->lrtyp )
				{
				const LOGTIME &logtime = plrquit->logtime;
				sprintf( rgchBuf, " (%u/%u/%u %u:%02u:%02u)", 
					(INT) (logtime.bMonth),
					(INT) (logtime.bDay),
					(INT) (logtime.bYear+1900),
					(INT) (logtime.bHours),
					(INT) (logtime.bMinutes),
					(INT) (logtime.bSeconds) );
				strcat( szLR, rgchBuf );
				}
			if ( plrquit->fHard )
				{
				sprintf( rgchBuf, "\n      Quit on Hard Restore." );
				strcat( szLR, rgchBuf );
				}
			else
				{
				sprintf( rgchBuf, "\n      Quit on Soft Restore." );
				strcat( szLR, rgchBuf );
				}
			
			sprintf( rgchBuf, "\n      RedoFrom:(%X,%X,%X)\n",
				(short) plrquit->lgposRedoFrom.le_lGeneration,
				(short) plrquit->lgposRedoFrom.le_isec,
				(short) plrquit->lgposRedoFrom.le_ib );
			strcat( szLR, rgchBuf );
					
			sprintf( rgchBuf, "      UndoRecordFrom:(%X,%X,%X)\n",
  				(short) plrquit->lgpos.le_lGeneration,
				(short) plrquit->lgpos.le_isec,
				(short) plrquit->lgpos.le_ib );
			strcat( szLR, rgchBuf );
			}
			break;
			
		case lrtypFullBackup:
		case lrtypIncBackup:
			{
			LRLOGRESTORE *plrlr = (LRLOGRESTORE *) plr;

		   	if ( plrlr->le_cbPath )
				{
				sprintf( rgchBuf, "%*s", plrlr->le_cbPath, plrlr->szData );
				strcat( szLR, rgchBuf );
				}
			break;
			}
			
		case lrtypBackup:
			{
			LRLOGBACKUP *plrlb = (LRLOGBACKUP *) plr;
			
			if ( plrlb->FFull() )
				{
				strcat( szLR, "FullBackup" );
				}
			else if ( plrlb->FIncremental() )
				{
				strcat( szLR, "IncrementalBackup" );
				}
			else if ( plrlb->FSnapshotStart() )
				{
				strcat( szLR, "StartSnapshot" );
				}
			else if ( plrlb->FSnapshotStop() )
				{
				strcat( szLR, "StopSnapshot" );
				}
			else
				{
				Assert ( fFalse );
				}
			
		   	if ( plrlb->le_cbPath )
				{
				sprintf( rgchBuf, " %*s", plrlb->le_cbPath, plrlb->szData );
				strcat( szLR, rgchBuf );
				}
			break;
			}

		case lrtypTrace:
			{
			LRTRACE *plrtrace = (LRTRACE *)plr;
	   		sprintf( rgchBuf, " (%x) %s", (PROCID)plrtrace->le_procid, plrtrace->sz );
			strcat( szLR, rgchBuf );
			break;
			}

#ifdef DISABLE_SLV
#else
		case lrtypSLVPageAppend:
			{
			LRSLVPAGEAPPEND*	plrSLVPageAppend = (LRSLVPAGEAPPEND *)plr;
			BYTE* 				pb;
			ULONG				cb;

			pb = (BYTE*) plr + sizeof( LRSLVPAGEAPPEND );
			cb = plrSLVPageAppend->le_cbData;

			sprintf( rgchBuf, " (%x,dbid:%u,ibLogical:0x%I64x,page:%lu,size:%lu,%s)",
					(PROCID) plrSLVPageAppend->le_procid,
					(USHORT) plrSLVPageAppend->dbid,
					(QWORD) plrSLVPageAppend->le_ibLogical,
					PGNO( ( plrSLVPageAppend->le_ibLogical / g_cbPage ) - cpgDBReserved + 1 ),
					(ULONG) plrSLVPageAppend->le_cbData,
					plrSLVPageAppend->FDataLogged() ? szData : szNoData );

			strcat( szLR, rgchBuf );

			if ( plrSLVPageAppend->FDataLogged() )
				{
				DataToSz( pb, cb, rgchBuf );
				strcat( szLR, rgchBuf );
				}
			break;
			}

		case lrtypSLVPageMove:
			{
			LRSLVPAGEMOVE*	plrSLVPageMove = (LRSLVPAGEMOVE *)plr;

			sprintf( rgchBuf, " (%x,dbid:%u,ibLogicalSrc:%I64u,ibLogicalDest:%I64u,size:%lu,checksum:0x%X) ",
					(PROCID) plrSLVPageMove->le_procid,
					(USHORT) plrSLVPageMove->dbid,
					(QWORD) plrSLVPageMove->le_ibLogicalSrc,
					(QWORD) plrSLVPageMove->le_ibLogicalDest,
					(ULONG) plrSLVPageMove->le_cbData,
					(ULONG) plrSLVPageMove->le_checksumSrc );
					
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypSLVSpace:
			{
			const CHAR			* szOper			= "UNKNOWN";
			const LRSLVSPACE	* const plrSLVSpace = (LRSLVSPACE *)plr;
			const BYTE			* const pb			= (BYTE *)plr + sizeof(LRSLVSPACE);
			const ULONG			cb					= plrSLVSpace->le_cbBookmarkKey;

			PGNO				pgnoLast;
			LongFromKey( &pgnoLast, plrSLVSpace->rgbData );
			Assert( 0 == ( pgnoLast % SLVSPACENODE::cpageMap ) );
			const PGNO			pgnoFirst			= pgnoLast - SLVSPACENODE::cpageMap + 1;

			switch( plrSLVSpace->oper )
				{
				case slvspaceoperInvalid:
					szOper = "Invalid";
					break;
				case slvspaceoperFreeToReserved:
					szOper = "FreeToReserved";
					break;
				case slvspaceoperReservedToCommitted:
					szOper = "ReservedToCommitted";
					break;
				case slvspaceoperFreeToCommitted:
					szOper = "FreeToCommitted";
					break;
				case slvspaceoperCommittedToDeleted:
					szOper = "CommittedToDeleted";
					break;
				case slvspaceoperDeletedToFree:
					szOper = "DeletedToFree";
					break;
				case slvspaceoperFree:	
					szOper = "Free";
					break;
				case slvspaceoperFreeReserved:
					szOper = "FreeReserved";
					break;
				case slvspaceoperDeletedToCommitted:
					szOper = "DeletedToCommitted";
					break;
 				default:
					szOper = "UNKNOWN";
					break;
				}
				
			sprintf( rgchBuf, " %I64x,%I64x,%lx:%u(%x,[%u:%lu:%u],%s:%s,%s(%d),%d-%d,rceid:%lu,objid:%lu)",
				(DBTIME) plrSLVSpace->le_dbtime,
				(DBTIME) plrSLVSpace->le_dbtimeBefore,
				(TRX) plrSLVSpace->le_trxBegin0,
				(USHORT) plrSLVSpace->level,
				(PROCID) plrSLVSpace->le_procid,
				(USHORT) plrSLVSpace->dbid,
				(PGNO) plrSLVSpace->le_pgno,
				plrSLVSpace->ILine(),
				plrSLVSpace->FVersioned() ? szVersion : szNoVersion,
				plrSLVSpace->FConcCI() ? szConcCI : szNotConcCI,
				szOper,
				plrSLVSpace->oper,
				pgnoFirst + plrSLVSpace->le_ipage,
				pgnoFirst + plrSLVSpace->le_ipage + plrSLVSpace->le_cpages - 1,
				plrSLVSpace->le_rceid,
				plrSLVSpace->le_objidFDP );
					
			strcat( szLR, rgchBuf );
			DataToSz( pb, cb, rgchBuf );
			strcat( szLR, rgchBuf );
			break;
			}
#endif	//	DISABLE_SLV

		case lrtypChecksum:
			{
			const LRCHECKSUM * const plrck = static_cast< const LRCHECKSUM* const >( plr );

			Assert( plrck->bUseShortChecksum == bShortChecksumOn ||
					plrck->bUseShortChecksum == bShortChecksumOff );

			if ( plrck->bUseShortChecksum == bShortChecksumOn )
				{
				sprintf( rgchBuf, " (0x%X,0x%X,0x%X checksum [0x%X,0x%X])",
					plrck->le_cbBackwards,
					plrck->le_cbForwards,
					plrck->le_cbNext,
					plrck->le_ulChecksum,
					plrck->le_ulShortChecksum );
				}
			else if ( plrck->bUseShortChecksum == bShortChecksumOff )
				{
				sprintf( rgchBuf, " (0x%X,0x%X,0x%X checksum [0x%X])",
					plrck->le_cbBackwards,
					plrck->le_cbForwards,
					plrck->le_cbNext,
					plrck->le_ulChecksum );
				}
			else
				{
				sprintf( rgchBuf, " CORRUPT (0x%X,0x%X,0x%X checksum 0x%X short checksum 0x%X use short checksum 0x%X)",
					plrck->le_cbBackwards,
					plrck->le_cbForwards,
					plrck->le_cbNext,
					plrck->le_ulChecksum,
					plrck->le_ulShortChecksum,
					plrck->bUseShortChecksum );
				}
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypExtRestore:
			{
			LREXTRESTORE *plrextrestore = (LREXTRESTORE *) plr;
			CHAR *sz;

			sz = reinterpret_cast<CHAR *>( plrextrestore ) + sizeof(LREXTRESTORE);
			sprintf( rgchBuf, " (%s,%s)", sz, sz + strlen(sz) + 1 );
			strcat( szLR, rgchBuf );
			break;
			}

		default:
			{
			Assert( fFalse );
			break;
			}
		}
	}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\jetapi.cxx ===
#include "std.hxx"

char g_szEventSource[JET_cbFullNameMost] = "";
char g_szEventSourceKey[JET_cbFullNameMost] = "";
BOOL g_fNoInformationEvent = fFalse;

ULONG	IFileSystemAPI::cmsecAccessDeniedRetryPeriod	= 10000;	//	default number of milliseconds to retry on AccessDenied

UINT	g_wAssertAction	= JET_AssertMsgBox;	// Default action is to pop up msg box.

BOOL g_fGlobalMinSetByUser = fFalse; // For use by JET_paramMaxVerPages and JET_paramGlobalMinVerPages
BOOL g_fGlobalPreferredSetByUser = fFalse; // For use by JET_paramMaxVerPages and JET_paramGlobalPreferVerPages


#ifdef MINIMAL_FUNCTIONALITY
void JetErrorToString( JET_ERR err, const char **szError, const char **szErrorText )
	{
	*szError = 0;
	*szErrorText = 0;
	}
#else
//  automatically generated
extern void JetErrorToString( JET_ERR err, const char **szError, const char **szErrorText );
#endif


#ifdef CATCH_EXCEPTIONS
BOOL	g_fCatchExceptions	= fTrue;
#endif	//	CATCH_EXCEPTIONS


#ifdef RTM
#else
ERR 	g_errTrap			= JET_errSuccess;	// Default is no error trap.
LGPOS	g_lgposRedoTrap		= lgposMax;			// Default to no redo trap.

#define SYSTEM_PIB_RFS

#endif


#ifdef SYSTEM_PIB_RFS
INT g_cSystemPibAlloc 		= 0;
INT g_cSystemPibAllocFail 	= 0;
#endif


BOOL fGlobalEseutil			= fFalse;


/*** utilities ***/

#ifdef DEBUG
extern ERR ISAMAPI ErrIsamGetTransaction( JET_SESID vsesid, ULONG_PTR *plevel );
#endif

/*	make global variable so that it can be inspected from debugger
/**/
unsigned long	g_ulVersion = ((unsigned long) DwUtilImageVersionMajor() << 24) + ((unsigned long) DwUtilImageBuildNumberMajor() << 8) + DwUtilImageBuildNumberMinor();

#ifdef RFS2
	extern DWORD g_cRFSAlloc;
	extern DWORD g_cRFSIO;
	extern DWORD g_fDisableRFS;
#endif


/*	Jet VTFN dispatch supports.
 */
#pragma warning(disable: 4100)			 /* Suppress Unreferenced parameter */


ERR VTAPI ErrIllegalAddColumn(JET_SESID sesid, JET_VTID vtid,
	const char  *szColumn, const JET_COLUMNDEF  *pcolumndef,
	const void  *pvDefault, unsigned long cbDefault,
	JET_COLUMNID  *pcolumnid)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalCloseTable(JET_SESID vsesid, JET_VTID vtid)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalComputeStats(JET_SESID vsesid, JET_VTID vtid)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}

ERR VTAPI ErrIllegalCopyBookmarks(JET_SESID sesid, JET_VTID vtidSrc,
	JET_TABLEID tableidDest, JET_COLUMNID columnidDest, unsigned long crecMax)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}

ERR VTAPI ErrIllegalCreateIndex(JET_SESID, JET_VTID, JET_INDEXCREATE *, unsigned long )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalDelete(JET_SESID vsesid, JET_VTID vtid)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalDeleteColumn(
	JET_SESID		vsesid,
	JET_VTID		vtid,
	const char		*szColumn,
	const JET_GRBIT	grbit )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalDeleteIndex(JET_SESID vsesid, JET_VTID vtid,
	const char  *szIndexName)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalDupCursor(JET_SESID vsesid, JET_VTID vtid,
	JET_TABLEID  *ptableid, JET_GRBIT grbit)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalEscrowUpdate( JET_SESID vsesid,
	JET_VTID vtid,
	JET_COLUMNID columnid,
	void *pv,
	unsigned long cbMax,
	void *pvOld,
	unsigned long cbOldMax,
	unsigned long *pcbOldActual,
	JET_GRBIT grbit )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalGetBookmark(
	JET_SESID		vsesid,
	JET_VTID		vtid,
	VOID * const	pvBookmark,
	const ULONG		cbMax,
	ULONG * const	pcbActual )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}

ERR VTAPI ErrIllegalGetIndexBookmark(
	JET_SESID		vsesid,
	JET_VTID		vtid,
	VOID * const	pvSecondaryKey,
	const ULONG		cbSecondaryKeyMax,
	ULONG * const	pcbSecondaryKeyActual,
	VOID * const	pvPrimaryBookmark,
	const ULONG		cbPrimaryBookmarkMax,
	ULONG *	const	pcbPrimaryBookmarkActual )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalGetChecksum(JET_SESID vsesid, JET_VTID vtid,
	unsigned long  *pChecksum)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalGetCurrentIndex(JET_SESID vsesid, JET_VTID vtid,
	char  *szIndexName, unsigned long cchIndexName)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalGetCursorInfo(JET_SESID vsesid, JET_VTID vtid,
	void  *pvResult, unsigned long cbMax, unsigned long InfoLevel)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalGetRecordPosition(JET_SESID vsesid, JET_VTID vtid,
	JET_RECPOS  *pkeypos, unsigned long cbKeypos)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalGetTableColumnInfo(JET_SESID vsesid, JET_VTID vtid,
	const char  *szColumnName, const JET_COLUMNID *pcolid, void  *pvResult,
	unsigned long cbMax, unsigned long InfoLevel)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalGetTableIndexInfo(JET_SESID vsesid, JET_VTID vtid,
	const char  *szIndexName, void  *pvResult,
	unsigned long cbMax, unsigned long InfoLevel)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalGetTableInfo(JET_SESID vsesid, JET_VTID vtid,
	void  *pvResult, unsigned long cbMax, unsigned long InfoLevel)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalGotoBookmark(
	JET_SESID			vsesid,
	JET_VTID			vtid,
	const VOID * const	pvBookmark,
	const ULONG			cbBookmark )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}

ERR VTAPI ErrIllegalGotoIndexBookmark(
	JET_SESID			vsesid,
	JET_VTID			vtid,
	const VOID * const	pvSecondaryKey,
	const ULONG			cbSecondaryKey,
	const VOID * const	pvPrimaryBookmark,
	const ULONG			cbPrimaryBookmark,
	const JET_GRBIT		grbit )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalGotoPosition(JET_SESID vsesid, JET_VTID vtid,
	JET_RECPOS *precpos)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalVtIdle(JET_SESID vsesid, JET_VTID vtid)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalMakeKey(
	JET_SESID		vsesid,
	JET_VTID		vtid,
	const VOID*		pvData,
	const ULONG		cbData,
	JET_GRBIT		grbit )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalGetLock(JET_SESID vsesid, JET_VTID vtid, JET_GRBIT grbit)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalMove(JET_SESID vsesid, JET_VTID vtid,
	long cRow, JET_GRBIT grbit)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalNotifyBeginTrans(JET_SESID vsesid, JET_VTID vtid)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalNotifyCommitTrans(JET_SESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalNotifyRollback(JET_SESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalNotifyUpdateUfn(JET_SESID vsesid, JET_VTID vtid)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalPrepareUpdate(JET_SESID vsesid, JET_VTID vtid,
	unsigned long prep)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalRenameColumn(JET_SESID vsesid, JET_VTID vtid,
	const char  *szColumn, const char  *szColumnNew, const JET_GRBIT grbit)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalRenameIndex(JET_SESID vsesid, JET_VTID vtid,
	const char  *szIndex, const char  *szIndexNew)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalRetrieveColumn(
	JET_SESID		vsesid,
	JET_VTID		vtid,
	JET_COLUMNID	columnid,
	VOID*			pvData,
	const ULONG		cbData,
	ULONG*			pcbActual,
	JET_GRBIT		grbit,
	JET_RETINFO*	pretinfo )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}

ERR VTAPI ErrIllegalRetrieveColumns(JET_SESID vsesid, JET_VTID vtid,
	JET_RETRIEVECOLUMN	*pretcols, unsigned long cretcols )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}

ERR VTAPI ErrIllegalEnumerateColumns(
	JET_SESID				vsesid,
	JET_VTID				vtid,
	unsigned long			cEnumColumnId,
	JET_ENUMCOLUMNID*		rgEnumColumnId,
	unsigned long*			pcEnumColumn,
	JET_ENUMCOLUMN**		prgEnumColumn,
	JET_PFNREALLOC			pfnRealloc,
	void*					pvReallocContext,
	unsigned long			cbDataMost,
	JET_GRBIT				grbit )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalRetrieveKey(
	JET_SESID		vsesid,
	JET_VTID		vtid,
	VOID*			pvKey,
	const ULONG		cbMax,
	ULONG*			pcbActual,
	JET_GRBIT		grbit )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalSeek(JET_SESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalSetColumn(
	JET_SESID		vsesid,
	JET_VTID		vtid,
	JET_COLUMNID	columnid,
	const VOID*		pvData,
	const ULONG		cbData,
	JET_GRBIT		grbit,
	JET_SETINFO*	psetinfo )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}

ERR VTAPI ErrIllegalSetColumns(JET_SESID vsesid, JET_VTID vtid,
	JET_SETCOLUMN	*psetcols, unsigned long csetcols )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}

ERR VTAPI ErrIllegalSetIndexRange(JET_SESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalUpdate(JET_SESID vsesid, JET_VTID vtid,
	void  *pvBookmark, unsigned long cbBookmark,
	unsigned long  *pcbActual, JET_GRBIT grbit )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}

ERR VTAPI ErrIllegalRegisterCallback(
	JET_SESID 		vsesid,
	JET_VTID		vtid,
	JET_CBTYP		cbtyp,
	JET_CALLBACK	pCallback,
	VOID *			pvContext,
	JET_HANDLE		*phCallbackId )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}

ERR VTAPI ErrIllegalUnregisterCallback(
	JET_SESID 		vsesid,
	JET_VTID		vtid,
	JET_CBTYP		cbtyp,
	JET_HANDLE		hCallbackId )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}

ERR VTAPI ErrIllegalSetLS(
	JET_SESID 		vsesid,
	JET_VTID		vtid,
	JET_LS			ls,
	JET_GRBIT		grbit )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}

ERR VTAPI ErrIllegalGetLS(
	JET_SESID 		vsesid,
	JET_VTID		vtid,
	JET_LS			*pls,
	JET_GRBIT		grbit )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}

ERR VTAPI ErrIllegalIndexRecordCount(
	JET_SESID sesid, JET_VTID vtid,	unsigned long *pcrec,
	unsigned long crecMax )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}

ERR VTAPI ErrIllegalRetrieveTaggedColumnList(
	JET_SESID			vsesid,
	JET_VTID			vtid,
	ULONG				*pcentries,
	VOID				*pv,
	const ULONG			cbMax,
	const JET_COLUMNID	columnidStart,
	const JET_GRBIT		grbit )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}

ERR VTAPI ErrIllegalSetSequential(
	const JET_SESID,
	const JET_VTID,
	const JET_GRBIT )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}

ERR VTAPI ErrIllegalResetSequential(
	const JET_SESID,
	const JET_VTID,
	const JET_GRBIT )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}

ERR VTAPI ErrIllegalSetCurrentIndex(
	JET_SESID			sesid,
	JET_VTID			tableid,
	const CHAR			*szIndexName,
	const JET_INDEXID	*pindexid,
	const JET_GRBIT		grbit,
	const ULONG			itagSequence )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}



ERR VTAPI ErrInvalidAddColumn(JET_SESID sesid, JET_VTID vtid,
	const char  *szColumn, const JET_COLUMNDEF  *pcolumndef,
	const void  *pvDefault, unsigned long cbDefault,
	JET_COLUMNID  *pcolumnid)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidCloseTable(JET_SESID vsesid, JET_VTID vtid)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidComputeStats(JET_SESID vsesid, JET_VTID vtid)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidCopyBookmarks(JET_SESID sesid, JET_VTID vtidSrc,
	JET_TABLEID tableidDest, JET_COLUMNID columnidDest, unsigned long crecMax)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidCreateIndex(JET_SESID vsesid, JET_VTID vtid, JET_INDEXCREATE *, unsigned long)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidDelete(JET_SESID vsesid, JET_VTID vtid)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidDeleteColumn(
	JET_SESID		vsesid,
	JET_VTID		vtid,
	const char		*szColumn,
	const JET_GRBIT	grbit )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidDeleteIndex(JET_SESID vsesid, JET_VTID vtid,
	const char  *szIndexName)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidDupCursor(JET_SESID vsesid, JET_VTID vtid,
	JET_TABLEID  *ptableid, JET_GRBIT grbit)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidEscrowUpdate(
	JET_SESID vsesid,
	JET_VTID vtid,
	JET_COLUMNID columnid,
	void *pv,
	unsigned long cbMax,
	void *pvOld,
	unsigned long cbOldMax,
	unsigned long *pcbOldActual,
	JET_GRBIT grbit )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidGetBookmark(
	JET_SESID		vsesid,
	JET_VTID		vtid,
	VOID * const	pvBookmark,
	const ULONG		cbMax,
	ULONG * const	pcbActual )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidGetIndexBookmark(
	JET_SESID		vsesid,
	JET_VTID		vtid,
	VOID * const	pvSecondaryKey,
	const ULONG		cbSecondaryKeyMax,
	ULONG * const	pcbSecondaryKeyActual,
	VOID * const	pvPrimaryBookmark,
	const ULONG		cbPrimaryBookmarkMax,
	ULONG *	const	pcbPrimaryBookmarkActual )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidGetChecksum(JET_SESID vsesid, JET_VTID vtid,
	unsigned long  *pChecksum)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidGetCurrentIndex(JET_SESID vsesid, JET_VTID vtid,
	char  *szIndexName, unsigned long cchIndexName)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidGetCursorInfo(JET_SESID vsesid, JET_VTID vtid,
	void  *pvResult, unsigned long cbMax, unsigned long InfoLevel)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidGetRecordPosition(JET_SESID vsesid, JET_VTID vtid,
	JET_RECPOS  *pkeypos, unsigned long cbKeypos)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidGetTableColumnInfo(JET_SESID vsesid, JET_VTID vtid,
	const char  *szColumnName, const JET_COLUMNID *pcolid, void  *pvResult,
	unsigned long cbMax, unsigned long InfoLevel)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidGetTableIndexInfo(JET_SESID vsesid, JET_VTID vtid,
	const char  *szIndexName, void  *pvResult,
	unsigned long cbMax, unsigned long InfoLevel)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidGetTableInfo(JET_SESID vsesid, JET_VTID vtid,
	void  *pvResult, unsigned long cbMax, unsigned long InfoLevel)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidGotoBookmark(
	JET_SESID			vsesid,
	JET_VTID			vtid,
	const VOID * const	pvBookmark,
	const ULONG			cbBookmark )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidGotoIndexBookmark(
	JET_SESID			vsesid,
	JET_VTID			vtid,
	const VOID * const	pvSecondaryKey,
	const ULONG			cbSecondaryKey,
	const VOID * const	pvPrimaryBookmark,
	const ULONG			cbPrimaryBookmark,
	const JET_GRBIT		grbit )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidGotoPosition(JET_SESID vsesid, JET_VTID vtid,
	JET_RECPOS *precpos)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidVtIdle(JET_SESID vsesid, JET_VTID vtid)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidMakeKey(
	JET_SESID		vsesid,
	JET_VTID		vtid,
	const VOID*		pvData,
	const ULONG		cbData,
	JET_GRBIT		grbit )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidMove(JET_SESID vsesid, JET_VTID vtid,
	long cRow, JET_GRBIT grbit)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidNotifyBeginTrans(JET_SESID vsesid, JET_VTID vtid)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidNotifyCommitTrans(JET_SESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidNotifyRollback(JET_SESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidNotifyUpdateUfn(JET_SESID vsesid, JET_VTID vtid)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidPrepareUpdate(JET_SESID vsesid, JET_VTID vtid,
	unsigned long prep)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidRenameColumn(JET_SESID vsesid, JET_VTID vtid,
	const char  *szColumn, const char  *szColumnNew, const JET_GRBIT grbit )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidRenameIndex(JET_SESID vsesid, JET_VTID vtid,
	const char  *szIndex, const char  *szIndexNew)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidRetrieveColumn(
	JET_SESID		vsesid,
	JET_VTID		vtid,
	JET_COLUMNID	columnid,
	VOID*			pvData,
	const ULONG		cbData,
	ULONG*			pcbActual,
	JET_GRBIT		grbit,
	JET_RETINFO*	pretinfo )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidRetrieveColumns(JET_SESID vsesid, JET_VTID vtid,
	JET_RETRIEVECOLUMN	*pretcols, unsigned long cretcols )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidEnumerateColumns(
	JET_SESID				vsesid,
	JET_VTID				vtid,
	unsigned long			cEnumColumnId,
	JET_ENUMCOLUMNID*		rgEnumColumnId,
	unsigned long*			pcEnumColumn,
	JET_ENUMCOLUMN**		prgEnumColumn,
	JET_PFNREALLOC			pfnRealloc,
	void*					pvReallocContext,
	unsigned long			cbDataMost,
	JET_GRBIT				grbit )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidRetrieveKey(
	JET_SESID		vsesid,
	JET_VTID		vtid,
	VOID*			pvKey,
	const ULONG		cbMax,
	ULONG*			pcbActual,
	JET_GRBIT		grbit )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidSeek(JET_SESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}



ERR VTAPI ErrInvalidSetColumn(
	JET_SESID		vsesid,
	JET_VTID		vtid,
	JET_COLUMNID	columnid,
	const VOID*		pvData,
	const ULONG		cbData,
	JET_GRBIT		grbit,
	JET_SETINFO*	psetinfo )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidSetColumns(JET_SESID vsesid, JET_VTID vtid,
	JET_SETCOLUMN	*psetcols, unsigned long csetcols )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidSetIndexRange(JET_SESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidUpdate(JET_SESID vsesid, JET_VTID vtid,
	void  *pvBookmark, unsigned long cbBookmark,
	unsigned long  *pcbActual, JET_GRBIT grbit )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidGetLock(JET_SESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidRegisterCallback(JET_SESID	vsesid, JET_VTID vtid, JET_CBTYP cbtyp,
	JET_CALLBACK pCallback, VOID * pvContext, JET_HANDLE *phCallbackId )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidUnregisterCallback(JET_SESID vsesid, JET_VTID vtid, JET_CBTYP cbtyp,
	JET_HANDLE hCallbackId )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidSetLS(
	JET_SESID 		vsesid,
	JET_VTID		vtid,
	JET_LS			ls,
	JET_GRBIT		grbit )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidGetLS(
	JET_SESID 		vsesid,
	JET_VTID		vtid,
	JET_LS			*pls,
	JET_GRBIT		grbit )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidIndexRecordCount(
	JET_SESID sesid, JET_VTID vtid,	unsigned long *pcrec,
	unsigned long crecMax )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidRetrieveTaggedColumnList(
	JET_SESID			vsesid,
	JET_VTID			vtid,
	ULONG				*pcentries,
	VOID				*pv,
	const ULONG			cbMax,
	const JET_COLUMNID	columnidStart,
	const JET_GRBIT		grbit )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidSetSequential(
	const JET_SESID,
	const JET_VTID,
	const JET_GRBIT )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidResetSequential(
	const JET_SESID,
	const JET_VTID,
	const JET_GRBIT )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidSetCurrentIndex(
	JET_SESID			sesid,
	JET_VTID			tableid,
	const CHAR			*szIndexName,
	const JET_INDEXID	*pindexid,
	const JET_GRBIT		grbit,
	const ULONG			itagSequence )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}






#ifdef DEBUG
CODECONST(VTDBGDEF) vtdbgdefInvalidTableid =
	{
	sizeof(VTFNDEF),
	0,
	"Invalid Tableid",
	0,
	{
		0,
		0,
		0,
		0,
	},
	};
#endif	/* DEBUG */

 extern const VTFNDEF vtfndefInvalidTableid =
	{
	sizeof(VTFNDEF),
	0,
#ifndef	DEBUG
	NULL,
#else	/* DEBUG */
	&vtdbgdefInvalidTableid,
#endif	/* !DEBUG */
	ErrInvalidAddColumn,
	ErrInvalidCloseTable,
	ErrInvalidComputeStats,
	ErrInvalidCreateIndex,
	ErrInvalidDelete,
	ErrInvalidDeleteColumn,
	ErrInvalidDeleteIndex,
	ErrInvalidDupCursor,
	ErrInvalidEscrowUpdate,
	ErrInvalidGetBookmark,
	ErrInvalidGetIndexBookmark,
	ErrInvalidGetChecksum,
	ErrInvalidGetCurrentIndex,
	ErrInvalidGetCursorInfo,
	ErrInvalidGetRecordPosition,
	ErrInvalidGetTableColumnInfo,
	ErrInvalidGetTableIndexInfo,
	ErrInvalidGetTableInfo,
	ErrInvalidGotoBookmark,
	ErrInvalidGotoIndexBookmark,
	ErrInvalidGotoPosition,
	ErrInvalidMakeKey,
	ErrInvalidMove,
	ErrInvalidPrepareUpdate,
	ErrInvalidRenameColumn,
	ErrInvalidRenameIndex,
	ErrInvalidRetrieveColumn,
	ErrInvalidRetrieveColumns,
	ErrInvalidRetrieveKey,
	ErrInvalidSeek,
	ErrInvalidSetCurrentIndex,
	ErrInvalidSetColumn,
	ErrInvalidSetColumns,
	ErrInvalidSetIndexRange,
	ErrInvalidUpdate,
	ErrInvalidGetLock,
	ErrInvalidRegisterCallback,
	ErrInvalidUnregisterCallback,
	ErrInvalidSetLS,
	ErrInvalidGetLS,
	ErrInvalidIndexRecordCount,
	ErrInvalidRetrieveTaggedColumnList,
	ErrInvalidSetSequential,
	ErrInvalidResetSequential,
	ErrInvalidEnumerateColumns
	};

const VTFNDEF vtfndefIsamCallback =
	{
	sizeof(VTFNDEF),
	0,
	NULL,
	ErrIllegalAddColumn,
	ErrIllegalCloseTable,
	ErrIllegalComputeStats,
	ErrIllegalCreateIndex,
	ErrIllegalDelete,
	ErrIllegalDeleteColumn,
	ErrIllegalDeleteIndex,
	ErrIsamDupCursor,
	ErrIllegalEscrowUpdate,
	ErrIsamGetBookmark,
	ErrIsamGetIndexBookmark,
	ErrIllegalGetChecksum,
	ErrIsamGetCurrentIndex,
	ErrIsamGetCursorInfo,
	ErrIsamGetRecordPosition,
	ErrIsamGetTableColumnInfo,
	ErrIsamGetTableIndexInfo,
	ErrIsamGetTableInfo,
	ErrIllegalGotoBookmark,
	ErrIllegalGotoIndexBookmark,
	ErrIllegalGotoPosition,
	ErrIllegalMakeKey,
	ErrIllegalMove,
	ErrIllegalPrepareUpdate,
	ErrIllegalRenameColumn,
	ErrIllegalRenameIndex,
	ErrIsamRetrieveColumn,
	ErrIsamRetrieveColumns,
	ErrIsamRetrieveKey,
	ErrIllegalSeek,
	ErrIllegalSetCurrentIndex,
	ErrIsamSetColumn,
	ErrIsamSetColumns,
	ErrIllegalSetIndexRange,
	ErrIllegalUpdate,
	ErrIllegalGetLock,
	ErrIsamRegisterCallback,
	ErrIsamUnregisterCallback,
	ErrIsamSetLS,
	ErrIsamGetLS,
	ErrIllegalIndexRecordCount,
	ErrIllegalRetrieveTaggedColumnList,
	ErrIllegalSetSequential,
	ErrIllegalResetSequential,
	ErrIsamEnumerateColumns
	};


/*	The following extern decl is JET Blue only system parameters.
 *	They are declared for JetSetSystemParameter/JetGetSystemParameter.
 */
extern BOOL g_fCreatePathIfNotExist;
extern long	g_cpgSESysMin;
extern long	g_lSessionsMax;
extern long	g_lOpenTablesMax;
extern long g_lOpenTablesPreferredMax;
extern long	g_lTemporaryTablesMax;
extern long	g_lCursorsMax;
extern long	g_lVerPagesMax;
extern long	g_lVerPagesPreferredMax;
extern long	g_lLogBuffers;
extern long	g_lLogFileSize;
extern BOOL g_fSetLogFileSize;
extern long	g_grbitsCommitDefault;
extern char	g_szLogFilePath[];
extern char	g_szLogFileFailoverPath[];
extern BOOL g_fLogFileCreateAsynch;
extern char	g_szRecovery[];
extern BOOL g_fDeleteOldLogs;
extern long g_lPageFragment;
extern BOOL	g_fLGCircularLogging;
extern long	g_cbEventHeapMax;
extern BOOL	g_fTempTableVersioning;
extern BOOL	g_fScrubDB;
extern BOOL g_fSortedRetrieveColumns;
extern long g_cpgBackupChunk;
extern long g_cBackupRead;
extern long g_cpageTempDBMin;
extern const ULONG	cbIDXLISTNewMembersSinceOriginalFormat;
extern BOOL g_fCleanupMismatchedLogFiles;
extern LONG g_lEventLoggingLevel;

LONG INST::iActivePerfInstIDMin = LONG_MAX;
LONG INST::iActivePerfInstIDMac = 1;
LONG INST::cInstancesCounter = 0;

//	All the counters are cleared during instance creation or deletion
//	So only thing we might need is InitPERFCounters function to
//	set initial values for specific counters
LOCAL VOID InitPERFCounters( INT iInstance )
	{
	//	Empty so far
	}

LONG		g_iPerfCounterOffset	= 0;

const INT	cInstPerfName			= 31;
WCHAR *		wszInstanceNames		= NULL;
static INT	cInstances;

static CCriticalSection	critInstanceNames( CLockBasicInfo( CSyncBasicInfo( "critInstanceNames" ), 0, 0 ) );

VOID PERFSetInstanceNames()
	{
	critInstanceNames.Enter();
	WCHAR * szT = wszInstanceNames;
	wcscpy( szT, L"_Total" );
	szT += wcslen( szT ) + 1;
	int ipinst;
	int ipinstLastUsed = 0;
	for( ipinstLastUsed = ipinstMax-1; ipinstLastUsed > 0; ipinstLastUsed-- )
		{
		if( g_rgpinst[ipinstLastUsed] )
			{
			break;
			}
		}

	for( ipinst = 0; ipinst <= ipinstLastUsed; ++ipinst )
		{
		if( g_rgpinst[ipinst] )
			{
			const char * const szInstanceName = g_rgpinst[ipinst]->m_szDisplayName ?
					g_rgpinst[ipinst]->m_szDisplayName : g_rgpinst[ipinst]->m_szInstanceName;

			if( szInstanceName )
				{
				swprintf( szT, L"%.*S", cInstPerfName, szInstanceName );
				}
			else
				{
				_itow( ipinst, szT, 10 );
				}
			}
		else
			{
			wcscpy( szT, L"_Unused" );
			}
		szT += wcslen( szT ) + 1;
		}
	cInstances = ipinstLastUsed + 2;
	//	set new current
	critInstanceNames.Leave();
	}

INST::INST( INT iInstance ) :
#ifdef DEBUGGER_EXTENSION
		m_rgEDBGGlobals( &rgEDBGGlobals ),
		m_rgfmp( &rgfmp ),
		m_rgpinst( g_rgpinst ),
#endif
		m_iInstance( iInstance + 1 ),
		m_fJetInitialized( fFalse ),
		m_fTermInProgress( fFalse ),
		m_fTermAbruptly( fFalse ),
		m_fSTInit( fSTInitNotDone ),
		m_fBackupAllowed( fFalse ),
		m_cSessionInJetAPI( 0 ),
		m_fStopJetService( fFalse ),
		m_errInstanceUnavailable( JET_errSuccess ),
		m_updateid( updateidMin ),
		m_critPIB( CLockBasicInfo( CSyncBasicInfo( szPIBGlobal ), rankPIBGlobal, 0 ) ),
		m_trxNewest( trxMin ),
		m_ppibGlobal( ppibNil ),
		m_ppibGlobalMin( ppibNil ),
		m_ppibGlobalMax( ppibNil ),
		m_pfcbhash( NULL ),
		m_critFCBList( CLockBasicInfo( CSyncBasicInfo( szFCBList ), rankFCBList, 0 ) ),
		m_pfcbList( pfcbNil ),
		m_pfcbAvailBelowMRU( pfcbNil ),
		m_pfcbAvailBelowLRU( pfcbNil ),
		m_pfcbAvailAboveMRU( pfcbNil ),
		m_pfcbAvailAboveLRU( pfcbNil ),
		m_cFCBAvail( 0 ),
		m_pcresFCBPool( NULL ),
		m_pcresTDBPool( NULL ),
		m_pcresIDBPool( NULL ),
		m_cFCBAboveThresholdSinceLastPurge( 0 ),
		m_critFCBCreate( CLockBasicInfo( CSyncBasicInfo( szFCBCreate ), rankFCBCreate, 0 ) ),
		m_pcresFUCBPool( NULL ),
		m_pcresSCBPool( NULL ),
		m_pbAttach( NULL ),
		m_critLV( CLockBasicInfo( CSyncBasicInfo( szLVCreate ), rankLVCreate, 0 ) ),
		m_ppibLV( NULL ),
		m_szInstanceName( NULL ),
		m_szDisplayName( NULL ),
		m_ulParams( 0 ),
		m_lSLVDefragFreeThreshold( g_lSLVDefragFreeThreshold ),
		m_plog( NULL ),
		m_pver( NULL ),
		m_rgoldstatDB( NULL ),
		m_pfsapi( NULL ),
		m_plnppibBegin( NULL ),
		m_plnppibEnd( NULL ),
		m_critLNPPIB( CLockBasicInfo( CSyncBasicInfo( "ListNodePPIB" ), rankPIBGlobal, 1 ) ),
		m_cOpenedSystemPibs( 0 ),
		m_cUsedSystemPibs( 0 ),
		m_lSLVDefragMoveThreshold( g_lSLVDefragMoveThreshold ),
		m_cNonLoggedIndexCreators( 0 ),
		m_cpls( 0 ),
		m_rgpls( NULL )
		{
		if ( m_iInstance > INST::iActivePerfInstIDMac )
			{
			INST::iActivePerfInstIDMac = m_iInstance;
			}
		if ( m_iInstance < INST::iActivePerfInstIDMin )
			{
			INST::iActivePerfInstIDMin = m_iInstance;
			}
#ifdef DEBUG
		m_trxNewest = trxMax - 1025;
#else
		m_trxNewest = trxMin;
#endif

		m_lSessionsMax = g_lSessionsMax;
		m_lVerPagesMax = g_lVerPagesMax;
		m_fPreferredSetByUser = fFalse;
		m_lVerPagesPreferredMax = g_lVerPagesPreferredMax;
		m_lOpenTablesMax = g_lOpenTablesMax;
		m_lOpenTablesPreferredMax = g_lOpenTablesPreferredMax;
		m_lTemporaryTablesMax = g_lTemporaryTablesMax;
		m_lCursorsMax = g_lCursorsMax;
		m_lLogBuffers = g_lLogBuffers;
		m_lLogFileSize = g_lLogFileSize;
		m_fSetLogFileSize = g_fSetLogFileSize;
		m_lLogFileSizeDuringRecovery = 0;
		m_fUseRecoveryLogFileSize = fFalse;
		m_cpgSESysMin = g_cpgSESysMin;
		m_lPageFragment = g_lPageFragment;
		m_cpageTempDBMin = g_cpageTempDBMin;
		m_pfnRuntimeCallback = g_pfnRuntimeCallback;
		m_chIndexTuplesLengthMin = g_chIndexTuplesLengthMin;
		m_chIndexTuplesLengthMax = g_chIndexTuplesLengthMax;
		m_chIndexTuplesToIndexMax = g_chIndexTuplesToIndexMax;
		m_grbitsCommitDefault = g_grbitsCommitDefault;

		m_fTempTableVersioning = ( g_fTempTableVersioning ? fTrue : fFalse );
		m_fCreatePathIfNotExist = ( g_fCreatePathIfNotExist ? fTrue : fFalse );
		m_fCleanupMismatchedLogFiles = ( g_fCleanupMismatchedLogFiles ? fTrue : fFalse );
		m_fNoInformationEvent = ( g_fNoInformationEvent ? fTrue : fFalse );
		m_fSLVProviderEnabled = ( g_fSLVProviderEnabled ? fTrue : fFalse );
		m_fOLDLevel = g_fGlobalOLDLevel;

		m_fEnableIndexChecking 		= ( g_fEnableIndexChecking ? fTrue : fFalse );
		m_fEnableIndexCleanup		= ( g_fEnableIndexCleanup ? fTrue : fFalse );

		m_lEventLoggingLevel = g_lEventLoggingLevel;

		m_idxunicodeDefault = g_idxunicodeDefault;

		if ( ErrOSFSCreate( this, &m_pfsapi ) < JET_errSuccess )
			{
			m_pfsapi = NULL;
			}

		//	store absolute path if possible
		if ( NULL == m_pfsapi
			|| m_pfsapi->ErrPathComplete( g_szSystemPath, m_szSystemPath ) < 0 )
			{
			strcpy( m_szSystemPath, g_szSystemPath );
			}
		strcpy( m_szTempDatabase, g_szTempDatabase );

		strcpy( m_szEventSource, g_szEventSource );
		strcpy( m_szEventSourceKey, g_szEventSourceKey );

		for ( DBID dbid = 0; dbid < dbidMax; dbid++ )
			m_mpdbidifmp[ dbid ] = ifmpMax;

		m_plnppibEnd = new ListNodePPIB;
		if ( NULL == m_plnppibEnd )
			{
			return;
			}

#ifdef DEBUG
		m_plnppibEnd->ppib = NULL;
#endif // DEBUG
		m_plnppibEnd->pNext = m_plnppibEnd;
		m_plnppibBegin = m_plnppibEnd;

		Assert( NULL == m_plog );
		Assert( NULL == m_pver );
		m_plog = new LOG( this );
		m_pver = new VER( this );

		Assert( NULL == m_rgoldstatDB );
		m_rgoldstatDB = new OLDDB_STATUS[ dbidMax ];

		// if allocation fails we we error out anyway
		// after the constructor
		if ( NULL != m_plog )
			{
			m_plog->m_fScrubDB = g_fScrubDB;
			}
		InitPERFCounters( m_iInstance );

		m_cpls = OSSyncGetProcessorCountMax();
		m_rgpls = (PLS*)PvOSMemoryPageAlloc( m_cpls * sizeof( PLS ), NULL );
		for ( size_t iProc = 0; m_rgpls && iProc < OSSyncGetProcessorCountMax(); iProc++ )
			{
			new(&m_rgpls[iProc]) PLS;
			}
		}

INST::~INST()
	{
	if ( INST::iActivePerfInstIDMin == m_iInstance )
		{
		while ( ipinstMax > INST::iActivePerfInstIDMin && pinstNil == g_rgpinst[INST::iActivePerfInstIDMin] )
			{
			INST::iActivePerfInstIDMin++;
			}
		}
	if ( INST::iActivePerfInstIDMac == m_iInstance )
		{
		while ( 1 < INST::iActivePerfInstIDMac && pinstNil == g_rgpinst[INST::iActivePerfInstIDMac-2] )
			{
			INST::iActivePerfInstIDMac--;
			}
		}

	ListNodePPIB *plnppib;
	// close system sessions
	m_critLNPPIB.Enter();
	if ( NULL != m_plnppibEnd )
		{
		Assert( 0 == m_cUsedSystemPibs );	// otherwise there is a thread still using a system PIB
		Assert( NULL != m_plnppibBegin );
		//	all the system session must be returned to the session pool
		Assert( m_plnppibEnd->pNext == m_plnppibBegin );
		plnppib		= m_plnppibEnd;
		m_plnppibEnd	= NULL;
		m_plnppibBegin	= NULL;
		}
	else
		{
		plnppib = NULL;
		}
	m_critLNPPIB.Leave();
	if ( NULL != plnppib )
		{
		//	all the sessions should be terminated already
		//	so just free nodes
		ListNodePPIB *plnppibFirst = plnppib;
		do
			{
			ListNodePPIB *plnppibMove = plnppib->pNext;
			delete plnppib;
			plnppib = plnppibMove;
			}
		while ( plnppibFirst != plnppib );
		}

	if ( m_szInstanceName )
		{
		delete[] m_szInstanceName;
		}
	if ( m_szDisplayName )
		{
		delete[] m_szDisplayName;
		}

	delete m_plog;
	delete m_pver;

	delete[] m_rgoldstatDB;

	delete m_pfsapi;

	//	clear the instance's set of perfmon counters
	for ( size_t iProc = 0; iProc < OSSyncGetProcessorCountMax(); iProc++ )
		{
		memset( &::Ppls( iProc )->rgbPerfCounters[ m_iInstance * g_iPerfCounterOffset ], 0, g_iPerfCounterOffset );
		}

	for ( size_t iProc = 0; m_rgpls && iProc < OSSyncGetProcessorCountMax(); iProc++ )
		{
		m_rgpls[iProc].~PLS();
		}
	OSMemoryPageFree( m_rgpls );
	}

VOID INST::SaveDBMSParams( DBMS_PARAM *pdbms_param )
	{
	Assert( strlen( m_szSystemPath ) <= IFileSystemAPI::cchPathMax );
	strcpy( pdbms_param->szSystemPath, m_szSystemPath );

	Assert( strlen( m_plog->m_szLogFilePath ) <= IFileSystemAPI::cchPathMax );
	strcpy( pdbms_param->szLogFilePath, m_plog->m_szLogFilePath );

	pdbms_param->fDBMSPARAMFlags = 0;
	if ( m_plog->m_fLGCircularLogging )
		pdbms_param->fDBMSPARAMFlags |= fDBMSPARAMCircularLogging;

	Assert( m_lSessionsMax >= 0 );
	Assert( m_lOpenTablesMax >= 0 );
	Assert( m_lVerPagesMax >= 0 );
	Assert( m_lCursorsMax >= 0 );

	//	buffers may be less than minimum during recovery if we're
	//	recovering using an old log file generated before we started
	//	enforcing a minimum log buffer size
	Assert( m_lLogBuffers >= lLogBufferMin || FRecovering() );

	ULONG_PTR ulMaxBuffers;
	CallS( ErrBFGetCacheSizeMax( &ulMaxBuffers ) );

	pdbms_param->le_lSessionsMax = m_lSessionsMax;
	pdbms_param->le_lOpenTablesMax = m_lOpenTablesMax;
	pdbms_param->le_lVerPagesMax = m_lVerPagesMax;
	pdbms_param->le_lCursorsMax = m_lCursorsMax;
	pdbms_param->le_lLogBuffers = m_lLogBuffers;
	pdbms_param->le_lcsecLGFile = m_plog->m_csecLGFile;
	pdbms_param->le_ulCacheSizeMax = (ULONG)ulMaxBuffers;

	memset( pdbms_param->rgbReserved, 0, sizeof(pdbms_param->rgbReserved) );

	return;
	}

VOID INST::RestoreDBMSParams( DBMS_PARAM *pdbms_param )
	{
	//	UNDONE: better cover additional needed resources and
	//	reduce asynchronous activity during recovery
	//	during recovery, even more resources may be necessary than
	//	during normal operation, since asynchronous activites are
	//	both being done, for recovery operation, and being redo by
	//	recovery operation.
	//
	m_lSessionsMax = pdbms_param->le_lSessionsMax;
	m_lOpenTablesMax = pdbms_param->le_lOpenTablesMax;
	m_lVerPagesMax = pdbms_param->le_lVerPagesMax;
	m_lCursorsMax = pdbms_param->le_lCursorsMax;
	m_lLogBuffers = pdbms_param->le_lLogBuffers;
	m_plog->m_csecLGFile = pdbms_param->le_lcsecLGFile;
	const ULONG	ulMaxBuffers	= pdbms_param->le_ulCacheSizeMax;

	Assert( m_lSessionsMax > 0 );
	Assert( m_lOpenTablesMax > 0 );
	Assert( m_lVerPagesMax > 0 );
	Assert( m_lCursorsMax > 0 );
	Assert( m_lLogBuffers > 0 );

	//	buffers may be less than minimum during recovery if we're
	//	recovering using an old log file generated before we started
	//	enforcing a minimum log buffer size
	Assert( m_lLogBuffers >= lLogBufferMin || FRecovering() );

	Assert( ulMaxBuffers > 0 );
	}

BOOL INST::FSetInstanceName( const char * szInstanceName )
	{
	ULONG newSize = szInstanceName ? ULONG( strlen(szInstanceName) ) : 0;

	if (m_szInstanceName)
		{
		delete [] m_szInstanceName;
		m_szInstanceName = NULL;
		}
	Assert ( NULL ==  m_szInstanceName);
	if ( 0 == newSize)
		{
		return fTrue;
		}

	m_szInstanceName = new char[newSize + 1];
	if ( NULL == m_szInstanceName)
		{
		return fFalse;
		}
	m_szInstanceName[0] = 0;

	if ( szInstanceName )
		{
		strcpy( m_szInstanceName, szInstanceName );
		}

	return fTrue;
	}

BOOL INST::FSetDisplayName( const char * szDisplayName )
	{
	ULONG newSize = szDisplayName ? ULONG( strlen(szDisplayName) ) : 0;

	if (m_szDisplayName)
		{
		delete [] m_szDisplayName;
		m_szDisplayName = NULL;
		}
	Assert ( NULL ==  m_szDisplayName);
	if ( 0 == newSize)
		{
		return fTrue;
		}

	m_szDisplayName = new char[newSize + 1];
	if ( NULL == m_szDisplayName)
		{
		return fFalse;
		}
	m_szDisplayName[0] = 0;

	if ( szDisplayName )
		{
		strcpy( m_szDisplayName, szDisplayName );
		}

	return fTrue;
	}

INST::ErrGetSystemPib( PIB **pppib )
	{
	ERR err = JET_errSuccess;
	ENTERCRITICALSECTION enter( &m_critLNPPIB );
	Assert( NULL != m_plnppibEnd );
	Assert( NULL != m_plnppibBegin );
	//	there are some available sessions

#ifdef SYSTEM_PIB_RFS

	//	debugging support: generate synthetic system PIB failures

	if( g_cSystemPibAllocFail
		&& 0 == ( ++g_cSystemPibAlloc % g_cSystemPibAllocFail ) )
		{
		Call( ErrERRCheck( JET_errOutOfSessions ) );
		}

#endif

	if ( m_plnppibEnd != m_plnppibBegin )
		{
		*pppib = m_plnppibBegin->ppib;
#ifdef DEBUG
		m_plnppibBegin->ppib = NULL;
#endif // DEBUG
		m_plnppibBegin = m_plnppibBegin->pNext;
		goto HandleError;
		}
	else if ( m_cOpenedSystemPibs >= cpibSystemFudge )
		{
		Call( ErrERRCheck( JET_errOutOfSessions ) );
		}
	//	else try to allocate new session
	else
		{
		//	allocate new node
		ListNodePPIB *plnppib = new ListNodePPIB;
		if ( NULL == plnppib )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		//	allocate new session and initialize it
		err = ErrPIBBeginSession( this, pppib, procidNil, fFalse );
		if ( JET_errSuccess > err )
			{
			delete plnppib;
			Call( err );
			}
		m_cOpenedSystemPibs++;
		(*pppib)->grbitsCommitDefault = JET_bitCommitLazyFlush;
		(*pppib)->SetFSystemCallback();
		//	add the node to the list
		Assert( NULL != m_plnppibEnd );
		plnppib->pNext	= m_plnppibEnd->pNext;
#ifdef DEBUG
		plnppib->ppib	= NULL;
#endif // DEBUG
		m_plnppibEnd->pNext = plnppib;
		}

HandleError:
	if( JET_errSuccess == err )
		{
		Assert( *pppib );
		++m_cUsedSystemPibs;
		}
	else
		{
		//	not expecting any warnings
		//
		Assert( err < JET_errSuccess );
		}
	return err;
	}

VOID INST::ReleaseSystemPib( PIB *ppib )
	{
	ENTERCRITICALSECTION enter( &m_critLNPPIB );
	Assert( NULL != m_plnppibEnd );
	Assert( NULL == m_plnppibEnd->ppib );
	m_plnppibEnd->ppib	= ppib;
	m_plnppibEnd		= m_plnppibEnd->pNext;
	--m_cUsedSystemPibs;
	}

CCriticalSection critInst( CLockBasicInfo( CSyncBasicInfo( szInstance ), rankInstance, 0 ) );
ULONG	g_cMaxInstancesRequestedByUser	= cMaxInstancesMultiInstanceDefault;
ULONG	ipinstMax 						= cMaxInstancesSingleInstanceDefault;
ULONG	ipinstMac 						= 0;
INST	*g_rgpinst[cMaxInstances]		= { 0 };
CRITPOOL< INST* > critpoolPinstAPI;

ULONG	g_cTermsInProgress				= 0;

//  ICF for the current process' name

PM_ICF_PROC LProcNameICFLPpv;

WCHAR wszProcName[IFileSystemAPI::cchPathMax];

long LProcNameICFLPpv( long lAction, void const **ppvMultiSz )
	{
	//  init ICF

	if ( lAction == ICFInit )
		{
#ifdef _UNICODE
		swprintf( wszProcName, L"%s\0" , SzUtilProcessName() );
#else  //  !_UNICODE
		swprintf( wszProcName, L"%S\0" , SzUtilProcessName() );
#endif  //  _UNICODE
		wszProcName[cInstPerfName] = 0;
		}

	else
		{
		if ( ppvMultiSz )
			{
			*ppvMultiSz = wszProcName;
			return 1;
			}
		}

	return 0;
	}



PM_ICF_PROC LInstanceNamesICFLPpv;

extern BOOL g_fSystemInit;

long LInstanceNamesICFLPpv( long lAction, void const** ppvMultiSz )
	{
	static LONG cInstancesLast;
	if( lAction == ICFData )
		{
		critInstanceNames.Enter();
		memcpy( &wszInstanceNames[ perfinstMax * ( cInstPerfName + 1) + 1 ], wszInstanceNames, sizeof(WCHAR) * (perfinstMax * ( cInstPerfName + 1) + 1) );
		cInstancesLast = cInstances;
		critInstanceNames.Leave();
		*ppvMultiSz = &wszInstanceNames[ perfinstMax * ( cInstPerfName + 1) + 1 ];
		return cInstancesLast;
		}

	return 0;
	}

/*
Sysrtem can be in one of the 3 states:
1. multi-instance enabled
	Use:  JetEnableMultiInstance to set global-default parameters
	Use:  JetCreateInstance to allocate an instance
	Use:  JetSetSystemParameter with not null instance to set param per instance
	Use:  JetInit with not null pinstance to initialize it (or allocate and inititalize if *pinstance == 0)
	Error:  JetSetSystemParameter with null instance (try to set global param
	Error:  JetInit with null pinstance (default instance can be find only in one-instance mode)

2. one-instance enabled
	Use:  JetSetSystemParameter with null instance to set param per instance
	Use:  JetSetSystemParameter with not null instance to set param per instance
	Use:  JetInit with to initialize the instance (the second call before JetTerm will fail)
	Error:  JetEnableMultiInstance
	Error:  JetCreateInstance

3. mode not set
	no instance is started (initial state and state after last running instance calls JetTerm (ipinstMac == 0)

If the mode is not set, the first function call specific for one of the modes will set it
*/
typedef enum { runInstModeNoSet, runInstModeOneInst, runInstModeMultiInst} RUNINSTMODE;
RUNINSTMODE g_runInstMode = runInstModeNoSet;

// set running mode
INLINE VOID RUNINSTSetMode(RUNINSTMODE newMode)
	{
	// must be in critical section to set
	Assert ( critInst.FOwner() );
	// must be before any instance is started
	Assert ( 0 == ipinstMac);
	g_runInstMode = newMode;
	}

// set running mode to one instance
INLINE VOID RUNINSTSetModeOneInst()
	{
	Assert ( runInstModeNoSet == g_runInstMode);
	RUNINSTSetMode(runInstModeOneInst);

	//	force ipinstMax to 1
	ipinstMax = cMaxInstancesSingleInstanceDefault;
	ifmpMax = ipinstMax * dbidMax;
	}

// set running mode to multi instance
INLINE VOID RUNINSTSetModeMultiInst()
	{
	Assert ( runInstModeNoSet == g_runInstMode);
	RUNINSTSetMode(runInstModeMultiInst);

	//	NOTE: we have separate ipinstMax and
	//	g_cMaxInstancesRequestedByUser variables in case
	//	the user wants to switch back and forth between
	//	single- and multi-instance mode (ipinstMax keeps
	//	track of the max instances depending on what mode
	//	we're in, while g_cMaxInstancesRequestedByUser
	//	only keeps track of the max instances in multi-
	//	instance mode)
	ipinstMax = g_cMaxInstancesRequestedByUser;
	ifmpMax = ipinstMax * dbidMax;
	}

// get runnign mode
INLINE RUNINSTMODE RUNINSTGetMode()
	{
	// can be no set mode only if no instance is active
	Assert (  runInstModeNoSet != g_runInstMode || 0 == ipinstMac );
	return g_runInstMode;
	}

INLINE ERR ErrRUNINSTCheckAndSetOneInstMode()
	{
	ERR		err		= JET_errSuccess;

	INST::EnterCritInst();
	if ( RUNINSTGetMode() == runInstModeNoSet)
		{
		RUNINSTSetModeOneInst();
		}
	else if ( RUNINSTGetMode() == runInstModeMultiInst)
		{
		err = ErrERRCheck( JET_errRunningInMultiInstanceMode );
		}
	INST::LeaveCritInst();

	return err;
	}


INLINE BOOL FINSTInvalid( const JET_INSTANCE instance )
	{
	return ( 0 == instance || (JET_INSTANCE)JET_instanceNil == instance );
	}


BOOL FINSTSomeInitialized()
	{
	const BOOL	fInitAlready	= ( RUNINSTGetMode() != runInstModeNoSet );
	return fInitAlready;
	}

ERR ErrNewInst(
	INST **			ppinst,
	const CHAR *	szInstanceName,
	const CHAR *	szDisplayName,
	INT *			pipinst )
	{
	ERR				err			= JET_errSuccess;
	INST *			pinst		= NULL;
	ULONG			ipinst;

	//	if running out of memory, return NULL
	*ppinst = pinst;

	Assert ( NULL == *ppinst );

	//	See if g_rgpinst still have space to hold the pinst.

	INST::EnterCritInst();

	if ( 0 == ipinstMac )
		{
		//	only the first instance should initialise the system
		Call( ErrIsamSystemInit() );
		}

	if ( ipinstMac >= ipinstMax )
		{
		Call ( ErrERRCheck( JET_errTooManyInstances ) );
		}
	else // check unique name
		{
		for ( ipinst = 0; ipinst < ipinstMax; ipinst++ )
			{
			if ( pinstNil == g_rgpinst[ ipinst ] )
				{
				continue;
				}
			if ( NULL == szInstanceName &&
				 NULL == g_rgpinst[ ipinst ]->m_szInstanceName )
				{
				Call ( ErrERRCheck( JET_errInstanceNameInUse ) );
				}
			if ( NULL != szInstanceName &&
			   	 NULL != g_rgpinst[ ipinst ]->m_szInstanceName &&
			   	 0 == strcmp( szInstanceName, g_rgpinst[ ipinst ]->m_szInstanceName ) )
				{
				Call ( ErrERRCheck( JET_errInstanceNameInUse ) );
				}
			}
		}

	Assert( JET_errSuccess == err );

	for ( ipinst = 0; ipinst < ipinstMax; ipinst++ )
		{
		if ( pinstNil == g_rgpinst[ ipinst ] )
			{
			break;
			}
		}
	Assert( ipinstMax > ipinst );

	(VOID)INST::IncAllocInstances();
	pinst = new INST( ipinst );
	if ( NULL != pinst )
		{
		if ( NULL == pinst->m_plog
			|| NULL == pinst->m_pver
			|| NULL == pinst->m_rgoldstatDB
			|| NULL == pinst->m_pfsapi
			|| NULL == pinst->FSetInstanceName( szInstanceName )
			|| NULL == pinst->FSetDisplayName( szDisplayName)
			|| NULL == pinst->m_rgpls )
			{
			delete pinst;
			pinst = NULL;
			}
		}
	if ( NULL == pinst )
		{
		(VOID)INST::DecAllocInstances();
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	*ppinst = pinst;

	Assert( pinstNil != pinst );

	AtomicExchangePointer( (void **)&g_rgpinst[ ipinst ], pinst );
	if ( pipinst )
		{
		*pipinst = ipinst;
		}
	ipinstMac++;

	PERFSetInstanceNames();

	//	verify we were allocated an entry in the instance array
	EnforceSz( ipinst < ipinstMax, "Instance array corrupted." );

HandleError:
	if ( JET_errSuccess > err )
		{
		if ( ipinstMac == 0 )
			{
			IsamSystemTerm();
			RUNINSTSetMode(runInstModeNoSet);
			}
		Assert ( NULL == pinst );
		}

	INST::LeaveCritInst();

	return err;
	}

VOID FreePinst( INST *pinst )
	{
	int ipinst;

	Assert( pinst );

	// fSTInitFailed meens restore faild. Since now we clean up the instance resources
	// also on error, it should be fine to release the instance
	// If we don't do that, we can reach the situation when all the g_rgpinst array is full
	// with such left "deactivated" instances and we can not start any new one
/*
	//	if it did not shut down properly, do not free this instance.
	//	keep it as used so that no one will be able to reuse it.

	if ( pinst->m_fSTInit == fSTInitFailed )
		return;
*/
	//	find the pinst.

	INST::EnterCritInst();

	for ( ipinst = 0; ipinst < ipinstMax; ipinst++ )
		{
		if ( g_rgpinst[ ipinst ] == pinst )
			{
			//	enter per-inst crit to make sure no one can read the pinst.

			CCriticalSection *pcritInst = &critpoolPinstAPI.Crit(&g_rgpinst[ipinst]);
			pcritInst->Enter();

			//	ensure no one beat us to it
			//
			if ( g_rgpinst[ ipinst ] == pinst )
				{
				pinst->APILock( pinst->fAPIDeleting );
				AtomicExchangePointer( (void **)&g_rgpinst[ ipinst ], pinstNil );
				ipinstMac--;
				delete pinst;
				(VOID)INST::DecAllocInstances();
				pcritInst->Leave();
				PERFSetInstanceNames();

				if ( ipinstMac == 0 )
					{
					IsamSystemTerm();
//					Assert (RUNINSTGetMode() == runInstModeOneInst || RUNINSTGetMode() == runInstModeMultiInst);
					RUNINSTSetMode(runInstModeNoSet);
					}
				}
			else
				{
				pcritInst->Leave();
				}

			break;
			}
		}

	INST::LeaveCritInst();
	}

INLINE VOID SetPinst( JET_INSTANCE *pinstance, JET_SESID sesid, INST **ppinst )
	{
	if ( !sesid || sesid == JET_sesidNil )
		{
		//	setting for one instance? NULL if for global default

		if ( pinstance && ipinstMac )
			*ppinst = *(INST **) pinstance;
		else
			*ppinst = NULL;
		}
	else
		{
		//	sesid is given, assuming the client knows what they are doing
		*ppinst = PinstFromPpib( (PIB *)sesid );
		}
	}

LOCAL ERR ErrFindPinst( JET_INSTANCE jinst, INST **ppinst, int *pipinst = NULL )
	{
	INST				*pinst	= (INST *)jinst;
	UINT				ipinst;
	const RUNINSTMODE	mode	= RUNINSTGetMode();

	Assert( ppinst );

	switch ( mode )
		{
		case runInstModeOneInst:
			//	find the only one instance, ignore the given instance
			//	since the given one may be bogus
			for ( ipinst = 0; ipinst < ipinstMax; ipinst++ )
				{
				if ( pinstNil != g_rgpinst[ ipinst ] )
					{
					*ppinst = g_rgpinst[ ipinst ];
					if ( pipinst )
						*pipinst = ipinst;
					return JET_errSuccess;
					}
				}
			break;
		case runInstModeMultiInst:
			if ( FINSTInvalid( jinst ) )
				return ErrERRCheck( JET_errInvalidParameter );
			for ( ipinst = 0; ipinst < ipinstMax; ipinst++ )
				{
				if ( pinstNil != g_rgpinst[ ipinst ]
					&& pinst == g_rgpinst[ ipinst ] )
					{
					// instance found
					*ppinst = g_rgpinst[ ipinst ];
					if ( pipinst )
						*pipinst = ipinst;
					return JET_errSuccess;
					}
				}
			break;
		default:
			Assert( runInstModeNoSet == mode );
		}

	//	a bogus instance
	return ErrERRCheck( JET_errInvalidParameter );
	}

INLINE INST *PinstFromSesid( JET_SESID sesid )
	{
	AssertSzRTL( JET_SESID( ppibNil ) != sesid, "Invalid (NULL) Session ID parameter." );
	AssertSzRTL( JET_sesidNil != sesid, "Invalid (JET_sesidNil) Session ID parameter." );
	INST *pinst = PinstFromPpib( (PIB*)sesid );
	AssertSzRTL( NULL != pinst, "Invalid Session ID parameter - has NULL as an instance." );
	AssertSzRTL( (INST*)JET_instanceNil != pinst, "Invalid Session ID parameter - has (JET_instanceNil) as an instance." );
	return pinst;
	}


//  ================================================================
VOID INST::SetInstanceUnavailable( const ERR err )
//  ================================================================
	{
	Assert( err < JET_errSuccess );

	//	in case this gets called multiple times,
	//	only record the initial error
	//	UNDONE: there's a concurrency hole
	//	where multiple threads may try to set
	//	this for the first time, but it's not
	//	a big deal
	//
	if ( JET_errSuccess == m_errInstanceUnavailable )
		{
		m_errInstanceUnavailable = err;

		//	on LogWriteFail, see if we can't determine
		//	a more precise error
		//
		if ( JET_errLogWriteFail == err
			&& m_plog->m_fLGNoMoreLogWrite )
			{
			const ERR	errLog	= m_plog->m_errNoMoreLogWrite;

			if ( JET_errSuccess != errLog )
				{
				m_errInstanceUnavailable = errLog;
				}
			}
		}
	}



#ifdef PROFILE_JET_API

#ifdef DEBUG
#else
#error "PROFILE_JET_API can be defined only in debug mode"
#endif

#define PROFILE_LOG_JET_OP				1
#define PROFILE_LOG_CALLS_SUMMARY		2

INT		profile_detailLevel		= 0;
FILE *	profile_pFile			= 0;
QWORD	profile_qwTimeOffset	= 0;
CHAR	profile_szFileName[ IFileSystemAPI::cchPathMax ]	= "";

#define ProfileQwPrintMs__( x ) (((double)(signed __int64)(x)*1000)/(signed _int64)QwUtilHRTFreq())

#endif // PROFILE_JET_API



class APICALL
	{
	private:
		ERR			m_err;

#ifdef PROFILE_JET_API
		INT			m_profile_opCurrentOp;
		CHAR *		m_profile_szCurrentOp;
		QWORD		m_profile_tickStart;
#endif

	public:
		APICALL( const INT op )
			{
#ifdef PROFILE_JET_API
			//	UNDONE: need to specify the
			//	name of the op as the second
			//	param to the CProfileCounter
			//	constructor
			if ( opMax != op
				&& ( profile_detailLevel & PROFILE_LOG_JET_OP )
				&& NULL != profile_pFile )
				{
				m_profile_opCurrentOp = op;
//				m_profile_szCurrentOp = #op;	//	UNDONE: record API name
				m_profile_tickStart = QwUtilHRTCount();
				}
			else
				{
				m_profile_opCurrentOp = opMax;
				}
#endif

			//	UNDONE: a PIB will be required if
			//	actual logging of the op is ever
			//	re-enabled
			DebugLogJetOp( JET_sesidNil, op );
			}

		~APICALL()
			{
#ifdef PROFILE_JET_API
			if ( opMax != m_profile_opCurrentOp )
				{
				Assert( NULL != profile_pFile );
				Assert( profile_detailLevel & PROFILE_LOG_JET_OP );

				const QWORD	profile_tickEnd	= QwUtilHRTCount();
				const QWORD	qwTime			= m_profile_tickStart/QwUtilHRTFreq() + profile_qwTimeOffset;
				const INT	hour			= (INT)( ( qwTime / 3600 ) % 24 );
				const INT	min				= (INT)( ( qwTime / 60 ) % 60 );
				const INT	sec				= (INT)( qwTime % 60 );

				fprintf(
					profile_pFile,
					"%02d:%02d:%02d %03d %.3f ms\n",
					hour,
					min,
					sec,
					m_profile_opCurrentOp,		//	UNDONE: print m_profile_szCurrentOp instead
					ProfileQwPrintMs__( profile_tickEnd - m_profile_tickStart ) );
				}
#endif
			}

		ERR ErrResult() const				{ return m_err;	}
		VOID SetErr( const ERR err )		{ m_err = err; }
	};	//	APICALL

class APICALL_INST : public APICALL
	{
	private:
		INST *		m_pinst;

	public:
		APICALL_INST( const INT op ) : APICALL( op )	{}
		~APICALL_INST()									{}

		INST * Pinst()									{ return m_pinst; }

		BOOL FEnter( const JET_INSTANCE instance )
			{
			const ERR	errT	=	ErrFindPinst( instance, &m_pinst );

			SetErr( errT >= JET_errSuccess ?
						m_pinst->ErrAPIEnter( fFalse ) :
						errT );

			return ( ErrResult() >= JET_errSuccess );
			}

		BOOL FEnterForInit( INST * const pinst )
			{
			m_pinst = pinst;
			SetErr( pinst->ErrAPIEnterForInit() );
			return ( ErrResult() >= JET_errSuccess );
			}

		BOOL FEnterForTerm( INST * const pinst )
			{
			m_pinst = pinst;
			SetErr( pinst->ErrAPIEnter( fTrue ) );
			return ( ErrResult() >= JET_errSuccess );
			}

		BOOL FEnterWithoutInit( INST * const pinst, const BOOL fAllowInitInProgress )
			{
			m_pinst = pinst;
			SetErr( pinst->ErrAPIEnterWithoutInit( fAllowInitInProgress ) );
			return ( ErrResult() >= JET_errSuccess );
			}

		VOID LeaveAfterCall( const ERR err )
			{
			m_pinst->APILeave();
			SetErr( err );
			}
	};

class APICALL_SESID : public APICALL
	{
	private:
		PIB *		m_ppib;

	public:
		APICALL_SESID( const INT op ) : APICALL( op )		{}
		~APICALL_SESID()									{}

		PIB * Ppib()										{ return m_ppib; }

		BOOL FEnter(
			const JET_SESID		sesid,
			const BOOL			fIgnoreStopService = fFalse )
			{
			//	UNDONE: this check is a hack for single-
			//	instance mode to attempt to minimise the
			//	concurrency holes that exists when API
			//	calls are made while the instance is
			//	terminating
			if ( g_cTermsInProgress >= ipinstMac )
				{
				SetErr( ErrERRCheck( 0 == ipinstMac ? JET_errNotInitialized : JET_errTermInProgress ) );
				return fFalse;
				}

			const INST * const	pinst	= PinstFromSesid( sesid );

			if ( pinst->m_fStopJetService && !fIgnoreStopService )
				{
				SetErr( ErrERRCheck( JET_errClientRequestToStopJetService ) );
				}
			else if ( pinst->FInstanceUnavailable() )
				{
				SetErr( pinst->ErrInstanceUnavailableErrorCode() );
				}
			else if ( pinst->m_fTermInProgress )
				{
				SetErr( ErrERRCheck( JET_errTermInProgress ) );
				}
			else
				{
				m_ppib = (PIB *)sesid;

				//	if someone else is already in the Jet API with
				//	this session and this is not a callback, then
				//	report a session-sharing violation
				//
				//	(UNDONE: this means that we don't detect
				//	session-sharing violations within callbacks)
				//
				Assert( m_ppib->m_cInJetAPI >= 0 );
				if ( 1 != AtomicIncrement( &m_ppib->m_cInJetAPI )
					&& !Ptls()->fInCallback )
					{
					PIBReportSessionSharingViolation( m_ppib );
					FireWall();
					AtomicDecrement( &m_ppib->m_cInJetAPI );
					SetErr( ErrERRCheck( JET_errSessionSharingViolation ) );
					}

				//	Must check fTermInProgress again in case
				//	it got set after we incremented m_cInJetAPI
				//
				else if ( pinst->m_fTermInProgress )
					{
					AtomicDecrement( &m_ppib->m_cInJetAPI );
					SetErr( ErrERRCheck( JET_errTermInProgress ) );
					}
				else
					{
					SetErr( JET_errSuccess );
					}
				}

			return ( ErrResult() >= JET_errSuccess );
			}

		__forceinline VOID LeaveAfterCall( const ERR err )
			{
			Assert( m_ppib->m_cInJetAPI > 0 );
			AtomicDecrement( &m_ppib->m_cInJetAPI );
			SetErr( err );
			}
		VOID LeaveAfterEndSession( const ERR err )
			{
			if ( err < JET_errSuccess )
				{
				//	if EndSession succeeded, the session is
				//	no longer alive, but if it failed the
				//	session is still alive, so we must still
				//	maintain the API refcount properly
				//
				Assert( m_ppib->m_cInJetAPI > 0 );
				AtomicDecrement( &m_ppib->m_cInJetAPI );
				}
			SetErr( err );
			}
	};


INST::PLS* INST::Ppls()
	{
	return &m_rgpls[ OSSyncGetCurrentProcessor() ];
	}

INST::PLS* INST::Ppls( const size_t iProc )
	{
	return iProc < m_cpls ? &m_rgpls[ iProc ] : NULL;
	}

LOCAL ERR INST::ErrAPIAbandonEnter_( const LONG lOld )
	{
	ERR		err;

	AtomicExchangeAdd( &m_cSessionInJetAPI, -1 );

	if ( lOld & fAPITerminating )
		{
		err = ErrERRCheck( JET_errTermInProgress );
		}
	else if ( lOld & fAPIRestoring )
		{
		err = ErrERRCheck( JET_errRestoreInProgress );
		}
	else
		{
		//	note that init might have gotten in and succeeded by
		//	now, but return NotInit anyways
		err = ErrERRCheck( JET_errNotInitialized );
		}

	return err;
	}

LOCAL ERR INST::ErrAPIEnter( const BOOL fTerminating )
	{
	if ( !fTerminating )
		{
		if ( m_fStopJetService )
			{
			return ErrERRCheck( JET_errClientRequestToStopJetService );
			}
		else if ( FInstanceUnavailable() )
			{
			return ErrInstanceUnavailableErrorCode();
			}
		}

	const LONG	lOld	= AtomicExchangeAdd( &m_cSessionInJetAPI, 1 );

	if ( ( ( lOld & maskAPILocked ) && !( lOld & fAPICheckpointing ) )
		|| 	!m_fJetInitialized )
		{
		return ErrAPIAbandonEnter_( lOld );
		}

	Assert( lOld < 0x0FFFFFFF );
	Assert( m_fJetInitialized );
	return JET_errSuccess;
	}

LOCAL ERR INST::ErrAPIEnterForInit()
	{
	ERR		err;

	if ( m_fJetInitialized )
		{
		err = ErrERRCheck( JET_errAlreadyInitialized );
		}
	else
		{
		long lT = AtomicExchangeAdd( &m_cSessionInJetAPI, 1 );
		Assert( lT >= 0 );
		err = JET_errSuccess;
		}

	return err;
	}

//	can enter API even if it's not initialised (but not if it's in progress)
LOCAL ERR INST::ErrAPIEnterWithoutInit( const BOOL fAllowInitInProgress )
	{
	ERR		err;
	LONG	lOld	= AtomicExchangeAdd( &m_cSessionInJetAPI, 1 );

	if ( ( lOld & maskAPILocked ) && !( lOld & fAPICheckpointing ) )
		{
		AtomicExchangeAdd( &m_cSessionInJetAPI, -1 );
		if ( lOld & fAPITerminating )
			{
			err = ErrERRCheck( JET_errTermInProgress );
			}
		else if ( lOld & fAPIRestoring )
			{
			err = ErrERRCheck( JET_errRestoreInProgress );
			}
		else
			{
			Assert( lOld & fAPIInitializing );
			err = ( fAllowInitInProgress ? JET_errSuccess : ErrERRCheck( JET_errInitInProgress ) );
			}
		}
	else
		{
		Assert( lOld < 0x0FFFFFFF );
		err = JET_errSuccess;
		}

	return err;
	}


INLINE VOID INST::APILeave()
	{
	const LONG	lOld	= AtomicExchangeAdd( &m_cSessionInJetAPI, -1 );
	Assert( lOld >= 1 );

	UtilAssertNotInAnyCriticalSection( );
	}


//	this function assumes we're in critpoolPinstAPI(&g_rgpinst[ipinst]).Crit()
BOOL INST::APILock( const LONG fAPIAction, const BOOL fNoWait )
	{
	LONG	lOld;

#ifdef DEBUG
	ULONG	cWaitForAllSessionsToLeaveJet = 0;
#endif

	Assert( fAPIAction & maskAPILocked );

	lOld = AtomicExchangeAdd( &m_cSessionInJetAPI, fAPIAction );

//	//	no one else could have the lock because we're in critpoolPinstAPI(&g_rgpinst[ipinst]).Crit()
//	Assert( !( lOld & maskAPILocked ) );

	while ( ( fAPIAction & fAPICheckpointing ) ?
				( lOld & maskAPILocked ) :
				( ( lOld & maskAPISessionCount ) > 1 || ( lOld & fAPICheckpointing ) ) )
		{
		if ( fNoWait )
			{
			lOld = AtomicExchangeAdd( &m_cSessionInJetAPI, -fAPIAction );
			return fFalse;
			}

		//	session still active, wait then retry
		AssertSz( ++cWaitForAllSessionsToLeaveJet < 10000,
			"The process has likely hung while attempting to terminate ESE.\nA thread was probably killed by the process while still in ESE." );
		UtilSleep( cmsecWaitGeneric );

		lOld = m_cSessionInJetAPI;
		}

	Assert( 1 == ( lOld & maskAPISessionCount ) || fAPICheckpointing );
	Assert( m_cSessionInJetAPI & fAPIAction );

	return fTrue;
	}

VOID INST::APIUnlock( const LONG fAPIAction )
	{
	const LONG	lOld	= AtomicExchangeAdd( &m_cSessionInJetAPI, -fAPIAction );
	Assert( lOld & fAPIAction );
#ifdef DEBUG
	{
	long cSessionInJetAPI = m_cSessionInJetAPI;
	Assert( 	!( cSessionInJetAPI & maskAPILocked )		// No one is holding except
			||	( cSessionInJetAPI & fAPICheckpointing )	// checkpointing, or
			||	( fAPIAction & fAPICheckpointing ) );		// Checkpointing itself is leaving
	}
#endif
	}

VOID INST::EnterCritInst() { critInst.Enter(); }
VOID INST::LeaveCritInst() { critInst.Leave(); }


ERR INST::ErrINSTSystemInit()
	{
	Assert( NULL != g_rgpinst );
	Assert( 0 == ipinstMac );
	Assert( NULL == wszInstanceNames );

	ERR err = JET_errSuccess;
	int i;

#ifdef PROFILE_JET_API
	Assert( NULL == profile_pFile );

	//	no file name specified
	if ( 0 == profile_szFileName[0] )
		{
		profile_detailLevel = 0;
		}
	if ( profile_detailLevel > 0 )
		{
		profile_pFile = fopen( profile_szFileName, "at" );
		if ( NULL != profile_pFile )
			{
			DATETIME datetime;
			profile_qwTimeOffset = QwUtilHRTCount();
			UtilGetCurrentDateTime( &datetime );
			profile_qwTimeOffset =
				(QWORD)(datetime.hour*3600 + datetime.minute*60 + datetime.second)
				- profile_qwTimeOffset/QwUtilHRTFreq();
			fprintf(
				profile_pFile,
				"\n%02d:%02d:%02d [BEGIN %s]\n",
				datetime.hour,
				datetime.minute,
				datetime.second,
				SzUtilProcessName() );
			}
		}
#endif // PROFILE_JET_API

	//  allocate CS storage, but not as CSs (no default initializer)
	if ( !critpoolPinstAPI.FInit( ipinstMax, rankAPI, szAPI ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//	Init the array for the instance names
	wszInstanceNames = new WCHAR[ 2 * ( perfinstMax * ( cInstPerfName + 1) + 1 ) ];
	if ( NULL == wszInstanceNames)
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

#ifdef SYSTEM_PIB_RFS
	g_cSystemPibAlloc 		= 0;
	g_cSystemPibAllocFail 	= 0;

	_TCHAR szT[64];
	if( FOSConfigGet( _T( "DEBUG" ), _T( "System PIB Failures" ), szT, sizeof( szT ) ) )
		{
		g_cSystemPibAllocFail = atoi( szT );

		if( g_cSystemPibAllocFail )
			{
			_TCHAR szMessage[128];
			const INT cchMessage 	= sizeof( szMessage ) / sizeof( szMessage[0] );
			const _TCHAR *rgpszT[1] = { szMessage };

			_snprintf(	szMessage,
						cchMessage,
						_T( "System PIB RFS enabled through the registry. System PIB allocation will fail every %d attempts" ),
						g_cSystemPibAllocFail );
			szMessage[cchMessage - 1] = 0;

			UtilReportEvent( eventWarning, GENERAL_CATEGORY, PLAIN_TEXT_ID, 1, rgpszT );
			}
		}
#endif


HandleError:
	if ( JET_errSuccess > err )
		{
		INSTSystemTerm();
		}

	return err;
	}


VOID INST::INSTSystemTerm()
	{
	//  free instance names
	delete[] wszInstanceNames;
	wszInstanceNames = NULL;

	//  terminate CS storage
	critpoolPinstAPI.Term();

#ifdef PROFILE_JET_API
	if ( NULL != profile_pFile )
		{
		DATETIME datetime;
		UtilGetCurrentDateTime( &datetime );
		fprintf( profile_pFile, "%02d:%02d:%02d [END %s]\n", datetime.hour, datetime.minute, datetime.second, SzUtilProcessName() );
		fclose( profile_pFile );
		profile_pFile = NULL;
		}
#endif
}

CCriticalSection critDBGPrint( CLockBasicInfo( CSyncBasicInfo( szDBGPrint ), rankDBGPrint, 0 ) );

VOID JET_API DBGFPrintF( char *sz )
	{
	critDBGPrint.Enter();
	FILE* f = fopen( szJetTxt, "a+" );
	if ( f != NULL )
		{
		fprintf( f, "%s", sz );
		fflush( f );
		fclose( f );
		}
	critDBGPrint.Leave();
	}


ERR ErrCheckUniquePath( INST *pinst )
	{
	ERR					err 						= JET_errSuccess;
	ERR					errFullPath					= JET_errSuccess;
	const BOOL			fTempDbForThisInst			= ( pinst->m_lTemporaryTablesMax > 0 && !pinst->FRecovering() );
	const BOOL			fRecoveryForThisInst		= !pinst->FComputeLogDisabled();
	IFileSystemAPI *	pfsapi						= NULL;
	ULONG				ipinstChecked				= 0;
	ULONG				ipinst;
	CHAR				rgchFullNameNew[IFileSystemAPI::cchPathMax];
	CHAR				rgchFullNameExist[IFileSystemAPI::cchPathMax];

	Call( ErrOSFSCreate( pinst, &pfsapi ) );

	INST::EnterCritInst();

	for ( ipinst = 0; ipinst < ipinstMax && ipinstChecked < ipinstMac; ipinst++ )
		{
		if ( !g_rgpinst[ ipinst ] )
			{
			continue;
			}
		ipinstChecked++;
		if ( g_rgpinst[ ipinst ] == pinst )
			{
			continue;
			}
		if ( !g_rgpinst[ ipinst ]->m_fJetInitialized )
			{
			continue;
			}

		//	check for file/path collisions against all other instances
		//
		//		check for temp database collisions
		//		check for log-path collisions
		//		check for system-path collisions

		//	if temp. database will be created,
		//	check for temp database collisions

		const BOOL	fTempDbForCurrInst	= ( g_rgpinst[ ipinst ]->m_lTemporaryTablesMax > 0
											&& !g_rgpinst[ ipinst ]->FRecovering() );
		if ( fTempDbForCurrInst && fTempDbForThisInst )
			{
			Call( pfsapi->ErrPathComplete( g_rgpinst[ ipinst ]->m_szTempDatabase, rgchFullNameExist ) );
			if ( JET_errSuccess == ( errFullPath = pfsapi->ErrPathComplete( pinst->m_szTempDatabase, rgchFullNameNew ) ) )
				{
				if ( !UtilCmpFileName( rgchFullNameExist, rgchFullNameNew ) )
					{
					err = ErrERRCheck( JET_errTempPathInUse );
					break;
					}
				}
			else
				{
				Assert( JET_errInvalidPath == errFullPath );	//	our instance has a bad temp db name/path
				}
			}

		//	don't require checkpoint file or logfiles if log is disabled
		if ( !g_rgpinst[ ipinst ]->FComputeLogDisabled()
			&& fRecoveryForThisInst )
			{

			//	check for system path collisions

			Call( pfsapi->ErrPathComplete( g_rgpinst[ ipinst ]->m_szSystemPath, rgchFullNameExist ) );
			if ( JET_errSuccess == ( errFullPath = pfsapi->ErrPathComplete( pinst->m_szSystemPath, rgchFullNameNew ) ) )
				{
				if ( !UtilCmpFileName( rgchFullNameExist, rgchFullNameNew ) )
					{
					err = ErrERRCheck( JET_errSystemPathInUse );
					break;
					}
				}
			else
				{
				Assert( JET_errInvalidPath == errFullPath );	//	our instance has a bad system path
				}

			Call( pfsapi->ErrPathComplete( g_rgpinst[ ipinst ]->m_plog->m_szLogFilePath, rgchFullNameExist ) );
			if ( JET_errSuccess == ( errFullPath = pfsapi->ErrPathComplete( pinst->m_plog->m_szLogFilePath, rgchFullNameNew ) ) )
				{
				if ( !UtilCmpFileName( rgchFullNameExist, rgchFullNameNew ) )
					{
					err = ErrERRCheck( JET_errLogFilePathInUse );
					break;
					}
				}
			else
				{
				Assert( JET_errInvalidPath == errFullPath );	//	our instance has a bad log path
				}
			}
		}

	INST::LeaveCritInst();

HandleError:

	delete pfsapi;
	return err;
	}

BOOL FUtilFileOnlyName( const char * szFileName)
	{
	char *szFound;

	OSSTRCharFindA( szFileName, bPathDelimiter, &szFound );
	if ( szFound )
		{
		return fFalse;
		}

	OSSTRCharFindA( szFileName, ':', &szFound );
	if ( szFound )
		{
		return fFalse;
		}

	return fTrue;
	}




/*=================================================================
ErrInit

Description:
  This function initializes Jet and the built-in ISAM.	It expects the
  DS register to be set correctly for this instance.

Return Value:
  JET_errSuccess if the routine can perform all operations cleanly;
  some appropriate error value otherwise.

=================================================================*/

LOCAL JET_ERR ErrInit(	INST		*pinst,
						BOOL		fSkipIsamInit,
						JET_GRBIT	grbit )
	{
	JET_ERR		err;

	Assert( !pinst->m_fJetInitialized );
	Assert( !pinst->m_fTermInProgress );

	if ( FUtilFileOnlyName( pinst->m_szTempDatabase ) )
		{
		char	szT[IFileSystemAPI::cchPathMax];

		//	the temporary database doesn't have a valid path
		//	use the system path as a default location (sys-path + '\' + tmpdbname + NULL)

		const DWORD cchSystemPath	= LOSSTRLengthA( pinst->m_szSystemPath );
		const DWORD cchTempPath		= LOSSTRLengthA( pinst->m_szTempDatabase );

		if ( cchSystemPath + 1 + cchTempPath + 1 > IFileSystemAPI::cchPathMax )
			{
			return ErrERRCheck( JET_errOutOfMemory );
			}

		//	copy temp database filename

		OSSTRCopyA( szT, pinst->m_szTempDatabase );

		//	construct full temp db name/path

		CallR( pinst->m_pfsapi->ErrPathBuild(
					pinst->m_szSystemPath,
					szT,
					NULL,
					pinst->m_szTempDatabase ) );
		}

	//	check for name/path collisions

	Call( ErrCheckUniquePath( pinst ) );

	/*	initialize the integrated ISAM
	/**/
	if ( !fSkipIsamInit )
		{
		Call( ErrIsamInit( JET_INSTANCE( pinst ), grbit ) );
		}

	return JET_errSuccess;

HandleError:
	Assert( err < 0 );
	return err;
	}


/*=================================================================
ErrSetSystemParameter

Description:
  This function sets system parameter values.  It calls ErrSetGlobalParameter
  to set global system parameters and ErrSetSessionParameter to set dynamic
  system parameters.

Parameters:
  sesid 		is the optional session identifier for dynamic parameters.
  sysParameter	is the system parameter code identifying the parameter.
  lParam		is the parameter value.
  sz			is the zero terminated string parameter.

Return Value:
  JET_errSuccess if the routine can perform all operations cleanly;
  some appropriate error value otherwise.

Errors/Warnings:
  JET_errInvalidParameter:
	Invalid parameter code.
  JET_errAlreadyInitialized:
	Initialization parameter cannot be set after the system is initialized.
  JET_errInvalidSesid:
	Dynamic parameters require a valid session id.

Side Effects: None
=================================================================*/

VOID SetCbPageRelated()
	{
	g_cbColumnLVChunkMost = g_cbPage - JET_cbColumnLVPageOverhead;

	g_cbLVBuf = 8 * g_cbColumnLVChunkMost;

	if ( 2048 == g_cbPage )
		{
		g_shfCbPage	= 11;
		}
	else if ( 8192 == g_cbPage )
		{
		g_shfCbPage	= 13;
		}
	else
		{
		Assert( 4096 == g_cbPage );
		g_shfCbPage	= 12;
		}

	cbRECRecordMost = REC::CbRecordMax();
#ifdef INTRINSIC_LV
	cbLVIntrinsicMost = cbRECRecordMost - sizeof(REC::cbRecordHeader) - sizeof(TAGFLD) - sizeof(TAGFLD_HEADER);
#endif INTRINSIC_LV
	}


// Allowed only from a general point of view, at other leveles (like BF)
// the SetSystemParam call may fail if an instance is running
LOCAL BOOL FAllowSetGlobalSysParamAfterStart( unsigned long paramid )
	{
	switch ( paramid )
		{
		case JET_paramCacheSizeMin:
		case JET_paramCacheSize:
		case JET_paramCacheSizeMax:
		case JET_paramCheckpointDepthMax:
		case JET_paramLRUKCorrInterval:
		case JET_paramLRUKHistoryMax:
		case JET_paramLRUKPolicy:
		case JET_paramLRUKTimeout:
		case JET_paramLRUKTrxCorrInterval:
		case JET_paramOutstandingIOMax:
		case JET_paramStartFlushThreshold:
		case JET_paramStopFlushThreshold:
		case JET_paramTableClassName:
		case JET_paramAssertAction:
		case JET_paramExceptionAction:
		case JET_paramPageHintCacheSize:
		case JET_paramOSSnapshotTimeout:
			return fTrue;
		}

	return fFalse;
	}

LOCAL ERR ErrAPICheckInstInit( const INST * const pinst )
	{
	Assert( pinstNil != pinst );
	return ( pinst->m_fJetInitialized ?
					ErrERRCheck( JET_errAlreadyInitialized ) :
					JET_errSuccess );
	}

LOCAL ERR ErrAPICheckSomeInstInit()
	{
	return ( FINSTSomeInitialized() ?
					ErrERRCheck( JET_errAlreadyInitialized ) :
					JET_errSuccess );
	}

ERR ErrSetSystemParameter(
	JET_INSTANCE	jinst,
	JET_SESID		sesid,
	unsigned long	paramid,
	ULONG_PTR		ulParam,
	const char  	*sz )
	{
	ERR				err 	= JET_errSuccess;
	INST			*pinst 	= (INST *)jinst;

	IFileSystemAPI* pfsapi	= NULL;

	//
	//	NOTE: this function verifies that multiple instances do not use the same paths
	//		  it checks the paths using the OS file-system because the OS file-system
	//			  is the only one that is used with these paths
	//

	Call( ErrOSFSCreate( pinst, &pfsapi ) );

#ifdef DEBUG
	if ( !pinst )
		{
		Assert( RUNINSTGetMode() == runInstModeNoSet
			|| FAllowSetGlobalSysParamAfterStart( paramid )
			|| !g_fSystemInit // during IsamSystemInit (ErrOSUConfigInit) we may set global params
			);
		}
	else
		{
		Assert( !sesid
			|| JET_sesidNil == sesid
			|| pinst == PinstFromPpib( (PIB *)sesid ) );
		}
#endif

	//	size of string argument
	//
	unsigned		cch;
	//	temporary string for path verification
	//
	CHAR			szT[IFileSystemAPI::cchPathMax];

	switch ( paramid )
		{
	case JET_paramSystemPath:

		char *szSystemPath;

		if ( ( cch = (ULONG)strlen(sz) ) >= IFileSystemAPI::cchPathMax )
			{
			Call( ErrERRCheck( JET_errInvalidParameter ) );
			}
		if ( pinst )
			{
			//	path to the checkpoint file
			//
			Call( ErrAPICheckInstInit( pinst ) );
			szSystemPath = pinst->m_szSystemPath;
			}
		else
			{
			szSystemPath = g_szSystemPath;
			}

		//	verify validity of path (always uses the OS file-system)
		//
		Call( pfsapi->ErrPathComplete( sz, szT ) );
		cch = (ULONG)strlen( szT );

		//	ensure there's enough room to append the name of the
		//	checkpoint file (+1 in case a trailing path delimiter
		//	is required)
		if ( cch + 1 + cbUnpathedFilenameMax >= IFileSystemAPI::cchPathMax )
			{
			Call( ErrERRCheck( JET_errInvalidParameter ) );
			}

		UtilMemCpy( szSystemPath, szT, cch + 1 );
        if ( !FOSSTRTrailingPathDelimiter( szSystemPath ) )
			{
			//	path must be '\\' terminated
			OSSTRAppendPathDelimiter( szSystemPath, fFalse );
			}
		break;

	case JET_paramTempPath:

		char * 		szTempDatabase;

		cch = (ULONG)strlen( sz );
		if ( cch >= IFileSystemAPI::cchPathMax )
			{
			Call( ErrERRCheck( JET_errInvalidParameter ) );
			}

		//	path to the temporary file directory
		//
		if ( pinst )
			{
			Call( ErrAPICheckInstInit( pinst ) );
			szTempDatabase = pinst->m_szTempDatabase;
			}
		else
			{
			szTempDatabase = g_szTempDatabase;
			}

		//	verify validity of path (always uses the OS file-system)
		//
		Call( pfsapi->ErrPathComplete( sz, szT ) );
		cch = (ULONG)strlen( szT );

		if ( FOSSTRTrailingPathDelimiter( const_cast< char * >( sz ) ) )
			{
			// If there's a trailing backslash, then this is a directory and
			// we must tack on the file name.

			// If user-specified directory had a trailing backslash, then the
			// fullpathed() directory should have one as well.
			Assert( FOSSTRTrailingPathDelimiter( szT ) );

			// Check that appending the filename doesn't exceed the maximum
			// Can't be equal to IFileSystemAPI::cchPathMax because IFileSystemAPI::cchPathMax includes the
			// null terminator.
			if ( cch + cbUnpathedFilenameMax >= IFileSystemAPI::cchPathMax )
				{
				Call( ErrERRCheck( JET_errInvalidParameter ) );
				}

			Call( pfsapi->ErrPathBuild( szT, szDefaultTempDbFileName, szDefaultTempDbExt, szTempDatabase ) );
			}
		else if ( FUtilFileOnlyName( sz ) )
			{
			// if only a file name specified, the file will get
			// created in the system directory (see ErrInit())
			UtilMemCpy( szTempDatabase, sz, strlen( sz ) + 1 );
			}
		else
			{
			if ( cch >= IFileSystemAPI::cchPathMax )
				{
				Call( ErrERRCheck( JET_errInvalidParameter ) );
				}

			// If no trailing backslash, then this is the pathed filename of
			// the temporary database.
			UtilMemCpy( szTempDatabase, szT, cch + 1 );
			}
		break;

	case JET_paramCreatePathIfNotExist:
		if ( pinst )
			pinst->m_fCreatePathIfNotExist = ( ulParam ? fTrue : fFalse );
		else
			g_fCreatePathIfNotExist = ( ulParam ? fTrue : fFalse );
		break;

	case JET_paramDbExtensionSize:				/* database expansion steps, default is 16 pages */
		if ( ulParam >= LONG_MAX || ulParam == 0 )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		if ( pinst )
			pinst->m_cpgSESysMin = (CPG)ulParam;
		else
			g_cpgSESysMin = (CPG)ulParam;
		break;

	case JET_paramPageReadAheadMax:	//	UNDONE: remove this parameter
///		Call( ErrERRCheck( JET_errInvalidParameter ) );
		break;

	case JET_paramPageTempDBMin:
		if ( ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		if ( pinst )
			pinst->m_cpageTempDBMin = (CPG)ulParam;
		else
			g_cpageTempDBMin = (CPG)ulParam;
		break;

	case JET_paramEnableTempTableVersioning:	/* version all temp table operations */
		if ( pinst )
			pinst->m_fTempTableVersioning = ( ulParam ? fTrue : fFalse );
		else
			g_fTempTableVersioning = ( ulParam ? fTrue : fFalse );
		break;

	case JET_paramZeroDatabaseDuringBackup:	/* zero deleted records/orphaned LVs during backup */
		if ( pinst )
			pinst->m_plog->m_fScrubDB = ulParam ? fTrue:fFalse;
		else
			g_fScrubDB = ulParam ? fTrue:fFalse;

		break;

	case JET_paramSLVDefragFreeThreshold:
		if ( pinst )
			{
			pinst->m_lSLVDefragFreeThreshold = (LONG)ulParam;
			}
		else
			{
			g_lSLVDefragFreeThreshold = (LONG)ulParam;
			}
		break;

	case JET_paramSLVDefragMoveThreshold:
		if( pinst )
			{
			pinst->m_lSLVDefragMoveThreshold = (LONG)ulParam;
			}
		else
			{
			g_lSLVDefragMoveThreshold = (LONG)ulParam;
			}
		break;

	case JET_paramIgnoreLogVersion:
		Call( ErrAPICheckSomeInstInit() );
		if ( pinst )
			{
			pinst->m_plog->m_fLGIgnoreVersion = ( ulParam ? fTrue : fFalse );
			}
		else
			{
			g_fLGIgnoreVersion = ( ulParam ? fTrue : fFalse );
			}
		break;

	case JET_paramCheckFormatWhenOpenFail:		/* check format number when db/log open fails */
/*
 * This is no longer a system param - we ALWAYS do this check on open failure
 *
		g_fCheckFormatWhenOpenFail = ( ulParam ? fTrue : fFalse );
*
*/
		break;
	case JET_paramMaxSessions:					/* Maximum number of sessions */
		if ( ulParam > cpibMax )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		if ( pinst )
			pinst->m_lSessionsMax = (LONG)ulParam;
		else
			g_lSessionsMax = (LONG)ulParam;
		break;

	case JET_paramMaxOpenTables:				/* Maximum number of open tables */
		if ( ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		if ( pinst )
			pinst->m_lOpenTablesMax = (LONG)ulParam;
		else
			g_lOpenTablesMax = (LONG)ulParam;
		break;

	case JET_paramPreferredMaxOpenTables:	/* Preferred maximum number of open tables */
		if ( ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		if ( pinst )
			pinst->m_lOpenTablesPreferredMax = (LONG)ulParam;
		else
			g_lOpenTablesPreferredMax = (LONG)ulParam;
		break;

	case JET_paramMaxTemporaryTables:
		if ( ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		if ( pinst )
			pinst->m_lTemporaryTablesMax = (LONG)ulParam;
		else
			g_lTemporaryTablesMax = (LONG)ulParam;
		break;

	case JET_paramMaxCursors:					/* maximum number of open cursors */
		if ( ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		if ( pinst )
			pinst->m_lCursorsMax = (LONG)ulParam;
		else
			g_lCursorsMax = (LONG)ulParam;
		break;

	case JET_paramMaxVerPages:					/* Maximum number of modified pages */
		{
		if ( 0 == ulParam || ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		const ULONG cbucket = ULONG( 1 + ( ulParam * 16 * 1024 - 1 ) / cbBucket );
		if ( pinst )
			{
			Call( ErrAPICheckInstInit( pinst ) );
			pinst->m_lVerPagesMax = cbucket;
			if ( ! pinst->m_fPreferredSetByUser )
				{
				// if user hasn't set InstancePrefer, set to same as max
				// for clients that aren't InstancePrefer "aware".
				pinst->m_lVerPagesPreferredMax = LONG( pinst->m_lVerPagesMax * ((double)g_lVerPagesPreferredMax / g_lVerPagesMax) );
				}
			}
		else
			{
			g_lVerPagesMax = cbucket;
			if ( ! g_fGlobalMinSetByUser )
				{
				// if user hasn't set GlobalMin, set to same as max
				// for clients that aren't GlobalMin "aware".
				g_lVerPagesMin = cbucket;
				}
			if ( ! g_fGlobalPreferredSetByUser	)
				{
				// if user hasn't set GlobalPrefer, set to same as max
				// for clients that aren't GlobalPrefer "aware".
				g_lVerPagesPreferredMax = LONG( g_lVerPagesMax * 0.9 );
				}
			}
		}
		break;

	case JET_paramGlobalMinVerPages:			/* Global minimum number of modified pages for all instances */
		{
		if ( 0 == ulParam || ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		const ULONG cbucket = ULONG( 1 + ( ulParam * 16 * 1024 - 1 ) / cbBucket );
		if ( pinst )
			{
			Call( ErrERRCheck( JET_errInvalidParameter ) );
			}
		else
			{
			g_fGlobalMinSetByUser = fTrue;
			g_lVerPagesMin = cbucket;
			}
		}
		break;

	case JET_paramPreferredVerPages:			/* Preferred number of modified pages */
		{
		if ( 0 == ulParam || ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		const ULONG cbucket = ULONG( 1 + ( ulParam * 16 * 1024 - 1 ) / cbBucket );
		if ( pinst )
			{
			pinst->m_fPreferredSetByUser = fTrue;
			pinst->m_lVerPagesPreferredMax = cbucket;
			}
		else
			{
			g_fGlobalPreferredSetByUser = fTrue;
			g_lVerPagesPreferredMax = cbucket;
			}
		}
		break;

	case JET_paramLogBuffers:
		if ( ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );

		if (pinst)
			{
			pinst->m_lLogBuffers = (LONG)ulParam;
			if ( pinst->m_lLogBuffers < lLogBufferMin )
				pinst->m_lLogBuffers = lLogBufferMin;
			}
		else
			{
			g_lLogBuffers = (LONG)ulParam;
			if ( g_lLogBuffers < lLogBufferMin )
				g_lLogBuffers = lLogBufferMin;
			}
		break;

	case JET_paramLogFileSize:
		{
		LONG	lLogFileSize	= (LONG)ulParam;

		if ( ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );

		if ( lLogFileSize < lLogFileSizeMin )
			lLogFileSize = lLogFileSizeMin;

		if ( pinst )
			{
			Call( ErrAPICheckInstInit( pinst ) );
			pinst->m_lLogFileSize = lLogFileSize;
			pinst->m_fSetLogFileSize = fTrue;
			}
		else
			{
			g_lLogFileSize = lLogFileSize;
			g_fSetLogFileSize = fTrue;
			}
		}
		break;

	case JET_paramLogCheckpointPeriod:
		//  no longer used
		break;

	case JET_paramWaitLogFlush:
		//  no longer used
		break;

	case JET_paramCommitDefault:
		//	validate grbits before setting them as defaults
		if ( ulParam & ~(JET_bitCommitLazyFlush|JET_bitWaitLastLevel0Commit) )
			Call( ErrERRCheck( JET_errInvalidParameter ) );

		if ( 0 == sesid || JET_sesidNil == sesid )
			{
			if ( pinst )
				pinst->m_grbitsCommitDefault = (LONG)ulParam;
			else
				g_grbitsCommitDefault = (LONG)ulParam;
			}
		else
			{
			CallS( ErrIsamSetCommitDefault( sesid, (LONG)ulParam ) );
			}
		break;

	case JET_paramLogWaitingUserMax:
		//  no longer used
		break;

	case JET_paramLogFilePath:

		char *szLogFilePath;

		//	path to the log file directory
		//
		if ( ( cch = (ULONG)strlen(sz) ) >= cbFilenameMost )
			{
			Call( ErrERRCheck( JET_errInvalidParameter ) );
			}
		if ( pinst )
			{
			//	path to the checkpoint file
			//
			Call( ErrAPICheckInstInit( pinst ) );
			szLogFilePath = pinst->m_plog->m_szLogFilePath;
			}
		else
			{
			szLogFilePath = g_szLogFilePath;
			}

		//	verify validity of path (always uses the OS file-system)
		//
		Call( pfsapi->ErrPathComplete( sz, szT ) );
		cch = (ULONG)strlen( szT );

		//	ensure there's enough room to append the name of the
		//	log files (+1 in case a trailing path delimiter
		//	is required)
		if ( cch + 1 + cbUnpathedFilenameMax >= IFileSystemAPI::cchPathMax )
			{
			Call( ErrERRCheck( JET_errInvalidParameter ) );
			}

		UtilMemCpy( szLogFilePath, szT, cch + 1 );
		if ( !FOSSTRTrailingPathDelimiter( szLogFilePath ) )
			{
			//	path must be '\\' terminated
			OSSTRAppendPathDelimiter( szLogFilePath, fFalse );
			}
		break;

	case JET_paramAlternateDatabaseRecoveryPath:
		{
		CHAR *	szDbRecoveryPath;

		//	path to look for dirty-shutdown databases during recovery
		//
		if ( ( cch = (ULONG)strlen(sz) ) >= cbFilenameMost )
			{
			Call( ErrERRCheck( JET_errInvalidParameter ) );
			}
		if ( pinstNil != pinst )
			{
			//	path to the checkpoint file
			//
			Call( ErrAPICheckInstInit( pinst ) );
			szDbRecoveryPath = pinst->m_plog->m_szAlternateDbDirDuringRecovery;
			}
		else
			{
			szDbRecoveryPath = g_szAlternateDbDirDuringRecovery;
			}

		//	verify validity of path (always uses the OS file-system)
		//
		Call( pfsapi->ErrPathComplete( sz, szT ) );
		cch = (ULONG)strlen( szT );

		//	ensure there's enough room to append the name of the
		//	database (+1 in case a trailing path delimiter
		//	is required)
		//	UNDONE: assumes 12.3 filename for the database
		//
		if ( cch + 1 + cbUnpathedFilenameMax >= IFileSystemAPI::cchPathMax )
			{
			Call( ErrERRCheck( JET_errInvalidParameter ) );
			}

		UtilMemCpy( szDbRecoveryPath, szT, cch + 1 );
		if ( !FOSSTRTrailingPathDelimiter( szDbRecoveryPath ) )
			{
			//	path must be '\\' terminated
			OSSTRAppendPathDelimiter( szDbRecoveryPath, fFalse );
			}

		//	set flag indicating alternate database recovery path is enabled
		//
		if ( pinstNil != pinst )
			{
			pinst->m_plog->m_fAlternateDbDirDuringRecovery = fTrue;
			}
		else
			{
			g_fAlternateDbDirDuringRecovery = fTrue;
			}

		break;
		}

	case JET_paramRecovery:			/* Switch for recovery on/off */
		if ( ( cch = (ULONG)strlen( sz ) ) >= cbFilenameMost )
			Call( ErrERRCheck( JET_errInvalidParameter ) );

		if ( 0 == strcmp( sz, "ESEUTIL" ) )
			{
			//	hack to allow us to know that this process is ESEUTIL
			fGlobalEseutil = fTrue;
			}
		else if ( pinst )
			{
			Assert (pinst->m_plog);
			UtilMemCpy( pinst->m_plog->m_szRecovery, sz, cch + 1 );
			}
		else
			{
			UtilMemCpy( g_szRecovery, sz, cch + 1 );
			}
		break;

	case JET_paramEventLogCache:
		Call( ErrAPICheckSomeInstInit() );
		if ( ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		g_cbEventHeapMax = (LONG)ulParam;
		break;

	case JET_paramBackupChunkSize:
		Call( ErrAPICheckSomeInstInit() );
		if ( 0 == ulParam || ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		g_cpgBackupChunk = (CPG)ulParam;
		break;

	case JET_paramBackupOutstandingReads:
		Call( ErrAPICheckSomeInstInit() );
		if ( 0 == ulParam || ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		g_cBackupRead = (LONG)ulParam;
		break;

	case JET_paramExceptionAction:
#ifdef CATCH_EXCEPTIONS
		Call( ErrAPICheckSomeInstInit() );
		g_fCatchExceptions = ( JET_ExceptionMsgBox == ulParam );
#else  //  !CATCH_EXCEPTIONS
		Call( ErrERRCheck( JET_errInvalidParameter ) );
#endif	//	CATCH_EXCEPTIONS
		break;

	case JET_paramPageFragment:
		if ( ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		if ( pinst )
			pinst->m_lPageFragment = (LONG)ulParam;
		else
			g_lPageFragment = (LONG)ulParam;
		break;

	case JET_paramVersionStoreTaskQueueMax:
		if ( ulParam >= cpibSystemFudge )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		if ( pinst )
			{
			Assert( NULL != pinst->m_pver );
			Call( ErrAPICheckInstInit( pinst ) );
			pinst->m_pver->m_ulVERTasksPostMax = (ULONG)ulParam;
			}
		else
			{
			g_ulVERTasksPostMax = (ULONG)ulParam;
			}
		break;

	case JET_paramDeleteOldLogs:
		if ( pinst )
			{
			Assert( NULL != pinst->m_plog );
			Call( ErrAPICheckInstInit( pinst ) );
			pinst->m_plog->m_fDeleteOldLogs = ( ulParam ? fTrue : fFalse );
			}
		else
			{
			g_fDeleteOldLogs = ( ulParam ? fTrue : fFalse );
			}
		break;

	case JET_paramDeleteOutOfRangeLogs:
		if ( pinst )
			{
			Assert( NULL != pinst->m_plog );
			Call( ErrAPICheckInstInit( pinst ) );
			pinst->m_plog->m_fDeleteOutOfRangeLogs = ( ulParam ? fTrue : fFalse );
			}
		else
			{
			g_fDeleteOutOfRangeLogs = ( ulParam ? fTrue : fFalse );
			}
		break;

	case JET_paramAccessDeniedRetryPeriod:
		//	silently cap retry period at 1 minute
		IFileSystemAPI::cmsecAccessDeniedRetryPeriod = (ULONG)min( ulParam, 60000 );
		break;

	case JET_paramEnableOnlineDefrag:
		if ( pinst )
			pinst->m_fOLDLevel = (LONG)ulParam;
		else
			g_fGlobalOLDLevel = (LONG)ulParam;
		break;

	case JET_paramAssertAction:
		g_wAssertAction = (UINT)ulParam;
		break;

	case JET_paramCircularLog:
		if ( pinst )
			{
			Call( ErrAPICheckInstInit( pinst ) );
			Assert ( NULL != pinst->m_plog );
			pinst->m_plog->m_fLGCircularLogging = ( ulParam ? fTrue : fFalse );
			}
		else
			{
			g_fLGCircularLogging = ( ulParam ? fTrue : fFalse );
			}
		break;

#ifdef RFS2
	case JET_paramRFS2AllocsPermitted:
		if ( ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		g_fDisableRFS = fFalse;
		g_cRFSAlloc = (LONG)ulParam;
		break;

	case JET_paramRFS2IOsPermitted:
		if ( ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		g_fDisableRFS = fFalse;
		g_cRFSIO = (LONG)ulParam;
		break;
#endif

	case JET_paramBaseName:
		{
		if ( strlen(sz) != 3 )
			Call( ErrERRCheck( JET_errInvalidParameter ) );

		if ( pinst )
			{
			LOG		* plog	= pinst->m_plog;

			Call( ErrAPICheckInstInit( pinst ) );

			strcpy( plog->m_szBaseName, sz );

			strcpy( plog->m_szJet, sz );

			strcpy( plog->m_szJetLog, sz );
			strcat( plog->m_szJetLog, szLogExt );

			strcpy( plog->m_szJetLogNameTemplate, sz );
			strcat( plog->m_szJetLogNameTemplate, "00000" );

			strcpy( plog->m_szJetTmp, sz );
			strcat( plog->m_szJetTmp, "tmp" );

			strcpy( plog->m_szJetTmpLog, plog->m_szJetTmp );
			strcat( plog->m_szJetTmpLog, szLogExt );

//			UNDONE: No point setting szJetTxt on a
//			per-instance basis because the print
//			function (DBGFPrintF) does not take an INST
//			strcpy( pinst->m_szJetTxt, sz );
//			strcat( pinst->m_szJetTxt, ".txt" );
			}
		else
			{
			strcpy( szBaseName, sz );

			strcpy( szJet, sz );

			strcpy( szJetLog, sz );
			strcat( szJetLog, szLogExt );

			strcpy( szJetLogNameTemplate, sz );
			strcat( szJetLogNameTemplate, "00000" );

			strcpy( szJetTmp, sz );
			strcat( szJetTmp, "tmp" );

			strcpy( szJetTmpLog, szJetTmp );
			strcat( szJetTmpLog, szLogExt );

			strcpy( szJetTxt, sz );
			strcat( szJetTxt, ".txt" );
			}
		break;
		}

	case JET_paramBatchIOBufferMax:
		break;

	case JET_paramCacheSizeMin:
		Call( ErrBFSetCacheSizeMin( ulParam ) );
		break;

	case JET_paramCacheSize:
		Call( ErrBFSetCacheSize( ulParam ) );
		break;

	case JET_paramCacheSizeMax:
		Call( ErrBFSetCacheSizeMax( ulParam ) );
		break;

	case JET_paramCheckpointDepthMax:
		Call( ErrBFSetCheckpointDepthMax( ulParam ) );
		break;

	case JET_paramLRUKCorrInterval:
		Call( ErrBFSetLRUKCorrInterval( ulParam ) );
		break;

	case JET_paramLRUKHistoryMax:
		break;

	case JET_paramLRUKPolicy:
		Call( ErrBFSetLRUKPolicy( ulParam ) );
		break;

	case JET_paramLRUKTimeout:
		Call( ErrBFSetLRUKTimeout( ulParam ) );
		break;

	case JET_paramLRUKTrxCorrInterval:
		break;

	case JET_paramOutstandingIOMax:
		break;

	case JET_paramStartFlushThreshold:
		Call( ErrBFSetStartFlushThreshold( ulParam ) );
		break;

	case JET_paramStopFlushThreshold:
		Call( ErrBFSetStopFlushThreshold( ulParam ) );
		break;

	case JET_paramTableClassName:
		break;

	case JET_paramEnableIndexChecking:
		if ( pinstNil != pinst )
			pinst->m_fEnableIndexChecking = (LONG)ulParam;
		else
			g_fEnableIndexChecking = (LONG)ulParam;
		break;

	case JET_paramEnableIndexCleanup:
		if ( pinstNil != pinst )
			pinst->m_fEnableIndexCleanup = (LONG)ulParam;
		else
			g_fEnableIndexCleanup = (LONG)ulParam;
		break;

	case JET_paramLogFileFailoverPath:

		char *szLogFileFailoverPath;

		if ( ( cch = (ULONG)strlen(sz) ) >= cbFilenameMost )
			{
			Call( ErrERRCheck( JET_errInvalidParameter ) );
			}
		if ( pinst )
			{
			//	path to the checkpoint file
			//
			Call( ErrAPICheckInstInit( pinst ) );

//	UNDONE: m_szLogFileFailoverPath has been removed from LOG
//	until the functionality is actually enabled
//			szLogFileFailoverPath = pinst->m_plog->m_szLogFileFailoverPath;
			szLogFileFailoverPath = g_szLogFileFailoverPath;
			}
		else
			{
			szLogFileFailoverPath = g_szLogFileFailoverPath;
			}

		//	verify validity of path (always uses the OS file-system)

		Call( pfsapi->ErrPathComplete( sz, szT ) );
		cch = (ULONG)strlen( szT );

		UtilMemCpy( szLogFileFailoverPath, szT, cch + 1 );
		if ( !FOSSTRTrailingPathDelimiter( szLogFileFailoverPath ) )
			{
			//	path must be '\\' terminated
			if ( cch+1 >= IFileSystemAPI::cchPathMax )
				{
				Call( ErrERRCheck( JET_errInvalidParameter ) );
				}
			OSSTRAppendPathDelimiter( szLogFileFailoverPath, fFalse );
			}
		break;

	case JET_paramLogFileCreateAsynch:
		if ( pinst )
			{
			Call( ErrAPICheckInstInit( pinst ) );
			pinst->m_plog->m_fCreateAsynchLogFile = ulParam ? fTrue : fFalse;
			}
		else
			{
			g_fLogFileCreateAsynch = ulParam ? fTrue : fFalse;
			}
		break;

	case JET_paramEnableImprovedSeekShortcut:
		Call( ErrAPICheckSomeInstInit() );
		//  defunct
		break;

	case JET_paramEnableSortedRetrieveColumns:
		Call( ErrAPICheckSomeInstInit() );
		//	defunct
		break;

	case JET_paramDatabasePageSize:
		Call( ErrAPICheckSomeInstInit() );
		if ( ulParam != 2048 && ulParam != 4096 && ulParam != 8192 )
			Call( ErrERRCheck( JET_errInvalidParameter) );
		g_cbPage = (LONG)ulParam;
		SetCbPageRelated();

#ifdef DEBUG
		g_fCbPageSet = fTrue;
#endif // DEBUG
		break;

	case JET_paramEventSource:

		char *szEventSource;

		if ( ( cch = (ULONG)strlen( sz ) ) >= cbFilenameMost )
			Call( ErrERRCheck( JET_errInvalidParameter ) );

		if ( pinst )
			{
			Call( ErrAPICheckInstInit( pinst ) );
			szEventSource = pinst->m_szEventSource;
			}
		else
			{
			szEventSource = g_szEventSource;
			}

		UtilMemCpy( szEventSource, sz, cch + 1 );
		break;

	case JET_paramEventSourceKey:

		char *szEventSourceKey;

		if ( ( cch = (ULONG)strlen( sz ) ) >= cbFilenameMost )
			Call( ErrERRCheck( JET_errInvalidParameter ) );

		if ( pinst )
			{
			Call( ErrAPICheckInstInit( pinst ) );
			szEventSourceKey = pinst->m_szEventSourceKey;
			}
		else
			{
			szEventSourceKey = g_szEventSourceKey;
			}

		UtilMemCpy( szEventSourceKey, sz, cch + 1 );
		break;

	case JET_paramNoInformationEvent:
		if ( pinst )
			pinst->m_fNoInformationEvent = ( ulParam ? fTrue : fFalse );
		else
			g_fNoInformationEvent = ( ulParam ? fTrue : fFalse );
		break;

	case JET_paramEventLoggingLevel:
		if ( ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		if ( pinst )
			pinst->m_lEventLoggingLevel = (LONG)ulParam;
		else
			g_lEventLoggingLevel = (LONG)ulParam;
		break;

	case JET_paramDisableCallbacks:
		Call( ErrAPICheckSomeInstInit() );
		g_fCallbacksDisabled = ( ulParam ? fTrue : fFalse );
		break;

	case JET_paramSLVProviderEnable:
		if ( pinst )
			{
			Call( ErrAPICheckInstInit( pinst ) );
			pinst->m_fSLVProviderEnabled = ( ulParam ? fTrue : fFalse );
			}
		else
			{
			g_fSLVProviderEnabled = ( ulParam ? fTrue : fFalse );
			}
		break;

	case JET_paramRuntimeCallback:
		if ( pinst )
			{
			Call( ErrAPICheckInstInit( pinst ) );
			pinst->m_pfnRuntimeCallback = (JET_CALLBACK)ulParam;
			}
		else
			{
			g_pfnRuntimeCallback = (JET_CALLBACK)ulParam;
			}
		Call( ( *(JET_CALLBACK)ulParam )(		//	make dummy call to callback to verify its existence
						JET_sesidNil,
						JET_dbidNil,
						JET_tableidNil,
						JET_cbtypNull,
						NULL,
						NULL,
						NULL,
						NULL ) );
		break;

	case JET_paramUnicodeIndexDefault:
		{
		IDXUNICODE	idxunicode	= *(IDXUNICODE *)ulParam;

		Call( ErrFILEICheckUserDefinedUnicode( pinstNil, &idxunicode ) );
		if ( pinstNil != pinst )
			{
			pinst->m_idxunicodeDefault = idxunicode;
			}
		else
			{
			g_idxunicodeDefault = idxunicode;
			}

		break;
		}

	case JET_paramIndexTuplesLengthMin:
		if ( 0 != ulParam
			&& ( ulParam < chIDXTuplesLengthMinAbsolute || ulParam > chIDXTuplesLengthMaxAbsolute ) )
			{
			Call( ErrERRCheck( JET_errIndexTuplesInvalidLimits ) );
			}

		if ( pinst )
			{
			pinst->m_chIndexTuplesLengthMin = (ULONG)( 0 == ulParam ? chIDXTuplesLengthMinDefault : ulParam );
			}
		else
			{
			g_chIndexTuplesLengthMin = (ULONG)( 0 == ulParam ? chIDXTuplesLengthMinDefault : ulParam );
			}
		break;

	case JET_paramIndexTuplesLengthMax:
		if ( 0 != ulParam
			&& ( ulParam < chIDXTuplesLengthMinAbsolute || ulParam > chIDXTuplesLengthMaxAbsolute ) )
			{
			Call( ErrERRCheck( JET_errIndexTuplesInvalidLimits ) );
			}

		if ( pinst )
			{
			pinst->m_chIndexTuplesLengthMax = (ULONG)( 0 == ulParam ? chIDXTuplesLengthMaxDefault : ulParam );
			}
		else
			{
			g_chIndexTuplesLengthMax = (ULONG)( 0 == ulParam ? chIDXTuplesLengthMaxDefault : ulParam );
			}
		break;

	case JET_paramIndexTuplesToIndexMax:
		if ( ulParam > chIDXTuplesToIndexMaxAbsolute )
			{
			Call( ErrERRCheck( JET_errIndexTuplesInvalidLimits ) );
			}

		if ( pinst )
			{
			pinst->m_chIndexTuplesToIndexMax = (ULONG)( 0 == ulParam ? chIDXTuplesToIndexMaxDefault : ulParam );
			}
		else
			{
			g_chIndexTuplesToIndexMax = (ULONG)( 0 == ulParam ? chIDXTuplesToIndexMaxDefault : ulParam );
			}
		break;

	case JET_paramPageHintCacheSize:
		if ( ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		Call( ErrAPICheckSomeInstInit() );
		g_cbPageHintCache = (LONG)ulParam;
		break;

	case JET_paramRecordUpgradeDirtyLevel:
		switch( ulParam )
			{
			case 0:
				CPAGE::bfdfRecordUpgradeFlags = bfdfClean;
				break;
			case 1:
				CPAGE::bfdfRecordUpgradeFlags = bfdfUntidy;
				break;
			case 2:
				CPAGE::bfdfRecordUpgradeFlags = bfdfDirty;
				break;
			case 3:
				CPAGE::bfdfRecordUpgradeFlags = bfdfFilthy;
				break;
			default:
				Call( ErrERRCheck( JET_errInvalidParameter ) );
				break;
			}
		break;

	case JET_paramRecoveryCurrentLogfile:
		AssertSz( fFalse, "JET_paramRecoveryCurrentLogfile cannot be set, only retrieved" );
		Call( ErrERRCheck( JET_errInvalidParameter ) );
		break;

	case JET_paramReplayingReplicatedLogfiles:
		if ( pinst )
			{
			pinst->m_plog->m_fReplayingReplicatedLogFiles = ( ulParam ? fTrue : fFalse );
			}
		else
			{
			Call( ErrERRCheck( JET_errInvalidParameter ) );
			}
		break;

	case JET_paramCleanupMismatchedLogFiles:
		if ( pinst )
			{
			Call( ErrAPICheckInstInit( pinst ) );
			pinst->m_fCleanupMismatchedLogFiles = ( ulParam ? fTrue : fFalse );
			}
		else
			{
			g_fCleanupMismatchedLogFiles = ( ulParam ? fTrue : fFalse );
			}
		break;

	case JET_paramOneDatabasePerSession:
		Call( ErrAPICheckSomeInstInit() );
		g_fOneDatabasePerSession = ( ulParam ? fTrue : fFalse );
		break;

	case JET_paramOSSnapshotTimeout:
		Call( ErrOSSnapshotSetTimeout( ulParam ) );
		break;

	case JET_paramMaxInstances:
		if ( ulParam < 1 || ulParam > cMaxInstances )
			Call( ErrERRCheck( JET_errInvalidParameter ) );

		Call( ErrAPICheckSomeInstInit() );

		g_cMaxInstancesRequestedByUser = (ULONG)ulParam;
		break;

	case JET_paramMaxDatabasesPerInstance:
		if ( ulParam < 1 || ulParam > cMaxDatabasesPerInstance )
			Call( ErrERRCheck( JET_errInvalidParameter ) );

		Call( ErrAPICheckSomeInstInit() );

//		dbidMax = (ULONG)ulParam;
		break;

	default:
		Call( ErrERRCheck( JET_errInvalidParameter ) );
		}

	err = JET_errSuccess;

HandleError:
	delete pfsapi;
	return err;
	}

LOCAL ERR ErrGetSystemParameter(
	JET_INSTANCE	jinst,
	JET_SESID		sesid,
	unsigned long	paramid,
	ULONG_PTR		*plParam,
	char			*sz,
	unsigned long	cbMax )
	{
	int				cch;
	INST			*pinst = (INST *)jinst;

	Assert( !jinst
		|| 0 == sesid
		|| JET_sesidNil == sesid
		|| pinst == PinstFromPpib( (PIB *)sesid ) );


	switch ( paramid )
		{
	case JET_paramSystemPath:
		//	path to the checkpoint file
		//
			{
			char *szFrom;
			szFrom = (pinst)?pinst->m_szSystemPath:g_szSystemPath;
			Assert (szFrom);

			cch = (ULONG)strlen(szFrom) + 1;
			if ( cch > (int)cbMax )
				cch = (int)cbMax;
			UtilMemCpy( sz, szFrom, cch );
			sz[cch - 1] = '\0';
			}
			break;

	case JET_paramTempPath:
		//	path to the temporary file directory
		//
			{
			char *szFrom;
			szFrom = (pinst)?pinst->m_szTempDatabase:g_szTempDatabase;
			Assert (szFrom);

			cch = (ULONG)strlen(szFrom) + 1;
			if ( cch > (int)cbMax )
				cch = (int)cbMax;
			UtilMemCpy( sz, szFrom, cch );
			sz[cch - 1] = '\0';
			}
		break;

	case JET_paramCreatePathIfNotExist:
		if ( plParam == NULL )
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = ( pinst ? pinst->m_fCreatePathIfNotExist : g_fCreatePathIfNotExist );
		break;

	case JET_paramDbExtensionSize:		/* database expansion steps, default is 16 pages */
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = ( pinst ? pinst->m_cpgSESysMin : g_cpgSESysMin );
		break;

	case JET_paramPageReadAheadMax:
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = 0;
		break;

	case JET_paramPageTempDBMin:
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = (pinst)?pinst->m_cpageTempDBMin:g_cpageTempDBMin;
		break;

	case JET_paramEnableTempTableVersioning:	/* version all temp table operations */
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = (pinst)?pinst->m_fTempTableVersioning:g_fTempTableVersioning;
		break;

	case JET_paramZeroDatabaseDuringBackup:	/* version all temp table operations */
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = (pinst)?pinst->m_plog->m_fScrubDB:g_fScrubDB;
		break;

	case JET_paramSLVDefragFreeThreshold:
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = (pinst)?pinst->m_lSLVDefragFreeThreshold:g_lSLVDefragFreeThreshold;
		break;

	case JET_paramSLVDefragMoveThreshold:
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = (pinst)?pinst->m_lSLVDefragMoveThreshold:g_lSLVDefragMoveThreshold;
		break;

	case JET_paramIgnoreLogVersion:
		if (plParam == NULL )
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = ( pinst ? pinst->m_plog->m_fLGIgnoreVersion : g_fLGIgnoreVersion );
		break;

	case JET_paramCheckFormatWhenOpenFail:		/* check format number when db/log open fails */
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
/*
 * This is no longer a system param - we ALWAYS do this check on open failure
 */
//		*plParam = g_fCheckFormatWhenOpenFail;

		*plParam = fTrue;
		break;

	case JET_paramMaxSessions:     /* Maximum number of sessions */
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = (pinst)?pinst->m_lSessionsMax:g_lSessionsMax;
		break;

	case JET_paramMaxOpenTables:   /* Maximum number of open tables */
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = (pinst)?pinst->m_lOpenTablesMax:g_lOpenTablesMax;
		break;

	case JET_paramPreferredMaxOpenTables:   /* Preferred maximum number of open tables */
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = (pinst)?pinst->m_lOpenTablesPreferredMax:g_lOpenTablesPreferredMax;
		break;

	case JET_paramMaxTemporaryTables:
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = (pinst)?pinst->m_lTemporaryTablesMax:g_lTemporaryTablesMax;
		break;

	case JET_paramMaxVerPages:     /* Maximum number of modified pages */
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = ((pinst)?pinst->m_lVerPagesMax:g_lVerPagesMax) * (cbBucket / 16384);
		break;

	case JET_paramGlobalMinVerPages:	/* Global minimum number of modified pages for all instances */
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		if ( NULL != pinst )
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = g_lVerPagesMin * (cbBucket / 16384);
		break;

	case JET_paramPreferredVerPages:     /* Preferred number of modified pages */
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = ((pinst)?pinst->m_lVerPagesPreferredMax:g_lVerPagesPreferredMax) * (cbBucket / 16384);
		break;

	case JET_paramMaxCursors:      /* maximum number of open cursors */
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = (pinst)?pinst->m_lCursorsMax:g_lCursorsMax;
		break;

	case JET_paramLogBuffers:
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = (pinst)?pinst->m_lLogBuffers:g_lLogBuffers;
		break;

	case JET_paramLogFileSize:
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = (pinst)?pinst->m_lLogFileSize:g_lLogFileSize;
		break;

	case JET_paramLogFilePath:     /* Path to the log file directory */
			{
			char *szFrom;
			if (pinst)
				{
				Assert(pinst->m_plog);
				szFrom = pinst->m_plog->m_szLogFilePath;
				}
			else
				{
				szFrom = g_szLogFilePath;
				}

			Assert(szFrom);
			cch = (ULONG)strlen(szFrom) + 1;
			if ( cch > (int)cbMax )
				cch = (int)cbMax;
			UtilMemCpy( sz,  szFrom, cch  );
			sz[cch-1] = '\0';
			}
		break;

	case JET_paramAlternateDatabaseRecoveryPath:
			{
			CHAR *	szFrom;

			if ( pinstNil != pinst )
				{
				Assert( NULL != pinst->m_plog );
				szFrom = pinst->m_plog->m_szAlternateDbDirDuringRecovery;
				}
			else
				{
				szFrom = g_szLogFilePath;
				}

			Assert( NULL != szFrom );
			cch = (ULONG)strlen( szFrom ) + 1;
			if ( cch > (INT)cbMax )
				cch = (INT)cbMax;

			UtilMemCpy( sz, szFrom, cch );
			sz[cch-1] = '\0';
			}
		break;

	case JET_paramRecovery:
			{
			char *szFrom;
			if (pinst)
				{
				Assert(pinst->m_plog);
				szFrom = pinst->m_plog->m_szRecovery;
				}
			else
				{
				szFrom = g_szRecovery;
				}
			Assert(szFrom);

			cch = (ULONG)strlen(szFrom) + 1;
			if ( cch > (int)cbMax )
				cch = (int)cbMax;
			UtilMemCpy( sz,  szFrom, cch  );
			sz[cch-1] = '\0';
			}
		break;

	case JET_paramEventLogCache:
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = g_cbEventHeapMax;
		break;

	case JET_paramExceptionAction:
#ifdef CATCH_EXCEPTIONS
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = ( g_fCatchExceptions ) ? JET_ExceptionMsgBox : JET_ExceptionNone;
#else  //  !CATCH_EXCEPTIONS
		return ErrERRCheck( JET_errInvalidParameter );
#endif	//	CATCH_EXCEPTIONS
		break;

#ifdef DEBUG
	case JET_paramTransactionLevel:
		ErrIsamGetTransaction( sesid, plParam );
		break;

	case JET_paramPrintFunction:
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
#ifdef _WIN64
		//	UNDONE: Must change lParam to a ULONG_PTR
		*plParam = NULL;
		return ErrERRCheck( JET_wrnNyi );
#else
		*plParam = (ULONG_PTR)DBGFPrintF;
		break;
#endif

#endif	//	DEBUG

	case JET_paramCommitDefault:
		if ( plParam == NULL )
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = ( pinst ? pinst->m_grbitsCommitDefault : g_grbitsCommitDefault );
		break;

	case JET_paramPageFragment:
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = ( pinst ? pinst->m_lPageFragment : g_lPageFragment );
		break;

	case JET_paramVersionStoreTaskQueueMax:
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = ( pinst ? pinst->m_pver->m_ulVERTasksPostMax : g_ulVERTasksPostMax );
		break;

	case JET_paramDeleteOldLogs:
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = ( pinst ? pinst->m_plog->m_fDeleteOldLogs : g_fDeleteOldLogs );
		break;

	case JET_paramDeleteOutOfRangeLogs:
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = ( pinst ? pinst->m_plog->m_fDeleteOutOfRangeLogs : g_fDeleteOutOfRangeLogs );
		break;

	case JET_paramAccessDeniedRetryPeriod:
		//	silently cap retry period at 1 minute
		if ( NULL == plParam )
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = IFileSystemAPI::cmsecAccessDeniedRetryPeriod;
		break;

	case JET_paramEnableOnlineDefrag:
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = ( pinst ? pinst->m_fOLDLevel : g_fGlobalOLDLevel );
		break;

	case JET_paramCircularLog:
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		if ( pinst )
			{
			Assert ( NULL != pinst->m_plog );
			*plParam = pinst->m_plog->m_fLGCircularLogging;
			}
		else
			{
			*plParam = g_fLGCircularLogging;
			}
		break;

#ifdef RFS2
	case JET_paramRFS2AllocsPermitted:
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = g_cRFSAlloc;
		break;

	case JET_paramRFS2IOsPermitted:
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = g_cRFSIO;
		break;
#endif

	case JET_paramBaseName:
		cch = (ULONG)strlen( pinst ? pinst->m_plog->m_szBaseName : szBaseName ) + 1;
		if (cch > (int)cbMax)
			cch = (int)cbMax;
		UtilMemCpy( sz, ( pinst ? pinst->m_plog->m_szBaseName : szBaseName ), cch );
		sz[cch-1] = '\0';
		break;

	case JET_paramBatchIOBufferMax:
		break;

	case JET_paramCacheSizeMin:
		return ErrBFGetCacheSizeMin( plParam );

	case JET_paramCacheSize:
		return ErrBFGetCacheSize( plParam );

	case JET_paramCacheSizeMax:
		return ErrBFGetCacheSizeMax( plParam );

	case JET_paramCheckpointDepthMax:
		return ErrBFGetCheckpointDepthMax( plParam );

	case JET_paramLRUKCorrInterval:
		return ErrBFGetLRUKCorrInterval( plParam );

	case JET_paramLRUKHistoryMax:
		*plParam = 0;
		break;

	case JET_paramLRUKPolicy:
		return ErrBFGetLRUKPolicy( plParam );

	case JET_paramLRUKTimeout:
		return ErrBFGetLRUKTimeout( plParam );

	case JET_paramLRUKTrxCorrInterval:
		*plParam = 0;
		break;

	case JET_paramOutstandingIOMax:
		break;

	case JET_paramStartFlushThreshold:
		return ErrBFGetStartFlushThreshold( plParam );

	case JET_paramStopFlushThreshold:
		return ErrBFGetStopFlushThreshold( plParam );

	case JET_paramTableClassName:
		memset( sz, 0, cbMax );
		break;

	case JET_paramCacheRequests:
		{
		*plParam = 0;
		return JET_errSuccess;
		}

	case JET_paramCacheHits:
		{
		*plParam = 0;
		return JET_errSuccess;
		}

	case JET_paramEnableIndexChecking:
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = ( pinstNil != pinst ? pinst->m_fEnableIndexChecking : g_fEnableIndexChecking );
		break;

	case JET_paramEnableIndexCleanup:
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = ( pinstNil != pinst ? pinst->m_fEnableIndexCleanup : g_fEnableIndexCleanup );
		break;

	case JET_paramLogFileFailoverPath:
			{
			char *szFrom;
			if (pinst)
				{
				Assert(pinst->m_plog);
//	UNDONE: m_szLogFileFailoverPath has been removed from LOG
//	until the functionality is actually enabled
//				szFrom = pinst->m_plog->m_szLogFileFailoverPath;
				szFrom = g_szLogFileFailoverPath;
				}
			else
				{
				szFrom = g_szLogFileFailoverPath;
				}
			Assert(szFrom);
			cch = (ULONG)strlen(szFrom) + 1;
			if ( cch > (int)cbMax )
				cch = (int)cbMax;
			UtilMemCpy( sz,  szFrom, cch  );
			sz[cch-1] = '\0';
			}
		break;

	case JET_paramLogFileCreateAsynch:
		if ( !plParam )
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = pinst ? pinst->m_plog->m_fCreateAsynchLogFile : g_fLogFileCreateAsynch;
		break;

	case JET_paramEnableImprovedSeekShortcut:
		*plParam = fFalse;  //  defunct
		break;

	case JET_paramEnableSortedRetrieveColumns:
		*plParam = fFalse;	//	defunct;
		break;

	case JET_paramDatabasePageSize:
		*plParam = g_cbPage;
		break;

	case JET_paramEventSource:
			{
			char *szFrom;
			szFrom = (pinst) ?pinst->m_szEventSource:g_szEventSource;
			Assert(szFrom);

			cch = (ULONG)strlen(szFrom) + 1;
			if (cch > (int)cbMax)
				cch = (int)cbMax;
			UtilMemCpy( sz, szFrom, cch );
			sz[cch-1] = '\0';
			}
		break;

	case JET_paramEventSourceKey:
			{
			char *szFrom;
			szFrom = (pinst) ?pinst->m_szEventSourceKey:g_szEventSourceKey;
			Assert(szFrom);
			cch = (ULONG)strlen(szFrom) + 1;
			if (cch > (int)cbMax)
				cch = (int)cbMax;
			UtilMemCpy( sz, szFrom, cch );
			sz[cch-1] = '\0';
			}
		break;

	case JET_paramNoInformationEvent:
		*plParam = ( pinst ? pinst->m_fNoInformationEvent : g_fNoInformationEvent );
		break;

	case JET_paramEventLoggingLevel:
		if (plParam == NULL)
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}
		*plParam = (pinst)? pinst->m_lEventLoggingLevel : g_lEventLoggingLevel;
		break;

	case JET_paramDisableCallbacks:
		*plParam = g_fCallbacksDisabled;
		break;

	case JET_paramBackupChunkSize:
		*plParam = g_cpgBackupChunk;
		break;

	case JET_paramBackupOutstandingReads:
		*plParam = g_cBackupRead;
		break;

	case JET_paramErrorToString:
		{
		if( NULL == plParam )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}

		const ERR err = *((ERR *)plParam);
		const CHAR * const szSep = ", ";

		const CHAR * szError;
		const CHAR * szErrorText;
		JetErrorToString( err, &szError, &szErrorText );

		cch = (ULONG)(strlen( szError ) + strlen( szErrorText ) + strlen( szSep ));
		if (cch > cbMax)
			{
			return ErrERRCheck( JET_errBufferTooSmall );
			}
		sz[0] = 0;
		strcat( sz, szError );
		strcat( sz, szSep );
		strcat( sz, szErrorText );
		break;
		}

	case JET_paramSLVProviderEnable:
		*plParam = (pinst)?pinst->m_fSLVProviderEnabled:g_fSLVProviderEnabled;
		break;

	case JET_paramRuntimeCallback:
		*plParam = (ULONG_PTR)( pinstNil == pinst ? g_pfnRuntimeCallback : pinst->m_pfnRuntimeCallback );
		break;

	case JET_paramUnicodeIndexDefault:
		if ( cbMax < sizeof(JET_UNICODEINDEX) )
			return ErrERRCheck( JET_errBufferTooSmall );

		*(IDXUNICODE *)plParam = ( pinstNil != pinst ? pinst->m_idxunicodeDefault : g_idxunicodeDefault );
		break;

	case JET_paramIndexTuplesLengthMin:
		if ( NULL == plParam )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}
		*plParam = ( pinst ? pinst->m_chIndexTuplesLengthMin : g_chIndexTuplesLengthMin );
		break;

	case JET_paramIndexTuplesLengthMax:
		if ( NULL == plParam )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}
		*plParam = ( pinst ? pinst->m_chIndexTuplesLengthMax : g_chIndexTuplesLengthMax );
		break;

	case JET_paramIndexTuplesToIndexMax:
		if ( NULL == plParam )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}
		*plParam = ( pinst ? pinst->m_chIndexTuplesToIndexMax : g_chIndexTuplesToIndexMax );
		break;

	case JET_paramPageHintCacheSize:
		*plParam = ULONG_PTR( g_cbPageHintCache );
		break;

	case JET_paramRecordUpgradeDirtyLevel:
		switch( CPAGE::bfdfRecordUpgradeFlags )
			{
			case bfdfClean:
				*plParam = 0;
				break;
			case bfdfUntidy:
				*plParam = 1;
				break;
			case bfdfDirty:
				*plParam = 2;
				break;
			case bfdfFilthy:
				*plParam = 3;
				break;
			default:
				AssertSz( fFalse, "Unknown BFDirtyFlag" );
				return ErrERRCheck( JET_errInternalError );
				break;
			}
		break;

	case JET_paramRecoveryCurrentLogfile:
		if ( pinst )
			{
			*plParam = ( pinst->m_plog->m_plgfilehdr ) ? pinst->m_plog->m_plgfilehdr->lgfilehdr.le_lGeneration : 0;
			}
		else
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}
		break;

	case JET_paramReplayingReplicatedLogfiles:
		if ( pinst )
			{
			*plParam = pinst->m_plog->m_fReplayingReplicatedLogFiles;
			}
		else
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}
		break;

	case JET_paramCleanupMismatchedLogFiles:
		if ( !plParam )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}
		*plParam = ULONG_PTR( pinst ? pinst->m_fCleanupMismatchedLogFiles : g_fCleanupMismatchedLogFiles );
		break;

	case JET_paramOSSnapshotTimeout:
		return ErrOSSnapshotGetTimeout( plParam );
		break;

	case JET_paramMaxInstances:
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );

		//	WARNING: this value will not match the
		//	current max. instances in effect if
		//	we're running in single-instance mode
		//	(this system param only controls max.
		//	instances for multi-instance mode)
		*plParam = g_cMaxInstancesRequestedByUser;
		break;

	case JET_paramMaxDatabasesPerInstance:
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = dbidMax;
		break;

	default:
		return ErrERRCheck( JET_errInvalidParameter );
		}

	return JET_errSuccess;
	}


extern "C" {

/***********************************************************************/
/***********************  JET API FUNCTIONS  ***************************/
/***********************************************************************/

/*	APICORE.CPP
 */


/*=================================================================
JetIdle

Description:
  Performs idle time processing.

Parameters:
  sesid			uniquely identifies session
  grbit			processing options

Return Value:
  Error code

Errors/Warnings:
  JET_errSuccess		some idle processing occurred
  JET_wrnNoIdleActivity no idle processing occurred
=================================================================*/

LOCAL JET_ERR JetIdleEx( JET_SESID sesid, JET_GRBIT grbit )
	{
	APICALL_SESID	apicall( opIdle );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrIsamIdle( sesid, grbit ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetIdle( JET_SESID sesid, JET_GRBIT grbit )
	{
	JET_TRY( JetIdleEx( sesid, grbit ) );
	}


LOCAL JET_ERR JetGetTableIndexInfoEx(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szIndexName,
	void			*pvResult,
	unsigned long	cbResult,
	unsigned long	InfoLevel )
	{
	ERR				err;
	ULONG			cbMin;
	APICALL_SESID	apicall( opGetTableIndexInfo );

	if ( !apicall.FEnter( sesid ) )
		return apicall.ErrResult();

	FillClientBuffer( pvResult, cbResult );

	switch( InfoLevel )
		{
		case JET_IdxInfo:
		case JET_IdxInfoList:
			cbMin = sizeof(JET_INDEXLIST) - cbIDXLISTNewMembersSinceOriginalFormat;
			break;
		case JET_IdxInfoSpaceAlloc:
		case JET_IdxInfoCount:
			cbMin = sizeof(ULONG);
			break;
		case JET_IdxInfoLangid:
			cbMin = sizeof(LANGID);
			break;
		case JET_IdxInfoVarSegMac:
			cbMin = sizeof(USHORT);
			break;
		case JET_IdxInfoIndexId:
			cbMin = sizeof(INDEXID);
			break;

		case JET_IdxInfoSysTabCursor:
		case JET_IdxInfoOLC:
		case JET_IdxInfoResetOLC:
			AssertTracking();
			err = ErrERRCheck( JET_errFeatureNotAvailable );
			goto HandleError;

		default:
			err = ErrERRCheck( JET_errInvalidParameter );
			goto HandleError;
		}

	if ( cbResult >= cbMin )
		{
		err = ErrDispGetTableIndexInfo(
					sesid,
					tableid,
					szIndexName,
					pvResult,
					cbResult,
					InfoLevel );
		}
	else
		{
		err = ErrERRCheck( JET_errBufferTooSmall );
		}

HandleError:
	apicall.LeaveAfterCall( err );
	return apicall.ErrResult();
	}

JET_ERR JET_API JetGetTableIndexInfo(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szIndexName,
	void			*pvResult,
	unsigned long	cbResult,
	unsigned long	InfoLevel )
	{
	JET_TRY( JetGetTableIndexInfoEx( sesid, tableid, szIndexName, pvResult, cbResult, InfoLevel ) );
	}


LOCAL JET_ERR JetGetIndexInfoEx(
	JET_SESID		sesid,
	JET_DBID		ifmp,
	const char		*szTableName,
	const char		*szIndexName,
	void			*pvResult,
	unsigned long	cbResult,
	unsigned long	InfoLevel )
	{
	ERR				err;
	ULONG			cbMin;
	APICALL_SESID	apicall( opGetIndexInfo );

	if ( !apicall.FEnter( sesid ) )
		return apicall.ErrResult();

	FillClientBuffer( pvResult, cbResult );

	switch( InfoLevel )
		{
		case JET_IdxInfo:
		case JET_IdxInfoList:
			cbMin = sizeof(JET_INDEXLIST) - cbIDXLISTNewMembersSinceOriginalFormat;
			break;
		case JET_IdxInfoSpaceAlloc:
		case JET_IdxInfoCount:
			cbMin = sizeof(ULONG);
			break;
		case JET_IdxInfoLangid:
			cbMin = sizeof(LANGID);
			break;
		case JET_IdxInfoVarSegMac:
			cbMin = sizeof(USHORT);
			break;
		case JET_IdxInfoIndexId:
			cbMin = sizeof(INDEXID);
			break;

		case JET_IdxInfoSysTabCursor:
		case JET_IdxInfoOLC:
		case JET_IdxInfoResetOLC:
			AssertTracking();
			err = ErrERRCheck( JET_errFeatureNotAvailable );
			goto HandleError;

		default :
			err = ErrERRCheck( JET_errInvalidParameter );
			goto HandleError;
		}

	if ( cbResult >= cbMin )
		{
		err = ErrIsamGetIndexInfo(
					sesid,
					(JET_DBID)ifmp,
					szTableName,
					szIndexName,
					pvResult,
					cbResult,
					InfoLevel );
		}
	else
		{
		err = ErrERRCheck( JET_errBufferTooSmall );
		}

HandleError:
	apicall.LeaveAfterCall( err );
	return apicall.ErrResult();
	}

JET_ERR JET_API JetGetIndexInfo(
	JET_SESID		sesid,
	JET_DBID		ifmp,
	const char		*szTableName,
	const char		*szIndexName,
	void			*pvResult,
	unsigned long	cbResult,
	unsigned long	InfoLevel )
	{
	JET_TRY( JetGetIndexInfoEx( sesid, ifmp, szTableName, szIndexName, pvResult, cbResult, InfoLevel ) );
	}


LOCAL JET_ERR JetGetObjectInfoEx(
	JET_SESID		sesid,
	JET_DBID		ifmp,
	JET_OBJTYP		objtyp,
	const char		*szContainerName,
	const char		*szObjectName,
	void			*pvResult,
	unsigned long	cbMax,
	unsigned long	InfoLevel )
	{
	ERR				err;
	ULONG			cbMin;
	APICALL_SESID	apicall( opGetObjectInfo );

	if ( !apicall.FEnter( sesid ) )
		return apicall.ErrResult();

	FillClientBuffer( pvResult, cbMax );

	switch( InfoLevel )
		{
		case JET_ObjInfo:
		case JET_ObjInfoNoStats:
			cbMin = sizeof(JET_OBJECTINFO);
			break;
		case JET_ObjInfoListNoStats:
		case JET_ObjInfoList:
			cbMin = sizeof(JET_OBJECTLIST);
			break;

		case JET_ObjInfoSysTabCursor:
		case JET_ObjInfoSysTabReadOnly:
		case JET_ObjInfoListACM:
		case JET_ObjInfoRulesLoaded:
			AssertTracking();
			err = ErrERRCheck( JET_errFeatureNotAvailable );
			goto HandleError;

		default:
			err = ErrERRCheck( JET_errInvalidParameter );
			goto HandleError;
		}

	if ( cbMax >= cbMin )
		{
		err = ErrIsamGetObjectInfo(
					sesid,
					(JET_DBID)ifmp,
					objtyp,
					szContainerName,
					szObjectName,
					pvResult,
					cbMax,
					InfoLevel );
		}
	else
		{
		err = ErrERRCheck( JET_errBufferTooSmall );
		}

HandleError:
	apicall.LeaveAfterCall( err );
	return apicall.ErrResult();
	}

JET_ERR JET_API JetGetObjectInfo(
	JET_SESID		sesid,
	JET_DBID		ifmp,
	JET_OBJTYP		objtyp,
	const char		*szContainerName,
	const char		*szObjectName,
	void			*pvResult,
	unsigned long	cbMax,
	unsigned long	InfoLevel )
	{
	JET_TRY( JetGetObjectInfoEx( sesid, ifmp, objtyp, szContainerName, szObjectName, pvResult, cbMax, InfoLevel ) );
	}


LOCAL JET_ERR JetGetTableInfoEx(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	void			*pvResult,
	unsigned long	cbMax,
	unsigned long	InfoLevel )
	{
	APICALL_SESID	apicall( opGetTableInfo );

	if ( apicall.FEnter( sesid ) )
		{
		FillClientBuffer( pvResult, cbMax );
		apicall.LeaveAfterCall( ErrDispGetTableInfo(
										sesid,
										tableid,
										pvResult,
										cbMax,
										InfoLevel ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetGetTableInfo(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	void			*pvResult,
	unsigned long	cbMax,
	unsigned long	InfoLevel )
	{
	JET_TRY( JetGetTableInfoEx( sesid, tableid, pvResult, cbMax, InfoLevel ) );
	}


LOCAL JET_ERR JetBeginTransactionEx( JET_SESID sesid, JET_GRBIT grbit )
	{
	APICALL_SESID	apicall( opBeginTransaction );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrIsamBeginTransaction( sesid, grbit ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetBeginTransaction( JET_SESID sesid )
	{
	JET_TRY( JetBeginTransactionEx( sesid, NO_GRBIT ) );
	}
JET_ERR JET_API JetBeginTransaction2( JET_SESID sesid, JET_GRBIT grbit )
	{
	JET_TRY( JetBeginTransactionEx( sesid, grbit ) );
	}


LOCAL JET_ERR JetPrepareToCommitTransactionEx(
	JET_SESID		sesid,
	const void		* pvData,
	unsigned long	cbData,
	JET_GRBIT		grbit )
	{
	APICALL_SESID	apicall( opPrepareToCommitTransaction );

	if ( apicall.FEnter( sesid ) )
		{
#ifdef DTC
		//	grbit currently unsupported
		apicall.LeaveAfterCall( 0 != grbit ?
									ErrERRCheck( JET_errInvalidGrbit ) :
									ErrIsamPrepareToCommitTransaction( sesid, pvData, cbData ) );
#else
		apicall.LeaveAfterCall( ErrERRCheck( JET_errFeatureNotAvailable ) );
#endif
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetPrepareToCommitTransaction(
	JET_SESID		sesid,
	const void		* pvData,
	unsigned long	cbData,
	JET_GRBIT		grbit )
	{
	JET_TRY( JetPrepareToCommitTransactionEx( sesid, pvData, cbData, grbit ) );
	}


LOCAL JET_ERR JetCommitTransactionEx( JET_SESID sesid, JET_GRBIT grbit )
	{
	APICALL_SESID	apicall( opCommitTransaction );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( grbit & ~(JET_bitCommitLazyFlush|JET_bitWaitLastLevel0Commit|JET_bitWaitAllLevel0Commit) ?
										ErrERRCheck( JET_errInvalidGrbit ) :
										ErrIsamCommitTransaction( sesid, grbit ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetCommitTransaction( JET_SESID sesid, JET_GRBIT grbit )
	{
	JET_TRY( JetCommitTransactionEx( sesid, grbit ) );
	}


LOCAL JET_ERR JetRollbackEx( JET_SESID sesid, JET_GRBIT grbit )
	{
	APICALL_SESID	apicall( opRollback );

	if ( apicall.FEnter( sesid, fTrue ) )
		{
		apicall.LeaveAfterCall( grbit & ~JET_bitRollbackAll ?
										ErrERRCheck( JET_errInvalidGrbit ) :
										ErrIsamRollback( sesid, grbit ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetRollback( JET_SESID sesid, JET_GRBIT grbit )
	{
	JET_TRY( JetRollbackEx( sesid, grbit ) );
	}


LOCAL JET_ERR JetOpenTableEx(
	JET_SESID		sesid,
	JET_DBID		ifmp,
	const char		*szTableName,
	const void		*pvParameters,
	unsigned long	cbParameters,
	JET_GRBIT		grbit,
	JET_TABLEID		*ptableid )
	{
	APICALL_SESID	apicall( opOpenTable );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrIsamOpenTable(
										sesid,
										(JET_DBID)ifmp,
										ptableid,
										(CHAR *)szTableName,
										grbit ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetOpenTable(
	JET_SESID		sesid,
	JET_DBID		ifmp,
	const char		*szTableName,
	const void		*pvParameters,
	unsigned long	cbParameters,
	JET_GRBIT		grbit,
	JET_TABLEID		*ptableid )
	{
	JET_TRY( JetOpenTableEx( sesid, ifmp, szTableName, pvParameters, cbParameters, grbit, ptableid ) );
	}


//  ================================================================
LOCAL JET_ERR JetSetTableSequentialEx(
	const JET_SESID 	sesid,
	const JET_TABLEID	tableid,
	const JET_GRBIT 	grbit )
//  ================================================================
	{
	APICALL_SESID		apicall( opSetTableSequential );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispSetTableSequential( sesid, tableid, grbit ) );
		}

	return apicall.ErrResult();
	}
//  ================================================================
JET_ERR JET_API JetSetTableSequential(
	JET_SESID 	sesid,
	JET_TABLEID	tableid,
	JET_GRBIT	grbit )
//  ================================================================
	{
	JET_TRY( JetSetTableSequentialEx( sesid, tableid, grbit ) );
	}


//  ================================================================
LOCAL JET_ERR JetResetTableSequentialEx(
	JET_SESID	 	sesid,
	JET_TABLEID		tableid,
	JET_GRBIT	 	grbit )
//  ================================================================
	{
	APICALL_SESID	apicall( opResetTableSequential );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispResetTableSequential( sesid, tableid, grbit ) );
		}

	return apicall.ErrResult();
	}
//  ================================================================
JET_ERR JET_API JetResetTableSequential(
	JET_SESID 	sesid,
	JET_TABLEID	tableid,
	JET_GRBIT	grbit )
//  ================================================================
	{
	JET_TRY( JetResetTableSequentialEx( sesid, tableid, grbit ) );
	}

LOCAL JET_ERR JetRegisterCallbackEx(
	JET_SESID 		sesid,
	JET_TABLEID		tableid,
	JET_CBTYP		cbtyp,
	JET_CALLBACK	pCallback,
	VOID *			pvContext,
	JET_HANDLE		*phCallbackId )
	{
	APICALL_SESID	apicall( opRegisterCallback );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispRegisterCallback(
										sesid,
										tableid,
										cbtyp,
										pCallback,
										pvContext,
										phCallbackId ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetRegisterCallback(
	JET_SESID 		sesid,
	JET_TABLEID		tableid,
	JET_CBTYP		cbtyp,
	JET_CALLBACK	pCallback,
	VOID *			pvContext,
	JET_HANDLE		*phCallbackId )
	{
	JET_TRY( JetRegisterCallbackEx( sesid, tableid, cbtyp, pCallback, pvContext, phCallbackId ) );
	}


LOCAL JET_ERR JetUnregisterCallbackEx(
	JET_SESID 		sesid,
	JET_TABLEID		tableid,
	JET_CBTYP		cbtyp,
	JET_HANDLE		hCallbackId )
	{
	APICALL_SESID	apicall( opUnregisterCallback );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispUnregisterCallback(
										sesid,
										tableid,
										cbtyp,
										hCallbackId ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetUnregisterCallback(
	JET_SESID 		sesid,
	JET_TABLEID		tableid,
	JET_CBTYP		cbtyp,
	JET_HANDLE		hCallbackId )
	{
	JET_TRY( JetUnregisterCallbackEx( sesid, tableid, cbtyp, hCallbackId ) );
	}


LOCAL JET_ERR JetSetLSEx(
	JET_SESID 		sesid,
	JET_TABLEID		tableid,
	JET_LS			ls,
	JET_GRBIT		grbit )
	{
	APICALL_SESID	apicall( opSetLS );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispSetLS( sesid, tableid, ls, grbit ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetSetLS(
	JET_SESID 		sesid,
	JET_TABLEID		tableid,
	JET_LS			ls,
	JET_GRBIT		grbit )
	{
	JET_TRY( JetSetLSEx( sesid, tableid, ls, grbit ) );
	}


LOCAL JET_ERR JetGetLSEx(
	JET_SESID 		sesid,
	JET_TABLEID		tableid,
	JET_LS			*pls,
	JET_GRBIT		grbit )
	{
	APICALL_SESID	apicall( opGetLS );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispGetLS( sesid, tableid, pls, grbit ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetGetLS(
	JET_SESID 		sesid,
	JET_TABLEID		tableid,
	JET_LS			*pls,
	JET_GRBIT		grbit )
	{
	JET_TRY( JetGetLSEx( sesid, tableid, pls, grbit ) );
	}


LOCAL JET_ERR JetDupCursorEx(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_TABLEID		*ptableid,
	JET_GRBIT		grbit )
	{
	APICALL_SESID	apicall( opDupCursor );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispDupCursor( sesid, tableid, ptableid, grbit ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetDupCursor(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_TABLEID		*ptableid,
	JET_GRBIT		grbit )
	{
	JET_TRY( JetDupCursorEx( sesid, tableid, ptableid, grbit ) );
	}


LOCAL JET_ERR JetCloseTableEx( JET_SESID sesid, JET_TABLEID tableid )
	{
	APICALL_SESID	apicall( opCloseTable );

	if ( apicall.FEnter( sesid, fTrue ) )
		{
		apicall.LeaveAfterCall( ErrDispCloseTable( sesid, tableid ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetCloseTable( JET_SESID sesid, JET_TABLEID tableid )
	{
	JET_TRY( JetCloseTableEx( sesid, tableid ) );
	}


LOCAL JET_ERR JetGetTableColumnInfoEx(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*pColumnNameOrId,
	void			*pvResult,
	unsigned long	cbMax,
	unsigned long	InfoLevel )
	{
	ERR				err;
	ULONG			cbMin;
	APICALL_SESID	apicall( opGetTableColumnInfo );

	if ( !apicall.FEnter( sesid ) )
		return apicall.ErrResult();

	FillClientBuffer( pvResult, cbMax );

	switch( InfoLevel )
		{
		case JET_ColInfo:
		case JET_ColInfoByColid:
			cbMin = sizeof(JET_COLUMNDEF);
			break;
		case JET_ColInfoList:
		case JET_ColInfoListCompact:
		case 2:
		case JET_ColInfoListSortColumnid:
			cbMin = sizeof(JET_COLUMNLIST);
			break;
		case JET_ColInfoBase:
			cbMin = sizeof(JET_COLUMNBASE);
			break;

		case JET_ColInfoSysTabCursor:
			AssertTracking();
			err = ErrERRCheck( JET_errFeatureNotAvailable );
			goto HandleError;

		default:
			err = ErrERRCheck( JET_errInvalidParameter );
			goto HandleError;
		}

	if ( cbMax >= cbMin )
		{
		if ( InfoLevel == JET_ColInfoByColid )
			{
			err = ErrDispGetTableColumnInfo(
							sesid,
							tableid,
							NULL,
							(JET_COLUMNID *)pColumnNameOrId,
							pvResult,
							cbMax,
							InfoLevel );
			}
		else
			{
			err = ErrDispGetTableColumnInfo(
							sesid,
							tableid,
							pColumnNameOrId,
							NULL,
							pvResult,
							cbMax,
							InfoLevel );
			}
		}
	else
		{
		err = ErrERRCheck( JET_errBufferTooSmall );
		}

HandleError:
	apicall.LeaveAfterCall( err );
	return apicall.ErrResult();
	}

JET_ERR JET_API JetGetTableColumnInfo(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*pColumnNameOrId,
	void			*pvResult,
	unsigned long	cbMax,
	unsigned long	InfoLevel )
	{
	JET_TRY( JetGetTableColumnInfoEx( sesid, tableid, pColumnNameOrId, pvResult, cbMax, InfoLevel ) );
	}


LOCAL JET_ERR JetGetColumnInfoEx(
	JET_SESID		sesid,
	JET_DBID		ifmp,
	const char		*szTableName,
	const char		*pColumnNameOrId,
	void			*pvResult,
	unsigned long	cbMax,
	unsigned long	InfoLevel )
	{
	ERR				err;
	ULONG			cbMin;
	APICALL_SESID	apicall( opGetColumnInfo );

	if ( !apicall.FEnter( sesid ) )
		return apicall.ErrResult();

	FillClientBuffer( pvResult, cbMax );

	switch( InfoLevel )
		{
		case JET_ColInfo:
		case JET_ColInfoByColid:
			cbMin = sizeof(JET_COLUMNDEF);
			break;
		case JET_ColInfoList:
		case JET_ColInfoListCompact:
		case 2 :
		case JET_ColInfoListSortColumnid:
			cbMin = sizeof(JET_COLUMNLIST);
			break;
		case JET_ColInfoBase:
			cbMin = sizeof(JET_COLUMNBASE);
			break;

		case JET_ColInfoSysTabCursor:
			AssertTracking();
			err = ErrERRCheck( JET_errFeatureNotAvailable );
			goto HandleError;

		default:
			err = ErrERRCheck( JET_errInvalidParameter );
			goto HandleError;
		}

	if ( cbMax >= cbMin )
		{
		if ( InfoLevel == JET_ColInfoByColid )
			{
			err = ErrIsamGetColumnInfo(
							sesid,
							(JET_DBID)ifmp,
							szTableName,
							NULL,
							(JET_COLUMNID *)pColumnNameOrId,
							pvResult,
							cbMax,
							InfoLevel );
			}
		else
			{
			err = ErrIsamGetColumnInfo(
							sesid,
							(JET_DBID)ifmp,
							szTableName,
							pColumnNameOrId,
							NULL,
							pvResult,
							cbMax,
							InfoLevel );
			}
		}
	else
		{
		err = ErrERRCheck( JET_errBufferTooSmall );
		}

HandleError:
	apicall.LeaveAfterCall( err );
	return apicall.ErrResult();
	}

JET_ERR JET_API JetGetColumnInfo(
	JET_SESID		sesid,
	JET_DBID		ifmp,
	const char		*szTableName,
	const char		*pColumnNameOrId,
	void			*pvResult,
	unsigned long	cbMax,
	unsigned long	InfoLevel )
	{
	JET_TRY( JetGetColumnInfoEx( sesid, ifmp, szTableName, pColumnNameOrId, pvResult, cbMax, InfoLevel ) );
	}

LOCAL JET_ERR JetRetrieveColumnEx(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_COLUMNID	columnid,
	void			*pvData,
	unsigned long	cbData,
	unsigned long	*pcbActual,
	JET_GRBIT		grbit,
	JET_RETINFO		*pretinfo )
	{
	APICALL_SESID	apicall( opRetrieveColumn );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispRetrieveColumn(
										sesid,
										tableid,
										columnid,
										pvData,
										cbData,
										pcbActual,
										grbit,
										pretinfo ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetRetrieveColumn(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_COLUMNID	columnid,
	void			*pvData,
	unsigned long	cbData,
	unsigned long	*pcbActual,
	JET_GRBIT		grbit,
	JET_RETINFO		*pretinfo )
	{
	JET_TRY( JetRetrieveColumnEx( sesid, tableid, columnid, pvData, cbData, pcbActual, grbit, pretinfo ) );
	}


LOCAL JET_ERR JetRetrieveColumnsEx(
	JET_SESID			sesid,
	JET_TABLEID			tableid,
	JET_RETRIEVECOLUMN	*pretrievecolumn,
	unsigned long		cretrievecolumn )
	{
	APICALL_SESID		apicall( opRetrieveColumns );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispRetrieveColumns(
										sesid,
										tableid,
										pretrievecolumn,
										cretrievecolumn ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetRetrieveColumns(
	JET_SESID			sesid,
	JET_TABLEID			tableid,
	JET_RETRIEVECOLUMN	*pretrievecolumn,
	unsigned long		cretrievecolumn )
	{
	JET_TRY( JetRetrieveColumnsEx( sesid, tableid, pretrievecolumn, cretrievecolumn ) );
	}


LOCAL JET_ERR JetEnumerateColumnsEx(
	JET_SESID			sesid,
	JET_TABLEID			tableid,
	unsigned long		cEnumColumnId,
	JET_ENUMCOLUMNID*	rgEnumColumnId,
	unsigned long*		pcEnumColumn,
	JET_ENUMCOLUMN**	prgEnumColumn,
	JET_PFNREALLOC		pfnRealloc,
	void*				pvReallocContext,
	unsigned long		cbDataMost,
	JET_GRBIT			grbit )
	{
	APICALL_SESID		apicall( opEnumerateColumns );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispEnumerateColumns(
										sesid,
										tableid,
										cEnumColumnId,
										rgEnumColumnId,
										pcEnumColumn,
										prgEnumColumn,
										pfnRealloc,
										pvReallocContext,
										cbDataMost,
										grbit ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetEnumerateColumns(
	JET_SESID				sesid,
	JET_TABLEID				tableid,
	unsigned long			cEnumColumnId,
	JET_ENUMCOLUMNID*		rgEnumColumnId,
	unsigned long*			pcEnumColumn,
	JET_ENUMCOLUMN**		prgEnumColumn,
	JET_PFNREALLOC			pfnRealloc,
	void*					pvReallocContext,
	unsigned long			cbDataMost,
	JET_GRBIT				grbit )
	{
	JET_TRY( JetEnumerateColumnsEx(	sesid,
									tableid,
									cEnumColumnId,
									rgEnumColumnId,
									pcEnumColumn,
									prgEnumColumn,
									pfnRealloc,
									pvReallocContext,
									cbDataMost,
									grbit ) );
	}


LOCAL JET_ERR JetRetrieveTaggedColumnListEx(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	unsigned long	*pcColumns,
	void			*pvData,
	unsigned long	cbData,
	JET_COLUMNID	columnidStart,
	JET_GRBIT		grbit )
	{
	APICALL_SESID	apicall( opRetrieveTaggedColumnList );

	if ( apicall.FEnter( sesid ) )
		{
		FillClientBuffer( pvData, cbData, fTrue );
		apicall.LeaveAfterCall( ErrDispRetrieveTaggedColumnList(
										sesid,
										tableid,
										pcColumns,
										pvData,
										cbData,
										columnidStart,
										grbit ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetRetrieveTaggedColumnList(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	unsigned long	*pcColumns,
	void			*pvData,
	unsigned long	cbData,
	JET_COLUMNID	columnidStart,
	JET_GRBIT		grbit )
	{
	JET_TRY( JetRetrieveTaggedColumnListEx( sesid, tableid, pcColumns, pvData, cbData, columnidStart, grbit ) );
	}


LOCAL JET_ERR JetSetColumnEx(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_COLUMNID	columnid,
	const void		*pvData,
	unsigned long	cbData,
	JET_GRBIT		grbit,
	JET_SETINFO		*psetinfo )
	{
	APICALL_SESID	apicall( opSetColumn );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispSetColumn(
										sesid,
										tableid,
										columnid,
										pvData,
										cbData,
										grbit,
										psetinfo ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetSetColumn(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_COLUMNID	columnid,
	const void		*pvData,
	unsigned long	cbData,
	JET_GRBIT		grbit,
	JET_SETINFO		*psetinfo )
	{
	JET_TRY( JetSetColumnEx( sesid, tableid, columnid, pvData, cbData, grbit, psetinfo ) );
	}


LOCAL JET_ERR JetSetColumnsEx(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_SETCOLUMN	*psetcolumn,
	unsigned long	csetcolumn )
	{
	APICALL_SESID	apicall( opSetColumns );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispSetColumns(
										sesid,
										tableid,
										psetcolumn,
										csetcolumn ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetSetColumns(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_SETCOLUMN	*psetcolumn,
	unsigned long	csetcolumn )
	{
	JET_TRY( JetSetColumnsEx( sesid, tableid, psetcolumn, csetcolumn ) );
	}


LOCAL JET_ERR JetPrepareUpdateEx(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	unsigned long	prep )
	{
	APICALL_SESID	apicall( opPrepareUpdate );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispPrepareUpdate( sesid, tableid, prep ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetPrepareUpdate(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	unsigned long	prep )
	{
	JET_TRY( JetPrepareUpdateEx( sesid, tableid, prep ) );
	}


LOCAL JET_ERR JetUpdateEx(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	void			*pvBookmark,
	unsigned long	cbMax,
	unsigned long	*pcbActual,
	const JET_GRBIT	grbit )
	{
	APICALL_SESID	apicall( opUpdate );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispUpdate(
										sesid,
										tableid,
										pvBookmark,
										cbMax,
										pcbActual,
										grbit ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetUpdate(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	void			*pvBookmark,
	unsigned long	cbMax,
	unsigned long	*pcbActual )
	{
	JET_TRY( JetUpdateEx( sesid, tableid, pvBookmark, cbMax, pcbActual, NO_GRBIT ) );
	}
JET_ERR JET_API JetUpdate2(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	void			*pvBookmark,
	unsigned long	cbMax,
	unsigned long	*pcbActual,
	const JET_GRBIT	grbit )
	{
	JET_TRY( JetUpdateEx( sesid, tableid, pvBookmark, cbMax, pcbActual, grbit ) );
	}


LOCAL JET_ERR JetEscrowUpdateEx(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_COLUMNID	columnid,
	void			*pv,
	unsigned long	cbMax,
	void			*pvOld,
	unsigned long	cbOldMax,
	unsigned long	*pcbOldActual,
	JET_GRBIT		grbit )
	{
	APICALL_SESID	apicall( opEscrowUpdate );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispEscrowUpdate(
										sesid,
										tableid,
										columnid,
										pv,
										cbMax,
										pvOld,
										cbOldMax,
										pcbOldActual,
										grbit ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetEscrowUpdate(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_COLUMNID	columnid,
	void			*pv,
	unsigned long	cbMax,
	void			*pvOld,
	unsigned long	cbOldMax,
	unsigned long	*pcbOldActual,
	JET_GRBIT		grbit )
	{
	JET_TRY( JetEscrowUpdateEx( sesid, tableid, columnid, pv, cbMax, pvOld, cbOldMax, pcbOldActual, grbit ) );
	}


LOCAL JET_ERR JetDeleteEx( JET_SESID sesid, JET_TABLEID tableid )
	{
	APICALL_SESID	apicall( opDelete );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispDelete( sesid, tableid ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetDelete( JET_SESID sesid, JET_TABLEID tableid )
	{
	JET_TRY( JetDeleteEx( sesid, tableid ) );
	}


LOCAL JET_ERR JetGetCursorInfoEx(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	void			*pvResult,
	unsigned long	cbMax,
	unsigned long	InfoLevel )
	{
	APICALL_SESID	apicall( opGetCursorInfo );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispGetCursorInfo(
										sesid,
										tableid,
										pvResult,
										cbMax,
										InfoLevel ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetGetCursorInfo(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	void			*pvResult,
	unsigned long	cbMax,
	unsigned long	InfoLevel )
	{
	JET_TRY( JetGetCursorInfoEx( sesid, tableid, pvResult, cbMax, InfoLevel ) );
	}


LOCAL JET_ERR JetGetCurrentIndexEx(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	char			*szIndexName,
	unsigned long	cchIndexName )
	{
	APICALL_SESID	apicall( opGetCurrentIndex );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispGetCurrentIndex(
										sesid,
										tableid,
										szIndexName,
										cchIndexName ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetGetCurrentIndex(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	char			*szIndexName,
	unsigned long	cchIndexName )
	{
	JET_TRY( JetGetCurrentIndexEx( sesid, tableid, szIndexName, cchIndexName ) );
	}

LOCAL JET_ERR JetSetCurrentIndexEx(
	JET_SESID			sesid,
	JET_TABLEID			tableid,
	const CHAR			*szIndexName,
	const JET_INDEXID	*pindexid,
	const JET_GRBIT		grbit,
	const ULONG			itagSequence )
	{
	APICALL_SESID		apicall( opSetCurrentIndex );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( grbit & ~(JET_bitMoveFirst|JET_bitNoMove) ?
										ErrERRCheck( JET_errInvalidGrbit ) :
										ErrDispSetCurrentIndex( sesid, tableid, szIndexName, pindexid, grbit, itagSequence ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetSetCurrentIndex(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szIndexName )
	{
	JET_TRY( JetSetCurrentIndexEx( sesid, tableid, szIndexName, NULL, JET_bitMoveFirst, 1 ) );
	}
JET_ERR JET_API JetSetCurrentIndex2(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szIndexName,
	JET_GRBIT		grbit )
	{
	JET_TRY( JetSetCurrentIndexEx( sesid, tableid, szIndexName, NULL, grbit, 1 ) );
	}
JET_ERR JET_API JetSetCurrentIndex3(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szIndexName,
	JET_GRBIT		grbit,
	unsigned long	itagSequence )
	{
	JET_TRY( JetSetCurrentIndexEx( sesid, tableid, szIndexName, NULL, grbit, itagSequence ) );
	}
JET_ERR JET_API JetSetCurrentIndex4(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szIndexName,
	JET_INDEXID		*pindexid,
	JET_GRBIT		grbit,
	unsigned long	itagSequence )
	{
	JET_TRY( JetSetCurrentIndexEx( sesid, tableid, szIndexName, pindexid, grbit, itagSequence ) );
	}


LOCAL JET_ERR JetMoveEx(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	signed long		cRow,
	JET_GRBIT		grbit )
	{
	APICALL_SESID	apicall( opMove );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispMove( sesid, tableid, cRow, grbit ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetMove(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	signed long		cRow,
	JET_GRBIT		grbit )
	{
	JET_TRY( JetMoveEx( sesid, tableid, cRow, grbit ) );
	}


LOCAL JET_ERR JetMakeKeyEx(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const void		*pvData,
	unsigned long	cbData,
	JET_GRBIT		grbit )
	{
	APICALL_SESID	apicall( opMakeKey );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispMakeKey(
										sesid,
										tableid,
										pvData,
										cbData,
										grbit ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetMakeKey(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const void		*pvData,
	unsigned long	cbData,
	JET_GRBIT		grbit )
	{
	JET_TRY( JetMakeKeyEx( sesid, tableid, pvData, cbData, grbit ) );
	}


LOCAL JET_ERR JetSeekEx( JET_SESID sesid, JET_TABLEID tableid, JET_GRBIT grbit )
	{
	APICALL_SESID	apicall( opSeek );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispSeek( sesid, tableid, grbit ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetSeek( JET_SESID sesid, JET_TABLEID tableid, JET_GRBIT grbit )
	{
	JET_TRY( JetSeekEx( sesid, tableid, grbit ) );
	}


LOCAL JET_ERR JetGetBookmarkEx(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	void			*pvBookmark,
	unsigned long	cbMax,
	unsigned long	*pcbActual )
	{
	APICALL_SESID	apicall( opGetBookmark );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispGetBookmark(
										sesid,
										tableid,
										pvBookmark,
										cbMax,
										pcbActual ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetGetBookmark(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	void			*pvBookmark,
	unsigned long	cbMax,
	unsigned long	*pcbActual )
	{
	JET_TRY( JetGetBookmarkEx( sesid, tableid, pvBookmark, cbMax, pcbActual ) );
	}

JET_ERR JET_API JetGetSecondaryIndexBookmarkEx(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	void *			pvSecondaryKey,
	unsigned long	cbSecondaryKeyMax,
	unsigned long *	pcbSecondaryKeyActual,
	void *			pvPrimaryBookmark,
	unsigned long	cbPrimaryBookmarkMax,
	unsigned long *	pcbPrimaryBookmarkActual )
	{
	APICALL_SESID	apicall( opGetBookmark );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispGetIndexBookmark(
										sesid,
										tableid,
										pvSecondaryKey,
										cbSecondaryKeyMax,
										pcbSecondaryKeyActual,
										pvPrimaryBookmark,
										cbPrimaryBookmarkMax,
										pcbPrimaryBookmarkActual ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetGetSecondaryIndexBookmark(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	void *			pvSecondaryKey,
	unsigned long	cbSecondaryKeyMax,
	unsigned long *	pcbSecondaryKeyActual,
	void *			pvPrimaryBookmark,
	unsigned long	cbPrimaryBookmarkMax,
	unsigned long *	pcbPrimaryBookmarkActual,
	const JET_GRBIT	grbit )
	{
	JET_TRY( JetGetSecondaryIndexBookmarkEx(
						sesid,
						tableid,
						pvSecondaryKey,
						cbSecondaryKeyMax,
						pcbSecondaryKeyActual,
						pvPrimaryBookmark,
						cbPrimaryBookmarkMax,
						pcbPrimaryBookmarkActual ) );
	}


LOCAL JET_ERR JetGotoBookmarkEx(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	void			*pvBookmark,
	unsigned long	cbBookmark )
	{
	APICALL_SESID	apicall( opGotoBookmark );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispGotoBookmark(
										sesid,
										tableid,
										pvBookmark,
										cbBookmark ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetGotoBookmark(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	void			*pvBookmark,
	unsigned long	cbBookmark )
	{
	JET_TRY( JetGotoBookmarkEx( sesid, tableid, pvBookmark, cbBookmark ) );
	}

JET_ERR JET_API JetGotoSecondaryIndexBookmarkEx(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	void *			pvSecondaryKey,
	unsigned long	cbSecondaryKey,
	void *			pvPrimaryBookmark,
	unsigned long	cbPrimaryBookmark,
	const JET_GRBIT	grbit )
	{
	APICALL_SESID	apicall( opGotoBookmark );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispGotoIndexBookmark(
										sesid,
										tableid,
										pvSecondaryKey,
										cbSecondaryKey,
										pvPrimaryBookmark,
										cbPrimaryBookmark,
										grbit ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetGotoSecondaryIndexBookmark(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	void *			pvSecondaryKey,
	unsigned long	cbSecondaryKey,
	void *			pvPrimaryBookmark,
	unsigned long	cbPrimaryBookmark,
	const JET_GRBIT	grbit )
	{
	JET_TRY( JetGotoSecondaryIndexBookmarkEx(
						sesid,
						tableid,
						pvSecondaryKey,
						cbSecondaryKey,
						pvPrimaryBookmark,
						cbPrimaryBookmark,
						grbit ) );
	}


JET_ERR JET_API JetIntersectIndexesEx(
	JET_SESID			sesid,
	JET_INDEXRANGE *	rgindexrange,
	unsigned long		cindexrange,
	JET_RECORDLIST *	precordlist,
	JET_GRBIT			grbit )
	{
	APICALL_SESID		apicall( opIntersectIndexes );

	if ( apicall.FEnter( sesid ) )
		{
		//  not dispatched because we don't have a tableid to dispatch on
		apicall.LeaveAfterCall( ErrIsamIntersectIndexes(
										sesid,
										rgindexrange,
										cindexrange,
										precordlist,
										grbit ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetIntersectIndexes(
	JET_SESID sesid,
	JET_INDEXRANGE * rgindexrange,
	unsigned long cindexrange,
	JET_RECORDLIST * precordlist,
	JET_GRBIT grbit )
	{
	JET_TRY( JetIntersectIndexesEx( sesid, rgindexrange, cindexrange, precordlist, grbit ) );
	}


LOCAL JET_ERR JetGetRecordPositionEx(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_RECPOS		*precpos,
	unsigned long	cbKeypos )
	{
	APICALL_SESID	apicall( opGetRecordPosition );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispGetRecordPosition(
										sesid,
										tableid,
										precpos,
										cbKeypos ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetGetRecordPosition(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_RECPOS		*precpos,
	unsigned long	cbKeypos )
	{
	JET_TRY( JetGetRecordPositionEx( sesid, tableid, precpos, cbKeypos ) );
	}


LOCAL JET_ERR JetGotoPositionEx(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_RECPOS		*precpos )
	{
	APICALL_SESID	apicall( opGotoPosition );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispGotoPosition(
										sesid,
										tableid,
										precpos ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetGotoPosition(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_RECPOS		*precpos )
	{
	JET_TRY( JetGotoPositionEx( sesid, tableid, precpos ) );
	}


LOCAL JET_ERR JetRetrieveKeyEx(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	void			*pvKey,
	unsigned long	cbMax,
	unsigned long	*pcbActual,
	JET_GRBIT		grbit )
	{
	APICALL_SESID	apicall( opRetrieveKey );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispRetrieveKey(
										sesid,
										tableid,
										pvKey,
										cbMax,
										pcbActual,
										grbit ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetRetrieveKey(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	void			*pvKey,
	unsigned long	cbMax,
	unsigned long	*pcbActual,
	JET_GRBIT		grbit )
	{
	JET_TRY( JetRetrieveKeyEx( sesid, tableid, pvKey, cbMax, pcbActual, grbit ) );
	}


LOCAL JET_ERR JetGetLockEx( JET_SESID sesid, JET_TABLEID tableid, JET_GRBIT grbit )
	{
	APICALL_SESID	apicall( opGetLock );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispGetLock( sesid, tableid, grbit ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetGetLock( JET_SESID sesid, JET_TABLEID tableid, JET_GRBIT grbit )
	{
	JET_TRY( JetGetLockEx( sesid, tableid, grbit ) );
	}


LOCAL JET_ERR JetGetVersionEx( JET_SESID sesid, unsigned long  *pVersion )
	{
	APICALL_SESID	apicall( opGetVersion );

	if ( apicall.FEnter( sesid ) )
		{
		//	assert no aliasing of version information
		Assert( DwUtilImageVersionMajor() < 1<<8 );
		Assert( DwUtilImageBuildNumberMajor() < 1<<16 );
		Assert( DwUtilImageBuildNumberMinor() < 1<<8 );

		*pVersion = g_ulVersion;

		apicall.LeaveAfterCall( JET_errSuccess );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetGetVersion( JET_SESID sesid, unsigned long  *pVersion )
	{
	JET_TRY( JetGetVersionEx( sesid, pVersion ) );
	}

/*=================================================================
JetGetSystemParameter

Description:
  This function returns the current settings of the system parameters.

Parameters:
  sesid 		is the optional session identifier for dynamic parameters.
  paramid		is the system parameter code identifying the parameter.
  plParam		is the returned parameter value.
  sz			is the zero terminated string parameter buffer.
  cbMax			is the size of the string parameter buffer.

Return Value:
  JET_errSuccess if the routine can perform all operations cleanly;
  some appropriate error value otherwise.

Errors/Warnings:
  JET_errInvalidParameter:
	Invalid parameter code.
  JET_errInvalidSesid:
	Dynamic parameters require a valid session id.

Side Effects:
  None.
=================================================================*/
LOCAL JET_ERR JetGetSystemParameterEx(
	JET_INSTANCE	instance,
	JET_SESID		sesid,
	unsigned long	paramid,
	ULONG_PTR		*plParam,
	char			*sz,
	unsigned long	cbMax )
	{
	APICALL_INST	apicall( opGetSystemParameter );
	INST 			*pinst;

	SetPinst( &instance, sesid, &pinst );

	if ( !pinst )
		{
		//	setting for global default]
		Assert( !sesid || sesid == JET_sesidNil );
		return ErrGetSystemParameter( 0, 0, paramid, plParam, sz, cbMax );
		}

	if ( apicall.FEnterWithoutInit( pinst, fFalse ) )
		{
		apicall.LeaveAfterCall( ErrGetSystemParameter(
										(JET_INSTANCE)pinst,
										sesid,
										paramid,
										plParam,
										sz,
										cbMax ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetGetSystemParameter(
	JET_INSTANCE	instance,
	JET_SESID		sesid,
	unsigned long	paramid,
	ULONG_PTR		*plParam,
	char			*sz,
	unsigned long	cbMax )
	{
	JET_TRY( JetGetSystemParameterEx( instance, sesid, paramid, plParam, sz, cbMax ) );
	}


/*=================================================================
JetBeginSession

Description:
  This function signals the start of a session for a given user.  It must
  be the first function called by the application on behalf of that user.

  The username and password supplied must correctly identify a user account
  in the security accounts subsystem of the engine for which this session
  is being started.  Upon proper identification and authentication, a SESID
  is allocated for the session, a user token is created for the security
  subject, and that user token is specifically associated with the SESID
  of this new session for the life of that SESID (until JetEndSession is
  called).

Parameters:
  psesid		is the unique session identifier returned by the system.
  szUsername	is the username of the user account for logon purposes.
  szPassword	is the password of the user account for logon purposes.

Return Value:
  JET_errSuccess if the routine can perform all operations cleanly;
  some appropriate error value otherwise.

Errors/Warnings:

Side Effects:
  * Allocates resources which must be freed by JetEndSession().
=================================================================*/

LOCAL JET_ERR JetBeginSessionEx(
	JET_INSTANCE	instance,
	JET_SESID		*psesid,
	const char		*szUsername,
	const char		*szPassword )
	{
	APICALL_INST	apicall( opBeginSession );

	if ( apicall.FEnter( instance ) )
		{
		//	tell the ISAM to start a new session
		apicall.LeaveAfterCall( ErrIsamBeginSession(
										(JET_INSTANCE)apicall.Pinst(),
										psesid ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetBeginSession(
	JET_INSTANCE	instance,
	JET_SESID		*psesid,
	const char		*szUsername,
	const char		*szPassword )
	{
	JET_TRY( JetBeginSessionEx( instance, psesid, szUsername, szPassword ) );
	}


LOCAL JET_ERR JetDupSessionEx( JET_SESID sesid, JET_SESID *psesid )
	{
	APICALL_SESID	apicall( opDupSession );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrIsamBeginSession(
										(JET_INSTANCE)PinstFromSesid( sesid ),
										psesid ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetDupSession( JET_SESID sesid, JET_SESID *psesid )
	{
	JET_TRY( JetDupSessionEx( sesid, psesid ) );
	}

/*=================================================================
JetEndSession

Description:
  This routine ends a session with a Jet engine.

Parameters:
  sesid 		identifies the session uniquely

Return Value:
  JET_errSuccess if the routine can perform all operations cleanly;
  some appropriate error value otherwise.

Errors/Warnings:
  JET_errInvalidSesid:
	The SESID supplied is invalid.

Side Effects:
=================================================================*/
LOCAL JET_ERR JetEndSessionEx( JET_SESID sesid, JET_GRBIT grbit )
	{
	APICALL_SESID	apicall( opEndSession );

	if ( apicall.FEnter( sesid, fTrue ) )
		{
		//	must call special routine LeaveAfterEndSession()
		//	because we can't reference the PIB anymore if
		//	ErrIsamEndSession() returns success
		//
		apicall.LeaveAfterEndSession( ErrIsamEndSession( sesid, grbit ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetEndSession( JET_SESID sesid, JET_GRBIT grbit )
	{
	JET_TRY( JetEndSessionEx( sesid, grbit ) );
	}

LOCAL JET_ERR JetCreateDatabaseEx(
	JET_SESID		sesid,
	const CHAR		*szDatabaseName,
	const CHAR		*szSLVName,
	const CHAR		*szSLVRoot,
	const ULONG		cpgDatabaseSizeMax,
	JET_DBID		*pifmp,
	JET_GRBIT		grbit )
	{
	APICALL_SESID	apicall( opCreateDatabase );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrIsamCreateDatabase(
										sesid,
										szDatabaseName,
										szSLVName,
										szSLVRoot,
										cpgDatabaseSizeMax,
										pifmp,
										grbit ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetCreateDatabase(
	JET_SESID		sesid,
	const char		*szFilename,
	const char		*szConnect,
	JET_DBID		*pifmp,
	JET_GRBIT		grbit )
	{
	JET_TRY( JetCreateDatabaseEx( sesid, szFilename, NULL, NULL, 0, pifmp, grbit ) );
	}
JET_ERR JET_API JetCreateDatabase2(
	JET_SESID		sesid,
	const CHAR		*szFilename,
	const ULONG		cpgDatabaseSizeMax,
	JET_DBID		*pifmp,
	JET_GRBIT		grbit )
	{
	JET_TRY( JetCreateDatabaseEx( sesid, szFilename, NULL, NULL, cpgDatabaseSizeMax, pifmp, grbit ) );
	}
JET_ERR JET_API JetCreateDatabaseWithStreaming(
	JET_SESID		sesid,
	const CHAR		*szDbFileName,
	const CHAR		*szSLVFileName,
	const CHAR		*szSLVRootName,
	const ULONG		cpgDatabaseSizeMax,
	JET_DBID		*pifmp,
	JET_GRBIT		grbit )
	{
	JET_TRY( JetCreateDatabaseEx(
					sesid,
					szDbFileName,
					szSLVFileName,
					szSLVRootName,
					cpgDatabaseSizeMax,
					pifmp,
					grbit|JET_bitDbCreateStreamingFile ) );
	}


LOCAL JET_ERR JetOpenDatabaseEx(
	JET_SESID		sesid,
	const char		*szDatabase,
	const char		*szConnect,
	JET_DBID		*pifmp,
	JET_GRBIT		grbit )
	{
	APICALL_SESID	apicall( opOpenDatabase );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrIsamOpenDatabase(
										sesid,
										szDatabase,
										szConnect,
										pifmp,
										grbit ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetOpenDatabase(
	JET_SESID		sesid,
	const char		*szDatabase,
	const char		*szConnect,
	JET_DBID		*pifmp,
	JET_GRBIT		grbit )
	{
	JET_TRY( JetOpenDatabaseEx( sesid, szDatabase, szConnect, pifmp, grbit ) );
	}


LOCAL JET_ERR JetGetDatabaseInfoEx(
	JET_SESID		sesid,
	JET_DBID		ifmp,
	void			*pvResult,
	unsigned long	cbMax,
	unsigned long	InfoLevel )
	{
	APICALL_SESID	apicall( opGetDatabaseInfo );

	if ( apicall.FEnter( sesid ) )
		{
		FillClientBuffer( pvResult, cbMax );
		apicall.LeaveAfterCall( ErrIsamGetDatabaseInfo(
										sesid,
										(JET_DBID)ifmp,
										pvResult,
										cbMax,
										InfoLevel ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetGetDatabaseInfo(
	JET_SESID		sesid,
	JET_DBID		ifmp,
	void			*pvResult,
	unsigned long	cbMax,
	unsigned long	InfoLevel )
	{
	JET_TRY( JetGetDatabaseInfoEx( sesid, ifmp, pvResult, cbMax, InfoLevel ) );
	}


LOCAL JET_ERR JetGetDatabaseFileInfoEx(
	const char		*szDatabaseName,
	void			*pvResult,
	unsigned long	cbMax,
	unsigned long	InfoLevel )
	{
	ERR				err				= JET_errSuccess;
	IFileSystemAPI*	pfsapi			= NULL;
	IFileFindAPI*	pffapi			= NULL;
	CHAR			szFullDbName[ IFileSystemAPI::cchPathMax ];
	QWORD			cbFileSize		= 0;
	INT				cSystemInitCalls= 0;
	BOOL			fInINSTCrit		= fFalse;

	Call( ErrOSFSCreate( pinstNil, &pfsapi ) );
	Call( pfsapi->ErrFileFind( szDatabaseName, &pffapi ) );
	Call( pffapi->ErrNext() );
	Call( pffapi->ErrPath( szFullDbName ) );
   	Call( pffapi->ErrSize( &cbFileSize ) );

	switch ( InfoLevel )
		{
		case JET_DbInfoFilesize:
	 		if ( sizeof( QWORD ) != cbMax )
	 			{
	    		Error( ErrERRCheck( JET_errInvalidBufferSize ), HandleError );
	    		}
	    	FillClientBuffer( pvResult, cbMax );

	    	memcpy( (BYTE*)pvResult, (BYTE*)&cbFileSize, sizeof( QWORD ) );
	    	break;

		case JET_DbInfoUpgrade:
			{
			if ( sizeof(JET_DBINFOUPGRADE ) != cbMax )
				{
				Call( ErrERRCheck( JET_errInvalidBufferSize ) );
				}

			JET_DBINFOUPGRADE	*pdbinfoupgd	= (JET_DBINFOUPGRADE *)pvResult;
			DBFILEHDR_FIX		*pdbfilehdr;

			if ( sizeof(JET_DBINFOUPGRADE) != pdbinfoupgd->cbStruct )
				{
				Call( ErrERRCheck( JET_errInvalidParameter ) );
				}

			memset( pdbinfoupgd, 0, sizeof(JET_DBINFOUPGRADE) );
			pdbinfoupgd->cbStruct = sizeof(JET_DBINFOUPGRADE);

			pdbinfoupgd->cbFilesizeLow	= DWORD( cbFileSize );
			pdbinfoupgd->cbFilesizeHigh	= DWORD( cbFileSize >> 32 );

			//	UNDONE:	need more accurate estimates of space and time requirements
			pdbinfoupgd->csecToUpgrade = ULONG( ( cbFileSize * 3600 ) >> 30 );	// shr 30 == divide by 1Gb
			cbFileSize = ( cbFileSize * 10 ) >> 6;								// shr 6 == divide by 64; 10/64 is roughly 15%
			pdbinfoupgd->cbFreeSpaceRequiredLow		= DWORD( cbFileSize );
			pdbinfoupgd->cbFreeSpaceRequiredHigh	= DWORD( cbFileSize >> 32 );

			fInINSTCrit = fTrue;
			INST::EnterCritInst();

			Assert( 0 == cSystemInitCalls );

			if ( 0 == ipinstMac )
				{
				//	HACK: must init I/O manager
				Call( INST::ErrINSTSystemInit() );
				cSystemInitCalls++;
				Call( ErrOSUInit() );
				cSystemInitCalls++;
				}

			//	bring in the database and check its header
			pdbfilehdr = (DBFILEHDR_FIX * )PvOSMemoryPageAlloc( g_cbPage, NULL );
			if ( NULL == pdbfilehdr )
				{
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}

			//	need to zero out header because we try to read it
			//	later on even on failure
			memset( pdbfilehdr, 0, g_cbPage );

			//	verify flags initialised
			Assert( !pdbinfoupgd->fUpgradable );
			Assert(	!pdbinfoupgd->fAlreadyUpgraded );

			err = ErrUtilReadShadowedHeader(
						pfsapi,
						szFullDbName,
						(BYTE*)pdbfilehdr,
						g_cbPage,
						OffsetOf( DBFILEHDR_FIX, le_cbPageSize ) );
			Assert( err <= JET_errSuccess );	// shouldn't get warnings

			//	Checksumming may have changed, which is probably
			//	why we got errors, so just force success.
			//	If there truly was an error, then the fUpgradable flag
			//	will be fFalse to indicate the database is not upgradable.
			//	If the user later tries to upgrade anyways, the error will
			//	be detected when the database is opened.
			err = JET_errSuccess;

			//	If able to read header, ignore any errors and check version
			//	Note that the magic number stays the same since 500.
			if ( ulDAEMagic == pdbfilehdr->le_ulMagic )
				{
				switch ( pdbfilehdr->le_ulVersion )
					{
					case ulDAEVersion:
						Assert( !pdbinfoupgd->fUpgradable );
						pdbinfoupgd->fAlreadyUpgraded = fTrue;
						if ( pdbfilehdr->Dbstate() == JET_dbstateBeingConverted )
							err = ErrERRCheck( JET_errDatabaseIncompleteUpgrade );
						break;
					case ulDAEVersion500:
					case ulDAEVersion550:
						pdbinfoupgd->fUpgradable = fTrue;
						Assert(	!pdbinfoupgd->fAlreadyUpgraded );
						break;
					case ulDAEVersion400:
						{
						CHAR szDbPath[IFileSystemAPI::cchPathMax];
						CHAR szDbFileName[IFileSystemAPI::cchPathMax];
						CHAR szDbFileExt[IFileSystemAPI::cchPathMax];

						Call( pfsapi->ErrPathParse( szFullDbName, szDbPath, szDbFileName, szDbFileExt ) );
						strcat( szDbFileName, szDbFileExt );

						//	HACK! HACK! HACK!
						//	there was a bug where the Exchange 4.0 skeleton DIR.EDB
						//	was mistakenly stamped with ulDAEVersion400.
						pdbinfoupgd->fUpgradable = ( 0 == _stricmp( szDbFileName, "dir.edb" ) ? fTrue : fFalse );
						Assert(	!pdbinfoupgd->fAlreadyUpgraded );
						break;
						}
					default:
						//	unsupported upgrade format
						Assert( !pdbinfoupgd->fUpgradable );
						Assert(	!pdbinfoupgd->fAlreadyUpgraded );
						break;
					}
				}

			OSMemoryPageFree( pdbfilehdr );

			break;
			}

	    case JET_DbInfoMisc:
		case JET_DbInfoPageSize:
		case JET_DbInfoHasSLVFile:
	    	{
	    	if ( ( InfoLevel == JET_DbInfoMisc && sizeof( JET_DBINFOMISC ) != cbMax )
	    		|| ( InfoLevel == JET_DbInfoPageSize && sizeof( ULONG ) != cbMax )
	    		|| ( InfoLevel == JET_DbInfoHasSLVFile && cbMax != sizeof( BOOL ) ) )
	    		{
		    	Call( ErrERRCheck( JET_errInvalidBufferSize ) );
		    	}
	    	FillClientBuffer( pvResult, cbMax );

			fInINSTCrit = fTrue;
			INST::EnterCritInst();

			Assert( 0 == cSystemInitCalls );

			if ( 0 == ipinstMac )
				{
				//	HACK: must init I/O manager
				Call( INST::ErrINSTSystemInit() );
				cSystemInitCalls++;
				Call( ErrOSUInit() );
				cSystemInitCalls++;
				}

 			DBFILEHDR *	pdbfilehdr	= (DBFILEHDR * )PvOSMemoryPageAlloc( g_cbPage, NULL );
			if ( NULL == pdbfilehdr )
				{
				err = ErrERRCheck( JET_errOutOfMemory );
				}

			else if ( JET_DbInfoPageSize == InfoLevel )
				{
				INT		bHeaderDamaged;
				err = ErrUtilOnlyReadShadowedHeader(	pfsapi,
														szFullDbName,
														(BYTE *)pdbfilehdr,
														g_cbPage,
														OffsetOf( DBFILEHDR_FIX, le_cbPageSize ),
														&bHeaderDamaged,
														NULL );
				if ( JET_errSuccess == err )
					{
					*( ULONG *)pvResult = ( 0 != pdbfilehdr->le_cbPageSize ?
											pdbfilehdr->le_cbPageSize :
											cbPageDefault );
					}

				OSMemoryPageFree( pdbfilehdr );
				}

			else
				{
		    	err = ErrUtilReadShadowedHeader(	pfsapi,
		    										szFullDbName,
		    										(BYTE *)pdbfilehdr,
		    										g_cbPage,
		    										OffsetOf( DBFILEHDR_FIX, le_cbPageSize ) );

		    	if ( JET_errSuccess == err )
		    		{
		    		switch ( InfoLevel )
		    			{
		    			case JET_DbInfoMisc:
							UtilLoadDbinfomiscFromPdbfilehdr( (JET_DBINFOMISC *)pvResult, (DBFILEHDR_FIX*)pdbfilehdr );
							break;
		    			case JET_DbInfoHasSLVFile:
							*( BOOL *)pvResult = !!pdbfilehdr->FSLVExists();
							break;
						default:
							Assert( fFalse );
		    			}
					}

				OSMemoryPageFree( pdbfilehdr );
				}

   			break;
	    	}

		case JET_DbInfoDBInUse:
			{

	    	if ( sizeof( BOOL ) != cbMax )
	    		{
		    	Error( ErrERRCheck( JET_errInvalidBufferSize ), HandleError );
		    	}

			*(BOOL *)pvResult = fFalse;

			// no fmp table
			if ( NULL == rgfmp)
				{
				break;
				}

			FMP::EnterCritFMPPool();

			for ( IFMP ifmp = FMP::IfmpMinInUse(); ifmp <= FMP::IfmpMacInUse(); ifmp++ )
				{
				FMP	* pfmp = &rgfmp[ ifmp ];

				if ( !pfmp->FInUse() )
					{
					continue;
					}

				if ( 0 != UtilCmpFileName( pfmp->SzDatabaseName(), szFullDbName ) )
					{
					continue;
					}

				*(BOOL *)pvResult = fTrue;
				break;
				}

			FMP::LeaveCritFMPPool();
			}
			break;
		default:
			 err = ErrERRCheck( JET_errInvalidParameter );
		}

HandleError:
	//	===> Initializing OS I/O manager hack error handling
	Assert( 2 >= cSystemInitCalls );
	if ( 2 == cSystemInitCalls )
		{
		OSUTerm();
		cSystemInitCalls--;
		}

	if ( 1 == cSystemInitCalls )
		{
		INST::INSTSystemTerm();
		cSystemInitCalls--;
		}

	if ( fInINSTCrit )
		{
		INST::LeaveCritInst();
		fInINSTCrit = fFalse;
		}

	Assert( 0 == cSystemInitCalls );
	Assert( !fInINSTCrit );
	//	<=== Initializing OS I/O manager hack error handling
	delete pffapi;
	delete pfsapi;
	return err;
	}


JET_ERR JET_API JetGetDatabaseFileInfo(
	const char		*szDatabaseName,
	void			*pvResult,
	unsigned long	cbMax,
	unsigned long	InfoLevel )
	{
	JET_TRY( JetGetDatabaseFileInfoEx( szDatabaseName, pvResult, cbMax, InfoLevel ) );
	}


LOCAL JET_ERR JetCloseDatabaseEx( JET_SESID sesid, JET_DBID ifmp, JET_GRBIT grbit )
	{
	APICALL_SESID	apicall( opCloseDatabase );

	if ( apicall.FEnter( sesid, fTrue ) )
		{
		apicall.LeaveAfterCall( ErrIsamCloseDatabase(
										sesid,
										(JET_DBID)ifmp,
										grbit ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetCloseDatabase( JET_SESID sesid, JET_DBID ifmp, JET_GRBIT grbit )
	{
	JET_TRY( JetCloseDatabaseEx( sesid, ifmp, grbit ) );
	}


LOCAL JET_ERR JetCreateTableEx(
	JET_SESID			sesid,
	JET_DBID			ifmp,
	const char			*szTableName,
	unsigned long		lPage,
	unsigned long		lDensity,
	JET_TABLEID			*ptableid )
	{
	APICALL_SESID		apicall( opCreateTable );
	JET_TABLECREATE2	tablecreate	=
							{	sizeof(JET_TABLECREATE2),
								(CHAR *)szTableName,
								NULL,
								lPage,
								lDensity,
								NULL,
								0,
								NULL,
								0,	// No columns/indexes
								NULL,
								0,	// No callbacks
								0,	// grbit
								JET_tableidNil,	// returned tableid
								0	// returned count of objects created
								};

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrIsamCreateTable2(
										sesid,
										(JET_DBID)ifmp,
										&tablecreate ) );

		//	the following statement automatically set to tableid Nil on error
		*ptableid = tablecreate.tableid;

		//	either the table was created or it was not
		Assert( 0 == tablecreate.cCreated || 1 == tablecreate.cCreated );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetCreateTable(
	JET_SESID		sesid,
	JET_DBID		ifmp,
	const char		*szTableName,
	unsigned long	lPage,
	unsigned long	lDensity,
	JET_TABLEID		*ptableid )
	{
	JET_TRY( JetCreateTableEx( sesid, ifmp, szTableName, lPage, lDensity, ptableid ) );
	}


LOCAL JET_ERR JetCreateTableColumnIndexEx(
	JET_SESID		sesid,
	JET_DBID		ifmp,
	JET_TABLECREATE	*ptablecreate )
	{
	APICALL_SESID	apicall( opCreateTableColumnIndex );

	if ( apicall.FEnter( sesid ) )
		{
		const BOOL	fInvalidParam	= ( NULL == ptablecreate
										|| sizeof(JET_TABLECREATE) != ptablecreate->cbStruct );
		apicall.LeaveAfterCall( fInvalidParam ?
									ErrERRCheck( JET_errInvalidParameter ) :
									ErrIsamCreateTable( sesid, (JET_DBID)ifmp, ptablecreate ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetCreateTableColumnIndex(
	JET_SESID		sesid,
	JET_DBID		ifmp,
	JET_TABLECREATE	*ptablecreate )
	{
	JET_TRY( JetCreateTableColumnIndexEx( sesid, ifmp, ptablecreate ) );
	}


LOCAL JET_ERR JetCreateTableColumnIndexEx2(
	JET_SESID			sesid,
	JET_DBID			ifmp,
	JET_TABLECREATE2	*ptablecreate )
	{
	APICALL_SESID		apicall( opCreateTableColumnIndex );

	if ( apicall.FEnter( sesid ) )
		{
		const BOOL	fInvalidParam	= ( NULL == ptablecreate
										|| sizeof(JET_TABLECREATE2) != ptablecreate->cbStruct );
		apicall.LeaveAfterCall( fInvalidParam ?
									ErrERRCheck( JET_errInvalidParameter ) :
									ErrIsamCreateTable2( sesid, (JET_DBID)ifmp, ptablecreate ) );
	}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetCreateTableColumnIndex2(
	JET_SESID			sesid,
	JET_DBID			ifmp,
	JET_TABLECREATE2	*ptablecreate )
	{
	JET_TRY( JetCreateTableColumnIndexEx2( sesid, ifmp, ptablecreate ) );
	}


LOCAL JET_ERR JetDeleteTableEx( JET_SESID sesid, JET_DBID ifmp, const char *szName )
	{
	APICALL_SESID	apicall( opDeleteTable );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrIsamDeleteTable(
										sesid,
										(JET_DBID)ifmp,
										(CHAR *)szName ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetDeleteTable( JET_SESID sesid, JET_DBID ifmp, const char *szName )
	{
	JET_TRY( JetDeleteTableEx( sesid, ifmp, szName ) );
	}


LOCAL JET_ERR JetRenameTableEx(
	JET_SESID		sesid,
	JET_DBID		dbid,
	const CHAR *	szName,
	const CHAR *	szNameNew )
	{
	APICALL_SESID	apicall( opRenameTable );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrIsamRenameTable(
										sesid,
										dbid,
										szName,
										szNameNew ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetRenameTable(
	JET_SESID	sesid,
	JET_DBID	dbid,
	const CHAR	*szName,
	const CHAR	*szNameNew )
	{
	JET_TRY( JetRenameTableEx( sesid, dbid, szName, szNameNew ) );
	}


LOCAL JET_ERR JetRenameColumnEx(
	const JET_SESID		sesid,
	const JET_TABLEID	tableid,
	const CHAR * const	szName,
	const CHAR * const	szNameNew,
	const JET_GRBIT 	grbit )
	{
	APICALL_SESID		apicall( opRenameColumn );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispRenameColumn(
										sesid,
										tableid,
										szName,
										szNameNew,
										grbit ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetRenameColumn(
	JET_SESID	sesid,
	JET_TABLEID	tableid,
	const CHAR	*szName,
	const CHAR	*szNameNew,
	JET_GRBIT	grbit )
	{
	JET_TRY( JetRenameColumnEx( sesid, tableid, szName, szNameNew, grbit ) );
	}


LOCAL JET_ERR JetAddColumnEx(
	JET_SESID			sesid,
	JET_TABLEID			tableid,
	const char			*szColumnName,
	const JET_COLUMNDEF	*pcolumndef,
	const void			*pvDefault,
	unsigned long		cbDefault,
	JET_COLUMNID		*pcolumnid )
	{
	APICALL_SESID		apicall( opAddColumn );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispAddColumn(
										sesid,
										tableid,
										szColumnName,
										pcolumndef,
										pvDefault,
										cbDefault,
										pcolumnid ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetAddColumn(
	JET_SESID			sesid,
	JET_TABLEID			tableid,
	const char			*szColumnName,
	const JET_COLUMNDEF	*pcolumndef,
	const void			*pvDefault,
	unsigned long		cbDefault,
	JET_COLUMNID		*pcolumnid )
	{
	JET_TRY( JetAddColumnEx( sesid, tableid, szColumnName, pcolumndef, pvDefault, cbDefault, pcolumnid ) );
	}


LOCAL JET_ERR JetDeleteColumnEx(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szColumnName,
	const JET_GRBIT	grbit )
	{
	APICALL_SESID	apicall( opDeleteColumn );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispDeleteColumn(
										sesid,
										tableid,
										szColumnName,
										grbit ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetDeleteColumn(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szColumnName )
	{
	JET_TRY( JetDeleteColumnEx( sesid, tableid, szColumnName, NO_GRBIT ) );
	}
JET_ERR JET_API JetDeleteColumn2(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szColumnName,
	const JET_GRBIT	grbit )
	{
	JET_TRY( JetDeleteColumnEx( sesid, tableid, szColumnName, grbit ) );
	}


LOCAL JET_ERR JetSetColumnDefaultValueEx(
	JET_SESID			sesid,
	JET_DBID			ifmp,
	const char			*szTableName,
	const char			*szColumnName,
	const void			*pvData,
	const unsigned long	cbData,
	const JET_GRBIT		grbit )
	{
	APICALL_SESID		apicall( opSetColumnDefaultValue );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrIsamSetColumnDefaultValue(
										sesid,
										ifmp,
										szTableName,
										szColumnName,
										pvData,
										cbData,
										grbit ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetSetColumnDefaultValue(
	JET_SESID			sesid,
	JET_DBID			ifmp,
	const char			*szTableName,
	const char			*szColumnName,
	const void			*pvData,
	const unsigned long	cbData,
	const JET_GRBIT		grbit )
	{
	JET_TRY( JetSetColumnDefaultValueEx( sesid, ifmp, szTableName, szColumnName, pvData, cbData, grbit ) );
	}

LOCAL JET_ERR JetCreateIndexEx(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_INDEXCREATE *pindexcreate,
	unsigned long 	cIndexCreate )
	{
	APICALL_SESID	apicall( opCreateIndex );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispCreateIndex(
										sesid,
										tableid,
										pindexcreate,
										cIndexCreate ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetCreateIndex(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szIndexName,
	JET_GRBIT		grbit,
	const char		*szKey,
	unsigned long	cbKey,
	unsigned long	lDensity )
	{
	JET_INDEXCREATE	idxcreate;
	idxcreate.cbStruct 		= sizeof( JET_INDEXCREATE );
	idxcreate.szIndexName 	= (CHAR *)szIndexName;
	idxcreate.szKey			= (CHAR *)szKey;
	idxcreate.cbKey			= cbKey;
	idxcreate.grbit			= grbit;
	idxcreate.ulDensity		= lDensity;
	idxcreate.lcid			= 0;
	idxcreate.cbVarSegMac	= 0;
	idxcreate.rgconditionalcolumn 	= 0;
	idxcreate.cConditionalColumn	= 0;
	idxcreate.err			= JET_errSuccess;

	JET_TRY( JetCreateIndexEx( sesid, tableid, &idxcreate, 1 ) );
	}
JET_ERR JET_API JetCreateIndex2(
	JET_SESID 		sesid,
	JET_TABLEID 	tableid,
	JET_INDEXCREATE *pindexcreate,
	unsigned long 	cIndexCreate )
	{
	JET_TRY( JetCreateIndexEx( sesid, tableid, pindexcreate, cIndexCreate ) );
	}


LOCAL JET_ERR JetDeleteIndexEx(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szIndexName )
	{
	APICALL_SESID	apicall( opDeleteIndex );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispDeleteIndex(
										sesid,
										tableid,
										szIndexName ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetDeleteIndex(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szIndexName )
	{
	JET_TRY( JetDeleteIndexEx( sesid, tableid, szIndexName ) );
	}


LOCAL JET_ERR JetComputeStatsEx( JET_SESID sesid, JET_TABLEID tableid )
	{
	APICALL_SESID	apicall( opComputeStats );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispComputeStats( sesid, tableid ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetComputeStats( JET_SESID sesid, JET_TABLEID tableid )
	{
	JET_TRY( JetComputeStatsEx( sesid, tableid ) );
	}


LOCAL JET_ERR JetAttachDatabaseEx(
	JET_SESID		sesid,
	const CHAR		*szDatabaseName,
	const CHAR		*szSLVName,
	const CHAR		*szSLVRoot,
	const ULONG		cpgDatabaseSizeMax,
	JET_GRBIT		grbit )
	{
	APICALL_SESID	apicall( opAttachDatabase );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrIsamAttachDatabase(
										sesid,
										szDatabaseName,
										szSLVName,
										szSLVRoot,
										cpgDatabaseSizeMax,
										grbit ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetAttachDatabase(
	JET_SESID		sesid,
	const CHAR		*szFilename,
	JET_GRBIT		grbit )
	{
	JET_TRY( JetAttachDatabaseEx( sesid, szFilename, NULL, NULL, 0, grbit ) );
	}
JET_ERR JET_API JetAttachDatabase2(
	JET_SESID		sesid,
	const CHAR		*szFilename,
	const ULONG		cpgDatabaseSizeMax,
	JET_GRBIT		grbit )
	{
	JET_TRY( JetAttachDatabaseEx( sesid, szFilename, NULL, NULL, cpgDatabaseSizeMax, grbit ) );
	}
JET_ERR JET_API JetAttachDatabaseWithStreaming(
	JET_SESID		sesid,
	const CHAR		*szDbFileName,
	const CHAR		*szSLVFileName,
	const CHAR		*szSLVRootName,
	const ULONG		cpgDatabaseSizeMax,
	JET_GRBIT		grbit )
	{
	JET_TRY( JetAttachDatabaseEx( sesid, szDbFileName, szSLVFileName, szSLVRootName, cpgDatabaseSizeMax, grbit ) );
	}


LOCAL JET_ERR JetDetachDatabaseEx( JET_SESID sesid, const char *szFilename, JET_GRBIT grbit)
	{
	APICALL_SESID	apicall( opDetachDatabase );

	if ( apicall.FEnter( sesid, fTrue ) )
		{
		const BOOL	fForceDetach	= ( JET_bitForceDetach & grbit );
		if ( fForceDetach )
			{
#ifdef INDEPENDENT_DB_FAILURE
			apicall.LeaveAfterCall( ErrIsamForceDetachDatabase( sesid, szFilename, grbit ) );
#else
			apicall.LeaveAfterCall( ErrERRCheck( JET_errForceDetachNotAllowed ) );
#endif
			}
		else
			{
			apicall.LeaveAfterCall( ErrIsamDetachDatabase( sesid, NULL, szFilename, grbit ) );
			}
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetDetachDatabase( JET_SESID sesid, const char *szFilename )
	{
	JET_TRY( JetDetachDatabaseEx( sesid, szFilename, NO_GRBIT ) );
	}
JET_ERR JET_API JetDetachDatabase2( JET_SESID sesid, const char *szFilename, JET_GRBIT grbit )
	{
	JET_TRY( JetDetachDatabaseEx( sesid, szFilename, grbit ) );
	}


LOCAL JET_ERR JetBackupInstanceEx(
	JET_INSTANCE 	instance,
	const char		*szBackupPath,
	JET_GRBIT		grbit,
	JET_PFNSTATUS	pfnStatus )
	{
	APICALL_INST	apicall( opBackupInstance );

	if ( apicall.FEnter( instance ) )
		{
		apicall.LeaveAfterCall( apicall.Pinst()->m_fBackupAllowed ?
										ErrIsamBackup( (JET_INSTANCE)apicall.Pinst(), szBackupPath, grbit, pfnStatus ) :
										ErrERRCheck( JET_errBackupNotAllowedYet ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetBackupInstance(
	JET_INSTANCE 	instance,
	const char		*szBackupPath,
	JET_GRBIT		grbit,
	JET_PFNSTATUS	pfnStatus )
	{
	JET_TRY( JetBackupInstanceEx( instance, szBackupPath, grbit, pfnStatus ) );
	}
JET_ERR JET_API JetBackup(
	const char		*szBackupPath,
	JET_GRBIT		grbit,
	JET_PFNSTATUS	pfnStatus )
	{
	ERR				err;

	CallR( ErrRUNINSTCheckAndSetOneInstMode() );

	return JetBackupInstance( (JET_INSTANCE)g_rgpinst[0], szBackupPath, grbit, pfnStatus );
	}


JET_ERR JET_API JetRestore(	const char *sz, JET_PFNSTATUS pfn )
	{
	ERR		err;

	CallR( ErrRUNINSTCheckAndSetOneInstMode() );

	return JetRestoreInstance( (JET_INSTANCE)g_rgpinst[0], sz, NULL, pfn );
	}
JET_ERR JET_API JetRestore2( const char *sz, const char *szDest, JET_PFNSTATUS pfn )
	{
	ERR		err;

	CallR( ErrRUNINSTCheckAndSetOneInstMode() );

	return JetRestoreInstance( (JET_INSTANCE)g_rgpinst[0], sz, szDest, pfn );
	}


LOCAL JET_ERR JetOpenTempTableEx(
	JET_SESID			sesid,
	const JET_COLUMNDEF	*prgcolumndef,
	unsigned long		ccolumn,
	JET_UNICODEINDEX	*pidxunicode,
	JET_GRBIT			grbit,
	JET_TABLEID			*ptableid,
	JET_COLUMNID		*prgcolumnid )
	{
	APICALL_SESID		apicall( opOpenTempTable );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrIsamOpenTempTable(
										sesid,
										prgcolumndef,
										ccolumn,
										pidxunicode,
										grbit,
										ptableid,
										prgcolumnid ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetOpenTempTable(
	JET_SESID			sesid,
	const JET_COLUMNDEF	*prgcolumndef,
	unsigned long		ccolumn,
	JET_GRBIT			grbit,
	JET_TABLEID			*ptableid,
	JET_COLUMNID		*prgcolumnid )
	{
	JET_TRY( JetOpenTempTableEx( sesid, prgcolumndef, ccolumn, NULL, grbit, ptableid, prgcolumnid ) );
	}
JET_ERR JET_API JetOpenTempTable2(
	JET_SESID			sesid,
	const JET_COLUMNDEF	*prgcolumndef,
	unsigned long		ccolumn,
	LCID				lcid,
	JET_GRBIT			grbit,
	JET_TABLEID			*ptableid,
	JET_COLUMNID		*prgcolumnid )
	{
	INST * const		pinst		= PinstFromSesid( sesid );
	JET_UNICODEINDEX	idxunicode	= { ( lcidNone == lcid ? pinst->m_idxunicodeDefault.lcid : lcid ), pinst->m_idxunicodeDefault.dwMapFlags };

	JET_TRY( JetOpenTempTableEx( sesid, prgcolumndef, ccolumn, &idxunicode, grbit, ptableid, prgcolumnid ) );
	}
JET_ERR JET_API JetOpenTempTable3(
	JET_SESID			sesid,
	const JET_COLUMNDEF	*prgcolumndef,
	unsigned long		ccolumn,
	JET_UNICODEINDEX	*pidxunicode,
	JET_GRBIT			grbit,
	JET_TABLEID			*ptableid,
	JET_COLUMNID		*prgcolumnid )
	{
	JET_TRY( JetOpenTempTableEx( sesid, prgcolumndef, ccolumn, pidxunicode, grbit, ptableid, prgcolumnid ) );
	}


LOCAL JET_ERR JetSetIndexRangeEx(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_GRBIT		grbit )
	{
	APICALL_SESID	apicall( opSetIndexRange );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispSetIndexRange(
										sesid,
										tableid,
										grbit ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetSetIndexRange(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_GRBIT		grbit )
	{
	JET_TRY( JetSetIndexRangeEx( sesid, tableid, grbit ) );
	}


LOCAL JET_ERR JetIndexRecordCountEx(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	unsigned long	*pcrec,
	unsigned long	crecMax )
	{
	APICALL_SESID	apicall( opIndexRecordCount );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDispIndexRecordCount(
										sesid,
										tableid,
										pcrec,
										crecMax ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetIndexRecordCount(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	unsigned long	*pcrec,
	unsigned long	crecMax )
	{
	JET_TRY( JetIndexRecordCountEx( sesid, tableid, pcrec, crecMax ) );
	}


/***********************************************************
/************* EXTERNAL BACKUP JET API *********************
/*****/
LOCAL JET_ERR JetBeginExternalBackupInstanceEx( JET_INSTANCE instance, JET_GRBIT grbit )
	{
	APICALL_INST	apicall( opBeginExternalBackupInstance );

	if ( apicall.FEnter( instance ) )
		{
		apicall.LeaveAfterCall( apicall.Pinst()->m_fBackupAllowed ?
										ErrIsamBeginExternalBackup( (JET_INSTANCE)apicall.Pinst() , grbit ) :
										ErrERRCheck( JET_errBackupNotAllowedYet ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetBeginExternalBackupInstance( JET_INSTANCE instance, JET_GRBIT grbit )
	{
	JET_TRY( JetBeginExternalBackupInstanceEx( instance, grbit ) );
	}
JET_ERR JET_API JetBeginExternalBackup( JET_GRBIT grbit )
	{
	ERR		err;

	CallR( ErrRUNINSTCheckAndSetOneInstMode() );

	return JetBeginExternalBackupInstance( (JET_INSTANCE)g_rgpinst[0], grbit );
	}


LOCAL JET_ERR JetGetAttachInfoInstanceEx(
	JET_INSTANCE	instance,
	void			*pv,
	unsigned long	cbMax,
	unsigned long	*pcbActual )
	{
	APICALL_INST	apicall( opGetAttachInfoInstance );

	if ( apicall.FEnter( instance ) )
		{
		apicall.LeaveAfterCall( ErrIsamGetAttachInfo(
										(JET_INSTANCE)apicall.Pinst(),
										pv,
										cbMax,
										pcbActual ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetGetAttachInfoInstance(
	JET_INSTANCE	instance,
	void			*pv,
	unsigned long	cbMax,
	unsigned long	*pcbActual )
	{
	JET_TRY( JetGetAttachInfoInstanceEx( instance, pv, cbMax, pcbActual ) );
	}
JET_ERR JET_API JetGetAttachInfo(
	void			*pv,
	unsigned long	cbMax,
	unsigned long	*pcbActual )
	{
	ERR				err;

	CallR( ErrRUNINSTCheckAndSetOneInstMode() );

	return JetGetAttachInfoInstance( (JET_INSTANCE)g_rgpinst[0], pv, cbMax, pcbActual );
	}


LOCAL JET_ERR JetOpenFileInstanceEx(
	JET_INSTANCE	instance,
	const char		*szFileName,
	JET_HANDLE		*phfFile,
	unsigned long	*pulFileSizeLow,
	unsigned long	*pulFileSizeHigh )
	{
	APICALL_INST	apicall( opOpenFileInstance );

	if ( apicall.FEnter( instance ) )
		{
		apicall.LeaveAfterCall( ErrIsamOpenFile(
										(JET_INSTANCE)apicall.Pinst(),
										szFileName,
										phfFile,
										pulFileSizeLow,
										pulFileSizeHigh ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetOpenFileInstance(
	JET_INSTANCE	instance,
	const char		*szFileName,
	JET_HANDLE		*phfFile,
	unsigned long	*pulFileSizeLow,
	unsigned long	*pulFileSizeHigh )
	{
	JET_TRY( JetOpenFileInstanceEx( instance, szFileName, phfFile, pulFileSizeLow, pulFileSizeHigh ) );
	}

JET_ERR JET_API JetOpenFileSectionInstance(
										JET_INSTANCE ulInstance,
										char *szFile,
										JET_HANDLE *phFile,
										long iSection,
										long cSections,
										unsigned long *pulSectionSizeLow,
										long *plSectionSizeHigh)
	{
	return ( cSections > 1 ?
				ErrERRCheck( JET_wrnNyi ) :
				JetOpenFileInstance( ulInstance,
								szFile,
								phFile,
								pulSectionSizeLow,
								(unsigned long *)plSectionSizeHigh ) );
	};

JET_ERR JET_API JetOpenFile(
	const char		*szFileName,
	JET_HANDLE		*phfFile,
	unsigned long	*pulFileSizeLow,
	unsigned long	*pulFileSizeHigh )
	{
	ERR				err;

	CallR( ErrRUNINSTCheckAndSetOneInstMode() );

	return JetOpenFileInstance( (JET_INSTANCE)g_rgpinst[0], szFileName, phfFile, pulFileSizeLow, pulFileSizeHigh );
	}


LOCAL JET_ERR JetReadFileInstanceEx(
	JET_INSTANCE	instance,
	JET_HANDLE		hfFile,
	void			*pv,
	unsigned long	cb,
	unsigned long	*pcbActual )
	{
	APICALL_INST	apicall( opReadFileInstance );

	if ( apicall.FEnter( instance ) )
		{
		apicall.LeaveAfterCall( ErrIsamReadFile(
										(JET_INSTANCE)apicall.Pinst(),
										hfFile,
										pv,
										cb,
										pcbActual ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetReadFileInstance(
	JET_INSTANCE	instance,
	JET_HANDLE		hfFile,
	void			*pv,
	unsigned long	cb,
	unsigned long	*pcbActual )
	{
	JET_TRY( JetReadFileInstanceEx( instance, hfFile, pv, cb, pcbActual ) );
	}
JET_ERR JET_API JetReadFile(
	JET_HANDLE		hfFile,
	void			*pv,
	unsigned long	cb,
	unsigned long	*pcbActual )
	{
	ERR				err;

	CallR( ErrRUNINSTCheckAndSetOneInstMode() );

	return JetReadFileInstance( (JET_INSTANCE)g_rgpinst[0], hfFile, pv, cb, pcbActual );
	}

LOCAL JET_ERR JetCloseFileInstanceEx( JET_INSTANCE instance, JET_HANDLE hfFile )
	{
	APICALL_INST	apicall( opCloseFileInstance );

	if ( apicall.FEnter( instance ) )
		{
		apicall.LeaveAfterCall( ErrIsamCloseFile(
										(JET_INSTANCE)apicall.Pinst(),
										hfFile ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetCloseFileInstance( JET_INSTANCE instance, JET_HANDLE hfFile )
	{
	JET_TRY( JetCloseFileInstanceEx( instance, hfFile ) );
	}
JET_ERR JET_API JetCloseFile( JET_HANDLE hfFile )
	{
	ERR		err;

	CallR( ErrRUNINSTCheckAndSetOneInstMode() );

	return JetCloseFileInstance( (JET_INSTANCE)g_rgpinst[0], hfFile );
	}


LOCAL JET_ERR JetGetLogInfoInstanceEx(
	JET_INSTANCE	instance,
	void			*pv,
	unsigned long	cbMax,
	unsigned long	*pcbActual,
	JET_LOGINFO 	*pLogInfo)
	{
	APICALL_INST	apicall( opGetLogInfoInstance );

	if ( apicall.FEnter( instance ) )
		{
		apicall.LeaveAfterCall( ErrIsamGetLogInfo(
										(JET_INSTANCE)apicall.Pinst(),
										pv,
										cbMax,
										pcbActual,
										pLogInfo ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetGetLogInfoInstance(
	JET_INSTANCE	instance,
	void			*pv,
	unsigned long	cbMax,
	unsigned long	*pcbActual )
	{
	JET_TRY( JetGetLogInfoInstanceEx( instance, pv, cbMax, pcbActual, NULL ) );
	}
JET_ERR JET_API JetGetLogInfoInstance2(	JET_INSTANCE instance,
										void *pv,
										unsigned long cbMax,
										unsigned long *pcbActual,
										JET_LOGINFO * pLogInfo)
	{
	JET_TRY( JetGetLogInfoInstanceEx( instance, pv, cbMax, pcbActual, pLogInfo ) );
	}
JET_ERR JET_API JetGetLogInfo(
	void			*pv,
	unsigned long	cbMax,
	unsigned long	*pcbActual )
	{
	ERR				err;

	CallR( ErrRUNINSTCheckAndSetOneInstMode() );

	return JetGetLogInfoInstance( (JET_INSTANCE)g_rgpinst[0], pv, cbMax, pcbActual );
	}

LOCAL JET_ERR JetGetTruncateLogInfoInstanceEx(
	JET_INSTANCE	instance,
	void			*pv,
	unsigned long	cbMax,
	unsigned long	*pcbActual)
	{
	APICALL_INST	apicall( opGetTruncateLogInfoInstance );

	if ( apicall.FEnter( instance ) )
		{
		apicall.LeaveAfterCall( ErrIsamGetTruncateLogInfo(
										(JET_INSTANCE)apicall.Pinst(),
										pv,
										cbMax,
										pcbActual ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetGetTruncateLogInfoInstance(	JET_INSTANCE instance,
												void *pv,
												unsigned long cbMax,
												unsigned long *pcbActual )
	{
	JET_TRY( JetGetTruncateLogInfoInstanceEx( instance, pv, cbMax, pcbActual ) );
	}


LOCAL JET_ERR JetTruncateLogInstanceEx( JET_INSTANCE instance )
	{
	APICALL_INST	apicall( opTruncateLogInstance );

	if ( apicall.FEnter( instance ) )
		{
		apicall.LeaveAfterCall( ErrIsamTruncateLog( (JET_INSTANCE)apicall.Pinst() ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetTruncateLogInstance( JET_INSTANCE instance )
	{
	JET_TRY( JetTruncateLogInstanceEx( instance ) );
	}
JET_ERR JET_API JetTruncateLog( void )
	{
	ERR		err;

	CallR( ErrRUNINSTCheckAndSetOneInstMode() );

	return JetTruncateLogInstance( (JET_INSTANCE)g_rgpinst[0] );
	}


LOCAL JET_ERR JetEndExternalBackupInstanceEx( JET_INSTANCE instance, JET_GRBIT grbit )
	{
	APICALL_INST	apicall( opEndExternalBackupInstance );

	if ( apicall.FEnter( instance ) )
		{
		apicall.LeaveAfterCall( ErrIsamEndExternalBackup(
										(JET_INSTANCE)apicall.Pinst(),
										grbit ) );
		}

	return apicall.ErrResult();
	}

JET_ERR JET_API JetEndExternalBackupInstance2( JET_INSTANCE instance, JET_GRBIT grbit )
	{
	JET_TRY( JetEndExternalBackupInstanceEx( instance, grbit ) );
	}


JET_ERR JET_API JetEndExternalBackupInstance( JET_INSTANCE instance )
	{
	// we had no flag to specify from the client side how the backup ended
	//and we assumed success until now.
	JET_TRY( JetEndExternalBackupInstanceEx( instance, JET_bitBackupEndNormal  ) );
	}
JET_ERR JET_API JetEndExternalBackup( void )
	{
	ERR		err;

	CallR( ErrRUNINSTCheckAndSetOneInstMode() );

	return JetEndExternalBackupInstance( (JET_INSTANCE)g_rgpinst[0] );
	}


volatile DWORD g_cRestoreInstance = 0;


ERR ErrINSTPrepareTargetInstance( INST * pinstTarget, char * szTargetInstanceLogPath, LONG * plGenHighTargetInstance  )
	{
	ERR				err = JET_errSuccess;

	DATA 			rgdata[3];
	LREXTRESTORE 	lrextrestore;
	LGPOS 			lgposLogRec;
	CHAR * 			szTargetInstanceName;

	Assert ( szTargetInstanceLogPath );
	Assert ( plGenHighTargetInstance );

	*plGenHighTargetInstance = 0;
	szTargetInstanceLogPath[0] = '\0';

	// if we found an instance, call APIEnter so that it can't get away until we are done with it
	// also this will check if the found instance is initalized and if it is restoring

	// if the target instance is restoring, error out at this point it will be a problem to force a new
	// generation in order to don't conflict on log files. They have to just try later

	CallR ( pinstTarget->ErrAPIEnter( fFalse ) );

	Assert ( pinstTarget );
	Assert ( pinstTarget->m_fJetInitialized );
	Assert ( pinstTarget->m_szInstanceName );

	// with circular logging we don't try to play forward logs, they are probably missing anyway
	// and we don't want to error out because of that
	if ( pinstTarget->m_plog->m_fLGCircularLogging )
		{
		// set as "no target instance"
		Assert ( 0 == *plGenHighTargetInstance );
		Assert ( '\0' == szTargetInstanceLogPath[0] );

// UNDONE: no changes in the resources are taken at this poin for PT RTM
// so the event log for skipping logs on hard recovery if circular logging is on
// will need to wait until post RTM
#if 0
		Assert ( pinstTarget->m_plog->m_szLogFilePath );
		const CHAR * rgszT[] = { pinstTarget->m_szInstanceName?pinstTarget->m_szInstanceName:"", pinstTarget->m_plog->m_szLogFilePath };

		UtilReportEvent(	eventWarning,
							LOGGING_RECOVERY_CATEGORY,
							RESTORE_CIRCULAR_LOGGING_SKIP_ID,
							2, rgszT);

MessageId=219
SymbolicName=RESTORE_CIRCULAR_LOGGING_SKIP_ID
Language=English
%1 (%2) The running instnace %3 has circular logging turned on. Restore will not attempt to replay the logfiles in folder %4.
%n%nFor more information, click http://www.microsoft.com/contentredirect.asp.
.
#endif // 0
		Assert ( JET_errSuccess == err );
		goto HandleError;
		}

	szTargetInstanceName = pinstTarget->m_szInstanceName?pinstTarget->m_szInstanceName:"";

	lrextrestore.lrtyp = lrtypExtRestore;

	rgdata[0].SetPv( (BYTE *)&lrextrestore );
	rgdata[0].SetCb( sizeof(LREXTRESTORE) );

	rgdata[1].SetPv( (BYTE *) pinstTarget->m_plog->m_szLogFilePath );
	rgdata[1].SetCb( strlen( pinstTarget->m_plog->m_szLogFilePath ) + 1 );

	rgdata[2].SetPv( (BYTE *) szTargetInstanceName );
	rgdata[2].SetCb( strlen( szTargetInstanceName ) + 1 );

	lrextrestore.SetCbInfo( USHORT( strlen( pinstTarget->m_plog->m_szLogFilePath ) + 1 + strlen( szTargetInstanceName ) + 1 ) );

	Call( pinstTarget->m_plog->ErrLGLogRec( rgdata, 3, fLGCreateNewGen, &lgposLogRec ) );

	while ( lgposLogRec.lGeneration > pinstTarget->m_plog->m_plgfilehdr->lgfilehdr.le_lGeneration )
		{
		if ( pinstTarget->m_plog->m_fLGNoMoreLogWrite )
			{
			Call ( ErrERRCheck( JET_errLogWriteFail ) );
			}
		UtilSleep( cmsecWaitGeneric );
		}

	Assert ( lgposLogRec.lGeneration > 1 );
	*plGenHighTargetInstance = lgposLogRec.lGeneration - 1;
	strcpy( szTargetInstanceLogPath, pinstTarget->m_plog->m_szLogFilePath  );

	CallS( err );

HandleError:
	// can't call APILeave() because we are in a critical section
	{
	const LONG	lOld	= AtomicExchangeAdd( &(pinstTarget->m_cSessionInJetAPI), -1 );
	Assert( lOld >= 1 );
	}

	return err;
	}

// this cristical section is entered then initalizing a restore instance
// We need it because we have 2 steps: check the target instance,
// then based on that complete the init step (after setting the log+system path)
// If we are doing it in a critical section, we may end with 2 restore instances
// that are finding no running instance and trying to start in the instance directory
// One will error out with LogPath in use instead of "Restore in Progress"
CCriticalSection critRestoreInst( CLockBasicInfo( CSyncBasicInfo( szRestoreInstance ), rankRestoreInstance, 0 ) );


LOCAL JET_ERR JetExternalRestoreEx(
	char			*szCheckpointFilePath,
	char			*szLogPath,
	JET_RSTMAP		*rgrstmap,
	long			crstfilemap,
	char			*szBackupLogPath,
	long			genLow,
	long			genHigh,
	char *			szLogBaseName,
	char *			szTargetInstanceName,
	char *			szTargetInstanceCheckpointPath,
	char *			szTargetInstanceLogPath,
	JET_PFNSTATUS	pfn )
	{
	APICALL_INST	apicall( opInit );
	INST *			pinst = NULL;
	INT				ipinst = ipinstMax;
	ERR				err = JET_errSuccess;

	CHAR *			szRestoreSystemPath = NULL;
	CHAR *			szRestoreLogPath = NULL;

	INST * 			pinstTarget = NULL;
	LONG 			lGenHighTarget;
	CHAR			szTargetLogPath[IFileSystemAPI::cchPathMax];

	const BOOL		fTargetName = (NULL != szTargetInstanceName);
	const BOOL		fTargetDirs = (NULL != szTargetInstanceLogPath);

	// used for unique TemDatabase
	CHAR			szTempDatabase[IFileSystemAPI::cchPathMax];

	CHAR * szNewInstanceName = NULL;
	BOOL fInCritInst = fFalse;
	BOOL fInCritRestoreInst = fFalse;

	CCriticalSection *pcritInst = NULL;


	lGenHighTarget = 0;
	szTargetLogPath[0] = '\0';

	// Target Dirs may be both present or both NULL
	if ( (szTargetInstanceLogPath && !szTargetInstanceCheckpointPath ) ||
		( !szTargetInstanceLogPath && szTargetInstanceCheckpointPath ) )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	// can have TarrgetName AND TargetDirs
	if ( szTargetInstanceName && szTargetInstanceLogPath )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	//	Get a new instance

	// new instance name is "RestoreXXXX"
	szNewInstanceName = new char[strlen(szRestoreInstanceName) + 4 /* will use a 4 digit counter */ + 1];
	if ( NULL == szNewInstanceName )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}

	sprintf( szNewInstanceName, "%s%04lu", szRestoreInstanceName, AtomicIncrement( (long*)&g_cRestoreInstance ) % 10000L );

	critRestoreInst.Enter();
	fInCritRestoreInst = fTrue;

	INST::EnterCritInst();
	fInCritInst = fTrue;

	// not allowed in one instance mode
	if ( runInstModeOneInst == RUNINSTGetMode() )
		{
		Call ( ErrERRCheck ( JET_errRunningInOneInstanceMode ) );
		}
	// force to multi instance mode as we want multiple restore
	else if ( runInstModeNoSet == RUNINSTGetMode() )
		{
		RUNINSTSetModeMultiInst();
		}

	Assert ( runInstModeMultiInst == RUNINSTGetMode() );

	// we want to run the restore instance using szCheckpointFilePath/szLogPath
	// the Target Instance is running or not provided. If provided but not running,
	// we want to run in the Target instance place (szTargetInstanceCheckpointPath/szTargetInstanceLogPath)


	Assert ( !fTargetDirs || !fTargetName );

	if ( !fTargetDirs && !fTargetName )
		{
		szRestoreSystemPath = szCheckpointFilePath;
		szRestoreLogPath = szLogPath;
		}
	else
		{
		// Target specified by Name XOR Dirs
		Assert ( fTargetDirs ^ fTargetName );

		if ( fTargetName )
			{
			pinstTarget = INST::GetInstanceByName( szTargetInstanceName );
			}
		else
			{
			pinstTarget = INST::GetInstanceByFullLogPath( szTargetInstanceLogPath );
			}

		if ( pinstTarget )
			{
			// Target Instance is Running
			szRestoreSystemPath = szCheckpointFilePath;
			szRestoreLogPath = szLogPath;

			Assert ( pinstTarget->m_szInstanceName );
			}
		else
			{
			// Target Not Running
			if ( fTargetName )
				{
				// the instance is provided not running and we have just the Instance Name
				// so we can't find out where the log files are. Error out
				Assert ( !fTargetDirs );
				Call ( ErrERRCheck ( JET_errBadRestoreTargetInstance ) );
				}

			Assert ( fTargetDirs );
			// instance found and not running, use TargetDirs
			szRestoreSystemPath = szTargetInstanceCheckpointPath;
			szRestoreLogPath = szTargetInstanceLogPath;
			}
		}

	// we have to set the system params first for the new instance
	Assert ( RUNINSTGetMode() == runInstModeMultiInst );

	if ( pinstTarget )
		{
		Call ( ErrINSTPrepareTargetInstance( pinstTarget, szTargetLogPath, &lGenHighTarget ) );
		}

	INST::LeaveCritInst();
	fInCritInst = fFalse;

	Call ( ErrNewInst( &pinst, szNewInstanceName, NULL, &ipinst ) );

	// we have to set the system params first
	if ( NULL != szLogBaseName)
		{
		Call ( ErrSetSystemParameter( (JET_INSTANCE)pinst, 0, JET_paramBaseName, 0, szLogBaseName ) );
		}

	// set restore path, we have to do this before ErrIsamExternalRestore (like it was before)
	// because the check against the runnign instances is in ErrInit

	if ( szRestoreLogPath )
		{
		Call ( ErrSetSystemParameter( (JET_INSTANCE)pinst, 0, JET_paramLogFilePath, 0, szRestoreLogPath ) );
		}

	if ( szRestoreSystemPath )
		{
		Call ( ErrSetSystemParameter( (JET_INSTANCE)pinst, 0, JET_paramSystemPath, 0, szRestoreSystemPath ) );

		// put the tem db in the checkpoint directory
		strcpy( szTempDatabase, szRestoreSystemPath );
		OSSTRAppendPathDelimiter( szTempDatabase, fTrue );
		Call ( ErrSetSystemParameter( (JET_INSTANCE) pinst, 0, JET_paramTempPath, 0, szTempDatabase ) );
		}

	//	Start to do JetRestore on this instance

	pcritInst = &critpoolPinstAPI.Crit(&g_rgpinst[ipinst]);
	pcritInst->Enter();

	if ( !apicall.FEnterForInit( pinst ) )
		{
		pcritInst->Leave();
		err = apicall.ErrResult();
		goto HandleError;
		}

	pinst->APILock( pinst->fAPIRestoring );
	pcritInst->Leave();

	Assert( !pinst->m_fJetInitialized );
	Assert( !pinst->m_fTermInProgress );

	err = ErrInit(	pinst,
					fTrue,		//	fSkipIsamInit
					0 );		//	grbit
	Assert( JET_errAlreadyInitialized != err );

	Assert( !pinst->m_fJetInitialized );
	Assert( !pinst->m_fTermInProgress );

	if ( err >= 0 )
		{
		pinst->m_fJetInitialized = fTrue;

		// now, other restore what will try to do restore on the same instance
		// will error out with "restore in progress" from ErrINSTPrepareTargetInstance (actually ErrAPIEnter)
		// because we set fAPIRestoring AND m_fJetInitialized
		critRestoreInst.Leave();
		fInCritRestoreInst = fFalse;

		strcpy( pinst->m_plog->m_szTargetInstanceLogPath , szTargetLogPath );
		pinst->m_plog->m_lGenHighTargetInstance = lGenHighTarget;

		err = ErrIsamExternalRestore(
					(JET_INSTANCE) pinst,
					szRestoreSystemPath,
					szRestoreLogPath,
					rgrstmap,
					crstfilemap,
					szBackupLogPath,
					genLow,
					genHigh,
					pfn );

//		OSUTerm();

		}
	else
		{
		critRestoreInst.Leave();
		fInCritRestoreInst = fFalse;
		}

	pinst->m_fJetInitialized = fFalse;

	pinst->APIUnlock( pinst->fAPIRestoring );

//	pcritInst->Leave();

	//	Return and delete the instance
	Assert ( !fInCritInst );

	apicall.LeaveAfterCall( err );

	FreePinst( pinst );

	Assert( NULL != szNewInstanceName );
	delete[] szNewInstanceName;

	return apicall.ErrResult();

HandleError:
	if ( pinst )
		{
		FreePinst( pinst );
		}

	if ( fInCritInst )
		{
		INST::LeaveCritInst();
		}

	if ( fInCritRestoreInst )
		{
		critRestoreInst.Leave();
		fInCritRestoreInst = fFalse;
		}

	if ( szNewInstanceName )
		{
		delete[] szNewInstanceName;
		}

	return err;
	}

LOCAL JET_ERR JetExternalRestore2Ex(
	char			*szCheckpointFilePath,
	char			*szLogPath,
	JET_RSTMAP		*rgrstmap,
	long			crstfilemap,
	char			*szBackupLogPath,
	JET_LOGINFO * pLogInfo,
	char *			szTargetInstanceName,
	char *			szTargetInstanceCheckpointPath,
	char *			szTargetInstanceLogPath,
	JET_PFNSTATUS	pfn )
	{

	if ( !pLogInfo || pLogInfo->cbSize != sizeof(JET_LOGINFO) )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	return JetExternalRestoreEx(	szCheckpointFilePath,
									szLogPath,
									rgrstmap,
									crstfilemap,
									szBackupLogPath,
									pLogInfo->ulGenLow,
									pLogInfo->ulGenHigh,
									pLogInfo->szBaseName,
									szTargetInstanceName,
									szTargetInstanceCheckpointPath,
									szTargetInstanceLogPath,
									pfn );

	}

JET_ERR JET_API JetExternalRestore(
	char			*szCheckpointFilePath,
	char			*szLogPath,
	JET_RSTMAP		*rgrstmap,
	long			crstfilemap,
	char			*szBackupLogPath,
	long			genLow,
	long			genHigh,
	JET_PFNSTATUS	pfn )
	{
	JET_TRY( JetExternalRestoreEx( szCheckpointFilePath, szLogPath, rgrstmap, crstfilemap, szBackupLogPath, genLow, genHigh, NULL, NULL, NULL, NULL, pfn ) );
	}

JET_ERR JET_API JetExternalRestore2( 	char *szCheckpointFilePath,
										char *szLogPath,
										JET_RSTMAP *rgrstmap,
										long crstfilemap,
										char *szBackupLogPath,
										JET_LOGINFO * pLogInfo,
										char *szTargetInstanceName,
										char *szTargetInstanceCheckpointPath,
										char *szTargetInstanceLogPath,
										JET_PFNSTATUS pfn )
	{
	JET_TRY( JetExternalRestore2Ex( szCheckpointFilePath, szLogPath, rgrstmap, crstfilemap, szBackupLogPath, pLogInfo, szTargetInstanceName, szTargetInstanceCheckpointPath, szTargetInstanceLogPath, pfn ) );
	}

LOCAL JET_ERR JetSnapshotStartEx(	JET_INSTANCE 		instance,
									char * 				szDatabases,
									JET_GRBIT			grbit)
	{
	APICALL_INST	apicall( opSnapshotStart );

	if ( apicall.FEnter( instance ) )
		{
		apicall.LeaveAfterCall( ErrIsamSnapshotStart(
										(JET_INSTANCE)apicall.Pinst(),
										szDatabases,
										grbit ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetSnapshotStart( 		JET_INSTANCE 		instance,
										char * 				szDatabases,
										JET_GRBIT			grbit)
	{
	JET_TRY( JetSnapshotStartEx( instance, szDatabases, grbit ) );
	}

LOCAL JET_ERR JetSnapshotStopEx(	JET_INSTANCE 		instance,
									JET_GRBIT			grbit)
	{
	APICALL_INST	apicall( opSnapshotStop );

	if ( apicall.FEnter( instance ) )
		{
		apicall.LeaveAfterCall( ErrIsamSnapshotStop(
										(JET_INSTANCE)apicall.Pinst(),
										grbit ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetSnapshotStop( 		JET_INSTANCE 				instance,
										JET_GRBIT 					grbit)
	{
	JET_TRY( JetSnapshotStopEx( instance, grbit ) );
	}


LOCAL JET_ERR JetResetCounterEx( JET_SESID sesid, long CounterType )
	{
	APICALL_SESID	apicall( opResetCounter );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrIsamResetCounter( sesid, CounterType ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetResetCounter( JET_SESID sesid, long CounterType )
	{
	JET_TRY( JetResetCounterEx( sesid, CounterType ) );
	}


LOCAL JET_ERR JetGetCounterEx( JET_SESID sesid, long CounterType, long *plValue )
	{
	APICALL_SESID	apicall( opGetCounter );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrIsamGetCounter(
										sesid,
										CounterType,
										plValue ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetGetCounter( JET_SESID sesid, long CounterType, long *plValue )
	{
	JET_TRY( JetGetCounterEx( sesid, CounterType, plValue ) );
	}


LOCAL JET_ERR JetCompactEx(
	JET_SESID		sesid,
	const char		*szDatabaseSrc,
	const char		*szDatabaseDest,
	JET_PFNSTATUS	pfnStatus,
	JET_CONVERT		*pconvert,
	JET_GRBIT		grbit )
	{
	APICALL_SESID	apicall( opCompact );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrIsamCompact(
										sesid,
										szDatabaseSrc,
										PinstFromSesid( sesid )->m_pfsapi,
										szDatabaseDest,
										NULL,
										pfnStatus,
										pconvert,
										grbit ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetCompact(
	JET_SESID		sesid,
	const char		*szDatabaseSrc,
	const char		*szDatabaseDest,
	JET_PFNSTATUS	pfnStatus,
	JET_CONVERT		*pconvert,
	JET_GRBIT		grbit )
	{
	JET_TRY( JetCompactEx( sesid, szDatabaseSrc, szDatabaseDest, pfnStatus, pconvert, grbit ) );
	}


LOCAL JET_ERR JetConvertDDLEx(
	JET_SESID		sesid,
	JET_DBID		ifmp,
	JET_OPDDLCONV	convtyp,
	void			*pvData,
	unsigned long	cbData )
	{
	ERR 			err;
	APICALL_SESID	apicall( opConvertDDL );

	if ( !apicall.FEnter( sesid ) )
		return apicall.ErrResult();

	PIB * const ppib = (PIB *)sesid;
	Call( ErrPIBCheck( ppib ) );
	Call( ErrPIBCheckUpdatable( ppib ) );
	Call( ErrPIBCheckIfmp( ppib, ifmp ) );

	if( NULL == pvData
		|| 0 == cbData )
		{
		Call( ErrERRCheck( JET_errInvalidParameter ) );
		}

	switch( convtyp )
		{
		case opDDLConvAddCallback:
			{
			if( sizeof( JET_DDLADDCALLBACK ) != cbData )
				{
				return ErrERRCheck( JET_errInvalidParameter );
				}
			const JET_DDLADDCALLBACK * const paddcallback = (JET_DDLADDCALLBACK *)pvData;
			const CHAR * const szTable 		= paddcallback->szTable;
			const JET_CBTYP cbtyp 			= paddcallback->cbtyp;
			const CHAR * const szCallback 	= paddcallback->szCallback;
			err = ErrCATAddCallbackToTable( ppib, ifmp, szTable, cbtyp, szCallback );
			}
			break;

		case opDDLConvChangeColumn:
			{
			if( sizeof( JET_DDLCHANGECOLUMN ) != cbData )
				{
				return ErrERRCheck( JET_errInvalidParameter );
				}
			const JET_DDLCHANGECOLUMN * const pchangecolumn = (JET_DDLCHANGECOLUMN *)pvData;
			const CHAR * const szTable 	= pchangecolumn->szTable;
			const CHAR * const szColumn = pchangecolumn->szColumn;
			const JET_COLTYP coltyp 	= pchangecolumn->coltypNew;
			const JET_GRBIT grbit 		= pchangecolumn->grbitNew;
			err = ErrCATConvertColumn( ppib, ifmp, szTable, szColumn, coltyp, grbit );
			}
			break;

		case opDDLConvAddConditionalColumnsToAllIndexes:
			{
			if( sizeof( JET_DDLADDCONDITIONALCOLUMNSTOALLINDEXES ) != cbData )
				{
				return ErrERRCheck( JET_errInvalidParameter );
				}
			const JET_DDLADDCONDITIONALCOLUMNSTOALLINDEXES * const paddcondidx 	= (JET_DDLADDCONDITIONALCOLUMNSTOALLINDEXES *)pvData;
			const CHAR * const szTable 											= paddcondidx->szTable;
			const JET_CONDITIONALCOLUMN * const rgconditionalcolumn				= paddcondidx->rgconditionalcolumn;
			const ULONG cConditionalColumn 										= paddcondidx->cConditionalColumn;
			err = ErrCATAddConditionalColumnsToAllIndexes( ppib, ifmp, szTable, rgconditionalcolumn, cConditionalColumn );
			}
			break;

		case opDDLConvAddColumnCallback:
			{
			if( sizeof( JET_DDLADDCOLUMNCALLBACK ) != cbData )
				{
				return ErrERRCheck( JET_errInvalidParameter );
				}
			const JET_DDLADDCOLUMNCALLBACK * const paddcolumncallback = (JET_DDLADDCOLUMNCALLBACK *)pvData;

			const CHAR * const szTable 			= paddcolumncallback->szTable;
			const CHAR * const szColumn			= paddcolumncallback->szColumn;
			const CHAR * const szCallback 		= paddcolumncallback->szCallback;
			const VOID * const pvCallbackData	= paddcolumncallback->pvCallbackData;
			const unsigned long cbCallbackData 	= paddcolumncallback->cbCallbackData;

			err = ErrCATAddColumnCallback( ppib, ifmp, szTable, szColumn, szCallback, pvCallbackData, cbCallbackData );
			}
			break;

		case opDDLConvIncreaseMaxColumnSize:
			{
			if ( sizeof( JET_DDLMAXCOLUMNSIZE ) != cbData )
				{
				return ErrERRCheck( JET_errInvalidParameter );
				}

			const JET_DDLMAXCOLUMNSIZE * const	pmaxcolumnsize	= (JET_DDLMAXCOLUMNSIZE *)pvData;

			const CHAR * const	szTable		= pmaxcolumnsize->szTable;
			const CHAR * const	szColumn	= pmaxcolumnsize->szColumn;
			const ULONG			cbMaxLen	= pmaxcolumnsize->cbMax;

			err = ErrCATIncreaseMaxColumnSize( ppib, ifmp, szTable, szColumn, cbMaxLen );
			break;
			}

		case opDDLConvChangeIndexDensity:
			{
			if ( sizeof( JET_DDLINDEXDENSITY ) != cbData )
				{
				return ErrERRCheck( JET_errInvalidParameter );
				}

			const JET_DDLINDEXDENSITY * const	pindexdensity	= (JET_DDLINDEXDENSITY *)pvData;

			const CHAR * const	szTable		= pindexdensity->szTable;
			const CHAR * const	szIndex		= pindexdensity->szIndex;
			const ULONG			ulDensity	= pindexdensity->ulDensity;

			err = ErrCATChangeIndexDensity( ppib, ifmp, szTable, szIndex, ulDensity );
			break;
			}

		case opDDLConvNull:
		case opDDLConvMax:
		default:
			err = ErrERRCheck( JET_errInvalidParameter );
			break;
		}

HandleError:
	apicall.LeaveAfterCall( err );
	return apicall.ErrResult();
	}

JET_ERR JET_API JetConvertDDL(
	JET_SESID		sesid,
	JET_DBID		ifmp,
	JET_OPDDLCONV	convtyp,
	void			*pvData,
	unsigned long	cbData )
	{
	JET_TRY( JetConvertDDLEx( sesid, ifmp, convtyp, pvData, cbData ) );
	}


LOCAL JET_ERR JetUpgradeDatabaseEx(
	JET_SESID		sesid,
	const CHAR		*szDbFileName,
	const CHAR		*szSLVFileName,
	const JET_GRBIT	grbit )
	{
	APICALL_SESID	apicall( opUpgradeDatabase );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrDBUpgradeDatabase(
										sesid,
										szDbFileName,
										szSLVFileName,
										grbit ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetUpgradeDatabase(
	JET_SESID		sesid,
	const CHAR		*szDbFileName,
	const CHAR		*szSLVFileName,
	const JET_GRBIT	grbit )
	{
	JET_TRY( JetUpgradeDatabaseEx( sesid, szDbFileName, szSLVFileName, grbit ) );
	}


INLINE JET_ERR JetIUtilities( JET_SESID sesid, JET_DBUTIL *pdbutil )
	{
	APICALL_SESID	apicall( opDBUtilities );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrIsamDBUtilities( sesid, pdbutil ) );
		}

	return apicall.ErrResult();
	}

extern "C" LOCAL JET_ERR JetInitEx(	JET_INSTANCE	*pinstance,
									JET_RSTMAP		*rgrstmap,
									long			crstfilemap,
									JET_GRBIT		grbit );

LOCAL JET_ERR JetDBUtilitiesEx( JET_DBUTIL *pdbutil )
	{
	AssertSzRTL( (JET_DBUTIL*)0 != pdbutil, "Invalid (NULL) pdbutil. Call JET dev." );
	AssertSzRTL( (JET_DBUTIL*)(-1) != pdbutil, "Invalid (-1) pdbutil. Call JET dev." );
	JET_ERR			err				= JET_errSuccess;
	JET_INSTANCE	instance		= 0;
	JET_SESID		sesid			= pdbutil->sesid;
	BOOL			fInit			= fFalse;

	if ( pdbutil->cbStruct != sizeof(JET_DBUTIL) )
		return ErrERRCheck( JET_errInvalidParameter );

	// Don't init if we're only dumping the logfile/checkpoint/DB header.
	switch( pdbutil->op )
		{
		case opDBUTILDumpHeader:
		case opDBUTILDumpLogfile:
		case opDBUTILDumpCheckpoint:
		case opDBUTILDumpLogfileTrackNode:
		case opDBUTILDumpPage:
		case opDBUTILDumpNode:
		case opDBUTILSLVMove:
			Call( JetInit( &instance ) );
			fInit = fTrue;
			Call( JetBeginSession( instance, &sesid, "user", "" ) );

			Call( ErrIsamDBUtilities( sesid, pdbutil ) );
			break;

		case opDBUTILEDBDump:
		case opDBUTILEDBRepair:
		case opDBUTILEDBScrub:
		case opDBUTILDBConvertRecords:
		case opDBUTILDBDefragment:
			Call( ErrIsamDBUtilities( pdbutil->sesid, pdbutil ) );
			break;

		case opDBUTILDumpData:
		default:
			if ( 0 == sesid || JET_sesidNil == sesid )
				{
				Call( JetInit( &instance ) );
				fInit = fTrue;
				Call( JetBeginSession( instance, &sesid, "user", "" ) );
				}

			Call( JetIUtilities( sesid, pdbutil ) );
			break;
		}

HandleError:
	if ( fInit )
		{
		if( sesid != 0 )
			{
			JetEndSession( sesid, 0 );
			}
		JetTerm2( instance, err < 0 ? JET_bitTermAbrupt : JET_bitTermComplete );
		}

	return err;
	}
JET_ERR JET_API JetDBUtilities( JET_DBUTIL *pdbutil )
	{
	JET_TRY( JetDBUtilitiesEx( pdbutil ) );
	}


LOCAL JET_ERR JetDefragmentEx(
	JET_SESID		sesid,
	JET_DBID		dbid,
	const char		*szDatabaseName,
	const char		*szTableName,
	unsigned long	*pcPasses,
	unsigned long  	*pcSeconds,
	JET_CALLBACK	callback,
	void			*pvContext,
	JET_GRBIT		grbit )
	{
	APICALL_SESID	apicall( opDefragment );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrIsamDefragment(
										sesid,
										dbid,
										szTableName,
										pcPasses,
										pcSeconds,
										callback,
										grbit ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetDefragment(
	JET_SESID		vsesid,
	JET_DBID		vdbid,
	const char		*szTableName,
	unsigned long	*pcPasses,
	unsigned long	*pcSeconds,
	JET_GRBIT		grbit )
	{
	JET_TRY( JetDefragmentEx( vsesid, vdbid, NULL, szTableName, pcPasses, pcSeconds, NULL, NULL, grbit ) );
	}
JET_ERR JET_API JetDefragment2(
	JET_SESID		vsesid,
	JET_DBID		vdbid,
	const char		*szTableName,
	unsigned long	*pcPasses,
	unsigned long	*pcSeconds,
	JET_CALLBACK	callback,
	JET_GRBIT		grbit )
	{
	JET_TRY( JetDefragmentEx( vsesid, vdbid, NULL, szTableName, pcPasses, pcSeconds, callback, NULL, grbit ) );
	}


LOCAL JET_ERR JetSetDatabaseSizeEx(
	JET_SESID		sesid,
	const CHAR		*szDatabaseName,
	ULONG			cpg,
	ULONG			*pcpgReal )
	{
	APICALL_SESID	apicall( opSetDatabaseSize );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrIsamSetDatabaseSize(
										sesid,
										szDatabaseName,
										cpg,
										pcpgReal ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetSetDatabaseSize(
	JET_SESID		vsesid,
	const CHAR		*szDatabaseName,
	ULONG			cpg,
	ULONG			*pcpgReal )
	{
	JET_TRY( JetSetDatabaseSizeEx( vsesid, szDatabaseName, cpg, pcpgReal ) );
	}


LOCAL JET_ERR JetGrowDatabaseEx(
	JET_SESID		sesid,
	JET_DBID		dbid,
	ULONG			cpg,
	ULONG			*pcpgReal )
	{
	APICALL_SESID	apicall( opGrowDatabase );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrIsamGrowDatabase(
										sesid,
										dbid,
										cpg,
										pcpgReal ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetGrowDatabase(
	JET_SESID		vsesid,
	JET_DBID		dbid,
	ULONG			cpg,
	ULONG			*pcpgReal )
	{
	JET_TRY( JetGrowDatabaseEx( vsesid, dbid, cpg, pcpgReal ) );
	}


LOCAL JET_ERR JetSetSessionContextEx( JET_SESID sesid, ULONG_PTR ulContext )
	{
	APICALL_SESID	apicall( opSetSessionContext );

	if ( apicall.FEnter( sesid ) )
		{
		apicall.LeaveAfterCall( ErrIsamSetSessionContext( sesid, ulContext ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetSetSessionContext( JET_SESID vsesid, ULONG_PTR ulContext )
	{
	JET_TRY( JetSetSessionContextEx( vsesid, ulContext ) );
	}

LOCAL JET_ERR JetResetSessionContextEx( JET_SESID sesid )
	{
	APICALL_SESID	apicall( opResetSessionContext );

	if ( apicall.FEnter( sesid, fTrue ) )
		{
		apicall.LeaveAfterCall( ErrIsamResetSessionContext( sesid ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetResetSessionContext( JET_SESID sesid )
	{
	JET_TRY( JetResetSessionContextEx( sesid ) );
	}


/*=================================================================
JetSetSystemParameter

Description:
  This function sets system parameter values.  It calls ErrSetSystemParameter
  to actually set the parameter values.

Parameters:
  sesid 	is the optional session identifier for dynamic parameters.
  paramid	is the system parameter code identifying the parameter.
  lParam	is the parameter value.
  sz		is the zero terminated string parameter.

Return Value:
  JET_errSuccess if the routine can perform all operations cleanly;
  some appropriate error value otherwise.

Errors/Warnings:
  JET_errInvalidParameter:
	  Invalid parameter code.
  JET_errAlreadyInitialized:
	  Initialization parameter cannot be set after the system is initialized.
  JET_errInvalidSesid:
	  Dynamic parameters require a valid session id.

Side Effects:
  * May allocate memory
=================================================================*/

LOCAL JET_ERR JetSetSystemParameterEx(
	JET_INSTANCE	*pinstance,
	JET_SESID		sesid,
	unsigned long	paramid,
	ULONG_PTR		lParam,
	const char		*sz )
	{
	APICALL_INST	apicall( opSetSystemParameter );
	INST 			*pinst;

	if ( FAllowSetGlobalSysParamAfterStart( paramid ) )
		{
		return ErrSetSystemParameter( 0, 0, paramid, lParam, sz );
		}

	SetPinst( pinstance, sesid, &pinst );

	switch ( RUNINSTGetMode() )
		{
		default:
			Assert( fFalse );
			//	fall through to no current mode:
		case runInstModeNoSet:
			//	setting for global default
			Assert( !sesid || sesid == JET_sesidNil );
			return ErrSetSystemParameter( 0, 0, paramid, lParam, sz );

		case runInstModeOneInst:
			if ( !sesid || JET_sesidNil == sesid )
				return ErrERRCheck( JET_errInvalidParameter );
			Assert( !FINSTInvalid( (JET_INSTANCE)pinst ) );
			break;

		case runInstModeMultiInst:
			// in multi-inst mode, global setting only through JetEnableMultiInstance
			if ( FINSTInvalid( (JET_INSTANCE)pinst ) )
				return ErrERRCheck( JET_errInvalidParameter );
			break;
		}

	Assert( !FINSTInvalid( (JET_INSTANCE)pinst ) );

	//	this flag is a hack for logshipping to allow it to abort
	//	UNDONE: instead of this hack, should add a new JetAbortLogshipping() API
	const BOOL		fAllowInitInProgress	= ( JET_paramReplayingReplicatedLogfiles == paramid && !lParam );

	if ( apicall.FEnterWithoutInit( pinst, fAllowInitInProgress ) )
		{
		apicall.LeaveAfterCall( ErrSetSystemParameter(
										(JET_INSTANCE)pinst,
										sesid,
										paramid,
										lParam,
										sz ) );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetSetSystemParameter(
	JET_INSTANCE	*pinstance,
	JET_SESID		sesid,
	ULONG			paramid,
	ULONG_PTR		lParam,
	const char		*sz )
	{
	JET_TRY( JetSetSystemParameterEx( pinstance, sesid, paramid, lParam, sz ) );
	}


ERR ErrInitAlloc(
	INST **ppinst,
	const char * szInstanceName = NULL,
	const char * szDisplayName = NULL,
	int *pipinst = NULL )
	{
	ERR		err = JET_errSuccess;

	Assert( ppinst );
	//	Get a new instance
	err = ErrNewInst( ppinst, szInstanceName, szDisplayName, pipinst );
	if ( err < 0 )
		return err;

	Assert( !(*ppinst)->m_fJetInitialized );
	return err;
	}

ERR ErrTermAlloc( JET_INSTANCE instance )
	{
	ERR		err 	= JET_errSuccess;
	INST	*pinst;

	CallR( ErrFindPinst( instance, &pinst ) );

	FreePinst( pinst );

	return err;
	}


ERR ErrInitComplete(	JET_INSTANCE	instance,
						JET_RSTMAP		*rgrstmap,
						long			crstfilemap,
						JET_GRBIT		grbit )
	{
	APICALL_INST	apicall( opInit );
	ERR				err;
	INST *			pinst;
	INT				ipinst;

	CallR( ErrFindPinst( instance, &pinst, &ipinst ) );

	//	Enter API for this instance

	CCriticalSection *pcritInst = &critpoolPinstAPI.Crit(&g_rgpinst[ipinst]);
	pcritInst->Enter();

	if ( !apicall.FEnterForInit( pinst ) )
		{
		pcritInst->Leave();
		return apicall.ErrResult();
		}

	pinst->APILock( pinst->fAPIInitializing );
	pcritInst->Leave();

	Assert( !pinst->m_fJetInitialized );
	Assert( !pinst->m_fTermInProgress );

	Assert ( err >= 0 );

	Call( pinst->m_plog->ErrLGRSTBuildRstmapForSoftRecovery( rgrstmap, crstfilemap ) );

	err = ErrInit(	pinst,
					fFalse,			//	fSkipIsamInit
					grbit );

	Assert( JET_errAlreadyInitialized != err );

	Assert( !pinst->m_fJetInitialized );
	Assert( !pinst->m_fTermInProgress );

	if ( err >= 0 )
		{
		pinst->m_fJetInitialized = fTrue;

		//	backup allowed only after Jet is properly initialized.

		pinst->m_fBackupAllowed = fTrue;
		}

	Assert( !pinst->m_fTermInProgress );

HandleError:

	pinst->m_plog->LGRSTFreeRstmap();

	pinst->APIUnlock( pinst->fAPIInitializing );

	apicall.LeaveAfterCall( err );
	return apicall.ErrResult();
	}

ERR ErrTermComplete( JET_INSTANCE instance, JET_GRBIT grbit )
	{
	APICALL_INST	apicall( opTerm );
	ERR				err;
	INST *			pinst;
	INT				ipinst;

	CallR( ErrFindPinst( instance, &pinst, &ipinst ) );

	CCriticalSection *pcritInst = &critpoolPinstAPI.Crit(&g_rgpinst[ipinst]);
	pcritInst->Enter();

	//	verify no one beat us to it
	//
	if ( g_rgpinst[ipinst] != pinst )
		{
		pcritInst->Leave();
		return ErrERRCheck( JET_errNotInitialized );
		}
	else if ( !pinst->m_fJetInitialized
		&& pinst->m_fSTInit == fSTInitNotDone )
		{
		//	instance was allocated, but never initialized
		//	(or possibly the instance has been terminated
		//	but not yet cleaned up, in which case we end
		//	up racing with the thread who terminated the
		//	instance, but hasn't yet cleaned up the INST
		//	resource - it doesn't really matter who wins)
		//
		pcritInst->Leave();
		CallS( ErrTermAlloc( instance ) );
		return JET_errSuccess;
		}

	if ( !apicall.FEnterForTerm( pinst ) )
		{
		pcritInst->Leave();
		return apicall.ErrResult();
		}

	AtomicIncrement( (LONG *)&g_cTermsInProgress );

	Assert( !pinst->m_fTermInProgress );
	pinst->m_fTermInProgress = fTrue;

	size_t cpibInJetAPI;
	do
		{
		cpibInJetAPI = 0;

		pinst->m_critPIB.Enter();
		for ( PIB* ppibScan = pinst->m_ppibGlobal; ppibScan; ppibScan = ppibScan->ppibNext )
			{
			//	skip PIB's on the global list which are actually free
			//	(their m_cInJetAPI may actually be non-zero, because
			//	we leave them as non-zero to try to trap anyone
			//	using a session that's been closed)
			//
			if ( levelNil != ppibScan->level )
				{
				cpibInJetAPI += ppibScan->m_cInJetAPI;
				}
			}
		pinst->m_critPIB.Leave();

		if ( cpibInJetAPI )
			{
			UtilSleep( cmsecWaitGeneric );
			}
		}
	while ( cpibInJetAPI );

	pinst->APILock( pinst->fAPITerminating );
	pcritInst->Leave();

	Assert( pinst->m_fJetInitialized );

	pinst->m_fBackupAllowed = fFalse;
	if ( grbit & JET_bitTermStopBackup )
		{
		// BUG_125711 (also in jet.h, JET_errBackupAbortByServer added)
		// will close the backup resources only if needed. Will return JET_errNoBackup if no backup.
		CallSx( pinst->m_plog->ErrLGBKIExternalBackupCleanUp( pinst->m_pfsapi, JET_errBackupAbortByServer ), JET_errNoBackup );
		// thats' all for this bug

		//	UNDONE: if cleanup failed, resources may not have been freed
		//	properly, so we may end up asserting/hanging/crashing/???
		//	later on in the termination process
		//
		pinst->m_plog->m_fBackupInProgress = fFalse;
		pinst->m_plog->m_fStopBackup = fFalse;
		pinst->m_plog->m_fBackupStatus = LOG::backupStateNotStarted;
		}

	err = ErrIsamTerm( (JET_INSTANCE)pinst, grbit );
	Assert( pinst->m_fJetInitialized );

	//	ipinstMac is about to be decremented, so must
	//	decrement cTermsInProgress accordingly
	//
	AtomicDecrement( (LONG *)&g_cTermsInProgress );

	const BOOL	fTermCompleted	= ( fSTInitNotDone == pinst->m_fSTInit );	//	is ISAM initialised?

	if ( fTermCompleted )
		{
//		OSUTerm();
		pinst->m_fJetInitialized = fFalse;
		}

	pinst->APIUnlock( pinst->fAPITerminating );

	apicall.LeaveAfterCall( err );

	if ( fTermCompleted )
		{
		CallS( ErrTermAlloc( instance ) );
		}

	return apicall.ErrResult();
	}


/*
Teh runing mode must be "NoSet" then set the mode to multi-instance.
Used to set the global param.

In:
	psetsysparam - array of parameters to set
	csetsysparam - items count in array

Out:
	pcsetsucceed - count of params set w/o error (pointer can de NULL)
	psetsysparam[i].err - set to error code from setting  psetsysparam[i].param

Return:
	JET_errSuccess or first error in array

Obs:
	it stops at the first error
*/
LOCAL JET_ERR JetEnableMultiInstanceEx(
	JET_SETSYSPARAM	*psetsysparam,
	unsigned long	csetsysparam,
	unsigned long	*pcsetsucceed )
	{
	ERR	 			err 			= JET_errSuccess;
	unsigned int 	i;
	unsigned long 	csetsucceed;

	csetsucceed = 0;

	INST::EnterCritInst();

	if ( RUNINSTGetMode() != runInstModeNoSet)
		{
		// function can't be called twice (JET_errSystemParamsAlreadySet) or in One Instance Mode (JET_errRunningInOneInstanceMode)
		Call( ErrERRCheck( RUNINSTGetMode() == runInstModeMultiInst ?
								JET_errSystemParamsAlreadySet :
								JET_errRunningInOneInstanceMode ) );
		}

	Assert ( 0 == csetsysparam ||NULL != psetsysparam );
	for (i = 0; i < csetsysparam; i++)
		{
		psetsysparam[i].err = ErrSetSystemParameter(0, 0, psetsysparam[i].paramid, psetsysparam[i].lParam, psetsysparam[i].sz);
		if ( JET_errSuccess > err)
			{
			Call( psetsysparam[i].err );
			}
		csetsucceed++;
		}

	// if setting was successful, set the multi-instance mode
	Assert( err >= JET_errSuccess );
	RUNINSTSetModeMultiInst();

HandleError:
	// UNDONE: if error: restore the params changed before the error
	//

	INST::LeaveCritInst();

	if (pcsetsucceed)
		{
		*pcsetsucceed = csetsucceed;
		}

	Assert ( err < JET_errSuccess || !pcsetsucceed || csetsysparam == *pcsetsucceed );
	return err;
	}

JET_ERR JET_API JetEnableMultiInstance(
	JET_SETSYSPARAM	*psetsysparam,
	unsigned long	csetsysparam,
	unsigned long	*pcsetsucceed )
	{
	JET_TRY( JetEnableMultiInstanceEx( psetsysparam, csetsysparam, pcsetsucceed ) );
	}


LOCAL JET_ERR JetInitEx(
	JET_INSTANCE *	pinstance,
	JET_RSTMAP		*rgrstmap,
	LONG			crstfilemap,
	JET_GRBIT		grbit )
	{
	ERR				err 				= JET_errSuccess;
	BOOL			fAllocateInstance 	= ( NULL == pinstance || FINSTInvalid( *pinstance ) );
	INST *			pinst;

	if ( fAllocateInstance && NULL != pinstance )
		*pinstance = JET_instanceNil;

	INST::EnterCritInst();

	// instance value to be returned must be provided in multi-instance
	if ( RUNINSTGetMode() == runInstModeMultiInst && !pinstance )
		{
		INST::LeaveCritInst();
		return ErrERRCheck( JET_errRunningInMultiInstanceMode );
		}

	// just one instance accepted in one instance mode
	if ( RUNINSTGetMode() == runInstModeOneInst && 0 != ipinstMac )
		{
		INST::LeaveCritInst();
		return ErrERRCheck( JET_errAlreadyInitialized ); // one instance already started
		}

	// set the instance mode to multi-instance if not set. That means:
	// no previous call to JetSetSystemParam, JetEnableMultiInstance, JetCreateInstance, JetInit
	// or all the previous started instances are no longer active
	if ( RUNINSTGetMode() == runInstModeNoSet )
		{
		Assert ( 0 == ipinstMac);
//		RUNINSTSetModeMultiInst();
		RUNINSTSetModeOneInst();
		}

	// in one instance mode, allocate instance even if pinstance (and *pinstance) not null
	// because this values can be bogus
	fAllocateInstance = fAllocateInstance | (RUNINSTGetMode() == runInstModeOneInst);

	INST::LeaveCritInst();

	// alocate a new instance or find the one provided (previously allocate with JetCreateInstance)
	if ( fAllocateInstance )
		{
		Call( ErrInitAlloc( &pinst ) );
		}
	else
		{
		Call( ErrFindPinst( *pinstance, &pinst ) );
		}

	// make the initialization

	CallJ( ErrInitComplete(	JET_INSTANCE( pinst ),
							rgrstmap,
							crstfilemap,
							grbit ), TermAlloc );

	Assert( err >= 0 );

	if ( fAllocateInstance && pinstance )
		*pinstance = (JET_INSTANCE) pinst;

	return err;

TermAlloc:
	Assert( err < 0 );
	// if instance allocated in this function call
	// or created by create instance, clean it
	if ( fAllocateInstance || ( NULL != pinstance && !FINSTInvalid( *pinstance ) ) )
		{
		ErrTermAlloc( (JET_INSTANCE)pinst );
		if ( NULL != pinstance )
			{
			*pinstance = NULL;
			}
		}

HandleError:
	Assert( err < 0 );
	return err;
	}
JET_ERR JET_API JetInit( JET_INSTANCE *pinstance )
	{
	return JetInit2( pinstance, NO_GRBIT );
	}

JET_ERR JET_API JetInit2( JET_INSTANCE *pinstance, JET_GRBIT grbit )
	{
	JET_TRY( JetInitEx( pinstance, NULL, 0, grbit ) );
	}

JET_ERR JET_API JetInit3(
	JET_INSTANCE *pinstance,
	JET_RSTMAP *rgrstmap,
	long crstfilemap,
	JET_GRBIT grbit )
	{
	JET_TRY( JetInitEx( pinstance, rgrstmap, crstfilemap, grbit ) );
	}



/*
Used to allocate an instance. This allowes to change
the instance parameters before calling JetInit for that instance.
The system params for this instance are set to the global ones
*/
LOCAL JET_ERR JetCreateInstanceEx(
	JET_INSTANCE *pinstance,
	const char * szInstanceName,
	const char * szDisplayName )
	{
	ERR			err 	= JET_errSuccess;
	INST *		pinst;

	// the allocated instance must be returned
	if ( !pinstance )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	Assert ( pinstance );
	*pinstance = JET_instanceNil;

	INST::EnterCritInst();

	// not allowed in one instance mode
	if ( RUNINSTGetMode() == runInstModeOneInst )
		{
		INST::LeaveCritInst();
		return ErrERRCheck( JET_errRunningInOneInstanceMode );
		}

	// set to multi-instance mode if not set
	if ( RUNINSTGetMode() == runInstModeNoSet)
		{
		RUNINSTSetModeMultiInst();
		}
	INST::LeaveCritInst();

	Assert ( RUNINSTGetMode() == runInstModeMultiInst );

	err = ErrInitAlloc( &pinst, szInstanceName, szDisplayName );

	if (err >= JET_errSuccess)
		{
		Assert ( pinstance );
		*pinstance = (JET_INSTANCE) pinst;
		}

	return err;
	}

JET_ERR JET_API JetCreateInstance(
	JET_INSTANCE *pinstance,
	const char * szInstanceName)
	{
	return JetCreateInstance2( pinstance, szInstanceName, NULL, NO_GRBIT );
	}

// Note: grbit is currently unused
JET_ERR JET_API JetCreateInstance2(
	JET_INSTANCE *pinstance,
	const char * szInstanceName,
	const char * szDisplayName,
	JET_GRBIT grbit )
	{
	JET_TRY( JetCreateInstanceEx( pinstance, szInstanceName, szDisplayName ) );
	}


LOCAL JET_ERR JetRestoreInstanceEx(
	JET_INSTANCE	instance,
	const char		*sz,
	const char		*szDest,
	JET_PFNSTATUS	pfn )
	{
	APICALL_INST	apicall( opInit );
	ERR				err;
	BOOL			fAllocateInstance 	= FINSTInvalid( instance ) ;
	INST			*pinst;
	INT				ipinst;
	CCriticalSection *pcritInst;

	if ( fAllocateInstance )
		{
		CallR( ErrInitAlloc( &pinst, szRestoreInstanceName, NULL, &ipinst ) );
		}
	else
		{
		CallR( ErrFindPinst( instance, &pinst, &ipinst ) );
		}

	pcritInst = &critpoolPinstAPI.Crit(&g_rgpinst[ipinst]);
	pcritInst->Enter();

	if ( !apicall.FEnterForInit( pinst ) )
		{
		pcritInst->Leave();
		if ( fAllocateInstance )
			{
			ErrTermAlloc( (JET_INSTANCE) pinst );
			}
		return apicall.ErrResult();
		}

	pinst->APILock( pinst->fAPIRestoring );
	pcritInst->Leave();

	Assert( !pinst->m_fJetInitialized );
	Assert( !pinst->m_fTermInProgress );

	err = ErrInit(	pinst,
					fTrue,		//	fSkipIsamInit
					0 );

	Assert( JET_errAlreadyInitialized != err );

	Assert( !pinst->m_fJetInitialized );
	Assert( !pinst->m_fTermInProgress );

	if ( err >= 0 )
		{
		pinst->m_fJetInitialized = fTrue;

		err = ErrIsamRestore( (JET_INSTANCE) pinst, (char *)sz, (char *)szDest, pfn );

//		OSUTerm();

		pinst->m_fJetInitialized = fFalse;
		}

	pinst->APIUnlock( pinst->fAPIRestoring );

	apicall.LeaveAfterCall( err );

	if ( fAllocateInstance )
		{
		FreePinst( pinst );
		}

	return apicall.ErrResult();
	}
JET_ERR JET_API JetRestoreInstance( JET_INSTANCE instance, const char *sz, const char *szDest, JET_PFNSTATUS pfn )
	{
	JET_TRY( JetRestoreInstanceEx( instance, sz, szDest, pfn ) );
	}

LOCAL JET_ERR JetTermEx( JET_INSTANCE instance, JET_GRBIT grbit )
	{
	return ErrTermComplete( instance, grbit );
	}

JET_ERR JET_API JetTerm( JET_INSTANCE instance )
	{
	JET_TRY( JetTermEx( instance, JET_bitTermAbrupt ) );
	}
JET_ERR JET_API JetTerm2( JET_INSTANCE instance, JET_GRBIT grbit )
	{
	JET_TRY( JetTermEx( instance, grbit ) );
	}


JET_ERR JET_API JetStopServiceInstanceEx( JET_INSTANCE instance )
	{
	ERR		err;
	INST	*pinst;

	CallR( ErrFindPinst( instance, &pinst ) );

	//  Halt OLD for this instance

	OLDTermInst( pinst );

	//	signal version cleanup to minimise
	//	the amount of work version cleanup
	//	has to do on term
	//
	pinst->m_pver->VERSignalCleanup();

    //	Set a very small checkpoint depth to cause the database cache
    //	to start flushing all important dirty pages to the database.
    //	Note that we do not set the depth to zero because that would
    //	make any remaining updates that need to be done very slow.
    //
    //	Ignore any errors, since this is just an optimistic perf
    //	optimisation.
    //
	CallS( ErrBFSetCheckpointDepthMax( 16384 ) );

	pinst->m_fStopJetService = fTrue;
	return JET_errSuccess;
	}
JET_ERR JET_API JetStopServiceInstance( JET_INSTANCE instance )
	{
	JET_TRY( JetStopServiceInstanceEx( instance ) );
	}
JET_ERR JET_API JetStopService()
	{
	ERR		err;

	CallR( ErrRUNINSTCheckAndSetOneInstMode() );

	return JetStopServiceInstance( (JET_INSTANCE)g_rgpinst[0] );
	}


LOCAL JET_ERR JetStopBackupInstanceEx( JET_INSTANCE instance )
	{
	ERR		err;
	INST	*pinst;

	CallR( ErrFindPinst( instance, &pinst ) );

	if ( pinst->m_plog )
		{
		pinst->m_plog->m_fStopBackup = fTrue;
		}

	return JET_errSuccess;
	}
JET_ERR JET_API JetStopBackupInstance( JET_INSTANCE instance )
	{
	JET_TRY( JetStopBackupInstanceEx( instance ) );
	}
JET_ERR JET_API JetStopBackup()
	{
	ERR		err;

	CallR( ErrRUNINSTCheckAndSetOneInstMode() );

	return JetStopBackupInstance( (JET_INSTANCE)g_rgpinst[0] ) ;
	}

LOCAL JET_ERR JetGetInstanceInfoEx( unsigned long *pcInstanceInfo, JET_INSTANCE_INFO ** paInstanceInfo, const BOOL fSnapshot = fFalse )
	{
	return ErrIsamGetInstanceInfo( pcInstanceInfo, paInstanceInfo );
	}

JET_ERR JET_API JetGetInstanceInfo( unsigned long *pcInstanceInfo, JET_INSTANCE_INFO ** paInstanceInfo )
	{
	JET_TRY( JetGetInstanceInfoEx( pcInstanceInfo, paInstanceInfo ) );
	}

JET_ERR JET_API JetFreeBuffer(
	char *pbBuf )
	{
	// use to free buffers returned by JetGetInstanceInfo
	OSMemoryHeapFree( (void* const)pbBuf );
	return JET_errSuccess;
	};


LOCAL JET_ERR JetOSSnapshotPrepareEx( JET_OSSNAPID * psnapId, const JET_GRBIT grbit )
	{
	return ErrIsamOSSnapshotPrepare( psnapId, grbit );
	}

JET_ERR JET_API JetOSSnapshotPrepare( JET_OSSNAPID * psnapId, const JET_GRBIT grbit )
	{
	JET_TRY( JetOSSnapshotPrepareEx( psnapId, grbit ) );
	}


LOCAL JET_ERR JetOSSnapshotFreezeEx( const JET_OSSNAPID snapId, unsigned long *pcInstanceInfo, JET_INSTANCE_INFO ** paInstanceInfo, const JET_GRBIT grbit )
	{
	return ErrIsamOSSnapshotFreeze( snapId, pcInstanceInfo, paInstanceInfo, grbit );
	}

JET_ERR JET_API JetOSSnapshotFreeze( const JET_OSSNAPID snapId, unsigned long *pcInstanceInfo, JET_INSTANCE_INFO ** paInstanceInfo, const JET_GRBIT grbit )
	{
	JET_TRY( JetOSSnapshotFreezeEx( snapId, pcInstanceInfo, paInstanceInfo, grbit ) );
	}


LOCAL JET_ERR JetOSSnapshotThawEx( const JET_OSSNAPID snapId, const JET_GRBIT grbit )
	{
	return ErrIsamOSSnapshotThaw( snapId, grbit );
	}

JET_ERR JET_API JetOSSnapshotThaw( const JET_OSSNAPID snapId, const JET_GRBIT grbit )
	{
	JET_TRY( JetOSSnapshotThawEx( snapId, grbit ) );
	}


LOCAL JET_ERR JetOSSnapshotAbortEx( const JET_OSSNAPID snapId, const JET_GRBIT grbit )
	{
	return ErrIsamOSSnapshotAbort( snapId, grbit );
	}

JET_ERR JET_API JetOSSnapshotAbort( const JET_OSSNAPID snapId, const JET_GRBIT grbit )
	{
	JET_TRY( JetOSSnapshotAbortEx( snapId, grbit ) );
	}

}	// extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\logdiff.cxx ===
#include "std.hxx"

class TAGFIELDS_DUMP : public TAGFIELDS
	{
	ULONG m_itagfld;

	enum { iInvalidState = -1 };

	const DATA* m_pData;
public:
	TAGFIELDS_DUMP( const DATA& dataRec ) : TAGFIELDS( dataRec ) { m_itagfld = iInvalidState; m_pData = &dataRec; }
	virtual ~TAGFIELDS_DUMP() {}
	
	BOOL FIsValidTagField() const { return ( m_itagfld != iInvalidState )? fTrue: fFalse; }
	const BYTE *PbTagColumnsHeader() const { return (const BYTE *)TAGFIELDS::PbTaggedColumns(); }
	ULONG CbTagColumnsHeaderSize() const { return TAGFIELDS::CTaggedColumns()*sizeof( TAGFLD ); }
	FID GetFID() const { Assert( FIsValidTagField() ); return TAGFIELDS::Fid( m_itagfld ); }
	const BYTE *PbData() const { Assert( FIsValidTagField() ); return ( const BYTE *)TAGFIELDS::PbData( m_itagfld ); }
	ULONG CbData() const { Assert( FIsValidTagField() ); return TAGFIELDS::CbData( m_itagfld ); }
	VOID FindFirstTagField() { m_itagfld = TAGFIELDS::CTaggedColumns() != 0? 0: iInvalidState; }
	VOID FindNextTagField() { Assert( FIsValidTagField() ); m_itagfld = ( m_itagfld+1 < TAGFIELDS::CTaggedColumns() )? m_itagfld+1: iInvalidState; }
	SIZE_T IbDataOffset() const { Assert( FIsValidTagField() ); return PbData() - (const BYTE *)m_pData->Pv(); }
	SIZE_T CbRestData() const { Assert( FIsValidTagField() ); return m_pData->Cb() - IbDataOffset(); }
	INT	Compare( const TAGFIELDS_DUMP &tfd ) const { Assert( FIsValidTagField() ); Assert( tfd.FIsValidTagField() ); return TAGFIELDS::TagFldCmp( Ptagfld( m_itagfld ), tfd.Ptagfld( tfd.m_itagfld ) ); }
	};


///#define DISABLE_LOGDIFF

#ifdef DEBUG
//	Dump diffs
//
VOID LGDumpDiff ( BYTE *pbDiff, INT cbDiff )
	{
	BYTE *pbDiffCur = pbDiff;
	BYTE *pbDiffMax = pbDiff + cbDiff;

	while ( pbDiffCur < pbDiffMax )
		{
		INT	ibOffsetOld;
		INT cbDataNew;

		DIFFHDR diffhdr = *( (DIFFHDR*) pbDiffCur );
		pbDiffCur += sizeof( DIFFHDR );

		ibOffsetOld = ( diffhdr.m_bitfield & DIFFHDR::ibOffsetMask ) >> DIFFHDR::ibOffsetShf;
		DBGprintf( "\n[ Offs:%u ", ibOffsetOld );

		if ( diffhdr.m_bitfield & DIFFHDR::fUseTwoBytesForDataLength )
			{
			DBGprintf( "2B " );
			cbDataNew = *( (UnalignedLittleEndian< WORD >*) pbDiffCur );
			pbDiffCur += sizeof( WORD );
			}
		else
			{
			DBGprintf( "1B " );
			cbDataNew = *( (UnalignedLittleEndian< BYTE >*) pbDiffCur );
			pbDiffCur += sizeof( BYTE );
			}
		
		if ( diffhdr.m_bitfield & DIFFHDR::fInsert )
			{
			DBGprintf( "InsertWithValue (%u): ", cbDataNew );
			ShowData( pbDiffCur, cbDataNew );
			pbDiffCur += cbDataNew;
			}
		else
			{
			if ( diffhdr.m_bitfield & DIFFHDR::fReplaceWithSameLength )
				{
				DBGprintf( "ReplaceWithSameLength (%u): ", cbDataNew );
				ShowData( pbDiffCur, cbDataNew );
				pbDiffCur += cbDataNew;
				}
			else
				{
				INT cbDataOld;

				if ( diffhdr.m_bitfield & DIFFHDR::fUseTwoBytesForDataLength )
					{
					cbDataOld = *( (UnalignedLittleEndian< WORD >*) pbDiffCur );
					pbDiffCur += sizeof( WORD );
					}
				else
					{
					cbDataOld = *( (UnalignedLittleEndian< BYTE >*) pbDiffCur );
					pbDiffCur += sizeof( BYTE );
					}
				
				DBGprintf( "ReplaceWithNewValue (%u=>%u): ", cbDataOld, cbDataNew );
				ShowData( pbDiffCur, cbDataNew );
				pbDiffCur += cbDataNew;
				}
			}

		DBGprintf( "]" );
		
		Assert( pbDiffCur <= pbDiffMax );
		}

	DBGprintf( "\n                 " );
	}
#endif



//	cbDataOld == 0 ----------------------> insertion.
//	cbDataNew == 0 ----------------------> deletion.
//	cbDataOld != 0 && cbDataNew != 0 ----> replace.
//
//	Fomat: DiffHdr - cbDataNew - [cbDataOld] - [NewData]
//

BOOL FLGAppendDiff(
	BYTE		**ppbCur,		// diff to append
	BYTE		*pbMax,			// max of pbCur to append
	const SIZE_T	ibOffsetOld,
	const SIZE_T	cbDataOld,
	const SIZE_T	cbDataNew,
	const BYTE	*pbDataNew )
	{
	//  validate IN args
	
	Assert( pbNil != pbDataNew || cbDataNew == 0 );
	Assert( REC::CbRecordMax() < g_cbColumnLVChunkMost );
	Assert( ibOffsetOld + cbDataOld >= ibOffsetOld );
	Assert( ibOffsetOld + cbDataOld <= g_cbColumnLVChunkMost );

	//  setup diffhdr
	DIFFHDR		diffhdr;
	const WORD	wBitField	= WORD( ( ( ibOffsetOld << DIFFHDR::ibOffsetShf ) & DIFFHDR::ibOffsetMask ) |
								(	cbDataOld != 0 && cbDataOld == cbDataNew ?
										DIFFHDR::fReplaceWithSameLength :
										0 ) |
								(	cbDataOld == 0 ?
										DIFFHDR::fInsert :
										0 ) |
								(	cbDataOld > 255 || cbDataNew > 255 ?
										DIFFHDR::fUseTwoBytesForDataLength :
										0 ) );

	diffhdr.m_bitfield = wBitField;

	//  check for truncation of the offset by too small of a bit field

	Assert( ( ( wBitField & DIFFHDR::ibOffsetMask ) >> DIFFHDR::ibOffsetShf ) == ibOffsetOld );

	//  compute the size of our data length storage.  we will need two data lengths
	//  if we are replacing with a different length:  one for the initial length
	//  and one for the final length

	const BOOL	fReplaceWithDiffLength	= !( wBitField & DIFFHDR::fReplaceWithSameLength )
											&& !( wBitField & DIFFHDR::fInsert );
	const ULONG	cbBytesForDataLength	= ( wBitField & DIFFHDR::fUseTwoBytesForDataLength ? 2 : 1 )
											* ( fReplaceWithDiffLength ? 2 : 1 );

	//	bail if the diff is too big to fit in the user's buffer

	BYTE	* pbCur	= *ppbCur;
	if ( ( pbCur + sizeof( DIFFHDR ) + cbBytesForDataLength + cbDataNew ) > pbMax )
		{
		return fFalse;
		}

	//  copy the diffhdr into the user's buffer

	*( (DIFFHDR*) pbCur ) = diffhdr;
	pbCur += sizeof( DIFFHDR );

	//  copy the data length(s) into the user's buffer

	if ( wBitField & DIFFHDR::fUseTwoBytesForDataLength )
		{
		*( (UnalignedLittleEndian< WORD >*) pbCur ) = (WORD)cbDataNew;
		pbCur += sizeof( WORD );
		
		if ( fReplaceWithDiffLength )
			{
			*( (UnalignedLittleEndian< WORD >*) pbCur ) = (WORD)cbDataOld;
			pbCur += sizeof( WORD );
			}
		}
	else
		{
		*( (UnalignedLittleEndian< BYTE >*) pbCur ) = (BYTE)cbDataNew;
		pbCur += sizeof( BYTE );
		
		if ( fReplaceWithDiffLength )
			{
			*( (UnalignedLittleEndian< BYTE >*) pbCur ) = (BYTE)cbDataOld;
			pbCur += sizeof( BYTE );
			}
		}

	//  copy the new data into the user's buffer
	
	UtilMemCpy( pbCur, pbDataNew, cbDataNew );
	pbCur += cbDataNew;

	//  return a pointer past the end of the section of the user's buffer that
	//  we consumed

	*ppbCur = pbCur;
	return fTrue;
	}

// Store header array of tagged fields
//
BOOL FLGSetArrayDiff( 
const BYTE * pbDataBegin,
const BYTE * const pbOld, 
const BYTE * const pbNew, 
const ULONG cbOld, 
const ULONG cbNew, 
BYTE ** ppbDiff, 
BYTE * pbDiffMaxTotal )
	{
	Assert( pbOld != NULL || cbOld == 0 );
	Assert( pbNew != NULL || cbNew == 0 );
	Assert( ppbDiff != NULL && *ppbDiff != NULL );
	Assert( pbDiffMaxTotal != NULL );
	Assert( (cbOld % sizeof( DWORD )) == 0 );
	Assert( (cbNew % sizeof( DWORD )) == 0 );
	Assert( (sizeof( TAGFLD ) %sizeof( DWORD )) == 0 );
	
	INT cbMinSize = cbOld;
	BOOL fTruncate, fEndIsReached;
	fTruncate = fFalse;
	fEndIsReached = fFalse;	//	if during comparision ends of both blocks are reached
	if ( cbMinSize > cbNew ) 
		{
		cbMinSize = cbNew;
		fTruncate = fTrue;
		}
	else if ( cbMinSize == cbNew )
		{
		fEndIsReached = fTrue;
		}

	Unaligned< DWORD > *pdwOldCur	= ( Unaligned< DWORD > * )pbOld;
	Unaligned< DWORD > *pdwOldMax	= pdwOldCur + ( cbMinSize / sizeof( DWORD ) );
	Unaligned< DWORD > *pdwNewCur	= ( Unaligned< DWORD > * )pbNew;
	Assert ( (BYTE *)(pdwOldCur + 1) - (BYTE *)pdwOldCur == 4 );
	
	//	establish diff buffer and
	//	ensure that diff record is no bigger than the after-image 
	//	(otherwise, it's cheaper just to log the entire after-image).
	BYTE	*pbDiffCur = *ppbDiff;
	BYTE	*pbDiffMax = pbDiffCur + cbNew;

	while ( pdwOldCur < pdwOldMax )
		{
		if ( *pdwOldCur == *pdwNewCur )
			{
			pdwOldCur++;
			pdwNewCur++;
			}
		else
			{
			//	store the offset
			//
			Assert( (const BYTE *)pdwOldCur >= pbOld );
			const SIZE_T ibOld		= (BYTE *)pdwOldCur - pbDataBegin;
			const BYTE	*pbNewData	= (BYTE *)pdwNewCur;
			SIZE_T		cbNewData	= sizeof( DWORD );
			pdwOldCur++;
			pdwNewCur++;
				//	compare 4 bytes at a time until data streams re-sync
			while ( pdwOldCur < pdwOldMax && *pdwOldCur != *pdwNewCur )
				{
				cbNewData += sizeof( DWORD );
				pdwOldCur ++;
				pdwNewCur ++;
				}

			//	if end of comparision block is reached
			//	check if should truncate ot expand the size of chunk
			SIZE_T cbOldData = cbNewData;
			if ( pdwOldCur == pdwOldMax )
				{
				if ( fTruncate )
					{
					cbOldData += cbOld - cbMinSize;
					}
				else
					{
					cbNewData += cbNew - cbMinSize;
					}
				fEndIsReached = fTrue;	//	the differences are completly set
				}
			else
				{
				// it is reached place there two datas are equal
				// so those DWORDs can be skipped
				pdwOldCur++;
				pdwNewCur++;
				}
			
			if ( !FLGAppendDiff(
					&pbDiffCur,
					pbDiffMax,					// max of pbCur to append
					ibOld,						// offset to old image
					cbOldData,					// length of the old image
					cbNewData,					// length of the new image
					pbNewData					// pbDataNew
					) )
				{
				goto LogAll;
				}
			}
		}

	Assert( pdwOldMax == pdwOldCur );
		
	if ( !fEndIsReached )
		{
		//	Different size of arrays
		//
		if ( !FLGAppendDiff(
					&pbDiffCur,
					pbDiffMax,						//	max of pbCur to append
					cbMinSize + pbOld - pbDataBegin,	//	offset to old image
					cbOld - cbMinSize,				//	length of the old image
					cbNew - cbMinSize,				//	length of the new image
					(const BYTE *)pdwNewCur ) )		//	pbDataNew
			{
			goto LogAll;
			}
		}
	*ppbDiff = pbDiffCur;
	return fTrue;
		
	LogAll:
		//	if logging differences is more expensive than
		//	logging all array
	return FLGAppendDiff(
			ppbDiff,
			pbDiffMaxTotal,		//	max of pbCur to append
			pbOld - pbDataBegin,	//	offset to old image
			cbOld,				//	length of the old image
			cbNew,				//	length of the new image
			pbNew );			//	pbDataNew
	}

//	Go through each column, compare the before image and after image of each column.
//

//  UNDONE:  Currently, we look at the rgbitSet bit array to detect if a column has
//  been set.  Since these bits no longer uniquely identify a particular column as
//  being set, we must compare the BI and the change for a difference for each column
//  set, and then only log if there is an actual change.

VOID LGSetColumnDiffs(
	FUCB		*pfucb,
	const DATA&	dataNew,
	const DATA&	dataOld,
	BYTE		*pbDiff,
	SIZE_T		*pcbDiff )
	{
	FID			fid;
	
	//	Initialize return value
	Assert( NULL != pcbDiff );
	*pcbDiff = 0;
	
	Assert( pfucbNil != pfucb );
	Assert( FFUCBIndex( pfucb ) || FFUCBSort( pfucb ) );

	FCB		*pfcb = pfucb->u.pfcb;
	Assert( pfcbNil != pfcb );

	TDB		*ptdb = pfcb->Ptdb();
	Assert( ptdbNil != ptdb );


#ifdef DISABLE_LOGDIFF
	// Returning with cbDiff set to 0 will effectively disable logdiff.
	return;
#endif

	const REC	*precOld	= (REC *)dataOld.Pv();
	const ULONG	cbRecOld	= dataOld.Cb();
	
	Assert( precNil != precOld );
	Assert( cbRecOld >= REC::cbRecordMin );
	Assert( cbRecOld <= REC::CbRecordMax() );

	//	get new data
	//
	const REC	*precNew	= (REC *)dataNew.Pv();
	const ULONG	cbRecNew	= dataNew.Cb();
	
	Assert( precNil != precNew );
	Assert( cbRecNew >= REC::cbRecordMin );
	Assert( cbRecNew <= REC::CbRecordMax() );
	
	//	check old and new data are consistent.
	//
	const FID	fidFixedLastInRecOld	= precOld->FidFixedLastInRec();
	const FID	fidFixedLastInRecNew	= precNew->FidFixedLastInRec();
	Assert( fidFixedLastInRecOld <= fidFixedLastInRecNew );
	
	const FID	fidVarLastInRecOld		= precOld->FidVarLastInRec();
	const FID	fidVarLastInRecNew		= precNew->FidVarLastInRec();
	Assert( fidVarLastInRecOld <= fidVarLastInRecNew );
	

	//	establish diff buffer, and ensure that diff record is no bigger
	//	than the after-image (otherwise, it's cheaper just to log the
	//	entire after-image).
	BYTE			*pbDiffCur				= pbDiff;
	BYTE			*pbDiffMax				= pbDiffCur + cbRecNew;
	
	//	log diffs in record header
	if ( memcmp( (BYTE *)precOld, (BYTE *)precNew, REC::cbRecordHeader ) != 0 )
		{
		if ( !FLGAppendDiff(
				&pbDiffCur,						// diff to append 
				pbDiffMax,						// max of pbDiffCur to append 
				0,								// offset to old rec 
				REC::cbRecordHeader,			// cbDataOld 
				REC::cbRecordHeader,			// cbDataNew 
				(BYTE *)precNew ) )				// pbDataNew
			{
			return;
			}
		}


	BOOL		fLogFixedNullBitMap		= fFalse;

	const BYTE	*pbFixedNullBitMapOld	= precOld->PbFixedNullBitMap();
	const BYTE	*pbFixedNullBitMapNew	= precNew->PbFixedNullBitMap();
														
	Assert( pbFixedNullBitMapOld > (BYTE *)precOld );
	Assert( pbFixedNullBitMapOld <= (BYTE *)precOld + cbRecOld );
	Assert( pbFixedNullBitMapNew > (BYTE *)precNew );
	Assert( pbFixedNullBitMapNew <= (BYTE *)precNew + cbRecNew );
	
	pfcb->EnterDML();
	
	Assert( fidFixedLastInRecOld <= fidFixedLastInRecNew );		//	can't shrink record
	for ( fid = fidFixedLeast; fid <= fidFixedLastInRecOld; fid++ )
		{
		//  if this column is not set, skip
		//
		// UNDONE: make it table look up instead of loop.
		if ( !FFUCBColumnSet( pfucb, fid ) )
			{
			continue;
			}

		//  at this point, the column _may_be_ set, but this is not known for
		//  sure!
		//

		//	this fixed column is set, make the diffs.
		//  (if this is a deleted column, skip)
		//

		//	convert fid to an offset
		const UINT	ifid			= fid - fidFixedLeast;
		const BOOL	fFieldNullOld	= FFixedNullBit( pbFixedNullBitMapOld + ifid/8, ifid );
		const BOOL	fFieldNullNew	= FFixedNullBit( pbFixedNullBitMapNew + ifid/8, ifid );

		if ( fFieldNullOld ^ fFieldNullNew )
			{
			//	If nullity changed, force diff of null bitmap.
			fLogFixedNullBitMap = fTrue;
			}

		//	If new field value is NULL, then don't need to update record data.
		//	It is sufficient just to update the null bitmap.
		if ( !fFieldNullNew )
			{
			const BOOL	fTemplateColumn	= ptdb->FFixedTemplateColumn( fid );
			const FIELD	*pfield			= ptdb->PfieldFixed( ColumnidOfFid( fid, fTemplateColumn ) );

			//	skip column if deleted
			if ( JET_coltypNil != pfield->coltyp )
				{
				if ( !FLGAppendDiff(
						&pbDiffCur,										// diff to append 
						pbDiffMax,										// max of pbDiffCur to append 
						pfield->ibRecordOffset,							// offset to old rec 
						pfield->cbMaxLen,								// cbDataOld 
						pfield->cbMaxLen,								// cbDataNew 
						(BYTE *)precNew + pfield->ibRecordOffset ) )	// pbDataNew
					{
					pfcb->LeaveDML();
					return;
					}
				}
			}
		}

	pfcb->LeaveDML();

	if ( fidFixedLastInRecOld < fidFixedLastInRecNew )
		{
		//	Log extended fixed columns.
		Assert( fidFixedLastInRecNew >= fidFixedLeast );

		//	we extend fixed field. Null array is resized. Log it.
		//
		fLogFixedNullBitMap = fTrue;

		//	log all the fields after fidFixedLastInRecOld.
		//
		const REC::RECOFFSET	ibBitMapOffsetOld	= (REC::RECOFFSET)( pbFixedNullBitMapOld - (BYTE *)precOld );
		const REC::RECOFFSET	ibBitMapOffsetNew	= (REC::RECOFFSET)( pbFixedNullBitMapNew - (BYTE *)precNew );

		Assert( ibBitMapOffsetNew > ibBitMapOffsetOld );
		const SIZE_T cbToAppend	= ibBitMapOffsetNew - ibBitMapOffsetOld;

		//	from the new record, get the data to append, but start
		//	where the old record left off.
		const BYTE	*pbToAppend	= (BYTE *)precNew + ibBitMapOffsetOld;

		if ( !FLGAppendDiff(
				&pbDiffCur,							// diff to append 
				pbDiffMax,							// max of pbDiffCur to append
				ibBitMapOffsetOld,					// offset to old rec 
				0,									// cbDataOld (0 == insert)
				cbToAppend,							// cbDataNew 
				pbToAppend							// pbDataNew 
				) )
			{
			return;
			}
		}


	//	check if need to log fixed fields null bitmap
	//
	if ( fLogFixedNullBitMap )
		{
		if ( !FLGAppendDiff(
			&pbDiffCur,
			pbDiffMax,									// max of pbDiffCur to append
			pbFixedNullBitMapOld - (BYTE *)precOld,		// offset to old image
			( fidFixedLastInRecOld + 7 ) / 8,			// length of the old image
			( fidFixedLastInRecNew + 7 ) / 8,			// length of the new image
			pbFixedNullBitMapNew ) )					// pbDataNew
			{
			return;
			}
		}

	//	check variable length fields
	//
	const UnalignedLittleEndian<REC::VAROFFSET>	*pibVarOffsOld	= precOld->PibVarOffsets();
	const UnalignedLittleEndian<REC::VAROFFSET>	*pibVarOffsNew	= precNew->PibVarOffsets();
	const REC::RECOFFSET	ibVarDataOld	= (REC::RECOFFSET)( precOld->PbVarData() - (BYTE *)precOld );
	const REC::RECOFFSET	ibVarDataNew	= (REC::RECOFFSET)( precNew->PbVarData() - (BYTE *)precNew );
	
	//	Find first set var field whose offset entry has changed, either
	//	because the offset has changed or because the null flag has changed.
	Assert( fidVarLastInRecOld <= fidVarLastInRecNew );
	for ( fid = fidVarLeast; fid <= fidVarLastInRecOld; fid++ )
		{
		const UINT	ifid	= fid - fidVarLeast;
		if ( pibVarOffsOld[ifid] != pibVarOffsNew[ifid] )
			{
			break;
			}
		}

	Assert( fid <= fidVarLastInRecNew || fidVarLastInRecOld == fidVarLastInRecNew );
	if ( fid <= fidVarLastInRecNew )
		{
		const UINT	ifid	= fid - fidVarLeast;
		
		//	we need to log the offset between fid and fidVarLastInRecNew
		//
		if ( !FLGAppendDiff(
				&pbDiffCur,
				pbDiffMax,													// max of pbDiffCur to append 
				(BYTE*)( pibVarOffsOld + ifid ) - (BYTE *)precOld,			// offset to old image 
				( fidVarLastInRecOld + 1 - fid ) * sizeof(REC::VAROFFSET),	// length of the old image 
				( fidVarLastInRecNew + 1 - fid ) * sizeof(REC::VAROFFSET),	// length of the new image 
				(BYTE *)( pibVarOffsNew + ifid ) ) )						// pbDataNew 
			{
			return;
			}
		}
			

	//	scan through each variable length field up to old last fid and log its replace image.
	//
	for ( fid = fidVarLeast; fid <= fidVarLastInRecOld; fid++ )
		{
		//  if this column is not set, skip
		//
		if ( !FFUCBColumnSet( pfucb, fid ) )
			continue;

		//  at this point, the column _may_be_ set, but this is not known for
		//  sure!
		//

//	Deleted column check is too expensive because we'd have to access the TDB
//
//		//  if this column is deleted, skip
//		//
//		if ( ptdb->PfieldVar( ColumnidOfFid( fid ) )->coltyp == JET_coltypNil )
//			{
//			continue;
//			}

		const REC::VAROFFSET	ibStartOfColumnOld	= precOld->IbVarOffsetStart( fid );
		const REC::VAROFFSET	ibEndOfColumnOld	= precOld->IbVarOffsetEnd( fid );
		const REC::VAROFFSET	ibStartOfColumnNew	= precNew->IbVarOffsetStart( fid );
		const REC::VAROFFSET	ibEndOfColumnNew	= precNew->IbVarOffsetEnd( fid );

		if ( !FLGAppendDiff(
					&pbDiffCur,
					pbDiffMax,										// max of pbDiffCur to append 
					ibVarDataOld + ibStartOfColumnOld,				// offset to old image 
					ibEndOfColumnOld - ibStartOfColumnOld,			// length of the old image 
					ibEndOfColumnNew - ibStartOfColumnNew,			// length of the new image 
					precNew->PbVarData() + ibStartOfColumnNew ) )	// pbDataNew 
			{
			return;
			}
		}
		
	Assert( fid == fidVarLastInRecOld + 1 );
	
	//	insert new image for fid > old last var fid as one contigous diff
	//
	if ( fid <= fidVarLastInRecNew )
		{
		const REC::VAROFFSET	ibStartOfColumn	= precNew->IbVarOffsetStart( fid );

		if ( !FLGAppendDiff(
				&pbDiffCur,
				pbDiffMax,											// max of pbDiffCur to append 
				ibVarDataOld + precOld->IbEndOfVarData(),			// offset to old image 
				0,													// length of the old image 
				precNew->IbEndOfVarData() - ibStartOfColumn,		// length of the new image 
				precNew->PbVarData() + ibStartOfColumn ) )			// pbDataNew 
			{
			return;
			}

		}

	// if we made some implicit operations store all the record
	// UNDONE: try to store whole tagfields area
	if ( FFUCBTagImplicitOp( pfucb ) )
		{
		SIZE_T ibTagOffsetOld = precOld->PbTaggedData() - (BYTE *)precOld;
		SIZE_T ibTagOffsetNew = precNew->PbTaggedData() - (BYTE *)precNew;
		if ( !FLGAppendDiff(
					&pbDiffCur,
					pbDiffMax,								// max of pbDiffCur to append
					ibTagOffsetOld,							// offset to old image 
					cbRecOld - ibTagOffsetOld,				// length of the old image 
					cbRecNew - ibTagOffsetNew,				// length of the new image 
					precNew->PbTaggedData() ) )				// pbDataNew 
			{
			return;
			}
		}
		
	else if ( FFUCBTaggedColumnSet( pfucb ) )
		{
		//	go through each Tag fields. check if tag field is different and check if a tag is
		//	deleted (set to Null), added (new tag field), or replaced.
		TAGFIELDS_DUMP tfdOld( dataOld );
		TAGFIELDS_DUMP tfdNew( dataNew );
		BOOL fTagColumnsHeaderLog = fFalse;
		//	check if have changes in tags header, like:
		//	adding a new column, deleting a column or resizing an existing column
		//
		if ( !FLGSetArrayDiff(
			(const BYTE *)precOld,
			tfdOld.PbTagColumnsHeader(),
			tfdNew.PbTagColumnsHeader(),
			tfdOld.CbTagColumnsHeaderSize(),
			tfdNew.CbTagColumnsHeaderSize(),
			&pbDiffCur,
			pbDiffMax ) )
			{
			return;
			}

		tfdOld.FindFirstTagField();
		tfdNew.FindFirstTagField();
		for ( ; tfdOld.FIsValidTagField() && tfdNew.FIsValidTagField(); )
			{
			const INT iFidOrder = tfdOld.Compare( tfdNew );
			if ( iFidOrder == 0 )
				{
				//	check if this column is modified
				//
				if ( FFUCBColumnSet( pfucb, tfdOld.GetFID() ) )
					{
					const SIZE_T	cbTagFieldOld	= tfdOld.CbData();
					const SIZE_T	cbTagFieldNew	= tfdNew.CbData();

					//	check if contents are still the same. If not, log replace.
					//
					if ( cbTagFieldNew != cbTagFieldOld
						|| memcmp( tfdOld.PbData(), tfdNew.PbData(), cbTagFieldNew ) != 0 )
						{
						//	replace from offset
						//
						if ( !FLGAppendDiff(
									&pbDiffCur,
									pbDiffMax,						// max of pbDiffCur to append 
									tfdOld.IbDataOffset(),			// offset to old image 
									cbTagFieldOld,					// length of the old image 
									cbTagFieldNew,					// length of the new image 
									tfdNew.PbData() ) )				// pbDataNew 
							{
							return;
							}
						}
					}
				tfdOld.FindNextTagField();
				tfdNew.FindNextTagField();
				}
			else if ( iFidOrder > 0 )
				{
				//	just set a new column, log insertion.
				//
				if ( !FLGAppendDiff(
							&pbDiffCur,
							pbDiffMax,							// max of pbDiffCur to append 
							tfdOld.IbDataOffset(),				// offset to old image 
							0,									// length of the old image 
							tfdNew.CbData(),					// length of the new image 
							tfdNew.PbData() ) )					// pbDataNew 
					{
					return;
					}

				tfdNew.FindNextTagField();
				}
				
			else
				{
				//	just set a column to Null (or default value if default value is defined)
				//	log as deletion.
				//
				if ( !FLGAppendDiff(
							&pbDiffCur,
							pbDiffMax,							// max of pbDiffCur to append 
							tfdOld.IbDataOffset(),				// offset to old image 
							tfdOld.CbData(),					// length of the old image 
							0,									// length of the new image 
							pbNil ) )							// pbDataNew 
					{
					return;
					}
							
				tfdOld.FindNextTagField();
				}
			}

		if ( tfdNew.FIsValidTagField() )
			{
			Assert( !tfdOld.FIsValidTagField() );
			
			if ( !FLGAppendDiff(
						&pbDiffCur,
						pbDiffMax,					// max of pbDiffCur to append 
						cbRecOld,					// offset to old image 
						0,							// length of the old image 
						tfdNew.CbRestData(),		// length of the new image 
						tfdNew.PbData() ) )			// pbDataNew
				{
				return;
				}
			}

		else if ( tfdOld.FIsValidTagField() )
			{
			Assert( !tfdNew.FIsValidTagField() );
			
			//	delete the remaining old tag columns
			//
			if ( !FLGAppendDiff(
						&pbDiffCur,
						pbDiffMax,								// max of pbDiffCur to append
						tfdOld.IbDataOffset(),						// offset to old image 
						tfdOld.CbRestData(),					// length of the old image 
						0,										// length of the new image 
						pbNil ) )								// pbDataNew 
				{
				return;
				}
			}

		else
			{
			Assert( !tfdOld.FIsValidTagField() );
			Assert( !tfdNew.FIsValidTagField() );
			}
		}	// FFUCBTaggedColumnSet()

	//	set up return value.
	//
	if ( pbDiffCur == pbDiff )
		{
		//	Old and New are the same, log a short diff.
		//
		if ( !FLGAppendDiff(
				&pbDiffCur,
				pbDiffMax,						// max of pbDiffCur to append
				0,							// offset to old image
				0,							// length of the old image
				0,							// length of the new image
				pbNil						// pbDataNew
				) )
			{
			Assert( *pcbDiff == 0 );
			return;
			}
		}

	*pcbDiff = pbDiffCur - pbDiff;


#ifdef DEBUG
	Assert( *pcbDiff != 0 );

	BYTE	rgbAfterImage[g_cbPageMax];
	SIZE_T	cbAfterImage;
	DATA	dataAfterImage;

	Assert( dataNew.Cb() <= REC::CbRecordMax() );
	Assert( g_cbColumnLVChunkMost > REC::CbRecordMax() );

	LGGetAfterImage( 
			pbDiff,
			*pcbDiff,
			(BYTE *)dataOld.Pv(),
			dataOld.Cb(),
			rgbAfterImage,
			&cbAfterImage );
	Assert( dataNew.Cb() == cbAfterImage );

	Assert( dataNew.Pv() == (BYTE *)precNew );

	dataAfterImage.SetPv( rgbAfterImage );
	dataAfterImage.SetCb( cbAfterImage );
	
	if ( !FDataEqual( dataNew, dataAfterImage ) )
		{
		REC		*precAfterImage		= (REC *)rgbAfterImage;
		DATA	dataNewT;
		
		//	dissect the comparison for easier debugging.

		//	check record header
		Assert( memcmp( precAfterImage, precNew, REC::cbRecordHeader ) == 0 );

		//	check fixed fields
		dataNewT.SetPv( (BYTE *)precNew );
		dataNewT.SetCb( precNew->IbEndOfFixedData() - precNew->CbFixedNullBitMap() );
		dataAfterImage.SetPv( precAfterImage );
		dataAfterImage.SetCb( precAfterImage->IbEndOfFixedData() - precAfterImage->CbFixedNullBitMap() );
		Assert( FDataEqual( dataNewT, dataAfterImage ) );
		
		//	check fixed field null bitmap
		dataNewT.SetPv( (BYTE *)precNew + precNew->IbEndOfFixedData() - precNew->CbFixedNullBitMap() );
		dataNewT.SetCb( precNew->CbFixedNullBitMap() );
		dataAfterImage.SetPv( (BYTE *)precAfterImage + precAfterImage->IbEndOfFixedData() - precAfterImage->CbFixedNullBitMap() );
		dataAfterImage.SetCb( precAfterImage->CbFixedNullBitMap() );
		Assert( FDataEqual( dataNewT, dataAfterImage ) );

		//	check variable offsets table
		dataNewT.SetPv( (BYTE *)precNew->PibVarOffsets() );
		dataNewT.SetCb( precNew->PbVarData() - (BYTE *)precNew->PibVarOffsets() );
		dataAfterImage.SetPv( (BYTE *)precAfterImage->PibVarOffsets() );
		dataAfterImage.SetCb( precAfterImage->PbVarData() - (BYTE *)precAfterImage->PibVarOffsets() );
		Assert( FDataEqual( dataNewT, dataAfterImage ) );

		//	check variable offsets table
		dataNewT.SetPv( precNew->PbVarData() );
		dataNewT.SetCb( precNew->PbTaggedData() - precNew->PbVarData() );
		dataAfterImage.SetPv( precAfterImage->PbVarData() );
		dataAfterImage.SetCb( precAfterImage->PbTaggedData() - precAfterImage->PbVarData() );
		Assert( FDataEqual( dataNewT, dataAfterImage ) );

		dataNewT.SetPv( precNew->PbTaggedData() );
		dataNewT.SetCb( (BYTE *)precNew + dataNew.Cb() - precNew->PbTaggedData() );
		dataAfterImage.SetPv( precAfterImage->PbTaggedData() );
		dataAfterImage.SetCb( rgbAfterImage + cbAfterImage - precAfterImage->PbTaggedData() );
		Assert( FDataEqual( dataNewT, dataAfterImage ) );

		//	one of the asserts above should have gone off, but
		//	add the following assert to ensures that we didn't
		//	miss any cases.
		Assert( fFalse );
		}
		
#endif	// DEBUG
	}


//  TODO:  rewrite this function

VOID LGSetLVDiffs(
	FUCB		*pfucb,
	const DATA&	dataNew,
	const DATA&	dataOld,
	BYTE		*pbDiff,
	SIZE_T		*pcbDiff )
	{
	//	Initialize return value
	Assert( NULL != pcbDiff );
	*pcbDiff = 0;
	
	Assert( pfucbNil != pfucb );
	Assert( pfcbNil != pfucb->u.pfcb );
	Assert( pfucb->u.pfcb->FTypeLV() );

#ifdef DISABLE_LOGDIFF
	//	Returning with cbDiff set to 0 will effectively disable logdiff.
	return;
#endif

	//	UNDONE: Need a more sophisticated diff routine that doesn't
	//	rely on the data segments being the same size
	INT cbMinSize = dataOld.Cb();
	BOOL fTruncate, fEndIsReached;
	fTruncate = fFalse;
	fEndIsReached = fFalse;	//	if during comparision ends of both blocks are reached
	if ( cbMinSize > dataNew.Cb() ) 
		{
		cbMinSize = dataNew.Cb();
		fTruncate = fTrue;
		}
	else if ( cbMinSize == dataNew.Cb() )
		{
		fEndIsReached = fTrue;
		}

	BYTE	*pbOldCur	= (BYTE *)dataOld.Pv();
	BYTE	*pbOldMax	= pbOldCur + ( cbMinSize - cbMinSize % sizeof( LONG ) );
	BYTE	*pbNewCur	= (BYTE *)dataNew.Pv();
	
	//	quickly finds where the differences begin
	//
	while ( pbOldCur < pbOldMax && *( Unaligned< LONG > * )pbOldCur == *( Unaligned< LONG > * )pbNewCur )
		{
		pbOldCur += sizeof( LONG );
		pbNewCur += sizeof( LONG );
		}

	pbOldMax += cbMinSize % sizeof( LONG );
	
	//	establish diff buffer and
	//	ensure that diff record is no bigger than the after-image 
	//	(otherwise, it's cheaper just to log the entire after-image).
	BYTE	*pbDiffCur = pbDiff;
	BYTE	*pbDiffMax = pbDiffCur + dataNew.Cb();

	while ( pbOldCur < pbOldMax )
		{
		if ( *pbOldCur == *pbNewCur )
			{
			pbOldCur++;
			pbNewCur++;
			}
		else
			{
			//	store the offset
			//
			Assert( pbOldCur >= dataOld.Pv() ); 
			const SIZE_T ibOld		= pbOldCur - (BYTE *)dataOld.Pv();
			const BYTE	*pbNewData	= pbNewCur;
			SIZE_T		cbNewData	= 0;
			SIZE_T		cbT;
				//	compare 4 bytes at a time until data streams re-sync
			do
				{
				if ( pbOldCur + sizeof( SIZE_T ) >= pbOldMax )
					cbT = pbOldMax - pbOldCur;
				else if ( *(Unaligned< SIZE_T > *)pbOldCur == *(Unaligned< SIZE_T > *)pbNewCur )
					{
					pbOldCur += sizeof( SIZE_T );
					pbNewCur += sizeof( SIZE_T );
					break;
					}
				else
					cbT = sizeof( SIZE_T );
					
				cbNewData += cbT;
				pbOldCur += cbT;
				pbNewCur += cbT;
				}
			while ( pbOldCur < pbOldMax );

			//	if end of comparision block is reached
			//	check if should truncate ot expand the size of chunk
			SIZE_T cbOldData = cbNewData;
			if ( pbOldCur == pbOldMax ) 
				{
				if ( fTruncate )
					{
					cbOldData += dataOld.Cb() - cbMinSize;
					}
				else
					{
					cbNewData += dataNew.Cb() - cbMinSize;
					}
				fEndIsReached = fTrue;	//	the differences are completly set
				}
				
			if ( !FLGAppendDiff(
					&pbDiffCur,
					pbDiffMax,					// max of pbCur to append
					ibOld,						// offset to old image
					cbOldData,					// length of the old image
					cbNewData,					// length of the new image
					pbNewData					// pbDataNew
					) )
				{
				return;
				}
			}
		}

	Assert( pbOldMax == pbOldCur );
		
	if ( pbDiffCur == pbDiff || !fEndIsReached )
		{
		//	No diff is found. Old and New are the same. Log insert null.
		//  Or different chunk's sizes. Log differences
		if ( !FLGAppendDiff(
					&pbDiffCur,
					pbDiffMax,					//	max of pbCur to append
					cbMinSize,					//	offset to old image
					dataOld.Cb() - cbMinSize,	//	length of the old image
					dataNew.Cb() - cbMinSize,	//	length of the new image
					pbNewCur ) )				//	pbDataNew
			{
			return;
			}

		}

	*pcbDiff = pbDiffCur - pbDiff;

#	if DEBUG
	Assert ( *pcbDiff != 0 );
	
	BYTE	rgbAfterImage[g_cbColumnLVChunkMax];
	SIZE_T	cbAfterImage;

	Assert( dataNew.Cb() <= g_cbColumnLVChunkMost );
	Assert( g_cbColumnLVChunkMost > REC::CbRecordMax() );
		
	LGGetAfterImage(
			pbDiff,
			*pcbDiff,
			(BYTE *)dataOld.Pv(),
			dataOld.Cb(),
			rgbAfterImage,
			&cbAfterImage );
	Assert( dataNew.Cb() == cbAfterImage );

	Assert( memcmp( rgbAfterImage, dataNew.Pv(), cbAfterImage ) == 0 );
#	endif
	}


VOID LGGetAfterImage(
	BYTE		*pbDiff,
	const SIZE_T	cbDiff,
	BYTE		*pbOld,
	const SIZE_T	cbOld,
	BYTE		*pbNew,
	SIZE_T	*pcbNew )
	{
	BYTE		*pbOldCur	= pbOld;
	BYTE		*pbNewCur	= pbNew;
	BYTE		*pbDiffCur	= pbDiff;
	BYTE		*pbDiffMax	= pbDiff + cbDiff;
	SIZE_T		cbT;

	while ( pbDiffCur < pbDiffMax )
		{
		INT 	cbDataNew;
		INT 	ibOffsetOld;
		SIZE_T 	cbSkip;
		
		DIFFHDR diffhdr = *( (DIFFHDR*) pbDiffCur );
		pbDiffCur += sizeof( DIFFHDR );
		
		ibOffsetOld = ( diffhdr.m_bitfield & DIFFHDR::ibOffsetMask ) >> DIFFHDR::ibOffsetShf;

		Assert( ibOffsetOld >= 0 );
		Assert( pbOld + ibOffsetOld >= pbOldCur );
		cbSkip = pbOld + ibOffsetOld - pbOldCur;
		Assert( g_cbColumnLVChunkMost > REC::CbRecordMax() );
		Assert( pbNewCur + cbSkip - pbNew <= g_cbColumnLVChunkMost );
		UtilMemCpy( pbNewCur, pbOldCur, cbSkip );
		pbNewCur += cbSkip;
		pbOldCur += cbSkip;
		
		if ( diffhdr.m_bitfield & DIFFHDR::fUseTwoBytesForDataLength )
			{
			cbDataNew = *( (UnalignedLittleEndian< WORD >*) pbDiffCur );
			pbDiffCur += sizeof( WORD );
			}
		else
			{
			cbDataNew = *( (UnalignedLittleEndian< BYTE >*) pbDiffCur );
			pbDiffCur += sizeof( BYTE );
			}
				
		Assert( g_cbColumnLVChunkMost > REC::CbRecordMax() );
		Assert( pbNewCur + cbDataNew - pbNew <= g_cbColumnLVChunkMost );
		if ( diffhdr.m_bitfield & DIFFHDR::fInsert )
			{
			UtilMemCpy( pbNewCur, pbDiffCur, cbDataNew );
			pbDiffCur += cbDataNew;
			}
		else
			{
			INT cbDataOld;

			if ( diffhdr.m_bitfield & DIFFHDR::fReplaceWithSameLength )
				{
				cbDataOld = cbDataNew;
				}
			else if ( diffhdr.m_bitfield & DIFFHDR::fUseTwoBytesForDataLength )
				{
				cbDataOld = *( (UnalignedLittleEndian< WORD >*) pbDiffCur );
				pbDiffCur += sizeof( WORD );
				}
			else
				{
				cbDataOld = *( (UnalignedLittleEndian< BYTE >*) pbDiffCur );
				pbDiffCur += sizeof( BYTE );
				}
				
			UtilMemCpy( pbNewCur, pbDiffCur, cbDataNew );
			pbDiffCur += cbDataNew;

			pbOldCur += cbDataOld;
			}

		pbNewCur += cbDataNew;

		Assert( pbDiffCur <= pbDiffMax );
		Assert( pbOldCur <= pbOld + cbOld );
		}

	//	copy the rest of before image.
	//
	cbT = pbOld + cbOld - pbOldCur;
	Assert( g_cbColumnLVChunkMost > REC::CbRecordMax() );
	Assert( pbNewCur + cbT - pbNew <= g_cbColumnLVChunkMost );
	UtilMemCpy( pbNewCur, pbOldCur, cbT );
	pbNewCur += cbT;

	//	set return value.
	//
	Assert( pbNewCur >= pbNew );
	*pcbNew = pbNewCur - pbNew;

	return;	
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\lv.cxx ===
/*******************************************************************

Long Values are stored in a per-table B-Tree. Each long value has 
a first node that contains the refcount and size of the long value
-- an LVROOT struct. The key of this node is the LID. Further nodes
have a key of LID:OFFSET (a LVKEY struct). The offset starts at 1
These values are big endian on disk.

OPTIMIZATION:  consider a critical section in each FCB for LV access
OPTIMIZATION:  don't store the longIdMax in the TDB. Seek to the end of
               the table, write latch the page and get the last id.

*******************************************************************/


#include "std.hxx"


//  ****************************************************************
//  MACROS
//  ****************************************************************

#ifdef DEBUG

//	DEBUG_LV:  this walks the long value tree at the top of RECAOSeparateLV
///#define DEBUG_LV

#endif	//	DEBUG


//  ****************************************************************
//  GLOBALS
//  ****************************************************************

//  OPTIMIZATION:  replace this with a pool of critical sections. hash on pgnoFDP
// LOCAL CCriticalSection critLV( CLockBasicInfo( CSyncBasicInfo( szLVCreate ), rankLVCreate, 0 ) );
// LOCAL PIB * ppibLV;


//  ****************************************************************
//  CONSTANTS
//  ****************************************************************

const ULONG ulLVOffsetFirst = 0;
const LID	lidMin			= 0;

//  ****************************************************************
//  INTERNAL FUNCTIONS
//  ****************************************************************


//  ****************************************************************
//  STRUCTURES
//  ****************************************************************


//  ================================================================
PERSISTED
struct LVKEY
//  ================================================================
//
// 	the nodes in the Long Value tree use a longID and an offset as
//  keys. we must have the lid first as this is all we store for LVROOTs
//
//-
	{
	UnalignedBigEndian< LID >		lid;
	UnalignedBigEndian< ULONG >		offset;
	};


//  ================================================================
INLINE LVKEY LVKeyFromLidOffset( LID lid, ULONG ulOffset )
//  ================================================================
	{
	Assert( lid > lidMin );
	LVKEY lvkey;
	lvkey.lid = lid;
	lvkey.offset = ulOffset;
	return lvkey;
	}


//  ================================================================
VOID OffsetFromKey( ULONG * pulOffset, const KEY& key )
//  ================================================================
	{
	Assert( sizeof( LVKEY ) == key.Cb() );
	Assert( pulOffset );

	LVKEY lvkey;
	key.CopyIntoBuffer( &lvkey );
	*pulOffset = lvkey.offset;
	}


//  ================================================================
INLINE VOID LidFromKey( LID * plid, const KEY& key )
//  ================================================================
	{
	Assert( sizeof( LVKEY ) == key.Cb() || sizeof( LID ) == key.Cb() );
	Assert( plid );

	LVKEY lvkey;
	key.CopyIntoBuffer( &lvkey );
	*plid = lvkey.lid;
	Assert( *plid > lidMin );
	}


//  ================================================================
VOID LidOffsetFromKey( LID * plid, ULONG * pulOffset, const KEY& key )
//  ================================================================
	{
	Assert( sizeof( LVKEY ) == key.Cb() );
	Assert( plid );
	Assert( pulOffset );

	LidFromKey( plid, key );
	OffsetFromKey( pulOffset, key );
	Assert( *pulOffset % g_cbColumnLVChunkMost == 0 );
	}



#ifdef LV_MERGE_BUG

LOCAL VOID LVICheckLVPage( FUCB *pfucb, CSR *pcsr, LID *plidOrphan )
	{
	const LID	lidOrphan		= *plidOrphan;
	LID			lidPrev			= lidMin;
	ULONG		ulOffsetPrev	= 0;
	BOOL		fLastSawRoot	= fFalse;
	BOOL		fLastSawData	= fFalse;
	ULONG		iline;
	const ULONG	clines			= pcsr->Cpage().Clines();

	Assert( pcsr->FLatched() );

	//	reset return value
	*plidOrphan = lidMin;
	
	for ( iline = 0; iline < clines; iline++ )
		{
		LID		lidT;
		ULONG	ulOffsetT;
		
		pcsr->ILine() = iline;
		NDGet( pfucb, pcsr );

		if ( FNDDeleted( pfucb->kdfCurr ) )
			continue;

		if ( sizeof(LID) == pfucb->kdfCurr.key.Cb() )
			{
			Enforce( sizeof(LVROOT) == pfucb->kdfCurr.data.Cb() );

			LidFromKey( &lidT, pfucb->kdfCurr.key );

			//	LIDs are monotonically increasing
			Enforce( lidPrev < lidT )

			//	assert below is invalid, because we can actually get two
			//	straight LVROOTs if two threads are inserting LV's simultaneously
			///	Assert( !fLastSawRoot );

			lidPrev = lidT;
			ulOffsetPrev = 0;
			fLastSawRoot = fTrue;
			fLastSawData = fFalse;
			}
			
		else if ( sizeof(LVKEY) == pfucb->kdfCurr.key.Cb() )
			{
			LidOffsetFromKey( &lidT, &ulOffsetT, pfucb->kdfCurr.key );
			if ( fLastSawRoot )
				{
				//	lid doesn't match root, or not first data node
				Enforce( lidT == lidPrev );
				Enforce( 0 == ulOffsetT );
				}
			else if ( fLastSawData )
				{
				//	lid doesn't match previous node, or offset not in line with offset of previous node
				Enforce( lidT == lidPrev );
				Enforce( ulOffsetT == ulOffsetPrev + g_cbColumnLVChunkMost );
				}
			else
				{
				Enforce( 0 == iline );

				//	LVROOT must be on previous page
				*plidOrphan = lidT;
				}

			lidPrev = lidT;
			ulOffsetPrev = ulOffsetT;
			fLastSawRoot = fFalse;
			fLastSawData = fTrue;
			}
		else
			{
			//	invalid key size
			EnforceSz( fFalse, "LV node has invalid key size" );
			}
		}

	if ( lidOrphan > lidMin && lidOrphan != lidPrev )
		{
		//	the next page had an orphan, so the last lid we encounter on this page should
		//	match the orphan
		Enforce( fFalse );
		}
	}

//	copied from FBTIUpdatablePage() (because that function is only
//	exposed in _bt.hxx)
INLINE BOOL	FLVIUpdatablePage( CSR *pcsr ) 
	{
	LOG *plog = PinstFromIfmp( pcsr->Cpage().Ifmp() )->m_plog;
	
	Assert( ( plog->m_fRecovering && latchRIW == pcsr->Latch() )
		|| latchWrite == pcsr->Latch() );
	
	return !plog->m_fRecovering || latchWrite == pcsr->Latch();
	}

VOID LVICheckLVMerge( FUCB *pfucb, MERGEPATH *pmergePath )
	{
	CSR			*pcsr			= &pmergePath->csr;
	CSR			*pcsrRight		= &pmergePath->pmerge->csrRight;
	CSR			*pcsrLeft		= &pmergePath->pmerge->csrLeft;
	LID			lidOrphan		= lidMin;
	const BOOL	fCheckMergePage	= FLVIUpdatablePage( pcsr );
	const BOOL	fCheckRight		= FLVIUpdatablePage( pcsrRight );
	const BOOL	fCheckLeft		= ( pgnoNull != pcsrLeft->Pgno()
									&& FLVIUpdatablePage( pcsrLeft ) );

	//	merge page is dependent on right page
	Enforce( !fCheckRight || fCheckMergePage );

	Enforce( pcsrRight->Pgno() != pgnoNull );
		
	if ( fCheckRight )
		LVICheckLVPage( pfucb, pcsrRight, &lidOrphan );

	if ( mergetypeFullRight != pmergePath->pmerge->mergetype )
		{
		Enforce( !fCheckRight || pcsrRight->Cpage().PgnoPrev() == pcsr->Pgno() );
		Enforce( !fCheckLeft || pcsrLeft->Cpage().PgnoNext() == pcsr->Pgno() );
		if ( fCheckMergePage )
			{
			Enforce( pcsr->Cpage().PgnoNext() == pcsrRight->Pgno() );
			Enforce( pcsr->Cpage().PgnoPrev() == pcsrLeft->Pgno() );

			LVICheckLVPage( pfucb, pcsr, &lidOrphan );
			}
		else
			{
			//	can't check merged page, must reset orphan or we might
			//	end up thinking the orphan's root is on the left page
			lidOrphan = lidMin;
			}
		}
	else
		{
		Enforce( !fCheckRight || pcsrRight->Cpage().PgnoPrev() == pcsrLeft->Pgno() );
		Enforce( !fCheckLeft || pcsrLeft->Cpage().PgnoNext() == pcsrRight->Pgno() );
		}

	if ( fCheckLeft )
		{
		LVICheckLVPage( pfucb, pcsrLeft, &lidOrphan );
		}
	}

#endif	//	LV_MERGE_BUG



//	retrieve versioned LV refcount
INLINE ULONG UlLVIVersionedRefcount( FUCB *pfucbLV )
	{
	LVROOT				*plvrootVersioned;
	LONG				lCompensating;
	BOOKMARK			bookmark;

	Assert( Pcsr( pfucbLV )->FLatched() );
	Assert( sizeof(LVROOT) == pfucbLV->kdfCurr.data.Cb() );
	Assert( sizeof(LID) == pfucbLV->kdfCurr.key.Cb() );

	bookmark.key = pfucbLV->kdfCurr.key;
	bookmark.data.Nullify();

	plvrootVersioned = reinterpret_cast<LVROOT*>( pfucbLV->kdfCurr.data.Pv() );

	lCompensating = LDeltaVERGetDelta( pfucbLV, bookmark, OffsetOf( LVROOT, ulReference )	);

	return plvrootVersioned->ulReference + lCompensating;
	}


//  ****************************************************************
//  DEBUG ROUTINES
//  ****************************************************************


//  ================================================================
INLINE VOID AssertLVRootNode( FUCB *pfucbLV, const LID lid )
//  ================================================================
//
//  This checks that the FUCB is currently referencing a valid LVROOT node
//
//-
	{
#ifdef DEBUG	
	LID		lidT;

	Assert( Pcsr( pfucbLV )->FLatched() );
	Assert( sizeof(LVROOT) == pfucbLV->kdfCurr.data.Cb() );
	Assert( sizeof(LID) == pfucbLV->kdfCurr.key.Cb() );
	LidFromKey( &lidT, pfucbLV->kdfCurr.key );
	Assert( lid == lidT );

	// versioned refcount must be non-zero, otherwise we couldn't see it
	// if FPIBDirty() is set then concurrent create index is looking at this LV
	// it is possible that the refcount could be zero
	Assert( UlLVIVersionedRefcount( pfucbLV ) > 0 || FPIBDirty( pfucbLV->ppib ) );
#endif	
	}


//	verify lid/offset of an LVKEY node
INLINE VOID AssertLVDataNode(
	FUCB		*pfucbLV,
	const LID	lid,
	const ULONG ulOffset )
	{
#ifdef DEBUG
	LID			lidT;
	ULONG		ib;

	Assert( Pcsr( pfucbLV )->FLatched() );
	Assert( sizeof(LVKEY) == pfucbLV->kdfCurr.key.Cb() );
	LidOffsetFromKey( &lidT, &ib, pfucbLV->kdfCurr.key );
	Assert( lid == lidT );
	Assert( ib % g_cbColumnLVChunkMost == 0 );
	Assert( ulOffset == ib );
#endif
	}


//  ================================================================
VOID LVReportCorruptedLV( const FUCB * const pfucbLV, const LID lid )
//  ================================================================
	{
	const CHAR *rgsz[4];
	INT			irgsz = 0;

	CHAR szTable[JET_cbNameMost+1];
	CHAR szDatabase[IFileSystemAPI::cchPathMax+1];
	CHAR szpgno[16];
	CHAR szlid[16];

	strcpy( szTable, pfucbLV->u.pfcb->PfcbTable()->Ptdb()->SzTableName() );
	strcpy( szDatabase, rgfmp[pfucbLV->u.pfcb->Ifmp()].SzDatabaseName() );
	sprintf( szpgno, "%d", Pcsr( pfucbLV )->Pgno() );
	sprintf( szlid, "%d", lid );

	rgsz[irgsz++] = szTable;
	rgsz[irgsz++] = szDatabase;
	rgsz[irgsz++] = szpgno;
	rgsz[irgsz++] = szlid;

	UtilReportEvent(
			eventError,
			DATABASE_CORRUPTION_CATEGORY,
			CORRUPT_LONG_VALUE_ID,
			irgsz,
			rgsz,
			0,
			NULL,
			PinstFromPfucb( pfucbLV ) );
	}


ERR ErrLVCheckDataNodeOfLid( FUCB *pfucbLV, const LID lid )
	{
	ERR		err;
	LID		lidT;
	
	Assert( Pcsr( pfucbLV )->FLatched() );

	if( fGlobalRepair )
		{
		//  don't bother returning an error during repair
		//  if we are running repair the database is probably corrupted
		return JET_errSuccess;
		}
		
	if ( sizeof(LVKEY) == pfucbLV->kdfCurr.key.Cb() )
		{
		LidFromKey( &lidT, pfucbLV->kdfCurr.key );
		if ( lid == lidT )
			{
#ifdef DEBUG
			ULONG	ib;
			OffsetFromKey( &ib, pfucbLV->kdfCurr.key );
			Assert( ib % g_cbColumnLVChunkMost == 0 );
#endif

			//	this is a valid data node belonging to this lid
			err = JET_errSuccess;
			}
		else
			{
			//	should be impossible (if lids don't match, we
			//	should have hit an LV root node, not another
			//	LV data node)
			LVReportCorruptedLV( pfucbLV, lid );
			FireWall();
			err = ErrERRCheck( JET_errLVCorrupted );
			}
		}

	else if ( sizeof(LID) == pfucbLV->kdfCurr.key.Cb()
		&& sizeof(LVROOT) == pfucbLV->kdfCurr.data.Cb() )
		{
		LidFromKey( &lidT, pfucbLV->kdfCurr.key );
		if ( lidT <= lid  )
			{
			LVReportCorruptedLV( pfucbLV, lid );
			FireWall();

			//	current LV has should have higher lid than previous LV
			err = ErrERRCheck( JET_errLVCorrupted );
			}
		else
			{
			//	moved on to a new lid, issue warning
			err = ErrERRCheck( wrnLVNoMoreData );
			}
		}
	else
		{
		LVReportCorruptedLV( pfucbLV, lid );
		FireWall();

		//	bogus LV node
		err = ErrERRCheck( JET_errLVCorrupted );
		}

	return err;
	}


#ifdef DEBUG
//  ================================================================
BOOL FAssertLVFUCB( const FUCB * const pfucb )
//  ================================================================
//
//  Asserts that the FUCB references a Long Value directory
//  long value directories do not have TDBs.
//
//-
	{
	FCB	*pfcb = pfucb->u.pfcb;
	if ( pfcb->FTypeLV() )
		{
		Assert( pfcb->Ptdb() == ptdbNil );
		}
	return pfcb->FTypeLV();
	}
#endif	


//  ****************************************************************
//  ROUTINES
//  ****************************************************************


//  ================================================================
BOOL FPIBSessionLV( PIB *ppib )
//  ================================================================
	{
	Assert( ppibNil != ppib );
	return ( PinstFromPpib(ppib)->m_ppibLV == ppib );
	}


//  ================================================================
LOCAL ERR ErrFILECreateLVRoot( PIB *ppib, FUCB *pfucb, PGNO *ppgnoLV )
//  ================================================================
//
//  Creates the LV tree for the given table. 
//	
//-
	{
	ERR		err = JET_errSuccess;
	FUCB	*pfucbTable = pfucbNil;
	PGNO	pgnoLVFDP = pgnoNull;
	OBJID	objidLV;
	BOOL	fInTransaction = fFalse;

	Assert( !FAssertLVFUCB( pfucb ) );
	
	const BOOL	fTemp = ( dbidTemp == rgfmp[ pfucb->ifmp ].Dbid() );
	Assert( ( fTemp && pfucb->u.pfcb->FTypeTemporaryTable() )
		|| ( !fTemp && pfucb->u.pfcb->FTypeTable() ) );

#ifdef DEBUG
	const BOOL	fExclusive = !FPIBSessionLV( ppib );
	if ( fExclusive )
		{
		Assert( pfucb->ppib == ppib );
		Assert( pfucb->u.pfcb->FDomainDenyReadByUs( pfucb->ppib ) );
		}
	else
		{
		Assert( !FPIBSessionLV( pfucb->ppib ) );
		Assert( !pfucb->u.pfcb->FDomainDenyReadByUs( pfucb->ppib ) );
		Assert( PinstFromPpib(ppib)->m_critLV.FOwner() );
		}
#endif		
	
	//  open the parent directory (so we are on the pgnoFDP ) and create the LV tree
	CallR( ErrDIROpen( ppib, pfucb->u.pfcb, &pfucbTable ) );
	Call( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	fInTransaction = fTrue;

	Call( PverFromIfmp( pfucb->ifmp )->ErrVERFlag( pfucbTable, operCreateLV, NULL, 0 ) );
	
	//  CONSIDER:  get at least enough pages to hold the LV we are about to insert
	//  we must open the directory with a different session.
	//	if this fails, rollback will free the extent, or at least, it will attempt
	//  to free the extent.
	Call( ErrDIRCreateDirectory( pfucbTable, cpgLVTree, &pgnoLVFDP, &objidLV, CPAGE::fPageLongValue ) );

	Assert( pgnoLVFDP > pgnoSystemRoot );
	Assert( pgnoLVFDP <= pgnoSysMax );
	Assert( pgnoLVFDP != pfucbTable->u.pfcb->PgnoFDP() );

	if ( !fTemp )
		{
		Assert( objidLV > objidSystemRoot );
		Call( ErrCATAddTableLV(
					ppib,
					pfucb->ifmp,
					pfucb->u.pfcb->ObjidFDP(),
					pgnoLVFDP,
					objidLV ) );
		}

	Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );
	fInTransaction = fFalse;

	*ppgnoLV = pgnoLVFDP;

HandleError:
	if ( fInTransaction )
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}
	Assert( pfucbTable != pfucbNil );
	DIRClose( pfucbTable );

#ifdef DEBUG
	if ( !fExclusive )
		Assert( PinstFromPpib(ppib)->m_critLV.FOwner() );
#endif		

	//	should have no other directory with the same parentId and name, or the same pgnoFDP	
	Assert( JET_errKeyDuplicate != err );
	return err;
	}


//  ================================================================
INLINE ERR ErrFILEIInitLVRoot( FUCB *pfucb, const PGNO pgnoLV, FUCB **ppfucbLV )
//  ================================================================
	{
	ERR				err;
	FCB * const		pfcbTable	= pfucb->u.pfcb;
	FCB	*			pfcbLV;

	// Link LV FCB into table.
	CallR( ErrDIROpen( pfucb->ppib, pgnoLV, pfucb->ifmp, ppfucbLV ) );
	Assert( *ppfucbLV != pfucbNil );
	Assert( !FFUCBVersioned( *ppfucbLV ) );	// Verify won't be deferred closed.
	pfcbLV = (*ppfucbLV)->u.pfcb;
	Assert( !pfcbLV->FInitialized() );

	Assert( pfcbLV->Ifmp() == pfucb->ifmp );
	Assert( pfcbLV->PgnoFDP() == pgnoLV );
	Assert( pfcbLV->Ptdb() == ptdbNil );
	Assert( pfcbLV->CbDensityFree() == 0 );

	Assert( pfcbLV->FTypeNull() );
	pfcbLV->SetTypeLV();
	
	Assert( pfcbLV->PfcbTable() == pfcbNil );
	pfcbLV->SetPfcbTable( pfcbTable );

	//	NOTE: we do not need to lock pfcbLV to read FAboveThreshold()
	//		  because the flag will never change on an LV FCB
	
	if ( pfcbLV->FAboveThreshold() )
		{
		//	since there is a cursor open on the FCB, it will not be in
		//		the avail list and we can directly set the flag
		
		//	NOTE: we must be the only people accessing pfucb->u.pfcb
		pfcbTable->Lock();
		pfcbTable->SetAboveThreshold();
		pfcbTable->Unlock();
		}

	//	finish the initialization of this LV FCB
	
	pfcbLV->CreateComplete();

	//	WARNING: publishing the FCB in the TDB *must*
	//	be the last thing or else other sessions might
	//	see an FCB that's not fully initialised
	//
	Assert( pfcbNil == pfcbTable->Ptdb()->PfcbLV() );
	pfcbTable->Ptdb()->SetPfcbLV( pfcbLV );

	return err;
	}


//  ================================================================
ERR ErrFILEOpenLVRoot( FUCB *pfucb, FUCB **ppfucbLV, BOOL fCreate )
//  ================================================================
	{
	ERR			err;
	PIB			*ppib;
	PGNO		pgnoLV = pgnoNull;
	
	Assert( pfcbNil != pfucb->u.pfcb );
	Assert( pfucb->ppib != PinstFromPfucb(pfucb)->m_ppibLV );

	//  HACK: repair checks only one table per thread, but we can't open derived tables
	//  if the template table is opened exculsively
	
	const BOOL	fExclusive = pfucb->u.pfcb->FDomainDenyReadByUs( pfucb->ppib ) || fGlobalRepair;
	const BOOL	fTemp = ( dbidTemp == rgfmp[ pfucb->ifmp ].Dbid() );	

	Assert( PinstFromPfucb(pfucb)->m_critLV.FNotOwner() );
	
	if ( fExclusive )
		{
		Assert( ( fTemp && pfucb->u.pfcb->FTypeTemporaryTable() )
			|| ( !fTemp && pfucb->u.pfcb->FTypeTable() ) );
		ppib = pfucb->ppib;
		Assert( pfcbNil == pfucb->u.pfcb->Ptdb()->PfcbLV() );
		}
	else
		{
		Assert( !fTemp );
		Assert( pfucb->u.pfcb->FTypeTable() );
		
		PinstFromPfucb(pfucb)->m_critLV.Enter();
		ppib = PinstFromPfucb(pfucb)->m_ppibLV;

		FCB	*pfcbLV = pfucb->u.pfcb->Ptdb()->PfcbLV();

		//  someone may have come in and created the LV tree already
		if ( pfcbNil != pfcbLV )
			{
			PinstFromPfucb(pfucb)->m_critLV.Leave();
			
			// PfcbLV won't go away, since only way it would be freed is if table
			// FCB is freed, which can't happen because we've got a cursor on the table.
			err = ErrDIROpen( pfucb->ppib, pfcbLV, ppfucbLV );
			return err;
			}
			
		err = ErrDBOpenDatabaseByIfmp( PinstFromPfucb(pfucb)->m_ppibLV, pfucb->ifmp );
		if ( err < 0 )
			{
			PinstFromPfucb(pfucb)->m_critLV.Leave();
			return err;
			}
		}

	Assert( pgnoNull == pgnoLV );	// initial value
	if ( !fTemp )
		{
		Call( ErrCATAccessTableLV( ppib, pfucb->ifmp, pfucb->u.pfcb->ObjidFDP(), &pgnoLV ) );
		}
	else
		{
		//	if opening LV tree for a temp. table, it MUST be created
		Assert( fCreate );
		}

	if ( pgnoNull == pgnoLV && fCreate )
		{
		// LV root not yet created.
		Call( ErrFILECreateLVRoot( ppib, pfucb, &pgnoLV ) );
		}

	// For temp. tables, if initialisation fails here, the space
	// for the LV will be lost, because it's not persisted in
	// the catalog.
	if( pgnoNull != pgnoLV )
		{
		err = ErrFILEIInitLVRoot( pfucb, pgnoLV, ppfucbLV );
		}
	else
		{
		//	if only opening LV tree (ie. no creation), and no LV tree
		//	exists, then return warning and no cursor.
		Assert( !fTemp );
		Assert( !fCreate );
		*ppfucbLV = pfucbNil;
		err = ErrERRCheck( wrnLVNoLongValues );
		}

HandleError:
	if ( !fExclusive )
		{
		Assert( ppib == PinstFromPfucb(pfucb)->m_ppibLV );
		CallS( ErrDBCloseAllDBs( PinstFromPfucb(pfucb)->m_ppibLV ) );

		PinstFromPfucb(pfucb)->m_critLV.Leave();
		}

#ifdef DEBUG
	if ( pfucb->u.pfcb->Ptdb()->PfcbLV() == pfcbNil )
		{
		Assert( err < JET_errSuccess
			|| ( !fCreate && wrnLVNoLongValues == err ) );
		}
	else
		{
		CallS( err );
		}
#endif

	return err;
	}


//  ================================================================
LOCAL ERR ErrDIROpenLongRoot(
	FUCB *		pfucb,
	FUCB **		ppfucbLV,
	const BOOL	fAllowCreate )
//  ================================================================
//
//  Extract the pgnoFDP of the long value tree table from the catalog and go to it
//  if the Long Value tree does not exist we will create it
//
//-
	{
	Assert( !FAssertLVFUCB( pfucb ) );
	Assert( ppfucbLV );


	Assert( pfcbNil != pfucb->u.pfcb );
	Assert( pfucb->u.pfcb->FTypeTable()
		|| pfucb->u.pfcb->FTypeTemporaryTable() );

	ERR			err		= JET_errSuccess;
	FCB * const	pfcbLV	= pfucb->u.pfcb->Ptdb()->PfcbLV();

	if ( pfcbNil == pfcbLV )
		{
		CallR( ErrFILEOpenLVRoot( pfucb, ppfucbLV, fAllowCreate ) );
		if ( wrnLVNoLongValues == err )
			{
			Assert( !fAllowCreate );
			Assert( pfucbNil == *ppfucbLV );
			return err;
			}
		else
			{
			CallS( err );
			Assert( pfucbNil != *ppfucbLV );
			}
		}
	else
		{
		CallR( ErrDIROpen( pfucb->ppib, pfcbLV, ppfucbLV ) );
		Assert( (*ppfucbLV)->u.pfcb == pfcbLV );
		}

	ASSERT_VALID( *ppfucbLV );
	
#ifdef DEBUG
	FCB * const	pfcbLVDBG	= (*ppfucbLV)->u.pfcb;
	Assert( pfcbLVDBG != pfcbNil );
	Assert( pfcbLVDBG->Ifmp() == pfucb->ifmp );
	Assert( pfcbLVDBG->PgnoFDP() != pfucb->u.pfcb->PgnoFDP() );
	Assert( pfcbLVDBG->Ptdb() == ptdbNil );
	Assert( pfcbLVDBG->FInitialized() );
	Assert( pfcbLVDBG->FTypeLV() );
	Assert( pfcbLVDBG->PfcbTable() == pfucb->u.pfcb );
	Assert( pfucb->u.pfcb->Ptdb()->PfcbLV() == pfcbLVDBG );

	// UNDONE: Since FCB critical sections are shared, is it not possible for this
	// assert to fire on a hash collision??
	Assert( pfcbLVDBG->IsUnlocked() );	//lint !e539
#endif

	FUCBSetLongValue( *ppfucbLV );

	//	if our table is open in sequential mode open the long value
	//	table in sequential mode as well.
    //	note that compact opens all its tables in sequential mode
    if ( FFUCBSequential( pfucb ) )
		{
        FUCBSetSequential( *ppfucbLV );
        }
    else
    	{
		FUCBResetSequential( *ppfucbLV );
	    }

	return err;
	}

LOCAL ERR ErrDIROpenLongRoot( FUCB * pfucb )
	{
	ERR	err	= JET_errSuccess;

	if ( pfucbNil == pfucb->pfucbLV )
		{
		//	use cached LV cursor
		CallR( ErrDIROpenLongRoot( pfucb, &pfucb->pfucbLV, fFalse ) );
		pfucb->pfucbLV->pfucbTable = pfucb;
		}
	else
		{
		Assert( FFUCBMayCacheLVCursor( pfucb ) );
		Assert( FFUCBLongValue( pfucb->pfucbLV ) );
		Assert( pfucb->pfucbLV->pfucbTable == pfucb );
		Assert( pfcbNil != pfucb->pfucbLV->u.pfcb );
		Assert( pfucb->pfucbLV->u.pfcb->FTypeLV() );
		Assert( pfucb->pfucbLV->u.pfcb->FInitialized() );
		Assert( pfucb->pfucbLV->u.pfcb->PfcbTable() == pfucb->u.pfcb );

		//	if our table is open in sequential mode open the long value
		//	table in sequential mode as well.
    	//	note that compact opens all its tables in sequential mode
	    if ( FFUCBSequential( pfucb ) )
			{
        	FUCBSetSequential( pfucb->pfucbLV );
	        }
    	else
	    	{
			FUCBResetSequential( pfucb->pfucbLV );
	    	}

    	//	OPTIMISATION: Should really call DIRUp() here to reset
    	//	currency, but all callers of this function immediately
    	//	do a ErrDIRDownLV(), which performs the DIRUp() for us
///    	DIRUp();
		}

	return err;
	}

INLINE VOID DIRCloseLongRoot( FUCB * pfucb )
	{
	Assert( pfucbNil != pfucb );
	Assert( pfcbNil != pfucb->u.pfcb );
	Assert( pfucb->u.pfcb->FTypeTable()
		|| pfucb->u.pfcb->FTypeTemporaryTable() );
	Assert( pfucbNil != pfucb->pfucbLV );
	Assert( pfucb->pfucbLV->pfucbTable == pfucb );
	Assert( pfcbNil != pfucb->pfucbLV->u.pfcb );
	Assert( pfucb->pfucbLV->u.pfcb->FTypeLV() );

	if ( FFUCBMayCacheLVCursor( pfucb ) )
		{
		DIRUp( pfucb->pfucbLV );
		}
	else
		{
		DIRClose( pfucb->pfucbLV );
		pfucb->pfucbLV = pfucbNil;
		}
	}


//  ================================================================
ERR ErrDIRDownLV(
	FUCB			*pfucb,
	const LID		lid,
	const ULONG		ulOffset,
	const DIRFLAG	dirflag )
//  ================================================================
//
//	This takes an FUCB that is opened on the Long Value tree table and seeks
//  to the appropriate offset in the long value.
//
//-
	{
	Assert( FAssertLVFUCB( pfucb ) );
	Assert( lid > lidMin );

	//  normalize the offset to a multiple of g_cbColumnLVChunkMost. we should seek to the exact node
	const ULONG ulOffsetT = ( ulOffset / g_cbColumnLVChunkMost ) * g_cbColumnLVChunkMost;
	
	//  make a key that consists of the long id and the offset
	const LVKEY	lvkey = LVKeyFromLidOffset( lid, ulOffsetT );

	DIRUp( pfucb );
	
	BOOKMARK	bm;
	bm.key.prefix.Nullify();
	bm.key.suffix.SetPv( const_cast<LVKEY *>( &lvkey ) );
	bm.key.suffix.SetCb( sizeof( LVKEY ) );
	bm.data.Nullify();

	DIB			dib;
	dib.dirflag = dirflag | fDIRExact;
	dib.pos		= posDown;
	dib.pbm		= &bm;
	
	ERR err = ErrDIRDown( pfucb, &dib );

	if ( JET_errSuccess == err )
		{
		AssertLVDataNode( pfucb, lid, ulOffsetT );
		}
	else if ( wrnNDFoundGreater == err
			|| wrnNDFoundLess == err )
		{
		LVReportCorruptedLV( pfucb, lid );
		FireWall();
		err = ErrERRCheck( JET_errLVCorrupted );
		}

	return err;
	}


//  ================================================================
ERR ErrDIRDownLV( FUCB * pfucb, const LID lid, DIRFLAG dirflag )
//  ================================================================
//
//	This takes an FUCB that is opened on the Long Value tree table and seeks
//  to the LVROOT node
//
//-
	{
	Assert( FAssertLVFUCB( pfucb ) );
	Assert( lid > lidMin );

	DIRUp( pfucb );

	//  make a key that consists of the LID only

	BYTE rgbKey[ sizeof( LID ) ];
	KeyFromLong( rgbKey, lid );

	BOOKMARK	bm;
	bm.key.prefix.Nullify();
	bm.key.suffix.SetPv( rgbKey );
	bm.key.suffix.SetCb( sizeof( rgbKey ) );
	bm.data.Nullify();

	DIB	dib;
	dib.dirflag = dirflag | fDIRExact;
	dib.pos		= posDown;
	dib.pbm		= &bm;
	
	ERR	err		= ErrDIRDown( pfucb, &dib );

	if ( JET_errSuccess == err )
		{
		AssertLVRootNode( pfucb, lid );
		}
	else if ( ( wrnNDFoundGreater == err
				|| wrnNDFoundLess == err
				|| JET_errRecordNotFound == err )
			&& !fGlobalRepair )
		{
		Assert( pfucb->ppib->level > 0 );
		LVReportCorruptedLV( pfucb, lid );
		FireWall();
		err = ErrERRCheck( JET_errLVCorrupted );
		}

	return err;
	}


//  ================================================================
INLINE ERR ErrRECISetLid(
	FUCB			*pfucb,
	const COLUMNID	columnid,
	const ULONG		itagSequence,
	const LID		lid )
//  ================================================================
//
//  Sets the separated LV struct in the record to point to the given LV.
//  Used after an LV is copied.
//
//-
	{
	Assert( !FAssertLVFUCB( pfucb ) );
	Assert( lid > lidMin );

	UnalignedLittleEndian< LID >		lidT	= lid;
	DATA								dataLV;

	dataLV.SetPv( &lidT );
	dataLV.SetCb( sizeof(lidT) );

	const ERR	err		= ErrRECSetColumn(
								pfucb,
								columnid,
								itagSequence,
								&dataLV,
								grbitSetColumnSeparated );
	return err;
	}


//	========================================================================
ERR ErrLVInit( INST *pinst )
//	========================================================================
//
//  This may leak critical sections if ErrPIBBeginSession fails.
//  Is this important?
//
//-
	{
	ERR err = JET_errSuccess;

	if ( !pinst->FRecovering() )
		{
		Call( ErrPIBBeginSession( pinst, &pinst->m_ppibLV, procidNil, fFalse ) );
		}

HandleError:
	return err;
	}


//	========================================================================
VOID LVTerm( INST * pinst )
//	========================================================================
	{	
	Assert( pinst->m_critLV.FNotOwner() );

	if ( pinst->m_ppibLV )
		{
		PIBEndSession( pinst->m_ppibLV );
		pinst->m_ppibLV = ppibNil;
		}
	}


// WARNING: See "LV grbit matrix" before making any modifications here.
INLINE ERR ErrLVOpFromGrbit(
	const JET_GRBIT	grbit,
	const ULONG		cbData,
	const BOOL		fNewInstance,
	const ULONG		ibLongValue,
	LVOP			*plvop )
	{
	const BOOL		fNoCbData = ( 0 == cbData );
	
	switch ( grbit )
		{
		case JET_bitSetAppendLV:
			if ( fNoCbData )
				{
				*plvop = ( fNewInstance ? lvopInsertZeroLength : lvopNull );
				}
			else
				{
				*plvop = ( fNewInstance ? lvopInsert : lvopAppend );
				}
			break;
		case JET_bitSetOverwriteLV:
			if ( fNoCbData )
				{
				if ( fNewInstance )
					{
					if ( 0 == ibLongValue )
						*plvop = lvopInsertZeroLength;
					else
						{
						*plvop = lvopNull;
						return ErrERRCheck( JET_errColumnNoChunk );
						}
					}
				else
					*plvop = lvopNull;
				}
			else
				{
				if ( fNewInstance )
					{
					if ( 0 == ibLongValue )
						*plvop = lvopInsert;
					else
						{
						*plvop = lvopNull;
						return ErrERRCheck( JET_errColumnNoChunk );
						}
					}
				else
					*plvop = lvopOverwriteRange;
				}
			break;
		case JET_bitSetSizeLV:
			if ( fNoCbData )
				{
				*plvop = ( fNewInstance ? lvopInsertNull : lvopReplaceWithNull );
				}
			else
				{
				*plvop = ( fNewInstance ? lvopInsertZeroedOut : lvopResize );
				}
			break;
		case JET_bitSetZeroLength:
			if ( fNoCbData )
				{
				*plvop = ( fNewInstance ? lvopInsertZeroLength : lvopReplaceWithZeroLength );
				}
			else
				{
				*plvop = ( fNewInstance ? lvopInsert : lvopReplace );
				}
			break;
		case JET_bitSetSizeLV|JET_bitSetZeroLength:
			if ( fNoCbData )
				{
				*plvop = ( fNewInstance ? lvopInsertZeroLength : lvopReplaceWithZeroLength );
				}
			else
				{
				*plvop = ( fNewInstance ? lvopInsertZeroedOut : lvopResize );
				}
			break;
		case JET_bitSetSizeLV|JET_bitSetOverwriteLV:
			if ( fNoCbData )
				{
				*plvop = ( fNewInstance ? lvopInsertNull : lvopReplaceWithNull );
				}
			else if ( fNewInstance )
				{
				if ( 0 == ibLongValue )
					*plvop = lvopInsert;
				else
					{
					*plvop = lvopNull;
					return ErrERRCheck( JET_errColumnNoChunk );
					}
				}
			else
				{
				*plvop = lvopOverwriteRangeAndResize;
				}
			break;
		default:
			Assert( 0 == grbit );
			if ( fNoCbData )
				{
				*plvop = ( fNewInstance ? lvopInsertNull : lvopReplaceWithNull );
				}
			else
				{
				*plvop = ( fNewInstance ? lvopInsert : lvopReplace );
				}
		}

	return JET_errSuccess;
	}

#ifdef INTRINSIC_LV

//	================================================================
LOCAL ERR ErrRECIBigGateToAOIntrinsicLV(
	FUCB			*pfucb,
	const COLUMNID	columnid,
	const ULONG		itagSequence,
	const DATA		*pdataColumn,
	const DATA		*pdataNew,
	const ULONG		ibLongValue,
	const LVOP		lvop)
//	================================================================
	{
	BYTE rgb[g_cbPageMax];
	Assert( pdataNew->Cb() <= cbLVIntrinsicMost );
	return ErrRECAOIntrinsicLV(
				pfucb,
				columnid,
				itagSequence,
				pdataColumn,
				pdataNew,
				ibLongValue,
				lvop,
				rgb );
	}

//	================================================================
LOCAL ERR ErrRECIRegularGateToAOIntrinsicLV(
	FUCB			*pfucb,
	const COLUMNID	columnid,
	const ULONG		itagSequence,
	const DATA		*pdataColumn,
	const DATA		*pdataNew,
	const ULONG		ibLongValue,
	const LVOP		lvop)
//	================================================================
	{
	BYTE rgb[cbLVBurstMin-1];
	Assert( pdataNew->Cb() < cbLVBurstMin );
	return ErrRECAOIntrinsicLV(
				pfucb,
				columnid,
				itagSequence,
				pdataColumn,
				pdataNew,
				ibLongValue,
				lvop,
				rgb );
	}

#endif // INTRINSIC_LV

//	================================================================

//  ================================================================
ERR ErrRECSetLongField(
	FUCB 			*pfucb,
	const COLUMNID	columnid,
	const ULONG		itagSequence,
	DATA			*pdataField,
	JET_GRBIT		grbit,
	const ULONG		ibLongValue,
	const ULONG		ulMax )
//  ================================================================
	{
	ERR			err;
	DATA		dataRetrieved;

	//	save SetSeparateLV status, then strip off the flag
	const BOOL	fRequestSeparateLV		= ( grbit & JET_bitSetSeparateLV );
#ifdef INTRINSIC_LV
	const BOOL	fSetIntrinsicLV			= ( grbit & JET_bitSetIntrinsicLV );
#endif // INTRINSIC_LV	

	//	save SetRevertToDefaultValue, then strip off flag
	const BOOL	fRevertToDefault		= ( grbit & JET_bitSetRevertToDefaultValue );

	//	save SetSLVFromSLVInfo status, then strip off the flag
	const BOOL	fSetSLVInfo				= ( grbit & JET_bitSetSLVFromSLVInfo );
	BOOL		fModifyExistingSLV		= fFalse;

	//	stip off grbits no longer recognised by this function
	//	note: unique multivalues are checked in ErrFLDSetOneColumn()
	grbit &= ~( JET_bitSetSeparateLV
				| JET_bitSetUniqueMultiValues
				| JET_bitSetUniqueNormalizedMultiValues
				| JET_bitSetSLVFromSLVInfo
				| JET_bitSetRevertToDefaultValue 
#ifdef INTRINSIC_LV
				| JET_bitSetIntrinsicLV );
#else // !INTRINSIC_LV
				);
#endif // INTRINSIC_LV

	ASSERT_VALID( pfucb );
	Assert( !FAssertLVFUCB( pfucb ) );
	
	//	if we are setting size only, pv may be NULL with non-zero cb
#ifdef DEBUG
	const BOOL	fNullPvDataAllowed =
					( grbit == JET_bitSetSizeLV
					|| grbit == ( JET_bitSetSizeLV|JET_bitSetZeroLength ) );
	pdataField->AssertValid( fNullPvDataAllowed );
#endif

	Assert( 0 == grbit
			|| JET_bitSetAppendLV == grbit
			|| JET_bitSetOverwriteLV == grbit
			|| JET_bitSetSizeLV == grbit
			|| JET_bitSetZeroLength == grbit
			|| ( JET_bitSetSizeLV | JET_bitSetZeroLength ) == grbit
			|| ( JET_bitSetOverwriteLV | JET_bitSetSizeLV ) == grbit );

	AssertSz( pfucb->ppib->level > 0, "LV update attempted at level 0" );
	if ( 0 == pfucb->ppib->level )
		{
		err = ErrERRCheck( JET_errNotInTransaction );
		return err;
		}

	Assert( FCOLUMNIDTagged( columnid ) );
	FUCBSetColumnSet( pfucb, FidOfColumnid( columnid ) );

	CallR( ErrDIRBeginTransaction( pfucb->ppib, NO_GRBIT ) );
	
	//	sequence == 0 means that new field instance is to be set, otherwise retrieve the existing data
	BOOL	fModifyExistingSLong	= fFalse;
	BOOL	fNewInstance			= ( 0 == itagSequence );
	if ( !fNewInstance )
		{
		Call( ErrRECIRetrieveTaggedColumn(
					pfucb->u.pfcb,
					columnid,
					itagSequence,
					pfucb->dataWorkBuf,
					&dataRetrieved,
					grbitRetrieveColumnDDLNotLocked ) );
		Assert( wrnRECLongField != err );
		switch ( err )
			{
			case wrnRECSeparatedLV:
				FUCBSetUpdateSeparateLV( pfucb );
				fModifyExistingSLong = fTrue;
			case wrnRECIntrinsicLV:
				Assert( !fNewInstance );
				break;

			case wrnRECSeparatedSLV:
				FUCBSetUpdateSeparateLV( pfucb );
				fModifyExistingSLong = fTrue;
			case wrnRECIntrinsicSLV:
				fModifyExistingSLV = fTrue;
				Assert( !fNewInstance );
				break;

			default:
				Assert( JET_wrnColumnNull == err
					|| wrnRECUserDefinedDefault == err );
				Assert( 0 == dataRetrieved.Cb() );
				fNewInstance = fTrue;
			}
		}
		

	LVOP	lvop;
	Call( ErrLVOpFromGrbit(
				grbit,
				pdataField->Cb(),
				fNewInstance,
				ibLongValue,
				&lvop ) );

	if ( fModifyExistingSLong )
		{
		if ( lvopReplace == lvop
			|| lvopReplaceWithNull == lvop
			|| lvopReplaceWithZeroLength == lvop )
			{
			//	we will be replacing an existing SLong in its entirety,
			//	so must first deref existing SLong.  If WriteConflict,
			//	it means that someone is already replacing over this
			//	column, so just return the error.
			Assert( FFUCBUpdateSeparateLV( pfucb ) );
			LID		lidT	= LidOfSeparatedLV( dataRetrieved );
			Call( ErrRECAffectSeparateLV( pfucb, &lidT, fLVDereference ) );
			Assert( JET_wrnCopyLongValue != err );

			//	separated LV is being replaced entirely, so reset modify flag
			fModifyExistingSLong = fFalse;
			}
		}
		
	switch ( lvop )
		{
		case lvopNull:
			err = JET_errSuccess;
			goto Commit;

		case lvopInsertNull:
		case lvopReplaceWithNull:
			Assert( ( lvopInsertNull == lvop && fNewInstance )
				|| ( lvopReplaceWithNull == lvop && !fNewInstance ) );
			Assert( !fModifyExistingSLong );
			Call( ErrRECSetColumn(
						pfucb,
						columnid,
						itagSequence,
						NULL,
						( fRevertToDefault ? JET_bitSetRevertToDefaultValue : NO_GRBIT ) ) );
			goto Commit;

		case lvopInsertZeroLength:
		case lvopReplaceWithZeroLength:
			{
			Assert( ( lvopInsertZeroLength == lvop && fNewInstance )
				|| ( lvopReplaceWithZeroLength == lvop && !fNewInstance ) );
			Assert( !fModifyExistingSLong );

			DATA	dataT;
			dataT.SetPv( NULL );
			dataT.SetCb( 0 );
			Call( ErrRECSetColumn( pfucb, columnid, itagSequence, &dataT ) );
			goto Commit;
			}
			
		case lvopInsert:
		case lvopInsertZeroedOut:
		case lvopReplace:
			if ( lvopReplace == lvop )
				{
				Assert( !fNewInstance );
				ASSERT_VALID( &dataRetrieved );
				}
			else
				{
				Assert( fNewInstance );
				}
			Assert( !fModifyExistingSLong );
			dataRetrieved.Nullify();
			break;

		case lvopAppend:
		case lvopResize:
		case lvopOverwriteRange:
		case lvopOverwriteRangeAndResize:
			Assert( !fNewInstance );
			ASSERT_VALID( &dataRetrieved );
			break;

		default:
			Assert( fFalse );
			break;
		}

	// All null/zero-length cases should have been handled above.
	Assert( pdataField->Cb() > 0 );


	if ( fModifyExistingSLong )
		{
		Assert( lvopAppend == lvop
			|| lvopResize == lvop
			|| lvopOverwriteRange == lvop
			|| lvopOverwriteRangeAndResize == lvop );
			
		// Flag should have gotten set when column was retrieved above.
		Assert( FFUCBUpdateSeparateLV( pfucb ) );

		LID		lidT	= LidOfSeparatedLV( dataRetrieved );
		Call( ErrRECAOSeparateLV( pfucb, &lidT, pdataField, ibLongValue, ulMax, lvop ) );
		if ( JET_wrnCopyLongValue == err )
			{
			Call( ErrRECISetLid( pfucb, columnid, itagSequence, lidT ) );
			}
		}
	else
		{
		//	determine space requirements of operation to see if we can
		//	make the LV intrinsic
		//	note that long field flag is included in length thereby limiting
		//	intrinsic long field to cbLVIntrinsicMost - sizeof(BYTE)
		ULONG		cbIntrinsic			= pdataField->Cb();

		Assert( fNewInstance || dataRetrieved.Cb() <= cbLVIntrinsicMost );
		
		switch ( lvop )
			{
			case lvopInsert:
			case lvopInsertZeroedOut:
				Assert( dataRetrieved.FNull() );
			case lvopReplace:	//lint !e616
			case lvopResize:
				break;
				
			case lvopOverwriteRange:
				cbIntrinsic += ibLongValue;
				if ( dataRetrieved.Cb() > cbIntrinsic )
					cbIntrinsic = dataRetrieved.Cb();
				break;
				
			case lvopOverwriteRangeAndResize:
				cbIntrinsic += ibLongValue;
				break;

			case lvopAppend:
				cbIntrinsic += dataRetrieved.Cb();
				break;

			case lvopNull:
			case lvopInsertNull:
			case lvopInsertZeroLength:
			case lvopReplaceWithNull:
			case lvopReplaceWithZeroLength:
			default:
				Assert( fFalse );
				break;
			}

#ifdef INTRINSIC_LV
		if ( fSetIntrinsicLV )
			{
			if ( pdataField->Cb() <= cbLVIntrinsicMost )
				{
				Call ( ErrRECIBigGateToAOIntrinsicLV(
							pfucb,
							columnid,
							itagSequence,
							&dataRetrieved,
							pdataField,
							ibLongValue,
							lvop ) );
				}
			else
				{
				Call ( ErrERRCheck( JET_errRecordTooBig ) );
				}
			}
		//	burst if value is greater than cbLVIntrinsicMost, or if
		//	LV separation is requested and the value is sufficiently large.
		else
			{
			Assert( !fSetIntrinsicLV );
			BOOL	fForceSeparateLV = ( cbIntrinsic >= cbLVBurstMin
									|| ( fRequestSeparateLV && cbIntrinsic > sizeof(LID) ) );
		if ( !fForceSeparateLV )
			{
			err = ErrRECIRegularGateToAOIntrinsicLV(
						pfucb,
						columnid,
						itagSequence,
						&dataRetrieved,
						pdataField,
						ibLongValue,
						lvop );

			//	on RecordTooBig, try bursting to LV
			//	tree if value is sufficiently large
			if ( JET_errRecordTooBig == err
				&& cbIntrinsic > sizeof(LID) )
				{
				fForceSeparateLV = fTrue;
				err = JET_errSuccess;
				}
			else
				{
				Call( err );
				}
			}
			
#else // !INTRINSIC_LV		
		BOOL	fForceSeparateLV = ( cbIntrinsic > cbLVIntrinsicMost
									|| ( fRequestSeparateLV && cbIntrinsic > sizeof(LID) ) );
		if ( !fForceSeparateLV )
			{
			err = ErrRECAOIntrinsicLV(
						pfucb,
						columnid,
						itagSequence,
						&dataRetrieved,
						pdataField,
						ibLongValue,
						lvop );

			//	on RecordTooBig, try bursting to LV
			//	tree if value is sufficiently large
			if ( JET_errRecordTooBig == err
				&& cbIntrinsic > sizeof(LID) )
				{
				fForceSeparateLV = fTrue;
				err = JET_errSuccess;
				}
			else
				{
				Call( err );
				}
			}
			
#endif // INTRINSIC_LV
			
		if ( fForceSeparateLV )
			{
			LID		lidT;

			// Flag may not have gotten set if this is a new instance.
			FUCBSetUpdateSeparateLV( pfucb );

			Call( ErrRECSeparateLV( pfucb, &dataRetrieved, &lidT, NULL ) );
			Assert( JET_wrnCopyLongValue == err );
			Call( ErrRECAOSeparateLV( pfucb, &lidT, pdataField, ibLongValue, ulMax, lvop ) );
			Assert( JET_wrnCopyLongValue != err );
			Call( ErrRECISetLid( pfucb, columnid, itagSequence, lidT ) );
			}
#ifdef INTRINSIC_LV			
			}
#endif // INTRINSIC_LV		
		}

Commit:
	Call( ErrDIRCommitTransaction( pfucb->ppib, NO_GRBIT ) );
	return err;

HandleError:
	Assert( err < 0 );
	CallSx( ErrDIRRollback( pfucb->ppib ), JET_errRollbackError );
	return err;
	}


//  ================================================================
LOCAL ERR ErrRECIBurstSeparateLV( FUCB * pfucbTable, FUCB * pfucbSrc, LID * plid )
//  ================================================================
//
//  Makes a new copy of an existing long value. If we are sucessful pfucbSrc
//  will point to the root of the new long value. We cannot have two cursors
//  open on the table at the same time (deadlock if they try to get the same
//  page), so we use a temp buffer.
//
//  On return pfucbSrc points to the root of the new long value
//
//-
	{
	ASSERT_VALID( pfucbTable );
	Assert( !FAssertLVFUCB( pfucbTable ) );
	ASSERT_VALID( pfucbSrc );
	Assert( FAssertLVFUCB( pfucbSrc ) );
	Assert( NULL != plid );
	Assert( *plid > lidMin );

	ERR			err			= JET_errSuccess;
	FUCB  	 	*pfucbDest  = pfucbNil;
	LID			lid			= lidMin;
	ULONG  	 	ulOffset	= 0;
	LVROOT		lvroot;
	DATA  	 	data;
	VOID		*pvbf		= NULL;
	BOOL		fLatchedSrc	= fFalse;

	//	get long value length
	AssertLVRootNode( pfucbSrc, *plid );
	UtilMemCpy( &lvroot, pfucbSrc->kdfCurr.data.Pv(), sizeof(LVROOT) );	//lint !e603

	BFAlloc( &pvbf );
	data.SetPv( pvbf );

	//  if we have data in the LV copy it all

	if ( lvroot.ulSize > 0 )
		{
		//	move source cursor to first chunk. remember its length
		Call( ErrDIRDownLV( pfucbSrc, *plid, ulLVOffsetFirst, fDIRNull ) );

		//  assert that all chunks except the last are the full size
		Assert( ( g_cbColumnLVChunkMost == pfucbSrc->kdfCurr.data.Cb() ) ||
				( ulOffset + g_cbColumnLVChunkMost > lvroot.ulSize ) );

		ulOffset += pfucbSrc->kdfCurr.data.Cb();

		//	make separate long value root, and insert first chunk
		UtilMemCpy( pvbf, pfucbSrc->kdfCurr.data.Pv(), pfucbSrc->kdfCurr.data.Cb() );
		Assert( data.Pv() == pvbf );
		data.SetCb( pfucbSrc->kdfCurr.data.Cb() );
		CallS( ErrDIRRelease( pfucbSrc ) );
		Call( ErrRECSeparateLV( pfucbTable, &data, &lid, &pfucbDest ) );
		Assert( lid > lidMin );

		//  release one cursor, restore another
		DIRUp( pfucbDest );

		//	copy remaining chunks of long value.
		while ( ( err = ErrDIRNext( pfucbSrc, fDIRNull ) ) >= JET_errSuccess )
			{
			fLatchedSrc = fTrue;

			//  make sure we are still on the same long value
			Call( ErrLVCheckDataNodeOfLid( pfucbSrc, *plid ) );

			if ( JET_errSuccess == err )
				{
				if ( ulOffset >= lvroot.ulSize )
					{
					LVReportCorruptedLV( pfucbSrc, *plid );
					FireWall();

					//	LV is bigger than what the LVROOT thinks
					err = ErrERRCheck( JET_errLVCorrupted );
					goto HandleError;
					}
				}
			else
				{
				Assert( wrnLVNoMoreData == err );
				if ( ulOffset != lvroot.ulSize )
					{
					LVReportCorruptedLV( pfucbSrc, *plid );
					FireWall();

					//	reached the end of the LV, but size does not
					//	match what LVROOT thinks it is
					err = ErrERRCheck( JET_errLVCorrupted );
					goto HandleError;
					}
					
				Call( ErrDIRRelease( pfucbSrc ) );
				fLatchedSrc = fFalse;
				break;
				}

			Assert( ( g_cbColumnLVChunkMost == pfucbSrc->kdfCurr.data.Cb() ) ||
					( ulOffset + g_cbColumnLVChunkMost > lvroot.ulSize ) );
			Assert( ulOffset + pfucbSrc->kdfCurr.data.Cb() <= lvroot.ulSize );


			LVKEY	lvkey;
			KEY		key;
			key.prefix.Nullify();
			key.suffix.SetPv( &lvkey );
			key.suffix.SetCb( sizeof( LVKEY ) );

			//  cache the data and insert it into pfucbDest
			//  OPTIMIZATION:  if ulOffset > 1 page we can keep both cursors open
			//  and insert directly from one to the other
			Assert( ulOffset % g_cbColumnLVChunkMost == 0 );
			lvkey = LVKeyFromLidOffset( lid, ulOffset );
			UtilMemCpy( pvbf, pfucbSrc->kdfCurr.data.Pv(), pfucbSrc->kdfCurr.data.Cb() );
			Assert( data.Pv() == pvbf );
			data.SetCb( pfucbSrc->kdfCurr.data.Cb() ) ;

			// Determine offset of next chunk.
			ulOffset += pfucbSrc->kdfCurr.data.Cb();

			Call( ErrDIRRelease( pfucbSrc ) );
			fLatchedSrc = fFalse;
			
			Call( ErrDIRInsert( pfucbDest, key, data, fDIRBackToFather ) );			

			//  release one cursor, restore the other
			DIRUp( pfucbDest );
			}

		if ( JET_errNoCurrentRecord != err )
			{
			Call( err );
			}
		}
		
	Assert( ulOffset == lvroot.ulSize );
					  
	//	move cursor to new long value
	err = ErrDIRDownLV( pfucbSrc, lid, fDIRNull );
	if ( err < JET_errSuccess )
		{
		Assert( JET_errWriteConflict != err );
		goto HandleError;
		}
	CallS( err );
	
	//	update lvroot.ulSize to correct long value size.
	data.SetPv( &lvroot );
	data.SetCb( sizeof(LVROOT) );
	lvroot.ulReference = 1;
	Call( ErrDIRReplace( pfucbSrc, data, fDIRNull ) );
	Call( ErrDIRGet( pfucbSrc ) );		// Recache

	//	set warning and new long value id for return.
	err 	= ErrERRCheck( JET_wrnCopyLongValue );
	*plid 	= lid;

HandleError:
	if ( fLatchedSrc )
		{
		Assert( err < 0 );
		CallS( ErrDIRRelease( pfucbSrc ) );
		}
	if ( pfucbNil != pfucbDest )
		{
		DIRClose( pfucbDest );
		}

	// The first thing we do is allocate a temporary buffer, so
	// we should never get here without having a buffer to free.
	Assert( NULL != pvbf );
	BFFree( pvbf );

	return err;
	}


INLINE ERR ErrLVAppendChunks(
	FUCB		*pfucbLV,
	LID			lid,
	ULONG		ulSize,
	BYTE		*pbAppend,
	const ULONG	cbAppend )
	{
	ERR			err				= JET_errSuccess;
	LVKEY		lvkey;
	KEY			key;
	DATA		data;
	const BYTE	* const pbMax	= pbAppend + cbAppend;

	key.prefix.Nullify();
	key.suffix.SetPv( &lvkey );
	key.suffix.SetCb( sizeof( LVKEY ) );

	//	append remaining long value data
	while( pbAppend < pbMax )
		{
		Assert( ulSize % g_cbColumnLVChunkMost == 0 );
		lvkey = LVKeyFromLidOffset( lid, ulSize );
		
		Assert( key.prefix.FNull() );
		Assert( key.suffix.Pv() == &lvkey );
		Assert( key.suffix.Cb() == sizeof(LVKEY) );

		data.SetPv( pbAppend );
		data.SetCb( min( pbMax - pbAppend, g_cbColumnLVChunkMost ) );
		
 		CallR( ErrDIRInsert( pfucbLV, key, data, fDIRBackToFather ) );
	 		
		ulSize += data.Cb();

		Assert( pbAppend + data.Cb() <= pbMax );
		pbAppend += data.Cb();
		}

	return err;
	}

ERR ErrRECAppendLVChunks(
	FUCB		*pfucbLV,
	LID			lid,
	ULONG		ulSize,
	BYTE		*pbAppend,
	const ULONG	cbAppend )
	{
	// Current size a chunk multiple.
	Assert( ulSize % g_cbColumnLVChunkMost == 0 );
	
	return ErrLVAppendChunks( pfucbLV, lid, ulSize, pbAppend, cbAppend );
	}


LOCAL ERR ErrLVAppend(
	FUCB		*pfucbLV,
	LID			lid,
	ULONG		ulSize,
	const DATA	*pdataAppend,
	VOID		*pvbf )
	{
	ERR			err				= JET_errSuccess;
	BYTE		*pbAppend		= reinterpret_cast<BYTE *>( pdataAppend->Pv() );
	ULONG		cbAppend		= pdataAppend->Cb();

	if ( 0 == cbAppend )
		return JET_errSuccess;

	//  APPEND long value
	if ( ulSize > 0 )
		{
		const ULONG ulOffsetLast = ( ( ulSize - 1 ) / g_cbColumnLVChunkMost ) * g_cbColumnLVChunkMost;
		CallR( ErrDIRDownLV( pfucbLV, lid, ulOffsetLast, fDIRFavourPrev ) );
		
		const ULONG	cbUsedInChunk		= pfucbLV->kdfCurr.data.Cb();
		Assert( cbUsedInChunk <= g_cbColumnLVChunkMost );
		if ( cbUsedInChunk < g_cbColumnLVChunkMost )
			{
			DATA		data;
			const ULONG	cbAppendToChunk	= min( cbAppend, g_cbColumnLVChunkMost - cbUsedInChunk );
			
			UtilMemCpy( pvbf, pfucbLV->kdfCurr.data.Pv(), cbUsedInChunk );
			UtilMemCpy( (BYTE *)pvbf + cbUsedInChunk, pbAppend, cbAppendToChunk );
			
			pbAppend += cbAppendToChunk;
			cbAppend -= cbAppendToChunk;
			ulSize += cbAppendToChunk;

			Assert( cbUsedInChunk + cbAppendToChunk <= g_cbColumnLVChunkMost );

			data.SetPv( pvbf );
			data.SetCb( cbUsedInChunk + cbAppendToChunk );
 			CallR( ErrDIRReplace( pfucbLV, data, fDIRNull ) );
			}
		}
	else
		{
		Assert( 0 == ulSize );
	
		//  the LV is size 0 and has a root only
		CallR( ErrDIRDownLV( pfucbLV, lid, fDIRNull ) );
		}
		
	if ( cbAppend > 0 )
		{
		Assert( ulSize % g_cbColumnLVChunkMost == 0 );
		DIRUp( pfucbLV );
		CallR( ErrLVAppendChunks( pfucbLV, lid, ulSize, pbAppend, cbAppend ) );
		}

	return err;
	}
	

LOCAL ERR ErrLVAppendZeroedOutChunks(
	FUCB		*pfucbLV,
	LID			lid,
	ULONG		ulSize,
	ULONG		cbAppend,
	VOID		*pvbf )
	{
	ERR			err		= JET_errSuccess;
	LVKEY		lvkey;
	KEY			key;
	DATA		data;

	DIRUp( pfucbLV );

	memset( pvbf, 0, g_cbColumnLVChunkMost );
	
	key.prefix.Nullify();
	key.suffix.SetPv( &lvkey );
	key.suffix.SetCb( sizeof( LVKEY ) );

	Assert( NULL != pvbf );
	data.SetPv( pvbf );
	
	//	append remaining long value data
	while( cbAppend > 0 )
		{
		Assert( ulSize % g_cbColumnLVChunkMost == 0 );
		lvkey = LVKeyFromLidOffset( lid, ulSize );
		
		Assert( key.prefix.FNull() );
		Assert( key.suffix.Pv() == &lvkey );
		Assert( key.suffix.Cb() == sizeof(LVKEY) );

		Assert( data.Pv() == pvbf );
		data.SetCb( min( cbAppend, g_cbColumnLVChunkMost ) );
		
 		CallR( ErrDIRInsert( pfucbLV, key, data, fDIRBackToFather ) );
	 		
		ulSize += data.Cb();

		Assert( cbAppend >= data.Cb() );
		cbAppend -= data.Cb();
		}

	return err;
	}
	

LOCAL ERR ErrLVTruncate(
	FUCB		*pfucbLV,
	LID			lid,
	const ULONG	ulTruncatedSize,
	VOID		*pvbf )
	{
	ERR			err;
	const ULONG	ulOffset = ulTruncatedSize;
	ULONG		ulOffsetChunk;
	DATA		data;
	
	//	seek to offset to begin deleting
	CallR( ErrDIRDownLV( pfucbLV, lid, ulOffset, fDIRNull ) );
	
	//	get offset of last byte in current chunk
	//	replace current chunk with remaining data, or delete if
	//	no remaining data.
	OffsetFromKey( &ulOffsetChunk, pfucbLV->kdfCurr.key );
	Assert( ulOffset >= ulOffsetChunk );
	data.SetCb( ulOffset - ulOffsetChunk );
	if ( data.Cb() > 0 )
		{
		data.SetPv( pvbf );
		UtilMemCpy( data.Pv(), pfucbLV->kdfCurr.data.Pv(), data.Cb() );
		CallR( ErrDIRReplace( pfucbLV, data, fDIRLogChunkDiffs ) );
		}
	else
		{
		CallR( ErrDIRDelete( pfucbLV, fDIRNull ) );
		}

	//	delete forward chunks
	while ( ( err = ErrDIRNext( pfucbLV, fDIRNull ) ) >= JET_errSuccess )
		{
		//  make sure we are still on the same long value
		err = ErrLVCheckDataNodeOfLid( pfucbLV, lid );
		if ( JET_errSuccess != err )
			{
			CallS( ErrDIRRelease( pfucbLV ) );
			return ( wrnLVNoMoreData == err ? JET_errSuccess : err );
			}
			
		CallR( ErrDIRDelete( pfucbLV, fDIRNull ) );
		}

	if ( JET_errNoCurrentRecord == err )
		{
		err = JET_errSuccess;
		}

	return err;
	}


INLINE ERR ErrLVOverwriteRange(
	FUCB		*pfucbLV,
	LID			lid,
	ULONG		ibLongValue,
	const DATA	*pdataField,
	VOID		*pvbf )
	{
	ERR			err;
	ULONG		cbChunk;		//  the size of the current chunk
	ULONG		ibChunk;		//  the index of the current chunk
	DATA		data;
	BYTE		*pb				= reinterpret_cast< BYTE *>( pdataField->Pv() );
	const BYTE	* const pbMax	= pb + pdataField->Cb();

	//	OVERWRITE long value. seek to offset to begin overwritting
	CallR( ErrDIRDownLV( pfucbLV, lid, ibLongValue, fDIRNull ) );

#ifdef DEBUG
	ULONG	cPartialChunkOverwrite	= 0;
#endif	

	//	overwrite portions of and complete chunks to effect overwrite
	for ( ; ; )
		{
		//	get size and offset of current chunk.
		cbChunk = pfucbLV->kdfCurr.data.Cb();
		OffsetFromKey( &ibChunk, pfucbLV->kdfCurr.key );
		Assert( ibLongValue >= ibChunk );
		Assert( ibLongValue < ibChunk + cbChunk );
		
		const ULONG	ib	= ibLongValue - ibChunk;
		const ULONG	cb	= (ULONG)min( cbChunk - ib, pbMax - pb );

		Assert( ib < cbChunk );
		Assert( cb <= cbChunk );

		//	special case overwrite of whole chunk
		if ( cb == cbChunk )
			{
			// Start overwriting at the beginning of a chunk.
			Assert( ibLongValue == ibChunk );
			data.SetCb( cb );
			data.SetPv( pb );
			}
		else
			{
#ifdef DEBUG
			// Should only do partial chunks for the first and last chunks.
			cPartialChunkOverwrite++;
			Assert( cPartialChunkOverwrite <= 2 );
#endif
			UtilMemCpy( pvbf, pfucbLV->kdfCurr.data.Pv(), cbChunk );
			UtilMemCpy( reinterpret_cast<BYTE *>( pvbf ) + ib, pb, cb );
			data.SetCb( cbChunk );
			data.SetPv( pvbf );
			}
		CallR( ErrDIRReplace( pfucbLV, data, fDIRLogChunkDiffs ) );
		
		pb += cb;
		ibLongValue += cb;

		//  we mey have written the entire long value
		Assert( pb <= pbMax );
		if ( pbMax == pb )
			{
			return JET_errSuccess;
			}

		//  goto the next chunk
		err = ErrDIRNext( pfucbLV, fDIRNull );
		if ( err < 0 )
			{
			if ( JET_errNoCurrentRecord == err )
				break;
			else
				return err;
			}

		//  make sure we are still on the same long value
		err = ErrLVCheckDataNodeOfLid( pfucbLV, lid );
		if ( err < 0 )
			{
			CallS( ErrDIRRelease( pfucbLV ) );
			return err;
			}
		else if ( wrnLVNoMoreData == err )
			{
			break;
			}

		//	All overwrites beyond the first should happen at the beginning
		//	of a chunk.
		Assert( ibLongValue % g_cbColumnLVChunkMost == 0 );
		}

	// If we got here, we ran out of stuff to overwrite before we ran out
	// of new data.  Append the new data.
	Assert( pb < pbMax );
	data.SetPv( pb );
	data.SetCb( pbMax - pb );
	err = ErrLVAppend(
				pfucbLV,
				lid,
				ibLongValue,
				&data,
				pvbf );

	return err;
	}

						
//  ================================================================
ERR ErrRECFSetLV(
	FUCB		*pfucb,
	LID			lid,
	BOOL		*pfSetLV )
//  ================================================================
//
//	Returns fTrue in *pfSetLV is this transaction has updated LV.  This function is called by
//	index update logic that optimizes updates to tuple indecies.
//-
	{
	ASSERT_VALID( pfucb );
	Assert( pfucb->ppib->level > 0 );

	ERR			err				= JET_errSuccess;
	FUCB	   	*pfucbLV		= pfucbNil;

	//	open cursor on LONG directory
	//	seek to this field instance
	//
	CallR( ErrDIROpenLongRoot( pfucb ) );
	Assert( wrnLVNoLongValues != err );
	pfucbLV = pfucb->pfucbLV;
	Assert( pfucbNil != pfucbLV );
	Assert( FFUCBLongValue( pfucbLV ) );

	//	move to start of long field instance
	//
	Call( ErrDIRDownLV( pfucbLV, lid, fDIRNull ) );

	//	set *pfSetLV is node replaced, updated, by this transaction
	//
	Call( ErrDIRFReplace( pfucbLV, pfSetLV ) );

HandleError:
	Assert( pfucbNil != pfucbLV );
	DIRCloseLongRoot( pfucb );
	return err;
	}


//  ================================================================
ERR ErrRECAOSeparateLV(
	FUCB		*pfucb,
	LID			*plid,
	const DATA	*pdataField,
	const ULONG	ibLongValue,
	const ULONG	ulMax,
	const LVOP	lvop )
//  ================================================================
//
//	Appends, overwrites and sets length of separate long value data.
//
//-
	{
	ASSERT_VALID( pfucb );
	Assert( plid );
	Assert( pfucb->ppib->level > 0 );

	// Null and zero-length are handled by RECSetLongField
	Assert( lvopInsert == lvop
			|| lvopInsertZeroedOut == lvop
			|| lvopReplace == lvop
			|| lvopAppend == lvop
			|| lvopResize == lvop
			|| lvopOverwriteRange == lvop
			|| lvopOverwriteRangeAndResize == lvop );

#ifdef DEBUG
	//	if we are setting size, pv may be NULL with non-zero cb
	pdataField->AssertValid( lvopInsertZeroedOut == lvop || lvopResize == lvop );
#endif	//	DEBUG

	// NULL and zero-length cases are handled by ErrRECSetLongField().
	Assert( pdataField->Cb() > 0 );

	ERR			err				= JET_errSuccess;
	ERR			wrn				= JET_errSuccess;
	FUCB	   	*pfucbLV		= pfucbNil;
	VOID		*pvbf			= NULL;
	LVROOT		lvroot;
	DATA	   	data;
	data.SetCb( sizeof(LVROOT) );
	data.SetPv( &lvroot );
	ULONG		ulVerRefcount;
	LID			lidCurr			= *plid;

	//	open cursor on LONG directory
	//	seek to this field instance
	//	find current field size
	//	add new field segment in chunks no larger than max chunk size
	CallR( ErrDIROpenLongRoot( pfucb ) );
	Assert( wrnLVNoLongValues != err );

	pfucbLV = pfucb->pfucbLV;
	Assert( pfucbNil != pfucbLV );
	Assert( FFUCBLongValue( pfucbLV ) );

	//	move to start of long field instance
	Call( ErrDIRDownLV( pfucbLV, *plid, fDIRNull ) );
	UtilMemCpy( &lvroot, pfucbLV->kdfCurr.data.Pv(), sizeof(LVROOT) );
	
	ulVerRefcount = UlLVIVersionedRefcount( pfucbLV );
	Assert( ulVerRefcount > 0 );	// versioned refcount must be non-zero, otherwise we couldn't see it

	//	get offset of last byte from long value size
	ULONG		ulSize;
	ULONG	   	ulNewSize;
#ifdef DEBUG
	ULONG		ulRefcountDBG;
	ulRefcountDBG	= lvroot.ulReference;
#endif	
	ulSize			= lvroot.ulSize;

	if ( ibLongValue > ulSize
		&& ( lvopOverwriteRange == lvop || lvopOverwriteRangeAndResize == lvop ) )
		{
		err = ErrERRCheck( JET_errColumnNoChunk );
		goto HandleError;
		}
	
	//  if we have more than one reference we have to burst the long value
	if ( ulVerRefcount > 1 )
		{
		Assert( *plid == lidCurr );
		Call( ErrRECIBurstSeparateLV( pfucb, pfucbLV, plid ) );	// lid will change
		Assert( JET_wrnCopyLongValue == err );
		Assert( *plid > lidCurr );
 		wrn = err;
		AssertLVRootNode( pfucbLV, *plid );
		UtilMemCpy( &lvroot, pfucbLV->kdfCurr.data.Pv(), sizeof(LVROOT) );
		Assert( 1 == lvroot.ulReference );
		}

	Assert( ulSize == lvroot.ulSize );

	switch ( lvop )
		{
		case lvopInsert:
		case lvopInsertZeroedOut:
		case lvopReplace:
			Assert( 0 == ulSize );		// replace = delete old + insert new (thus, new LV currently has size 0)
		case lvopResize:
			ulNewSize = pdataField->Cb();
			break;
			
		case lvopOverwriteRange:
			ulNewSize = max( ibLongValue + pdataField->Cb(), ulSize );
			break;
		
		case lvopOverwriteRangeAndResize:
			ulNewSize = ibLongValue + pdataField->Cb();
			break;
			
		case lvopAppend:
			ulNewSize = ulSize + pdataField->Cb();
			break;

		case lvopNull:
		case lvopInsertNull:
		case lvopInsertZeroLength:
		case lvopReplaceWithNull:
		case lvopReplaceWithZeroLength:
		default:
			Assert( fFalse );
			break;
		}
		
	//	check for field too long
	if ( ( ulMax > 0 && ulNewSize > ulMax ) || ulNewSize > LONG_MAX )
		{
		err = ErrERRCheck( JET_errColumnTooBig );
		goto HandleError;
		}

	//	force refcount to 1, because after a successful replace, that's
	//	what the refcount should be -- anything else will cause a conflict
	lvroot.ulReference = 1;
	
	//	replace long value size with new size (even if the size didn't change).
	//	this also 'locks' the long value for us
	lvroot.ulSize = ulNewSize;
	Assert( sizeof(LVROOT) == data.Cb() );
	Assert( &lvroot == data.Pv() );
	err = ErrDIRReplace( pfucbLV, data, fDIRNull );
	if ( err < 0 )
		{
		if ( JET_errWriteConflict != err )
			goto HandleError;

		//  write conflict means someone else was modifying/deltaing
		//  the long value

		//	if ulVerRefcount was greater than 1, we would have burst
		//	and thus should not have write-conflicted
		Assert( 1 == ulVerRefcount );

		//  we lost the page during the write conflict
		Call( ErrDIRGet( pfucbLV ) );

		if ( FDIRDeltaActiveNotByMe( pfucbLV, OffsetOf( LVROOT, ulReference ) ) )
			{
			//  we lost our latch and someone else entered the page and did a delta
			//  this should only happen if we didn't burst above
			Assert( JET_wrnCopyLongValue != wrn );
			Assert( *plid == lidCurr );
			Call( ErrRECIBurstSeparateLV( pfucb, pfucbLV, plid ) );	// lid will change
			Assert( JET_wrnCopyLongValue == err );
			Assert( *plid > lidCurr );
			wrn = err;
			AssertLVRootNode( pfucbLV, *plid );
			UtilMemCpy( &lvroot, pfucbLV->kdfCurr.data.Pv(), sizeof(LVROOT) );
			Assert( 1 == lvroot.ulReference );
			lvroot.ulSize = ulNewSize;
			Assert( sizeof(LVROOT) == data.Cb() );
			Assert( &lvroot == data.Pv() );
			Call( ErrDIRReplace( pfucbLV, data, fDIRNull ) );
			
			//	if deref write-conflicts, it means someone else is
			//	already updating this record
			Assert( !Pcsr( pfucb )->FLatched() );
			Call( ErrRECAffectSeparateLV( pfucb, &lidCurr, fLVDereference ) );
			Assert( JET_wrnCopyLongValue != err );
			}
		else
			{
			// Another thread doing replace or delete on same LV.
			CallS( ErrDIRRelease( pfucbLV ) );
			err = ErrERRCheck( JET_errWriteConflict );
			goto HandleError;
			}
		}
	else if ( ulVerRefcount > 1 )
		{
		//	bursting was successful - update refcount on original LV.
		//	if this deref subsequently write-conflicts, it means
		//	someone else is already updating this record.
		Assert( !Pcsr( pfucb )->FLatched() );
		Call( ErrRECAffectSeparateLV( pfucb, &lidCurr, fLVDereference ) );
		Assert( JET_wrnCopyLongValue != err );
		}

	Assert( 1 == lvroot.ulReference );

	//	allocate buffer for partial overwrite caching.
	Assert( NULL == pvbf );
	BFAlloc( &pvbf );
	
	switch( lvop )
		{
		case lvopInsert:
		case lvopReplace:
			Assert( 0 == ulSize );
			DIRUp( pfucbLV );
			Call( ErrLVAppendChunks(
						pfucbLV,
						*plid,
						0,
						reinterpret_cast<BYTE *>( pdataField->Pv() ),
						pdataField->Cb() ) );
			break;

		case lvopResize:
			//	TRUNCATE long value
			if ( ulNewSize < ulSize )
				{
				Call( ErrLVTruncate( pfucbLV, *plid, ulNewSize, pvbf ) );
				}
			else if ( ulNewSize > ulSize )
				{
				if ( ulSize > 0 )
					{
					//	EXTEND long value with chunks of 0s
					
					//  seek to the maximum offset to get the last chunk
					//	long value chunk tree may be empty
					const ULONG ulOffsetLast = ( ( ulSize - 1 ) / g_cbColumnLVChunkMost ) * g_cbColumnLVChunkMost;
					Call( ErrDIRDownLV( pfucbLV, *plid, ulOffsetLast, fDIRFavourPrev ) );
					AssertLVDataNode( pfucbLV, *plid, ulOffsetLast );

					const ULONG	cbUsedInChunk		= pfucbLV->kdfCurr.data.Cb();
					Assert( cbUsedInChunk <= g_cbColumnLVChunkMost );
					if ( cbUsedInChunk < g_cbColumnLVChunkMost )
						{
						const ULONG	cbAppendToChunk	= min(
														ulNewSize - ulSize,
														g_cbColumnLVChunkMost - cbUsedInChunk );
						
						UtilMemCpy( pvbf, pfucbLV->kdfCurr.data.Pv(), cbUsedInChunk );
						memset( (BYTE *)pvbf + cbUsedInChunk, 0, cbAppendToChunk );
			
						ulSize += cbAppendToChunk;

						Assert( cbUsedInChunk + cbAppendToChunk <= g_cbColumnLVChunkMost );
						
						data.SetPv( pvbf );
						data.SetCb( cbUsedInChunk + cbAppendToChunk );
						Call( ErrDIRReplace( pfucbLV, data, fDIRLogChunkDiffs ) );
						}
					else
						{
						Assert( ulSize % g_cbColumnLVChunkMost == 0 );
						}

					Assert( ulSize <= ulNewSize );
					}

				else
					{
					Call( ErrDIRDownLV( pfucbLV, *plid, fDIRNull ) );

					//  the LV is size 0 and has a root only. we have landed on the root
					AssertLVRootNode( pfucbLV, *plid );

					//	we will be appending zerout-out chunks to this LV
					Assert( ulSize < ulNewSize );
					}

				if ( ulSize < ulNewSize )
					{
					Assert( ulSize % g_cbColumnLVChunkMost == 0 );
					Call( ErrLVAppendZeroedOutChunks(
							pfucbLV,
							*plid,
							ulSize,
							ulNewSize - ulSize,
							pvbf ) );
					}
				}
			else
				{
				// no size change required
				err = JET_errSuccess;
				}
			break;

		case lvopInsertZeroedOut:
			Assert( 0 == ulSize );
			Call( ErrLVAppendZeroedOutChunks(
						pfucbLV,
						*plid,
						ulSize,
						pdataField->Cb(),
						pvbf ) );
			break;

		case lvopAppend:
			Call( ErrLVAppend(
						pfucbLV,
						*plid,
						ulSize,
						pdataField,
						pvbf ) );
			break;

		case lvopOverwriteRangeAndResize:
			if ( ulNewSize < ulSize )
				{
				Call( ErrLVTruncate( pfucbLV, *plid, ulNewSize, pvbf ) );
				}
			//	Fall through to do the actual overwrite:
			
		case lvopOverwriteRange:
			if ( 0 == ulSize )
				{
				//	may hit this case if we're overwriting a zero-length column
				//	that was force-separated
				Assert( 0 == ibLongValue );
				DIRUp( pfucbLV );
				Call( ErrLVAppendChunks(
							pfucbLV,
							*plid,
							0,
							reinterpret_cast<BYTE *>( pdataField->Pv() ),
							pdataField->Cb() ) );
				}
			else if ( ibLongValue == ulSize )
				{
				//	pathological case of overwrite starting exactly at the point where
				//	the LV ends - this degenerates to an append
				Call( ErrLVAppend(
							pfucbLV,
							*plid,
							ulSize,
							pdataField,
							pvbf ) );
				}
			else
				{
				Call( ErrLVOverwriteRange(
							pfucbLV,
							*plid,
							ibLongValue,
							pdataField,
							pvbf ) );
				}
			break;

		case lvopNull:
		case lvopInsertNull:
		case lvopInsertZeroLength:
		case lvopReplaceWithNull:
		case lvopReplaceWithZeroLength:
		default:
			Assert( fFalse );
			break;
		}


#ifdef DEBUG
	{
		//	move to start of long field instance
		Call( ErrDIRDownLV( pfucbLV, *plid, fDIRNull ) );
		UtilMemCpy( &lvroot, pfucbLV->kdfCurr.data.Pv(), sizeof(LVROOT) );
		Assert( lvroot.ulSize == ulNewSize );
		Assert( ulNewSize > 0 );

		ULONG ulOffsetLastT;
		ulOffsetLastT = ( ( ulNewSize - 1 ) / g_cbColumnLVChunkMost ) * g_cbColumnLVChunkMost;
		Call( ErrDIRDownLV( pfucbLV, *plid, ulOffsetLastT, fDIRFavourPrev ) );

		ULONG ulOffsetT;
		OffsetFromKey( &ulOffsetT, pfucbLV->kdfCurr.key );
		Assert( ulOffsetLastT == ulOffsetT );

		LID		lidT;
		LidFromKey( &lidT, pfucbLV->kdfCurr.key );
		Assert( *plid == lidT );

		ULONG	ibChunk;
		OffsetFromKey( &ibChunk, pfucbLV->kdfCurr.key );

		Assert( ulNewSize == ibChunk + pfucbLV->kdfCurr.data.Cb() );

		err = ErrDIRNext( pfucbLV, fDIRNull );
		if( JET_errNoCurrentRecord == err )
			{
			err = JET_errSuccess;
			}
		else if ( err < 0 )
			{
			goto HandleError;
			}
		else
			{
			LidFromKey( &lidT, pfucbLV->kdfCurr.key );
			Assert( *plid != lidT );
			}
	}
#endif


HandleError:
	if ( NULL != pvbf )
		{
		BFFree( pvbf );
		}

	Assert( pfucbNil != pfucbLV );
	DIRCloseLongRoot( pfucb );

	//	return warning if no failure	
	err = ( err < JET_errSuccess ) ? err : wrn;
	return err;
	}


//  ================================================================
ERR ErrRECAOIntrinsicLV(
	FUCB			*pfucb,
	const COLUMNID	columnid,
	const ULONG		itagSequence,
	const DATA		*pdataColumn,
	const DATA		*pdataNew,
	const ULONG		ibLongValue,
	const LVOP		lvop
#ifdef INTRINSIC_LV
	, BYTE 			*rgb 
#endif // INTRINSIC_LV
	)
//  ================================================================
	{
	ASSERT_VALID( pdataColumn );

//	Can't perform this check on the FUCB, because it may be a fake FUCB used
//	solely as a placeholder while building the default record.	
///	ASSERT_VALID( pfucb );

	Assert( pdataNew->Cb() > 0 );
	Assert( pdataNew->Cb() <= cbLVIntrinsicMost );
#ifdef INTRINSIC_LV
	Assert( rgb != NULL );
#else // INTRINSIC_LV
	BYTE		rgb[ cbLVIntrinsicMost ];
#endif // INTRINSIC_LV	
	DATA 		dataSet;

	dataSet.SetPv( rgb );

	
	switch ( lvop )
		{
		case lvopInsert:
		case lvopReplace:
			Assert( pdataColumn->FNull() );
			
			UtilMemCpy( rgb, pdataNew->Pv(), pdataNew->Cb() );
			dataSet.SetCb( pdataNew->Cb() );
			break;
			
		case lvopInsertZeroedOut:
			Assert( pdataColumn->FNull() );

			memset( rgb, 0, pdataNew->Cb() );
			dataSet.SetCb( pdataNew->Cb() );
			break;

		case lvopResize:
			Assert( pdataColumn->Cb() <= cbLVIntrinsicMost );
			UtilMemCpy(
				rgb,
				pdataColumn->Pv(),
				min( pdataNew->Cb(), pdataColumn->Cb() ) );
			if ( pdataNew->Cb() > pdataColumn->Cb() )
				{
				memset(
					rgb + pdataColumn->Cb(),
					0,
					pdataNew->Cb() - pdataColumn->Cb() );
				}
			dataSet.SetCb( pdataNew->Cb() );
			break;

		case lvopOverwriteRange:
		case lvopOverwriteRangeAndResize:
			Assert( pdataColumn->Cb() <= cbLVIntrinsicMost );
			if ( ibLongValue > pdataColumn->Cb() )
				{
				return ErrERRCheck( JET_errColumnNoChunk );
				}
			UtilMemCpy( rgb, pdataColumn->Pv(), pdataColumn->Cb() );
			UtilMemCpy(
				rgb + ibLongValue,
				pdataNew->Pv(),
				pdataNew->Cb() );
			if ( lvopOverwriteRange == lvop
				&& pdataColumn->Cb() > ibLongValue + pdataNew->Cb() )
				{
				dataSet.SetCb( pdataColumn->Cb() );
				}
			else
				{
				dataSet.SetCb( ibLongValue + pdataNew->Cb() );
				}
			break;			

		case lvopAppend:
			Assert( pdataColumn->Cb() <= cbLVIntrinsicMost );
			UtilMemCpy( rgb, pdataColumn->Pv(), pdataColumn->Cb() );
			UtilMemCpy( rgb + pdataColumn->Cb(), pdataNew->Pv(), pdataNew->Cb() );
			dataSet.SetCb( pdataColumn->Cb() + pdataNew->Cb() );
			break;

		case lvopNull:
		case lvopInsertNull:
		case lvopInsertZeroLength:
		case lvopReplaceWithNull:
		case lvopReplaceWithZeroLength:
		default:
			Assert( fFalse );
			break;
		}

	Assert( dataSet.Cb() <= cbLVIntrinsicMost );

	return ErrRECSetColumn( pfucb, columnid, itagSequence, &dataSet );
	}


//  ================================================================
LOCAL VOID LVIGetProperLVImageFromRCE(
	PIB			* const ppib,
	const FUCB 	* const pfucb,
	FUCB		* const pfucbLV,
	const BOOL	fAfterImage,
	const RCE	* const prceBase
	)
//  ================================================================
	{
	PIB			*ppibT;
	RCEID		rceidBegin;

	if ( prceBase->TrxCommitted() == trxMax )
		{
		Assert( ppibNil != prceBase->Pfucb()->ppib );
		ppibT = prceBase->Pfucb()->ppib;
		Assert( prceBase->TrxBegin0() == ppibT->trxBegin0 );
		}
	else
		{
		ppibT = ppibNil;
		}
	Assert( TrxCmp( prceBase->TrxBegin0(), prceBase->TrxCommitted() ) < 0 );
			
	if ( prceBase->FOperReplace() )
		{
		const VERREPLACE* pverreplace = reinterpret_cast<const VERREPLACE*>( prceBase->PbData() );
		rceidBegin = pverreplace->rceidBeginReplace;
		Assert( rceidNull == rceidBegin || rceidBegin < prceBase->Rceid() );
		}
	else
		{
		// If not a replace, force retrieval of after-image.
		rceidBegin = rceidNull;
		}
	
	const BYTE 	*pbImage	= NULL;
	ULONG		cbImage		= 0;

	BYTE		rgbKey[sizeof(LVKEY)];
	BOOKMARK	bookmark;
	
	pfucbLV->kdfCurr.key.CopyIntoBuffer( rgbKey, sizeof( rgbKey ) );
	bookmark.key.prefix.Nullify();
	bookmark.key.suffix.SetPv( rgbKey );
	bookmark.key.suffix.SetCb( pfucbLV->kdfCurr.key.Cb() );
	bookmark.data.Nullify();
	
	const BOOL fImage = FVERGetReplaceImage(
					ppibT,
					pfucbLV->u.pfcb->Ifmp(),
					pfucbLV->u.pfcb->PgnoFDP(),
					bookmark,
					rceidBegin,
					prceBase->Rceid(),
					prceBase->TrxBegin0(),
					prceBase->TrxCommitted(),
					fAfterImage,
					&pbImage,
					&cbImage
					);
	if( fImage )
		{
		pfucbLV->kdfCurr.data.SetPv( (BYTE *)pbImage );
		pfucbLV->kdfCurr.data.SetCb( cbImage );
		}
	}

//  ================================================================
LOCAL VOID LVIGetProperLVImageNoRCE(
	PIB			* const ppib,
	const FUCB 	* const pfucb,
	FUCB		* const pfucbLV
	)
//  ================================================================
	{
	Assert( FNDVersion( pfucbLV->kdfCurr ) );	//	no need to call if its not versioned
	
	const BYTE 	*pbImage	= NULL;
	ULONG		cbImage		= 0;

	BYTE		rgbKey[sizeof(LVKEY)];
	BOOKMARK	bookmark;
	
	pfucbLV->kdfCurr.key.CopyIntoBuffer( rgbKey, sizeof( rgbKey ) );
	bookmark.key.prefix.Nullify();
	bookmark.key.suffix.SetPv( rgbKey );
	bookmark.key.suffix.SetCb( pfucbLV->kdfCurr.key.Cb() );
	bookmark.data.Nullify();

	Assert( ppib->level > 0 );
	Assert( trxMax != ppib->trxBegin0 );
	
	const RCEID	rceidBegin	= ( FFUCBReplacePrepared( pfucb ) ?
									pfucb->rceidBeginUpdate :
									rceidNull );
	
	//	on a Replace, only way rceidBeginUpdate is not set is if versioning is off
	//	(otherwise, at the very least, we would have a Write-Lock RCE)
	Assert( rceidNull != rceidBegin
		|| !FFUCBReplacePrepared( pfucb )
		|| rgfmp[pfucb->ifmp].FVersioningOff() );

	const BOOL fImage = FVERGetReplaceImage(
					ppib,
					pfucbLV->u.pfcb->Ifmp(),
					pfucbLV->u.pfcb->PgnoFDP(),
					bookmark,
					rceidBegin,
					RCE::RceidLast()+1,
					ppib->trxBegin0,
					trxMax,
					fFalse,	//	always want the before-image
					&pbImage,
					&cbImage
					);
	if( fImage )
		{
		pfucbLV->kdfCurr.data.SetPv( (BYTE *)pbImage );
		pfucbLV->kdfCurr.data.SetCb( cbImage );
		}
	}


//  ================================================================
LOCAL VOID LVIGetProperLVImage(
	PIB			* const ppib,
	const FUCB 	* const pfucb,
	FUCB		* const pfucbLV,
	const BOOL	fAfterImage,
	const RCE	* const prceBase
	)
//  ================================================================
	{
	if( prceBase )
		{
		LVIGetProperLVImageFromRCE(
			ppib,
			pfucb,
			pfucbLV,
			fAfterImage,
			prceBase );
		}
	else
		{
		Assert( !fAfterImage );
		LVIGetProperLVImageNoRCE( ppib, pfucb, pfucbLV );
		}
	}


//  ================================================================
ERR ErrRECRetrieveSLongField(
	FUCB			*pfucb,
	LID				lid,
	BOOL			fAfterImage,
	ULONG			ibGraphic,
	BYTE			*pb,
	ULONG			cbMax,
	ULONG			*pcbActual,	//	pass NULL to force LV comparison instead of retrieval
	JET_PFNREALLOC	pfnRealloc,
	void*			pvReallocContext,
	const RCE		* const prceBase	//	used to retrieve older versions of the long-value
	)
//  ================================================================
//
//  opens cursor on LONG tree of table
//	seeks to given lid
//	copies LV from given ibGraphic into given buffer
//	must not use given FUCB to retrieve
//	also must release latches held on LONG tree and close cursor on LONG
//  pb call be null -- in that case we just retrieve the full size of the
//  long value
//
// If fAfterImage is FALSE:
//  We want to see what the long-value looked like before the insert/replace/delete
//  performed by this session. That means we have to adjust the nodes for the before
//  images of any replaces the session has done. This is used (for example) to determine
//  which index entries to delete when replacing a record with an indexed long-value.
//
// If fAfterImage is TRUE:
//  We want to see the LV as it is right now.
//
// If prceBase is not null:
//  We want to see the long-value as it was at the time of the given RCE. This is used
//  by concurrent create index. In order to process replaces properly both the before
//  and after images must be available, so the fAfterImage flag is used here as well.
//
//-
	{
	ASSERT_VALID( pfucb );
	Assert( pfucb->u.pfcb->Ptdb() != ptdbNil );
	AssertDIRNoLatch( pfucb->ppib );

	ERR			err				= JET_errSuccess;
	BOOL		fFreeBuffer		= fFalse;
	FUCB		*pfucbLV		= pfucbNil;
	BYTE		*pbMax;
	ULONG		cb;
	ULONG		ulActual;
	ULONG		ulOffset;
	ULONG		ib;
	BOOL		fInTransaction	= fFalse;

 	const BOOL		fComparing		= ( NULL == pcbActual );

	// if we are retrieving an older image, the actual chunks we want to see may have been flag deleted
	// (they won't have been removed by version store cleanup though). In order to see the flag-deleted
	// chunks we have to use fDIRAllNode

	//	BUG: this code doesn't deal with retrieving the before-image of an LV that has been shrunk. If
	//	the end chunks of the LV have been deleted we will not be able to see them. Passing in fDIRAllNode
	//	would allow this but breaks other things (we see the after-image of other transactions replaces).
	//	See NT:707609. This should only really affect tuple indexing
 	const DIRFLAG	dirflag			= ( prceBase ? fDIRAllNode : fDIRNull );

	//	begin transaction for read consistency
	if ( 0 == pfucb->ppib->level )
		{
		Call( ErrDIRBeginTransaction( pfucb->ppib, JET_bitTransactionReadOnly ) );
		fInTransaction = fTrue;
		}

	//	open cursor on LONG, seek to long field instance
	//	seek to ibGraphic
	//	copy data from long field instance segments as
	//	necessary
	Call( ErrDIROpenLongRoot( pfucb ) );
	Assert( wrnLVNoLongValues != err );

	pfucbLV = pfucb->pfucbLV;
	Assert( pfucbNil != pfucbLV );
	Assert( FFUCBLongValue( pfucbLV ) );

	if( ibGraphic < g_cbColumnLVChunkMost
		&& NULL != pb )
		{
		//  in a lot of cases the chunk we want may be on the next page. always preread the next page
		const CPG cpgPreread = 2;
		FUCBSetPrereadForward( pfucbLV, cpgPreread );
		}

	//	move to long field instance
	Call( ErrDIRDownLV( pfucbLV, lid, dirflag ) );
	if ( ( !fAfterImage && FNDPossiblyVersioned( pfucbLV, Pcsr( pfucbLV ) ) ) || prceBase )
		{
		LVIGetProperLVImage( pfucbLV->ppib, pfucb, pfucbLV, fAfterImage, prceBase );
		}
	
	ulActual = ( reinterpret_cast<LVROOT*>( pfucbLV->kdfCurr.data.Pv() )->ulSize );

	//	set return value cbActual
	if ( ibGraphic >= ulActual )
		{
		if ( NULL != pcbActual )
			*pcbActual = 0;

		if ( fComparing && 0 == cbMax )
			err = ErrERRCheck( JET_errMultiValuedDuplicate );	//	both are zero-length
		else
			err = JET_errSuccess;

		goto HandleError;
		}
	else
		{
		ulActual -= ibGraphic;

		if ( NULL != pcbActual )
			*pcbActual = ulActual;
		}

	if ( fComparing )
		{
		if ( ulActual != cbMax )
			{
			err = JET_errSuccess;		//	size is different, so LV must be different
			goto HandleError;
			}
		}
	else if ( NULL == pb )		//  special code to handle NULL buffer. just return the size
		{
		goto HandleError;
		}

	//  if we are using the pfnRealloc hack to read up to cbMax bytes of the LV
	//  then grab a buffer large enough to store the data to return and place
	//  a pointer to that buffer in the output buffer.  we will then rewrite
	//  the args to look like a normal LV retrieval
	//
	//  NOTE:  on an error, the allocated memory will NOT be freed

	if ( pfnRealloc )
		{
		Alloc( *((BYTE**)pb) = (BYTE*)pfnRealloc( pvReallocContext, NULL, min( cbMax, ulActual ) ) );
		fFreeBuffer	= fTrue;					//  free pb on an error
		pb			= *((BYTE**)pb);  			//  redirect pv to the new buffer
		cbMax		= min( cbMax, ulActual );	//  fixup cbMax to be the size of the new buffer
		}

	//  try and preread all of the pages that we will need. remember to preread a page with 
	//  a partial chunk at the end
	CPG 	cpgPreread;
	ULONG	ibOffset;
	BOOL 	fPreread;
	ULONG	cbPreread;
	ibOffset	= ( ibGraphic / g_cbColumnLVChunkMost ) *  g_cbColumnLVChunkMost;
	cbPreread	= min( cbMax, ulActual - ibOffset );
	cpgPreread 	= ( cbPreread + g_cbColumnLVChunkMost - 1 ) / g_cbColumnLVChunkMost;

	if( cpgPreread > 2 || 0 != ibGraphic )
		{
		if( cpgPreread > 256 )
			{
			//  this is a _really_ long-value. set the FUCB to sequential
			FUCBSetSequential( pfucbLV );
			}
		FUCBSetPrereadForward( pfucbLV, cpgPreread );
		fPreread = fTrue;
		}
	else
		{
		FUCBResetPreread( pfucbLV );
		fPreread = fFalse;
		}

	//	move to ibGraphic in long field
	if( ibGraphic < g_cbColumnLVChunkMost
		&& !fPreread )
		{
		//  the chunk we want is offset 0, which is the next chunk. do a DIRNext to avoid the seek
		Call( ErrDIRNext( pfucbLV, dirflag ) );
		if ( ( !fAfterImage && FNDPossiblyVersioned( pfucbLV, Pcsr( pfucbLV ) ) ) || prceBase )
			{
			LVIGetProperLVImage( pfucbLV->ppib, pfucb, pfucbLV, fAfterImage, prceBase );
			}

		Call( ErrLVCheckDataNodeOfLid( pfucbLV, lid ) );
		OffsetFromKey( &ulOffset, pfucbLV->kdfCurr.key );
		if( 0 != ulOffset )
			{
			LVReportCorruptedLV( pfucbLV, lid );
			FireWall();
			Call( ErrERRCheck( JET_errLVCorrupted ) );
			}
		}
	else
		{
		Call( ErrDIRDownLV( pfucbLV, lid, ibGraphic, dirflag ) );
		if ( ( !fAfterImage && FNDPossiblyVersioned( pfucbLV, Pcsr( pfucbLV ) ) ) || prceBase )
			{
			LVIGetProperLVImage( pfucbLV->ppib, pfucb, pfucbLV, fAfterImage, prceBase );
			}
		}
	Assert( sizeof(LVKEY) == pfucbLV->kdfCurr.key.Cb() );
	OffsetFromKey( &ulOffset, pfucbLV->kdfCurr.key );
	Assert( ulOffset + pfucbLV->kdfCurr.data.Cb() - ibGraphic <= g_cbColumnLVChunkMost );
	cb = min( ulOffset + pfucbLV->kdfCurr.data.Cb() - ibGraphic, cbMax );
	
	//	set pbMax to the largest pointer that we can read
	pbMax = pb + min( ulActual, cbMax );

	//	offset in chunk
	ib = ibGraphic - ulOffset;

	if ( fComparing )
		{
		if ( 0 != memcmp( pb, reinterpret_cast<BYTE *>( pfucbLV->kdfCurr.data.Pv() ) + ib, cb ) )
			{
			err = JET_errSuccess;			//	diff found
			goto HandleError;
			}
		}
	else
		{
		UtilMemCpy( pb, reinterpret_cast<BYTE *>( pfucbLV->kdfCurr.data.Pv() ) + ib, cb );
		}
	pb += cb;

	//	copy further chunks
	while ( pb < pbMax )
		{
		err = ErrDIRNext( pfucbLV, dirflag );
		if ( ( !fAfterImage && FNDPossiblyVersioned( pfucbLV, Pcsr( pfucbLV ) ) ) || prceBase )
			{
			LVIGetProperLVImage( pfucbLV->ppib, pfucb, pfucbLV, fAfterImage, prceBase );
			}

		//	It can only failed when resource failed.
#ifdef DEBUG		
		// something like CallSx( err , "JET_errDiskIO && JET_errOutOfMemory" );
		if ( JET_errDiskIO != err && JET_errOutOfMemory != err )
			{
			CallS( err );
			}
#endif // DEBUG		

		Call( err );

		//  make sure we are still on the same long value
		Call( ErrLVCheckDataNodeOfLid( pfucbLV, lid ) );
		if ( wrnLVNoMoreData == err )
			{
			break;
			}

		cb = (ULONG)min( pfucbLV->kdfCurr.data.Cb(), pbMax - pb );
		Assert( cb <= g_cbColumnLVChunkMost );
		
		if ( fComparing )
			{
			if ( 0 != memcmp( pb, pfucbLV->kdfCurr.data.Pv(), cb ) )
				{
				err = JET_errSuccess;		//	diff found
				goto HandleError;
				}
			}
		else
			{
			UtilMemCpy( pb, pfucbLV->kdfCurr.data.Pv(), cb );
			}
		pb += cb;
		}

	err = ( fComparing ? ErrERRCheck( JET_errMultiValuedDuplicate ) : JET_errSuccess );

HandleError:
	//  if we are using the pfnRealloc hack and there was an error then free the buffer
	if ( fFreeBuffer && err < JET_errSuccess )
		{
		pfnRealloc( pvReallocContext, pb, 0 );
		}
	
	if ( pfucbNil != pfucbLV )
		{
		DIRCloseLongRoot( pfucb );
		}

	//	commit -- we have done no updates must succeed
	if ( fInTransaction )
		{
		CallS( ErrDIRCommitTransaction( pfucb->ppib, NO_GRBIT ) );
		}

	AssertDIRNoLatch( pfucb->ppib );
	return err;
	}


//  ================================================================
ERR ErrRECRetrieveSLongFieldRefCount(
	FUCB	*pfucb,
	LID		lid,
	BYTE	*pb,
	ULONG	cbMax,
	ULONG	*pcbActual
	)
//  ================================================================
//
//  opens cursor on LONG tree of table
//	seeks to given lid
//  returns the reference count on the LV
//
//-
	{
	ASSERT_VALID( pfucb );
	Assert( pcbActual );
	Assert( pfucb->u.pfcb->Ptdb() != ptdbNil );
	AssertDIRNoLatch( pfucb->ppib );

	ERR			err				= JET_errSuccess;
	FUCB		*pfucbLV		= pfucbNil;
	BOOL		fInTransaction	= fFalse;
 
	//	begin transaction for read consistency
	if ( 0 == pfucb->ppib->level )
		{
		Call( ErrDIRBeginTransaction( pfucb->ppib, JET_bitTransactionReadOnly ) );
		fInTransaction = fTrue;
		}

	Call( ErrDIROpenLongRoot( pfucb ) );
	Assert( wrnLVNoLongValues != err );

	pfucbLV = pfucb->pfucbLV;
	Assert( pfucbNil != pfucbLV );
	Assert( FFUCBLongValue( pfucbLV ) );

	//	move to long field instance
	Call( ErrDIRDownLV( pfucbLV, lid, fDIRNull ) );

	const LVROOT* plvroot;
	plvroot = reinterpret_cast<LVROOT*>( pfucbLV->kdfCurr.data.Pv() );

	if ( cbMax < sizeof( plvroot->ulReference ) )
		{
		err = ErrERRCheck( JET_errInvalidBufferSize );
		goto HandleError;
		}
			
	*pcbActual = sizeof( plvroot->ulReference );
	*( reinterpret_cast<Unaligned< ULONG > *>( pb ) ) = plvroot->ulReference;
	
HandleError:
	if ( pfucbLV != pfucbNil )
		{
		DIRCloseLongRoot( pfucb );
		}

	//	commit -- we have done no updates must succeed
	if ( fInTransaction )
		{
		CallS( ErrDIRCommitTransaction( pfucb->ppib, NO_GRBIT ) );
		}

	AssertDIRNoLatch( pfucb->ppib );
	return err;	
	}
	

//  ================================================================
LOCAL ERR ErrLVGetNextLID( FUCB * pfucb, FUCB * pfucbLV )
//  ================================================================
//
//  Seek to the end of the LV tree passed in. Set the lidLast of the
//  table tdb to the last lid in the LV tree. We use critLV
//  to syncronize this
//
//  We expect to be in the critical section of the fcb of the table
//
//- 
	{
	Assert( !FAssertLVFUCB( pfucb ) );
	Assert( FAssertLVFUCB( pfucbLV ) );

	ERR		err		= JET_errSuccess;
	ULONG	lidNext;
	DIB		dib;
	
	dib.dirflag = fDIRAllNode;
	dib.pos		= posLast;
	
	err = ErrDIRDown( pfucbLV, &dib );
	switch( err )
		{
		case JET_errSuccess:
			LidFromKey( reinterpret_cast<LID *>( &lidNext ), pfucbLV->kdfCurr.key );
			Assert( lidNext > lidMin );		//	lid's start numbering at 1.
			lidNext++;						//	add one to the last used lid to get the next available one
			pfucb->u.pfcb->Ptdb()->InitUlLongIdLast( lidNext );
			break;

		case JET_errRecordNotFound:
			lidNext = lidMin+1;				//	Empty tree, so first lid is 1
			pfucb->u.pfcb->Ptdb()->InitUlLongIdLast( lidNext );
			err = JET_errSuccess;			//  the tree can be empty
			break;

		default:							//  error condition -- don't set lid
			Assert( err != JET_errNoCurrentRecord );
			Assert( err < 0 );				//	if we get a warning back, we're in a lot of trouble because the caller doesn't handle that case
			break;
		}
	DIRUp( pfucbLV );						//  back to LONG.

	return err;
	}


//  ================================================================
ERR ErrRECSeparateLV(
	FUCB		*pfucb,
	const DATA	*pdataField,
	LID			*plid,
	FUCB		**ppfucb,
	LVROOT		*plvrootInit )
//  ================================================================
//
//	Converts intrinsic long field into separated long field. 
//	Intrinsic long field constraint of length less than cbLVIntrinsicMost bytes
//	means that breakup is unnecessary.  Long field may also be
//	null. At the end a LV with LID==pfucb->u.pfcb->ptdb->ulLongIdLast will have
//  been inserted. 
//
//  ppfucb can be null
//
//-
	{
	ASSERT_VALID( pfucb );
	Assert( !FAssertLVFUCB( pfucb ) );
	ASSERT_VALID( pdataField );
	Assert( plid );

	//	Unless this is for compact/upgrade
///	Assert( pfucb->ppib->level > 0 );

	ERR			err				= JET_errSuccess;
	FUCB 		*pfucbLV		= NULL;
	KEY			key;
	DATA  		data;
	LVROOT		lvroot;

	// Sorts don't have LV's (they would have been materialised).
	Assert( !pfucb->u.pfcb->FTypeSort() );

	CallR( ErrDIROpenLongRoot( pfucb, &pfucbLV, fTrue ) );
	Assert( wrnLVNoLongValues != err );
	Assert( pfucbNil != pfucbLV );
	Assert( FFUCBLongValue( pfucbLV ) );

	BOOL	fBeginTrx = fFalse;

	if ( 0 == pfucb->ppib->level )
		{
		Call( ErrDIRBeginTransaction( pfucb->ppib, NO_GRBIT ) );
		fBeginTrx = fTrue;
		}

	// Lid's are numbered starting at 1.  An lidLast of 0 indicates that we must
	// first retrieve the lidLast.  In the pathological case where there are
	// currently no lid's, we'll go through here anyway, but only the first
	// time (since there will be lid's after that).
	Assert( pfucb->u.pfcb->Ptdb() != ptdbNil );
	if ( pfucb->u.pfcb->Ptdb()->UlLongIdLast() == lidMin )
		{
		// TDB's lidLast hasn't been set yet.  Must seek to it.
		// If successful, the TDB's lidLast will be incremented and
		// the value will be returned in lidNext
		Call( ErrLVGetNextLID( pfucb, pfucbLV ) );
		Assert( pfucb->u.pfcb->IsUnlocked() );
		}

	Call( pfucb->u.pfcb->Ptdb()->ErrGetAndIncrUlLongIdLast( plid ) );
	Assert( *plid > 0 );

	//	add long field id with long value size
	if ( NULL == plvrootInit )
		{
		lvroot.ulReference 	= 1;
		lvroot.ulSize 		= pdataField->Cb();
		data.SetPv( &lvroot );
		}
	else
		{
		data.SetPv( plvrootInit );
		}
		
	data.SetCb( sizeof(LVROOT) );

	BYTE rgbKey[ sizeof( LID ) ];
	KeyFromLong( rgbKey, *plid );
	
	key.prefix.Nullify();
	key.suffix.SetPv( rgbKey );
	key.suffix.SetCb( sizeof( rgbKey ) );
	Call( ErrDIRInsert( pfucbLV, key, data, fDIRNull ) );
	
	//	if dataField is non NULL, add dataField
	if ( pdataField->Cb() > 0 )
		{
		Assert( NULL != pdataField->Pv() );
		LVKEY lvkey = LVKeyFromLidOffset( *plid, ulLVOffsetFirst );
		key.prefix.Nullify();
		key.suffix.SetPv( &lvkey );
		key.suffix.SetCb( sizeof( LVKEY ) );
		Assert( key.Cb() == sizeof(LVKEY) );
		err = ErrDIRInsert( pfucbLV, key, *pdataField, fDIRBackToFather );
		Assert( JET_errKeyDuplicate != err );
		Call( err );
		}

	err = ErrERRCheck( JET_wrnCopyLongValue );

HandleError:
	// discard temporary FUCB, or return to caller if ppfucb is not NULL.
	if ( err < JET_errSuccess || NULL == ppfucb )
		{
		DIRClose( pfucbLV );
		}
	else
		{
		*ppfucb = pfucbLV;
		}

	if ( fBeginTrx )
		{
		if ( err >= JET_errSuccess )
			{
			err = ErrDIRCommitTransaction( pfucb->ppib, NO_GRBIT );
			//  if we fail, fallthrough to Rollback below
			}
		if ( err < JET_errSuccess )
			{
			CallSx( ErrDIRRollback( pfucb->ppib ), JET_errRollbackError );
			}
		}

	Assert( JET_errKeyDuplicate != err );

	return err;
	}


//  ================================================================
ERR ErrRECAffectSeparateLV( FUCB *pfucb, LID *plid, ULONG fLV )
//  ================================================================
	{
	ASSERT_VALID( pfucb );
	Assert( !FAssertLVFUCB( pfucb ) );
	Assert( plid && *plid > lidMin );
	Assert( pfucb->ppib->level > 0 );
 	
	ERR			err			= JET_errSuccess;
	FUCB		*pfucbLV	= pfucbNil;
	
	CallR( ErrDIROpenLongRoot( pfucb ) );
	Assert( wrnLVNoLongValues != err );

	pfucbLV = pfucb->pfucbLV;
	Assert( pfucbNil != pfucbLV );
	Assert( FFUCBLongValue( pfucbLV ) );

	//	move to long field instance
	Call( ErrDIRDownLV( pfucbLV, *plid, fDIRNull ) );

	Assert( locOnCurBM == pfucbLV->locLogical );
	Assert( Pcsr( pfucbLV )->FLatched() );

	if ( fLVDereference == fLV )
		{
		const LONG		lDelta		= -1;
		KEYDATAFLAGS	kdf;

		//	cursor's kdfCurr may point to version store,
		//	so must go directly to node to find true refcount
		NDIGetKeydataflags( Pcsr( pfucbLV )->Cpage(), Pcsr( pfucbLV )->ILine(), &kdf );
		Assert( sizeof( LVROOT ) == kdf.data.Cb() );

		const LVROOT * const plvroot = reinterpret_cast<LVROOT *>( kdf.data.Pv() );

		//	don't want count to drop below 0
		if ( 0 == plvroot->ulReference )
			{
			//	someone else must have an active reference to this node
			//	so if this asert fires, it indicates the LV is orphaned
			Assert( FDIRDeltaActiveNotByMe( pfucbLV, OffsetOf( LVROOT, ulReference ) )
				|| FDIRWriteConflict( pfucbLV, operDelta ) );
			err = ErrERRCheck( JET_errWriteConflict );
			goto HandleError;
			}

		Call( ErrDIRDelta(
				pfucbLV,
				OffsetOf( LVROOT, ulReference ),
				&lDelta,
				sizeof( lDelta ),
				NULL,
				0,
				NULL,
				fDIRNull | fDIRDeltaDeleteDereferencedLV ) );
///		Call( ErrDIRGet( pfucbLV ) );
///		if ( 0 == reinterpret_cast<LVROOT*>( pfucbLV->kdfCurr.data.pv )->ulReference
///			&& !FDIRDelta( pfucbLV, OffsetOf( LVROOT, ulReference ) ) )
///			{
///			//	delete long field tree
///			Call( ErrRECDeleteDereferencedLV( pfucbLV ) );
///			}
		}
	else
		{
		Assert( fLVReference == fLV );
		
		//	long value may already be in the process of being
		//	modified for a specific record.  This can only
		//	occur if the long value reference is 1.  If the reference
		//	is 1, then check the root for any version, committed
		//	or uncommitted.  If version found, then burst copy of
		//	old version for caller record.
		const LONG lDelta	= 1;
		err = ErrDIRDelta(
				pfucbLV,
				OffsetOf( LVROOT, ulReference ),
				&lDelta,
				sizeof( lDelta ),
				NULL,
				0,
				NULL,
				fDIRNull | fDIRDeltaDeleteDereferencedLV );
		if ( JET_errWriteConflict == err )
			{
			//  we lost the page during the write conflict
			Call( ErrDIRGet( pfucbLV ) );
			Call( ErrRECIBurstSeparateLV( pfucb, pfucbLV, plid ) );
			}
		}
		
HandleError:
	// discard temporary FUCB
	Assert( pfucbNil != pfucbLV );
	DIRCloseLongRoot( pfucb );

	return err;
	}

LOCAL ERR ErrRECDeleteLV( FUCB *pfucbLV, DIRFLAG dirflag )
//
//  Given a FUCB set to the root of a LV, delete the entire LV.
//
	{
	ASSERT_VALID( pfucbLV );
	Assert( FAssertLVFUCB( pfucbLV ) );
	Assert( sizeof(LVROOT) == pfucbLV->kdfCurr.data.Cb() || fGlobalRepair );
	Assert( sizeof(LID) == pfucbLV->kdfCurr.key.Cb() || fGlobalRepair );

	ERR			err			= JET_errSuccess;

 	LID			lidDelete;
	LidFromKey( &lidDelete, pfucbLV->kdfCurr.key );
	//  delete each chunk
	for( ; ; )
		{
		Call( ErrDIRDelete( pfucbLV, dirflag ) );
		err = ErrDIRNext( pfucbLV, fDIRNull );
		if ( err < JET_errSuccess )
			{
			if ( JET_errNoCurrentRecord == err )
				{
				err = JET_errSuccess;	// No more LV chunks. We're done.
				}
			goto HandleError;
			}
		CallS( err );		// Warnings not expected.

		//  make sure we are still on the same long value
		
		LID lidT;
		LidFromKey( &lidT, pfucbLV->kdfCurr.key );
		if ( lidDelete != lidT )
			{
			err = JET_errSuccess;
			break;
			}
		}

	//	verify return value
	CallS( err );

HandleError:
	Assert( JET_errNoCurrentRecord != err );
	Assert( JET_errRecordNotFound != err );
	Assert( pfucbNil != pfucbLV );
	return err;
	}

//  ================================================================
ERR ErrRECDeletePossiblyDereferencedLV( FUCB *pfucbLV, const TRX trxDeltaCommitted )
//  ================================================================
//
//  Given a FUCB set to the root of a LV, delete the entire LV. If
//  it is dereferenced
//
//-
	{	 
	ASSERT_VALID( pfucbLV );
	Assert( FAssertLVFUCB( pfucbLV ) );
	Assert( pfucbLV->ppib->level > 0 );
	Assert( sizeof(LVROOT) == pfucbLV->kdfCurr.data.Cb() );
	Assert( sizeof(LID) == pfucbLV->kdfCurr.key.Cb() );

	//	in order for us to delete the LV, it must have a refcount of 0 and there
	//	must be no other versions beyond this one
	if( reinterpret_cast<LVROOT*>( pfucbLV->kdfCurr.data.Pv() )->ulReference != 0
		|| FDIRActiveVersion( pfucbLV, trxDeltaCommitted ) )
		{
		return ErrERRCheck( JET_errRecordNotDeleted );
		}
	return ErrRECDeleteLV( pfucbLV, fDIRNull );
	}


//  ================================================================
ERR ErrRECAffectLongFieldsInWorkBuf( FUCB *pfucb, LVAFFECT lvaffect )
//  ================================================================
	{
	ASSERT_VALID( pfucb );
	Assert( !FAssertLVFUCB( pfucb ) );
	Assert( !pfucb->dataWorkBuf.FNull() );
	Assert( lvaffectSeparateAll == lvaffect || lvaffectReferenceAll == lvaffect );

	Assert( pfcbNil != pfucb->u.pfcb );
	Assert( ptdbNil != pfucb->u.pfcb->Ptdb() );

	ERR				err;
	VOID *			pvWorkBufSav	= NULL;
	const ULONG		cbWorkBufSav	= pfucb->dataWorkBuf.Cb();

	AssertDIRNoLatch( pfucb->ppib );

	AssertSz( pfucb->ppib->level > 0, "LV update attempted at level 0" );
	if ( 0 == pfucb->ppib->level )
		{
		err = ErrERRCheck( JET_errNotInTransaction );
		return err;
		}

	CallR( ErrDIRBeginTransaction( pfucb->ppib, NO_GRBIT ) );

	Assert( NULL != pfucb->dataWorkBuf.Pv() );
	Assert( cbWorkBufSav >= REC::cbRecordMin );
	Assert( cbWorkBufSav <= REC::CbRecordMax() );

	if ( lvaffectSeparateAll == lvaffect )
		{
		BFAlloc( &pvWorkBufSav );
		UtilMemCpy( pvWorkBufSav, pfucb->dataWorkBuf.Pv(), cbWorkBufSav );
		}
	else
		{
		//	don't need to save off copy buffer because this is
		//	an InsertCopy and on failure, we will throw away the
		//	copy buffer
		Assert( lvaffectReferenceAll == lvaffect );
		Assert( FFUCBInsertCopyPrepared( pfucb ) );
		}

	TAGFIELDS		tagfields( pfucb->dataWorkBuf );
	Call( tagfields.ErrAffectLongValuesInWorkBuf( pfucb, lvaffect ) );

	Assert( !Pcsr( pfucb )->FLatched() );
	
	Call( ErrDIRCommitTransaction( pfucb->ppib, NO_GRBIT ) );
	FUCBSetTagImplicitOp( pfucb );

	if ( NULL != pvWorkBufSav )
		BFFree( pvWorkBufSav );

	return err;

HandleError:
	Assert( err < 0 );
	CallSx( ErrDIRRollback( pfucb->ppib ), JET_errRollbackError );
	Assert( !Pcsr( pfucb )->FLatched() );

	if ( NULL != pvWorkBufSav )
		{
		//	restore original copy buffer, because any LV updates
		//	that happened got rolled back
		UtilMemCpy( pfucb->dataWorkBuf.Pv(), pvWorkBufSav, cbWorkBufSav );
		pfucb->dataWorkBuf.SetCb( cbWorkBufSav );
		BFFree( pvWorkBufSav );
		}

	return err;
	}


//  ================================================================
ERR ErrRECDereferenceLongFieldsInRecord( FUCB *pfucb )
//  ================================================================
	{
	ERR					err;

	ASSERT_VALID( pfucb );
	Assert( !FAssertLVFUCB( pfucb ) );
	Assert( pfcbNil != pfucb->u.pfcb );

	//	only called by ErrIsamDelete(), which always begins a transaction
	Assert( pfucb->ppib->level > 0 );
	
	AssertDIRNoLatch( pfucb->ppib );

	CallR( ErrDIRGet( pfucb ) );
	Assert( !pfucb->kdfCurr.data.FNull() );

	TAGFIELDS	tagfields( pfucb->kdfCurr.data );
	Call( tagfields.ErrDereferenceLongValuesInRecord( pfucb ) );

HandleError:
	if ( Pcsr( pfucb )->FLatched() )
		{
		CallS( ErrDIRRelease( pfucb ) );
		}
	AssertDIRNoLatch( pfucb->ppib );
	return err;
	}



//  ****************************************************************
//	Functions used by compact to scan long value tree
//		ErrCMPGetFirstSLongField
//		ErrCMPGetNextSLongField
//	are used to scan the long value root and get lid. CMPRetrieveSLongFieldValue
//	is used to scan the long value. Due to the way the long value tree is
//	organized, we use the calling sequence (see CMPCopyLVTree in sortapi.c)
//		ErrCMPGetSLongFieldFirst
//		loop
//			loop to call CMPRetrieveSLongFieldValue to get the whole long value
//		till ErrCMPGetSLongFieldNext return no current record
//		ErrCMPGetSLongFieldClose
//  ****************************************************************

LOCAL ERR ErrCMPGetReferencedSLongField(
	FUCB		*pfucbGetLV,
	LID			*plid,
	LVROOT		*plvroot )
	{
	ERR			err;
	const LID	lidPrevLV	= *plid;
	
#ifdef DEBUG
	ULONG		ulSizeCurr	= 0;
	ULONG		ulSizeSeen	= 0;
	LID			lidPrevNode	= *plid;
	
	LVCheckOneNodeWhileWalking( pfucbGetLV, plid, &lidPrevNode, &ulSizeCurr, &ulSizeSeen );
#endif	

	forever
		{
		if ( sizeof(LID) != pfucbGetLV->kdfCurr.key.Cb()
			|| sizeof(LVROOT) != pfucbGetLV->kdfCurr.data.Cb() )
			{
			LVReportCorruptedLV( pfucbGetLV, *plid );
			FireWall();
			err = ErrERRCheck( JET_errLVCorrupted );
			goto HandleError;
			}
			
		LidFromKey( plid, pfucbGetLV->kdfCurr.key );
		if ( *plid <= lidPrevLV )
			{
			LVReportCorruptedLV( pfucbGetLV, *plid );
			FireWall();

			//	lids are monotonically increasing
			err = ErrERRCheck( JET_errLVCorrupted );
			goto HandleError;
			}
		
		const ULONG	ulRefcount	= (reinterpret_cast<LVROOT*>( pfucbGetLV->kdfCurr.data.Pv() ))->ulReference;
		if ( ulRefcount > 0 )
			{
			plvroot->ulSize = (reinterpret_cast<LVROOT*>( pfucbGetLV->kdfCurr.data.Pv() ))->ulSize;
			plvroot->ulReference = ulRefcount;
			err = ErrDIRRelease( pfucbGetLV );
			Assert( JET_errNoCurrentRecord != err );
			Assert( JET_errRecordNotFound != err );
			break;
			}

		// Skip LV's with refcount == 0
		do
			{
			Call( ErrDIRNext( pfucbGetLV, fDIRNull ) );

			Call( ErrLVCheckDataNodeOfLid( pfucbGetLV, *plid ) );
				
#ifdef DEBUG			
			LVCheckOneNodeWhileWalking( pfucbGetLV, plid, &lidPrevNode, &ulSizeCurr, &ulSizeSeen );
#endif
			}
		while ( wrnLVNoMoreData != err );

		}	// forever


HandleError:
	return err;
	}


//  ================================================================
ERR ErrCMPGetSLongFieldFirst(
	FUCB	*pfucb,
	FUCB	**ppfucbGetLV,
	LID		*plid,
	LVROOT	*plvroot )
//  ================================================================
	{
	ERR		err			= JET_errSuccess;
	FUCB	*pfucbGetLV	= pfucbNil;

	Assert( pfucb != pfucbNil );
 
	//	open cursor on LONG

	CallR( ErrDIROpenLongRoot( pfucb, &pfucbGetLV, fFalse ) );
	if ( wrnLVNoLongValues == err )
		{
		Assert( pfucbNil == pfucbGetLV );
		*ppfucbGetLV = pfucbNil;
		return ErrERRCheck( JET_errRecordNotFound );
		}

	Assert( pfucbNil != pfucbGetLV );
	Assert( FFUCBLongValue( pfucbGetLV ) );

	// seek to first long field instance

	DIB		dib;
	dib.dirflag			= fDIRNull;
	dib.pos				= posFirst;
	Call( ErrDIRDown( pfucbGetLV, &dib ) );

	err = ErrCMPGetReferencedSLongField( pfucbGetLV, plid, plvroot );
	Assert( JET_errRecordNotFound != err );
	if ( err < 0 )
		{
		if ( JET_errNoCurrentRecord == err )
			err = ErrERRCheck( JET_errRecordNotFound );
		goto HandleError;
		}
		
	*ppfucbGetLV = pfucbGetLV;

	return err;
	
	
HandleError:
	//	discard temporary FUCB

	if ( pfucbGetLV != pfucbNil )
		{
		DIRClose( pfucbGetLV );
		}

	return err;
	}


//  ================================================================
ERR ErrCMPGetSLongFieldNext(
	FUCB	*pfucbGetLV,
	LID		*plid,
	LVROOT	*plvroot )
//  ================================================================
	{
	ERR		err = JET_errSuccess;

	Assert( pfucbNil != pfucbGetLV );
 
	//	move to next long field instance

	CallR( ErrDIRNext( pfucbGetLV, fDIRNull ) );
	
	err = ErrCMPGetReferencedSLongField( pfucbGetLV, plid, plvroot );
	Assert( JET_errRecordNotFound != err );

	return err;
	}
 
//  ================================================================
VOID CMPGetSLongFieldClose(	FUCB *pfucbGetLV )
//  ================================================================
	{
	Assert( pfucbGetLV != pfucbNil );
	DIRClose( pfucbGetLV );
	}

//  ================================================================
ERR ErrCMPRetrieveSLongFieldValueByChunks(
	FUCB		*pfucbGetLV,		//	pfucb must be on the LV root node.
	const LID	lid,
	const ULONG	cbTotal,			//	Total LV data length.
	ULONG		ibLongValue,		//	starting offset.
	BYTE		*pbBuf,
	const ULONG	cbMax,
	ULONG		*pcbReturned )		//	Total returned byte count
//  ================================================================
	{
	ERR			err;
	BYTE		*pb			= pbBuf;
	ULONG		cbRemaining	= cbMax;

	*pcbReturned = 0;

	//	We must be on LVROOT if ibGraphic == 0
#ifdef DEBUG
	if ( 0 == ibLongValue )
		{
		CallS( ErrDIRGet( pfucbGetLV ) );
		AssertLVRootNode( pfucbGetLV, lid );
		Assert( cbTotal == (reinterpret_cast<LVROOT*>( pfucbGetLV->kdfCurr.data.Pv() ))->ulSize );
		}
#endif	

	// For this to work properly, ibLongValue must always point to the
	// beginning of a chunk, and the buffer passed in must be big enough
	// to hold at least one chunk.
	Assert( ibLongValue % g_cbColumnLVChunkMost == 0 );
	Assert( cbMax >= g_cbColumnLVChunkMost );

	while( ibLongValue < cbTotal && cbRemaining >= g_cbColumnLVChunkMost )
		{
		CallR( ErrDIRNext( pfucbGetLV, fDIRNull ) );

		//  make sure we are still on the same long value
		Call( ErrLVCheckDataNodeOfLid( pfucbGetLV, lid ) );
		if ( wrnLVNoMoreData == err )
			{
			LVReportCorruptedLV( pfucbGetLV, lid );
			FireWall();

			//	ran out of data before we were supposed to
			err = ErrERRCheck( JET_errLVCorrupted );
			goto HandleError;
			}

		const ULONG cb = pfucbGetLV->kdfCurr.data.Cb();

		// If not a complete chunk, then must be the last chunk.
		Assert( cb == g_cbColumnLVChunkMost || ibLongValue + cb == cbTotal );
		
		UtilMemCpy( pb, pfucbGetLV->kdfCurr.data.Pv(), cb );
		pb += cb;
		cbRemaining -= cb;
		ibLongValue += cb;
		Assert( ibLongValue <= cbTotal );
		}

	// Either we reached the end of the LV or we ran out of buffer space.
	Assert( ibLongValue == cbTotal || cbRemaining < g_cbColumnLVChunkMost );

	*pcbReturned = ULONG( pb - pbBuf );

	Assert( *pcbReturned <= cbMax );

	err = JET_errSuccess;

HandleError:
	CallS( ErrDIRRelease( pfucbGetLV ) );
	return err;
	}


ERR ErrRECUpdateLVRefcount(
	FUCB		*pfucb,
	const LID	lid,
	const ULONG	ulRefcountOld,
	const ULONG	ulRefcountNew )
	{
	ERR			err;
	FUCB		*pfucbLV	= pfucbNil;
	
	CallR( ErrDIROpenLongRoot( pfucb ) );
	Assert( wrnLVNoLongValues != err );		// should only call this func if we know LV's exist

	pfucbLV = pfucb->pfucbLV;
	Assert( pfucbNil != pfucbLV );
	Assert( FFUCBLongValue( pfucbLV ) );

	Call( ErrDIRDownLV( pfucbLV, lid, fDIRNull ) );
	Assert( (reinterpret_cast<LVROOT*>( pfucbLV->kdfCurr.data.Pv() ))->ulReference
		== ulRefcountOld );

	if ( 0 == ulRefcountNew )
		{
		Assert( ulRefcountOld != ulRefcountNew );
		Call( ErrRECDeleteLV( pfucbLV, fDIRNull ) );
		}
#ifdef DEBUG
	//	in non-DEBUG, this check is performed before calling this function
	else if ( ulRefcountOld == ulRefcountNew )
		{
		//	refcount is already correct. Do nothing.
		}
#endif				
	else
		{
		//	update refcount with correct count
		LVROOT	lvroot;
		DATA	data;

		data.SetPv( &lvroot );
		data.SetCb( sizeof(LVROOT) );
				
		UtilMemCpy( &lvroot, pfucbLV->kdfCurr.data.Pv(), sizeof(LVROOT) );
		lvroot.ulReference = ulRefcountNew;
		Call( ErrDIRReplace( pfucbLV, data, fDIRNull ) );
		}

HandleError:
	Assert( pfucbNil != pfucbLV );
	DIRCloseLongRoot( pfucb );

	return err;
	}
	


#ifdef DEBUG

VOID LVCheckOneNodeWhileWalking(
	FUCB	*pfucbLV,
	LID		*plidCurr,
	LID		*plidPrev,
	ULONG	*pulSizeCurr,
	ULONG	*pulSizeSeen )
	{
	//  make sure we are still on the same long value
	if ( sizeof(LID) == pfucbLV->kdfCurr.key.Cb() )
		{
		//  we must be on the first node of a new long value
		Assert( sizeof(LVROOT) == pfucbLV->kdfCurr.data.Cb() );

		//  get the new LID
		LidFromKey( plidCurr, pfucbLV->kdfCurr.key );
		Assert( *plidCurr > *plidPrev );
		*plidPrev = *plidCurr;
			
		//  get the new size. make sure we saw all of the previous LV
		Assert( *pulSizeCurr == *pulSizeSeen );
		*pulSizeCurr = (reinterpret_cast<LVROOT*>( pfucbLV->kdfCurr.data.Pv() ))->ulSize;
		*pulSizeSeen = 0;

		//  its O.K. to have an unreferenced LV (it should get cleaned up), but we may want
		//  to set a breakpoint
		if ( 0 == ( reinterpret_cast<LVROOT*>( pfucbLV->kdfCurr.data.Pv() ) )->ulReference )
			{
			/// AssertSz( fFalse, "Unreferenced long value" );
			Assert( 0 == *pulSizeSeen );	//  a dummy statement to set a breakpoint on
			}
			
		}
	else
		{
		Assert( *plidCurr > lidMin );
		Assert( sizeof(LVKEY) == pfucbLV->kdfCurr.key.Cb() );

		//  check that we are still on our own lv.
		LID		lid			= lidMin;
		ULONG	ulOffset	= 0;
		LidOffsetFromKey( &lid, &ulOffset, pfucbLV->kdfCurr.key );
		Assert( lid == *plidCurr );
		Assert( ulOffset == *pulSizeSeen );

		//  keep track of how much of the LV we have seen
		//  the nodes should be of maximum size, except at the end
		*pulSizeSeen += pfucbLV->kdfCurr.data.Cb();
		Assert( *pulSizeSeen <= *pulSizeCurr );
		Assert( g_cbColumnLVChunkMost == pfucbLV->kdfCurr.data.Cb()
			|| *pulSizeSeen == *pulSizeCurr );

		}
	}

#endif	//  DEBUG

#ifdef MINIMAL_FUNCTIONALITY
#else

//  ================================================================
RECCHECKLV::RECCHECKLV( TTMAP& ttmap, const REPAIROPTS * m_popts ) :
//  ================================================================
	m_ttmap( ttmap ),
	m_popts( m_popts ),
	m_ulSizeCurr( 0 ),
	m_ulSizeSeen( 0 ),
	m_lidCurr( lidMin )
	{
	}


//  ================================================================
RECCHECKLV::~RECCHECKLV()
//  ================================================================
	{
	}


//  ================================================================
ERR RECCHECKLV::operator()( const KEYDATAFLAGS& kdf )
//  ================================================================
	{
	ERR err = JET_errSuccess;
	ERR wrn = JET_errSuccess;

	if ( sizeof(LID) == kdf.key.Cb() )
		{			
		const LID lidOld = m_lidCurr;

		LidFromKey( &m_lidCurr, kdf.key );

		if( sizeof(LVROOT) != kdf.data.Cb() )
			{
			(*m_popts->pcprintfError)( "corrupted LV(%d) (LVROOT data mismatch: expected %d bytes, got %d bytes\r\n",
										m_lidCurr, sizeof( LVROOT ), kdf.data.Cb() );
			Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
			}

		if( m_lidCurr <= lidOld )
			{
			(*m_popts->pcprintfError)( "corrupted LV(%d) (LIDs are not increasing: %d )\r\n", m_lidCurr, lidOld );
			Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
			}
		
		if( m_ulSizeCurr != m_ulSizeSeen )
			{
			(*m_popts->pcprintfError)( "corrupted LV(%d) (LV too short: expected %d bytes, saw %d bytes)\r\n", lidOld, m_ulSizeCurr, m_ulSizeSeen );
			Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
			}
		m_ulSizeCurr = (reinterpret_cast<LVROOT*>( kdf.data.Pv() ))->ulSize;
		m_ulSizeSeen = 0;

		const ULONG ulReference = (reinterpret_cast<LVROOT*>( kdf.data.Pv() ))->ulReference;			

#ifdef SYNC_DEADLOCK_DETECTION
		COwner* const pownerSaved = Pcls()->pownerLockHead;
		Pcls()->pownerLockHead = NULL;
#endif  //  SYNC_DEADLOCK_DETECTION
		err = m_ttmap.ErrSetValue( m_lidCurr, ulReference );
#ifdef SYNC_DEADLOCK_DETECTION
		Pcls()->pownerLockHead = pownerSaved;
#endif  //  SYNC_DEADLOCK_DETECTION
		Call( err );
		}
	else
		{
		if( lidMin == m_lidCurr )
			{
			(*m_popts->pcprintfError)( "corrupted LV(%d) (lid == lidmin)\r\n", m_lidCurr );
			Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
			}
		if( sizeof(LVKEY) != kdf.key.Cb() )
			{
			(*m_popts->pcprintfError)( "corrupted LV(%d) (LVKEY size mismatch: expected %d bytes, got %d bytes)\r\n",
										m_lidCurr, sizeof( LVKEY ), kdf.key.Cb() );
			Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
			}

		//  check that we are still on our own lv.
		LID		lid			= lidMin;
		ULONG	ulOffset	= 0;
		LidOffsetFromKey( &lid, &ulOffset, kdf.key );
		if( lid != m_lidCurr )
			{
			(*m_popts->pcprintfError)( "corrupted LV(%d) (lid changed to %d without root, size is %d bytes)\r\n",
										m_lidCurr, lid, kdf.data.Cb() );
			Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
			}
		if( ulOffset != m_ulSizeSeen )
			{
			(*m_popts->pcprintfError)( "corrupted LV(%d) (missing chunk: offset is %d, saw %d bytes, size is %d bytes)\r\n",
											m_lidCurr, ulOffset, m_ulSizeSeen, kdf.data.Cb() );
			Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
			}
		if( 0 != ( ulOffset % g_cbColumnLVChunkMost ) )
			{
			(*m_popts->pcprintfError)( "corrupted LV(%d) (incorrect offset: offset is %d, size is %d bytes)\r\n",
										m_lidCurr, ulOffset, kdf.data.Cb() );
			Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
			}

		//  keep track of how much of the LV we have seen
		//  the nodes should be of maximum size, except at the end
		m_ulSizeSeen += kdf.data.Cb();
		if( m_ulSizeSeen > m_ulSizeCurr )
			{
			(*m_popts->pcprintfError)( "corrupted LV(%d) (LV too long: expected %d bytes, saw %d bytes)\r\n",
										m_lidCurr, m_ulSizeCurr, m_ulSizeSeen );
			Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
			}
		if( g_cbColumnLVChunkMost != kdf.data.Cb() && m_ulSizeSeen != m_ulSizeCurr )
			{
			(*m_popts->pcprintfError)( "corrupted LV(%d) (node is wrong size: node is %d bytes)\r\n",
										m_lidCurr, kdf.data.Cb() );
			Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
			}
		}

HandleError:
	if( JET_errSuccess == err )
		{
		err = wrn;
		}
	return err;
	}
	

//  ================================================================
RECCHECKLVSTATS::RECCHECKLVSTATS( LVSTATS * plvstats ) :
//  ================================================================
	m_plvstats( plvstats )
	{
	}


//  ================================================================
RECCHECKLVSTATS::~RECCHECKLVSTATS()
//  ================================================================
	{
	}


//  ================================================================
ERR RECCHECKLVSTATS::operator()( const KEYDATAFLAGS& kdf )
//  ================================================================
	{
	if ( sizeof(LID) == kdf.key.Cb() )
		{			
		LID lid;
		LidFromKey( &lid, kdf.key );
		
		const ULONG ulSize 		= (reinterpret_cast<LVROOT*>( kdf.data.Pv() ))->ulSize;
		const ULONG ulReference = (reinterpret_cast<LVROOT*>( kdf.data.Pv() ))->ulReference;	

		m_plvstats->cbLVTotal += ulSize;

		if( lidMin == m_plvstats->lidMin )
			{
			m_plvstats->lidMin = lid;
			}
		m_plvstats->lidMin = min( lid, m_plvstats->lidMin );
		m_plvstats->lidMax = max( lid, m_plvstats->lidMax );
		
		++(m_plvstats->clv );

		if( ulReference > 1 )
			{
			++(m_plvstats->clvMultiRef );
			}
		else if( 0 == ulReference )
			{
			++(m_plvstats->clvNoRef );
			}

		m_plvstats->ulReferenceMax = max( ulReference, m_plvstats->ulReferenceMax );
		
		m_plvstats->cbLVMin = min( ulSize, m_plvstats->cbLVMin );
		m_plvstats->cbLVMax = max( ulSize, m_plvstats->cbLVMax );
		}

	return JET_errSuccess;
	}


//  ================================================================
ERR ErrREPAIRCheckLV(
	FUCB * const pfucb,
	LID * const plid,
	ULONG * const pulRefcount,
	ULONG * const pulSize,
	BOOL * const pfLVHasRoot,
	BOOL * const pfLVComplete,
	BOOL * const pfDone )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	ULONG ulSizeSeen 	= 0;

	Call( ErrDIRGet( pfucb ) );

	*pfLVHasRoot		= fFalse;
	*pfLVComplete 		= fFalse;
	*pfDone				= fFalse;
	*pulRefcount		= 0;
	LidFromKey( plid, pfucb->kdfCurr.key );

	if ( sizeof( LID ) != pfucb->kdfCurr.key.Cb()
		|| sizeof( LVROOT ) != pfucb->kdfCurr.data.Cb() )
		{
		if( sizeof( LVKEY ) != pfucb->kdfCurr.key.Cb() )
			{
			//  this would be a really strange corruption
			goto HandleError;
			}

		LID		lid			= lidMin;
		ULONG	ulOffset	= 0;
		LidOffsetFromKey( &lid, &ulOffset, pfucb->kdfCurr.key );

		if( 0 == ulOffset )
			{
			//  we are not on the root, we are on the first LV chunk
			*pulRefcount = 0;
			*pulSize = 0;
			ulSizeSeen = pfucb->kdfCurr.data.Cb();
			}
		else
			{
			// we are neither on the root, nor on the first LV chunk
			// no way to recover this LV
			goto HandleError;
			}
		}
	else
		{
		*pfLVHasRoot = fTrue;
		*pulRefcount = (reinterpret_cast<LVROOT*>( pfucb->kdfCurr.data.Pv() ) )->ulReference;
		*pulSize = (reinterpret_cast<LVROOT*>( pfucb->kdfCurr.data.Pv() ) )->ulSize;
		}

	for( ; ; )
		{
		err = ErrDIRNext( pfucb, fDIRNull );
		if( JET_errNoCurrentRecord == err )
			{
			break;
			}
		Call( err );

		LID lidT;
		LidFromKey( &lidT, pfucb->kdfCurr.key );

		if( *plid != lidT )
			{
			//  we are on a new LV
			break;
			}

		if( sizeof( LVKEY ) != pfucb->kdfCurr.key.Cb() )
			{
			//  this would be a really strange corruption
			goto HandleError;
			}
			
		ULONG	ulOffset;
		LidOffsetFromKey( &lidT, &ulOffset, pfucb->kdfCurr.key );
		if( ulOffset != ulSizeSeen )
			{
			//  we are missing a chunk
			goto HandleError;
			}	

		ulSizeSeen += pfucb->kdfCurr.data.Cb();

		if( g_cbColumnLVChunkMost != pfucb->kdfCurr.data.Cb()
			&& ulSizeSeen < *pulSize
			&& *pfLVHasRoot )
			{
			//  all chunks in the middle should be the full LV chunk size
			goto HandleError;
			}

		if( ulSizeSeen > *pulSize
			&& *pfLVHasRoot )
			{
			//  this LV is too long
			goto HandleError;
			}
		}

	Assert( err >= 0 || JET_errNoCurrentRecord == err );
	
	*pfDone 		= ( JET_errNoCurrentRecord == err );

	if( *pfLVHasRoot )
		{
		*pfLVComplete	= ( ulSizeSeen == *pulSize );	
		}
	else
		{
		//  we can only be sure that we didn't lose a bit of a long value
		//  if the chunk at the end is not a full chunk
		*pfLVComplete = ( ulSizeSeen % g_cbColumnLVChunkMost ) != 0;
		*pulSize = ulSizeSeen;
		*pulRefcount = 1;
		}

	if( err >= 0 )
		{
		Call( ErrDIRRelease( pfucb ) );
		}
	
	err = JET_errSuccess;

HandleError:
	return err;
	}


//  ================================================================
LOCAL ERR ErrREPAIRDownLV( FUCB * pfucb, LID lid )
//  ================================================================
//
//  This will search for a partial chunk of a LV
//
//-
	{
	ERR err = JET_errSuccess;

	BYTE rgbKey[ sizeof( LID ) ];
	KeyFromLong( rgbKey, lid );

	BOOKMARK	bm;
	bm.key.prefix.Nullify();
	bm.key.suffix.SetPv( rgbKey );
	bm.key.suffix.SetCb( sizeof( rgbKey ) );
	bm.data.Nullify();

	DIB			dib;
	dib.dirflag = fDIRNull;
	dib.pos		= posDown;
	dib.pbm		= &bm;

	DIRUp( pfucb );
	err = ErrDIRDown( pfucb, &dib );
	Assert( JET_errRecordDeleted != err );
	
	const BOOL fFoundLess		= ( err == wrnNDFoundLess );
	const BOOL fFoundGreater 	= ( err == wrnNDFoundGreater );
	const BOOL fFoundEqual 		= ( !fFoundGreater && !fFoundLess && err >= 0 );
	Call( err );

	Assert( fGlobalRepair || !fFoundGreater );
	if( fFoundEqual )
		{
		//  we are on the node we want
		}
	else if( fFoundLess )
		{
		//  we are on a node that is less than our current node
		Assert( locBeforeSeekBM == pfucb->locLogical );
		Call( ErrDIRNext( pfucb, fDIRNull ) );
		}
	else if( fFoundGreater )
		{
		//  we are on a node with a greater key than the one we were seeking for
		//  this is actually the node we want to be on
		Assert( locAfterSeekBM == pfucb->locLogical );
		pfucb->locLogical = locOnCurBM;
		}
		
HandleError:
	return err;
	}


//  ================================================================
ERR ErrREPAIRDeleteLV( FUCB * pfucb, LID lid )
//  ================================================================
	{
	Assert( fGlobalRepair );
	
	ERR err = JET_errSuccess;

	Call( ErrREPAIRDownLV( pfucb, lid ) );

#ifdef DEBUG
	LID lidT;
	LidFromKey( &lidT, pfucb->kdfCurr.key );
	Assert( lidT == lid );
#endif	//	DEBUG
	
	Call( ErrRECDeleteLV( pfucb, fDIRNoVersion ) );

HandleError:
	return err;
	}


//  ================================================================
ERR ErrREPAIRCreateLVRoot( FUCB * const pfucb, const LID lid, const ULONG ulRefcount, const ULONG ulSize )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	BYTE rgbKey[ sizeof( LID ) ];	//	this is the key to insert
	KeyFromLong( rgbKey, lid );

	KEY key;
	key.prefix.Nullify();
	key.suffix.SetPv( rgbKey );
	key.suffix.SetCb( sizeof( rgbKey ) );

	LVROOT lvroot;
	lvroot.ulReference = ulRefcount;
	lvroot.ulSize = ulSize;

	DATA data;
	data.SetPv( &lvroot );
	data.SetCb( sizeof( LVROOT ) );
	
	err = ErrDIRInsert( pfucb, key, data, fDIRNull | fDIRNoVersion | fDIRNoLog, NULL );
	
	return err;
	}


//  ================================================================
ERR ErrREPAIRNextLV( FUCB * pfucb, LID lidCurr, BOOL * pfDone )
//  ================================================================
	{
	ERR err = JET_errSuccess;
	const LID lidNext = lidCurr + 1;

	err = ErrREPAIRDownLV( pfucb, lidNext );
	if( JET_errNoCurrentRecord == err
		|| JET_errRecordNotFound == err )
		{
		*pfDone = fTrue;
		return JET_errSuccess;
		}
	Call( err );
	
#ifdef DEBUG
	LID lidT;
	LidFromKey( &lidT, pfucb->kdfCurr.key );
	Assert( lidT >= lidNext );
#endif	//	DEBUG
	
HandleError:
	return err;
	}


//  ================================================================
ERR ErrREPAIRUpdateLVRefcount(
	FUCB		* const pfucbLV,
	const LID	lid,
	const ULONG	ulRefcountOld,
	const ULONG	ulRefcountNew )
//  ================================================================
	{
	Assert( ulRefcountOld != ulRefcountNew );
	
	ERR			err;

	LVROOT	lvroot;
	DATA	data;

	Call( ErrDIRDownLV( pfucbLV, lid, fDIRNull ) );
	Assert( (reinterpret_cast<LVROOT*>( pfucbLV->kdfCurr.data.Pv() ))->ulReference
		== ulRefcountOld );
	
	data.SetPv( &lvroot );
	data.SetCb( sizeof(LVROOT) );
			
	UtilMemCpy( &lvroot, pfucbLV->kdfCurr.data.Pv(), sizeof(LVROOT) );
	lvroot.ulReference = ulRefcountNew;
	Call( ErrDIRReplace( pfucbLV, data, fDIRNull ) );

HandleError:
	return err;
	}


//  ================================================================
LOCAL ERR ErrSCRUBIZeroLV( 	PIB * const 	ppib,
							const IFMP 		ifmp,
							CSR * const 	pcsr,
							const INT 		iline,
							const LID 		lid,
							const ULONG 	ulSize,
							const BOOL		fCanChangeCSR )
//  ================================================================
	{
	ERR				err;
	KEYDATAFLAGS 	kdf;
	INT				ilineT = iline;

	while( 1 )
		{
		if( ilineT == pcsr->Cpage().Clines() )
			{
			const PGNO pgnoNext = pcsr->Cpage().PgnoNext();
			if( NULL == pgnoNext )
				{
				//  end of the tree
				return JET_errSuccess;
				}

			if( !fCanChangeCSR )
				{
				//  we need to keep the root of the LV latched for further processing
				//  use a new CSR to venture onto new pages
				CSR csrNext;
				CallR( csrNext.ErrGetRIWPage( ppib, ifmp, pgnoNext ) );
				csrNext.UpgradeFromRIWLatch();

				BFDirty( pcsr->Cpage().PBFLatch() );	

				err = ErrSCRUBIZeroLV( ppib, ifmp, &csrNext, 0, lid, ulSize, fTrue );
				
				csrNext.ReleasePage();
				csrNext.Reset();
				
				return err;
				}
			else
				{
				//  the page should be write latched downgrade to a RIW latch
				//  ErrSwitchPage will RIW latch the next page
				pcsr->Downgrade( latchRIW );
				
				CallR( pcsr->ErrSwitchPage( ppib, ifmp, pgnoNext ) );
				pcsr->UpgradeFromRIWLatch();

				BFDirty( pcsr->Cpage().PBFLatch() );	

				ilineT = 0;
				}
			}

		NDIGetKeydataflags( pcsr->Cpage(), ilineT, &kdf );

		//  check to see if we have reached the next LVROOT
		if( sizeof( LID ) == kdf.key.Cb() )
			{
			if( sizeof( LVROOT ) != kdf.data.Cb() )
				{
				AssertSz( fFalse, "Corrupted LV: corrupted LVROOT" );
				return ErrERRCheck( JET_errLVCorrupted );
				}
			//  reached the start of the next long-value
			return JET_errSuccess;
			}

		//  make sure we are on a LVDATA node
		if( sizeof( LVKEY ) != kdf.key.Cb() )
			{
			AssertSz( fFalse, "Corrupted LV: unknown key size" );
			return ErrERRCheck( JET_errLVCorrupted );
			}

		//  make sure LIDs haven't changed
		LID lidT;
		LidFromKey( &lidT, kdf.key );
		if( lid != lidT )
			{
			//  this can happen if the next LV is being deleted
			return JET_errSuccess;
			}

		//	make sure the LV isn't too long
		ULONG ulOffset;
		OffsetFromKey( &ulOffset, kdf.key );
		if( ulOffset > ulSize && !FNDDeleted( kdf ) )
			{
			AssertSz( fFalse, "Corrupted LV: LV too long" );
			return ErrERRCheck( JET_errLVCorrupted );
			}

		//  we are on a data node of our LV
		memset( kdf.data.Pv(), 'l', kdf.data.Cb() );
		
		++ilineT;
		}
	return JET_errSuccess;
	}


//  ================================================================
ERR ErrSCRUBZeroLV( PIB * const ppib,
					const IFMP ifmp,
					CSR * const pcsr,
					const INT iline )
//  ================================================================
	{
	CSR csrT;
	
	KEYDATAFLAGS kdf;
	NDIGetKeydataflags( pcsr->Cpage(), iline, &kdf );
	Assert( sizeof( LVROOT ) == kdf.data.Cb() );
	
	const LVROOT * const plvroot = reinterpret_cast<LVROOT *>( kdf.data.Pv() );
	Assert( 0 == plvroot->ulReference );

	const ULONG ulSize = plvroot->ulSize;
	LID lid;
	LidFromKey( &lid, kdf.key );

	return ErrSCRUBIZeroLV( ppib, ifmp, pcsr, iline+1, lid, ulSize, fFalse );
	}

#endif	//	MINIMAL_FUNCTIONALITY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\node.cxx ===
/*******************************************************************

Operations that modify a node are done in three stages:

1. Create a 'tentative' version (before image) for the record
1. Dirty the page -- this will increase the timestamp
2. Log the operation.
3. If the log operation succeeded:
	3.1	Update the page. Set its lgpos to the position we got
   	from the log operation. As the page is write latched
	we do not need to worry about the page being flushed yet

The item that a currency references must be there

*******************************************************************/


#include "std.hxx"


//  ****************************************************************
//  MACROS
//  ****************************************************************

#ifdef DEBUG

//  check that the node is in order at each entry point
///#define DEBUG_NODE

//  check that the node is in order after each insertion
///#define DEBUG_NODE_INSERT

//  check the binary-search seeks with linear scans
///#define DEBUG_NODE_SEEK

#endif	// DEBUG


//  ****************************************************************
//  CONSTANTS
//  ****************************************************************

//  the number of DATA structs that a KEYDATAFLAGS is converted to
const ULONG cdataKDF	= 4;

//  the number of DATA structs that a prefix becomes
const ULONG cdataPrefix	= 3;


//  ****************************************************************
//  PROTOTYPES
//  ****************************************************************

LOCAL VOID NDILineToKeydataflags		( const LINE * pline, KEYDATAFLAGS * pkdf );
LOCAL INT CdataNDIPrefixAndKeydataflagsToDataflags ( 
	KEYDATAFLAGS 	* const pkdf,
	DATA 			* const rgdata,
	INT 			* const pfFlags,
	LE_KEYLEN		* const ple_keylen );
LOCAL INT CdataNDIKeydataflagsToDataflags (
	const KEYDATAFLAGS 	* const pkdf,
	DATA 				* const rgdata,
	INT 				* const pfFlags,
	LE_KEYLEN			* const ple_keylen );
INLINE VOID NDISetCompressed			( KEYDATAFLAGS& kdf );
INLINE VOID NDIResetCompressed			( KEYDATAFLAGS& kdf );
INLINE VOID NDISetFlag					( CSR * pcsr, INT fFlag );
INLINE VOID NDIResetFlag				( CSR * pcsr, INT fFlag );

INLINE VOID NDIGetBookmark				( const CPAGE& cpage, INT iline, BOOKMARK * pbookmark, const BOOL fUnique );
LOCAL ERR ErrNDISeekInternalPage		( CSR * pcsr, const BOOKMARK& bm );
LOCAL ERR ErrNDISeekLeafPage			( const FUCB * pfucb, CSR * pcsr, const BOOKMARK& bm );

#ifdef DEBUG
INLINE VOID NDIAssertCurrency			( const FUCB * pfucb, const CSR * pcsr );
INLINE VOID NDIAssertCurrencyExists		( const FUCB * pfucb, const CSR * pcsr );

#ifdef DEBUG_NODE_SEEK
LOCAL INT IlineNDISeekGEQDebug			( const FUCB * pfucb, const CPAGE& cpage, const BOOKMARK& bm, INT * plastCompare );
LOCAL INT IlineNDISeekGEQInternalDebug	( const CPAGE& cpage, const BOOKMARK& bm, INT * plastCompare );
#endif	//	DEBUG_NODE_SEEK

#else
#define NDIAssertCurrency( pfucb, pcsr )		((VOID) 0)
#define NDIAssertCurrencyExists( pfucb, pcsr )	((VOID) 0)
#endif	//  DEBUG


//  ****************************************************************
//  INTERNAL ROUTINES
//  ****************************************************************


//  ================================================================
LOCAL VOID NDILineToKeydataflags( const LINE * pline, KEYDATAFLAGS * pkdf )
//  ================================================================
	{
	const BYTE	*pb				= (BYTE*)pline->pv;
	INT			cbKeyCountTotal	= cbKeyCount;

	if ( pline->fFlags & fNDCompressed )
		{
		//  prefix key compressed
		pkdf->key.prefix.SetCb( *((UnalignedLittleEndian< SHORT > *)pb) );
		pb += cbPrefixOverhead;
		cbKeyCountTotal += cbPrefixOverhead;
		}
	else
		{
		//  no prefix compression
		pkdf->key.prefix.SetCb( 0 );
		}

	pkdf->key.suffix.SetCb( *((UnalignedLittleEndian< SHORT > *)pb) );
	pkdf->key.suffix.SetPv( const_cast<BYTE *>( pb ) + cbKeyCount );
	
	pkdf->data.SetCb( pline->cb - pkdf->key.suffix.Cb() - cbKeyCountTotal );
	pkdf->data.SetPv( const_cast<BYTE *>( pb ) + cbKeyCount + pkdf->key.suffix.Cb() );
	
	pkdf->fFlags	= pline->fFlags;

	Assert( pkdf->key.suffix.Cb() + pkdf->data.Cb() + cbKeyCountTotal == ( ULONG )pline->cb );

	//	kdf can not yet be validated since prefix.pv is not yet set
	}


//  ================================================================
LOCAL INT CdataNDIPrefixAndKeydataflagsToDataflags(
	KEYDATAFLAGS 	* const pkdf,
	DATA 			* const rgdata,
	INT 			* const pfFlags,
	LE_KEYLEN		* const ple_keylen )
//  ================================================================
//
//	sets up rgdata to insert kdf with *pcbPrefix as prefix.cb
//	adjust kdf.suffix.cb to new suffix.cb
//  rgdata must have at least cdataKDF + 1 elements
//
//-
	{
	ASSERT_VALID( pkdf );
	
	INT idata = 0;

	Assert( ple_keylen->le_cbPrefix >= 0 );
	if ( ple_keylen->le_cbPrefix > 0 )
		{
		//  prefix compresses
		Assert( ple_keylen->le_cbPrefix > cbPrefixOverhead );
		Assert( sizeof(ple_keylen->le_cbPrefix) == cbPrefixOverhead );
		
		rgdata[idata].SetPv( &ple_keylen->le_cbPrefix );
		rgdata[idata].SetCb( cbPrefixOverhead );
		++idata;
		}
		
	//	suffix count will be updated correctly below
	rgdata[idata].SetPv( &ple_keylen->le_cbSuffix );
	rgdata[idata].SetCb( cbKeyCount );
	++idata;

	//	leave ple_keylen->le_cbPrefix out of given key to get suffix to insert
	Assert( pkdf->key.Cb() >= ple_keylen->le_cbPrefix );
	if ( pkdf->key.prefix.Cb() <= ple_keylen->le_cbPrefix )
		{
		//	get suffix to insert from pkdf->suffix
		const INT	cbPrefixInSuffix = ple_keylen->le_cbPrefix - pkdf->key.prefix.Cb();

		rgdata[idata].SetPv( (BYTE *) pkdf->key.suffix.Pv() + cbPrefixInSuffix );
		rgdata[idata].SetCb( pkdf->key.suffix.Cb() - cbPrefixInSuffix );
		idata++;

		//	decrease size of suffix
		pkdf->key.suffix.DeltaCb( - cbPrefixInSuffix );
		}
	else
		{
		//	get suffix to insert from pkdf->prefix and suffix
		rgdata[idata].SetPv( (BYTE *)pkdf->key.prefix.Pv() + ple_keylen->le_cbPrefix );
		rgdata[idata].SetCb( pkdf->key.prefix.Cb() - ple_keylen->le_cbPrefix );
		++idata;

		rgdata[idata] = pkdf->key.suffix;
		++idata;

		//	decrease size of suffix
		pkdf->key.suffix.DeltaCb( pkdf->key.prefix.Cb() - ple_keylen->le_cbPrefix );
		}

	//	update suffix count in output buffer
	ple_keylen->le_cbSuffix = (USHORT)pkdf->key.suffix.Cb();

	//	get data of kdf
	rgdata[idata] = pkdf->data;
	++idata;

	*pfFlags = pkdf->fFlags;
	if ( ple_keylen->le_cbPrefix > 0 )
		{
		*pfFlags |= fNDCompressed;
		}
	else
		{
		*pfFlags &= ~fNDCompressed;
		}
	
	return idata;
	}


//  ================================================================
LOCAL INT CdataNDIKeydataflagsToDataflags(
	const KEYDATAFLAGS 	* const pkdf,
	DATA 				* const rgdata,
	INT 				* const pfFlags,
	LE_KEYLEN			* const ple_keylen )
//  ================================================================
//
//  rgdata must have at least cdataKDF elements
//
//-
	{
	ASSERT_VALID( pkdf );
	
	INT idata = 0;

	if ( !pkdf->key.prefix.FNull() )
		{
		//  prefix compresses
		Assert( pkdf->key.prefix.Cb() > cbPrefixOverhead );
		Assert( FNDCompressed( *pkdf ) );

		ple_keylen->le_cbPrefix = USHORT( pkdf->key.prefix.Cb() );
		rgdata[idata].SetPv( &ple_keylen->le_cbPrefix );
		rgdata[idata].SetCb( cbPrefixOverhead );
		++idata;
		}
	else
		{
		Assert( !FNDCompressed( *pkdf ) );
		}

	ple_keylen->le_cbSuffix = USHORT( pkdf->key.suffix.Cb() );
	rgdata[idata].SetPv( &ple_keylen->le_cbSuffix );
	rgdata[idata].SetCb( cbKeyCount );
	++idata;

	rgdata[idata] = pkdf->key.suffix;
	++idata;

	rgdata[idata] = pkdf->data;
	++idata;

	*pfFlags = pkdf->fFlags;
	
	return idata;
	}


//  ================================================================
VOID NDIGetKeydataflags( const CPAGE& cpage, INT iline, KEYDATAFLAGS * pkdf )
//  ================================================================
	{
	LINE line;
	cpage.GetPtr( iline, &line );
	NDILineToKeydataflags( &line, pkdf );
	if( FNDCompressed( *pkdf ) )
		{
		cpage.GetPtrExternalHeader( &line );
		if ( !cpage.FRootPage() )
			{
			pkdf->key.prefix.SetPv( (BYTE *)line.pv );
			}
		else
			{
			Assert( fFalse );
			if ( cpage.FSpaceTree() )
				{
				pkdf->key.prefix.SetPv( (BYTE *)line.pv + sizeof( SPLIT_BUFFER ) );
				}
			else
				{
				pkdf->key.prefix.SetPv( (BYTE *)line.pv + sizeof( SPACE_HEADER ) );
				}
			}
		}
	else
		{
		Assert( 0 == pkdf->key.prefix.Cb() );
		pkdf->key.prefix.SetPv( NULL );
		}
	
	ASSERT_VALID( pkdf );
	}


//  ================================================================
INLINE VOID NDIGetBookmark( const CPAGE& cpage, INT iline, BOOKMARK * pbookmark, const BOOL fUnique )
//  ================================================================
//
//  returns the correct bookmark for the node. this depends on wether the index is
//  unique or not. may need the FUCB to determine if the index is unique
//
//-
	{
	KEYDATAFLAGS keydataflags;
	NDIGetKeydataflags( cpage, iline, &keydataflags );

	NDGetBookmarkFromKDF( keydataflags, pbookmark, fUnique );
	
	ASSERT_VALID( pbookmark );
	}


//  ================================================================
INLINE VOID NDISetCompressed( KEYDATAFLAGS& kdf )
//  ================================================================
	{
	kdf.fFlags |= fNDCompressed;
#ifdef DEBUG_NODE
	Assert( FNDCompressed( kdf ) );
#endif	//	DEBUG_NODE
	}

	
//  ================================================================
INLINE VOID NDIResetCompressed( KEYDATAFLAGS& kdf )
//  ================================================================
	{
	kdf.fFlags &= ~fNDCompressed;
#ifdef DEBUG_NODE
	Assert( !FNDCompressed( kdf ) );
#endif	//	DEBUG_NODE
	}

	
//  ================================================================
INLINE VOID NDISetFlag( CSR * pcsr, INT fFlag )
//  ================================================================
	{
	KEYDATAFLAGS kdf;
	NDIGetKeydataflags( pcsr->Cpage(), pcsr->ILine(), &kdf );
	pcsr->Cpage().ReplaceFlags( pcsr->ILine(), kdf.fFlags | fFlag );

#ifdef DEBUG_NODE
	NDIGetKeydataflags( pcsr->Cpage(), pcsr->ILine(), &kdf );
	Assert( kdf.fFlags & fFlag );	//  assert the flag is set
#endif	//  DEBUG_NODE
	}


//  ================================================================
INLINE VOID NDIResetFlag( CSR * pcsr, INT fFlag )
//  ================================================================
	{
	Assert( pcsr );

	KEYDATAFLAGS kdf;
	NDIGetKeydataflags( pcsr->Cpage(), pcsr->ILine(), &kdf );
///	Assert( kdf.fFlags & fFlag );	//  unsetting a flag that is not set?!
	pcsr->Cpage().ReplaceFlags( pcsr->ILine(), kdf.fFlags & ~fFlag );

#ifdef DEBUG_NODE
	NDIGetKeydataflags( pcsr->Cpage(), pcsr->ILine(), &kdf );
	Assert( !( kdf.fFlags & fFlag ) );
#endif	//  DEBUG_NODE
	}


//  ================================================================
INT IlineNDISeekGEQ( const CPAGE& cpage, const BOOKMARK& bm, const BOOL fUnique, INT * plastCompare )
//  ================================================================
//
//  finds the first item greater or equal to the
//  given bookmark, returning the result of the last comparison
//
//-
	{
	Assert( cpage.FLeafPage() );
	
	const INT		clines 		= cpage.Clines( );	
	Assert( clines > 0 );	// will not work on an empty page
	INT				ilineFirst	= 0;
	INT				ilineLast	= clines - 1;
	INT				ilineMid	= 0;
	INT				iline		= -1;
	INT				compare		= 0;
	BOOKMARK		bmNode;

	while( ilineFirst <= ilineLast )	
		{
		ilineMid = (ilineFirst + ilineLast)/2;
		NDIGetBookmark( cpage, ilineMid, &bmNode, fUnique );
		compare = CmpKeyData( bmNode, bm );
			
		if ( compare < 0 )
			{
			//  the midpoint item is less than what we are looking for. look in top half
			ilineFirst = ilineMid + 1;
			}
		else if ( 0 == compare )
			{
			//  we have found the item
			iline = ilineMid;
			break;
			}
		else	// ( compare > 0 )
			{
			//  the midpoint item is greater than what we are looking for. look in bottom half
			ilineLast = ilineMid;
			if ( ilineLast == ilineFirst )
				{
				iline = ilineMid;
				break;
				}
			}
		}

	if( 0 != compare && 0 == bm.data.Cb() )
		{
		*plastCompare = CmpKey( bmNode.key, bm.key );	//lint !e772
		}
	else
		{
		*plastCompare = compare;
		}
			
#ifdef DEBUG_NODE_SEEK
	INT compareT;
	const INT	ilineT = IlineNDISeekGEQDebug( pfucb, cpage, bm, &compareT );
	if ( ilineT >= 0 )
		{
		if ( compareT > 0 )
			{
			Assert( *plastCompare > 0 );
			}
		else if ( compareT < 0 )
			{
			Assert( *plastCompare < 0 );
			}
		else
			{
			Assert( 0 == *plastCompare );
			}
		}
	Assert( ilineT == iline );
#endif
	return iline;
	}


//  ================================================================
INT IlineNDISeekGEQInternal(
	const CPAGE& cpage,
	const BOOKMARK& bm,
	INT * plastCompare )
//  ================================================================
//
//	seeks for bookmark in an internal page. We use binary search. At any
//  time the iline ilineLast is >= bm. To preserve this we include the
//  midpoint in the new range when the item we are seeking for is in the
//  lower half of the range.
//
//-
	{
	Assert( !cpage.FLeafPage() || fGlobalRepair );
	
	const INT		clines 		= cpage.Clines( );	
	Assert( clines > 0 );	// will not work on an empty page
	KEYDATAFLAGS	kdfNode;
	INT				ilineFirst	= 0;
	INT				ilineLast	= clines - 1;
	INT				ilineMid	= 0;
	INT				compare		= 0;

	LINE			lineExternalHeader;
	LINE			line;
	cpage.GetPtrExternalHeader( &lineExternalHeader );
	kdfNode.key.prefix.SetPv( lineExternalHeader.pv );

	while( ilineFirst <= ilineLast )
		{
		ilineMid = (ilineFirst + ilineLast)/2;

		cpage.GetPtr( ilineMid, &line );
		NDILineToKeydataflags( &line, &kdfNode );
		Assert( kdfNode.key.prefix.Pv() == lineExternalHeader.pv );
		
		Assert( sizeof( PGNO ) == kdfNode.data.Cb() );
		compare = CmpKeyWithKeyData( kdfNode.key, bm );

		if ( compare < 0 )
			{
			//  the midpoint item is less than what we are looking for. look in top half
			ilineFirst = ilineMid + 1;
			}
		else if ( 0 == compare )
			{
			//  we have found the item
			break;
			}
		else	// ( compare > 0 )
			{
			//  the midpoint item is greater than what we are looking for. look in bottom half
			ilineLast = ilineMid;
			if ( ilineLast == ilineFirst )
				{
				break;
				}
			}
		}

	Assert( ilineMid >= 0 );
	Assert( ilineMid < clines );

	if ( 0 == compare )
		{
		//  we found the item
		*plastCompare = 0;
		}
	else
		{
		*plastCompare	= 1;
		}

#ifdef DEBUG_NODE_SEEK
	INT compareT;
	const INT	ilineT = IlineNDISeekGEQInternalDebug( cpage, bm, &compareT );
	if ( compareT > 0 )
		{
		Assert( *plastCompare > 0 );
		}
	else if ( compareT < 0 )
		{
		Assert( *plastCompare < 0 );
		}
	else
		{
		Assert( 0 == *plastCompare );
		}
	Assert( ilineT == ilineMid );
#endif

	return ilineMid;
	}


#ifdef DEBUG_NODE_SEEK
//  ================================================================
LOCAL INT IlineNDISeekGEQDebug( const FUCB * pfucb, const CPAGE& cpage, const BOOKMARK& bm, INT * plastCompare )
//  ================================================================
//
//  finds the first item greater or equal to the
//  given bookmark, returning the result of the last comparison
//
//-
	{
	Assert( cpage.FLeafPage() );
	
	const INT		clines 	= cpage.Clines( );
	BOOKMARK		bmNode;

	INT				iline	= 0;
	for ( ; iline < clines; iline++ )
		{
		NDIGetBookmark( cpage, iline, &bmNode, FFUCBUnique( pfucb ) );
		INT cmp = CmpKey( bmNode.key, bm.key );
		
		if ( cmp < 0 )
			{
			//  keep on looking
			}
		else if ( cmp > 0 || bm.data.Cb() == 0 )
			{
			Assert( cmp > 0 || 
					bm.data.Cb() == 0 && cmp == 0 );
			*plastCompare = cmp;
			return iline;
			}
		else
			{
			//	key is same
			//	check data -- only if we are seeking for a key-data
			Assert( cmp == 0 );
			Assert( bm.data.Cb() != 0 );

			cmp = CmpData( bmNode.data, bm.data );
			if ( cmp >= 0 )
				{
				*plastCompare = cmp;
				return iline;
				}
			}
		}

	return -1;
	}

	
//  ================================================================
LOCAL INT IlineNDISeekGEQInternalDebug(
	const CPAGE& cpage,
	const BOOKMARK& bm,
	INT * plastCompare )
//  ================================================================
//
//	seeks for bookmark in an internal page
//
//-
	{
	Assert( !cpage.FLeafPage() );
	
	const INT		clines = cpage.Clines( ) - 1;
	KEYDATAFLAGS	kdfNode;
	INT				iline;

	for ( iline = 0; iline < clines; iline++ )
		{
		NDIGetKeydataflags ( cpage, iline, &kdfNode );
		Assert( sizeof( PGNO ) == kdfNode.data.Cb() );

		const INT compare = CmpKeyWithKeyData( kdfNode.key, bm );
		if ( compare < 0 )
			{
			//  keep on looking
			}
		else
			{
			Assert( compare >= 0 );
			*plastCompare = compare;
			return iline;
			}
		}

	//	for internal pages
	//	last key or NULL is greater than everything else
#ifdef DEBUG
	Assert( cpage.Clines() - 1 == iline );
	NDIGetKeydataflags( cpage, iline, &kdfNode );
	Assert( kdfNode.key.FNull() ||
			CmpKeyWithKeyData( kdfNode.key, bm ) > 0 );
#endif

	*plastCompare = 1;
	return iline;
	}

#endif	//	DEBUG_NODE_SEEK


//  ================================================================
LOCAL ERR ErrNDISeekInternalPage( CSR * pcsr, const BOOKMARK& bm )
//  ================================================================
//
//	Seek on an internal page never returns wrnNDFoundLess
//	if bookmark.data is not null, never returns wrnNDEqual
//
//-
	{
	ASSERT_VALID( &bm );

	ERR			err;
	INT			compare;
	const INT	iline	= IlineNDISeekGEQInternal( pcsr->Cpage(), bm, &compare );	
	Assert( iline >= 0 );
	Assert( iline < pcsr->Cpage().Clines( ) );

	if ( 0 == compare )
		{
		//  we found an exact match
		//	page delimiter == bookmark of search 
		//	the cursor is placed on node next to S
		//	because no node in the subtree rooted at S 
		//	can have a key == XY -- such cursor placement obviates a moveNext at BT level
		//	Also, S can not be the last node in page because if it were,
		//	we would not have seeked down to this page!
		pcsr->SetILine( iline + 1 );
		err = JET_errSuccess;
		}
	else
		{
		//  we are on the first node greater than the BOOKMARK
		pcsr->SetILine( iline );
		err = ErrERRCheck( wrnNDFoundGreater );
		}

	return err;
	}

			
//  ================================================================
LOCAL ERR ErrNDISeekLeafPage( const FUCB * pfucb, CSR * pcsr, const BOOKMARK& bm )
//  ================================================================
//
//	Seek on leaf page returns wrnNDFoundGreater/Less/Equal
//
//-
	{
	ASSERT_VALID( &bm );

	ERR			err;
	INT			compare;
	const INT	iline	= IlineNDISeekGEQ(
											pcsr->Cpage(), 
											bm, 
											FFUCBUnique( pfucb ),	//	UNDONE: can't uniqueness be determined by the cpage flags?
											&compare );
	Assert( iline < pcsr->Cpage().Clines( ) );

	if ( iline >= 0 && 0 == compare )
		{
		//  great! we found the node 
		pcsr->SetILine( iline );
		err = JET_errSuccess;
		}
	else if ( iline < 0 )
		{
		//	all nodes in page are less than XY
		//  place cursor on last node in page;
		pcsr->SetILine( pcsr->Cpage().Clines( ) - 1 );
		err = ErrERRCheck( wrnNDFoundLess );
		}
	else
		{
		//	node S exists && key-data(S) > XY
		pcsr->SetILine( iline );
		err = ErrERRCheck( wrnNDFoundGreater );
		}

	return err;
	}


//  ****************************************************************
//  EXTERNAL ROUTINES
//  ****************************************************************


//  ================================================================
VOID NDMoveFirstSon( FUCB * pfucb, CSR * pcsr )
//  ================================================================
	{
	NDIAssertCurrency( pfucb, pcsr );

	pcsr->SetILine( 0 );
	NDGet( pfucb, pcsr );
	}


//  ================================================================
VOID NDMoveLastSon( FUCB * pfucb, CSR * pcsr )
//  ================================================================
	{
	NDIAssertCurrency( pfucb, pcsr );
	
	pcsr->SetILine( pcsr->Cpage().Clines() - 1 );
	NDGet( pfucb, pcsr );
	}

//  ================================================================
ERR ErrNDFModified( FUCB * pfucb, BOOL * pfModified )
//  ================================================================
//
//	returns true if the node was modified by calling session
//
//-
	{
	ERR				err						= JET_errSuccess;
	
	ASSERT_VALID( pfucb );
	AssertBTType( pfucb );
	AssertNDGet( pfucb );

	//	if session cursor isolation model is not dirty and node
	//	has version, then call version store for appropriate version.
	//
	if ( FNDPossiblyVersioned( pfucb, Pcsr( pfucb ) )  )
		{
		//	get bookmark from node in page
		//
		BOOKMARK		bm;
		
		NDGetBookmarkFromKDF( pfucb, pfucb->kdfCurr, &bm );
		
		Call( ErrVERFModified( pfucb, bm, pfModified ) );
		}
	else
		{
		*pfModified = fFalse;
		}
		
HandleError:
	return err;
	}

//  ================================================================
ERR ErrNDVisibleToCursor( FUCB * pfucb, BOOL * pfVisibleToCursor )
//  ================================================================
//
//	returns true if the node, as seen by cursor, exists
//	and is not deleted
//
//-
	{
	ERR				err						= JET_errSuccess;
	BOOL			fVisible;
	
	ASSERT_VALID( pfucb );
	AssertBTType( pfucb );
	AssertNDGet( pfucb );

	//	if session cursor isolation model is not dirty and node
	//	has version, then call version store for appropriate version.
	if ( FNDPossiblyVersioned( pfucb, Pcsr( pfucb ) )
		&& !FPIBDirty( pfucb->ppib ) )
		{
		//	get bookmark from node in page
		BOOKMARK		bm;
		
		NDGetBookmarkFromKDF( pfucb, pfucb->kdfCurr, &bm );
		
		NS ns;
		Call( ErrVERAccessNode( pfucb, bm, &ns ) );
		switch( ns )
			{
			case nsVersion:
			case nsVerInDB:
				fVisible = fTrue;
				break;
			case nsDatabase:
				fVisible = !FNDDeleted( pfucb->kdfCurr );
				break;
			case nsNone:
			case nsInvalid:
			default:
				Assert( nsInvalid == ns );
				fVisible = fFalse;
				break;
			}
		}
	else
		{
		fVisible = !FNDDeleted( pfucb->kdfCurr );
		}

	*pfVisibleToCursor = fVisible;

HandleError:
	Assert( JET_errSuccess == err || 0 == pfucb->ppib->level );
	return err;
	}


//  ================================================================
BOOL FNDPotVisibleToCursor( const FUCB * pfucb, CSR * pcsr )
//  ================================================================
//
//	returns true if node, as seen by cursor,
//	potentially exists
//	i.e., node is uncommitted by other or not deleted in page
//
//-
	{
	ASSERT_VALID( pfucb );

	BOOL	fVisible = !( FNDDeleted( pfucb->kdfCurr ) );

	//	if session cursor isolation model is not dirty and node
	//	has version, then call version store for appropriate version.

	//	UNDONE: Use FNDPossiblyVersioned() if this function
	//	is called in any active code paths (currently, it's
	//	only called in DEBUG code or in code paths that
	//	should be impossible

	if ( FNDVersion( pfucb->kdfCurr )
		&& !FPIBDirty( pfucb->ppib ) )
		{
		BOOKMARK	bm;
		NDGetBookmarkFromKDF( pfucb, pfucb->kdfCurr, &bm );
		const VS vs = VsVERCheck( pfucb, pcsr, bm );
		fVisible = FVERPotThere( vs, !fVisible );
		}

	return fVisible;
	}


//  ================================================================
VOID NDBulkDelete( CSR * pcsr, INT clines )
//  ================================================================
//
//	deletes clines lines from current position in page
//		- expected to be at the end of page
//
//-
	{
	ASSERT_VALID( pcsr );
	Assert( pcsr->Cpage().FAssertWriteLatch( ) );
	Assert( pcsr->FDirty() );
	Assert( 0 <= clines );
	Assert( pcsr->ILine() >= 0 );
	Assert( pcsr->Cpage().Clines() == pcsr->ILine() + clines );

	//	delete lines from the end to avoid reorganization of tag array
	INT	iline = pcsr->ILine() + clines - 1;
	for ( ; iline >= pcsr->ILine(); --iline )
		{
		Assert( pcsr->Cpage().Clines() - 1 == iline );
		pcsr->Cpage().Delete( iline );
		}
	}


//  ================================================================
VOID NDInsert( FUCB *pfucb, CSR * pcsr, const KEYDATAFLAGS * pkdf, INT cbPrefix )
//  ================================================================
//
//	inserts node into page at current cursor position
//	cbPrefix bytes of *pkdf is prefix key part
//	no logging/versioning
//	used by split to perform split operation
//
//-
	{
#ifdef DEBUG
	if( pfucbNil != pfucb )
		{
		ASSERT_VALID( pfucb );
		Assert( pfucb->ppib->level > 0 || !rgfmp[pfucb->ifmp].FLogOn() );
		}
	ASSERT_VALID( pcsr );
	Assert( pcsr->Cpage().FAssertWriteLatch( ) );
	Assert( pcsr->FDirty() );
	ASSERT_VALID( pkdf );
#endif

	DATA			rgdata[cdataKDF+1];
	INT				fFlagsLine;
	KEYDATAFLAGS	kdf					= *pkdf;
	LE_KEYLEN		le_keylen;
	le_keylen.le_cbPrefix = (USHORT)cbPrefix;

	const INT 		cdata				= CdataNDIPrefixAndKeydataflagsToDataflags(
													&kdf,
													rgdata,
													&fFlagsLine,
													&le_keylen );
	Assert( cdata <= cdataKDF + 1 );

	pcsr->Cpage().Insert( pcsr->ILine(), 
						  rgdata, 
						  cdata,
						  fFlagsLine );

#ifdef DEBUG_NODE_INSERT
	if( pfucbNil != pfucb )
		{
		NDAssertNDInOrder( pfucb, pcsr );
		}
#endif	// DEBUG_NODE
	}


//  ================================================================
VOID NDInsert( FUCB *pfucb, CSR * pcsr, const KEYDATAFLAGS * pkdf )
//  ================================================================
//
//	inserts node into page at current cursor position
//	no logging/versioning
//	used by split to perform split operation
//
//-
	{
	ASSERT_VALID( pfucb );
	ASSERT_VALID( pcsr );
	Assert( pcsr->Cpage().FAssertWriteLatch( ) );
	Assert( pcsr->FDirty() );
	ASSERT_VALID( pkdf );
	Assert( pfucb->ppib->level > 0 || !rgfmp[pfucb->ifmp].FLogOn() );

	DATA		rgdata[cdataKDF];
	INT			fFlagsLine;
	LE_KEYLEN	le_keylen;
	const INT	cdata			= CdataNDIKeydataflagsToDataflags(
											pkdf,
											rgdata,
											&fFlagsLine,
											&le_keylen );
	pcsr->Cpage().Insert( pcsr->ILine(), 
						  rgdata, 
						  cdata,
						  fFlagsLine );
	Assert( cdata <= cdataKDF );

#ifdef DEBUG_NODE_INSERT
	NDAssertNDInOrder( pfucb, pcsr );
#endif	// DEBUG_NODE

	NDGet( pfucb, pcsr );
	}


//  ================================================================
VOID NDReplaceForUpgrade(
	CPAGE * const pcpage,
	const INT iline,
	const DATA * const pdata,
	const KEYDATAFLAGS& kdfOld )
//  ================================================================
//
//	replaces data in page at current cursor position
//	no logging/versioning
//	used by upgrade to change record format
//  does not do a NDGet!
//
//-
	{
	KEYDATAFLAGS	kdf = kdfOld;
	DATA 			rgdata[cdataKDF];
	INT  			fFlagsLine;
	LE_KEYLEN		le_keylen;

#ifdef DEBUG
	//	make sure the correct KDF was passed in
	KEYDATAFLAGS kdfDebug;
	NDIGetKeydataflags( *pcpage, iline, &kdfDebug );
	Assert( kdfDebug.key.prefix.Pv() == kdfOld.key.prefix.Pv() );
	Assert( kdfDebug.key.prefix.Cb() == kdfOld.key.prefix.Cb() );
	Assert( kdfDebug.key.suffix.Pv() == kdfOld.key.suffix.Pv() );
	Assert( kdfDebug.key.suffix.Cb() == kdfOld.key.suffix.Cb() );
	Assert( kdfDebug.data.Pv() == kdfOld.data.Pv() );
	Assert( kdfDebug.data.Cb() == kdfOld.data.Cb() );
#endif	//	DEBUG

	Assert( kdf.data.Cb() >= pdata->Cb() );	//	cannot grow the record as we have pointers to data on the page
	kdf.data = *pdata;

	const INT	cdata		= CdataNDIKeydataflagsToDataflags(
										&kdf,
										rgdata,
										&fFlagsLine,
										&le_keylen );
	Assert( cdata <= ( sizeof( rgdata ) / sizeof( rgdata[0]) ) );
	
	pcpage->Replace( iline, rgdata, cdata, fFlagsLine );
	}


//  ================================================================
VOID NDReplace( CSR * pcsr, const DATA * pdata )
//  ================================================================
//
//	replaces data in page at current cursor position
//	no logging/versioning
//	used by split to perform split operation
//  does not do a NDGet!
//
//-
	{
	ASSERT_VALID( pcsr );
	Assert( pcsr->Cpage().FAssertWriteLatch( ) );
	Assert( pcsr->FDirty() );
	ASSERT_VALID( pdata );

	KEYDATAFLAGS	kdf;
	DATA 			rgdata[cdataKDF];
	INT  			fFlagsLine;
	LE_KEYLEN		le_keylen;

	//	get key and flags from page
	NDIGetKeydataflags( pcsr->Cpage(), pcsr->ILine(), &kdf );
	kdf.data = *pdata;

	//	replace node with new data
	const INT		cdata			= CdataNDIKeydataflagsToDataflags(
												&kdf,
												rgdata,
												&fFlagsLine,
												&le_keylen );
	Assert( cdata <= cdataKDF );
	pcsr->Cpage().Replace( pcsr->ILine(), rgdata, cdata, fFlagsLine );
	}


//  ================================================================
VOID NDDelete( CSR *pcsr )
//  ================================================================
//
//	deletes node from page at current cursor position
//	no logging/versioning
//
//-
	{
	ASSERT_VALID( pcsr );
	Assert( pcsr->Cpage().FAssertWriteLatch( ) );
	Assert( pcsr->FDirty() );
	Assert( pcsr->ILine() < pcsr->Cpage().Clines() );
	
	pcsr->Cpage().Delete( pcsr->ILine() );
	}


//  ================================================================
ERR ErrNDSeek( FUCB * pfucb, CSR * pcsr, const BOOKMARK& bookmark )
//  ================================================================
	{
	ASSERT_VALID( pfucb );
	ASSERT_VALID( pcsr );
	ASSERT_VALID( &bookmark );
	AssertSz( pcsr->Cpage().Clines() > 0, "Seeking on an empty page" );

	const BOOL	fInternalPage	= !pcsr->Cpage().FLeafPage();
	ERR			err				= JET_errSuccess;

	if ( fInternalPage )
		{
		err = ErrNDISeekInternalPage( pcsr, bookmark );
		}
	else
		{
		err = ErrNDISeekLeafPage( pfucb, pcsr, bookmark );
		}
	
	NDGet( pfucb, pcsr );
	return err; 
	}


//  ================================================================
VOID NDGet( FUCB * pfucb, const CSR * pcsr )
//  ================================================================
	{
	NDIAssertCurrencyExists( pfucb, pcsr );

	KEYDATAFLAGS keydataflags;
	NDIGetKeydataflags( pcsr->Cpage(), pcsr->ILine(), &keydataflags );
	pfucb->kdfCurr = keydataflags;
	pfucb->fBookmarkPreviouslySaved = fFalse;
	}


//  ================================================================
ERR ErrNDInsert(
		FUCB * const pfucb,
		CSR * const pcsr,
		const KEYDATAFLAGS * const pkdf,
		const DIRFLAG dirflag,
		const RCEID rceid,
		const VERPROXY * const pverproxy )
//  ================================================================
	{
	NDIAssertCurrency( pfucb, pcsr );
	ASSERT_VALID( pkdf );
	Assert( pcsr->Cpage().FAssertWriteLatch( ) );
	Assert( NULL == pverproxy || proxyCreateIndex == pverproxy->proxy );
	
	ERR			err				= JET_errSuccess;
	const BOOL	fVersion		= !( dirflag & fDIRNoVersion ) && !rgfmp[pfucb->ifmp].FVersioningOff();
	const BOOL	fLogging		= !( dirflag & fDIRNoLog ) && rgfmp[pfucb->ifmp].FLogOn();

	KEYDATAFLAGS kdfT = *pkdf;
	
	Assert( !fLogging || pfucb->ppib->level > 0 );
	Assert( !fVersion || rceidNull != rceid );
	Assert( !fVersion || !PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering );

	//	BUGFIX #151574: caller should have already ascertained that the node will
	//	fit on the page, but at that time, the caller may not have had the
	//	write-latch on the page and couldn't update the cbUncommittedFree, so
	//	now that we have the write-latch, we have re-compute to guarantee that
	//	the cbFree doesn't become less than the cbUncommittedFree
	const ULONG	cbReq			= CbNDNodeSizeCompressed( kdfT );
	if ( cbReq > pcsr->Cpage().CbFree( ) - pcsr->Cpage().CbUncommittedFree( ) )
		{
		//	this call to FNDFreePageSpace() is now guaranteed to succeed and
		//	update the cbUncommittedFree if necessary
		const BOOL	fFreePageSpace	= FNDFreePageSpace( pfucb, pcsr, cbReq );
		Assert( fFreePageSpace );

		//	now that we have the write-latch on the page, we are guaranteed to
		//	be able to upgrade cbUncommittedFree on the page, and that in turn
		//	should guarantee that we should now have enough page space, so we
		//	Enforce() this to ensure we don't corrupt the page
		Enforce( cbReq <= pcsr->Cpage().CbFree() - pcsr->Cpage().CbUncommittedFree() );
		}

	if ( fLogging )
		{
		//	log the operation, getting the lgpos
		LGPOS	lgpos;

		Call( ErrLGInsert( pfucb, pcsr, kdfT, rceid, dirflag, &lgpos, pverproxy, fMustDirtyCSR ) );
		pcsr->Cpage().SetLgposModify( lgpos );
		}
	else
		{
		pcsr->Dirty( );
		}

	//	insert operation can not fail after this point
	//	since we have already logged the operation
	if( fVersion )
		{
		kdfT.fFlags |= fNDVersion;
		}
	NDInsert( pfucb, pcsr, &kdfT );
	NDGet( pfucb, pcsr );

HandleError:
	Assert( JET_errSuccess == err || fLogging );
#ifdef DEBUG_NODE_INSERT
	NDAssertNDInOrder( pfucb, pcsr );
#endif	// DEBUG_NODE_INSERT

	return err;
	}


INLINE ERR ErrNDILogReplace(
	FUCB			* const pfucb,
	CSR				* const pcsr,
	const DATA&		data,
	const DIRFLAG	dirflag,
	const RCEID		rceid )
	{
	ERR				err;
	DATA			dataDiff;
	SIZE_T			cbDiff					= 0;
	BOOL			fDiffBufferAllocated	= fFalse;

	AssertNDGet( pfucb, pcsr );		// logdiff needs access to kdfCurr

	if ( dirflag & fDIRLogColumnDiffs )
		{
		Assert( data.Cb() <= cbRECRecordMost );
		dataDiff.SetPv( PvOSMemoryHeapAlloc( cbRECRecordMost ) );
		if ( NULL != dataDiff.Pv() )
			{
			fDiffBufferAllocated = fTrue;
			LGSetColumnDiffs(
					pfucb,
					data,
					pfucb->kdfCurr.data,
					(BYTE *)dataDiff.Pv(),
					&cbDiff );
			Assert( cbDiff <= cbRECRecordMost );
			}
		}
	else if ( dirflag & fDIRLogChunkDiffs )
		{
		Assert( data.Cb() <= g_cbColumnLVChunkMost );
		dataDiff.SetPv( PvOSMemoryHeapAlloc( g_cbColumnLVChunkMost ) );
		if ( NULL != dataDiff.Pv() )
			{
			fDiffBufferAllocated = fTrue;
			LGSetLVDiffs(
					pfucb,
					data,
					pfucb->kdfCurr.data,
					(BYTE *)dataDiff.Pv(),
					&cbDiff );
			Assert( cbDiff <= g_cbColumnLVChunkMost );
			}
		}

	Assert( fDiffBufferAllocated || 0 == cbDiff );
	dataDiff.SetCb( cbDiff );

	//	log the operation, getting the lgpos
	LGPOS	lgpos;
	Call( ErrLGReplace( pfucb, 
						pcsr, 
						pfucb->kdfCurr.data, 
						data,
						( cbDiff > 0 ? &dataDiff : NULL ),
						rceid,
						dirflag, 
						&lgpos,
						fMustDirtyCSR ) );
	pcsr->Cpage().SetLgposModify( lgpos );

HandleError:
	if ( fDiffBufferAllocated )
		OSMemoryHeapFree( dataDiff.Pv() );

	return err;
	}

//  ================================================================
ERR ErrNDReplace(
		FUCB * const pfucb,
		CSR * const pcsr,
		const DATA * const pdata,
		const DIRFLAG dirflag,
		const RCEID rceid,
		const RCE * const prceReplace )
//  ================================================================
//
//  UNDONE: we only need to replace the data, not the key
//			the page level should take the length of the key
//			and not replace the data
//
//-
	{
	NDIAssertCurrencyExists( pfucb, pcsr );	//  we should have done a FlagReplace
	ASSERT_VALID( pdata );
	Assert( pcsr->Cpage().FAssertWriteLatch( ) );
	
	ERR			err			= JET_errSuccess;

	NDGet( pfucb, pcsr );
	const INT	cbDataOld	= pfucb->kdfCurr.data.Cb();
	const INT	cbReq 		= pdata->Cb() - cbDataOld;
	const BOOL	fDirty		= !( dirflag & fDIRNoDirty );

	if ( cbReq > 0 && !FNDFreePageSpace( pfucb, pcsr, cbReq ) )
		{
		//	requested space not available in page
		//	check if same node has enough uncommitted freed space to be used
		Assert( fDirty );

		const ULONG		cbReserved	= CbNDReservedSizeOfNode( pfucb, pcsr );
		if ( cbReq > cbReserved + pcsr->Cpage().CbFree() - pcsr->Cpage().CbUncommittedFree() )
			{
			err = ErrERRCheck( errPMOutOfPageSpace );
			Assert( fDirty );
			return err;
			}
		}

	const BOOL		fVersion			= !( dirflag & fDIRNoVersion ) && !rgfmp[pfucb->ifmp].FVersioningOff();
	const BOOL		fLogging			= !( dirflag & fDIRNoLog ) && rgfmp[pfucb->ifmp].FLogOn();
	Assert( !fLogging || pfucb->ppib->level > 0 );
	Assert( !fVersion || rceidNull != rceid );
	Assert( !fVersion || !PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering );
	Assert( ( prceNil == prceReplace ) == !fVersion || PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering );

	INT				cdata;
	INT  			fFlagsLine;
	KEYDATAFLAGS	kdf;
	DATA 			rgdata[cdataKDF+1];
	LE_KEYLEN		le_keylen;

	Assert( fDirty || pcsr->FDirty() );

	if ( fLogging )
		{
		//	we have to dirty
		Assert( fDirty );
		Call( ErrNDILogReplace(
					pfucb,
					pcsr,
					*pdata,
					dirflag,
					rceid ) );
		}
	else if ( fDirty )
		{
		pcsr->Dirty( );
		}

	//	operation cannot fail from here on

	//	get key and flags from fucb
	kdf.key 	= pfucb->bmCurr.key;
	kdf.data 	= *pdata;
	kdf.fFlags 	= pfucb->kdfCurr.fFlags | ( fVersion ? fNDVersion : 0 );

#ifdef DEBUG
		{
		AssertNDGet( pfucb, pcsr );

		KEYDATAFLAGS	kdfT;

		//	get key and flags from page. compare with bookmark
		NDIGetKeydataflags( pcsr->Cpage(), pcsr->ILine(), &kdfT );
		Assert( CmpKey( kdf.key, kdfT.key ) == 0 );
		}
#endif	//  DEBUG

	//	replace node with new data
	le_keylen.le_cbPrefix = USHORT( pfucb->kdfCurr.key.prefix.Cb() );
	cdata = CdataNDIPrefixAndKeydataflagsToDataflags( &kdf, rgdata, &fFlagsLine, &le_keylen );
	Assert( cdata <= cdataKDF + 1 );

	if ( prceNil != prceReplace && cbReq > 0 )
		{
		Assert( fVersion || PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering );
		//	set uncommitted freed space in page for growing node
		VERSetCbAdjust( pcsr, prceReplace, pdata->Cb(), cbDataOld, fDoUpdatePage );
		}

	pcsr->Cpage().Replace( pcsr->ILine(), rgdata, cdata, fFlagsLine );

	if ( prceNil != prceReplace && cbReq < 0 )
		{
		Assert( fVersion || PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering );
		//	set uncommitted freed space for shrinking node
		VERSetCbAdjust( pcsr, prceReplace, pdata->Cb(), cbDataOld, fDoUpdatePage );
		}

	NDGet( pfucb, pcsr );

HandleError:
	Assert( JET_errSuccess == err || fLogging );	
	return err;
	}


//  ================================================================
ERR ErrNDFlagInsert(
		FUCB * const pfucb,
		CSR * const pcsr,
		const DIRFLAG dirflag,
		const RCEID rceid,
		const VERPROXY * const pverproxy )
//  ================================================================
//
//  this is a flag-undelete with the correct logging and version store stuff
//
//-
	{
	NDIAssertCurrency( pfucb, pcsr );
	Assert( pcsr->Cpage().FAssertWriteLatch( ) );
	Assert( NULL == pverproxy || proxyCreateIndex == pverproxy->proxy );

	ERR			err				= JET_errSuccess;
	const BOOL	fVersion		= !( dirflag & fDIRNoVersion ) && !rgfmp[pfucb->ifmp].FVersioningOff();
	const BOOL	fLogging		= !( dirflag & fDIRNoLog ) && rgfmp[pfucb->ifmp].FLogOn();
	const BOOL	fDirty		= !( dirflag & fDIRNoDirty );
	Assert( !fLogging || pfucb->ppib->level > 0 );
	Assert( !fVersion || rceidNull != rceid );
	Assert( !fVersion || !PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering );

	NDGet( pfucb, pcsr );
	
	Assert( fDirty || pcsr->FDirty() );

	if ( fLogging )
		{		
		//	log the operation, getting the lgpos
		LGPOS	lgpos;

		// we have to dirty
		Assert (fDirty);
		
		Call( ErrLGFlagInsert( pfucb, pcsr, pfucb->kdfCurr, rceid, dirflag, &lgpos, pverproxy, fMustDirtyCSR ) );
		pcsr->Cpage().SetLgposModify( lgpos );
		}
	else
		{
		if ( fDirty )
			{
			pcsr->Dirty( );
			}
		}
	
	NDIResetFlag( pcsr, fNDDeleted );
	if ( fVersion )
		{
		NDISetFlag ( pcsr, fNDVersion );
		}
	NDGet( pfucb, pcsr );
		
HandleError:
	Assert( JET_errSuccess == err || fLogging );
#ifdef DEBUG_NODE_INSERT
	NDAssertNDInOrder( pfucb, pcsr );
#endif	// DEBUG_NODE_INSERT

	return err;
	}


//  ================================================================
ERR ErrNDFlagInsertAndReplaceData(
	FUCB				* const pfucb,
	CSR					* const pcsr,
	const KEYDATAFLAGS	* const pkdf,
	const DIRFLAG		dirflag,
	const RCEID			rceidInsert,
	const RCEID			rceidReplace,
	const RCE			* const prceReplace,
	const VERPROXY * const pverproxy )
//  ================================================================
	{
	NDIAssertCurrency( pfucb, pcsr );
	Assert( pkdf->data.Cb() > 0 );
	Assert( pcsr->Cpage().FAssertWriteLatch( ) );
	Assert( NULL == pverproxy || proxyCreateIndex == pverproxy->proxy );
	
	ERR			err				= JET_errSuccess;
	const BOOL	fVersion		= !( dirflag & fDIRNoVersion ) && !rgfmp[pfucb->ifmp].FVersioningOff();
	const BOOL	fLogging		= !( dirflag & fDIRNoLog ) && rgfmp[pfucb->ifmp].FLogOn();
	Assert( !fLogging || pfucb->ppib->level > 0 );
	Assert( !fVersion || rceidNull != rceidInsert );
	Assert( !fVersion || rceidNull != rceidReplace );
	Assert( !fVersion || prceNil != prceReplace );
	Assert( !fVersion || !PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering );

	NDGet( pfucb, pcsr );
	Assert( FNDDeleted( pfucb->kdfCurr ) );
	Assert( FKeysEqual( pkdf->key, pfucb->kdfCurr.key ) );

	const INT	cbDataOld	= pfucb->kdfCurr.data.Cb();
	const INT 	cbReq 		= pkdf->data.Cb() - cbDataOld;
							
	if ( cbReq > 0 && !FNDFreePageSpace ( pfucb, pcsr, cbReq ) )
		{
		//	requested space not available in page
		//	check if same node has enough uncommitted freed space to be used
		const ULONG		cbReserved	= CbNDReservedSizeOfNode( pfucb, pcsr );
		if ( cbReq > cbReserved + pcsr->Cpage().CbFree() - pcsr->Cpage().CbUncommittedFree() )
			{
			err = ErrERRCheck( errPMOutOfPageSpace );
			return err;
			}
		}
	
	KEYDATAFLAGS	kdf;
	INT 			cdata;
	DATA 			rgdata[cdataKDF+1];
	INT				fFlagsLine;
	LE_KEYLEN		le_keylen;

 				
	Assert( !(dirflag & fDIRNoDirty ) );

	if ( fLogging )
		{
		//	log the operation, getting the lgpos
		LGPOS	lgpos;

		Call( ErrLGFlagInsertAndReplaceData( pfucb, 
											 pcsr, 
											 *pkdf, 
											 rceidInsert,
											 rceidReplace,
											 dirflag, 
											 &lgpos,
											 pverproxy,
											 fMustDirtyCSR ) );
		pcsr->Cpage().SetLgposModify( lgpos );
		}
	else
		{
		pcsr->Dirty( );
		}
		
	//	get key from fucb
	kdf.key 		= pkdf->key;
	kdf.data 		= pkdf->data;
	kdf.fFlags 		= pfucb->kdfCurr.fFlags | ( fVersion ? fNDVersion : 0 );

	Assert( FKeysEqual( kdf.key, pfucb->kdfCurr.key ) );

	le_keylen.le_cbPrefix = USHORT( pfucb->kdfCurr.key.prefix.Cb() );

	//	replace node with new data
	cdata = CdataNDIPrefixAndKeydataflagsToDataflags(
					&kdf,
					rgdata,
					&fFlagsLine,
					&le_keylen );


	if ( prceNil != prceReplace && cbReq > 0 )
		{
		Assert( fVersion || PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering );
		//	set uncommitted freed space in page for growing node
		VERSetCbAdjust( pcsr, prceReplace, pkdf->data.Cb(), cbDataOld, fDoUpdatePage );
		}

	pcsr->Cpage().Replace( pcsr->ILine(), rgdata, cdata, fFlagsLine );

	if ( prceNil != prceReplace && cbReq < 0 )
		{
		Assert( fVersion || PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering );
		//	set uncommitted freed space for shrinking node
		VERSetCbAdjust( pcsr, prceReplace, pkdf->data.Cb(), cbDataOld, fDoUpdatePage );
		}
		
	NDIResetFlag( pcsr, fNDDeleted );
	
	NDGet( pfucb, pcsr );
	
HandleError:
	Assert( JET_errSuccess == err || fLogging );	
#ifdef DEBUG_NODE_INSERT
	NDAssertNDInOrder( pfucb, pcsr );
#endif	// DEBUG_NODE_INSERT

	return err;
	}


//  ================================================================
ERR ErrNDDelta(
		FUCB		* const pfucb,
		CSR			* const pcsr,
		const INT	cbOffset,
		const VOID	* const pv,
		const ULONG	cbMax,
		VOID		* const pvOld,
		const ULONG	cbMaxOld,
		ULONG		* const pcbOldActual,
		const DIRFLAG	dirflag,
		const RCEID rceid )
//  ================================================================
//
//  No VERPROXY because it is not used by concurrent create index
//
	{
	NDIAssertCurrency( pfucb, pcsr );
	Assert( pcsr->Cpage().FAssertWriteLatch( ) );
	Assert( pv );
	Assert( sizeof( LONG ) == cbMax );

	const BOOL	fVersion		= !( dirflag & fDIRNoVersion ) && !rgfmp[pfucb->ifmp].FVersioningOff();
	const BOOL	fLogging		= !( dirflag & fDIRNoLog ) && rgfmp[pfucb->ifmp].FLogOn();
	const BOOL	fDirty			= !( dirflag & fDIRNoDirty );
	const LONG	lDelta			= *(UnalignedLittleEndian< LONG > *)pv;
	Assert( !fLogging || pfucb->ppib->level > 0 );
	Assert( !fVersion || rceidNull != rceid );
	Assert( !fVersion || !PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering );

	KEYDATAFLAGS keydataflags;
	NDIGetKeydataflags( pcsr->Cpage(), pcsr->ILine(), &keydataflags );
	Assert( cbOffset <= (INT)keydataflags.data.Cb() );
	Assert( cbOffset >= 0 );

	ERR						err		= JET_errSuccess;
	RCE				* 		prce	= prceNil;
	UnalignedLittleEndian< LONG > * const plDelta = (UnalignedLittleEndian< LONG > *)( (BYTE *)keydataflags.data.Pv() + cbOffset );

	BOOKMARK		bookmark;
	NDIGetBookmark( pcsr->Cpage(), pcsr->ILine(), &bookmark, FFUCBUnique( pfucb ) );

	if ( pvOld )
		{
		Assert( sizeof( LONG ) == cbMaxOld );
		//	Endian conversion
		*(LONG*)pvOld = *plDelta;
		if ( pcbOldActual )
			{
			*pcbOldActual = sizeof( LONG );
			}
		}

	Assert( fDirty || pcsr->FDirty() );

	if ( fLogging )
		{
		//	log the operation, getting the lgpos
		LGPOS	lgpos;

		// we have to dirty
		Assert (fDirty);
		
		Call( ErrLGDelta( pfucb, pcsr, bookmark, cbOffset, lDelta, rceid, dirflag, &lgpos, fMustDirtyCSR ) );
		pcsr->Cpage().SetLgposModify( lgpos );
		}
	else
		{
		if ( fDirty )
			{
			pcsr->Dirty( );
			}
		}

	//  we have a pointer to the data on the page so we can modify the data directly 
	*plDelta += lDelta;

	if ( fVersion )
		{
		NDISetFlag ( pcsr, fNDVersion );
		}

HandleError:
	Assert( JET_errSuccess == err || fLogging );
	return err;
	}


//  ================================================================
ERR ErrNDFlagDelete(
		FUCB * const pfucb,
		CSR * const pcsr,
		const DIRFLAG dirflag,
		const RCEID rceid,
		const VERPROXY * const pverproxy )
//  ================================================================
	{
	NDIAssertCurrency( pfucb, pcsr );
	Assert( pcsr->Cpage().FAssertWriteLatch( ) );
	Assert( NULL == pverproxy || proxyCreateIndex == pverproxy->proxy );

	const BOOL	fVersion		= !( dirflag & fDIRNoVersion ) && !rgfmp[pfucb->ifmp].FVersioningOff();
	const BOOL	fLogging		= !( dirflag & fDIRNoLog ) && rgfmp[pfucb->ifmp].FLogOn();
	const BOOL	fDirty		= !( dirflag & fDIRNoDirty );
	const ULONG fFlags		= fNDDeleted | ( fVersion ? fNDVersion : 0 );
	
	Assert( !fLogging || pfucb->ppib->level > 0 );
	Assert( !fVersion || rceidNull != rceid );
	Assert( !fVersion || !PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering );

	ERR			err				= JET_errSuccess;
	RCE			*prce			= prceNil;

	Assert( fDirty || pcsr->FDirty() );

	if ( fLogging )
		{
		//	log the operation, getting the lgpos 
		LGPOS	lgpos;

		// we have to dirty
		Assert (fDirty);

		Call( ErrLGFlagDelete( pfucb, pcsr, rceid, dirflag, &lgpos, pverproxy, fMustDirtyCSR ) );
		pcsr->Cpage().SetLgposModify( lgpos );
		}
	else
		{
		if ( fDirty )
			{
			pcsr->Dirty( );
			}
		}

	NDISetFlag( pcsr, fFlags );

HandleError:
	Assert( JET_errSuccess == err || fLogging );	
	return err;
	}


//  ================================================================
VOID NDResetFlagDelete( CSR * pcsr )
//  ================================================================
//
//  this is called by VER to undo. the undo	is already logged
//  so we don't need to log or version
//
//-
	{
	Assert( pcsr->ILine() >= 0 );
	Assert( pcsr->ILine() < pcsr->Cpage().Clines( ) );
	Assert( pcsr->Cpage().FAssertWriteLatch( ) );
	
	NDIResetFlag( pcsr, fNDDeleted );
	}


//  ================================================================
VOID NDDeferResetNodeVersion( CSR * pcsr )
//  ================================================================
//
//  we want to reset the bit but only flush the page if necessary
//  this will update the checksum
//
//-
	{
	Assert( pcsr->ILine() >= 0 );
	Assert( pcsr->ILine() < pcsr->Cpage().Clines( ) );

	LATCH latchOld;
	if ( pcsr->ErrUpgradeToWARLatch( &latchOld ) == JET_errSuccess )
		{
		NDIResetFlag( pcsr, fNDVersion );
		BFDirty( pcsr->Cpage().PBFLatch(), bfdfUntidy );
		pcsr->DowngradeFromWARLatch( latchOld );
		}
	}


//  ================================================================
VOID NDResetVersionInfo( CPAGE * const pcpage )
//  ================================================================
	{
	if ( pcpage->FLeafPage() && !pcpage->FSpaceTree() )
		{
		pcpage->ResetAllFlags( fNDVersion );
		pcpage->SetCbUncommittedFree( 0 );
		}
	}


//  ================================================================
ERR ErrNDFlagVersion( CSR * pcsr )
//  ================================================================
//
//  not logged
//
//-
	{
	Assert( pcsr->ILine() >= 0 );
	Assert( pcsr->ILine() < pcsr->Cpage().Clines( ) );
	Assert( pcsr->Cpage().FAssertWriteLatch( ) );
	Assert( pcsr->FDirty() );

	NDISetFlag( pcsr, fNDVersion );
	return JET_errSuccess;
	}


//  ================================================================
ERR ErrNDDelete( FUCB * pfucb, CSR * pcsr, const DIRFLAG dirflag )
//  ================================================================
//
//  delete is called by cleanup to delete *visible* nodes
//	that have been flagged as deleted.  This operation is logged
//	for redo only.
//
//-
	{
#ifdef DEBUG
	NDIAssertCurrency( pfucb, pcsr );
	Assert( pcsr->Cpage().FAssertWriteLatch( ) );
	NDGet( pfucb, pcsr );
	Assert( FNDDeleted( pfucb->kdfCurr ) ||
			!FNDVersion( pfucb->kdfCurr ) );
#endif

	ERR			err			= JET_errSuccess;
	const BOOL	fLogging	= !( dirflag & fDIRNoLog ) && rgfmp[pfucb->ifmp].FLogOn() && !PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering;
	Assert( !rgfmp[pfucb->ifmp].FLogOn() || !PinstFromIfmp( pfucb->ifmp )->m_plog->m_fLogDisabled );
	Assert( pfucb->ppib->level > 0 || !fLogging );

	Assert( !( dirflag & fDIRNoDirty ) );

	//	log the operation
	if ( fLogging )
		{
		LGPOS	lgpos;

		CallR( ErrLGDelete( pfucb, pcsr, &lgpos, fMustDirtyCSR ) );
		pcsr->Cpage().SetLgposModify( lgpos );
		}
	else
		{
		pcsr->Dirty( );
		}
	
	NDDelete( pcsr );
	
	return err;
	}


#ifdef DISABLE_SLV
#else

//  ================================================================
ERR ErrNDMungeSLVSpace( FUCB * const pfucb,
						CSR * const pcsr,
						const SLVSPACEOPER slvspaceoper,
						const LONG ipage,
						const LONG cpages,
						const DIRFLAG dirflag,
						const RCEID rceid )
//  ================================================================
	{
	NDIAssertCurrencyExists( pfucb, pcsr );
	Assert( pcsr->Cpage().FAssertWriteLatch( ) );

	FMP* const	pfmp		= &rgfmp[pfucb->ifmp];
	const BOOL	fLogging	= !( dirflag & fDIRNoLog ) && pfmp->FLogOn();
	const BOOL	fDirty		= !( dirflag & fDIRNoDirty );

	KEYDATAFLAGS keydataflags;
	NDIGetKeydataflags( pcsr->Cpage(), pcsr->ILine(), &keydataflags );
	
	BOOKMARK		bookmark;
	NDIGetBookmark( pcsr->Cpage(), pcsr->ILine(), &bookmark, FFUCBUnique( pfucb ) );

	Assert( sizeof( SLVSPACENODE ) == keydataflags.data.Cb() );
	SLVSPACENODE * const pslvspacenode = (SLVSPACENODE *)keydataflags.data.Pv();
	ASSERT_VALID( pslvspacenode );

	SLVSPACENODECACHE * const pslvspacenodecache = pfmp->Pslvspacenodecache();
	Assert( NULL != pslvspacenodecache 
			|| PinstFromPfucb( pfucb )->FRecovering() || fGlobalRepair );

	PGNO pgnoLast;
	LongFromKey( &pgnoLast, keydataflags.key );
	Assert( 0 == ( pgnoLast % SLVSPACENODE::cpageMap ) );

	//  before we log the operation, determine if it is a valid one
	//  otherwise, we would log the operation, crash and rollback and
	//  invalid transition -- possibly undoing previous, valid transitions
	switch( slvspaceoper )
		{
		case slvspaceoperFreeToReserved:
			pslvspacenode->CheckReserve( ipage, cpages );
			break;
		case slvspaceoperReservedToCommitted:
			pslvspacenode->CheckCommitFromReserved( ipage, cpages );
			break;
		case slvspaceoperFreeToCommitted:
			pslvspacenode->CheckCommitFromFree( ipage, cpages );
			break;
		case slvspaceoperCommittedToDeleted:
			pslvspacenode->CheckDeleteFromCommitted( ipage, cpages );
			break;
		case slvspaceoperDeletedToFree:
			pslvspacenode->CheckFree( ipage, cpages );
			break;
		case slvspaceoperFree:
			pslvspacenode->CheckFree( ipage, cpages );
			break;
		case slvspaceoperFreeReserved:
			pslvspacenode->CheckFreeReserved( ipage, cpages );
			break;
		case slvspaceoperDeletedToCommitted:
			pslvspacenode->CheckCommitFromDeleted( ipage, cpages );
			break;
 		default:
			AssertSz( fFalse, "Unknown SLVSPACEOPER" );
		}

	Assert( fDirty || pcsr->FDirty() );

	if ( fLogging )
		{
		ERR err;
		LGPOS	lgpos;

		// we have to dirty
		Assert (fDirty);
		
		CallR( ErrLGSLVSpace( pfucb, pcsr, bookmark, slvspaceoper, ipage, cpages, rceid, dirflag, &lgpos, fMustDirtyCSR ) );
		pcsr->Cpage().SetLgposModify( lgpos );
		}
	else
		{
		if ( fDirty )
			{
			pcsr->Dirty( );
			}
		}

	switch( slvspaceoper )
		{
		case slvspaceoperFreeToReserved:
			pslvspacenode->Reserve( ipage, cpages );
			if( pslvspacenodecache )
				{
				pslvspacenodecache->DecreaseCpgAvail( pgnoLast, cpages );
				}
			pfmp->IncSLVSpaceCount( SLVSPACENODE::sFree, -cpages );
			pfmp->IncSLVSpaceCount( SLVSPACENODE::sReserved, cpages );
			break;
		case slvspaceoperReservedToCommitted:
			pslvspacenode->CommitFromReserved( ipage, cpages );
			pfmp->IncSLVSpaceCount( SLVSPACENODE::sReserved, -cpages );
			pfmp->IncSLVSpaceCount( SLVSPACENODE::sCommitted, cpages );
			break;
		case slvspaceoperFreeToCommitted:
			pslvspacenode->CommitFromFree( ipage, cpages );
			if( pslvspacenodecache )
				{
				pslvspacenodecache->DecreaseCpgAvail( pgnoLast, cpages );
				}
			pfmp->IncSLVSpaceCount( SLVSPACENODE::sFree, -cpages );
			pfmp->IncSLVSpaceCount( SLVSPACENODE::sCommitted, cpages );
			break;
		case slvspaceoperCommittedToDeleted:
			pslvspacenode->DeleteFromCommitted( ipage, cpages );
			pfmp->IncSLVSpaceCount( SLVSPACENODE::sCommitted, -cpages );
			pfmp->IncSLVSpaceCount( SLVSPACENODE::sDeleted, cpages );
			break;
		case slvspaceoperDeletedToFree:
			pslvspacenode->Free( ipage, cpages );
			if( pslvspacenodecache )
				{
				pslvspacenodecache->IncreaseCpgAvail( pgnoLast, cpages );
				}
			pfmp->IncSLVSpaceCount( SLVSPACENODE::sDeleted, -cpages );
			pfmp->IncSLVSpaceCount( SLVSPACENODE::sFree, cpages );
			break;
		case slvspaceoperFree:
			{
			//  yeah, this isn't good but it only happens rarely
			LONG ipageT;
			LONG cpagesBI[ SLVSPACENODE::sMax ] = { 0 };
			for ( ipageT = ipage; ipageT < ipage + cpages; ipageT++ )
				{
				cpagesBI[ pslvspacenode->GetState( ipageT ) ]++;
				}
			Assert( cpages == cpagesBI[ SLVSPACENODE::sReserved ] + cpagesBI[ SLVSPACENODE::sCommitted ] + cpagesBI[ SLVSPACENODE::sDeleted ] );
			pslvspacenode->Free( ipage, cpages );
			if( pslvspacenodecache )
				{
				pslvspacenodecache->IncreaseCpgAvail( pgnoLast, cpages );
				}
			pfmp->IncSLVSpaceCount( SLVSPACENODE::sReserved, -cpagesBI[ SLVSPACENODE::sReserved ] );
			pfmp->IncSLVSpaceCount( SLVSPACENODE::sCommitted, -cpagesBI[ SLVSPACENODE::sCommitted ] );
			pfmp->IncSLVSpaceCount( SLVSPACENODE::sDeleted, -cpagesBI[ SLVSPACENODE::sDeleted ] );
			pfmp->IncSLVSpaceCount( SLVSPACENODE::sFree, cpages );
			}
			break;
		case slvspaceoperFreeReserved:
			{
			LONG cpagesFreed;
			pslvspacenode->FreeReserved( ipage, cpages, &cpagesFreed );
			if( pslvspacenodecache )
				{
				pslvspacenodecache->IncreaseCpgAvail( pgnoLast, cpagesFreed );
				}
			pfmp->IncSLVSpaceCount( SLVSPACENODE::sReserved, -cpagesFreed );
			pfmp->IncSLVSpaceCount( SLVSPACENODE::sFree, cpagesFreed );
			}
			break;
		case slvspaceoperDeletedToCommitted:
			pslvspacenode->CommitFromDeleted( ipage, cpages );
			pfmp->IncSLVSpaceCount( SLVSPACENODE::sDeleted, -cpages );
			pfmp->IncSLVSpaceCount( SLVSPACENODE::sCommitted, cpages );
			break;
 		default:
			AssertSz( fFalse, "Unknown SLVSPACEOPER" );
		}

	pfmp->IncSLVSpaceOperCount( slvspaceoper, cpages );

	return JET_errSuccess;
	}

#endif	//	DISABLE_SLV


//  ================================================================
VOID NDGetExternalHeader( KEYDATAFLAGS * const pkdf, const CSR * pcsr )
//  ================================================================
	{
	LINE line;
	pcsr->Cpage().GetPtrExternalHeader( &line );
	pkdf->key.Nullify();
	pkdf->data.SetCb( line.cb );
	pkdf->data.SetPv( line.pv );
	pkdf->fFlags 	= 0;
	}


//  ================================================================
VOID NDGetExternalHeader( FUCB * pfucb, const CSR * pcsr )
//  ================================================================
	{
	ASSERT_VALID( pfucb );
	ASSERT_VALID( pcsr );

	LINE line;
	pcsr->Cpage().GetPtrExternalHeader( &line );
	pfucb->kdfCurr.key.Nullify();
	pfucb->kdfCurr.data.SetCb( line.cb );
	pfucb->kdfCurr.data.SetPv( line.pv );
	pfucb->kdfCurr.fFlags 	= 0;
	}


//  ================================================================
VOID NDGetPrefix( FUCB * pfucb, const CSR * pcsr )
//  ================================================================
	{
	ASSERT_VALID( pfucb );
	ASSERT_VALID( pcsr );

	LINE line;
	pcsr->Cpage().GetPtrExternalHeader( &line );

	pfucb->kdfCurr.Nullify();
	pfucb->kdfCurr.fFlags = 0;

	if ( !pcsr->Cpage().FRootPage() )
		{
		pfucb->kdfCurr.key.prefix.SetPv( line.pv );
		pfucb->kdfCurr.key.prefix.SetCb( line.cb );
		}
	else if ( pcsr->Cpage().FSpaceTree() )
		{
		if ( line.cb >= sizeof( SPLIT_BUFFER ) )
			{
			pfucb->kdfCurr.key.prefix.SetPv( (BYTE *)line.pv + sizeof( SPLIT_BUFFER ) );
			pfucb->kdfCurr.key.prefix.SetCb( line.cb - sizeof( SPLIT_BUFFER ) );
			}
		else
			{
			Assert( 0 == line.cb );
			Assert( FFUCBSpace( pfucb ) );

/*	Can't make this assertion because sometimes we are calling this code without having
	setup the SPLIT_BUFFER (eg. merge of the space tree itself)
			//	split buffer may be missing from page if upgrading from ESE97 and it couldn't
			//	fit on the page, in which case it should be hanging off the FCB
			Assert( NULL != pfucb->u.pfcb->Psplitbuf( FFUCBAvailExt( pfucb ) )
				|| PinstFromPfucb( pfucb )->FRecovering() );
*/				
			pfucb->kdfCurr.key.prefix.SetPv( line.pv );
			pfucb->kdfCurr.key.prefix.SetCb( 0 );
			}
		}		
	else
		{
		Assert( line.cb >= sizeof( SPACE_HEADER ) );
		pfucb->kdfCurr.key.prefix.SetPv( (BYTE *)line.pv + sizeof( SPACE_HEADER ) );
		pfucb->kdfCurr.key.prefix.SetCb( line.cb - sizeof( SPACE_HEADER ) );
		}
	return;
	}


//  ================================================================
ERR ErrNDSetExternalHeader( FUCB * pfucb, CSR * pcsr, const DATA * pdata, DIRFLAG dirflag )
//  ================================================================
	{
	NDIAssertCurrency( pfucb, pcsr );
	ASSERT_VALID( pdata );
	Assert( pcsr->Cpage().FAssertWriteLatch( ) );

	ERR			err			= JET_errSuccess;
	const BOOL	fLogging	= !( dirflag & fDIRNoLog ) && rgfmp[pfucb->ifmp].FLogOn();
	
	if ( fLogging )
		{
		//	log the operation, getting the lgpos
		//
		LGPOS	lgpos;
		
		Call( ErrLGSetExternalHeader( pfucb, pcsr, *pdata, &lgpos, fMustDirtyCSR ) );
		pcsr->Cpage().SetLgposModify( lgpos );
		}
	else
		{
		pcsr->Dirty( );
		}
	
	pcsr->Cpage().SetExternalHeader( pdata, 1, 0 ); //  external header has no flags -- yet

HandleError:
	return err;
	}


//  ================================================================
VOID NDSetExternalHeader( FUCB * pfucb, CSR * pcsr, const DATA * pdata )
//  ================================================================
	{
	NDIAssertCurrency( pfucb, pcsr );
	ASSERT_VALID( pdata );
	Assert( pcsr->Cpage().FAssertWriteLatch( ) );

	Assert( pcsr->FDirty( ) );
	pcsr->Cpage().SetExternalHeader( pdata, 1, 0 ); //  external header has no flags -- yet
	return;
	}


//  ================================================================
VOID NDSetPrefix( CSR * pcsr, const KEY& key )
//  ================================================================
	{
	Assert( pcsr->Cpage().FAssertWriteLatch( ) );
	Assert( pcsr->FDirty() );

	//	JLIEM: if this is the source page of the split, I don't
	//	follow how we can guarantee this assert won't go off.
	//	Ultimately, it's probably okay because the cbUncommittedFree
	//	will eventually be set to the right value in BTISplitMoveNodes().
	Assert( pcsr->Cpage().CbFree( ) - pcsr->Cpage().CbUncommittedFree( ) >= key.Cb() );
	
	DATA			rgdata[cdataPrefix];
	INT				idata = 0;

	BYTE			rgexthdr[ max( sizeof(SPLIT_BUFFER), sizeof(SPACE_HEADER) ) ];

	if ( pcsr->Cpage().FRootPage() )
		{
		if ( key.FNull() )
			return;

		//	should currently be a dead code path because we never append prefix data to
		//	the SPLIT_BUFFER or SPACE_HEADER
		//	UNDONE: code below won't even work properly because it doesn't properly
		//	handle the case of the SPLIT_BUFFER being cached in the FCB
		Assert( fFalse );
			
		//	copy space header and reinsert
		const ULONG	cbExtHdr	= ( pcsr->Cpage().FSpaceTree() ? sizeof(SPLIT_BUFFER) : sizeof(SPACE_HEADER) );
		LINE		line;

		pcsr->Cpage().GetPtrExternalHeader( &line );
		if ( 0 != line.cb )
			{
			//	don't currently support prefix data following SPLIT_BUFFER/SPACE_HEADER
			Assert( line.cb == cbExtHdr );	
		
			UtilMemCpy( rgexthdr, line.pv, cbExtHdr );

			rgdata[idata].SetPv( rgexthdr );
			rgdata[idata].SetCb( cbExtHdr );
			++idata;
			}
		else
			{
			//	SPLIT_BUFFER must be cached in the FCB
			Assert( pcsr->Cpage().FSpaceTree() );
			}
		}
		
	rgdata[idata] = key.prefix;
	++idata;
	rgdata[idata] = key.suffix;
	++idata;

	pcsr->Cpage().SetExternalHeader( rgdata, idata, 0 ); //  external header has no flags -- yet
	}


//  ================================================================
VOID NDGrowCbPrefix( const FUCB *pfucb, CSR * pcsr, INT cbPrefixNew )
//  ================================================================
//
//	grows cbPrefix in current node to cbPrefixNew -- thereby shrinking node
//
//-
	{
	NDIAssertCurrency( pfucb, pcsr );
	AssertNDGet( pfucb, pcsr );
	Assert( pfucb->kdfCurr.key.prefix.Cb() < cbPrefixNew );
	Assert( pcsr->Cpage().FAssertWriteLatch( ) );
	Assert( pcsr->FDirty() );

	KEYDATAFLAGS	kdf = pfucb->kdfCurr;
	
	//	set node as compressed
	Assert( cbPrefixNew > cbPrefixOverhead );
	NDISetCompressed( kdf );

	DATA 		rgdata[cdataKDF+1];
	INT			fFlagsLine;
	LE_KEYLEN	le_keylen;
	le_keylen.le_cbPrefix = (USHORT)cbPrefixNew;

	//	replace node with new key
	const INT	cdata			= CdataNDIPrefixAndKeydataflagsToDataflags(
											&kdf,
											rgdata,
											&fFlagsLine,
											&le_keylen );
	Assert( cdata <= cdataKDF + 1 );
	pcsr->Cpage().Replace( pcsr->ILine(), rgdata, cdata, fFlagsLine );
	}


//  ================================================================
VOID NDShrinkCbPrefix( FUCB *pfucb, CSR * pcsr, const DATA *pdataOldPrefix, INT cbPrefixNew )
//  ================================================================
//
//	shrinks cbPrefix in current node to cbPrefixNew -- thereby growing node
//	expensive operation -- perf needed
//
//-
	{
	NDIAssertCurrency( pfucb, pcsr );
	AssertNDGet( pfucb, pcsr );
	Assert( pfucb->kdfCurr.key.prefix.Cb() > cbPrefixNew );
	Assert( pcsr->Cpage().FAssertWriteLatch( ) );
	Assert( pcsr->FDirty() );

	KEYDATAFLAGS	kdf = pfucb->kdfCurr;

	//	set flags in kdf to compressed
	//	point prefix to old prefix [which has been deleted]
	if ( cbPrefixNew > 0 )
		{
		Assert( cbPrefixNew > cbPrefixOverhead );
		NDISetCompressed( kdf );
		}
	else
		{
		NDIResetCompressed( kdf );
		}

	//	fix prefix to point to old prefix
	kdf.key.prefix.SetPv( pdataOldPrefix->Pv() );
	Assert( (INT)pdataOldPrefix->Cb() >= kdf.key.prefix.Cb() );
	Assert( kdf.key.prefix.Cb() == pfucb->kdfCurr.key.prefix.Cb() );

	BYTE *rgb;
//	BYTE	rgb[g_cbPageMax];
	BFAlloc( (VOID **)&rgb );
	
	kdf.key.suffix.SetPv( rgb );
	pfucb->kdfCurr.key.suffix.CopyInto( kdf.key.suffix );

	kdf.data.SetPv( rgb + kdf.key.suffix.Cb() );
	pfucb->kdfCurr.data.CopyInto( kdf.data );

	DATA 		rgdata[cdataKDF+1];
	INT  		fFlagsLine;
	LE_KEYLEN	le_keylen;
	le_keylen.le_cbPrefix = (USHORT)cbPrefixNew;

	//	replace node with new key
	const INT	cdata			= CdataNDIPrefixAndKeydataflagsToDataflags(
											&kdf,
											rgdata,
											&fFlagsLine,
											&le_keylen );
	Assert( cdata <= cdataKDF + 1 );
	pcsr->Cpage().Replace( pcsr->ILine(), rgdata, cdata, fFlagsLine );

	BFFree( rgb );
	}


//  ================================================================
INT CbNDUncommittedFree( const FUCB * const pfucb, const CSR * const pcsr )
//  ================================================================
	{
	ASSERT_VALID( pfucb );

	Assert( !pcsr->Cpage().FSpaceTree() );

	LONG	cbActualUncommitted		= 0;

	if ( pcsr->FPageRecentlyDirtied( pfucb->ifmp ) )
		{
		for ( INT iline = 0; iline < pcsr->Cpage().Clines( ); iline++ )
			{
			KEYDATAFLAGS keydataflags;
			NDIGetKeydataflags( pcsr->Cpage(), iline, &keydataflags );

			if ( FNDVersion( keydataflags ) )
				{
				BOOKMARK bookmark;
				NDIGetBookmark( pcsr->Cpage(), iline, &bookmark, FFUCBUnique( pfucb ) );

				cbActualUncommitted += CbVERGetNodeReserve( ppibNil, pfucb, bookmark, keydataflags.data.Cb() );
				}
			}
		}
	Assert(	cbActualUncommitted >= 0 );
	Assert( cbActualUncommitted <= pcsr->Cpage().CbFree() );
		
	return cbActualUncommitted;
	}


//  ****************************************************************
//  DEBUG ROUTINES
//  ****************************************************************

#ifdef DEBUG

//  ================================================================
INLINE VOID NDIAssertCurrency( const FUCB * pfucb, const CSR * pcsr )
//  ================================================================
	{
	ASSERT_VALID( pfucb );
	ASSERT_VALID( pcsr );
	
	Assert( pcsr->FLatched() );
#ifdef DEBUG_NODE
	NDAssertNDInOrder( pfucb, pcsr );
#endif	//	DEBUG_NODE
	}


//  ================================================================
INLINE VOID NDIAssertCurrencyExists( const FUCB * pfucb, const CSR * pcsr )
//  ================================================================
	{
	NDIAssertCurrency( pfucb, pcsr );
	Assert( pcsr->ILine() >= 0 );
	Assert( pcsr->ILine() < pcsr->Cpage().Clines( ) );
	}


//  ================================================================
VOID NDAssertNDInOrder( const FUCB * pfucb, const CSR * pcsr )
//  ================================================================
//
//	assert nodes in page are in bookmark order
//
//-
	{
	ASSERT_VALID( pfucb );
	ASSERT_VALID( pcsr );

	const INT 	clines 	= pcsr->Cpage().Clines( );

	//  we could optimize this loop by only fetching one node each time
	INT 		iline	=	0;
	for ( ;iline < (clines - 1); iline++ )
		{
		BOOKMARK	bmLess;
		BOOKMARK	bmGreater;

		NDIGetBookmark( pcsr->Cpage(), iline, &bmLess, FFUCBUnique( pfucb ) );
		NDIGetBookmark( pcsr->Cpage(), iline+1, &bmGreater, FFUCBUnique( pfucb ) );

		if ( bmGreater.key.FNull() )
			{
			//	if key is null, then must be last node in internal page
			Assert( !pcsr->Cpage().FLeafPage() || FFUCBRepair( pfucb ) );
			Assert( iline + 1 == clines - 1 );
			continue;
			}

		Assert( !bmLess.key.FNull() );
		const INT cmp = pcsr->Cpage().FLeafPage() ? 
							CmpBM( bmLess, bmGreater ) :
							CmpKey( bmLess.key, bmGreater.key );
		if (	cmp > 0 
				|| ( FFUCBUnique( pfucb ) && 0 == cmp ) ) 
			{
			AssertSz( fFalse, "NDAssertNDInOrder: node is out of order" );
			}
		}
	}

#endif		//  DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\mem.cxx ===
#include "std.hxx"


// PRIVATE:
const ULONG			MEMPOOL::cbChunkSize		= 256;		// If out of buffer space, increase by this many bytes.
const USHORT		MEMPOOL::ctagChunkSize		= 4;		// If out of tag space, increase by this many tags.
const USHORT		MEMPOOL::cMaxEntries		= 0xfff0;	// maximum number of tags
const MEMPOOL::ITAG	MEMPOOL::itagTagArray		= 0;		// itag 0 is reserved for the itag array itself
const MEMPOOL::ITAG	MEMPOOL::itagFirstUsable	= 1;		// First itag available for users


INLINE BOOL MEMPOOL::FResizeBuf( ULONG cbNewBufSize )
	{
	BYTE 		*pbuf;

	// Ensure we're not cropping off used space.
	Assert( IbBufFree() <= CbBufSize() );
	Assert( cbNewBufSize >= IbBufFree() );

	pbuf = (BYTE *)PvOSMemoryHeapAlloc( cbNewBufSize );
	if ( pbuf == NULL )
		return fFalse;

	// Copy the old buffer contents to the new, then delete the old buffer.
	UtilMemCpy( pbuf, Pbuf(), IbBufFree() );
	OSMemoryHeapFree( Pbuf() );
				
	// Buffer has relocated.
	SetPbuf( pbuf );
	SetCbBufSize( cbNewBufSize );

	return fTrue;
	}


INLINE BOOL MEMPOOL::FGrowBuf( ULONG cbNeeded )
	{
	return FResizeBuf( CbBufSize() + cbNeeded + cbChunkSize );
	}


INLINE ERR MEMPOOL::ErrGrowEntry( ITAG itag, ULONG cbNew )
	{
	MEMPOOLTAG	*rgbTags = (MEMPOOLTAG *)Pbuf();
	ITAG		itagCurrent;

	Assert( itag >= itagFirstUsable || itag == itagTagArray );

	//  get current tag

	const ULONG ibEntry	= rgbTags[itag].ib;
	const ULONG cbOld	= rgbTags[itag].cb;

	//  we had better be growing this tag

	Assert( cbNew > cbOld );

	//  align cbOld and cbNew

	ULONG cbOldAlign = cbOld + sizeof( QWORD ) - 1;
	cbOldAlign -= cbOldAlign % sizeof( QWORD );
	ULONG cbNewAlign = cbNew + sizeof( QWORD ) - 1;
	cbNewAlign -= cbNewAlign % sizeof( QWORD );

	//  compute the additional space that we will need

	const ULONG cbAdditional = cbNewAlign - cbOldAlign;

	// First ensure that we have enough buffer space to allow the entry
	// to enlarge.
	
	if ( CbBufSize() - IbBufFree() < cbAdditional )
		{
		if ( !FGrowBuf( cbAdditional - ( CbBufSize() - IbBufFree() ) ) )
			return ErrERRCheck( JET_errOutOfMemory );

		// Buffer likely relocated, so refresh.
		rgbTags = (MEMPOOLTAG *)Pbuf();
		}

	Assert( ( ibEntry + cbOld ) <= IbBufFree() );
	Assert( ( ibEntry + cbNew ) <= CbBufSize() );
	memmove( Pbuf() + ibEntry + cbNewAlign, Pbuf() + ibEntry + cbOldAlign, IbBufFree() - ( ibEntry + cbOldAlign ) );

	SetIbBufFree( IbBufFree() + cbAdditional );
	Assert( IbBufFree() <= CbBufSize() );

	// Fix up the tag array to match the byte movement of the buffer.
	for ( itagCurrent = itagFirstUsable; itagCurrent < ItagUnused(); itagCurrent++ )
		{
		// Ignore itags on the freed list.  Also ignore buffer space that occurs
		// before the space to be enlarged.
		if ( rgbTags[itagCurrent].cb > 0  &&  rgbTags[itagCurrent].ib > ibEntry )
			{
			Assert( rgbTags[itagCurrent].ib >= ibEntry + cbOldAlign );
			rgbTags[itagCurrent].ib += cbAdditional;
			Assert( rgbTags[itagCurrent].ib + rgbTags[itagCurrent].cb <= IbBufFree() );
			}
		}
	Assert( itagCurrent == ItagUnused() );

	// Update byte count.

	rgbTags[itag].cb = cbNew;

	return JET_errSuccess;
	}


INLINE VOID MEMPOOL::ShrinkEntry( ITAG itag, ULONG cbNew )
	{
	BYTE		*pbuf = Pbuf();
	MEMPOOLTAG	*rgbTags = (MEMPOOLTAG *)pbuf;
	ITAG		itagCurrent;

	Assert( itag >= itagFirstUsable );
	Assert( cbNew < rgbTags[itag].cb );

	//  get current tag

	const ULONG ibEntry	= rgbTags[itag].ib;
	const ULONG cbOld	= rgbTags[itag].cb;

	//  we had better be shrinking this tag

	Assert( cbNew < cbOld );

	//  align cbOld and cbNew

	ULONG cbOldAlign = cbOld + sizeof( QWORD ) - 1;
	cbOldAlign -= cbOldAlign % sizeof( QWORD );
	ULONG cbNewAlign = cbNew + sizeof( QWORD ) - 1;
	cbNewAlign -= cbNewAlign % sizeof( QWORD );

	//  compute the new ending offset and the space to delete

	const ULONG ibNewEnd = ibEntry + cbNewAlign;
	const ULONG cbDelete = cbOldAlign - cbNewAlign;

	// Remove the entry to be deleted by collapsing the buffer over
	// the space occupied by that entry.
	
	Assert( ibNewEnd > 0 );
	Assert( ibNewEnd >= rgbTags[itagTagArray].ib + rgbTags[itagTagArray].cb );
	Assert( ( ibNewEnd + cbDelete ) <= IbBufFree() );

	memmove( pbuf + ibNewEnd, pbuf + ibNewEnd + cbDelete, IbBufFree() - ( ibNewEnd + cbDelete ) );

	SetIbBufFree( IbBufFree() - cbDelete );
	Assert( IbBufFree() > 0 );
	Assert( IbBufFree() >= rgbTags[itagTagArray].ib + rgbTags[itagTagArray].cb );

	// Fix up the tag array to match the byte movement of the buffer.
	for ( itagCurrent = itagFirstUsable; itagCurrent < ItagUnused(); itagCurrent++ )
		{
		Assert( rgbTags[itagCurrent].ib != ibNewEnd  ||
			( itagCurrent == itag  &&  cbNew == 0 ) );

		// Ignore itags on the freed list.  Also ignore buffer space that occurs
		// before the space to be deleted.
		if ( rgbTags[itagCurrent].cb > 0  &&  rgbTags[itagCurrent].ib > ibNewEnd )
			{
			Assert( rgbTags[itagCurrent].ib >= ibNewEnd + cbDelete );
			rgbTags[itagCurrent].ib -= cbDelete;
			Assert( rgbTags[itagCurrent].ib >= ibNewEnd );
			Assert( rgbTags[itagCurrent].ib + rgbTags[itagCurrent].cb <= IbBufFree() );
			}
		}
	Assert( itagCurrent == ItagUnused() );

	rgbTags[itag].cb = cbNew;
	}


ERR MEMPOOL::ErrMEMPOOLInit(
	ULONG		cbInitialSize,
	USHORT		cInitialEntries,
	BOOL		fPadding )			// Pass TRUE if additional insertions will occur
	{
	MEMPOOLTAG	*rgbTags;
	BYTE		*pbuf;

	if ( cInitialEntries >= cMaxEntries )
		return ErrERRCheck( JET_errTooManyMempoolEntries );
		
	cInitialEntries++;			// Add one for the tag array itself

	if ( fPadding )
		{
		Assert ( cMaxEntries > ctagChunkSize );
		if ( cInitialEntries > cMaxEntries - ctagChunkSize )
			{
			fPadding = fFalse;
			}
		else
			{
			cInitialEntries += ctagChunkSize;
			}
		}
	
	Assert( cInitialEntries >= 1 );
	
	if ( cInitialEntries > cMaxEntries )
		return ErrERRCheck( JET_errTooManyMempoolEntries );

	ULONG cbTagArray		= cInitialEntries * sizeof( MEMPOOLTAG );
	ULONG cbTagArrayAlign	= cbTagArray + sizeof( QWORD ) - 1;
	cbTagArrayAlign			-= cbTagArrayAlign % sizeof( QWORD );

	if ( fPadding )
		{
		cbInitialSize += cbChunkSize;
		Assert( cbInitialSize > cbChunkSize );			// Overflow check
		}
		
	cbInitialSize += cbTagArrayAlign;
	Assert( cbInitialSize >= sizeof(MEMPOOLTAG) );		// At least one tag.
	Assert( cbInitialSize >= cbTagArrayAlign );			// Overflow check

	pbuf = (BYTE *)PvOSMemoryHeapAlloc( cbInitialSize );
	if ( pbuf == NULL )
		return ErrERRCheck( JET_errOutOfMemory );

	rgbTags = (MEMPOOLTAG *)pbuf;
	rgbTags[itagTagArray].ib = 0;		// tag array starts at beginning of memory
	rgbTags[itagTagArray].cb = cbTagArray;

	Assert( cbTagArrayAlign <= cbInitialSize );

	SetCbBufSize( cbInitialSize );
	SetIbBufFree( cbTagArrayAlign );
	SetItagUnused( itagFirstUsable );
	SetItagFreed( itagFirstUsable );
	SetPbuf( pbuf );
	
	return JET_errSuccess;
	}


// Add some bytes to the buffer and return an itag to its entry.
ERR MEMPOOL::ErrAddEntry( BYTE *rgb, ULONG cb, ITAG *piTag )
	{
	MEMPOOLTAG	*rgbTags;
	ULONG		cTotalTags;

	Assert( cb > 0 );
	Assert( piTag );

	AssertValid();					// Validate integrity of string buffer.
	rgbTags = (MEMPOOLTAG *)Pbuf();
	cTotalTags = rgbTags[itagTagArray].cb / sizeof(MEMPOOLTAG);

	// Check for tag space.
	if ( ItagFreed() < ItagUnused() )
		{
		// Re-use a freed iTag.
		*piTag = ItagFreed();
		Assert( rgbTags[ItagFreed()].cb == 0 );
		Assert( rgbTags[ItagFreed()].ib >= itagFirstUsable );

		//	The tag entry of the freed tag will point to the next freed tag.
		SetItagFreed( (ITAG)rgbTags[ItagFreed()].ib );
		Assert( rgbTags[ItagFreed()].cb == 0 || ItagFreed() == ItagUnused() );
		}

	else 
		{
		// No freed tags to re-use, so get the next unused tag.
		Assert( ItagFreed() == ItagUnused() );

		if ( ItagUnused() == cTotalTags )
			{
			ERR err;

			if ( cTotalTags + ctagChunkSize > cMaxEntries )
				return ErrERRCheck( JET_errOutOfMemory );

			// Tags all used up.  Allocate a new block of tags.
			err = ErrGrowEntry(
				itagTagArray,
				rgbTags[itagTagArray].cb + ( ctagChunkSize * sizeof(MEMPOOLTAG) ) );
			if ( err != JET_errSuccess )
				{
				Assert( err == JET_errOutOfMemory );
				return err;
				}

			cTotalTags += ctagChunkSize;
			
			rgbTags = (MEMPOOLTAG *)Pbuf();		// In case buffer relocated to accommodate growth.
			Assert( rgbTags[itagTagArray].cb == cTotalTags * sizeof(MEMPOOLTAG) );
			}

		*piTag = ItagUnused();
		SetItagFreed( ITAG( ItagFreed() + 1 ) );
		SetItagUnused( ITAG( ItagUnused() + 1 ) );
		}

	Assert( ItagFreed() <= ItagUnused() );
	Assert( ItagUnused() <= cTotalTags );

	//  init the tag to be zero sized at the end of the used buffer

	rgbTags[*piTag].ib = IbBufFree();
	rgbTags[*piTag].cb = 0;

	//  try to grow the tag to the requested size

	ERR err = ErrGrowEntry( *piTag, cb );
	rgbTags = (MEMPOOLTAG *)Pbuf();		// In case buffer relocated to accommodate growth.

	//  if we failed to grow the tag, return it to the freed list

	if ( err < JET_errSuccess )
		{
		Assert( err == JET_errOutOfMemory );
		
		Assert( rgbTags[*piTag].cb == 0 );
		rgbTags[*piTag].ib = ItagFreed();
		SetItagFreed( *piTag );
		*piTag = 0;
	
		return ErrERRCheck( JET_errOutOfMemory );
		}

	// If user passed in info, copy it to the buffer space allocated.
	// Otherwise, zero out the space allocated.
	
	if ( rgb )
		{
		UtilMemCpy( Pbuf() + rgbTags[*piTag].ib, rgb, cb );
		}
	else
		{
		memset( Pbuf() + rgbTags[*piTag].ib, 0, cb );
		}
	
	return JET_errSuccess;	
	}


VOID MEMPOOL::DeleteEntry( ITAG itag )
	{
	MEMPOOLTAG	*rgbTags;

	AssertValid();					// Validate integrity of buffer.

	rgbTags = (MEMPOOLTAG *)Pbuf();

	// We should not have already freed this entry.
	Assert( itag >= itagFirstUsable );
	Assert( itag < ItagUnused() );
	Assert( itag != ItagFreed() );

	// Remove the space dedicated to the entry to be deleted.
	Assert( rgbTags[itag].cb > 0 );			// Make sure it's not currently on the freed list.
	ShrinkEntry( itag, 0 );

	// Add the tag of the deleted entry to the list of freed tags.
	Assert( rgbTags[itag].cb == 0 );
	rgbTags[itag].ib = ItagFreed();
	SetItagFreed( itag );
	}


// If rgb==NULL, then just resize the entry (ie. don't replace the contents).
ERR MEMPOOL::ErrReplaceEntry( ITAG itag, BYTE *rgb, ULONG cb )
	{
	ERR			err = JET_errSuccess;
	MEMPOOLTAG	*rgbTags;

	// If replacing to 0 bytes, use DeleteEntry() instead.
	Assert( cb > 0 );

	AssertValid();					// Validate integrity of buffer.
	Assert( itag >= itagFirstUsable );
	Assert( itag < ItagUnused() );

	rgbTags = (MEMPOOLTAG *)Pbuf();

	Assert( rgbTags[itag].cb > 0 );
	Assert( rgbTags[itag].ib + rgbTags[itag].cb <= IbBufFree() );

	if ( cb < rgbTags[itag].cb )
		{
		// The new entry is smaller than the old entry.  Remove leftover space.
		ShrinkEntry( itag, cb );
		}
	else if ( cb > rgbTags[itag].cb )
		{
		// The new entry is larger than the old entry, so enlargen the
		// entry before writing to it.
		err = ErrGrowEntry( itag, cb );
		rgbTags = (MEMPOOLTAG *)Pbuf();		// In case buffer relocated to accommodate growth.
		}

	if ( JET_errSuccess == err && rgb != NULL )
		{
		// Overwrite the old entry with the new one.
		UtilMemCpy( Pbuf() + rgbTags[itag].ib, rgb, cb );
		}

	return err;
	}


BOOL MEMPOOL::FCompact()
	{
	AssertValid();				// Validate integrity of buffer.

	// Compact only if there's excessive unused space.
	BOOL	fCompactNeeded = ( CbBufSize() - IbBufFree() > 32 );
	return ( fCompactNeeded ? FResizeBuf( IbBufFree() ) : fTrue );
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\old.cxx ===
#include "std.hxx"

//  ================================================================
class RECCHECKOLD : public RECCHECK
//  ================================================================
	{
	protected:
		RECCHECKOLD( const PGNO pgnoFDP, const IFMP ifmp, FUCB * pfucb, INST * const pinst );

	protected:
		const PGNO m_pgnoFDP;
		const IFMP m_ifmp;
		FUCB * const m_pfucb;				//  used to see if there are active versions
		INST * const m_pinst;

	private:
		RECCHECKOLD( const RECCHECKOLD& );
		RECCHECKOLD& operator=( const RECCHECKOLD& );
	};


//  ================================================================
class RECCHECKFINALIZE : public RECCHECKOLD
//  ================================================================
	{
	public:
		RECCHECKFINALIZE( 	const FID fid,
							const USHORT ibRecordOffset,
							const PGNO pgnoFDP,
							const IFMP ifmp,
							FUCB * const pfucb,
							INST * const pinst,
							const BOOL fCallback,
							const BOOL fDelete );
		ERR operator()( const KEYDATAFLAGS& kdf );

	protected:
		const FID		m_fid;
		const USHORT	m_ibRecordOffset;
		const BOOL		m_fCallback:1;			//	should a callback be issued?
		const BOOL		m_fDelete:1;			//	should the record be deleted?

	private:
		RECCHECKFINALIZE( const RECCHECKFINALIZE& );
		RECCHECKFINALIZE& operator=( const RECCHECKFINALIZE& );
	};


//  ================================================================
class RECCHECKDELETELV : public RECCHECKOLD
//  ================================================================
	{
	public:
		RECCHECKDELETELV( const PGNO pgnoFDP, const IFMP ifmp, FUCB * const pfucb, INST * const pinst );
		ERR operator()( const KEYDATAFLAGS& kdf );

	private:
		RECCHECKDELETELV( const RECCHECKDELETELV& );
		RECCHECKDELETELV& operator=( RECCHECKDELETELV& );
	};


LOCAL const _TCHAR		szOLD[]							= _T( "MSysDefrag1" );		//	table name for OLD Phase I

LOCAL JET_COLUMNCREATE	rgjccOLD[]						=
	{
	sizeof(JET_COLUMNCREATE),	"ObjidFDP",		JET_coltypLong,			0,	JET_bitColumnNotNULL,	NULL,	0,	0,	0,	0,
	sizeof(JET_COLUMNCREATE),	"DefragType",	JET_coltypUnsignedByte,	0,	NO_GRBIT,				NULL,	0,	0,	0,	0,
	sizeof(JET_COLUMNCREATE),	"Sentinel",		JET_coltypLong,			0,	NO_GRBIT,				NULL,	0,	0,	0,	0,
	sizeof(JET_COLUMNCREATE),	"Status",		JET_coltypShort,		0,	NO_GRBIT,				NULL,	0,	0,	0,	0,
	sizeof(JET_COLUMNCREATE),	"CurrentKey",	JET_coltypLongBinary,	0,	NO_GRBIT,				NULL,	0,	0,	0,	0,
	};
LOCAL const ULONG		ccolOLD							= sizeof(rgjccOLD) / sizeof(JET_COLUMNCREATE);

LOCAL JET_CONDITIONALCOLUMN	rgcondcolOLD[]				=
	{
	sizeof(JET_CONDITIONALCOLUMN),	"ObjidFDP",	JET_bitIndexColumnMustBeNonNull
	};
LOCAL const ULONG		ccondcolOLD						= sizeof(rgcondcolOLD) / sizeof(JET_CONDITIONALCOLUMN);

LOCAL JET_INDEXCREATE	rgjicOLD[]						=
	{
	sizeof(JET_INDEXCREATE),	"TablesToDefrag",	"+ObjidFDP\0",	(ULONG)strlen( "+ObjidFDP" ) + 2, JET_bitIndexUnique, 0, 0, 0, rgcondcolOLD, ccondcolOLD, 0
	};
LOCAL const ULONG		cidxOLD							= sizeof(rgjicOLD) / sizeof(JET_INDEXCREATE);

LOCAL const FID			fidOLDObjidFDP					= fidFixedLeast;
LOCAL const FID			fidOLDType						= fidFixedLeast+1;
LOCAL const FID			fidOLDObjidFDPSentinel			= fidFixedLeast+2;
LOCAL const FID			fidOLDStatus					= fidFixedLeast+3;
LOCAL const FID			fidOLDCurrentKey				= fidTaggedLeast;

LOCAL CCriticalSection	critOLD( CLockBasicInfo( CSyncBasicInfo( szOLD ), rankOLD, 0 ) );

LOCAL const CPG 		cpgOLDUpdateBookmarkThreshold	= 500;		// number of pages to clean before updating catalog

BOOL FOLDSystemTable( const CHAR *szTableName )
	{
	return ( 0 == UtilCmpName( szTableName, szOLD ) );
	}


//  ================================================================
INLINE VOID OLDDB_STATUS::Reset()
//  ================================================================
	{
	Assert( critOLD.FOwner() );

#ifdef OLD_DEPENDENCY_CHAIN_HACK
	m_pgnoPrevPartialMerge = 0;
	m_cpgAdjacentPartialMerges = 0;
#endif

	Reset_();
	}


//  ****************************************************************
//	RECCHECKOLD
//  ****************************************************************

RECCHECKOLD::RECCHECKOLD( const PGNO pgnoFDP, const IFMP ifmp, FUCB * const pfucb, INST * const pinst ) :
	m_pgnoFDP( pgnoFDP ),
	m_ifmp( ifmp ),
	m_pfucb( pfucb ),
	m_pinst( pinst )
	{
	//	UNDONE: eliminate superfluous pgnoFDP param
	Assert( pgnoFDP == pfucb->u.pfcb->PgnoFDP() );
	}
	

//  ****************************************************************
//	RECCHECKFINALIZE
//  ****************************************************************

RECCHECKFINALIZE::RECCHECKFINALIZE(
	const FID fid,
	const USHORT ibRecordOffset,
	const PGNO pgnoFDP,
	const IFMP ifmp,
	FUCB * const pfucb,
	INST * const pinst,
	const BOOL fCallback,
	const BOOL fDelete ) :
	RECCHECKOLD( pgnoFDP, ifmp, pfucb, pinst ),
	m_fid( fid ),
	m_ibRecordOffset( ibRecordOffset ),
	m_fCallback( fCallback ),
	m_fDelete( fDelete )
	{
	Assert( FFixedFid( m_fid ) );
	}

ERR RECCHECKFINALIZE::operator()( const KEYDATAFLAGS& kdf )
	{
	const REC * prec = (REC *)kdf.data.Pv();
	if( m_fid > prec->FidFixedLastInRec() )
		{
		//  Column not present in record. Ignore the default value
		Assert( fFalse );		//  A finalizable column should always be present in the record
		return JET_errSuccess;
		}

	//	NULL bit is not set: column is NULL
	const UINT	ifid			= m_fid - fidFixedLeast;
	const BYTE	*prgbitNullity	= prec->PbFixedNullBitMap() + ifid/8;
	if ( FFixedNullBit( prgbitNullity, ifid ) )
		{
		//  Column is NULL
		return JET_errSuccess;
		}

	//  Currently all finalizable columns are ULONGs
	const ULONG * pulColumn = (ULONG *)((BYTE *)prec + m_ibRecordOffset );
	if( 0 == *pulColumn )
		{
		BOOKMARK bm;
		bm.key = kdf.key;
		bm.data.Nullify();
			
		if( !FVERActive( m_pfucb, bm ) )
			{
			//  This record should be finalized
			FINALIZETASK * ptask = new FINALIZETASK(
											m_pgnoFDP,
											m_pfucb->u.pfcb,
											m_ifmp,
											bm,
											m_ibRecordOffset,
											m_fCallback,
											m_fDelete );
			if( NULL == ptask )
				{
				return ErrERRCheck( JET_errOutOfMemory );
				}
			m_pinst->m_pver->IncrementCAsyncCleanupDispatched();
			const ERR err = m_pinst->Taskmgr().ErrTMPost( TASK::DispatchGP, ptask );
			if( err < JET_errSuccess )
				{
				//  The task was not enqued sucessfully.
				m_pinst->m_pver->IncrementCCleanupFailed();
				delete ptask;
				return err;
				}
			}
		}
		
	return JET_errSuccess;
	}


//  ****************************************************************
//	RECCHECKDELETELV
//  ****************************************************************

RECCHECKDELETELV::RECCHECKDELETELV(
	const PGNO pgnoFDP,
	const IFMP ifmp,
	FUCB * const pfucb,
	INST * const pinst ) :
	RECCHECKOLD( pgnoFDP, ifmp, pfucb, pinst )
	{
	}

ERR RECCHECKDELETELV::operator()( const KEYDATAFLAGS& kdf )
	{
	//  See if we are on a LVROOT
	if( sizeof( LID ) == kdf.key.Cb() )
		{
		if( sizeof( LVROOT ) != kdf.data.Cb() )
			{
			return ErrERRCheck( JET_errLVCorrupted );
			}
		//  We are on a LVROOT, is the refcount 0?
		const LVROOT * const plvroot = (LVROOT *)kdf.data.Pv();
		if( 0 == plvroot->ulReference )
			{
			BOOKMARK bm;
			bm.key = kdf.key;
			bm.data.Nullify();

			Assert( sizeof( LID ) == bm.key.Cb() );
			Assert( 0 == bm.data.Cb() );
			
			if( !FVERActive( m_pfucb, bm ) )
				{
				//  This LV has a refcount of zero and has no versions
				DELETELVTASK * ptask = new DELETELVTASK( m_pgnoFDP, m_pfucb->u.pfcb, m_ifmp, bm );
				if( NULL == ptask )
					{
					return ErrERRCheck( JET_errOutOfMemory );
					}
				m_pinst->m_pver->IncrementCAsyncCleanupDispatched();
				const ERR err = m_pinst->Taskmgr().ErrTMPost( TASK::DispatchGP, ptask );
				if( err < JET_errSuccess )
					{
					//  The task was not enqued sucessfully.
					m_pinst->m_pver->IncrementCCleanupFailed();
					delete ptask;
					return err;
					}
				}
			}
		}
	return JET_errSuccess;
	}

	

//	end OLD for all the active databases of an instance

VOID OLDTermInst( INST *pinst )
	{
	DBID	dbid;

	critOLD.Enter();

	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		Assert( dbidTemp != dbid );

		OLDDB_STATUS * const	poldstatDB	= pinst->m_rgoldstatDB + dbid;
		if ( poldstatDB->FRunning()
			&& !poldstatDB->FTermRequested() )
			{
			poldstatDB->SetFTermRequested();
			critOLD.Leave();

			poldstatDB->SetSignal();
			if ( poldstatDB->FRunning() )
				{
				poldstatDB->ThreadEnd();
#ifdef OLD_SCRUB_DB				
				poldstatDB->ScrubThreadEnd();
#endif				
				}

			critOLD.Enter();
			poldstatDB->Reset();
			}
		}

	critOLD.Leave();
	}


INLINE BOOL FOLDContinue( const IFMP ifmp )
	{
	const INST * const			pinst		= PinstFromIfmp( ifmp );
	const DBID					dbid		= rgfmp[ifmp].Dbid();
	const OLDDB_STATUS * const	poldstatDB	= pinst->m_rgoldstatDB + dbid;

	//	Continue with OLD until signalled to terminate or until we
	//	hit specified timeout
	return ( !poldstatDB->FTermRequested()
		&& !poldstatDB->FReachedMaxElapsedTime()
		&& !pinst->m_fStopJetService );
	}

INLINE BOOL FOLDContinueTree( const FUCB * pfucb )
	{
	return ( !pfucb->u.pfcb->FDeletePending() && FOLDContinue( pfucb->ifmp ) );
	}


LOCAL ERR ErrOLDUpdateDefragStatus(
	PIB *						ppib,
	FUCB *						pfucbDefrag,
	DEFRAG_STATUS&				defragstat )
	{
	ERR							err;
	const INST * const			pinst		= PinstFromPpib( ppib );
	const DBID					dbid		= rgfmp[ pfucbDefrag->ifmp ].Dbid();
	const OLDDB_STATUS * const	poldstatDB	= pinst->m_rgoldstatDB + dbid;
	OBJID						objid		= defragstat.ObjidCurrentTable();
	DEFRAGTYPE					defragtype	= defragstat.DefragType();
	DATA						dataT;

	if ( poldstatDB->FAvailExtOnly() )
		return JET_errSuccess;
	
	//	update MSysDefrag to reflect next table to defrag
	Assert( !Pcsr( pfucbDefrag )->FLatched() );

	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	
	Call( ErrIsamPrepareUpdate( ppib, pfucbDefrag, JET_prepReplace ) )
	
	dataT.SetPv( &objid );
	dataT.SetCb( sizeof(OBJID) );
	Call( ErrRECSetColumn(
				pfucbDefrag,
				fidOLDObjidFDP,
				1,
				&dataT ) );
	Call( ErrRECSetColumn(
				pfucbDefrag,
				fidOLDObjidFDPSentinel,
				1,
				&dataT ) );
				
	dataT.SetPv( &defragtype );
	dataT.SetCb( sizeof(DEFRAGTYPE) );
	Call( ErrRECSetColumn(
				pfucbDefrag,
				fidOLDStatus,
				1,
				defragstat.FTypeNull() ? NULL : &dataT ) );
				
	if ( defragstat.CbCurrentKey() > 0 )
		{
		dataT.SetPv( defragstat.RgbCurrentKey() );
		dataT.SetCb( defragstat.CbCurrentKey() );
		
		Assert( FTaggedFid( fidOLDCurrentKey ) );
		err = ErrRECSetLongField(
					pfucbDefrag,
					fidOLDCurrentKey,
					1,
					&dataT );
		Assert( JET_errRecordTooBig != err );
		Call( err );
		}
	else
		{
		Call( ErrRECSetColumn(
					pfucbDefrag,
					fidOLDCurrentKey,
					1,
					NULL ) );
		}
				
	Call( ErrIsamUpdate( ppib, pfucbDefrag, NULL, 0, NULL, NO_GRBIT ) );
	
	Call( ErrDIRCommitTransaction( ppib, JET_bitCommitLazyFlush ) );
	
	return JET_errSuccess;

HandleError:
	CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
	return err;
	}


LOCAL ERR ErrOLDDefragOneTree(
	PIB				*ppib,
	FUCB			*pfucb,
	FUCB 			*pfucbDefrag,
	DEFRAG_STATUS&	defragstat,
	const BOOL		fResumingTree,
	RECCHECK		*preccheck )
	{
	ERR				err;
	INST * 			const pinst				= PinstFromPpib( ppib );
	DIB				dib;
	BOOKMARK		bmStart;
	BOOKMARK		bmNext;
	BYTE			rgbKeyBuf[KEY::cbKeyMax];
	BOOL			fInTrx 					= fFalse;

	Assert( pfucbNil != pfucb );
	Assert( dbidTemp != rgfmp[ pfucb->ifmp ].Dbid() );
	Assert( ( !fResumingTree && defragstat.FTypeSpace() )
		|| defragstat.FTypeTable()
		|| defragstat.FTypeLV() );

	//	UNDONE: Non-unique keys not currently supported.  In order to support
	//	non-unique keys, the rgbKeyBuf and defragstat.RgbCurrentKey() buffers
	//	would have to be doubled in size (to accommodate the primary key bookmark).
	Assert( FFUCBUnique( pfucb ) );
	Assert( !pfucb->u.pfcb->FTypeSecondaryIndex() );

	Assert( !Pcsr( pfucb )->FLatched() );
	Assert( !Pcsr( pfucbDefrag )->FLatched() );

	//	small trees should have been filtered out by ErrOLDDefragOneTable()
	Assert( pfucb->u.pfcb->FSpaceInitialized() );
	Assert( pgnoNull != pfucb->u.pfcb->PgnoOE() );
	Assert( pgnoNull != pfucb->u.pfcb->PgnoAE() );

	bmStart.Nullify();
	bmStart.key.suffix.SetPv( defragstat.RgbCurrentKey() );
	bmNext.Nullify();
	bmNext.key.suffix.SetPv( rgbKeyBuf );

	if ( fResumingTree && defragstat.CbCurrentKey() > 0 )
		{
		bmStart.key.suffix.SetCb( defragstat.CbCurrentKey() );
		dib.pos = posDown;
		dib.pbm = &bmStart;
		}
	else
		{
		dib.pos = posLast;
		}

	dib.dirflag = fDIRAllNode;
	err = ErrBTDown( pfucb, &dib, latchReadTouch );
	if ( err < 0 )
		{
		if ( JET_errRecordNotFound == err )
			err = JET_errSuccess;		// no records in table

		return err;
		}
	
	Assert( Pcsr( pfucb )->FLatched() );

	NDGetBookmarkFromKDF( pfucb, pfucb->kdfCurr, &bmStart );

	//	normalised key cannot be NULL (at minimum, there will be a prefix byte)
	Assert( !bmStart.key.FNull() );

	//	UNDONE: Currently, must copy into bmNext so it will get copied back to bmStart
	//	in the loop below.  Is there a better way?
	Assert( bmNext.key.suffix.Pv() == rgbKeyBuf );
	Assert( 0 == bmNext.key.prefix.Cb() );
	bmStart.key.CopyIntoBuffer( bmNext.key.suffix.Pv(), bmStart.key.Cb() );
	bmNext.key.suffix.SetCb( bmStart.key.Cb() );

	bmNext.data.SetPv( (BYTE *)bmNext.key.suffix.Pv() + bmNext.key.Cb() );
	bmStart.data.CopyInto( bmNext.data );

	//	must reset bmStart, because it got set to elsewhere by NDGetBookmarkFromKDF()
	bmStart.Nullify();
	bmStart.key.suffix.SetPv( defragstat.RgbCurrentKey() );

#ifdef OLD_DEPENDENCY_CHAIN_HACK
	pinst->m_rgoldstatDB[ rgfmp[pfucb->ifmp].Dbid() ].SetPgnoPrevPartialMerge( 0 );
	pinst->m_rgoldstatDB[ rgfmp[pfucb->ifmp].Dbid() ].ResetCpgAdjacentPartialMerges();
#endif	

	while ( !bmNext.key.FNull()
		&& FOLDContinueTree( pfucb ) )
		{
		BOOL	fPerformedRCEClean	= fFalse;
		
		VOID	*pvSwap	= bmStart.key.suffix.Pv();
		bmStart.key.suffix.SetPv( bmNext.key.suffix.Pv() );
		bmStart.key.suffix.SetCb( bmNext.key.suffix.Cb() );
		bmStart.data.SetPv( bmNext.data.Pv() );
		bmStart.data.SetCb( bmNext.data.Cb() );

		bmNext.Nullify();
		bmNext.key.suffix.SetPv( pvSwap );

		Assert( bmStart.key.prefix.Cb() == 0 );
		Assert( bmNext.key.prefix.Cb() == 0 );

		//	UNDONE: secondary indexes not currently supported
		Assert( bmStart.data.Cb() == 0 );
		Assert( bmNext.data.Cb() == 0 );

		BTUp( pfucb );

		Assert( !fInTrx );
		Call( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
		fInTrx = fTrue;

		forever
			{
			err = ErrBTIMultipageCleanup( pfucb, bmStart, &bmNext, preccheck );
			BTUp( pfucb );

			if ( err < 0 )
				{
				//	if out of version store, try once to clean up
				if ( JET_errVersionStoreOutOfMemory == err && !fPerformedRCEClean )
					{
					CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
					fInTrx = fFalse;
					
					UtilSleep( 1000 );
					
					Call( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
					fInTrx = fTrue;

					//	only try cleanup once
					fPerformedRCEClean = fTrue;
					}
				else if ( errBTMergeNotSynchronous != err )
					{
					goto HandleError;
					}
				}
			else
				{
				break;
				}
			}

		//	see if we need to update catalog with our progress
		if ( !defragstat.FTypeSpace() )
			{
			Assert( !FFUCBSpace( pfucb ) );
			if ( bmNext.key.suffix.Pv() == defragstat.RgbCurrentKey() )
				{
				defragstat.SetCbCurrentKey( bmNext.key.suffix.Cb() );

				Assert( bmStart.key.suffix.Pv() == rgbKeyBuf );
				}
			else
				{
				Assert( bmStart.key.suffix.Pv() == defragstat.RgbCurrentKey() );
				Assert( bmStart.key.suffix.Cb() == defragstat.CbCurrentKey() );
				Assert( bmNext.key.suffix.Pv() == rgbKeyBuf );
				}

			defragstat.IncrementCpgCleaned();
			if ( defragstat.CpgCleaned() > cpgOLDUpdateBookmarkThreshold )
				{
				defragstat.ResetCpgCleaned();

				//	UNDONE: Don't currently support non-unique indexes;
				Assert( 0 == bmNext.data.Cb() );
				Assert( 0 == bmNext.key.prefix.Cb() );
			
				//	UNDONE: Don't currently support non-unique indexes
				Assert( defragstat.CbCurrentKey() <= KEY::cbKeyMax );

				//	Ensure LV doesn't get burst.
				Assert( defragstat.CbCurrentKey() < cbLVIntrinsicMost );

				Assert( defragstat.FTypeTable() || defragstat.FTypeLV() );
				Call( ErrOLDUpdateDefragStatus( ppib, pfucbDefrag, defragstat ) );
				}
			}
		else
			{
			Assert( FFUCBSpace( pfucb ) );
			if ( bmNext.key.suffix.Pv() == defragstat.RgbCurrentKey() )
				{
				Assert( bmStart.key.suffix.Pv() == rgbKeyBuf );
				}
			else
				{
				Assert( bmStart.key.suffix.Pv() == defragstat.RgbCurrentKey() );
				Assert( bmNext.key.suffix.Pv() == rgbKeyBuf );
				}
			}

		Assert( fInTrx );
		Call( ErrDIRCommitTransaction( ppib, JET_bitCommitLazyFlush ) );
		fInTrx = fFalse;

		while ( pinst->m_plog->m_fBackupInProgress && FOLDContinueTree( pfucb ) )
			{
			//	suspend OLD if this process is performing online backup
			pinst->m_rgoldstatDB[ rgfmp[pfucb->ifmp].Dbid() ].FWaitOnSignal( cmsecWaitForBackup );
			}
		}

	Assert( !fInTrx );

HandleError:
	BTUp( pfucb );
	
	if ( fInTrx )
		{
		Assert( err < 0 );
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}

	return err;
	}


LOCAL ERR ErrOLDDefragSpaceTree(
	PIB				* ppib,
	FUCB			* pfucb,
	FUCB 			* pfucbDefrag,
	const BOOL		fAvailExt )
	{
	ERR				err;
	FUCB			* pfucbT	= pfucbNil;
	DEFRAG_STATUS	defragstat;

	Assert( !FFUCBSpace( pfucb ) );

	Assert( pfucb->u.pfcb->FSpaceInitialized() );
	Assert( pgnoNull != pfucb->u.pfcb->PgnoAE() );
	Assert( pgnoNull != pfucb->u.pfcb->PgnoOE() );

	if ( fAvailExt )
		{
		CallR( ErrSPIOpenAvailExt( ppib, pfucb->u.pfcb, &pfucbT ) );
		}
	else
		{
		CallR( ErrSPIOpenOwnExt( ppib, pfucb->u.pfcb, &pfucbT ) );
		}
	Assert( FFUCBSpace( pfucbT ) );
	
	defragstat.SetTypeSpace();
	err = ErrOLDDefragOneTree(
				ppib,
				pfucbT,
				pfucbDefrag,
				defragstat,
				fFalse,
				NULL );


	Assert( pfucbNil != pfucbT );
	BTClose( pfucbT );

	return err;
	}

//  ================================================================
LOCAL ERR ErrOLDCheckForFinalize(
			PIB * const ppib,
			FUCB * const pfucb,
			INST * const pinst,
			RECCHECK ** ppreccheck )
//  ================================================================
	{
	ERR err = JET_errSuccess;
	
	*ppreccheck = NULL;
	
	FCB * const pfcb = pfucb->u.pfcb;
	pfcb->EnterDDL();
	
	Assert( NULL != pfcb );
	Assert( pfcb->FTypeTable() );
	Assert( NULL != pfcb->Ptdb() );
	TDB * const ptdb = pfcb->Ptdb();

	//  Does this table have a finalize callback
	const CBDESC * pcbdesc = ptdb->Pcbdesc();
	while( NULL != pcbdesc )
		{
		if( pcbdesc->cbtyp & JET_cbtypFinalize )
			{
			break;
			}
		pcbdesc = pcbdesc->pcbdescNext;
		}
	if( NULL == pcbdesc )
		{
		//  No finalize callback
		pfcb->LeaveDDL();
		return JET_errSuccess;
		}

	//  Now find the first column that is finalizable
	//  UNDONE: find all finalizable columns and build a RECCHECKMACRO
	const FID	fidLast	= ptdb->FidFixedLast();
	FID			fid;
	for( fid = fidFixedLeast; fid <= fidLast; ++fid )
		{
		const BOOL	fTemplateColumn	= ptdb->FFixedTemplateColumn( fid );
		const FIELD	* const pfield	= ptdb->PfieldFixed( ColumnidOfFid( fid, fTemplateColumn ) );
		if ( FFIELDFinalize( pfield->ffield ) || FFIELDDeleteOnZero( pfield->ffield ) )
			{
			//  we have found the column
			*ppreccheck = new RECCHECKFINALIZE(
								fid,
								pfield->ibRecordOffset,
								pfcb->PgnoFDP(),
								pfcb->Ifmp(),
								pfucb,
								pinst,
								FFIELDFinalize( pfield->ffield ),
								FFIELDDeleteOnZero( pfield->ffield ) );
			err = ( NULL == *ppreccheck ) ? ErrERRCheck( JET_errOutOfMemory ) : JET_errSuccess;
			break;
			}
		}
	pfcb->LeaveDDL();
	return err;
	}


LOCAL ERR ErrOLDDefragOneTable(
	PIB	*						ppib,
	FUCB *						pfucbCatalog,
	FUCB *						pfucbDefrag,
	DEFRAG_STATUS&				defragstat )
	{
	ERR							err;
	const IFMP					ifmp			= pfucbCatalog->ifmp;
	const OLDDB_STATUS * const	poldstatDB		= PinstFromIfmp( ifmp )->m_rgoldstatDB + rgfmp[ifmp].Dbid();
	FUCB *						pfucb			= pfucbNil;
	FUCB *						pfucbLV			= pfucbNil;
	OBJID						objidTable;
	DATA						dataField;
	CHAR						szTable[JET_cbNameMost+1];
	BOOL						fLatchedCatalog	= fFalse;

	Assert( !Pcsr( pfucbDefrag )->FLatched() );
	
	Assert( !Pcsr( pfucbCatalog )->FLatched() );
	err = ErrDIRGet( pfucbCatalog );
	if ( err < 0 )
		{
		if ( JET_errRecordDeleted == err )
			err = JET_errSuccess;		//	since we're at level 0, table may have just gotten deleted, so skip it
		goto HandleError;
		}
	fLatchedCatalog = fTrue;

	//	first record with this objidFDP should always be the Table object.
	Assert( FFixedFid( fidMSO_Type ) );
	CallS( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Type,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	Assert( dataField.Cb() == sizeof(SYSOBJ) );

	if ( sysobjTable != *( (UnalignedLittleEndian< SYSOBJ > *)dataField.Pv() ) )
		{
		//	We might end up not on a table record because we do our seek at level 0
		//	and may be seeking while someone is in the middle of committing a table
		//	creation to level 0 - hence, we miss the table record, but suddenly
		//	start seeing the column records.
		//	This could only happen if the table was new, so it wouldn't require
		//	defragmentation anyway.  Just skip the table.
		err = JET_errSuccess;
		goto HandleError;
		}

	Assert( FFixedFid( fidMSO_ObjidTable ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_ObjidTable,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(OBJID) );
	UtilMemCpy( &objidTable, dataField.Pv(), sizeof(OBJID) );

	Assert( objidTable >= objidFDPMSO );
	if ( defragstat.ObjidCurrentTable() != objidTable )
		{
		defragstat.SetObjidCurrentTable( objidTable );

		//	must force to restart from top of table in case we were trying to resume
		//	a tree that no longer exists
		defragstat.SetTypeNull();
		}

	Assert( FVarFid( fidMSO_Name ) );
	Call( ErrRECIRetrieveVarColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Name,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() > 0 );
	Assert( dataField.Cb() <= JET_cbNameMost );
	UtilMemCpy( szTable, dataField.Pv(), dataField.Cb() );
	szTable[dataField.Cb()] = '\0';

	Assert( fLatchedCatalog );
	CallS( ErrDIRRelease( pfucbCatalog ) );
	fLatchedCatalog = fFalse;

	//	UNDONE: defragment secondary index trees
	
	err = ErrFILEOpenTable( ppib, ifmp, &pfucb, szTable, NO_GRBIT );
	if ( err < 0 )
		{
		Assert( pfucbNil == pfucb );
		if ( JET_errTableLocked == err || JET_errObjectNotFound == err )
			err = JET_errSuccess;		//	if table is exclusively held or has since been deleted, just skip it
		goto HandleError;
		}

	Assert( pfucbNil != pfucb );

	//	need access to space info immediately
	if ( !pfucb->u.pfcb->FSpaceInitialized() )
		{
		Call( ErrSPDeferredInitFCB( pfucb ) );
		}
	
	Assert( pfucb->u.pfcb->FSpaceInitialized() );		//	OLD forces space info to be retrieved on OpenTable
	if ( pgnoNull == pfucb->u.pfcb->PgnoOE() )
		{
		Assert( pgnoNull == pfucb->u.pfcb->PgnoAE() );
		}
	else
		{
		Assert( pgnoNull != pfucb->u.pfcb->PgnoAE() );
		Assert( pfucb->u.pfcb->PgnoAE() == pfucb->u.pfcb->PgnoOE()+1 );
		}
	
	//	don't defrag tables without space trees -- they're so small
	//	they're not worth defragging
	if ( FOLDContinueTree( pfucb )
		&& pgnoNull != pfucb->u.pfcb->PgnoOE() )
		{
		BOOL	fResumingTree	= !defragstat.FTypeNull();

		//	ALWAYS defrag space trees, regardless of whether we're resuming or not
		Call( ErrOLDDefragSpaceTree(
					ppib,
					pfucb,
					pfucbDefrag,
					fTrue ) );
		if ( !FOLDContinueTree( pfucb ) )
			{
			goto HandleError;
			}

		if ( !poldstatDB->FAvailExtOnly() )
			{
			Call( ErrOLDDefragSpaceTree(
						ppib,
						pfucb,
						pfucbDefrag,
						fFalse ) );
			if ( !FOLDContinueTree( pfucb ) )
				{
				goto HandleError;
				}

			if ( defragstat.FTypeNull() || defragstat.FTypeTable() )
				{
				//  determine if there are any columns to be finalized
				RECCHECK * preccheck = NULL;
				Call( ErrOLDCheckForFinalize( ppib, pfucb, PinstFromPpib( ppib ), &preccheck ) );

				defragstat.SetTypeTable();
				err = ErrOLDDefragOneTree(
							ppib,
							pfucb,
							pfucbDefrag,
							defragstat,
							fResumingTree,
							preccheck );

				if( NULL != preccheck )
					{
					delete preccheck;
					}

				if ( err >= 0 && FOLDContinueTree( pfucb ) )
					{
					defragstat.SetTypeLV();
					defragstat.SetCbCurrentKey( 0 );
					}
				else
					{
					goto HandleError;
					}
				}
			else
				{
				Assert( defragstat.FTypeLV() );
				Assert( fResumingTree );
				}
			}

		if ( defragstat.FTypeLV() || poldstatDB->FAvailExtOnly() )
			{
			Call( ErrFILEOpenLVRoot( pfucb, &pfucbLV, fFalse ) );	// UNDONE: Call ErrDIROpenLongRoot() instead
			if ( wrnLVNoLongValues == err )
				{
				Assert( pfucbNil == pfucbLV );
				}
			else
				{
				CallS( err );
				Assert( pfucbNil != pfucbLV );
				Assert( pfucbLV->u.pfcb->FSpaceInitialized() );	//	we don't defer space init for LV trees

				if ( pgnoNull == pfucbLV->u.pfcb->PgnoAE() )
					{
					Assert( pgnoNull == pfucbLV->u.pfcb->PgnoOE() );
					goto HandleError;
					}
				else
					{
					Assert( pgnoNull != pfucb->u.pfcb->PgnoOE() );
					Assert( pfucbLV->u.pfcb->PgnoAE() == pfucbLV->u.pfcb->PgnoOE()+1 );
					}
				
				Call( ErrOLDDefragSpaceTree(
							ppib,
							pfucbLV,
							pfucbDefrag,
							fTrue ) );
				if ( FOLDContinueTree( pfucb )				//	use table's cursor to check if we should continue
					&& !poldstatDB->FAvailExtOnly() )
					{
					RECCHECKDELETELV reccheck(
						pfucbLV->u.pfcb->PgnoFDP(),
						pfucbLV->ifmp,
						pfucbLV,
						PinstFromPfucb( pfucb ) );
					
					Call( ErrOLDDefragSpaceTree(
								ppib,
								pfucbLV,
								pfucbDefrag,
								fFalse ) );
					if ( !FOLDContinueTree( pfucb )	)			//	use table's cursor to check if we should continue
						{
						goto HandleError;
						}
					
					Call( ErrOLDDefragOneTree(
								ppib,
								pfucbLV,
								pfucbDefrag,
								defragstat,
								fResumingTree,
								&reccheck ) );
					}
				}
			}
		}

HandleError:
	if ( fLatchedCatalog )
		{
		CallS( ErrDIRRelease( pfucbCatalog ) );
		}
		
	if ( pfucbNil != pfucbLV )
		{
		DIRClose( pfucbLV );
		}
		
	if ( pfucbNil != pfucb )
		{
		CallS( ErrFILECloseTable( ppib, pfucb ) );
		}

	return err;
	}


LOCAL ERR ErrOLDDefragTables(
	PIB *					ppib,
	FUCB *					pfucbDefrag,
	DEFRAG_STATUS&			defragstat )
	{
	ERR						err;
	INST * const			pinst			= PinstFromPpib( ppib );
	const IFMP				ifmp 			= pfucbDefrag->ifmp;
	OLDDB_STATUS * const	poldstatDB		= pinst->m_rgoldstatDB + rgfmp[ifmp].Dbid();
	FUCB *					pfucbCatalog	= pfucbNil;
	OBJID					objidNext		= defragstat.ObjidCurrentTable();
	ULONG_PTR				csecStartPass;
	const CHAR *			rgszT[1];
	CHAR 					szTrace[64];

	Assert( dbidTemp != rgfmp[ ifmp ].Dbid() );
	Assert( 0 == poldstatDB->CPasses() );
	Assert( 0 == defragstat.CpgCleaned() );
	Assert( defragstat.FPassNull() );

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	rgszT[0] = rgfmp[ifmp].SzDatabaseName();

	if ( objidNext > objidFDPMSO )
		{
		UtilReportEvent(
			eventInformation,
			ONLINE_DEFRAG_CATEGORY,
			OLD_RESUME_PASS_ID,
			1,
			rgszT,
			0,
			NULL,
			pinst );
		defragstat.SetPassPartial();

		sprintf( szTrace, "OLD RESUME (ifmp %d)", ifmp );
		}
	else
		{
		UtilReportEvent(
			eventInformation,
			ONLINE_DEFRAG_CATEGORY,
			OLD_BEGIN_FULL_PASS_ID,
			1,
			rgszT,
			0,
			NULL,
			pinst );
		defragstat.SetPassFull();

		sprintf( szTrace, "OLD BEGIN (ifmp %d)", ifmp );
		}
		
	Call ( pinst->m_plog->ErrLGTrace( ppib, szTrace ) );		

	csecStartPass = UlUtilGetSeconds();

	while ( FOLDContinue( ifmp ) )
		{
		Call( ErrIsamMakeKey(
					ppib,
					pfucbCatalog,
					(BYTE *)&objidNext,
					sizeof(objidNext),
					JET_bitNewKey ) );
		err = ErrIsamSeek( ppib, pfucbCatalog, JET_bitSeekGE );
		if ( JET_errRecordNotFound == err )
			{
			err = JET_errSuccess;

			//	reset status
			defragstat.SetTypeNull();
			defragstat.SetObjidCurrentTable( objidFDPMSO );
			defragstat.ResetCpgCleaned();

			Call( ErrOLDUpdateDefragStatus( ppib, pfucbDefrag, defragstat ) );

			sprintf( szTrace, "OLD COMPLETED PASS (ifmp %d)", ifmp );
			Call ( pinst->m_plog->ErrLGTrace( ppib, szTrace ) );

			//	if we reached the end, start over
			if ( defragstat.FPassPartial() )
				{
				UtilReportEvent(
					eventInformation,
					ONLINE_DEFRAG_CATEGORY,
					OLD_COMPLETE_RESUMED_PASS_ID,
					1,
					rgszT,
					0,
					NULL,
					pinst );
				defragstat.SetPassFull();		//	completed partial pass, begin full pass
				
				}
			else
				{
				UtilReportEvent(
					eventInformation,
					ONLINE_DEFRAG_CATEGORY,
					OLD_COMPLETE_FULL_PASS_ID,
					1,
					rgszT,
					0,
					NULL,
					pinst );

				poldstatDB->IncCPasses();
				if ( poldstatDB->FReachedMaxPasses() )
					{
					defragstat.SetPassCompleted();
					break;
					}
				}

			//	if performing a finite number of passes, then just wait long enough for
			//	background cleanup to catch up before doing next pass.
			ULONG	cmsecWait	=	cmsecAsyncBackgroundCleanup;
			if ( poldstatDB->FInfinitePasses() )
				{
				//	if performing an infinite number of passes, then pad the wait time
				//	such that each pass will take at least 1 hour
				const ULONG_PTR		csecCurrentPass	= UlUtilGetSeconds() - csecStartPass;
				if ( csecCurrentPass < csecOLDMinimumPass )
					{
					cmsecWait = (ULONG)max( ( csecOLDMinimumPass - csecCurrentPass ) * 1000, cmsecAsyncBackgroundCleanup );
					}
				}
				
			poldstatDB->FWaitOnSignal( cmsecWait );

			if ( FOLDContinue( ifmp ) )
				{
				UtilReportEvent(
					eventInformation,
					ONLINE_DEFRAG_CATEGORY,
					OLD_BEGIN_FULL_PASS_ID,
					1,
					rgszT,
					0,
					NULL,
					pinst );
				
				Assert( defragstat.FPassFull() );

				sprintf( szTrace, "OLD RESTART FULL PASS (ifmp %d)", ifmp );
				Call ( pinst->m_plog->ErrLGTrace( ppib, szTrace ) );

				csecStartPass = UlUtilGetSeconds();
				}
			}
		else
			{
			Call( err );
			Assert( JET_wrnSeekNotEqual == err );

			//	NOTE: the only time defragstat.Type should be non-NULL is the very
			//	first iteration if we're resuming the tree

			Call( ErrOLDDefragOneTable(
						ppib,
						pfucbCatalog,
						pfucbDefrag,
						defragstat ) );

			if ( !FOLDContinue( ifmp ) )
				break;
				
			//	prepare for next table
			defragstat.SetTypeNull();
			defragstat.SetObjidNextTable();
			}
			
		objidNext = defragstat.ObjidCurrentTable();
		}

	if ( !defragstat.FPassCompleted() )
		{
		UtilReportEvent(
			eventInformation,
			ONLINE_DEFRAG_CATEGORY,
			OLD_INTERRUPTED_PASS_ID,
			1,
			rgszT,
			0,
			NULL,
			pinst );
		}

HandleError:

	sprintf( szTrace, "OLD END (ifmp %d, err %d)", ifmp, err );
	(void) ( pinst->m_plog->ErrLGTrace( ppib, szTrace ) );

	Assert( pfucbNil != pfucbCatalog );	
	CallS( ErrCATClose( ppib, pfucbCatalog ) );
	
	return err;
	}


LOCAL ERR ErrOLDCreate( PIB *ppib, const IFMP ifmp )
	{
	ERR				err;
	FUCB			*pfucb;
	DATA			dataField;
	OBJID			objidFDP	= objidFDPMSO;
	JET_TABLECREATE2	jtcOLD		=
		{
		sizeof(JET_TABLECREATE2),
		(CHAR *)szOLD,
		NULL,					// Template table
		0,
		100,					//	set to 100% density, because we will always be appending
		rgjccOLD,
		ccolOLD,
		rgjicOLD,
		cidxOLD,
		NULL,
		0,
		JET_bitTableCreateFixedDDL|JET_bitTableCreateSystemTable,
		0,
		0
		};

	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
		
	//	MSysDefrag doesn't exist, so create it
	Call( ErrFILECreateTable( ppib, ifmp, &jtcOLD ) );
	pfucb = (FUCB *)jtcOLD.tableid;

	//	insert initial record
	Call( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepInsert ) )
	dataField.SetPv( &objidFDP );
	dataField.SetCb( sizeof(OBJID) );
	Call( ErrRECSetColumn(
				pfucb,
				fidOLDObjidFDP,
				1,
				&dataField ) );
	Call( ErrRECSetColumn(
				pfucb,
				fidOLDObjidFDPSentinel,
				1,
				&dataField ) );
	Call( ErrIsamUpdate( ppib, pfucb, NULL, 0, NULL, NO_GRBIT ) );

	Call( ErrFILECloseTable( ppib, pfucb ) );

	Call( ErrDIRCommitTransaction( ppib, JET_bitCommitLazyFlush ) );
	
	return JET_errSuccess;

HandleError:
	CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );

	return err;
	}


DWORD OLDDefragDb( DWORD_PTR dw )
	{
	ERR						err;
	IFMP					ifmp			= (IFMP)dw;
	INST * const			pinst			= PinstFromIfmp( ifmp );
	OLDDB_STATUS * const	poldstatDB		= pinst->m_rgoldstatDB + rgfmp[ifmp].Dbid();
	PIB *					ppib			= ppibNil;
	FUCB *					pfucb			= pfucbNil;
	BOOL					fOpenedDb		= fFalse;
	DEFRAG_STATUS			defragstat;
	DATA					dataField;

	Assert( 0 == poldstatDB->CPasses() );

	CallR( ErrPIBBeginSession( pinst, &ppib, procidNil, fFalse ) );
	Assert( ppibNil != ppib );

	ppib->SetFUserSession();					//	we steal a user session in order to do OLD
	ppib->SetFSessionOLD();
	ppib->grbitsCommitDefault = JET_bitCommitLazyFlush;

	Call( ErrDBOpenDatabaseByIfmp( ppib, ifmp ) );
	fOpenedDb = fTrue;
	
	err = ErrFILEOpenTable( ppib, ifmp, &pfucb, szOLD, NO_GRBIT );
	if ( err < 0 )
		{
		if ( JET_errObjectNotFound != err )
			goto HandleError;

		//	Create the table, then re-open it.  Can't just use the cursor returned from CreateTable
		//	because that cursor has exclusive use of the table, meaning that it will be visible
		//	to Info calls (because it's in the catalog) but not accessible.
		Call( ErrOLDCreate( ppib, ifmp ) );
		Call( ErrFILEOpenTable( ppib, ifmp, &pfucb, szOLD, NO_GRBIT ) );
		}

	Assert( pfucbNil != pfucb );

	//	UNDONE: Switch to secondary index, see if any tables have been
	//	specifically requested to be defragmented, and process those first

	//	move to first record, which defines the "defrag window"
	err = ErrIsamMove( ppib, pfucb, JET_MoveFirst, NO_GRBIT );
	Assert( JET_errNoCurrentRecord != err );
	Assert( JET_errRecordNotFound != err );
	Call( err );

	Assert( !Pcsr( pfucb )->FLatched() );
	Call( ErrDIRGet( pfucb ) );
	
#ifdef DEBUG
	//	verify Type is NULL, so that this record doesn't get included
	//	in the secondary index
	Assert( FFixedFid( fidOLDType ) );
	err = ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucb->u.pfcb->Ptdb(),
				fidOLDType,
				pfucb->kdfCurr.data,
				&dataField );
	Assert( JET_wrnColumnNull == err );
#endif

	Assert( FFixedFid( fidOLDObjidFDP ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucb->u.pfcb->Ptdb(),
				fidOLDObjidFDP,
				pfucb->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(OBJID) );
	defragstat.SetObjidCurrentTable( *( (UnalignedLittleEndian< OBJID > *)dataField.Pv() ) );

#ifdef DEBUG
	//	UNDONE: Multi-threaded OLD support.  ObjidBegin and ObjidEnd define
	//	the window of tables on which all threads are working.
	OBJID	objidFDPEnd;
	Assert( FFixedFid( fidOLDObjidFDPSentinel ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucb->u.pfcb->Ptdb(),
				fidOLDObjidFDPSentinel,
				pfucb->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(OBJID) );
	UtilMemCpy( &objidFDPEnd, dataField.Pv(), sizeof(OBJID) );

	Assert( objidFDPEnd == defragstat.ObjidCurrentTable() );
#endif

	Assert( FFixedFid( fidOLDStatus ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucb->u.pfcb->Ptdb(),
				fidOLDStatus,
				pfucb->kdfCurr.data,
				&dataField ) );
	if ( JET_errSuccess == err )
		{
		Assert( dataField.Cb() == sizeof(DEFRAGTYPE) );
		defragstat.SetType( *( (UnalignedLittleEndian< DEFRAGTYPE > *)dataField.Pv() ) );
		Assert( defragstat.FTypeTable() || defragstat.FTypeLV() );

		Assert( FTaggedFid( fidOLDCurrentKey ) );
		Call( ErrRECIRetrieveTaggedColumn(
					pfucb->u.pfcb,
					ColumnidOfFid( fidOLDCurrentKey, fFalse ),
					1,
					pfucb->kdfCurr.data,
					&dataField ) );
		Assert( dataField.Cb() <= KEY::cbKeyMax );
		Assert( wrnRECUserDefinedDefault != err );
		Assert( wrnRECSeparatedSLV != err );
		Assert( wrnRECIntrinsicSLV != err );
		Assert( wrnRECSeparatedLV != err );

		Assert( wrnRECLongField != err );
		if ( JET_errSuccess == err || wrnRECIntrinsicLV == err )
			{
			memcpy( defragstat.RgbCurrentKey(), dataField.Pv(), dataField.Cb() );
			defragstat.SetCbCurrentKey( dataField.Cb() );
			}
		else
			{
			Assert( JET_wrnColumnNull == err );
			Assert( 0 == dataField.Cb() );
			defragstat.SetCbCurrentKey( 0 );
			}
		}
	else
		{
		Assert( JET_wrnColumnNull == err );
		defragstat.SetTypeNull();
		}

	if ( poldstatDB->FAvailExtOnly() )
		{
		defragstat.SetTypeNull();
		defragstat.SetObjidCurrentTable( objidFDPMSO );
		}

	CallS( ErrDIRRelease( pfucb ) );
	
	Call( ErrOLDDefragTables( ppib, pfucb, defragstat ) );

	Call( ErrOLDUpdateDefragStatus( ppib, pfucb, defragstat ) );

	if( NULL != poldstatDB->Callback() )
		{
		Assert( ppibNil != ppib );
		(VOID)( poldstatDB->Callback() )(
					reinterpret_cast<JET_SESID>( ppib ),
					static_cast<JET_DBID>( ifmp ),
					JET_tableidNil,
					JET_cbtypOnlineDefragCompleted,
					NULL,
					NULL,
					NULL,
					0 );
		}
		
HandleError:
	Assert( ppibNil != ppib );
	
	if ( err < 0 )
		{
		CHAR		szErr[16];
		const CHAR	*rgszT[2];

		sprintf( szErr, "%d", err );

		rgszT[0] = rgfmp[ifmp].SzDatabaseName();
		rgszT[1] = szErr;

		//	even though an error was encountered, just report it as a warning
		//	because the next time OLD is invoked, it will simply resume from
		//	where it left off
		UtilReportEvent(
			eventWarning,
			ONLINE_DEFRAG_CATEGORY,
			OLD_ERROR_ID,
			2,
			rgszT,
			0,
			NULL,
			pinst );

		//	track errors to catch cases where we could actually
		//	have recovered from whatever error was encountered
		AssertTracking();
		}
	
	if ( pfucbNil != pfucb )
		{
		CallS( ErrFILECloseTable( ppib, pfucb ) );
		}
	if ( fOpenedDb )
		{
		CallS( ErrDBCloseAllDBs( ppib ) );
		}

	PIBEndSession( ppib );

	critOLD.Enter();
	if ( !poldstatDB->FTermRequested() )
		{
		
		//	we're terminating before the client asked
		poldstatDB->ThreadEnd();
#ifdef OLD_SCRUB_DB				
		poldstatDB->ScrubThreadEnd();
#endif
		poldstatDB->Reset();
		}
	critOLD.Leave();

	return 0;
	}


#ifdef OLD_SCRUB_DB

//  ================================================================
ULONG OLDScrubDb( DWORD_PTR dw )
//  ================================================================
	{
	const CPG cpgPreread = 256;

	ERR				err;
	IFMP			ifmp			= (IFMP)dw;
	PIB				*ppib			= ppibNil;
	BOOL			fOpenedDb		= fFalse;
	SCRUBDB 		* pscrubdb 		= NULL;

	const ULONG_PTR ulSecStart = UlUtilGetSeconds();
	
	CallR( ErrPIBBeginSession( PinstFromIfmp( ifmp ), &ppib, procidNil, fFalse ) );
	Assert( ppibNil != ppib );

	ppib->SetFUserSession();					//	we steal a user session in order to do OLD
///	ppib->SetSessionOLD();
	ppib->grbitsCommitDefault = JET_bitCommitLazyFlush;

	Call( ErrDBOpenDatabaseByIfmp( ppib, ifmp ) );
	fOpenedDb = fTrue;

	pscrubdb = new SCRUBDB( ifmp );
	if( NULL == pscrubdb )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	while( FOLDContinue( ifmp ) )
		{
		const CHAR * rgszT[1];
		INT isz = 0;
		
		rgszT[isz++] = rgfmp[ifmp].SzDatabaseName();
		Assert( isz <= sizeof( rgszT ) / sizeof( rgszT[0] ) );
		
		UtilReportEvent(
				eventInformation,
				DATABASE_ZEROING_CATEGORY,
				DATABASE_ZEROING_STARTED_ID,
				isz,
				rgszT,
				0,
				NULL,
				PinstFromIfmp( ifmp ) );

		PGNO pgnoLast;
		pgnoLast = rgfmp[ifmp].PgnoLast();

		DBTIME dbtimeLastScrubNew;
		dbtimeLastScrubNew = rgfmp[ifmp].Dbtime();
		
		Call( pscrubdb->ErrInit( ppib, CUtilProcessProcessor() ) );

		PGNO pgno;
		pgno = 1;

		while( pgnoLast	>= pgno && FOLDContinue( ifmp ) )
			{
			ULONG_PTR cpgCache;
			CallS( ErrBFGetCacheSize( &cpgCache ) );
			
			const CPG cpgChunk 		= 256;
			const CPG cpgPreread 	= min( cpgChunk, pgnoLast - pgno + 1 );
			BFPrereadPageRange( ifmp, pgno, cpgPreread );

			Call( pscrubdb->ErrScrubPages( pgno, cpgPreread ) );
			pgno += cpgPreread;

			while( ( pscrubdb->Scrubstats().cpgSeen + ( cpgCache / 4 ) ) < pgno
				   && FOLDContinue( ifmp ) )
				{
				UtilSleep( cmsecWaitGeneric );
				}
			}

		Call( pscrubdb->ErrTerm() );

		if( pgno > pgnoLast )
			{
			//  we completed a pass
			rgfmp[ifmp].Pdbfilehdr()->dbtimeLastScrub = dbtimeLastScrubNew;
			LGIGetDateTime( &rgfmp[ifmp].Pdbfilehdr()->logtimeScrub );
			}

			{
			const ULONG_PTR ulSecFinished 	= UlUtilGetSeconds();
			const ULONG_PTR ulSecs 			= ulSecFinished - ulSecStart;

			const CHAR * rgszT[16];
			INT isz = 0;

			CHAR	szSeconds[16];
			CHAR	szErr[16];
			CHAR	szPages[16];
			CHAR	szBlankPages[16];
			CHAR	szUnchangedPages[16];
			CHAR	szUnusedPages[16];
			CHAR	szUsedPages[16];
			CHAR	szDeletedRecordsZeroed[16];
			CHAR	szOrphanedLV[16];

			sprintf( szSeconds, "%d", ulSecs );
			sprintf( szErr, "%d", err );
			sprintf( szPages, "%d", pscrubdb->Scrubstats().cpgSeen );
			sprintf( szBlankPages, "%d", pscrubdb->Scrubstats().cpgUnused );
			sprintf( szUnchangedPages, "%d", pscrubdb->Scrubstats().cpgUnchanged );
			sprintf( szUnusedPages, "%d", pscrubdb->Scrubstats().cpgZeroed );
			sprintf( szUsedPages, "%d", pscrubdb->Scrubstats().cpgUsed );
			sprintf( szDeletedRecordsZeroed, "%d", pscrubdb->Scrubstats().cFlagDeletedNodesZeroed );
			sprintf( szOrphanedLV, "%d", pscrubdb->Scrubstats().cOrphanedLV );

			rgszT[isz++] = rgfmp[ifmp].SzDatabaseName();
			rgszT[isz++] = szSeconds;
			rgszT[isz++] = szErr;
			rgszT[isz++] = szPages;
			rgszT[isz++] = szBlankPages;
			rgszT[isz++] = szUnchangedPages;
			rgszT[isz++] = szUnusedPages;
			rgszT[isz++] = szUsedPages;
			rgszT[isz++] = szDeletedRecordsZeroed;
			rgszT[isz++] = szOrphanedLV;
			
			Assert( isz <= sizeof( rgszT ) / sizeof( rgszT[0] ) );
			UtilReportEvent(
					eventInformation,
					DATABASE_ZEROING_CATEGORY,
					DATABASE_ZEROING_STOPPED_ID,
					isz,
					rgszT,
					0,
					NULL,
					PinstFromIfmp( ifmp ) );
			}

		//  wait one minute before starting again
		pinst->m_rgoldstatDB[ rgfmp[ifmp].Dbid() ].FWaitOnSignal( 60 * 1000 );
		}

HandleError:
	if ( fOpenedDb )
		{
		CallS( ErrDBCloseAllDBs( ppib ) );
		}

	if( NULL != pscrubdb )
		{
		(VOID)pscrubdb->ErrTerm();
		delete pscrubdb;
		}

	Assert( ppibNil != ppib );	
	PIBEndSession( ppib );	
	
	return 0;
	}

#endif	//	OLD_SCRUB_DB


ERR ErrOLDDefragment(
	const IFMP		ifmp,
	const CHAR *	szTableName,
	ULONG *			pcPasses,
	ULONG *			pcsec,
	JET_CALLBACK	callback,
	JET_GRBIT		grbit )
	{
	ERR				err;
	const BOOL		fReturnPassCount	= ( NULL != pcPasses && ( grbit & JET_bitDefragmentBatchStop ) );
	const BOOL		fReturnElapsedTime	= ( NULL != pcsec && ( grbit & JET_bitDefragmentBatchStop ) );
	INST * const	pinst				= PinstFromIfmp( ifmp );
	const LONG		fOLDLevel			= ( pinst->m_fOLDLevel & JET_OnlineDefragAllOBSOLETE ?
												JET_OnlineDefragAll :
												pinst->m_fOLDLevel );
	const BOOL		fAvailExtOnly		= ( ( grbit & JET_bitDefragmentAvailSpaceTreesOnly ) ?
												( fOLDLevel & (JET_OnlineDefragDatabases|JET_OnlineDefragSpaceTrees) ) :
												( ( fOLDLevel & JET_OnlineDefragSpaceTrees )
													&& !( fOLDLevel & JET_OnlineDefragDatabases ) ) );
	grbit &= ~JET_bitDefragmentAvailSpaceTreesOnly;

	Assert( !pinst->FRecovering() );
	Assert( !fGlobalRepair );

	if ( fReturnPassCount )
		*pcPasses = 0;

	if ( fReturnElapsedTime )
		*pcsec = 0;

	if ( 0 == fOLDLevel )
		return JET_errSuccess;
	
	if ( dbidTemp == rgfmp[ ifmp ].Dbid() )
		{
		err = ErrERRCheck( JET_errInvalidDatabaseId );
		return err;
		}
	Assert( rgfmp[ ifmp ].Dbid() > 0 );

	if ( rgfmp[ ifmp ].FReadOnlyAttach() )
		{
		err = ErrERRCheck( JET_errDatabaseFileReadOnly );
		return err;
		}

	critOLD.Enter();

	OLDDB_STATUS * const		poldstatDB	= pinst->m_rgoldstatDB + rgfmp[ifmp].Dbid();

	switch( grbit )
		{			
		//  defunct but still used
		case JET_bitDefragmentSLVBatchStart:
		case JET_bitDefragmentSLVBatchStop:
			err = JET_errSuccess;
			break;

		case JET_bitDefragmentBatchStart:
			if ( poldstatDB->FRunning() )
				{
				err = ErrERRCheck( JET_wrnDefragAlreadyRunning );
				}
			else if ( !( fOLDLevel & JET_OnlineDefragDatabases )
					&& !fAvailExtOnly )
				{
				err = JET_errSuccess;
				}
			else
				{
				poldstatDB->Reset();
				
				if ( fAvailExtOnly )
					poldstatDB->SetFAvailExtOnly();

				if ( NULL != pcPasses )
					poldstatDB->SetCPassesMax( *pcPasses );

				poldstatDB->SetCsecStart( UlUtilGetSeconds() );
				if ( NULL != pcsec && *pcsec > 0 )
					poldstatDB->SetCsecMax( poldstatDB->CsecStart() + *pcsec );

				if ( NULL != callback )
					poldstatDB->SetCallback( callback );

				err = poldstatDB->ErrThreadCreate( ifmp, OLDDefragDb );

#ifdef OLD_SCRUB_DB
				if( err >= 0 )
					{
					//	UNDONE: We currently don't clean up the thread handle correctly.  Must
					//	fix the code if this ever gets enabled.
					EnforceSz( fFalse, "Scrubbing during OLD not yet supported" );

					err = poldstatDB->ErrScrubThreadCreate( ifmp );
					}
#endif	//	OLD_SCRUB_DB
				}
			break;
		case JET_bitDefragmentBatchStop:
			if ( !poldstatDB->FRunning()
				|| poldstatDB->FTermRequested() )		//	someone else beat us to it, or the thread is terminating itself
				{
				if ( fOLDLevel & (JET_OnlineDefragDatabases|JET_OnlineDefragSpaceTrees) )
					{
					err = ErrERRCheck( JET_wrnDefragNotRunning );
					}
				else
					{
					//	OLD was force-disabled for this database,
					//	so just report success instead of a warning
					err = JET_errSuccess;
					}
				}
			else
				{
				poldstatDB->SetFTermRequested();
				critOLD.Leave();
				
				poldstatDB->SetSignal();
				if ( poldstatDB->FRunning() )
					{
					poldstatDB->ThreadEnd();
#ifdef OLD_SCRUB_DB				
					poldstatDB->ScrubThreadEnd();
#endif					
					}

				critOLD.Enter();

				if ( fReturnPassCount )
					*pcPasses = poldstatDB->CPasses();
				if ( fReturnElapsedTime )
					*pcsec = (ULONG)( UlUtilGetSeconds() - poldstatDB->CsecStart() );

				poldstatDB->Reset();

				err = JET_errSuccess;	
				}
			break;
			
		default:
			err = ErrERRCheck( JET_errInvalidGrbit );
		}

	critOLD.Leave();

	return err;
	}


ERR ErrIsamDefragment(
	JET_SESID	vsesid,
	JET_DBID	vdbid,
	const CHAR	*szTableName,
	ULONG		*pcPasses,
	ULONG		*pcsec,
	JET_CALLBACK callback,
	JET_GRBIT	grbit )
	{
	ERR			err;
	PIB			*ppib		= (PIB *)vsesid;
	const IFMP	ifmp		= IFMP( DBID( vdbid ) );
	INST* const	pinst		= PinstFromPpib( ppib );

	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrPIBCheckIfmp( ppib, ifmp ) );
	CallR( ErrPIBCheckUpdatable( ppib ) );

	if ( JET_bitDefragmentScrubSLV == grbit )
		{
#if defined( MINIMAL_FUNCTIONALITY ) || defined( DISABLE_SLV )
		CallR( ErrERRCheck( JET_wrnNyi ) );
#else
		CPG cpgSeen;
		CPG cpgScrubbed;
		CallR( ErrSCRUBScrubStreamingFile( ppib, ifmp, &cpgSeen, &cpgScrubbed, NULL ) );
#endif		
		}
	else
		{
		CallR( ErrOLDDefragment( ifmp, szTableName, pcPasses, pcsec, callback, grbit ) );
		}

	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\recupd.cxx ===
#include "std.hxx"

enum RECOPER
	{
	recoperInsert,
	recoperDelete,
	recoperReplace
	};

LOCAL ERR ErrRECIInsert( FUCB *pfucb, VOID *pv, ULONG cbMax, ULONG *pcbActual, const JET_GRBIT grbit );
LOCAL ERR ErrRECIReplace( FUCB *pfucb, const JET_GRBIT grbit );


//  ================================================================
LOCAL ERR ErrRECICallback(
		PIB * const ppib,
		FUCB * const pfucb,
		TDB * const ptdb,
		const JET_CBTYP cbtyp,
		const ULONG ulId,
		void * const pvArg1,
		void * const pvArg2,
		const ULONG ulUnused )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	const JET_SESID sesid 		= (JET_SESID)ppib;
	const JET_TABLEID tableid 	= (JET_TABLEID)pfucb;
	const JET_DBID ifmp 		= (JET_DBID)pfucb->ifmp;

	const VTFNDEF * const pvtfndefSaved = pfucb->pvtfndef;
	pfucb->pvtfndef = &vtfndefIsamCallback;
	
	const TRX trxSession = TrxVERISession( pfucb );
	const CBDESC * pcbdesc = ptdb->Pcbdesc();
	while( NULL != pcbdesc && err >= JET_errSuccess )
		{
		BOOL fVisible = fTrue;
#ifdef VERSIONED_CALLBACKS
		if( !( pcbdesc->fVersioned ) )
			{
			fVisible = fTrue;
			}
		else
			{
			if( trxMax == pcbdesc->trxRegisterCommit0 )
				{
				//  uncommitted register. only visible if we are the session that added it
				Assert( trxMax != pcbdesc->trxRegisterBegin0 );
				Assert( trxMax == pcbdesc->trxRegisterCommit0 );
				Assert( trxMax == pcbdesc->trxUnregisterBegin0 );
				Assert( trxMax == pcbdesc->trxUnregisterCommit0 );
				fVisible = trxSession == pcbdesc->trxRegisterBegin0;
				}
			else if( trxMax == pcbdesc->trxUnregisterBegin0 )
				{
				//  committed register. visible if we began after the register committed
				Assert( trxMax != pcbdesc->trxRegisterBegin0 );
				Assert( trxMax != pcbdesc->trxRegisterCommit0 );
				Assert( trxMax == pcbdesc->trxUnregisterBegin0 );
				Assert( trxMax == pcbdesc->trxUnregisterCommit0 );
				fVisible = TrxCmp( trxSession, pcbdesc->trxRegisterCommit0 ) > 0;
				}
			else if( trxMax == pcbdesc->trxUnregisterCommit0 )
				{
				//	uncommitted unregister. visible unless we are the session that unregistered it
				Assert( trxMax != pcbdesc->trxRegisterBegin0 );
				Assert( trxMax != pcbdesc->trxRegisterCommit0 );
				Assert( trxMax != pcbdesc->trxUnregisterBegin0 );
				Assert( trxMax == pcbdesc->trxUnregisterCommit0 );
				fVisible = trxSession != pcbdesc->trxUnregisterBegin0;
				}
			else
				{
				//  commited unregister. only visible if we began before the unregister committed
				Assert( trxMax != pcbdesc->trxRegisterBegin0 );
				Assert( trxMax != pcbdesc->trxRegisterCommit0 );
				Assert( trxMax != pcbdesc->trxUnregisterBegin0 );
				Assert( trxMax != pcbdesc->trxUnregisterCommit0 );
				fVisible = TrxCmp( trxSession, pcbdesc->trxUnregisterCommit0 ) <= 0;
				}
			}
#endif	//	VERSIONED_CALLBACKS
		
		if( fVisible
			&& ( pcbdesc->cbtyp & cbtyp )
			&& ulId == pcbdesc->ulId )
			{
			++(Ptls()->ccallbacksNested);
			Ptls()->fInCallback = fTrue;

			TRY
				{
				err = (*pcbdesc->pcallback)(
						sesid,
						ifmp,
						tableid,
						cbtyp & pcbdesc->cbtyp,
						pvArg1,
						pvArg2,
						pcbdesc->pvContext,
						ulUnused );
				}
			EXCEPT( efaExecuteHandler )
				{
				err = JET_errCallbackFailed;
				}
			ENDEXCEPT;
				
			if ( JET_errSuccess != err )
				{
				ErrERRCheck( err );
				}
			if( 0 == ( --(Ptls()->ccallbacksNested) ) )
				{
				Ptls()->fInCallback = fFalse;
				}
			}
		pcbdesc = pcbdesc->pcbdescNext;
		}		

	pfucb->pvtfndef = pvtfndefSaved;

	return err;
	}


//  ================================================================
ERR ErrRECCallback( 
		PIB * const ppib,
		FUCB * const pfucb,
		const JET_CBTYP cbtyp,
		const ULONG ulId,
		void * const pvArg1,
		void * const pvArg2,
		const ULONG ulUnused )
//  ================================================================
//
//  Call the specified callback type for the specified id
//
//-
	{
	Assert( JET_cbtypNull != cbtyp );
	
	ERR err = JET_errSuccess;
	
	FCB * const pfcb = pfucb->u.pfcb;
	Assert( NULL != pfcb );
	TDB * const ptdb = pfcb->Ptdb();
	Assert( NULL != ptdb );

	Assert( err >= JET_errSuccess );

	if( NULL != ptdb->Pcbdesc() )
		{
///		pfcb->EnterDDL();
		err = ErrRECICallback( ppib, pfucb, ptdb, cbtyp, ulId, pvArg1, pvArg2, ulUnused );
///		pfcb->LeaveDDL();
		}

	if( err >= JET_errSuccess )
		{
		FCB * const pfcbTemplate = ptdb->PfcbTemplateTable();
		if( pfcbNil != pfcbTemplate )
			{
			TDB * const ptdbTemplate = pfcbTemplate->Ptdb();
			err = ErrRECICallback( ppib, pfucb, ptdbTemplate, cbtyp, ulId, pvArg1, pvArg2, ulUnused );
			}
		}

	return err;
	}


ERR VTAPI ErrIsamUpdate(
  	JET_SESID	sesid,
	JET_VTID	vtid,
	VOID 		*pv,
	ULONG 		cbMax,
	ULONG 		*pcbActual,
	JET_GRBIT	grbit )
	{
 	PIB * const ppib	= reinterpret_cast<PIB *>( sesid );
	FUCB * const pfucb	= reinterpret_cast<FUCB *>( vtid );

	ERR			err;

	CallR( ErrPIBCheck( ppib ) );
	AssertDIRNoLatch( ppib );
	CheckTable( ppib, pfucb );
	CheckSecondary( pfucb );

	if ( FFUCBReplacePrepared( pfucb ) )
		{
		BOOKMARK *pbm;
		
		if ( cbMax > 0 )
			{
			CallR( ErrDIRGetBookmark( pfucb, &pbm ) );
			AssertDIRNoLatch( ppib );
			Assert( pbm->data.Cb() == 0 );
			Assert( pbm->key.Cb() > 0 );
			Assert( pbm->key.prefix.FNull() );

			if ( pcbActual != NULL )
				{
				*pcbActual = pbm->key.Cb();
				}

			pbm->key.CopyIntoBuffer( pv, min( cbMax, (ULONG)pbm->key.Cb() ) ); 
			}						    

		Assert( pfucb->ppib == ppib );
		err = ErrRECIReplace( pfucb, grbit );
		}						   
	else if ( FFUCBInsertPrepared( pfucb ) )
		{
		//	get bookmark of inserted node in pv
		//
		err = ErrRECIInsert( pfucb, pv, cbMax, pcbActual, grbit );
		}
	else
		err = ErrERRCheck( JET_errUpdateNotPrepared );

	//  free temp working buffer
	//
	if ( err >= 0 && !fGlobalRepair )		//	for fGlobalRepair we will cache these until we close the cursor
		{
		RECIFreeCopyBuffer( pfucb );
		}

	AssertDIRNoLatch( ppib );
	Assert( err != JET_errNoCurrentRecord );
	return err;
	}


#ifndef RTM
//  ================================================================
VOID RECReportUndefinedUnicodeEntry(
	IN const OBJID objidTable,
	IN const OBJID objidIndex,
	IN const KEY& 	primaryKey,
	IN const KEY& 	secondaryKey,
	IN const LCID	lcid,
	IN const INT	itag,
	IN const INT	ichOffset,
	IN const BOOL	fInsert )
//  ================================================================
	{
	Assert( primaryKey.Cb() <= JET_cbPrimaryKeyMost );
	Assert( secondaryKey.Cb() <= JET_cbSecondaryKeyMost );
	
	BYTE	rgbPrimaryKey[JET_cbPrimaryKeyMost];
	BYTE	rgbSecondaryKey[JET_cbSecondaryKeyMost];
	CHAR	*szPrimaryKey = NULL;
	CHAR	*szSecondaryKey = NULL;

	primaryKey.CopyIntoBuffer( rgbPrimaryKey, sizeof( rgbPrimaryKey ) );
	secondaryKey.CopyIntoBuffer( rgbSecondaryKey, sizeof( rgbSecondaryKey ) );
	
	szPrimaryKey = (CHAR *)LocalAlloc( 0, JET_cbPrimaryKeyMost * 8 /* hex formatting overhead */ );
	if ( NULL != szPrimaryKey )
		{
		DBUTLSprintHex(
			szPrimaryKey,
			rgbPrimaryKey,
			primaryKey.Cb() );
		}

	szSecondaryKey = (CHAR *)LocalAlloc( 0, JET_cbSecondaryKeyMost * 8 /* hex formatting overhead */ );
	if ( NULL != szSecondaryKey )
		{
		DBUTLSprintHex(
			szSecondaryKey,
			rgbSecondaryKey,
			secondaryKey.Cb() );
		}

	OSTrace(
		ostlMedium,
		OSFormat(
			"UndefinedUnicodeEntry: %s, objidTable = %d, objidIndex = %d, primaryKey = %s, secondaryKey = %s, lcid = %d, itag = %d, ichOffset = %d\n",
			fInsert ? "insert" : "delete",
			objidTable,
			objidIndex,
			( NULL != szPrimaryKey ? szPrimaryKey : "<unknown>" ),
			( NULL != szSecondaryKey ? szSecondaryKey : "<unknown>" ),
			lcid,
			itag,
			ichOffset )
		);

	if ( NULL != szPrimaryKey )
		{
		LocalFree( szPrimaryKey );
		}
	if ( NULL != szSecondaryKey )
		{
		LocalFree( szSecondaryKey );
		}
	}
#endif	//	!RTM


LOCAL ERR ErrRECIUpdateIndex(
	FUCB			*pfucb,
	FCB				*pfcbIdx,
	const RECOPER	recoper,
	const DIB		*pdib = NULL )
	{
	ERR				err = JET_errSuccess;					// error code of various utility
	FUCB			*pfucbIdx;								//	cursor on secondary index
	
	Assert( pfcbIdx != pfcbNil );
	Assert( pfcbIdx->PfcbTable()->Ptdb() != ptdbNil );
	Assert( pfcbIdx->Pidb() != pidbNil );
	Assert( pfucb != pfucbNil );
	Assert( pfucb->ppib != ppibNil );
	Assert( pfucb->ppib->level < levelMax );
	Assert( !Pcsr( pfucb )->FLatched() );
	AssertDIRNoLatch( pfucb->ppib );

	Assert( pfcbIdx->FTypeSecondaryIndex() );
	Assert( pfcbIdx->PfcbTable() == pfucb->u.pfcb );

	//	open FUCB on this index
	//
	CallR( ErrDIROpen( pfucb->ppib, pfcbIdx, &pfucbIdx ) );
	Assert( pfucbIdx != pfucbNil );
	FUCBSetIndex( pfucbIdx );
	FUCBSetSecondary( pfucbIdx );
	
	//	get bookmark of primary index record replaced
	//
	Assert( FFUCBPrimary( pfucb ) );
	Assert( FFUCBUnique( pfucb ) );

#ifdef DEBUG
	const BOOKMARK		*pbmPrimary		= ( recoperInsert == recoper ? pdib->pbm : &pfucb->bmCurr );
	Assert( pbmPrimary->key.prefix.FNull() );
	Assert( pbmPrimary->key.Cb() > 0 );
	Assert( pbmPrimary->data.FNull() );
#endif

	if ( recoperInsert == recoper )
		{
		Assert( NULL != pdib );
		err = ErrRECIAddToIndex( pfucb, pfucbIdx, pdib->pbm, pdib->dirflag );
		}
	else
		{
		Assert( NULL == pdib );
		if ( recoperDelete == recoper )
			{
			err = ErrRECIDeleteFromIndex( pfucb, pfucbIdx, &pfucb->bmCurr );
			}
		else
			{
			Assert( recoperReplace == recoper);
			err = ErrRECIReplaceInIndex( pfucb, pfucbIdx, &pfucb->bmCurr );
			}
		}

	//	close the FUCB
	//
	DIRClose( pfucbIdx );

	AssertDIRNoLatch( pfucb->ppib );
	return err;
	}


LOCAL BOOL FRECIAllSparseIndexColumnsSet(
	const IDB * const		pidb,
	const FUCB * const		pfucbTable )
	{
	Assert( pidb->FSparseIndex() );

	if ( pidb->CidxsegConditional() > 0 )
		{
		//	can't use IDB's rgbitIdx because
		//	we must filter out conditional index
		//	columns

		const FCB * const		pfcbTable	= pfucbTable->u.pfcb;
		const TDB * const		ptdb		= pfcbTable->Ptdb();
		const IDXSEG *			pidxseg		= PidxsegIDBGetIdxSeg( pidb, ptdb );
		const IDXSEG * const	pidxsegMac	= pidxseg + pidb->Cidxseg();

		Assert( pidxseg < pidxsegMac );
		for ( ; pidxseg < pidxsegMac; pidxseg++ )
			{
			if ( !FFUCBColumnSet( pfucbTable, pidxseg->Fid() ) )
				{
				//	found a sparse index column that didn't get set
				return fFalse;
				}
			}
		}
	else
		{
		//	no conditional columns, so we can use
		//	the IDB bit array

		const LONG_PTR *		plIdx		= (LONG_PTR *)pidb->RgbitIdx();
		const LONG_PTR * const	plIdxMax	= plIdx + ( cbRgbitIndex / sizeof(LONG_PTR) );
		const LONG_PTR *		plSet		= (LONG_PTR *)pfucbTable->rgbitSet;
 
		for ( ; plIdx < plIdxMax; plIdx++, plSet++ )
			{
			if ( (*plIdx & *plSet) != *plIdx )
				{
				//	found a sparse index column that didn't get set
				return fFalse;
				}
			}
		}

	//	all sparse index columns were set
	return fTrue;
	}
	
LOCAL BOOL FRECIAnySparseIndexColumnSet(
	const IDB * const		pidb,
	const FUCB * const		pfucbTable )
	{
	Assert( pidb->FSparseIndex() );

	if ( pidb->CidxsegConditional() > 0 )
		{
		//	can't use IDB's rgbitIdx because
		//	we must filter out conditional index
		//	columns

		const FCB * const		pfcbTable	= pfucbTable->u.pfcb;
		const TDB * const		ptdb		= pfcbTable->Ptdb();
		const IDXSEG *			pidxseg		= PidxsegIDBGetIdxSeg( pidb, ptdb );
		const IDXSEG * const	pidxsegMac	= pidxseg + pidb->Cidxseg();

		Assert( pidxseg < pidxsegMac );
		for ( ; pidxseg < pidxsegMac; pidxseg++ )
			{
			if ( FFUCBColumnSet( pfucbTable, pidxseg->Fid() ) )
				{
				//	found a sparse index column that got set
				return fTrue;
				}
			}
		}

	else
		{
		//	no conditional columns, so we can use
		//	the IDB bit array

		const LONG_PTR *		plIdx		= (LONG_PTR *)pidb->RgbitIdx();
		const LONG_PTR * const	plIdxMax	= plIdx + ( cbRgbitIndex / sizeof(LONG_PTR) );
		const LONG_PTR *		plSet		= (LONG_PTR *)pfucbTable->rgbitSet;
 
		for ( ; plIdx < plIdxMax; plIdx++, plSet++ )
			{
			if ( *plIdx & *plSet )
				{
				//	found a sparse index column that got set
				return fTrue;
				}
			}
		}

	//	no sparse index columns were set
	return fFalse;
	}
	

INLINE BOOL FRECIPossiblyUpdateSparseIndex(
	const IDB * const		pidb,
	const FUCB * const		pfucbTable )
	{
	Assert( pidb->FSparseIndex() );

	if ( !pidb->FAllowSomeNulls() )
		{
		//	IgnoreAnyNull specified, so only need to
		//	update the index if all index columns
		//	were set
		return FRECIAllSparseIndexColumnsSet( pidb, pfucbTable );
		}
	else if ( !pidb->FAllowFirstNull() )
		{
		//	IgnoreFirstNull specified, so only need to
		//	update the index if the first column was set
		const FCB * const		pfcbTable	= pfucbTable->u.pfcb;
		const TDB * const		ptdb		= pfcbTable->Ptdb();
		const IDXSEG *			pidxseg		= PidxsegIDBGetIdxSeg( pidb, ptdb );
		return FFUCBColumnSet( pfucbTable, pidxseg->Fid() );
		}
	else
		{
		//	IgnoreNull specified, so need to update the
		//	index if any index column was set
		return FRECIAnySparseIndexColumnSet( pidb, pfucbTable );
		}
	}

LOCAL BOOL FRECIPossiblyUpdateSparseConditionalIndex(
	const IDB * const	pidb,
	const FUCB * const	pfucbTable )
	{
	Assert( pidb->FSparseConditionalIndex() );
	Assert( pidb->CidxsegConditional() > 0 );

	const FCB * const		pfcbTable	= pfucbTable->u.pfcb;
	const TDB * const		ptdb		= pfcbTable->Ptdb();
	const IDXSEG *			pidxseg		= PidxsegIDBGetIdxSegConditional( pidb, ptdb );
	const IDXSEG * const	pidxsegMac	= pidxseg + pidb->CidxsegConditional();

	//	check conditional columns and see if we can
	//	automatically deduce whether the record should
	//	be added to the index, regardless of whether any
	//	of the actual index columns were set or not
	for ( ; pidxseg < pidxsegMac; pidxseg++ )
		{
		//	check that the update didn't modify the
		//	conditional column
		if ( !FFUCBColumnSet( pfucbTable, pidxseg->Fid() ) )
			{
			const FIELD * const	pfield	= ptdb->Pfield( pidxseg->Columnid() );

			if ( !FFIELDUserDefinedDefault( pfield->ffield ) )
				{
				//	given that the update didn't modify the
				//	conditional column, see if the default
				//	value of the column would cause the
				//	record to be excluded from the index
				//	(NOTE: default values cannot be NULL)
				const BOOL	fHasDefault	= FFIELDDefault( pfield->ffield );
				const BOOL	fSparse		= ( pidxseg->FMustBeNull() ?
												fHasDefault :
												!fHasDefault );
				if ( fSparse )
					{
					//	this record will be excluded from
					//	the index
					return fFalse;
					}
				}
			}
		}

	//	could not exclude the record based on
	//	unset conditional columns
	return fTrue;
	}


//  ================================================================
LOCAL BOOL FRECIHasUserDefinedColumns( const IDXSEG * const pidxseg, const INT cidxseg, const TDB * const ptdb )
//  ================================================================
	{
	INT iidxseg;
	for( iidxseg = 0; iidxseg < cidxseg; ++iidxseg )
		{
		const FIELD * const pfield = ptdb->Pfield( pidxseg[iidxseg].Columnid() );
		if( FFIELDUserDefinedDefault( pfield->ffield ) )
			{
			return fTrue;
			}
		}
	return fFalse;
	}

//  ================================================================
LOCAL BOOL FRECIHasUserDefinedColumns( const IDB * const pidb, const TDB * const ptdb )
//  ================================================================
	{
	const INT cidxseg = pidb->Cidxseg();
	const IDXSEG * const pidxseg = PidxsegIDBGetIdxSeg( pidb, ptdb );
	if( FRECIHasUserDefinedColumns( pidxseg, cidxseg, ptdb ) )
		{
		return fTrue;
		}
	else if( pidb->CidxsegConditional() > 0 )
		{
		const INT cidxsegConditional = pidb->CidxsegConditional();
		const IDXSEG * const pidxsegConditional = PidxsegIDBGetIdxSegConditional( pidb, ptdb );
		return FRECIHasUserDefinedColumns( pidxsegConditional, cidxsegConditional, ptdb );
		}
	return fFalse;
	}


LOCAL VOID RECIReportIndexCorruption( const FCB * const pfcbIdx )
	{
	const IDB * const	pidb					= pfcbIdx->Pidb();
	INT					iszT					= 0;
	const CHAR *		rgszT[3];

	//	only for secondary indexes
	Assert( pidbNil != pidb );
	Assert( !pidb->FPrimary() );

	//	pfcbTable may not be linked up if we're in CreateIndex(),
	//	in which case we don't have access to the information
	//	we want to report
	if ( pfcbNil == pfcbIdx->PfcbTable() )
		return;

	//	WARNING! WARNING!  This code currently does not grab the DML latch,
	//	so there doesn't appear to be any guarantee that the table and index
	//	name won't be relocated from underneath us

	const BOOL			fHasUserDefinedColumns	= FRECIHasUserDefinedColumns(
															pidb,
															pfcbIdx->PfcbTable()->Ptdb() );

	rgszT[iszT++] = pfcbIdx->PfcbTable()->Ptdb()->SzIndexName(
														pidb->ItagIndexName(),
														pfcbIdx->FDerivedIndex() );
	rgszT[iszT++] = pfcbIdx->PfcbTable()->Ptdb()->SzTableName();
	rgszT[iszT++] = fHasUserDefinedColumns ? "1" : "0";

	Assert( iszT == ( sizeof( rgszT ) / sizeof( rgszT[0] ) ) );

	UtilReportEvent(
			eventError,
			DATABASE_CORRUPTION_CATEGORY,
			INDEX_CORRUPTED_ID,
			iszT,
			rgszT,
			0,
			NULL,
			PinstFromIfmp( pfcbIdx->Ifmp() ) );
	}


LOCAL ERR ErrRECICheckESE97Compatibility( FUCB * const pfucb, const DATA& dataRec )
	{
	ERR					err;
	FCB * const			pfcbTable		= pfucb->u.pfcb;
	const REC * const	prec			= (REC *)dataRec.Pv();
	size_t				cbRecESE97;

	Assert( pfcbTable->FTypeTable() );

	//	fixed/variable column overhead hasn't changed
	//
	//	UNDONE: we don't currently account for fixed/variable columns
	//	that may have been deleted
	//
	cbRecESE97 = prec->PbTaggedData() - (BYTE *)prec;
	Assert( cbRecESE97 <= cbRECRecordMost );
	Assert( cbRecESE97 <= dataRec.Cb() );

	//	OPTIMISATION: see if the record size is small enough such that
	//	we know we're guaranteed to fit in an ESE97 record
	//
	//	The only size difference between ESE97 and ESE98 is the amount
	//	of overhead that multi-values consume.  Fixed, variable, and
	//	non-multi-valued tagged columns still take the same amount of
	//	overhead.  Thus, for the greatest size difference, we need to
	//	ask how we could cram the most multi-values into a record.
	//	The answer is to have just a single multi-valued non-long-value
	//	tagged column where all multi-values contain zero-length data.
	//
	//	So what we're going to do first is take the amount of possible
	//	record space remaining and compute how many such ESE97 multi-
	//	values we could fill that space with.
	//
	const size_t		cbESE97Remaining			= ( cbRECRecordMost - cbRecESE97 );
	const size_t		cESE97MultiValues			= cbESE97Remaining / sizeof(TAGFLD);

	//	In ESE98, the marginal cost for a multi-value is 2 bytes, and the
	//	overhead for the initial column is 5 bytes.
	//
	const size_t		cbESE98ColumnOverhead		= 5;
	const size_t		cbESE98MultiValueOverhead	= 2;

	//	Next, see how big the tagged data would be if the same
	//	multi-values were represented in ESE98.  This will be
	//	our threshold record size.  If the current tagged data
	//	is less than this threshold, then we're guaranteed
	//	that this record will fit in ESE97 no matter what.
	//
	const size_t		cbESE98Threshold			= cbESE98ColumnOverhead
														+ ( cESE97MultiValues * cbESE98MultiValueOverhead );
	const BOOL			fRecordWillFitInESE97		= ( ( dataRec.Cb() - cbRecESE97 ) <= cbESE98Threshold );

	if ( fRecordWillFitInESE97 )
		{
#ifdef DEBUG
		//	in DEBUG, take non-optimised path anyway to verify
		//	that record does indeed fit in ESE97
#else
		return JET_errSuccess;
#endif
		}
	else
		{
		//	this DOESN'T mean that the record won't fit, it
		//	just means it may or may not fit, we can't make
		//	an absolute determination just by the record
		//	size, so we have to iterate through all the
		//	tagged data 
		}


	//	If the optimisation above couldn't definitively
	//	determine if the record will fit in ESE97, then
	//	we have to take the slow path of computing
	//	ESE97 record size column-by-column.
	//
	CTaggedColumnIter	citerTagged;
	Call( citerTagged.ErrInit( pfcbTable, dataRec ) );	//	initialises currency to BeforeFirst

	while ( JET_errNoCurrentRecord != ( err = citerTagged.ErrMoveNext() ) )
		{
		COLUMNID	columnid;
		size_t		cbESE97Format;

		//	validate error returned from column navigation
		//
		Call( err );

		//	ignore columns that are not visible to us (we're assuming the
		//	column has been deleted and the column space would be able to
		//	be re-used
		//
		Call( citerTagged.ErrGetColumnId( &columnid ) );
		err = ErrRECIAccessColumn( pfucb, columnid );
		if ( JET_errColumnNotFound != err )
			{
			Call( err );

			Call( citerTagged.ErrCalcCbESE97Format( &cbESE97Format ) );
			cbRecESE97 += cbESE97Format;

			if ( cbRecESE97 > cbRECRecordMost )
				{
				Assert( !fRecordWillFitInESE97 );
				Call( ErrERRCheck( JET_errRecordTooBigForBackwardCompatibility ) );
				}
			}
		}

	Assert( cbRecESE97 <= cbRECRecordMost );
	err = JET_errSuccess;
	
HandleError:
	return err;
	}

//+local
// ErrRECIInsert
// ========================================================================
// ErrRECIInsert( FUCB *pfucb, VOID *pv, ULONG cbMax, ULONG *pcbActual, DIRFLAG dirflag )
//
// Adds a record to a data file.  All indexes on the data file are
// updated to reflect the addition.
//
// PARAMETERS	pfucb						FUCB for file
//				pv							pointer to bookmark buffer pv != NULL, bookmark is returned
//				cbMax						size of bookmark buffer
//				pcbActual					returned size of bookmark
//
// RETURNS		Error code, one of the following:
//					 JET_errSuccess		Everything went OK.
//					-KeyDuplicate		The record being added causes
//										an illegal duplicate entry in an index.
//					-NullKeyDisallowed	A key of the new record is NULL.
//					-RecordNoCopy		There is no working buffer to add from.
//					-NullInvalid		The record being added contains
//										at least one null-valued field
//										which is defined as NotNull.
// SIDE EFFECTS
//		After addition, file currency is left on the new record.
//		Index currency (if any) is left on the new index entry.
//		On failure, the currencies are returned to their initial states.
//
//	COMMENTS
//		No currency is needed to add a record.
//		A transaction is wrapped around this function.	Thus, any
//		work done will be undone if a failure occurs.
//-
LOCAL ERR ErrRECIInsert(
	FUCB *			pfucb,
	VOID *			pv,
	ULONG			cbMax,
	ULONG *			pcbActual,
	const JET_GRBIT	grbit )
	{
	ERR				err;  						 	// error code of various utility
	PIB *			ppib					= pfucb->ppib;
	KEY				keyToAdd;					 	// key of new data record
	BYTE			rgbKey[ JET_cbPrimaryKeyMost ];	// key buffer
	FCB *			pfcbTable;					 	// file's FCB
	FCB *			pfcbIdx;					 	// loop variable for each index on file
	FUCB *			pfucbT					= pfucbNil;
	BOOL			fUpdatingLatchSet		= fFalse;
	BOOL			fUndefinedUnicodeChars 	= fFalse;

	CheckPIB( ppib );
	AssertDIRNoLatch( ppib );
	CheckTable( ppib, pfucb );
	CheckSecondary( pfucb );

	//	should have been checked in PrepareUpdate
	//
	Assert( FFUCBUpdatable( pfucb ) );
	Assert( FFUCBInsertPrepared( pfucb ) );

	//	efficiency variables
	//
	pfcbTable = pfucb->u.pfcb;
	Assert( pfcbTable != pfcbNil );

	//	if necessary, begin transaction
	//
	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );

	//	delete the original copy if necessary
	if ( FFUCBInsertCopyDeleteOriginalPrepared( pfucb ) )
		{
		FUCBSetUpdateForInsertCopyDeleteOriginal( pfucb );
		Call( ErrIsamDelete( ppib, pfucb ) );
		}

	// Do the BeforeInsert callback
	Call( ErrRECCallback( ppib, pfucb, JET_cbtypBeforeInsert, 0, NULL, NULL, 0 ) );

	//	open temp FUCB on data file
	//
	Call( ErrDIROpen( ppib, pfcbTable, &pfucbT ) );
	Assert( pfucbT != pfucbNil );
	FUCBSetIndex( pfucbT );

	Assert( !pfucb->dataWorkBuf.FNull() );
	BOOL fIllegalNulls;
	Call( ErrRECIIllegalNulls( pfucb, pfucb->dataWorkBuf, &fIllegalNulls ) );
	if ( fIllegalNulls )
		{
		err = ErrERRCheck( JET_errNullInvalid );
		goto HandleError;
		}

	if ( grbit & JET_bitUpdateCheckESE97Compatibility )
		{
		Call( ErrRECICheckESE97Compatibility( pfucb, pfucb->dataWorkBuf ) );
		}

	Call( pfcbTable->ErrSetUpdatingAndEnterDML( ppib ) );
	fUpdatingLatchSet = fTrue;
	
	//	set version and autoinc columns
	//
	pfcbTable->AssertDML();

	FID		fidVersion;
	fidVersion = pfcbTable->Ptdb()->FidVersion();		// UNDONE: Need to properly version these.
	if ( fidVersion != 0 && !( FFUCBColumnSet( pfucb, fidVersion ) ) )
		{
		//	set version column to zero
		//
		TDB *			ptdbT			= pfcbTable->Ptdb();
		const BOOL		fTemplateColumn	= ptdbT->FFixedTemplateColumn( fidVersion );
		const COLUMNID	columnidT		= ColumnidOfFid( fidVersion, fTemplateColumn );
		ULONG			ul				= 0;
		DATA			dataField;

		if ( fTemplateColumn )
			{
			Assert( FCOLUMNIDTemplateColumn( columnidT ) );
			if ( !pfcbTable->FTemplateTable() )
				{
				// Switch to template table.
				ptdbT->AssertValidDerivedTable();
				ptdbT = ptdbT->PfcbTemplateTable()->Ptdb();
				}
			else
				{
				ptdbT->AssertValidTemplateTable();
				}
			}
		else
			{
			Assert( !FCOLUMNIDTemplateColumn( columnidT ) );
			Assert( !pfcbTable->FTemplateTable() );
			}

		dataField.SetPv( (BYTE *)&ul );
		dataField.SetCb( sizeof(ul) );
		err = ErrRECISetFixedColumn(
					pfucb,
					ptdbT,
					columnidT,
					&dataField );
		if ( err < 0 )
			{
			pfcbTable->LeaveDML();
			goto HandleError;
			}
		}

	pfcbTable->AssertDML();
	
#ifdef DEBUG	
	if ( pfcbTable->Ptdb()->FidAutoincrement() != 0 )
		{
		const TDB		* const ptdbT	= pfcbTable->Ptdb();
		const BOOL		fTemplateColumn	= ptdbT->FFixedTemplateColumn( ptdbT->FidAutoincrement() );
		const COLUMNID	columnidT		= ColumnidOfFid( ptdbT->FidAutoincrement(), fTemplateColumn );
		DATA			dataT;

		Assert( FFUCBColumnSet( pfucb, FidOfColumnid( columnidT ) ) );

		// Just retrieve column, even if we don't have versioned
		// access to it.
		CallS( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbT,
				columnidT,
				pfucb->dataWorkBuf,
				&dataT ) );
		
		Assert( !( pfcbTable->FTypeSort()
				|| pfcbTable->FTypeTemporaryTable() ) );	// Don't currently support autoinc with sorts/temp. tables

		Assert( ptdbT->QwAutoincrement() > 0 );
		if ( ptdbT->F8BytesAutoInc() )
			{
			Assert( dataT.Cb() == sizeof(QWORD) );
			Assert( *(UnalignedLittleEndian< QWORD > *)dataT.Pv() <= ptdbT->QwAutoincrement() );
			}
		else
			{
			Assert( dataT.Cb() == sizeof(ULONG) );
			Assert( *(UnalignedLittleEndian< ULONG > *)dataT.Pv() <= (ULONG)ptdbT->QwAutoincrement() );
			}
		}
#endif

	pfcbTable->LeaveDML();

	//	get key to add with new record
	//
	keyToAdd.prefix.Nullify();
	keyToAdd.suffix.SetPv( rgbKey );
	if ( pidbNil == pfcbTable->Pidb() )
		{
		DBK	dbk;

		//	file is sequential
		//

		//	dbk's are numbered starting at 1.  A dbk of 0 indicates that we must
		//	first retrieve the dbkMost.  In the pathological case where there are
		//	currently no dbk's, we'll go through here anyway, but only the first
		//	time (since there will be dbk's after that).
		//
		if ( pfcbTable->Ptdb()->DbkMost() == 0 )
			{
			DIB		dib;

			DIRGotoRoot( pfucbT );

			//	down to the last data record
			//
			dib.dirflag = fDIRNull;
			dib.pos = posLast;
			err = ErrDIRDown( pfucbT, &dib );
			Assert( err != JET_errNoCurrentRecord );
			switch( err )
				{
				case JET_errSuccess:
					{
					BYTE	rgbT[4];
					pfucbT->kdfCurr.key.CopyIntoBuffer( rgbT, sizeof( rgbT ) );
					dbk = ( rgbT[0] << 24 ) + ( rgbT[1] << 16 ) + ( rgbT[2] << 8 ) + rgbT[3];
					Assert( dbk > 0 );		// dbk's start numbering at 1
					DIRUp( pfucbT );
					Assert( !Pcsr( pfucbT )->FLatched( ) );
					break;
					}
				case JET_errRecordNotFound:
					Assert( !Pcsr( pfucbT )->FLatched( ) );
					dbk = 0;
					break;

				default:
					Assert( !Pcsr( pfucbT )->FLatched( ) );
					goto HandleError;
				}

			//	if there are no records in the table, then the first
			//	dbk value is 1.  Otherwise, set dbk to next value after
			//	maximum found.
			//
			dbk++;

			//	While retrieving the dbkMost, someone else may have been
			//	doing the same thing and beaten us to it.  When this happens,
			//	cede to the other guy.
			//
			pfcbTable->Ptdb()->InitDbkMost( dbk );
			}

		Call( pfcbTable->Ptdb()->ErrGetAndIncrDbkMost( &dbk ) );
		Assert( dbk > 0 );

		keyToAdd.suffix.SetCb( sizeof(DBK) );

		BYTE	*pb = (BYTE *) keyToAdd.suffix.Pv();
		pb[0] = (BYTE)((dbk >> 24) & 0xff);
		pb[1] = (BYTE)((dbk >> 16) & 0xff);
		pb[2] = (BYTE)((dbk >> 8) & 0xff);
		pb[3] = (BYTE)(dbk & 0xff);
		}

	else
		{
		//	file is primary
		//		
		Assert( !pfcbTable->Pidb()->FMultivalued() );
		Assert( !pfcbTable->Pidb()->FTuples() );
		Call( ErrRECRetrieveKeyFromCopyBuffer(
			pfucb,
			pfcbTable->Pidb(),
			&keyToAdd, 
			1,
			0,
			&fUndefinedUnicodeChars,
			prceNil ) );

		CallS( ErrRECValidIndexKeyWarning( err ) );
		Assert( wrnFLDNotPresentInIndex != err );
		Assert( wrnFLDOutOfKeys != err );
		Assert( wrnFLDOutOfTuples != err );

		if ( pfcbTable->Pidb()->FNoNullSeg()
			&& ( wrnFLDNullKey == err || wrnFLDNullFirstSeg == err || wrnFLDNullSeg == err ) )
			Error( ErrERRCheck( JET_errNullKeyDisallowed ), HandleError )
		}

	//	check if return buffer for bookmark is sufficient size
	//
	if ( pv != NULL && (ULONG)keyToAdd.Cb() > cbMax )
		{
		Error( ErrERRCheck( JET_errBufferTooSmall ), HandleError )
		}

	//	insert record.  Move to DATA root.
	//
	DIRGotoRoot( pfucbT );

	Call( ErrDIRInsert( pfucbT, keyToAdd, pfucb->dataWorkBuf, fDIRNull ) );

	if( fUndefinedUnicodeChars )
		{
		Assert( pidbNil != pfcbTable->Pidb() );
		
		RECReportUndefinedUnicodeEntry(
			pfcbTable->ObjidFDP(),
			pfcbTable->ObjidFDP(),
			keyToAdd,
			keyToAdd,
			pfcbTable->Pidb()->Lcid(),
			1,
			0,
			fTrue );

		if( pfcbTable->Pidb()->FUnicodeFixupOn() )
			{
			Call( ErrCATInsertMSURecord(
					pfucb->ppib,
					pfucb->ifmp,
					pfucbNil, 
					pfcbTable->ObjidFDP(),
					pfcbTable->ObjidFDP(),
					keyToAdd,
					keyToAdd,
					pfcbTable->Pidb()->Lcid(),
					1,
					0 ) );
			}
		}
	
	//	return bookmark of inserted record
	//
	AssertDIRNoLatch( ppib );
	Assert( !pfucbT->bmCurr.key.FNull() && pfucbT->bmCurr.key.Cb() == keyToAdd.Cb() );
	Assert( pfucbT->bmCurr.data.Cb() == 0 );

	if ( pcbActual != NULL || pv != NULL )
		{
		BOOKMARK	*pbmPrimary;	//	bookmark of primary index node inserted

		CallS( ErrDIRGetBookmark( pfucbT, &pbmPrimary ) );
		
		//	set return values
		//
		if ( pcbActual != NULL )
			{
			Assert( pbmPrimary->key.Cb() == keyToAdd.Cb() );
			*pcbActual = pbmPrimary->key.Cb();
			}
		
		if ( pv != NULL )
			{
			Assert( cbMax >= (ULONG)pbmPrimary->key.Cb() );
			pbmPrimary->key.CopyIntoBuffer( pv, min( cbMax, (ULONG)pbmPrimary->key.Cb() ) ); 
			}
		}

#ifdef DISABLE_SLV
#else

	// UNDONE SLVOWNERMAP: performance double scan in loop and in slvInfo.ErrLoad !!!! To be changed
	if ( FFUCBSLVOwnerMapNeedUpdate( pfucb )
		|| FFUCBUpdateForInsertCopyDeleteOriginal( pfucb ) ) // we have to update the ownership of the SLV space
		{
		BOOKMARK	bmForOwnerMap;

		bmForOwnerMap.Nullify();

#ifdef DEBUG
		keyToAdd.AssertValid();
#endif // DEBUG		
	
		bmForOwnerMap.key.suffix.SetCb( keyToAdd.suffix.Cb() );
		bmForOwnerMap.key.suffix.SetPv( keyToAdd.suffix.Pv() );
		bmForOwnerMap.key.prefix.SetCb( keyToAdd.prefix.Cb() );
		bmForOwnerMap.key.prefix.SetPv( keyToAdd.prefix.Pv() );

		TAGFIELDS	tagfields( pfucb->dataWorkBuf );
		Call( tagfields.ErrUpdateSLVOwnerMapForRecordInsert( pfucb, bmForOwnerMap ) );
		
		FUCBResetSLVOwnerMapNeedUpdate( pfucb );
		}

#endif	//	DISABLE_SLV

	
	//	insert item in secondary indexes
	//
	// No critical section needed to guard index list because Updating latch
	// protects it.
	DIB		dib;
	BOOL fInsertCopy;
	fInsertCopy = FFUCBInsertCopyPrepared( pfucb );
	dib.pbm		= &pfucbT->bmCurr;
	dib.dirflag	= fDIRNull;
	for ( pfcbIdx = pfcbTable->PfcbNextIndex();
		pfcbIdx != pfcbNil;
		pfcbIdx = pfcbIdx->PfcbNextIndex() )
		{
		if ( FFILEIPotentialIndex( ppib, pfcbTable, pfcbIdx ) )
			{
			const IDB * const	pidb		= pfcbIdx->Pidb();
			BOOL				fUpdate		= fTrue;

			if ( !fInsertCopy )
				{
				//	see if the sparse conditional index can tell
				//	us to skip the update
				if ( pidb->FSparseConditionalIndex() )
					fUpdate = FRECIPossiblyUpdateSparseConditionalIndex( pidb, pfucb );

				//	if the sparse conditional index could not cause us to
				//	skip the index update, see if the sparse index can
				//	tell us to skip the update
				if ( fUpdate && pidb->FSparseIndex() )
					fUpdate = FRECIPossiblyUpdateSparseIndex( pidb, pfucb );
				}

			if ( fUpdate )
				{
				Call( ErrRECIUpdateIndex( pfucb, pfcbIdx, recoperInsert, &dib ) );
				}
			}
		}
	
	Assert( pfcbTable != pfcbNil );
	pfcbTable->ResetUpdating();
	fUpdatingLatchSet = fFalse;

	DIRClose( pfucbT );
	pfucbT = pfucbNil;

	//	if no error, commit transaction
	//
	Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );
		
	FUCBResetUpdateFlags( pfucb );

	// Do the AfterInsert callback
	CallS( ErrRECCallback( ppib, pfucb, JET_cbtypAfterInsert, 0, NULL, NULL, 0 ) );

	AssertDIRNoLatch( ppib );

	return err;

HandleError:
	Assert( err < 0 );
	
	if ( fUpdatingLatchSet )
		{
		Assert( pfcbTable != pfcbNil );
		pfcbTable->ResetUpdating();
		}

	if ( pfucbNil != pfucbT )
		{
		DIRClose( pfucbT );
		}

	/*	rollback all changes on error
	/**/
	CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );

	AssertDIRNoLatch( ppib );
	return err;
	}


// Called by defrag to insert record but preserve copy buffer.
ERR ErrRECInsert( FUCB *pfucb, BOOKMARK * const pbmPrimary )
	{
	ERR		err;
	PIB		*ppib = pfucb->ppib;
	
	AssertDIRNoLatch( ppib );
	CheckTable( ppib, pfucb );
	CheckSecondary( pfucb );
	Assert( pfucb->pfucbCurIndex == pfucbNil );
	Assert( !FFUCBSecondary( pfucb ) );

	if ( NULL != pbmPrimary )
		{
		ULONG cb = pbmPrimary->key.suffix.Cb();
		err = ErrRECIInsert(
					pfucb,
					pbmPrimary->key.suffix.Pv(),
					JET_cbBookmarkMost,
					&cb,
					NO_GRBIT );
		pbmPrimary->key.suffix.SetCb( cb );
		Assert( pbmPrimary->key.suffix.Cb() <= JET_cbBookmarkMost );
		}
	else
		{
		err = ErrRECIInsert( pfucb, NULL, 0, NULL, NO_GRBIT );
		}
	
	Assert( JET_errNoCurrentRecord != err );
	
	AssertDIRNoLatch( ppib );
	return err;
	}


//+local
// ErrRECIAddToIndex
// ========================================================================
// ERR ErrRECIAddToIndex( FCB *pfcbIdx, FUCB *pfucb )
//
// Extracts key from data record and adds that key with the given SRID to the index
//
// PARAMETERS	pfcbIdx 		  			FCB of index to insert into
//				pfucb						cursor pointing to primary index record
//
// RETURNS		JET_errSuccess, or error code from failing routine
//
// SIDE EFFECTS 
// SEE ALSO		Insert
//-
ERR	ErrRECIAddToIndex(
	FUCB		*pfucb,
	FUCB		*pfucbIdx,
	BOOKMARK	*pbmPrimary,
	DIRFLAG 	dirflag,
	RCE			*prcePrimary )
	{
	ERR			err;
	const FCB	* const pfcbIdx			= pfucbIdx->u.pfcb;
	const IDB	* const pidb			= pfcbIdx->Pidb();
	KEY			keyToAdd;
	BYTE		rgbKey[ JET_cbSecondaryKeyMost ];
	ULONG		itagSequence;
	BOOL		fNullKey				= fFalse;
	BOOL		fIndexUpdated			= fFalse;
	BOOL		fUndefinedUnicodeChars	= fFalse;

	AssertDIRNoLatch( pfucb->ppib );
	
	Assert( pfcbIdx != pfcbNil );
	Assert( pfcbIdx->FTypeSecondaryIndex() );
	Assert( pidbNil != pidb );

	Assert( prceNil != prcePrimary  ?
				pfcbNil == pfcbIdx->PfcbTable() :		//	InsertByProxy: index not linked in yet
				pfcbIdx->PfcbTable() == pfucb->u.pfcb );

	keyToAdd.prefix.Nullify();
	keyToAdd.suffix.SetPv( rgbKey );
	for ( itagSequence = 1; ; itagSequence++ )
		{
		fUndefinedUnicodeChars = fFalse;
		
		CallR( ErrRECRetrieveKeyFromCopyBuffer(
				pfucb,
				pidb,
				&keyToAdd,
				itagSequence,
				0,
				&fUndefinedUnicodeChars,
				prcePrimary ) );

		CallS( ErrRECValidIndexKeyWarning( err ) );

		if ( wrnFLDOutOfKeys == err )
			{
			Assert( itagSequence > 1 );
			break;
			}

		else if ( wrnFLDOutOfTuples == err )
			{
			//	try next itagSequence
			Assert( pidb->FTuples() );
			if ( pidb->FMultivalued() )
				{
				//	NOTE: if we got wrnFLDOutOfTuples because
				//	itagSequence 1 was NULL (ie. there are no
				//	more multivalues), we are actually going
				//	to make one more iteration of this loop
				//	and break out when itagSequence 2 returns
				//	wrnFLDOutOfKeys.
				//	UNDONE: optimise to not require a second
				//	iteration
				continue;
				}
			else
				break;
			}

		else if ( wrnFLDNotPresentInIndex == err )
			{
			Assert( 1 == itagSequence );
//			AssertSz( fFalse, "[laurionb]: ErrRECIAddToIndex: new record is not in index" );
			break;
			}

		else if ( pidb->FNoNullSeg()
			&& ( wrnFLDNullKey == err || wrnFLDNullFirstSeg == err || wrnFLDNullSeg == err ) )
			{
			err = ErrERRCheck( JET_errNullKeyDisallowed );
			return err;
			}

		if ( wrnFLDNullKey == err )
			{
			Assert( 1 == itagSequence );	//	nulls beyond itagSequence 1 would have generated wrnFLDOutOfKeys
			Assert( !pidb->FTuples() );		//	tuple indexes would have generated wrnFLDOutOfTuples instead
			if ( !pidb->FAllowAllNulls() )
				break;
			fNullKey = fTrue;
			}
		else if ( ( wrnFLDNullFirstSeg  == err && !pidb->FAllowFirstNull() )
				|| ( wrnFLDNullSeg == err && !pidb->FAllowSomeNulls() ) )
			{
			break;
			}

		//	insert index-fixup node if needed
		//
		if( fUndefinedUnicodeChars )
			{
			RECReportUndefinedUnicodeEntry(
				pfucb->u.pfcb->ObjidFDP(),
				pfcbIdx->ObjidFDP(),
				pbmPrimary->key,
				keyToAdd,
				pfcbIdx->Pidb()->Lcid(),
				itagSequence,
				0,
				fTrue );

			if( pfcbIdx->Pidb()->FUnicodeFixupOn() )
				{
				if ( prceNil != prcePrimary )
					{
					//	UNDONE: we're in the update phase of
					//	concurrent create-index, and it's too
					//	complicated to try to update the
					//	fixup table at this point, so just
					//	flag the index as having fixups
					//	disabled
					//
					pfcbIdx->Pidb()->ResetFUnicodeFixupOn();
					}
				else
					{
					CallR( ErrCATInsertMSURecord(
								pfucb->ppib,
								pfucb->ifmp,
								pfucbNil,
								pfucb->u.pfcb->ObjidFDP(),
								pfcbIdx->ObjidFDP(),
								pbmPrimary->key,
								keyToAdd,
								pfcbIdx->Pidb()->Lcid(),
								itagSequence,
								0 ) );
					}
				}
			}
		
		//  unversioned inserts into a secondary index are dangerous as if this fails the
		//  record will not be removed from the primary index
		Assert( !( dirflag & fDIRNoVersion ) );

		Assert( pbmPrimary->key.prefix.FNull() );
		Assert( pbmPrimary->key.Cb() > 0 );
		
		err = ErrDIRInsert( pfucbIdx, keyToAdd, pbmPrimary->key.suffix, dirflag, prcePrimary );
		if ( err < 0 )
			{
			if ( JET_errMultiValuedIndexViolation == err )
				{
				if ( itagSequence > 1 && !pidb->FUnique() )
					{
					Assert( pidb->FMultivalued() );

					//	must have been record with multi-value column
					//	or tuples with sufficiently similar values
					//	(ie. the indexed portion of the multi-values
					//	or tuples were identical) to produce redundant
					//	index entries.
					err = JET_errSuccess;
					}
				else
					{
					RECIReportIndexCorruption( pfcbIdx );
					AssertSz( fFalse, "JET_errSecondaryIndexCorrupted during an insert" );
					err = ErrERRCheck( JET_errSecondaryIndexCorrupted );
					}
				}
			CallR( err );
			}
		else
			{
			fIndexUpdated = fTrue;
			}

		if ( pidb->FTuples() )
			{
			//	at minimum, index entry with itagSequence==1 and ichOffset==0
			//	already got added
			Assert( fIndexUpdated );

			for ( ULONG ichOffset = 1; ichOffset < pidb->ChTuplesToIndexMax(); ichOffset++ )
				{
				fUndefinedUnicodeChars = fFalse;
				CallR( ErrRECRetrieveKeyFromCopyBuffer(
							pfucb,
							pidb,
							&keyToAdd,
							itagSequence,
							ichOffset,
							&fUndefinedUnicodeChars,
							prcePrimary ) );

				//	all other warnings should have been detected
				//	when we retrieved with ichOffset==0
				CallSx( err, wrnFLDOutOfTuples );
				if ( JET_errSuccess != err )
					break;

				if( fUndefinedUnicodeChars )
					{
					RECReportUndefinedUnicodeEntry(
						pfucb->u.pfcb->ObjidFDP(),
						pfcbIdx->ObjidFDP(),
						pbmPrimary->key,
						keyToAdd,
						pfcbIdx->Pidb()->Lcid(),
						itagSequence,
						ichOffset,
						fTrue );				

					if( pfcbIdx->Pidb()->FUnicodeFixupOn() )
						{
						if ( prceNil != prcePrimary )
							{
							//	UNDONE: we're in the update phase of
							//	concurrent create-index, and it's too
							//	complicated to try to update the
							//	fixup table at this point, so just
							//	flag the index as having fixups
							//	disabled
							//
							pfcbIdx->Pidb()->ResetFUnicodeFixupOn();
							}
						else
							{
							CallR( ErrCATInsertMSURecord(
										pfucb->ppib,
										pfucb->ifmp,
										pfucbNil,
										pfucb->u.pfcb->ObjidFDP(),
										pfcbIdx->ObjidFDP(),
										pbmPrimary->key,
										keyToAdd,
										pfcbIdx->Pidb()->Lcid(),
										itagSequence,
										ichOffset ) );
							}
						}
					}

				//  unversioned inserts into a secondary index are dangerous as if this fails the
				//  record will not be removed from the primary index
				Assert( !( dirflag & fDIRNoVersion ) );

				Assert( pbmPrimary->key.prefix.FNull() );
				Assert( pbmPrimary->key.Cb() > 0 );
				
				err = ErrDIRInsert( pfucbIdx, keyToAdd, pbmPrimary->key.suffix, dirflag, prcePrimary );
				if ( err < 0 )
					{
					if ( JET_errMultiValuedIndexViolation == err )
						{
						//	must have been record with multi-value column
						//	or tuples with sufficiently similar values
						//	(ie. the indexed portion of the multi-values
						//	or tuples were identical) to produce redundant
						//	index entries.
						err = JET_errSuccess;
						}
					CallR( err );
					}
				}
			}

		//	dont keep extracting for keys with no tagged segments
		//
		if ( !pidb->FMultivalued() || fNullKey )
			{
			//	if no multivalues in this index, there's no point going beyond first itagSequence
			//	if key is null, this implies there are no further multivalues
			Assert( 1 == itagSequence );	//	nulls beyond itagSequence 1 would have generated wrnFLDOutOfKeys
			break;
			}
		}

	//	suppress warnings
	CallS( ErrRECValidIndexKeyWarning( err ) );
	err = ( fIndexUpdated ? ErrERRCheck( wrnFLDIndexUpdated ) : JET_errSuccess );
	return err;
	}
	

//+API
// ErrIsamDelete
// ========================================================================
// ErrIsamDelete( PIB *ppib, FCBU *pfucb )
//
// Deletes the current record from data file.  All indexes on the data
// file are updated to reflect the deletion.
//
// PARAMETERS
// 			ppib		PIB of this user
// 			pfucb		FUCB for file to delete from
// RETURNS
//		Error code, one of the following:
//			JET_errSuccess	 			Everything went OK.
//			JET_errNoCurrentRecord	   	There is no current record.
// SIDE EFFECTS 
//			After the deletion, file currency is left just before
//			the next record.  Index currency (if any) is left just
//			before the next index entry.  If the deleted record was
//			the last in the file, the currencies are left after the
//			new last record.  If the deleted record was the only record
//			in the entire file, the currencies are left in the
//			"beginning of file" state.	On failure, the currencies are
//			returned to their initial states.
//			If there is a working buffer for SetField commands,
//			it is discarded.
// COMMENTS		
//			If the currencies are not ON a record, the delete will fail.
//			A transaction is wrapped around this function.	Thus, any
//			work done will be undone if a failure occurs.
//			Index entries are not made for entirely-null keys.
//			For temporary files, transaction logging is deactivated
//			for the duration of the routine.
//-
ERR VTAPI ErrIsamDelete(
	JET_SESID	sesid,
	JET_VTID	vtid )
	{
	ERR			err;
 	PIB 		* ppib				= reinterpret_cast<PIB *>( sesid );
	FUCB		* pfucb				= reinterpret_cast<FUCB *>( vtid );
	FCB			* pfcbTable;					// table FCB
	FCB			* pfcbIdx;						// loop variable for each index on file
	BOOL		fUpdatingLatchSet	= fFalse;

	CallR( ErrPIBCheck( ppib ) );

	CheckTable( ppib, pfucb );
	CheckSecondary( pfucb );
	AssertDIRNoLatch( ppib );
	
	//	ensure that table is updatable
	//
	CallR( ErrFUCBCheckUpdatable( pfucb )  );
	CallR( ErrPIBCheckUpdatable( ppib ) );

#ifdef PREREAD_INDEXES_ON_DELETE
	if( pfucb->u.pfcb->FPreread() )
		{
		BTPrereadIndexesOfFCB( pfucb->u.pfcb );
		}
#endif	//	PREREAD_INDEXES_ON_DELETE

	if ( !FFUCBUpdateForInsertCopyDeleteOriginal( pfucb ) )
		{
		//	reset copy buffer status on record delete unless we are in
		//  insert-copy-delete-original mode (ie: copy buffer is in use)
		if ( FFUCBUpdatePrepared( pfucb ) )
			{
			if ( FFUCBInsertCopyDeleteOriginalPrepared( pfucb ) )
				{
				return ErrERRCheck( JET_errAlreadyPrepared );
				}
			else
				{
				CallR( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepCancel ) );
				}
			}
		CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
		}

	//	if InsertCopyDeleteOriginal, transaction is started in ErrRECIInsert()
	Assert( !FFUCBInsertCopyDeleteOriginalPrepared( pfucb ) );
	Assert( ppib->level > 0 );

#ifdef DEBUG
	const BOOL	fLogIsDone = !PinstFromPpib( ppib )->m_plog->m_fLogDisabled
							&& !PinstFromPpib( ppib )->m_plog->m_fRecovering
							&& rgfmp[pfucb->ifmp].FLogOn();
#endif

	// Do the BeforeDelete callback
	Call( ErrRECCallback( ppib, pfucb, JET_cbtypBeforeDelete, 0, NULL, NULL, 0 ) );

	// After ensuring that we're in a transaction, refresh
	// our cursor to ensure we still have access to the record.
	Call( ErrDIRGetLock( pfucb, writeLock ) );

	//	efficiency variables
	//
	pfcbTable = pfucb->u.pfcb;
	Assert( pfcbTable != pfcbNil );

	Call( pfcbTable->ErrSetUpdatingAndEnterDML( ppib ) );
	fUpdatingLatchSet = fTrue;

	Assert(	fLogIsDone == ( !PinstFromPpib( ppib )->m_plog->m_fLogDisabled && !PinstFromPpib( ppib )->m_plog->m_fRecovering && rgfmp[pfucb->ifmp].FLogOn() ) );
	Assert( ppib->level < levelMax );

	//	delete from secondary indexes
	//
	// No critical section needed to guard index list because Updating latch
	// protects it.
	pfcbTable->LeaveDML();
	for( pfcbIdx = pfcbTable->PfcbNextIndex();
		pfcbIdx != pfcbNil;
		pfcbIdx = pfcbIdx->PfcbNextIndex() )
		{
		if ( FFILEIPotentialIndex( ppib, pfcbTable, pfcbIdx ) )
			{
			Call( ErrRECIUpdateIndex( pfucb, pfcbIdx, recoperDelete ) );
			}
		}

	//	do not touch LV/SLV data if we are doing an insert-copy-delete-original
	if ( !FFUCBUpdateForInsertCopyDeleteOriginal( pfucb ) )
		{
		//	SLVs now decommitted at the same time we deref separated LVs

		//	delete record long values
		Call( ErrRECDereferenceLongFieldsInRecord( pfucb ) );
		}

	Assert(	fLogIsDone == ( !PinstFromPpib( ppib )->m_plog->m_fLogDisabled && !PinstFromPpib( ppib )->m_plog->m_fRecovering && rgfmp[pfucb->ifmp].FLogOn() ) );

	//	if the primary index is over unicode columns, see if we have to update the fixup table
	if( pfcbTable->Pidb()
		&& pfcbTable->Pidb()->FLocalizedText() )
		{
		BOOL 	fUndefinedUnicodeChars = fFalse;
		BYTE	rgbKey[JET_cbKeyMost];
		KEY	 	keyToDelete;

		keyToDelete.Nullify();
		keyToDelete.suffix.SetPv( rgbKey );
		keyToDelete.suffix.SetCb( sizeof( rgbKey ) );
		
		Call( ErrRECRetrieveKeyFromRecord(
				pfucb,
				pfcbTable->Pidb(),
				&keyToDelete,
				1,
				0, 
				&fUndefinedUnicodeChars,
				fFalse ) );

		//	Do not assert that keyToDelete == pfucb->bmCurr.key
		//
		//	The unicode fixup code does a JET_prepInsertCopyDeleteOriginal to fix up records whose primary index over a unicode column
		//	and the unicode column contains undefined characters. If that is happening ErrIsamDelete will be called to remove the original
		//	record. When that happens this code should remove the original record, although the column now normalizes to something different.
		//
		//	If fUndefinedUnicodeChars is set, the code below will do the right thing. Otherwise a special-case check in ErrCATIFixupOneMSUEntry
		//	will delete the entry.
		//	
		//	REMEMBER: use pfucb->bmCurr.key below, NOT keyToDelete
		//

		if( fUndefinedUnicodeChars )
			{
			RECReportUndefinedUnicodeEntry(
				pfcbTable->ObjidFDP(),
				pfcbTable->ObjidFDP(),
				pfucb->bmCurr.key,
				pfucb->bmCurr.key,
				pfcbTable->Pidb()->Lcid(),
				1,
				0, 
				fFalse );

				if( pfcbTable->Pidb()->FUnicodeFixupOn() )
					{
					Call( ErrCATDeleteMSURecord(
						pfucb->ppib,
						pfucb->ifmp,
						pfucbNil,
						pfcbTable->ObjidFDP(),
						pfcbTable->ObjidFDP(),
						pfucb->bmCurr.key,
						pfucb->bmCurr.key,
						1,
						0 ) );
					}
			
			}
		}
	
	//	delete record
	//
	Call( ErrDIRDelete( pfucb, fDIRNull ) );
	AssertDIRNoLatch( ppib );

	Assert(	fLogIsDone == ( !PinstFromPpib( ppib )->m_plog->m_fLogDisabled && !PinstFromPpib( ppib )->m_plog->m_fRecovering && rgfmp[pfucb->ifmp].FLogOn() ) );

	pfcbTable->ResetUpdating();
	fUpdatingLatchSet = fFalse;
	
	//	if no error, commit transaction
	//
	//	if InsertCopyDeleteOriginal, commit will be performed in ErrRECIInsert()
	if ( !FFUCBUpdateForInsertCopyDeleteOriginal( pfucb ) )
		{
		Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );
		}

	AssertDIRNoLatch( ppib );

	// Do the AfterDelete callback
	CallS( ErrRECCallback( ppib, pfucb, JET_cbtypAfterDelete, 0, NULL, NULL, 0 ) );

	Assert(	fLogIsDone == ( !PinstFromPpib( ppib )->m_plog->m_fLogDisabled && !PinstFromPpib( ppib )->m_plog->m_fRecovering && rgfmp[pfucb->ifmp].FLogOn() ) );

	return err;

	
HandleError:
	Assert( err < 0 );
	AssertDIRNoLatch( ppib );
	Assert(	fLogIsDone == ( !PinstFromPpib( ppib )->m_plog->m_fLogDisabled && !PinstFromPpib( ppib )->m_plog->m_fRecovering && rgfmp[pfucb->ifmp].FLogOn() ) );

	if ( fUpdatingLatchSet )
		{
		Assert( pfcbTable != pfcbNil );
		pfcbTable->ResetUpdating();		//lint !e644
		}

	//	rollback all changes on error
	//	if InsertCopyDeleteOriginal, rollback will be performed in ErrRECIInsert()
	if ( !FFUCBUpdateForInsertCopyDeleteOriginal( pfucb ) )
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}

	return err;
	}


ERR ErrRECIDeleteIndexEntry(
	FUCB *		pfucbIdx,
	KEY&		keyToDelete,
	KEY&		keyPrimary,
	RCE *		prcePrimary,
	const BOOL	fMayHaveAlreadyBeenDeleted,
	BOOL * 		pfIndexEntryDeleted )		//	leave unchanged if index entry not deleted, set to TRUE if index entry deleted
	{
	ERR			err;
	DIB			dib;
	BOOKMARK	bmSeek;

	Assert( pfucbIdx->u.pfcb->FTypeSecondaryIndex() );
	Assert( keyPrimary.prefix.FNull() );
	Assert( keyPrimary.Cb() > 0 );

	bmSeek.Nullify();
	bmSeek.key = keyToDelete;

	if( !FFUCBUnique( pfucbIdx ) )
		{
		bmSeek.data = keyPrimary.suffix;
		}
		
	dib.pos 	= posDown;
	dib.dirflag = fDIRExact;
	dib.pbm		= &bmSeek;
		
	err = ErrDIRDown( pfucbIdx, &dib );
	switch ( err )
		{
		case JET_errRecordNotFound:
			if ( fMayHaveAlreadyBeenDeleted )
				{
				//	must have been record with multi-value column
				//	or tuples with sufficiently similar values
				//	(ie. the indexed portion of the multi-values
				//	or tuples were identical) to produce redundant
				//	index entries.
				//
				err = JET_errSuccess;
				break;
				}

			//	FALL THROUGH:

		case wrnNDFoundLess:
		case wrnNDFoundGreater:
			RECIReportIndexCorruption( pfucbIdx->u.pfcb );
			AssertSz( fFalse, "JET_errSecondaryIndexCorrupted during a delete" );
			err = ErrERRCheck( JET_errSecondaryIndexCorrupted );
			break;

		default:
			CallR( err );
			CallS( err );	//	don't expect any warnings except the ones filtered out above

			//	PERF: we should be able to avoid the release and call
			//	ErrDIRDelete with the page latched
			//
			CallR( ErrDIRRelease( pfucbIdx ) );
			CallR( ErrDIRDelete( pfucbIdx, fDIRNull, prcePrimary ) );
			*pfIndexEntryDeleted = fTrue;
		}

	return err;
	}

//+INTERNAL
//	ErrRECIDeleteFromIndex
//	========================================================================
//	ErrRECIDeleteFromIndex( FCB *pfcbIdx, FUCB *pfucb )
//	
//	Extracts key from data record and deletes the key with the given SRID
//
//	PARAMETERS	
//				pfucb							pointer to primary index record to delete
//				pfcbIdx							FCB of index to delete from
//	RETURNS		
//				JET_errSuccess, or error code from failing routine
//	SIDE EFFECTS 
//	SEE ALSO  	ErrRECDelete
//-

ERR	ErrRECIDeleteFromIndex(
	FUCB			*pfucb,
	FUCB			*pfucbIdx,
	BOOKMARK		*pbmPrimary,
	RCE				*prcePrimary )
	{
	ERR				err;
	const FCB		* const pfcbIdx	= pfucbIdx->u.pfcb;
	const IDB 		* const pidb	= pfcbIdx->Pidb();
	KEY				keyToDelete;
	BYTE			rgbKey[ JET_cbSecondaryKeyMost ];
	ULONG			itagSequence;
	BOOL			fNullKey				= fFalse;
	const BOOL		fDeleteByProxy			= ( prcePrimary != prceNil ); 
	const BOOL		fHasMultivalue			= pidb->FMultivalued();
	const BOOL		fAllowAllNulls			= pidb->FAllowAllNulls();
	const BOOL		fAllowFirstNull 		= pidb->FAllowFirstNull();
	const BOOL		fAllowSomeNulls 		= pidb->FAllowSomeNulls();
	const BOOL		fNoNullSeg				= pidb->FNoNullSeg();
	const BOOL		fUnique					= pidb->FUnique();
	BOOL			fIndexUpdated			= fFalse;
	BOOL			fUndefinedUnicodeChars	= fFalse;

	AssertDIRNoLatch( pfucb->ppib );
	
	Assert( pfcbIdx != pfcbNil );
	Assert( pfcbIdx->FTypeSecondaryIndex() );
	Assert( pidbNil != pidb );
	
	//	delete all keys from this index for dying data record
	//
	keyToDelete.prefix.Nullify();
	keyToDelete.suffix.SetPv( rgbKey );
	for ( itagSequence = 1; ; itagSequence++ )
		{
		fUndefinedUnicodeChars = fFalse;
		
		//	get key
		//
		if ( fDeleteByProxy )
			{
			Assert( pfcbIdx->PfcbTable() == pfcbNil );	// Index not linked in yet.
			CallR( ErrRECRetrieveKeyFromCopyBuffer(
				pfucb,
				pidb,
				&keyToDelete,
				itagSequence,
				0,
				&fUndefinedUnicodeChars,
				prcePrimary ) );
			}
		else
			{
			Assert( pfcbIdx->PfcbTable() == pfucb->u.pfcb );		
			CallR( ErrRECRetrieveKeyFromRecord(
				pfucb,
				pidb,
				&keyToDelete,
				itagSequence,
				0,
				&fUndefinedUnicodeChars,
				fFalse ) );
			}

		CallS( ErrRECValidIndexKeyWarning( err ) );

		if ( wrnFLDOutOfKeys == err )
			{
			Assert( itagSequence > 1 );
			break;
			}

		else if ( wrnFLDOutOfTuples == err )
			{
			//	try next itagSequence
			Assert( pidb->FTuples() );
			if ( fHasMultivalue )
				{
				//	NOTE: if we got wrnFLDOutOfTuples because
				//	itagSequence 1 was NULL (ie. there are no
				//	more multivalues), we are actually going
				//	to make one more iteration of this loop
				//	and break out when itagSequence 2 returns
				//	wrnFLDOutOfKeys.
				//	UNDONE: optimise to not require a second
				//	iteration
				continue;
				}
			else
				break;
			}

		//	record must honor index no NULL segment requirements
		//
		if ( fNoNullSeg )
			{
			Assert( wrnFLDNullSeg != err );
			Assert( wrnFLDNullFirstSeg != err );
			Assert( wrnFLDNullKey != err );
			}

		if ( ( wrnFLDNullFirstSeg == err && !fAllowFirstNull )
			|| ( wrnFLDNullSeg == err && !fAllowSomeNulls )
			|| ( wrnFLDNullKey == err && !fAllowAllNulls )
			|| wrnFLDNotPresentInIndex == err )
			{
			Assert( wrnFLDNotPresentInIndex != err || 1 == itagSequence );
///			AssertSz( wrnFLDNotPresentInIndex != err, "[laurionb]: ErrRECIDeleteFromIndex: original record was not in index" );
			break;
			}

		fNullKey = ( wrnFLDNullKey == err );
		Assert( !fNullKey || 1 == itagSequence );	//	nulls beyond itagSequence 1 would have generated wrnFLDOutOfKeys
		Assert( !fNullKey || !pidb->FTuples() );	//	tuple indexes would have generated wrnFLDOutOfTuples instead

		//	remove the MSU entry for the key
		
		if( fUndefinedUnicodeChars )
			{
			RECReportUndefinedUnicodeEntry(
				pfucb->u.pfcb->ObjidFDP(),
				pfcbIdx->ObjidFDP(),
				pbmPrimary->key,
				keyToDelete,
				pfcbIdx->Pidb()->Lcid(),
				itagSequence,
				0,
				fFalse );	

			if( pfcbIdx->Pidb()->FUnicodeFixupOn() )
				{
				if ( fDeleteByProxy )
					{
					//	UNDONE: we're in the update phase of
					//	concurrent create-index, and it's too
					//	complicated to try to update the
					//	fixup table at this point, so just
					//	flag the index as having fixups
					//	disabled
					//
					pfcbIdx->Pidb()->ResetFUnicodeFixupOn();
					}
				else
					{
					CallR( ErrCATDeleteMSURecord(
								pfucb->ppib,
								pfucb->ifmp,
								pfucbNil,
								pfucb->u.pfcb->ObjidFDP(),
								pfcbIdx->ObjidFDP(),
								pbmPrimary->key,
								keyToDelete,
								itagSequence,
								0 ) );
					}
				}
			}

		//	is it possible that the index entry may already have been deleted
		//	as a result of a previous multi-value generating the same index
		//	entry as the current multi-value?
		//
		const BOOL	fMayHaveAlreadyBeenDeleted	= ( itagSequence > 1
													&& !fUnique
													&& fIndexUpdated );
		Assert( !fMayHaveAlreadyBeenDeleted || fHasMultivalue );

		//	delete corresponding index entry
		//
		CallR( ErrRECIDeleteIndexEntry(
						pfucbIdx,
						keyToDelete,
						pbmPrimary->key,
						prcePrimary,
						fMayHaveAlreadyBeenDeleted,
						&fIndexUpdated ) );

		if ( pidb->FTuples() )
			{
			//	at minimum, index entry with itagSequence==1 and ichOffset==0
			//	already got deleted
			Assert( fIndexUpdated );

			for ( ULONG ichOffset = 1; ichOffset < pidb->ChTuplesToIndexMax(); ichOffset++ )
				{
				fUndefinedUnicodeChars = fFalse;
				
				if ( fDeleteByProxy )
					{
					Assert( pfcbIdx->PfcbTable() == pfcbNil );	// Index not linked in yet.
					CallR( ErrRECRetrieveKeyFromCopyBuffer(
						pfucb,
						pidb,
						&keyToDelete,
						itagSequence,
						ichOffset,
						&fUndefinedUnicodeChars,
						prcePrimary ) );
					}
				else
					{
					Assert( pfcbIdx->PfcbTable() == pfucb->u.pfcb );		
					CallR( ErrRECRetrieveKeyFromRecord(
						pfucb,
						pidb,
						&keyToDelete,
						itagSequence,
						ichOffset,
						&fUndefinedUnicodeChars,
						fFalse ) );
					}

				//	all other warnings should have been detected
				//	when we retrieved with ichOffset==0
				CallSx( err, wrnFLDOutOfTuples );
				if ( JET_errSuccess != err )
					break;

				if( fUndefinedUnicodeChars )
					{
					RECReportUndefinedUnicodeEntry(
						pfucb->u.pfcb->ObjidFDP(),
						pfcbIdx->ObjidFDP(),
						pbmPrimary->key,
						keyToDelete,
						pfcbIdx->Pidb()->Lcid(),
						itagSequence,
						ichOffset,
						fFalse );				

					if( pfcbIdx->Pidb()->FUnicodeFixupOn() )
						{
						if ( fDeleteByProxy )
							{
							//	UNDONE: we're in the update phase of
							//	concurrent create-index, and it's too
							//	complicated to try to update the
							//	fixup table at this point, so just
							//	flag the index as having fixups
							//	disabled
							//
							pfcbIdx->Pidb()->ResetFUnicodeFixupOn();
							}
						else
							{
							CallR( ErrCATDeleteMSURecord(
										pfucb->ppib,
										pfucb->ifmp,
										pfucbNil,
										pfucb->u.pfcb->ObjidFDP(),
										pfcbIdx->ObjidFDP(),
										pbmPrimary->key,
										keyToDelete,
										itagSequence,
										ichOffset ) );
							}
						}
					}				

				//	delete corresponding index entry
				//
				CallR( ErrRECIDeleteIndexEntry(
								pfucbIdx,
								keyToDelete,
								pbmPrimary->key,
								prcePrimary,
								fTrue,		//	a previous tuple may have generated the same index key
								&fIndexUpdated ) );
				}
			}

		//	dont keep extracting for keys with no tagged segments
		//
		if ( !fHasMultivalue || fNullKey )
			{
			//	if no multivalues in this index, there's no point going beyond first itagSequence
			//	if key is null, this implies there are no further multivalues
			Assert( 1 == itagSequence );	//	nulls beyond itagSequence 1 would have generated wrnFLDOutOfKeys
			break;
			}
		}

	//	suppress warnings
	CallS( ErrRECValidIndexKeyWarning( err ) );
	err = ( fIndexUpdated ? ErrERRCheck( wrnFLDIndexUpdated ) : JET_errSuccess );
	return err;
	}


//	determines whether an index may have changed using the hashed tags
//
LOCAL BOOL FRECIIndexPossiblyChanged(
	const BYTE * const		rgbitIdx,
	const BYTE * const		rgbitSet )
	{
	const LONG_PTR *		plIdx		= (LONG_PTR *)rgbitIdx;
	const LONG_PTR * const	plIdxMax	= plIdx + ( cbRgbitIndex / sizeof(LONG_PTR) );
	const LONG_PTR *		plSet		= (LONG_PTR *)rgbitSet;

	for ( ; plIdx < plIdxMax; plIdx++, plSet++ )
		{
		if ( *plIdx & *plSet )
			{
			return fTrue;
			}
		}

	return fFalse;
	}


//	determines whether an index may has changed by comparing the keys
//	UNDONE: only checks first multi-value in a multi-valued index, but
//	for now that's fine because this code is only used for DEBUG purposes
//	except on the primary index, which will never have multi-values
//
LOCAL ERR ErrRECFIndexChanged( FUCB *pfucb, FCB *pfcbIdx, BOOL *pfChanged )
	{
	KEY		keyOld;
	KEY		keyNew;
	BYTE	rgbOldKey[ KEY::cbKeyMax ];		//	this function is called on primary index to ensure it hasn't changed
	BYTE	rgbNewKey[ KEY::cbKeyMax ];		//	and on secondary index to cascade record updates
	DATA   	*plineNewData = &pfucb->dataWorkBuf;
	ERR		err;

	BOOL	fCopyBufferKeyIsPresentInIndex 	= fFalse;
	BOOL	fRecordKeyIsPresentInIndex		= fFalse;
	
	Assert( pfucb );
	Assert( !Pcsr( pfucb )->FLatched( ) );
	Assert( pfcbNil != pfucb->u.pfcb );
	Assert( pfcbNil != pfcbIdx );
	Assert( pfucb->dataWorkBuf.Cb() == plineNewData->Cb() );
	Assert( pfucb->dataWorkBuf.Pv() == plineNewData->Pv() );

	//	UNDONE: do something else for tuple indexes
	Assert( !pfcbIdx->Pidb()->FTuples() );

	//	get new key from copy buffer
	//
	keyNew.prefix.Nullify();
	keyNew.suffix.SetCb( sizeof( rgbNewKey ) );
	keyNew.suffix.SetPv( rgbNewKey );
	CallR( ErrRECRetrieveKeyFromCopyBuffer(
		pfucb, 
		pfcbIdx->Pidb(),
		&keyNew, 
		1,
		0,
		NULL,
		prceNil ) );
	CallS( ErrRECValidIndexKeyWarning( err ) );
	Assert( wrnFLDOutOfKeys != err );		//	should never get OutOfKeys since we're only retrieving itagSequence 1
	Assert( wrnFLDOutOfTuples != err );		//	this routine not currently called for tuple indexes

	fCopyBufferKeyIsPresentInIndex = ( wrnFLDNotPresentInIndex != err );
		

	//	get the old key from the node
	//
	keyOld.prefix.Nullify();
	keyOld.suffix.SetCb( sizeof( rgbNewKey ) );
	keyOld.suffix.SetPv( rgbOldKey );

	Call( ErrRECRetrieveKeyFromRecord( pfucb, pfcbIdx->Pidb(), &keyOld, 1, 0, NULL, fTrue ) );

	CallS( ErrRECValidIndexKeyWarning( err ) );
	Assert( wrnFLDOutOfKeys != err );
	Assert( wrnFLDOutOfTuples != err );

	fRecordKeyIsPresentInIndex = ( wrnFLDNotPresentInIndex != err );

	if( fCopyBufferKeyIsPresentInIndex && !fRecordKeyIsPresentInIndex 
		|| !fCopyBufferKeyIsPresentInIndex && fRecordKeyIsPresentInIndex )
		{
		//  one is in the index and the other isn't (even though an indexed column may not have changed!)
		*pfChanged = fTrue;
		Assert( !Pcsr( pfucb )->FLatched() );
		return JET_errSuccess;
		}
	else if( !fCopyBufferKeyIsPresentInIndex && !fRecordKeyIsPresentInIndex )
		{
		//  neither are in the index (nothing has changed)
		*pfChanged = fFalse;
		Assert( !Pcsr( pfucb )->FLatched() );
		return JET_errSuccess;		
		}

#ifdef DEBUG
	//	record must honor index no NULL segment requirements
	if ( pfcbIdx->Pidb()->FNoNullSeg() )
		{
		Assert( wrnFLDNullSeg != err );
		Assert( wrnFLDNullFirstSeg != err );
		Assert( wrnFLDNullKey != err );
		}
#endif

	*pfChanged = !FKeysEqual( keyOld, keyNew );

	Assert( !Pcsr( pfucb )->FLatched() );
	return JET_errSuccess;
	
HandleError:
	Assert( !Pcsr( pfucb )->FLatched() );
	return err;
	}



//	upgrades a ReplaceNoLock to a regular Replace by write-locking the record
ERR ErrRECUpgradeReplaceNoLock( FUCB *pfucb )
	{
	ERR		err;

	Assert( FFUCBReplaceNoLockPrepared( pfucb ) );
	
	//	UNDONE:	compute checksum on commit to level 0
	//			in support of following sequence:
	// 				BeginTransaction
	// 				PrepareUpdate, defer checksum since in xact
	// 				SetColumns
	// 				Commit to level 0, other user may update it
	// 				Update
	Assert( !FFUCBDeferredChecksum( pfucb )
		|| pfucb->ppib->level > 0 );
			
	CallR( ErrDIRGetLock( pfucb, writeLock ) );

	CallR( ErrDIRGet( pfucb ));
	const BOOL	fWriteConflict = ( !FFUCBDeferredChecksum( pfucb ) && !FFUCBCheckChecksum( pfucb ) );
	CallS( ErrDIRRelease( pfucb ));

	if ( fWriteConflict )
		{
		err = ErrERRCheck( JET_errWriteConflict );
		}
	else
		{
		UpgradeReplaceNoLock( pfucb );
		}

	return err;
	}


//+local
//	ErrRECIReplace
//	========================================================================
//	ErrRECIReplace( FUCB *pfucb, DIRFLAG dirflag )
//
//	Updates a record in a data file.	 All indexes on the data file are
// 	pdated to reflect the updated data record.
//
//	PARAMETERS	pfucb		 FUCB for file
//	RETURNS		Error code, one of the following:
//					 JET_errSuccess	  			 Everything went OK.
//					-NoCurrentRecord			 There is no current record
//									  			 to update.
//					-RecordNoCopy				 There is no working buffer
//									  			 to update from.
//					-KeyDuplicate				 The new record data causes an
//									  			 illegal duplicate index entry
//									  			 to be generated.
//					-RecordPrimaryChanged		 The new data causes the primary
//									  			 key to change.
//	SIDE EFFECTS
//		After update, file currency is left on the updated record.
//		Similar for index currency.
//		The effect of a GetNext or GetPrevious operation will be
//		the same in either case.  On failure, the currencies are
//		returned to their initial states.
//		If there is a working buffer for SetField commands,
//		it is discarded.
//
//	COMMENTS
//		If currency is not ON a record, the update will fail.
//		A transaction is wrapped around this function.	Thus, any
//		work done will be undone if a failure occurs.
//		For temporary files, transaction logging is deactivated
//		for the duration of the routine.
//		Index entries are not made for entirely-null keys.
//-
LOCAL ERR ErrRECIReplace( FUCB *pfucb, const JET_GRBIT grbit )
	{
	ERR		err;					// error code of various utility
	PIB		*ppib				= pfucb->ppib;
	FCB		*pfcbTable;				// file's FCB
	FCB		*pfcbIdx;				// loop variable for each index on file
	FID		fidFixedLast;
	FID		fidVarLast;
	BOOL   	fUpdateIndex;
	BOOL	fUpdatingLatchSet	= fFalse;

	CheckPIB( ppib );
	AssertDIRNoLatch( ppib );
	CheckTable( ppib, pfucb );
	CheckSecondary( pfucb );

	//	should have been checked in PrepareUpdate
	//
	Assert( FFUCBUpdatable( pfucb ) );
	Assert( FFUCBReplacePrepared( pfucb ) );

	//	efficiency variables
	//
	pfcbTable = pfucb->u.pfcb;
	Assert( pfcbTable != pfcbNil );

	//	data to use for update is in workBuf
	//
	Assert( !pfucb->dataWorkBuf.FNull() );
	
	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );

	//	optimistic locking, ensure that record has
	//	not changed since PrepareUpdate
	//
	if ( FFUCBReplaceNoLockPrepared( pfucb ) )
		{
		Call( ErrRECUpgradeReplaceNoLock( pfucb ) );
		}

	// Do the BeforeReplace callback
	Call( ErrRECCallback( ppib, pfucb, JET_cbtypBeforeReplace, 0, NULL, NULL, 0 ) );
	
	if ( grbit & JET_bitUpdateCheckESE97Compatibility )
		{
		Call( ErrRECICheckESE97Compatibility( pfucb, pfucb->dataWorkBuf ) );
		}

	Call( pfcbTable->ErrSetUpdatingAndEnterDML( ppib ) );
	fUpdatingLatchSet = fTrue;

	//	Set these efficiency variables after FUCB read latch
	//
	pfcbTable->AssertDML();
	fidFixedLast = pfcbTable->Ptdb()->FidFixedLast();
	fidVarLast = pfcbTable->Ptdb()->FidVarLast();

	//	if need to update indexes, then cache old record
	//
	fUpdateIndex = FRECIIndexPossiblyChanged(
							pfcbTable->Ptdb()->RgbitAllIndex(),
							pfucb->rgbitSet );

	pfcbTable->LeaveDML();
	
   	Assert( !Pcsr( pfucb )->FLatched() );
	if ( fUpdateIndex )
		{
		//	ensure primary key did not change
		//
		if ( pfcbTable->Pidb() != pidbNil )
			{
			BOOL	fIndexChanged;

		   	Call( ErrRECFIndexChanged( pfucb, pfcbTable, &fIndexChanged ) );
		   	Assert( !Pcsr( pfucb )->FLatched() );

			if ( fIndexChanged )
				{
				Error( ErrERRCheck( JET_errRecordPrimaryChanged ), HandleError )
				}
			}
		}
		
#ifdef DEBUG
	else
		{
		if ( pfcbTable->Ptdb() != ptdbNil && pfcbTable->Pidb() != pidbNil )
			{
			BOOL	fIndexChanged;

		   	Call( ErrRECFIndexChanged( pfucb, pfcbTable, &fIndexChanged ) );
			Assert( !fIndexChanged );
			}
		}
#endif

	//	set version column if present
	//
	FID		fidVersion;

	Assert( FFUCBIndex( pfucb ) );
	pfcbTable->EnterDML();
	fidVersion = pfcbTable->Ptdb()->FidVersion();
	pfcbTable->LeaveDML();

	if ( fidVersion != 0 )
		{
		FCB				* pfcbT			= pfcbTable;
		const BOOL		fTemplateColumn	= pfcbTable->Ptdb()->FFixedTemplateColumn( fidVersion );
		const COLUMNID	columnidT		= ColumnidOfFid( fidVersion, fTemplateColumn );
		ULONG			ulT;
		DATA			dataField;
		
		Assert( !Pcsr( pfucb )->FLatched() );

		err =  ErrRECIAccessColumn( pfucb, columnidT );
		if ( err < 0 )
			{
			if ( JET_errColumnNotFound != err )
				goto HandleError;
			}

		//	get current record
		//
		Call( ErrDIRGet( pfucb ) );

		if ( fTemplateColumn )
			{
			Assert( FCOLUMNIDTemplateColumn( columnidT ) );
			if ( !pfcbT->FTemplateTable() )
				{
				// Switch to template table.
				pfcbT->Ptdb()->AssertValidDerivedTable();
				pfcbT = pfcbT->Ptdb()->PfcbTemplateTable();
				}
			else
				{
				pfcbT->Ptdb()->AssertValidTemplateTable();
				}
			}
		else
			{
			Assert( !FCOLUMNIDTemplateColumn( columnidT ) );
			Assert( !pfcbT->FTemplateTable() );
			}

		//	increment field from value in current record
		//
		pfcbT->EnterDML();
		
		err = ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfcbT->Ptdb(),
				columnidT,
				pfucb->kdfCurr.data,
				&dataField );
		if ( err < 0 )
			{
			pfcbT->LeaveDML();
			CallS( ErrDIRRelease( pfucb ) );
			goto HandleError;
			}

		//	handle case where field is NULL when column added
		//	to table with records present
		//
		if ( dataField.Cb() == 0 )
			{
			ulT = 1;
			}
		else
			{
			Assert( dataField.Cb() == sizeof(ULONG) );
			ulT = *(UnalignedLittleEndian< ULONG > *)dataField.Pv();
			ulT++;
			}
			
		dataField.SetPv( (BYTE *)&ulT );
		dataField.SetCb( sizeof(ulT) );
		err = ErrRECISetFixedColumn( pfucb, pfcbT->Ptdb(), columnidT, &dataField );
		
		pfcbT->LeaveDML();

		CallS( ErrDIRRelease( pfucb ) );
		Call( err );
		}

	Assert( !Pcsr( pfucb )->FLatched( ) );
	
	//	update indexes
	//
	if ( fUpdateIndex )
		{
#ifdef PREREAD_INDEXES_ON_REPLACE
		if( pfucb->u.pfcb->FPreread() )
			{
			const INT cSecondaryIndexesToPreread = 16;
	
			PGNO rgpgno[cSecondaryIndexesToPreread + 1];	//  NULL-terminated
			INT	ipgno = 0;
	
			// No critical section needed to guard index list because Updating latch
			// protects it.
			for ( pfcbIdx = pfcbTable->PfcbNextIndex();
				  pfcbIdx != pfcbNil && ipgno < cSecondaryIndexesToPreread;
				  pfcbIdx = pfcbIdx->PfcbNextIndex() )
				{
				if ( pfcbIdx->Pidb() != pidbNil
					 && FFILEIPotentialIndex( ppib, pfcbTable, pfcbIdx )
					 && FRECIIndexPossiblyChanged( pfcbIdx->Pidb()->RgbitIdx(), pfucb->rgbitSet ) )
					{
					//  preread this index as we will probably update it
					rgpgno[ipgno++] = pfcbIdx->PgnoFDP();
					}
				}
			rgpgno[ipgno] = pgnoNull;
			
			BFPrereadPageList( pfucb->ifmp, rgpgno );
			}
#endif	//	PREREAD_INDEXES_ON_REPLACE

		// No critical section needed to guard index list because Updating latch
		// protects it.
		for ( pfcbIdx = pfcbTable->PfcbNextIndex();
			pfcbIdx != pfcbNil;
			pfcbIdx = pfcbIdx->PfcbNextIndex() )
			{
			if ( pfcbIdx->Pidb() != pidbNil )		// sequential indexes don't need updating
				{
				if ( FFILEIPotentialIndex( ppib, pfcbTable, pfcbIdx ) )
					{
					if ( FRECIIndexPossiblyChanged( pfcbIdx->Pidb()->RgbitIdx(), pfucb->rgbitSet ) )
						{
						Call( ErrRECIUpdateIndex( pfucb, pfcbIdx, recoperReplace ) );
						}
#ifdef DEBUG
					else if ( pfcbIdx->Pidb()->FTuples() )
						{
						//	UNDONE: Need to come up with some other validation
						//	routine because ErrRECFIndexChanged() doesn't
						//	properly handle tuple index entries
						}
					else
						{
						BOOL	fIndexChanged;

					   	Call( ErrRECFIndexChanged( pfucb, pfcbIdx, &fIndexChanged ) );
						Assert( !fIndexChanged );
						}
#endif
					}
				}
			}
		}

	//	do the replace
	//
	Call( ErrDIRReplace( pfucb, pfucb->dataWorkBuf, fDIRLogColumnDiffs ) );
	
	pfcbTable->ResetUpdating();
	fUpdatingLatchSet = fFalse;

	//	if no error, commit transaction
	//
	Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );

	FUCBResetUpdateFlags( pfucb );

	// Do the AfterReplace callback
	CallS( ErrRECCallback( ppib, pfucb, JET_cbtypAfterReplace, 0, NULL, NULL, 0 ) );

	AssertDIRNoLatch( ppib );

	return err;


HandleError:
	Assert( err < 0 );
	AssertDIRNoLatch( ppib );

	if ( fUpdatingLatchSet )
		{
		Assert( pfcbTable != pfcbNil );
		pfcbTable->ResetUpdating();
		}

	//	rollback all changes on error
	//
	CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );

	return err;
	}


INLINE ERR ErrRECIRetrieveKeyForReplace(
	FUCB * const		pfucb,
	const FCB * const	pfcbIdx,
	KEY * const			pkey,
	const ULONG			itagSequence,
	const ULONG			ichOffset,
	BOOL * const		pfUndefinedUnicodeChars,
	RCE * const			prcePrimary )
	{
	ERR					err;
	const BOOL			fReplaceByProxy		= ( prceNil != prcePrimary );

	if ( fReplaceByProxy )
		{
		DATA	dataRec;

		Assert( pfcbNil == pfcbIdx->PfcbTable() );		// Index not linked in yet.

		// Before-image is stored in RCE.
		Assert( operReplace == prcePrimary->Oper() );
		dataRec.SetPv( const_cast<BYTE *>( prcePrimary->PbData() ) + cbReplaceRCEOverhead );
		dataRec.SetCb( prcePrimary->CbData() - cbReplaceRCEOverhead );
		CallR( ErrRECIRetrieveKey(
					pfucb,
					pfcbIdx->Pidb(),
					dataRec,
					pkey,
					itagSequence,
					ichOffset,
					pfUndefinedUnicodeChars,
					fTrue,
					prcePrimary ) );
		}
	else
		{
		Assert( pfcbIdx->PfcbTable() == pfucb->u.pfcb );
		CallR( ErrRECRetrieveKeyFromRecord(
					pfucb,
					pfcbIdx->Pidb(),
					pkey,
					itagSequence,
					ichOffset,
					pfUndefinedUnicodeChars,
					fTrue ) );
		}

	CallS( ErrRECValidIndexKeyWarning( err ) );
	return err;
	}
	

//+local
// ErrRECIReplaceInIndex
// ========================================================================
// ERR ErrRECIReplaceInIndex( FCB *pfcbIdx, FUCB *pfucb )
//
// Extracts keys from old and new data records, and if they are different,
// adds the new index entry and deletes the old index entry.
//
// PARAMETERS
//				pfcbIdx				  		FCB of index to insert into
//				pfucb						record FUCB pointing to primary record changed
//
// RETURNS		JET_errSuccess, or error code from failing routine
//
// SIDE EFFECTS 
// SEE ALSO		Replace
//-
ERR ErrRECIReplaceInIndex(
	FUCB			*pfucb,
	FUCB			*pfucbIdx,
	BOOKMARK		*pbmPrimary,
	RCE				*prcePrimary )
	{
	ERR				err;									// error code of various utility
	const FCB		* const pfcbIdx			= pfucbIdx->u.pfcb;
	const IDB		* const pidb			= pfcbIdx->Pidb();
	KEY				keyOld;				  					// key extracted from old record
	BYTE  	 		rgbOldKey[JET_cbSecondaryKeyMost];		// buffer for old key
	KEY				keyNew;				  					// key extracted from new record
	BYTE 	  		rgbNewKey[JET_cbSecondaryKeyMost];		// buffer for new key
	ULONG 	 		itagSequenceOld; 						// used to extract keys
	ULONG 	 		itagSequenceNew;						// used to extract keys
	BOOL  	 		fMustDelete;							// record no longer generates key
	BOOL 	 		fMustAdd;								// record now generates this key
	BOOL  	 		fDoOldNullKey;
	BOOL  	 		fDoNewNullKey;
	const BOOL		fHasMultivalue			= pidb->FMultivalued();
	const BOOL		fAllowAllNulls			= pidb->FAllowAllNulls();
	const BOOL		fAllowFirstNull			= pidb->FAllowFirstNull();
	const BOOL		fAllowSomeNulls			= pidb->FAllowSomeNulls();
	const BOOL		fNoNullSeg				= pidb->FNoNullSeg();
	const BOOL		fUnique					= pidb->FUnique();
	const BOOL		fTuples					= pidb->FTuples();
	BOOL			fIndexUpdated			= fFalse;
	BOOL			fUndefinedUnicodeChars	= fFalse;
	FCB * const 	pfcb					= pfucb->u.pfcb;
	Assert( NULL != pfcb );
	TDB * const 	ptdb					= pfcb->Ptdb();
	Assert( NULL != ptdb );
	
	AssertDIRNoLatch( pfucb->ppib );
	
	Assert( pfcbIdx != pfcbNil );
	Assert( pfcbIdx->FTypeSecondaryIndex() );
	Assert( pidbNil != pidb );
	
	Assert( !( fNoNullSeg && ( fAllowAllNulls || fAllowSomeNulls ) ) );

	// if fAllowNulls, then fAllowSomeNulls needs to be true
	//
	Assert( !fAllowAllNulls || fAllowSomeNulls );

	keyOld.prefix.Nullify();
	keyOld.suffix.SetPv( rgbOldKey );
	keyNew.prefix.Nullify();
	keyNew.suffix.SetPv( rgbNewKey );

	//	if tuples index then check once that tuples column has actually been updated
	//	instead of the normal per-key check
	//
	//	UNDONE: if conditional columns are stored in the mempool, we would have to
	//	grab the DML latch to make this check (to ensure the mempool isn't modified
	//	from underneath us), so for now bypass the optimisation if there are too
	//	many conditional columns
	//
	if ( fTuples && !pidb->FIsRgidxsegConditionalInMempool() )
		{
		BOOL				fColumnChanged	= fFalse;

		//	get column id of tuples column. Currently, there can be only one tuples column
		//	just as there can only be one tagged column that is honoured for multi-value indexing.
		//
		Assert( 1 == pidb->Cidxseg() );
		Assert( !pidb->FIsRgidxsegInMempool() );
		const JET_COLUMNID	columnidTuples	= pidb->rgidxseg[0].Columnid();

		//	determine if tuples column has been updated.  If column is in-row then compare
		//	in-row bytes.  Any difference found causes full re-indexing of tuples information.
		//	If column is out-of-row then check for version on root of LV.  If version is found
		//	then full re-indexing of tuples column is performed.
		//
		Assert( !fColumnChanged );
		for ( itagSequenceOld = 1; !fColumnChanged; itagSequenceOld++ )
			{
			CallR( ErrRECIFColumnSet(
				pfucb,
				ptdb,
				columnidTuples,
				itagSequenceOld,
				prcePrimary,
				fFalse,
				&fColumnChanged ) );
			CallSx( err, JET_wrnColumnNull );
			if ( JET_wrnColumnNull == err )
				{
				//	both old and new values are NULL, so
				//	we've reached the end of the multi-values
				//	and no modification was detected
				//
				Assert( !fColumnChanged );
				break;
				}
			else if ( !fHasMultivalue )
				{
				//	if index is not flagged as multi-valued,
				//	break out after first itag
				//
				Assert( 1 == itagSequenceOld );
				break;
				}
			}

		//	now check conditional columns, because if their
		//	polarity changed, it would affect whether or
		//	not the record is included in the index
		//
		Assert( !pidb->FIsRgidxsegConditionalInMempool() );
		for ( ULONG iidxseg = 0;
			!fColumnChanged && iidxseg < pidb->CidxsegConditional();
			iidxseg++ )
			{
			CallR( ErrRECIFColumnSet(
						pfucb,
						ptdb,
						pidb->rgidxsegConditional[iidxseg].Columnid(),
						1,		//	only checking for NULL or non-NULL, so only need to check first itag
						prcePrimary,
						fTrue,
						&fColumnChanged ) );
			CallSx( err, JET_wrnColumnNull );
			}

		if ( !fColumnChanged )
			{
			//	update did not affect tuple-indexed column nor any of the
			//	conditional columns it may depend on, so we can bail
			//
			return JET_errSuccess;
			}
		}

	//	delete the old key from the index 
	//
	fDoOldNullKey = fFalse;
	for ( itagSequenceOld = 1; ; itagSequenceOld++ )
		{
		fUndefinedUnicodeChars = fFalse;
		
		CallR( ErrRECIRetrieveKeyForReplace(
					pfucb,
					pfcbIdx,
					&keyOld,
					itagSequenceOld,
					0,
					&fUndefinedUnicodeChars,
					prcePrimary ) );

		if ( wrnFLDOutOfKeys == err )
			{
			Assert( itagSequenceOld > 1 );
			break;
			}

		else if ( wrnFLDOutOfTuples == err )
			{
			//	try next itagSequence
			Assert( fTuples );
			if ( fHasMultivalue )
				{
				//	NOTE: if we got wrnFLDOutOfTuples because
				//	itagSequence 1 was NULL (ie. there are no
				//	more multivalues), we are actually going
				//	to make one more iteration of this loop
				//	and break out when itagSequence 2 returns
				//	wrnFLDOutOfKeys.
				//	UNDONE: optimise to not require a second
				//	iteration
				continue;
				}
			else
				break;
			}

		else if ( wrnFLDNotPresentInIndex == err )
			{
			//  original record was not in this index. no need to remove it
			Assert( 1 == itagSequenceOld );
//			AssertSz( fFalse, "[laurionb]: ErrRECIReplaceInIndex: original record was not in index" );
			break;
			}

		//	record must honor index no NULL segment requirements
		//
		if ( fNoNullSeg )
			{
			Assert( wrnFLDNullSeg != err );
			Assert( wrnFLDNullFirstSeg != err );
			Assert( wrnFLDNullKey != err );
			}

		if ( wrnFLDNullKey == err )
			{
			Assert( 1 == itagSequenceOld );	//	nulls beyond itagSequence 1 would have generated wrnFLDOutOfKeys
			Assert( !fTuples );		//	tuple indexes would have generated wrnFLDOutOfTuples instead
			if ( !fAllowAllNulls )
				break;
			fDoOldNullKey = fTrue;
			}
		else if ( ( wrnFLDNullFirstSeg == err && !fAllowFirstNull )
				|| ( wrnFLDNullSeg == err && !fAllowSomeNulls ) )
			{
			break;
			}

		//	if this entry contains undefined unicode characters, unconditionally delete its MSU entry
		if( fUndefinedUnicodeChars )
			{
			RECReportUndefinedUnicodeEntry(
				pfucb->u.pfcb->ObjidFDP(),
				pfcbIdx->ObjidFDP(),
				pbmPrimary->key,
				keyOld,
				pfcbIdx->Pidb()->Lcid(),
				itagSequenceOld,
				0,
				fFalse );	

			if( pfcbIdx->Pidb()->FUnicodeFixupOn() )
				{
				if ( prceNil != prcePrimary )
					{
					//	UNDONE: we're in the update phase of
					//	concurrent create-index, and it's too
					//	complicated to try to update the
					//	fixup table at this point, so just
					//	flag the index as having fixups
					//	disabled
					//
					pfcbIdx->Pidb()->ResetFUnicodeFixupOn();
					}
				else
					{
					CallR( ErrCATDeleteMSURecord(
								pfucb->ppib,
								pfucb->ifmp,
								pfucbNil,
								pfucb->u.pfcb->ObjidFDP(),
								pfcbIdx->ObjidFDP(),
								pbmPrimary->key,
								keyOld,
								itagSequenceOld,
								0 ) );
					}
				}
			}

		//	UNDONE: for tuple indexes, skip check to see if we have to delete
		//	(we will unconditionally delete)
		//
		const BOOL	fPerformDeleteCheck		= !fTuples;
		fMustDelete = fTrue;	
		fDoNewNullKey = fFalse;
		for ( itagSequenceNew = 1; fPerformDeleteCheck; itagSequenceNew++ )
			{
			//	extract key from new data in copy buffer
			//
			Assert( prceNil != prcePrimary ?
					pfcbIdx->PfcbTable() == pfcbNil :		// Index not linked in yet.
					pfcbIdx->PfcbTable() == pfucb->u.pfcb );
			CallR( ErrRECRetrieveKeyFromCopyBuffer(
				pfucb, 
				pidb,
				&keyNew,
				itagSequenceNew,
				0,
				NULL,
				prcePrimary ) );

			CallS( ErrRECValidIndexKeyWarning( err ) );

			if ( wrnFLDOutOfKeys == err )
				{
				Assert( itagSequenceNew > 1 );
				break;
				}

			else if ( wrnFLDOutOfTuples == err )
				{
				//	UNDONE: should currently be impossible due to fPerformDeleteCheck hack
				//
				Assert( fFalse );

				//	try next itagSequence
				//
				Assert( fTuples );
				if ( fHasMultivalue )
					{
					//	NOTE: if we got wrnFLDOutOfTuples because
					//	itagSequence 1 was NULL (ie. there are no
					//	more multivalues), we are actually going
					//	to make one more iteration of this loop
					//	and break out when itagSequence 2 returns
					//	wrnFLDOutOfKeys.
					//	UNDONE: optimise to not require a second iteration
					//
					continue;
					}
				else
					break;
				}

			else if ( wrnFLDNotPresentInIndex == err )
				{
				//  new entry not present in the index. always delete the old one
				Assert( fMustDelete );
				Assert( 1 == itagSequenceNew );
				break;
				}

			if ( wrnFLDNullKey == err )
				{
				Assert( 1 == itagSequenceNew );	//	nulls beyond itagSequence 1 would have generated wrnFLDOutOfKeys
				Assert( !fTuples );		//	tuple indexes would have generated wrnFLDOutOfTuples instead
				if ( !fAllowAllNulls )
					break;
				fDoNewNullKey = fTrue;
				}
			else if ( ( wrnFLDNullFirstSeg == err && !fAllowFirstNull )
					|| ( wrnFLDNullSeg == err && !fAllowSomeNulls ) )
				{
				break;
				}

			if ( FKeysEqual( keyOld, keyNew ) )
				{
				//	the existing key matches one of the new keys,
				//	so no need to delete it
				fMustDelete = fFalse;
				break;
				}
			else if ( !fHasMultivalue || fDoNewNullKey )
				{
				//	if no multivalues in this index, there's no point going beyond first itagSequence
				//	if key is null, this implies there are no further multivalues
				Assert( 1 == itagSequenceNew );	//	nulls beyond itagSequence 1 would have generated wrnFLDOutOfKeys
				break;
				}
			}

		Assert( fMustDelete || !fTuples );
		if ( fMustDelete )
			{
			//	is it possible that the index entry may already have been deleted
			//	as a result of a previous multi-value generating the same index
			//	entry as the current multi-value?
			//
			const BOOL	fMayHaveAlreadyBeenDeleted	= ( itagSequenceOld > 1
														&& !fUnique
														&& fIndexUpdated );
			Assert( !fMayHaveAlreadyBeenDeleted || fHasMultivalue );

			//	delete corresponding index entry
			//
			CallR( ErrRECIDeleteIndexEntry(
							pfucbIdx,
							keyOld,
							pbmPrimary->key,
							prcePrimary,
							fMayHaveAlreadyBeenDeleted,
							&fIndexUpdated ) );
			}

		if ( fTuples )
			{
			//	at minimum, index with itagSequence==1 and ibSequence==0
			//	already got deleted, since we don't currently do
			//	FMustDelete optimisation for tuple indexes
			Assert( fIndexUpdated );

			for ( ULONG ichOffset = 1; ichOffset < pidb->ChTuplesToIndexMax(); ichOffset++ )
				{
				fUndefinedUnicodeChars = fFalse;
				
				CallR( ErrRECIRetrieveKeyForReplace(
							pfucb,
							pfcbIdx,
							&keyOld,
							itagSequenceOld,
							ichOffset,
							&fUndefinedUnicodeChars,
							prcePrimary ) );

				//	all other warnings should have been detected
				//	when we retrieved with ichOffset==0
				//
				CallSx( err, wrnFLDOutOfTuples );
				if ( JET_errSuccess != err )
					break;

				if( fUndefinedUnicodeChars )
					{
					RECReportUndefinedUnicodeEntry(
						pfucb->u.pfcb->ObjidFDP(),
						pfcbIdx->ObjidFDP(),
						pbmPrimary->key,
						keyOld,
						pfcbIdx->Pidb()->Lcid(),
						itagSequenceOld,
						ichOffset,
						fFalse );				

					if( pfcbIdx->Pidb()->FUnicodeFixupOn() )
						{
						if ( prceNil != prcePrimary )
							{
							//	UNDONE: we're in the update phase of
							//	concurrent create-index, and it's too
							//	complicated to try to update the
							//	fixup table at this point, so just
							//	flag the index as having fixups
							//	disabled
							//
							pfcbIdx->Pidb()->ResetFUnicodeFixupOn();
							}
						else
							{
							CallR( ErrCATDeleteMSURecord(
										pfucb->ppib,
										pfucb->ifmp,
										pfucbNil,
										pfucb->u.pfcb->ObjidFDP(),
										pfcbIdx->ObjidFDP(),
										pbmPrimary->key,
										keyOld,
										itagSequenceOld,
										ichOffset ) );
							}
						}
					}

				//	delete corresponding index entry
				//
				CallR( ErrRECIDeleteIndexEntry(
								pfucbIdx,
								keyOld,
								pbmPrimary->key,
								prcePrimary,
								fTrue,		//	a previous tuple may have generated the same index key
								&fIndexUpdated ) );
				}
			}

		if ( !fHasMultivalue || fDoOldNullKey )
			{
			//	if no multivalues in this index, there's no point going beyond first itagSequence
			//	if key is null, this implies there are no further multivalues
			//
			Assert( 1 == itagSequenceOld );	//	nulls beyond itagSequence 1 would have generated wrnFLDOutOfKeys
			break;
			}
		}

	fDoNewNullKey = fFalse;
	for ( itagSequenceNew = 1; ; itagSequenceNew++ )
		{
		fUndefinedUnicodeChars = fFalse;
		
		//	extract key from new data in copy buffer
		//
		Assert( prceNil != prcePrimary ?
				pfcbIdx->PfcbTable() == pfcbNil :		// Index not linked in yet.
				pfcbIdx->PfcbTable() == pfucb->u.pfcb );
		CallR( ErrRECRetrieveKeyFromCopyBuffer(
			pfucb, 
			pidb, 
			&keyNew, 
			itagSequenceNew,
			0,
			&fUndefinedUnicodeChars,
			prcePrimary ) );

		CallS( ErrRECValidIndexKeyWarning( err ) );

		if ( wrnFLDOutOfKeys == err )
			{
			Assert( itagSequenceNew > 1 );
			break;
			}

		else if ( wrnFLDOutOfTuples == err )
			{
			//	try next itagSequence
			//
			Assert( fTuples);
			if ( fHasMultivalue )
				{
				//	NOTE: if we got wrnFLDOutOfTuples because
				//	itagSequence 1 was NULL (ie. there are no
				//	more multivalues), we are actually going
				//	to make one more iteration of this loop
				//	and break out when itagSequence 2 returns
				//	wrnFLDOutOfKeys.
				//	UNDONE: optimise to not require a second iteration
				//
				continue;
				}
			else
				break;
			}

		else if ( wrnFLDNotPresentInIndex == err )
			{
			//  new record was not in this index
			//
			Assert( 1 == itagSequenceNew );
			break;
			}

		if ( fNoNullSeg && ( wrnFLDNullSeg == err || wrnFLDNullFirstSeg == err || wrnFLDNullKey == err ) )
			{
			err = ErrERRCheck( JET_errNullKeyDisallowed );
			return err;
			}

		if ( wrnFLDNullKey == err )
			{
			Assert( 1 == itagSequenceNew );	//	nulls beyond itagSequence 1 would have generated wrnFLDOutOfKeys
			Assert( !fTuples );		//	tuple indexes would have generated wrnFLDOutOfTuples instead
			if ( !fAllowAllNulls )
				break;
			fDoNewNullKey = fTrue;
			}
		else if ( ( wrnFLDNullFirstSeg == err && !fAllowFirstNull )
				|| ( wrnFLDNullSeg == err && !fAllowSomeNulls ) )
			{
			break;
			}

		//	insert the MSU entry			

		if( fUndefinedUnicodeChars )
			{
			RECReportUndefinedUnicodeEntry(
				pfucb->u.pfcb->ObjidFDP(),
				pfcbIdx->ObjidFDP(),
				pbmPrimary->key,
				keyNew,
				pfcbIdx->Pidb()->Lcid(),
				itagSequenceNew,
				0,
				fTrue );

			if( pfcbIdx->Pidb()->FUnicodeFixupOn() )
				{
				if ( prceNil != prcePrimary )
					{
					//	UNDONE: we're in the update phase of
					//	concurrent create-index, and it's too
					//	complicated to try to update the
					//	fixup table at this point, so just
					//	flag the index as having fixups
					//	disabled
					//
					pfcbIdx->Pidb()->ResetFUnicodeFixupOn();
					}
				else
					{
					CallR( ErrCATInsertMSURecord(
								pfucb->ppib,
								pfucb->ifmp,
								pfucbNil,
								pfucb->u.pfcb->ObjidFDP(),
								pfcbIdx->ObjidFDP(),
								pbmPrimary->key,
								keyNew,
								pfcbIdx->Pidb()->Lcid(),
								itagSequenceNew,
								0 ) );
					}
				}
			}				

		//	UNDONE: for tuple indexes, skip check to see if we have to add
		//	(we will unconditionally add)
		//
		const BOOL	fPerformAddCheck	= !fTuples;
		fMustAdd = fTrue;
		fDoOldNullKey = fFalse;
		for ( itagSequenceOld = 1; fPerformAddCheck; itagSequenceOld++ )
			{
			CallR( ErrRECIRetrieveKeyForReplace(
						pfucb,
						pfcbIdx,
						&keyOld,
						itagSequenceOld,
						0,
						NULL,
						prcePrimary ) );

			if ( wrnFLDOutOfKeys == err )
				{
				Assert( itagSequenceOld > 1 );
				break;
				}

			else if ( wrnFLDOutOfTuples == err )
				{
				//	UNDONE: should currently be impossible due to fPerformAddCheck hack
				Assert( fFalse );

				//	try next itagSequence
				//
				Assert( fTuples );
				if ( fHasMultivalue )
					{
					//	NOTE: if we got wrnFLDOutOfTuples because
					//	itagSequence 1 was NULL (ie. there are no
					//	more multivalues), we are actually going
					//	to make one more iteration of this loop
					//	and break out when itagSequence 2 returns
					//	wrnFLDOutOfKeys.
					//	UNDONE: optimise to not require a second iteration
					//
					continue;
					}
				else
					break;
				}

			else if ( wrnFLDNotPresentInIndex == err )
				{
				//  the old record was not present in the index. the new one is (or we would bail out above )
				//
				Assert( fMustAdd );
				Assert( 1 == itagSequenceOld );
				break;
				}
				
			//	record must honor index no NULL segment requirements
			//
			if ( fNoNullSeg )
				{
				Assert( wrnFLDNullSeg != err );
				Assert( wrnFLDNullFirstSeg != err );
				Assert( wrnFLDNullKey != err );
				}

			if ( wrnFLDNullKey == err )
				{
				Assert( 1 == itagSequenceOld );	//	nulls beyond itagSequence 1 would have generated wrnFLDOutOfKeys
				Assert( !fTuples );		//	tuple indexes would have generated wrnFLDOutOfTuples instead
				if ( !fAllowAllNulls )
					break;
				fDoOldNullKey = fTrue;
				}
			else if ( ( wrnFLDNullFirstSeg == err && !fAllowFirstNull )
					|| ( wrnFLDNullSeg == err && !fAllowSomeNulls ) )
				{
				break;
				}

			if ( FKeysEqual( keyOld, keyNew ) )
				{
				//	the new key matches one of the existing old keys, so no need to add it
				//
				fMustAdd = fFalse;
				break;
				}

			else if ( !fHasMultivalue || fDoOldNullKey )
				{
				//	if no multivalues in this index, there's no point going beyond first itagSequence
				//	if key is null, this implies there are no further multivalues
				//
				Assert( 1 == itagSequenceOld );	//	nulls beyond itagSequence 1 would have generated wrnFLDOutOfKeys
				break;
				}
			}

		Assert( fMustAdd || !fTuples );
		if ( fMustAdd )
			{
			//	move to DATA root and insert new index entry.
			//
			DIRGotoRoot( pfucbIdx );
			Assert( pbmPrimary->key.prefix.FNull() );
			Assert( pbmPrimary->key.Cb() > 0 );

			err = ErrDIRInsert(
						pfucbIdx,
						keyNew,
						pbmPrimary->key.suffix,
						fDIRBackToFather,
						prcePrimary );
			if ( err < 0 )
				{
				if ( JET_errMultiValuedIndexViolation == err )
					{
					if ( itagSequenceNew > 1 && !fUnique )
						{
						Assert( fHasMultivalue );

						//	must have been record with multi-value column
						//	or tuples with sufficiently similar values
						//	(ie. the indexed portion of the multi-values
						//	or tuples were identical) to produce redundant index entries.
						//
						err = JET_errSuccess;
						}
					else
						{
						RECIReportIndexCorruption( pfcbIdx );
						AssertSz( fFalse, "JET_errSecondaryIndexCorrupted during a replace" );
						err = ErrERRCheck( JET_errSecondaryIndexCorrupted );
						}
					}
				CallR( err );
				}
			else
				{
				fIndexUpdated = fTrue;
				}
			}

		if ( fTuples )
			{
			//	at minimum, index entry with itagSequence==1 and ichOffset==0
			//	already got added, since we don't currently do
			//	FMustAdd optimisation for tuple indexes.
			//
			Assert( fIndexUpdated );

			for ( ULONG ichOffset = 1; ichOffset < pidb->ChTuplesToIndexMax(); ichOffset++ )
				{
				CallR( ErrRECRetrieveKeyFromCopyBuffer(
								pfucb, 
								pidb, 
								&keyNew, 
								itagSequenceNew,
								ichOffset,
								&fUndefinedUnicodeChars,
								prcePrimary ) );

				//	all other warnings should have been detected
				//	when we retrieved with ichOffset==0.
				//
				CallSx( err, wrnFLDOutOfTuples );
				if ( JET_errSuccess != err )
					break;

				//	insert the MSU entry
				//
				if( fUndefinedUnicodeChars )
					{
					RECReportUndefinedUnicodeEntry(
						pfucb->u.pfcb->ObjidFDP(),
						pfcbIdx->ObjidFDP(),
						pbmPrimary->key,
						keyNew,
						pfcbIdx->Pidb()->Lcid(),
						itagSequenceNew,
						ichOffset,
						fTrue );

					if( pfcbIdx->Pidb()->FUnicodeFixupOn() )
						{
						if ( prceNil != prcePrimary )
							{
							//	UNDONE: we're in the update phase of
							//	concurrent create-index, and it's too
							//	complicated to try to update the
							//	fixup table at this point, so just
							//	flag the index as having fixups
							//	disabled
							//
							pfcbIdx->Pidb()->ResetFUnicodeFixupOn();
							}
						else
							{
							CallR( ErrCATInsertMSURecord(
										pfucb->ppib,
										pfucb->ifmp,
										pfucbNil,
										pfucb->u.pfcb->ObjidFDP(),
										pfcbIdx->ObjidFDP(),
										pbmPrimary->key,
										keyNew,
										pfcbIdx->Pidb()->Lcid(),
										itagSequenceNew,
										ichOffset ) );
							}
						}
					}

				//	move to DATA root and insert new index entry.
				//
				Assert( pbmPrimary->key.prefix.FNull() );
				Assert( pbmPrimary->key.Cb() > 0 );

				err = ErrDIRInsert(
							pfucbIdx,
							keyNew,
							pbmPrimary->key.suffix,
							fDIRBackToFather,
							prcePrimary );
				if ( JET_errMultiValuedIndexViolation == err )
					{
					//	must have been record with multi-value column
					//	or tuples with sufficiently similar values
					//	(ie. the indexed portion of the multi-values
					//	or tuples were identical) to produce redundant index entries.
					//
					err = JET_errSuccess;
					}
				else
					{
					CallR( err );
					}
				}
			}

		if ( !fHasMultivalue || fDoNewNullKey )
			{
			//	if no multivalues in this index, there's no point going beyond first itagSequence
			//	if key is null, this implies there are no further multivalues.
			//
			Assert( 1 == itagSequenceNew );	//	nulls beyond itagSequence 1 would have generated wrnFLDOutOfKeys
			break;
			}
		}


	//	suppress warnings
	//
	CallS( ErrRECValidIndexKeyWarning( err ) );
	err = ( fIndexUpdated ? ErrERRCheck( wrnFLDIndexUpdated ) : JET_errSuccess );
	return err;
	}


//  ================================================================
LOCAL ERR ErrRECIEscrowUpdate(
	PIB				*ppib,
	FUCB			*pfucb,
	const COLUMNID	columnid,
	const VOID		*pv,
	ULONG			cbMax,
	VOID			*pvOld,
	ULONG			cbOldMax,
	ULONG			*pcbOldActual,
	JET_GRBIT		grbit )
//  ================================================================
	{
	ERR			err			= JET_errSuccess;
	BOOL		fCommit		= fFalse;
	FIELD		fieldFixed;

	CallR( ErrRECIAccessColumn( pfucb, columnid, &fieldFixed ) );

	if ( FFUCBUpdatePrepared( pfucb ) )
		{
		return ErrERRCheck( JET_errAlreadyPrepared );
		}

	if ( sizeof( LONG ) != cbMax )
		{
		return ErrERRCheck( JET_errInvalidBufferSize );
		}

	if ( pvOld && 0 != cbOldMax && sizeof(LONG) > cbOldMax )
		{
		return ErrERRCheck( JET_errInvalidBufferSize );
		}

	if ( !FCOLUMNIDFixed( columnid ) )
		{
		return ErrERRCheck( JET_errInvalidOperation );
		}
	
	//	assert against client misbehaviour - EscrowUpdating a record while
	//	another cursor of the same session has an update pending on the record
	CallR( ErrRECSessionWriteConflict( pfucb ) );
	
	FCB	*pfcb = pfucb->u.pfcb;

	if ( FCOLUMNIDTemplateColumn( columnid ) )
		{
		if ( !pfcb->FTemplateTable() )
			{
			// Switch to template table.
			pfcb->Ptdb()->AssertValidDerivedTable();
			pfcb = pfcb->Ptdb()->PfcbTemplateTable();
			}
		else
			{
			pfcb->Ptdb()->AssertValidTemplateTable();
			}
		}

	if ( !FFIELDEscrowUpdate( fieldFixed.ffield ) )
		{
		return ErrERRCheck( JET_errInvalidOperation );
		}
	Assert( FCOLUMNIDFixed( columnid ) );

	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );

#ifdef DEBUG
	err = ErrDIRGet( pfucb );
	if ( err >= 0 )
		{
		const REC * const prec = (REC *)pfucb->kdfCurr.data.Pv();
		Assert( prec->FidFixedLastInRec() >= FidOfColumnid( columnid ) );
		CallS( ErrDIRRelease( pfucb ) );
		}
	Assert( !Pcsr( pfucb )->FLatched() );
#endif

	//  ASSERT: the offset is represented in the record

	DIRFLAG dirflag = fDIRNull;
	if ( JET_bitEscrowNoRollback & grbit )
		{
		dirflag |= fDIRNoVersion;
		}
	if( FFIELDFinalize( fieldFixed.ffield ) )
		{
		dirflag |= fDIREscrowCallbackOnZero;
		}
	if( FFIELDDeleteOnZero( fieldFixed.ffield ) )
		{
		dirflag |= fDIREscrowDeleteOnZero;
		}

	err = ErrDIRDelta(
			pfucb,
			fieldFixed.ibRecordOffset,
			pv,
			cbMax,
			pvOld,
			cbOldMax,
			pcbOldActual,
			dirflag );
	
	if ( err >= 0 )
		{
		err = ErrDIRCommitTransaction( ppib, NO_GRBIT );
		}
	if ( err < 0 )
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}

	return err;
	}


//  ================================================================
ERR VTAPI ErrIsamEscrowUpdate(
  	JET_SESID		sesid,
	JET_VTID		vtid,
	JET_COLUMNID	columnid,
	VOID 			*pv,
	ULONG 			cbMax,
	VOID 			*pvOld,
	ULONG 			cbOldMax,
	ULONG			*pcbOldActual,
	JET_GRBIT		grbit )
//  ================================================================
	{
 	PIB * const ppib	= reinterpret_cast<PIB *>( sesid );
	FUCB * const pfucb	= reinterpret_cast<FUCB *>( vtid );

	ERR			err = JET_errSuccess;

	if( ppib->level <= 0 )
		{
		return ErrERRCheck( JET_errNotInTransaction );
		}

	CallR( ErrPIBCheck( ppib ) );
	AssertDIRNoLatch( ppib );
	CheckTable( ppib, pfucb );
	CheckSecondary( pfucb );
	
	//	ensure that table is updatable
	//
	CallR( ErrFUCBCheckUpdatable( pfucb )  );
	CallR( ErrPIBCheckUpdatable( ppib ) );

	err = ErrRECIEscrowUpdate(
			ppib,
			pfucb,
			columnid,
			pv,
			cbMax,
			pvOld,
			cbOldMax,
			pcbOldActual,
			grbit );

	AssertDIRNoLatch( ppib );
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\rec.cxx ===
#include "std.hxx"

const WORD ibRECStartFixedColumns	= REC::cbRecordMin;

static JET_COLUMNDEF rgcolumndefJoinlist[] =
	{
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypBinary, 0, 0, 0, 0, 0, JET_bitColumnTTKey },
	};


/*=================================================================
ErrIsamGetLock

Description:
	get lock on the record from the specified file.

Parameters:

	PIB			*ppib			PIB of user
	FUCB	 	*pfucb	  		FUCB for file
	JET_GRBIT	grbit 			options

Return Value: standard error return

Errors/Warnings:
<List of any errors or warnings, with any specific circumstantial
 comments supplied on an as-needed-only basis>

Side Effects:
=================================================================*/

ERR VTAPI ErrIsamGetLock( JET_SESID sesid, JET_VTID vtid, JET_GRBIT grbit )
	{
 	PIB		*ppib = reinterpret_cast<PIB *>( sesid );
	FUCB	*pfucb = reinterpret_cast<FUCB *>( vtid );
	ERR		err;

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );
	CheckSecondary( pfucb );
	
	if ( ppib->level <= 0 )
		return ErrERRCheck( JET_errNotInTransaction );

	if ( JET_bitReadLock == grbit )	
		{
		Call( ErrDIRGetLock( pfucb, readLock ) );
		}
	else if ( JET_bitWriteLock == grbit )
		{
		//	ensure that table is updatable
		//
		CallR( ErrFUCBCheckUpdatable( pfucb )  );
		CallR( ErrPIBCheckUpdatable( ppib ) );

		Call( ErrDIRGetLock( pfucb, writeLock ) );
		}
	else
		{
		err = ErrERRCheck( JET_errInvalidGrbit );
		}

HandleError:
	return err;
	}


/*=================================================================
ErrIsamMove

Description:
	Retrieves the first, last, (nth) next, or (nth) previous
	record from the specified file.

Parameters:

	PIB			*ppib			PIB of user
	FUCB	 	*pfucb	  		FUCB for file
	LONG	 	crow			number of rows to move
	JET_GRBIT	grbit 			options

Return Value: standard error return

Errors/Warnings:
<List of any errors or warnings, with any specific circumstantial
 comments supplied on an as-needed-only basis>

Side Effects:
=================================================================*/

ERR VTAPI ErrIsamMove( JET_SESID sesid, JET_VTID vtid, LONG crow, JET_GRBIT grbit )
	{
 	PIB		*ppib = reinterpret_cast<PIB *>( sesid );
	FUCB	*pfucb = reinterpret_cast<FUCB *>( vtid );
	ERR		err = JET_errSuccess;
 	FUCB	*pfucbSecondary;			// FUCB for secondary index (if any)
	FUCB	*pfucbIdx;				// FUCB of selected index (pri or sec)
	DIB		dib;					// Information block for DirMan

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );
	CheckSecondary( pfucb );

	if ( FFUCBUpdatePrepared( pfucb ) )
		{
		CallR( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepCancel ) );
		}

	AssertDIRNoLatch( ppib );
	dib.dirflag = fDIRNull;

	// Get secondary index FUCB if any
	pfucbSecondary = pfucb->pfucbCurIndex;
	if ( pfucbSecondary == pfucbNil )
		pfucbIdx = pfucb;
	else
		pfucbIdx = pfucbSecondary;

	if ( crow == JET_MoveLast )
		{
		DIRResetIndexRange( pfucb );

		dib.pos = posLast;

		//	move to DATA root
		//
		DIRGotoRoot( pfucbIdx );

		err = ErrDIRDown( pfucbIdx, &dib );
		}
	else if ( crow > 0 )
		{
		LONG crowT = crow;

		if ( grbit & JET_bitMoveKeyNE )
			dib.dirflag |= fDIRNeighborKey;

		//	Move forward number of rows given
		//
		while ( crowT-- > 0 )
			{
			err = ErrDIRNext( pfucbIdx, dib.dirflag );
			if ( err < 0 )
				{
				Assert( !Pcsr( pfucbIdx )->FLatched() );
				break;
				}

			Assert( Pcsr( pfucbIdx )->FLatched() );
			
			if ( ( grbit & JET_bitMoveKeyNE ) && crowT > 0 )
				{
				// Need to do neighbour-key checking, so bookmark
				// must always be up-to-date.
				Call( ErrDIRRelease( pfucbIdx ) );
				Call( ErrDIRGet( pfucbIdx ) );
				Assert( Pcsr( pfucbIdx )->FLatched() );
				}
			}
		}
	else if ( crow == JET_MoveFirst )
		{
		DIRResetIndexRange( pfucb );

		dib.pos 		= posFirst;

		//	move to DATA root
		//
		DIRGotoRoot( pfucbIdx );

		err = ErrDIRDown( pfucbIdx, &dib );
		}
	else if ( crow == 0 )
		{
		err = ErrDIRGet( pfucbIdx );
		}
	else
		{
		LONG crowT = crow;

		if ( grbit & JET_bitMoveKeyNE )
			dib.dirflag |= fDIRNeighborKey;

		while ( crowT++ < 0 )
			{
			err = ErrDIRPrev( pfucbIdx, dib.dirflag );
			if ( err < 0 )
				{
				AssertDIRNoLatch( ppib );
				break;
				}

			Assert( Pcsr( pfucbIdx )->FLatched() );
			if ( ( grbit & JET_bitMoveKeyNE ) && crowT < 0 )
				{
				// Need to do neighbour-key checking, so bookmark
				// must always be up-to-date.
				Call( ErrDIRRelease( pfucbIdx ) );
				Call( ErrDIRGet( pfucbIdx ) );
				Assert( Pcsr( pfucbIdx )->FLatched() );
				}
			}
		}

	//	if the movement was successful and a secondary index is
	//	in use, then position primary index to record.
	//
	if ( err == JET_errSuccess && pfucbSecondary != pfucbNil )
		{
		BOOKMARK	bmRecord;
		
		Assert( pfucbSecondary->kdfCurr.data.Pv() != NULL );
		Assert( pfucbSecondary->kdfCurr.data.Cb() > 0 );
		Assert( Pcsr( pfucbIdx )->FLatched() );

		bmRecord.key.prefix.Nullify();
		bmRecord.key.suffix = pfucbSecondary->kdfCurr.data;
		bmRecord.data.Nullify();

		//	We will need to touch the data page buffer.

		CallJ( ErrDIRGotoBookmark( pfucb, bmRecord ), ReleaseLatch );

		Assert( !Pcsr( pfucb )->FLatched() );
		Assert( PgnoFDP( pfucb ) != pgnoSystemRoot );
		Assert( pfucb->u.pfcb->FPrimaryIndex() );
		}

	if ( JET_errSuccess == err )
		{
ReleaseLatch:
		ERR		errT;

		Assert( Pcsr( pfucbIdx )->FLatched() );

		errT = ErrDIRRelease( pfucbIdx );
		AssertDIRNoLatch( ppib );

		if ( JET_errSuccess == err && JET_errSuccess == errT )
			 {
			 return err;
			 }

		if ( err >= 0 && errT < 0 )
			{
			//	return the more severe error
			//
			err = errT;
			}
		}

HandleError:
	AssertDIRNoLatch( ppib );

	if ( crow > 0 )
		{
		DIRAfterLast( pfucbIdx );
		DIRAfterLast(pfucb);
		}
	else if ( crow < 0 )
		{
		DIRBeforeFirst(pfucbIdx);
		DIRBeforeFirst(pfucb);
		}

	switch ( err )
		{
		case JET_errRecordNotFound:
			err = ErrERRCheck( JET_errNoCurrentRecord );
		case JET_errNoCurrentRecord:
		case JET_errRecordDeleted:
			break;
		default:
			Assert( JET_errSuccess != err );
			DIRBeforeFirst( pfucbIdx );
			if ( pfucbSecondary != pfucbNil )
				DIRBeforeFirst( pfucbSecondary );
		}

	AssertDIRNoLatch( ppib );
	return err;
	}


ERR	ErrRECIMove( FUCB *pfucbTable, LONG crow, JET_GRBIT grbit )
	{
 	PIB		*ppib = pfucbTable->ppib;
	ERR		err = JET_errSuccess;
	FUCB	*pfucbIdx = pfucbTable->pfucbCurIndex ? 
							pfucbTable->pfucbCurIndex : 
							pfucbTable;
						
	DIRFLAG	dirflag = fDIRNull;
	
	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucbTable );
	CheckSecondary( pfucbTable );

	Assert( Pcsr( pfucbIdx )->FLatched() );
	Assert( !FFUCBUpdatePrepared( pfucbTable ) );
	
	if ( crow > 0 )
		{
		LONG crowT = crow;

		if ( grbit & JET_bitMoveKeyNE )
			dirflag |= fDIRNeighborKey;

		//	Move forward number of rows given
		//
		while ( crowT-- > 0 )
			{
			if ( grbit & JET_bitMoveKeyNE )
				{
				// Need to do neighbour-key checking, so bookmark
				// must always be up-to-date.
				Call( ErrDIRRelease( pfucbIdx ) );
				Call( ErrDIRGet( pfucbIdx ) );
				}
			
			err = ErrDIRNext( pfucbIdx, dirflag );
			if ( err < 0 )
				{
				AssertDIRNoLatch( ppib );
				break;
				}
				
			Assert( Pcsr( pfucbIdx )->FLatched() );
			}
		}
	else
		{
		Assert( crow < 0 );
		LONG crowT = crow;

		if ( grbit & JET_bitMoveKeyNE )
			dirflag |= fDIRNeighborKey;

		while ( crowT++ < 0 )
			{
			if ( grbit & JET_bitMoveKeyNE )
				{
				// Need to do neighbour-key checking, so bookmark
				// must always be up-to-date.
				Call( ErrDIRRelease( pfucbIdx ) );
				Call( ErrDIRGet( pfucbIdx ) );
				}
			
			err = ErrDIRPrev( pfucbIdx, dirflag );
			if ( err < 0 )
				{
				AssertDIRNoLatch( ppib );
				break;
				}
				
			Assert( Pcsr( pfucbIdx )->FLatched() );
			}
		}

	//	if the movement was successful and a secondary index is
	//	in use, then position primary index to record.
	//
	if ( JET_errSuccess == err )
		{
		if ( pfucbIdx != pfucbTable )
			{
			BOOKMARK	bmRecord;
			
			Assert( pfucbIdx->kdfCurr.data.Pv() != NULL );
			Assert( pfucbIdx->kdfCurr.data.Cb() > 0 );
			Assert( pfucbIdx->locLogical == locOnCurBM );
			Assert( Pcsr( pfucbIdx )->FLatched() );

			bmRecord.key.prefix.Nullify();
			bmRecord.key.suffix = pfucbIdx->kdfCurr.data;
			bmRecord.data.Nullify();
			
			//	We will need to touch the data page buffer.

			Call( ErrDIRGotoBookmark( pfucbTable, bmRecord ) );

			Assert( !Pcsr( pfucbTable )->FLatched() );
			Assert( PgnoFDP( pfucbTable ) != pgnoSystemRoot );
			Assert( pfucbTable->u.pfcb->FPrimaryIndex() );
			}
			
		Assert( Pcsr( pfucbIdx )->FLatched() );
		}
		
HandleError:
	if ( err < 0 )
		{
		AssertDIRNoLatch( ppib );
		
		if ( crow > 0 )
			{
			DIRAfterLast( pfucbIdx );
			DIRAfterLast( pfucbTable );
			}
		else if ( crow < 0 )
			{
			DIRBeforeFirst( pfucbIdx );
			DIRBeforeFirst( pfucbTable );
			}

		Assert( err != JET_errRecordNotFound );
		switch ( err )
			{
			case JET_errNoCurrentRecord:
			case JET_errRecordDeleted:
				break;
			default:
				Assert( JET_errSuccess != err );
				DIRBeforeFirst( pfucbIdx );
				DIRBeforeFirst( pfucbTable );
			}
		}
		
	return err;
	}

	
//	=================================================================
//	ErrIsamSeek

//	Description:
//	Retrieve the record specified by the given key or the
//	one just after it (SeekGT or SeekGE) or the one just
//	before it (SeekLT or SeekLE).

//	Parameters:

//	PIB			*ppib			PIB of user
//	FUCB		*pfucb 			FUCB for file
//	JET_GRBIT 	grbit			grbit

//	Return Value: standard error return

//	Errors/Warnings:
//	<List of any errors or warnings, with any specific circumstantial
//	comments supplied on an as-needed-only basis>

//	Side Effects:
//	=================================================================

ERR VTAPI ErrIsamSeek( JET_SESID sesid, JET_VTID vtid, JET_GRBIT grbit )
	{
 	PIB 		*ppib			= reinterpret_cast<PIB *>( sesid );
	FUCB 		*pfucbTable		= reinterpret_cast<FUCB *>( vtid );

	ERR			err;
	BOOKMARK	bm;			  			//	for search key
	DIB			dib;
	FUCB 		*pfucbSeek;				//	pointer to current FUCB
	BOOL		fFoundLess;
	BOOL		fFoundGreater;
	BOOL		fFoundEqual;
	BOOL		fRelease;

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucbTable );
	CheckSecondary( pfucbTable );
	AssertDIRNoLatch( ppib );

	//	find cursor to seek on
	//
	pfucbSeek = pfucbTable->pfucbCurIndex == pfucbNil ? 
					pfucbTable :
					pfucbTable->pfucbCurIndex;

	if ( !FKSPrepared( pfucbSeek ) )
		{
		return ErrERRCheck( JET_errKeyNotMade );
		}
	FUCBAssertValidSearchKey( pfucbSeek );

	//	Reset copy buffer status
	//
	if ( FFUCBUpdatePrepared( pfucbTable ) )
		{
		CallR( ErrIsamPrepareUpdate( ppib, pfucbTable, JET_prepCancel ) );
		}

	//	reset index range limit
	//
	DIRResetIndexRange( pfucbTable );

	//	ignore segment counter
	//
	bm.key.prefix.Nullify();
	bm.key.suffix.SetPv( pfucbSeek->dataSearchKey.Pv() );
	bm.key.suffix.SetCb( pfucbSeek->dataSearchKey.Cb() );
	bm.data.Nullify();

	dib.pos = posDown;
	dib.pbm = &bm;

	if ( grbit & (JET_bitSeekLT|JET_bitSeekLE) )
		{
		dib.dirflag = fDIRFavourPrev;
		}
	else if ( grbit & JET_bitSeekGE )
		{
		dib.dirflag = fDIRFavourNext;
		}
	else if ( grbit & JET_bitSeekGT )
		{
		if ( !FFUCBUnique( pfucbSeek )
			&& bm.key.suffix.Cb() < cbKeyMostWithOverhead )		//	may be equal if Limit already set or client used JET_bitNormalizedKey
			{
			//	PERF: seek on Limit of key, otherwise we would
			//	end up on the first index entry for this key
			//	(because of the trailing bookmark) and we
			//	would have to laterally navigate past it
			//	(and possibly others)
			( (BYTE *)bm.key.suffix.Pv() )[bm.key.suffix.Cb()] = 0xff;
			bm.key.suffix.DeltaCb( 1 );
			}
		dib.dirflag = fDIRFavourNext;
		}
	else if ( grbit & JET_bitSeekEQ )
		{
		dib.dirflag = fDIRExact;
#ifdef CHECK_UNIQUE_KEY_ON_NONUNIQUE_INDEX
		if ( grbit & JET_bitCheckUniqueness )
			{
			dib.dirflag |= fDIRCheckUniqueness;
			}
#endif
		}
	else
		{
		dib.dirflag = fDIRNull;
		}

	err = ErrDIRDown( pfucbSeek, &dib );

	//	remember return from seek
	//
	fFoundLess = ( wrnNDFoundLess == err );
	fFoundGreater = ( wrnNDFoundGreater == err );
	fFoundEqual = ( !fFoundGreater
					&& !fFoundLess
					&& err >= 0 );
	fRelease = ( err >= 0 );

	Assert( !fRelease || Pcsr( pfucbSeek )->FLatched() );
	Assert( err < 0 || fFoundEqual || fFoundGreater || fFoundLess );
	
#define bitSeekAll (JET_bitSeekEQ | JET_bitSeekGE | JET_bitSeekGT |	JET_bitSeekLE | JET_bitSeekLT)

	if ( fFoundEqual )
		{
#ifdef CHECK_UNIQUE_KEY_ON_NONUNIQUE_INDEX
		const BOOL	fFoundUniqueKey		= ( ( grbit & JET_bitCheckUniqueness )
											&& ( JET_wrnUniqueKey == err || FFUCBUnique( pfucbSeek ) ) );
#else
		const BOOL	fFoundUniqueKey		= fFalse;
#endif

		Assert( Pcsr( pfucbSeek )->FLatched() );
		Assert( locOnCurBM == pfucbSeek->locLogical );
		if ( pfucbTable->pfucbCurIndex != pfucbNil )
			{
			//	if a secondary index is in use,
			//	then position primary index on record
			//
			Assert( FFUCBSecondary( pfucbSeek ) );
			Assert( pfucbSeek == pfucbTable->pfucbCurIndex );

			//	goto bookmark pointed to by secondary index node
			//
			BOOKMARK	bmRecord;
			
			Assert(pfucbSeek->kdfCurr.data.Pv() != NULL);
			Assert(pfucbSeek->kdfCurr.data.Cb() > 0 );

			bmRecord.key.prefix.Nullify();
			bmRecord.key.suffix = pfucbSeek->kdfCurr.data;
			bmRecord.data.Nullify();

			//	We will need to touch the data page buffer.

			Call( ErrDIRGotoBookmark( pfucbTable, bmRecord ) );
			
			Assert( PgnoFDP( pfucbTable ) != pgnoSystemRoot );
			Assert( pfucbTable->u.pfcb->FPrimaryIndex() );
			}

		switch ( grbit & bitSeekAll )
			{
			case JET_bitSeekEQ:
				Assert( fRelease );
				Assert( Pcsr( pfucbSeek )->FLatched() );
				Call( ErrDIRRelease( pfucbSeek ) );
				fRelease = fFalse;
		
				//	found equal on seek equal.  If index range grbit is
				//	set and we know the current key is not unique
				//	then set index range upper inclusive.
				//
				if ( fFoundUniqueKey )
					{
					err = ErrERRCheck( JET_wrnUniqueKey );
					}
				else if ( grbit & JET_bitSetIndexRange )
					{
					CallR( ErrIsamSetIndexRange( ppib, pfucbTable, JET_bitRangeInclusive | JET_bitRangeUpperLimit ) );
					}

				goto Release;
				break;

			case JET_bitSeekGE:
			case JET_bitSeekLE:
				//	release and return
				//
				CallS( err );
				goto Release;
				break;

			case JET_bitSeekGT:
				//	move to next node with different key
				//	release and return
				//
				err = ErrRECIMove( pfucbTable, JET_MoveNext, JET_bitMoveKeyNE );
				
				if ( err < 0 )
					{
					AssertDIRNoLatch( ppib );
					if ( JET_errNoCurrentRecord == err )
						{
						KSReset( pfucbSeek );
						return ErrERRCheck( JET_errRecordNotFound );
						}

					goto HandleError;
					}

				CallS( err );
				goto Release;
				break;

			case JET_bitSeekLT:
				//	move to previous node with different key
				//	release and return
				//
				err = ErrRECIMove( pfucbTable, JET_MovePrevious, JET_bitMoveKeyNE );
				
				if ( err < 0 )
					{
					AssertDIRNoLatch( ppib );
					if ( JET_errNoCurrentRecord == err )
						{
						KSReset( pfucbSeek );
						return ErrERRCheck( JET_errRecordNotFound );
						}

					goto HandleError;
					}

				CallS( err );
				goto Release;
				break;

			default:
				Assert( fFalse );
				return err;
			}
		}
	else if ( fFoundLess )
		{
		Assert( Pcsr( pfucbSeek )->FLatched() );
		Assert( locBeforeSeekBM == pfucbSeek->locLogical );
		
		switch ( grbit & bitSeekAll )
			{
			case JET_bitSeekEQ:
				if ( FFUCBUnique( pfucbSeek ) )
					{
					//	see RecordNotFound case below for an
					//	explanation of why we need to set
					//	the locLogical of the primary cursor
					//	(note: the secondary cursor will
					//	narmally get set to locLogical when
					//	we call ErrDIRRelease() below, but
					//	may get set to locOnFDPRoot if we
					//	couldn't save the bookmark)
					if ( pfucbTable != pfucbSeek )
						{
						Assert( !Pcsr( pfucbTable )->FLatched() );
						pfucbTable->locLogical = locOnSeekBM;
						}
					err = ErrERRCheck( JET_errRecordNotFound );
					goto Release;
					}
					
				//	For non-unique indexes, because we use
				//	key+data for keys of internal nodes,
				//	and because child nodes have a key
				//	strictly less than its parent, we
				//	might end up on the wrong leaf node.
				//	We want to go to the right sibling and
				//	check the first node there to see if
				//	the key-only matches.
				Assert( pfucbSeek->u.pfcb->FTypeSecondaryIndex() );	//	only secondary index can be non-unique

				//	FALL THROUGH

			case JET_bitSeekGE:
			case JET_bitSeekGT:
				//	move to next node 
				//	release and return
MoveNextOnNonUnique:
				err = ErrRECIMove( pfucbTable, JET_MoveNext, NO_GRBIT );

				if ( err < 0 )
					{
					AssertDIRNoLatch( ppib );
					if ( JET_errNoCurrentRecord == err )
						{
						KSReset( pfucbSeek );
						return ErrERRCheck( JET_errRecordNotFound );
						}

					goto HandleError;
					}

				CallS( err );

				if ( !FFUCBUnique( pfucbSeek ) )
					{
					//	For a non-unique index, there are some complexities
					//	because the keys are stored as key+data but we're
					//	doing a key-only search.  This might cause us to
					//	fall short of the node we truly want, so we have
					//	to laterally navigate.
					Assert( pfucbSeek == pfucbTable->pfucbCurIndex ); 
					Assert( Pcsr( pfucbSeek )->FLatched() );
					const INT	cmp = CmpKey( pfucbSeek->kdfCurr.key, bm.key );
					Assert( cmp >= 0 );
					
					if ( grbit & JET_bitSeekGE )
						{
						if ( 0 != cmp )
							err = ErrERRCheck( JET_wrnSeekNotEqual );
						}
					else if ( grbit & JET_bitSeekGT )
						{
						//	the keys match exactly, but we're doing
						//	a strictly greater than search, so must
						//	keep navigating
						if ( 0 == cmp )
							goto MoveNextOnNonUnique;
						}
					else
						{
						Assert( grbit & JET_bitSeekEQ );

						if ( 0 != cmp )
							{
							err = ErrERRCheck( JET_errRecordNotFound );
							}
						else if ( grbit & ( JET_bitSetIndexRange|JET_bitCheckUniqueness ) )
							{
							Assert( fRelease );
							Assert( Pcsr( pfucbSeek )->FLatched() );

#ifdef CHECK_UNIQUE_KEY_ON_NONUNIQUE_INDEX
							BOOL		fFoundUniqueKey		= fFalse;

							if ( grbit & JET_bitCheckUniqueness )
								{
								const CSR * const	pcsr	= Pcsr( pfucbSeek );
								if ( pcsr->ILine() < pcsr->Cpage().Clines() - 1 )
									{
									const INT		cmpT	= CmpNDKeyOfNextNode( pcsr, bm.key );
									Assert( cmpT >= 0 );
									fFoundUniqueKey = ( cmpT > 0 );
									}
								}
#else
							const BOOL	fFoundUniqueKey		= fFalse;
#endif

							Call( ErrDIRRelease( pfucbSeek ) );
							fRelease = fFalse;

							if ( fFoundUniqueKey )
								{
								err = ErrERRCheck( JET_wrnUniqueKey );
								}
							else if ( grbit & JET_bitSetIndexRange )
								{
								CallR( ErrIsamSetIndexRange( ppib, pfucbTable, JET_bitRangeInclusive | JET_bitRangeUpperLimit ) );
								}
							}
						}
					}

				else if ( grbit & JET_bitSeekGE )
					{
					err = ErrERRCheck( JET_wrnSeekNotEqual );
					}

				goto Release;
				break;
			
			case JET_bitSeekLE:
			case JET_bitSeekLT:
				//	move to previous node -- to adjust DIR level locLogical
				//	release and return
				//
				err = ErrRECIMove( pfucbTable, JET_MovePrevious, NO_GRBIT );

				if ( err < 0 )
					{
					AssertDIRNoLatch( ppib );
					if ( JET_errNoCurrentRecord == err )
						{
						KSReset( pfucbSeek );
						return ErrERRCheck( JET_errRecordNotFound );
						}

					goto HandleError;
					}

				if ( grbit & JET_bitSeekLE )
					{
					err = ErrERRCheck( JET_wrnSeekNotEqual );
					}
				goto Release;
				break;

			default:
				Assert( fFalse );
				return err;
			}
		}
	else if ( fFoundGreater )
		{
		Assert( Pcsr( pfucbSeek )->FLatched() );
		Assert( locAfterSeekBM == pfucbSeek->locLogical );
		
		switch ( grbit & bitSeekAll )
			{
			case JET_bitSeekEQ:
				//	see RecordNotFound case below for an
				//	explanation of why we need to set
				//	the locLogical of the primary cursor
				//	(note: the secondary cursor will
				//	narmally get set to locLogical when
				//	we call ErrDIRRelease() below, but
				//	may get set to locOnFDPRoot if we
				//	couldn't save the bookmark)
				if ( pfucbTable != pfucbSeek )
					{
					Assert( !Pcsr( pfucbTable )->FLatched() );
					pfucbTable->locLogical = locOnSeekBM;
					}
				err = ErrERRCheck( JET_errRecordNotFound );
				goto Release;
				break;

			case JET_bitSeekGE:
			case JET_bitSeekGT:
				//	move next to fix DIR level locLogical
				//	release and return
				//
				err = ErrRECIMove( pfucbTable, JET_MoveNext, NO_GRBIT );

				Assert( err >= 0 );
				if ( err < 0 )
					{
					AssertDIRNoLatch( ppib );
					if ( JET_errNoCurrentRecord == err )
						{
						KSReset( pfucbSeek );
						return ErrERRCheck( JET_errRecordNotFound );
						}

					goto HandleError;
					}

				if ( grbit & JET_bitSeekGE )
					{
					err = ErrERRCheck( JET_wrnSeekNotEqual );
					}
				goto Release;
				break;
			
			case JET_bitSeekLE:
			case JET_bitSeekLT:
				//	move previous
				//	release and return
				//
				err = ErrRECIMove( pfucbTable, JET_MovePrevious, NO_GRBIT );

				if ( err < 0 )
					{
					AssertDIRNoLatch( ppib );
					if ( JET_errNoCurrentRecord == err )
						{
						KSReset( pfucbSeek );
						return ErrERRCheck( JET_errRecordNotFound );
						}

					goto HandleError;
					}

				Assert( CmpKey( pfucbSeek->kdfCurr.key, bm.key ) < 0 );
				if ( grbit & JET_bitSeekLE )
					{
					err = ErrERRCheck( JET_wrnSeekNotEqual );
					}
				goto Release;
				break;

			default:
				Assert( fFalse );
				return err;
			}
		}
	else
		{
		Assert( err < 0 );
		Assert( JET_errNoCurrentRecord != err );
		Assert( !Pcsr( pfucbSeek )->FLatched() );

		if ( JET_errRecordNotFound == err )
			{
			//	The secondary index cursor has been placed on a
			//	virtual record, so we must update the primary
			//	index cursor as well (if not, then it's possible
			//	to do, for instance, a RetrieveColumn on the
			//	primary cursor and you'll get back data from the
			//	record you were on before the seek but a
			//	RetrieveFromIndex on the secondary cursor will
			//	return JET_errNoCurrentRecord).
			//	Note that although the locLogical of the primary
			//	cursor is being updated, it's not necessary to
			//	update the primary cursor's bmCurr, because it
			//	will never be accessed (the secondary cursor takes
			//	precedence).  The only reason we reset the
			//	locLogical is for error-handling so that we
			//	properly err out with JET_errNoCurrentRecord if
			//	someone tries to use the cursor to access a record
			//	before repositioning the secondary cursor to a true
			//	record.
			Assert( locOnSeekBM == pfucbSeek->locLogical );
			if ( pfucbTable != pfucbSeek )
				{
				Assert( !Pcsr( pfucbTable )->FLatched() );
				pfucbTable->locLogical = locOnSeekBM;
				}
			}

		KSReset( pfucbSeek );
		AssertDIRNoLatch( ppib );
		return err;
		}

Release:
	//	release latched page and return error
	//
	if ( fRelease )
		{
		Assert( Pcsr( pfucbSeek ) ->FLatched() );
		const ERR	errT	= ErrDIRRelease( pfucbSeek );
		if ( errT < 0 )
			{
			err = errT;
			goto HandleError;
			}
		}
	KSReset( pfucbSeek );
	AssertDIRNoLatch( ppib );
	return err;

HandleError:
	//	reset cursor to before first
	//
	Assert( err < 0 );
	KSReset( pfucbSeek );
	DIRUp( pfucbSeek );
	DIRBeforeFirst( pfucbSeek );
	if ( pfucbTable != pfucbSeek )
		{
		Assert( !Pcsr( pfucbTable )->FLatched() );
		DIRBeforeFirst( pfucbTable );
		}
	AssertDIRNoLatch( ppib );
	return err;
	}

	
//	=================================================================
LOCAL ERR ErrRECICheckIndexrangesForUniqueness(
			const JET_SESID sesid,
			const JET_INDEXRANGE * const rgindexrange,
			const ULONG cindexrange )
//	=================================================================
	{
 	PIB	* const ppib		= reinterpret_cast<PIB *>( sesid );

	//  check that all the tableid's are on the same table and different indexes
	INT itableid;
	for( itableid = 0; itableid < cindexrange; ++itableid )
		{
		if( sizeof( JET_INDEXRANGE ) != rgindexrange[itableid].cbStruct )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}
		
		const FUCB * const pfucb	= reinterpret_cast<FUCB *>( rgindexrange[itableid].tableid );
		CheckTable( ppib, pfucb );
		CheckSecondary( pfucb );		

		//  don't do a join on the primary index!
			
		if( !pfucb->pfucbCurIndex )
			{
			AssertSz( fFalse, "Don't do a join on the primary index!" );
			return ErrERRCheck( JET_errInvalidParameter );
			}

		//  check the GRBITs

		if( JET_bitRecordInIndex != rgindexrange[itableid].grbit 
//	LaurionB: 01/10/02: removed until ErrRECIJoinFindDuplicates is fixed
//	for JET_bitRecordNotInIndex
///			&& JET_bitRecordNotInIndex != rgindexrange[itableid].grbit
			)
			{
			AssertSz( fFalse, "Invalid grbit in JET_INDEXRANGE" );
			return ErrERRCheck( JET_errInvalidGrbit );
			}

		//  check against all other indexes for duplications
		
		INT itableidT;
		for( itableidT = 0; itableidT < cindexrange; ++itableidT )
			{
			if( itableidT == itableid )
				{
				continue;
				}
				
			const FUCB * const pfucbT	= reinterpret_cast<FUCB *>( rgindexrange[itableidT].tableid );

			//  don't do a join on the primary index!
			
			if( !pfucbT->pfucbCurIndex )
				{
				AssertSz( fFalse, "Don't do a join on the primary index!" );
				return ErrERRCheck( JET_errInvalidParameter );
				}

			//  compare FCB's to make sure we are on the same table
			
			if( pfucbT->u.pfcb != pfucb->u.pfcb )
				{
				AssertSz( fFalse, "Indexes are not on the same table" );
				return ErrERRCheck( JET_errInvalidParameter );
				}

			//  compare secondary indexes to make sure the indexes are different

			if( pfucb->pfucbCurIndex->u.pfcb == pfucbT->pfucbCurIndex->u.pfcb )
				{
				AssertSz( fFalse, "Indexes are the same" );
				return ErrERRCheck( JET_errInvalidParameter );
				}
			}
		}
	return JET_errSuccess;
	}


//	=================================================================
LOCAL ERR ErrRECIInsertBookmarksIntoSort(
	FUCB * const		pfucb,
	FUCB * const		pfucbSort,
	const JET_GRBIT		grbit )
//	=================================================================
	{
	ERR					err;
	const INST * const	pinst		= PinstFromPfucb( pfucb );
	INT					cBookmarks	= 0;
	KEY					key;
	DATA				data;

	key.prefix.Nullify();
	data.Nullify();

	Call( ErrDIRGet( pfucb ) );
	do
		{
		//	this loop can take some time, so see if we need
		//	to terminate because of shutdown
		//
		Call( pinst->ErrCheckForTermination() );

		key.suffix = pfucb->kdfCurr.data;
		Call( ErrSORTInsert( pfucbSort, key, data ) );
		++cBookmarks;
		}
	while( ( err = ErrDIRNext( pfucb, fDIRNull ) ) == JET_errSuccess );

	if( JET_errNoCurrentRecord == err )
		{
		err = JET_errSuccess;
		}

HandleError:
	DIRUp( pfucb );
	FUCBResetPreread( pfucb );
	
	return err;
	}


//	=================================================================
LOCAL ERR ErrRECIJoinFindDuplicates(
	JET_SESID						sesid,
	const JET_INDEXRANGE * const	rgindexrange,
	FUCB * 							rgpfucbSort[],
	const ULONG						cindexes,
	JET_RECORDLIST * const 			precordlist,
	JET_GRBIT						grbit )
//	=================================================================
	{
	ERR								err;
	const INST * const				pinst		= PinstFromPpib( (PIB *)sesid );
	INT								isort;
	BYTE							rgfSortIsMin[64];
	
	//  move all the sorts to the first record
	
	for( isort = 0; isort < cindexes; ++isort )
		{
		err = ErrSORTNext( rgpfucbSort[isort] );
		if( JET_errNoCurrentRecord == err )
			{
			//  no bookmarks to return
			err = JET_errSuccess;
			return err;
			}
		Call( err );
		}

	//  create the temp table for the bookmarks

	Assert( 1 == sizeof( rgcolumndefJoinlist ) / sizeof( rgcolumndefJoinlist[0] ) );
	Call( ErrIsamOpenTempTable(
				sesid,
				rgcolumndefJoinlist,
				sizeof( rgcolumndefJoinlist ) / sizeof( rgcolumndefJoinlist[0] ),
				NULL,
				NO_GRBIT,
				&(precordlist->tableid),
				&(precordlist->columnidBookmark ) ) );

	//  take a unique list of bookmarks from the sorts

	while( 1 )
		{
		INT 	isortMin 	= 0;
				
		//	this loop can take some time, so see if we need
		//	to terminate because of shutdown
		//
		Call( pinst->ErrCheckForTermination() );

		//  find the index of the sort with the smallest bookmark
		
		for( isort = 1; isort < cindexes; ++isort )
			{
			const INT cmp = CmpKey( rgpfucbSort[isortMin]->kdfCurr.key, rgpfucbSort[isort]->kdfCurr.key );
			if( 0 == cmp )
				{
				}
			else if( cmp < 0 )
				{
				//  the current min is smaller
				}
			else
				{
				//  we have a new minimum				
				Assert( cmp > 0 );
				isortMin = isort;
				}
			}

		//  see if all keys are the same as the minimum

		BOOL 	fDuplicate 	= fTrue;
		memset( rgfSortIsMin, 0, sizeof( rgfSortIsMin ) );
		
		rgfSortIsMin[isortMin] = fTrue;
		for( isort = 0; isort < cindexes; ++isort )
			{
			if( isort == isortMin )
				{
				continue;
				}
			const INT cmp = CmpKey( rgpfucbSort[isortMin]->kdfCurr.key, rgpfucbSort[isort]->kdfCurr.key );
			if( 0 == cmp )
				{
				if( JET_bitRecordInIndex == rgindexrange[isort].grbit )
					{
					}
				else if( JET_bitRecordNotInIndex == rgindexrange[isort].grbit )
					{
					fDuplicate = fFalse;
					}
				else
					{
					Assert( fFalse );
					}

				rgfSortIsMin[isort] = fTrue;
				}
			else
				{
				if( JET_bitRecordInIndex == rgindexrange[isort].grbit )
					{
					fDuplicate = fFalse;
					}
				else if( JET_bitRecordNotInIndex == rgindexrange[isort].grbit )
					{
					}
				else
					{
					Assert( fFalse );
					}

				Assert( !rgfSortIsMin[isort] );
				}
			}

		//  if there are duplicates, insert into the temp table
		
		if( fDuplicate )
			{
			Call( ErrDispPrepareUpdate( sesid, precordlist->tableid, JET_prepInsert ) );

			Assert( rgpfucbSort[isortMin]->kdfCurr.key.prefix.FNull() );
			Call( ErrDispSetColumn(
						sesid,
						precordlist->tableid,
						precordlist->columnidBookmark,
						rgpfucbSort[isortMin]->kdfCurr.key.suffix.Pv(),
						rgpfucbSort[isortMin]->kdfCurr.key.suffix.Cb(),
						NO_GRBIT,
						NULL ) );

			Call( ErrDispUpdate( sesid, precordlist->tableid, NULL, 0, NULL, NO_GRBIT ) );

			++(precordlist->cRecord);
			}

		//  remove all minimums
		
		for( isort = 0; isort < cindexes; ++isort )
			{
			if( rgfSortIsMin[isort] )
				{
				err = ErrSORTNext( rgpfucbSort[isort] );
				if( JET_errNoCurrentRecord == err )
					{
					err = JET_errSuccess;
					return err;
					}
				Call( err );
				}	
			}
		}

HandleError:

	if( err < 0 && JET_tableidNil != precordlist->tableid )
		{
		CallS( ErrDispCloseTable( sesid, precordlist->tableid ) );
		precordlist->tableid = JET_tableidNil;
		}

	return err;
	}


//	=================================================================
ERR ErrIsamIntersectIndexes(
	const JET_SESID sesid,
	const JET_INDEXRANGE * const rgindexrange,
	const ULONG cindexrange,
	JET_RECORDLIST * const precordlist,
	const JET_GRBIT grbit )
//	=================================================================
	{
 	PIB	* const ppib		= reinterpret_cast<PIB *>( sesid );
 	
 	const INT	cSort = 64;
 	FUCB * 		rgpfucbSort[64];
 	
 	INT 		isort;

	ERR			err;

	//  check input parameters
	
	CallR( ErrPIBCheck( ppib ) );
	AssertDIRNoLatch( ppib );

	if( NULL == precordlist
		|| sizeof( JET_RECORDLIST ) != precordlist->cbStruct )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	if( 0 == cindexrange )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}
		
	if( cindexrange > cSort )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	//  check that all the tableid's are on the same table and different indexes
	
	CallR( ErrRECICheckIndexrangesForUniqueness( sesid, rgindexrange, cindexrange ) );

	//  set all the sort's to NULL

	for( isort = 0; isort < cindexrange; ++isort )
		{
		rgpfucbSort[isort] = pfucbNil;
		}

	//  initialize the pjoinlist

	precordlist->tableid	= JET_tableidNil;
	precordlist->cRecord 	= 0;
	precordlist->columnidBookmark = 0;
	
	//  create the sorts

	for( isort = 0; isort < cindexrange; ++isort )
		{
		Call( ErrSORTOpen( ppib, rgpfucbSort + isort, fTrue, fTrue ) );	
		}

	//  for each index, put all the primary keys in its index range into its sort

	for( isort = 0; isort < cindexrange; ++isort )
		{
		FUCB * const pfucb	= reinterpret_cast<FUCB *>( rgindexrange[isort].tableid );
		Call( ErrRECIInsertBookmarksIntoSort( pfucb->pfucbCurIndex, rgpfucbSort[isort], grbit ) );
		Call( ErrSORTEndInsert( rgpfucbSort[isort] ) );
		}

	//  insert duplicate bookmarks into a new temp table
	
	Call( ErrRECIJoinFindDuplicates(
			sesid,
			rgindexrange,
			rgpfucbSort,
			cindexrange,
			precordlist,
			grbit ) );

HandleError:

	//  close all the sorts

	for( isort = 0; isort < cindexrange; ++isort )
		{
		if( pfucbNil != rgpfucbSort[isort] )
			{
			SORTClose( rgpfucbSort[isort] );
			rgpfucbSort[isort] = pfucbNil;
			}
		}
	
	return err;
	}


LOCAL ERR ErrRECIGotoBookmark(
	PIB*				ppib,
	FUCB *				pfucb,
	const VOID * const	pvBookmark,
	const ULONG			cbBookmark,
	const ULONG			itagSequence )
	{
	ERR					err;
	BOOKMARK			bm;
	
	CallR( ErrPIBCheck( ppib ) );
	AssertDIRNoLatch( ppib );
	CheckTable( ppib, pfucb );
	Assert( FFUCBIndex( pfucb ) );
	Assert( FFUCBPrimary( pfucb ) );
	Assert( pfucb->u.pfcb->FPrimaryIndex() );
	CheckSecondary( pfucb );

	if( 0 == cbBookmark || NULL == pvBookmark )
		{
		//  don't pass a NULL bookmark into the DIR level
		return ErrERRCheck( JET_errInvalidBookmark );
		}

	//	reset copy buffer status
	//
	if ( FFUCBUpdatePrepared( pfucb ) )
		{
		CallR( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepCancel ) );
		}

	//	reset index range limit
	//
	DIRResetIndexRange( pfucb );

	KSReset( pfucb );

	//	get node, and return error if this node is not there for caller.
	//
	bm.key.prefix.Nullify();
	bm.key.suffix.SetPv( const_cast<VOID *>( pvBookmark ) );
	bm.key.suffix.SetCb( cbBookmark );
	bm.data.Nullify();

	Call( ErrDIRGotoJetBookmark( pfucb, bm ) );
	AssertDIRNoLatch( ppib );
	
	Assert( pfucb->u.pfcb->FPrimaryIndex() );
	Assert( PgnoFDP( pfucb ) != pgnoSystemRoot );
	
	//	goto bookmark record build key for secondary index
	//	to bookmark record
	//
	if ( pfucb->pfucbCurIndex != pfucbNil )
		{
		//	get secondary index cursor
		//
		FUCB	*pfucbIdx = pfucb->pfucbCurIndex;
		IDB		*pidb;
		KEY 	key;
		
		Assert( pfucbIdx->u.pfcb != pfcbNil );
		Assert( pfucbIdx->u.pfcb->FTypeSecondaryIndex() );
		
		pidb = pfucbIdx->u.pfcb->Pidb();
		Assert( pidb != pidbNil );
		Assert( !pidb->FPrimary() );
		
		KSReset( pfucbIdx );

		//	allocate goto bookmark resources
		//
		if ( NULL == pfucbIdx->dataSearchKey.Pv() )
			{
			pfucbIdx->dataSearchKey.SetPv( PvOSMemoryHeapAlloc( cbKeyMostWithOverhead ) );
			if ( NULL == pfucbIdx->dataSearchKey.Pv() )
				return ErrERRCheck( JET_errOutOfMemory );
			pfucbIdx->dataSearchKey.SetCb( cbKeyMostWithOverhead );
			}

		//	make key for record for secondary index
		//
		key.prefix.Nullify();
		key.suffix.SetPv( pfucbIdx->dataSearchKey.Pv() );
		key.suffix.SetCb( pfucbIdx->dataSearchKey.Cb() );
		Call( ErrRECRetrieveKeyFromRecord( pfucb, pidb, &key, itagSequence, 0, NULL, fFalse ) );
		AssertDIRNoLatch( ppib );
		if ( wrnFLDOutOfKeys == err )
			{
			Assert( itagSequence > 1 );
			err = ErrERRCheck( JET_errBadItagSequence );
			goto HandleError;
			}

		//	record must honor index no NULL segment requirements
		//
		if ( pidb->FNoNullSeg() )
			{
			Assert( wrnFLDNullSeg != err );
			Assert( wrnFLDNullFirstSeg != err );
			Assert( wrnFLDNullKey != err );
			}

		//	if item is not index, then move before first instead of seeking
		//
		Assert( err > 0 || JET_errSuccess == err );
		if ( err > 0
			&& ( ( wrnFLDNullKey == err && !pidb->FAllowAllNulls() )
				|| ( wrnFLDNullFirstSeg == err && !pidb->FAllowFirstNull() )
				|| ( wrnFLDNullSeg == err && !pidb->FAllowSomeNulls() ) )
				|| wrnFLDOutOfTuples == err
				|| wrnFLDNotPresentInIndex == err )
			{
			//	assumes that NULLs sort low
			//
			DIRBeforeFirst( pfucbIdx );
			err = ErrERRCheck( JET_errNoCurrentRecord );
			}
		else
			{
			//	move to DATA root
			//
			DIRGotoRoot( pfucbIdx );

			//	seek on secondary key and primary key as data
			//
			Assert( bm.key.prefix.FNull() );
			Call( ErrDIRDownKeyData( pfucbIdx, key, bm.key.suffix ) );
			CallS( err );
			}
		}

	CallSx( err, JET_errNoCurrentRecord );

HandleError:
	AssertDIRNoLatch( ppib );
	return err;
	}

ERR VTAPI ErrIsamGotoBookmark(
	JET_SESID			sesid,
	JET_VTID			vtid,
	const VOID * const	pvBookmark,
	const ULONG			cbBookmark )
	{
	return ErrRECIGotoBookmark(
						reinterpret_cast<PIB *>( sesid ),
						reinterpret_cast<FUCB *>( vtid ),
						pvBookmark,
						cbBookmark,
						1 );
	}

ERR VTAPI ErrIsamGotoIndexBookmark(
	JET_SESID			sesid,
	JET_VTID			vtid,
	const VOID * const	pvSecondaryKey,
	const ULONG			cbSecondaryKey,
	const VOID * const	pvPrimaryBookmark,
	const ULONG			cbPrimaryBookmark,
	const JET_GRBIT		grbit )
	{
	ERR					err;
 	PIB *				ppib		= reinterpret_cast<PIB *>( sesid );
	FUCB *				pfucb		= reinterpret_cast<FUCB *>( vtid );
	FUCB * const		pfucbIdx	= pfucb->pfucbCurIndex;
	BOOL				fInTrx		= fFalse;
	BOOKMARK			bm;

	CallR( ErrPIBCheck( ppib ) );
	AssertDIRNoLatch( ppib );
	CheckTable( ppib, pfucb );
	Assert( FFUCBIndex( pfucb ) );
	Assert( FFUCBPrimary( pfucb ) );
	Assert( pfucb->u.pfcb->FPrimaryIndex() );

	if ( pfucbNil == pfucbIdx )
		{
		return ErrERRCheck( JET_errNoCurrentIndex );
		}

	Assert( FFUCBSecondary( pfucbIdx ) );
	Assert( pfucbIdx->u.pfcb->FTypeSecondaryIndex() );

	if( 0 == cbSecondaryKey || NULL == pvSecondaryKey )
		{
		//  don't pass a NULL bookmark into the DIR level
		return ErrERRCheck( JET_errInvalidBookmark );
		}

	bm.key.prefix.Nullify();
	bm.key.suffix.SetPv( const_cast<VOID *>( pvSecondaryKey ) );
	bm.key.suffix.SetCb( cbSecondaryKey );

	if ( FFUCBUnique( pfucbIdx ) )
		{
		//	don't need primary bookmark, even if one was specified
		bm.data.Nullify();
		}
	else
		{
		if ( 0 == cbPrimaryBookmark || NULL == pvPrimaryBookmark )
			return ErrERRCheck( JET_errInvalidBookmark );

		bm.data.SetPv( const_cast<VOID *>( pvPrimaryBookmark ) );
		bm.data.SetCb( cbPrimaryBookmark );
		}


	//	reset copy buffer status
	//
	if ( FFUCBUpdatePrepared( pfucb ) )
		{
		Call( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepCancel ) );
		}

	//	reset index range limit
	//
	DIRResetIndexRange( pfucb );

	KSReset( pfucb );
	KSReset( pfucbIdx );

	if ( 0 == ppib->level )
		{
		Call( ErrDIRBeginTransaction( ppib, JET_bitTransactionReadOnly ) );
		fInTrx = fTrue;
		}

	//	move secondary cursor to desired location
	err = ErrDIRGotoJetBookmark( pfucbIdx, bm );
	Assert( !Pcsr( pfucbIdx )->FLatched() );

	//	Within ErrDIRGotoJetBookmark(), JET_errRecordDeleted
	//	from ErrBTGotoBookmark() means that the node with the
	//	specified bookmark was physically expunged, and
	//	JET_errRecordDeleted from ErrBTGet() means that the
	//	node is still physically present, but not visible
	//	to this cursor. In either case, establish virtual
	//	currency (so DIRNext/Prev() will work) if permitted.
	if ( JET_errRecordDeleted == err
		&& ( grbit & JET_bitBookmarkPermitVirtualCurrency ) )
		{
		Call( ErrBTDeferGotoBookmark( pfucbIdx, bm, fFalse/*no touch*/ ) );
		pfucbIdx->locLogical = locOnSeekBM;
		}
	else
		{
		Call( err );
		}

	CallS( err );
	AssertDIRNoLatch( ppib );

	Assert( locOnCurBM == pfucbIdx->locLogical
		|| locOnSeekBM == pfucbIdx->locLogical );
	Assert( bm.key.prefix.FNull() );
	bm.key.suffix = pfucbIdx->bmCurr.data;
	bm.data.Nullify();

	//	move primary cursor to match secondary cursor
	err = ErrBTDeferGotoBookmark( pfucb, bm, fTrue/*touch*/ );
	CallSx( err, JET_errOutOfMemory );
	if ( err < 0 )
		{
		//	force both cursors to a virtual currency
		//	UNDONE: I'm not sure what exactly the
		//	appropriate currency should be if we
		//	err out here
		pfucbIdx->locLogical = locOnSeekBM;
		pfucb->locLogical = locOnSeekBM;
		goto HandleError;
		}

	//	The secondary index cursor may have been placed on a
	//	virtual record, so we must update the primary
	//	index cursor as well (if not, then it's possible
	//	to do, for instance, a RetrieveColumn on the
	//	primary cursor and you'll get back data from the
	//	record you were on before the seek but a
	//	RetrieveFromIndex on the secondary cursor will
	//	return JET_errNoCurrentRecord).
	//	Note that although the locLogical of the primary
	//	cursor is being updated, it's not necessary to
	//	update the primary cursor's bmCurr, because it
	//	will never be accessed (the secondary cursor takes
	//	precedence).  The only reason we reset the
	//	locLogical is for error-handling so that we
	//	properly err out with JET_errNoCurrentRecord if
	//	someone tries to use the cursor to access a record
	//	before repositioning the secondary cursor to a true
	//	record.
	Assert( locOnCurBM == pfucbIdx->locLogical
		|| locOnSeekBM == pfucbIdx->locLogical );
	pfucb->locLogical = pfucbIdx->locLogical;

	Assert( FDataEqual( pfucbIdx->bmCurr.data, pfucb->bmCurr.key.suffix ) );

	if ( locOnSeekBM == pfucbIdx->locLogical )
		{
		//	if currency was placed on virtual bookmark, record must have gotten deleted
		Call( ErrERRCheck( JET_errRecordDeleted ) );
		}

	else if ( FFUCBUnique( pfucbIdx ) && 0 != cbPrimaryBookmark )
		{
		//	on a unique index, we'll ignore any primary bookmark the
		//	user may have specified, so need to verify this is truly
		//	the record the user requested
		if ( pfucbIdx->bmCurr.data.Cb() != cbPrimaryBookmark
			|| 0 != memcmp( pfucbIdx->bmCurr.data.Pv(), pvPrimaryBookmark, cbPrimaryBookmark ) )
			{
			//	index entry was found, but has a different primary
			//	bookmark, so must assume that original record
			//	was deleted (and new record subsequently got
			//	inserted with same secondary index key, but
			//	different primary key)
			//	NOTE: the user's currency will be left on the
			//	index entry matching the desired key, even
			//	though we're erring out because the primary'
			//	bookmark doesn't match
			Call( ErrERRCheck( JET_errRecordDeleted ) );
			}
		}

	CallS( err );

HandleError:
	if ( fInTrx )
		{
		CallS( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );
		}

	AssertDIRNoLatch( ppib );
	return err;
	}


ERR VTAPI ErrIsamGotoPosition( JET_SESID sesid, JET_VTID vtid, JET_RECPOS *precpos )
	{
 	PIB *ppib	= reinterpret_cast<PIB *>( sesid );
	FUCB *pfucb = reinterpret_cast<FUCB *>( vtid );

	ERR		err;
	FUCB 	*pfucbSecondary;

	CallR( ErrPIBCheck( ppib ) );
	AssertDIRNoLatch( ppib );
	CheckTable( ppib, pfucb );
	CheckSecondary( pfucb );

	if ( precpos->centriesLT > precpos->centriesTotal )
		{
		err = ErrERRCheck( JET_errInvalidParameter );
		return err;
		}

	//	Reset copy buffer status
	//
	if ( FFUCBUpdatePrepared( pfucb ) )
		{
		CallR( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepCancel ) );
		}

	//	reset index range limit
	//
	DIRResetIndexRange( pfucb );

	//	reset key stat
	//
	KSReset( pfucb );

	//	set non primary index pointer, may be null
	//
	pfucbSecondary = pfucb->pfucbCurIndex;

	if ( pfucbSecondary == pfucbNil )
		{
		//	move to DATA root
		//
		DIRGotoRoot( pfucb );

		err = ErrDIRGotoPosition( pfucb, precpos->centriesLT, precpos->centriesTotal );

		if ( err >= 0 )
			{
			Assert( Pcsr( pfucb )->FLatched( ) );

			err = ErrDIRRelease( pfucb );
			}
		}
	else
		{
		ERR			errT = JET_errSuccess;
		
		//	move to DATA root
		//
		DIRGotoRoot( pfucbSecondary );

		err = ErrDIRGotoPosition( pfucbSecondary, precpos->centriesLT, precpos->centriesTotal );

		//	if the movement was successful and a secondary index is
		//	in use, then position primary index to record.
		//
		if ( JET_errSuccess == err )
			{
			//	goto bookmark pointed to by secondary index node
			//
			BOOKMARK	bmRecord;
			
			Assert(pfucbSecondary->kdfCurr.data.Pv() != NULL);
			Assert(pfucbSecondary->kdfCurr.data.Cb() > 0 );

			bmRecord.key.prefix.Nullify();
			bmRecord.key.suffix = pfucbSecondary->kdfCurr.data;
			bmRecord.data.Nullify();

			//	We will need to touch the data page buffer.

			errT = ErrDIRGotoBookmark( pfucb, bmRecord );

			Assert( PgnoFDP( pfucb ) != pgnoSystemRoot );
			Assert( pfucb->u.pfcb->FPrimaryIndex() );
			}

		if ( err >= 0 )
			{
			//	release latch
			//
			err = ErrDIRRelease( pfucbSecondary );

			if ( errT < 0 && err >= 0 )
				{
				//	propagate the more severe error
				//
				err = errT;
				}
			}
		else
			{
			AssertDIRNoLatch( ppib );
			}
		}

	AssertDIRNoLatch( ppib );
	
	//	if no records then return JET_errRecordNotFound
	//	otherwise return error from called routine
	//
	if ( err < 0 )
		{
		DIRBeforeFirst( pfucb );

		if ( pfucbSecondary != pfucbNil )
			{
			DIRBeforeFirst( pfucbSecondary );
			}
		}
	else
		{
		Assert ( JET_errSuccess == err || wrnNDFoundLess == err || wrnNDFoundGreater == err );
		err = JET_errSuccess;
		}

	return err;
	}


ERR VTAPI ErrIsamSetIndexRange( JET_SESID sesid, JET_VTID vtid, JET_GRBIT grbit )
	{
	ERR		err			= JET_errSuccess;
 	PIB		*ppib		= reinterpret_cast<PIB *>( sesid );
	FUCB	*pfucbTable	= reinterpret_cast<FUCB *>( vtid );
	FUCB	*pfucb		= pfucbTable->pfucbCurIndex ? 
							pfucbTable->pfucbCurIndex : pfucbTable;

	/*	ppib is not used in this function
	/**/
	AssertDIRNoLatch( ppib );

	/*	if instant duration index range, then reset index range.
	/**/
	if ( grbit & JET_bitRangeRemove )
		{
		if ( FFUCBLimstat( pfucb ) )
			{
			DIRResetIndexRange( pfucbTable );
			CallS( err );
			goto HandleError;
			}
		else
			{
			Call( ErrERRCheck( JET_errInvalidOperation ) );
			}
		}

	/*	must be on index
	/**/
	if ( pfucb == pfucbTable )
		{
		FCB		*pfcbTable = pfucbTable->u.pfcb;
		BOOL	fPrimaryIndexTemplate = fFalse;

		Assert( pfcbNil != pfcbTable );
		Assert( pfcbTable->FPrimaryIndex() );
		
		if ( pfcbTable->FDerivedTable() )
			{
			Assert( pfcbTable->Ptdb() != ptdbNil );
			Assert( pfcbTable->Ptdb()->PfcbTemplateTable() != pfcbNil );
			FCB	*pfcbTemplateTable = pfcbTable->Ptdb()->PfcbTemplateTable();
			if ( !pfcbTemplateTable->FSequentialIndex() )
				{
				//	If template table has a primary index,
				//	we must have inherited it,
				fPrimaryIndexTemplate = fTrue;
				Assert( pfcbTemplateTable->Pidb() != pidbNil );
				Assert( pfcbTemplateTable->Pidb()->FTemplateIndex() );
				Assert( pfcbTable->Pidb() == pfcbTemplateTable->Pidb() );
				}
			else
				{
				Assert( pfcbTemplateTable->Pidb() == pidbNil );
				}
			}

		//	if primary index was present when schema was faulted in,
		//	no need for further check because we don't allow
		//	the primary index to be deleted
		if ( !fPrimaryIndexTemplate && !pfcbTable->FInitialIndex() )
			{
			pfcbTable->EnterDML();
			if ( pidbNil == pfcbTable->Pidb() )
				{
				err = ErrERRCheck( JET_errNoCurrentIndex );
				}
			else
				{
				err = ErrFILEIAccessIndex( ppib, pfcbTable, pfcbTable );
				if ( JET_errIndexNotFound == err )
					err = ErrERRCheck( JET_errNoCurrentIndex );
				}
			pfcbTable->LeaveDML();
			Call( err );
			}
		}

	/*	key must be prepared
	/**/
	if ( !( FKSPrepared( pfucb ) ) )
		{
		Call( ErrERRCheck( JET_errKeyNotMade ) );
		}

	FUCBAssertValidSearchKey( pfucb );
	
	/*	set index range and check current position
	/**/
	DIRSetIndexRange( pfucb, grbit );
	err = ErrDIRCheckIndexRange( pfucb );

	/*	reset key status
	/**/
	KSReset( pfucb );

	/*	if instant duration index range, then reset index range.
	/**/
	if ( grbit & JET_bitRangeInstantDuration )
		{
		DIRResetIndexRange( pfucbTable );
		}

HandleError:
	AssertDIRNoLatch( ppib );
	return err;
	}


ERR ErrIsamSetCurrentIndex(
	JET_SESID			vsesid,
	JET_VTID			vtid,
	const CHAR			*szName,
	const JET_INDEXID	*pindexid,			//	default = NULL
	const JET_GRBIT		grbit,				//	default = JET_bitMoveFirst
	const ULONG			itagSequence )		//	default = 1
	{
	ERR					err;
	PIB					*ppib			= (PIB *)vsesid;
	FUCB				*pfucb			= (FUCB *)vtid;
	CHAR				*szIndex;
	CHAR				szIndexNameBuf[ (JET_cbNameMost + 1) ];

	CallR( ErrPIBCheck( ppib ) );
	AssertDIRNoLatch( ppib );
	CheckTable( ppib, pfucb );
	CheckSecondary( pfucb );
	Assert(	JET_bitMoveFirst == grbit || JET_bitNoMove == grbit );

	//	index name is ignored if an indexid is passed in
	//
	//	a null or empty index name indicates switching to primary index
	//
	if ( NULL != pindexid
		|| NULL == szName
		|| '\0' == *szName )
		{
		szIndex = NULL;
		}
	else
		{
		szIndex = szIndexNameBuf;
		Call( ErrUTILCheckName( szIndex, szName, (JET_cbNameMost + 1) ) );
		}

	if ( JET_bitMoveFirst == grbit )
		{
		//	Reset copy buffer status
		//
		if ( FFUCBUpdatePrepared( pfucb ) )
			{
			CallR( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepCancel ) );
			}
		
		//	change index and defer move first
		//
		Call( ErrRECSetCurrentIndex( pfucb, szIndex, (INDEXID *)pindexid ) );
		AssertDIRNoLatch( ppib );

		if( pfucb->u.pfcb->FPreread() && pfucbNil != pfucb->pfucbCurIndex )
			{
			//  Preread the root of the index
			BFPrereadPageRange( pfucb->ifmp, pfucb->pfucbCurIndex->u.pfcb->PgnoFDP(), 1 );
			}
		
		RECDeferMoveFirst( ppib, pfucb );
		}
	else
		{
		Assert( JET_bitNoMove == grbit );
		
		//	get bookmark of current record, change index,
		//	and goto bookmark.
		BOOKMARK	*pbm;
			
		Call( ErrDIRGetBookmark( pfucb, &pbm ) );
		AssertDIRNoLatch( ppib );
			
		Call( ErrRECSetCurrentIndex( pfucb, szIndex, (INDEXID *)pindexid ) );
			
		//	UNDONE:	error handling.  We should not have changed
		//	currency or current index, if set current index
		//	fails for any reason.  Note that this functionality
		//	could be provided by duplicating the cursor, on 
		//	the primary index, setting the current index to the
		//	new index, getting the bookmark from the original 
		//	cursor, goto bookmark on the duplicate cursor, 
		//	instating the duplicate cursor for the table id of
		//	the original cursor, and closing the original cursor.
		//
		Assert( pbm->key.Cb() > 0 );
		Assert( pbm->data.Cb() == 0 );
			
		Assert( pbm->key.prefix.FNull() );
		Call( ErrRECIGotoBookmark(
					pfucb->ppib,
					pfucb,
					pbm->key.suffix.Pv(),
					pbm->key.suffix.Cb(),
					max( 1, itagSequence ) ) );
		}

HandleError:
	AssertDIRNoLatch( ppib );
	return err;
	}


ERR ErrRECSetCurrentIndex(
	FUCB			*pfucb,
	const CHAR		*szIndex,
	const INDEXID	*pindexid )
	{
	ERR				err;
	FCB				*pfcbTable;
	FCB				*pfcbSecondary;
	FUCB			**ppfucbCurIdx;
	FUCB			* pfucbOldIndex			= pfucbNil;
	BOOL			fSettingToPrimaryIndex	= fFalse;
	BOOL			fInDMLLatch				= fFalse;
	BOOL			fIncrementedRefCount	= fFalse;
	BOOL			fClosedPreviousIndex	= fFalse;

	Assert( pfucb != pfucbNil );
	Assert( FFUCBIndex( pfucb ) );
	AssertDIRNoLatch( pfucb->ppib );

	pfcbTable = pfucb->u.pfcb;
	Assert( pfcbTable != pfcbNil );
	Assert( pfcbTable->FPrimaryIndex() );

	Assert( pfcbTable->Ptdb() != ptdbNil );

	ppfucbCurIdx = &pfucb->pfucbCurIndex;

	//	caller should have verified that an
	//	empty index name is not being passed in
	//
	Assert( NULL == szIndex || '\0' != *szIndex );

	//	NOTE: index name is ignored if an indexid
	//	is specified
	//
	if ( NULL != pindexid )
		{
		if ( sizeof(INDEXID) != pindexid->cbStruct )
			{
			return ErrERRCheck( JET_errInvalidIndexId );
			}

		const FCB	* pfcbIndex	= pindexid->pfcbIndex;

		if ( pfcbIndex == pfcbTable )
			{
			fSettingToPrimaryIndex = fTrue;
			if ( pfcbIndex->ObjidFDP() != pindexid->objidFDP
				|| pfcbIndex->PgnoFDP() != pindexid->pgnoFDP )
				{
				return ErrERRCheck( JET_errInvalidIndexId );
				}
			}

		else if ( NULL != *ppfucbCurIdx && pfcbIndex == (*ppfucbCurIdx)->u.pfcb )
			{
			//	switching to the current index
			//
			return ( pfcbIndex->ObjidFDP() != pindexid->objidFDP
					|| pfcbIndex->PgnoFDP() != pindexid->pgnoFDP ?
							ErrERRCheck( JET_errInvalidIndexId ) :
							JET_errSuccess );
			
			}

		else if ( !pfcbIndex->FValid( PinstFromPfucb( pfucb ) ) )
			{
			AssertSz( fFalse, "Bogus FCB pointer." );
			return ErrERRCheck( JET_errInvalidIndexId );
			}

		else
			{
			//	verify index visibility
			pfcbTable->EnterDML();

			if ( pfcbIndex->ObjidFDP() != pindexid->objidFDP
				|| pfcbIndex->PgnoFDP() != pindexid->pgnoFDP
				|| !pfcbIndex->FTypeSecondaryIndex()
				|| pfcbIndex->PfcbTable() != pfcbTable )
				{
				err = ErrERRCheck( JET_errInvalidIndexId );
				}
			else
				{
				err = ErrFILEIAccessIndex( pfucb->ppib, pfcbTable, pfcbIndex );
				}

			if ( err < 0 )
				{
				pfcbTable->LeaveDML();

				//	return JET_errInvalidIndexId if index not visible to us
				return ( JET_errIndexNotFound == err ?
								ErrERRCheck( JET_errInvalidIndexId ) :
								err );
				}

			else if ( pfcbIndex->Pidb()->FTemplateIndex() )
				{
				// Don't need refcount on template indexes, since we
				// know they'll never go away.
				Assert( pfcbIndex->Pidb()->CrefCurrentIndex() == 0 );
				}

			else
				{
				//	pin the index until we're ready to open a cursor on it
				pfcbIndex->Pidb()->IncrementCurrentIndex();
				fIncrementedRefCount = fTrue;
				}

			pfcbTable->LeaveDML();
			}

		}

	//	a null index name indicates switching to primary index
	//
	else if ( NULL == szIndex )
		{
		fSettingToPrimaryIndex = fTrue;
		}

	else
		{
		BOOL	fPrimaryIndexTemplate	= fFalse;

		//	see if we're switching to the derived
		//	primary index (if any)
		if ( pfcbTable->FDerivedTable() )
			{
			Assert( pfcbTable->Ptdb() != ptdbNil );
			Assert( pfcbTable->Ptdb()->PfcbTemplateTable() != pfcbNil );
			const FCB * const	pfcbTemplateTable	= pfcbTable->Ptdb()->PfcbTemplateTable();

			if ( !pfcbTemplateTable->FSequentialIndex() )
				{
				// If template table has a primary index, we must have inherited it.

				fPrimaryIndexTemplate = fTrue;
				Assert( pfcbTemplateTable->Pidb() != pidbNil );
				Assert( pfcbTemplateTable->Pidb()->FTemplateIndex() );
				Assert( pfcbTable->Pidb() == pfcbTemplateTable->Pidb() );

				const TDB * const	ptdb			= pfcbTemplateTable->Ptdb();
				const IDB * const	pidb			= pfcbTemplateTable->Pidb();
				const CHAR * const	szPrimaryIdx	= ptdb->SzIndexName( pidb->ItagIndexName() );

				if ( 0 == UtilCmpName( szIndex, szPrimaryIdx ) )
					{			
					fSettingToPrimaryIndex = fTrue;
					}
				}
			else
				{
				Assert( pfcbTemplateTable->Pidb() == pidbNil );
				}
			}
			
		//	see if we're switching to the primary index
		if ( !fPrimaryIndexTemplate )
			{
			pfcbTable->EnterDML();

			if	( pfcbTable->Pidb() != pidbNil )
				{
				Assert( pfcbTable->Pidb()->ItagIndexName() != 0 );
				err = ErrFILEIAccessIndexByName( pfucb->ppib, pfcbTable, pfcbTable, szIndex );
				if ( err < 0 )
					{
					if ( JET_errIndexNotFound != err )
						{
						pfcbTable->LeaveDML();
						return err;
						}
					}
				else
					{
					fSettingToPrimaryIndex = fTrue;
					}
				}

			if ( !fSettingToPrimaryIndex
				&& pfucbNil != *ppfucbCurIdx
				&& !( (*ppfucbCurIdx)->u.pfcb->FDerivedIndex() ) )
				{
				//	don't let go of the DML latch because
				//	we're going to need it below to check
				//	if we're switching to the current
				fInDMLLatch = fTrue;
				}
			else
				{
				pfcbTable->LeaveDML();
				}
			}
		}

	if ( fSettingToPrimaryIndex )
		{
		Assert( !fInDMLLatch );

		if ( *ppfucbCurIdx != pfucbNil )
			{
			Assert( FFUCBIndex( *ppfucbCurIdx ) );
			Assert( FFUCBSecondary( *ppfucbCurIdx ) );
			Assert( (*ppfucbCurIdx)->u.pfcb != pfcbNil );
			Assert( (*ppfucbCurIdx)->u.pfcb->FTypeSecondaryIndex() );
			Assert( (*ppfucbCurIdx)->u.pfcb->Pidb() != pidbNil );
			Assert( (*ppfucbCurIdx)->u.pfcb->Pidb()->ItagIndexName() != 0 );
			Assert( (*ppfucbCurIdx)->u.pfcb->Pidb()->CrefCurrentIndex() > 0
				|| (*ppfucbCurIdx)->u.pfcb->Pidb()->FTemplateIndex() );

			//  move the sequential flag back to this index
			//  we are about to close this FUCB so we don't need to reset its flags
			if( FFUCBSequential( *ppfucbCurIdx ) )
				{
				FUCBSetSequential( pfucb );
				}
				
			//	really changing index, so close old one
			
			DIRClose( *ppfucbCurIdx );
			*ppfucbCurIdx = pfucbNil;
		
			//	changing to primary index.  Reset currency to beginning.
			ppfucbCurIdx = &pfucb;
			goto ResetCurrency;
			}
			
		//	UNDONE:	this case should honor grbit move expectations
		return JET_errSuccess;
		}

	
	Assert( NULL != szIndex || NULL != pindexid );

	//	have a current secondary index
	//
	if ( *ppfucbCurIdx != pfucbNil )
		{
		const FCB * const	pfcbSecondaryIdx	= (*ppfucbCurIdx)->u.pfcb;
		
		Assert( FFUCBIndex( *ppfucbCurIdx ) );
		Assert( FFUCBSecondary( *ppfucbCurIdx ) );
		Assert( pfcbSecondaryIdx != pfcbNil );
		Assert( pfcbSecondaryIdx->FTypeSecondaryIndex() );
		Assert( pfcbSecondaryIdx->Pidb() != pidbNil );
		Assert( pfcbSecondaryIdx->Pidb()->ItagIndexName() != 0 );
		Assert( pfcbSecondaryIdx->Pidb()->CrefCurrentIndex() > 0
			|| pfcbSecondaryIdx->Pidb()->FTemplateIndex() );

		if ( NULL != pindexid )
			{
			//	already verified above that we're not
			//	switching to the current index
			Assert( !fInDMLLatch );
			Assert( pfcbSecondaryIdx != pindexid->pfcbIndex );
			}

		else if ( pfcbSecondaryIdx->FDerivedIndex() )
			{
			Assert( !fInDMLLatch );
			Assert( pfcbSecondaryIdx->Pidb()->FTemplateIndex() );
			Assert( pfcbTable->Ptdb() != ptdbNil );
			Assert( pfcbTable->Ptdb()->PfcbTemplateTable() != pfcbNil );
			Assert( pfcbTable->Ptdb()->PfcbTemplateTable()->Ptdb() != ptdbNil );
			const TDB * const	ptdb		= pfcbTable->Ptdb()->PfcbTemplateTable()->Ptdb();
			const IDB * const	pidb		= pfcbSecondaryIdx->Pidb();
			const CHAR * const	szCurrIdx	= ptdb->SzIndexName( pidb->ItagIndexName() );
			if ( 0 == UtilCmpName( szIndex, szCurrIdx ) )
				{
				//	changing to the current secondary index, so do nothing.
				return JET_errSuccess;
				}
			}
		else
			{
			// See if the desired index is the current one
			if ( !fInDMLLatch )
				pfcbTable->EnterDML();

			const TDB * const	ptdb		= pfcbTable->Ptdb();
			const FCB * const	pfcbIndex	= (*ppfucbCurIdx)->u.pfcb;
			const IDB * const	pidb		= pfcbIndex->Pidb();
			const CHAR * const	szCurrIdx	= ptdb->SzIndexName(
														pidb->ItagIndexName(),
														pfcbIndex->FDerivedIndex() );
			const INT			cmp			= UtilCmpName( szIndex, szCurrIdx );

			pfcbTable->LeaveDML();
			fInDMLLatch = fFalse;

			if ( 0 == cmp )
				{
				//	changing to the current secondary index, so do nothing.
				return JET_errSuccess;
				}
			}


		Assert( !fInDMLLatch );

		//	really changing index, so close old one
		//
		if ( FFUCBVersioned( *ppfucbCurIdx ) )
			{
			//	if versioned, must defer-close cursor
			DIRClose( *ppfucbCurIdx );
			}
		else
			{
			pfucbOldIndex = *ppfucbCurIdx;
			Assert( !PinstFromPfucb( pfucbOldIndex )->FRecovering() );
			Assert( !Pcsr( pfucbOldIndex )->FLatched() );
			Assert( !FFUCBDeferClosed( pfucbOldIndex ) );
			Assert( !FFUCBVersioned( pfucbOldIndex ) );
			Assert( !FFUCBDenyRead( pfucbOldIndex ) );
			Assert( !FFUCBDenyWrite( pfucbOldIndex ) );
			Assert( JET_LSNil == pfucbOldIndex->ls );
			Assert( pfcbNil != pfucbOldIndex->u.pfcb );
			Assert( pfucbOldIndex->u.pfcb->FTypeSecondaryIndex() );
			FILEReleaseCurrentSecondary( pfucbOldIndex );
			FCBUnlinkWithoutMoveToAvailList( pfucbOldIndex );
			KSReset( pfucbOldIndex );
			pfucbOldIndex->bmCurr.Nullify();
			}

		*ppfucbCurIdx = pfucbNil;
		fClosedPreviousIndex = fTrue;
		}

	//	set new current secondary index
	//
	Assert( pfucbNil == *ppfucbCurIdx );
	Assert( !fInDMLLatch );

	if ( NULL != pindexid )
		{
		//	IDB was already pinned above
		pfcbSecondary = pindexid->pfcbIndex;
		Assert( pfcbNil != pfcbSecondary );
		Assert( pfcbSecondary->Pidb()->CrefCurrentIndex() > 0
			|| pfcbSecondary->Pidb()->FTemplateIndex() );
		}
	else
		{
		//	verify visibility on desired index and pin it
		pfcbTable->EnterDML();
	
		for ( pfcbSecondary = pfcbTable->PfcbNextIndex();
			pfcbSecondary != pfcbNil;
			pfcbSecondary = pfcbSecondary->PfcbNextIndex() )
			{
			Assert( pfcbSecondary->Pidb() != pidbNil );
			Assert( pfcbSecondary->Pidb()->ItagIndexName() != 0 );

			err = ErrFILEIAccessIndexByName( pfucb->ppib, pfcbTable, pfcbSecondary, szIndex );
			if ( err < 0 )
				{
				if ( JET_errIndexNotFound != err )
					{
					pfcbTable->LeaveDML();
					goto HandleError;
					}
				}
			else
				{
				// Found the index we want.
				break;
				}
			}

		if ( pfcbNil == pfcbSecondary )
			{
			pfcbTable->LeaveDML();
			Call( ErrERRCheck( JET_errIndexNotFound ) );
			}

		else if ( pfcbSecondary->Pidb()->FTemplateIndex() )
			{
			// Don't need refcount on template indexes, since we
			// know they'll never go away.
			Assert( pfcbSecondary->Pidb()->CrefCurrentIndex() == 0 );
			}
		else
			{
			pfcbSecondary->Pidb()->IncrementCurrentIndex();
			fIncrementedRefCount = fTrue;
			}

		pfcbTable->LeaveDML();
		}

	Assert( !pfcbSecondary->FDomainDenyRead( pfucb->ppib ) );
	Assert( pfcbSecondary->FTypeSecondaryIndex() );

	Assert( ( fIncrementedRefCount
			&& pfcbSecondary->Pidb()->CrefCurrentIndex() > 0 )
		|| ( !fIncrementedRefCount
			&& pfcbSecondary->Pidb()->FTemplateIndex()
			&& pfcbSecondary->Pidb()->CrefCurrentIndex() == 0 ) );

	//	open an FUCB for the new index
	//
	Assert( pfucbNil == *ppfucbCurIdx );
	Assert( pfucb->ppib != ppibNil );
	Assert( pfucb->ifmp == pfcbSecondary->Ifmp() );
	Assert( !fInDMLLatch );

	if ( pfucbNil != pfucbOldIndex )
		{
		const BOOL	fUpdatable	= FFUCBUpdatable( pfucbOldIndex );

		FUCBResetFlags( pfucbOldIndex );
		FUCBResetPreread( pfucbOldIndex );

		if ( fUpdatable )
			{
			FUCBSetUpdatable( pfucbOldIndex );
			}

		//	initialize CSR in fucb
		//	this allocates page structure
		//
		new( Pcsr( pfucbOldIndex ) ) CSR;

		pfcbSecondary->Link( pfucbOldIndex );

		pfucbOldIndex->levelOpen = pfucbOldIndex->ppib->level;
		DIRInitOpenedCursor( pfucbOldIndex, pfucbOldIndex->ppib->level );

		*ppfucbCurIdx = pfucbOldIndex;
		pfucbOldIndex = pfucbNil;

		err = JET_errSuccess;
		}
	else
		{
		err = ErrDIROpen( pfucb->ppib, pfcbSecondary, ppfucbCurIdx );
		if ( err < 0 )
			{
			if ( fIncrementedRefCount )
				pfcbSecondary->Pidb()->DecrementCurrentIndex();
			goto HandleError;
			}
		}

	Assert( !fInDMLLatch );
	Assert( pfucbNil != *ppfucbCurIdx );
	FUCBSetIndex( *ppfucbCurIdx );
	FUCBSetSecondary( *ppfucbCurIdx );
	FUCBSetCurrentSecondary( *ppfucbCurIdx );
	(*ppfucbCurIdx)->pfucbTable = pfucb;

	//  move the sequential flag to this index
	//  we don't want the sequential flag set on the primary index any more
	//  because we don't want to preread while seeking on the bookmarks from
	//  the secondary index
	if( FFUCBSequential( pfucb ) )
		{
		FUCBResetSequential( pfucb );
		FUCBResetPreread( pfucb );
		FUCBSetSequential( *ppfucbCurIdx );
		}

	//	reset the index and file currency
	//
ResetCurrency:
	Assert( !fInDMLLatch );
	DIRBeforeFirst( *ppfucbCurIdx );
	if ( pfucb != *ppfucbCurIdx )
		{
		DIRBeforeFirst( pfucb );
		}

	AssertDIRNoLatch( pfucb->ppib );
	return JET_errSuccess;

HandleError:
	Assert( err < JET_errSuccess );
	Assert( !fInDMLLatch );

	if ( pfucbNil != pfucbOldIndex )
		{
		RECReleaseKeySearchBuffer( pfucbOldIndex );
		BTReleaseBM( pfucbOldIndex );
		FUCBClose( pfucbOldIndex );
		}

	Assert( pfucbNil == pfucb->pfucbCurIndex );
	if ( fClosedPreviousIndex )
		{
		DIRBeforeFirst( pfucb );
		}

	return err;
	}


LOCAL ERR ErrRECIIllegalNulls(
	FUCB			* pfucb,
	FCB				* pfcb,
	const DATA&		dataRec,
	BOOL			*pfIllegalNulls )
	{
	ERR				err					= JET_errSuccess;

	Assert( pfcbNil != pfcb );
	const TDB		* const ptdb		= pfcb->Ptdb();
	const BOOL		fTemplateTable		= ptdb->FTemplateTable();
	COLUMNID		columnid;

	Assert( pfIllegalNulls );
	Assert( !( *pfIllegalNulls ) );

	//	check fixed fields
	if ( ptdb->FidFixedLast() >= ptdb->FidFixedFirst() )
		{
		const COLUMNID	columnidFixedLast	= ColumnidOfFid( ptdb->FidFixedLast(), fTemplateTable );
		for ( columnid = ColumnidOfFid( ptdb->FidFixedFirst(), fTemplateTable );
			columnid <= columnidFixedLast;
			columnid++ )
			{
			FIELD	field;

			//	template columns are guaranteed to exist
			if ( fTemplateTable )
				{
				Assert( JET_coltypNil != ptdb->PfieldFixed( columnid )->coltyp );
				field.ffield = ptdb->PfieldFixed( columnid )->ffield;
				}
			else
				{
				Assert( !FCOLUMNIDTemplateColumn( columnid ) );
				err = ErrRECIAccessColumn( pfucb, columnid, &field );
				if ( err < 0 )
					{
					if ( JET_errColumnNotFound == err  )
						continue;
					else
						return err;
					}

				Assert( JET_coltypNil != field.coltyp );
				}

			if ( FFIELDNotNull( field.ffield ) )
				{
				const ERR	errCheckNull	= ErrRECIFixedColumnInRecord( columnid, pfcb, dataRec );
				BOOL		fNull;

				if ( JET_errColumnNotFound == errCheckNull )
					{
					// Column not in record -- it's null if there's no default value.
					fNull = !FFIELDDefault( field.ffield );
					}
				else
					{
					CallSx( errCheckNull, JET_wrnColumnNull );
					fNull = ( JET_wrnColumnNull == errCheckNull );
					}

				if ( fNull )
					{
					*pfIllegalNulls = fTrue;
					return JET_errSuccess;
					}
				}
			}
		}

	//	check var fields
	if ( ptdb->FidVarLast() >= ptdb->FidVarFirst() )
		{
		const COLUMNID	columnidVarLast		= ColumnidOfFid( ptdb->FidVarLast(), fTemplateTable );
		for ( columnid = ColumnidOfFid( ptdb->FidVarFirst(), fTemplateTable );
			columnid <= columnidVarLast;
			columnid++ )
			{
			//	template columns are guaranteed to exist
			if ( !fTemplateTable )
				{
				Assert( !FCOLUMNIDTemplateColumn( columnid ) );
				err = ErrRECIAccessColumn( pfucb, columnid );
				if ( err < 0 )
					{
					if ( JET_errColumnNotFound == err  )
						continue;
					else
						return err;
					}
				}

			if ( columnid > ptdb->FidVarLastInitial() )
				pfcb->EnterDML();

			Assert( JET_coltypNil != ptdb->PfieldVar( columnid )->coltyp );
			const FIELDFLAG		ffield	= ptdb->PfieldVar( columnid )->ffield;

			if ( columnid > ptdb->FidVarLastInitial() )
				pfcb->LeaveDML();

			if ( FFIELDNotNull( ffield ) )
				{
				const ERR	errCheckNull	= ErrRECIVarColumnInRecord( columnid, pfcb, dataRec );
				BOOL		fNull;

				if ( JET_errColumnNotFound == errCheckNull )
					{
					// Column not in record -- it's null if there's no default value.
					fNull = !FFIELDDefault( ffield );
					}
				else
					{
					CallSx( errCheckNull, JET_wrnColumnNull );
					fNull = ( JET_wrnColumnNull == errCheckNull );
					}
					
				if ( fNull )
					{
					*pfIllegalNulls = fTrue;
					return JET_errSuccess;
					}
				}
			}
		}

	*pfIllegalNulls = fFalse;

	CallSx( err, JET_errColumnNotFound );
	return JET_errSuccess;
	}


ERR ErrRECIIllegalNulls(
	FUCB		*pfucb,
	const DATA&	dataRec,
	BOOL		*pfIllegalNulls )
	{
	ERR			err;
	FCB			* pfcb = pfucb->u.pfcb;

	Assert( pfIllegalNulls );
	*pfIllegalNulls = fFalse;

	if ( pfcbNil != pfcb->Ptdb()->PfcbTemplateTable() )
		{
		pfcb->Ptdb()->AssertValidDerivedTable();
		CallR( ErrRECIIllegalNulls(
				pfucb,
				pfcb->Ptdb()->PfcbTemplateTable(),
				dataRec,
				pfIllegalNulls ) );
		}

	if ( !( *pfIllegalNulls ) )
		{
		CallR( ErrRECIIllegalNulls(
			pfucb,
			pfcb,
			dataRec,
			pfIllegalNulls ) );
		}

	return JET_errSuccess;
	}
	
ERR VTAPI ErrIsamGetCurrentIndex( JET_SESID sesid, JET_VTID vtid, CHAR *szCurIdx, ULONG cbMax )
	{
 	PIB		*ppib	= reinterpret_cast<PIB *>( sesid );
	FUCB	*pfucb = reinterpret_cast<FUCB *>( vtid );
	FCB		*pfcbTable;

	ERR		err = JET_errSuccess;
	CHAR	szIndex[JET_cbNameMost+1];

	CallR( ErrPIBCheck( ppib ) );
	AssertDIRNoLatch( ppib );
	CheckTable( ppib, pfucb );
	CheckSecondary( pfucb );

	if ( cbMax < 1 )
		{
		return JET_wrnBufferTruncated;
		}

	pfcbTable = pfucb->u.pfcb;
	Assert( pfcbNil != pfcbTable );
	Assert( ptdbNil != pfcbTable->Ptdb() );

	if ( pfucb->pfucbCurIndex != pfucbNil )
		{
		Assert( pfucb->pfucbCurIndex->u.pfcb != pfcbNil );
		Assert( pfucb->pfucbCurIndex->u.pfcb->FTypeSecondaryIndex() );
		Assert( !pfucb->pfucbCurIndex->u.pfcb->FDeletePending() );
		Assert( !pfucb->pfucbCurIndex->u.pfcb->FDeleteCommitted() );
		Assert( pfucb->pfucbCurIndex->u.pfcb->Pidb() != pidbNil );
		Assert( pfucb->pfucbCurIndex->u.pfcb->Pidb()->ItagIndexName() != 0 );
		
		const FCB	* const pfcbIndex = pfucb->pfucbCurIndex->u.pfcb;
		if ( pfcbIndex->FDerivedIndex() )
			{
			Assert( pfcbIndex->Pidb()->FTemplateIndex() );
			const FCB	* const pfcbTemplateTable = pfcbTable->Ptdb()->PfcbTemplateTable();
			Assert( pfcbNil != pfcbTemplateTable );
			strcpy(
				szIndex,
				pfcbTemplateTable->Ptdb()->SzIndexName( pfcbIndex->Pidb()->ItagIndexName() ) );
			}
		else
			{
			pfcbTable->EnterDML();
			strcpy(
				szIndex,
				pfcbTable->Ptdb()->SzIndexName(	pfcbIndex->Pidb()->ItagIndexName() ) );
			pfcbTable->LeaveDML();
			}
		}
	else
		{
		BOOL	fPrimaryIndexTemplate = fFalse;

		if ( pfcbTable->FDerivedTable() )
			{
			Assert( pfcbTable->Ptdb() != ptdbNil );
			Assert( pfcbTable->Ptdb()->PfcbTemplateTable() != pfcbNil );
			const FCB	* const pfcbTemplateTable = pfcbTable->Ptdb()->PfcbTemplateTable();
			if ( !pfcbTemplateTable->FSequentialIndex() )
				{
				// If template table has a primary index, we must have inherited it.
				fPrimaryIndexTemplate = fTrue;
				Assert( pfcbTemplateTable->Pidb() != pidbNil );
				Assert( pfcbTemplateTable->Pidb()->FTemplateIndex() );
				Assert( pfcbTable->Pidb() == pfcbTemplateTable->Pidb() );
				Assert( pfcbTemplateTable->Pidb()->ItagIndexName() != 0 );
				strcpy(
					szIndex,
					pfcbTemplateTable->Ptdb()->SzIndexName( pfcbTable->Pidb()->ItagIndexName() ) );
				}
			else
				{
				Assert( pfcbTemplateTable->Pidb() == pidbNil );
				}
			}

		if ( !fPrimaryIndexTemplate )
			{
			pfcbTable->EnterDML();
			if ( pfcbTable->Pidb() != pidbNil )
				{
				ERR	errT = ErrFILEIAccessIndex( ppib, pfcbTable, pfcbTable );
				if ( errT < 0 )
					{
					if ( JET_errIndexNotFound != errT )
						{
						pfcbTable->LeaveDML();
						return errT;
						}
					szIndex[0] = '\0';	// Primary index not visible - return sequential index
					}
				else
					{
					Assert( pfcbTable->Pidb()->ItagIndexName() != 0 );
					strcpy(
						szIndex,
						pfcbTable->Ptdb()->SzIndexName( pfcbTable->Pidb()->ItagIndexName() ) );
					}
				}
			else
				{
				szIndex[0] = '\0';
				}
			pfcbTable->LeaveDML();
			}
		}


	if ( cbMax > JET_cbNameMost + 1 )
		cbMax = JET_cbNameMost + 1;
	strncpy( szCurIdx, szIndex, (USHORT)cbMax - 1 );
	szCurIdx[ cbMax - 1 ] = '\0';
	CallS( err );
	AssertDIRNoLatch( ppib );
	return err;
	}


ERR VTAPI ErrIsamGetChecksum( JET_SESID sesid, JET_VTID vtid, ULONG *pulChecksum )
	{
 	PIB *ppib	= reinterpret_cast<PIB *>( sesid );
	FUCB *pfucb = reinterpret_cast<FUCB *>( vtid );

	ERR   	err = JET_errSuccess;

	CallR( ErrPIBCheck( ppib ) );
	AssertDIRNoLatch( ppib );
 	CheckFUCB( ppib, pfucb );
	Call( ErrDIRGet( pfucb ) );
	*pulChecksum = UlChecksum( pfucb->kdfCurr.data.Pv(), pfucb->kdfCurr.data.Cb() );

	CallS( ErrDIRRelease( pfucb ) );

HandleError:
	AssertDIRNoLatch( ppib );
	return err;
	}


ULONG UlChecksum( VOID *pv, ULONG cb )
	{
	//	UNDONE:	find a way to compute check sum in longs independant
	//				of pb, byte offset in page

	/*	compute checksum by adding bytes in data record and shifting
	/*	result 1 bit to left after each operation.
	/**/
	BYTE   	*pbT = (BYTE *) pv;
	BYTE  	*pbMax = pbT + cb;
	ULONG  	ulChecksum = 0;

	/*	compute checksum
	/**/
	for ( ; pbT < pbMax; pbT++ )
		{
		ulChecksum += *pbT;
		ulChecksum <<= 1;
		}

	return ulChecksum;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\pib.cxx ===
#include "std.hxx"


PM_CEF_PROC LPIBInUseCEFLPv;
PERFInstanceG<> cPIBInUse;
long LPIBInUseCEFLPv( long iInstance, void* pvBuf )
	{
	cPIBInUse.PassTo( iInstance, pvBuf );
	return 0;
	}

PM_CEF_PROC LPIBTotalCEFLPv;
PERFInstanceG<> cPIBTotal;
long LPIBTotalCEFLPv( long iInstance, void* pvBuf )
	{
	cPIBTotal.PassTo( iInstance, pvBuf );
	return 0;
	}


#ifndef RTM
//  ================================================================
template< class T >
VOID CSIMPLELIST<T>::UnitTest()
//  ================================================================
	{
	ERR err;
	CSIMPLELIST<T> simplelist;

	AssertRTL( simplelist.FEmpty() );
	simplelist.MakeEmpty();
	AssertRTL( simplelist.FEmpty() );
	simplelist.MakeEmpty();
	AssertRTL( simplelist.FEmpty() );

	Call( simplelist.ErrInsert( 1 ) );
	AssertRTL( !simplelist.FEmpty() );
	Call( simplelist.ErrInsert( 2 ) );
	AssertRTL( !simplelist.FEmpty() );
	Call( simplelist.ErrInsert( 3 ) );
	AssertRTL( !simplelist.FEmpty() );
	Call( simplelist.ErrInsert( 4 ) );
	AssertRTL( !simplelist.FEmpty() );
	Call( simplelist.ErrInsert( 5 ) );
	AssertRTL( !simplelist.FEmpty() );
	Call( simplelist.ErrInsert( 6 ) );
	AssertRTL( !simplelist.FEmpty() );
	Call( simplelist.ErrInsert( 7 ) );
	AssertRTL( !simplelist.FEmpty() );
	Call( simplelist.ErrInsert( 8 ) );
	AssertRTL( !simplelist.FEmpty() );
	Call( simplelist.ErrInsert( 1 ) );
	AssertRTL( !simplelist.FEmpty() );

	CallS( simplelist.ErrDelete( 911 ) );
	AssertRTL( !simplelist.FEmpty() );
	CallS( simplelist.ErrDelete( 0 ) );
	AssertRTL( !simplelist.FEmpty() );
	CallS( simplelist.ErrDelete( 0xffffffff ) );
	AssertRTL( !simplelist.FEmpty() );
	CallS( simplelist.ErrDelete( 10 ) );
	AssertRTL( !simplelist.FEmpty() );
	CallS( simplelist.ErrDelete( 11 ) );
	AssertRTL( !simplelist.FEmpty() );
	CallS( simplelist.ErrDelete( 11 ) );
	AssertRTL( !simplelist.FEmpty() );
	CallS( simplelist.ErrDelete( 11 ) );
	AssertRTL( !simplelist.FEmpty() );
	CallS( simplelist.ErrDelete( 11 ) );
	AssertRTL( !simplelist.FEmpty() );
	CallS( simplelist.ErrDelete( 0 ) );
	AssertRTL( !simplelist.FEmpty() );
	CallS( simplelist.ErrDelete( 0xffffffff ) );
	AssertRTL( !simplelist.FEmpty() );
	CallS( simplelist.ErrDelete( 1 ) );
	AssertRTL( !simplelist.FEmpty() );
	CallS( simplelist.ErrDelete( 6 ) );
	AssertRTL( !simplelist.FEmpty() );
	CallS( simplelist.ErrDelete( 7 ) );
	AssertRTL( !simplelist.FEmpty() );
	CallS( simplelist.ErrDelete( 8 ) );
	AssertRTL( !simplelist.FEmpty() );
	CallS( simplelist.ErrDelete( 2 ) );
	AssertRTL( !simplelist.FEmpty() );
	CallS( simplelist.ErrDelete( 3 ) );
	AssertRTL( !simplelist.FEmpty() );
	CallS( simplelist.ErrDelete( 4 ) );
	AssertRTL( !simplelist.FEmpty() );
	CallS( simplelist.ErrDelete( 5 ) );
	AssertRTL( !simplelist.FEmpty() );
	CallS( simplelist.ErrDelete( 1 ) );
	AssertRTL( simplelist.FEmpty() );

	Call( simplelist.ErrInsert( 6 ) );
	AssertRTL( !simplelist.FEmpty() );
	Call( simplelist.ErrInsert( 7 ) );
	AssertRTL( !simplelist.FEmpty() );
	Call( simplelist.ErrInsert( 8 ) );
	AssertRTL( !simplelist.FEmpty() );
	Call( simplelist.ErrInsert( 1 ) );
	AssertRTL( !simplelist.FEmpty() );

	simplelist.MakeEmpty();
	AssertRTL( simplelist.FEmpty() );

	Call( simplelist.ErrInsert( 1 ) );
	AssertRTL( !simplelist.FEmpty() );
	Call( simplelist.ErrInsert( 2 ) );
	AssertRTL( !simplelist.FEmpty() );
	Call( simplelist.ErrInsert( 3 ) );
	AssertRTL( !simplelist.FEmpty() );
	Call( simplelist.ErrInsert( 4 ) );
	AssertRTL( !simplelist.FEmpty() );
	Call( simplelist.ErrInsert( 5 ) );
	AssertRTL( !simplelist.FEmpty() );
	Call( simplelist.ErrInsert( 6 ) );
	AssertRTL( !simplelist.FEmpty() );
	Call( simplelist.ErrInsert( 7 ) );
	AssertRTL( !simplelist.FEmpty() );
	Call( simplelist.ErrInsert( 8 ) );
	AssertRTL( !simplelist.FEmpty() );
	Call( simplelist.ErrInsert( 1 ) );
	AssertRTL( !simplelist.FEmpty() );

	T t;

	CallS( simplelist.ErrPop( &t ) );
	AssertRTL( !simplelist.FEmpty() );
	AssertRTL( 1 == t );
	CallS( simplelist.ErrPop( &t ) );
	AssertRTL( !simplelist.FEmpty() );
	AssertRTL( 8 == t );
	CallS( simplelist.ErrPop( &t ) );
	AssertRTL( !simplelist.FEmpty() );
	AssertRTL( 7 == t );
	CallS( simplelist.ErrPop( &t ) );
	AssertRTL( !simplelist.FEmpty() );
	AssertRTL( 6 == t );
	CallS( simplelist.ErrPop( &t ) );
	AssertRTL( !simplelist.FEmpty() );
	AssertRTL( 5 == t );
	CallS( simplelist.ErrPop( &t ) );
	AssertRTL( !simplelist.FEmpty() );
	AssertRTL( 4 == t );
	CallS( simplelist.ErrPop( &t ) );
	AssertRTL( !simplelist.FEmpty() );
	AssertRTL( 3 == t );
	CallS( simplelist.ErrPop( &t ) );
	AssertRTL( !simplelist.FEmpty() );
	AssertRTL( 2 == t );
	CallS( simplelist.ErrPop( &t ) );
	AssertRTL( simplelist.FEmpty() );
	AssertRTL( 1 == t );

HandleError:
	switch( err )
		{
		case JET_errSuccess:
		case JET_errOutOfMemory:
			break;
		default:
			CallS( err );
		}
	simplelist.MakeEmpty();
	}
#endif	//	!RTM


#ifdef DEBUG
//  ================================================================
template< class T >
VOID CSIMPLELIST<T>::AssertValid() const
//  ================================================================
	{
	Assert( m_itMac >= 0 );
	Assert( m_itMax >= 0 );

	if( m_pt )
		{
		Assert( m_itMac <= m_itMax );
		}
	else
		{
		Assert( 0 == m_itMac );
		Assert( 0 == m_itMax );
		}
	}
#endif	//	DEBUG


//  ================================================================
INLINE VOID PIB::ReleaseAllCachedCursors()
//  ================================================================
	{
	while ( pfucbNil != m_pfucbCache )
		{
		FUCB * const	pfucbToRelease		= m_pfucbCache;
		m_pfucbCache = pfucbToRelease->pfucbCacheNext;
		MEMReleasePfucb( m_pinst, pfucbToRelease );

		Assert( m_cfucbCache > 0 );
		m_cfucbCache--;
		}
	Assert( 0 == m_cfucbCache );
	}

//  ================================================================
ERR PIB::ErrRegisterDeferredRceid( const RCEID& rceid )
//  ================================================================
	{
	Assert( rceidNull != rceid );
	return m_simplelistRceidDeferred.ErrInsert( rceid );
	}


//  ================================================================
ERR	PIB::ErrDeregisterDeferredRceid( const RCEID& rceid )
//  ================================================================
	{
	Assert( rceidNull != rceid );
	return m_simplelistRceidDeferred.ErrDelete( rceid );
	}


//  ================================================================
VOID PIB::RemoveAllDeferredRceid()
//  ================================================================
	{
	m_simplelistRceidDeferred.MakeEmpty();
	}


//  ================================================================
VOID PIB::AssertNoDeferredRceid() const
//  ================================================================
	{
	AssertRTL( m_simplelistRceidDeferred.FEmpty() );
	}


//  ================================================================
TRX TrxOldest( INST *pinst )
//  ================================================================
	{
	TRX		trxOldest	= trxMax;
	size_t	iProc;

	for ( iProc = 0; iProc < OSSyncGetProcessorCountMax(); iProc++ )
		{
		INST::PLS* const ppls = pinst->Ppls( iProc );
		ppls->m_critPIBTrxOldest.Enter();
		}
	for ( iProc = 0; iProc < OSSyncGetProcessorCountMax(); iProc++ )
		{
		INST::PLS* const ppls = pinst->Ppls( iProc );
		PIB* const ppibTrxOldest = ppls->m_ilTrxOldest.PrevMost();
		if ( ppibTrxOldest && TrxCmp( ppibTrxOldest->trxBegin0, trxOldest ) < 0 )
			{
			trxOldest = ppibTrxOldest->trxBegin0;
			}
		}
	for ( iProc = 0; iProc < OSSyncGetProcessorCountMax(); iProc++ )
		{
		INST::PLS* const ppls = pinst->Ppls( iProc );
		ppls->m_critPIBTrxOldest.Leave();
		}

	Assert( !pinst->m_plog->m_fRecovering || trxMax == trxOldest );
	return trxOldest;
	}

//	================================================================
VOID PIBSetTrxBegin0ToTrxOldest( PIB * const ppib )
//	================================================================
	{
	INST *pinst = PinstFromPpib( ppib );
	for ( size_t iProc = 0; iProc < OSSyncGetProcessorCountMax(); iProc++ )
		{
		INST::PLS* const ppls = pinst->Ppls( iProc );
		ppls->m_critPIBTrxOldest.Enter();
		}
	for ( iProc = 0; iProc < OSSyncGetProcessorCountMax(); iProc++ )
		{
		INST::PLS* const ppls = pinst->Ppls( iProc );
		PIB* const ppibTrxOldest = ppls->m_ilTrxOldest.PrevMost();
		if ( ppibTrxOldest && TrxCmp( ppibTrxOldest->trxBegin0, ppib->trxBegin0 ) < 0 )
			{
			ppib->m_pplsTrxOldest->m_ilTrxOldest.Remove( ppib );
			ppib->trxBegin0 = ppibTrxOldest->trxBegin0;
			ppls->m_ilTrxOldest.InsertAsPrevMost( ppib );
			ppib->m_pplsTrxOldest = ppls;
			}
		}
	for ( iProc = 0; iProc < OSSyncGetProcessorCountMax(); iProc++ )
		{
		INST::PLS* const ppls = pinst->Ppls( iProc );
		ppls->m_critPIBTrxOldest.Leave();
		}
	}


#define PpibMEMAlloc( pinst ) reinterpret_cast<PIB*>( pinst->m_pcresPIBPool->PbAlloc( __FILE__, __LINE__ ) )


ERR PIB::ErrAbortAllMacros( BOOL fLogEndMacro )
	{
	ASSERT_VALID( this );

	ERR		err;
	MACRO	*pMacro, *pMacroNext;
	for ( pMacro = m_pMacroNext; pMacro != NULL; pMacro = pMacroNext )
		{
		pMacroNext = pMacro->PMacroNext();
		if ( pMacro->Dbtime() != dbtimeNil )
			{
			//	Record LGMacroAbort.
			//
			LGPOS	lgpos;
			DBTIME	dbtime = pMacro->Dbtime();

			if ( fLogEndMacro )
				{
				CallR( ErrLGMacroAbort( this, dbtime, &lgpos ) );
				}

			//	release recorded log
			//
			this->ResetMacroGoing( dbtime );
			}
		}

	//	release last macro
	//
	if ( m_pMacroNext != NULL )
		{
		Assert( m_pMacroNext->PMacroNext() == NULL );
		Assert( dbtimeNil == m_pMacroNext->Dbtime() );
		OSMemoryHeapFree( m_pMacroNext );
		m_pMacroNext = NULL;
		}

	return JET_errSuccess;
	}


INLINE VOID MEMReleasePpib( PIB *& ppib )
	{
	INST *pinst = PinstFromPpib( ppib );
	pinst->m_pcresPIBPool->Release( (BYTE *)ppib );
#ifdef DEBUG
	ppib = 0;
#endif
	}

ERR	ErrPIBInit( INST *pinst, int cpibMax )
	{
	ERR 	err 	= JET_errSuccess;

#ifndef RTM
	CSIMPLELIST<RCEID>::UnitTest();
#endif	//	RTM

	Assert( IbAlignForAllPlatforms( sizeof(PIB) ) == sizeof(PIB) );
#ifdef PCACHE_OPTIMIZATION
	Assert( sizeof(PIB) % 32 == 0 );
#endif

	pinst->m_pcresPIBPool = new CRES( pinst, residPIB, sizeof( PIB ), cpibMax, &err );
	if ( err < JET_errSuccess )
		{
		delete pinst->m_pcresPIBPool;
		pinst->m_pcresPIBPool = NULL;
		}
	else if ( NULL == pinst->m_pcresPIBPool )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		}
	CallR( err );

	Assert(NULL != pinst->m_pcresPIBPool);
	pinst->m_ppibGlobalMin = (PIB *) pinst->m_pcresPIBPool->PbMin();
	pinst->m_ppibGlobalMax = (PIB *) pinst->m_pcresPIBPool->PbMax();
	pinst->m_ppibGlobal = ppibNil;

	cPIBInUse.Clear( pinst );
	cPIBTotal.Set( pinst, cpibMax );

	return JET_errSuccess;
	}

VOID PIBTerm( INST *pinst )
	{
	PIB     *ppib;

	pinst->m_critPIB.Enter();

	cPIBTotal.Clear( pinst );
	cPIBInUse.Clear( pinst );

	for ( ppib = pinst->m_ppibGlobal; ppib != ppibNil; ppib = pinst->m_ppibGlobal )
		{
		PIB             *ppibCur;
		PIB             *ppibPrev;

		Assert( !ppib->FLGWaiting() );

		ppibPrev = (PIB *)((BYTE *)&pinst->m_ppibGlobal - OffsetOf(PIB, ppibNext));
		while( ( ppibCur = ppibPrev->ppibNext ) != ppib && ppibCur != ppibNil )
			{
			ppibPrev = ppibCur;
			}

		if ( ppibCur != ppibNil )
			{
			ppibPrev->ppibNext = ppibCur->ppibNext;
			Assert( ppibPrev != ppibPrev->ppibNext );
			}

		//	internal sessions may not access the temp. database
		if( FPIBUserOpenedDatabase( ppib, dbidTemp ) )
			{
			DBResetOpenDatabaseFlag( ppib, pinst->m_mpdbidifmp[ dbidTemp ] );
			}

		ppib->FreePvRecordFormatConversionBuffer();

		//	close all cursors still open
		//	should only be sort file cursors
		//
		while( pfucbNil != ppib->pfucbOfSession )
			{
			FUCB	*pfucb	= ppib->pfucbOfSession;

			if ( FFUCBSort( pfucb ) )
				{
				Assert( !( FFUCBIndex( pfucb ) ) );
				CallS( ErrIsamSortClose( ppib, pfucb ) );
				}
			else
				{
				AssertSz( fFalse, "PIBTerm: At least one non sort fucb is left open." );
				break;
				}
			}

		ppib->~PIB();
		MEMReleasePpib( ppib );
		}

	pinst->m_ppibGlobal = ppibNil;

	pinst->m_critPIB.Leave();

	//	Release mem resource

	delete pinst->m_pcresPIBPool;

	//	Reset PIB global variables

	pinst->m_ppibGlobalMin = NULL;
	pinst->m_ppibGlobalMax = NULL;
	pinst->m_ppibGlobal = ppibNil;
	}


ERR ErrPIBBeginSession( INST *pinst, PIB **pppib, PROCID procidTarget, BOOL fForCreateTempDatabase )
	{
	ERR		err;
	PIB		*ppib;

	Assert( pinst->FRecovering() || procidTarget == procidNil );

	pinst->m_critPIB.Enter();

	if ( procidTarget != procidNil )
		{
		PIB *ppibTarget;

		/*  allocate inactive PIB according to procidTarget
		/**/
		Assert( pinst->FRecovering() );
		ppibTarget = PpibOfProcid( pinst, procidTarget );
		for ( ppib = pinst->m_ppibGlobal; ppib != ppibTarget && ppib != ppibNil; ppib = ppib->ppibNext );
		if ( ppib != ppibNil )
			{
			/*  we found a reusable one.
			/*	Set level to hold the pib
			/**/
			Assert( ppib->level == levelNil );
			Assert( ppib->procid == ProcidPIBOfPpib( ppib ) );
			Assert( ppib->procid == procidTarget );
			Assert( !FPIBUserOpenedDatabase( ppib, dbidTemp ) );
			ppib->level = 0;
			}
		}
	else
		{
		/*	allocate inactive PIB on anchor list
		/**/
		for ( ppib = pinst->m_ppibGlobal; ppib != ppibNil; ppib = ppib->ppibNext )
			{
			if ( ppib->level == levelNil )
				{
#ifdef DEBUG
				//	at the point where we go to create the temp
				//	database, there shouldn't be any pibs
				//	available for reuse
				Assert( !fForCreateTempDatabase );
				if ( FPIBUserOpenedDatabase( ppib, dbidTemp ) )
					{
					Assert( !pinst->FRecovering() );
					Assert( pinst->m_lTemporaryTablesMax > 0 );
					}
				else
					{
					Assert( pinst->FRecovering()
						|| 0 == pinst->m_lTemporaryTablesMax );
					}
#endif

				/*  we found a reusable one.
				/*	Set level to hold the pib
				/**/
				ppib->level = 0;
				break;
				}
			}
		}

	/*	return success if found PIB
	/**/
	if ( ppib != ppibNil )
		{
		/*  we found a reusable one.
		/*	Do not reset non-common items.
		/**/
		Assert( ppib->level == 0 );

		Assert( !FSomeDatabaseOpen( ppib ) );

		Assert( ppib->pfucbOfSession == pfucbNil );
		Assert( ppib->procid != procidNil );

		/*  set PIB procid from parameter or native for session
		/**/
		Assert( ppib->procid == ProcidPIBOfPpib( ppib ) );
		Assert( ppib->procid != procidNil );
		}
	else
		{
		pinst->m_critPIB.Leave();
NewPib:
		/*  allocate PIB from free list and
		/*	set non-common items.
		/**/
		ppib = PpibMEMAlloc( pinst );
		if ( ppib == NULL )
			{
			err = ErrERRCheck( JET_errOutOfSessions );
			goto HandleError;
			}

		Assert( FAlignedForAllPlatforms( ppib ) );

		ppib->prceNewest = prceNil;
		memset( (BYTE *)ppib, 0, sizeof(PIB) );

		new( ppib ) PIB;
		ppib->m_pinst = pinst;

		/*  general initialization for each new pib.
		/**/
		ppib->procid = ProcidPIBOfPpib( ppib );
		Assert( ppib->procid != procidNil );
		ppib->grbitsCommitDefault = NO_GRBIT;	/* set default commit flags in IsamBeginSession */

		if ( !fForCreateTempDatabase
			&& pinst->m_lTemporaryTablesMax > 0
			&& !pinst->FRecovering() )
			{
			/*  the temporary database is always open when not in recovery mode
			/**/
			DBSetOpenDatabaseFlag( ppib, pinst->m_mpdbidifmp[ dbidTemp ] );
			}

		//	Initialize critical section for accessing the pib's RCE

		/*  link PIB into list
		/**/
		pinst->m_critPIB.Enter();
		ppib->ppibNext = pinst->m_ppibGlobal;
		Assert( ppib != ppib->ppibNext );
		pinst->m_ppibGlobal = ppib;

		if ( procidTarget != procidNil && ppib != PpibOfProcid( pinst, procidTarget ) )
			{
			ppib->level = levelNil;

			/*  set non-zero items used by version store so that version store
			/*  will not mistaken it.
			/**/
			ppib->lgposStart = lgposMax;
			ppib->trxBegin0 = trxMax;

			pinst->m_critPIB.Leave();
			goto NewPib;
			}
		}

	/*  set common PIB initialization items
	/**/

	/*  set non-zero items
	/**/
	ppib->lgposStart = lgposMax;
	ppib->trxBegin0 = trxMax;

	ppib->lgposCommit0 = lgposMax;

	/*  set zero items including flags and monitor fields.
	/**/


	/*  default mark this a system session
	/**/
	ppib->ResetFlags();
	Assert( !ppib->FUserSession() );	//	default marks this as a system session
	Assert( !ppib->FAfterFirstBT() );
	Assert( !ppib->FRecoveringEndAllSessions() );
	Assert( !ppib->FLGWaiting() );
	Assert( !ppib->FBegin0Logged() );
	Assert( !ppib->FSetAttachDB() );
	Assert( !ppib->FSessionOLD() );

	ppib->levelBegin = 0;
	ppib->clevelsDeferBegin = 0;
	ppib->levelRollback = 0;
	ppib->updateid = updateidNil;

	ppib->InitDistributedTrxData();

#ifdef DEBUG
	if ( FPIBUserOpenedDatabase( ppib, dbidTemp ) )
		{
		Assert( !pinst->FRecovering() );
		Assert( pinst->m_lTemporaryTablesMax > 0 );
		Assert( !fForCreateTempDatabase );
		}
	else
		{
		Assert( pinst->FRecovering()
			|| 0 == pinst->m_lTemporaryTablesMax
			|| fForCreateTempDatabase );
		}
#endif

	Assert( dwPIBSessionContextNull == ppib->dwSessionContext
		|| dwPIBSessionContextUnusable == ppib->dwSessionContext );
	ppib->dwSessionContext = dwPIBSessionContextNull;
	ppib->dwSessionContextThreadId = 0;
	ppib->dwTrxContext = 0;
	ppib->m_cInJetAPI = 0;

#ifdef INDEPENDENT_DB_FAILURE
	ppib->m_ifmpForceDetach = ifmpMax;
#endif

	*pppib = ppib;
	err = JET_errSuccess;

	cPIBInUse.Inc( pinst );

	pinst->m_critPIB.Leave();

HandleError:
	return err;
	}


VOID PIBEndSession( PIB *ppib )
	{
	INST *pinst = PinstFromPpib( ppib );

	pinst->m_critPIB.Enter();

	cPIBInUse.Dec( pinst );

	Assert( dwPIBSessionContextNull == ppib->dwSessionContext
		|| dwPIBSessionContextUnusable == ppib->dwSessionContext );
	ppib->dwSessionContext = dwPIBSessionContextUnusable;
	ppib->dwSessionContextThreadId = 0;
	ppib->dwTrxContext = 0;

	/*  all session resources except version buckets should have been
	/*  released to free pools.
	/**/
	Assert( pfucbNil == ppib->pfucbOfSession );

	ppib->ReleaseAllCachedCursors();
	ppib->level = levelNil;
	ppib->lgposStart = lgposMax;
	ppib->ResetFlags();

	ppib->FreeDistributedTrxData();
	ppib->FreePvRecordFormatConversionBuffer();

	pinst->m_critPIB.Leave();
	return;
	}


ERR VTAPI ErrIsamSetCommitDefault( JET_SESID sesid, long grbits )
	{
	((PIB *)sesid)->grbitsCommitDefault = grbits;
	return JET_errSuccess;
	}

ERR VTAPI ErrIsamSetSessionContext( JET_SESID sesid, DWORD_PTR dwContext )
	{
	PIB*	ppib	= (PIB *)sesid;

	//	verify not using reserved values
	if ( dwPIBSessionContextNull == dwContext
		|| dwPIBSessionContextUnusable == dwContext )
		return ErrERRCheck( JET_errInvalidParameter );

	return ErrPIBSetSessionContext( ppib, dwContext );
	}

ERR VTAPI ErrIsamResetSessionContext( JET_SESID sesid )
	{
	PIB*	ppib		= (PIB *)sesid;

	if ( ppib->dwSessionContextThreadId != DwUtilThreadId()
		|| dwPIBSessionContextNull == ppib->dwSessionContext )
		return ErrERRCheck( JET_errSessionContextNotSetByThisThread );

	Assert(	dwPIBSessionContextUnusable != ppib->dwSessionContext );
	PIBResetSessionContext( ppib );

	return JET_errSuccess;
	}

VOID PIBReportSessionSharingViolation( PIB *ppib )
	{
	CHAR szSession[32];
	CHAR szSesContext[32];
	CHAR szSesContextThreadID[32];
	CHAR szThreadID[32];

	_stprintf( szSession, _T( "0x%p" ), ppib );
	if ( ppib->FUseSessionContextForTrxContext() )
		{
		_stprintf( szSesContext, _T( "0x%0*I64X" ), sizeof(DWORD_PTR)*2, QWORD( ppib->dwSessionContext ) );
		_stprintf( szSesContextThreadID, _T( "0x%0*I64X" ), sizeof(DWORD_PTR)*2, QWORD( ppib->dwSessionContextThreadId ) );
		}
	else
		{
		_stprintf( szSesContext, _T( "0x%08X" ), 0 );
		_stprintf( szSesContextThreadID, _T( "0x%0*I64X" ), sizeof(DWORD_PTR)*2, QWORD( ppib->dwTrxContext ) );
		}
	_stprintf( szThreadID, _T( "0x%0*I64X" ), sizeof(DWORD_PTR)*2, QWORD( DwUtilThreadId() ) );

	const CHAR *rgszT[4] = { szSession, szSesContext, szSesContextThreadID, szThreadID };
	UtilReportEvent(
			eventError,
			TRANSACTION_MANAGER_CATEGORY,
			SESSION_SHARING_VIOLATION_ID,
			4,
			rgszT,
			0,
			NULL,
			PinstFromPpib( ppib ) );
	}


extern ULONG cBTSplits;

ERR VTAPI ErrIsamResetCounter( JET_SESID sesid, int CounterType )
	{
	return JET_errFeatureNotAvailable;
	}

extern PM_CEF_PROC LBTSplitsCEFLPv;

ERR VTAPI ErrIsamGetCounter( JET_SESID sesid, int CounterType, long *plValue )
	{
	return JET_errFeatureNotAvailable;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\scrub.cxx ===
#include "std.hxx"

#ifdef MINIMAL_FUNCTIONALITY
#else

extern VOID NDIGetKeydataflags( const CPAGE& cpage, INT iline, KEYDATAFLAGS * pkdf );
LOCAL ERR ErrSCRUBGetObjidsFromCatalog(
		PIB * const ppib,
		const IFMP ifmp,
		OBJIDINFO ** ppobjidinfo,
		LONG * pcobjidinfo );


//  ================================================================
BOOL OBJIDINFO::CmpObjid( const OBJIDINFO& left, const OBJIDINFO& right )
//  ================================================================
	{
	return left.objidFDP < right.objidFDP;
	}


//  ================================================================
ERR ErrDBUTLScrub( JET_SESID sesid, const JET_DBUTIL *pdbutil )
//  ================================================================
	{
	ERR err = JET_errSuccess;
	PIB * const ppib = reinterpret_cast<PIB *>( sesid );
	SCRUBDB * pscrubdb = NULL;

	LOGTIME logtimeScrub;

	Call( ErrIsamAttachDatabase( sesid, pdbutil->szDatabase, pdbutil->szSLV, pdbutil->szSLV, 0, NO_GRBIT ) );

	//	WARNING: must set ifmp to 0 to ensure high-dword is
	//	initialised on 64-bit, because we'll be casting this
	//	to a JET_DBID, which is a dword
	IFMP ifmp;
	ifmp = 0;
	Call( ErrIsamOpenDatabase(
		sesid,
		pdbutil->szDatabase,
		NULL,
		reinterpret_cast<JET_DBID *>( &ifmp ),
		NO_GRBIT
		) );

	PGNO pgnoLast;
	pgnoLast = rgfmp[ifmp].PgnoLast();

	DBTIME dbtimeLastScrubNew;
	dbtimeLastScrubNew = rgfmp[ifmp].DbtimeLast();
	
	pscrubdb = new SCRUBDB( ifmp );
	if( NULL == pscrubdb )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}

	Call( pscrubdb->ErrInit( ppib, CUtilProcessProcessor() ) );

	ULONG cpgBuffers;
	cpgBuffers = (ULONG)max( 512, ( ( OSMemoryAvailable() - ( 16 * 1024 * 1024 ) ) / ( g_cbPage + 128 ) ) );
	if( JET_errSuccess == ErrBFSetCacheSize( cpgBuffers ) )
		{
		(*CPRINTFSTDOUT::PcprintfInstance())( "got %d buffers\r\n", cpgBuffers );
		CallS( ErrBFSetCacheSize( 0 ) );
		}
	else
		{
		(*CPRINTFSTDOUT::PcprintfInstance())( "failed to get %d buffers\r\n", cpgBuffers );
		cpgBuffers = 1024;
		}

	JET_SNPROG snprog;
	memset( &snprog, 0, sizeof( snprog ) );	
	snprog.cunitTotal 	= pgnoLast;
	snprog.cunitDone 	= 0;

	JET_PFNSTATUS pfnStatus;
	pfnStatus = reinterpret_cast<JET_PFNSTATUS>( pdbutil->pfnCallback );
	
	if ( NULL != pfnStatus )
		{
		(VOID)pfnStatus( sesid, JET_snpScrub, JET_sntBegin, NULL );	
		}

	PGNO pgno;
	pgno = 1;

	while( pgnoLast	>= pgno )
		{
		const CPG cpgChunk = 256;
		const CPG cpgPreread = min( cpgChunk, pgnoLast - pgno + 1 );
		BFPrereadPageRange( ifmp, pgno, cpgPreread );

		Call( pscrubdb->ErrScrubPages( pgno, cpgPreread ) );
		pgno += cpgPreread;

		snprog.cunitDone = pscrubdb->Scrubstats().cpgSeen;
		if ( NULL != pfnStatus )
			{
			(VOID)pfnStatus( sesid, JET_snpScrub, JET_sntProgress, &snprog );
			}

		while( ( pscrubdb->Scrubstats().cpgSeen + ( cpgBuffers / 4 ) ) < pgno )
			{
			snprog.cunitDone = pscrubdb->Scrubstats().cpgSeen;
			if ( NULL != pfnStatus )
				{
				(VOID)pfnStatus( sesid, JET_snpScrub, JET_sntProgress, &snprog );
				}
			UtilSleep( cmsecWaitGeneric );
			}
		}

	snprog.cunitDone = pscrubdb->Scrubstats().cpgSeen;
	if ( NULL != pfnStatus )
		{
		(VOID)pfnStatus( sesid, JET_snpScrub, JET_sntProgress, &snprog );
		}

	Call( pscrubdb->ErrTerm() );
	
	if ( NULL != pfnStatus )
		{
		(VOID)pfnStatus( sesid, JET_snpRepair, JET_sntComplete, NULL );
		}

	rgfmp[ifmp].SetDbtimeLastScrub( dbtimeLastScrubNew );
	LGIGetDateTime( &logtimeScrub );	
	rgfmp[ifmp].SetLogtimeScrub( logtimeScrub );
	
	(*CPRINTFSTDOUT::PcprintfInstance())( "%d pages seen\n", pscrubdb->Scrubstats().cpgSeen );
	(*CPRINTFSTDOUT::PcprintfInstance())( "%d blank pages seen\n", pscrubdb->Scrubstats().cpgUnused );
	(*CPRINTFSTDOUT::PcprintfInstance())( "%d unchanged pages seen\n", pscrubdb->Scrubstats().cpgUnchanged );
	(*CPRINTFSTDOUT::PcprintfInstance())( "%d unused pages zeroed\n", pscrubdb->Scrubstats().cpgZeroed );
	(*CPRINTFSTDOUT::PcprintfInstance())( "%d used pages seen\n", pscrubdb->Scrubstats().cpgUsed );
	(*CPRINTFSTDOUT::PcprintfInstance())( "%d pages with unknown objid\n", pscrubdb->Scrubstats().cpgUnknownObjid );
	(*CPRINTFSTDOUT::PcprintfInstance())( "%d nodes seen\n", pscrubdb->Scrubstats().cNodes );
	(*CPRINTFSTDOUT::PcprintfInstance())( "%d flag-deleted nodes zeroed\n", pscrubdb->Scrubstats().cFlagDeletedNodesZeroed );
	(*CPRINTFSTDOUT::PcprintfInstance())( "%d flag-deleted nodes not zeroed\n", pscrubdb->Scrubstats().cFlagDeletedNodesNotZeroed );
	(*CPRINTFSTDOUT::PcprintfInstance())( "%d version bits reset seen\n", pscrubdb->Scrubstats().cVersionBitsReset );
	(*CPRINTFSTDOUT::PcprintfInstance())( "%d orphaned LVs\n", pscrubdb->Scrubstats().cOrphanedLV );

	err = pscrubdb->Scrubstats().err;
	
	delete pscrubdb;
	pscrubdb = NULL;

	Call( err );

	if ( rgfmp[ifmp].FSLVAttached() )
	{
#ifdef DISABLE_SLV
		Call( ErrERRCheck( JET_wrnNyi ) );
#else
		CPG cpgSeen;
		CPG	cpgScrubbed;
		Call( ErrSCRUBScrubStreamingFile( ppib, ifmp, &cpgSeen, &cpgScrubbed, pfnStatus ) );

		(*CPRINTFSTDOUT::PcprintfInstance())( "%d pages seen\n", cpgSeen );
		(*CPRINTFSTDOUT::PcprintfInstance())( "%d pages scrubbed\n", cpgScrubbed );	
#endif
	}
	
HandleError:
	if( NULL != pscrubdb )
		{
		const ERR errT = pscrubdb->ErrTerm();
		if( err >= 0 && errT < 0 )
			{
			err = errT;
			}
		delete pscrubdb;
		}
	return err;
	}


//  ================================================================
SCRUBDB::SCRUBDB( const IFMP ifmp ) :
	m_ifmp( ifmp )
//  ================================================================
	{
	m_constants.dbtimeLastScrub = 0;
	m_constants.pcprintfVerbose = CPRINTFSTDOUT::PcprintfInstance();
	m_constants.pcprintfDebug	= CPRINTFSTDOUT::PcprintfInstance();
	m_constants.objidMax		= 0;
	m_constants.pobjidinfo		= 0;
	m_constants.cobjidinfo		= 0;

	m_stats.err					= JET_errSuccess;
	m_stats.cpgSeen 			= 0;
	m_stats.cpgUnused 			= 0;
	m_stats.cpgUnchanged 		= 0;
	m_stats.cpgZeroed 			= 0;
	m_stats.cpgUsed 			= 0;
	m_stats.cpgUnknownObjid		= 0;
	m_stats.cNodes 				= 0;
	m_stats.cFlagDeletedNodesZeroed 	= 0;
	m_stats.cFlagDeletedNodesNotZeroed 	= 0;	
	m_stats.cOrphanedLV 		= 0;
	m_stats.cVersionBitsReset 	= 0;

	m_context.pconstants 	= &m_constants;
	m_context.pstats		= &m_stats;
	}


//  ================================================================
SCRUBDB::~SCRUBDB()
//  ================================================================
	{
	delete [] m_constants.pobjidinfo;
	}


//  ================================================================
volatile const SCRUBSTATS& SCRUBDB::Scrubstats() const
//  ================================================================
	{
	return m_stats;
	}


//  ================================================================
ERR SCRUBDB::ErrInit( PIB * const ppib, const INT cThreads )
//  ================================================================
	{
	ERR err;
	
	INST * const pinst = PinstFromIfmp( m_ifmp );

#ifdef DEBUG
	INT cLoop = 0;
#endif	//	DEBUG

	Call( m_taskmgr.ErrInit( pinst, cThreads ) );

	CallS( ErrDIRBeginTransaction( ppib, JET_bitTransactionReadOnly ) );
	//  get an objidMax
	//  wait until this is the oldest transaction in the system
	//  at which point all objids < objidMax have been committed to
	//  the catalog. then commit the transaction and read the catalog
	m_constants.objidMax = rgfmp[m_ifmp].ObjidLast();
	while( TrxOldest( pinst ) != ppib->trxBegin0 )
		{
		UtilSleep( cmsecWaitGeneric );
		AssertSz( ++cLoop < 36000, "Waiting a long time for all transactions to commit (Deadlocked?)" );
		}
	CallS( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );
	
	m_constants.dbtimeLastScrub = rgfmp[m_ifmp].DbtimeLastScrub();

	Call( ErrSCRUBGetObjidsFromCatalog(
			ppib,
			m_ifmp,
			&m_constants.pobjidinfo,
			&m_constants.cobjidinfo ) );

	return err;
	
HandleError:
	CallS( ErrTerm() );
	return err;
	}


//  ================================================================
ERR SCRUBDB::ErrTerm()
//  ================================================================
	{
	ERR err;
	
	Call( m_taskmgr.ErrTerm() );

	delete [] m_constants.pobjidinfo;
	m_constants.pobjidinfo = NULL;

	err = m_stats.err;
	
HandleError:
	return err;
	}


//  ================================================================
ERR SCRUBDB::ErrScrubPages( const PGNO pgnoFirst, const CPG cpg )
//  ================================================================
	{
	SCRUBTASK * ptask = new SCRUBTASK( m_ifmp, pgnoFirst, cpg, &m_context );
	if( NULL == ptask )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}
	const ERR err = m_taskmgr.ErrPostTask( TASK::Dispatch, (ULONG_PTR)ptask );
	if( err < JET_errSuccess )
		{
		//  The task was not enqued sucessfully.
		delete ptask;
		}
	return err;
	}


//  ================================================================
SCRUBTASK::SCRUBTASK( const IFMP ifmp, const PGNO pgnoFirst, const CPG cpg, const SCRUBCONTEXT * const pcontext ) :
	DBTASK( ifmp ),
	m_pgnoFirst( pgnoFirst ),
	m_cpg( cpg ),
	m_pcontext( pcontext ),
	m_pobjidinfoCached( NULL ),
	m_objidNotFoundCached( objidNil )
//  ================================================================
	{
	//	don't fire off async tasks on the temp. database because the
	//	temp. database is simply not equipped to deal with concurrent access
	AssertRTL( dbidTemp != rgfmp[ifmp].Dbid() );
	}

	
//  ================================================================
SCRUBTASK::~SCRUBTASK()
//  ================================================================
	{
	}

		
//  ================================================================
ERR SCRUBTASK::ErrExecute( PIB * const ppib )
//  ================================================================
	{
	ERR	err	= JET_errSuccess;

	for ( PGNO pgno = m_pgnoFirst; pgno < m_pgnoFirst + m_cpg; ++pgno )
		{
		CSR	csr;
		err = csr.ErrGetRIWPage( ppib, m_ifmp, pgno );
		if ( JET_errPageNotInitialized == err )
			{
			//  this page is already zeroed out
			AtomicIncrement( &( m_pcontext->pstats->cpgUnused ) );
			err = JET_errSuccess;
			}
		else if ( err >= 0 )
			{
			err = ErrProcessPage_( ppib, &csr );
			}

		AtomicIncrement( &( m_pcontext->pstats->cpgSeen ) );
		csr.ReleasePage( fTrue );
		Call( err );
		}

HandleError:
	if ( err < 0 )
		{
		AtomicCompareExchange( &m_pcontext->pstats->err, JET_errSuccess, err );
		}
	return err;
	}


//  ================================================================
VOID SCRUBTASK::HandleError( const ERR err )
//  ================================================================
	{
	}


//  ================================================================
ERR SCRUBTASK::ErrProcessPage_(
		PIB * const ppib,
		CSR * const pcsr )
//  ================================================================
	{
	const OBJID objid = pcsr->Cpage().ObjidFDP();

	// do not scrub space tree pages
	if ( pcsr->Cpage().FSpaceTree() )
		{
		return JET_errSuccess;
		}

	if( objid > m_pcontext->pconstants->objidMax )
		{
		AtomicIncrement( &( m_pcontext->pstats->cpgUnknownObjid ) );
		return JET_errSuccess;
		}
		
	if( objid == m_objidNotFoundCached )
		{
		return ErrProcessUnusedPage_( ppib, pcsr );
		}
	else if( m_pobjidinfoCached && objid == m_pobjidinfoCached->objidFDP )
		{
		}
	else if( objidSystemRoot == objid )
		{
		//  this is not in the catalog
		return JET_errSuccess;
		}
	else
		{
		OBJIDINFO objidinfoSearch;
		objidinfoSearch.objidFDP = objid;
		
		OBJIDINFO * pobjidinfoT = m_pcontext->pconstants->pobjidinfo;
		pobjidinfoT = lower_bound(
						pobjidinfoT, 
						m_pcontext->pconstants->pobjidinfo + m_pcontext->pconstants->cobjidinfo,
						objidinfoSearch,
						OBJIDINFO::CmpObjid );
											
		if( pobjidinfoT == m_pcontext->pconstants->pobjidinfo + m_pcontext->pconstants->cobjidinfo
			|| pobjidinfoT->objidFDP != objid )
			{
			m_objidNotFoundCached = objid;
			return ErrProcessUnusedPage_( ppib, pcsr );
			}
		else
			{
			m_pobjidinfoCached = pobjidinfoT;
			}
		}

	if( pcsr->Cpage().Dbtime() < m_pcontext->pconstants->dbtimeLastScrub )
		{
		//  this page should not have been empty the last time we saw it
		//  if so we would have zeroed it out and never should have ended up here
		AtomicIncrement( &( m_pcontext->pstats->cpgUnchanged ) );
		return JET_errSuccess;
		}

	if( pcsr->Cpage().FEmptyPage() )
		{
		return ErrProcessUnusedPage_( ppib, pcsr );
		}
		
	return ErrProcessUsedPage_( ppib, pcsr );
	}


//  ================================================================
ERR SCRUBTASK::ErrProcessUnusedPage_(
		PIB * const ppib,
		CSR * const pcsr )
//  ================================================================
//
//  Can't call CPAGE::ResetHeader because of concurrency issues
//  we don't want to lose our latch on the page, let someone else
//  use the page and then zero it out
//
//-
	{
	pcsr->UpgradeFromRIWLatch();

	//  Don't call CSR::Dirty() or CPAGE::Dirty() because we don't
	//  want the dbtime on the page changed
	BFDirty( pcsr->Cpage().PBFLatch() );	

	//  Delete all the data on the page
	const INT clines = pcsr->Cpage().Clines();
	INT iline;
	for( iline = 0; iline < clines; ++iline )
		{
		pcsr->Cpage().Delete( 0 );
		}
		
	//  reorganize the page and zero all unused data
	pcsr->Cpage().ReorganizeAndZero( 'u' );
	
	pcsr->Downgrade( latchReadNoTouch );

	AtomicIncrement( &( m_pcontext->pstats->cpgZeroed ) );

	return JET_errSuccess;
	}


//  ================================================================
ERR SCRUBTASK::FNodeHasVersions_( const OBJID objidFDP, const KEYDATAFLAGS& kdf, const TRX trxOldest ) const
//  ================================================================
	{
	Assert( m_pobjidinfoCached->objidFDP == objidFDP );

	BOOKMARK bm;
	bm.key = kdf.key;
	if( m_pobjidinfoCached->fUnique )
		{
		bm.data.Nullify();
		}
	else
		{
		bm.data = kdf.data;
		}

	const BOOL fActiveVersion = FVERActive( m_ifmp, m_pobjidinfoCached->pgnoFDP, bm, trxOldest );
	return fActiveVersion;
	}


//  ================================================================
ERR SCRUBTASK::ErrProcessUsedPage_(
		PIB * const ppib,
		CSR * const pcsr )
//  ================================================================
//
//  for each node on the page
//    if it is flag-deleted zero out the data
//    check for an orphaned LV
//
//-
	{
	Assert( m_pobjidinfoCached->objidFDP == pcsr->Cpage().ObjidFDP() );
	
	ERR err = JET_errSuccess;
	
	AtomicIncrement( &( m_pcontext->pstats->cpgUsed ) );

	const TRX trxOldest = TrxOldest( PinstFromPpib( ppib ) );
	
	pcsr->UpgradeFromRIWLatch();

	//  Don't call CSR::Dirty() or CPAGE::Dirty() because we don't
	//  want the dbtime on the page changed
	BFDirty( pcsr->Cpage().PBFLatch() );	

	if( pcsr->Cpage().FLeafPage() )
		{
		LONG cVersionBitsReset 			= 0;
		LONG cFlagDeletedNodesZeroed 	= 0;
		LONG cFlagDeletedNodesNotZeroed = 0;
		
		KEYDATAFLAGS kdf;
		INT iline;
		for( iline = 0; iline < pcsr->Cpage().Clines(); ++iline )
			{
			NDIGetKeydataflags( pcsr->Cpage(), iline, &kdf );
			
			if( FNDDeleted( kdf ) )
				{
				if( !FNDVersion( kdf )
					|| !FNodeHasVersions_( pcsr->Cpage().ObjidFDP(), kdf, trxOldest ) )
					{
					//  don't zero out the data for non-unique indexes
					//  the data is part of the bookmark and can't be removed or the sort order
					//  will be wrong
					if( m_pobjidinfoCached->fUnique )
						{
						++cFlagDeletedNodesZeroed;
						//  the kdf is pointing directly into the page
						memset( kdf.data.Pv(), 'd', kdf.data.Cb() );
						}

					if( FNDVersion( kdf ) )
						{
						++cVersionBitsReset;
						pcsr->Cpage().ReplaceFlags( iline, kdf.fFlags & ~fNDVersion );
						}
					}
				else
					{
					++cFlagDeletedNodesNotZeroed;
					}
				}
			else if( pcsr->Cpage().FLongValuePage() 
					&& !pcsr->Cpage().FSpaceTree() )
				{
				if( sizeof( LID ) == kdf.key.Cb() )
					{
					if( sizeof( LVROOT ) != kdf.data.Cb() )
						{
						AssertSz( fFalse, "Corrupted LV: corrupted LVROOT" );
						Call( ErrERRCheck( JET_errLVCorrupted ) );
						}
					const LVROOT * const plvroot = reinterpret_cast<LVROOT *>( kdf.data.Pv() );
					if( 0 == plvroot->ulReference 
						&& !FNodeHasVersions_( pcsr->Cpage().ObjidFDP(), kdf, trxOldest ) )
						{
						AtomicIncrement( &( m_pcontext->pstats->cOrphanedLV ) );
						Call( ErrSCRUBZeroLV( ppib, m_ifmp, pcsr, iline ) );
						}
					}
				}
			}

		//  report stats for all nodes at one time to reduce contention
		AtomicExchangeAdd( &( m_pcontext->pstats->cNodes ), pcsr->Cpage().Clines() );
		AtomicExchangeAdd( &( m_pcontext->pstats->cVersionBitsReset ), cVersionBitsReset );
		AtomicExchangeAdd( &( m_pcontext->pstats->cFlagDeletedNodesZeroed ), cFlagDeletedNodesZeroed );
		AtomicExchangeAdd( &( m_pcontext->pstats->cFlagDeletedNodesNotZeroed ), cFlagDeletedNodesNotZeroed );
		}
		
	//  reorganize the page and zero all unused data
	pcsr->Cpage().ReorganizeAndZero( 'z' );
	
HandleError:
	pcsr->Downgrade( latchReadNoTouch );
	CallS( err );
	return err;
	}


//  ================================================================
LOCAL ERR ErrSCRUBGetObjidsFromCatalog(
		PIB * const ppib,
		const IFMP ifmp,
		OBJIDINFO ** ppobjidinfo,
		LONG * pcobjidinfo )
//  ================================================================
	{
	FUCB * pfucbCatalog = pfucbNil;
	ERR err;
	DATA data;

	*ppobjidinfo	= NULL;
	*pcobjidinfo	= 0;

	const LONG		cobjidinfoChunk 	= 64;
	LONG			iobjidinfoNext 		= 0;
	LONG			cobjidinfoAllocated = cobjidinfoChunk;
	OBJIDINFO	* 	pobjidinfo			= new OBJIDINFO[cobjidinfoChunk];

	if( NULL == pobjidinfo )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}
			
	SYSOBJ	sysobj;

	OBJID	objidFDP;
	PGNO	pgnoFDP;
	BOOL	fUnique;
	BOOL	fPrimaryIndex;

	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	FUCBSetSequential( pfucbCatalog );
	FUCBSetPrereadForward( pfucbCatalog, cpgPrereadSequential );

	err = ErrIsamMove( ppib, pfucbCatalog, JET_MoveFirst, 0 );
	while ( err >= 0 )
		{
		BOOL fBtree = fFalse;
		
		Call( ErrDIRGet( pfucbCatalog ) );

		Assert( FFixedFid( fidMSO_Type ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_Type,
					pfucbCatalog->kdfCurr.data,
					&data ) );
		CallS( err );

		sysobj = (SYSOBJ)(*( reinterpret_cast<UnalignedLittleEndian< SYSOBJ > *>( data.Pv() ) ) );
		switch( sysobj )
			{
			case sysobjNil:
			case sysobjColumn:
			case sysobjCallback:
				//  These are not B-trees
				break;
				
			case sysobjTable:
			case sysobjIndex:
			case sysobjLongValue:
			case sysobjSLVAvail:
			case sysobjSLVOwnerMap:
				//  These are B-trees
				//  Obtain their objids and pgnoFDPs
				fBtree = fTrue;
				
				Assert( FFixedFid( fidMSO_Id ) );
				Call( ErrRECIRetrieveFixedColumn(
							pfcbNil,
							pfucbCatalog->u.pfcb->Ptdb(),
							fidMSO_Id,
							pfucbCatalog->kdfCurr.data,
							&data ) );
				CallS( err );

				objidFDP = (OBJID)(*( reinterpret_cast<UnalignedLittleEndian< OBJID > *>( data.Pv() ) ));

				Assert( FFixedFid( fidMSO_PgnoFDP ) );
				Call( ErrRECIRetrieveFixedColumn(
							pfcbNil,
							pfucbCatalog->u.pfcb->Ptdb(),
							fidMSO_PgnoFDP,
							pfucbCatalog->kdfCurr.data,
							&data ) );
				CallS( err );

				pgnoFDP = (PGNO)(*( reinterpret_cast<UnalignedLittleEndian< PGNO > *>( data.Pv() ) ));

				break;

			default:
				Assert( fFalse );
				break;
			}			

		//  we need a list of unique objids for version store lookups
		fUnique			= fTrue;
		fPrimaryIndex	= fFalse;
		if( sysobjIndex == sysobj )
			{
			IDBFLAG idbflag;
			Assert( FFixedFid( fidMSO_Flags ) );
			Call( ErrRECIRetrieveFixedColumn(
						pfcbNil,
						pfucbCatalog->u.pfcb->Ptdb(),
						fidMSO_Flags,
						pfucbCatalog->kdfCurr.data,
						&data ) );
			CallS( err );
			Assert( data.Cb() == sizeof(ULONG) );
			UtilMemCpy( &idbflag, data.Pv(), sizeof(IDBFLAG) );

			fUnique = FIDBUnique( idbflag );
			fPrimaryIndex = FIDBPrimary( idbflag );
			}

		Call( ErrDIRRelease( pfucbCatalog ) );

		//  the primary index is already recorded as the B-Tree
		if( fBtree && !fPrimaryIndex )
			{
			if( iobjidinfoNext >= cobjidinfoAllocated )
				{
				const LONG cobjidinfoAllocatedOld = cobjidinfoAllocated;
				const LONG cobjidinfoAllocatedNew = cobjidinfoAllocated + cobjidinfoChunk;
				OBJIDINFO * const pobjidinfoOld = pobjidinfo;
				OBJIDINFO * const pobjidinfoNew = new OBJIDINFO[cobjidinfoAllocatedNew];
				
				if( NULL == pobjidinfoNew )
					{
					Call( ErrERRCheck( JET_errOutOfMemory ) );
					}
					
				memcpy( pobjidinfoNew, pobjidinfoOld, sizeof( OBJIDINFO ) * cobjidinfoAllocatedOld );

				pobjidinfo 		= pobjidinfoNew;
				cobjidinfoAllocated = cobjidinfoAllocatedNew;

				delete [] pobjidinfoOld;
				}
			pobjidinfo[iobjidinfoNext].objidFDP = objidFDP;
			pobjidinfo[iobjidinfoNext].pgnoFDP 	= pgnoFDP;
			pobjidinfo[iobjidinfoNext].fUnique 	= fUnique;

			++iobjidinfoNext;
			}
			
		err = ErrIsamMove( ppib, pfucbCatalog, JET_MoveNext, 0 );
		}
		
	if ( JET_errNoCurrentRecord == err )
		{
		err = JET_errSuccess;
		}
	
HandleError:
	if( pfucbNil != pfucbCatalog )
		{
		DIRUp( pfucbCatalog );
		CallS( ErrCATClose( ppib, pfucbCatalog ) );
		}

	if( err >= 0 )
		{
		sort( pobjidinfo, pobjidinfo + iobjidinfoNext, OBJIDINFO::CmpObjid );
		*ppobjidinfo	= pobjidinfo;
		*pcobjidinfo	= iobjidinfoNext;
		}
	else
		{
		delete [] pobjidinfo;
		*ppobjidinfo	= NULL;
		*pcobjidinfo		= 0;
		}
	return err;
	}


#ifdef DISABLE_SLV
#else

//  ================================================================
ERR ErrSCRUBIScrubOneSLVPageUsingData( 
		PIB * const ppib,
		const IFMP ifmpDb,
		const PGNO pgno,
		const VOID * const pvPageScrubbed )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	BFLatch bfl;
	Call( ErrBFWriteLatchPage( &bfl, ifmpDb | ifmpSLV, pgno, bflfNew ) );

	memcpy( bfl.pv, pvPageScrubbed, g_cbPage );

	BFWriteUnlatch( &bfl );
	
HandleError:
	return err;
	}


//  ================================================================
ERR ErrSCRUBIScrubOneSLVPageUsingFiles( 
		PIB * const ppib,
		const IFMP ifmpDb,
		const PGNO pgno,
		const VOID * const pvPageScrubbed )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	const QWORD ibOffset = OffsetOfPgno( pgno );

	//  write the page syncronously
	//	CONSIDER:  issue an async write
	
	Call( rgfmp[ifmpDb].PfapiSLV()->ErrIOWrite(	ibOffset,
												g_cbPage,
												(BYTE *)pvPageScrubbed ) );
	
HandleError:
	return err;
	}


//  ================================================================
ERR ErrSCRUBIScrubOneSLVPage( 
		PIB * const ppib,
		const IFMP ifmpDb,
		const PGNO pgno,
		const VOID * const pvPageScrubbed )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	if ( PinstFromPpib( ppib )->FSLVProviderEnabled() )
		{
		//  zero the SLV page using the SLV Provider

		Call( ErrSCRUBIScrubOneSLVPageUsingFiles( ppib, ifmpDb, pgno, pvPageScrubbed ) );
		}
	else
		{
		//  zero the SLV page using data

		Call( ErrSCRUBIScrubOneSLVPageUsingData( ppib, ifmpDb, pgno, pvPageScrubbed ) );
		}
	
HandleError:
	return err;
	}


//  ================================================================
ERR ErrSCRUBIScrubSLVPages( 
		PIB * const ppib,
		const IFMP ifmpDb,
		const PGNO pgnoStart,
		const SLVSPACENODE * const pspacenode,
		CPG * const pcpgSeen,
		CPG * const pcpgScrubbed,
		const VOID * const pvPageScrubbed,
		JET_PFNSTATUS pfnStatus,
		JET_SNPROG * const psnprog )
//  ================================================================
//
//	For each free page in the SLVSPACENODE
//	write a blank page into the database
//
//-
	{
	ERR err = JET_errSuccess;

	Assert ( pcpgSeen );
	Assert ( pcpgScrubbed );
	*pcpgSeen = CPG(0);
	*pcpgScrubbed = CPG(0);

	INT ipage;
	for( ipage = 0; ipage < SLVSPACENODE::cpageMap; ++ipage )
		{
		SLVSPACENODE::STATE state = pspacenode->GetState( ipage );
		(*pcpgSeen)++;
		if( SLVSPACENODE::sFree == state )
			{
			Call( ErrSCRUBIScrubOneSLVPage( ppib, ifmpDb, pgnoStart + ipage, pvPageScrubbed ) );
			(*pcpgScrubbed)++;
			}
		++(psnprog->cunitDone);
		if ( ( 0 == ( psnprog->cunitDone % 128 ) )
			&& NULL != pfnStatus )
			{
			(VOID)pfnStatus( (JET_SESID)ppib, JET_snpRepair, JET_sntProgress, psnprog );
			}			
		}
	
HandleError:
	return err;
	}


//  ================================================================
ERR ErrSCRUBIScrubOneSlvspacenode( 
		PIB * const ppib,
		const IFMP ifmpDb,
		const FUCB * const pfucbSLVAvail,
		CPG * const pcpgSeen,
		CPG * const pcpgScrubbed,
		const VOID * const pvPageScrubbed,
		JET_PFNSTATUS pfnStatus,
		JET_SNPROG * const psnprog )		
//  ================================================================
//
//	CONSIDER:	make a copy of the SLVSPACENODE
//				transition all free pages to Deleted
//				update the SLVSPACENODECACHE
//				unlatch the page
//				scrub the copy of the SLVSPACENODe
//				copy the original SLVSPACENODE back
//
//-
	{
	ERR err = JET_errSuccess;

	PGNO pgno;
	LongFromKey( &pgno, pfucbSLVAvail->kdfCurr.key );
	pgno -= ( SLVSPACENODE::cpageMap - 1 );	//	first page is 1

	const SLVSPACENODE * const pspacenode = (SLVSPACENODE *)pfucbSLVAvail->kdfCurr.data.Pv();

	Call( ErrSCRUBIScrubSLVPages( 
			ppib,
			ifmpDb,
			pgno,
			pspacenode,
			pcpgSeen,
			pcpgScrubbed,
			pvPageScrubbed,
			pfnStatus,
			psnprog ) );

HandleError:
	return err;
	}


//  ================================================================
ERR ErrSCRUBIScrubStreamingFile( 
		PIB * const ppib,
		const IFMP ifmpDb,
		FUCB * const pfucbSLVAvail,
		CPG * const pcpgSeen,
		CPG * const pcpgScrubbed,
		const VOID * const pvPageScrubbed,
		JET_PFNSTATUS pfnStatus,
		JET_SNPROG * const psnprog )		
//  ================================================================
	{
	ERR err = JET_errSuccess;

	DIB dib;
	dib.pos = posFirst;
	dib.pbm = NULL;
	dib.dirflag = fDIRNull;

	Call( ErrBTDown( pfucbSLVAvail, &dib, latchReadNoTouch ) );

	Assert ( pcpgSeen );
	Assert ( pcpgScrubbed );
	*pcpgSeen = 0;
	*pcpgScrubbed = 0;

	do
		{
		CPG cpgSeenStep;
		CPG cpgScrubbedStep;
		
		Call( ErrSCRUBIScrubOneSlvspacenode( 
				ppib,
				ifmpDb,
				pfucbSLVAvail,
				&cpgSeenStep,
				&cpgScrubbedStep,
				pvPageScrubbed,
				pfnStatus,
				psnprog ) );

		*pcpgSeen += cpgSeenStep;
		*pcpgScrubbed += cpgScrubbedStep;
				
		} while( ( err = ErrBTNext( pfucbSLVAvail, fDIRNull ) ) == JET_errSuccess );

	if( JET_errNoCurrentRecord == err )
		{
		err = JET_errSuccess;
		}
		
HandleError:
	Assert ( *pcpgSeen >= *pcpgScrubbed );

	return err;
	}


//  ================================================================
ERR ErrSCRUBScrubStreamingFile( 
		PIB * const ppib,
		const IFMP ifmpDb,
		CPG * const pcpgSeen,
		CPG * const pcpgScrubbed,
		JET_PFNSTATUS pfnStatus )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	FUCB * pfucbSLVAvail = pfucbNil;

	// initialize out params
	Assert ( pcpgSeen );
	Assert ( pcpgScrubbed );
	*pcpgSeen = CPG(0);
	*pcpgScrubbed = CPG(0);
	
	VOID * const pvPageScrubbed = PvOSMemoryPageAlloc( g_cbPage, NULL );
	if( NULL == pvPageScrubbed )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	memset( pvPageScrubbed, '?', g_cbPage );

	//	init the status bar

	JET_SNPROG snprog;
	memset( &snprog, 0, sizeof( snprog ) );	
	snprog.cunitTotal 	= rgfmp[ifmpDb].PgnoSLVLast();
	snprog.cunitDone 	= 0;

	if ( NULL != pfnStatus )
		{
		(VOID)pfnStatus( (JET_SESID)ppib, JET_snpRepair, JET_sntBegin, NULL );	
		}

	//	open the SLVAvail tree
	Assert ( rgfmp[ifmpDb].FSLVAttached() );

	Call( ErrBTOpen( ppib, rgfmp[ifmpDb].PfcbSLVAvail(), &pfucbSLVAvail, fFalse ) );

	Call( ErrSCRUBIScrubStreamingFile( 
			ppib,
			ifmpDb,
			pfucbSLVAvail,
			pcpgSeen,
			pcpgScrubbed,
			pvPageScrubbed,
			pfnStatus,
			&snprog ) );

HandleError:
	if ( NULL != pfnStatus )
		{
		(VOID)pfnStatus( (JET_SESID)ppib, JET_snpRepair, JET_sntComplete, NULL );	
		}

	if( pfucbNil != pfucbSLVAvail )
		{
		BTClose( pfucbSLVAvail );
		}

	OSMemoryPageFree( pvPageScrubbed );
	return err;
	}
	

//  ================================================================
SCRUBSLVTASK::SCRUBSLVTASK( SCRUBSLVCONTEXT * const pcontext ) :
//  ================================================================
	m_pcontext( pcontext ),
	DBTASK( pcontext->ifmp ),
	m_fUnattended ( fFalse )
	{
	//	don't fire off async tasks on the temp. database because the
	//	temp. database is simply not equipped to deal with concurrent access
	AssertRTL( dbidTemp != rgfmp[pcontext->ifmp].Dbid() );
	}

//  ================================================================
SCRUBSLVTASK::SCRUBSLVTASK( const IFMP ifmp ) :
//  ================================================================
	m_pcontext( NULL ),
	DBTASK( ifmp ),
	m_fUnattended ( fTrue )
	{
	//	don't fire off async tasks on the temp. database because the
	//	temp. database is simply not equipped to deal with concurrent access
	AssertRTL( dbidTemp != rgfmp[ifmp].Dbid() );
	}

//  ================================================================
SCRUBSLVTASK::~SCRUBSLVTASK()
//  ================================================================
	{
	}

		
//  ================================================================
VOID SCRUBSLVTASK::HandleError( const ERR err )
//  ================================================================
	{
	AssertSz( fFalse, "Unable to scrub the streaming file" );
	//	UNDONE: we need a smarter response
	}


//  ================================================================
ERR SCRUBSLVTASK::ErrExecute( PIB * const ppib )
//  ================================================================
	{
	ERR 	 err 				= JET_errSuccess;
	ULONG_PTR ulSecsStartScrub 	= 0;
	CPG		 cpgSeen 			= 0;
	CPG		 cpgScrubbed 		= 0;

	
	Assert ( m_fUnattended ^ (ULONG_PTR) m_pcontext );
	
	if ( m_fUnattended )
		{
		// EventLog start
		const CHAR * rgszT[1];
		INT isz = 0;
		
		rgszT[isz++] = rgfmp[m_ifmp].SzSLVName();
		Assert( isz <= sizeof( rgszT ) / sizeof( rgszT[0] ) );
		
		UtilReportEvent(
				eventInformation,
				DATABASE_ZEROING_CATEGORY,
				DATABASE_SLV_ZEROING_STARTED_ID,
				isz,
				rgszT,
				0,
				NULL,
				PinstFromIfmp( m_ifmp ) );
		}
	else
		{
		Assert ( m_ifmp == m_pcontext->ifmp );
		}

	ulSecsStartScrub = UlUtilGetSeconds();
		
	Call( ErrSCRUBScrubStreamingFile( 
			ppib,
			m_ifmp,
			&cpgSeen,
			&cpgScrubbed,
			NULL ) );
	
HandleError:

	if ( !m_fUnattended )
		{
		m_pcontext->err	= err;
		m_pcontext->cpgSeen = cpgSeen;
		m_pcontext->cpgScrubbed = cpgScrubbed;

		m_pcontext->signal.Set();
		}
	else
		{
		const ULONG_PTR ulSecFinished 	= UlUtilGetSeconds();
		const ULONG_PTR ulSecs 			= ulSecFinished - ulSecsStartScrub;

		// EventLog stop		
		const CHAR * rgszT[8];
		INT isz = 0;

		CHAR	szSeconds[16];
		CHAR	szErr[16];
		CHAR	szPages[16];
		CHAR	szScrubPages[16];

		sprintf( szSeconds, "%"FMTSZ3264"d", ulSecs );
		sprintf( szErr, "%d", err );
		sprintf( szPages, "%d", cpgSeen );
		sprintf( szScrubPages, "%d", cpgScrubbed );

		rgszT[isz++] = rgfmp[m_ifmp].SzSLVName();
		rgszT[isz++] = szSeconds;
		rgszT[isz++] = szErr;
		rgszT[isz++] = szPages;
		rgszT[isz++] = szScrubPages;
		
		Assert( isz <= sizeof( rgszT ) / sizeof( rgszT[0] ) );
		UtilReportEvent(
				( err >= JET_errSuccess ? eventInformation : eventError ),
				DATABASE_ZEROING_CATEGORY,
				DATABASE_SLV_ZEROING_STOPPED_ID,
				isz,
				rgszT,
				0,
				NULL,
				PinstFromIfmp( m_ifmp ) );
		// UNDONE: the task msg is deleting the task object ?
		}

	return err;
	}

#endif	//	DISABLE_SLV

#endif	//	MINIMAL_FUNCTIONALITY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ese98\src\ese\slvsp.cxx ===
#include "std.hxx"
#include "_bt.hxx"

#ifdef DISABLE_SLV
#else

#ifndef RTM


//  ================================================================
LOCAL ERR ErrSLVISpaceTestInsert( PIB * const ppib, FUCB * const pfucb, const ULONG pgnoLast )
//  ================================================================
	{
	//  Insert the SLVSPACENODE
	SLVSPACENODE slvspacenode;
	slvspacenode.Init();

	ULONG ulKey;
	KeyFromLong( (BYTE *)&ulKey, pgnoLast );
	
	KEY key;
	key.prefix.Nullify();
	key.suffix.SetPv( (BYTE *)&ulKey );
	key.suffix.SetCb( sizeof( ulKey ) );

	DATA data;
	data.SetPv( &slvspacenode );
	data.SetCb( sizeof( slvspacenode ) );

	return ErrBTInsert( pfucb, key, data, fDIRNull );
	}


//  ================================================================
LOCAL ERR ErrSLVISpaceTestSeek( PIB * const ppib, FUCB * const pfucb, const ULONG pgnoLast )
//  ================================================================
	{
	ULONG ulKey;
	KeyFromLong( (BYTE *)&ulKey, pgnoLast );

	BOOKMARK bookmark;
	bookmark.key.prefix.Nullify();
	bookmark.key.suffix.SetPv( (BYTE *)&ulKey );
	bookmark.key.suffix.SetCb( sizeof( ulKey ) );
	bookmark.data.Nullify();

	//  Seek to the SLVSPACENODE
	DIB dib;
	dib.pos = posDown;
	dib.pbm = &bookmark;
	dib.dirflag = fDIRNull;
	return ErrBTDown( pfucb, &dib, latchRIW );
	}


//  ================================================================
LOCAL ERR ErrSLVISpaceTestMunge(
	PIB * const ppib,
	FUCB * const pfucb,
	const ULONG pgnoLast,
	const SLVSPACEOPER slvspaceoper,
	const LONG ipage,
	const LONG cpages,
	const DIRFLAG dirflag )
//  ================================================================
	{
	ERR err;
	Call( ErrSLVISpaceTestSeek( ppib, pfucb, pgnoLast ) );
	CallS( Pcsr( pfucb )->ErrUpgrade() );
	Call( ErrBTMungeSLVSpace(
				pfucb,
				slvspaceoper,
				ipage,
				cpages,
				dirflag ) );
	BTUp( pfucb );

HandleError:
	return err;
	}


//  ================================================================
LOCAL ERR ErrSLVISpaceTestDelete( PIB * const ppib, FUCB * const pfucb, const ULONG pgnoLast )
//  ================================================================
	{
	ERR err;
	CallR( ErrSLVISpaceTestSeek( ppib, pfucb, pgnoLast ) );
	CallR( ErrBTRelease( pfucb ) );
	return ErrBTFlagDelete( pfucb, fDIRNull );
	}


//  ================================================================
LOCAL ERR ErrSLVISpaceTest( PIB * const ppib, FUCB * const pfucb, const ULONG pgnoLast )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	Call( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );

	Call( ErrSLVISpaceTestSeek( ppib, pfucb, pgnoLast ) );
	CallS( Pcsr( pfucb )->ErrUpgrade() );

	//  FREE => RESERVED
	Call( ErrBTMungeSLVSpace(
				pfucb,
				slvspaceoperFreeToReserved,
				23,
				13,
				fDIRNull ) );

	//  RESERVED => COMMITTED
	Call( ErrBTMungeSLVSpace(
				pfucb,
				slvspaceoperReservedToCommitted,
				23,
				13,
				fDIRNull ) );

	//  FREE => COMMITTED
	Call( ErrBTMungeSLVSpace(
				pfucb,
				slvspaceoperFreeToCommitted,
				36,
				1,
				fDIRNull ) );

	//  COMMITTED => DELETED
	Call( ErrBTMungeSLVSpace(
				pfucb,
				slvspaceoperCommittedToDeleted,
				23,
				14,
				fDIRNull ) );

	//  After the commit RCEClean should pick up the deleted space and move it 
	//  to free
	
	BTUp( pfucb );
	Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );

HandleError:
	return err;
	}


//  ================================================================
LOCAL ERR ErrSLVISpaceTestRollback( PIB * const ppib, FUCB * const pfucb, const ULONG pgnoLast )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	//  FREE => RESERVED => ROLLBACK
	Call( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	Call( ErrSLVISpaceTestMunge(
			ppib,
			pfucb,
			pgnoLast,
			slvspaceoperFreeToReserved,
			47,
			16,
			fDIRNull ) );
	CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );

	//  RESERVED => COMMITTED => ROLLBACK
	Call( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	Call( ErrSLVISpaceTestMunge(
			ppib,
			pfucb,
			pgnoLast,
			slvspaceoperFreeToReserved,
			100,
			16,
			fDIRNull ) );
	Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );
	Call( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	Call( ErrSLVISpaceTestMunge(
			ppib,
			pfucb,
			pgnoLast,
			slvspaceoperReservedToCommitted,
			100,
			16,
			fDIRNull ) );
	CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );

	//  FREE => RESERVED => COMMITTED => ROLLBACK
	Call( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	Call( ErrSLVISpaceTestMunge(
			ppib,
			pfucb,
			pgnoLast,
			slvspaceoperFreeToReserved,
			100,
			16,
			fDIRNull ) );
	Call( ErrSLVISpaceTestMunge(
			ppib,
			pfucb,
			pgnoLast,
			slvspaceoperReservedToCommitted,
			100,
			16,
			fDIRNull ) );
	CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
	
	//  FREE => COMMITTED => ROLLBACK
	Call( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	Call( ErrSLVISpaceTestMunge(
			ppib,
			pfucb,
			pgnoLast,
			slvspaceoperFreeToCommitted,
			300,
			16,
			fDIRNull ) );
	CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );

	//  COMMITTED => DELETED => ROLLBACK
	Call( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	Call( ErrSLVISpaceTestMunge(
			ppib,
			pfucb,
			pgnoLast,
			slvspaceoperFreeToCommitted,
			399,
			16,
			fDIRNull ) );
	Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );
	Call( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	Call( ErrSLVISpaceTestMunge(
			ppib,
			pfucb,
			pgnoLast,
			slvspaceoperCommittedToDeleted,
			399,
			16,
			fDIRNull ) );
	CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );

HandleError:
	return err;
	}

//  ================================================================
ERR ErrSLVISpaceTestSetupReservedAndDeleted( PIB * const ppib, FUCB * const pfucb )
//  ================================================================
	{
	ERR err;
	
	//  NODE 1: all pages reserved
	Call( ErrSLVISpaceTestMunge(
			ppib,
			pfucb,
			2 * SLVSPACENODE::cpageMap, 
			slvspaceoperFreeToReserved,
			0,
			SLVSPACENODE::cpageMap,
			fDIRNoVersion ) );

	//  NODE 4: all pages deleted
	Call( ErrSLVISpaceTestMunge(
			ppib,
			pfucb,
			5 * SLVSPACENODE::cpageMap, 
			slvspaceoperFreeToCommitted,
			0,
			SLVSPACENODE::cpageMap,
			fDIRNoVersion ) );
	Call( ErrSLVISpaceTestMunge(
			ppib,
			pfucb,
			5 * SLVSPACENODE::cpageMap, 
			slvspaceoperCommittedToDeleted,
			0,
			SLVSPACENODE::cpageMap,
			fDIRNoVersion ) );

	//  NODE 27: first reserved
	Call( ErrSLVISpaceTestMunge(
			ppib,
			pfucb,
			28 * SLVSPACENODE::cpageMap, 
			slvspaceoperFreeToReserved,
			0,
			1,
			fDIRNoVersion ) );

	//  NODE 28: last deleted
	Call( ErrSLVISpaceTestMunge(
			ppib,
			pfucb,
			29 * SLVSPACENODE::cpageMap, 
			slvspaceoperFreeToCommitted,
			SLVSPACENODE::cpageMap - 1,
			1,
			fDIRNoVersion ) );
	Call( ErrSLVISpaceTestMunge(
			ppib,
			pfucb,
			29 * SLVSPACENODE::cpageMap, 
			slvspaceoperCommittedToDeleted,
			SLVSPACENODE::cpageMap - 1,
			1,
			fDIRNoVersion ) );

	//  NODE 29: some reserved, some deleted
	//		10 :10  -- reserved
	Call( ErrSLVISpaceTestMunge(
			ppib,
			pfucb,
			30 * SLVSPACENODE::cpageMap, 
			slvspaceoperFreeToReserved,
			10,
			10,
			fDIRNoVersion ) );
	//		20 :20  -- deleted
	Call( ErrSLVISpaceTestMunge(
			ppib,
			pfucb,
			30 * SLVSPACENODE::cpageMap, 
			slvspaceoperFreeToCommitted,
			20,
			60,	//	leave some committed nodes
			fDIRNoVersion ) );
	Call( ErrSLVISpaceTestMunge(
			ppib,
			pfucb,
			30 * SLVSPACENODE::cpageMap, 
			slvspaceoperCommittedToDeleted,
			20,
			20,
			fDIRNoVersion ) );
	//		100:15  -- reserved
	Call( ErrSLVISpaceTestMunge(
			ppib,
			pfucb,
			30 * SLVSPACENODE::cpageMap, 
			slvspaceoperFreeToReserved,
			100,
			15,
			fDIRNoVersion ) );
	//		115:3   -- deleted
	Call( ErrSLVISpaceTestMunge(
			ppib,
			pfucb,
			30 * SLVSPACENODE::cpageMap, 
			slvspaceoperFreeToCommitted,
			115,
			5,
			fDIRNoVersion ) );
	Call( ErrSLVISpaceTestMunge(
			ppib,
			pfucb,
			30 * SLVSPACENODE::cpageMap, 
			slvspaceoperCommittedToDeleted,
			115,
			5,
			fDIRNoVersion ) );
	//		150:1  -- reserved
	Call( ErrSLVISpaceTestMunge(
			ppib,
			pfucb,
			30 * SLVSPACENODE::cpageMap, 
			slvspaceoperFreeToReserved,
			150,
			1,
			fDIRNoVersion ) );
	//		152:1  -- reserved
	Call( ErrSLVISpaceTestMunge(
			ppib,
			pfucb,
			30 * SLVSPACENODE::cpageMap, 
			slvspaceoperFreeToReserved,
			152,
			1,
			fDIRNoVersion ) );

HandleError:
	return err;
	}


//  ================================================================
ERR ErrSLVSpaceTest( PIB * const ppib, FUCB * const pfucb )
//  ================================================================
//
//  Insert a node and try the SLV space operations on it
//
//-
	{
	ERR err = JET_errSuccess;

	const INT cnodesMax = 32;
	INT cnodes;

	SLVSPACENODECACHE * const pslvspacenodecache = rgfmp[pfucb->ifmp].Pslvspacenodecache();
	if( pslvspacenodecache )
		{
		const CPG cpg = cnodesMax * SLVSPACENODE::cpageMap;
		Call( pslvspacenodecache->ErrGrowCache( cpg ) );
		}

	//  Insert the nodes
	Call( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	for( cnodes = 0; cnodes < cnodesMax; ++cnodes )
		{
		const ULONG pgnoLast = (cnodes + 1) * SLVSPACENODE::cpageMap;
		Call( ErrSLVISpaceTestInsert( ppib, pfucb, pgnoLast ) );
		BTUp( pfucb );

		if( pslvspacenodecache )
			{
			pslvspacenodecache->SetCpgAvail( pgnoLast, SLVSPACENODE::cpageMap );
			}
		}
	Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );

 	//  Tests
	Call( ErrSLVISpaceTest( ppib, pfucb, 7 * SLVSPACENODE::cpageMap ) );
	Call( ErrSLVISpaceTest( ppib, pfucb, 13 * SLVSPACENODE::cpageMap ) );
	Call( ErrSLVISpaceTestRollback( ppib, pfucb, 12 * SLVSPACENODE::cpageMap ) );
	Call( ErrSLVISpaceTestRollback( ppib, pfucb, 1 * SLVSPACENODE::cpageMap ) );

	Call( ErrSLVISpaceTestSetupReservedAndDeleted( ppib, pfucb ) );
	ULONG cpagesSeen;
	ULONG cpagesReset;
	ULONG cpagesFree;
	Call( ErrSLVResetAllReservedOrDeleted( pfucb, &cpagesSeen, &cpagesReset, &cpagesFree ) );

	//  make sure that all the nodes have been reset
	for( cnodes = 0; cnodes < cnodesMax; ++cnodes )
		{
		const ULONG pgnoLast = (cnodes + 1) * SLVSPACENODE::cpageMap;
		Call( ErrSLVISpaceTestSeek( ppib, pfucb, pgnoLast ) );
		const SLVSPACENODE * const pspacenode = (SLVSPACENODE *)pfucb->kdfCurr.data.Pv();
		const LONG ipageFirstReservedOrDeleted = pspacenode->IpageFirstReservedOrDeleted();
		Assert( ipageFirstReservedOrDeleted == SLVSPACENODE::cpageMap );
		BTUp( pfucb );
		}

	//  Let the version store cleanup
	Call( ErrIsamIdle( (JET_SESID)ppib, JET_bitIdleCompact ) );

	//  Remove the nodes
	Call( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	for( cnodes = 0; cnodes < cnodesMax; ++cnodes )
		{
		const ULONG pgnoLast = (cnodes + 1) * SLVSPACENODE::cpageMap;
		Call( ErrSLVISpaceTestDelete( ppib, pfucb, pgnoLast ) );
		BTUp( pfucb );
		}
	Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );

HandleError:
	return err;
	}
#endif	//  !RTM


ERR ErrSLVInsertSpaceNode( FUCB *pfucbSLVAvail, const PGNO pgnoLast )
	{
	KEY				key;
	DATA			data;
	SLVSPACENODE	slvspnode;
	BYTE			rgbKey[sizeof(PGNO)];

	Assert( pfucbNil != pfucbSLVAvail );
	Assert( pgnoLast >= cpgSLVFileMin );

	KeyFromLong( rgbKey, pgnoLast );
	key.prefix.Nullify();
	key.suffix.SetPv( rgbKey );
	key.suffix.SetCb( sizeof(PGNO) );

	slvspnode.Init();
	Assert( cpgSLVExtent == slvspnode.CpgAvail() );

	data.SetPv( (BYTE *)&slvspnode );
	data.SetCb( sizeof(SLVSPACENODE) );

	BTUp( pfucbSLVAvail );
	const ERR	 err = ErrBTInsert( pfucbSLVAvail, key, data, fDIRNoVersion, NULL );
	Assert( err < 0 || Pcsr( pfucbSLVAvail )->FLatched() );

	SLVSPACENODECACHE * const pslvspacenodecache = rgfmp[pfucbSLVAvail->ifmp].Pslvspacenodecache();
	if( err >= 0 && pslvspacenodecache )
		{
		pslvspacenodecache->SetCpgAvail( pgnoLast, cpgSLVExtent );
		}
		
	return err;
	}
	
ERR ErrSLVCreateAvailMap( PIB *ppib, FUCB *pfucbDb )
	{
	ERR				err;
	const IFMP		ifmp		= pfucbDb->ifmp;
	FUCB			*pfucbSLV	= pfucbNil;
	PGNO			pgnoSLVFDP;
	OBJID			objidSLV;
	const BOOL		fTempDb		= ( dbidTemp == rgfmp[ifmp].Dbid() );

	Assert( ppibNil != ppib );
	Assert( rgfmp[ifmp].FCreatingDB() || fGlobalRepair );
	Assert( 0 == ppib->level || ( 1 == ppib->level && rgfmp[ifmp].FLogOn() ) || fGlobalRepair );
	Assert( pfucbDb->u.pfcb->FTypeDatabase() );
	
	//  CONSIDER:  get at least enough pages to hold the LV we are about to insert
	//  we must open the directory with a different session.
	//	if this fails, rollback will free the extent, or at least, it will attempt
	//  to free the extent.
	CallR( ErrDIRCreateDirectory(
				pfucbDb,
				cpgSLVAvailTree,
				&pgnoSLVFDP,
				&objidSLV,
				CPAGE::fPageSLVAvail,
				fSPMultipleExtent | fSPUnversionedExtent ) );

	Assert( pgnoSLVFDP > pgnoSystemRoot );
	Assert( pgnoSLVFDP <= pgnoSysMax );

	Call( ErrBTOpen( ppib, pgnoSLVFDP, ifmp, &pfucbSLV ) );
	Assert( pfucbNil != pfucbSLV );

	Call( ErrSLVInsertSpaceNode( pfucbSLV, cpgSLVFileMin ) );
	Assert( Pcsr( pfucbSLV )->FLatched() );
	CallS( ErrBTRelease( pfucbSLV ) );

	//	ensure FUCB doesn't get defer-closed and FCB gets freed
	//	on subsequent BTClose() below
	Assert( !FFUCBVersioned( pfucbSLV ) );
	Assert( !pfucbSLV->u.pfcb->FInitialized() );

	if ( !fTempDb )
		{
		Assert( objidSLV > objidSystemRoot );
		Call( ErrCATAddDbSLVAvail(
					ppib,
					ifmp,
					szSLVAvail,
					pgnoSLVFDP,
					objidSLV ) );
		}
	else
		{
		Assert( pgnoTempDbSLVAvail == pgnoSLVFDP );
		Assert( objidTempDbSLVAvail == objidSLV );
		}

	BTClose( pfucbSLV );
	pfucbSLV = pfucbNil;
	
	if( fGlobalRepair )
		{
		FCB * pfcbSLVAvail = pfcbNil;
		Call( ErrSLVAvailMapInit( ppib, ifmp, pgnoSLVFDP, &pfcbSLVAvail ) );
		Assert( pfcbNil != pfcbSLVAvail );
		}

HandleError:
	if ( pfucbNil != pfucbSLV )
		{
		BTClose( pfucbSLV );
		}
	return err;
	}


//  ================================================================
ERR ErrSLVResetAllReservedOrDeleted( FUCB * const pfucb, ULONG * const pcpagesSeen, ULONG * const pcpagesReset, ULONG * const pcpagesFree )
//  ================================================================
//
//  Walks the SLV space tree pointed to by the pfucb and resets all
//  reserved or deleted pages to free. This is done unversioned (we
//  aren't interested in rollback and will have to re-examine the tree
//  if we crash).
//
//  The number of SLV pages seen and reset is returned
//  
//
//-
	{
	ERR err = JET_errSuccess;

	SLVSPACENODECACHE * const pslvspacenodecache = rgfmp[pfucb->ifmp].Pslvspacenodecache();
	Assert( NULL != pslvspacenodecache );
	
	CallR( ErrDIRBeginTransaction( pfucb->ppib, NO_GRBIT ) );

	LONG cpagesReset 	= 0;
	LONG cpagesSeen		= 0;
	LONG cpagesFree 	= 0;
	
	DIB dib;

	dib.pos 	= posFirst;
	dib.pbm 	= NULL;
	dib.dirflag = fDIRNull;

	FUCBSetPrereadForward( pfucb, cpgPrereadSequential );
	err = ErrBTDown( pfucb, &dib, latchReadTouch );
	if( JET_errNoCurrentRecord == err )
		{
		//  the tree is empty
		err = JET_errSuccess;
		goto HandleError;
		}
	Call( err );

	do
		{
		if( sizeof( SLVSPACENODE ) != pfucb->kdfCurr.data.Cb() )
			{
			AssertSz( fFalse, "SLV space tree corruption. Data is wrong size" );
			Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
			}
		if( sizeof( PGNO ) != pfucb->kdfCurr.key.Cb() )
			{
			AssertSz( fFalse, "SLV space tree corruption. Key is wrong size" );
			Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
			}
			
		cpagesSeen = cpagesSeen + SLVSPACENODE::cpageMap;

		ULONG pgnoCurr;
		LongFromKey( &pgnoCurr, pfucb->kdfCurr.key );
		if( cpagesSeen != pgnoCurr )
			{
			AssertSz( fFalse, "SLV space tree corruption. Nodes out of order" );
			Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
			}

		const SLVSPACENODE * pspacenode = (SLVSPACENODE *)pfucb->kdfCurr.data.Pv();

#ifndef RTM
		Call( pspacenode->ErrCheckNode( CPRINTFDBGOUT::PcprintfInstance() ) );
#endif	//	RTM

		if( pspacenode->CpgAvail() == SLVSPACENODE::cpageMap )
			{
			goto NextNode;
			}
			
		LONG ipageFirstReservedOrDeleted;
		ipageFirstReservedOrDeleted = pspacenode->IpageFirstReservedOrDeleted();
		Assert( ipageFirstReservedOrDeleted <= SLVSPACENODE::cpageMap );
		if( ipageFirstReservedOrDeleted >= SLVSPACENODE::cpageMap )
			{
			goto NextNode;
			}
		else
			{
			LATCH		latch		= latchReadTouch;
						
Refresh:
			//	upgrade latch on page
			//
			err = Pcsr( pfucb )->ErrUpgrade();
			if ( errBFLatchConflict == err )
				{
				Assert( !Pcsr( pfucb )->FLatched() );

				latch = latchRIW;
				Call ( ErrBTIRefresh( pfucb, latch ) );

				goto Refresh;
				}
			Call( err );
			
			Assert( latchWrite == Pcsr( pfucb )->Latch() );

			//  NOTE: the page may have moved while being upgraded (??)
			Assert( sizeof( SLVSPACENODE ) == pfucb->kdfCurr.data.Cb() );
			pspacenode = (SLVSPACENODE *)pfucb->kdfCurr.data.Pv();

			LONG 				ipageStartRun	= ipageFirstReservedOrDeleted;
			LONG 				cpagesRun		= 0;
			SLVSPACENODE::STATE stateRun		= SLVSPACENODE::sReserved;	//  guess that it is reserved
			
			LONG ipage;
			for( ipage = ipageFirstReservedOrDeleted; ipage < SLVSPACENODE::cpageMap; ++ipage )
				{
				const SLVSPACENODE::STATE state = pspacenode->GetState( ipage );
				if( state == stateRun )
					{
					//  this is part of the run
					++cpagesRun;
					}
				else
					{
					//  free the pages in the old run
					if( cpagesRun > 0 )
						{
						Assert( SLVSPACENODE::sReserved == stateRun
								|| SLVSPACENODE::sDeleted == stateRun );
						const SLVSPACEOPER oper = ( stateRun == SLVSPACENODE::sDeleted ) ? slvspaceoperFree : slvspaceoperFreeReserved;
						
						// No need to mark the pages as unused in the OwnerMap
						// because the operation isn't moving pages out from the commited state
						// (transition into commited state are not marked in OwnerMap at this level)
						Call( ErrBTMungeSLVSpace( pfucb, oper, ipageStartRun, cpagesRun, fDIRNoVersion ) );
						cpagesReset += cpagesRun;
						}

					//  start a new run if necessary
					if( SLVSPACENODE::sReserved == state
						|| SLVSPACENODE::sDeleted == state )
						{
						stateRun 		= state;
						ipageStartRun	= ipage;
						cpagesRun 		= 1;
						}
					else
						{
						stateRun 		= SLVSPACENODE::sInvalid;
						cpagesRun 		= 0;
#ifdef DEBUG
						ipageStartRun 	= 0xfefffeff;
#endif	//	DEBUG
						}
					}
				}
			//  if the run was at the end of the page we may not have finished
			if( cpagesRun > 0 )
				{
				Assert( SLVSPACENODE::sReserved == stateRun
						|| SLVSPACENODE::sDeleted == stateRun );
				const SLVSPACEOPER oper = ( stateRun == SLVSPACENODE::sDeleted ) ? slvspaceoperFree : slvspaceoperFreeReserved;
				
				// No need to mark the pages as unused in the OwnerMap
				// because the operation isn't moving pages out from the commited state
				// (transition into commited state are not marked in OwnerMap at this level)
				Call( ErrBTMungeSLVSpace( pfucb, oper, ipageStartRun, cpagesRun, fDIRNoVersion ) );
				cpagesReset += cpagesRun;
				}
				
			Assert( latchWrite == Pcsr( pfucb )->Latch() );
			Pcsr( pfucb )->Downgrade( latchReadTouch );			
			}

NextNode:

///		printf( "%d:%d\n", pgnoCurr, pspacenode->CpgAvail() );
		pslvspacenodecache->SetCpgAvail( pgnoCurr, pspacenode->CpgAvail() );
			
		cpagesFree = cpagesFree + pspacenode->CpgAvail();
		
		} while( JET_errSuccess == ( err = ErrBTNext( pfucb, fDIRNull ) ) );

	if( JET_errNoCurrentRecord == err )
		{
		err = JET_errSuccess;
		}
		
	BTUp( pfucb );
	Call( ErrDIRCommitTransaction( pfucb->ppib, JET_bitCommitLazyFlush ) );
	
HandleError:
	if( pcpagesSeen )
		{
		*pcpagesSeen = cpagesSeen;
		}
	if( pcpagesReset )
		{
		*pcpagesReset = cpagesReset;
		}
	if( pcpagesFree )
		{
		*pcpagesFree = cpagesFree;
		}
		
	BTUp( pfucb );

	if ( err < JET_errSuccess )
		{
		CallSx( ErrDIRRollback( pfucb->ppib ), JET_errRollbackError );
		}

	return err;
	}


//  ================================================================
SLVSPACENODE::SLVSPACENODE()
//  ================================================================
	{
	//  do not initialize any member variables so that we can
	//  use placement new
	}

	
//  ================================================================
SLVSPACENODE::~SLVSPACENODE()
//  ================================================================
	{
	ASSERT_VALID( this );	
	}
	

//  ================================================================
VOID SLVSPACENODE::EnforcePageState( const LONG ipage, const LONG cpg, const STATE state ) const
//  ================================================================
	{
	INT ipageT;
	for( ipageT = ipage; ipageT < ipage + cpg; ++ipageT )
		{
		const STATE stateReal = GetState_( ipageT );
		if( stateReal != state )
			{
			const CHAR * rgsz[2];
			INT irgsz = 0;

			CHAR szStateExpected[16];
			CHAR szStateActual[16];

			sprintf( szStateExpected, "%d", state );
			sprintf( szStateActual, "%d", stateReal );
			
			rgsz[irgsz++] = szStateExpected;
			rgsz[irgsz++] = szStateActual;
			
			UtilReportEvent(	eventError,
								DATABASE_CORRUPTION_CATEGORY,
								CORRUPT_SLV_SPACE_ID,
								irgsz,
								rgsz );
								
			EnforceSz( fFalse, "SLVSPACENODE::EnforcePageState" );
			}
		}
	}


#if defined( DEBUG ) || !defined( RTM )
//  ================================================================
VOID SLVSPACENODE::AssertPageState( const LONG ipage, const LONG cpg, const STATE state ) const
//  ================================================================
	{
	INT ipageT;
	for( ipageT = ipage; ipageT < ipage + cpg; ++ipageT )
		{
		const STATE stateReal = GetState_( ipageT );
		Assert( state == stateReal );
		}
	}


//  ================================================================
VOID SLVSPACENODE::AssertValid() const
//  ================================================================
	{
	Assert( m_cpgAvail >= 0 );
	Assert( m_cpgAvail <= SLVSPACENODE::cpageMap );
	Assert( 0 == m_cpgAvailLargestContig );
	INT cpgAvail = 0;
	INT ipage;
	for( ipage = 0; ipage < SLVSPACENODE::cpageMap; ++ipage )
		{
		const STATE state = GetState_( ipage );
		Assert( sFree == state
				|| sReserved == state
				|| sDeleted == state
				|| sCommitted == state );
		if( sFree == state )
			{
			++cpgAvail;
			}
		}
	Assert( m_cpgAvail == cpgAvail );
	}
	

//  ================================================================
VOID SLVSPACENODE::Test()
//  ================================================================
	{
	Assert( 0x0 == sFree );
	Assert( 0x3 == sCommitted );
	
	SLVSPACENODE slvspacenode;
	slvspacenode.Init();
	INT ipage;
	INT ipageT;

	//  FREE => RESERVED => COMMITTED => DELETED
	for( ipage = SLVSPACENODE::cpageMap - 1; ipage >= 0; --ipage )
		{
		Assert( slvspacenode.CpgAvail() == ipage + 1 );
		Assert( slvspacenode.GetState( ipage ) == sFree );
		slvspacenode.Reserve( ipage, 1 );
		Assert( slvspacenode.GetState( ipage ) == sReserved );
		Assert( slvspacenode.CpgAvail() == ipage );
		slvspacenode.CommitFromReserved( ipage, 1 );
		Assert( slvspacenode.GetState( ipage ) == sCommitted );
		Assert( slvspacenode.CpgAvail() == ipage );
		slvspacenode.DeleteFromCommitted( ipage, 1 );
		Assert( slvspacenode.GetState( ipage ) == sDeleted );
		Assert( slvspacenode.CpgAvail() == ipage );
		}

	//  DELETED => FREE
	for( ipage = 0; ipage < SLVSPACENODE::cpageMap; ++ipage )
		{
		Assert( slvspacenode.CpgAvail() == ipage );
		slvspacenode.Free( ipage, 1 );
		Assert( slvspacenode.GetState( ipage ) == sFree );
		Assert( slvspacenode.CpgAvail() == ipage + 1 );
		}

	//  FREE => COMMITTED
	slvspacenode.CommitFromFree( 0, SLVSPACENODE::cpageMap );
	slvspacenode.AssertPageState( 0, SLVSPACENODE::cpageMap, sCommitted );
	Assert( 0 == slvspacenode.CpgAvail() );

	//  COMMITTED => FREE
	slvspacenode.Free( 0, SLVSPACENODE::cpageMap );
	slvspacenode.AssertPageState( 0, SLVSPACENODE::cpageMap, sFree );
	Assert( SLVSPACENODE::cpageMap == slvspacenode.CpgAvail() );

	//  IpageFirstFree
	//  move every node to the committed state and free each one separately
	slvspacenode.CommitFromFree( 0, SLVSPACENODE::cpageMap );
	slvspacenode.AssertPageState( 0, SLVSPACENODE::cpageMap, sCommitted );
	Assert( 0 == slvspacenode.CpgAvail() );

	for( ipage = 0; ipage < SLVSPACENODE::cpageMap; ++ipage )
		{
		slvspacenode.Free( ipage, 1 );
		const LONG ipageFree = slvspacenode.IpageFirstFree();
		Assert( ipageFree == ipage );
		slvspacenode.CommitFromFree( ipage, 1 );
		}

	//  IpageFirstReservedOrDeleted & IpageFirstCommitted
	//  move every node to the free state and commit
	ipageT = slvspacenode.IpageFirstReservedOrDeleted();
	Assert( SLVSPACENODE::cpageMap == ipageT );	//  all nodes are committed

	slvspacenode.Free( 0, SLVSPACENODE::cpageMap );
	slvspacenode.AssertPageState( 0, SLVSPACENODE::cpageMap, sFree );
	Assert( SLVSPACENODE::cpageMap == slvspacenode.CpgAvail() );

	ipageT = slvspacenode.IpageFirstReservedOrDeleted();
	Assert( SLVSPACENODE::cpageMap == ipageT );	//  all nodes are free

	for( ipage = 0; ipage < SLVSPACENODE::cpageMap; ++ipage )
		{
		LONG ipageFirstReservedOrDeleted;
		LONG ipageFirstCommitted;
		
		slvspacenode.Reserve( ipage, 1 );
		ipageFirstReservedOrDeleted = slvspacenode.IpageFirstReservedOrDeleted();
		Assert( ipageFirstReservedOrDeleted == ipage );
		
		slvspacenode.CommitFromReserved( ipage, 1 );
		ipageFirstCommitted = slvspacenode.IpageFirstCommitted();
		Assert( ipageFirstCommitted == ipage );		
		
		slvspacenode.DeleteFromCommitted( ipage, 1 );
		ipageFirstReservedOrDeleted = slvspacenode.IpageFirstReservedOrDeleted();
		Assert( ipageFirstReservedOrDeleted == ipage );		

		slvspacenode.Free( ipage, 1 );
		}	
	
	}
#endif //  DEBUG \\ !RTM


//  ================================================================
VOID SLVSPACENODE::Init()
//  ================================================================
	{
	m_cpgAvail 				= SLVSPACENODE::cpageMap;
	m_cpgAvailLargestContig = 0;	//	not currently maintained
	m_ulFlags				= 0;
	memset( m_rgbMap, 0x00, SLVSPACENODE::cbMap );
	ASSERT_VALID( this );
	}


//  ================================================================
LONG SLVSPACENODE::CpgAvail() const
//  ================================================================
	{
	ASSERT_VALID( this );	
	return m_cpgAvail;
	}


//  ================================================================
SLVSPACENODE::STATE SLVSPACENODE::GetState( const ULONG ipage ) const
//  ================================================================
	{
	Assert( ipage < SLVSPACENODE::cpageMap );
	ASSERT_VALID( this );	
	return GetState_( ipage );
	}


//  ================================================================
LONG SLVSPACENODE::IpageFirstFree() const
//  ================================================================
//
//  Returns the index of the first free page. Search by DWORDs for
//  speed
//
//  A DWORD contains 16 pairs of bits. We are looking for a pair where
//  both bits are zero. We shift the top bit of each pair down by one,
//  OR with the lower bits of each pair and set the unused bits to 0.
//  By comparing the results with the result if all pages were used
//  we can quickly determine if at least one page is free.
//
//  We then use a loop to find the first free page
//
//-
	{
	ASSERT_VALID( this );
	Assert( 0x00 == sFree );
	Assert( cbMap % sizeof( DWORD ) == 0 );
	Assert( 0 != m_cpgAvail );	//	don't call this if there aren't any free pages
	INT idw;
	for( idw = 0; idw < cbMap / sizeof( DWORD ); ++idw )
		{
		const DWORD dwMaskLowBits	= 0x55555555;	//	only the low bits of each pair
		const DWORD dw 				= ((UnalignedLittleEndian< DWORD > *)m_rgbMap)[idw];
		DWORD dwPairs 				= ( dw | ( dw >> 1 ) );
		if(  ( dwPairs & dwMaskLowBits ) != dwMaskLowBits )
			{
			INT ipageInDword;
			for( ipageInDword = 0; ipageInDword < cpagesInDword; ++ipageInDword )
				{
				if( !( dwPairs & 1 ) )
					{
					//  this page is free
					return ipageInDword + ( idw * cpagesInDword );
					}
				dwPairs >>= 2;
				}
			Assert( fFalse );
			}
		}
	Assert( fFalse );
	return idw * cpagesInDword;
	}


//  ================================================================
LONG SLVSPACENODE::IpageFirstCommitted() const
//  ================================================================
//
//  Returns the index of the first committed page. Search by DWORDs for
//  speed
//
//  A DWORD contains 16 pairs of bits. We are looking for a pair where
//  both bits are one. We shift the top bit of each pair down by one,
//  AND with the lower bits of each pair and set the unused bits to 0.
//  By comparing the result with 0 we can quickly determine if at least
//  one page is free committed
//
//  We then use a loop to find the first committed page
//
//-
	{
	ASSERT_VALID( this );
	Assert( 0x03 == sCommitted );
	Assert( cbMap % sizeof( DWORD ) == 0 );
	INT idw;
	for( idw = 0; idw < cbMap / sizeof( DWORD ); ++idw )
		{
		const DWORD dwMaskLowBits	= 0x55555555;	//	only the low bits of each pair
		const DWORD dw 				= ((UnalignedLittleEndian< DWORD > *)m_rgbMap)[idw];
		DWORD dwPairs 				= ( dw & ( dw >> 1 ) ) & dwMaskLowBits;
		if( dwPairs != 0 )
			{
			
			//  at least one of the pages in this DWORD is committed
			
			INT ipageInDword;
			for( ipageInDword = 0; ipageInDword < cpagesInDword; ++ipageInDword )
				{
				if( dwPairs & 0x1 )
					{
					//  this page is committed
					return ipageInDword + ( idw * cpagesInDword );
					}
				dwPairs >>= 2;
				}
			}
		}
	return idw * cpagesInDword;
	}


//  ================================================================
LONG SLVSPACENODE::IpageFirstReservedOrDeleted() const
//  ================================================================
//
//  Returns the index of the first reserved or deleted page.
//  Search by DWORDs for speed
//
//  A DWORD contains 16 pairs of bits. We are looking for a pair where
//  both bits are different. We shift the top bit of each pair down by one,
//  XOR with the lower bits of each pair and set the unused bits to 0.
//  By comparing the results with the result if all pairs had the same bits
//  (i.e. 0) we can quickly determine if at least one page is reserved/deleted.
//
//  We then use a loop to find the first free page
//
//-
	{
	ASSERT_VALID( this );
	Assert( 0x01 == sReserved );
	Assert( 0x02 == sDeleted );
	Assert( cbMap % sizeof( DWORD ) == 0 );
	INT idw;
	for( idw = 0; idw < cbMap / sizeof( DWORD ); ++idw )
		{
		const DWORD dwMaskLowBits	= 0x55555555;	//	only the low bits of each pair
		const DWORD dw 				= ((UnalignedLittleEndian< DWORD > *)m_rgbMap)[idw];
		DWORD dwPairs 				= ( dw ^ ( dw >> 1 ) );
		if( ( dwPairs & dwMaskLowBits ) != 0 )
			{
			INT ipageInDword;
			for( ipageInDword = 0; ipageInDword < cpagesInDword; ++ipageInDword )
				{
				if( dwPairs & 1 )
					{
					//  this page is free
					return ipageInDword + ( idw * cpagesInDword );
					}
				dwPairs >>= 2;
				}
			Assert( fFalse );
			}
		}
	return idw * cpagesInDword;
	}


//  ================================================================
ERR SLVSPACENODE::ErrCheckNode( CPRINTF * pcprintfError ) const
//  ================================================================
	{
	ERR err = JET_errSuccess;
	
	LONG ipage;
	LONG cpgAvail;
	for( ipage = 0, cpgAvail = 0; ipage < SLVSPACENODE::cpageMap; ++ipage )
		{
		const SLVSPACENODE::STATE state = GetState( ipage );
		if( SLVSPACENODE::sFree == state )
			{
			++cpgAvail;
			}
		}

	if( CpgAvail() != cpgAvail )
		{
		(*pcprintfError)( "SLVSPACENODE: cpgAvail is wrong (%d, expected %d)\r\n", CpgAvail(), cpgAvail );
		CallR( ErrERRCheck( JET_errDatabaseCorrupted ) );
		}

	return err;
	}


//  ================================================================
ERR SLVSPACENODE::ErrGetFreePagesFromExtent(
	FUCB		*pfucbSLVAvail,
	PGNO		*ppgnoFirst,			//	initially pass in first page of extent, pass NULL for subsequent extents
	CPG			*pcpgReq,
	const BOOL	fReserveOnly )
//  ================================================================
//
//	first the first range of free pages within this extent
//
//-
	{
	CPG			cpgReq			= *pcpgReq;
	UINT		ipageFirst;

	//	must be in transaction because caller will be required to rollback on failure
	Assert( pfucbSLVAvail->ppib->level > 0 );

	Assert( latchWrite == Pcsr( pfucbSLVAvail )->Latch() );

	Assert( NULL == ppgnoFirst || pgnoNull != *ppgnoFirst );

	Assert( cpgReq > 0 );
	*pcpgReq = 0;

	Assert( NULL == ppgnoFirst || CpgAvail() > 0 );

	if ( cpgSLVExtent == CpgAvail() )
		{
		//	special case: entire page free
		ipageFirst = 0;
		*pcpgReq = min( cpgReq, cpgSLVExtent );
		}
	else
		{
		UINT	ipage;

		if ( NULL != ppgnoFirst )
			{
			ipage	= IpageFirstFree();
			}
		else if ( sFree != GetState( 0 ) )
			{
			//	this is not the first extent, so can't do anything because first
			//	page in this extent is not free
			Assert( 0 == *pcpgReq );
			return JET_errSuccess;
			}
		else
			{
			ipage = 0;
			}
	
#ifdef DEBUG
		INT ipageT;
		for ( ipageT = 0; sFree != GetState( ipageT ); ipageT++ )
			{
			//	something drastically wrong if we fall off the
			//	end of the map without finding any free pages
			Assert( ipageT < cpageMap );
			}
		Assert( ipageT == ipage );
#endif	//	DEBUG

		for ( ipageFirst = ipage;
			ipage < cpageMap && sFree == GetState( ipage ) && (*pcpgReq) < cpgReq;
			ipage++ )
			{
			(*pcpgReq)++;
			}

		Assert( ipageFirst < cpageMap );
		Assert( *pcpgReq > 0 );

		if ( NULL != ppgnoFirst )
			{
			*ppgnoFirst += ipageFirst;
			}
		else
			{
			Assert( 0 == ipageFirst );
			}
		}


	Assert( ipageFirst < cpageMap );
	Assert( *pcpgReq > 0 );
	Assert( *pcpgReq <= cpgReq );

	// That's no need to update SLV OwnerMap as long as
	// the pages are not entering or exiting the sCommit status
	// The operation here is slvspaceoperFreeToReserved or slvspaceoperFreeToCommitted,

	const ERR	err		= ErrBTMungeSLVSpace(
								pfucbSLVAvail,
								fReserveOnly ? slvspaceoperFreeToReserved : slvspaceoperFreeToCommitted,
								ipageFirst,
								*pcpgReq,
								fDIRNull );

								
	return err;
	}


//  ================================================================
VOID SLVSPACENODE::CheckFree( const LONG ipage, const LONG cpg ) const
//  ================================================================
	{
	Assert( ipage >= 0 );
	Assert( ipage < SLVSPACENODE::cpageMap );
	Assert( cpg > 0 );
	Assert( cpg <= SLVSPACENODE::cpageMap );
	ASSERT_VALID( this );	
	
	//  we should not be freeing an already freed page
	INT ipageT;
	for( ipageT = ipage; ipageT < ipage + cpg; ++ipageT )
		{
		const STATE sReal = GetState_( ipageT );
		if( sFree == sReal )
			{
			const CHAR * rgsz[2];
			INT irgsz = 0;

			CHAR szStateExpected[16];
			CHAR szStateActual[16];

			sprintf( szStateExpected, "%d", sFree );
			sprintf( szStateActual, "%d", sReal );
			
			rgsz[irgsz++] = szStateExpected;
			rgsz[irgsz++] = szStateActual;
			
			UtilReportEvent(	eventError,
								DATABASE_CORRUPTION_CATEGORY,
								CORRUPT_SLV_SPACE_ID,
								irgsz,
								rgsz );
								
			EnforceSz( fFalse, "SLV Space Map corrupted" );
			}
		}
	}


//  ================================================================
VOID SLVSPACENODE::CheckFreeReserved( const LONG ipage, const LONG cpg ) const
//  ================================================================
//
//  When freeing from the reserved state some of the pages in the 
//  SLVSPACENODE may have been freed already by a rollback from the
//  committed state.
//
//-
	{
	Assert( ipage >= 0 );
	Assert( ipage < SLVSPACENODE::cpageMap );
	Assert( cpg > 0 );
	Assert( cpg <= SLVSPACENODE::cpageMap );
	ASSERT_VALID( this );	

	//  we should not be freeing a deleted page
	//  committed pages should have been rolled back already
	INT ipageT;
	for( ipageT = ipage; ipageT < ipage + cpg; ++ipageT )
		{
		const STATE sReal = GetState_( ipageT );
		if( sDeleted == sReal
			|| sCommitted == sReal )
			{
			const CHAR * rgsz[2];
			INT irgsz = 0;

			CHAR szStateExpected[16];
			CHAR szStateActual[16];

			sprintf( szStateExpected, "%d", sFree );
			sprintf( szStateActual, "%d", sReal );
			
			rgsz[irgsz++] = szStateExpected;
			rgsz[irgsz++] = szStateActual;
			
			UtilReportEvent(	eventError,
								DATABASE_CORRUPTION_CATEGORY,
								CORRUPT_SLV_SPACE_ID,
								irgsz,
								rgsz );
								
			EnforceSz( fFalse, "SLV Space Map corrupted" );
			}
		}

	}


//  ================================================================
VOID SLVSPACENODE::CheckReserve( const LONG ipage, const LONG cpg ) const
//  ================================================================
	{
	Assert( ipage >= 0 );
	Assert( ipage < SLVSPACENODE::cpageMap );
	Assert( cpg > 0 );
	Assert( cpg <= SLVSPACENODE::cpageMap );
	ASSERT_VALID( this );	
	
	EnforcePageState( ipage, cpg, sFree );
	}


//  ================================================================
VOID SLVSPACENODE::CheckCommitFromFree( const LONG ipage, const LONG cpg ) const
//  ================================================================
	{
	Assert( ipage >= 0 );
	Assert( ipage < SLVSPACENODE::cpageMap );
	Assert( cpg > 0 );
	Assert( cpg <= SLVSPACENODE::cpageMap );
	ASSERT_VALID( this );	
	
	EnforcePageState( ipage, cpg, sFree );
	}


//  ================================================================
VOID SLVSPACENODE::CheckCommitFromReserved( const LONG ipage, const LONG cpg ) const
//  ================================================================
	{
	Assert( ipage >= 0 );
	Assert( ipage < SLVSPACENODE::cpageMap );
	Assert( cpg > 0 );
	Assert( cpg <= SLVSPACENODE::cpageMap );
	ASSERT_VALID( this );	
	
	EnforcePageState( ipage, cpg, sReserved );
	}


//  ================================================================
VOID SLVSPACENODE::CheckCommitFromDeleted( const LONG ipage, const LONG cpg ) const
//  ================================================================
	{
	Assert( ipage >= 0 );
	Assert( ipage < SLVSPACENODE::cpageMap );
	Assert( cpg > 0 );
	Assert( cpg <= SLVSPACENODE::cpageMap );
	ASSERT_VALID( this );	
	
	EnforcePageState( ipage, cpg, sDeleted );
	}


//  ================================================================
VOID SLVSPACENODE::CheckDeleteFromCommitted( const LONG ipage, const LONG cpg ) const
//  ================================================================
	{
	Assert( ipage >= 0 );
	Assert( ipage < SLVSPACENODE::cpageMap );
	Assert( cpg > 0 );
	Assert( cpg <= SLVSPACENODE::cpageMap );
	ASSERT_VALID( this );	
	
	EnforcePageState( ipage, cpg, sCommitted );
	}


//  ================================================================
VOID SLVSPACENODE::Free( const LONG ipage, const LONG cpg )
//  ================================================================
	{
	Assert( ipage >= 0 );
	Assert( ipage < SLVSPACENODE::cpageMap );
	Assert( cpg > 0 );
	Assert( cpg <= SLVSPACENODE::cpageMap );
	ASSERT_VALID( this );	

#ifdef DEBUG	//	checked already by CheckFree
	//  we should not be freeing an already freed page
	INT ipageT;
	for( ipageT = ipage; ipageT < ipage + cpg; ++ipageT )
