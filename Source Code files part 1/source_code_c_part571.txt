*
 *  @parm   HWND | hwndOwner |
 *
 *          Owner window (if modal).
 *
 *  @parm   DWORD | fl |
 *
 *          Flags.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP
CNil_RunControlPanel(PDICB pdcb, HWND hwndOwner, DWORD fl)
{
    /*
     *  This may legitimately be called, because it comes from
     *  a client calling IDirectInputDevice::RunControlPanel.
     */
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}


/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | CookDeviceData |
 *
 *          Cook a piece of device data that was obtained from the
 *          data buffer.  This data does not pass through the device
 *          callback, so it needs to be cooked externally.  In
 *          comparison, device state information is obtained via
 *          DIDM_GETDEVICESTATE, which the callback can cook before
 *          returning.
 *
 *          If the callback returns E_NOTIMPL, then the caller is
 *          permitted to cache the result <y for the entire device>
 *          (not merely for the device object) until the next DIDM_ACQUIRE.
 *
 *  @parm   DWORD | cdod |
 *
 *          Number of objects to cook.  This can be zero, in which case
 *          the caller is checking whether the device requires cooking.
 *
 *  @parm   LPDIDEVICEOBJECTDATA | rgdod |
 *
 *          Array of object data to cook.
 *
 *          Note, however, that the <e DIDEVICEOBJETCDATA.dwOfs> fields
 *          are not what you think.  The low word contains the application
 *          data offset (which is not important to the callback); the
 *          high word contains the object ID (traditionally called the
 *          "device type" code).
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP
CNil_CookDeviceData(PDICB pdcb, DWORD cdod, LPDIDEVICEOBJECTDATA rgdod)
{
    /*
     *  This should never happen; we don't get called until we're sure
     *  it's okay.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | CreateEffect |
 *
 *          Create an <i IDirectInputEffectDriver> callback.
 *
 *  @parm   LPDIRECTINPUTEFFECTSHEPHERD * | ppes |
 *
 *          Receives the shepherd for the effect driver.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP
CNil_CreateEffect(PDICB pdcb, LPDIRECTINPUTEFFECTSHEPHERD *ppes)
{
    /*
     *  This may legitimately be called, because it comes from
     *  a client calling a force feedback method.
     */
    *ppes = 0;
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | GetFFConfigKey |
 *
 *          Returns a handle to the registry key which contains
 *          force feedback configuration information.
 *
 *  @parm   DWORD | sam |
 *
 *          Security access mask.
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives key handle on success.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP
CNil_GetFFConfigKey(PDICB pdcb, DWORD sam, PHKEY phk)
{
    /*
     *  This should never happen; we don't get called until we're sure
     *  it's okay.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | SendDeviceData |
 *
 *          Spew some data to the device.
 *
 *  @parm   DWORD | cbdod |
 *
 *          Size of each object.
 *
 *  @parm   IN LPCDIDEVICEOBJECTDATA | rgdod |
 *
 *          Array of <t DIDEVICEOBJECTDATA> structures.
 *
 *  @parm   INOUT LPDWORD | pdwInOut |
 *
 *          Number of items actually sent.
 *
 *  @parm   DWORD | fl |
 *
 *          Flags.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 *****************************************************************************/

STDMETHODIMP
CNil_SendDeviceData(PDICB pdcb, DWORD cbdod, LPCDIDEVICEOBJECTDATA rgdod,
                       LPDWORD pdwInOut, DWORD fl)
{
    /*
     *  This should never happen; we don't get called until we're sure
     *  it's okay.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | Poll |
 *
 *          Poll the device as necessary.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP
CNil_Poll(PDICB pdcb)
{
    /*
     *  This should never happen; we don't get called until we're sure
     *  it's okay.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | MapUsage |
 *
 *          Given a usage and usage page (munged into a single
 *          <t DWORD>), find a device object that matches it.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP
CNil_MapUsage(PDICB pdcb, DWORD dwUsage, PINT piOut)
{
    /*
     *  This should never happen; we don't get called until we're sure
     *  it's okay.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method DWORD | CNil | GetUsage |
 *
 *          Given an object index, return the usage and usage page,
 *          packed into a single <t DWORD>.
 *
 *  @parm   int | iobj |
 *
 *          Object index to be converted.
 *
 *  @returns
 *
 *          Zero because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP_(DWORD)
CNil_GetUsage(PDICB pdcb, int iobj)
{
    /*
     *  This should never happen; we don't get called until we're sure
     *  it's okay.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return 0;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method DWORD | CNil | SetDIData |
 *
 *          Set DirectInput version from CDIDev *.
 *
 *  @parm   DWORD | dwVer |
 *
 *          DirectInput version
 *
 *  @parm   LPVOID | lpdihacks |
 *
 *          AppHack data
 *
 *  @returns
 *
 *          Zero because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP
CNil_SetDIData(PDICB pdcb, DWORD dwVer, LPVOID lpdihacks)
{
    /*
     *  This should never happen; we don't get called until we're sure
     *  it's okay.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return 0;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | BuildDefaultActionMap |
 *
 *          Validate the passed action map, blanking out invalid ones.
 *
 *  @parm   LPDIACTIONFORMATW | pActionFormat |
 *
 *          Actions to map.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags used to indicate mapping preferences.
 *
 *  @parm   REFGUID | guidInst |
 *
 *          Device instance GUID.
 *
 *  @returns
 *
 *          <c E_NOTIMPL> 
 *
 *****************************************************************************/

STDMETHODIMP
CNil_BuildDefaultActionMap
(
    PDICB               pdcb, 
    LPDIACTIONFORMATW   paf, 
    DWORD               dwFlags, 
    REFGUID             guidInst
)
{
    /*
     *  This should never happen; we don't get called until we're sure
     *  it's okay.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}


/****************************************************************************
 *
 *      Our VTBL for our static object
 *
 ***************************************************************************/

#pragma BEGIN_CONST_DATA

IDirectInputDeviceCallbackVtbl c_vtblNil = {
    CNil_QueryInterface,
    CNil_AddRef,
    CNil_Release,
    CNil_GetInstance,
    CDefDcb_GetVersions,
    CNil_GetDataFormat,
    CNil_GetObjectInfo,
    CNil_GetCapabilities,
    CNil_Acquire,
    CNil_Unacquire,
    CNil_GetDeviceState,
    CNil_GetDeviceInfo,
    CNil_GetProperty,
    CNil_SetProperty,
    CNil_SetEventNotification,
    CNil_SetCooperativeLevel,
    CNil_RunControlPanel,
    CNil_CookDeviceData,
    CNil_CreateEffect,
    CNil_GetFFConfigKey,
    CNil_SendDeviceData,
    CNil_Poll,
    CNil_GetUsage,
    CNil_MapUsage,
    CNil_SetDIData,
    CNil_BuildDefaultActionMap,
};

IDirectInputDeviceCallback c_dcbNil = {
    &c_vtblNil,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\digenm.c ===
/*****************************************************************************
 *
 *  DIGenM.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Practice generic IDirectInputDevice callback for mouse.
 *
 *  Contents:
 *
 *      CMouse_New
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflMouse

/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *****************************************************************************/

Primary_Interface(CMouse, IDirectInputDeviceCallback);

Interface_Template_Begin(CMouse)
    Primary_Interface_Template(CMouse, IDirectInputDeviceCallback)
Interface_Template_End(CMouse)

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global DIOBJECTDATAFORMAT | c_rgodfMouse[] |
 *
 *          Device object data formats for the generic mouse device.
 *          The axes come first, then the buttons.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define MAKEODF(guid, f, type, inst, aspect)                \
    { &GUID_##guid,                                         \
      FIELD_OFFSET(DIMOUSESTATE_INT, f),                        \
      DIDFT_##type | DIDFT_MAKEINSTANCE(inst),              \
      DIDOI_ASPECT##aspect,                                 \
    }                                                       \

/*
 * Warning!  If you change this table, you must adjust the IDS_MOUSEOBJECT
 * table in dinput.rc to match!
 */

DIOBJECTDATAFORMAT c_rgodfMouse[] = {
    MAKEODF( XAxis,            lX,   RELAXIS, 0, POSITION),
    MAKEODF( YAxis,            lY,   RELAXIS, 1, POSITION),
    MAKEODF( ZAxis,            lZ,   RELAXIS, 2, POSITION),
    MAKEODF(Button, rgbButtons[0], PSHBUTTON, 3,  UNKNOWN),
    MAKEODF(Button, rgbButtons[1], PSHBUTTON, 4,  UNKNOWN),
    MAKEODF(Button, rgbButtons[2], PSHBUTTON, 5,  UNKNOWN),
    MAKEODF(Button, rgbButtons[3], PSHBUTTON, 6,  UNKNOWN),
    MAKEODF(Button, rgbButtons[4], PSHBUTTON, 7,  UNKNOWN),
    MAKEODF(Button, rgbButtons[5], PSHBUTTON, 8,  UNKNOWN),
    MAKEODF(Button, rgbButtons[6], PSHBUTTON, 9,  UNKNOWN),
    MAKEODF(Button, rgbButtons[7], PSHBUTTON,10,  UNKNOWN),
};

#define c_podfMouseAxes     (&c_rgodfMouse[0])
#define c_podfMouseButtons  (&c_rgodfMouse[3])

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CMouse |
 *
 *          The <i IDirectInputDeviceCallback> object for the generic mouse.
 *
 *  @field  IDirectInputDeviceCalllback | didc |
 *
 *          The object (containing vtbl).
 *
 *  @field  LPDIMOUSESTATE_INT | pdmsPhys |
 *
 *          Pointer to physical mouse status information kept down in the
 *          VxD.
 *
 *  @field  POINT | ptPrev |
 *
 *          Location of the mouse at the time we stole it exclusively.
 *
 *  @field  HWND | hwndCaptured |
 *
 *          The window that captured the mouse.
 *
 *  @field  VXDINSTANCE * | pvi |
 *
 *          The DirectInput instance handle.  Even though we manipulate
 *          the flags field, we do not need to mark it volatile because
 *          we modify the flags only when unacquired, whereas the device
 *          driver modifies the flags only when acquired.
 *
 *  @field  UINT | dwAxes |
 *
 *          Number of axes on the mouse.
 *
 *  @field  UINT | dwButtons |
 *
 *          Number of buttons on the mouse.
 *
 *  @field  DWORD | flEmulation |
 *
 *          The emulation flags forced by the application.  If any of
 *          these flags is set (actually, at most one will be set), then
 *          we are an alias device.
 *
 *  @field  DIDATAFORMAT | df |
 *
 *          The dynamically-generated data format based on the
 *          mouse type.
 *
 *  @field  DIOBJECTDATAFORMAT | rgodf[] |
 *
 *          Object data format table generated as part of the
 *          <e CMouse.df>.
 *
 *  @comm
 *
 *          It is the caller's responsibility to serialize access as
 *          necessary.
 *
 *****************************************************************************/

typedef struct CMouse {

    /* Supported interfaces */
    IDirectInputDeviceCallback dcb;

    LPDIMOUSESTATE_INT pdmsPhys;            /* Physical mouse state */

    POINT ptPrev;
    HWND hwndCapture;

    VXDINSTANCE *pvi;

    UINT dwAxes;
    UINT dwButtons;
    DWORD flEmulation;

    DIDATAFORMAT df;
    DIOBJECTDATAFORMAT rgodf[cA(c_rgodfMouse)];

} CMouse, DM, *PDM;

#define ThisClass CMouse
#define ThisInterface IDirectInputDeviceCallback
#define riidExpected &IID_IDirectInputDeviceCallback

/*****************************************************************************
 *
 *      CMouse::QueryInterface      (from IUnknown)
 *      CMouse::AddRef              (from IUnknown)
 *      CMouse::Release             (from IUnknown)
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @returns
 *
 *      Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | QIHelper |
 *
 *      We don't have any dynamic interfaces and simply forward
 *      to <f Common_QIHelper>.
 *
 *  @parm   IN REFIID | riid |
 *
 *      The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *      Receives a pointer to the obtained interface.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | AppFinalize |
 *
 *          We don't have any weak pointers, so we can just
 *          forward to <f Common_Finalize>.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released from the application's perspective.
 *
 *****************************************************************************/

#ifdef DEBUG

Default_QueryInterface(CMouse)
Default_AddRef(CMouse)
Default_Release(CMouse)

#else

#define CMouse_QueryInterface   Common_QueryInterface
#define CMouse_AddRef           Common_AddRef
#define CMouse_Release          Common_Release

#endif

#define CMouse_QIHelper         Common_QIHelper
#define CMouse_AppFinalize      Common_AppFinalize

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CMouse_Finalize |
 *
 *          Releases the resources of the device.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
CMouse_Finalize(PV pvObj)
{
    PDM this = pvObj;

    if (this->pvi) {
        HRESULT hres;
        hres = Hel_DestroyInstance(this->pvi);
        AssertF(SUCCEEDED(hres));
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CMouse | GetPhysicalPosition |
 *
 *          Read the physical mouse position into <p pmstOut>.
 *
 *          Note that it doesn't matter if this is not atomic.
 *          If a mouse motion occurs while we are reading it,
 *          we will get a mix of old and new data.  No big deal.
 *
 *  @parm   PDM | this |
 *
 *          The object in question.
 *
 *  @parm   LPDIMOUSESTATE_INT | pdmsOut |
 *
 *          Where to put the mouse position.
 *  @returns
 *          None.
 *
 *****************************************************************************/

void INLINE
CMouse_GetPhysicalPosition(PDM this, LPDIMOUSESTATE_INT pdmsOut)
{
    AssertF(this->pdmsPhys);
    *pdmsOut = *this->pdmsPhys;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | Acquire |
 *
 *          Tell the device driver to begin data acquisition.
 *          Give the device driver the current mouse button states
 *          in case it needs them.
 *
 *          It is the caller's responsibility to have set the
 *          data format before obtaining acquisition.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c S_FALSE>: The operation was begun and should be completed
 *          by the caller by communicating with the <t VXDINSTANCE>.
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_Acquire(PDICB pdcb)
{
    HRESULT hres;
    PDM this;
    VXDDWORDDATA vdd;
    DWORD mef;
    EnterProcI(IDirectInputDeviceCallback::Mouse::Acquire,
               (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);

    vdd.pvi = this->pvi;
    vdd.dw = 0;

    /*
     *  Collect information about which buttons are down.
     */
    mef = 0;
    if (GetAsyncKeyState(VK_LBUTTON) < 0) {
        mef |= MOUSEEVENTF_LEFTUP;
        vdd.dw |= 0x80;
    }
    if (GetAsyncKeyState(VK_RBUTTON) < 0) {
        mef |= MOUSEEVENTF_RIGHTUP;
        vdd.dw |= 0x8000;
    }
    if (GetAsyncKeyState(VK_MBUTTON) < 0) {
        mef |= MOUSEEVENTF_MIDDLEUP;
        vdd.dw |= 0x800000;
    }

    /*
     *  HACKHACK - This, strictly speaking, belongs in dihel.c,
     *  but we need to maintain some state, and it's easier to
     *  put the state in our own object.
     */

    /*
     *  A bit of work needs to be done at ring 3 now.
     */
    if (this->pvi->fl & VIFL_CAPTURED) {
        RECT rc;

        /*
         *  Hide the mouse cursor (for compatibility with NT emulation)
         */
        GetCursorPos(&this->ptPrev);
        GetWindowRect(this->hwndCapture, &rc);
        SetCursorPos((rc.left + rc.right) >> 1,
                     (rc.top + rc.bottom) >> 1);
        ShowCursor(0);

	    if (!(this->pvi->fl & VIFL_EMULATED)) {
			/*
			 *  Force all mouse buttons up from USER's point of view
			 *  to avoid "stuck mouse button" problems.  However, don't
			 *  force a button up unless it is actually down.
			 */
			if (mef) {
				mouse_event(mef, 0, 0, 0, 0);
			}
		}
    }

    if (!(this->pvi->fl & VIFL_EMULATED)) {
        hres = IoctlHw(IOCTL_MOUSE_INITBUTTONS, &vdd.dw, cbX(vdd.dw), 0, 0);
    } else {
      #ifdef USE_WM_INPUT
        if( g_fRawInput ) {
            hres = CDIRaw_Mouse_InitButtons();
        }
      #endif
        hres = CEm_Mouse_InitButtons(&vdd);
    }

    AssertF(SUCCEEDED(hres));

    hres = S_FALSE;                 /* Please finish for me */

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | Unacquire |
 *
 *          Tell the device driver to stop data acquisition.
 *
 *          It is the caller's responsibility to call this only
 *          when the device has been acquired.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c S_FALSE>: The operation was begun and should be completed
 *          by the caller by communicating with the <t VXDINSTANCE>.
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_Unacquire(PDICB pdcb)
{
    HRESULT hres;
    PDM this;
  #ifdef WANT_TO_FIX_MANBUG43879  
    DWORD mef;
  #endif
    EnterProcI(IDirectInputDeviceCallback::Mouse::Unacquire,
               (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);

  #ifdef WANT_TO_FIX_MANBUG43879
    /*
     *  Collect information about which buttons are down.
     */
    mef = 0;
    if (GetAsyncKeyState(VK_LBUTTON) < 0) {
        mef |= MOUSEEVENTF_LEFTUP;
    }
    if (GetAsyncKeyState(VK_RBUTTON) < 0) {
        mef |= MOUSEEVENTF_RIGHTUP;
    }
    if (GetAsyncKeyState(VK_MBUTTON) < 0) {
        mef |= MOUSEEVENTF_MIDDLEUP;
    }

    if (this->pvi->fl & VIFL_FOREGROUND) {
        /*
         *  Force all mouse buttons up from USER's point of view
         *  to avoid "stuck mouse button" problems.  However, don't
         *  force a button up unless it is actually down.
         *  This could happen if DInput loses UP events due to slow
         *  low-level hook. See bug: 43879.
         */
        if (mef) {
            mouse_event(mef, 0, 0, 0, 0);
        }
    }
  #endif

    /*
     *  HACKHACK - This is the corresponding half of the HACKHACK
     *  in CMouse_Acquire.
     */

    /*
     *  A bit of work needs to be done at ring 3 now.
     */
    if (this->pvi->fl & VIFL_CAPTURED) {
        RECT rcDesk;
        RECT rcApp;

        /*
         *  Reposition and restore the mouse cursor
         *  (for compatibility with NT emulation)
         *
         *  Do not reposition the mouse cursor if we lost to a
         *  window that covers the screen.  Otherwise, our
         *  repositioning will nuke the screen saver.
         */
        GetWindowRect(GetDesktopWindow(), &rcDesk);
        GetWindowRect(GetForegroundWindow(), &rcApp);
        SubtractRect(&rcDesk, &rcDesk, &rcApp);
        if (!IsRectEmpty(&rcDesk)) {
            SetCursorPos(this->ptPrev.x, this->ptPrev.y);
        }
        ShowCursor(1);
    }

    hres = S_FALSE;
    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | GetInstance |
 *
 *          Obtains the DirectInput instance handle.
 *
 *  @parm   OUT PPV | ppvi |
 *
 *          Receives the instance handle.
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_GetInstance(PDICB pdcb, PPV ppvi)
{
    HRESULT hres;
    PDM this;
    EnterProcI(IDirectInputDeviceCallback::Mouse::GetInstance, (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);
    *ppvi = (PV)this->pvi;
    hres = S_OK;

    ExitOleProcPpvR(ppvi);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | GetDataFormat |
 *
 *          Obtains the device's preferred data format.
 *
 *  @parm   OUT LPDIDEVICEFORMAT * | ppdf |
 *
 *          <t LPDIDEVICEFORMAT> to receive pointer to device format.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpmdr> parameter is not a valid pointer.
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_GetDataFormat(PDICB pdcb, LPDIDATAFORMAT *ppdf)
{
    HRESULT hres;
    PDM this;
    EnterProcI(IDirectInputDeviceCallback::Mouse::GetDataFormat,
               (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    *ppdf = &this->df;
    hres = S_OK;

    ExitOleProcPpvR(ppdf);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | GetDeviceInfo |
 *
 *          Obtain general information about the device.
 *
 *  @parm   OUT LPDIDEVICEINSTANCEW | pdiW |
 *
 *          <t DEVICEINSTANCE> to be filled in.  The
 *          <e DEVICEINSTANCE.dwSize> and <e DEVICEINSTANCE.guidInstance>
 *          have already been filled in.
 *
 *          Secret convenience:  <e DEVICEINSTANCE.guidProduct> is equal
 *          to <e DEVICEINSTANCE.guidInstance>.
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_GetDeviceInfo(PDICB pdcb, LPDIDEVICEINSTANCEW pdiW)
{
    HRESULT hres;
    PDM this;
    EnterProcI(IDirectInputDeviceCallback::Mouse::GetDeviceInfo,
               (_ "pp", pdcb, pdiW));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(IsValidSizeDIDEVICEINSTANCEW(pdiW->dwSize));

    AssertF(IsEqualGUID(&GUID_SysMouse   , &pdiW->guidInstance) ||
            IsEqualGUID(&GUID_SysMouseEm , &pdiW->guidInstance) ||
            IsEqualGUID(&GUID_SysMouseEm2, &pdiW->guidInstance));
    pdiW->guidProduct = GUID_SysMouse;

    pdiW->dwDevType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_MOUSE,
                                         DI8DEVTYPEMOUSE_UNKNOWN);

    LoadStringW(g_hinst, IDS_STDMOUSE, pdiW->tszProductName, cA(pdiW->tszProductName));
    LoadStringW(g_hinst, IDS_STDMOUSE, pdiW->tszInstanceName, cA(pdiW->tszInstanceName));

    hres = S_OK;

    ExitOleProcR();
    return hres;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CMouse | GetProperty |
 *
 *          Get a mouse device property.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being retrieved.
 *
 *  @parm   LPDIPROPHEADER | pdiph |
 *
 *          Structure to receive property value.
 *
 *  @returns
 *
 *          <c E_NOTIMPL> nothing happened.  The caller will do
 *          the default thing in response to <c E_NOTIMPL>.
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_GetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPDIPROPHEADER pdiph)
{
    HRESULT hres;
    PDM this;
    EnterProcI(IDirectInputDeviceCallback::Mouse::GetProperty,
               (_ "pxxp", pdcb, ppropi->pguid, ppropi->iobj, pdiph));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    /*
     *  Granularity is only supported for wheels.
     */
    if (ppropi->pguid == DIPROP_GRANULARITY &&
        ppropi->dwDevType == (DIDFT_RELAXIS | DIDFT_MAKEINSTANCE(2)) )
    {
        LPDIPROPDWORD pdipdw = (PV)pdiph;
        pdipdw->dwData = g_lWheelGranularity? (DWORD)g_lWheelGranularity : 120;
        hres = S_OK;
    }
    else
    {
        hres = E_NOTIMPL;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CMouse | GetCapabilities |
 *
 *          Get mouse device capabilities.
 *
 *  @parm   LPDIDEVCAPS | pdc |
 *
 *          Device capabilities structure to receive result.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_GetCapabilities(PDICB pdcb, LPDIDEVCAPS pdc)
{
    HRESULT hres;
    PDM this;
    EnterProcI(IDirectInputDeviceCallback::Mouse::GetCapabilities,
               (_ "pp", pdcb, pdc));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    pdc->dwDevType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_MOUSE,
                                        DI8DEVTYPEMOUSE_UNKNOWN);
    pdc->dwFlags = DIDC_ATTACHED;
    if (this->flEmulation) {
        pdc->dwFlags |= DIDC_ALIAS;
    }

    pdc->dwAxes = this->dwAxes;
    pdc->dwButtons = this->dwButtons;
    AssertF(pdc->dwPOVs == 0);

    hres = S_OK;
    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | GetDeviceState |
 *
 *          Obtains the state of the mouse device.
 *
 *          It is the caller's responsibility to have validated all the
 *          parameters and ensure that the device has been acquired.
 *
 *  @parm   OUT LPVOID | lpvData |
 *
 *          Mouse data in the preferred data format.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpmdr> parameter is not a valid pointer.
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_GetDeviceState(PDICB pdcb, LPVOID pvData)
{
    HRESULT hres;
    PDM this;
    EnterProcI(IDirectInputDeviceCallback::Mouse::GetDeviceState,
               (_ "pp", pdcb, pvData));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);
    AssertF(this->pdmsPhys);

    if (this->pvi->fl & VIFL_ACQUIRED) {
        CMouse_GetPhysicalPosition(this, pvData);
        hres = S_OK;
    } else {
        hres = DIERR_INPUTLOST;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | GetObjectInfo |
 *
 *          Obtain the friendly name of an object, passwed by index
 *          into the preferred data format.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the object being accessed.
 *
 *  @parm   IN OUT LPDIDEVICEOBJECTINSTANCEW | pdidioiW |
 *
 *          Structure to receive information.  The
 *          <e DIDEVICEOBJECTINSTANCE.guidType>,
 *          <e DIDEVICEOBJECTINSTANCE.dwOfs>,
 *          and
 *          <e DIDEVICEOBJECTINSTANCE.dwType>
 *          fields have already been filled in.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_GetObjectInfo(PDICB pdcb, LPCDIPROPINFO ppropi,
                                 LPDIDEVICEOBJECTINSTANCEW pdidoiW)
{
    HRESULT hres;
    PDM this;
    EnterProcI(IDirectInputDeviceCallback::Mouse::GetObjectInfo,
               (_ "pxp", pdcb, ppropi->iobj, pdidoiW));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(IsValidSizeDIDEVICEOBJECTINSTANCEW(pdidoiW->dwSize));

    if (ppropi->iobj < this->df.dwNumObjs) {
        AssertF(this->rgodf == this->df.rgodf);
        AssertF(ppropi->dwDevType == this->rgodf[ppropi->iobj].dwType);

        AssertF(DIDFT_GETTYPE(ppropi->dwDevType) == DIDFT_RELAXIS ||
                DIDFT_GETTYPE(ppropi->dwDevType) == DIDFT_PSHBUTTON);


        LoadStringW(g_hinst, IDS_MOUSEOBJECT +
                             DIDFT_GETINSTANCE(ppropi->dwDevType),
                             pdidoiW->tszName, cA(pdidoiW->tszName));

        /*
         *  We do not support force feedback on mice, so
         *  there are no FF flags to report.
         */
        hres = S_OK;
    } else {
        hres = E_INVALIDARG;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | SetCooperativeLevel |
 *
 *          Notify the device of the cooperative level.
 *
 *  @parm   IN HWND | hwnd |
 *
 *          The window handle.
 *
 *  @parm   IN DWORD | dwFlags |
 *
 *          The cooperativity level.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_SetCooperativeLevel(PDICB pdcb, HWND hwnd, DWORD dwFlags)
{
    HRESULT hres;
    PDM this;
    EnterProcI(IDirectInputDeviceCallback::Mouse::SetCooperativityLevel,
               (_ "pxx", pdcb, hwnd, dwFlags));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);

#ifdef USE_SLOW_LL_HOOKS
    AssertF(DIGETEMFL(this->pvi->fl) == 0 ||
            DIGETEMFL(this->pvi->fl) == DIEMFL_MOUSE ||
            DIGETEMFL(this->pvi->fl) == DIEMFL_MOUSE2);
#else
    AssertF(DIGETEMFL(this->pvi->fl) == 0 ||
            DIGETEMFL(this->pvi->fl) == DIEMFL_MOUSE2);
#endif
    /*
     *  Even though we can do it, we don't let the app
     *  get background exclusive access.  As with the keyboard,
     *  there is nothing that technically prevents us from
     *  supporting it; we just don't feel like it because it's
     *  too dangerous.
     */

    /*
     *  VxD and LL (emulation 1) behave the same, so we check
     *  if it's "not emulation 2".
     */

    if (!(this->pvi->fl & DIMAKEEMFL(DIEMFL_MOUSE2))) {

        if (dwFlags & DISCL_EXCLUSIVE) {
            if (dwFlags & DISCL_FOREGROUND) {
              #ifdef WANT_TO_FIX_MANBUG43879  
                this->pvi->fl |= VIFL_FOREGROUND;
              #endif
                this->pvi->fl |= VIFL_CAPTURED;
                hres = S_OK;
            } else {                /* Disallow exclusive background */
                SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("Exclusive background mouse access disallowed"));
                hres = E_NOTIMPL;
            }
        } else {
          #ifdef WANT_TO_FIX_MANBUG43879
            if (dwFlags & DISCL_FOREGROUND) {
                this->pvi->fl |= VIFL_FOREGROUND;
            }
          #endif

            this->pvi->fl &= ~VIFL_CAPTURED;
            hres = S_OK;
        }

    } else {
        /*
         *  Emulation 2 supports only exclusive foreground.
         */
        if ((dwFlags & (DISCL_EXCLUSIVE | DISCL_FOREGROUND)) ==
                       (DISCL_EXCLUSIVE | DISCL_FOREGROUND)) {
          #ifdef WANT_TO_FIX_MANBUG43879  
            this->pvi->fl |= VIFL_FOREGROUND;
          #endif
            this->pvi->fl |= VIFL_CAPTURED;
            hres = S_OK;
        } else {
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("Mouse access must be exclusive foreground in Emulation 2."));
            hres = E_NOTIMPL;
        }
    }

    if (SUCCEEDED(hres)) {
        this->hwndCapture = hwnd;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | RunControlPanel |
 *
 *          Run the mouse control panel.
 *
 *  @parm   IN HWND | hwndOwner |
 *
 *          The owner window.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

TCHAR c_tszMouse[] = TEXT("mouse");

#pragma END_CONST_DATA

STDMETHODIMP
CMouse_RunControlPanel(PDICB pdcb, HWND hwnd, DWORD dwFlags)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Mouse::RunControlPanel,
               (_ "pxx", pdcb, hwnd, dwFlags));

    hres = hresRunControlPanel(c_tszMouse);

    ExitOleProcR();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | BuildDefaultActionMap |
 *
 *          Validate the passed action map, blanking out invalid ones.
 *
 *  @parm   LPDIACTIONFORMATW | pActionFormat |
 *
 *          Actions to map.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags used to indicate mapping preferences.
 *
 *  @parm   REFGUID | guidInst |
 *
 *          Device instance GUID.
 *
 *  @returns
 *
 *          <c E_NOTIMPL>
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_BuildDefaultActionMap
(
    PDICB               pdcb,
    LPDIACTIONFORMATW   paf,
    DWORD               dwFlags,
    REFGUID             guidInst
)
{
    HRESULT hres;
    PDM this;

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    EnterProcI(IDirectInputDeviceCallback::Mouse::BuildDefaultActionMap,
        (_ "ppxG", pdcb, paf, dwFlags, guidInst));

    this = _thisPvNm(pdcb, dcb);

    hres = CMap_BuildDefaultSysActionMap ( paf, dwFlags, DIPHYSICAL_MOUSE,
        guidInst, &this->df, 3 /* Generic mice buttons start at instnace 3 */ );

    ExitOleProcR();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method UINT | CMouse | NumAxes |
 *
 *          Determine the number of mouse axes.
 *
 *          On Windows NT, we can use the new <c SM_MOUSEWHEELPRESENT>
 *          system metric.  On Windows 95, we have to hunt for the
 *          Magellan window (using the mechanism documented in the
 *          Magellan SDK).
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

TCHAR c_tszMouseZClass[] = TEXT("MouseZ");
TCHAR c_tszMouseZTitle[] = TEXT("Magellan MSWHEEL");
TCHAR c_tszMouseZActive[] = TEXT("MSH_WHEELSUPPORT_MSG");

#pragma END_CONST_DATA

#ifdef WINNT
#define CMouse_IsMagellanWheel() FALSE
#else
BOOL INLINE
CMouse_IsMagellanWheel(void)
{
    HWND hwnd = FindWindow(c_tszMouseZClass, c_tszMouseZTitle);
    return hwnd && SendMessage(hwnd, RegisterWindowMessage(c_tszMouseZActive), 0, 0);
}
#endif

#ifndef SM_MOUSEWHEELPRESENT
#define SM_MOUSEWHEELPRESENT            75
#endif

UINT INLINE
CMouse_NumAxes(void)
{
    UINT dwAxes;

    if (GetSystemMetrics(SM_MOUSEWHEELPRESENT) || CMouse_IsMagellanWheel()) {
        dwAxes = 3;
    } else {
        dwAxes = 2;
    }

    if (dwAxes == 2) {
        //Should avoid rebuilding too frequently.
        DIHid_BuildHidList(FALSE);

        DllEnterCrit();

        if (g_phdl) {
            int ihdi;
            for (ihdi = 0; ihdi < g_phdl->chdi; ihdi++) {
                if (dwAxes < g_phdl->rghdi[ihdi].osd.uiAxes) {
                    dwAxes = g_phdl->rghdi[ihdi].osd.uiAxes;
                }
            }
        }
        DllLeaveCrit();
    }

    return dwAxes;
}

UINT INLINE
CMouse_NumButtons(DWORD dwAxes)
{
    UINT dwButtons;

    dwButtons = GetSystemMetrics(SM_CMOUSEBUTTONS);

#ifndef WINNT
  #ifdef HID_SUPPORT
    {
        /*
         *  ISSUE-2001/03/29-timgill Should try to avoid rebuilding Hid List too frequently.
         */
        DIHid_BuildHidList(FALSE);

        DllEnterCrit();

        if (g_phdl) {
            int ihdi;
            for (ihdi = 0; ihdi < g_phdl->chdi; ihdi++) {
                if (dwButtons < g_phdl->rghdi[ihdi].osd.uiButtons) {
                    dwButtons = g_phdl->rghdi[ihdi].osd.uiButtons;
                }
            }
        }
        DllLeaveCrit();
    }
  #endif
#endif

    if( dwButtons >= 8 ) {
        dwButtons = 8;
    }
    else if (dwAxes == 3 && dwButtons < 3) {
        /*
         *  HACK FOR MAGELLAN!
         *
         *  They return 2 from GetSystemMetrics(SM_CMOUSEBUTTONS).
         *  So if we see a Z-axis, then assume that
         *  there is also a third button.
         */
        dwButtons = 3;
    }

    return dwButtons;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CMouse | AddObjects |
 *
 *          Add a number of objects to the device format.
 *
 *  @parm   LPCDIOBJECTDATAFORMAT | rgodf |
 *
 *          Array of objects to be added.
 *
 *  @parm   UINT | cObj |
 *
 *          Number of objects to add.
 *
 *****************************************************************************/

void INTERNAL
CMouse_AddObjects(PDM this, LPCDIOBJECTDATAFORMAT rgodf, UINT cObj)
{
    UINT iodf;
    EnterProc(CMouse_AddObjects, (_ "pxx", this, rgodf, cObj));

    for (iodf = 0; iodf < cObj; iodf++) {
        this->rgodf[this->df.dwNumObjs++] = rgodf[iodf];
    }
    AssertF(this->df.dwNumObjs <= cA(this->rgodf));
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CMouse | Init |
 *
 *          Initialize the object by establishing the data format
 *          based on the mouse type.
 *
 *          Code for detecting the IntelliMouse (formerly known as
 *          Magellan) pointing device is swiped from zmouse.h.
 *
 *  @parm   REFGUID | rguid |
 *
 *          The instance GUID we are being asked to create.
 *
 *****************************************************************************/

HRESULT INTERNAL
CMouse_Init(PDM this, REFGUID rguid)
{
    HRESULT hres;
    VXDDEVICEFORMAT devf;
    EnterProc(CMouse_Init, (_ "pG", this, rguid));

    this->df.dwSize = cbX(DIDATAFORMAT);
    this->df.dwObjSize = cbX(DIOBJECTDATAFORMAT);
    this->df.dwDataSize = cbX(DIMOUSESTATE_INT);
    this->df.rgodf = this->rgodf;
    AssertF(this->df.dwFlags == 0);
    AssertF(this->df.dwNumObjs == 0);

    /*
     *  Need to know early if we have a Z-axis, so we can disable
     *  the Z-wheel if it doesn't exist.
     *
     *  Note that this disabling needs to be done only on Win95.
     *  Win98 and NT4 have native Z-axis support, so there is
     *  nothing bogus that needs to be hacked.
     */
    this->dwAxes = CMouse_NumAxes();
    devf.dwExtra = this->dwAxes;
    if (this->dwAxes < 3) {
        DWORD dwVer = GetVersion();
        if ((LONG)dwVer >= 0 ||
            MAKEWORD(HIBYTE(LOWORD(dwVer)), LOBYTE(dwVer)) >= 0x040A) {
            devf.dwExtra = 3;
        }
    }
    CMouse_AddObjects(this, c_podfMouseAxes, this->dwAxes);

    /*
     *  Create the object with the most optimistic data format.
     *  This is important, because DINPUT.VXD builds the
     *  data format only once, and we need to protect ourselves against
     *  the user going into Control Panel and enabling the Z-Wheel
     *  after DINPUT.VXD has already initialized.
     */

    devf.cbData = cbX(DIMOUSESTATE_INT);
    devf.cObj = cA(c_rgodfMouse);
    devf.rgodf = c_rgodfMouse;

    /*
     *  But first a word from our other sponsor:  Figure out the
     *  emulation flags based on the GUID.
     */

    AssertF(GUID_SysMouse   .Data1 == 0x6F1D2B60);
    AssertF(GUID_SysMouseEm .Data1 == 0x6F1D2B80);
    AssertF(GUID_SysMouseEm2.Data1 == 0x6F1D2B81);

    switch (rguid->Data1) {

    default:
    case 0x6F1D2B60:
        AssertF(IsEqualGUID(rguid, &GUID_SysMouse));
        AssertF(this->flEmulation == 0);
        break;

    case 0x6F1D2B80:
        AssertF(IsEqualGUID(rguid, &GUID_SysMouseEm));
        this->flEmulation = DIEMFL_MOUSE;
        break;

    case 0x6F1D2B81:
        AssertF(IsEqualGUID(rguid, &GUID_SysMouseEm2));
        this->flEmulation = DIEMFL_MOUSE2;
        break;

    }

    devf.dwEmulation = this->flEmulation;

    hres = Hel_Mouse_CreateInstance(&devf, &this->pvi);
    if (SUCCEEDED(hres)) {

        AssertF(this->pvi);
        this->pdmsPhys = this->pvi->pState;

        this->dwButtons = CMouse_NumButtons( this->dwAxes );

        CMouse_AddObjects(this, c_podfMouseButtons, this->dwButtons);

        hres = S_OK;

    } else {
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("Mismatched version of dinput.vxd"));
        hres = E_FAIL;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *      CMouse_New       (constructor)
 *
 *      Fail the create if the machine has no mouse.
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_New(PUNK punkOuter, REFGUID rguid, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Mouse::<constructor>,
               (_ "Gp", riid, ppvObj));

    AssertF(IsEqualGUID(rguid, &GUID_SysMouse) ||
            IsEqualGUID(rguid, &GUID_SysMouseEm) ||
            IsEqualGUID(rguid, &GUID_SysMouseEm2));

    if (GetSystemMetrics(SM_MOUSEPRESENT)) {
        hres = Common_NewRiid(CMouse, punkOuter, riid, ppvObj);

        if (SUCCEEDED(hres)) {
            /* Must use _thisPv in case of aggregation */
            PDM this = _thisPv(*ppvObj);

            if (SUCCEEDED(hres = CMouse_Init(this, rguid))) {
            } else {
                Invoke_Release(ppvObj);
            }

        }
    } else {
        RPF("Warning: System does not have a mouse");
        /*
         *  Since we by-passed the parameter checks and we failed to create
         *  the new interface, try to zero the pointer now.
         */
        if (!IsBadWritePtr(ppvObj, sizeof(UINT_PTR) ))
        {
            *(PUINT_PTR)ppvObj = 0;
        }
        hres = DIERR_DEVICENOTREG;
    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define CMouse_Signature        0x53554F4D      /* "MOUS" */

Primary_Interface_Begin(CMouse, IDirectInputDeviceCallback)
    CMouse_GetInstance,
    CDefDcb_GetVersions,
    CMouse_GetDataFormat,
    CMouse_GetObjectInfo,
    CMouse_GetCapabilities,
    CMouse_Acquire,
    CMouse_Unacquire,
    CMouse_GetDeviceState,
    CMouse_GetDeviceInfo,
    CMouse_GetProperty,
    CDefDcb_SetProperty,
    CDefDcb_SetEventNotification,
    CMouse_SetCooperativeLevel,
    CMouse_RunControlPanel,
    CDefDcb_CookDeviceData,
    CDefDcb_CreateEffect,
    CDefDcb_GetFFConfigKey,
    CDefDcb_SendDeviceData,
    CDefDcb_Poll,
    CDefDcb_GetUsage,
    CDefDcb_MapUsage,
    CDefDcb_SetDIData,
    CMouse_BuildDefaultActionMap,
Primary_Interface_End(CMouse, IDirectInputDeviceCallback)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\diguid.c ===
/*****************************************************************************
 *
 *  DIGuid.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Misc GUID-related helper functions.
 *
 *  Contents:
 *
 *      DICreateGuid
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflUtil


/*****************************************************************************
 *
 *      Globals
 *
 *****************************************************************************/

typedef void (__stdcall *UUIDCREATE)(OUT LPGUID pguid);

UUIDCREATE g_UuidCreate;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | FakeUuidCreate |
 *
 *          Create a GUID using a fake algorithm that is close enough.
 *          Since we don't let our GUIDs leave the DirectInput world,
 *          the uniqueness policy can be relaxed.
 *
 *          OLE generates a GUID as follows:
 *
 *          Get the current local time in FILETIME format.
 *
 *          Add the magic number 0x00146bf33e42c000 = 580819200 seconds =
 *          9580320 minutes = 159672 hours = 6653 days, approximately
 *          18 years.  Who knows why.
 *
 *          Subtract 0x00989680 (approximately 256 seconds).  Who
 *          knows why.
 *
 *          If you combine the above two steps, the net result is to
 *          add 0x00146bf33daa2980.
 *
 *          The dwLowDateTime of the resulting FILETIME becomes Data1.
 *
 *          The dwHighDateTime of the resulting FILETIME becomes
 *          Data2 and Data3, except that the high nibble of Data3
 *          is forced to 1.
 *
 *          The first two bytes of Data4 are a big-endian 10-bit
 *          sequence counter, with the top bit set and the other
 *          bits zero.
 *
 *          The last six bytes are the network card identifier.
 *
 *  @parm   LPGUID | pguid |
 *
 *          Receives the GUID to create.
 *
 *****************************************************************************/

void INTERNAL
FakeUuidCreate(LPGUID pguid)
{
    LONG lRc;
    SYSTEMTIME st;
    union {
        FILETIME ft;
        DWORDLONG ldw;
    } u;

    GetLocalTime(&st);
    SystemTimeToFileTime(&st, &u.ft);
    u.ldw += 0x00146BF33DAA2980;

    /*
     *  Note: The wacky pun is actually safe on a RISC because
     *  Data2 is already dword-aligned.
     */

    pguid->Data1 = u.ft.dwLowDateTime;
    *(LPDWORD)&pguid->Data2 = (u.ft.dwHighDateTime & 0x0FFFFFFF) | 0x10000000;

    lRc = Excl_UniqueGuidInteger();
    lRc = lRc & 0x3FFF;

    pguid->Data4[0] = 0x80 | HIBYTE(lRc);
    pguid->Data4[1] =        LOBYTE(lRc);


    /*
     *  We use the network adapter ID of the dial-up adapter as our
     *  network ID.  No real network adapter will have this ID.
     */
    pguid->Data4[2] = 'D';
    pguid->Data4[3] = 'E';
    pguid->Data4[4] = 'S';
    pguid->Data4[5] = 'T';
    pguid->Data4[6] = 0x00;
    pguid->Data4[7] = 0x00;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DICreateGuid |
 *
 *          Create a GUID.  Because we don't want to pull in all of OLE,
 *          we don't actually use RPCRT4
 *
 *  @parm   LPGUID | pguid |
 *
 *          Receives the GUID to create.
 *
 *****************************************************************************/

void EXTERNAL
DICreateGuid(LPGUID pguid)
{
    AssertF(g_hmtxGlobal);

    FakeUuidCreate(pguid);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DICreateStaticGuid |
 *
 *          Create a "static" <t GUID>, which is a <t GUID> that can be
 *          deterministically regenerated from its parameters.
 *
 *          This is used to invent <t GUID>s for HID devices
 *          and vendors.
 *
 *          The entire <t GUID> is zero, except for the pid and vid
 *          which go into Data1, and the network adapter
 *          ID is the dial-up adapter.
 *
 *          We put the variable bits into the Data1 because that's
 *          how GUIDs work.
 *
 *          The resulting GUID is {pidvid-0000-0000-0000-504944564944}
 *
 *  @parm   LPGUID | pguid |
 *
 *          Receives the created <t GUID>.
 *
 *****************************************************************************/

void EXTERNAL
DICreateStaticGuid(LPGUID pguid, WORD pid, WORD vid)
{
    pguid->Data1 = MAKELONG(vid, pid);

    pguid->Data2 = 0;
    pguid->Data3 = 0;

    /*
     *  We use the string "PIDVID" as our network adapter ID.
     *  No real network adapter will have this ID.
     */
    pguid->Data4[0] = 0x00;
    pguid->Data4[1] = 0x00;
    pguid->Data4[2] = 'P';
    pguid->Data4[3] = 'I';
    pguid->Data4[4] = 'D';
    pguid->Data4[5] = 'V';
    pguid->Data4[6] = 'I';
    pguid->Data4[7] = 'D';

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\digenk.c ===
/*****************************************************************************
 *
 *  DIGenK.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Generic IDirectInputDevice callback for keyboard.
 *
 *  Contents:
 *
 *      CKbd_CreateInstance
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      Some holes in windows.h on NT platforms.
 *
 *****************************************************************************/

#ifndef VK_KANA
#define VK_KANA         0x15
#endif

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflKbd

/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *      WARNING!  If you add a secondary interface, you must also change
 *      CKbd_New!
 *
 *****************************************************************************/

Primary_Interface(CKbd, IDirectInputDeviceCallback);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct KBDSTAT |
 *
 *          Internal instantaneous keyboard status information.
 *
 *  @field  BYTE | rgb[DIKBD_CKEYS] |
 *
 *          Array of key states, one for each logical key.
 *
 *****************************************************************************/

typedef struct KBDSTAT {

    BYTE    rgb[DIKBD_CKEYS];

} KBDSTAT, *PKBDSTAT;

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @topic  Special remarks on keyboard scan codes |
 *
 *          There are several aspects of keyboards which applications should
 *          be aware of.  Applications are encouraged to allow users to
 *          reconfigure keyboard action keys to suit the physical keyboard
 *          layout.
 *
 *          For the purposes of this discussion, the baseline keyboard
 *          shall be the US PC Enhanced keyboard.  When a key is described
 *          as "missing", it means that the key is present on the US PC
 *          Enhanced keyboard but not on the keyboard under discussion.
 *          When a key is described as "added", it means that the key is
 *          absent on the US PC Enhanced keyboard but present on the
 *          keyboard under discussion.
 *
 *          Not all PC Enhanced keyboards support the new Windows keys
 *          (DIK_LWIN, DIK_RWIN, and DIK_APPS).  There is no way to
 *          determine whether the keys are physically available.
 *
 *          Note that there is no DIK_PAUSE key code.  The PC Enhanced
 *          keyboard does not generate a separate DIK_PAUSE scan code;
 *          rather, it synthesizes a "Pause" from the DIK_LCONTROL and
 *          DIK_NUMLOCK scan codes.
 *
 *          Keyboards for laptops or other reduced-footprint computers
 *          frequently do not implement a full set of keys.  Instead,
 *          some keys (typically numeric keypad keys) are multiplexed
 *          with other keys, selected by an auxiliary "mode" key which
 *          does not generate a separate scan code.
 *
 *          If the keyboard subtype indicates a PC XT or PC AT keyboard,
 *          then the following keys are not available:
 *          DIK_F11, DIK_F12, and all the extended keys (DIK_* values
 *          greater than or equal to 0x80).  Furthermore, the PC XT
 *          keyboard lacks DIK_SYSRQ.
 *
 *          Japanese keyboards contain a substantially different set of
 *          keys from US keyboards.  The following keyboard scan codes
 *          are not available on Japanese keyboards:
 *          DIK_EQUALS, DIK_APOSTROPHE, DIK_GRAVE, DIK_NUMPADENTER,
 *          DIK_RCONTROL, DIK_RMENU.  Furthermore, most Japanese
 *          keyboards do not support DIK_RSHIFT.  (It is customary
 *          to use DIK_NUMPADEQUAL in place of DIK_RSHIFT.)
 *
 *          Japanese keyboards contain the following additional keys:
 *          DIK_F14, DIK_NUMPADEQUAL, DIK_CIRCUMFLEX, DIK_AT, DIK_COLON,
 *          DIK_UNDERLINE, DIK_XFER, DIK_NFER, DIK_STOP, DIK_KANA, and
 *          DIK_NUMPADCOMMA.
 *
 *          Note that on Japanese keyboards, the DIK_CAPSLOCK and
 *          DIK_KANA keys are toggle buttons and not push buttons.
 *          They generate a down event
 *          when first pressed, then generate an up event when pressed a
 *          second time.
 *          Note that on Windows 2000, the DIK_KANJI key is also treated as a 
 *          toggle.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global KBDTYPE | c_rgktWhich[] |
 *
 *          Array that describes which keyboards support which keys.
 *
 *          The list is optimistic.  If any keyboard of the indicated
 *          type supports the key, then we list it.
 *
 *          Items marks "available for NEC" are keys which are extremely
 *          unlikely to be used in future versions of the Enhanced
 *          keyboard and therefore can be used as ersatz scan codes for
 *          NEC-only keys.
 *
 *          Note:  Kana and CAPSLOCK are toggle buttons on NEC keyboards.
 *          Note:  Kana, Kanji and CAPSLOCK are toggle buttons on all NT JPN 
 *                 keyboards.
 *
 *****************************************************************************/

BYTE g_rgbKbdRMap[DIKBD_CKEYS];

typedef BYTE KBDTYPE;

#define KBDTYPE_XT       0x01       /* Key exists on XT class keyboard */
#define KBDTYPE_AT       0x02       /* Key exists on AT class keyboard */
#define KBDTYPE_ENH      0x04       /* Key exists on Enhanced keyboard */
#define KBDTYPE_NEC      0x08       /* Key exists on NEC keyboard */
#define KBDTYPE_ANYKBD   0x0F       /* Key exists somewhere in the world */

#define KBDTYPE_NECTGL   0x10       /* Is a toggle-key on NEC keyboard */
#define KBDTYPE_NTTGL    0x20       /* Is a toggle-key on an NT FE keyboard */

#pragma BEGIN_CONST_DATA

#define XT      KBDTYPE_XT  |
#define AT      KBDTYPE_XT  |
#define ENH     KBDTYPE_ENH |
#define NEC     KBDTYPE_NEC |
#define NECTGL  KBDTYPE_NECTGL |
#define NTTGL   KBDTYPE_NTTGL |

KBDTYPE c_rgktWhich[] = {

                               0,     /* 0x00 - <undef>  */
    XT AT ENH NEC              0,     /* 0x01 - Esc      */
    XT AT ENH NEC              0,     /* 0x02 - 1        */
    XT AT ENH NEC              0,     /* 0x03 - 2        */
    XT AT ENH NEC              0,     /* 0x04 - 3        */
    XT AT ENH NEC              0,     /* 0x05 - 4        */
    XT AT ENH NEC              0,     /* 0x06 - 5        */
    XT AT ENH NEC              0,     /* 0x07 - 6        */
    XT AT ENH NEC              0,     /* 0x08 - 7        */
    XT AT ENH NEC              0,     /* 0x09 - 8        */
    XT AT ENH NEC              0,     /* 0x0A - 9        */
    XT AT ENH NEC              0,     /* 0x0B - 0        */
    XT AT ENH NEC              0,     /* 0x0C - -        */
    XT AT ENH                  0,     /* 0x0D - =        */
    XT AT ENH NEC              0,     /* 0x0E - BkSp     */
    XT AT ENH NEC              0,     /* 0x0F - Tab      */

    XT AT ENH NEC              0,     /* 0x10 - Q        */
    XT AT ENH NEC              0,     /* 0x11 - W        */
    XT AT ENH NEC              0,     /* 0x12 - E        */
    XT AT ENH NEC              0,     /* 0x13 - R        */
    XT AT ENH NEC              0,     /* 0x14 - T        */
    XT AT ENH NEC              0,     /* 0x15 - Y        */
    XT AT ENH NEC              0,     /* 0x16 - U        */
    XT AT ENH NEC              0,     /* 0x17 - I        */
    XT AT ENH NEC              0,     /* 0x18 - O        */
    XT AT ENH NEC              0,     /* 0x19 - P        */
    XT AT ENH NEC              0,     /* 0x1A - [        */
    XT AT ENH NEC              0,     /* 0x1B - ]        */
    XT AT ENH NEC              0,     /* 0x1C - Enter    */
    XT AT ENH NEC              0,     /* 0x1D - LCtrl    */
    XT AT ENH NEC              0,     /* 0x1E - A        */
    XT AT ENH NEC              0,     /* 0x1F - S        */

    XT AT ENH NEC              0,     /* 0x20 - D        */
    XT AT ENH NEC              0,     /* 0x21 - F        */
    XT AT ENH NEC              0,     /* 0x22 - G        */
    XT AT ENH NEC              0,     /* 0x23 - H        */
    XT AT ENH NEC              0,     /* 0x24 - J        */
    XT AT ENH NEC              0,     /* 0x25 - K        */
    XT AT ENH NEC              0,     /* 0x26 - L        */
    XT AT ENH NEC              0,     /* 0x27 - ;        */
    XT AT ENH                  0,     /* 0x28 - '        */
    XT AT ENH                  0,     /* 0x29 - `        */
    XT AT ENH NEC              0,     /* 0x2A - LShift   */
    XT AT ENH NEC              0,     /* 0x2B - \        */
    XT AT ENH NEC              0,     /* 0x2C - Z        */
    XT AT ENH NEC              0,     /* 0x2D - X        */
    XT AT ENH NEC              0,     /* 0x2E - C        */
    XT AT ENH NEC              0,     /* 0x2F - V        */

    XT AT ENH NEC              0,     /* 0x30 - B        */
    XT AT ENH NEC              0,     /* 0x31 - N        */
    XT AT ENH NEC              0,     /* 0x32 - M        */
    XT AT ENH NEC              0,     /* 0x33 - ,        */
    XT AT ENH NEC              0,     /* 0x34 - .        */
    XT AT ENH NEC              0,     /* 0x35 - /        */
    XT AT ENH NEC              0,     /* 0x36 - RShift   */
    XT AT ENH NEC              0,     /* 0x37 - Num*     */
    XT AT ENH NEC              0,     /* 0x38 - LAlt     */
    XT AT ENH NEC              0,     /* 0x39 - Space    */
    XT AT ENH NEC NECTGL NTTGL 0,     /* 0x3A - CapsLock */
    XT AT ENH NEC              0,     /* 0x3B - F1       */
    XT AT ENH NEC              0,     /* 0x3C - F2       */
    XT AT ENH NEC              0,     /* 0x3D - F3       */
    XT AT ENH NEC              0,     /* 0x3E - F4       */
    XT AT ENH NEC              0,     /* 0x3F - F5       */

    XT AT ENH NEC              0,     /* 0x40 - F6       */
    XT AT ENH NEC              0,     /* 0x41 - F7       */
    XT AT ENH NEC              0,     /* 0x42 - F8       */
    XT AT ENH NEC              0,     /* 0x43 - F9       */
    XT AT ENH NEC              0,     /* 0x44 - F10      */
    XT AT ENH                  0,     /* 0x45 - NumLock  */
    XT AT ENH                  0,     /* 0x46 - ScrLock  */
    XT AT ENH NEC              0,     /* 0x47 - Numpad7  */
    XT AT ENH NEC              0,     /* 0x48 - Numpad8  */
    XT AT ENH NEC              0,     /* 0x49 - Numpad9  */
    XT AT ENH NEC              0,     /* 0x4A - Numpad-  */
    XT AT ENH NEC              0,     /* 0x4B - Numpad4  */
    XT AT ENH NEC              0,     /* 0x4C - Numpad5  */
    XT AT ENH NEC              0,     /* 0x4D - Numpad6  */
    XT AT ENH NEC              0,     /* 0x4E - Numpad+  */
    XT AT ENH NEC              0,     /* 0x4F - Numpad1  */

    XT AT ENH NEC              0,     /* 0x50 - Numpad2  */
    XT AT ENH NEC              0,     /* 0x51 - Numpad3  */
    XT AT ENH NEC              0,     /* 0x52 - Numpad0  */
    XT AT ENH NEC              0,     /* 0x53 - Numpad.  */

                               0,     /* 0x54 - <undef>  */
                               0,     /* 0x55 - <undef>  */
          ENH                  0,     /* 0x56 - <undef>. On UK/Germany keyboards, it is <, > and |. */
          ENH NEC              0,     /* 0x57 - F11      */
          ENH NEC              0,     /* 0x58 - F12      */
                               0,     /* 0x59 - <undef>  */
                               0,     /* 0x5A - <undef>  */
                               0,     /* 0x5B - <undef>  */
                               0,     /* 0x5C - <undef>  */
                               0,     /* 0x5D - <undef>  */
                               0,     /* 0x5E - <undef>  */
                               0,     /* 0x5F - <undef>  */

                               0,     /* 0x60 - <undef>  */
                               0,     /* 0x61 - <undef>  */
                               0,     /* 0x62 - <undef>  */
                               0,     /* 0x63 - <undef>  */
              NEC              0,     /* 0x64 - F13      */
              NEC              0,     /* 0x65 - F14      */
              NEC              0,     /* 0x66 - F15      */
                               0,     /* 0x67 - <undef>  */
                               0,     /* 0x68 - <undef>  */
                               0,     /* 0x69 - <undef>  */
                               0,     /* 0x6A - <undef>  */
                               0,     /* 0x6B - <undef>  */
                               0,     /* 0x6C - <undef>  */
                               0,     /* 0x6D - <undef>  */
                               0,     /* 0x6E - <undef>  */
                               0,     /* 0x6F - <undef>  */

              NEC NECTGL NTTGL 0,     /* 0x70 - Kana     */
                               0,     /* 0x71 - <undef>  */
                               0,     /* 0x72 - <undef>  */
          ENH                  0,     /* 0x73 - <undef>.  On Portugese (Brazilian) keyboard, it is /, ? */
                               0,     /* 0x74 - <undef>  */
                               0,     /* 0x75 - <undef>  */
                               0,     /* 0x76 - <undef>  */
                               0,     /* 0x77 - <undef>  */
                               0,     /* 0x78 - <undef>  */
              NEC              0,     /* 0x79 - Convert  */
                               0,     /* 0x7A - <undef>  */
              NEC              0,     /* 0x7B - Nfer     */
                               0,     /* 0x7C - <undef>  */
              NEC              0,     /* 0x7D - Yen      */
          ENH                  0,     /* 0x7E - <undef>.  On Portugese (Brazilian) keyboard, it is keypad . */
                               0,     /* 0x7F - <undef>  */

                                /* Extended keycodes go here */

                               0,     /* 0x80 - <undef>  */
                               0,     /* 0x81 - <undef>  */
                               0,     /* 0x82 - <undef>  */
                               0,     /* 0x83 - <undef>  */
                               0,     /* 0x84 - <undef>  */
                               0,     /* 0x85 - <undef>  */
                               0,     /* 0x86 - <undef>  */
                               0,     /* 0x87 - <undef>  */
                               0,     /* 0x88 - <undef>  */
                               0,     /* 0x89 - <undef>  */
                               0,     /* 0x8A - <undef>  */
                               0,     /* 0x8B - <undef>  */
                               0,     /* 0x8C - <undef>  */
              NEC              0,     /* 0x8D - Num=     */
                               0,     /* 0x8E - <undef>  */
                               0,     /* 0x8F - <undef>  */

          ENH NEC              0,     /* 0x90 - ^        */ ///Prev Track
              NEC              0,     /* 0x91 - @        */
              NEC              0,     /* 0x92 - :        */
              NEC              0,     /* 0x93 - _        */
              NEC        NTTGL 0,     /* 0x94 - Xfer - AKA Kanji */
              NEC              0,     /* 0x95 - Stop     */
              NEC              0,     /* 0x96 - AX       */
              NEC              0,     /* 0x97 - Unlabel'd*/
                               0,     /* 0x98 - <undef>  */ /* available for NEC */
          ENH                  0,     /* 0x99 - <undef>  */ /* available for NEC */ ///Next Track
                               0,     /* 0x9A - <undef>  */
                               0,     /* 0x9B - <undef>  */
          ENH                  0,     /* 0x9C - NumEnter */
          ENH                  0,     /* 0x9D - RCtrl    */
                               0,     /* 0x9E - <undef>  */ /* available for NEC */
                               0,     /* 0x9F - <undef>  */ /* available for NEC */

          ENH                  0,     /* 0xA0 - <undef>  */ /* available for NEC */ ///Mute
          ENH                  0,     /* 0xA1 - <undef>  */ /* available for NEC */ ///Calculator
          ENH                  0,     /* 0xA2 - <undef>  */ /* available for NEC */ ///Play/Pause
                               0,     /* 0xA3 - <undef>  */ /* available for NEC */
          ENH                  0,     /* 0xA4 - <undef>  */ /* available for NEC */ ///Stop
                               0,     /* 0xA5 - <undef>  */ /* available for NEC */
                               0,     /* 0xA6 - <undef>  */ /* available for NEC */
                               0,     /* 0xA7 - <undef>  */
                               0,     /* 0xA8 - <undef>  */
                               0,     /* 0xA9 - <undef>  */
                               0,     /* 0xAA - <undef>  */
                               0,     /* 0xAB - <undef>  */
                               0,     /* 0xAC - <undef>  */ /* available for NEC */
                               0,     /* 0xAD - <undef>  */ /* available for NEC */
          ENH                  0,     /* 0xAE - <undef>  */ /* available for NEC */ ///Volume -
                               0,     /* 0xAF - <undef>  */ /* available for NEC */

          ENH                  0,     /* 0xB0 - <undef>  */ /* available for NEC */ ///Volume +
                               0,     /* 0xB1 - <undef>  */ /* available for NEC */
          ENH                  0,     /* 0xB2 - <undef>  */ /* available for NEC */ ///Web/Home
              NEC              0,     /* 0xB3 - Num,     */
                               0,     /* 0xB4 - <undef>  */
          ENH NEC              0,     /* 0xB5 - Num/     */
                               0,     /* 0xB6 - <undef>  */
       AT ENH NEC              0,     /* 0xB7 - SysRq    */
          ENH                  0,     /* 0xB8 - RAlt     */
                               0,     /* 0xB9 - <undef>  */
                               0,     /* 0xBA - <undef>  */
                               0,     /* 0xBB - <undef>  */
                               0,     /* 0xBC - <undef>  */
                               0,     /* 0xBD - <undef>  */
                               0,     /* 0xBE - <undef>  */
                               0,     /* 0xBF - <undef>  */

                               0,     /* 0xC0 - <undef>  */
                               0,     /* 0xC1 - <undef>  */
                               0,     /* 0xC2 - <undef>  */
                               0,     /* 0xC3 - <undef>  */
                               0,     /* 0xC4 - <undef>  */
          ENH                  0,     /* 0xC5 - Pause    */
                               0,     /* 0xC6 - <undef>  */
          ENH NEC              0,     /* 0xC7 - Home     */
          ENH NEC              0,     /* 0xC8 - UpArrow  */
          ENH NEC              0,     /* 0xC9 - PgUp     */
                               0,     /* 0xCA - <undef>  */
          ENH NEC              0,     /* 0xCB - LtArrow  */
                               0,     /* 0xCC - <undef>  */
          ENH NEC              0,     /* 0xCD - RtArrow  */
                               0,     /* 0xCE - <undef>  */
          ENH NEC              0,     /* 0xCF - End      */

          ENH NEC              0,     /* 0xD0 - DnArrow  */
          ENH NEC              0,     /* 0xD1 - PgDn     */
          ENH NEC              0,     /* 0xD2 - Insert   */
          ENH NEC              0,     /* 0xD3 - Delete   */
                               0,     /* 0xD4 - <undef>  */
                               0,     /* 0xD5 - <undef>  */
                               0,     /* 0xD6 - <undef>  */
                               0,     /* 0xD7 - <undef>  */
                               0,     /* 0xD8 - <undef>  */
                               0,     /* 0xD9 - <undef>  */
                               0,     /* 0xDA - <undef>  */
          ENH NEC              0,     /* 0xDB - LWin     */
          ENH NEC              0,     /* 0xDC - RWin     */
          ENH NEC              0,     /* 0xDD - AppMenu  */
          ENH                  0,     /* 0xDE - Power    */
          ENH                  0,     /* 0xDF - Sleep    */

                               0,     /* 0xE0 - <undef>  */
                               0,     /* 0xE1 - <undef>  */
                               0,     /* 0xE2 - <undef>  */
          ENH                  0,     /* 0xE3 - Wake     */
                               0,     /* 0xE4 - <undef>  */
          ENH                  0,     /* 0xE5 - <undef>  */ ///Search
          ENH                  0,     /* 0xE6 - <undef>  */ ///Favorites
          ENH                  0,     /* 0xE7 - <undef>  */ ///Refresh
          ENH                  0,     /* 0xE8 - <undef>  */ ///Stop
          ENH                  0,     /* 0xE9 - <undef>  */ ///Forward
          ENH                  0,     /* 0xEA - <undef>  */ ///Back
          ENH                  0,     /* 0xEB - <undef>  */ ///My Computer
          ENH                  0,     /* 0xEC - <undef>  */ ///Mail
          ENH                  0,     /* 0xED - <undef>  */ ///Media
                               0,     /* 0xEE - <undef>  */
                               0,     /* 0xEF - <undef>  */

                               0,     /* 0xF0 - <undef>  */
                               0,     /* 0xF1 - <undef>  */
                               0,     /* 0xF2 - <undef>  */
                               0,     /* 0xF3 - <undef>  */
                               0,     /* 0xF4 - <undef>  */
                               0,     /* 0xF5 - <undef>  */
                               0,     /* 0xF6 - <undef>  */
                               0,     /* 0xF7 - <undef>  */
                               0,     /* 0xF8 - <undef>  */
                               0,     /* 0xF9 - <undef>  */
                               0,     /* 0xFA - <undef>  */
                               0,     /* 0xFB - <undef>  */
                               0,     /* 0xFC - <undef>  */
                               0,     /* 0xFD - <undef>  */
                               0,     /* 0xFE - <undef>  */
                               0,     /* 0xFF - <undef>  */

};

#undef  XT
#undef  AT
#undef  ENH
#undef  NEC

#if 0
DWORD dwSpecKeys[] = {0x56, 0x64, 0x65, 0x66, 0x73, 0x7e, 0x90, 0x99, 
                      0xa0, 0xa1, 0xa2, 0xa4, 0xae, 0xb0, 0xb2, 0xde, 
                      0xdf, 0xe3, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 
                      0xeb, 0xec, 0xed };
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CKbd |
 *
 *          The <i IDirectInputDeviceCallback> object for the
 *          generic keyboard.
 *
 *  @field  IDirectInputDeviceCalllback | didc |
 *
 *          The object (containing vtbl).
 *
 *  @field  PMKBDSTAT | pksPhys |
 *
 *          Pointer to physical keyboard status information kept down in the
 *          VxD.
 *
 *  @field  VXDINSTANCE * | pvi |
 *
 *          The DirectInput instance handle.
 *
 *  @field  DWORD | dwKbdType |
 *
 *          The device subtype for this keyboard.
 *
 *  @field  DWORD | flEmulation |
 *
 *          The emulation flags forced by the application.  If any of
 *          these flags is set (actually, at most one will be set), then
 *          we are an alias device.
 *
 *  @field  DIDATAFORMAT | df |
 *
 *          The dynamically-generated data format based on the
 *          keyboard type.
 *
 *  @field  DIOBJECTDATAFORMAT | rgodf[] |
 *
 *          Object data format table generated as part of the
 *          <e CKbd.df>.
 *
 *  @comm
 *
 *          It is the caller's responsibility to serialize access as
 *          necessary.
 *
 *****************************************************************************/

typedef struct CKbd {

    /* Supported interfaces */
    IDirectInputDeviceCallback dcb;

    PKBDSTAT pksPhys;

    VXDINSTANCE *pvi;

    DWORD dwKbdType;
    DWORD flEmulation;

    DIDATAFORMAT df;
    DIOBJECTDATAFORMAT rgodf[DIKBD_CKEYS];

} CKbd, DK, *PDK;

#define ThisClass CKbd
#define ThisInterface IDirectInputDeviceCallback
#define riidExpected &IID_IDirectInputDeviceCallback

/*****************************************************************************
 *
 *      CKbd::QueryInterface      (from IUnknown)
 *      CKbd::AddRef              (from IUnknown)
 *      CKbd::Release             (from IUnknown)
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @returns
 *
 *      Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | QIHelper |
 *
 *      We don't have any dynamic interfaces and simply forward
 *      to <f Common_QIHelper>.
 *
 *  @parm   IN REFIID | riid |
 *
 *      The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *      Receives a pointer to the obtained interface.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | AppFinalize |
 *
 *          We don't have any weak pointers, so we can just
 *          forward to <f Common_Finalize>.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released from the application's perspective.
 *
 *****************************************************************************/

#ifdef DEBUG

Default_QueryInterface(CKbd)
Default_AddRef(CKbd)
Default_Release(CKbd)

#else

#define CKbd_QueryInterface   Common_QueryInterface
#define CKbd_AddRef           Common_AddRef
#define CKbd_Release          Common_Release

#endif

#define CKbd_QIHelper         Common_QIHelper
#define CKbd_AppFinalize      Common_AppFinalize

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CKbd_Finalize |
 *
 *          Releases the resources of the device.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
CKbd_Finalize(PV pvObj)
{
    PDK this = pvObj;

    if (this->pvi) {
        HRESULT hres;
        hres = Hel_DestroyInstance(this->pvi);
        AssertF(SUCCEEDED(hres));
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   int | WrappedGetKeyboardType |
 *
 *          GetKeyboardType but wrapped in DEBUG for registry overrides.
 *
 *  @parm   int  | nTypeFlag |
 *
 *          Which data to return.  Only 0, 1 and 2 are supported
 *
 *  @returns
 *
 *          int value requested
 *
 *****************************************************************************/

#ifndef DEBUG
  #ifdef USE_WM_INPUT
    #define WrappedGetKeyboardType(x) DIRaw_GetKeyboardType(x)
  #else
    #define WrappedGetKeyboardType(x) GetKeyboardType(x)
  #endif
#else
int INTERNAL WrappedGetKeyboardType
( 
    int nTypeFlag 
)
{
    TCHAR ValueName[2];
    int TypeRes;

  #ifdef USE_WM_INPUT
    TypeRes = DIRaw_GetKeyboardType( nTypeFlag );
  #else
    TypeRes = GetKeyboardType( nTypeFlag );
  #endif

    if( nTypeFlag < 10 )
    {
        ValueName[0] = TEXT( '0' ) + nTypeFlag;
        ValueName[1] = TEXT( '\0' );
        
        TypeRes = (int)RegQueryDIDword( REGSTR_KEY_KEYBTYPE, ValueName, (DWORD)TypeRes );

        SquirtSqflPtszV(sqfl | sqflTrace, 
            TEXT( "DINPUT: GetKeyboardType(%d) returning 0x%08x" ),
            nTypeFlag, TypeRes );
    }
    else
    {
        RPF( "Somebody is passing %d to WrappedGetKeyboardType", nTypeFlag );
    }

    return TypeRes;
}
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | Acquire |
 *
 *          Tell the device driver to begin data acquisition.
 *
 *          It is the caller's responsibility to have set the
 *          data format before obtaining acquisition.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c S_FALSE>: The operation was begun and should be completed
 *          by the caller by communicating with the <t VXDINSTANCE>.
 *
 *****************************************************************************/

STDMETHODIMP
CKbd_Acquire(PDICB pdcb)
{
    VXDDWORDDATA vdd;
    PDK this;
    HRESULT hres;

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    /*
     *  Propagate the state of the potential toggle keys down to
     *  the VxD.  This also alerts the VxD that acquisition is coming,
     *  so it can reset the state tables if necessary.
     */
    vdd.pvi = this->pvi;
    vdd.dw = 0;
    if( WrappedGetKeyboardType(0) == 7 )
    {
        /*
         *  Let the keyboard driver know that this is an FE keyboard
         */
        vdd.dw |= 16;

        if (GetAsyncKeyState(VK_KANA) < 0) {
            vdd.dw |= 1;
        }
        if (GetAsyncKeyState(VK_CAPITAL) < 0) {
            vdd.dw |= 2;
        }
        if (GetAsyncKeyState(VK_KANJI) < 0) {
            vdd.dw |= 8;
        }
    }

    if( this->pvi->fl & VIFL_CAPTURED )
    {
        vdd.dw |= 4;        // Tell the keyboard driver to pre-acquire hooks
    }

    hres = Hel_Kbd_InitKeys(&vdd);
    
    if( this->pvi->fl & VIFL_CAPTURED )
    {
        /*
         *  A bit of work needs to be done at ring 3 now.
         *  Try to clear any key that is set.  Start with VK_BACK as mouse 
         *  buttons and undefined things go before.
         *  This still covers a lot of undefined VKs but we're less likely 
         *  to do damage clearing something that was undefined than leaving 
         *  keys uncleared.
         */
        BYTE vk;
        for( vk=VK_BACK; vk<VK_OEM_CLEAR; vk++ )
        {
            if( ( vk == VK_KANA ) || ( vk == VK_KANJI ) || ( vk == VK_CAPITAL ) )
            {
                continue;
            }
            if(GetAsyncKeyState(vk) < 0)
            {
                keybd_event( vk, 0, KEYEVENTF_KEYUP, 0 );
            }
        }
    }

    return S_FALSE;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | GetInstance |
 *
 *          Obtains the DirectInput instance handle.
 *
 *  @parm   OUT PPV | ppvi |
 *
 *          Receives the instance handle.
 *
 *****************************************************************************/

STDMETHODIMP
CKbd_GetInstance(PDICB pdcb, PPV ppvi)
{
    HRESULT hres;
    PDK this;
    EnterProcI(IDirectInputDeviceCallback::Kbd::GetInstance, (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);
    *ppvi = (PV)this->pvi;
    hres = S_OK;

    ExitOleProcPpvR(ppvi);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | GetDataFormat |
 *
 *          Obtains the device's preferred data format.
 *
 *  @parm   OUT LPDIDEVICEFORMAT * | ppdf |
 *
 *          <t LPDIDEVICEFORMAT> to receive pointer to device format.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpmdr> parameter is not a valid pointer.
 *
 *****************************************************************************/

STDMETHODIMP
CKbd_GetDataFormat(PDICB pdcb, LPDIDATAFORMAT *ppdf)
{
    HRESULT hres;
    PDK this;
    EnterProcI(IDirectInputDeviceCallback::Kbd::GetDataFormat,
               (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    *ppdf = &this->df;
    hres = S_OK;

    ExitOleProcPpvR(ppdf);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | GetDeviceInfo |
 *
 *          Obtain general information about the device.
 *
 *  @parm   OUT LPDIDEVICEINSTANCEW | pdiW |
 *
 *          <t DEVICEINSTANCE> to be filled in.  The
 *          <e DEVICEINSTANCE.dwSize> and <e DEVICEINSTANCE.guidInstance>
 *          have already been filled in.
 *
 *          Secret convenience:  <e DEVICEINSTANCE.guidProduct> is equal
 *          to <e DEVICEINSTANCE.guidInstance>.
 *
 *****************************************************************************/

STDMETHODIMP
CKbd_GetDeviceInfo(PDICB pdcb, LPDIDEVICEINSTANCEW pdiW)
{
    HRESULT hres;
    PDK this;
    EnterProcI(IDirectInputDeviceCallback::Kbd::GetDeviceInfo,
               (_ "pp", pdcb, pdiW));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(IsValidSizeDIDEVICEINSTANCEW(pdiW->dwSize));

    AssertF(IsEqualGUID(&GUID_SysKeyboard   , &pdiW->guidInstance) ||
            IsEqualGUID(&GUID_SysKeyboardEm , &pdiW->guidInstance) ||
            IsEqualGUID(&GUID_SysKeyboardEm2, &pdiW->guidInstance));

    pdiW->guidProduct = GUID_SysKeyboard;

    pdiW->dwDevType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_KEYBOARD,
                                         this->dwKbdType);


    LoadStringW(g_hinst, IDS_STDKEYBOARD, pdiW->tszProductName, cA(pdiW->tszProductName));
    LoadStringW(g_hinst, IDS_STDKEYBOARD, pdiW->tszInstanceName, cA(pdiW->tszInstanceName));

    hres = S_OK;

    ExitOleProcR();
    return hres;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | GetProperty |
 *
 *          Retrieve a device property.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being retrieved.
 *
 *  @parm   LPDIPROPHEADER | pdiph |
 *
 *          Structure to receive property value.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          <c E_NOTIMPL> nothing happened.  The caller will do
 *          the default thing in response to <c E_NOTIMPL>.
 *
 *****************************************************************************/

STDMETHODIMP
CKbd_GetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPDIPROPHEADER pdiph)
{
    HRESULT hres = E_NOTIMPL;
    PDK this;
    EnterProcI(IDirectInputDeviceCallback::Kbd::GetProperty,
               (_ "pxxp", pdcb, ppropi->pguid, ppropi->iobj, pdiph));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    switch((DWORD)(UINT_PTR)(ppropi->pguid))
    {
        case (DWORD)(UINT_PTR)(DIPROP_KEYNAME):
        {
            LPDIPROPSTRING pdipstr = (PV)pdiph;

            memset( pdipstr->wsz, 0, cbX(pdipstr->wsz) );
            hres = DIGetKeyNameText( ppropi->iobj, ppropi->dwDevType, pdipstr->wsz, cA(pdipstr->wsz) );
        }
        break;

        case (DWORD)(UINT_PTR)(DIPROP_SCANCODE):
        {
            LPDIPROPDWORD pdipdw = (PV)pdiph;
            DWORD dwCode;

            AssertF( ppropi->iobj < this->df.dwNumObjs );
            AssertF( ppropi->dwDevType == this->df.rgodf[ppropi->iobj].dwType );

            dwCode = (DWORD)g_rgbKbdRMap[ppropi->iobj];
            
            if( dwCode == 0xC5 ) {
                dwCode = 0x451DE1;
            } else if( dwCode & 0x80 ) {
                dwCode = ((dwCode & 0x7F) << 8) | 0xE0;
            }
            pdipdw->dwData = dwCode;
            
            hres = S_OK;
        }
        break;

        default:
            SquirtSqflPtszV(sqflKbd | sqflBenign ,
                            TEXT("CKbd_GetProperty(iobj=%08x): E_NOTIMPL on guid: %08x"),
                            ppropi->iobj, ppropi->pguid);

            break;
    }


    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CKbd | GetCapabilities |
 *
 *          Get keyboard device capabilities.
 *
 *  @parm   LPDIDEVCAPS | pdc |
 *
 *          Device capabilities structure to receive result.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CKbd_GetCapabilities(PDICB pdcb, LPDIDEVCAPS pdc)
{
    HRESULT hres;
    PDK this;
    EnterProcI(IDirectInputDeviceCallback::Kbd::GetCapabilities,
               (_ "pp", pdcb, pdc));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    pdc->dwDevType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_KEYBOARD,
                                        this->dwKbdType);
    pdc->dwFlags = DIDC_ATTACHED;
    if (this->flEmulation) {
        pdc->dwFlags |= DIDC_ALIAS;
    }

    AssertF(pdc->dwAxes == 0);
    AssertF(pdc->dwPOVs == 0);
    pdc->dwButtons = this->df.dwNumObjs;
    hres = S_OK;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CKbd | GetPhysicalState |
 *
 *          Read the physical keyboard state into <p pksOut>.
 *
 *          Note that it doesn't matter if this is not atomic.
 *          If a key goes down or up while we are reading it,
 *          we will get a mix of old and new data.  No big deal.
 *
 *  @parm   PDK | this |
 *
 *          The object in question.
 *
 *  @parm   PKBDSTATE | pksOut |
 *
 *          Where to put the keyboard state.
 *  @returns
 *          None.
 *
 *****************************************************************************/

void INLINE
CKbd_GetPhysicalState(PDK this, PKBDSTAT pksOut)
{
    AssertF(this->pksPhys);
    *pksOut = *this->pksPhys;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | GetDeviceState |
 *
 *          Obtains the state of the keyboard device.
 *
 *          It is the caller's responsibility to have validated all the
 *          parameters and ensure that the device has been acquired.
 *
 *  @parm   OUT LPVOID | lpvData |
 *
 *          Keyboard data in the preferred data format.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpmdr> parameter is not a valid pointer.
 *
 *****************************************************************************/

STDMETHODIMP
CKbd_GetDeviceState(PDICB pdcb, LPVOID pvData)
{
    HRESULT hres;
    PDK this;
    PKBDSTAT pkstOut = pvData;
    EnterProcI(IDirectInputDeviceCallback::Kbd::GetDeviceState,
               (_ "pp", pdcb, pvData));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    /*
     *  ISSUE-2001/03/29-timgill older apps may need compat behaviour
     *  We never used to check whether or not the device was still 
     *  acquired since without exclusive mode there would be no reason for 
     *  the device not to be.  
     *  To keep behavior the same for older apps it might be better to 
     *  only fail if VIFL_CAPTURED is not set but just checking VIFL_ACQUIRED 
     *  is good enough for now, maybe for ever.
     */
//    if( !(this->pvi->fl & VIFL_CAPTURED) 
//      || (this->pvi->fl & VIFL_ACQUIRED) )
    if( this->pvi->fl & VIFL_ACQUIRED )
    {
        CKbd_GetPhysicalState(this, pkstOut);
        hres = S_OK;
    } else {
        RPF( "Keyboard VxD flags: 0x%08x", this->pvi->fl );
        hres = DIERR_INPUTLOST;
    }

    ExitOleProcR();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | GetObjectInfo |
 *
 *          Obtain the friendly name of an object, passwed by index
 *          into the preferred data format.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the object being accessed.
 *
 *  @parm   IN OUT LPDIDEVICEOBJECTINSTANCEW | pdidioiW |
 *
 *          Structure to receive information.  The
 *          <e DIDEVICEOBJECTINSTANCE.guidType>,
 *          <e DIDEVICEOBJECTINSTANCE.dwOfs>,
 *          and
 *          <e DIDEVICEOBJECTINSTANCE.dwType>
 *          fields have already been filled in.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
CKbd_GetObjectInfo(PDICB pdcb, LPCDIPROPINFO ppropi,
                               LPDIDEVICEOBJECTINSTANCEW pdidoiW)
{
    HRESULT hres = S_OK;
    PDK this;
    EnterProcI(IDirectInputDeviceCallback::Kbd::GetObjectInfo,
               (_ "pxp", pdcb, ppropi->iobj, pdidoiW));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(IsValidSizeDIDEVICEOBJECTINSTANCEW(pdidoiW->dwSize));

    if (ppropi->iobj < this->df.dwNumObjs) {
        AssertF(this->rgodf == this->df.rgodf);
        AssertF(ppropi->dwDevType == this->rgodf[ppropi->iobj].dwType);
        AssertF(ppropi->dwDevType & DIDFT_BUTTON);

#if 0
        /*
         * We keep using this code only to make it consistent with old code, 
         * otherwise we would use the new code.
         * Someday, we may change to use the new code. It is more accurate,
         * especially for Japanese Keyboard, and for future devices.
         */
        LoadStringW(g_hinst,
                    IDS_KEYBOARDOBJECT +
                    DIDFT_GETINSTANCE(ppropi->dwDevType),
                    pdidoiW->tszName, cA(pdidoiW->tszName));
#else
        {
            memset( pdidoiW->tszName, 0, cbX(pdidoiW->tszName) );
            hres = DIGetKeyNameText(ppropi->iobj, ppropi->dwDevType, pdidoiW->tszName, cA(pdidoiW->tszName) );
        }
#endif
    } else {
        hres = E_INVALIDARG;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | SetCooperativeLevel |
 *
 *          Notify the device of the cooperative level.
 *
 *  @parm   IN HWND | hwnd |
 *
 *          The window handle.
 *
 *  @parm   IN DWORD | dwFlags |
 *
 *          The cooperativity level.  We do not support exclusive access.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
CKbd_SetCooperativeLevel(PDICB pdcb, HWND hwnd, DWORD dwFlags)
{
    HRESULT hres;
    PDK this;
    EnterProcI(IDirectInputDeviceCallback::Kbd::SetCooperativityLevel,
               (_ "pxx", pdcb, hwnd, dwFlags));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);

    AssertF(DIGETEMFL(this->pvi->fl) == 0 ||
            DIGETEMFL(this->pvi->fl) == DIEMFL_KBD ||
            DIGETEMFL(this->pvi->fl) == DIEMFL_KBD2);

    /*
     *  We don't allow background exclusive access.
     *  This is actually not a real problem to support; we just don't feel like it
     *  because it's too dangerous.
     */
    if (!(this->pvi->fl & DIMAKEEMFL(DIEMFL_KBD2))) {

        if (dwFlags & DISCL_EXCLUSIVE) {
            if (dwFlags & DISCL_FOREGROUND) {
                this->pvi->fl |= VIFL_CAPTURED;
                this->pvi->fl |= VIFL_NOWINKEY;
                hres = S_OK;
            } else {                /* Disallow exclusive background */
                hres = E_NOTIMPL;
            }
        } else {
            this->pvi->fl &= ~VIFL_CAPTURED;
            this->pvi->fl &= ~VIFL_NOWINKEY;
            hres = S_OK;

            if (dwFlags & DISCL_NOWINKEY) {
                if (dwFlags & DISCL_FOREGROUND) {
                    this->pvi->fl |= VIFL_NOWINKEY;
                } else {
                    RPF("Kbd::SetCooperativeLevel: NOWINKEY not supported in Backgroud mode.");
                    hres = E_NOTIMPL;
                }
            }
        }
    } else {

        /*
         *  Emulation level 2 does not support background access.
         */

        if ((this->pvi->fl & DIMAKEEMFL(DIEMFL_KBD2)) &&
            (dwFlags & DISCL_BACKGROUND)) {
            hres = E_NOTIMPL;
        } else {
            this->pvi->fl &= ~VIFL_NOWINKEY;
            hres = S_OK;

            if (dwFlags & DISCL_NOWINKEY) {
                if (dwFlags & DISCL_FOREGROUND) {
                    this->pvi->fl |= VIFL_NOWINKEY;
                } else {
                    RPF("Kbd::SetCooperativeLevel: NOWINKEY not supported in Backgroud mode.");
                    hres = E_NOTIMPL;
                }
            }
        }
    }
    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | RunControlPanel |
 *
 *          Run the keyboard control panel.
 *
 *  @parm   IN HWND | hwndOwner |
 *
 *          The owner window.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

TCHAR c_tszKeyboard[] = TEXT("keyboard");

#pragma END_CONST_DATA

STDMETHODIMP
CKbd_RunControlPanel(PDICB pdcb, HWND hwnd, DWORD dwFlags)
{
    HRESULT hres;
    PDK this;
    EnterProcI(IDirectInputDeviceCallback::Kbd::RunControlPanel,
               (_ "pxx", pdcb, hwnd, dwFlags));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    hres = hresRunControlPanel(c_tszKeyboard);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | BuildDefaultActionMap |
 *
 *          Validate the passed action map, blanking out invalid ones.
 *
 *  @parm   LPDIACTIONFORMATW | pActionFormat |
 *
 *          Actions to map.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags used to indicate mapping preferences.
 *
 *  @parm   REFGUID | guidInst |
 *
 *          Device instance GUID.
 *
 *  @returns
 *
 *          <c E_NOTIMPL> 
 *
 *****************************************************************************/

STDMETHODIMP
CKbd_BuildDefaultActionMap
(
    PDICB               pdcb, 
    LPDIACTIONFORMATW   paf, 
    DWORD               dwFlags, 
    REFGUID             guidInst
)
{
    HRESULT hres;
    PDK this;

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    EnterProcI(IDirectInputDeviceCallback::CKbd::BuildDefaultActionMap, 
        (_ "ppxG", pdcb, paf, dwFlags, guidInst));

    this = _thisPvNm(pdcb, dcb);

    hres = CMap_BuildDefaultSysActionMap ( paf, dwFlags, DIPHYSICAL_KEYBOARD, 
        guidInst, &this->df, 0 /* Mouse button instance, ignored for kbds */ );

    ExitOleProcR();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method DWORD | CKbd | InitJapanese |
 *
 *          Initialize the Japanese keyboard goo.
 *
 *          Annoying quirk!  On Windows 95, Japanese keyboards generate
 *          their own scan codes.  But on Windows NT, they generate
 *          "nearly AT-compatible" scan codes.
 *
 *  @returns
 *
 *          KBDTYPE_ANYKBD or KBDTYPE_ANYKBD + KBDTYPE_NECTGL.
 *
 *****************************************************************************/

DWORD INTERNAL
CKbd_InitJapanese(PDK this, PVXDDEVICEFORMAT pdevf)
{
    DWORD dwSubType;
    UINT idKbd;
    DWORD dwRc;

#ifdef WINNT
#define WIN9X_RC( rc ) 
#else
#define WIN9X_RC( rc ) dwRc = ( rc )
#endif
    dwSubType = WrappedGetKeyboardType(1);
    if (HIBYTE(dwSubType) == 0x0D) {    /* NEC PC98 series */

        switch (LOBYTE(dwSubType)) {
        case 1:
        default:
            idKbd = IDDATA_KBD_NEC98;
            this->dwKbdType = DI8DEVTYPEKEYBOARD_NEC98;
            WIN9X_RC( KBDTYPE_ANYKBD + KBDTYPE_NECTGL );
            break;

        case 4:
            idKbd = IDDATA_KBD_NEC98LAPTOP;
            this->dwKbdType = DI8DEVTYPEKEYBOARD_NEC98LAPTOP;
            WIN9X_RC( KBDTYPE_ANYKBD + KBDTYPE_NECTGL );
            break;

        case 5:
            idKbd = IDDATA_KBD_NEC98_106;
            this->dwKbdType = DI8DEVTYPEKEYBOARD_NEC98106;
            WIN9X_RC( KBDTYPE_ANYKBD + KBDTYPE_NECTGL );
            break;
        }

        /*
         *  If the scan code for ESC is 1, then we're on an
         *  NEC98 keyboard that acts AT-like.
         */

        CAssertF(IDDATA_KBD_NEC98_NT - IDDATA_KBD_NEC98 ==
                 IDDATA_KBD_NEC98LAPTOP_NT - IDDATA_KBD_NEC98LAPTOP);
        CAssertF(IDDATA_KBD_NEC98_NT - IDDATA_KBD_NEC98 ==
                 IDDATA_KBD_NEC98_106_NT - IDDATA_KBD_NEC98_106);

        if (MapVirtualKey(VK_ESCAPE, 0) == DIK_ESCAPE) {
            idKbd += IDDATA_KBD_NEC98_NT - IDDATA_KBD_NEC98;
        }

    } else {

        switch (dwSubType) {
        case 0:
            this->dwKbdType = DI8DEVTYPEKEYBOARD_PCENH;
            dwRc = KBDTYPE_ENH;
            goto done;                      /* Yuck */

        case 1:
            idKbd = IDDATA_KBD_JAPANAX;
            this->dwKbdType = DI8DEVTYPEKEYBOARD_JAPANAX;
            WIN9X_RC( KBDTYPE_ANYKBD );
            break;

        case 13:
        case 14:
        case 15:
            idKbd = IDDATA_KBD_J3100;
            this->dwKbdType = DI8DEVTYPEKEYBOARD_J3100;
            WIN9X_RC( KBDTYPE_ANYKBD );
            break;

        case 4:             /* Rumored to be Epson */
        case 5:             /* Rumored to be Fujitsu */
        case 7:             /* Rumored to be IBMJ */
        case 10:            /* Rumored to be Matsushita */
        case 18:            /* Rumored to be Toshiba */
        default:
            idKbd = IDDATA_KBD_JAPAN106;
            this->dwKbdType = DI8DEVTYPEKEYBOARD_JAPAN106;
            WIN9X_RC( KBDTYPE_ANYKBD );
            break;
        }
    }

#undef WIN9X_RC

#ifdef WINNT
    /*
         *  ISSUE-2001/03/29-timgill Japanese keyboard assumption needs testing
         *  All Japanese keyboards on NT have toggle keys
         *  Except subtype zero? Needs test
     */
    dwRc = KBDTYPE_ANYKBD + KBDTYPE_NTTGL;
#endif

    /*
     *  Now load up the translation table goo.
     */
    pdevf->dwExtra = (DWORD)(UINT_PTR)pvFindResource(g_hinst, idKbd, RT_RCDATA);
    if (pdevf->dwExtra == 0) {
        dwRc = 0;
    }

done:;
    return dwRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | Init |
 *
 *          Initialize the object by establishing the data format
 *          based on the keyboard type.  Anything we don't recognize,
 *          we treat as a PC Enhanced keyboard.
 *
 *  @parm   REFGUID | rguid |
 *
 *          The instance GUID we are being asked to create.
 *
 *****************************************************************************/

HRESULT INTERNAL
CKbd_Init(PDK this, REFGUID rguid)
{
    DWORD dwDevType;
    UINT ib;
    HRESULT hres;
    VXDDEVICEFORMAT devf;
    EnterProc(CKbd_Init, (_ "pG", this, rguid));

#ifdef DEBUG
    /*
     *  Check that the Japan tables aren't messed up.
     */
    {
        UINT idk;

        for (idk = IDDATA_KBD_NEC98; idk <= IDDATA_KBD_J3100; idk++) {
            BYTE rgb[DIKBD_CKEYS];
            HANDLE hrsrc;
            LPBYTE pb;
            ZeroX(rgb);

            /*
             *  Make sure the table exists.
             */
            hrsrc = FindResource(g_hinst, (LPTSTR)(LONG_PTR)(idk), RT_RCDATA);
            AssertF(hrsrc);
            pb = LoadResource(g_hinst, hrsrc);

            /*
             *  Walk the table and make sure each thing that exists
             *  in the translation table also exists in our master table.
             *  Also make sure that it isn't a dup with something else
             *  in the same table.
             */

            /*
             *  Note, however, that the JAPAN106 keyboard contains
             *  dups so we can save having to write an entire
             *  translation table.  And then NEC98_NT tables contain
             *  lots of dups out of sheer laziness.
             */

            for (ib = 0; ib < DIKBD_CKEYS; ib++) {
                if (pb[ib]) {
                    AssertF(c_rgktWhich[pb[ib]] & KBDTYPE_ANYKBD);
                    AssertF(fLorFF(idk == IDDATA_KBD_JAPAN106 && ib == 0x73,
                                   rgb[pb[ib]] == 0));
                    rgb[pb[ib]] = 1;
                }
            }
        }
    }
#endif

    this->df.dwSize = cbX(DIDATAFORMAT);
    this->df.dwObjSize = cbX(DIOBJECTDATAFORMAT);
    this->df.dwDataSize = sizeof(KBDSTAT);
    this->df.rgodf = this->rgodf;

    this->dwKbdType = WrappedGetKeyboardType(0);

    /*
     *  Create the object with the most optimistic data format.
     *  This allows apps to access new keys without having to rev DINPUT.
     *
     *  However, leave out the following scan codes because some keyboards
     *  generate them spuriously:
     *
     *  0xB6
     *
     *      If you hold the right shift key and then press an
     *      extended arrow key, then release both, some keyboards
     *      generate the following:
     *
     *          0x36        - right shift down
     *          0xE0 0xB6   - extended right shift up (?)
     *          0xE0 0x4B   - extended left arrow down
     *          0xE0 0xCB   - extended left arrow up
     *          0xE0 0x36   - extended right shift down (?)
     *          0xE6        - right shift up
     *
     *      The stray 0xE0 0x36 needs to be ignored.
     *
     *  0xAA
     *
     *      Same as 0xB6, but with the left shift key.
     *
     *
     */
    for (ib = 0; ib < DIKBD_CKEYS; ib++) {
        if (ib != 0xAA && ib != 0xB6) {
            this->rgodf[ib].pguid = &GUID_Key;
            this->rgodf[ib].dwOfs = ib;
            this->rgodf[ib].dwType = DIDFT_PSHBUTTON | DIDFT_MAKEINSTANCE(ib);
            AssertF(this->rgodf[ib].dwFlags == 0);
        }
    }
    devf.cObj = DIKBD_CKEYS;

    devf.cbData = cbX(KBDSTAT);
    devf.rgodf = this->rgodf;

    /*
     *  But first a word from our sponsor:  Figure out if this keyboard
     *  needs a translation table.
     */

    devf.dwExtra = 0;               /* Assume no translation */
    if (this->dwKbdType != 7) {     /* Not a yucky Japanese keyboard */
        switch (this->dwKbdType) {
        case DI8DEVTYPEKEYBOARD_PCXT:  dwDevType = KBDTYPE_XT;  break;
        case DI8DEVTYPEKEYBOARD_PCAT:  dwDevType = KBDTYPE_AT;  break;
        default:
        case DI8DEVTYPEKEYBOARD_PCENH: dwDevType = KBDTYPE_ENH; break;
        }
    } else {                        /* Yucky Japanese keyboard */
        dwDevType = CKbd_InitJapanese(this, &devf);
        if (!dwDevType) {
            goto justfail;
        }
    }

    /*
     *  And now a word from our other sponsor:  Figure out the
     *  emulation flags based on the GUID.
     */

    AssertF(GUID_SysKeyboard   .Data1 == 0x6F1D2B61);
    AssertF(GUID_SysKeyboardEm .Data1 == 0x6F1D2B82);
    AssertF(GUID_SysKeyboardEm2.Data1 == 0x6F1D2B83);

    switch (rguid->Data1) {

    default:
    case 0x6F1D2B61:
        AssertF(IsEqualGUID(rguid, &GUID_SysKeyboard));
        AssertF(this->flEmulation == 0);
        break;

    case 0x6F1D2B82:
        AssertF(IsEqualGUID(rguid, &GUID_SysKeyboardEm));
        this->flEmulation = DIEMFL_KBD;
        break;

    case 0x6F1D2B83:
        AssertF(IsEqualGUID(rguid, &GUID_SysKeyboardEm2));
        this->flEmulation = DIEMFL_KBD2;
        break;

    }

    devf.dwEmulation = this->flEmulation;

    hres = Hel_Kbd_CreateInstance(&devf, &this->pvi);
    if (SUCCEEDED(hres)) {
        UINT cobj;
        BYTE rgbSeen[DIKBD_CKEYS];
        AssertF(this->pvi);
        AssertF(this->df.dwFlags == 0);
        AssertF(this->df.dwNumObjs == 0);

        /*
         *  Japanese keyboards have many-to-one mappings, so
         *  we need to filter out the dups or we end up in big
         *  trouble.
         */
        ZeroX(rgbSeen);

        /*
         *  Now create the real data format.
         *
         *  We shadow this->df.dwNumObjs in cobj so that the compiler
         *  can enregister it.
         *
         *  Note that we filter through the translation table if there
         *  is one.
         */

        cobj = 0;
        for (ib = 0; ib < DIKBD_CKEYS; ib++) {
            BYTE bScan = devf.dwExtra ? ((LPBYTE)devf.dwExtra)[ib] : ib;
            if ((c_rgktWhich[bScan] & dwDevType) && !rgbSeen[bScan]) {
                PODF podf = &this->rgodf[cobj];
                rgbSeen[bScan] = 1;
                podf->pguid = &GUID_Key;
                podf->dwOfs = bScan;

                /*
                 * To make a mapping talbe for original scan code from DIK_* code.
                 */
                g_rgbKbdRMap[cobj] = (BYTE) ib;
                if( dwDevType == KBDTYPE_ENH ) {  //how about Japanese KBD?
                    if( ib == 0x45 || ib == 0xC5) {
                        g_rgbKbdRMap[cobj] = (ib & 0x7F) | (ib ^ 0x80);
                    }
                }

                if (c_rgktWhich[bScan] & dwDevType & (KBDTYPE_NECTGL|KBDTYPE_NTTGL) ) {
                    podf->dwType = DIDFT_TGLBUTTON | DIDFT_MAKEINSTANCE(bScan);
                } else {
                    podf->dwType = DIDFT_PSHBUTTON | DIDFT_MAKEINSTANCE(bScan);
                }
                AssertF(podf->dwFlags == 0);
                cobj++;
                this->df.dwNumObjs++;
            }
        }

        this->pksPhys = this->pvi->pState;

    } else {
    justfail:;
        hres = E_FAIL;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *      CKbd_New       (constructor)
 *
 *****************************************************************************/

STDMETHODIMP
CKbd_New(PUNK punkOuter, REFGUID rguid, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Kbd::<constructor>,
               (_ "Gp", riid, ppvObj));

    AssertF(IsEqualGUID(rguid, &GUID_SysKeyboard) ||
            IsEqualGUID(rguid, &GUID_SysKeyboardEm) ||
            IsEqualGUID(rguid, &GUID_SysKeyboardEm2));

    hres = Common_NewRiid(CKbd, punkOuter, riid, ppvObj);

    if (SUCCEEDED(hres)) {
        /* Must use _thisPv in case of aggregation */
        PDK this = _thisPv(*ppvObj);

        if (SUCCEEDED(hres = CKbd_Init(this, rguid))) {
        } else {
            Invoke_Release(ppvObj);
        }

    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define CKbd_Signature        0x2044424B      /* "KBD " */

Interface_Template_Begin(CKbd)
    Primary_Interface_Template(CKbd, IDirectInputDeviceCallback)
Interface_Template_End(CKbd)

Primary_Interface_Begin(CKbd, IDirectInputDeviceCallback)
    CKbd_GetInstance,
    CDefDcb_GetVersions,
    CKbd_GetDataFormat,
    CKbd_GetObjectInfo,
    CKbd_GetCapabilities,
    CKbd_Acquire,
    CDefDcb_Unacquire,
    CKbd_GetDeviceState,
    CKbd_GetDeviceInfo,
    CKbd_GetProperty,
    CDefDcb_SetProperty,
    CDefDcb_SetEventNotification,
    CKbd_SetCooperativeLevel,
    CKbd_RunControlPanel,
    CDefDcb_CookDeviceData,
    CDefDcb_CreateEffect,
    CDefDcb_GetFFConfigKey,
    CDefDcb_SendDeviceData,
    CDefDcb_Poll,
    CDefDcb_GetUsage,
    CDefDcb_MapUsage,
    CDefDcb_SetDIData,
    CKbd_BuildDefaultActionMap,
Primary_Interface_End(CKbd, IDirectInputDeviceCallback)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\digendef.c ===
/*****************************************************************************
 *
 *  DIGenDef.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Default IDirectInputDevice callback.
 *
 *  Contents:
 *
 *      CDefDcb_Acquire
 *      CDefDcb_Unacquire
 *      CDefDcb_GetProperty
 *      CDefDcb_SetProperty
 *      CDefDcb_SetCooperativeLevel
 *      CDefDcb_CookDeviceData
 *      CDefDcb_CreateEffect
 *      CDefDcb_GetFFConfigKey
 *      CDefDcb_SendDeviceData
 *      CDefDcb_Poll
 *      CDefDcb_MapUsage
 *      CDefDcb_GetUsage
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflNil

/*****************************************************************************
 *
 *      Note!  These are generic default functions that all return
 *      E_NOTIMPL.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | Acquire |
 *
 *          Tell the device driver to begin data acquisition.
 *
 *          It is the caller's responsibility to have set the
 *          data format before obtaining acquisition.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTACQUIRED>: The device could not be acquired.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_Acquire(PDICB pdcb)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::Acquire, (_ "p", pdcb));

    hres = S_FALSE;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | Unacquire |
 *
 *          Tell the device driver to stop data acquisition.
 *
 *          It is the caller's responsibility to call this only
 *          when the device has been acquired.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTACQUIRED>: The device was not acquired.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_Unacquire(PDICB pdcb)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::Unacquire, (_ "p", pdcb));

    hres = S_FALSE;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CDefDcb | GetProperty |
 *
 *          Retrieve a device property.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being retrieved.
 *
 *  @parm   LPDIPROPHEADER | pdiph |
 *
 *          Where to put the property value.
 *
 *  @returns
 *
 *          <c E_NOTIMPL> nothing happened.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_GetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPDIPROPHEADER pdiph)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::GetProperty,
               (_ "pxxp", pdcb, ppropi->pguid, ppropi->iobj, pdiph));

    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CDefDcb | SetProperty |
 *
 *          Set a device property.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being set.
 *
 *  @parm   LPCDIPROPHEADER | pdiph |
 *
 *          Structure containing property value.
 *
 *  @returns
 *
 *          <c E_NOTIMPL> nothing happened.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_SetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPCDIPROPHEADER pdiph)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::SetProperty,
               (_ "pxxp", pdcb, ppropi->pguid, ppropi->iobj, pdiph));

    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | SetEventNotification |
 *
 *          Called by DirectInput to inquire whether the device
 *          supports event notifications.
 *
 *  @parm   IN PDM | this |
 *
 *          The object in question.
 *
 *  @field  HANDLE | h |
 *
 *          The notification handle, if any.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c S_FALSE>: The operation was begun and should be completed
 *          by the caller by communicating with the <t VXDINSTANCE>.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_SetEventNotification(PDICB pdcb, HANDLE h)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::DefDcb::SetEventNotification,
               (_ "px", pdcb, h));

    /*
     *  Yes, we support it.  Please do it for me.
     */
    hres = S_FALSE;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefdcb | SetCooperativeLevel |
 *
 *          Notify the device of the cooperative level.
 *
 *  @parm   IN HWND | hwnd |
 *
 *          The window handle.
 *
 *  @parm   IN DWORD | dwFlags |
 *
 *          The cooperativity level.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_SetCooperativeLevel(PDICB pdcb, HWND hwnd, DWORD dwFlags)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::SetCooperativityLevel,
               (_ "pxx", pdcb, hwnd, dwFlags));

    hres = S_OK;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | CookDeviceData |
 *
 *          Manipulate buffered device data.
 *
 *  @parm   DWORD | cdod |
 *
 *          Number of objects to cook; zero is a valid value.
 *
 *  @parm   LPDIDEVICEOBJECTDATA | rgdod |
 *
 *          Array of object data to cook.
 *
 *  @returns
 *
 *          <c E_NOTIMPL>: Nothing happened.
 *
 ***************************************************************************/

STDMETHODIMP
CDefDcb_CookDeviceData
(
    PDICB                   pdcb, 
    DWORD                   cdod, 
    LPDIDEVICEOBJECTDATA    rgdod
)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::CookDeviceData,
               (_ "pxp", pdcb, cdod, rgdod));

    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | CreateEffect |
 *
 *          Create an <i IDirectInputEffectDriver> interface.
 *
 *  @parm   LPDIRECTINPUTEFFECTSHEPHERD * | ppes |
 *
 *          Receives the shepherd for the effect driver.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_CreateEffect(PDICB pdcb, LPDIRECTINPUTEFFECTSHEPHERD *ppes)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Kbd::CreateEffect, (_ "p", pdcb));

    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | GetFFConfigKey |
 *
 *          Open and return the registry key that contains
 *          force feedback configuration information.
 *
 *  @parm   DWORD | sam |
 *
 *          Security access mask.
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives the registry key.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_GetFFConfigKey(PDICB pdcb, DWORD sam, PHKEY phk)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::GetFFConfigKey,
               (_ "px", pdcb, sam));

    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | SendDeviceData |
 *
 *          Spew some data to the device.
 *
 *  @parm   DWORD | cbdod |
 *
 *          Size of each object.
 *
 *  @parm   IN LPCDIDEVICEOBJECTDATA | rgdod |
 *
 *          Array of <t DIDEVICEOBJECTDATA> structures.
 *
 *  @parm   INOUT LPDWORD | pdwInOut |
 *
 *          Number of items actually sent.
 *
 *  @parm   DWORD | fl |
 *
 *          Flags.
 *
 *  @returns
 *
 *          <c E_NOTIMPL> because we don't support output.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_SendDeviceData(PDICB pdcb, DWORD cbdod, LPCDIDEVICEOBJECTDATA rgdod,
                       LPDWORD pdwInOut, DWORD fl)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::SendDeviceData, (_ "p", pdcb));

    *pdwInOut = 0;
    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | Poll |
 *
 *          Ping down into the driver to get the latest data.
 *
 *  @returns
 *
 *          <c S_FALSE> because nothing is pollable.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_Poll(PDICB pdcb)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::Poll, (_ "p", pdcb));

    hres = S_FALSE;

    ExitOleProcR();
    return hres;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | GetVersions |
 *
 *          Obtain version information about the force feedback
 *          hardware and driver.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_UNSUPPORTED> = <c E_NOTIMPL>: No version
 *          information is available.
 *
 ***************************************************************************/

STDMETHODIMP
CDefDcb_GetVersions(PDICB pdcb, LPDIDRIVERVERSIONS pvers)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::GetVersions, (_ "p", pdcb));

    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | MapUsage |
 *
 *          Given a usage and usage page (munged into a single
 *          <t DWORD>), find a device object that matches it.
 *
 *  @parm   DWORD | dwUsage |
 *
 *          The usage page and usage combined into a single <t DWORD>
 *          with the <f DIMAKEUSAGEDWORD> macro.
 *
 *  @parm   PINT | piOut |
 *
 *          Receives the object index of the found object, if successful.
 *
 *  @returns
 *
 *          <c E_NOTIMPL> because we don't support usages.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_MapUsage(PDICB pdcb, DWORD dwUsage, PINT piOut)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::MapUsage, (_ "p", pdcb));

    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method DWORD | CDefDcb | GetUsage |
 *
 *          Given an object index, return the usage and usage page,
 *          packed into a single <t DWORD>.
 *
 *  @parm   int | iobj |
 *
 *          The object index to convert.
 *
 *  @returns
 *
 *          Zero because we don't support usages.
 *
 *****************************************************************************/

STDMETHODIMP_(DWORD)
CDefDcb_GetUsage(PDICB pdcb, int iobj)
{
    EnterProcI(IDirectInputDeviceCallback::Def::GetUsage, (_ "p", pdcb));

    return 0;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | SetDIData |
 *
 *          Set DirectInput version and AppHack data from CDIDev *.
 *
 *  @parm   DWORD | dwVer |
 *
 *          DirectInput version
 *
 *  @parm   LPVOID | lpdihacks |
 *
 *          AppHack data
 *
 *  @returns
 *
 *          <c E_NOTIMPL> because we can't store the data in the device 
 *          specific structure from the default callback.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_SetDIData(PDICB pdcb, DWORD dwVer, LPVOID lpdihacks)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::SetDIData, (_ "pup", pdcb, dwVer, lpdihacks));

    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | BuildDefaultActionMap |
 *
 *          Generate default mappings for the objects on this device.
 *
 *  @parm   LPDIACTIONFORMATW | pActionFormat |
 *
 *          Actions to map.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags used to indicate mapping preferences.
 *
 *  @parm   REFGUID | guidInst |
 *
 *          Device instance GUID.
 *
 *  @returns
 *
 *          <c E_NOTIMPL> because default mapping has to be done by specific 
 *          device callback.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_BuildDefaultActionMap
(
    PDICB               pdcb, 
    LPDIACTIONFORMATW   paf, 
    DWORD               dwFlags, 
    REFGUID             guidInst
)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::BuildDefaultActionMap, 
        (_ "ppxG", pdcb, paf, dwFlags, guidInst));

    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dihel.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dihel.h
 *  Content:    DirectInput internal include file for the
 *              hardware emulation layer
 *
 ***************************************************************************/

HRESULT EXTERNAL Hel_AcquireInstance(PVXDINSTANCE pvi);
HRESULT EXTERNAL Hel_UnacquireInstance(PVXDINSTANCE pvi);
HRESULT EXTERNAL Hel_SetBufferSize(PVXDDWORDDATA pvdd);
HRESULT EXTERNAL Hel_DestroyInstance(PVXDINSTANCE pvi);

HRESULT EXTERNAL Hel_SetDataFormat(PVXDDATAFORMAT pvdf);
HRESULT EXTERNAL Hel_SetNotifyHandle(PVXDDWORDDATA pvdd);

HRESULT EXTERNAL
Hel_Mouse_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut);

HRESULT EXTERNAL
Hel_Kbd_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut);

HRESULT EXTERNAL Hel_Kbd_InitKeys(PVXDDWORDDATA pvdd);

HRESULT EXTERNAL Hel_Joy_GetInitParms(DWORD dwExternalID, PVXDINITPARMS pvip);

#ifndef WINNT
HRESULT EXTERNAL Hel_Joy_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut);
HRESULT EXTERNAL Hel_Joy_Ping(PVXDINSTANCE pvi);
HRESULT EXTERNAL Hel_Joy_ConfigChanged(DWORD dwFlags);
HRESULT EXTERNAL Hel_Joy_GetAxisCaps(DWORD dwExternalID, PVXDAXISCAPS pvac, LPJOYREGHWCONFIG phwc );
#endif

/*
 *  HID always runs via ring 3.
 */
#define Hel_HID_CreateInstance          CEm_HID_CreateInstance

#ifdef WINNT
#define IoctlHw( ioctl, pvIn, cbIn, pvOut, cbOut ) ( (HRESULT)DIERR_BADDRIVERVER )
#else
HRESULT EXTERNAL
IoctlHw(DWORD ioctl, LPVOID pvIn, DWORD cbIn, LPVOID pvOut, DWORD cbOut);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dihel.c ===
/*****************************************************************************
 *
 *  DIHel.c
 *
 *  Copyright (c) 1996 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Hardware emulation layer for DirectInput.
 *
 *  Contents:
 *
 *      Hel_AcquireInstance
 *      Hel_UnacquireInstance
 *      Hel_SetBufferSize
 *      Hel_DestroyInstance
 *
 *      Hel_SetDataFormat
 *      Hel_SetNotifyHandle
 *
 *      Hel_Mouse_CreateInstance
 *      Hel_Kbd_CreateInstance
 *      Hel_Kbd_InitKeys
 *      Hel_Joy_CreateInstance
 *      Hel_Joy_Ping
 *      Hel_Joy_GetInitParms
 *
 *      IoctlHw
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflHel

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | IoctlHw |
 *
 *          Send the IOCtl to the hardware device.
 *
 *  @parm   DWORD | ioctl |
 *
 *          I/O control code.
 *
 *  @parm   IN LPVOID | pvIn |
 *
 *          Optional input parameter.
 *
 *  @parm   DWORD | cbIn |
 *
 *          Size of input buffer in bytes.
 *
 *  @parm   IN LPVOID | pvOut |
 *
 *          Optional output parameter.
 *
 *  @parm   DWORD | cbOut |
 *
 *          Size of output buffer in bytes.
 *
 *  @returns
 *
 *          <c S_OK> if the ioctl succeeded and returned the correct
 *          number of bytes, else something based on the Win32 error code.
 *
 *****************************************************************************/

#ifndef WINNT
HRESULT EXTERNAL
IoctlHw(DWORD ioctl, LPVOID pvIn, DWORD cbIn, LPVOID pvOut, DWORD cbOut)
{
    HRESULT hres;
    DWORD cbRc;

    if (g_hVxD != INVALID_HANDLE_VALUE) {
        if (DeviceIoControl(g_hVxD, ioctl, pvIn, cbIn,
                            pvOut, cbOut, &cbRc, 0)) {
            if (cbRc == cbOut) {
                hres = S_OK;
            } else {
                SquirtSqflPtszV(sqfl, TEXT("Ioctl(%08x) returned wrong cbOut"),
                                ioctl);
                hres = DIERR_BADDRIVERVER;
            }
        } else {
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("Ioctl(%08x) failed, error %d"),
                            ioctl, GetLastError());
            hres = hresLe(GetLastError());
        }
    } else {
        hres = DIERR_BADDRIVERVER;
    }
    return hres;
}
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_IoctlChoose |
 *
 *          Send the IOCtl to the hardware device if it is native,
 *          or perform the operation through emulation if it is emulated.
 *
 *  @parm   PVXDINSTANCE | pvi |
 *
 *          The device in question.
 *
 *  @parm   PFNHANDLER | pfn |
 *
 *          The emulation function to call to carry out the operation.
 *
 *  @parm   DWORD | ioctl |
 *
 *          I/O control code.
 *
 *  @parm   IN LPVOID | pvIn |
 *
 *          Optional input parameter.
 *
 *  @parm   DWORD | cbIn |
 *
 *          Size of input buffer in bytes.
 *
 *****************************************************************************/

typedef HRESULT (EXTERNAL *PFNHANDLER)(PV pv);

HRESULT INTERNAL
Hel_IoctlChoose(PVXDINSTANCE pvi, PFNHANDLER pfn,
                DWORD ioctl, LPVOID pvIn, DWORD cbIn)
{
    HRESULT hres;
    if (!(pvi->fl & VIFL_EMULATED)) {
        hres = IoctlHw(ioctl, pvIn, cbIn, 0, 0);
    } else {
        hres = pfn(pvIn);
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_AcquireInstance |
 *
 *          Attempt to acquire the device instance, using either the
 *          device driver or emulation, whichever is appropriate.
 *
 *  @parm   PVXDINSTANCE | pvi |
 *
 *          The instance to acquire.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_AcquireInstance(PVXDINSTANCE pvi)
{
    return Hel_IoctlChoose(pvi, CEm_AcquireInstance,
                           IOCTL_ACQUIREINSTANCE, &pvi, cbX(pvi));
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_UnacquireInstance |
 *
 *          Attempt to unacquire the device instance.
 *
 *  @parm   PVXDINSTANCE | pvi |
 *
 *          The instance to unacquire.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_UnacquireInstance(PVXDINSTANCE pvi)
{
    return Hel_IoctlChoose(pvi, CEm_UnacquireInstance,
                           IOCTL_UNACQUIREINSTANCE, &pvi, cbX(pvi));
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_SetBufferSize |
 *
 *          Set the buffer size.
 *
 *  @parm   PVXDDWORDDATA | pvdd |
 *
 *          Information about the buffer size.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_SetBufferSize(PVXDDWORDDATA pvdd)
{
    HRESULT hres;
    EnterProc(Hel_SetBufferSize, (_ "pxx", pvdd->pvi, pvdd->dw, pvdd->pvi->fl));

    hres = Hel_IoctlChoose(pvdd->pvi, CEm_SetBufferSize,
                           IOCTL_SETBUFFERSIZE, pvdd, cbX(*pvdd));

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_DestroyInstance |
 *
 *          Destroy the device instance in the appropriate way.
 *
 *  @parm   PVXDINSTANCE | pvi |
 *
 *          The instance.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_DestroyInstance(PVXDINSTANCE pvi)
{
    return Hel_IoctlChoose(pvi, CEm_DestroyInstance,
                         IOCTL_DESTROYINSTANCE, &pvi, cbX(pvi));
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_SetDataFormat |
 *
 *          Set the data format.
 *
 *  @parm   PVXDDATAFORMAT | pvdf |
 *
 *          Information about the data format.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_SetDataFormat(PVXDDATAFORMAT pvdf)
{
    return Hel_IoctlChoose(pvdf->pvi, CEm_SetDataFormat,
                           IOCTL_SETDATAFORMAT, pvdf, cbX(*pvdf));
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_SetNotifyHandle |
 *
 *          Set the event handle for notification.
 *
 *  @parm   PVXDDWORDDATA | pvdd |
 *
 *          9x: dw = ring 0 handle. Dinput calls _OpenVxDHandle to get ring 0 handle.
 *          NT: dw = ring 3 handle. DINPUT.SYS translates the handle to pointer.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_SetNotifyHandle(PVXDDWORDDATA pvdd)
{
    HRESULT hres;
    if (!(pvdd->pvi->fl & VIFL_EMULATED)) {
#ifndef WINNT
        AssertF(_OpenVxDHandle);
        if (pvdd->dw) {
            pvdd->dw = _OpenVxDHandle((HANDLE)pvdd->dw);
        }
#endif

        hres = IoctlHw(IOCTL_SETNOTIFYHANDLE, pvdd, cbX(*pvdd), 0, 0);
    } else {
        hres = S_OK;
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CREATEDEVICEINFO |
 *
 *          Describes how to create the device either via the driver or
 *          via emulation.
 *
 *  @parm   DWORD | dwIoctl |
 *
 *          IOCtl code to try.
 *
 *  @parm   DWORD | flEmulation |
 *
 *          Flag in registry that forces emulation.
 *
 *  @parm   EMULATIONCREATEPROC | pfnCreate |
 *
 *          Function that creates emulation object.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

typedef HRESULT (EXTERNAL *EMULATIONCREATEPROC)
                (PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut);


typedef struct CREATEDEVICEINFO {
    DWORD dwIoctl;
    DWORD flEmulation;
    EMULATIONCREATEPROC pfnCreate;
} CREATEDEVICEINFO, *PCREATEDEVICEINFO;

CREATEDEVICEINFO c_cdiMouse = {
    IOCTL_MOUSE_CREATEINSTANCE,
    DIEMFL_MOUSE,
    CEm_Mouse_CreateInstance,
};

CREATEDEVICEINFO c_cdiKbd = {
    IOCTL_KBD_CREATEINSTANCE,
    DIEMFL_KBD | DIEMFL_KBD2,
    CEm_Kbd_CreateInstance,
};

CREATEDEVICEINFO c_cdiJoy = {
    IOCTL_JOY_CREATEINSTANCE,
    DIEMFL_JOYSTICK,
    CEm_Joy_CreateInstance,
};

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_CreateInstance |
 *
 *          Attempt to create the device instance through the driver
 *          with the specified IOCtl.
 *
 *          If that is not possible, then use the emulation callback.
 *
 *  @parm   PCREATEDEVICEINFO | pcdi |
 *
 *          Describes how to create the device.
 *
 *  @parm   PVXDDEVICEFORMAT | pdevf |
 *
 *          Describes the device being created.
 *
 *  @parm   PVXDINSTANCE * | ppviOut |
 *
 *          Receives created instance.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_CreateInstance(PCREATEDEVICEINFO pcdi,
                   PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut)
{
    HRESULT hres;

    pdevf->dwEmulation |= g_flEmulation;
    pdevf->dwEmulation &= pcdi->flEmulation;

    if (pdevf->dwEmulation ||
        (FAILED(hres = IoctlHw(pcdi->dwIoctl, pdevf, cbX(*pdevf),
                        ppviOut, cbX(*ppviOut))))) {
        hres = pcdi->pfnCreate(pdevf, ppviOut);
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_Mouse_CreateInstance |
 *
 *          Attempt to create the device instance through the driver.
 *          If that is not possible, then use the emulation layer.
 *
 *  @parm   PVXDDEVICEFORMAT | pdevf |
 *
 *          Describes the device being created.
 *
 *  @parm   PVXDINSTANCE * | ppviOut |
 *
 *          Receives created instance.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_Mouse_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut)
{
    return Hel_CreateInstance(&c_cdiMouse, pdevf, ppviOut);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_Kbd_CreateInstance |
 *
 *          Attempt to create the device instance through the driver.
 *          If that is not possible, then use the emulation layer.
 *
 *  @parm   PVXDDEVICEFORMAT | pdevf |
 *
 *          Describes the device being created.
 *
 *  @parm   PVXDINSTANCE * | ppviOut |
 *
 *          Receives created instance.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_Kbd_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut)
{
    return Hel_CreateInstance(&c_cdiKbd, pdevf, ppviOut);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_Kbd_InitKeys |
 *
 *          Tell the device driver (or emulation) about the key state.
 *
 *  @parm   PVXDDWORDDATA | pvdd |
 *
 *          The instance and the key state.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_Kbd_InitKeys(PVXDDWORDDATA pvdd)
{
    return Hel_IoctlChoose(pvdd->pvi, CEm_Kbd_InitKeys,
                           IOCTL_KBD_INITKEYS, pvdd, cbX(*pvdd));
}

#ifndef WINNT
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_Joy_CreateInstance |
 *
 *          Attempt to create the device instance through the driver.
 *          If that is not possible, then use the emulation layer.
 *
 *  @parm   PVXDDEVICEFORMAT | pdevf |
 *
 *          Describes the device being created.
 *
 *  @parm   PVXDINSTANCE * | ppviOut |
 *
 *          Receives created instance.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_Joy_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut)
{
    return Hel_CreateInstance(&c_cdiJoy, pdevf, ppviOut);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_Joy_Ping |
 *
 *          Ask the device driver (or emulation) to get the joystick info.
 *
 *  @parm   PVXDDWORDDATA | pvdd |
 *
 *          The instance and the key state.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_Joy_Ping(PVXDINSTANCE pvi)
{
    return Hel_IoctlChoose(pvi, CEm_Joy_Ping,
                           IOCTL_JOY_PING8, &pvi, cbX(pvi));
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_Joy_ConfigChanged |
 *
 *          Tell vjoyd config has been changed.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_Joy_ConfigChanged(DWORD dwFlags)
{
    return IoctlHw(IOCTL_JOY_CONFIGCHANGED, &dwFlags, cbX(dwFlags), NULL, 0);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_Joy_GetAxisCaps |
 *
 *          Obtain a bitmask of the axes supported by the joystick.
 *          If VJOYD won't tell us, then we figure it out from the
 *          registry structure passed in.
 *
 *  @parm   DWORD | dwExternalID |
 *
 *          The external joystick number.
 *
 *  @parm   PVXDAXISCAPS | pvac |
 *
 *          Structure to receive the axis capabilities.
 *
 *  @parm   LPJOYREGHWCONFIG | phwc |
 *
 *          The joystick settings as reported by the registry.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_Joy_GetAxisCaps
(
    DWORD dwExternalID, 
    PVXDAXISCAPS pvac, 
    LPJOYREGHWCONFIG phwc
)
{
    HRESULT hres;
    DWORD   dwRegAxes;

    /*
     *  Every joystick has an X and Y (no way to tell)
     *  Mark as position axes or they won't count!
     */
    dwRegAxes = JOYPF_X | JOYPF_Y | JOYPF_POSITION;

    if (phwc->hws.dwFlags & JOY_HWS_HASZ) {
        dwRegAxes |= JOYPF_Z;
    }

    if ( (phwc->hws.dwFlags & JOY_HWS_HASR) || (phwc->dwUsageSettings & JOY_US_HASRUDDER) ){
        dwRegAxes |= JOYPF_R;
    }

    if (phwc->hws.dwFlags & JOY_HWS_HASU) {
        dwRegAxes |= JOYPF_U;
    }

    if (phwc->hws.dwFlags & JOY_HWS_HASV) {
        dwRegAxes |= JOYPF_V;
    }

    if ((g_flEmulation & DIEMFL_JOYSTICK) ||
        FAILED(hres = IoctlHw(IOCTL_JOY_GETAXES,
                        &dwExternalID, cbX(dwExternalID),
                        pvac, cbX(*pvac)))) {

        /*
         *  If that didn't work, then just use the registry.
         */
        if (phwc->hws.dwFlags & JOY_HWS_HASPOV) {
            pvac->dwPos |= JOYPF_POV0;
        }


        /*
         *  Old VJOYD clients do not support velocity or any of the
         *  other stuff.
         */
        pvac->dwVel = 0;
        pvac->dwAccel = 0;
        pvac->dwForce = 0;

        hres = S_OK;
    }
    else
    {
        /*
         *  ManBug 28971:  Logitech drivers (and probably others) respond to 
         *  probing on axes for which they do not report data so set the 
         *  position axes to whatever is reported in the registry.
         *  Note this still allows multiple POVs to be picked up as only one 
         *  POV is supported by the registry flags.
         */
        pvac->dwPos &= ~JOYPF_ALLAXES;
        pvac->dwPos |= dwRegAxes;
    }

    /*
     *  CJoy_InitRing3 assumes that this never fails.
     */
    AssertF(SUCCEEDED(hres));

    return hres;
}

#endif //WINNT

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_Joy_GetInitParms |
 *
 *          Ask the device driver (or emulation) for
 *          VJOYD initialization parameters.
 *
 *          In emulation, we assume the internal and external
 *          IDs are equal (because they may as well be),
 *          that no flags are set, and there are no versions.
 *
 *  @parm   DWORD | dwExternalID |
 *
 *          The external joystick number.
 *
 *  @parm   PVXDINITPARMS | pvip |
 *
 *          Receives assorted information.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_Joy_GetInitParms(DWORD dwExternalID, PVXDINITPARMS pvip)
{
    HRESULT hres;

    if ((g_flEmulation & DIEMFL_JOYSTICK) ||
         FAILED(hres = IoctlHw(IOCTL_JOY_GETINITPARMS,
                               &dwExternalID, cbX(dwExternalID),
                               pvip, cbX(*pvip))) ||
         FAILED(hres = pvip->hres)) {

        /*
         *  Do it the emulation way.
         */

         ZeroX(*pvip);
         pvip->dwId = dwExternalID;
         hres = S_OK;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dihid.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dihid.h
 *  Content:    DirectInput internal include file for HID
 *
 ***************************************************************************/

#ifndef _DIHID_H
#define _DIHID_H

/*
 *  Defines that should be in hidusage.h but are not yet
 */

#ifndef HID_USAGE_PAGE_PID
#define HID_USAGE_PAGE_PID      ( (USAGE) 0x0000f )
#endif

#ifndef HID_USAGE_PAGE_VENDOR
#define HID_USAGE_PAGE_VENDOR   ( (USAGE) 0xff00 )
#endif  

#ifndef HID_USAGE_SIMULATION_RUDDER
#define HID_USAGE_SIMULATION_RUDDER         ((USAGE) 0xBA)
#endif
#ifndef HID_USAGE_SIMULATION_THROTTLE
#define HID_USAGE_SIMULATION_THROTTLE       ((USAGE) 0xBB)
#endif
#ifndef HID_USAGE_SIMULATION_ACCELERATOR
#define HID_USAGE_SIMULATION_ACCELERATOR    ((USAGE) 0xC4)
#endif
#ifndef HID_USAGE_SIMULATION_BRAKE
#define HID_USAGE_SIMULATION_BRAKE          ((USAGE) 0xC5)
#endif
#ifndef HID_USAGE_SIMULATION_CLUTCH
#define HID_USAGE_SIMULATION_CLUTCH         ((USAGE) 0xC6)
#endif
#ifndef HID_USAGE_SIMULATION_SHIFTER
#define HID_USAGE_SIMULATION_SHIFTER        ((USAGE) 0xC7)
#endif
#ifndef HID_USAGE_SIMULATION_STEERING
#define	HID_USAGE_SIMULATION_STEERING		((USAGE) 0xC8)
#endif
#ifndef HID_USAGE_GAME_POV
#define HID_USAGE_GAME_POV                  ((USAGE) 0x20)
#endif


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct HIDDEVICEINFO |
 *
 *          Records information about a single hid device.
 *
 *  @field  DIOBJECTSTATICDATA | osd |
 *
 *          Standard information that identifies the device crudely.
 *
 *          The <e DIOBJECTSTATICDATA.dwDevType> field contains the
 *          device type code, used by
 *          <f CDIDEnum_Next>.
 *
 *          If the device is a HID mouse, then the remaining fields
 *          are commandeered as follows:
 *
 *          The <e DIOBJECTSTATICDATA.pcguid> field is the number
 *          of buttons on the mouse.
 *
 *          The <e DIOBJECTSTATICDATA.CreateDcb> field is the number
 *          of axes on the mouse.
 *
 *          See <f DIHid_ProbeMouse> for an explanation of why we
 *          need to do this.
 *
 *  @field  PSP_DEVICE_INTERFACE_DETAIL_DATA | pdidd |
 *
 *          Pointer to name for device to be used in <f CreateFile>.
 *
 *  @field  HKEY | hk |
 *
 *          Registry key that contains configuration information.
 *          Sadly, we must keep it open because there is no way to
 *          obtain the name of the key, and the only way to open the
 *          key is inside an enumeration.
 *
 *  @field  HKEY | hkOld |
 *
 *          Registry key that contains configuration information.
 *          This key originally pointed to the registry used in Win2k Gold. 
 *          It is to maintain compatibiltiy with Win2k Gold.
 *
 *  @field  LPTSTR | ptszId |
 *
 *          Cached device ID that allows us to access other information
 *          about the device.
 *
 *  @field  GUID | guid |
 *
 *          The instance GUID for the device.
 *
 *  @field  GUID | guidProduct | 
 *
 *          The product GUID for the device.
 *
 *	@field	WORD | ProductID |
 *
 *			The PID for the device
 *
 *	@field	WORD | VendorID |
 *
 *			The VID for the device
 *
 *
 *****************************************************************************/

typedef struct HIDDEVICEINFO
{
    DIOBJECTSTATICDATA osd;
    PSP_DEVICE_INTERFACE_DETAIL_DATA pdidd;
    HKEY hk;
    HKEY hkOld;
    LPTSTR ptszId;
    GUID guid;
    GUID guidProduct;
    int  idJoy;
	WORD ProductID;
	WORD VendorID;
    BOOL fAttached;
} HIDDEVICEINFO, *PHIDDEVICEINFO;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct HIDDEVICELIST |
 *
 *          Records information about all the HID devices.
 *
 *  @field  int | chdi |
 *
 *          Number of items in the list that are in use.
 *
 *  @field  int | chdiAlloc |
 *
 *          Number of items allocated in the list.
 *
 *  @field  HIDDEVICEINFO | rghdi[0] |
 *
 *          Variable-size array of device information structures.
 *
 *****************************************************************************/

typedef struct HIDDEVICELIST
{

    int chdi;
    int chdiAlloc;
    int idMaxJoy;
    HIDDEVICEINFO rghdi[0];

} HIDDEVICELIST, *PHIDDEVICELIST;

extern PHIDDEVICELIST g_phdl;

    #define cbHdlChdi(chdi)         FIELD_OFFSET(HIDDEVICELIST, rghdi[chdi])

/*
 *  We choose our starting point at 64 devices, since
 *  that's the maximum number of USB devices supported.  This
 *  avoids needless reallocs.
 */

    #define chdiMax                 64
    #define chdiInit                16

/*
 *  Tag for unused translation of object instance
 */
    #define NOREGTRANSLATION        (0x80000000)

/*
 *  VID/PID definitions used to handle analog devices
 */
    #define MSFT_SYSTEM_VID         (0x45E)
    #define MSFT_SYSTEM_PID         (0x100)
    #define ANALOG_ID_ROOT          TEXT("VID_045E&PID_01")

/*
 *  VID/PID template so that upper case hex is always used
 */
    #define VID_PID_TEMPLATE        TEXT("VID_%04X&PID_%04X")

/*
 *  Size of string in characters generated using VID_PID_TEMPLATE
 */
    #define cbszVIDPID              cA( VID_PID_TEMPLATE )


/*****************************************************************************
 *
 *      dihidenm.c - HID enumeration functions.
 *
 *****************************************************************************/

extern TCHAR g_tszIdLastRemoved[MAX_PATH]; //in dihidenm.c
extern DWORD g_tmLastRemoved;   //in dihinenm.c

STDMETHODIMP hresFindHIDInstanceGUID(PCGUID pguid, CREATEDCB *pcdcb);
STDMETHODIMP hresFindHIDDeviceInterface(LPCTSTR ptszPath, LPGUID pguidOut);

PHIDDEVICEINFO EXTERNAL phdiFindHIDInstanceGUID(PCGUID pguid);
PHIDDEVICEINFO EXTERNAL phdiFindHIDDeviceInterface(LPCTSTR ptszPath);

void EXTERNAL DIHid_BuildHidList(BOOL fForce);
void EXTERNAL DIHid_EmptyHidList(void);

BOOL EXTERNAL
    DIHid_GetDevicePath(HDEVINFO hdev,
                        PSP_DEVICE_INTERFACE_DATA pdid,
                        PSP_DEVICE_INTERFACE_DETAIL_DATA *ppdidd,
                        PSP_DEVINFO_DATA pdinf);


BOOL EXTERNAL
    DIHid_GetDeviceInstanceId(HDEVINFO hdev,
                              PSP_DEVINFO_DATA pdinf, 
                              LPTSTR *pptszId);

BOOL EXTERNAL
    DIHid_GetInstanceGUID(HKEY hk, LPGUID pguid);

    
/*****************************************************************************
 *
 *      diguid.c - GUID generation
 *
 *****************************************************************************/

void EXTERNAL DICreateGuid(LPGUID pguid);
void EXTERNAL DICreateStaticGuid(LPGUID pguid, WORD pid, WORD vid);

/*****************************************************************************
 *
 *      dihid.c
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *          We will just use the HID item index as our DirectInput
 *          internal ID number, which is in turn an index into the
 *          <t DIOBJECTDATAFORMAT> array.
 *
 *          Keyboard support requires a translation table.
 *          Other devices also a translation table so that the external 
 *          instance numbers can be made compatible with legacy ones and 
 *          so that secondary aliases can be separated from primary ones.
 *
 *          Since HID restarts the item index counter at zero for
 *          each of input, feature, and output, we need to do some
 *          adjustment so there aren't any collisions.  So we
 *          shift the features to start after the inputs, and the
 *          outputs to start after the features.
 *
 *          The <e CHid.rgdwBase> array contains the amount by which
 *          each group of HID item indexes has been shifted.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | HidP_IsValidReportType |
 *
 *          For debugging only.  Check if a value is a valid
 *          <t HIDP_REPORT_TYPE>.
 *
 *          Note that we also create a "fake" report type in which
 *          to record our collections.
 *
 *  @field  HIDP_REPORT_TYPE | type |
 *
 *          One of the values
 *          <c HidP_Input>,
 *          <c HidP_Output>,
 *          or
 *          <c HidP_Feature>.  Hopefully.
 *
 *****************************************************************************/

    #define HidP_Max            (HidP_Feature + 1)
    #define HidP_Coll           HidP_Max
    #define HidP_MaxColl        (HidP_Coll + 1)

BOOL INLINE
    HidP_IsValidReportType(HIDP_REPORT_TYPE type)
{
    CAssertF(HidP_Input == 0);
    CAssertF(HidP_Output == 1);
    CAssertF(HidP_Feature == 2);
    return type < HidP_Max;
}

/*****************************************************************************
 *
 *          There are three (overlapping) classes of HID reports.
 *
 *          InputLike - HidP_Input and HidP_Feature
 *          OutputLike - HidP_Output and HidP_Feature
 *          NothingLike - HidP_Coll
 *
 *****************************************************************************/

BOOL INLINE
    HidP_IsInputLike(HIDP_REPORT_TYPE type)
{
    return type == HidP_Input || type == HidP_Feature;
}

BOOL INLINE
    HidP_IsOutputLike(HIDP_REPORT_TYPE type)
{
    return type == HidP_Output || type == HidP_Feature;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct LMINMAX |
 *
 *          Min and max, that's all.  These are kept in structures
 *          to make logical-to-physical and physical-to-logical
 *          translations less gross.
 *
 *  @field  LONG | Min |
 *
 *          The minimum value.
 *
 *  @field  LONG | Max |
 *
 *          The maximum value.
 *
 *****************************************************************************/

typedef struct LMINMAX
{
    LONG Min;
    LONG Max;
} LMINMAX, *PLMINMAX;

typedef const LMINMAX *PCLMINMAX;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct HIDGROUPCAPS |
 *
 *          This structure unifies the various HID caps structures
 *          <t HIDP_BUTTON_CAPS> and
 *          <t HIDP_VALUE_CAPS>.
 *
 *  @field  HIDP_REPORT_TYPE | type |
 *
 *          One of the values
 *          <c HidP_Input>,
 *          <c HidP_Output>,
 *          or
 *          <c HidP_Feature>.
 *
 *  @field  UINT | cObj |
 *
 *          Number of objects in this group.
 *
 *  @field  USAGE | UsagePage |
 *
 *          Usage page for all usages in the group.
 *
 *  @field  USAGE | UsageMin |
 *
 *          First usage described by this group.  The remaining
 *          items are numbered consecutively starting from
 *          this value.
 *
 *  @field  USHORT | StringMin |
 *
 *          String for first usage described by this group.
 *          The remaining strings are numbered consecutively
 *          starting from this value, unless the string maximum
 *          is reached, in which case all subsequent objects
 *          share that last string.
 *
 *  @field  USHORT | StringMax |
 *
 *          Last string.
 *
 *  @field  USHORT | DesignatorMin |
 *
 *          Designator for first usage described by this group.
 *          The remaining designators are numbered consecutively
 *          starting from this value, unless the designator maximum
 *          is reached, in which case all subsequent objects
 *          share that last designator.
 *
 *  @field  USHORT | DesignatorMax |
 *
 *          Last designator.
 *
 *  @field  USHORT | DataIndexMin |
 *
 *          Data index for the first usage described by this group.
 *          The remaining data index values are numbered consecutively
 *          starting from this value.
 *
 *  @field  USHORT | usGranularity |
 *
 *          If object is a POV or wheel, then contains device granularity.
 *
 *  @field  LONG | lMask |
 *
 *          Mask bits used for sign extension.  For example, if the
 *          value is 8-bits, the mask will be 0xFFFFFF80, indicating
 *          that bit 7 (0x00000080) is extended to fill the remainder
 *          of the value.
 *
 *          This field is used only by values.
 *
 *  @field  USHORT | BitSize |
 *
 *          Number of bits devoted to this value, including the sign bit.
 *
 *          ISSUE-2001/03/29-timgill structure field probably not used anywhere.
 *
 *  @field  USHORT | LinkCollection |
 *
 *          HID link collection number.
 *
 *  @field  LMINMAX | Logical |
 *
 *          Logical minimum and maximum values.
 *          These are the extremes of raw values
 *          that can validly be received from the device.
 *
 *          This field is used only by values.
 *
 *  @field  LMINMAX | Physical |
 *
 *          Physical minimum and maximum values.
 *          This is the "actual" value
 *          that the logical minimum and maximum value corresponds to.
 *
 *          This field is used only by values, and is consulted
 *          only when converting between DirectInput calibration
 *          (which uses logical values) and VJOYD calibration
 *          (which uses physical values).
 *
 *  @field  LONG | Null |
 *
 *          The null value to be used for output.
 *
 *          This field is used only by values.
 *
 *  @field  ULONG | Units |
 *
 *          The HID units descriptor, if any.
 *
 *  @field  WORD | Exponent |
 *
 *          The HID unit exponent, if any.
 *
 *  @field  WORD | wReportId |
 *
 *          HID report Id
 *
 *  @field  BOOL | IsAbsolute |
 *
 *          Nonzero if the group describes absolute axes.
 *
 *          This field is used only by values.
 *
 *  @field  BOOL | IsValue |
 *
 *          Nonzero if the group describes a HID value.
 *
 *          Note that an analog pushbutton is reported by
 *          DirectInput as a <c DIDFT_BUTTON>, but is
 *          handled internally as a HID value.
 *
 *  @field  BOOL | IsAlias |
 *
 *          Nonzero if the group describes an alias.
 *
 *  @field  BOOL | IsSigned |
 *          
 *          The return data is signed. 
 *
 *  @field  BOOL | IsPolledPOV |
 *          
 *          TRUE if axis is a polled POV. 
 *
 *  @devnote New for DX6.1a
 *
 *****************************************************************************/

    #define HIDGROUPCAPS_SIGNATURE      0x47444948  /* HIDG */

typedef struct HIDGROUPCAPS
{

    D(DWORD dwSignature;)
    HIDP_REPORT_TYPE type;
    UINT    cObj;

    USAGE   UsagePage;
    USAGE   UsageMin;

    USHORT  StringMin,        StringMax;
    USHORT  DesignatorMin,    DesignatorMax;
    USHORT  DataIndexMin;

    USHORT  usGranularity;

    LONG    lMask;

    USHORT  BitSize;

    USHORT  LinkCollection;

    LMINMAX Logical;
    LMINMAX Physical;

    LONG    Null;

    ULONG   Units;
    WORD    Exponent;

    WORD    wReportId;
    BOOL    fReportDisabled;
    BOOL    Reserved;

    BOOL    IsAbsolute;
    BOOL    IsValue;
    BOOL    IsAlias;
    BOOL    IsSigned;
    
  #ifdef WINNT
    BOOL    IsPolledPOV;
  #endif

} HIDGROUPCAPS, *PHIDGROUPCAPS;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct HIDOBJCAPS |
 *
 *          This structure contains various cached pointers for each
 *          object on the device, allowing us to get at things like
 *          the group caps and the calibration information.
 *
 *  @field  PHIDGROUPCAPS | pcaps |
 *
 *          The <t PHIDGROUPCAPS> for the group the object belongs to.
 *
 *  @field  PJOYRANGECONVERT | pjrc |
 *
 *          If non-NULL, then points to the range conversion information
 *          for the object.
 *
 *  @field  int | idata |
 *
 *          Index into the <t HIDP_DATA> array for the corresponding
 *          output/feature report,
 *          or <c -1> if the item is not in the output/feature report.
 *
 *****************************************************************************/

typedef struct HIDOBJCAPS
{
    PHIDGROUPCAPS pcaps;
    PJOYRANGECONVERT pjrc;
    int idata;
} HIDOBJCAPS, *PHIDOBJCAPS;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct HIDREPORTINFO |
 *
 *          This structure contains information that is used for
 *          parsing HID reports.
 *
 *  @field  PHIDP_DATA | rgdata |
 *
 *          Array used when parsing reports via
 *          <f HidP_GetData> or <f HidP_SetData>.  This MUST be aligned 
 *          correctly on some architechtures.
 *
 *  @field  PV | pvReport |
 *
 *          The report itself.
 *
 *  @field  int | cdataMax |
 *
 *          Number of elements in the <e HIDREPORTINFO.rgdata> array.
 *
 *  @field  int | cdataUsed |
 *
 *          Number of elements in the <e HIDREPORTINFO.rgdata> array
 *          that are actually in use.
 *
 *  @field  ULONG | cbReport |
 *
 *          Number of bytes in the report.
 *
 *  @field  BOOL | fNeedClear |
 *
 *          Nonzero if the report needs to be zero'd out because we
 *          deleted something (most likely a button) from it.
 *          The only way to delete an item from a report is to zero
 *          out the entire report and then re-add everything back in.
 *
 *  @field  BOOL | fChanged |
 *
 *          Nonzero if an element in the report has changed.
 *
 *****************************************************************************/

typedef struct HIDREPORTINFO
{
    PHIDP_DATA rgdata;
    PV pvReport;
    int cdataMax;
    int cdataUsed;
    ULONG cbReport;
    BOOL fNeedClear;
    BOOL fChanged;
} HIDREPORTINFO, *PHIDREPORTINFO;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CHid |
 *
 *          The <i IDirectInputDeviceCallback> object for HID devices.
 *
 *  @field  IDirectInputDeviceCalllback | didc |
 *
 *          The object (containing vtbl).
 *
 *  @field  PV | pvGroup2 |
 *
 *          Pointer to group 2 memory.  This field is a union with the 
 *          pointer to the first chunk of memory in the second memory group.
 *
 *  @field  HIDREPORTINFO | hriIn |
 *
 *          HID input report parsing and state.
 *
 *          This memory is the first chunk of group 2.
 *
 *  @field  HIDREPORTINFO | hriOut |
 *
 *          HID output report parsing and state.
 *
 *  @field  HIDREPORTINFO | hriFea |
 *
 *          HID feature report parsing and state.
 *
 *  @field  PV | pvPhys |
 *
 *          Pointer to physical device status information updated
 *          asynchronously by the data collection thread.
 *
 *  @field  PV | pvStage |
 *
 *          Staging area used when the HID report is parsed.
 *
 *          This memory is the last chunk of group 2.
 *
 *  @field  DWORD | cbPhys |
 *
 *          Size of the physical device state.
 *
 *  @field  VXDINSTANCE * | pvi |
 *
 *          The DirectInput instance handle.
 *
 *          HID devices always run through ring 3, which is misleadingly
 *          called "emulation".
 *
 *  @field  DWORD | dwDevType |
 *
 *          Device type code.
 *
 *  @field  LPTSTR | ptszId |
 *
 *          Setupapi device instance ID.  Used to obtain things
 *          like manufacturer name.
 *
 *  @field  LPTSTR | ptszPath |
 *
 *          Path to the device, for <f CreateFile>.
 *
 *  @field  UINT | dwAxes |
 *
 *          Number of axes on the device.
 *
 *  @field  UINT | dwButtons |
 *
 *          Number of buttons on the device.
 *
 *  @field  UINT | dwPOVs |
 *
 *          Number of POV controllers on the device.
 *
 *  @field  HANDLE | hdev |
 *
 *          Handle to the device itself.  This field is valid only
 *          while the device is acquired.
 *
 *  @field  HANDLE | hdevEm |
 *
 *          <f DuplicateHandle> of the <e CHid.hdev> which is used
 *          by the worker thread.  We need to keep this separate from
 *          the main copy to avoid race conditions between the main
 *          thread and the worker thread.
 *
 *  @field  HKEY | hkInstType |
 *
 *          Per-instance registry key that contains additional configuration
 *          information, equivalent to the joystick Type key.
 *
 *  @field  DWORD | rgdwBase[HidP_MaxColl] |
 *
 *          Array of base indices for the three HID usage classes:
 *          <c HidP_Input>, <c HidP_Output>, and <c HidP_Feature>.
 *          We hide the <c HidP_Collection> base index here, too.
 *
 *  @field  PHIDOBJCAPS | rghoc |
 *
 *          Pointer to array of
 *          <t PHIDOBJCAPS>, one for each object on the device,
 *          each of which in turn contains info about a single object.
 *
 *          This memory is allocated as part of the
 *          df.rgodf in the <t DIDATAFORMAT> structure
 *          hence should not be freed separately.
 *
 *  @field  DIDATAFORMAT | df |
 *
 *          The dynamically-generated data format based on the
 *          usages on the HID device.
 *
 *  @field  DWORD | ibButtonData |
 *
 *          The location of the button data inside the data format.
 *
 *  @field  DWORD | cbButtonData |
 *
 *          The number of bytes of button data inside the data format.
 *
 *  @field  PBYTE * | rgpbButtonMasks |
 *
 *          Pointer to a an array of pointers to byte strings to mask 
 *          the buttons relevant to a report.
 *
 *  @field  PHIDP_PREPARSED_DATA | ppd |
 *
 *          Preparsed data generated by the HID subsystem.
 *
 *  @field  PHIDGROUPCAPS | rgcaps |
 *
 *          Array of <t HIDGROUPCAPS> structures used to keep
 *          track of the various buttons, groups, and collections.
 *
 *  @field  UINT | ccaps |
 *
 *          Number of caps structures in the <e CHid.rgcaps> array.
 *
 *  @field  HIDP_CAPS | caps |
 *
 *          Cached HID caps.
 *
 *  @field  OVERLAPPED | o |
 *
 *          Overlapped I/O structure used by worker thread
 *          for reading.
 *
 *
 *  @field  PJOYRANGECONVERT | pjrcNext |
 *
 *          Pointer to the first <t JOYRANGECONVERT> structure
 *          (in a preallocated array) which has
 *          yet to be used.
 *          This structure is used for logical-to-physical
 *          range conversion (a.k.a. calibration).
 *
 *          This memory is allocated as part of the
 *          df.rgodf in the <t DIDATAFORMAT> structure
 *          hence should not be freed separately.
 *
 *          This field is used during device initialization to
 *          parcel out the <t JOYRANGECONVERT>s.  Afterwards,
 *          the field is <c NULL> if we did not create any
 *          conversion structures (hence do not need to subclass
 *          the cooperative window to catch recalibrations).
 *
 *  @field  PBYTE | rgbaxissemflags |
 *
 *          This points to an array which maps DirectInput axis 
 *          instance values to default semantic map flags.
 *
 *  @field  PINT | rgiobj |
 *
 *          This points to an array which maps DirectInput instance 
 *          values (DIDFT_GETINSTANCE) into object indices.
 *
 *  @field  PINT | rgipov |
 *
 *          If we are not a keyboard, then this is the first element in 
 *          the above array which maps povs.
 *
 *  @field  PINT | rgiaxis |
 *
 *          If we are not a keyboard, then this is the first element in 
 *          the above array which maps axes.
 *
 *  @field  PINT | rgicoll |
 *
 *          If we are not a keyboard, then this is the first element in 
 *          the above array which maps collections.
 *          //ISSUE-2001/03/29-timgill need to document keyboard case behaviour
 *
 *  @field  UINT | uiInstanceMax |
 *
 *          The number of elements in the above
 *          <f rgiobj> array.
 *
 *  @field  int | idJoy |
 *
 *          Joystick identifier for <f joyGetPosEx> and friends for
 *          legacy access.
 *
 *          This value starts out as -1, to meant that
 *          the corresponding legacy joystick is unknown.
 *          If we do something that requires the matched legacy
 *          joystick to be found, we check if the current value
 *          is still valid.  If not (either it is -1 or the cached
 *          value is stale), then we go hunt for the correct value.
 *
 *  @field  HKEY | hkType |
 *
 *          The joystick type key opened with <c MAXIMUM_ALLOWED> access.
 *          This is not per-instance; multiple instances of the same
 *          hardware share this key.
 *
 *  @field  USHORT | VendorID |
 *
 *          HID vendor ID for this device.
 *
 *  @field  USHORT | ProductID |
 *
 *          HID product ID for this device.
 *
 *  @field  HWND | hwnd |
 *
 *          The window which we have subclassed in order to watch
 *          for recalibration messages.
 *
 *  @field  BOOL | IsPolledInput |
 *
 *          Nonzero if the device has to be polled for Input data.
 *
 *  @field  BOOL | fPIDdevice |
 *
 *          Set to true if the device is found to support PID. 
 *
 *  @field  WORD | wMaxReportId | 
 *          
 *          The maximum (number) of ReportId used by the HID device.   
 *      
 *  @field  PUCHAR | pEnableReportId |
 *          
 *          Pointer to (wMaxReportId) bytes. If a reportID needs to be
 *          polled in order to get features / set Output, then that element
 *          of this array is set to 0x1.
 *
 *  @field HKEY | hkProp |
 *
 *          Extended properties for device type. Currently we keep dwFlags2 and
 *          OEMMapFile under this key.  
 *  
 *  @field  BOOL | fEnableInputReport |
 *
 *          True if Input report should be enabled for this device.
 *  
 *  @field  BOOL | fFlags2Checked |
 *
 *          True after we check the registry for Flags2 for disabling
 *          input reports.
 *
 *  @comm
 *
 *          It is the caller's responsibility to serialize access as
 *          necessary.
 *
 *****************************************************************************/

typedef struct CHid
{

    /* Supported interfaces */
    IDirectInputDeviceCallback dcb;

    union
    {
        PV            pvGroup2;
        HIDREPORTINFO hriIn;
    };

    HIDREPORTINFO hriOut;
    HIDREPORTINFO hriFea;

    PV       pvPhys;
    PV       pvStage;
    DWORD    cbPhys;

    VXDINSTANCE *pvi;

    DWORD    dwDevType;

    UINT     dwAxes;
    UINT     dwButtons;
    UINT     dwPOVs;
    UINT     dwCollections;

    HANDLE   hdev;
    HANDLE   hdevEm;

    DWORD    rgdwBase[HidP_MaxColl];
    PHIDOBJCAPS rghoc;
    DIDATAFORMAT df;

    DWORD    ibButtonData;
    DWORD    cbButtonData;
    PBYTE   *rgpbButtonMasks;

    PHIDP_PREPARSED_DATA ppd;
    PHIDGROUPCAPS rgcaps;

    PJOYRANGECONVERT pjrcNext;

    HIDP_CAPS caps;

    ED       ed;
    OVERLAPPED o;
    DWORD    dwStartRead;
    DWORD    dwStopRead;

    PBYTE    rgbaxissemflags;
    PINT     rgiobj;
    PINT     rgipov;
    PINT     rgiaxis;
    PINT     rgicoll;
    UINT     uiInstanceMax;

    LPTSTR   ptszId;
    LPTSTR   ptszPath;
    HKEY     hkInstType;
    UINT     ccaps;
    int      idJoy;

    HKEY     hkType;
    USHORT   VendorID;
    USHORT   ProductID;
    
    #define  FAILED_POLL_THRESHOLD   (0x4)
        
    HWND     hwnd;    
    
    BOOL     IsPolledInput;
    BOOL     fPIDdevice;  
    WORD     wMaxReportId[HidP_Max];
    PUCHAR   pEnableReportId[HidP_Max];

    DWORD    dwVersion;

    DIAPPHACKS  diHacks;

    HKEY     hkProp;

    BOOL     fEnableInputReport;
    BOOL     fFlags2Checked;

} CHid, CHID, *PCHID;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PCHID | pchidFromPo |
 *
 *          Given an interior pointer to an <t OVERLAPPED>, retrieve
 *          a pointer to the parent <t CHid>.
 *
 *  @parm   LPOVERLAPPED | po |
 *
 *          The pointer to convert.
 *
 *****************************************************************************/

PCHID INLINE
    pchidFromPo(LPOVERLAPPED po)
{
    return pvSubPvCb(po, FIELD_OFFSET(CHid, o));
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PCHID | pchidFromPed |
 *
 *          Given an interior pointer to a <t CEd>, retrieve
 *          a pointer to the parent <t CHid>.
 *
 *  @parm   PED | ped |
 *
 *          The pointer to convert.
 *
 *****************************************************************************/

PCHID INLINE
    pchidFromPed(PED ped)
{
    return pvSubPvCb(ped, FIELD_OFFSET(CHid, ed));
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PCHID | pchidFromPem |
 *
 *          Given a <t CEm>, wander back to the
 *          <t CHid> that spawned it.
 *
 *  @parm   PEM | pem |
 *
 *          The pointer at which to start.
 *
 *****************************************************************************/

PCHID INLINE
    pchidFromPem(PEM pem)
{
    PCHID pchid = pchidFromPed(pem->ped);
    AssertF(pemFromPvi(pchid->pvi) == pem);
    return pchid;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method UINT | CHid | ObjFromType |
 *
 *          Given a <p dwType>, extract the instance number
 *          and (if necessary) convert it to an object index.
 *          Note, the instance number will always be of the primary instance
 *          not an alias.
 *
 *  @parm   PCHID | this |
 *
 *          HID device object.
 *
 *  @parm   DWORD | dwType |
 *
 *          The type code to convert.
 *
 *  @returns
 *
 *          The object index, or an out-of-range value.
 *
 *****************************************************************************/

UINT INLINE
    CHid_ObjFromType(PCHID this, DWORD dwType)
{
    UINT uiObj = DIDFT_GETINSTANCE(dwType);

    // ISSUE-2001/03/29-timgill Range checks may be unnecessary
    // MarcAnd can we ever get the out of range value?
    //          if so, can we really run with it?
    //          if not, can these range checks be converted into Asserts?

    /*
     *  The range checking makes use of the fact that the translation 
     *  tables are taken from a contiguous memory allocation and that
     *  aliased collections are not distinguished.
     */
    if(this->rgiobj)
    {
        switch( DIDFT_GETTYPE(dwType) )
        {
        case DIDFT_RELAXIS:
        case DIDFT_ABSAXIS:
            if( &this->rgiaxis[uiObj] < this->rgicoll )
            {
                uiObj = this->rgiaxis[uiObj];
            } else
            {
                uiObj = 0xFFFFFFFF;
            }
            break;

        case DIDFT_PSHBUTTON:
        case DIDFT_TGLBUTTON:
            /*
             * If it is keyboard, this->rgiobj == this->rgipov (see CHid_MungeKeyboard).
             * So, we can't test &this->rgiobj[uiObj] < this->rgipov.
             */
            if( (GET_DIDEVICE_TYPE(this->dwDevType) == DI8DEVTYPE_KEYBOARD &&
                 uiObj < this->uiInstanceMax ) ||
                &this->rgiobj[uiObj] < this->rgipov )
            {
                uiObj = this->rgiobj[uiObj];
            } else
            {
                uiObj = 0xFFFFFFFF;
            }
            break;

        case DIDFT_POV:
            if( &this->rgipov[uiObj] < this->rgiaxis )
            {
                uiObj = this->rgipov[uiObj];
            } else
            {
                uiObj = 0xFFFFFFFF;
            }
            break;
        case (DIDFT_COLLECTION | DIDFT_NODATA):
            if( &this->rgicoll[uiObj] <= &this->rgiobj[this->uiInstanceMax] )
            {
                uiObj = this->rgicoll[uiObj];
            } else
            {
                uiObj = 0xFFFFFFFF;
            }
            break;
        case DIDFT_NODATA:
            /*
             * So far, this TYPE only shows up on Keyboard (HID_USAGE_PAGE_LED).
             */
            if( GET_DIDEVICE_TYPE(this->dwDevType) == DI8DEVTYPE_KEYBOARD &&
                 uiObj < this->uiInstanceMax )
            {
                uiObj = this->rgiobj[uiObj];
            }
            break;
        
        default:
            /*
             *  Hopefully this is just a vendor defined object but squirt
             *  in debug as these may cause problems.
             */
            SquirtSqflPtszV(sqflHidParse | sqflVerbose,
                            TEXT("CHid_ObjFromType: dwType 0x%08x not converted"),
                            dwType );                
            break;
        }
    }
    else
    {
        SquirtSqflPtszV(sqflHidParse | sqflError,
                        TEXT("CHid_ObjFromType: Translation array missing") );
    }

    return uiObj;
}

LONG EXTERNAL
    CHid_CoordinateTransform(PLMINMAX Dst, PLMINMAX Src, LONG lVal);

#ifndef WINNT
void EXTERNAL
    CHid_UpdateVjoydCalibration(PCHID this, UINT iobj);

void EXTERNAL
    CHid_UpdateCalibrationFromVjoyd(PCHID this, UINT iobj, LPDIOBJECTCALIBRATION pCal);
#endif

/*****************************************************************************
 *
 *      dihidini.c - Device callback initialization stuff
 *
 *****************************************************************************/

#define INITBUTTONFLAG     0x10000000

HRESULT EXTERNAL CHid_InitParseData(PCHID this);

HRESULT EXTERNAL CHid_Init(PCHID this, REFGUID rguid);

HANDLE EXTERNAL CHid_OpenDevicePath(PCHID this, DWORD dwAttributes );

UINT EXTERNAL CHid_LoadCalibrations(PCHID this);

BOOL EXTERNAL CHid_IsPolledDevice( HANDLE hdev );

/*****************************************************************************
 *
 *      dihiddat.c - HID data parsing/management
 *
 *****************************************************************************/

typedef HRESULT (FAR PASCAL * SENDHIDREPORT)(PCHID this, PHIDREPORTINFO phri);

void EXTERNAL CHid_ResetDeviceData(PCHID this, PHIDREPORTINFO phri,
                                   HIDP_REPORT_TYPE type);
HRESULT EXTERNAL CHid_AddDeviceData(PCHID this, UINT uiObj, DWORD dwData);
STDMETHODIMP CHid_PrepareDeviceData(PCHID this, PHIDREPORTINFO phri);
STDMETHODIMP CHid_SendHIDReport(PCHID this, PHIDREPORTINFO phri,
                                HIDP_REPORT_TYPE type, SENDHIDREPORT SendHIDReport);

NTSTATUS EXTERNAL
    CHid_ParseData(PCHID this, HIDP_REPORT_TYPE type, PHIDREPORTINFO phri);


HRESULT EXTERNAL
    DIHid_GetRegistryProperty(LPTSTR ptszId, DWORD dwProperty, LPDIPROPHEADER pdiph);

DWORD EXTERNAL DIHid_DetectHideAndRevealFlags( PCHID this );

/*****************************************************************************
 *
 *      diemh.c - HID "emulation"
 *
 *****************************************************************************/

void EXTERNAL CEm_HID_Sync(PLLTHREADSTATE plts, PEM pem);

BOOL EXTERNAL CEm_HID_IssueRead( PCHID pchid );

#endif /* _DIHID_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dihiddat.c ===
/*****************************************************************************
 *
 *  DIHidDat.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      HID data management.
 *
 *  Contents:
 *
 *      CHid_AddDeviceData
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflHidDev


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CHid | DelDeviceData |
 *
 *          Remove an item of device data from the list.
 *
 *          We grab the last item and slide it into place, updating
 *          the various pointers as we go.
 *
 *  @parm   PHIDREPORTINFO | phri |
 *
 *          The HID report from which the item is being deleted.
 *
 *  @parm   int | idataDel |
 *
 *          The data value being deleted.
 *
 *  @parm   HIDP_REPORT_TYPE | type |
 *
 *          The report type we are mangling with.
 *
 *****************************************************************************/

void INTERNAL
CHid_DelDeviceData(PCHID this, PHIDREPORTINFO phri, int idataDel,
                   HIDP_REPORT_TYPE type)
{
    DWORD dwBase = this->rgdwBase[type];
    int iobjDel = phri->rgdata[idataDel].DataIndex + dwBase;
    PHIDOBJCAPS phocDel = &this->rghoc[iobjDel];
    int idataSrc;

    SquirtSqflPtszV(sqflHidOutput,
                    TEXT("DelDeviceData(%d) - cdataUsed = %d, obj=%d"),
                    idataDel, phri->cdataUsed, iobjDel);

    AssertF(idataDel >= 0);
    AssertF(idataDel < phri->cdataUsed);
    AssertF(phri->cdataUsed > 0);

    /*
     *  Wipe out the item being deleted.
     *  Remember that the report needs to be rebuilt.
     */
    AssertF(phocDel->idata == idataDel);
    phocDel->idata = -1;
    phri->fNeedClear = TRUE;

    /*
     *  Slide the top item into its place.
     */
    idataSrc = (int)--(phri->cdataUsed);
    if (idataSrc > idataDel) {
        int iobjSrc;
        PHIDOBJCAPS phocSrc;

        AssertF(idataSrc > 0 && idataSrc < phri->cdataMax);

        iobjSrc = phri->rgdata[idataSrc].DataIndex + dwBase;
        phocSrc = &this->rghoc[iobjSrc];

        AssertF(phocSrc->idata == idataSrc);

        phocSrc->idata = idataDel;
        phri->rgdata[idataDel] = phri->rgdata[idataSrc];

    }

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CHid | ResetDeviceData |
 *
 *          Clean out all old device data from the list.
 *
 *  @parm   PHIDREPORTINFO | phri |
 *
 *          The HID report which should be reset.
 *
 *  @parm   HIDP_REPORT_TYPE | type |
 *
 *          The report type we are mangling with.
 *
 *****************************************************************************/

void EXTERNAL
CHid_ResetDeviceData(PCHID this, PHIDREPORTINFO phri, HIDP_REPORT_TYPE type)
{
    SquirtSqflPtszV(sqflHidOutput,
                    TEXT("ResetDeviceData(%d) - cdataUsed = %d"),
                    type, phri->cdataUsed);

    if (phri->cdataUsed) {
        int idata;
        DWORD dwBase = this->rgdwBase[type];

        phri->fNeedClear = TRUE;
        for (idata = 0; idata < phri->cdataUsed; idata++) {
            int iobj = phri->rgdata[idata].DataIndex + dwBase;
            PHIDOBJCAPS phoc = &this->rghoc[iobj];

            AssertF(phoc->idata == idata);
            phoc->idata = -1;
        }

        phri->cdataUsed = 0;
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | AddDeviceData |
 *
 *          Add (or replace) a piece of device data to the array.
 *
 *          If we are removing a button, then we delete it, because
 *          the HID way of talking about a button is "If you don't
 *          talk about it, then it isn't set."
 *
 *  @parm   UINT | uiObj |
 *
 *          The object being added.
 *
 *  @parm   DWORD | dwData |
 *
 *          The data value to add.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_REPORTFULL>: Too many items are set in the report.
 *          ISSUE-2001/03/29-timgill Need more return code clarification
 *
 *****************************************************************************/

HRESULT EXTERNAL
CHid_AddDeviceData(PCHID this, UINT uiObj, DWORD dwData)
{
    HRESULT hres;
    LPDIOBJECTDATAFORMAT podf;

    AssertF(uiObj < this->df.dwNumObjs);

    podf = &this->df.rgodf[uiObj];

    if (podf->dwType & DIDFT_OUTPUT) {
        PHIDOBJCAPS phoc = &this->rghoc[uiObj];
        PHIDGROUPCAPS pcaps = phoc->pcaps;
        PHIDREPORTINFO phri;

		// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
		SquirtSqflPtszV(sqflHidOutput,
                        TEXT("CHid_AddDeviceData(%p, %d, %d) - type %d"),
                        this, uiObj, dwData, pcaps->type);

        /*
         *  Decide if it's HidP_Output or HidP_Feature.
         */
        AssertF(HidP_IsOutputLike(pcaps->type));

        switch (pcaps->type) {
        case HidP_Output:  phri = &this->hriOut; break;
        case HidP_Feature: phri = &this->hriFea; break;
        default:           AssertF(0); hres = E_FAIL; goto done;
        }

        AssertF(phri->cdataUsed <= phri->cdataMax);
        if (phoc->idata == -1) {
            SquirtSqflPtszV(sqflHidOutput,
                            TEXT("CHid_AddDeviceData - no iData"));

        } else {
            AssertF(phoc->idata < phri->cdataUsed);
            AssertF(uiObj == phri->rgdata[phoc->idata].DataIndex +
                                         this->rgdwBase[pcaps->type]);
            SquirtSqflPtszV(sqflHidOutput,
                            TEXT("CHid_AddDeviceData - iData = %d ")
                            TEXT("DataIndex = %d"),
                            phoc->idata,
                            phri->rgdata[phoc->idata].DataIndex);
        }

        phri->fChanged = TRUE;

        if (pcaps->IsValue) {
            /*
             *  Just swipe the value.
             *  The fallthrough code will handle this.
             */
        } else {
            /*
             *  If the button is being deleted, then delete it
             *  and that's all.
             */
            if (dwData == 0) {
                if (phoc->idata >= 0) {
                    CHid_DelDeviceData(this, phri, phoc->idata, pcaps->type);
                    AssertF(phoc->idata == -1);
                } else {
                    SquirtSqflPtszV(sqflHidOutput,
                                    TEXT("CHid_AddDeviceData - nop"));
                }
                hres = S_OK;
                goto done;
            } else {
                dwData = TRUE;  /* HidP_SetData requires this for buttons */
            }
        }

        /*
         *  If there is not already a slot for this item, then
         *  find one.
         */
        if (phoc->idata < 0) {
            if (phri->cdataUsed < phri->cdataMax) {
                USHORT DataIndex;

                phoc->idata = phri->cdataUsed++;

                DataIndex = (USHORT)(uiObj - this->rgdwBase[pcaps->type]);
                phri->rgdata[phoc->idata].DataIndex = DataIndex;

                SquirtSqflPtszV(sqflHidOutput,
                                TEXT("CHid_AddDeviceData - create iData = %d ")
                                TEXT("DataIndex = %d"),
                                phoc->idata,
                                DataIndex);
            } else {
                RPF("SendDeviceData: No room for more data");
                hres = DIERR_REPORTFULL;
                goto done;
            }
        }

        AssertF(phri->cdataUsed <= phri->cdataMax);
        AssertF(phoc->idata >= 0 && phoc->idata < phri->cdataUsed);
        AssertF(uiObj == phri->rgdata[phoc->idata].DataIndex +
                                     this->rgdwBase[pcaps->type]);

        /*
         *  Here it comes... The entire purpose of this function
         *  is the following line of code...  (Well, not the
         *  *entire* purpose, but 90% of it...)
         */
        phri->rgdata[phoc->idata].RawValue = dwData;

        SquirtSqflPtszV(sqflHidOutput,
                        TEXT("CHid_AddDeviceData - iData(%d) dwData = %d"),
                        phoc->idata, dwData);

        hres = S_OK;
    done:;

    } else {
        RPF("SendDeviceData: Object %08x is not DIDFT_OUTPUT",
            podf->dwType);
        hres = E_INVALIDARG;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | SendHIDReport |
 *
 *          Build up an output or feature report and send it.
 *          If the report has not changed, then do nothing.
 *
 *  @parm   PHIDREPORTINFO | phri |
 *
 *          Describes the HID report we should build.
 *
 *  @parm   OUTPUTHIDREPORT | OutputHIDReport |
 *
 *          Output a HID report to wherever it's supposed to go.
 *
 *  @parm   HIDP_REPORT_TYPE | type |
 *
 *          The report type being sent.
 *          <c HidP_Output> or <c HidP_Feature>.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully
 *          and the report is ready to be sent to the device.
 *
 *          <c DIERR_REPORTFULL>: Too many items are set in the report.
 *
 *  @cb     HRESULT CALLBACK | SendHIDReportProc |
 *
 *          An internal callback which takes a composed HID report
 *          and sends it in the appropriate manner to the device.
 *
 *  @parm   PCHID | this |
 *
 *          The device in question.
 *
 *  @parm   PHIDREPORTINFO | phri |
 *
 *          The report being sent.
 *
 *****************************************************************************/

STDMETHODIMP
CHid_SendHIDReport(PCHID this, PHIDREPORTINFO phri, HIDP_REPORT_TYPE type,
                   SENDHIDREPORT SendHIDReport)
{
    HRESULT hres = S_OK;
    DWORD cdata;
    NTSTATUS stat;

    if (phri->fChanged) {

        if (phri->fNeedClear) {
            ZeroMemory(phri->pvReport, phri->cbReport);
            phri->fNeedClear = FALSE;
        }

        cdata = phri->cdataUsed;
        stat = HidP_SetData(type, phri->rgdata, &cdata, this->ppd,
                            phri->pvReport, phri->cbReport);
        if (SUCCEEDED(stat) && (int)cdata == phri->cdataUsed) {
            if ( SUCCEEDED( hres = SendHIDReport(this, phri) ) ) {
                phri->fChanged = FALSE;
            }
        } else if (stat == HIDP_STATUS_BUFFER_TOO_SMALL) {
            hres = DIERR_REPORTFULL;
        } else {
            RPF("SendDeviceData: Unexpected HID failure");
            hres = E_FAIL;
        }

    } else {
        /* Vacuous success */
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method NTSTATUS | CHid | ParseData |
 *
 *          Parse a single input report and set up the
 *          <e CHid.pvStage> buffer to contain the new device state.
 *
 *  @parm   HIDP_REPORT_TYPE | type |
 *
 *          HID report type being parsed.
 *
 *  @parm   PHIDREPORTINFO | phri |
 *
 *          Information that tells us how to parse the report.
 *
 *****************************************************************************/

NTSTATUS INTERNAL
CHid_ParseData(PCHID this, HIDP_REPORT_TYPE type, PHIDREPORTINFO phri)
{
    NTSTATUS stat = E_FAIL;

    /*
     *  Do this only if there are inputs at all.  This avoids
     *  annoying boundary conditions.
     */
    UCHAR uReportId;
    ULONG cdataMax = phri->cdataMax;

    if (cdataMax && phri->cbReport) {
        
        uReportId = *(UCHAR*)phri->pvReport;
        
        if( uReportId <  this->wMaxReportId[type] &&
            *(this->pEnableReportId[type]  + uReportId) )
        {

            stat = HidP_GetData(type, phri->rgdata, &cdataMax,
                                this->ppd, phri->pvReport, phri->cbReport);

            if (SUCCEEDED(stat)) {
                ULONG idata;

                /*
                 *  If we successfully got stuff, then wipe out the old
                 *  buttons and start with new ones.
                 *
                 *  HID data parsing rules differ from buttons to axes.
                 *  For buttons, the rule is that if it isn't in the
                 *  report, then the button isn't presed.
                 *
                 *  Compare axes, where the rule is that if it isn't
                 *  in the report, then the value is unchanged.
                 *  
                 *  To avoid deleting buttons that are reported in reports 
                 *  other than the one just received we check for multiple 
                 *  reports during initialization and if necessary set up mask 
                 *  arrays for the buttons.  The mask is an arrays of bytes of 
                 *  the same length as the button data, one for each report 
                 *  that contains any buttons.  If the device only has one 
                 *  report there are no mask arrays so we can optimize by just 
                 *  zeroing all the buttons.  If the device has multiple 
                 *  reports there is an array of pointers to the mask arrays, 
                 *  if a report has no buttons, the pointer is NULL so no 
                 *  further processing is required.  For reports that do have 
                 *  buttons, each byte in the button data is ANDed with the 
                 *  corresponding byte in the mask so that only buttons in 
                 *  the received report are zeroed.
                 */
                if( this->rgpbButtonMasks == NULL )
                {
                    /*
                     *  Only one report so just zero all buttons
                     *  This is the normal case so it is important that this 
                     *  be done as quickly as possible.
                     */
                    ZeroMemory(pvAddPvCb(this->pvStage, this->ibButtonData),
                               this->cbButtonData);
                }
                else
                {
                    if( this->rgpbButtonMasks[uReportId-1] != NULL )
                    {
                        /*
                         *  ISSUE-2001/05/12-MarcAnd  Could mask buttons faster
                         *  If we do this often, we could consider doing masks 
                         *  with multiple bytes in each opperation.
                         */

                        PBYTE pbMask;
                        PBYTE pbButtons;
                        PBYTE pbButtonEnd = pvAddPvCb(this->pvStage, this->ibButtonData + this->cbButtonData);
                        for( pbMask = this->rgpbButtonMasks[uReportId-1],
                             pbButtons = pvAddPvCb(this->pvStage, this->ibButtonData);
                             pbButtons < pbButtonEnd;
                             pbMask++, pbButtons++ )
                        {
                            *pbButtons &= *pbMask;
                        }
                    }
                    else
                    {
                        /*
                         *  No buttons in this report
                         */
                    }
                }

                for (idata = 0; idata < cdataMax; idata++) {

                    UINT uiObj;
                    PHIDGROUPCAPS pcaps;

                    /*
                     *  Be careful and make sure that HID didn't
                     *  give us anything with a bogus item index.
                     *
                     *  ISSUE-2001/03/29-timgill Not Feature-friendly.
                     */
                    AssertF(this->rgdwBase[HidP_Input] == 0);

                    SquirtSqflPtszV(sqfl | sqflTrace,
                            TEXT("HidP_GetData: %2d -> %d"),
                            phri->rgdata[idata].DataIndex,
                            phri->rgdata[idata].RawValue);

                    uiObj = this->rgdwBase[type] + phri->rgdata[idata].DataIndex;

                    if (uiObj < this->df.dwNumObjs &&
                        (pcaps = this->rghoc[uiObj].pcaps) &&
                        pcaps->type == type) {
                        LPDIOBJECTDATAFORMAT podf;
                        LONG lValue = (LONG)phri->rgdata[idata].RawValue;

                        /*
                         *  Sign-extend the raw value if necessary.
                         */
                        if (lValue & pcaps->lMask ) {
                            if( pcaps->IsSigned) 
                                lValue |= pcaps->lMask;
                            else
                                lValue &= pcaps->lMask;
                        }

                        if (HidP_IsOutputLike(pcaps->type)) {
                            HRESULT hres;
                            hres = CHid_AddDeviceData(this, uiObj, lValue);
                            AssertF(SUCCEEDED(hres));
                        }

                        podf = &this->df.rgodf[uiObj];

                        if (!pcaps->IsValue) {
                            LPBYTE pb = pvAddPvCb(this->pvStage, podf->dwOfs);
                            AssertF(lValue);
                            *pb = 0x80;

                        } else {

                            LONG UNALIGNED *pl = pvAddPvCb(this->pvStage, podf->dwOfs);

                            // ISSUE-2001/03/29-timgill need to consider how logical/physical mapping can alter scaling

                            if (podf->dwType & DIDFT_RELAXIS) {
                                if (pcaps->usGranularity) {
                                    lValue = -lValue * pcaps->usGranularity;
                                }

                                *pl += lValue;
                            } else if ( (podf->dwType & DIDFT_ABSAXIS) 
                                      #ifdef WINNT
                                        || ((podf->dwType & DIDFT_POV) && pcaps->IsPolledPOV) 
                                      #endif
                            ) {
                                PJOYRANGECONVERT pjrc;
                                *pl = lValue;

                                /*
                                 *  Apply the ramp if any.
                                 */
                                pjrc = this->rghoc[uiObj].pjrc;
                                if( pjrc 
                                 && !( this->pvi->fl & VIFL_RELATIVE ) ) 
                                {
                                    CCal_CookRange(pjrc, pl);
                                }
                            } else if (podf->dwType & DIDFT_BUTTON) {

                                /*
                                 *  Current applications do not expect any values 
                                 *  other than zero and 0x80.  Just in case 
                                 *  someone has implemented an analog button the 
                                 *  way we had suggested, make sure we any value 
                                 *  greater than or equal to half pressed reports 
                                 *  0x80 and anything else reports as zero.
                                 *  Note, out of range values default to zero.
                                 */
                                if( ( lValue <= pcaps->Logical.Max )
                                 && ( ( lValue - pcaps->Logical.Min ) >= 
                                      ( ( ( pcaps->Logical.Max - pcaps->Logical.Min ) + 1 ) / 2 ) ) )
                                {
                                    *((PBYTE)pl) = 0x80;
                                }
                                else
                                {
                                    *((PBYTE)pl) = 0;
                                }

                            } else if (podf->dwType & DIDFT_POV) {
                                /*
                                 *  For (non-polled) POVs, an out of range value 
                                 *  is a NULL aka centered.  Otherwise work out 
                                 *  the angle from the fraction of the circle.
                                 */
                                if (lValue < pcaps->Logical.Min ||
                                    lValue > pcaps->Logical.Max) {
                                    *pl = JOY_POVCENTERED;
                                } else {
                                    lValue -= pcaps->Logical.Min;
                                    *pl = lValue * pcaps->usGranularity;
                                }
                            }

                        }
                    } else {
                        SquirtSqflPtszV(sqfl | sqflTrace,
                                TEXT("HidP_GetData: Unable to use data element"));
                    }
                }
                stat = S_OK;
            }
            stat = S_OK;
        }
    } else {
        stat = E_FAIL;    
    }
    return stat;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dihid.c ===
/*****************************************************************************
*
*  DIHid.c
*
*  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
*
*  Abstract:
*
*      The HID device callback.
*
*  Contents:
*
*      CHid_New
*
*****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflHidDev


/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *****************************************************************************/

Primary_Interface(CHid, IDirectInputDeviceCallback);

Interface_Template_Begin(CHid)
Primary_Interface_Template(CHid, IDirectInputDeviceCallback)
Interface_Template_End(CHid)

/*****************************************************************************
 *
 *      Forward declarations
 *
 *      These are out of laziness, not out of necessity.
 *
 *****************************************************************************/

LRESULT CALLBACK
    CHid_SubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp,
                      UINT_PTR uid, ULONG_PTR dwRef);
STDMETHODIMP_(DWORD) CHid_GetUsage(PDICB pdcb, int iobj);

/*****************************************************************************
 *
 *      Hid devices are totally arbitrary, so there is nothing static we
 *      can cook up to describe them.  We generate all the information on
 *      the fly.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *      Auxiliary helper definitions for CHid.
 *
 *****************************************************************************/

    #define ThisClass CHid
    #define ThisInterface IDirectInputDeviceCallback
    #define riidExpected &IID_IDirectInputDeviceCallback

/*****************************************************************************
 *
 *      CHid::QueryInterface      (from IUnknown)
 *      CHid::AddRef              (from IUnknown)
 *      CHid::Release             (from IUnknown)
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @returns
 *
 *      Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | QIHelper |
 *
 *      We don't have any dynamic interfaces and simply forward
 *      to <f Common_QIHelper>.
 *
 *
 *  @parm   IN REFIID | riid |
 *
 *      The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *      Receives a pointer to the obtained interface.
 *
 *****************************************************************************/

    #ifdef DEBUG

Default_QueryInterface(CHid)
Default_AddRef(CHid)
Default_Release(CHid)

    #else

        #define CHid_QueryInterface   Common_QueryInterface
        #define CHid_AddRef           Common_AddRef
        #define CHid_Release          Common_Release

    #endif

    #define CHid_QIHelper         Common_QIHelper

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CHid | RemoveSubclass |
 *
 *          Remove our subclass hook on the window.
 *
 *****************************************************************************/

void INTERNAL
    CHid_RemoveSubclass(PCHID this)
{

    /*
     *  !! All the comments in CJoy_RemoveSubclass apply here !!
     */
    if(this->hwnd)
    {
        HWND hwnd = this->hwnd;
        this->hwnd = 0;
        if(!RemoveWindowSubclass(hwnd, CHid_SubclassProc, 0))
        {
            /*
             *  The RemoveWindowSubclass can fail if the window
             *  was destroyed behind our back.
             */
            // AssertF(!IsWindow(hwnd));
        }
        Sleep(0);                   /* Let the worker thread drain */
        Common_Unhold(this);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | Unacquire |
 *
 *          Tell the device driver to stop data acquisition.
 *
 *          It is the caller's responsibility to call this only
 *          when the device has been acquired.
 *
 *          Warning!  We require that the device critical section be
 *          held so we don't race against our worker thread.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c S_FALSE>: The operation was begun and should be completed
 *          by the caller by communicating with the <t VXDINSTANCE>.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_Unacquire(PDICB pdcb)
{
    HRESULT hres;
    PCHID this;

    EnterProcI(IDirectInputDeviceCallback::HID::Unacquire,
               (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);
    AssertF(this->pvi->pdd);
    AssertF(CDIDev_InCrit(this->pvi->pdd));    

    hres = S_FALSE;     /* Please finish for me */

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CHid_Finalize |
 *
 *          Releases the resources of the device after all references
 *          (both strong and weak) are gone.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
    CHid_Finalize(PV pvObj)
{
    UINT  iType;
    PCHID this = pvObj;

    if(this->hkInstType)
    {
        RegCloseKey(this->hkInstType);
    }

    if(this->hkType)
    {
        RegCloseKey(this->hkType);
    }

    if( this->hkProp)
    {
        RegCloseKey(this->hkProp);
    }

    AssertF(this->hdev == INVALID_HANDLE_VALUE);
    AssertF(this->hdevEm == INVALID_HANDLE_VALUE);

    if(this->ppd)
    {
        HidD_FreePreparsedData(this->ppd);
    }

    /*
     *
     *  Free group 2 memory:
     *
     *      hriIn.pvReport      Input data
     *      hriIn.rgdata
     *
     *      hriOut.pvReport     Output data
     *      hriOut.rgdata
     *
     *      hriFea.pvReport     Feature data (both in and out)
     *      hriFea.rgdata
     *
     *      pvPhys              Used by ED
     *      pvStage
     */

    FreePpv(&this->pvGroup2);

    /*
     *  Freeing df.rgodf also frees rgpvCaps, rgvcaps, rgbcaps, rgcoll.
     */
    FreePpv(&this->df.rgodf);

    FreePpv(&this->rgbaxissemflags);
    FreePpv(&this->rgiobj);
    FreePpv(&this->ptszPath);
    FreePpv(&this->ptszId);
    FreePpv(&this->rgpbButtonMasks);

    for(iType = 0x0; iType < HidP_Max; iType++)
    {
        FreePpv(&this->pEnableReportId[iType]);  
    }

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | AppFinalize |
 *
 *          The client <t VXDINSTANCE> contains a weak pointer back
 *          to us so that that it can party on the data format we
 *          collected.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released from the application's perspective.
 *
 *****************************************************************************/

void INTERNAL
    CHid_AppFinalize(PV pvObj)
{
    PCHID this = pvObj;

    if(this->pvi)
    {
        HRESULT hres;
        CHid_RemoveSubclass(this);
        /*
         *  Prefix warns that "this" may have been freed (mb:34570) however 
         *  in AppFinalize we should always have our internal reference to 
         *  keep it around.  As long as refcounting is not broken, we are OK 
         *  and any refcount bug has to be fixed so don't hide it here.
         */
        hres = Hel_DestroyInstance(this->pvi);
        AssertF(SUCCEEDED(hres));
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | CHid_SubclassProc |
 *
 *          Window subclass procedure which watches for
 *          joystick configuration change notifications.
 *
 *          Even if we are not a joystick, we still listen to
 *          this, in case somebody recalibrated a remote control
 *          or some other wacky thing like that.
 *
 *          However, if our device has no calibratable controls,
 *          then there's no point in watching for recalibration
 *          notifications.
 *
 *  @parm   HWND | hwnd |
 *
 *          The victim window.
 *
 *  @parm   UINT | wm |
 *
 *          Window message.
 *
 *  @parm   WPARAM | wp |
 *
 *          Message-specific data.
 *
 *  @parm   LPARAM | lp |
 *
 *          Message-specific data.
 *
 *  @parm   UINT | uid |
 *
 *          Callback identification number, always zero.
 *
 *  @parm   DWORD | dwRef |
 *
 *          Reference data, a pointer to our joystick device callback.
 *
 *****************************************************************************/

LRESULT CALLBACK
    CHid_SubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp,
                      UINT_PTR uid, ULONG_PTR dwRef)
{
    #ifdef XDEBUG
    static CHAR s_szProc[] = "";
    #endif

    PCHID this = (PCHID)dwRef;
    AssertF(uid == 0);
    /*
     *  Wacky subtlety going on here to avoid race conditions.
     *  See the mondo comment block in CJoy_RemoveSubclass [sic]
     *  for details.
     *
     *  We can get faked out if the memory associated with the
     *  CHid is still physically allocated, the vtbl is magically
     *  still there and the hwnd field somehow matches our hwnd.
     */
    if(SUCCEEDED(hresPv(this)) && this->hwnd == hwnd)
    {
        switch(wm)
        {
        case WM_POWERBROADCAST :
            // 7/18/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
            SquirtSqflPtszV( sqfl | sqflError,
                TEXT("WM_POWERBROADCAST(0x%x) for 0x%p"), wp, this);

            if(wp == PBT_APMSUSPEND )
            {
                CEm_ForceDeviceUnacquire(pemFromPvi(this->pvi)->ped, 0x0 );
            }
            else if(wp == PBT_APMRESUMESUSPEND )
            {
                CEm_ForceDeviceUnacquire(pemFromPvi(this->pvi)->ped, 0x0 );
                
                DIBus_BuildList(TRUE);
            }
            break;

        default:
            if( wm == g_wmJoyChanged )
            {
                /*
                 * Once we receive this notification message, we need to rebuild
                 * our list, because sometimes the user has just changed the device's ID.
                 * See manbug: 35445
                 */
                DIHid_BuildHidList(TRUE);

                Common_Hold(this);

                CHid_LoadCalibrations(this);

                Common_Unhold(this);
            }
            // 7/18/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
            SquirtSqflPtszV( sqfl | sqflVerbose,
                TEXT("wp(0x%x) wm(0x%x) for 0x%p"), wm, wp, this);
            break;
        }
    }
    return DefSubclassProc(hwnd, wm, wp, lp);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CHid | GetPhysicalState |
 *
 *          Read the physical device state into <p pmstOut>.
 *
 *          Note that it doesn't matter if this is not atomic.
 *          If a device report arrives while we are reading it,
 *          we will get a mix of old and new data.  No big deal.
 *
 *  @parm   PCHID | this |
 *
 *          The object in question.
 *
 *  @parm   PV | pvOut |
 *
 *          Where to put the device state.
 *
 *  @returns
 *          None.
 *
 *****************************************************************************/

void INLINE
    CHid_GetPhysicalState(PCHID this, PV pvOut)
{
    AssertF(this->pvPhys);
    AssertF(this->cbPhys);

    CopyMemory(pvOut, this->pvPhys, this->cbPhys);


}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | Acquire |
 *
 *          Tell the device driver to begin data acquisition.
 *          We create a handle to the device so we can talk to it again.
 *          We must create each time so we can survive in the
 *          "unplug/replug" case.  When a device is unplugged,
 *          its <t HANDLE> becomes permanently invalid and must be
 *          re-opened for it to work again.
 *
 *          Warning!  We require that the device critical section be
 *          held so we don't race against our worker thread.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c S_FALSE>: The operation was begun and should be completed
 *          by the caller by communicating with the <t VXDINSTANCE>.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_Acquire(PDICB pdcb)
{
    HRESULT hres;
    HANDLE h;
    PCHID this;
    EnterProcI(IDirectInputDeviceCallback::HID::Acquire,
               (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);
    AssertF(this->pvi->pdd);
    AssertF(CDIDev_InCrit(this->pvi->pdd));
    AssertF(this->hdev == INVALID_HANDLE_VALUE);


    /*
     *  We must check connectivity by opening the device, because NT
     *  leaves the device in the info list even though it has
     *  been unplugged.
     */
    h = CHid_OpenDevicePath(this, FILE_FLAG_OVERLAPPED);
    if(h != INVALID_HANDLE_VALUE)
    {
        NTSTATUS stat;
        DWORD dwFlags2 = 0;

        /*
         * Obtain Flags2 to find out if input report is disabled for this device,
         * if we haven't done so.
         */
        if (!this->fFlags2Checked)
        {
            JoyReg_GetValue( this->hkProp, REGSTR_VAL_FLAGS2, REG_BINARY,
                             &dwFlags2, cbX(dwFlags2) );
            this->fFlags2Checked = TRUE;
            this->fEnableInputReport = ( (dwFlags2 & JOYTYPE_ENABLEINPUTREPORT) != 0 );
        }

        if ( this->fEnableInputReport )
        {
            BYTE id;
            for (id = 0; id < this->wMaxReportId[HidP_Input]; ++id)
                if ( this->pEnableReportId[HidP_Input][id] )
                {
                    BOOL bRet;

                    *(BYTE*)this->hriIn.pvReport = id;
                    bRet = HidD_GetInputReport(h, this->hriIn.pvReport, this->hriIn.cbReport);

                    if (bRet)
                    {
                        stat = CHid_ParseData(this, HidP_Input, &this->hriIn);
                        if (SUCCEEDED(stat))
                        {
                            this->pvi->fl |= VIFL_INITIALIZE;  /* Set the flag so the event can be buffered.
                                                                  since VIFL_ACQUIRED isn't set yet. */
                            CEm_AddState(&this->ed, this->pvStage, GetTickCount());
                            this->pvi->fl &= ~VIFL_INITIALIZE;  /* Clear the flag when done. */
                        }
                    } else
                    {
                        DWORD dwError = GetLastError();

                        // ERROR_SEM_TIMEOUT means the device has timed out.
                        if (dwError == ERROR_SEM_TIMEOUT)
                        {
                            /*
                             * Timed out. The device does not support input report. We need to record
                             * the fact in registry so that GetInputReport() does not ever get called
                             * again for this device, since each failed call takes five seconds to
                             * complete.
                             */
                            this->fEnableInputReport = TRUE;
                            dwFlags2 &= ~JOYTYPE_ENABLEINPUTREPORT;
                            hres = JoyReg_SetValue( this->hkProp, REGSTR_VAL_FLAGS2, 
                                                    REG_BINARY, (PV)&dwFlags2, cbX( dwFlags2 ) );
                            break;
                        }

                        RPF("CHid_InitParse: Unable to read HID input report LastError(0x%X)", dwError );
                    }
                }
        }

        CloseHandle(h);
        /* Please finish for me */
        hres = S_FALSE;
    } else
    {
        hres = DIERR_UNPLUGGED;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | GetInstance |
 *
 *          Obtains the DirectInput instance handle.
 *
 *  @parm   OUT PPV | ppvi |
 *
 *          Receives the instance handle.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_GetInstance(PDICB pdcb, PPV ppvi)
{
    HRESULT hres;
    PCHID this;
    EnterProcI(IDirectInputDeviceCallback::Hid::GetInstance, (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);
    *ppvi = (PV)this->pvi;
    hres = S_OK;

    ExitOleProcPpvR(ppvi);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | GetDataFormat |
 *
 *          Obtains the device's preferred data format.
 *
 *  @parm   OUT LPDIDEVICEFORMAT * | ppdf |
 *
 *          <t LPDIDEVICEFORMAT> to receive pointer to device format.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpmdr> parameter is not a valid pointer.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_GetDataFormat(PDICB pdcb, LPDIDATAFORMAT *ppdf)
{
    HRESULT hres;
    PCHID this;
    EnterProcI(IDirectInputDeviceCallback::Hid::GetDataFormat,
               (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    *ppdf = &this->df;
    hres = S_OK;

    ExitOleProcPpvR(ppdf);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DIHid_GetParentRegistryProperty |
 *
 *  @parm   LPTSTR | ptszId |
 *
 *          Device Instance ID.           
 *
 *  @parm   DWORD | dwProperty |
 *
 *          The property being queried.
 *
 *  @parm   LPDIPROPHEADER | diph |
 *
 *          Property data to be set.
 *
 *  @parm   BOOL | diph |
 *
 *          Get from parent or grand parent.
 *
 *****************************************************************************/

HRESULT INTERNAL
    DIHid_GetParentRegistryProperty(LPTSTR ptszId, DWORD dwProperty, LPDIPROPHEADER pdiph, BOOL bGrandParent)
{

    HDEVINFO hdev;
    LPDIPROPSTRING pstr = (PV)pdiph;
    TCHAR   tsz[MAX_PATH];
    HRESULT hres = E_FAIL;

    ZeroX(tsz);
    hdev = SetupDiCreateDeviceInfoList(NULL, NULL);
    if(hdev != INVALID_HANDLE_VALUE)
    {
        SP_DEVINFO_DATA dinf;

        /*
         *  For the instance name, use the friendly name if possible.
         *  Else, use the device description.
         */
        dinf.cbSize = cbX(SP_DEVINFO_DATA);
        if(SetupDiOpenDeviceInfo(hdev, ptszId, NULL, 0, &dinf))
        {
            DEVINST DevInst;
            CONFIGRET cr;
            if( (cr = CM_Get_Parent(&DevInst, dinf.DevInst, 0x0)) == CR_SUCCESS )
            {
                ULONG   ulLength;

                CAssertF( SPDRP_DEVICEDESC   +1  == CM_DRP_DEVICEDESC  );
                CAssertF( SPDRP_FRIENDLYNAME +1  ==  CM_DRP_FRIENDLYNAME );

                if(bGrandParent)
                {
                    cr = CM_Get_Parent(&DevInst, DevInst, 0x0);
                    if( cr != CR_SUCCESS )
                    {
                        // No GrandParent ?? 
                    }
                }

                ulLength = MAX_PATH * cbX(TCHAR);

                if( cr == CR_SUCCESS && 
                    ( cr = CM_Get_DevNode_Registry_Property(
                                                           DevInst,
                                                           dwProperty+1,
                                                           NULL,
                                                           tsz,
                                                           &ulLength,
                                                           0x0 ) ) == CR_SUCCESS )
                {
                    // Success
                    hres = S_OK;
    #ifdef UNICODE
                    lstrcpyW(pstr->wsz, tsz);
    #else
                    TToU(pstr->wsz, MAX_PATH, tsz);
    #endif
                } else
                {
                    SquirtSqflPtszV(sqfl | sqflVerbose,
                                    TEXT("CM_Get_DevNode_Registry_Property FAILED") );
                }
            } else
            {
                SquirtSqflPtszV(sqfl | sqflVerbose,
                                TEXT("CM_Get_Parent FAILED") );
            }
        }

        SetupDiDestroyDeviceInfoList(hdev);
    } else
    {
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("SetupDiCreateDeviceInfoList FAILED, le = %d"), GetLastError() );
    }

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DIHid_GetRegistryProperty |
 *
 *  @parm   LPTSTR | ptszId |
 *
 *          Device Instance ID.           
 *
 *  @parm   DWORD | dwProperty |
 *
 *          The property being queried.
 *
 *  @parm   LPDIPROPHEADER | diph |
 *
 *          Property data to be set.
 *
 *****************************************************************************/

HRESULT EXTERNAL
    DIHid_GetRegistryProperty(LPTSTR ptszId, DWORD dwProperty, LPDIPROPHEADER pdiph)
{

    HDEVINFO hdev;
    LPDIPROPSTRING pstr = (PV)pdiph;
    TCHAR   tsz[MAX_PATH];
    HRESULT hres = E_FAIL;

    ZeroX(tsz);
    hdev = SetupDiCreateDeviceInfoList(NULL, NULL);
    if(hdev != INVALID_HANDLE_VALUE)
    {
        SP_DEVINFO_DATA dinf;

        /*
         *  For the instance name, use the friendly name if possible.
         *  Else, use the device description.
         */
        dinf.cbSize = cbX(SP_DEVINFO_DATA);
        if(SetupDiOpenDeviceInfo(hdev, ptszId, NULL, 0, &dinf))
        {
            if(SetupDiGetDeviceRegistryProperty(hdev, &dinf, dwProperty, NULL, 
                                                (LPBYTE)tsz, MAX_PATH, NULL) )
            {
                hres = S_OK;
    #ifdef UNICODE
                lstrcpyW(pstr->wsz, tsz);
    #else
                TToU(pstr->wsz, MAX_PATH, tsz);
    #endif
            } else
            {
                SquirtSqflPtszV(sqfl | sqflVerbose,
                                TEXT("SetupDiOpenDeviceInfo FAILED, le = %d"), GetLastError() );
            }
        } else
        {
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("SetupDiOpenDeviceInfo FAILED, le = %d"), GetLastError() );
        }

        SetupDiDestroyDeviceInfoList(hdev);
    } else
    {
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("SetupDiCreateDeviceInfoList FAILED, le = %d"), GetLastError() );
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | GetGuidAndPath |
 *
 *          Get a Hid device's class GUID (namely, the HID guid)
 *          and device interface (path).
 *
 *  @parm   PCHID | this |
 *
 *          The Hid object.
 *
 *  @parm   LPDIPROPHEADER | pdiph |
 *
 *          Structure to receive property value.
 *
 *****************************************************************************/

HRESULT INTERNAL
    CHid_GetGuidAndPath(PCHID this, LPDIPROPHEADER pdiph)
{
    HRESULT hres;
    LPDIPROPGUIDANDPATH pgp = (PV)pdiph;

    pgp->guidClass = GUID_HIDClass;
    TToU(pgp->wszPath, cA(pgp->wszPath), this->ptszPath);

    hres = S_OK;

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method BOOLEAN | CHid | CHidInsertScanCodes |
 *
 *
 *  @parm   
 *
 *   ISSUE-2001/03/29-timgill function needs documenting
 *
 *
 *****************************************************************************/

BOOLEAN CHidInsertScanCodes
(
    IN PVOID Context,      // Some caller supplied context.
    IN PCHAR NewScanCodes, // A list of i8042 scan codes.
    IN ULONG Length        // the length of the scan codes.
)
{
    int Idx;
    /*
     *  This is not inner loop code so don't rush it
     */
    AssertF( Length <= cbX( DWORD ) );
    for( Idx = 0; Idx < cbX( DWORD ); Idx++ )
    {
        if( Length-- )
        {
            *(((PCHAR)Context)++) = *(NewScanCodes++);
        }
        else
        {
            *(((PCHAR)Context)++) = '\0';
        }
    }

    return TRUE;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL |  fHasSpecificHardwareMatch |
 *
 *          Find out from SetupAPI whether the device was matched with a 
 *          specific hardware ID match or generic match.
 *          A specific match should have caused a device description to be 
 *          installed which is likely to be at least as good as what HID could 
 *          get from a product string in firmware.  (a. because it's easier to 
 *          update an INF after release than firmware; b. because HID can only 
 *          get us an English string.)  Generic matches on the other hand are,
 *          by definition, all the same so cannot be used to tell two devices 
 *          apart.
 *
 *  @parm   LPTSTR | ptszId |
 *          
 *          Device Instance ID.
 *  
 *  @returns 
 *          <c TRUE> if the device was installed using a specific match.
 *          <c FALSE> if it was not or if installation info was unobtainable.
 *
 *  @comm
 *          This is used on Win2k for game controllers and Win9x for mice and 
 *          keyboards.  Win2k we can't read HID mice and keyboards and on 
 *          Win9x VJoyD should always create device names before DInput.dll.  
 *          On Win9x this is less of a big deal for game controllers because 
 *          IHVs are accoustomed to adding their display name to 
 *          MediaProperties.
 *
 *****************************************************************************/
BOOL fHasSpecificHardwareMatch( LPTSTR ptszId )
{
    HDEVINFO    hInfo;
    BOOL        fRc = FALSE;

    EnterProcI(fHasSpecificHardwareMatch,(_ "s", ptszId));

    hInfo = SetupDiCreateDeviceInfoList(NULL, NULL);
    if( hInfo != INVALID_HANDLE_VALUE )
    {
        SP_DEVINFO_DATA dinf;

        dinf.cbSize = cbX(SP_DEVINFO_DATA);
        if( SetupDiOpenDeviceInfo(hInfo, ptszId, NULL, 0, &dinf) )
        {
            CONFIGRET   cr;
            DEVINST     DevInst;

            cr = CM_Get_Parent( &DevInst, dinf.DevInst, 0x0 );
            if( cr == CR_SUCCESS )
            {
                TCHAR       tszDevInst[MAX_PATH];
                cr = CM_Get_Device_ID( DevInst, (DEVINSTID)tszDevInst, MAX_PATH, 0 );
                if( cr == CR_SUCCESS )
                {
                    if( SetupDiOpenDeviceInfo(hInfo, tszDevInst, NULL, 0, &dinf) )
                    {
                        HKEY hkDrv;

                        hkDrv = SetupDiOpenDevRegKey( hInfo, &dinf, DICS_FLAG_GLOBAL, 0, 
                            DIREG_DRV, MAXIMUM_ALLOWED );

                        if( hkDrv != INVALID_HANDLE_VALUE )
                        {
                            PTCHAR      tszHardwareID = NULL;
                            PTCHAR      tszMatchingID = NULL;
                            ULONG       ulLength = 0;
                    
                            cr = CM_Get_DevNode_Registry_Property(DevInst,
                                                                  CM_DRP_HARDWAREID,
                                                                  NULL,
                                                                  NULL,
                                                                  &ulLength,
                                                                  0x0 );
                            /*
                             *  Win2k returns CR_BUFFER_SMALL but 
                             *  Win9x returns CR_SUCCESS so allow both.
                             */
                            if( ( ( cr == CR_BUFFER_SMALL ) || ( cr == CR_SUCCESS ) )
                             && ulLength )
                            {
#ifndef WINNT
                                /*
                                 *  Need to allocate extra for terminator on Win9x
                                 */
                                ulLength++;
#endif
                                if( SUCCEEDED( AllocCbPpv( ulLength + ( MAX_PATH * cbX(tszMatchingID[0]) ), &tszMatchingID ) ) )
                                {
                                    cr = CM_Get_DevNode_Registry_Property(DevInst,
                                                                          CM_DRP_HARDWAREID,
                                                                          NULL,
                                                                          (PBYTE)&tszMatchingID[MAX_PATH],
                                                                          &ulLength,
                                                                          0x0 );
                                    if( cr == CR_SUCCESS )
                                    {
                                        tszHardwareID = &tszMatchingID[MAX_PATH];
                                    }
                                    else
                                    {
                                        SquirtSqflPtszV(sqfl | sqflError,
                                            TEXT("CR error %d getting HW ID"), cr );
                                    }
                                }
                                else
                                {
                                    SquirtSqflPtszV(sqfl | sqflError,
                                        TEXT("No memory requesting %d bytes for HW ID"), ulLength );
                                }
                            }
                            else
                            {
                                SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("Unexpected CR error %d getting HW ID size"), cr );
                            }

                            if( tszHardwareID )
                            {
                                ulLength = MAX_PATH * cbX(tszMatchingID[0]);
                                cr = RegQueryValueEx( hkDrv, REGSTR_VAL_MATCHINGDEVID, 0, 0, (PBYTE)tszMatchingID, &ulLength );
                                if( CR_SUCCESS == cr )
                                {
                                    while( ulLength = lstrlen( tszHardwareID ) )
                                    {
                                        if( !lstrcmpi( tszHardwareID, tszMatchingID ) )
                                        {
                                            fRc = TRUE;
                                            break;
                                        }
                                        tszHardwareID += ulLength + 1;
                                    }
                                }
                                else
                                {
                                    SquirtSqflPtszV(sqfl | sqflError,
                                        TEXT("No matching ID!, cr = %d"), cr );
                                }
                            }

                            if( tszMatchingID )
                            {
                                FreePv( tszMatchingID );
                            }

                            RegCloseKey( hkDrv );
                        }
                        else
                        {
                            SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("SetupDiOpenDevRegKey failed, le = %d"), GetLastError() );
                        }
                    }
                    else
                    {
                        SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("SetupDiOpenDeviceInfo failed for %S (parent), le = %d"), 
                            tszDevInst, GetLastError() );
                    }
                }
                else
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("CM_Get_Device_ID FAILED %d"), cr );
                }
            }
            else
            {
                SquirtSqflPtszV(sqfl | sqflError,
                    TEXT("CM_Get_Parent FAILED %d"), cr );
            }
        }
        else
        {
            SquirtSqflPtszV(sqfl | sqflError,
                TEXT("SetupDiOpenDeviceInfo failed for %S (child), le = %d"), 
                ptszId, GetLastError() );
        }

        SetupDiDestroyDeviceInfoList(hInfo);
    } 
    else
    {
        SquirtSqflPtszV(sqfl | sqflError,
            TEXT("SetupDiCreateDeviceInfoList failed, le = %d"), GetLastError() );
    }

    ExitProc();

    return fRc;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL |  fGetProductStringFromDevice |
 *
 *          Try getting the product name from HID.
 *          If the device has one of these, this is what is displayed 
 *          when the device is initially recognized.  Unfortunately 
 *          this name does not land up in the friendly name registry 
 *          entry so in case this gets fixed we go directly to HID.
 *
 *  @parm   PCHID | this |
 *
 *          The Hid object.
 *
 *  @parm   PWCHAR | wszBuffer |
 *          
 *          Where to put the product string if found.
 *  
 *  @parm   ULONG | ulBufferLen |
 *          
 *          How big the string buffer is in bytes
 *  
 *  @returns 
 *          <c TRUE> if a string has been placed in the buffer
 *          <c FALSE> if no string was retrieved
 *
 *****************************************************************************/
BOOL fGetProductStringFromDevice
( 
    PCHID   this,
    PWCHAR  wszBuffer,
    ULONG   ulBufferLen
)
{
    BOOL fRc;

    /*
     *  If we already have a handle open (device is acquired), use 
     *  it, otherwise open one just for now.
     */
    if( this->hdev != INVALID_HANDLE_VALUE )
    {
        fRc = HidD_GetProductString( this->hdev, wszBuffer, ulBufferLen );
    }
    else
    {
        HANDLE hdev;

        hdev = CHid_OpenDevicePath(this, FILE_FLAG_OVERLAPPED);
        if(hdev != INVALID_HANDLE_VALUE)
        {
            wszBuffer[0] = 0;
            fRc = HidD_GetProductString( hdev, wszBuffer, ulBufferLen );
            fRc = (fRc)?(wszBuffer[0] != 0):FALSE;
            CloseHandle(hdev);
        } 
        else
        {
            fRc = FALSE;
        }
    }

    return fRc;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | GetProperty |
 *
 *          Get a Hid device property.
 *
 *  @parm   PCHID | this |
 *
 *          The Hid object.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being retrieved.
 *
 *  @parm   LPDIPROPHEADER | pdiph |
 *
 *          Structure to receive property value.
 *
 *  @returns
 *
 *          <c E_NOTIMPL> nothing happened.  The caller will do
 *          the default thing in response to <c E_NOTIMPL>.
 *
 *****************************************************************************/
#ifdef WINNT
TCHAR   g_wszDefaultHIDName[80];
UINT    g_uLenDefaultHIDSize;
#endif

STDMETHODIMP
    CHid_GetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPDIPROPHEADER pdiph)
{
    HRESULT hres;
    PCHID this;
    EnterProcI(IDirectInputDeviceCallback::Hid::GetProperty,
               (_ "pxxp", pdcb, ppropi->pguid, ppropi->iobj, pdiph));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    if(ppropi->iobj < this->df.dwNumObjs)
    {    /* Object property */
        AssertF(ppropi->dwDevType == this->df.rgodf[ppropi->iobj].dwType);
        switch((DWORD)(UINT_PTR)(ppropi->pguid))
        {
        case (DWORD)(UINT_PTR)(DIPROP_ENABLEREPORTID):
            {        
                LPDIPROPDWORD ppropdw = CONTAINING_RECORD(pdiph, DIPROPDWORD, diph);

                PHIDGROUPCAPS pcaps = this->rghoc[ppropi->iobj].pcaps;

                AssertF(fLimpFF(pcaps,
                                pcaps->dwSignature == HIDGROUPCAPS_SIGNATURE));

                ppropdw->dwData = 0x0;
                AssertF(pcaps->wReportId < this->wMaxReportId[pcaps->type]);
                AssertF(this->pEnableReportId[pcaps->type]);
                (UCHAR)ppropdw->dwData = *(this->pEnableReportId[pcaps->type] + pcaps->wReportId);
                hres = S_OK;
            }
            break;

        case (DWORD)(UINT_PTR)(DIPROP_PHYSICALRANGE):
            {        
                LPDIPROPRANGE pdiprg  = CONTAINING_RECORD(pdiph, DIPROPRANGE, diph);
                PHIDGROUPCAPS pcaps = this->rghoc[ppropi->iobj].pcaps;

                pdiprg->lMin = pcaps->Physical.Min;
                pdiprg->lMax = pcaps->Physical.Max;
                hres = S_OK;
                break;
            }
            break;

        case (DWORD)(UINT_PTR)(DIPROP_LOGICALRANGE):
            {        
                LPDIPROPRANGE pdiprg  = CONTAINING_RECORD(pdiph, DIPROPRANGE, diph);
                PHIDGROUPCAPS pcaps = this->rghoc[ppropi->iobj].pcaps;

                pdiprg->lMin = pcaps->Logical.Min;
                pdiprg->lMax = pcaps->Logical.Max;
                hres = S_OK;
            }
            break;

        case (DWORD)(UINT_PTR)(DIPROP_KEYNAME):
            {
                LPDIPROPSTRING pdipstr = (PV)pdiph;
                UINT uiInstance = ppropi->iobj;
                PHIDGROUPCAPS pcaps;

                AssertF(uiInstance == CHid_ObjFromType(this, ppropi->dwDevType));

                pcaps = this->rghoc[uiInstance].pcaps;

                /*
                 *  pcaps might be NULL if HID messed up and left gaps
                 *  in the index lists.
                 */
                if(pcaps)
                {
                    UINT duiInstance;
        
                    AssertF(pcaps->dwSignature == HIDGROUPCAPS_SIGNATURE);
        
                    if(ppropi->dwDevType & DIDFT_COLLECTION)
                    {
                        duiInstance = 0;
                    } else
                    {
                        /*
                         *  Now convert the uiInstance to a duiInstance,
                         *  giving the index of this object into the group.
                         */
                        AssertF(HidP_IsValidReportType(pcaps->type));
                        duiInstance = uiInstance - (this->rgdwBase[pcaps->type] +
                            pcaps->DataIndexMin);
                    }

                    if(GetHIDString(pcaps->UsageMin + duiInstance,
                                        pcaps->UsagePage,
                                        pdipstr->wsz, cA(pdipstr->wsz)))
                    {
                        hres = S_OK;
                    }
                    else
                    {
                        hres = DIERR_OBJECTNOTFOUND;
                    } 
        
                } else
                {
                    hres = DIERR_NOTFOUND;
                }
                
            }
            break;

        case (DWORD)(UINT_PTR)(DIPROP_SCANCODE):
            {
                LPDIPROPDWORD pdipdw = (PV)pdiph;
                UINT uiInstance = ppropi->iobj;
                PHIDGROUPCAPS pcaps;

                AssertF(uiInstance == CHid_ObjFromType(this, ppropi->dwDevType));

                pcaps = this->rghoc[uiInstance].pcaps;

                /*
                 *  pcaps might be NULL if HID messed up and left gaps
                 *  in the index lists.
                 */
                if(pcaps ) 
                {
                    if ( pcaps->UsagePage == HID_USAGE_PAGE_KEYBOARD )
//ISSUE-2001/03/29-timgill unable to access keyboard consumer keys
//can't do this           || pcaps->UsagePage == HID_USAGE_PAGE_CONSUMER )
                    {
                        UINT duiInstance;
                        HIDP_KEYBOARD_MODIFIER_STATE modifiers;
                        USAGE us;
            
                        AssertF(pcaps->dwSignature == HIDGROUPCAPS_SIGNATURE);
    
                        if(ppropi->dwDevType & DIDFT_COLLECTION)
                        {
                            duiInstance = 0;
                        } else
                        {
                            /*
                             *  Now convert the uiInstance to a duiInstance,
                             *  giving the index of this object into the group.
                             */
                            AssertF(HidP_IsValidReportType(pcaps->type));
                            duiInstance = uiInstance - (this->rgdwBase[pcaps->type] +
                                          pcaps->DataIndexMin);
                        }
            
                        us = pcaps->UsageMin + duiInstance;
    
                        CAssertF( cbX( modifiers ) == cbX( modifiers.ul ) );
                        modifiers.ul = 0; // Use no modifiers for translation
    
                        if( SUCCEEDED(HidP_TranslateUsagesToI8042ScanCodes( &us, 1, HidP_Keyboard_Make, &modifiers, 
                                                                   CHidInsertScanCodes,
                                                                   &pdipdw->dwData 
                                                                 ) ) )
                        {
                            hres = S_OK;
                        } else
                        {
                            hres = E_FAIL;
                        }
                    } else 
                    {
                        hres = E_NOTIMPL;
                    }
                } else 
                {
                    hres = DIERR_NOTFOUND;
                }
            }
            break;
        
        default:
            if(ppropi->dwDevType & DIDFT_POV)
            {
                PHIDGROUPCAPS pcaps = this->rghoc[ppropi->iobj].pcaps;

                AssertF(fLimpFF(pcaps,
                                pcaps->dwSignature == HIDGROUPCAPS_SIGNATURE));

              #ifdef WINNT
                if( pcaps && pcaps->IsPolledPOV && ppropi->pguid == DIPROP_CALIBRATIONMODE ) {
                    PJOYRANGECONVERT pjrc = this->rghoc[ppropi->iobj].pjrc;

                    if(pjrc)
                    {
                        hres = CCal_GetProperty(pjrc, ppropi->pguid, pdiph);
                    } else
                    {
                        hres = E_NOTIMPL;
                    }
                } else
              #endif
                {
                    if(pcaps && ppropi->pguid == DIPROP_GRANULARITY)
                    {
                        LPDIPROPDWORD pdipdw = (PV)pdiph;
                        pdipdw->dwData = pcaps->usGranularity;
                        hres = S_OK;
                    } else
                    {
                        hres = E_NOTIMPL;
                    }
                }
            } else if(ppropi->dwDevType & DIDFT_RELAXIS)
            {

                /*
                 *  All relative axes have a full range by default,
                 *  so we don't need to do anything.
                 */
                hres = E_NOTIMPL;

            } else if(ppropi->dwDevType & DIDFT_ABSAXIS)
            {
                PJOYRANGECONVERT pjrc = this->rghoc[ppropi->iobj].pjrc;

                /*
                 *  Theoretically, every absolute axis will have
                 *  calibration info.  But test just in case something
                 *  impossible happens.
                 */
                if(pjrc)
                {
                    hres = CCal_GetProperty(pjrc, ppropi->pguid, pdiph);
                } else
                {
                    hres = E_NOTIMPL;
                }

            } else
            {
                SquirtSqflPtszV(sqflHidDev | sqflError,
                                TEXT("CHid_GetProperty(iobj=%08x): E_NOTIMPL on guid: %08x"),
                                ppropi->iobj, ppropi->pguid);

                hres = E_NOTIMPL;
            }
        }
    } else if(ppropi->iobj == 0xFFFFFFFF)
    {        /* Device property */

        switch((DWORD)(UINT_PTR)ppropi->pguid)
        {

        case (DWORD)(UINT_PTR)DIPROP_GUIDANDPATH:
            hres = CHid_GetGuidAndPath(this, pdiph);
            break;

        case (DWORD)(UINT_PTR)DIPROP_INSTANCENAME:
        {
            /*
             *  Friendly names cause all manner of problems with devices that 
             *  use auto detection so only allow non-predefined analog devices 
             *  to use them.
             */
            if( ( this->VendorID == MSFT_SYSTEM_VID )
             && ( this->ProductID >= MSFT_SYSTEM_PID + JOY_HW_PREDEFMAX )
             && ( ( this->ProductID & 0xff00 ) == MSFT_SYSTEM_PID ) )
            {
                AssertF(this->hkType);
                
                if( this->hkType )
                {
                    LPDIPROPSTRING pstr = (PV)pdiph;

                    hres = JoyReg_GetValue(this->hkType,
                                           REGSTR_VAL_JOYOEMNAME, REG_SZ,
                                           pstr->wsz,
                                           cbX(pstr->wsz));
                                              
                    if( SUCCEEDED(hres ) )
                    {
                        SquirtSqflPtszV(sqflHid | sqflVerbose,
                            TEXT( "Got instance name %s"), pstr->wsz );

                        if( ( this->diHacks.nMaxDeviceNameLength < MAX_PATH )
                         && ( this->diHacks.nMaxDeviceNameLength < lstrlenW(pstr->wsz) ) )
                        {
                            pstr->wsz[this->diHacks.nMaxDeviceNameLength] = L'\0';
                        }

                        hres = S_OK;
                        break;
                    }
                }
            }
            /*
             *  Fall through to catch the product name
             */
        }
        case (DWORD)(UINT_PTR)DIPROP_PRODUCTNAME:
        {

            LPDIPROPSTRING pdipstr = (PV)pdiph;

            /*
             *  For now, don't deal with mice and keyboard names on NT
             */
          #ifdef WINNT
            AssertF( ( GET_DIDEVICE_TYPE( this->dwDevType ) != DI8DEVTYPE_KEYBOARD )
                  && ( GET_DIDEVICE_TYPE( this->dwDevType ) != DI8DEVTYPE_MOUSE ) );
          #endif
            if( GET_DIDEVICE_TYPE( this->dwDevType ) < DI8DEVTYPE_GAMEMIN ) 
            {
                AssertF( GET_DIDEVICE_TYPE( this->dwDevType ) >= DI8DEVTYPE_DEVICE );
                if( fHasSpecificHardwareMatch( this->ptszId )
                      && SUCCEEDED( hres = DIHid_GetParentRegistryProperty(this->ptszId, SPDRP_DEVICEDESC, pdiph, 0x0 ) ) )
                {
                    SquirtSqflPtszV(sqflHid | sqflVerbose,
                        TEXT("Got sys dev description %S"), pdipstr->wsz );
                }
                else if( fGetProductStringFromDevice( this, pdipstr->wsz, cbX( pdipstr->wsz ) ) )
                {
                    SquirtSqflPtszV(sqflHid | sqflVerbose,
                        TEXT( "Got sys dev name from device %S"), pdipstr->wsz );
                    hres = S_OK;
                }
                else
                {
                    if( SUCCEEDED( hres = DIHid_GetRegistryProperty(this->ptszId, SPDRP_DEVICEDESC, pdiph ) ) )
                    {
                        SquirtSqflPtszV(sqflHid | sqflVerbose,
                            TEXT( "Got sys dev name from devnode registry %S"), pdipstr->wsz );
                    }
                    else
                    {
                        UINT uDefName;

                        switch( GET_DIDEVICE_TYPE( this->dwDevType ) )
                        {
                        case DI8DEVTYPE_MOUSE:
                            uDefName = IDS_STDMOUSE;
                            break;
                        case DI8DEVTYPE_KEYBOARD:
                            uDefName = IDS_STDKEYBOARD;
                            break;
                        default:
                            uDefName = IDS_DEVICE_NAME;
                            break;
                        }
                        if( LoadStringW(g_hinst, uDefName, pdipstr->wsz, cA( pdipstr->wsz ) ) )
                        {
                            SquirtSqflPtszV(sqflHid | sqflVerbose,
                                TEXT( "Loaded default sys dev name %S"), pdipstr->wsz );
                            hres = S_OK;
                        }
                        else
                        {
                            /*
                             *  Give up, this machine is toast if we can't 
                             *  even load a string from our own resources.
                             */
                            SquirtSqflPtszV(sqflHidDev | sqflError,
                                            TEXT("CHid_GetProperty(guid:%08x) failed to get name"),
                                            ppropi->pguid);
                            hres = E_FAIL;
                        }
                    }
                }
            }
            else
            {

                /*
                 *  For game controllers, first look in MediaProperties.
                 *  This is the most likely place to find a localized string 
                 *  free from corruption by the setup process.
                 *  This should only fail before the type key is created when 
                 *  it first used so other paths are rare.
                 */

                DIJOYTYPEINFO dijti;
                WCHAR wszType[cbszVIDPID];

                /* Check the type key or get predefined name */
                ZeroX(dijti);
                dijti.dwSize = cbX(dijti);

                if( ( this->VendorID == MSFT_SYSTEM_VID )
                    &&( ( this->ProductID >= MSFT_SYSTEM_PID + JOY_HW_PREDEFMIN )
                        &&( this->ProductID < MSFT_SYSTEM_PID + JOY_HW_PREDEFMAX ) ) )
                {
                    wszType[0] = L'#';
                    wszType[1] = L'0' + (WCHAR)(this->ProductID-MSFT_SYSTEM_PID);
                    wszType[2] = L'\0';

                    hres = JoyReg_GetPredefTypeInfo( wszType, &dijti, DITC_DISPLAYNAME);
                    AssertF( SUCCEEDED( hres ) );
                    AssertF( dijti.wszDisplayName[0] != L'\0' );
                    lstrcpyW(pdipstr->wsz, dijti.wszDisplayName);
                    SquirtSqflPtszV(sqflHid | sqflVerbose,
                        TEXT( "Got name as predefined %s"), pdipstr->wsz );
                } 
                else
                {
                  #ifndef WINNT
                    static WCHAR wszDefHIDName[] = L"HID Game Controller";
                  #endif
                    BOOL fOverwriteDeviceName = FALSE;

                  #ifndef UNICODE
                    TCHAR tszType[cbszVIDPID];

                    wsprintf(tszType, VID_PID_TEMPLATE, this->VendorID, this->ProductID);
                    TToU( wszType, cA(wszType), tszType );
                  #else
                    wsprintf(wszType, VID_PID_TEMPLATE, this->VendorID, this->ProductID);
                  #endif

                  #ifdef WINNT
                    #define INPUT_INF_FILENAME L"\\INF\\INPUT.INF"
                    if( g_wszDefaultHIDName[0] == L'\0' )
                    {
                        WCHAR   wszInputINF[MAX_PATH];
                        UINT    uLen;
                        uLen = GetWindowsDirectoryW( wszInputINF, cA( wszInputINF ) );

                        /*
                         *  If the path is too long, don't set the filename 
                         *  so the the default string gets used when the 
                         *  GetPrivateProfileString fails.
                         */
                        if( uLen < cA(wszInputINF) - cA(INPUT_INF_FILENAME) )
                        {
                            memcpy( (PBYTE)&wszInputINF[uLen], (PBYTE)INPUT_INF_FILENAME, cbX( INPUT_INF_FILENAME ) );
                        }

                        /*
                         *  Remember the length, if the string was too long to 
                         *  fit in the buffer there will be plenty to make a 
                         *  reasonable comparison.
                         */
                        g_uLenDefaultHIDSize = 2 * GetPrivateProfileStringW( 
                            L"strings", L"HID.DeviceDesc", L"USB Human Interface Device",
                            g_wszDefaultHIDName, cA( g_wszDefaultHIDName ) - 1, wszInputINF );
                    }
                    #undef INPUT_INF_FILENAME
                  #endif
                  
                    if( SUCCEEDED(hres = JoyReg_GetTypeInfo(wszType, &dijti, DITC_DISPLAYNAME))
                        && (dijti.wszDisplayName[0] != L'\0')
                      #ifdef WINNT
                        && ( (g_uLenDefaultHIDSize == 0)
                            || memcmp(dijti.wszDisplayName, g_wszDefaultHIDName, g_uLenDefaultHIDSize) ) // not equal
                      #else
                        && memcmp(dijti.wszDisplayName, wszDefHIDName, cbX(wszDefHIDName)-2)  //not equal
                      #endif
                    )
                    {
                        lstrcpyW(pdipstr->wsz, dijti.wszDisplayName);

                        SquirtSqflPtszV(sqflHid | sqflVerbose,
                            TEXT("Got name from type info %s"), pdipstr->wsz );
                    }
                  #ifdef WINNT
                    else if( fHasSpecificHardwareMatch( this->ptszId )
                          && SUCCEEDED( hres = DIHid_GetParentRegistryProperty(this->ptszId, SPDRP_DEVICEDESC, pdiph, 0x0 ) ) )
                    {
                        fOverwriteDeviceName = TRUE;

                        SquirtSqflPtszV(sqflHid | sqflVerbose,
                            TEXT("Got device description %s"), pdipstr->wsz );
                    }
                  #endif
                    else
                    {
                        if( fGetProductStringFromDevice( this, pdipstr->wsz, cbX( pdipstr->wsz ) ) )
                        {
                            fOverwriteDeviceName = TRUE;

                            SquirtSqflPtszV(sqflHid | sqflVerbose,
                                TEXT("Got description %s from device"), pdipstr->wsz );
                        }
                        else
                        {
                            /*
                             *  Just make up a name from the caps
                             */
                            CType_MakeGameCtrlName( pdipstr->wsz, 
                                this->dwDevType, this->dwAxes, this->dwButtons, this->dwPOVs );

                            fOverwriteDeviceName = TRUE;

                            SquirtSqflPtszV(sqflHid | sqflVerbose,
                                TEXT("Made up name %s"), pdipstr->wsz );

                        }

                        hres = S_OK;
                    }

                    if( fOverwriteDeviceName ) {
                        /*
                         * If we have a better name, overwrite the old one with this better one.
                         * See manbug 46438.
                         */
                        AssertF(this->hkType);
                        AssertF(pdipstr->wsz[0]);
                        hres = JoyReg_SetValue(this->hkType,
                                               REGSTR_VAL_JOYOEMNAME, REG_SZ,
                                               pdipstr->wsz,
                                               cbX(pdipstr->wsz));
                        if( FAILED(hres) ){
                            SquirtSqflPtszV(sqflHid | sqflVerbose,
                                TEXT("Unable to overwrite generic device name with %s"), pdipstr->wsz );
    
                            // This failure (unlikely) doesn't matter.
                            hres = S_OK;
                        }
                    }

                }
            }

            if( SUCCEEDED(hres) 
             && ( this->diHacks.nMaxDeviceNameLength < MAX_PATH )
             && ( this->diHacks.nMaxDeviceNameLength < lstrlenW(pdipstr->wsz) ) )
            {
                pdipstr->wsz[this->diHacks.nMaxDeviceNameLength] = L'\0';
            }
            break;
        }

        case (DWORD)(UINT_PTR)DIPROP_JOYSTICKID:
            if( ( GET_DIDEVICE_TYPE( this->dwDevType ) >= DI8DEVTYPE_GAMEMIN ) 
             && ( this->dwDevType & DIDEVTYPE_HID ) )
            {
                LPDIPROPDWORD pdipdw = (PV)pdiph;
                pdipdw->dwData =  this->idJoy;
                hres = S_OK;

            } else
            {
                hres = E_NOTIMPL;
            }
            break;

        case (DWORD)(UINT_PTR)DIPROP_GETPORTDISPLAYNAME:

#ifdef WINNT
            /* For HID devices Port Display Name is the grand parent name */
            hres = DIHid_GetParentRegistryProperty(this->ptszId, SPDRP_FRIENDLYNAME, pdiph, TRUE);
            if( FAILED(hres) )
            {
                /* Maybe we can use the Product Name */
                hres = DIHid_GetParentRegistryProperty(this->ptszId, SPDRP_DEVICEDESC, pdiph, TRUE);
                if( SUCCEEDED(hres) )
                {
                    /* We only sort of succeeded */
                    hres = S_FALSE;
                }
            }
            if( SUCCEEDED(hres) 
             && ( this->diHacks.nMaxDeviceNameLength < MAX_PATH ) )
            {
                LPDIPROPSTRING pdipstr = (PV)pdiph;
                if( this->diHacks.nMaxDeviceNameLength < lstrlenW(pdipstr->wsz) )
                {
                    pdipstr->wsz[this->diHacks.nMaxDeviceNameLength] = L'\0';
                }
            }
#else
            // Not sure how this works on Win9x
            hres = E_NOTIMPL;
#endif
            break;

        case (DWORD)(UINT_PTR)(DIPROP_ENABLEREPORTID):
            hres = E_NOTIMPL;
            break;

        case (DWORD)(UINT_PTR)DIPROP_VIDPID:
            {
                LPDIPROPDWORD pdipdw = (PV)pdiph;
                /* Assert that a DWORD copy is all that is needed */
                CAssertF( FIELD_OFFSET( CHID, VendorID ) + cbX( this->VendorID ) 
                       == FIELD_OFFSET( CHID, ProductID ) );
                pdipdw->dwData =  *((PDWORD)(&this->VendorID));
                hres = S_OK;
            } 
            break;

        case (DWORD)(UINT_PTR)(DIPROP_MAPFILE):
            if( ( this->dwDevType == DI8DEVTYPE_MOUSE )
             || ( this->dwDevType == DI8DEVTYPE_KEYBOARD ) )
            {
                hres = E_NOTIMPL;
            }
            else
            {
                LPDIPROPSTRING pdipstr = (PV)pdiph;
                LONG    lRes;
                DWORD   dwBufferSize = cbX(pdipstr->wsz);

                lRes = RegQueryStringValueW( this->hkProp, REGSTR_VAL_JOYOEMMAPFILE, pdipstr->wsz, &dwBufferSize );
                hres = ( pdipstr->wsz[0] && ( lRes == ERROR_SUCCESS ) ) ? S_OK : DIERR_OBJECTNOTFOUND;

#ifdef WINNT
				if (SUCCEEDED(hres))
				{
					// there is a file name in the registry

#define MAP_INI_FILEPATH L"\\DIRECTX\\DINPUT"
					WCHAR   wszMapINI[MAX_PATH+1];
                    UINT    uLen;
					WCHAR wszDrive[_MAX_DRIVE];
					WCHAR wszFullPath[MAX_PATH];
					LPWSTR pFilename = NULL;

					// construct the directory path to the INIs
					ZeroMemory(wszMapINI, cbX(wszMapINI));
                    uLen = GetSystemDirectoryW( wszMapINI, cA( wszMapINI ) );
					if( uLen < cA(wszMapINI) - cA(MAP_INI_FILEPATH) )
                    {
                        memcpy( (PBYTE)&wszMapINI[uLen], (PBYTE)MAP_INI_FILEPATH, cbX( MAP_INI_FILEPATH ) );
                    }

					// Valmel: ISSUE 2001/03/22: note that we do not handle paths that
					// start with "%windir%" or "%SystemRoot%"; this is because dimap.dll doesn't
					// handle them correctly either
					wszDrive[0]=0;
					ZeroMemory(wszFullPath, cbX(wszFullPath));
					_wsplitpath(pdipstr->wsz,wszDrive,NULL,NULL,NULL);
					if (wszDrive[0] == 0)
					{
						// relative path -- attach directory path to the front
						_snwprintf(wszFullPath, MAX_PATH, TEXT("%s\\%s"), wszMapINI, pdipstr->wsz);
					}
					else
					{
						// absolute path -- copy it
						lstrcpynW(wszFullPath, pdipstr->wsz, MAX_PATH);
					}

					// take care of ".." and ".",
					// and check that our path starts w/ the correct directory path
					uLen = GetFullPathNameW(wszFullPath, cA(pdipstr->wsz), pdipstr->wsz, &pFilename);
					if ((uLen > cA(pdipstr->wsz)) || (_wcsnicmp(pdipstr->wsz, wszMapINI, lstrlenW(wszMapINI)) != 0))
					{
						// either the path is longer than the space we have for it, or
						// it doesn't start w/ the correct directory path; 
						// return a "not found" error different from the one we return if there's no registry entry
						ZeroMemory(pdipstr->wsz, cbX(pdipstr->wsz));
						hres = DIERR_NOTFOUND;
					}

#undef MAP_INI_FILEPATH
				}
#endif

            }
            break;

        case (DWORD)(UINT_PTR)(DIPROP_TYPENAME):
            if( ( this->dwDevType == DI8DEVTYPE_MOUSE )
             || ( this->dwDevType == DI8DEVTYPE_KEYBOARD ) )
            {
                hres = E_NOTIMPL;
            }
            else
            {
                LPDIPROPSTRING pdipstr = (PV)pdiph;

                if( ( this->VendorID == MSFT_SYSTEM_VID )
                    &&( ( this->ProductID >= MSFT_SYSTEM_PID + JOY_HW_PREDEFMIN )
                        &&( this->ProductID < MSFT_SYSTEM_PID + JOY_HW_PREDEFMAX ) ) )
                {
                    pdipstr->wsz[0] = L'#';
                    pdipstr->wsz[1] = L'0' + (WCHAR)(this->ProductID-MSFT_SYSTEM_PID);
                    pdipstr->wsz[2] = L'\0';
                } 
                else
                {
    #ifndef UNICODE
                    TCHAR tszType[cbszVIDPID];

                    wsprintf(tszType, VID_PID_TEMPLATE, this->VendorID, this->ProductID);
                    TToU( pdipstr->wsz, cA(pdipstr->wsz), tszType );
    #else
                    wsprintf(pdipstr->wsz, VID_PID_TEMPLATE, this->VendorID, this->ProductID);
    #endif
                }
                hres = S_OK;
            }
            break;

        default:
            SquirtSqflPtszV(sqflHid | sqflBenign ,
                            TEXT("CHid_GetProperty(iobj=0xFFFFFFFF): E_NOTIMPL on guid: %08x"),
                            ppropi->pguid);

            hres = E_NOTIMPL;
            break;
        }

    } else
    {
        SquirtSqflPtszV(sqflHidDev | sqflError,
                        TEXT("CHid_GetProperty(iobj=%08x): E_NOTIMPL on guid: %08x"),
                        ppropi->iobj, ppropi->pguid);

        hres = E_NOTIMPL;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LONG | CHid_CoordinateTransform |
 *
 *          Convert numbers from logical to physical or vice versa.
 *
 *          If either the To or From values look suspicious, then
 *          ignore them and leave the values alone.
 *
 *  @parm   PLMINMAX | Dst |
 *
 *          Destination min/max information.
 *
 *  @parm   PLMINMAX | Src |
 *
 *          Source min/max information.
 *
 *  @parm   LONG | lVal |
 *
 *          Source value to be converted.
 *
 *  @returns
 *
 *          The destination value after conversion.
 *
 *****************************************************************************/

LONG EXTERNAL
    CHid_CoordinateTransform(PLMINMAX Dst, PLMINMAX Src, LONG lVal)
{
    /*
     *  Note that the sanity check is symmetric in Src and Dst.
     *  This is important, so that we never get into a weird
     *  case where we can convert one way but can't convert back.
     */
    if(Dst->Min < Dst->Max && Src->Min < Src->Max)
    {

        /*
         *  We need to perform a straight linear interpolation.
         *  The math comes out like this:
         *
         *  x  - x0   y  - y0
         *  ------- = -------
         *  x1 - x0   y1 - y0
         *
         *  If you now do a "solve for y", you get
         *
         *
         *               y1 - y0
         *  y = (x - x0) ------- + y0
         *               x1 - x0
         *
         *  where "x" is Src, "y" is Dst, 0 is Min, and 1 is Max.
         *
         *
         */

        lVal = MulDiv(lVal - Src->Min, Dst->Max - Dst->Min,
                      Src->Max - Src->Min) + Dst->Min;
    }

    return lVal;
}


#ifndef WINNT
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method int | CHid | IsMatchingJoyDevice |
 *
 *          Does the cached joystick ID match us?
 *
 *  @parm   OUT PVXDINITPARMS | pvip |
 *
 *          On success, contains parameter values.
 *
 *  @returns
 *
 *          Nonzero on success.
 *
 *****************************************************************************/

BOOL INTERNAL
    CHid_IsMatchingJoyDevice(PCHID this, PVXDINITPARMS pvip)
{
    CHAR sz[MAX_PATH];
    LPSTR pszPath;
    BOOL fRc;

    pszPath = JoyReg_JoyIdToDeviceInterface_95(this->idJoy, pvip, sz);
    if(pszPath)
    {
        SquirtSqflPtszV(sqfl | sqflTrace,
                        TEXT("CHid_IsMatchingJoyDevice: %d -> %s"),
                        this->idJoy, pszPath);
    #ifdef UNICODE
        {
            CHAR szpath[MAX_PATH];
            UToA( szpath, cA(szpath), (LPWSTR)this->ptszPath);
            fRc = ( lstrcmpiA(pszPath, szpath) == 0x0 );
        }
    #else
        fRc = ( lstrcmpiA(pszPath, (PCHAR)this->ptszPath) == 0x0 );
    #endif
    } else
    {
        fRc = FALSE;
    }

    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CHid | FindJoyDevice |
 *
 *          Look for the VJOYD device that matches us, if any.
 *
 *          On return, the <e CHID.idJoy> field contains the
 *          matching joystick number, or -1 if not found.
 *
 *  @parm   OUT PVXDINITPARMS | pvip |
 *
 *          On success, contains parameter values.
 *
 *****************************************************************************/

void INTERNAL
    CHid_FindJoyDevice(PCHID this, PVXDINITPARMS pvip)
{

    /*
     *  If we have a cached value, and it still works, then
     *  our job is done.
     */
    if(this->idJoy >= 0 &&
       CHid_IsMatchingJoyDevice(this, pvip))
    {
    } else
    {
        /*
         *  Need to keep looking.  (Or start looking.)
         *
         *  A countdown loop is nicer, but for efficiency, we count
         *  upwards, since the joystick we want tends to be near the
         *  beginning.
         */
        for(this->idJoy = 0; this->idJoy < cJoyMax; this->idJoy++)
        {
            if(CHid_IsMatchingJoyDevice(this, pvip))
            {
                goto done;
            }
        }
        this->idJoy = -1;
    }

    done:;
}
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method int | CHid | MapAxis |
 *
 *          Find VJOYD axis from HID axis, if one.
 *
 *  @parm   PVXDINITPARMS | pvip |
 *
 *          Parameter values that let us known which axes VJOYD
 *          has mapped to which HID Axes.
 *
 *  @parm   UINT | iobj |
 *
 *          Object index of the object whose axis value changed.
 *
 *  @returns
 *
 *          The VJOYD axis number that changed (0 to 5), or -1
 *          if there is no matching axis.  There will be no matching
 *          axis if, for example, the device has something that is
 *          not expressible via VJOYD (e.g., a temperature sensor).
 *
 *****************************************************************************/

int INTERNAL
    CHid_MapAxis(PCHID this, PVXDINITPARMS pvip, UINT iobj)
{
    int iAxis;
    DWORD dwUsage;

    AssertF(this->dcb.lpVtbl->GetUsage == CHid_GetUsage);

    dwUsage = CHid_GetUsage(&this->dcb, (int)iobj);

    if(dwUsage)
    {

        /*
         *  A countdown loop lets us fall out with the correct failure
         *  code (namely, -1).
         */
        iAxis = cJoyPosAxisMax;
        while(--iAxis >= 0)
        {
            if(pvip->Usages[iAxis] == dwUsage)
            {
                break;
            }
        }
    } else
    {
        /*
         *  Eek!  No usage information for the axis.  Then it certainly
         *  isn't a VJOYD axis.
         */
        iAxis = -1;
    }

    return iAxis;

}

#ifndef WINNT
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CHid | UpdateVjoydCalibration |
 *
 *          Somebody changed the calibration on a single axis.  If we
 *          are shadowing a joystick, then look for the VJOYD alias of
 *          our device and update its registry settings, too.
 *
 *
 *  @parm   UINT | iobj |
 *
 *          Object index of the object whose calibration changed.
 *
 *****************************************************************************/

void EXTERNAL
    CHid_UpdateVjoydCalibration(PCHID this, UINT iobj)
{
    HRESULT hres;
    int iAxis;
    VXDINITPARMS vip;
    DIJOYCONFIG cfg;
    PHIDGROUPCAPS pcaps;
    PJOYRANGECONVERT pjrc;

    AssertF(iobj < this->df.dwNumObjs);

    /*
     *  Proceed if...
     *
     *  -   We can find the VJOYD device we correspond to.
     *  -   We can find the axis that got updated.
     *  -   The indicated axis has capability information.
     *  -   The indicated axis has calibration information.
     *  -   We can read the old calibration information.
     */

    CHid_FindJoyDevice(this, &vip);
    if(this->idJoy >= 0 &&
       (iAxis = CHid_MapAxis(this, &vip, iobj)) >= 0 &&
       (pcaps = this->rghoc[iobj].pcaps) != NULL &&
       (pjrc = this->rghoc[iobj].pjrc) != NULL &&
       SUCCEEDED(hres = JoyReg_GetConfig(this->idJoy, &cfg,
                                         DIJC_REGHWCONFIGTYPE)))
    {

        PLMINMAX Dst = &pcaps->Physical;
        PLMINMAX Src = &pcaps->Logical;

        AssertF(iAxis < cJoyPosAxisMax);

    #define JoyPosValue(phwc, f, i)                                 \
            *(LPDWORD)pvAddPvCb(&(phwc)->hwv.jrvHardware.f,             \
                            ibJoyPosAxisFromPosAxis(i))

        /*
         *  We use logical coordinates, but VJOYD wants physical
         *  coordinates, so do the conversion while we copy the
         *  values.
         */
    #define ConvertValue(f1, f2)                                    \
            JoyPosValue(&cfg.hwc, f1, iAxis) =                          \
                    CHid_CoordinateTransform(Dst, Src, pjrc->f2)        \

        ConvertValue(jpMin   , dwPmin);
        ConvertValue(jpMax   , dwPmax);
        ConvertValue(jpCenter, dwPc  );

    #undef ConvertValue
    #undef JoyPosValue

        /*
         *  Notice that we do *not* pass the DIJC_UPDATEALIAS flag
         *  because WE ARE THE ALIAS!  If we had passed the flag,
         *  then JoyReg would create us and attempt to update our
         *  calibration which we don't want it to do because the
         *  whole thing was our idea in the first place.
         */
        hres = JoyReg_SetConfig(this->idJoy, &cfg.hwc, &cfg,
                                DIJC_REGHWCONFIGTYPE);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CHid | UpdateCalibrationFromVjoyd |
 *
 *          This function is only for Win9x. Joy.cpl uses winmm (through vjoyd)
 *          to calibrate the device, and save calibration information directly into
 *          registry without notifying HID. ANother issue is: vjoyd only use unsigned
 *          data (physical data), while HID also use signed data. When we read
 *          calibration information from VJOYD, we need do conversion.
 *
 *  @parm   UINT | iobj |
 *
 *          Object index of the object whose calibration changed.
 *
 *****************************************************************************/

void EXTERNAL
    CHid_UpdateCalibrationFromVjoyd(PCHID this, UINT iobj, LPDIOBJECTCALIBRATION pCal)
{
    HRESULT hres;
    int iAxis;
    VXDINITPARMS vip;
    DIJOYCONFIG cfg;
    PHIDGROUPCAPS pcaps;
    PJOYRANGECONVERT pjrc;

    AssertF(iobj < this->df.dwNumObjs);

    /*
     *  Proceed if...
     *
     *  -   We can find the VJOYD device we correspond to.
     *  -   We can find the axis that got updated.
     *  -   The indicated axis has capability information.
     *  -   The indicated axis has calibration information.
     *  -   We can read the calibration information.
     */

    CHid_FindJoyDevice(this, &vip);
    if(this->idJoy >= 0 &&
       (iAxis = CHid_MapAxis(this, &vip, iobj)) >= 0 &&
       (pcaps = this->rghoc[iobj].pcaps) != NULL &&
       (pjrc = this->rghoc[iobj].pjrc) != NULL &&
       SUCCEEDED(hres = JoyReg_GetConfig(this->idJoy, &cfg,
                                         DIJC_REGHWCONFIGTYPE)))
    {

        PLMINMAX Src = &pcaps->Physical;
        PLMINMAX Dst = &pcaps->Logical;

        AssertF(iAxis < cJoyPosAxisMax);

        #define JoyPosValue(phwc, f, i)                                 \
            *(LPDWORD)pvAddPvCb(&(phwc)->hwv.jrvHardware.f,             \
                            ibJoyPosAxisFromPosAxis(i))

        /*
         *  We use logical coordinates, but VJOYD wants physical
         *  coordinates, so do the conversion while we copy the
         *  values.
         */
        #define ConvertValue(f1, f2)                           \
            pCal->f2 = CHid_CoordinateTransform(Dst, Src,     \
                                             JoyPosValue(&cfg.hwc, f1, iAxis) ) 
        ConvertValue(jpMin   , lMin);
        ConvertValue(jpMax   , lMax);
        ConvertValue(jpCenter, lCenter);

        #undef ConvertValue
        #undef JoyPosValue

    }
}
#endif

#ifdef WINNT
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func HRESULT |  DIHid_SetParentRegistryProperty |
 *
 *          Wrapper around <f SetupDiSetDeviceRegistryProperty>
 *          that handles character set issues.
 *
 *  @parm   LPTSTR ptszId
 *          
 *          Device Instance ID.
 *  
 *  @parm   DWORD | dwProperty |
 *
 *          The property being queried.
 *
 *  @parm   LPCDIPROPHEADER | diph |
 *
 *          Property data to be set.
 *
 *****************************************************************************/
HRESULT INTERNAL
    DIHid_SetParentRegistryProperty(LPTSTR ptszId, DWORD dwProperty, LPCDIPROPHEADER pdiph)
{
    HDEVINFO hdev;
    TCHAR   tsz[MAX_PATH];
    LPDIPROPSTRING pstr = (PV)pdiph;
    HRESULT hres = E_FAIL;

    hdev = SetupDiCreateDeviceInfoList(NULL, NULL);
    if(hdev != INVALID_HANDLE_VALUE)
    {
        SP_DEVINFO_DATA dinf;

        ZeroX(tsz);
    #ifdef UNICODE
        lstrcpyW(tsz, pstr->wsz);
    #else 
        UToA(tsz, cA(tsz), pstr->wsz);
    #endif
        dinf.cbSize = cbX(SP_DEVINFO_DATA);

        if(SetupDiOpenDeviceInfo(hdev, ptszId, NULL, 0, &dinf))
        {
            CONFIGRET cr;
            DEVINST DevInst;
            if( (cr = CM_Get_Parent(&DevInst, dinf.DevInst, 0x0) ) == CR_SUCCESS )
            {
                CAssertF( SPDRP_DEVICEDESC   +1  == CM_DRP_DEVICEDESC  );
                CAssertF( SPDRP_FRIENDLYNAME +1  ==  CM_DRP_FRIENDLYNAME );

                if( ( cr = CM_Set_DevNode_Registry_Property(
                                                           DevInst,
                                                           dwProperty+1,
                                                           (LPBYTE)tsz,
                                                           MAX_PATH *cbX(TCHAR),
                                                           0x0 ) ) == CR_SUCCESS )
                {
                    hres = S_OK;
                } else
                {
                    SquirtSqflPtszV(sqfl | sqflVerbose,
                                    TEXT("CM_Get_DevNode_Registry_Property FAILED") );
                }
            } else
            {
                SquirtSqflPtszV(sqfl | sqflVerbose,
                                TEXT("CM_Get_Parent FAILED") );
            }
        } else
        {
            SquirtSqflPtszV(sqfl | sqflVerbose,
                            TEXT("SetupDiOpenDeviceInfo FAILED, le = %d"), GetLastError() );
        }

        SetupDiDestroyDeviceInfoList(hdev);
    } else
    {
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("SetupDiCreateDeviceInfoList FAILED, le = %d"), GetLastError() );
    }

    return hres;
}
#else
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func HRESULT |  DIHid_SetRegistryProperty |
 *
 *          Wrapper around <f SetupDiSetDeviceRegistryProperty>
 *          that handles character set issues.
 *
 *  @parm   LPTSTR ptszId
 *          
 *          Device Instance ID.
 *  
 *  @parm   DWORD | dwProperty |
 *
 *          The property being queried.
 *
 *  @parm   LPCDIPROPHEADER | diph |
 *
 *          Property data to be set.
 *
 *****************************************************************************/
HRESULT INTERNAL
    DIHid_SetRegistryProperty(LPTSTR ptszId, DWORD dwProperty, LPCDIPROPHEADER pdiph)
{
    HDEVINFO hdev;
    TCHAR   tsz[MAX_PATH];
    LPDIPROPSTRING pstr = (PV)pdiph;
    HRESULT hres;

    hdev = SetupDiCreateDeviceInfoList(NULL, NULL);
    if(hdev != INVALID_HANDLE_VALUE)
    {
        SP_DEVINFO_DATA dinf;

        ZeroX(tsz);
    #ifdef UNICODE
        lstrcpyW(tsz, pstr->wsz);
    #else 
        UToA(tsz, cA(tsz), pstr->wsz);
    #endif
        dinf.cbSize = cbX(SP_DEVINFO_DATA);

        if(SetupDiOpenDeviceInfo(hdev, ptszId, NULL, 0, &dinf))
        {
            if(SetupDiSetDeviceRegistryProperty(hdev, &dinf, dwProperty,
                                                (LPBYTE)tsz, MAX_PATH*cbX(TCHAR)) )
            {
                hres = S_OK;

            } else
            {
                hres = E_FAIL;
            }
        } else
        {
            hres = E_FAIL;
        }

        SetupDiDestroyDeviceInfoList(hdev);
    } else
    {
        hres = E_FAIL;
    }

    return hres;
}
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | SetAxisProperty |
 *
 *          Set the appropriate axis property (or return E_NOTIMPL if the 
 *          property is not an axis property).
 *          If the request is to set a property on the device,
 *          then convert it into separate requests, one for each
 *          axis.
 *
 *  @parm   PDCHID | this |
 *
 *          The device object.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being set.
 *
 *  @parm   LPCDIPROPHEADER | pdiph |
 *
 *          Structure containing property value.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c E_NOTIMPL> nothing happened.  The caller will do
 *          the default thing in response to <c E_NOTIMPL>.
 *
 *****************************************************************************/

STDMETHODIMP
CHid_SetAxisProperty
(
    PCHID this, 
    LPCDIPROPINFO ppropi, 
    LPCDIPROPHEADER pdiph
)
{
    HRESULT hres;
    INT     iObjLimit;
    INT     iObj;


    if (ppropi->dwDevType == 0) 
    {   /* For device try every object */
        iObj = 0;
        iObjLimit = this->df.dwNumObjs;
    } 
    else
    {   /* For axis just do the requested one */
        iObj = ppropi->iobj;
        iObjLimit = ppropi->iobj + 1;
    }

    hres = S_OK;
    for( ; iObj < iObjLimit; iObj++ )
    {
        PJOYRANGECONVERT pjrc;

        if( pjrc = this->rghoc[iObj].pjrc )
        {
            if( (this->df.rgodf[iObj].dwType &
                 (DIDFT_ALIAS | DIDFT_VENDORDEFINED | DIDFT_OUTPUT | DIDFT_ABSAXIS)) == DIDFT_ABSAXIS)
            {
                PHIDGROUPCAPS pcaps = this->rghoc[iObj].pcaps;
                DIPROPCAL cal;
                
                /*
                *  Specific calibrations arrive in VJOYD coordinates.
                *  We need to convert them to DirectInput (logical)
                *  coordinates if so.
                */
                if(ppropi->pguid == DIPROP_SPECIFICCALIBRATION)
                {
                   if( pcaps )
                   {
                       PLMINMAX Dst = &pcaps->Logical;
                       PLMINMAX Src = &pcaps->Physical;
                       LPDIPROPCAL pcal = CONTAINING_RECORD(pdiph, DIPROPCAL, diph);
                
                       cal.lMin    = CHid_CoordinateTransform(Dst, Src, pcal->lMin);
                       cal.lCenter = CHid_CoordinateTransform(Dst, Src, pcal->lCenter);
                       cal.lMax    = CHid_CoordinateTransform(Dst, Src, pcal->lMax);
                
                       pdiph = &cal.diph;
                   }
                   else
                   {
                       AssertF( ppropi->dwDevType == 0 );
                       /*
                        *  Ignore the error.  If this is an object set 
                        *  property validation should have caught this 
                        *  already and the DX7 patch code for device set 
                        *  property special cased E_NOTIMPL so that one bad 
                        *  axis would not cause the whole call to fail when 
                        *  other axes may be OK.
                        *  A bit flakey but "this should never happen"
                        */            
                       continue;
                   }
                }
                
                hres = CCal_SetProperty( pjrc, ppropi, pdiph, this->hkInstType );
                
                #ifndef WINNT
                /*
                *  If we successfully changed the calibration of a game 
                *  controller device, then see if it's a VJOYD device.
                */
                if(SUCCEEDED(hres) &&
                  ppropi->pguid == DIPROP_CALIBRATION &&
                  GET_DIDEVICE_TYPE(this->dwDevType) >= DI8DEVTYPE_GAMEMIN)
                {
                   CHid_UpdateVjoydCalibration(this, ppropi->iobj);
                }
                #endif
            }
          #ifdef WINNT
            else if( (this->df.rgodf[iObj].dwType & 
                  (DIDFT_ALIAS | DIDFT_VENDORDEFINED | DIDFT_OUTPUT | DIDFT_POV)) == DIDFT_POV)
            {
                PHIDGROUPCAPS pcaps = this->rghoc[iObj].pcaps;
                
                if( pcaps )
                {
                    if( pcaps->IsPolledPOV ) 
                    {
                        hres = CCal_SetProperty(pjrc, ppropi, pdiph, this->hkInstType);
            
                        if( SUCCEEDED(hres) ) {
                            CHid_LoadCalibrations(this);
                            CHid_InitParseData( this );
                        }
                    }
                    else
                    {
                        if( ppropi->dwDevType != 0 )
                        {
                            hres = E_NOTIMPL;
                        }
                    }
                }
                else
                {
                    AssertF( ppropi->dwDevType == 0 );
                    /*
                     *  Ignore the error.  If this is an object set 
                     *  property validation should have caught this 
                     *  already and the DX7 patch code for device set 
                     *  property special cased E_NOTIMPL so that one bad 
                     *  axis would not cause the whole call to fail when 
                     *  other axes may be OK.
                     *  A bit flakey but "this should never happen"
                     */            
                    continue;
                }
            }
          #endif
        }
        else
        {
            /*
             *  If the object cannot have an axis property set, the DX7 code 
             *  returned E_NOTIMPL when it should have returned some parameter 
             *  error.  For a device, this is not an error as we are iterating 
             *  all objects looking for absolute axes.
             *  If it is an absolute axis but has no range conversion, return 
             *  E_NOTIMPL to match previous versions for an object but ignore 
             *  for the device.  This probably should be an E_FAIL...
             */
            if( ppropi->dwDevType != 0 )
            {
                hres = E_NOTIMPL;
            }
        }
    }

    /*
     *  Don't need to hold/unhold here because the app called us so it should 
     *  not be releasing us at the same time. (mb:34570)
     */
    CHid_LoadCalibrations(this);

    if( SUCCEEDED(hres) )
    {
        /*
         *  Until such time as CHid_InitParseData returns anything other than 
         *  S_OK, don't update a possibly more informative result with this.
         */
        D( HRESULT hresDbg = )
        CHid_InitParseData( this );
        D( AssertF( hresDbg == S_OK ); ) 
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | SetProperty |
 *
 *          Set a hid device property.
 *
 *  @parm   PCHID | this |
 *
 *          The hid object.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being set.
 *
 *  @parm   LPCDIPROPHEADER | pdiph |
 *
 *          Structure containing property value.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c E_NOTIMPL> nothing happened.  The caller will do
 *          the default thing in response to <c E_NOTIMPL>.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_SetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPCDIPROPHEADER pdiph)
{
    HRESULT hres;
    PCHID this;
    EnterProcI(IDirectInputDeviceCallback::Hid::SetProperty,
               (_ "pxxp", pdcb, ppropi->pguid, ppropi->iobj, pdiph));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    if(ppropi->iobj < this->df.dwNumObjs)
    {
        /* 
         * Object Property
         */
        PHIDGROUPCAPS pcaps;
        AssertF(ppropi->dwDevType == this->df.rgodf[ppropi->iobj].dwType);
        AssertF(ppropi->iobj == CHid_ObjFromType(this, ppropi->dwDevType));

        if( pcaps = this->rghoc[ppropi->iobj].pcaps )
        {
            switch((DWORD)(UINT_PTR)ppropi->pguid)
            {
            case (DWORD)(UINT_PTR)(DIPROP_ENABLEREPORTID):
                {
                    LPDIPROPDWORD ppropdw = CONTAINING_RECORD(pdiph, DIPROPDWORD, diph);

                    AssertF(pcaps->wReportId < this->wMaxReportId[pcaps->type]);
                    AssertF(this->pEnableReportId[pcaps->type]);

                    hres = S_OK;
                    if( ppropdw->dwData == 0x1 )
                    {
                        *(this->pEnableReportId[pcaps->type] + pcaps->wReportId) = 0x1;
                        pcaps->fReportDisabled = FALSE;
                    } else
                    {
                        *(this->pEnableReportId[pcaps->type] + pcaps->wReportId) = 0x0;
                        pcaps->fReportDisabled = TRUE;
                    }
                }
                break;

            default:
                AssertF(ppropi->dwDevType == this->df.rgodf[ppropi->iobj].dwType);
                AssertF(ppropi->iobj == CHid_ObjFromType(this, ppropi->dwDevType));

                hres = CHid_SetAxisProperty( this, ppropi, pdiph );

            }
        } else
        {
            SquirtSqflPtszV(sqflHidDev | sqflError,
                            TEXT("CHid_SetProperty FAILED due to missing caps for type 0x%08x, obj %d"),
                            ppropi->dwDevType, ppropi->iobj  );

            hres = E_NOTIMPL;
        }
    } else if(ppropi->iobj == 0xFFFFFFFF)
    {        /* Device property */

        switch((DWORD)(UINT_PTR)ppropi->pguid)
        {
        case (DWORD)(UINT_PTR)DIPROP_GUIDANDPATH:
            SquirtSqflPtszV(sqflHidDev | sqflError,
                            TEXT("CHid_SetProperty(iobj=%08x): PROP_GUIDANDPATH is read only.") );
            hres = E_NOTIMPL;
            break;


        case (DWORD)(UINT_PTR)DIPROP_INSTANCENAME:
            /*
             *  Friendly names cause all manner of problems with devices that 
             *  use auto detection so only allow non-predefined analog devices 
             *  to use them.
             */
            if( ( this->VendorID == MSFT_SYSTEM_VID )
             && ( this->ProductID >= MSFT_SYSTEM_PID + JOY_HW_PREDEFMAX )
             && ( ( this->ProductID & 0xff00 ) == MSFT_SYSTEM_PID ) )
            {
                AssertF(this->hkType);
                
                if( this->hkType )
                {
                    LPDIPROPSTRING pstr = (PV)pdiph;

                    hres = JoyReg_SetValue(this->hkType,
                                           REGSTR_VAL_JOYOEMNAME, REG_SZ,
                                           pstr->wsz,
                                           cbX(pstr->wsz));
                                              
                    if( SUCCEEDED(hres ) )
                    {
                        SquirtSqflPtszV(sqflHid | sqflVerbose,
                            TEXT( "Set instance name %s"), pstr->wsz );
                        hres = S_OK;
                    } else {
                        hres = E_FAIL;
                    }
                } else {
                    hres = E_FAIL;
                }
            }
            else
            {
                /*
                 *  GenJ returns E_NOTIMPL for this property so do the same
                 */
                hres = E_NOTIMPL;
            }

            break;

        case (DWORD)(UINT_PTR)DIPROP_PRODUCTNAME:
          #ifdef WINNT
            hres = DIHid_SetParentRegistryProperty(this->ptszId, SPDRP_DEVICEDESC, pdiph);
          #else
            hres = DIHid_SetRegistryProperty(this->ptszId, SPDRP_DEVICEDESC, pdiph);
          #endif
            break;

        case (DWORD)(UINT_PTR)(DIPROP_ENABLEREPORTID):
            {            
                LPDIPROPDWORD ppropdw = CONTAINING_RECORD(pdiph, DIPROPDWORD, diph);

                UINT iType;

                if( ppropdw->dwData == 0x0  )
                {
                    for( iType = 0x0; iType < HidP_Max; iType++)
                    {
                        ZeroBuf(this->pEnableReportId[iType], this->wMaxReportId[iType]);
                    }

                } else
                {
                    for( iType = 0x0; iType < HidP_Max; iType++)
                    {
                        memset(this->pEnableReportId[iType], 0x1, this->wMaxReportId[iType]);
                    }
                }
                hres = S_OK;
            }
            break;

        case (DWORD)(UINT_PTR)DIPROP_RANGE:
        case (DWORD)(UINT_PTR)DIPROP_DEADZONE:
        case (DWORD)(UINT_PTR)DIPROP_SATURATION:
        case (DWORD)(UINT_PTR)DIPROP_CALIBRATIONMODE:
        case (DWORD)(UINT_PTR)DIPROP_CALIBRATION:
            hres = CHid_SetAxisProperty( this, ppropi, pdiph );
            break;

        default:
            SquirtSqflPtszV(sqflHidDev| sqflBenign,
                            TEXT("CHid_SetProperty(iobj=%08x): E_NOTIMPL on guid: %08x"),
                            ppropi->iobj, ppropi->pguid);

            hres = E_NOTIMPL;
            break;
        }

    } else
    {
        SquirtSqflPtszV(sqflHidDev | sqflError,
                        TEXT("CHid_SetProperty(iobj=%08x): E_NOTIMPL on guid: %08x"),
                        ppropi->iobj, ppropi->pguid);

        hres = E_NOTIMPL;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CHid | GetCapabilities |
 *
 *          Get Hid device capabilities.
 *
 *  @parm   LPDIDEVCAPS | pdc |
 *
 *          Device capabilities structure to receive result.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_GetCapabilities(PDICB pdcb, LPDIDEVCAPS pdc)
{
    HRESULT hres;
    PCHID this;
    HANDLE h;
    DWORD dwFlags2 = 0;

    EnterProcI(IDirectInputDeviceCallback::Hid::GetCapabilities,
               (_ "pp", pdcb, pdc));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    /*
     *  We must check connectivity by opening the device, because NT
     *  leaves the device in the info list even though it has
     *  been unplugged.
     */
    h = CHid_OpenDevicePath(this, FILE_FLAG_OVERLAPPED);
    if(h != INVALID_HANDLE_VALUE)
    {
      #ifndef WINNT
        if( this->hkType )
        {
            VXDINITPARMS vip;

            CHid_FindJoyDevice(this, &vip);

            if( TRUE == CHid_IsMatchingJoyDevice( this, &vip ) )
            {
                DWORD dwFlags1;
                if( SUCCEEDED( JoyReg_GetValue( this->hkType,
                                                REGSTR_VAL_FLAGS1, REG_BINARY, 
                                                &dwFlags1, 
                                                cbX(dwFlags1) ) ) )
                {
                    if( dwFlags1 & JOYTYPE_NOHIDDIRECT )
                    {
                        pdc->dwFlags |= DIDC_ALIAS;
                    }
                }
            }
        }
      #endif // !WINNT

        CloseHandle(h);

        if( this->pvi->fl & VIFL_UNPLUGGED )
        {
            pdc->dwFlags &= ~DIDC_ATTACHED;
        } else
        {
            pdc->dwFlags |= DIDC_ATTACHED;
        }

    } else
    {
        pdc->dwFlags &= ~DIDC_ATTACHED;
    }

    if( this->IsPolledInput )
    {
        pdc->dwFlags |= DIDC_POLLEDDEVICE;
    }

    if( this->hkProp )
    {
        JoyReg_GetValue( this->hkProp, REGSTR_VAL_FLAGS2, REG_BINARY, 
            &dwFlags2, cbX(dwFlags2) );
    }

    if( !( dwFlags2 & JOYTYPE_HIDEACTIVE ) )
    {
        // Currently we only hide "fictional" keyboards and mice. 
        if(   ( GET_DIDEVICE_TYPE( this->dwDevType ) == DI8DEVTYPE_MOUSE )
            ||( GET_DIDEVICE_TYPE( this->dwDevType ) == DI8DEVTYPE_KEYBOARD )
              )
        {
            dwFlags2 = DIHid_DetectHideAndRevealFlags(this) ;
        }
    }

    if( dwFlags2 & JOYTYPE_HIDEACTIVE )
    {
        switch( GET_DIDEVICE_TYPE( this->dwDevType ) )
        {
        case DI8DEVTYPE_DEVICE:
            if( dwFlags2 & JOYTYPE_DEVICEHIDE )
            {
                pdc->dwFlags |= DIDC_HIDDEN;
            }
            break;
        case DI8DEVTYPE_MOUSE:
            if( dwFlags2 & JOYTYPE_MOUSEHIDE )
            {
                pdc->dwFlags |= DIDC_HIDDEN;
            }
            break;
        case DI8DEVTYPE_KEYBOARD:
            if( dwFlags2 & JOYTYPE_KEYBHIDE )
            {
                pdc->dwFlags |= DIDC_HIDDEN;
            }
            break;
        default:
            if( dwFlags2 & JOYTYPE_GAMEHIDE )
            {
                pdc->dwFlags |= DIDC_HIDDEN;
            }
            break;
        }
    }

    pdc->dwDevType = this->dwDevType;
    pdc->dwAxes = this->dwAxes;
    pdc->dwButtons = this->dwButtons;
    pdc->dwPOVs = this->dwPOVs;

    hres = S_OK;
    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | GetDeviceState |
 *
 *          Obtains the state of the Hid device.
 *
 *          It is the caller's responsibility to have validated all the
 *          parameters and ensure that the device has been acquired.
 *
 *  @parm   OUT LPVOID | lpvData |
 *
 *          Hid data in the preferred data format.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpmdr> parameter is not a valid pointer.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_GetDeviceState(PDICB pdcb, LPVOID pvData)
{
    HRESULT hres;
    PCHID this;
    EnterProcI(IDirectInputDeviceCallback::Hid::GetDeviceState,
               (_ "pp", pdcb, pvData));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);
    AssertF(this->pvPhys);
    AssertF(this->cbPhys);

    if(this->pvi->fl & VIFL_ACQUIRED)
    {
        CHid_GetPhysicalState(this, pvData);
        hres = S_OK;
    } else
    {
        hres = DIERR_INPUTLOST;
    }

    ExitOleProcR();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | GetObjectInfo |
 *
 *          Obtain the friendly name and FF/HID information
 *          of an object.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the object being accessed.
 *
 *  @parm   IN OUT LPDIDEVICEOBJECTINSTANCEW | pdidioiW |
 *
 *          Structure to receive information.  All fields have been
 *          filled in up to the <e DIDEVICEOBJECTINSTANCE.tszObjName>.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_GetObjectInfo(PDICB pdcb, LPCDIPROPINFO ppropi,
                       LPDIDEVICEOBJECTINSTANCEW pdidoiW)
{
    HRESULT hres;
    PCHID this;
    EnterProcI(IDirectInputDeviceCallback::Hid::GetObjectInfo,
               (_ "pxp", pdcb, ppropi->iobj, pdidoiW));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF((int) ppropi->iobj >= 0);

    if(ppropi->iobj < this->df.dwNumObjs)
    {
        UINT uiInstance = ppropi->iobj;
        PHIDGROUPCAPS pcaps;

        AssertF(ppropi->dwDevType == this->df.rgodf[uiInstance].dwType);
        AssertF(uiInstance == CHid_ObjFromType(this, ppropi->dwDevType));

        pcaps = this->rghoc[uiInstance].pcaps;

        /*
         *  pcaps might be NULL if HID messed up and left gaps
         *  in the index lists.
         */
        if(pcaps)
        {
            UINT ids, duiInstance;

            AssertF(pcaps->dwSignature == HIDGROUPCAPS_SIGNATURE);

            /*
             *  See if there's anything in the registry that will help.
             */
            CType_RegGetObjectInfo(this->hkType, ppropi->dwDevType, pdidoiW);


            if(ppropi->dwDevType & DIDFT_COLLECTION)
            {

                ids = IDS_COLLECTIONTEMPLATE;

                duiInstance = 0;

            } else
            {
                if(ppropi->dwDevType & DIDFT_BUTTON)
                {

                    ids = IDS_BUTTONTEMPLATE;

                } else if(ppropi->dwDevType & DIDFT_AXIS)
                {

                    ids = IDS_AXISTEMPLATE;

                } else if(ppropi->dwDevType & DIDFT_POV)
                {

                    ids = IDS_POVTEMPLATE;

                } else
                {
                    ids = IDS_UNKNOWNTEMPLATE;
                }

                /*
                 *  Now convert the uiInstance to a duiInstance,
                 *  giving the index of this object into the group.
                 */
                AssertF(HidP_IsValidReportType(pcaps->type));
                duiInstance = uiInstance -
                              (this->rgdwBase[pcaps->type] +
                               pcaps->DataIndexMin);
            }

            /*
             *  Okay, now we have all the info we need to proceed.
             */

            /*
             *  If there was no overriding name in the registry, then
             *  try to get a custom name from the usage page/usage.
             *  If even that fails, then use the generic name.
             *  Note, generic names will contain zero based numbers
             *  which can look wrong if some objects have names and 
             *  others take defaults.
             */
            if(pdidoiW->tszName[0])
            {
            } else
                if(GetHIDString(pcaps->UsageMin + duiInstance,
                                pcaps->UsagePage,
                                pdidoiW->tszName, cA(pdidoiW->tszName)))
            {
                if(ppropi->dwDevType & DIDFT_COLLECTION)
                {
                    InsertCollectionNumber(DIDFT_GETINSTANCE( ppropi->dwDevType ), 
                                           pdidoiW->tszName);
                }
            } else
            {
                GetNthString(pdidoiW->tszName, ids, 
                             DIDFT_GETINSTANCE( ppropi->dwDevType ));
            }
            if(pdidoiW->dwSize >= cbX(DIDEVICEOBJECTINSTANCE_DX5W))
            {

                pdidoiW->wCollectionNumber = pcaps->LinkCollection;

                pdidoiW->wDesignatorIndex = pcaps->DesignatorMin + duiInstance;
                if(pdidoiW->wDesignatorIndex > pcaps->DesignatorMax)
                {
                    pdidoiW->wDesignatorIndex = pcaps->DesignatorMax;
                }

                /*
                 *  Much as you may try, you cannot override the usage
                 *  page and usage.  Doing so would mess up the GUID
                 *  selection code that happens in DIHIDINI.C.
                 *
                 *  If you change your mind and allow overridden usage
                 *  pages and usages, then you'll also have to change
                 *  CHid_GetUsage.
                 *
                 *  At this point, the registry overrides have already 
                 *  been read so defeat the override here.
                 */
                pdidoiW->wUsagePage = pcaps->UsagePage;
                pdidoiW->wUsage = pcaps->UsageMin + duiInstance;
                pdidoiW->dwDimension  = pcaps->Units;
                pdidoiW->wExponent  = pcaps->Exponent;
                pdidoiW->wReportId  = pcaps->wReportId;
            }

            hres = S_OK;
        } else
        {
            hres = E_INVALIDARG;
        }
    } else
    {
        hres = E_INVALIDARG;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method DWORD | CHid | GetUsage |
 *
 *          Given an object index, return the usage and usage page,
 *          packed into a single <t DWORD>.
 *
 *  @parm   int | iobj |
 *
 *          The object index to convert.
 *
 *  @returns
 *
 *          Returns a <c DIMAKEUSAGEDWORD> of the resulting usage and
 *          usage page, or zero on error.
 *
 *****************************************************************************/

STDMETHODIMP_(DWORD)
CHid_GetUsage(PDICB pdcb, int iobj)
{
    PCHID this;
    PHIDGROUPCAPS pcaps;
    DWORD dwRc;
    EnterProcI(IDirectInputDeviceCallback::Hid::GetUsage,
               (_ "pu", pdcb, iobj));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(iobj >= 0);
    AssertF((UINT)iobj < this->df.dwNumObjs);

    pcaps = this->rghoc[iobj].pcaps;

    /*
     *  pcaps might be NULL if HID messed up and left gaps
     *  in the index lists.
     */
    if(pcaps)
    {
        UINT duiInstance;

        AssertF(pcaps->dwSignature == HIDGROUPCAPS_SIGNATURE);

        if(this->df.rgodf[iobj].dwType & DIDFT_COLLECTION)
        {

            duiInstance = 0;

        } else
        {

            /*
             *  Now convert the iobj to a duiInstance,
             *  giving the index of this object into the group.
             */
            AssertF(HidP_IsValidReportType(pcaps->type));
            duiInstance = iobj -
                          (this->rgdwBase[pcaps->type] +
                           pcaps->DataIndexMin);
        }

        /*
         *  CHid_GetObjectInfo also assumes that there is no way
         *  to override the usage page and usage values in the
         *  registry.
         */
        dwRc = DIMAKEUSAGEDWORD(pcaps->UsagePage,
                                pcaps->UsageMin + duiInstance);

    } else
    {
        dwRc = 0;
    }

    ExitProcX(dwRc);
    return dwRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | MapUsage |
 *
 *
 *          Given a usage and usage page (munged into a single
 *          <t DWORD>), find a device object that matches it.
 *
 *  @parm   DWORD | dwUsage |
 *
 *          The usage page and usage combined into a single <t DWORD>
 *          with the <f DIMAKEUSAGEDWORD> macro.
 *
 *  @parm   PINT | piOut |
 *
 *          Receives the object index of the found object, if successful.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c S_OK> if an object was found.
 *
 *          <c DIERR_NOTFOUND> if no matching object was found.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_MapUsage(PDICB pdcb, DWORD dwUsage, PINT piOut)
{
    HRESULT hres;
    PCHID   this;
    UINT    icaps;
    UINT    uiObj;
    UINT    duiObj;

    EnterProcI(IDirectInputDeviceCallback::Hid::MapUsage,
               (_ "px", pdcb, dwUsage));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    for(icaps = 0; icaps < this->ccaps; icaps++)
    {
        PHIDGROUPCAPS pcaps = &this->rgcaps[icaps];

        /*
         * Shall we support mapping HidP_Output usage? 
         * If we should, it is easy to add it later.
         */
        uiObj = this->rgdwBase[HidP_Input] + pcaps->DataIndexMin;

        for(duiObj = 0; duiObj < pcaps->cObj; duiObj++)
        {
            if( dwUsage == DIMAKEUSAGEDWORD(pcaps->UsagePage, pcaps->UsageMin+duiObj) )
            {
                *piOut = uiObj+duiObj; 
                AssertF(*piOut < (INT)this->df.dwNumObjs);
                hres = S_OK;
                goto done;
            }

        }
    }
    
    hres = DIERR_NOTFOUND;

    done:;
    ExitBenignOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | SetCooperativeLevel |
 *
 *          Notify the device of the cooperative level.
 *
 *  @parm   IN HWND | hwnd |
 *
 *          The window handle.
 *
 *  @parm   IN DWORD | dwFlags |
 *
 *          The cooperativity level.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/


STDMETHODIMP
    CHid_SetCooperativeLevel(PDICB pdcb, HWND hwnd, DWORD dwFlags)
{
    HRESULT hres;
    PCHID this;

    EnterProcI(IDirectInputDeviceCallback::Hid::SetCooperativityLevel,
               (_ "pxx", pdcb, hwnd, dwFlags));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    /*
     *  We won't subclass Motocross Madness. See NT bug 262280.
     *  Use the app hacks for MCM and any app like it.
     */
    if( !this->diHacks.fNoSubClass )
    {

        AssertF(this->pvi);

        /*
         *  First get out of the old window.
         */
        CHid_RemoveSubclass(this);
        /*
         *  Prefix warns that "this" may have been freed (mb:34570) however 
         *  If you're in SetCooperativeLevel and you have a window subclassed 
         *  then there must be a hold for the subclassed window as well as 
         *  one for the unreleased interface so the Common_Unhold won't free 
         *  the pointer.
         */


        /*
         *  If a new window is passed, then subclass it so we can
         *  watch for joystick configuration change messages.
         *
         *  If we can't, don't worry.  All it means that we won't
         *  be able to catch when the user recalibrates a device,
         *  which isn't very often.
         */
        if(hwnd)
        {
            if(SetWindowSubclass(hwnd, CHid_SubclassProc, 0x0, (ULONG_PTR)this))
            {
                this->hwnd = hwnd;
                Common_Hold(this);
            }

        } else
        {
            RPF("SetCooperativeLevel: You really shouldn't pass hwnd = 0; "
                "device calibration may be dodgy");
        }

    }

    hres = S_OK;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | RunControlPanel |
 *
 *          Run the Hid control panel.
 *
 *  @parm   IN HWND | hwndOwner |
 *
 *          The owner window.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_RunControlPanel(PDICB pdcb, HWND hwnd, DWORD dwFlags)
{
    HRESULT hres;
    PCHID this;
    EnterProcI(IDirectInputDeviceCallback::Hid::RunControlPanel,
               (_ "pxx", pdcb, hwnd, dwFlags));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    /*
     * How to invoke HID cpl?
     *
     * Currently, we just launch joy.cpl. If more HID devices show up
     * which don't belong to game control panel, we may change it to
     * proper cpl.
     *
     * on NT hresRunControlPanel(TEXT("srcmgr.cpl,@2"));
     * on 9x hresRunControlPanel(TEXT("sysdm.cpl,@0,1"));
     *
     */
    hres = hresRunControlPanel(TEXT("joy.cpl"));

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | GetFFConfigKey |
 *
 *          Open and return the registry key that contains
 *          force feedback configuration information.
 *
 *  @parm   DWORD | sam |
 *
 *          Security access mask.
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives the registry key.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_GetFFConfigKey(PDICB pdcb, DWORD sam, PHKEY phk)
{
    HRESULT hres;
    PCHID this;
    EnterProcI(IDirectInputDeviceCallback::HID::GetFFConfigKey,
               (_ "px", pdcb, sam));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    hres = JoyReg_OpenFFKey(this->hkType, sam, phk);

    AssertF(fLeqvFF(SUCCEEDED(hres), *phk));

    if(FAILED(hres) && this->fPIDdevice )
    {
        *phk = NULL;
        hres = S_FALSE;
    }

    ExitBenignOleProcPpvR(phk);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | GetDeviceInfo |
 *
 *          Obtain general information about the device.
 *
 *  @parm   OUT LPDIDEVICEINSTANCEW | pdiW |
 *
 *          <t DEVICEINSTANCE> to be filled in.  The
 *          <e DEVICEINSTANCE.dwSize> and <e DEVICEINSTANCE.guidInstance>
 *          have already been filled in.
 *
 *          Secret convenience:  <e DEVICEINSTANCE.guidProduct> is equal
 *          to <e DEVICEINSTANCE.guidInstance>.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_GetDeviceInfo(PDICB pdcb, LPDIDEVICEINSTANCEW pdiW)
{
    HRESULT hres;
    PCHID this;

    DIPROPINFO      propi;                            
    DIPROPSTRING    dips;

    EnterProcI(IDirectInputDeviceCallback::Hid::GetDeviceInfo,
               (_ "pp", pdcb, pdiW));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);
    AssertF(IsValidSizeDIDEVICEINSTANCEW(pdiW->dwSize));

    DICreateStaticGuid(&pdiW->guidProduct, this->ProductID, this->VendorID);

    pdiW->dwDevType = this->dwDevType;

    if(pdiW->dwSize >= cbX(DIDEVICEINSTANCE_DX5W))
    {
        pdiW->wUsagePage = this->caps.UsagePage;
        pdiW->wUsage     = this->caps.Usage;
    }

    propi.dwDevType = DIPH_DEVICE;
    propi.iobj      = 0xFFFFFFFF;
    propi.pguid = DIPROP_PRODUCTNAME;

    if(SUCCEEDED(hres = pdcb->lpVtbl->GetProperty(pdcb, &propi, &dips.diph)) )
    {
        lstrcpyW(pdiW->tszProductName, dips.wsz);
    }

    propi.pguid = DIPROP_INSTANCENAME;
    if( FAILED(pdcb->lpVtbl->GetProperty(pdcb, &propi, &dips.diph)))
    {
        // Use Product Name
    }

    lstrcpyW(pdiW->tszInstanceName, dips.wsz); 


    if(pdiW->dwSize >= cbX(DIDEVICEINSTANCE_DX5W))
    {
        HKEY hkFF;
        HRESULT hresFF;

        /*
         *  If there is a force feedback driver, then fetch the driver CLSID
         *  as the FF GUID.
         */
        hresFF = CHid_GetFFConfigKey(pdcb, KEY_QUERY_VALUE, &hkFF);
        if(SUCCEEDED(hresFF))
        {
            LONG lRc;
            TCHAR tszClsid[ctchGuid];

            lRc = RegQueryString(hkFF, TEXT("CLSID"), tszClsid, cA(tszClsid));
            if(lRc == ERROR_SUCCESS &&
               ParseGUID(&pdiW->guidFFDriver, tszClsid))
            {
            } else
            {
                ZeroX(pdiW->guidFFDriver);
            }
            RegCloseKey(hkFF);
        }
    }


    ExitOleProcR();
    return hres;

}
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | CreateEffect |
 *
 *
 *          Create an <i IDirectInputEffectDriver> interface.
 *
 *  @parm   LPDIRECTINPUTEFFECTSHEPHERD * | ppes |
 *
 *          Receives the shepherd for the effect driver.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_CreateEffect(PDICB pdcb, LPDIRECTINPUTEFFECTSHEPHERD *ppes)
{
    HRESULT hres;
    PCHID this;
    HKEY hk;
    EnterProcI(IDirectInputDeviceCallback::HID::CreateEffect, (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    hres = CHid_GetFFConfigKey(pdcb, KEY_QUERY_VALUE, &hk);
    if(SUCCEEDED(hres))
    {
        DIHIDFFINITINFO init;
        PHIDDEVICEINFO phdi;

        hres = CEShep_New(hk, 0, &IID_IDirectInputEffectShepherd, ppes);
        if(SUCCEEDED(hres))
        {
    #ifndef UNICODE
            WCHAR wszPath[MAX_PATH];
    #endif

            init.dwSize = cbX(init);
    #ifdef UNICODE
            init.pwszDeviceInterface = this->ptszPath;
    #else
            init.pwszDeviceInterface = wszPath;
            TToU(wszPath, cA(wszPath), this->ptszPath);
    #endif

            DllEnterCrit();
            phdi = phdiFindHIDDeviceInterface(this->ptszPath);

            if( phdi )
            {
                init.GuidInstance = phdi->guid;
            } else
            {
                ZeroX(init.GuidInstance);
            }
            DllLeaveCrit();

            hres = (*ppes)->lpVtbl->DeviceID((*ppes), this->idJoy, TRUE, &init);
            if(SUCCEEDED(hres))
            {
            } else
            {
                Invoke_Release(ppes);
            }
        }
		if (hk != NULL)
		{
            RegCloseKey(hk);
		}
    } else
    {
        hres = E_NOTIMPL;
        *ppes = 0;
    }

    ExitOleProcPpvR(ppes);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | SendOutputReport |
 *
 *          Actually send the report as an output report.
 *
 *  @parm   PHIDREPORTINFO | phri |
 *
 *          The report being sent.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

void CALLBACK
    CHid_DummyCompletion(DWORD dwError, DWORD cbRead, LPOVERLAPPED po)
{
}

STDMETHODIMP
    CHid_SendOutputReport(PCHID this, PHIDREPORTINFO phri)
{
    HRESULT hres;
    OVERLAPPED o;

    AssertF(phri == &this->hriOut);
    ZeroX(o);

    /*
     *  Annoying API:  Since this->hdev was opened
     *  as FILE_FLAG_OVERLAPPED, *all* I/O must be overlapped.
     *  So we simulate a synchronous I/O by issuing an
     *  overlapped I/O and waiting for the completion.
     */

    if(WriteFileEx(this->hdev, phri->pvReport,
                   phri->cbReport, &o, CHid_DummyCompletion))
    {
        do
        {
            SleepEx(INFINITE, TRUE);
        } while(!HasOverlappedIoCompleted(&o));

        if(phri->cbReport == o.InternalHigh)
        {
            hres = S_OK;
        } else
        {
            RPF("SendDeviceData: Wrong HID output report size?");
            hres = E_FAIL;      /* Aigh!  HID lied to me! */
        }
    } else
    {
        hres = hresLe(GetLastError());

        /* 
         *  Note, we have not broken the read loop so there is no need to 
         *  force the device unaquired (though dinput.dll does).
         *
         *  If this causes problems revert to the old behavior.
         *  CEm_ForceDeviceUnacquire(pemFromPvi(this->pvi)->ped, 0x0);
         */
    }

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | SendFeatureReport |
 *
 *          Actually send the report as an feature report.
 *
 *  @parm   PHIDREPORTINFO | phri |
 *
 *          The report being sent.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_SendFeatureReport(PCHID this, PHIDREPORTINFO phri)
{
    HRESULT hres;

    AssertF(phri == &this->hriFea);

    if(HidD_SetFeature(this->hdev, phri->pvReport, phri->cbReport))
    {
        hres = S_OK;
    } else
    {
        RPF("SendDeviceData: Unable to set HID feature");
        hres = hresLe(GetLastError());
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | SendDeviceData |
 *
 *          Spew some data to the device.
 *
 *  @parm   DWORD | cbdod |
 *
 *          Size of each object.
 *
 *  @parm   IN LPCDIDEVICEOBJECTDATA | rgdod |
 *
 *          Array of <t DIDEVICEOBJECTDATA> structures.
 *
 *  @parm   INOUT LPDWORD | pdwInOut |
 *
 *          On entry, number of items to send;
 *          on exit, number of items actually sent.
 *
 *  @parm   DWORD | fl |
 *
 *          Flags.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_REPORTFULL>: Too many items are set in the report.
 *                                (More than can be sent to the device)
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_SendDeviceData(PDICB pdcb, DWORD cbdod, LPCDIDEVICEOBJECTDATA rgdod,
                        LPDWORD pdwInOut, DWORD fl)
{
    HRESULT hres;
    PCHID this;
    DWORD dwIn, dw;
    const BYTE * pbcod;
    EnterProcI(IDirectInputDeviceCallback::Hid::SendDeviceData,
               (_ "xpux", cbdod, pdcb, *pdwInOut, fl));


    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    dwIn = *pdwInOut;
    *pdwInOut = 0;

    if(fl & DISDD_CONTINUE)
    {
    } else
    {
        CHid_ResetDeviceData(this, &this->hriOut, HidP_Output);
        CHid_ResetDeviceData(this, &this->hriFea, HidP_Feature);
    }

    for(dw = 0, pbcod = (const BYTE*)rgdod; dw < dwIn; dw++)
    {
        DWORD dwType = ((LPDIDEVICEOBJECTDATA)pbcod)->dwOfs;
        UINT uiObj = CHid_ObjFromType(this, dwType);

        if(uiObj < this->df.dwNumObjs &&
           DIDFT_FINDMATCH(this->df.rgodf[uiObj].dwType, dwType))
        {
            hres = CHid_AddDeviceData(this, uiObj, ((LPDIDEVICEOBJECTDATA)pbcod)->dwData);
            if(FAILED(hres))
            {
                *pdwInOut = dw;
                goto done;
            }
        } else
        {
            hres = E_INVALIDARG;
            goto done;
        }
        pbcod += cbdod;
    }

    /*
     *  All the items made it into the buffer.
     */
    *pdwInOut = dw;

    /*
     *  Now send it all out.
     */
    if(SUCCEEDED(hres = CHid_SendHIDReport(this, &this->hriOut, HidP_Output,
                                           CHid_SendOutputReport)) &&
       SUCCEEDED(hres = CHid_SendHIDReport(this, &this->hriFea, HidP_Feature,
                                           CHid_SendFeatureReport)))
    {
    }

    done:;
    ExitOleProcR();
    return hres;
}
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | Poll |
 *
 *          Read any polled input and features to see what's there.
 *
 *  @returns
 *
 *          <c S_OK> if we pinged okay.
 *          <c S_FALSE> doesn't require polling
 *          <c DIERR_UNPLUGGED> the device requires polling and is unplugged
 *          Other errors returned from HID are possible for a polled device.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_Poll(PDICB pdcb)
{
    //Prefix: 45082
    HRESULT hres = S_FALSE;  //We need use S_FALSE as default. See manbug 31874.
    PCHID this;
    EnterProcI(IDirectInputDeviceCallback::Hid::Poll, (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    if( this->IsPolledInput )
    {
        hres = DIERR_UNPLUGGED;
        if(ReadFileEx(this->hdev, this->hriIn.pvReport,
                      this->hriIn.cbReport, &this->o, CHid_DummyCompletion))
        {
            do
            {
                SleepEx( INFINITE, TRUE);
            } while(!HasOverlappedIoCompleted(&this->o));

            if(this->hriIn.cbReport == this->o.InternalHigh)
            {
                NTSTATUS stat;

                CopyMemory(this->pvStage, this->pvPhys, this->cbPhys);

                stat = CHid_ParseData(this, HidP_Input, &this->hriIn);

                if(SUCCEEDED(stat))
                {
                    CEm_AddState(&this->ed, this->pvStage, GetTickCount());                
                    this->pvi->fl &=  ~VIFL_UNPLUGGED;
                    hres = S_OK;
                } else
                {
                    RPF( "CHid_ParseData failed in Poll, status = 0x%08x", stat );
                    hres = stat;
                }
            }
        }

        if( FAILED(hres) )
        {
            /* 
             *  Note, we have not broken the read loop so there is no need to 
             *  force the device unaquired (though dinput.dll does).
             *
             *  If this causes problems revert to the old behavior.
             *  CEm_ForceDeviceUnacquire(pemFromPvi(this->pvi)->ped, 0x0);
             */
            hres = DIERR_UNPLUGGED;
            this->pvi->fl |= VIFL_UNPLUGGED;        
        }
    }


    if( this->hriFea.cbReport )
    {
        UINT uReport;
        /*
         *  We should never get here unless there really are any
         *  features that need to be polled.
         */
        AssertF(this->hriFea.cbReport);
        AssertF(this->hriFea.pvReport);

        /*
         *  Read the new features and parse/process them.
         *
         *  Notice that we read the features into the same buffer
         *  that we log them into.  That's okay; the "live" parts
         *  of the two buffers never actually overlap.
         */
        for( uReport = 0x0; uReport < this->wMaxReportId[HidP_Feature]; uReport++ )
        {
            if( *(this->pEnableReportId[HidP_Feature] + uReport ) == TRUE )
            {
                *((UCHAR*)(this->hriFea.pvReport)) = (UCHAR)uReport;

                /*
                 *  Wipe out all the old goo because we're taking over.
                 */
                CHid_ResetDeviceData(this, &this->hriFea, HidP_Feature);

                if(HidD_GetFeature(this->hdev, this->hriFea.pvReport,
                                   this->hriFea.cbReport))
                {
                    NTSTATUS stat;

                    stat = CHid_ParseData(this, HidP_Feature, &this->hriFea);

                    AssertF(SUCCEEDED(stat));
                    if(SUCCEEDED(stat))
                    {
                        CEm_AddState(&this->ed, this->pvStage, GetTickCount());                
                    }

                    hres = stat;

                } else
                {
                    RPF("CHid_Poll: Unable to read HID features (ReportID%d) LastError(0x%x)", uReport, GetLastError() );
                    hres = hresLe(GetLastError());

                }
            }
        }
    }

    ExitOleProcR();
    return hres;
}


/*****************************************************************************
 *
 *      CHid_New       (constructor)
 *
 *      Fail the create if we can't open the device.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_New(PUNK punkOuter, REFGUID rguid, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Hid::<constructor>,
               (_ "Gp", riid, ppvObj));

    hres = Common_NewRiid(CHid, punkOuter, riid, ppvObj);

    if(SUCCEEDED(hres))
    {
        /* Must use _thisPv in case of aggregation */
        PCHID this = _thisPv(*ppvObj);

        if(SUCCEEDED(hres = CHid_Init(this, rguid)))
        {
        } else
        {
            Invoke_Release(ppvObj);
        }

    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | SetDIData |
 *
 *          Set DirectInput version and apphack data from CDIDev *.
 *
 *  @parm   DWORD | dwVer |
 *
 *          DirectInput version
 *
 *  @parm   LPVOID | lpdihacks |
 *
 *          AppHack data
 *
 *  @returns
 *
 *          <c E_NOTIMPL> because we don't support usages.
 *
 *****************************************************************************/

STDMETHODIMP
CHid_SetDIData(PDICB pdcb, DWORD dwVer, LPVOID lpdihacks)
{
    HRESULT hres;
    PCHID this;
    EnterProcI(IDirectInputDeviceCallback::Hid::SetDIData,
               (_ "pup", pdcb, dwVer, lpdihacks));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    this->dwVersion = dwVer;
    CopyMemory(&this->diHacks, (LPDIAPPHACKS)lpdihacks, sizeof(this->diHacks));

    hres = S_OK;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | BuildDefaultActionMap |
 *
 *          Generate default mappings for the objects on this device.
 *
 *  @parm   LPDIACTIONFORMATW | pActionFormat |
 *
 *          Actions to map.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags used to indicate mapping preferences.
 *
 *  @parm   REFGUID | guidInst | 
 *
 *          Device instance GUID.
 *
 *  @returns
 *
 *          <c E_NOTIMPL> 
 *
 *****************************************************************************/

STDMETHODIMP
CHid_BuildDefaultActionMap
(
    PDICB               pdcb, 
    LPDIACTIONFORMATW   paf, 
    DWORD               dwFlags, 
    REFGUID             guidInst
)
{
    HRESULT hres;
    PCHID   this;
    DWORD   dwPhysicalGenre;

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    EnterProcI(IDirectInputDeviceCallback::Hid::BuildDefaultActionMap, 
        (_ "ppxG", pdcb, paf, dwFlags, guidInst));

    this = _thisPvNm(pdcb, dcb);

    switch( GET_DIDEVICE_TYPE( this->dwDevType ) )
    {
    case DI8DEVTYPE_DEVICE:
        hres = S_FALSE;
        goto ExitBuildDefaultActionMap;
    case DI8DEVTYPE_MOUSE:
        dwPhysicalGenre = DIPHYSICAL_MOUSE;
        break;
    case DI8DEVTYPE_KEYBOARD:
        dwPhysicalGenre = DIPHYSICAL_KEYBOARD;
        break;
    default:
        dwPhysicalGenre = 0;
        break;
    }

    if( dwPhysicalGenre  )
    {
        hres = CMap_BuildDefaultSysActionMap( paf, dwFlags, dwPhysicalGenre, 
            guidInst, &this->df, 0 /* HID mice buttons start at instance zero */ );
    }
    else
    {
        PDIDOBJDEFSEM       rgObjSem;

        if( SUCCEEDED( hres = AllocCbPpv(cbCxX( 
            (this->dwAxes + this->dwPOVs + this->dwButtons ), DIDOBJDEFSEM),
            &rgObjSem) ) )
        {
            PDIDOBJDEFSEM   pAxis;
            PDIDOBJDEFSEM   pPOV;
            PDIDOBJDEFSEM   pButton;
            BYTE            rgbIndex[DISEM_FLAGS_GET(DISEM_FLAGS_S)];
            UINT            ObjIdx;
            
            pAxis = rgObjSem;
            pPOV = &pAxis[this->dwAxes];
            pButton = &pPOV[this->dwPOVs];
            ZeroMemory( rgbIndex, cbX(rgbIndex) );

            for( ObjIdx = 0; ObjIdx < this->df.dwNumObjs; ObjIdx++ )
            {
                if( this->df.rgodf[ObjIdx].dwType & DIDFT_NODATA )
                {
                    continue;
                }

                if( this->df.rgodf[ObjIdx].dwType & DIDFT_AXIS ) 
                {
                    PHIDGROUPCAPS   pcaps;

                    pcaps = this->rghoc[ObjIdx].pcaps;
                    
                    pAxis->dwID = this->df.rgodf[ObjIdx].dwType;
                    if( this->rgbaxissemflags[DIDFT_GETINSTANCE( pAxis->dwID )] )
                    {
                        pAxis->dwSemantic = DISEM_TYPE_AXIS | DISEM_FLAGS_SET ( this->rgbaxissemflags[DIDFT_GETINSTANCE( pAxis->dwID )] );

                        /*
                         *  The index is zero so that a real index can be ORed in.
                         *  Also, assert that the rgbIndex is big enough and 
                         *  that subtracting 1 won't give a negative index!
                         */
                        AssertF( DISEM_INDEX_GET(pAxis->dwSemantic) == 0 );
                        AssertF( DISEM_FLAGS_GET(pAxis->dwSemantic) > 0 );
                        AssertF( DISEM_FLAGS_GET(pAxis->dwSemantic) <= DISEM_FLAGS_GET(DISEM_FLAGS_S) );
                    
                        CAssertF( DISEM_FLAGS_GET(DISEM_FLAGS_X) == 1 );
                        pAxis->dwSemantic |= DISEM_INDEX_SET( rgbIndex[DISEM_FLAGS_GET(pAxis->dwSemantic)-1]++ );
                    }
                    else
                    {
                        /*
                         *  If the axis has no semantic flags, it is 
                         *  unrecognized so short cut the above to produce 
                         *  a plain axis that can be matched only with "ANY".
                         */
                        pAxis->dwSemantic = DISEM_TYPE_AXIS;
                    }

                    if( !pcaps->IsAbsolute )
                    {
                        pAxis->dwSemantic |= DIAXIS_RELATIVE;
                    }

                    pAxis++;
                }
                else if( this->df.rgodf[ObjIdx].dwType & DIDFT_POV ) 
                {
                    pPOV->dwID = this->df.rgodf[ObjIdx].dwType;
                    pPOV->dwSemantic = DISEM_TYPE_POV;
                    pPOV++;
                }
                else if( this->df.rgodf[ObjIdx].dwType & DIDFT_BUTTON ) 
                {
                    pButton->dwID = this->df.rgodf[ObjIdx].dwType;
                    pButton->dwSemantic = DISEM_TYPE_BUTTON;
                    pButton++;
                }
            }

            AssertF( pAxis == &rgObjSem[this->dwAxes] );
            AssertF( pPOV == &rgObjSem[this->dwAxes + this->dwPOVs] );
            AssertF( pButton == &rgObjSem[this->dwAxes + this->dwPOVs + this->dwButtons] );

            hres = CMap_BuildDefaultDevActionMap( paf, dwFlags, guidInst, rgObjSem, 
                this->dwAxes, this->dwPOVs, this->dwButtons );

            FreePv( rgObjSem );
        }
    }

ExitBuildDefaultActionMap:;

    ExitOleProcR();
    return hres;
}


/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

    #pragma BEGIN_CONST_DATA

    #define CHid_Signature          0x20444948      /* "HID " */

Primary_Interface_Begin(CHid, IDirectInputDeviceCallback)
CHid_GetInstance,
CDefDcb_GetVersions,
CHid_GetDataFormat,
CHid_GetObjectInfo,
CHid_GetCapabilities,
CHid_Acquire,
CHid_Unacquire,
CHid_GetDeviceState,
CHid_GetDeviceInfo,
CHid_GetProperty,
CHid_SetProperty,
CDefDcb_SetEventNotification,
    #ifdef WINNT
    CHid_SetCooperativeLevel,
    #else
    CDefDcb_SetCooperativeLevel,
    #endif
CHid_RunControlPanel,
CDefDcb_CookDeviceData,
CHid_CreateEffect,
CHid_GetFFConfigKey,
CHid_SendDeviceData,
CHid_Poll,
CHid_GetUsage,
CHid_MapUsage,
CHid_SetDIData,
CHid_BuildDefaultActionMap,
Primary_Interface_End(CHid, IDirectInputDeviceCallback)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dihidini.c ===
/*****************************************************************************
 *
 *  DIHidIni.c
 *
 *  Copyright (c) 1996 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      The initialization-related functions of the HID device callback.
 *
 *      All the HID support is getting kind of bulky, so I've broken
 *      it out into submodules.
 *
 *  Contents:
 *
 *      CHid_Init
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflHidIni


/*****************************************************************************
 *
 *      Hid devices are totally arbitrary, so there is nothing static we
 *      can cook up to describe them.  We generate all the information on
 *      the fly.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   UINT | CHid_LoadCalibrations |
 *
 *          Load calibration information from the registry (or wherever).
 *          This is done when the device is created, and whenever we
 *          receive a recalibration message.
 *
 *  @returns
 *
 *          Returns the number of axes we calibrated.  This information
 *          is used during device initialization to see if we need to
 *          worry about calibration in the future.
 *
 *****************************************************************************/

UINT EXTERNAL
    CHid_LoadCalibrations(PCHID this)
{
    UINT uiObj;
    UINT uiRc = 0;

    /*
     *  Preinitialize the HIDP_DATA indices to -1 to indicate
     *  that they aren't there.  We must do this before we
     *  mess with AddDeviceData, which assumes that all the
     *  indices are properly set up.
     */
    for(uiObj = 0; uiObj < this->df.dwNumObjs; uiObj++)
    {
        PJOYRANGECONVERT pjrc = this->rghoc[uiObj].pjrc;
        PHIDGROUPCAPS pcaps = this->rghoc[uiObj].pcaps;
        if(pjrc && pcaps)
        {
            LPDIOBJECTDATAFORMAT podf = &this->df.rgodf[uiObj];
            DIOBJECTCALIBRATION cal;
          #ifdef WINNT
            DIPOVCALIBRATION pov;
          #endif
            D(LPCTSTR ptszWhence;)

            /*
             *  Note, we do not have to deal with mice on Win2k, yet...
             */
          #ifdef WINNT
            HRESULT hres;
            HKEY hk;

            D( ptszWhence = TEXT("unknown") );
            
            if( podf->dwType & DIDFT_POV ) 
            {
                if( pcaps->IsPolledPOV )  {
                    ZeroX( pov );
                    hres = CType_OpenIdSubkey(this->hkInstType, podf->dwType,
                                              KEY_QUERY_VALUE, &hk);
                    if(SUCCEEDED(hres))
                    {
                        hres = JoyReg_GetValue(hk, TEXT("Calibration"),
                                               REG_BINARY, &pov,
                                               cbX(DIPOVCALIBRATION));
                        RegCloseKey(hk);
                    }
                }
            } else
            {
                ZeroX( cal );
    
                hres = CType_OpenIdSubkey(this->hkInstType, podf->dwType,
                                          KEY_QUERY_VALUE, &hk);
    
                if(SUCCEEDED(hres))
                {
                    hres = JoyReg_GetValue(hk, TEXT("Calibration"),
                                           REG_BINARY, &cal,
                                           cbX(DIOBJECTCALIBRATION));
                    RegCloseKey(hk);
                }
    
                /*
                 *  If there is no calibration data, then create
                 *  some defaults based on the logical min/max.
                 */
                if(FAILED(hres))
                {
                    /*
                     *  But only if the logical min/max is sane!
                     */
                    if(pcaps->Logical.Min < pcaps->Logical.Max)
                    {
                        cal.lMin = pcaps->Logical.Min;
                        /*
                         *  HACKHACK
                         *  The analog joystick driver cannot report the true 
                         *  range of the device, so to keep the sample driver 
                         *  pure, it reports a range of zero to the point at 
                         *  which it would consider the axis absent.  This is
                         *  good in terms of reporting healthy HID data but 
                         *  it means that any normal joystick will only return 
                         *  values in a fraction of this range.  So if this 
                         *  device is an analog device default the calibration 
                         *  to the typical range.
                         */
                        if( ( this->VendorID == MSFT_SYSTEM_VID )
                          &&( ( this->ProductID & 0xff00 ) == MSFT_SYSTEM_PID ) )
                        {
                            /*
                             *  To be extra safe, compute the max from the 
                             *  reported range.  The divisor is a fudge factor 
                             *  derived by what looked about right to MarcAnd.
                             */
                            cal.lMax = pcaps->Logical.Min + 
                                ( ( pcaps->Logical.Max - pcaps->Logical.Min ) / 11 );
                            D(ptszWhence = TEXT("log (adj)"));
                        }
                        else
                        {
                            cal.lMax = pcaps->Logical.Max;
                            D(ptszWhence = TEXT("log"));
                        }
                    } else
                    {
                        D(ptszWhence = TEXT("def"));
                        cal.lMin = 0;
                        cal.lMax = 655;
                    }
                    cal.lCenter = CCal_Midpoint(cal.lMin, cal.lMax);
                } else
                {
                    D(ptszWhence = TEXT("reg"));
                }
            }

          #else
            if( GET_DIDEVICE_TYPE(this->dwDevType) == DI8DEVTYPE_MOUSE )
            {
                if( this->df.rgodf[uiObj].dwType & DIDFT_ABSAXIS )
                {
                    if(pcaps->Logical.Min < pcaps->Logical.Max)
                    {
                        cal.lMin = pcaps->Logical.Min;
                        cal.lMax = pcaps->Logical.Max;
                        D(ptszWhence = TEXT("mouse log"));
                    }
                    else
                    {
                        /* 
                         *  Absolute mice traditionally report 0 - 64K 
                         */
                        cal.lMin = 0;
                        cal.lMax = 65535;   
                        D(ptszWhence = TEXT("mouse def"));
                    }
                    cal.lCenter = CCal_Midpoint(cal.lMin, cal.lMax);
                }
                else
                {
                    /*
                     *  Relative mouse axis, just zero to keep sane
                     */
                    ZeroX( cal );
                }
            } else if ( this->idJoy < 0 ) //See manbug 50591
            {
                HRESULT hres;
                HKEY hk;
                
                ZeroX( cal );
    
                hres = CType_OpenIdSubkey(this->hkInstType, podf->dwType,
                                          KEY_QUERY_VALUE, &hk);
    
                if(SUCCEEDED(hres))
                {
                    hres = JoyReg_GetValue(hk, TEXT("Calibration"),
                                           REG_BINARY, &cal,
                                           cbX(DIOBJECTCALIBRATION));
                    RegCloseKey(hk);
                } else {
                    /*
                     *  But only if the logical min/max is sane!
                     */
                    if(pcaps->Logical.Min < pcaps->Logical.Max)
                    {
                        cal.lMin = pcaps->Logical.Min;
                        cal.lMax = pcaps->Logical.Max;
                    } else
                    {
                        cal.lMin = 0;
                        cal.lMax = 655; //best guess
                    }

                    cal.lCenter = CCal_Midpoint(cal.lMin, cal.lMax);
                }

				D(ptszWhence = TEXT("non-gamecontroller"));
            } else
            {
                ZeroX( cal );
    
                /*
                 * Because the CPL on Win9x only updates calibration in MediaResources,
                 * We need read that calibration information and update for HID.
                 */
                CHid_UpdateCalibrationFromVjoyd(this, uiObj, &cal);

                D(ptszWhence = TEXT("WinMM Reg"));
            }
          #endif

          #ifdef WINNT
            if( podf->dwType & DIDFT_POV )
            {
                if( pcaps->IsPolledPOV )  {
                    memcpy( pjrc->lMinPOV, pov.lMin, cbX(pjrc->lMinPOV) );
                    memcpy( pjrc->lMaxPOV, pov.lMax, cbX(pjrc->lMaxPOV) );
                }
            } else 
          #endif
            {
                D(SquirtSqflPtszV(sqflHidParse,
                                  TEXT(" Calibration(%d) %s %d..%d..%d"),
                                  CHid_ObjFromType(this, podf->dwType), ptszWhence,
                                  cal.lMin, cal.lCenter, cal.lMax));
    
                /*
                 *  Saturation always defaults to 100%.
                 */
                pjrc->dwPmin = cal.lMin;
                pjrc->dwPmax = cal.lMax;
                pjrc->dwPc   = cal.lCenter;
    
                if( pjrc->dwCPointsNum == 0 ) {
                    //use two control points by default
                    pjrc->dwCPointsNum = 2;
                    pjrc->cp[0].lP = pjrc->dwPmin;
                    pjrc->cp[0].dwLog = 0;
                    pjrc->cp[1].lP = pjrc->dwPmax;
                    pjrc->cp[1].dwLog = RANGEDIVISIONS;
                } else {
                    pjrc->cp[0].lP = pjrc->dwPmin;
                    pjrc->cp[pjrc->dwCPointsNum-1].lP = pjrc->dwPmax;
                }
            
                CCal_RecalcRange(pjrc);
    
                uiRc++;
            }
        }
    }

    return uiRc;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CHid_SortCaps |
 *
 *          Sort the capabilities by Data Index.  This is important
 *          so that the items are assigned numbers in the same order
 *          by both DirectInput and HID.
 *
 *          Note that we exploit the not-exactly-a-coincidence
 *          that a <t HIDP_VALUE_CAPS> and a
 *          <t HIDP_BUTTON_CAPS> are identical wherever they overlap.
 *
 *  @parm   PV | rgv |
 *
 *          Array of either <t HIDP_VALUE_CAPS> or <t HIDP_BUTTON_CAPS>
 *          structures.
 *
 *  @parm   UINT | cv |
 *
 *          Number of structures that need to be sorted.
 *
 *****************************************************************************/

void INTERNAL
    CHid_SortCaps(PV rgv, UINT cv)
{
    /*
     *  For concreteness, we use HIDP_VALUE_CAPS.
     */
    PHIDP_VALUE_CAPS rgvcaps = rgv;
    UINT ivcaps;

    /*
     *  There are several non-coincidences which we exploit.
     *
     *  HIDP_VALUE_CAPS and HIDP_BUTTON_CAPS are the same size.
     *
     *  HIDP_VALUE_CAPS.Range.DataIndexMin,
     *  HIDP_VALUE_CAPS.NotRange.DataIndex,
     *  HIDP_BUTTON_CAPS.Range.DataIndexMin, and
     *  HIDP_BUTTON_CAPS.NotRange.DataIndex are all at the same offset.
     */
    CAssertF(cbX(HIDP_VALUE_CAPS) == cbX(HIDP_BUTTON_CAPS));

    /*
     *  For some reason, the compiler doesn't think that these
     *  expressions are constant so I can't use CAssertF.
     */
    AssertF(FIELD_OFFSET(HIDP_VALUE_CAPS,  NotRange.DataIndex) ==
            FIELD_OFFSET(HIDP_VALUE_CAPS,     Range.DataIndexMin));
    AssertF(FIELD_OFFSET(HIDP_VALUE_CAPS,     Range.DataIndexMin) ==
            FIELD_OFFSET(HIDP_BUTTON_CAPS,    Range.DataIndexMin));
    AssertF(FIELD_OFFSET(HIDP_BUTTON_CAPS,    Range.DataIndexMin) ==
            FIELD_OFFSET(HIDP_BUTTON_CAPS, NotRange.DataIndex));

    #ifdef REALLY_ANNOYING
    /*
     *  Dump the Before list.
     */
    for(ivcaps = 0; ivcaps < cv; ivcaps++)
    {
        SquirtSqflPtszV(sqflHidParse,
                        TEXT("HidP_SortCaps:%2d = %04x"),
                        ivcaps, rgvcaps[ivcaps].Range.DataIndexMin);
    }
    #endif

    /*
     *  Since there are typically not very many caps, we will use
     *  a simple insertion sort.
     *
     *  Note if caps entries have the same data index they are 
     *  aliases.  Make sure the primary alias will be the first
     *  in the sorted list.
     */

    for(ivcaps = 1; ivcaps < cv; ivcaps++)
    {
        int ivcapsT;
        HIDP_VALUE_CAPS vcaps = rgvcaps[ivcaps];

        ivcapsT = ivcaps;
        while( ( --ivcapsT >= 0 )
             &&( ( rgvcaps[ivcapsT].Range.DataIndexMin >
                   vcaps.Range.DataIndexMin )
               ||( ( rgvcaps[ivcapsT].Range.DataIndexMin ==
                     vcaps.Range.DataIndexMin )
                 &&( rgvcaps[ivcapsT].IsAlias ) ) ) )
        {
            rgvcaps[ivcapsT+1] = rgvcaps[ivcapsT];
        }
        rgvcaps[ivcapsT+1] = vcaps;
    }

    #ifdef REALLY_ANNOYING
    /*
     *  Dump the After list.
     */
    for(ivcaps = 0; ivcaps < cv; ivcaps++)
    {
        SquirtSqflPtszV(sqflHidParse,
                        TEXT("HidP_SortCaps:%2d = %04x"),
                        ivcaps, rgvcaps[ivcaps].Range.DataIndexMin);
    }
    #endif

    /*
     *  Assert that everything is weakly monotonically sorted.
     *
     *  If two items are equal, then it means that HID messed up 
     *  or the values are aliases.
     *  We don't complain about it here; we will notice later.
     */
    for(ivcaps = 1; ivcaps < cv; ivcaps++)
    {
        AssertF(rgvcaps[ivcaps-1].Range.DataIndexMin <=
                rgvcaps[ivcaps  ].Range.DataIndexMin);
    }
}



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | CHid_FindAspect |
 *
 *          Try to determine the aspect flags for this value.
 *
 *  @parm   PHIDP_VALUE_CAPS | pvcaps |
 *
 *          Pointer to HID value caps to search through
 *          structures.
 *
 *  @returns
 *
 *          Flags set for the aspect if found
 *
 *  @comm
 *          Currently (08-Dec-98) most devices and drivers do not 
 *          declare units but since drivers must use the generic 
 *          position usages in order to be recognized assume that 
 *          these imply that position data is being returned.
 *
 *****************************************************************************/
DWORD CHID_FindAspect
(
    PHIDP_VALUE_CAPS    pvcaps
)
{
    DWORD               dwAspect = 0;

    if( pvcaps->Units )
    {
#define HID_UNIT_SYSTEM_MASK        0x0000000fL
#define HID_UNIT_LENGTH_MASK        0x000000f0L
#define HID_UNIT_MASS_MASK          0x00000f00L
#define HID_UNIT_TIME_MASK          0x0000f000L
        /*
         *  If available, use the units to derive the DI aspect 
         *  flags for input objects.
         */

        if( pvcaps->Units & ~( HID_UNIT_SYSTEM_MASK 
                             | HID_UNIT_LENGTH_MASK 
                             | HID_UNIT_MASS_MASK 
                             | HID_UNIT_TIME_MASK ) )
        {
            SquirtSqflPtszV(sqflTrace | sqflHidParse,
                            TEXT("Unit 0x%08x contains basic units that cannot be translated to aspects"),
                            pvcaps->Units );
        }
        else
        {
            /*
             *  The system of measurement should be one of the 
             *  four defined systems and the length must be one 
             *  dimensional.
             */
            if( ( ( pvcaps->Units & ( HID_UNIT_SYSTEM_MASK | HID_UNIT_LENGTH_MASK ) ) >= 0x11 )
              &&( ( pvcaps->Units & ( HID_UNIT_SYSTEM_MASK | HID_UNIT_LENGTH_MASK ) ) <= 0x14 ) )
            {
                switch( pvcaps->Units & ( HID_UNIT_TIME_MASK | HID_UNIT_MASS_MASK ) )
                {
                case 0x0000:
                    dwAspect = DIDOI_ASPECTPOSITION;
                    break;
                case 0xf000:
                    dwAspect = DIDOI_ASPECTVELOCITY;
                    break;
                case 0xe000:
                    dwAspect = DIDOI_ASPECTACCEL;
                    break;
                case 0xe100:
                    dwAspect = DIDOI_ASPECTFORCE;
                    break;
                default:
                    if( 0x0004 == ( pvcaps->Units & ( HID_UNIT_TIME_MASK | HID_UNIT_MASS_MASK | HID_UNIT_SYSTEM_MASK ) ) )
                    {
                        SquirtSqflPtszV(sqflTrace | sqflHidParse,
                            TEXT("Unit \"degrees\" will not be mapped to a DI aspect (probably a POV)") );
                    }
                    else
                    {
                        SquirtSqflPtszV(sqflTrace | sqflHidParse,
                                        TEXT("Unit 0x%04x represents a mass/time unit that cannot be translated to aspects"),
                                        pvcaps->Units );
                    }
                }
            }
            else
            {
                SquirtSqflPtszV(sqflTrace | sqflHidParse,
                                TEXT("Unit 0x%04x contains represents a length/system unit that cannot be translated to aspects"),
                                pvcaps->Units );                                
            }
        }

#ifdef DEBUG
        if( dwAspect )
        {
            SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                            TEXT("Unit 0x%04x translated to aspect 0x%04x"), 
                            pvcaps->Units, dwAspect );
        }
#endif

#undef HID_UNIT_SYSTEM_MASK
#undef HID_UNIT_LENGTH_MASK
#undef HID_UNIT_MASS_MASK
#undef HID_UNIT_TIME_MASK

    }
    else
    {
        PHIDUSAGEMAP phum;

        phum = UsageToUsageMap( DIMAKEUSAGEDWORD( pvcaps->UsagePage,
                                                     pvcaps->Range.UsageMin ) );

        if( phum && phum->bPosAxis <= 6 )
        {
            phum = UsageToUsageMap( DIMAKEUSAGEDWORD( pvcaps->UsagePage,
                                                         pvcaps->Range.UsageMax ) );

            if( phum && phum->bPosAxis <= 6 )
            {
                dwAspect = DIDOI_ASPECTPOSITION;
            }
        }
        else
        {
            SquirtSqflPtszV(sqflTrace | sqflHidParse,
                            TEXT("No aspect found for 0x%04x page usage 0x%04x-0x%04x"),
                            pvcaps->UsagePage, pvcaps->Range.UsageMin, pvcaps->Range.UsageMax );                                
        }        

#ifdef DEBUG
        if( dwAspect )
        {
            SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                            TEXT("Usage (page:min-max) 0x%04x:0x%04x-0x%04x translated to aspect 0x%04x"), 
                            pvcaps->UsagePage, pvcaps->Range.UsageMin, pvcaps->Range.UsageMax, dwAspect );
        }
#endif

    }

    return dwAspect;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | InitAxisClass |
 *
 *          Initialize one class (input, feature, output) of axes.
 *
 *  @parm   PHIDGROUPCAPS | rgcaps |
 *
 *          Array of <t HIDGROUPCAPS> structures to receive the caps
 *          of the axes in the class.
 *
 *  @parm   USHORT | ccaps |
 *
 *          Number of <t HIDGROUPCAPS> structures we expect to find.
 *
 *  @parm   HIDP_REPORT_TYPE | type |
 *
 *          One of the values
 *          <c HidP_Input>,
 *          <c HidP_Feature> or
 *          <c HidP_Output>.
 *
 *****************************************************************************/

HRESULT INTERNAL
    CHid_InitAxisClass(PCHID this, PHIDGROUPCAPS rgcaps, USHORT ccaps,
                       HIDP_REPORT_TYPE type)
{
    USHORT cvcaps;
    NTSTATUS stat;
    HRESULT hres;
    DWORD ivcaps;
    LONG lSignedMask;
    PHIDP_VALUE_CAPS rgvcaps;

    AssertF(rgcaps >= this->rgcaps);
    AssertF(rgcaps + ccaps <= &this->rgcaps[this->ccaps]);

    /*
     *  Annoying quirk:
     *
     *  HID doesn't like it when you pass 0 to HidP_GetValueCaps,
     *  so we need to special-case the "no axes" scenario.
     */
    if(ccaps == 0)
    {
        hres = S_OK;
        goto done;
    }

    hres = AllocCbPpv(cbCxX(ccaps, HIDP_VALUE_CAPS), &rgvcaps);
    if(FAILED(hres))
    {
        goto done;
    }

    cvcaps = ccaps;
    stat = HidP_GetValueCaps(type, rgvcaps, &cvcaps, this->ppd);
    if(FAILED(stat))
    {
        RPF("HidP_GetValueCaps failed - can't use device");
        hres = E_FAIL;
        goto freedone;
    }

    if(cvcaps != ccaps)
    {
        RPF("HidP_GetValueCaps inconsistent with HidP_GetCaps - "
            "can't use device");
        hres = E_FAIL;
        goto freedone;
    }

    CHid_SortCaps(rgvcaps, cvcaps);

    for(ivcaps = 0; ivcaps < cvcaps; ivcaps++)
    {
        PHIDP_VALUE_CAPS pvcaps = &rgvcaps[ivcaps];
        PHIDGROUPCAPS pcaps = &rgcaps[ivcaps];
        BOOL fPOV;
        UINT uiObj;
        UINT duiObj;
        DWORD dwAspect;

        /*
         *  ISSUE-2001/03/06-MarcAnd Ignoring report count
         *  We ignore the report count which may be bad, need 
         *  to test device with values declared in a range to see what HID 
         *  really gives us.
         *  At the descriptor level, values can be delared in a range with 
         *  usages and the last usage is repeated for any excess values.  
         */
        if(pvcaps->IsRange)
        {
            if(pvcaps->Range.DataIndexMax - pvcaps->Range.DataIndexMin !=
               pvcaps->Range.UsageMax - pvcaps->Range.UsageMin)
            {
                RPF("HidP_GetValueCaps corrupted VALUE_CAPS - "
                    "can't use device");
                hres = E_FAIL;
                goto freedone;
            }

        } else
        {
            pvcaps->Range.UsageMax = pvcaps->Range.UsageMin;
        }

        if( ( type == HidP_Input ) && !pvcaps->IsAlias )
        {
            /*
             *  The values are sorted by data index with the primary alias 
             *  before any other.  So find out the aspect of the axis each 
             *  time we get a new primary and use it for any alias that follow.
             */
            dwAspect = CHID_FindAspect( pvcaps );
        }

        pcaps->wReportId          = pvcaps->ReportID;
        this->wMaxReportId[type]  = max(pcaps->wReportId, this->wMaxReportId[type]);

        pcaps->UsagePage          = pvcaps->UsagePage;
        pcaps->UsageMin           = pvcaps->Range.UsageMin;
        pcaps->DataIndexMin       = pvcaps->Range.DataIndexMin;

        pcaps->cObj               = pvcaps->Range.UsageMax -
                                    pvcaps->Range.UsageMin + 1;

        /*
         *  The mask consists of the top bit of the BitSize and          
         *  all bits above it.  Examples:
         *
         *           BitSize                     8              32  
         *           BitSize - 1                 7              31
         *     1 << (BitSize - 1)       0x00000080      0x80000000
         *    (1 << (BitSize - 1)) - 1  0x0000007F      0x7FFFFFFF
         *  ~((1 << (BitSize - 1)) - 1) 0xFFFFFF80      0x80000000
         *
         */

        pcaps->BitSize            = pvcaps->BitSize;
        pcaps->lMask              = ~((1 << (pcaps->BitSize - 1)) - 1);
        lSignedMask               =  max( 1, ( 1 << pcaps->BitSize) -1 );

        pcaps->LinkCollection     = pvcaps->LinkCollection;
        pcaps->Units              = pvcaps->Units;
        pcaps->Exponent           = LOWORD(pvcaps->UnitsExp);

        pcaps->Logical.Min        = pvcaps->LogicalMin;
        pcaps->Logical.Max        = pvcaps->LogicalMax;

        pcaps->Physical.Min       = pvcaps->PhysicalMin;
        pcaps->Physical.Max       = pvcaps->PhysicalMax;

        if(pcaps->Logical.Min >= pcaps->Logical.Max)
        {
            RPF("HidP_GetValueCaps Logical Min >= Logical Max - ");

            if( pcaps->Physical.Min < pcaps->Physical.Max )
            {
                pcaps->Logical = pcaps->Physical;
            } else
            {
                pcaps->Logical.Min = pcaps->lMask;
                pcaps->Logical.Max = ~pcaps->lMask;
            }

            SquirtSqflPtszV(sqflHidParse | sqflVerbose,
                            TEXT("HidP_GetValueCaps:")
                            TEXT("Logical Min(was:%d now:%d)")
                            TEXT("Logical Max(was:%d now:%d)"),
                            pvcaps->LogicalMin, pcaps->Logical.Min,
                            pvcaps->LogicalMax, pcaps->Logical.Max);

        }

        /*
         *  the range for LogicalMin / LogicalMax had better fall
         *  within the range of values the device can possibly
         *  report.
         *
         *  The lMask value happens also to be the smallest possible
         *  negative value, and the bitwise negation of it happens
         *  to be the largest possible positive value.  The wonders
         *  of two-s complement arithmetic.
         */

        /* 
         *  Extra case is fix for 268519
         */
        if(pcaps->Physical.Min > pcaps->Physical.Max)
        {
            RPF("HidP_GetValueCaps Physical Min/Max(%d/%d) is bad setting all to zero to %d"
                "device may have bad firmware", pcaps->Physical.Min, pcaps->Physical.Max, lSignedMask);
            
            pcaps->Logical.Min = 0;
            pcaps->Physical.Min = 0;
            pcaps->Logical.Max = lSignedMask;
            pcaps->Physical.Max = lSignedMask;
            pcaps->lMask = lSignedMask; 
            pcaps->IsSigned = FALSE;
        }
        else
        {
            if(pcaps->Physical.Min == pcaps->Physical.Max)
            {
                pcaps->Physical = pcaps->Logical;
            }

            if(pcaps->Logical.Min >=  pcaps->lMask &&     // Logical Min / Max are signed
               pcaps->Logical.Max <= ~pcaps->lMask)
            {
                pcaps->IsSigned = TRUE; 

            } else if(pcaps->Logical.Min >= 0 && 
                      pcaps->Logical.Max <= lSignedMask  )
            {                                              // Logical Min / Max are unsigned
                pcaps->lMask = lSignedMask; 
                pcaps->IsSigned = FALSE;

            } else if (pcaps->UsagePage >= HID_USAGE_PAGE_VENDOR )
            {
                // Let this one pass, hopefully the broken descriptors are for
                // usages that are vendor specific and will not effect too many folks
                RPF("HidP_GetValueCaps Logical Min/Max(%d/%d) don't fit in BitSize(%d) - "
                    "device may have bad firmware", pcaps->Logical.Min, pcaps->Logical.Max, pcaps->BitSize);

                pcaps->Logical.Min = pcaps->lMask;
                pcaps->Logical.Max = ~pcaps->lMask;
                pcaps->IsSigned = TRUE;            

            }else
            {
                RPF("HidP_GetValueCaps UsagePage(0x%x)Usage(0x%x) Logical Min/Max(%d/%d) don't fit in BitSize(%d) - "
                    "can't use device", pcaps->UsagePage, pcaps->UsageMin, pcaps->Logical.Min, pcaps->Logical.Max, pcaps->BitSize);
                hres = E_FAIL;
                goto freedone;
            }
        }

        AssertF(pcaps->Physical.Min < pcaps->Physical.Max);

        pcaps->StringMin          = pvcaps->Range.StringMin;
        pcaps->StringMax          = pvcaps->IsStringRange ?
                                    pvcaps->Range.StringMax :
                                    pvcaps->Range.StringMin;

        pcaps->DesignatorMin      = pvcaps->Range.DesignatorMin;
        pcaps->DesignatorMax      = pvcaps->IsDesignatorRange ?
                                    pvcaps->Range.DesignatorMax :
                                    pvcaps->Range.DesignatorMin;

        pcaps->IsAbsolute         = pvcaps->IsAbsolute;
        pcaps->IsValue            = TRUE;
        pcaps->IsAlias            = pvcaps->IsAlias;
        pcaps->type               = type;

        /*
         *  HID reports axes and POVs as the same thing, and the two 
         *  POV usages we recognize are in different pages, so you 
         *  will never get multiple POVs coming through in a single 
         *  value-caps.
         *
         *  ISSUE-2001/03/06-MarcAnd POVs within caps are treated as axes
         *  There is, however, the problem of a POV buried inside
         *  a larger value-cap that describes axes.  Tough.  Those
         *  POVs are in trouble.
         */

#define HID_USAGE_GAME_POV                          ((USAGE) 0x20)

        fPOV = pcaps->cObj == 1 
                           && ( ( pcaps->UsagePage == HID_USAGE_PAGE_GENERIC 
                                &&pcaps->UsageMin == HID_USAGE_GENERIC_HATSWITCH )
                              ||( pcaps->UsagePage == HID_USAGE_PAGE_GAME 
                                &&pcaps->UsageMin == HID_USAGE_GAME_POV ) );


        if(fPOV)
        {
            LONG lUnits;

            /*
             *  POVs are assumed to start at north and increase
             *  clockwise through the logical maximum.
             */
            lUnits = pcaps->Logical.Max - pcaps->Logical.Min + 1;
            if(lUnits)
            {
                pcaps->usGranularity = (USHORT)(36000U / lUnits);
            }
        } else
        {
            if( ( pcaps->UsagePage == HID_USAGE_PAGE_GENERIC &&
                  pcaps->UsageMin <= HID_USAGE_GENERIC_HATSWITCH &&
                  pvcaps->Range.UsageMax >= HID_USAGE_GENERIC_HATSWITCH )
              ||( pcaps->UsagePage == HID_USAGE_PAGE_GAME &&
                  pcaps->UsageMin <= HID_USAGE_GAME_POV &&
                  pvcaps->Range.UsageMax >= HID_USAGE_GAME_POV ) )
            {
                SquirtSqflPtszV(sqflHidParse | sqflError,
                                TEXT("HidP_GetValueCaps - multi-usage cap ")
                                TEXT("includes hatswitch or POV - will be treated")
                                TEXT("as axis"));
            }
        }

#undef HID_USAGE_GAME_POV

        SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                        TEXT("HidP_GetValueCaps(%d)[%d]: Objs = %d"),
                        type, ivcaps, pcaps->cObj);
        SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                        TEXT("HidP_GetValueCaps(%d)[%d]: Index %d ..."),
                        type, ivcaps,
                        pcaps->DataIndexMin);
        SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                        TEXT("HidP_GetValueCaps(%d)[%d]: Logical = %d..%d"),
                        type, ivcaps,
                        pcaps->Logical.Min, pcaps->Logical.Max);
        SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                        TEXT("HidP_GetValueCaps(%d)[%d]: Physical = %d..%d"),
                        type, ivcaps,
                        pcaps->Physical.Min, pcaps->Physical.Max);
        SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                        TEXT("HidP_GetValueCaps(%d)[%d]: Units = 0x%08x"),
                        type, ivcaps,
                        pcaps->Units);
        SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                        TEXT("HidP_GetValueCaps(%d)[%d]: IsAbs = %d"),
                        type, ivcaps,
                        pcaps->IsAbsolute);
        SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                        TEXT("HidP_GetValueCaps(%d)[%d]: BitSize = %d"),
                        type, ivcaps,
                        pcaps->BitSize);
        SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                        TEXT("HidP_GetValueCaps(%d)[%d]: IsAlias = %d"),
                        type, ivcaps,
                        pcaps->IsAlias);
        if(pcaps->LinkCollection)
        {
            SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                            TEXT("HidP_GetValueCaps(%d)[%d]: ")
                            TEXT("LinkCollection %d"),
                            type, ivcaps,
                            pcaps->LinkCollection);
        }

        /*
         *  Come up with a decent Null value if possible.
         *  The traditional Null value is the arithmetically
         *  smallest value which lies outside the
         *  LogicalMin/LogicalMax range.  Conveniently, the
         *  pcaps->lMask is the most negative value that is
         *  in range.
         */
        AssertF(pcaps->Null == 0);
        if(pvcaps->HasNull)
        {
          #ifdef WINNT
            pcaps->IsPolledPOV = FALSE;
          #endif
          
            if(pcaps->lMask < pcaps->Logical.Min)
            {
                pcaps->Null = pcaps->lMask;
            } else if(!(pcaps->lMask & (pcaps->Logical.Max + 1)))
            {
                pcaps->Null = pcaps->Logical.Max + 1;
            } else if( ! pcaps->IsSigned )
            {
                pcaps->Null = 0x0;
            } else
            {
                SquirtSqflPtszV(sqflTrace,
                                TEXT("VALUE_CAPS claims Null but no room!"));
            }
            SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                            TEXT("HidP_GetValueCaps(%d)[%d]: Null = %d"),
                            type, ivcaps,
                            pcaps->Null);
        } else {
          #ifdef WINNT
            if( fPOV &&
                (this->VendorID == MSFT_SYSTEM_VID ) &&
                ( (this->ProductID & 0xff00) == MSFT_SYSTEM_PID) )
            {
                LONG lUnits;

                lUnits = pcaps->Logical.Max - pcaps->Logical.Min + 1;
                if(lUnits)
                {
                    pcaps->usGranularity = (USHORT)9000;
                }

                pcaps->IsPolledPOV = TRUE;

                SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                                TEXT("HidP_GetValueCaps(%d)[%d]: Null = %d (Polled POV)."),
                                type, ivcaps,
                                pcaps->Null);
            }
          #endif
        }

        uiObj = this->rgdwBase[type] + pcaps->DataIndexMin;
        for(duiObj = 0; duiObj < pcaps->cObj; duiObj++)
        {
            DWORD dwObjType;
            LPDIOBJECTDATAFORMAT podf;

            /*
             *  If HID messed up and gave us something out of range,
             *  then give up on this value caps (since the rest are
             *  also out of range) and move on to the next one.
             */
            if(uiObj + duiObj >= this->df.dwNumObjs)
            {
                RPF("HidP_GetValueCaps inconsistent with NumberDataIndices - "
                    "skipping object (sorry)");
                break;
            }

            AssertF(uiObj + duiObj < this->df.dwNumObjs);

            if(this->rghoc[uiObj + duiObj].pcaps)
            {
                RPF("HidP_GetValueCaps inconsistent - "
                    "can't use device");
                hres = E_FAIL;
                goto freedone;
            }

            this->rghoc[uiObj + duiObj].pcaps = pcaps;
            podf = &this->df.rgodf[uiObj + duiObj];

            /*
             *  HACKHACK!  Wheels are identified by
             *  UsageToUsageMap as GUID_Slider, but we
             *  want them to be GUID_ZAxis if we are a mouse.
             *
             *  We also set the granularity here.
             */
            if(GET_DIDEVICE_TYPE(this->dwDevType) == DI8DEVTYPE_MOUSE &&
               pcaps->UsageMin + duiObj == HID_USAGE_GENERIC_WHEEL &&
               pcaps->UsagePage == HID_USAGE_PAGE_GENERIC)
            {
                podf->pguid = &GUID_ZAxis;
                pcaps->usGranularity = (USHORT)g_lWheelGranularity;
            } else if( type == HidP_Input )
            {
                PHIDUSAGEMAP phum;

                phum = UsageToUsageMap( DIMAKEUSAGEDWORD( pcaps->UsagePage,
                                                          pcaps->UsageMin + duiObj ) );
                if(phum)
                {
                    podf->pguid = phum->pguid;
                } else
                {
                    podf->pguid = &GUID_Unknown;
                }
            } else 
            {
                podf->pguid = &GUID_Unknown;
            }

            /*
             *  Set a default instance.  This will be overwritten later 
             *  if this object is of a type we fully understand.
             */        
            dwObjType = DIDFT_MAKEINSTANCE(uiObj + duiObj);

            if( pcaps->IsAlias )
            {
                dwObjType |= DIDFT_ALIAS;
            }
            
            if(pcaps->UsagePage >= HID_USAGE_PAGE_VENDOR )
            {
                dwObjType |= DIDFT_VENDORDEFINED;
            }
            else if(podf->pguid == &GUID_POV)
            {
                /* Note, this must be an input to have been mapped */
                dwObjType |= DIDFT_POV;
                if( !pcaps->IsAlias )
                {
                    this->dwPOVs++;
                }
            } 
            else if( type == HidP_Input )
            {
                /*
                 *  In order to reduce the likelyhood of an app picking up an 
                 *  input value that is not a user controlled axis, only mark 
                 *  values as axes if they are inputs on a usage page that 
                 *  contains such usages.
                 *  ISSUE-2000/11/07-MarcAnd ideally we should be looking at 
                 *  not only the usage of the object but at the collections 
                 *  that contain it.
                 */
                switch( pcaps->UsagePage )
                {
                case HID_USAGE_PAGE_BUTTON:
                    /*
                     *  The plan was that an absolute input axis on the button 
                     *  page would be an analog button.  Unfortunately it 
                     *  could be a mis-declared button array selector (482186).  
                     *  Safest thing is to ignore the thing completely.
                     */
                    SquirtSqflPtszV(sqfl | sqflVerbose,
                        TEXT("Ignoring value on button page usage ID 0x%04X"),
                        pcaps->UsageMin + duiObj );
                    break;

                case HID_USAGE_PAGE_GENERIC:
                    if( pcaps->UsageMin + duiObj == HID_USAGE_GENERIC_COUNTED_BUFFER )
                    {
                        SquirtSqflPtszV(sqfl | sqflTrace,
                            TEXT("Leaving counted buffer as unclassified object") );
                        break;
                    }

                    if( pcaps->UsageMin + duiObj == HID_USAGE_GENERIC_BYTE_COUNT )
                    {
                        SquirtSqflPtszV(sqfl | sqflTrace,
                            TEXT("Leaving byte count as unclassified object") );
                        break;
                    }

                case HID_USAGE_PAGE_SIMULATION:
                case HID_USAGE_PAGE_VR:
                case HID_USAGE_PAGE_SPORT:
                case HID_USAGE_PAGE_GAME:
                case HID_USAGE_PAGE_KEYBOARD:
                case HID_USAGE_PAGE_CONSUMER:
                case HID_USAGE_PAGE_DIGITIZER:
                    if( pcaps->IsAbsolute)
                    {
                        dwObjType |= DIDFT_ABSAXIS;
                    }
                    else
                    { 
                        dwObjType |= DIDFT_RELAXIS;
                    }
                    break;

                default:
                    SquirtSqflPtszV(sqfl | sqflTrace,
                        TEXT("Assuming value 0x%04X:0x%04X is not a user control"),
                        pcaps->UsagePage,pcaps->UsageMin + duiObj );
                }

                if( ( dwObjType & DIDFT_AXIS ) && !pcaps->IsAlias )
                {
                    this->dwAxes++;
                }
            }

            /*
             *  Objects must have an offset to be accessed
             */
            podf->dwOfs = this->df.dwDataSize;
            if( !pcaps->IsAlias) 
            { 
                this->df.dwDataSize += cbX(DWORD);
            }

            if(HidP_IsOutputLike(type))
            {
                /*
                 *  Input and feature allow data; output does not.
                 */
                if(type == HidP_Output)
                {
                    dwObjType |= ( DIDFT_NODATA | DIDFT_OUTPUT );
                }
                else
                {
                    dwObjType |= DIDFT_OUTPUT;
                }
            }

            podf->dwType = dwObjType;


            if(type != HidP_Input )
            {
                podf->dwFlags = DIDOI_POLLED | DIDOI_NOTINPUT;
            }
            else if(this->IsPolledInput )
            {
                podf->dwFlags = dwAspect | DIDOI_POLLED;
            } else
            {
                podf->dwFlags = dwAspect;
            }

            
            /*
             *  ISSUE-2001/03/06-MarcAnd  DIDOI FF attributes
             */
            if( this->fPIDdevice                    // FF device 
                && ! IsEqualGUID(podf->pguid, &GUID_Unknown ) )  // We map the axis
            {
                NTSTATUS            ntStat;
                USHORT              cAButton=0x0;
            
                ntStat =  HidP_GetSpecificButtonCaps 
                        (
                               HidP_Output,                        // ReportType
                               pcaps->UsagePage,                   // UsagePage
                               0x0,                                // Link Collection
                               (USAGE)(pcaps->UsageMin + duiObj),  // Usage 
                               NULL,                               // ValueCaps
                               &cAButton,                          // ValueCapsLength
                               this->ppd                           // PreparsedData
                        );
         
                if(   SUCCEEDED(ntStat)
                    || (ntStat == HIDP_STATUS_BUFFER_TOO_SMALL)  )// In case someone has more than one
            
                {
                    podf->dwFlags |= DIDOI_FFACTUATOR;
                    podf->dwType |= DIDFT_MAKEATTR(DIDOI_FFACTUATOR);
                }
            }
            
            /*
             *  Note that we do not calibrate relative axes,
             *  since there's really nothing to calibrate.
             *
             *  Note also that we calibrate only inputs.
             *  We don't want to do de-calibration on outputs.
             *  (And since features are input+output, we don't
             *  do it on features either.)
             *
             *  We merely set up the calibration here; the
             *  reading of the calibration values is done
             *  by CHid_LoadCalibrations.
             *
             */
            if(type == HidP_Input)
            {

                PJOYRANGECONVERT pjrc = this->pjrcNext++;

                this->rghoc[uiObj + duiObj].pjrc = pjrc;

                /*
                 *  Saturation always defaults to 100%.
                 */
                pjrc->dwSat = RANGEDIVISIONS;
                AssertF(pjrc->dwDz == 0);

                if( dwObjType & DIDFT_ABSAXIS ) 
                {
                    pjrc->lMin = 0;
                    pjrc->lMax = 65535;
                    pjrc->lC = 65535/2;
                } 
              #ifdef WINNT
                else if( (dwObjType & DIDFT_POV) && pcaps->IsPolledPOV ) 
                {
                    pjrc->fPolledPOV = TRUE;
                }
              #endif
            }
        }
        D(pcaps->dwSignature = HIDGROUPCAPS_SIGNATURE);
    }

    hres = S_OK;

    freedone:;
    FreePv(rgvcaps);

    done:;
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | InitAxes |
 *
 *          Identify and initialize the axes: input, feature and output.
 *
 *          HID calls them "values" because they might not really
 *          be axes in the joystick sense.
 *
 *          The input axes come first, then the feature axes,
 *          then the output axes.
 *
 *****************************************************************************/

HRESULT INTERNAL
    CHid_InitAxes(PCHID this)
{
    HRESULT hres;
    DWORD ccaps;

    /*
     *  Do the input axes...
     */
    hres = CHid_InitAxisClass(this, &this->rgcaps[0],
                              this->caps.NumberInputValueCaps,
                              HidP_Input);
    if(FAILED(hres))
    {
        goto done;
    }
    ccaps = this->caps.NumberInputValueCaps;

    /*
     *  Do the feature axes...
     */
    hres = CHid_InitAxisClass(this, &this->rgcaps[ccaps],
                              this->caps.NumberFeatureValueCaps,
                              HidP_Feature);
    if(FAILED(hres))
    {
        goto done;
    }
    ccaps += this->caps.NumberFeatureValueCaps;

    /*
     *  Do the output axes...
     */
    hres = CHid_InitAxisClass(this, &this->rgcaps[ccaps],
                              this->caps.NumberOutputValueCaps,
                              HidP_Output);
    if(FAILED(hres))
    {
        goto done;
    }

    done:;
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | InitButtonClass |
 *
 *          Initialize one class (input, feature, output) of buttons.
 *
 *  @parm   PHIDGROUPCAPS | rgcaps |
 *
 *          Array of <t HIDGROUPCAPS> structures to receive the caps
 *          of the buttons in the class.
 *
 *  @parm   USHORT | ccaps |
 *
 *          Number of <t HIDGROUPCAPS> structures we expect to find.
 *
 *  @parm   HIDP_REPORT_TYPE | type |
 *
 *          One of the values
 *          <c HidP_Input>,
 *          <c HidP_Feature> or
 *          <c HidP_Output>.
 *
 *****************************************************************************/

HRESULT INTERNAL CHid_InitButtonClass
(
    PCHID this, 
    PHIDGROUPCAPS rgcaps, 
    PBYTE rgbReportIDs, 
    USHORT ccaps, 
    HIDP_REPORT_TYPE type
)
{
    USHORT cbcaps;
    NTSTATUS stat;
    HRESULT hres;
    DWORD ibcaps;
    PHIDP_BUTTON_CAPS rgbcaps;
    
    AssertF(rgcaps >= this->rgcaps);
    AssertF(rgcaps + ccaps <= &this->rgcaps[this->ccaps]);

    /*
     *  Annoying quirk:
     *
     *  HID doesn't like it when you pass 0 to HidP_GetButtonCaps,
     *  so we need to special-case the "no buttons" scenario.
     */
    if(ccaps == 0)
    {
        hres = S_OK;
        goto done;
    }

    hres = AllocCbPpv(cbCxX(ccaps, HIDP_BUTTON_CAPS), &rgbcaps);
    if(FAILED(hres))
    {
        goto done;
    }

    cbcaps = ccaps;

    stat = HidP_GetButtonCaps(type, rgbcaps, &cbcaps, this->ppd);

    if(FAILED(stat))
    {
        RPF("HidP_GetButtonCaps failed - can't use device");
        hres = E_FAIL;
        goto freedone;
    }

    /* HidP_GetCaps has the annoying habit of treating everything that is
     * single bit as a button. 
     * This causes some problems. For example the ALPS gamepad declares its
     * POVs as single bit values, (not buttons though). 
     * Hence we need to be prepared for the buttons being less than advertised 
     */

    if(cbcaps != ccaps)
    {
        RPF("HidP_GetButtonCaps(%d) (%d) inconsistent "
            "with HidP_GetCaps (%d) - "
            "can't use device", type, cbcaps, ccaps);
        hres = E_FAIL;
        goto freedone;
    }

    CHid_SortCaps(rgbcaps, cbcaps);

    for(ibcaps = 0; ibcaps < cbcaps; ibcaps++)
    {
        PHIDP_BUTTON_CAPS pbcaps = &rgbcaps[ibcaps];
        PHIDGROUPCAPS pcaps = &rgcaps[ibcaps];
        UINT uiObj;
        UINT duiObj;

        if(pbcaps->IsRange)
        {
            if(pbcaps->Range.DataIndexMax - pbcaps->Range.DataIndexMin !=
               pbcaps->Range.UsageMax - pbcaps->Range.UsageMin)
            {
                RPF("HidP_GetButtonCaps corrupted BUTTON_CAPS - "
                    "can't use device");
                hres = E_FAIL;
                goto freedone;
            }
        } else
        {
            pbcaps->Range.UsageMax = pbcaps->Range.UsageMin;
        }

        pcaps->wReportId          = pbcaps->ReportID;
        this->wMaxReportId[type]  = max(pcaps->wReportId, this->wMaxReportId[type]);

        pcaps->UsagePage          = pbcaps->UsagePage;
        pcaps->UsageMin           = pbcaps->Range.UsageMin;
        pcaps->DataIndexMin       = pbcaps->Range.DataIndexMin;

        pcaps->cObj               = pbcaps->Range.UsageMax -
                                    pbcaps->Range.UsageMin + 1;

        /*
         *  Buttons are (from the HID definition) items with
         *  a bit size of 1.
         */
        pcaps->BitSize            = 1;
        pcaps->lMask              = ~((1 << (pcaps->BitSize - 1)) - 1);
        /*
         *  Not applicable for buttons:
         *
         *  LogicalMin/Max, PhysicalMin/Max, Units.
         */
        pcaps->LinkCollection     = pbcaps->LinkCollection;

        pcaps->StringMin          = pbcaps->Range.StringMin;
        pcaps->StringMax          = pbcaps->IsStringRange ?
                                    pbcaps->Range.StringMax :
                                    pbcaps->Range.StringMin;

        pcaps->DesignatorMin      = pbcaps->Range.DesignatorMin;
        pcaps->DesignatorMax      = pbcaps->IsDesignatorRange ?
                                    pbcaps->Range.DesignatorMax :
                                    pbcaps->Range.DesignatorMin;

        /*
         *  ISSUE-2001/03/06-MarcAnd What does IsAbsolute mean for a button?
         */
        pcaps->IsAbsolute         = pbcaps->IsAbsolute;

        AssertF(!pcaps->IsValue);

        pcaps->type               = type;

        pcaps->IsAlias            = pbcaps->IsAlias;


        SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                        TEXT("HidP_GetButtonCaps(%d)[%d]: ")
                        TEXT("Objs=%2d ")
                        TEXT("idx=%2d... ")
                        TEXT("coll=%d")
                        TEXT("IsAlias=%d"),
                        type, ibcaps,
                        pcaps->cObj,
                        pcaps->DataIndexMin,
                        pcaps->LinkCollection,
                        pcaps->IsAlias);

        uiObj = this->rgdwBase[type] + pcaps->DataIndexMin;
        for(duiObj = 0; duiObj < pcaps->cObj; duiObj++)
        {
            DWORD dwObjType;
            LPDIOBJECTDATAFORMAT podf;
            /*
             *  If HID messed up and gave us something out of range,
             *  then give up on this value caps (since the rest are
             *  also out of range) and move on to the next one.
             */
            if(uiObj + duiObj >= this->df.dwNumObjs)
            {
                RPF("HidP_GetButtonCaps inconsistent with NumberDataIndices - "
                    "skipping object (sorry)");
                break;
            }

            AssertF(uiObj + duiObj < this->df.dwNumObjs);

            if(this->rghoc[uiObj + duiObj].pcaps)
            {
                RPF("HidP_GetButtonCaps inconsistent - "
                    "can't use device");
                hres = E_FAIL;
                goto freedone;
            }

            /*
             *  No fatal errors have been detected so store the object details
             */
            AssertF( rgbReportIDs[uiObj + duiObj] == 0 );
            rgbReportIDs[uiObj + duiObj] = pbcaps->ReportID;

            this->rghoc[uiObj + duiObj].pcaps = pcaps;
            podf = &this->df.rgodf[uiObj + duiObj];
            
            /*
             *  Set a default instance.  This will be overwritten later 
             *  if this object is of a type we fully understand.
             */        
            dwObjType = DIDFT_MAKEINSTANCE(uiObj + duiObj);
            
            if(pcaps->UsagePage >= HID_USAGE_PAGE_VENDOR )
            {
                /*
                 *  ISSUE-2001/03/06-MarcAnd  vendor defined objects
                 *  An aliased vendor defined usage may have a standard (not 
                 *  vendor defined) alias but the whole object will still be 
                 *  marked as vendor defined
                 */
                if( pcaps->IsAlias )
                {
                    dwObjType |= DIDFT_ALIAS;
                }
                dwObjType |= DIDFT_VENDORDEFINED;
                podf->pguid = &GUID_Unknown;
            } 
            else
            {
                if( pcaps->IsAlias )
                {
                    dwObjType |= DIDFT_ALIAS;
                }
                /*
                 *  In order to reduce the likelyhood of an app picking up a 
                 *  bit that is not a user controlled button, only mark bits 
                 *  as buttons if they are inputs on a usage page that 
                 *  contains such usages.
                 *  ISSUE-2000/11/07-MarcAnd ideally we should be looking at 
                 *  not only the usage of the object but at the collections 
                 *  that contain it.
                 */
                if( type == HidP_Input )
                {
                    switch( pcaps->UsagePage )
                    {
                    case HID_USAGE_PAGE_KEYBOARD:
                        podf->pguid = &GUID_Key;            
                        break;

                    case HID_USAGE_PAGE_BUTTON:
                        if( ( duiObj == 0 )
                         && ( pcaps->UsageMin == 0 ) )
                        {
                            /*
                             *  Special case button zero means no buttons 
                             *  are pressed 
                             */
                            SquirtSqflPtszV(sqfl | sqflTrace,
                                TEXT("Ignoring \"No button\" button") );
                            goto IgnoreButton;
                        }
                    case HID_USAGE_PAGE_GENERIC:
                    case HID_USAGE_PAGE_SIMULATION:
                    case HID_USAGE_PAGE_VR:
                    case HID_USAGE_PAGE_SPORT:
                    case HID_USAGE_PAGE_GAME:
                    case HID_USAGE_PAGE_CONSUMER:
                    case HID_USAGE_PAGE_DIGITIZER:
                        podf->pguid = &GUID_Button;
                        break;
                    default:
                        SquirtSqflPtszV(sqfl | sqflTrace,
                            TEXT("Assuming button 0x%04X:0x%04X is not a user control"),
                            pcaps->UsagePage,pcaps->UsageMin + duiObj );
                        goto IgnoreButton;
                    }

                    dwObjType |= DIDFT_PSHBUTTON;
                    if( !pcaps->IsAlias )
                    {
                        this->dwButtons++;
                    }
                }
                else
                {
                    SquirtSqflPtszV(sqfl | sqflTrace,
                        TEXT("Assuming non-input bit 0x%04X:0x%04X is not a user control"),
                        pcaps->UsagePage,pcaps->UsageMin + duiObj );
IgnoreButton:;
                    podf->pguid = &GUID_Unknown;
                }

            }
            


            
            /*
             *  Objects must have an offset to be accessed
             */
            podf->dwOfs = this->df.dwDataSize;
            if( !pcaps->IsAlias) 
            { 
                this->df.dwDataSize += cbX(BYTE);
            }

            if(HidP_IsOutputLike(type))
            {
                /*
                 *  Input and feature allow data; output does not.
                 */
                if(type == HidP_Output)
                {
                    dwObjType |= ( DIDFT_NODATA | DIDFT_OUTPUT );
                }
                else
                {
                    dwObjType |= DIDFT_OUTPUT;
                }
            }

            podf->dwType = dwObjType;

            if(type != HidP_Input  )
            {
                podf->dwFlags = DIDOI_POLLED | DIDOI_NOTINPUT;
            } else if( this->IsPolledInput )
            {
                podf->dwFlags = DIDOI_POLLED;
            } else
            {
                podf->dwFlags = 0;
            }
        
            /*
             *  ISSUE-2001/03/06-MarcAnd  DIDOI FF attributes if not defined in registry
             */
            if(    this->fPIDdevice  
                && ( dwObjType & DIDFT_PSHBUTTON ) )
            {
                podf->dwFlags |= DIDOI_FFEFFECTTRIGGER;
                podf->dwType |= DIDFT_MAKEATTR(DIDOI_FFEFFECTTRIGGER);
            }
        
        
        }

        D(pcaps->dwSignature = HIDGROUPCAPS_SIGNATURE);
    }

    hres = S_OK;

    freedone:;
    FreePv(rgbcaps);

    done:;
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | InitButtons |
 *
 *          Identify and initialize the buttons: input, feature, and output.
 *
 *          The input buttons come first, then the feature buttons,
 *          then the output buttons.
 *
 *****************************************************************************/

HRESULT INTERNAL
    CHid_InitButtons(PCHID this)
{
    HRESULT hres;
    DWORD ccaps;
    PBYTE rgbReportIDs;
    UINT cbReportIDs;
    UINT uMaxReportId;

    this->ibButtonData = this->df.dwDataSize;

    /*
     *  Skip over the value caps to get to the buttons ...
     */
    ccaps = this->caps.NumberInputValueCaps +
            this->caps.NumberFeatureValueCaps +
            this->caps.NumberOutputValueCaps;

    /*
     *  Allocate a temporary buffer to store the report ID of each button.
     *  We use the sum of all data indices and collections so that the 
     *  internal object index of each button can be used as the index into 
     *  the buffer.  We leave value and collection elements alone so they 
     *  are just a small waste of space.
     */

    cbReportIDs = this->caps.NumberInputDataIndices +
                  this->caps.NumberFeatureDataIndices +
                  this->caps.NumberOutputDataIndices +
                  this->caps.NumberLinkCollectionNodes;

    hres = AllocCbPpv( cbReportIDs, &rgbReportIDs );

    if(FAILED(hres))
    {
        goto done;
    }

    /*
     *  Do the input buttons...
     */

    hres = CHid_InitButtonClass(this, 
                                &this->rgcaps[ccaps],
                                rgbReportIDs,
                                this->caps.NumberInputButtonCaps,
                                HidP_Input);
    if(FAILED(hres))
    {
        goto done;
    }
    ccaps += this->caps.NumberInputButtonCaps;

    /*
     *  Do the feature buttons...
     */
    hres = CHid_InitButtonClass(this, 
                                &this->rgcaps[ccaps],
                                rgbReportIDs,
                                this->caps.NumberFeatureButtonCaps,
                                HidP_Feature);
    if(FAILED(hres))
    {
        goto done;
    }
    ccaps += this->caps.NumberFeatureButtonCaps;

    /*
     *  Do the output buttons...
     */
    hres = CHid_InitButtonClass(this, 
                                &this->rgcaps[ccaps],
                                rgbReportIDs,
                                this->caps.NumberOutputButtonCaps,
                                HidP_Output);
    if(FAILED(hres))
    {
        goto done;
    }

    this->cbButtonData = this->df.dwDataSize - this->ibButtonData;

    /*
     *  If this device only has one report ID, it must be ID zero
     */
    uMaxReportId = (UINT) max( this->wMaxReportId[HidP_Input], 
                               max( this->wMaxReportId[HidP_Feature], 
                                    this->wMaxReportId[HidP_Output] ) );

    /*
     *  If there's only one report or there are no buttons there's 
     *  no need to set up the arrays of data masks for each report.
     */
    if( uMaxReportId == 0 )
    {
        AssertF( this->rgpbButtonMasks == NULL );
    }
    else if( this->cbButtonData == 0 )
    {
        AssertF( this->rgpbButtonMasks == NULL );
    }
    else
    {
        /*
         *  Allocate enough space for a mask array and a pointer to the array 
         *  for each report.
         */
        hres = AllocCbPpv( uMaxReportId * ( this->cbButtonData + cbX( PV ) ), 
            &this->rgpbButtonMasks );

        if( SUCCEEDED( hres ) )
        {
            UINT uReportId;
            UINT uDataIdx;
            UINT uBtnIdx;
            UINT_PTR uCurrentMaskOfs;

            /*
             *  The masks start after the last pointer to masks
             */
            uCurrentMaskOfs = uMaxReportId * cbX( this->rgpbButtonMasks[0] );
            memset( (PBYTE)this->rgpbButtonMasks + uCurrentMaskOfs , 0xFF, this->cbButtonData * uMaxReportId );


            /*
             *  Search through our temp buffer once for each report
             */
            for( uReportId=0; uReportId<uMaxReportId; uReportId++ )
            {
                for( uBtnIdx=uDataIdx=0; uDataIdx<cbReportIDs; uDataIdx++ )
                {
                    /*
                     *  Report IDs are one based but we use a zero based array 
                     *  so adjust when testing for a matching ID
                     */
                    if( rgbReportIDs[uDataIdx] == uReportId+1 )
                    {
                        /*
                         *  Set the offset for this report to the current 
                         *  mask array.  An offset is used so that when the 
                         *  memory is realloc'ed down to the size actually 
                         *  used, it is easier to generate pointers.  If a 
                         *  report contains more than one  button the same 
                         *  value will be set repeatedly.
                         */
                        this->rgpbButtonMasks[uReportId] = (PBYTE)uCurrentMaskOfs;

                        /*
                         *  The final result is an AND mask so clear all bits
                         *  so this button will be cleared when this report 
                         *  is being processed
                         */
                        ((PBYTE)this->rgpbButtonMasks)[uCurrentMaskOfs+uBtnIdx] = 0;
                    }

                    /*
                     *  Just in case there are gaps in the HID report we 
                     *  use our own counter of button index which is only 
                     *  incremented when we find a button to keep in line 
                     *  with the contiguous block of buttons that we use.
                     */
                    if( rgbReportIDs[uDataIdx] != 0 )
                    {
                        uBtnIdx++;
                        AssertF( uBtnIdx <= this->cbButtonData );
                    }
                }
                
                /*
                 *  There should always be exactly as many buttons in 
                 *  all the reports combined as we found when counting 
                 *  how many buttons there were of each type.
                 */
                AssertF( uBtnIdx == this->cbButtonData );

                /*
                 *  If any buttons were found in this report, use next mask
                 */
                if( this->rgpbButtonMasks[uReportId] == (PBYTE)uCurrentMaskOfs )
                {
                    uCurrentMaskOfs += this->cbButtonData;
                }
            }

            /*
             *  At least one report had to have a button in it.
             */
            AssertF( uCurrentMaskOfs != uMaxReportId * cbX( this->rgpbButtonMasks[0] ) );
        
            /*
             *  Try to reduce the allocation to what we actually used
             *  In the worst case we only land up using excess memory
             */
            ReallocCbPpv( (UINT)uCurrentMaskOfs, &this->rgpbButtonMasks );

            /*
             *  Convert the table of offsets into pointers
             */
            for( uReportId=0; uReportId<uMaxReportId; uReportId++ )
            {
                if( this->rgpbButtonMasks[uReportId] )
                {
                    this->rgpbButtonMasks[uReportId] += (UINT_PTR)this->rgpbButtonMasks;
                }
            }
        }
    }
    done:;

    FreePpv( &rgbReportIDs );

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CHid | InitCollections |
 *
 *          Identify and initialize the HID link collections.
 *
 *****************************************************************************/

HRESULT INTERNAL
    CHid_InitCollections(PCHID this)
{
    HRESULT hres;
    NTSTATUS stat;
    DWORD icoll, ccoll, ccaps;
    PHIDP_LINK_COLLECTION_NODE rgcoll;

    ccoll = this->caps.NumberLinkCollectionNodes;

    /*
     *  Annoying quirk:
     *
     *  HID doesn't like it when you pass 0 to HidP_GetLinkCollectionNodes,
     *  so we need to special-case the "no collections" scenario.
     */
    if(ccoll == 0)
    {
        hres = S_OK;
        goto done;
    }

    hres = AllocCbPpv(cbCxX(ccoll, HIDP_LINK_COLLECTION_NODE), &rgcoll);
    if(FAILED(hres))
    {
        goto done;
    }

    /*
     *  Get the collections...
     */
    stat = HidP_GetLinkCollectionNodes(rgcoll, &ccoll, this->ppd);
    if(FAILED(stat))
    {
        RPF("HidP_GetLinkCollectionNodes failed - can't use device");
        hres = E_FAIL;
        goto freedone;
    }

    if(ccoll != this->caps.NumberLinkCollectionNodes)
    {
        RPF("HidP_GetLinkCollectionNodes inconsistent with HidP_GetCaps - "
            "can't use device");
        hres = E_FAIL;
        goto freedone;
    }

    ccaps = this->caps.NumberInputValueCaps +
            this->caps.NumberFeatureValueCaps +
            this->caps.NumberOutputValueCaps +
            this->caps.NumberInputButtonCaps +
            this->caps.NumberFeatureButtonCaps +
            this->caps.NumberOutputButtonCaps;

    AssertF(ccaps + ccoll == this->ccaps);

    for(icoll = 0; icoll < ccoll; icoll++)
    {
        PHIDP_LINK_COLLECTION_NODE pcoll = &rgcoll[icoll];
        PHIDGROUPCAPS pcaps = &this->rgcaps[ccaps + icoll];
        UINT uiObj;
        LPDIOBJECTDATAFORMAT podf;
      
        pcaps->UsagePage          = pcoll->LinkUsagePage;
        pcaps->UsageMin           = pcoll->LinkUsage;
        pcaps->cObj               = 1;
        pcaps->IsAlias            = pcoll->IsAlias;

        /*
         *  Not applicable for collections:
         *
         *  StringMin/Max,
         *  DesignatorMin/Max,
         *  BitSize, LogicalMin/Max, PhysicalMin/Max, Units.
         *  IsAbsolute
         */
        pcaps->LinkCollection     = pcoll->Parent;

        pcaps->type               = HidP_Coll;

        /*
         *  We cook up DataIndexMin to correspond to this item.
         */
        pcaps->DataIndexMin       = (USHORT)icoll;

        uiObj = this->rgdwBase[HidP_Coll] + pcaps->DataIndexMin;

        /*
         *  We generated these indices on our own, so they
         *  can't possible be wrong.
         */
        AssertF(uiObj < this->df.dwNumObjs);

        this->rghoc[uiObj].pcaps = pcaps;
        podf = &this->df.rgodf[uiObj];

        /*
         *  ISSUE-2001/03/06-MarcAnd  collections have GUID_Unknown
         *  Collections are more or less hidden and therefore unusable.
         */
        podf->pguid = &GUID_Unknown;

        /*
         *  Set a default instance.  This will be overwritten later 
         *  if this object is of a type we fully understand.
         */        
        podf->dwType = DIDFT_MAKEINSTANCE(uiObj) | DIDFT_COLLECTION | DIDFT_NODATA;

        if(pcaps->UsagePage >= HID_USAGE_PAGE_VENDOR )
        {
            podf->dwType |= DIDFT_VENDORDEFINED;
        }

        podf->dwFlags = 0;

        /*
         *  CHid_ObjFromType relies on dwCollections not being split between
         *  aliased and unaliased.
         */
        this->dwCollections++;

        SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                        TEXT("HidP_GetLinkCollectionNodes(%d)[%d]: ")
                        TEXT("Objs=%2d ")
                        TEXT("idx=%2d... ")
                        TEXT("coll=%d")
                        TEXT("IsAlias=%d"),
                        pcaps->type, icoll,
                        pcaps->cObj,
                        pcaps->DataIndexMin,
                        pcaps->LinkCollection,
                        pcaps->IsAlias);

        D(pcaps->dwSignature = HIDGROUPCAPS_SIGNATURE);
    }

    hres = S_OK;

    freedone:;
    FreePv(rgcoll);

    done:;
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | AllocObjectMemory |
 *
 *          Allocate all the memory that will be used to store object
 *          information.
 *
 *****************************************************************************/

HRESULT INTERNAL
    CHid_AllocObjectMemory(PCHID this)
{
    DWORD cb;
    DWORD cvcaps, cbcaps, ccoll, cjrc;
    HRESULT hres;

    /*
     *  Some trace squirties because HID is tricky.
     */

    SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                    TEXT("HidP_GetCaps: NumberInputDataIndices    = %d"),
                    this->caps.NumberInputDataIndices);
    SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                    TEXT("HidP_GetCaps: NumberOutputDataIndices   = %d"),
                    this->caps.NumberOutputDataIndices);
    SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                    TEXT("HidP_GetCaps: NumberFeatureDataIndices  = %d"),
                    this->caps.NumberFeatureDataIndices);
    SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                    TEXT("HidP_GetCaps: NumberLinkCollectionNodes = %d"),
                    this->caps.NumberLinkCollectionNodes);

    SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                    TEXT("HidP_GetCaps: NumberInputValueCaps      = %d"),
                    this->caps.NumberInputValueCaps);
    SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                    TEXT("HidP_GetCaps: NumberOutputValueCaps     = %d"),
                    this->caps.NumberOutputValueCaps);
    SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                    TEXT("HidP_GetCaps: NumberFeatureValueCaps    = %d"),
                    this->caps.NumberFeatureValueCaps);

    SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                    TEXT("HidP_GetCaps: NumberInputButtonCaps     = %d"),
                    this->caps.NumberInputButtonCaps);
    SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                    TEXT("HidP_GetCaps: NumberOutputButtonCaps    = %d"),
                    this->caps.NumberOutputButtonCaps);
    SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                    TEXT("HidP_GetCaps: NumberFeatureButtonCaps   = %d"),
                    this->caps.NumberFeatureButtonCaps);

    /*
     *  Allocate the memory into which we place
     *  the DIOBJECTDATAFORMATs we build.
     */
    this->df.dwNumObjs = this->caps.NumberInputDataIndices +
                         this->caps.NumberOutputDataIndices +
                         this->caps.NumberFeatureDataIndices +
                         this->caps.NumberLinkCollectionNodes;
    if(this->df.dwNumObjs >= DIDFT_GETINSTANCE(DIDFT_ANYINSTANCE))
    {
        ("Too many objects in HID device (%d) - can't use device",
         this->df.dwNumObjs);
        hres = E_FAIL;
        goto done;
    }

    SquirtSqflPtszV(sqflHidParse,
                    TEXT("CHid_AllocObjectMemory: dwNumObjs      = %d"),
                    this->df.dwNumObjs);

    /*
     *  ISSUE-2001/10/17-MarcAnd  Axes declared in ranges cause AVs
     *  We only allocate as many JOYRANGECONVERT elements as there are value 
     *  caps in HID but multiple axes may be declared in a range which will 
     *  be reported in a single value caps.
     */
    cjrc   = this->caps.NumberInputValueCaps;

    cvcaps = this->caps.NumberInputValueCaps +
             this->caps.NumberFeatureValueCaps +
             this->caps.NumberOutputValueCaps;

    cbcaps = this->caps.NumberInputButtonCaps +
             this->caps.NumberFeatureButtonCaps +
             this->caps.NumberOutputButtonCaps;

    ccoll  = this->caps.NumberLinkCollectionNodes;

    this->ccaps = cvcaps + cbcaps + ccoll;

    /*
     *  Allocating the memory is done in four phases.
     *
     *  1. Tally up how much memory we need,
     *  2. Allocate that memory,
     *  3. Dole out the memory we allocated,
     *  4. Check that we didn't mess up.
     *
     *  Since this is extremely error-prone (I've messed it up at least
     *  once), the work is hidden inside macros.
     *
     *  The macro THINGS expands to a series of THING()s, each of which
     *  specifies a field name and the size it should be.  Each time you
     *  want to iterate over the fields, use the THINGS macro.
     */

    #define THINGS()                                                        \
        THING(df.rgodf,     cbCxX(this->df.dwNumObjs, DIOBJECTDATAFORMAT)); \
        THING(rghoc,        cbCxX(this->df.dwNumObjs, HIDOBJCAPS));         \
        THING(rgcaps,       cbCxX(this->ccaps, HIDGROUPCAPS));              \
        THING(pjrcNext,     cbCxX(cjrc, JOYRANGECONVERT));                  \

    /*
     *  Make a pass through the fields adding up the memory requirements.
     */
    #define THING(f, cbF)       cb += cbF
    cb = 0;
    THINGS();
    #undef THING

    hres = ReallocCbPpv(cb, &this->df.rgodf);

    if(SUCCEEDED(hres))
    {

        PV pv;

        /*
         *  Make a pass through the fields carving up the memory block
         *  and handing out pieces of it.
         */
    #define THING(f, cbF) this->f = pv; pv = pvAddPvCb(pv, cbF)
        pv = this->df.rgodf;
        THINGS();
    #undef THING

        /*
         *  There should be no byte left over.
         */
        AssertF(pvAddPvCb(this->df.rgodf, cb) == pv);

    }

    #undef THINGS

    SquirtSqflPtszV(sqflHidParse,
                    TEXT("CHid_AllocObjectMemory: pv = %08x, cb = 0x%08x"),
                    this->df.rgodf, cb);

    done:;
    return hres;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | EnumKeyboardMunge |
 *
 *          Enumerate the objects in the list, indicating whether
 *          each object is "keyboardlike" or "otherlike".
 *
 *  @parm   LPBYTE | pb |
 *
 *          Pointer to translation table that converts HID usages
 *          into keyboard scan codes.
 *
 *  @parm   KBDMUNGECALLBACK | Munge |
 *
 *          Callback function that handles each object as we find it.
 *
 *  @parm   PV | pvRef |
 *
 *          Reference data for callback.
 *
 *  @cb     void CALLBACK | KbdMungeCallback |
 *
 *          Called once for each object on a keyboard HID device.
 *
 *  @parm   PCHID | this |
 *
 *          The device itself.
 *
 *  @parm   UINT | uiObj |
 *
 *          The object being enumerated.
 *
 *  @parm   UINT | dik |
 *
 *          DirectInput scan code for the object, or a value greater than
 *          or equal to <c DIKBD_CKEYS> if it's a fake instance number
 *          concocted for a non-AT key.
 *
 *****************************************************************************/

typedef void (CALLBACK *KBDMUNGECALLBACK)(PCHID this, UINT uiObj, UINT dik);

void INTERNAL
    CHid_EnumKeyboardMunge(PCHID this, LPBYTE pb, KBDMUNGECALLBACK Munge)
{
    UINT uiObj;
    BYTE rgbSeen[DIKBD_CKEYS];
    UINT uiCollections;

    /*
     *  In principle we could walk the this->rgcaps array, but
     *  that would open the risk that the this->rgcaps array
     *  and this->df.rgodf array are out of sync for some
     *  bizarre reason.  Do it the slow way just to be safe.
     *
     *  Furthermore, only the first item with a particular
     *  keyboard usage gets mapped into the DirectInput table.
     *  So if a keyboard has two ESCAPE keys, only the first
     *  one shows up in the DirectInput table; the second one
     *  shows up as "just another key".
     */

    this->uiInstanceMax = DIKBD_CKEYS;
    ZeroX(rgbSeen);
    for(uiCollections = uiObj = 0; uiObj < this->df.dwNumObjs; uiObj++)
    {
        PHIDGROUPCAPS pcaps;
        UINT dik;
        UINT duiObj;
        UINT DataIndex;
        UINT Usage;

        pcaps = this->rghoc[uiObj].pcaps;

        if( pcaps->type == HidP_Coll )
        {
            dik = uiCollections++;
        }
        else
        {
            AssertF( HidP_IsValidReportType(pcaps->type) );
                
            DataIndex = uiObj - this->rgdwBase[pcaps->type];
            duiObj = DataIndex - pcaps->DataIndexMin;

            AssertF(duiObj < pcaps->cObj);

            Usage = pcaps->UsageMin + duiObj;

            if(pcaps->UsagePage == HID_USAGE_PAGE_KEYBOARD)
            {
                if(Usage < DIKBD_CKEYS && pb[Usage] && !rgbSeen[pb[Usage]])
                {
                    rgbSeen[pb[Usage]] = 1;
                    dik = pb[Usage];
                } else
                {
                    dik = this->uiInstanceMax++;
                }

            } else
            {
                dik = this->uiInstanceMax++;
            }

        }
        Munge(this, uiObj, dik);
    }

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CHid | TallyKeyboardObjs |
 *
 *          Callback function used during preliminary tallying to
 *          tot up how many of the objects can be treated as
 *          AT-compatible keyboard gizmos and how many are HID-specific.
 *
 *  @parm   UINT | uiObj |
 *
 *          The object being enumerated.
 *
 *  @parm   UINT | dik |
 *
 *          DirectInput scan code for the object, or a value greater than
 *          or equal to <c DIKBD_CKEYS> if it's a fake instance number
 *          concocted for a non-AT key.
 *
 *****************************************************************************/

void INTERNAL
    CHid_TallyKeyboardObjs(PCHID this, UINT uiObj, UINT dik)
{
    this;
    uiObj;
    dik;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CHid | ReassignKeyboardObjs |
 *
 *          Callback function used to shuffle instance numbers around
 *          to make them AT-compatible when possible.
 *
 *  @parm   UINT | uiObj |
 *
 *          The object being enumerated.
 *
 *  @parm   UINT | dik |
 *
 *          DirectInput scan code for the object, or a value greater than
 *          or equal to <c DIKBD_CKEYS> if it's a fake instance number
 *          concocted for a non-AT key or an index number for a collection.
 *
 *****************************************************************************/

void INTERNAL
    CHid_ReassignKeyboardObjs(PCHID this, UINT uiObj, UINT dik)
{
    if( this->df.rgodf[uiObj].dwType & DIDFT_COLLECTION )
    {
        this->rgicoll[dik] = uiObj;
    }
    else
    {
        this->rgiobj[dik] = uiObj;
    }

    SquirtSqflPtszV(sqfl | sqflVerbose,
                    TEXT("CHid_ReassignKeyboardObjs: ")
                    TEXT("uiObj = %03x, dwType = %08x, dik=%04x"),
                    uiObj, this->df.rgodf[uiObj].dwType,
                    dik);

    this->df.rgodf[uiObj].dwType =
        (this->df.rgodf[uiObj].dwType & ~DIDFT_INSTANCEMASK) |
        DIDFT_MAKEINSTANCE(dik);

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | MungeKeyboard |
 *
 *          We just created a keyboard device.
 *
 *          Unfortunately, DirectInput has some annoying requirements
 *          for keyboard devices, so here is where we swizzle the instance
 *          numbers around to keep DirectInput happy.
 *
 *****************************************************************************/

HRESULT INTERNAL
    CHid_MungeKeyboard(PCHID this)
{
    HRESULT hres;
    LPBYTE pb;

    AssertF(this->rgiobj == 0);

    pb = pvFindResource(g_hinst, IDDATA_HIDMAP, RT_RCDATA);
    if(pb)
    {
        /*
         *  Count up the number of non-keyboard things on this device.
         *  They will get instance numbers starting at DIKBD_CKEYS.
         */

        CHid_EnumKeyboardMunge(this, pb, CHid_TallyKeyboardObjs);

        /*
         *  Now that we know how many nonstandard keyboard thingies
         *  we have, allocate room for the translation table
         *  and work all the instance values around to keep
         *  legacy apps happy.
         */

        hres = ReallocCbPpv(cbCdw(this->uiInstanceMax + this->dwCollections), &this->rgiobj);
        if(SUCCEEDED(hres))
        {
            memset(this->rgiobj, 0xFF, cbCxX(this->uiInstanceMax + this->dwCollections, INT));

            /*
             *  In case a keyboard comes along with non-button inputs,
             *  set up the other types of pointers to the same buffer.
             */
            this->rgipov = this->rgiaxis = this->rgiobj;

            /*
             *  Put collections at the end, there should be at least one
             */
            AssertF( this->dwCollections );
            this->rgicoll = &this->rgiobj[this->uiInstanceMax];

            CHid_EnumKeyboardMunge(this, pb, CHid_ReassignKeyboardObjs);

            hres = S_OK;
        }

        /*
         *  Prefix warns that the resource is leaked (mb:34650) but there is 
         *  no API to release a raw resource (FreeResource is a stub) so there 
         *  is nothing we can do.
         */
    } else
    {
        hres = E_FAIL;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | MungeNotKeyboard |
 *
 *          We just created a device that is not a keyboard.
 *
 *          Since we need the instance for each object to be relative only to 
 *          objects of that type, we need to replace the device relative 
 *          values generated into type relative ones.  In addition, to 
 *          maintain compatability with pre-HID object instances we need to 
 *          use axis instance numbers that would be generated for a WinMM 
 *          mapped axis.
 *          Aliased objects must be given the same instance number as the 
 *          primary alias so that the only difference between them is their 
 *          usage.  This prevents a data format being generated using multiple 
 *          aliases of the same object.
 *
 *          ISSUE-2001/03/13-MarcAnd  HID object munging is incomplete
 *          1.  Multiple values on a single axis (force and position)
 *          2.  Multiple instances of an axis type (two throttles)
 *          3.  Does not distinguish output only values (actuators) from axes
 *          4.  Keyboards with anything other than buttons should have this 
 *              done but won't
 *
 *****************************************************************************/

/*
 *  Internal function to convert all the attributes of one object to another
 *
 *  If an axis needs to be reinterpreted here, both the axis semantic and the 
 *  object GUID need to be changed so that the axis will be used consistently 
 *  in both semantic mapper and data format games.
 *
 *  Note, multiple instances of an axis type are not handled well.
 */
void INTERNAL ReinterpretObject
(
    PCHID   this,
    PDWORD  pdwHints,
    int     cAxes,
    PDWORD  pdwTypeFlags,
    DWORD   dwSrcHint,
    DWORD   dwDstHint,
    BYTE    bSemFlags,
    PCGUID  pgNew
)
{

    if( ( *pdwTypeFlags & ( dwSrcHint | dwDstHint ) ) == dwSrcHint )
    {
        int idx;

        for( idx = 0; idx < cAxes + 6; idx++ )
        {
            if( pdwHints[idx] == dwSrcHint )
            {
                *pdwTypeFlags ^= ( dwSrcHint | dwDstHint );
                pdwHints[idx] = dwDstHint;
                this->rgbaxissemflags[idx] = bSemFlags;
                this->df.rgodf[this->rgiaxis[idx]].pguid = pgNew;
                break;
            }
        }
        AssertF( idx < cAxes + 6 );
    }
}


HRESULT INTERNAL
    CHid_MungeNotKeyboard(PCHID this)
{
    HRESULT hres;

    unsigned int uiObj;
    int iButton;
    int iCollection = 0;
    int iPOV = 0;
    int iAxis = 0;
    //to indicate the index of the last "actual" button
    int iLastButtonIndex = 0;
    //to indicate the number of "non-actual" buttons
    int iOtherButton = 0;

    PINT piRemap = 0;

    BOOL fCarController = FALSE;

    DWORD dwTypeFlags = 0;
    int cAxes;

    D( iButton = 0; )
    AssertF(this->rgiobj == 0);

    /*
     *  First count the distinct types so we know how to segment rgiobj
     */

    for(uiObj = 0; uiObj < this->df.dwNumObjs; uiObj++)
    {
        SquirtSqflPtszV(sqflHidParse | sqflVerbose,
                        TEXT("CHid_MungeNotKeyboard: uiObj: %d starts as dwType 0x%08x"),
                        uiObj, this->df.rgodf[uiObj].dwType );

        if( !this->rghoc[uiObj].pcaps )
        {
            continue;
        }

        if( this->rghoc[uiObj].pcaps->IsAlias )
        {
            /*
             *  If there's a steering wheel anywhere, we need to know
             */
            if( ( DIDFT_AXIS == ( this->df.rgodf[uiObj].dwType & ( DIDFT_AXIS | DIDFT_NODATA ) ) )
             && ( this->rghoc[uiObj].pcaps->UsagePage == HID_USAGE_PAGE_SIMULATION )
             && ( HID_USAGE_SIMULATION_STEERING == 
                  ( this->rghoc[uiObj].pcaps->UsageMin + uiObj 
                  - this->rgdwBase[this->rghoc[uiObj].pcaps->type] 
                  - this->rghoc[uiObj].pcaps->DataIndexMin ) ) )
            {
                fCarController = TRUE;
            }
            continue;
        }


        /*
         *  Don't bother taking pointer to dwType in this simple
         *  loop as it should be enregistered anyway.
         */
        if( this->df.rgodf[uiObj].dwType & DIDFT_COLLECTION )
        {
            iCollection++;
        } 
        else if( this->df.rgodf[uiObj].dwType & DIDFT_NODATA )
        {
            /*
             *  Don't count objects that report no data
             */
            continue;
        }
        else if( this->df.rgodf[uiObj].dwType & DIDFT_BUTTON )
        {
            //HID reports everything that has size 1 bit as a button.
            //We need to know the index of the highest "actual" button -- the one that has USAGE_PAGE_BUTTON
            //And then we also need to know how many "non-actual" buttons there are.
            //The total amount of memory we need to allocate for buttons is the sum of those 2.
            if (this->rghoc[uiObj].pcaps->UsagePage == HID_USAGE_PAGE_BUTTON)
            {
                int iUsage = ( this->rghoc[uiObj].pcaps->UsageMin
                                     + uiObj 
                                     - this->rgdwBase[this->rghoc[uiObj].pcaps->type] 
                                     - this->rghoc[uiObj].pcaps->DataIndexMin );
                if (iUsage > iLastButtonIndex)
                {
                    iLastButtonIndex = iUsage;
                }
            }
            else
            {
                iOtherButton++;
            }
            D( iButton++; )
        }
        else if( this->df.rgodf[uiObj].dwType & DIDFT_AXIS )
        {
            iAxis++;
        }
        else if( this->df.rgodf[uiObj].dwType & DIDFT_POV )
        {
            iPOV++;
        }
    }


    /*
     *  Assert that we counted everything OK while we have a button count
     */
    AssertF( (int)this->df.dwNumObjs >= ( iPOV + iButton + iAxis + iCollection ) );

    /*
     *  The total amount of memory we need to allocate for buttons is the sum of 
     *  the highest "actual" button index and the number of "non-actual" buttons.
     */
    iButton = iOtherButton + iLastButtonIndex;
    AssertF(iButton >= 0);

    /*
     *  You can go to a whole lot of trouble finding out exactly what gaps 
     *  are left by the WinMM mapping but in the end, it's only 24 bytes of 
     *  data and it takes way more to work out how to save them.
     *  So just allocate 6 extra in case all the axes are non-WinMM.
     *  Note, there is weirdnes involved in WinMM axes as a real WinMM device 
     *  always have the U (Ry) and V (Rx) axes mapped to S0 and S1 however HID 
     *  devices have more flexible mappings.  Since the main reason to try to 
     *  keep WinMM and HID axes the same is for FF, only X and Y are critical.
     *  Keep the button count in cAxes so we can reference it when we need to 
     *  without worrying about whether iAxis is the current max or the real 
     *  max.  Should do this for the other counts as well but that can wait 
     *  until this function gets its long overdue restructuring.
     */
    cAxes = iAxis;
    this->uiInstanceMax = iCollection + iButton + cAxes + iPOV + 6;

    /*
     *  Note, piRemap received a pointer to a buffer user for workspace.
     *  The single allocation is subdivided as follows: 
     *      a buffer for an array of ints for matched objects, 
     *      an array of USAGES for axes and 
     *      and array of DWORDs for hint flags.
     */
    if( SUCCEEDED( hres = ReallocCbPpv(cbCdw(this->uiInstanceMax), &this->rgiobj) ) 
     && SUCCEEDED( hres = AllocCbPpv( ( cbCdw( 2 * (cAxes + 6) ) + cbCxX(this->uiInstanceMax, INT) ), &piRemap ) ) 
     && SUCCEEDED( hres = AllocCbPpv( cAxes + 6, &this->rgbaxissemflags ) ) )
    {
    /*
     * NOTE - this is not the order they are stored in the registry - but the macro used for
     *        generating them internally has been reversed somewhere along the track.
     */
typedef union _USAGES
{
    struct
    {
        USAGE Usage;
        USAGE UsagePage;
    };
    DWORD dwUsages;
} USAGES, *PUSAGES;

        PUSAGES pUsageMatches;
        PDWORD  pdwHints;
        int iNops = 0;
        int iUsages = 0;
        int iAxisIdx;
        HKEY hkAxis;

        DWORD dwTestType = 0;
        int iTypeAxes = 0;
        BOOL bAllMatch=TRUE;

        ZeroMemory( this->rgbaxissemflags, cAxes + 6 );
        memset(piRemap, 0xFF, cbCxX(this->uiInstanceMax, INT));
        memset(this->rgiobj, 0xFF, cbCxX(this->uiInstanceMax, INT));

        /*
         *  CHid_ObjFromType relies on the order of these for range checking
         */
        this->rgipov = &this->rgiobj[iButton];
        this->rgiaxis = &this->rgipov[iPOV];
        this->rgicoll = &this->rgipov[cAxes+6];


        /*
         *  In order to allow IHVs to describe their devices with usages 
         *  that we don't have in our table but still work for legacy apps, we 
         *  allow axes to be selected using the DIOBJECTATTRIBUTES in the 
         *  registry.  
         */
        pUsageMatches = (PUSAGES)&piRemap[this->uiInstanceMax];
        pdwHints = &pUsageMatches[cAxes + 6].dwUsages;

        /*
         *  Assert that we can treat the combined usage page / usage 
         *  WORDs using a union of a DWORD and two WORDs.
        CAssertF( ( FIELD_OFFSET( DIOBJECTATTRIBUTES, wUsage ) 
                  - FIELD_OFFSET( DIOBJECTATTRIBUTES, wUsagePage ) )
               == ( FIELD_OFFSET( USAGES, Usage ) 
                  - FIELD_OFFSET( USAGES, UsagePage ) ) );
         */

        /*
         *  Fetch IHV matches for all reasonable axes.
         */
        for( iAxisIdx = 0; iAxisIdx < cAxes + 5; iAxisIdx++ )
        {
            if( SUCCEEDED( CType_OpenIdSubkey( this->hkType, 
                    DIDFT_AXIS | DIDFT_MAKEINSTANCE( iAxisIdx ), 
                    KEY_QUERY_VALUE, &hkAxis ) ) )
            {
                DIOBJECTATTRIBUTES attr;

                if( ( SUCCEEDED( JoyReg_GetValue( hkAxis, TEXT("Attributes"),
                        REG_BINARY, &attr, cbX(attr) ) ) )
                 && ( *(PDWORD)&attr.wUsagePage ) )
                {
                    pUsageMatches[iAxisIdx].UsagePage = attr.wUsagePage;
                    pUsageMatches[iAxisIdx].Usage = attr.wUsage;
                    iUsages++;
                    /*
                     * Check it really exists on the device
                     * New behaviour is to ignore ALL registry mappings
                     * and dfault to DX7 implementation if a bogus
                     * control is found
                     */
                    for(uiObj = 0; uiObj < this->df.dwNumObjs; uiObj++)
                    {
                        if( ( this->df.rgodf[uiObj].dwType & DIDFT_AXIS )
                           && ( this->rghoc[uiObj].pcaps )
                           && ( this->rghoc[uiObj].pcaps->type == HidP_Input ) )
                        {   
                            USAGES Usages;
                            UINT   uidObj;

                            Usages.UsagePage = this->rghoc[uiObj].pcaps->UsagePage;
                            uidObj = uiObj - ( this->rgdwBase[HidP_Input] + this->rghoc[uiObj].pcaps->DataIndexMin );
                            Usages.Usage = this->rghoc[uiObj].pcaps->UsageMin + uidObj;
                            if( Usages.dwUsages == pUsageMatches[iAxisIdx].dwUsages )
                            {
                                SquirtSqflPtszV(sqfl | sqflVerbose,
                                    TEXT("CHid_MungeNotKeyboard: Object %d matches  0x%08x"),
                                    uiObj, pUsageMatches[iAxisIdx].dwUsages );
                                break;
                            }
                        }
                    }
                    if (uiObj >= this->df.dwNumObjs)
                    {
                        //Error in registry settings - usage/usagepage pair not present on device
                        //reset
                        SquirtSqflPtszV(sqfl | sqflVerbose,
                            TEXT("CHid_MungeNotKeyboard: No matches for 0x%08x -  abandoning IHV map"),
                            pUsageMatches[iAxisIdx].dwUsages );
                        iUsages=0;
                        memset(piRemap, 0xFF, cbCxX(this->uiInstanceMax, INT));
                        bAllMatch=FALSE;
                        break;
                    }
                }
                else
                {
                    iNops++;
                }

                RegCloseKey( hkAxis );

                if( iUsages + iNops == cAxes )
                {
                    /*
                     *  We've opened as many keys as we have axes
                     *  continue the loop in debug as sanity check.
                     */
#ifdef XDEBUG
                    int iDbgIdx;
                    for( iDbgIdx = iAxisIdx + 1; iDbgIdx < cAxes + 5; iDbgIdx++ )
                    {
                        if( SUCCEEDED( CType_OpenIdSubkey( this->hkType, 
                                DIDFT_AXIS | DIDFT_MAKEINSTANCE( iDbgIdx ), 
                                KEY_QUERY_VALUE, &hkAxis ) ) )
                        {
                            RPF( "More axis keys than axes on device %04x:%04x!",
                                this->VendorID, this->ProductID );
                        }
                    }
#endif
                    break;
                }
            }
        }

        /*
         *  Go through all input axes, including aliases, trying to find a match
         */
        for(uiObj = 0; uiObj < this->df.dwNumObjs && bAllMatch; uiObj++)
        {
            UINT    uiObjPrimary;
            int     iUsageIdx;

            if( ( this->df.rgodf[uiObj].dwType & DIDFT_AXIS )
             && ( this->rghoc[uiObj].pcaps )
             && ( this->rghoc[uiObj].pcaps->type == HidP_Input ) )
            {
                USAGES Usages;
                UINT   uidObj;

                if( !this->rghoc[uiObj].pcaps->IsAlias )
                {
                    uiObjPrimary = uiObj;
                }

                
                Usages.UsagePage = this->rghoc[uiObj].pcaps->UsagePage;
                uidObj = uiObj - ( this->rgdwBase[HidP_Input] + this->rghoc[uiObj].pcaps->DataIndexMin );
                Usages.Usage = this->rghoc[uiObj].pcaps->UsageMin + uidObj;
                
                /*
                 *  Use incremental loop for better JoyHID consistency
                 */
                for( iUsageIdx = 0; iUsageIdx <= iAxisIdx; iUsageIdx++ )
                {
                    if( Usages.dwUsages == pUsageMatches[iUsageIdx].dwUsages )
                    {
                        PHIDUSAGEMAP phum;
                        LPDIOBJECTDATAFORMAT podf;

                        /*
                         *  Remember this one for later and 
                         *  discount it from further matches.
                         */
                        piRemap[uiObjPrimary] = iUsageIdx;
                        pUsageMatches[iUsageIdx].dwUsages = 0;

                        /*
                         *  Try to fix up the object GUID
                         *  Use a usage page usage match if possible 
                         *  otherwise pretend this is a generic axis 
                         *  of the appropriate type or settle for 
                         *  unknown.
                         */
                        podf = &this->df.rgodf[uiObj + uidObj];
                        if( iUsageIdx < 6 )
                        {
                            phum = UsageToUsageMap( DIMAKEUSAGEDWORD( 
                                HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_X + iUsageIdx ) );
                            AssertF( phum );
                            podf->pguid = phum->pguid;
                            this->rgbaxissemflags[iUsageIdx] = phum->bSemFlag;
                            pdwHints[iUsageIdx] = phum->dwSemHint;
                            dwTypeFlags |= phum->dwSemHint;
                        }
                        else if (iUsageIdx < 8)
                        {
                            podf->pguid = &GUID_Slider;
                            this->rgbaxissemflags[iUsageIdx] = DISEM_FLAGS_GET( DISEM_FLAGS_S );
                        }
                        else
                        {
                            podf->pguid = &GUID_Unknown;
                            this->rgbaxissemflags[iUsageIdx] = DISEM_FLAGS_GET( DISEM_FLAGS_S );
                        }

                        /*
                         *  Mark the primary axis associated with 
                         *  the matched axis as already set up.
                         */
                        this->rgiaxis[iUsageIdx] = uiObjPrimary;
                        this->df.rgodf[uiObjPrimary].dwType &= ~DIDFT_INSTANCEMASK;
                        this->df.rgodf[uiObjPrimary].dwType |= DIDFT_MAKEINSTANCE(iUsageIdx);

                        break;
                    }
                }
            }
            else
            {
                /* Not an axis, with caps and input */
            }
        }
    

        iCollection = 0;
        iButton = 0;
        iPOV = 0;
        iAxis = 6;

        for(uiObj = 0; uiObj < this->df.dwNumObjs; uiObj++)
        {
            PHIDUSAGEMAP phum;
            PDWORD pdwType;

            pdwType = &this->df.rgodf[uiObj].dwType;

            if( !this->rghoc[uiObj].pcaps || this->rghoc[uiObj].pcaps->IsAlias 
              ||!( *pdwType & ( DIDFT_AXIS | DIDFT_BUTTON | DIDFT_POV | DIDFT_COLLECTION ) ))
            {
                continue;
            }

            if( *pdwType & DIDFT_COLLECTION )
            {
                *pdwType = (*pdwType & ~DIDFT_INSTANCEMASK) | DIDFT_MAKEINSTANCE(iCollection);
                this->rgicoll[iCollection++] = uiObj;
                continue;
            }
            else if( *pdwType & DIDFT_NODATA )
            {
                /*
                 *  Leave other no data objects alone
                 */
                continue;
            }
            
            if( *pdwType & DIDFT_BUTTON )
            {
                *pdwType &= ~DIDFT_INSTANCEMASK;
                //The buttons need to be sorted (manbug 30320) --
                //the ones that have USAGE_PAGE_BUTTON come first, sorted by button number,
                //w/ gaps for missing numbers if necessary;
                //then add on those that do not have USAGE_PAGE_BUTTON 
                //(since HID reports anything w/ size 1 bit is a button), unsorted.

                if (this->rghoc[uiObj].pcaps->UsagePage == HID_USAGE_PAGE_BUTTON)
                {
                    //put in the correct position, leaving gaps if needed.
                    //Usage - 1 will give us the position, since HID usages are 1-based,
                    //but DInput button indeces are 0-based.
                    int iPosition = ( this->rghoc[uiObj].pcaps->UsageMin
                                     + uiObj 
                                     - this->rgdwBase[this->rghoc[uiObj].pcaps->type] 
                                     - this->rghoc[uiObj].pcaps->DataIndexMin ) - 1;
                    AssertF(iPosition >= 0);
                    *pdwType |= DIDFT_MAKEINSTANCE(iPosition);
                    this->rgiobj[iPosition] = uiObj;
                 }
                 else
                 {
                     //iLastIndex indicates where to put the non-USAGE_PAGE_BUTTON things
                     //in the order that they come in the report
                    *pdwType |= DIDFT_MAKEINSTANCE(iLastButtonIndex);
                    this->rgiobj[iLastButtonIndex++] = uiObj; 
                 }
                
                 //increment the count of how many real things (excluing gaps) we've got
                 iButton++;
            }
            else if( *pdwType & DIDFT_AXIS )
            {
                if( piRemap[uiObj] == -1 )
                {

                    WORD wUsage;
                    UINT uiObjPrimary = uiObj; 

                    *pdwType &= ~DIDFT_INSTANCEMASK;
                    /*
                     *  Check this axis and it's aliases for a match
                     */
                    while( TRUE )
                    {
                        wUsage = (WORD) ( this->rghoc[uiObj].pcaps->UsageMin
                                        + uiObj 
                                        - this->rgdwBase[this->rghoc[uiObj].pcaps->type] 
                                        - this->rghoc[uiObj].pcaps->DataIndexMin );

                        phum = UsageToUsageMap( DIMAKEUSAGEDWORD( 
                                this->rghoc[uiObj].pcaps->UsagePage, wUsage ) );
                        /*
                         *  Slightly odd loop structure to avoid incrementing 
                         *  uiObj on the last iteration.  This makes sure we 
                         *  don't miss anything in the outer loop and that 
                         *  uiObj relates to the alias we matched when testing 
                         *  for default semantic mappings.
                         */
                        if( phum || (uiObj+1 == this->df.dwNumObjs) 
                         || !this->rghoc[uiObj+1].pcaps->IsAlias )
                        {
                            break;
                        }
                        uiObj++;
                    } 
                    if( phum )
                    {
                        /*
                         *  Since the axis is recognixed up the count
                         */
                        iTypeAxes++;

                        /*
                         *  Find it's position keeping WinMM in mind.
                         */
                        if( ( phum->bPosAxis < 6 )
                          &&( this->rgiaxis[phum->bPosAxis] == -1 ) )
                        {
                            this->rgiaxis[phum->bPosAxis] = uiObjPrimary ;
                            *pdwType |= DIDFT_MAKEINSTANCE(phum->bPosAxis);
                        }
                        else if( ( phum->bPosAxis == 6 )
                               &&( this->rgiaxis[2] == -1 ) )
                        {
                            this->rgiaxis[2] = uiObjPrimary;
                            *pdwType |= DIDFT_MAKEINSTANCE(2);
                        }
                        else
                        {
                            *pdwType |= DIDFT_MAKEINSTANCE(iAxis);
                            this->rgiaxis[iAxis++] = uiObjPrimary ;
                        }

                        /*
                         *  While we know which usage is most recognizable, add in 
                         *  flags to help us refine the device type and save off 
                         *  flags for default semantic mapping of this axis.
                         */
                        this->rgbaxissemflags[DIDFT_GETINSTANCE(*pdwType)] = phum->bSemFlag;
                        pdwHints[DIDFT_GETINSTANCE(*pdwType)] = phum->dwSemHint;
                        dwTypeFlags |= phum->dwSemHint;
                    }
                    else
                    {
                        /*
                         *  Unfortunately, the current HID parser does not 
                         *  implement more unusual HID caps like "preferred 
                         *  state" so just assume any other axes are sliders.
                         */
                        if( this->rghoc[uiObj].pcaps->UsagePage == HID_USAGE_PAGE_SIMULATION )
                        {
                            if( wUsage == HID_USAGE_SIMULATION_CLUTCH )
                            {
                                dwTypeFlags |= DISEM_HINT_CLUTCH;
                                pdwHints[iAxis] = DISEM_HINT_CLUTCH;
                                this->rgbaxissemflags[iAxis] = DISEM_FLAGS_GET( DISEM_FLAGS_C );
                                iTypeAxes++;
                            }
                            else 
                            {
                                if( wUsage == HID_USAGE_SIMULATION_SHIFTER )
                                {
                                    dwTypeFlags |= DISEM_HINT_SHIFTER;
                                    pdwHints[iAxis] = DISEM_HINT_CLUTCH;
                                    iTypeAxes++;
                                }
                                else
                                {
                                    pdwHints[iAxis] = DISEM_HINT_SLIDER;
                                }
                                this->rgbaxissemflags[iAxis] = DISEM_FLAGS_GET( DISEM_FLAGS_S );
                            }
                        }
                        *pdwType |= DIDFT_MAKEINSTANCE(iAxis);
                        this->rgiaxis[iAxis++] = uiObjPrimary ;
                    }
                }
            }
            else 
            {
                /* 
                 *  We already checked that it's one of the above or a POV
                 *  so it must be a POV.
                 */
                AssertF( *pdwType & DIDFT_POV );
                *pdwType &= ~DIDFT_INSTANCEMASK;
                *pdwType |= DIDFT_MAKEINSTANCE(iPOV);
                this->rgipov[iPOV++] = uiObj;
                dwTypeFlags |= DISEM_HINT_POV;
            }
        }

        /*
         *  Now that we know about all the controls we base our type 
         *  decisions on, setup/validate the type and subtype.
         */

        AssertF( GET_DIDEVICE_TYPE( this->dwDevType ) != DI8DEVTYPE_KEYBOARD );

        if( GET_DIDEVICE_TYPE( this->dwDevType ) == DI8DEVTYPE_MOUSE )
        {
            if( dwTypeFlags & DISEM_HINT_ABSOLUTE )
            {
                this->dwDevType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_MOUSE,
                                                     DI8DEVTYPEMOUSE_ABSOLUTE)
                                 | DIDEVTYPE_HID;
            }
        }
        else
        {
            DWORD dwFlags2;
            JOYREGHWSETTINGS    hws;

            /*
             *  Get the old registry flags for initial hints in case this 
             *  device has more generic usages than it needed to have and 
             *  these have registry overrides.
             *  Only look for flags that are less generic to avoid a case 
             *  where an older DInput (or JoyHID) labelled this device 
             *  inadequately.
             *  If the call fails the buffer is zeroed
             */

            JoyReg_GetValue(this->hkType, REGSTR_VAL_JOYOEMDATA, 
                    REG_BINARY, &hws, cbX(hws));

            if( this->hkProp )
            {
                JoyReg_GetValue( this->hkProp, REGSTR_VAL_FLAGS2, REG_BINARY, 
                    &dwFlags2, cbX(dwFlags2) );
            }

            CAssertF( ( DISEM_HINT_THROTTLE >> 6 ) == JOY_HWS_HASZ );
            CAssertF( ( DISEM_HINT_POV >> 6 ) == JOY_HWS_HASPOV );

            dwTestType = GetValidDI8DevType( dwFlags2, iButton, dwTypeFlags >> 14 );

            if( dwTestType )
            {
                /*
                 *  If a valid override exists just use it
                 */
                this->dwDevType = dwTestType | DIDEVTYPE_HID;
            }
            else
            {

#ifdef XDEBUG
                /*
                 *  Fetch the value again in debug so we can report failures.
                 */
                if( this->hkProp )
                {
                    DWORD dwDbgFlags2;
                    JoyReg_GetValue( this->hkProp, REGSTR_VAL_FLAGS2, REG_BINARY, 
                        &dwDbgFlags2, cbX(dwDbgFlags2) );

                    if( GET_DIDEVICE_TYPEANDSUBTYPE( dwDbgFlags2 ) )
                    {
                        RPF( "Ignoring invalid type/subtype Flags2 value 0x%08x for HID", dwDbgFlags2 );
                    }
                }
#endif
                /*
                 *  This one is straight forward
                 */
                if( hws.dwFlags & JOY_HWS_ISHEADTRACKER )
                {
                    dwTestType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_SUPPLEMENTAL, 
                        DI8DEVTYPESUPPLEMENTAL_HEADTRACKER );
                    goto MNK_CheckType;
                }

                if( hws.dwFlags & JOY_HWS_ISYOKE )
                {
                    dwTestType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_FLIGHT,
                        DI8DEVTYPEFLIGHT_YOKE);
                    goto MNK_CheckType;
                }

                /*
                 *  Other registry flags only relate to the type so the 
                 *  subtype will still need to be found.
                 */
                if( hws.dwFlags & JOY_HWS_ISGAMEPAD )
                {
                    dwTestType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_GAMEPAD, DI8DEVTYPEGAMEPAD_STANDARD);
                    goto MNK_AdjustType;
                }
                
            }

            /*
             *  If we have somehow recognized this as a car controller, do any 
             *  processing necessary to munge the axes.
             *  Note we have to go through this path, even if the device has a 
             *  registry override type and subtype so that the right axes get 
             *  used for a device which has been changed into a car controller
             */
            if( ( hws.dwFlags & JOY_HWS_ISCARCTRL ) 
             || fCarController 
             || ( GET_DIDEVICE_TYPE( this->dwDevType ) == DI8DEVTYPE_DRIVING ) )
            {
                dwTestType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_DRIVING, 0);

                if( DISEM_HINT_X == ( dwTypeFlags & ( DISEM_HINT_X | DISEM_HINT_STEERING ) ) )
                {
                    /* 
                     *  If the device has no wheel but has an X axis 
                     *  use that instead.  The semantic flags are the 
                     *  same so just switch the hints.
                     */
                    dwTypeFlags ^= ( DISEM_HINT_X | DISEM_HINT_STEERING );
                }
                
                if( ( dwTypeFlags & DISEM_HINT_STEERING ) == 0 )
                {
                    /*
                     *  If there's still no steering wheel, make the type 
                     *  device so it can be processed into a supplemental
                     */
                    dwTestType = MAKE_DIDEVICE_TYPE( DI8DEVTYPE_DEVICE, 0 );
                }

                /*
                 *  In terms of HID usages, the common forms of pedals are:
                 *
                 *  1)  Accellerator and Brake
                 *  2)  Split Y axis, below center accel, above brake
                 *  3)  Z accel, Y brake
                 *  4)  Y accel, Rz brake
                 *  5)  Z accel, Rz brake
                 *
                 *  The first form is ideal so all that is needed is to 
                 *  make sure that any further processing does not disturb 
                 *  those axes whilst allowing for only one being exact.
                 *  The second form is assumed for a car controller with 
                 *  only a Y (in addition to a possible X).
                 *  The other two forms are distinguished either by an 
                 *  explicite registry flag or by the exact match of Y and 
                 *  Rz with none of Z, accel or brake for the latter form.
                 *  Since a real Z axis would be an oddity on a steering 
                 *  wheel, assume that the IHVs who have taken the Y, Rz 
                 *  path are not going to add a Z.
                 */
                
                
                /*
                 *  If there is an override to Y split pedals and a Y is 
                 *  present then set type and subtype and bypass the rest.
                 */

                switch( dwFlags2 & JOYTYPE_INFOMASK )
                {
                case JOYTYPE_INFODEFAULT:
                    break;
                case JOYTYPE_INFOYYPEDALS:
                    if( dwTypeFlags & DISEM_HINT_Y )
                    {
                        if( dwTypeFlags & DISEM_HINT_STEERING )
                        {
                            dwTestType = MAKE_DIDEVICE_TYPE( DI8DEVTYPE_DRIVING, DI8DEVTYPEDRIVING_COMBINEDPEDALS );
                        }
                        else
                        {
                            AssertF( GET_DIDEVICE_TYPEANDSUBTYPE( dwTestType ) == MAKE_DIDEVICE_TYPE( DI8DEVTYPE_DEVICE, 0 ) );
                        }
                        goto MNK_CheckType;
                    }
                    RPF( "JOYTYPE_INFOYYPEDALS set but device has no Y" );
                    break;

                case JOYTYPE_INFOZYPEDALS:
                    ReinterpretObject( this, pdwHints, cAxes, &dwTypeFlags, 
                        DISEM_HINT_Y, DISEM_HINT_BRAKE, 
                        DISEM_FLAGS_GET(DIAXIS_ANY_B_1), &GUID_RzAxis );

                    ReinterpretObject( this, pdwHints, cAxes, &dwTypeFlags, 
                        DISEM_HINT_Z, DISEM_HINT_ACCELERATOR, 
                        DISEM_FLAGS_GET(DIAXIS_ANY_A_1), &GUID_YAxis );

                    ReinterpretObject( this, pdwHints, cAxes, &dwTypeFlags, 
                        DISEM_HINT_THROTTLE, DISEM_HINT_ACCELERATOR, 
                        DISEM_FLAGS_GET(DIAXIS_ANY_A_1), &GUID_YAxis );
                    break;
                            
                case JOYTYPE_INFOYRPEDALS:
                    ReinterpretObject( this, pdwHints, cAxes, &dwTypeFlags, 
                        DISEM_HINT_RZ, DISEM_HINT_BRAKE, 
                        DISEM_FLAGS_GET(DIAXIS_ANY_B_1), &GUID_RzAxis );

                    ReinterpretObject( this, pdwHints, cAxes, &dwTypeFlags, 
                        DISEM_HINT_Y, DISEM_HINT_ACCELERATOR, 
                        DISEM_FLAGS_GET(DIAXIS_ANY_A_1), &GUID_YAxis );
                    break;
                            
                case JOYTYPE_INFOZRPEDALS:
                    ReinterpretObject( this, pdwHints, cAxes, &dwTypeFlags, 
                        DISEM_HINT_RZ, DISEM_HINT_BRAKE, 
                        DISEM_FLAGS_GET(DIAXIS_ANY_B_1), &GUID_RzAxis );

                    ReinterpretObject( this, pdwHints, cAxes, &dwTypeFlags, 
                        DISEM_HINT_Z, DISEM_HINT_ACCELERATOR, 
                        DISEM_FLAGS_GET(DIAXIS_ANY_A_1), &GUID_YAxis );

                    ReinterpretObject( this, pdwHints, cAxes, &dwTypeFlags, 
                        DISEM_HINT_THROTTLE, DISEM_HINT_ACCELERATOR, 
                        DISEM_FLAGS_GET(DIAXIS_ANY_A_1), &GUID_YAxis );
                    break;
                            
                default:
                    RPF( "Ignoring invalid JOYTYPE_INFO* Flags in 0x%08x", dwFlags2 & JOYTYPE_INFOMASK );
                }

                /*
                 *  In the absence of an override, first see if there's 
                 *  anything worth reinterpreting.
                 */
                if( 0 == ( dwTypeFlags & 
                    ( DISEM_HINT_Z | DISEM_HINT_ACCELERATOR | DISEM_HINT_THROTTLE
                    | DISEM_HINT_RZ | DISEM_HINT_BRAKE | DISEM_HINT_ACCELERATOR ) ) )
                {
                    if( ( dwTypeFlags & ( DISEM_HINT_STEERING | DISEM_HINT_Y ) )
                     == ( DISEM_HINT_STEERING | DISEM_HINT_Y ) )
                    {
                        /*
                         *  Combined pedal device
                         */
                        dwTestType = MAKE_DIDEVICE_TYPE( DI8DEVTYPE_DRIVING, DI8DEVTYPEDRIVING_COMBINEDPEDALS );
                    }
                    else
                    {
                        AssertF( GET_DIDEVICE_TYPEANDSUBTYPE( dwTestType ) == MAKE_DIDEVICE_TYPE( DI8DEVTYPE_DEVICE, 0 ) );
                    }
                    goto MNK_CheckType;
                }
                else if( ( DISEM_HINT_Y | DISEM_HINT_RZ ) == 
                    ( dwTypeFlags 
                    & ( DISEM_HINT_Y | DISEM_HINT_Z | DISEM_HINT_RZ | DISEM_HINT_BRAKE | DISEM_HINT_ACCELERATOR ) ) )
                {
                    /*
                     *  Although the axis GUIDs accel == Y and brake == RZ are 
                     *  already correct, use the common function to change the 
                     *  semantic flags or I'll forget to change the axis flags.
                     */
                    ReinterpretObject( this, pdwHints, cAxes, &dwTypeFlags, 
                        DISEM_HINT_Y, DISEM_HINT_ACCELERATOR, 
                        DISEM_FLAGS_GET(DIAXIS_ANY_A_1), &GUID_YAxis );

                    ReinterpretObject( this, pdwHints, cAxes, &dwTypeFlags, 
                        DISEM_HINT_RZ, DISEM_HINT_BRAKE, 
                        DISEM_FLAGS_GET(DIAXIS_ANY_B_1), &GUID_RzAxis );
                }
                else
                {
                    /*
                     *  Both of the other split pedal types have a Z-like accelerator
                     */
                    ReinterpretObject( this, pdwHints, cAxes, &dwTypeFlags, 
                        DISEM_HINT_Z, DISEM_HINT_ACCELERATOR, 
                        DISEM_FLAGS_GET(DIAXIS_ANY_A_1), &GUID_YAxis );

                    ReinterpretObject( this, pdwHints, cAxes, &dwTypeFlags, 
                        DISEM_HINT_THROTTLE, DISEM_HINT_ACCELERATOR, 
                        DISEM_FLAGS_GET(DIAXIS_ANY_A_1), &GUID_YAxis );


                    /*
                     *  Look for a brake on RZ before Y as a device with RZ 
                     *  is very likely to report a Y as well.
                     */
                    ReinterpretObject( this, pdwHints, cAxes, &dwTypeFlags, 
                        DISEM_HINT_RZ, DISEM_HINT_BRAKE, 
                        DISEM_FLAGS_GET(DIAXIS_ANY_B_1), &GUID_RzAxis );

                    ReinterpretObject( this, pdwHints, cAxes, &dwTypeFlags, 
                        DISEM_HINT_Y, DISEM_HINT_BRAKE, 
                        DISEM_FLAGS_GET(DIAXIS_ANY_B_1), &GUID_RzAxis );

                }

                /*
                 *  If somehow we have found an accellerator, make sure we 
                 *  don't expose any Y axes as well or the accellerator 
                 *  may get bumped from the default Y position.
                 */
                if( dwTypeFlags & DISEM_HINT_ACCELERATOR )
                {
                    int idx;

                    dwTypeFlags &= ~DISEM_HINT_Y;
                    for( idx = 0; idx < cAxes + 6; idx++ )
                    {
                        if( pdwHints[idx] == DISEM_HINT_Y )
                        {
                            pdwHints[idx] = DISEM_HINT_SLIDER;
                            dwTypeFlags |= DISEM_HINT_SLIDER;
                            this->rgbaxissemflags[idx] = DISEM_FLAGS_GET(DIAXIS_ANY_S_1);
                            this->df.rgodf[this->rgiaxis[idx]].pguid = &GUID_Slider;
                        }
                    }
                }
            }
            else
            {
                /*
                 *  Just take the default calculated from the HID caps (or the override)
                 */
                dwTestType = this->dwDevType;
#ifdef XDEBUG
                if( GET_DIDEVICE_TYPEANDSUBTYPE( dwTestType ) != GET_DIDEVICE_TYPEANDSUBTYPE( dwFlags2 ) )
                {
                    switch( GET_DIDEVICE_TYPE( dwTestType ) )
                    {
                    case DI8DEVTYPE_DEVICE:
                        AssertF( GET_DIDEVICE_SUBTYPE( dwTestType ) == 0 );
                        break;
                    case DI8DEVTYPE_JOYSTICK:
                        AssertF( GET_DIDEVICE_SUBTYPE( dwTestType ) == DI8DEVTYPEJOYSTICK_STANDARD );
                        break;
                    case DI8DEVTYPE_GAMEPAD:
                        AssertF( GET_DIDEVICE_SUBTYPE( dwTestType ) == DI8DEVTYPEGAMEPAD_STANDARD );
                        break;
                    default:
                        RPF( "Invalid type %02x", GET_DIDEVICE_TYPE( dwTestType ) );
                        AssertF( !"Invalid type!" );
                    }
                }
#endif

                /*
                 *  Check for Z axis behavior overrides
                 *  Since the default behavior is to always use a Z as a Z, 
                 *  only the override to slider is needed here.
                 */
                if( dwFlags2 & JOYTYPE_INFOZISSLIDER )
                {
                    if( dwTypeFlags & DISEM_HINT_Z )
                    {
                        /*
                         *  Reset the slider flag as ReinterpretObject does 
                         *  not change axes if the target this axis
                         */
                        dwTypeFlags &= ~DISEM_HINT_SLIDER;
                        ReinterpretObject( this, pdwHints, cAxes, &dwTypeFlags, 
                            DISEM_HINT_Z, DISEM_HINT_SLIDER, 
                            DISEM_FLAGS_GET(DIAXIS_ANY_S_1), &GUID_Slider );
                    }
                    else
                    {
                        RPF( "JOYTYPE_INFOZISSLIDER set but device has no Z" );
                    }
                }
            }

            /*
             *  If the dwFlags2 and dwTestType are the same, we are using a 
             *  registry override so don't try to refine it.
             */
            if( GET_DIDEVICE_TYPEANDSUBTYPE( dwTestType ) != GET_DIDEVICE_TYPEANDSUBTYPE( dwFlags2 ) )
            {
                if( dwTypeFlags & DISEM_HINT_STEERING )
                {
                    /*
                     *  If it has a steering wheel, it's a driving device
                     */
                    dwTestType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_DRIVING, 0 );
                }
                else if( ( dwTypeFlags & DISEM_HINT_SIXDOF ) == DISEM_HINT_SIXDOF )
                {
                    /*
                     *  Special case six degree of freedom devices
                     */
                    dwTestType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_1STPERSON, 
                        DI8DEVTYPE1STPERSON_SIXDOF );
                    goto MNK_CheckType;
                }

MNK_AdjustType:;
                /*
                 *  We should be left with only the following device types: 
                 *      joystick, gamepad, driving and device
                 *  For the first three only subtypes need to be found.
                 *  For DI8DEVTYPE_DEVICE some may be changed to 
                 *  DI8DEVTYPE_SUPPLEMENTAL if an appropriate subtype can be 
                 *  found.
                 */
                switch( GET_DIDEVICE_TYPE( dwTestType ) )
                {
                case DI8DEVTYPE_DEVICE:
                    /*
                     *  Since this is not a joystick or gamepad, only use it 
                     *  if it has the vehicle simulation controls we support.
                     */
                    if( ( dwTypeFlags & ( DISEM_HINT_ACCELERATOR | DISEM_HINT_BRAKE | DISEM_HINT_CLUTCH ) )
                     == ( DISEM_HINT_ACCELERATOR | DISEM_HINT_BRAKE | DISEM_HINT_CLUTCH ) )
                    {
                        dwTestType = MAKE_DIDEVICE_TYPE( DI8DEVTYPE_SUPPLEMENTAL, 
                            DI8DEVTYPESUPPLEMENTAL_THREEPEDALS );
                    }
                    else if( ( dwTypeFlags & ( DISEM_HINT_ACCELERATOR | DISEM_HINT_BRAKE ) )
                          == ( DISEM_HINT_ACCELERATOR | DISEM_HINT_BRAKE ) )
                    {
                        dwTestType = MAKE_DIDEVICE_TYPE( DI8DEVTYPE_SUPPLEMENTAL, 
                            DI8DEVTYPESUPPLEMENTAL_DUALPEDALS );
                    }
                    else if( dwTypeFlags & DISEM_HINT_THROTTLE ) 
                    {
                        dwTestType = MAKE_DIDEVICE_TYPE( DI8DEVTYPE_SUPPLEMENTAL, 
                            DI8DEVTYPESUPPLEMENTAL_THROTTLE );
                    }
                    else if( dwTypeFlags & DISEM_HINT_SHIFTER ) 
                    {
                        dwTestType = MAKE_DIDEVICE_TYPE( DI8DEVTYPE_SUPPLEMENTAL, 
                            DI8DEVTYPESUPPLEMENTAL_SHIFTER );
                    }
                    else if( dwTypeFlags & DISEM_HINT_RUDDER ) 
                    {
                        dwTestType = MAKE_DIDEVICE_TYPE( DI8DEVTYPE_SUPPLEMENTAL, 
                            DI8DEVTYPESUPPLEMENTAL_RUDDERPEDALS );
                    }
                    else
                    {
                        /* 
                         *  Totally unknown so leave it as device 
                         *  Allowing other devices to be treated as game 
                         *  controllers can cause HID controls on devices 
                         *  such as speakers to be included.
                         */
                    }
                    break;
                case DI8DEVTYPE_JOYSTICK:
                case DI8DEVTYPE_GAMEPAD:
                    if( ( dwTypeFlags & ( DISEM_HINT_X | DISEM_HINT_Y ) ) != ( DISEM_HINT_X | DISEM_HINT_Y ) )
                    {
                        dwTestType = MAKE_DIDEVICE_TYPE( DI8DEVTYPE_SUPPLEMENTAL, 
                            DI8DEVTYPESUPPLEMENTAL_UNKNOWN );
                    }
                    break;

                case DI8DEVTYPE_DRIVING:
                    if( ( dwTypeFlags & ( DISEM_HINT_ACCELERATOR | DISEM_HINT_BRAKE | DISEM_HINT_CLUTCH ) )
                     == ( DISEM_HINT_ACCELERATOR | DISEM_HINT_BRAKE | DISEM_HINT_CLUTCH ) )
                    {
                        dwTestType |= MAKE_DIDEVICE_TYPE( 0, DI8DEVTYPEDRIVING_THREEPEDALS );
                    }
                    else if( ( dwTypeFlags & ( DISEM_HINT_ACCELERATOR | DISEM_HINT_BRAKE ) )
                     == ( DISEM_HINT_ACCELERATOR | DISEM_HINT_BRAKE ) )
                    {
                        dwTestType |= MAKE_DIDEVICE_TYPE( 0, DI8DEVTYPEDRIVING_DUALPEDALS );
                    }
                    else if( dwTypeFlags & DISEM_HINT_Y  ) 
                    {
                        dwTestType |= MAKE_DIDEVICE_TYPE( 0, DI8DEVTYPEDRIVING_COMBINEDPEDALS );
                    }
                    else
                    {
                        dwTestType |= MAKE_DIDEVICE_TYPE( 0, DI8DEVTYPEDRIVING_LIMITED );
                    }
                    break;

                default:
                    AssertF( !"Unexpected device type" );
                }
        
            
                /*
                 *  Use the common function to make this a limited type if the 
                 *  number of buttons or flags dictate it.
                 *  Since the type and subtype are known to be valid, the return 
                 *  value should never be a failure (zero).
                 */
MNK_CheckType:;
                this->dwDevType = DIDEVTYPE_HID 
                    | GetValidDI8DevType( dwTestType, iButton, hws.dwFlags );
                AssertF( this->dwDevType & ~DIDEVTYPE_HID );
            }                        
        }

        /*
         *  Finally, mark all secondary aliases with the primary alias 
         *  instance and sqfl all the translations.
         */
        for(uiObj = 0; uiObj < this->df.dwNumObjs; uiObj++)
        {
            int iPrimary;
            D( iPrimary = -1; )

            if( this->rghoc[uiObj].pcaps )
            {
                if( !this->rghoc[uiObj].pcaps->IsAlias )
                {
                    iPrimary = this->df.rgodf[uiObj].dwType;
                }
                else
                {
                    D( AssertF( iPrimary != -1 ) );
                    /*
                     *  Prefix notices that iPrimary would be uninitialized if 
                     *  we find the alias before the primary but that should 
                     *  never happen as the object are sorted by definition.
                     */
                    if( DIDFT_GETTYPE(iPrimary) != DIDFT_GETTYPE(this->df.rgodf[uiObj].dwType) )
                    {
                        SquirtSqflPtszV(sqflHidParse | sqflError,
                            TEXT("CHid_MungeNotKeyboard: uiObj: %d dwType 0x%08x ")
                            TEXT("does not match primary 0x%08x"),
                            uiObj, this->df.rgodf[uiObj].dwType, iPrimary );
                    }
                    /*
                     *  There are very few attributes of an alias that are not 
                     *  overridden by the primary.
                     */
                    this->df.rgodf[uiObj].dwType = ( iPrimary & ~DIDFT_ALIASATTRMASK ) 
                                                 | ( this->df.rgodf[uiObj].dwType & DIDFT_ALIASATTRMASK );
                }
                SquirtSqflPtszV(sqflHidParse | sqflVerbose,
                                TEXT("CHid_MungeNotKeyboard: uiObj: %d set to dwType 0x%08x"),
                                uiObj, this->df.rgodf[uiObj].dwType );
            }
            else
            {
                SquirtSqflPtszV(sqflHidParse | sqflVerbose,
                                TEXT("CHid_MungeNotKeyboard: uiObj: %d  has pcaps == NULL"),
                                uiObj );                
            }
        }

    }
    else
    {
        FreePpv( &this->rgbaxissemflags );
    }
    FreePpv( &piRemap );

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | InitObjects |
 *
 *          Identify and initialize the objects supported by the device.
 *
 *****************************************************************************/

HRESULT INTERNAL
    CHid_InitObjects(PCHID this)
{
    HRESULT hres;
    UINT uiObj;
    UINT iType;
    /*
     *  Build the base array table to convert HID item indexes
     *  into DirectInput ID instance numbers.
     */
    AssertF(this->rgdwBase[HidP_Input] == 0);
    this->rgdwBase[HidP_Feature] = this->caps.NumberInputDataIndices;
    this->rgdwBase[HidP_Output ] = this->rgdwBase[HidP_Feature] +
                                   this->caps.NumberFeatureDataIndices;
    this->rgdwBase[HidP_Coll   ] = this->rgdwBase[HidP_Output ] +
                                   this->caps.NumberOutputDataIndices;


    /*
     *  Determine if this device supports PID 
     */
    this->fPIDdevice = FALSE;
    if(    this->caps.NumberOutputValueCaps != 0x0 
        && this->caps.NumberOutputButtonCaps != 0x0 )
    {
        NTSTATUS    ntStat;
        USHORT      cAButton=0x0;
        
        ntStat = HidP_GetSpecificButtonCaps
         (
                HidP_Output,                        // ReportType
                HID_USAGE_PAGE_PID,                 // UsagePage
                0x0,                                // Link Collection
                0x0,                                // Usage 
                NULL,                               // ValueCaps
                &cAButton,                          // ValueCapsLength
                this->ppd                           // PreparsedData
         );

        
        if(     ntStat == HIDP_STATUS_BUFFER_TOO_SMALL
            &&  cAButton > 0x2    // Is this enough for PID device ??   
            )
        {
            this->fPIDdevice = TRUE;
        }
     }


    /*
     *  Note that we must do axes first because that keeps
     *  everything aligned.
     *
     *  Warning, diem.c assumes axes come first.
     */
    hres = CHid_InitAxes(this);
    if(FAILED(hres))
    {
        goto done;
    }

    hres = CHid_InitButtons(this);
    if(FAILED(hres))
    {
        goto done;
    }

    hres = CHid_InitCollections(this);
    if(FAILED(hres))
    {
        goto done;
    }

    /*
     *  Round the data size up to the nearest DWORD.
     */
    this->df.dwDataSize = (this->df.dwDataSize + 3) & ~3;

    /*
     * Allocate memory for report ID enable flags
     *
     *  ISSUE-2001/05/12-MarcAnd  Memory allocations should be merged
     *  These memory blocks could be merged.  For most devices the total memory 
     *  needed is only one or two bytes so there may be better ways.
     */
    for( iType = HidP_Input; iType < HidP_Max; iType++ )
    {
        this->wMaxReportId[iType] += 1;
        hres = AllocCbPpv(this->wMaxReportId[iType], &this->pEnableReportId[iType]);
        if( FAILED(hres) )
        {
            goto done;
        }
    }



    AssertF(this->rgiobj == 0);

    /*
     *  Munge the data before trying to look up supplemental 
     *  information in the registry.
     */
    if(GET_DIDEVICE_TYPE(this->dwDevType) == DI8DEVTYPE_KEYBOARD)
    {
        CHid_MungeKeyboard(this);
    }
    else
    {
        CHid_MungeNotKeyboard(this);
    }

    /*
     *  Collect attributes for each object and add them to the
     *  device type code.  This allows the registry to enable
     *  things like force feedback.
     */
    for(uiObj = 0; uiObj < this->df.dwNumObjs; uiObj++)
    {
        CType_RegGetTypeInfo(this->hkType, &this->df.rgodf[uiObj], this->fPIDdevice);
        if( ( GET_DIDEVICE_TYPE(this->dwDevType) == DI8DEVTYPE_DRIVING )
         && ( this->df.rgodf[uiObj].dwFlags & DIDOI_FFACTUATOR )
         && ( this->df.rgodf[uiObj].pguid != &GUID_XAxis ) )
        {
            /*
             *  IHVs set FF attributes on non-FF axes for wheels because 
             *  first generation FF apps were only written to support joysticks.
             *  Since we now munge the various configurations of pedal axes to 
             *  report all split pedals in the same way, the fake Y axis can 
             *  land up on different axes, usually Slider0.  Rather than have 
             *  people code to these different fake axes, strip out actuator 
             *  status from any driving axis except the wheel.
             */
            this->df.rgodf[uiObj].dwFlags &= ~DIDOI_FFACTUATOR;
            this->df.rgodf[uiObj].dwType &= ~DIDFT_FFACTUATOR;
        }
    }

    #ifdef DEBUG
    for(uiObj = 0; uiObj < this->df.dwNumObjs; uiObj++)
    {
        PHIDGROUPCAPS pcaps;
        UINT uiObjReal =
            CHid_ObjFromType(this, this->df.rgodf[uiObj].dwType);
        pcaps = this->rghoc[uiObjReal].pcaps;
        if(pcaps)
        {
            AssertF(pcaps->dwSignature == HIDGROUPCAPS_SIGNATURE);
        }
        
        if( uiObjReal != uiObj )
        {
            RPF( "uiObj = 0x%08x, type = 0x%08x, exposed Obj = 0x%08x",
                uiObj, this->df.rgodf[uiObj].dwType, uiObjReal );
        }
        AssertF(CHid_ObjFromType(this, this->df.rgodf[uiObj].dwType)
                == uiObj);

        /*
         *  Anything that is DIDFT_AXIS must be a HID axis.  However,
         *  the converse is not true for the case of analog buttons.
         */
        AssertF(fLimpFF(this->df.rgodf[uiObj].dwType & DIDFT_AXIS,
                        pcaps->IsValue));

        SquirtSqflPtszV(sqfl | sqflVerbose,
                        TEXT("CHid_InitObj: uiObj = %02x, dwType = %08x"),
                        uiObj, this->df.rgodf[uiObj].dwType);

    }
    #endif

    hres = S_OK;

    done:;
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | InitParse |
 *
 *          Identify and initialize the data structures needed for
 *          parsing reports.
 *
 *****************************************************************************/

HRESULT INTERNAL
    CHid_InitParse(PCHID this)
{
    DWORD cb;
    HRESULT hres;

    /*
     *  Obtain the maximum number of HIDP_DATA structures
     *  that will be returned at one go.
     */

    this->hriIn .cdataMax = HidP_MaxDataListLength(HidP_Input ,  this->ppd);
    this->hriOut.cdataMax = HidP_MaxDataListLength(HidP_Output,  this->ppd);
    this->hriFea.cdataMax = HidP_MaxDataListLength(HidP_Feature, this->ppd);

    /*
     *  More annoyances.
     */
    this->hriIn .cbReport = this->caps.  InputReportByteLength;
    this->hriOut.cbReport = this->caps. OutputReportByteLength;
    this->hriFea.cbReport = this->caps.FeatureReportByteLength;

    /*
     *  Some trace squirties because HID is tricky.
     */

    SquirtSqflPtszV(sqflHidParse,
                    TEXT("CHid_InitParse: MaxDataListLength(Input)  = %d"),
                    this->hriIn.cdataMax);
    SquirtSqflPtszV(sqflHidParse,
                    TEXT("CHid_InitParse: MaxDataListLength(Output) = %d"),
                    this->hriOut.cdataMax);
    SquirtSqflPtszV(sqflHidParse,
                    TEXT("CHid_InitParse: MaxDataListLength(Feature)= %d"),
                    this->hriFea.cdataMax);
    SquirtSqflPtszV(sqflHidParse,
                    TEXT("CHid_InitParse: InputReportByteLength     = %d"),
                    this->caps.InputReportByteLength);
    SquirtSqflPtszV(sqflHidParse,
                    TEXT("CHid_InitParse: OutputReportByteLength    = %d"),
                    this->caps.OutputReportByteLength);
    SquirtSqflPtszV(sqflHidParse,
                    TEXT("CHid_InitParse: FeatureReportByteLength   = %d"),
                    this->caps.FeatureReportByteLength);

    /*
     *  Now allocate all the report-related memory.
     */
    this->cbPhys = this->df.dwDataSize;

    /*
     *  Allocating the memory is done in four phases.
     *
     *  1. Tally up how much memory we need,
     *  2. Allocate that memory,
     *  3. Dole out the memory we allocated,
     *  4. Check that we didn't mess up.
     *
     *  Since this is extremely error-prone (I've messed it up at least
     *  once), the work is hidden inside macros.
     *
     *  The macro THINGS expands to a series of THING()s, each of which
     *  specifies a field name and the size it should be.  Each time you
     *  want to iterate over the fields, use the THINGS macro.
     *
     *  (Yes, this is the same comment block as when we did this before.)
     *
     *  Note, the arrays of HIDP_DATA structures must be correctly
     *  aligned in some architechtures.
     */
    CAssertF( FIELD_OFFSET(CHID, hriIn.rgdata) == FIELD_OFFSET(CHID, pvGroup2) );

    #define THINGS()                                                        \
        THING(hriIn.rgdata,    cbCxX(this->hriIn.cdataMax, HIDP_DATA));     \
        THING(hriOut.rgdata,   cbCxX(this->hriOut.cdataMax, HIDP_DATA));    \
        THING(hriFea.rgdata,   cbCxX(this->hriFea.cdataMax, HIDP_DATA));    \
        THING(hriIn.pvReport,  this->hriIn.cbReport);                       \
        THING(hriOut.pvReport, this->hriOut.cbReport);                      \
        THING(hriFea.pvReport, this->hriFea.cbReport);                      \
        THING(pvPhys,          this->cbPhys);                               \
        THING(pvStage,         this->cbPhys);                               \

    /*
     *  Make a pass through the fields adding up the memory requirements.
     */
    #define THING(f, cbF)       cb += cbF
    cb = 0;
    THINGS();
    #undef THING

    hres = ReallocCbPpv(cb, &this->pvGroup2);

    if(SUCCEEDED(hres))
    {

        PV pv;

        /*
         *  Assert that the allocation is aligned
         */
        AssertF( !( ((UINT_PTR)this->pvGroup2) & ( MAX_NATURAL_ALIGNMENT - 1 ) ) );

        /*
         *  Make a pass through the fields carving up the memory block
         *  and handing out pieces of it.
         */
    #define THING(f, cbF) this->f = pv; pv = pvAddPvCb(pv, cbF)
        pv = this->pvGroup2;
        THINGS();
    #undef THING

        /*
         *  There should be no byte left over.
         */
        AssertF(pvAddPvCb(this->pvGroup2, cb) == pv);

    }

    #undef THINGS

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | InitParseData |
 *
 *          Post-init pass to set up all the data used by parsing.
 *
 *****************************************************************************/

HRESULT EXTERNAL
    CHid_InitParseData(PCHID this)
{
    HRESULT hres;
    UINT uiObj;

    /*
     *  Preinitialize the HIDP_DATA indices to -1 to indicate
     *  that they aren't there.  We must do this before we
     *  mess with AddDeviceData, which assumes that all the
     *  indices are properly set up.
     */
    for(uiObj = 0; uiObj < this->df.dwNumObjs; uiObj++)
    {
        this->rghoc[uiObj].idata = -1;
    }

    /*
     *  Now do some initialization of each object.
     */
    for(uiObj = 0; uiObj < this->df.dwNumObjs; uiObj++)
    {
        PHIDGROUPCAPS pcaps = this->rghoc[uiObj].pcaps;
        LPDIOBJECTDATAFORMAT podf = &this->df.rgodf[uiObj];

        /* 
         *  ISSUE-2001/03/13-MarcAnd  Should we panic if this assertion fails?
         */
        AssertF(pcaps);

        if(pcaps)
        {
            /*
             *  For input-like objects, we need to initialize the
             *  physical state fields to sane defaults so apps
             *  don't get confused if they issue a read before the first
             *  report arrives.
             *
             *  Buttons start out not pressed, which means we don't need
             *  to do anything since it's already zero-initialized.
             *
             *  Relative axes start out not moving, which means we don't need
             *  to do anything since it's already zero-initialized.
             *
             *  Absolute axes start out centered.
             *
             *  POVs start out neutral.
             *
             */

            /* No calibration for features as they are input / output */

            if(pcaps->type == HidP_Input )
            {
                LONG UNALIGNED * pl;

                pl = pvAddPvCb(this->pvPhys, podf->dwOfs);

                if(podf->dwType & DIDFT_ABSAXIS )
                {
                    if( this->rghoc[uiObj].pjrc->fRaw )
                        *pl = (this->rghoc[uiObj].pcaps->Logical.Min + this->rghoc[uiObj].pcaps->Logical.Max) / 2;
                    else
                        *pl = this->rghoc[uiObj].pjrc->lC;
                } else if(podf->dwType & DIDFT_POV)
                {
                    *pl = JOY_POVCENTERED;
                }
            }

            /*
             *  ISSUE-2001/03/13-MarcAnd output objects uninitialized
             *  For output-like objects, we would have liked to have set the 
             *  value to Null if possible to keep things vaguely sane.
             *  Unfortunately code like:
             *      if(HidP_IsOutputLike(pcaps->type))
             *      {
             *          CHid_AddDeviceData(this, uiObj,pcaps->Null);
             *      }
             *  Does not work!
             */
        }
    }

    hres = S_OK;

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | InitAttributes |
 *
 *          Pull out the <t HIDD_ATTRIBUTES> and squirrel away the
 *          information we like.  Doing this up front is important
 *          in case the device gets unplugged later and we lose the
 *          ability to talk to it.
 *
 *  @parm   PHIDD_ATTRIBUTES | pattr |
 *
 *          <t HIDD_ATTRIBUTES> containing attributes of device.
 *
 *****************************************************************************/

HRESULT EXTERNAL
    CHid_InitAttributes(PCHID this, PHIDD_ATTRIBUTES pattr)
{
    HRESULT hres;

    TCHAR tszType[20];
    #ifndef UNICODE
    WCHAR wszType[20];
    #endif
    int ctch;

    // Input report is disabled until we read flags2 from registry.
    this->fEnableInputReport = FALSE;
    this->fFlags2Checked = FALSE;

    this->ProductID = pattr->ProductID;
    this->VendorID = pattr->VendorID;

    AssertF(this->hkType == 0);

    if( ( this->VendorID == MSFT_SYSTEM_VID )
      &&( ( this->ProductID >= MSFT_SYSTEM_PID + JOY_HW_PREDEFMIN )
        &&( this->ProductID < MSFT_SYSTEM_PID + JOY_HW_PREDEFMAX ) ) )
    {
        /* 
         *  Predefined types don't have keys 
         */
    }
    else
    {
        /*
         *  The type key for HID devices is "VID_xxxx&PID_yyyy",
         *  mirroring the format used by plug and play.
         */
        ctch = wsprintf(tszType, VID_PID_TEMPLATE,
                        this->VendorID, this->ProductID);

        AssertF(ctch < cA(tszType));

        #ifdef UNICODE
        hres = JoyReg_OpenTypeKey(tszType, MAXIMUM_ALLOWED, REG_OPTION_NON_VOLATILE, &this->hkType);
        JoyReg_OpenPropKey(tszType, MAXIMUM_ALLOWED, REG_OPTION_NON_VOLATILE, &this->hkProp);
        /*
         * If we fail to open the prop key - we will continue to function with loss in functionality
         * Specifically no device images, etc
         */
        #else
        TToU(wszType, cA(wszType), tszType);
        hres = JoyReg_OpenTypeKey(wszType, MAXIMUM_ALLOWED, REG_OPTION_NON_VOLATILE, &this->hkType);
        JoyReg_OpenPropKey(wszType, MAXIMUM_ALLOWED, REG_OPTION_NON_VOLATILE, &this->hkProp);
        /*
         * If we fail to open the prop key - we will continue to function with loss in functionality
         * Specifically no device images, etc
         */

        #endif

        /*
         *  It is not a problem if we can't open the type key.
         *  The device will run suboptimally, but it will still run.
         */
        AssertF(fLeqvFF(SUCCEEDED(hres), this->hkType));

        
    }
    hres = S_OK;

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | CHid_DoPathAndIdMatch |
 *
 *          Given a device name, obtain the corresponding path
 *          ("device interface") associated with it, and check
 *          that it's the right string.
 *
 *  @parm   LPCTSTR | ptszId |
 *
 *          The device name.
 *
 *  @parm   LPCTSTR | ptszPath |
 *
 *          The path we should get back.
 *
 *****************************************************************************/

BOOL INTERNAL
    CHid_DoPathAndIdMatch(LPCTSTR ptszId, LPCTSTR ptszPath)
{
    GUID guidHid;
    HDEVINFO hdev;
    BOOL fRc;

    HidD_GetHidGuid(&guidHid);

    hdev = SetupDiGetClassDevs(&guidHid, ptszId, 0,
                               DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
    if(hdev != INVALID_HANDLE_VALUE)
    {
        SP_DEVICE_INTERFACE_DATA did;
        PSP_DEVICE_INTERFACE_DETAIL_DATA pdidd;

        /* 
         *  SetupDI requires that the caller initialize cbSize.
         */
        did.cbSize = cbX(did);

        if(SetupDiEnumDeviceInterfaces(hdev, 0, &guidHid, 0, &did))
        {
            pdidd      = NULL;
            if(DIHid_GetDevicePath(hdev, &did, &pdidd, NULL))
            {
                fRc = ( lstrcmpi(pdidd->DevicePath, ptszPath) == 0x0 );
                if( fRc == FALSE )
                {
                    SquirtSqflPtszV(sqflHidParse | sqflError,
                                    TEXT("pdidd->DevicePath = %s")
                                    TEXT("ptszPath = %s "),
                                    pdidd->DevicePath, ptszPath
                                   );
                }
                FreePv(pdidd);
            } else // GetDevicePath FAILED
            {
                fRc = FALSE;
                SquirtSqflPtszV(sqflHidParse,
                                TEXT("GetDevicePath FAILED"));
            }
        } else // SetupDiEnumDeviceInterface FAILED
        {
            fRc = FALSE;
            SquirtSqflPtszV(sqflHidParse,
                            TEXT("SetupDiEnumDeviceInterface FAILED"));
        }
        SetupDiDestroyDeviceInfoList(hdev);
    } else // SetupDiGetClassDevs FAILED
    {
        fRc = FALSE;
        SquirtSqflPtszV(sqflHidParse,
                        TEXT("SetupDiGetClassDevs FAILED"));
    }

    return fRc;
}



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | IsPolledDevice |
 *
 *          Returns true if this device has to be polled for input data
 *          False if this device supports event driven input 
 *
 *  @parm   HANDLE | hdev |
 *
 *          File Handle to a HID device
 *
 *****************************************************************************/

BOOL EXTERNAL CHid_IsPolledDevice( HANDLE hdev )
{

    /*
     *  To determine if a device is polled, we send it an IOCTL to set its 
     *  poll frequency.  If the device responds with a, huh! 
     *  (STATUS_INVALID_DEVICE_REQUEST) then we know the device is not polled.  
     *  On Win2k we use the poll interval value zero which is a special value 
     *  that signals HID that we want to do opportunistic polls rather than 
     *  polls on a background timer.  In this case, as long as polls are not 
     *  faster than the predefined minimum (currently 5ms) the poll will be 
     *  completed either with recent data or the result of an immediate poll.
     *  On Win98 Gold opportunistic polls are not implemented so we always 
     *  use HIDs background polling, with an interval set to keep the device 
     *  responsive without swamping the system.  To make sure we use a read 
     *  thread, rather than a blocking read, we have to treat this devices as 
     *  interrupt driven.
     *  HID makes this change the polling interval specific to our handle so 
     *  that other apps reading from this device will not be damaged.
     */
    BOOL    frc;
    ULONG   uPollingFreq;
    DWORD   cbRc;

#ifdef WINNT
    BOOL    fRet;
    uPollingFreq = 0;
#else
    uPollingFreq = 40;
#endif

    frc = DeviceIoControl (hdev,
                           IOCTL_HID_SET_POLL_FREQUENCY_MSEC,
                           &uPollingFreq, cbX(uPollingFreq),
                           &uPollingFreq, cbX(uPollingFreq),
                           &cbRc, NULL);
#ifdef WINNT
    if( frc )
    {
        SquirtSqflPtszV(sqflHidParse,
                        TEXT("CHid_IsPolledDevice: Opportunistic polling set") );
        fRet = TRUE;            
    } else
    {
        SquirtSqflPtszV(sqflHidParse,
                        TEXT("CHid_IsPolledDevice: NOT POLLED, LastError = 0x%x"),
                        GetLastError());
        fRet = FALSE;
    }
    return fRet;

#else
    return FALSE;
#endif

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HANDLE | CHid_OpenDevicePath |
 *
 *          Given a device name, open the device via its
 *          device interface.
 *
 *  @parm   LPCTSTR | ptszId |
 *
 *  @parm   DWORD | dwAttributes |
 *          
 *          Create File attributes 
 *
 *          The device name.
 *
 *****************************************************************************/

HANDLE EXTERNAL
    CHid_OpenDevicePath(PCHID this, DWORD dwAttributes)
{
    HANDLE hDev;

    hDev = CreateFile(this->ptszPath,
                   GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                   0,                /* no SECURITY_ATTRIBUTES */
                   OPEN_EXISTING,
                   dwAttributes, /* attributes */
                   0);               /* template */

    if( hDev == INVALID_HANDLE_VALUE )
    {
        SquirtSqflPtszV(sqflHidParse | sqflBenign,
            TEXT("Failed to open HID %s, le=%d"), this->ptszPath, GetLastError() );
    }

    this->IsPolledInput = CHid_IsPolledDevice(hDev);

    return hDev;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | GetHdevInfo |
 *
 *          Get information about the device that is kept in the
 *          HANDLE itself.  We create the handle, get the goo, and
 *          then close the handle.
 *
 *          The preparsed data is stashed into the <e CHid.ppd>
 *          field of the <t CHid> structure.
 *
 *  @parm   PHIDD_ATTRIBUTES | pattr |
 *
 *          Receives the <t HIDD_ATTRIBUTES> of the device.
 *
 *****************************************************************************/

BOOL INTERNAL
    CHid_GetHdevInfo(PCHID this, PHIDD_ATTRIBUTES pattr)
{
    HANDLE hdev;
    BOOL fRc = FALSE;

    hdev = CHid_OpenDevicePath(this, FILE_FLAG_OVERLAPPED);
    if(hdev != INVALID_HANDLE_VALUE)
    {
        pattr->Size = cbX(*pattr);
        if( HidD_GetAttributes(hdev, pattr) )
        {
            if( HidD_GetPreparsedData(hdev, &this->ppd) )
            {
                fRc = TRUE;
            }
            else
            {
                RPF( "HidD_GetPreparsedData failed, le=%d", GetLastError() );
            }
        }
        else
        {
            RPF( "HidD_GetAttributes failed, le=%d", GetLastError() );
        }
        CloseHandle(hdev);
    }
    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | Init |
 *
 *          Initialize the object.
 *
 *****************************************************************************/

HRESULT EXTERNAL
    CHid_Init(PCHID this, REFGUID rguid)
{
    HRESULT hres = E_FAIL;
    PHIDDEVICEINFO phdi;
    EnterProc(CHid_Init, (_ "p", this));

    SquirtSqflPtszV(sqflHidParse,
                    TEXT("CHid_Init: Starting %08x"), rguid->Data1);

    this->df.dwSize = cbX(DIDATAFORMAT);
    this->df.dwObjSize = cbX(DIOBJECTDATAFORMAT);

    AssertF(this->df.dwDataSize == 0);
    AssertF(this->df.rgodf == 0);
    AssertF(this->df.dwFlags == 0);
    AssertF(this->df.dwNumObjs == 0);
    AssertF(this->dwAxes == 0);
    AssertF(this->dwButtons == 0);
    AssertF(this->dwCollections == 0);

    this->idJoy = -1;                   /* Unknown associated VJOYD device */
    this->hdev = INVALID_HANDLE_VALUE;
    this->hdevEm = INVALID_HANDLE_VALUE;

    this->diHacks.nMaxDeviceNameLength = MAX_PATH;

    DllEnterCrit();

    phdi = phdiFindHIDInstanceGUID(rguid);

    if(phdi)
    {
        this->dwDevType = phdi->osd.dwDevType;
        this->idJoy = phdi->idJoy;

        /*
         *  Dup the registry key so we can hang onto it after
         *  the original has been closed.  If the RegOpenKeyEx
         *  fails, the value of this->hkInstType will stay zero
         *  so we won't run with garbage.
         */
        AssertF(this->hkInstType == 0);

        hres = hresMumbleKeyEx(phdi->hk, 
                               TEXT("Type"), 
                               DI_KEY_ALL_ACCESS, 
                               REG_OPTION_NON_VOLATILE, 
                               &this->hkInstType);
        /*
         *  Dup the paths and stuff.
         */
        hres = hresDupPtszPptsz(phdi->pdidd->DevicePath, &this->ptszPath);

        if(SUCCEEDED(hres))
        {
            hres = hresDupPtszPptsz(phdi->ptszId, &this->ptszId);
        }
    }

    /*
     *  Get out of the critical section as quickly as possible.
     *  Note phdi is invalid once we leave the critical section however 
     *  we can safely use is as a flag that the GUID was found.
     */
    DllLeaveCrit();

    if(phdi)
    {
        if(SUCCEEDED(hres))
        {
            HIDD_ATTRIBUTES attr;
            
            if( !CHid_GetHdevInfo(this, &attr) )
            {
                SquirtSqflPtszV(sqflHidParse | sqflError,
                    TEXT("%hs: CHid_GetHdevInfo failed"), s_szProc );
                hres = E_FAIL;
            }
            else if( FAILED(HidP_GetCaps(this->ppd, &this->caps) ) )
            {
                SquirtSqflPtszV(sqflHidParse | sqflError,
                    TEXT("%hs: HidP_GetCaps failed, le=%d"), s_szProc, GetLastError() );
                hres = E_FAIL;
            }
            else if( !CHid_DoPathAndIdMatch(this->ptszId, this->ptszPath) )
            {
                SquirtSqflPtszV(sqflHidParse | sqflError,
                    TEXT("%hs: Path and HW ID do not match"), s_szProc );
                hres = E_FAIL;
            }
            else
            {

                if(SUCCEEDED(hres = CHid_InitAttributes(this, &attr)) &&
                   SUCCEEDED(hres = CHid_AllocObjectMemory(this)) &&
                   SUCCEEDED(hres = CHid_InitObjects(this)) &&
                   SUCCEEDED(hres = CHid_InitParse(this)) &&
                   SUCCEEDED(hres = CHid_InitParseData(this)))
                {

                    VXDDEVICEFORMAT devf;
                    UINT uiCal;

                    /*
                     *  Load calibration information, and if there were
                     *  no calibratable items, then wipe out this->pjrcNext
                     *  to indicate that there is no need to watch for
                     *  recalibration messages.
                     */
                    uiCal = CHid_LoadCalibrations(this);
                    if(uiCal == 0)
                    {
                        this->pjrcNext = NULL;
                    }

                    

                    /*
                     *  Remember to do this after we have
                     *  created the data format.
                     */
                    devf.cbData  = this->df.dwDataSize;
                    devf.cObj    = this->df.dwNumObjs;
                    devf.rgodf   = this->df.rgodf;
                    /* 
                     *  Note, dwExtra is 64 bits on 64 bit platforms
                     *  should update the name one day.
                     */
                    devf.dwExtra = (UINT_PTR)this;
                    devf.dwEmulation = 0;

                    hres = Hel_HID_CreateInstance(&devf, &this->pvi);  

                    /* Polled input devices may not be attached */
                    if(this->IsPolledInput)
                    {
                        HANDLE hdev;
                        PBUSDEVICEINFO  pbdi;

                        hdev = CHid_OpenDevicePath(this, 0x0);

                        if( hdev != INVALID_HANDLE_VALUE )
                        {
                            int i;
                            BOOL frc;
                            DWORD cbRead;                        
                            BOOL bPresent = FALSE;

                            for( i=0x0; i < FAILED_POLL_THRESHOLD; i++ )
                            {
                                frc = ReadFile(hdev, this->hriIn.pvReport,
                                               this->hriIn.cbReport, &cbRead, 0x0  );

                                if( frc != 0x0  &&
                                    cbRead == this->hriIn.cbReport )
                                {
                                    bPresent = TRUE;
                                    break;
                                } else
                                {
                                    Sleep(10);
                                    
                                    SquirtSqflPtszV(sqflHidParse | sqflVerbose,
                                                    TEXT("CHid_Init: ReadFailed, LastError = 0x%x"),
                                                    GetLastError());
                                
                                }
                            }

                            CloseHandle(hdev);

                            if( bPresent == FALSE )
                            {
                                this->pvi->fl |=  VIFL_UNPLUGGED;                            
                                SquirtSqflPtszV(sqflHidParse | sqflBenign,
                                                TEXT("%hs: ReadFailed, setting to unplugged"), s_szProc );
                            }

                            DllEnterCrit();

                            phdi = phdiFindHIDDeviceInterface(this->ptszPath);
                            AssertF(phdi != NULL);
                            pbdi = pbdiFromphdi(phdi);

                            DllLeaveCrit();


                            if( pbdi != NULL )
                            {
                                if( pbdi->fDeleteIfNotConnected == TRUE )
                                {
                                    if( bPresent == FALSE )
                                    {
                                        lstrcpy( g_tszIdLastRemoved, pbdi->ptszId );
                                        g_tmLastRemoved = GetTickCount();

                                        DIBusDevice_Remove(pbdi);
                                    }
                                    pbdi->fDeleteIfNotConnected = FALSE;
                                }
                            }
                        } else
                        {
                            // Could not Open the device 
                            this->pvi->fl |=  VIFL_UNPLUGGED;
                        }
                    }
                }
            } 
        }
    } else
    {
        // Squirt: device mysteriously gone
        hres = DIERR_DEVICENOTREG;
    }

    SquirtSqflPtszV(sqflHidParse,
                    TEXT("CHid_Init: Ending %08x"), rguid->Data1);

    ExitOleProc();
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dihidusg.c ===
/*****************************************************************************
 *
 *  DIHidUsg.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Mapping between GUIDs and HID usages.
 *
 *  Contents:
 *
 *      UsageToGuid
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflHidUsage

#pragma BEGIN_CONST_DATA

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global HIDUSAGEMAP | c_rghum[] |
 *
 *          Mapping between GUIDs and HID usages for one-to-one mappings.
 *
 *****************************************************************************/

#ifndef DISEM_FLAGS_0
#define DISEM_FLAGS_0 0
#endif

#define MAKEHUM(Page, Usage, PosAxis, SemFlag, Guid)        \
    {   DIMAKEUSAGEDWORD(HID_USAGE_PAGE_##Page,             \
                         HID_USAGE_##Page##_##Usage),       \
        PosAxis,                                            \
        DISEM_FLAGS_GET(DISEM_FLAGS_##SemFlag),             \
        0,0,                                                \
        DISEM_HINT_##Usage,                                 \
        &Guid,                                              \
    }                                                       \


HIDUSAGEMAP c_rghum[] = {
    MAKEHUM(GENERIC,    X,          0,  X,  GUID_XAxis),
    MAKEHUM(GENERIC,    Y,          1,  Y,  GUID_YAxis),
    MAKEHUM(GENERIC,    Z,          2,  Z,  GUID_ZAxis),
    MAKEHUM(GENERIC,    WHEEL,      2,  Z,  GUID_ZAxis),
    MAKEHUM(GENERIC,    RX,         3,  V,  GUID_RxAxis),
    MAKEHUM(GENERIC,    RY,         4,  U,  GUID_RyAxis),
    MAKEHUM(GENERIC,    RZ,         5,  R,  GUID_RzAxis),
    MAKEHUM(GENERIC,    HATSWITCH,  7,  0,  GUID_POV),

    MAKEHUM(GENERIC,    SLIDER,     6,  S,  GUID_Slider),
    MAKEHUM(GENERIC,    DIAL,       6,  S,  GUID_Slider),

    MAKEHUM(SIMULATION, STEERING,   0,  X,  GUID_XAxis),
    MAKEHUM(SIMULATION, ACCELERATOR,1,  A,  GUID_YAxis),
    MAKEHUM(SIMULATION, BRAKE,      5,  B,  GUID_RzAxis),
    MAKEHUM(SIMULATION, RUDDER,     5,  R,  GUID_RzAxis),
    MAKEHUM(SIMULATION, THROTTLE,   6,  A,  GUID_Slider),
    MAKEHUM(GAME,       POV,        7,  0,  GUID_POV),
};

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   PCGUID | UsageToUsageMap |
 *
 *          Takes some HID usage and usage page information and
 *          returns a pointer to a <t HIDUSAGEMAP> that describes
 *          how we should treat it.
 *
 *          If the type is not recognized, then <c NULL> is returned.
 *
 *  @parm   DWORD | dwUsage |
 *
 *          Usage page and usage to convert.  This should be a <t DWORD>
 *          formed using DIMAKEUSAGEDWORD on the component <t USAGE> values.
 *
 *****************************************************************************/

PHIDUSAGEMAP EXTERNAL
UsageToUsageMap(DWORD dwUsage)
{
    PHIDUSAGEMAP phum;
    int   ihum;

    for (ihum = 0; ihum < cA(c_rghum); ihum++) {
        if (c_rghum[ihum].dwUsage == dwUsage) {
            phum = &c_rghum[ihum];
            goto done;
        }
    }

    phum = 0;

done:;
    if( phum )
    {
        SquirtSqflPtszV(sqflHidUsage | sqflVerbose,
                        TEXT("UsageToUsageMap: mapped 0x%04x:0x%04x to index %d"),
                            HIWORD( dwUsage ), LOWORD( dwUsage ), ihum );
    }
    else
    {
        SquirtSqflPtszV(sqflHidUsage | sqflVerbose,
                        TEXT("UsageToUsageMap: failed to map 0x%04x:0x%04x"),
                            HIWORD( dwUsage ), LOWORD( dwUsage ) );
    }

    return phum;
}


#if 0
// After we fixed Windows bug 357943, this function is no longer needed.
// But keep here for sometime just in case...
//
/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   DWORD | GuidToUsage |
 *
 *          Map Guid to Usage
 *
 *          If the guid is not recognized, then 0 is returned.
 *
 *  @parm   PCGUID | pguid |
 *
 *          guid to map
 *
 *****************************************************************************/

DWORD EXTERNAL
GuidToUsage(PCGUID pguid)
{
    DWORD dwUsage;
    int   ihum;

    for (ihum = 0; ihum < cA(c_rghum); ihum++) {
        if ( IsEqualGUID( c_rghum[ihum].pguid, pguid ) ) {
            dwUsage = c_rghum[ihum].dwUsage;
            goto done;
        }
    }

    dwUsage = 0;

done:;
    return dwUsage;
}
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   UINT | GetHIDString |
 *
 *          Given a HID usage page and usage, obtain a generic string
 *          that describes it if we recognize it.
 *
 *  @parm   DWORD | Usage |
 *
 *          Usage number to convert.  This is a <t DWORD> instead of
 *          a <t USAGE> because you aren't supposed to pass short types
 *          as parameters to functions.
 *
 *  @parm   DWORD | UsagePage |
 *
 *          Usage page to convert.
 *
 *  @parm   LPWSTR | pwszBuf |
 *
 *          Buffer to receive string.
 *
 *  @parm   UINT | cwch |
 *
 *          Size of buffer.
 *
 *  @returns
 *
 *          Returns the number of characters retrieved, or zero
 *          if no string was obtained.
 *
 *****************************************************************************/

/*
 *  Maps usage pages to string groups.  Each string group is 512 strings long.
 *  Zero means "No string group".
 */
UINT c_mpuiusagePage[] = {
    0,                          /* Invalid */
    IDS_PAGE_GENERIC,           /* HID_USAGE_PAGE_GENERIC   */
    IDS_PAGE_VEHICLE,           /* HID_USAGE_PAGE_SIMULATION */
    IDS_PAGE_VR,                /* HID_USAGE_PAGE_VR        */
    IDS_PAGE_SPORT,             /* HID_USAGE_PAGE_SPORT     */
    IDS_PAGE_GAME,              /* HID_USAGE_PAGE_GAME      */
    0,                          /* ???????????????????????  */
    IDS_PAGE_KEYBOARD,          /* HID_USAGE_PAGE_KEYBOARD  */
    IDS_PAGE_LED,               /* HID_USAGE_PAGE_LED       */
    0,                          /* HID_USAGE_PAGE_BUTTON    */
    0,                          /* HID_USAGE_PAGE_ORDINAL   */
    IDS_PAGE_TELEPHONY,         /* HID_USAGE_PAGE_TELEPHONY */
    IDS_PAGE_CONSUMER,          /* HID_USAGE_PAGE_CONSUMER  */
    IDS_PAGE_DIGITIZER,         /* HID_USAGE_PAGE_DIGITIZER */
    0,                          /* ???????????????????????  */
    IDS_PAGE_PID,               /* HID_USAGE_PAGE_PID       */
};

UINT EXTERNAL
GetHIDString(DWORD Usage, DWORD UsagePage, LPWSTR pwszBuf, UINT cwch)
{
    UINT uiRc;

    if (UsagePage < cA(c_mpuiusagePage) &&
        c_mpuiusagePage[UsagePage] &&
        Usage < 512) {
        uiRc = LoadStringW(g_hinst, c_mpuiusagePage[UsagePage] + Usage,
                           pwszBuf, cwch);

         SquirtSqflPtszV(sqflHidUsage | sqflBenign,
                        TEXT("[%s]\nName=%s\n Usage=%d \n UsagePage=%d"),
                            pwszBuf, pwszBuf, Usage, UsagePage );

    } else {
        uiRc = 0;
    }
    return uiRc;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | InsertCollectionNumber |
 *
 *          Prefix the collection number on the existing string.
 *
 *  @parm   UINT | icoll |
 *
 *          Collection number to be prefixed.
 *
 *          (Actually, it's placed wherever the string resource
 *          tells us, to allow for localization.)
 *
 *  @parm   LPWSTR | pwsz |
 *
 *          Output buffer assumed to be of size MAX_PATH.
 *
 *****************************************************************************/

void EXTERNAL
InsertCollectionNumber(UINT icoll, LPWSTR pwszBuf)
{
    TCHAR tsz[MAX_PATH];
    TCHAR tszFormat[64];
#ifndef UNICODE
    TCHAR tszOut[MAX_PATH];
#endif
    int ctch;

    ctch = LoadString(g_hinst, IDS_COLLECTIONTEMPLATEFORMAT,
                      tszFormat, cA(tszFormat));

    /*
     *  Make sure the combined format and collection name
     *  don't overflow the buffer.  The maximum length of
     *  the stringification of icoll is 65534 because we
     *  allow only 16 bits worth of DIDFT_INSTANCEMASK.
     *
     *  We also have to put it into a holding buffer because
     *  pwszBuf is about to be smashed by the upcoming wsprintf.
     */
    UToT(tsz, cA(tsz) - ctch, pwszBuf);

#ifdef UNICODE
    wsprintfW(pwszBuf, tszFormat, icoll, tsz);
#else
    wsprintfA(tszOut, tszFormat, icoll, tsz);
    TToU(pwszBuf, MAX_PATH, tszOut);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dijoyhid.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dijoyhid.h
 *  Content:    DirectInput internal include file JoyHid mapping
 *
 ***************************************************************************/

#ifndef DIJOYHID_H
#define DIJOYHID_H

#define MIN_PERIOD         10  /* minimum polling period */
#define MAX_PERIOD         1000  /* maximum polling period */

typedef struct tag_USAGES {
	DWORD dwUsage;
    DWORD dwFlags;
    DWORD dwCaps;
    DWORD dwAxisPos;
} USAGES;

#define USAGE_SENTINAL  { 0x0, 0x0, 0x0  }

enum eControls {			// Index list for supported joystick axes
	ecX=0x0, ecY, ecZ, ecRz, ecRy, ecRx, ecEnd
};


#ifndef HID_USAGE_SIMULATION
#define	HID_USAGE_SIMULATION_STEERING       ((USAGE) 0xC8)
#endif

#ifndef HID_USAGE_SIMULATION_ACCELERATOR 
#define	HID_USAGE_SIMULATION_ACCELERATOR    ((USAGE) 0xC4)
#endif

#ifndef HID_USAGE_SIMULATION_BRAKE
#define	HID_USAGE_SIMULATION_BRAKE          ((USAGE) 0xC5)
#endif

/*
 * keep the following dwAxisPos as ascending.
 */
USAGES AxesUsages[] = {
    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_GENERIC,    HID_USAGE_GENERIC_X),              0x0,          0x0         , 0 },  // X
    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_SIMULATION, HID_USAGE_SIMULATION_STEERING),    0x0,          0x0         , 0 },

    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_GENERIC,    HID_USAGE_GENERIC_Y),              0x0,          0x0         , 1 },  // Y
    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_SIMULATION, HID_USAGE_SIMULATION_ACCELERATOR), 0x0,          0x0         , 1 },

    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_GENERIC,    HID_USAGE_GENERIC_Z),              JOY_HWS_HASZ, JOYCAPS_HASZ, 2 },  // Z
    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_GENERIC,    HID_USAGE_GENERIC_SLIDER),         JOY_HWS_HASZ, JOYCAPS_HASZ, 2 },
    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_SIMULATION, HID_USAGE_SIMULATION_THROTTLE),    JOY_HWS_HASZ, JOYCAPS_HASZ, 2 },
    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_SIMULATION, HID_USAGE_GENERIC_DIAL),           JOY_HWS_HASZ, JOYCAPS_HASZ, 2 },
    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_GENERIC,    HID_USAGE_GENERIC_WHEEL),          JOY_HWS_HASZ, JOYCAPS_HASZ, 2 },
    
    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_SIMULATION, HID_USAGE_SIMULATION_RUDDER),      JOY_HWS_HASR, JOYCAPS_HASR, 3 },
    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_GENERIC,    HID_USAGE_GENERIC_RZ),             JOY_HWS_HASR, JOYCAPS_HASR, 3 },  // R
    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_SIMULATION, HID_USAGE_SIMULATION_BRAKE),       JOY_HWS_HASR, JOYCAPS_HASR, 3 },
    
    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_GENERIC,    HID_USAGE_GENERIC_RY),             JOY_HWS_HASU, JOYCAPS_HASU, 4 },  // U
    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_SIMULATION, HID_USAGE_SIMULATION_THROTTLE),    JOY_HWS_HASU, JOYCAPS_HASU, 4 },
    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_GENERIC,    HID_USAGE_GENERIC_SLIDER),         JOY_HWS_HASU, JOYCAPS_HASU, 4 },
    
    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_GENERIC,    HID_USAGE_GENERIC_RX),             JOY_HWS_HASV, JOYCAPS_HASV, 5 },  // V
    
    USAGE_SENTINAL
};


USAGES CheckHatswitch[] = {
    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_GENERIC,    HID_USAGE_GENERIC_HATSWITCH)  , JOY_HWS_HASPOV, JOYCAPS_HASPOV },  // ecHatswitch
    USAGE_SENTINAL
};

#endif // DIJOYHID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dijoyreg.h ===
/*****************************************************************************
 *
 *  DIJoyReg.h
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Registry-related snippets from the Windows 95 mmddk.h file.
 *      We must steal it because the Windows NT mmddk.h file does not
 *      contain the registry settings.  (Sigh.)
 *
 *****************************************************************************/

#include <regstr.h>

/* pre-defined joystick types */
#define JOY_HW_NONE                     0
#define JOY_HW_CUSTOM                   1
#define JOY_HW_2A_2B_GENERIC            2
#define JOY_HW_2A_4B_GENERIC            3
#define JOY_HW_2B_GAMEPAD               4
#define JOY_HW_2B_FLIGHTYOKE            5
#define JOY_HW_2B_FLIGHTYOKETHROTTLE    6
#define JOY_HW_3A_2B_GENERIC            7
#define JOY_HW_3A_4B_GENERIC            8
#define JOY_HW_4B_GAMEPAD               9
#define JOY_HW_4B_FLIGHTYOKE            10
#define JOY_HW_4B_FLIGHTYOKETHROTTLE    11
#define JOY_HW_TWO_2A_2B_WITH_Y         12
#define JOY_HW_LASTENTRY                13

/* calibration flags */
#define JOY_ISCAL_XY            0x00000001l     /* XY are calibrated */
#define JOY_ISCAL_Z             0x00000002l     /* Z is calibrated */
#define JOY_ISCAL_R             0x00000004l     /* R is calibrated */
#define JOY_ISCAL_U             0x00000008l     /* U is calibrated */
#define JOY_ISCAL_V             0x00000010l     /* V is calibrated */
#define JOY_ISCAL_POV           0x00000020l     /* POV is calibrated */

/* point of view constants */
#define JOY_POV_NUMDIRS          4
#define JOY_POVVAL_FORWARD       0
#define JOY_POVVAL_BACKWARD      1
#define JOY_POVVAL_LEFT          2
#define JOY_POVVAL_RIGHT         3

/* Specific settings for joystick hardware */
#define JOY_HWS_HASZ            0x00000001l     /* has Z info? */
#define JOY_HWS_HASPOV          0x00000002l     /* point of view hat present */
#define JOY_HWS_POVISBUTTONCOMBOS 0x00000004l   /* pov done through combo of buttons */
#define JOY_HWS_POVISPOLL       0x00000008l     /* pov done through polling */
#define JOY_HWS_ISYOKE          0x00000010l     /* joystick is a flight yoke */
#define JOY_HWS_ISGAMEPAD       0x00000020l     /* joystick is a game pad */
#define JOY_HWS_ISCARCTRL       0x00000040l     /* joystick is a car controller */
/* X defaults to J1 X axis */
#define JOY_HWS_XISJ1Y          0x00000080l     /* X is on J1 Y axis */
#define JOY_HWS_XISJ2X          0x00000100l     /* X is on J2 X axis */
#define JOY_HWS_XISJ2Y          0x00000200l     /* X is on J2 Y axis */
/* Y defaults to J1 Y axis */
#define JOY_HWS_YISJ1X          0x00000400l     /* Y is on J1 X axis */
#define JOY_HWS_YISJ2X          0x00000800l     /* Y is on J2 X axis */
#define JOY_HWS_YISJ2Y          0x00001000l     /* Y is on J2 Y axis */
/* Z defaults to J2 Y axis */
#define JOY_HWS_ZISJ1X          0x00002000l     /* Z is on J1 X axis */
#define JOY_HWS_ZISJ1Y          0x00004000l     /* Z is on J1 Y axis */
#define JOY_HWS_ZISJ2X          0x00008000l     /* Z is on J2 X axis */
/* POV defaults to J2 Y axis, if it is not button based */
#define JOY_HWS_POVISJ1X        0x00010000l     /* pov done through J1 X axis */
#define JOY_HWS_POVISJ1Y        0x00020000l     /* pov done through J1 Y axis */
#define JOY_HWS_POVISJ2X        0x00040000l     /* pov done through J2 X axis */
/* R defaults to J2 X axis */
#define JOY_HWS_HASR            0x00080000l     /* has R (4th axis) info */
#define JOY_HWS_RISJ1X          0x00100000l     /* R done through J1 X axis */
#define JOY_HWS_RISJ1Y          0x00200000l     /* R done through J1 Y axis */
#define JOY_HWS_RISJ2Y          0x00400000l     /* R done through J2 X axis */
/* U & V for future hardware */
#define JOY_HWS_HASU            0x00800000l     /* has U (5th axis) info */
#define JOY_HWS_HASV            0x01000000l     /* has V (6th axis) info */

/* Usage settings */
#define JOY_US_HASRUDDER        0x00000001l     /* joystick configured with rudder */
#define JOY_US_PRESENT          0x00000002l     /* is joystick actually present? */
#define JOY_US_ISOEM            0x00000004l     /* joystick is an OEM defined type */

/* struct for storing x,y, z, and rudder values */
typedef struct joypos_tag {
    DWORD       dwX;
    DWORD       dwY;
    DWORD       dwZ;
    DWORD       dwR;
    DWORD       dwU;
    DWORD       dwV;
} JOYPOS, FAR *LPJOYPOS;

/* struct for storing ranges */
typedef struct joyrange_tag {
    JOYPOS      jpMin;
    JOYPOS      jpMax;
    JOYPOS      jpCenter;
} JOYRANGE,FAR *LPJOYRANGE;

typedef struct joyreguservalues_tag {
    DWORD       dwTimeOut;      /* value at which to timeout joystick polling */
    JOYRANGE    jrvRanges;      /* range of values app wants returned for axes */
    JOYPOS      jpDeadZone;     /* area around center to be considered
                                   as "dead". specified as a percentage
                                   (0-100). Only X & Y handled by system driver */
} JOYREGUSERVALUES, FAR *LPJOYREGUSERVALUES;

typedef struct joyreghwsettings_tag {
    DWORD       dwFlags;
    DWORD       dwNumButtons;           /* number of buttons */
} JOYREGHWSETTINGS, FAR *LPJOYHWSETTINGS;

/* range of values returned by the hardware (filled in by calibration) */
typedef struct joyreghwvalues_tag {
    JOYRANGE    jrvHardware;            /* values returned by hardware */
    DWORD       dwPOVValues[JOY_POV_NUMDIRS];/* POV values returned by hardware */
    DWORD       dwCalFlags;             /* what has been calibrated */
} JOYREGHWVALUES, FAR *LPJOYREGHWVALUES;

/* hardware configuration */
typedef struct joyreghwconfig_tag {
    JOYREGHWSETTINGS    hws;            /* hardware settings */
    DWORD               dwUsageSettings;/* usage settings */
    JOYREGHWVALUES      hwv;            /* values returned by hardware */
    DWORD               dwType;         /* type of joystick */
    DWORD               dwReserved;     /* reserved for OEM drivers */
} JOYREGHWCONFIG, FAR *LPJOYREGHWCONFIG;

/* joystick calibration info structure */
typedef struct joycalibrate_tag {
    UINT    wXbase;
    UINT    wXdelta;
    UINT    wYbase;
    UINT    wYdelta;
    UINT    wZbase;
    UINT    wZdelta;
} JOYCALIBRATE;
typedef JOYCALIBRATE FAR *LPJOYCALIBRATE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dilib1.c ===
/*****************************************************************************
 *
 *  DILib1.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Objects exported statically into our library.
 *
 *  Contents:
 *
 *      c_dfDIMouse
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global DIOBJECTDATAFORMAT | c_rgdoiDIMouse[] |
 *
 *          Device object data formats for mouse-style access.
 *
 *  @global DIDEVICEFORMAT | c_dfDIMouse |
 *
 *          Device format for mouse-style access.
 *
 *          A pointer to this structure may be passed to
 *          <mf IDirectInputDevice::SetDataFormat> to indicate that
 *          the device will be accessed in the form of a mouse.
 *
 *          When a device has been set to the mouse data format,
 *          the <mf IDirectInputDevice::GetDeviceState> function
 *          returns a <t DIMOUSESTATE> structure, and the
 *          <mf IDirectInputDevice::GetDeviceData> function
 *          returns a <t DIDEVICEOBJECTDATA> whose <p dwOfs>
 *          field is a <c DIMOFS_*> value which describes the
 *          object whose data is being reported.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

static DIOBJECTDATAFORMAT c_rgodfDIMouse[] = {
    { &GUID_XAxis, FIELD_OFFSET(DIMOUSESTATE,        lX),       DIDFT_AXIS | DIDFT_ANYINSTANCE, },
    { &GUID_YAxis, FIELD_OFFSET(DIMOUSESTATE,        lY),       DIDFT_AXIS | DIDFT_ANYINSTANCE, },
    { &GUID_ZAxis, FIELD_OFFSET(DIMOUSESTATE,        lZ),       DIDFT_AXIS | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE, rgbButtons[0]), DIDFT_BUTTON | DIDFT_ANYINSTANCE, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE, rgbButtons[1]), DIDFT_BUTTON | DIDFT_ANYINSTANCE, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE, rgbButtons[2]), DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE, rgbButtons[3]), DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL, },
};

const DIDATAFORMAT c_dfDIMouse = {
    sizeof(DIDATAFORMAT),
    sizeof(DIOBJECTDATAFORMAT),
    DIDF_RELAXIS,
    sizeof(DIMOUSESTATE),
    cA(c_rgodfDIMouse),
    c_rgodfDIMouse,
};

#pragma END_CONST_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dihidenm.c ===
/*****************************************************************************
 *
 *  DIHidEnm.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Support functions for HID enumeration.
 *
 *  Contents:
 *
 *      DIHid_BuildHidList
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflHid


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global PHIDDEVICELIST | g_hdl |
 *
 *          List of known HID devices.
 *
 *  @global DWORD | g_tmLastHIDRebuild |
 *
 *          The time we last rebuilt the HID list.  Zero means that the
 *          HID list has never been rebuilt.  Watch out for wraparound;
 *          a 32-bit value rolls over after about 30 days.
 *
 *****************************************************************************/

#define MSREBUILDRATE       20000                /* Twenty seconds */
#define MSREBUILDRATE_FIFTH  5000                /* Two seconds */

PHIDDEVICELIST g_phdl;
DWORD g_tmLastHIDRebuild;

TCHAR g_tszIdLastRemoved[MAX_PATH];
DWORD g_tmLastRemoved = 0;
TCHAR g_tszIdLastUnknown[MAX_PATH];
DWORD g_tmLastUnknown = 0;


    #pragma BEGIN_CONST_DATA

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PHIDDEVICEINFO | phdiFindHIDInstanceGUID |
 *
 *          Locates information given an instance GUID for a HID device.
 *
 *          The parameters have already been validated.
 *
 *          The DLL critical must be held across the call; once the
 *          critical section is released, the returned pointer becomes
 *          invalid.
 *
 *  @parm   IN PCGUID | pguid |
 *
 *          The instance GUID to be located.
 *
 *  @returns
 *
 *          Pointer to the <t HIDDEVICEINFO> that describes
 *          the device.
 *
 *****************************************************************************/

PHIDDEVICEINFO EXTERNAL
    phdiFindHIDInstanceGUID(PCGUID pguid)
{
    PHIDDEVICEINFO phdi;

    AssertF(InCrit());

    if(g_phdl)
    {
        int ihdi;

        for(ihdi = 0, phdi = g_phdl->rghdi; 
           ihdi < g_phdl->chdi;
           ihdi++, phdi++)
        {
            if(IsEqualGUID(pguid, &phdi->guid)  )
            {
                goto done;
            }
        }
        /* 
         * Memphis Bug#68994. App does not detect USB device. 
         * App was using product guid. 
         * Fix: We allow match to HID guid, if product guid is specfied
         */
        for(ihdi = 0, phdi = g_phdl->rghdi;
           ihdi < g_phdl->chdi;
           ihdi++, phdi++)
        {
            if(IsEqualGUID(pguid, &phdi->guidProduct)  )
            {
                RPF("Warning: Use instance GUID (NOT product GUID) to refer to a device.");
                goto done;
            }
        }

        #ifdef WINNT
        /*
         *  NT Bug#351951.
         *  If they are directly asking for one of the predefined joystick 
         *  IDs then see if we have a device mapped to that ID.  If so,
         *  pretend they asked for that GUID instead.
         */

        /*
         *  Weakly Assert the range of predefined static joystick instance GUIDs
         */
        AssertF( ( rgGUID_Joystick[0].Data1 & 0x0f ) == 0 );
        AssertF( ( rgGUID_Joystick[0x0f].Data1 & 0x0f ) == 0x0f );

        /*
         *  Check the GUID is the same as the first static one ignoring LS 4 bits
         */
        if( ( (pguid->Data1 & 0xf0) == (rgGUID_Joystick[0].Data1 & 0xf0) )
          && !memcmp( ((PBYTE)&rgGUID_Joystick)+1, ((PBYTE)pguid)+1, sizeof(*pguid) - 1 ) )
        {
            RPF("Using predefined instance GUIDs is bad and should not work!");
            phdi = phdiFindJoyId( pguid->Data1 & 0x0f );
            goto done;
        }
        #endif
    }
    phdi = 0;

    done:;

    return phdi;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFindHIDInstanceGUID |
 *
 *          Locates information given an instance GUID for a HID device.
 *
 *          The parameters have already been validated.
 *
 *  @parm   IN PCGUID | pguid |
 *
 *          The instance GUID to be located.
 *
 *  @parm   OUT CREATEDCB * | pcdcb |
 *
 *          Receives pointer to the <f CreateDcb> function for the object.
 *
 *****************************************************************************/

STDMETHODIMP
    hresFindHIDInstanceGUID(PCGUID pguid, CREATEDCB *pcdcb)
{
    HRESULT hres;
    PHIDDEVICEINFO phdi;
    EnterProc(hresFindHIDInstanceGUID, (_ "G", pguid));

    AssertF(SUCCEEDED(hresFullValidGuid(pguid, 0)));

    DllEnterCrit();

    phdi = phdiFindHIDInstanceGUID(pguid);
    if(phdi)
    {
        *pcdcb = CHid_New;
        hres = S_OK;
    } else
    {
        hres = DIERR_DEVICENOTREG;
    }

    DllLeaveCrit();

    /*
     *  Don't use ExitOleProcPpv because that will validate that
     *  *pcdcb == 0 if FAILED(hres), but that's not our job.
     */
    ExitOleProc();

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PHIDDEVICEINFO | phdiFindHIDDeviceId |
 *
 *          Locates information given a deviceID
 *          (in other words, <enumerator>\<enumerator-specific-device-ID>) for a HID device.
 *
 *          The parameters have already been validated.
 *
 *          The DLL critical must be held across the call; once the
 *          critical section is released, the returned pointer becomes
 *          invalid.
 *
 *  @parm   IN LPCTSTR | ptszId |
 *
 *          The interface device to be located.
 *
 *  @returns
 *
 *          Pointer to the <t HIDDEVICEINFO> that describes
 *          the device.
 *
 *****************************************************************************/

PHIDDEVICEINFO EXTERNAL
    phdiFindHIDDeviceId(LPCTSTR ptszId)
{
    PHIDDEVICEINFO phdi;

    AssertF(InCrit());

    if(g_phdl)
    {
        int ihdi;

        for(ihdi = 0, phdi = g_phdl->rghdi; ihdi < g_phdl->chdi;
           ihdi++, phdi++)
        {
            if(phdi->pdidd &&
               lstrcmpi(phdi->ptszId, ptszId) == 0)
            {
                goto done;
            }
        }
    }
    phdi = 0;

    done:;

    return phdi;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PHIDDEVICEINFO | phdiFindHIDDeviceInterface |
 *
 *          Locates information given a device interface
 *          (in other words, a \\.\... thing) for a HID device.
 *
 *          The parameters have already been validated.
 *
 *          The DLL critical must be held across the call; once the
 *          critical section is released, the returned pointer becomes
 *          invalid.
 *
 *  @parm   IN LPCTSTR | ptszPath |
 *
 *          The interface device to be located.
 *
 *  @returns
 *
 *          Pointer to the <t HIDDEVICEINFO> that describes
 *          the device.
 *
 *****************************************************************************/

PHIDDEVICEINFO EXTERNAL
    phdiFindHIDDeviceInterface(LPCTSTR ptszPath)
{
    PHIDDEVICEINFO phdi;

    AssertF(InCrit());

    if(g_phdl)
    {
        int ihdi;

        for(ihdi = 0, phdi = g_phdl->rghdi; ihdi < g_phdl->chdi;
           ihdi++, phdi++)
        {
            if(phdi->pdidd &&
               lstrcmpi(phdi->pdidd->DevicePath, ptszPath) == 0)
            {
                goto done;
            }
        }
    }
    phdi = 0;

    done:;

    return phdi;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFindHIDDeviceInterface |
 *
 *          Locates information given a device interface
 *          (in other words, a \\.\... thing) for a HID device.
 *
 *          The parameters have already been validated.
 *
 *  @parm   IN LPCTSTR | ptszPath |
 *
 *          The interface device to be located.
 *
 *  @parm   OUT LPGUID | pguidOut |
 *
 *          Receives the instance GUID of the device found.
 *
 *****************************************************************************/

STDMETHODIMP
    hresFindHIDDeviceInterface(LPCTSTR ptszPath, LPGUID pguidOut)
{
    HRESULT hres;
    PHIDDEVICEINFO phdi;
    EnterProc(hresFindHIDDeviceInterface, (_ "s", ptszPath));

    DllEnterCrit();

    phdi = phdiFindHIDDeviceInterface(ptszPath);

    if(phdi)
    {
        *pguidOut = phdi->guid;
        hres = S_OK;
    } else
    {
        hres = DIERR_DEVICENOTREG;
    }

    DllLeaveCrit();

    ExitOleProc();

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DIHid_ProbeMouse |
 *
 *          That this function exists at all is a total hack to work
 *          around bugs in Memphis and NT5.
 *
 *          If you call GetSystemMetrics(SM_WHEELPRESENT) or
 *          GetSystemMetrics(SM_MOUSEBUTTONS), USER32 does not
 *          return the correct values if your HID mouse is
 *          not the same as your PS/2 mouse (if any).
 *
 *          For example, if your PS/2 mouse is a regular two-button
 *          mouse but your HID mouse is a wheel mouse, GetSystemMetrics
 *          will still say "No wheel, 2 buttons" even though it's wrong.
 *
 *          So what we have to do is wander through all the HID mice in
 *          the system and record the number of buttons they have,
 *          and whether they have a wheel.
 *
 *          That way, when we create a system mouse, we can take the
 *          maximum of every supported device.
 *
 *****************************************************************************/

void INTERNAL
    DIHid_ProbeMouse(PHIDDEVICEINFO phdi, PHIDP_CAPS pcaps,
                     PHIDP_PREPARSED_DATA ppd)
{
    LPVOID pvReport;
    HRESULT hres;

    /*
     *  Get the number of buttons in the generic button page.
     *  This is the only page the MOUHID uses.
     */
    phdi->osd.uiButtons =
        HidP_MaxUsageListLength(HidP_Input, HID_USAGE_PAGE_BUTTON, ppd);

    /*
     *  See if there is a HID_USAGE_GENERIC_WHEEL.
     *  This is the way that MOUHID detects a wheel.
     */
    hres = AllocCbPpv(pcaps->InputReportByteLength, &pvReport);
    if(SUCCEEDED(hres))
    {
        ULONG ul;
        NTSTATUS stat;

        stat = HidP_GetUsageValue(HidP_Input, HID_USAGE_PAGE_GENERIC, 0,
                                  HID_USAGE_GENERIC_WHEEL, &ul, ppd,
                                  pvReport,
                                  pcaps->InputReportByteLength);
        if(SUCCEEDED(stat))
        {
            phdi->osd.uiAxes = 3;
        }

        FreePv(pvReport);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DIHid_ParseUsagePage |
 *
 *  ISSUE-2001/02/06-TimGill  Enumeration needs to know device type
 *          Parse the usage page information and create a first pass at DI 
 *          style type information.
 *          This really is not enough information to be useful as 
 *          enumeration needs to know the final device type.
 *
 *****************************************************************************/

void INTERNAL
    DIHid_ParseUsagePage(PHIDDEVICEINFO phdi, PHIDP_CAPS pcaps,
                         PHIDP_PREPARSED_DATA ppd)

{
    switch(pcaps->UsagePage)
    {
    case HID_USAGE_PAGE_GENERIC:
        switch(pcaps->Usage)
        {

        /*
         *  MouHID accepts either HID_USAGE_GENERIC_MOUSE or
         *  HID_USAGE_GENERIC_POINTER, so we will do the same.
         */
        case HID_USAGE_GENERIC_MOUSE:
        case HID_USAGE_GENERIC_POINTER:
            DIHid_ProbeMouse(phdi, pcaps, ppd);
            phdi->osd.dwDevType =
                MAKE_DIDEVICE_TYPE(DI8DEVTYPE_MOUSE,
                                   DI8DEVTYPEMOUSE_UNKNOWN) |
                DIDEVTYPE_HID;
            break;

        case HID_USAGE_GENERIC_JOYSTICK:
            phdi->osd.dwDevType =
                MAKE_DIDEVICE_TYPE(DI8DEVTYPE_JOYSTICK,
                                   DI8DEVTYPEJOYSTICK_STANDARD) |
                DIDEVTYPE_HID;
            break;

        case HID_USAGE_GENERIC_GAMEPAD:
            phdi->osd.dwDevType =
                MAKE_DIDEVICE_TYPE(DI8DEVTYPE_GAMEPAD,
                                   DI8DEVTYPEGAMEPAD_STANDARD) |
                DIDEVTYPE_HID;
            break;

        case HID_USAGE_GENERIC_KEYBOARD:
            phdi->osd.dwDevType =
                MAKE_DIDEVICE_TYPE(DI8DEVTYPE_KEYBOARD,
                                   DI8DEVTYPEKEYBOARD_UNKNOWN) |
                DIDEVTYPE_HID;
            break;

        default:
            phdi->osd.dwDevType = DI8DEVTYPE_DEVICE | DIDEVTYPE_HID;
            break;
        }
        break;

    default:
        phdi->osd.dwDevType = DI8DEVTYPE_DEVICE | DIDEVTYPE_HID;
        break;
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | DIHid_GetDevicePath |
 *
 *          Obtain the path for the device.  This is a simple wrapper
 *          function to keep DIHid_BuildHidListEntry from getting too
 *          annoying.
 *
 *          This also gets the devinfo so we can get the
 *          instance ID string for subsequent use to get the
 *          friendly name, etc.
 *
 *****************************************************************************/

BOOL EXTERNAL
    DIHid_GetDevicePath(HDEVINFO hdev,
                        PSP_DEVICE_INTERFACE_DATA pdid,
                        PSP_DEVICE_INTERFACE_DETAIL_DATA *ppdidd,
                        OPTIONAL PSP_DEVINFO_DATA pdinf)
{
    HRESULT hres;
    BOOL fRc;
    DWORD cbRequired;
    EnterProcI(DIHid_GetDevicePath, (_ "xp", hdev, pdid));

    AssertF(*ppdidd == 0);

    /*
     *  Ask for the required size then allocate it then fill it.
     *
     *  Note that we don't need to free the memory on the failure
     *  path; our caller will do the necessary memory freeing.
     *
     *  Sigh.  Windows NT and Windows 98 implement
     *  SetupDiGetDeviceInterfaceDetail differently if you are
     *  querying for the buffer size.
     *
     *  Windows 98 returns FALSE, and GetLastError() returns
     *  ERROR_INSUFFICIENT_BUFFER.
     *
     *  Windows NT returns TRUE.
     *
     *  So we allow the cases either where the call succeeds or
     *  the call fails with ERROR_INSUFFICIENT_BUFFER.
     */
    if(SetupDiGetDeviceInterfaceDetail(hdev, pdid, 0, 0,
                                       &cbRequired, 0) ||
       GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    {

        hres = AllocCbPpv(cbRequired, ppdidd);


        // Keep prefix happy, manbug 29341
        if(SUCCEEDED(hres) && ( *ppdidd != NULL) )
        {
            PSP_DEVICE_INTERFACE_DETAIL_DATA pdidd = *ppdidd;

            /* 
             *  Note, The cbSize field always contains the size of the fixed 
             *  part of the data structure, not a size reflecting the 
             *  variable-length string at the end. 
             */

            pdidd->cbSize = cbX(SP_DEVICE_INTERFACE_DETAIL_DATA);

            fRc = SetupDiGetDeviceInterfaceDetail(hdev, pdid, pdidd,
                                                  cbRequired, &cbRequired, pdinf);

            if(!fRc)
            {
                FreePpv(ppdidd);

                /*
                 * Set fRc = FALSE again, so the compiler doesn't need
                 * to blow a register to cache the value zero.
                 */
                fRc = FALSE;
            }
        } else
        {
            fRc = FALSE;
        }
    } else
    {
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%hs: SetupDiGetDeviceInterfaceDetail failed 1, ")
                        TEXT("Error = %d"),
                        s_szProc, GetLastError());
        fRc = FALSE;
    }

    ExitProcF(fRc);
    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | DIHid_GetDeviceInstanceId |
 *
 *          Obtain the instance ID for the device.
 *
 *          The instance ID allows us to get access to device
 *          properties later.
 *
 *****************************************************************************/

BOOL EXTERNAL
    DIHid_GetDeviceInstanceId(HDEVINFO hdev,
                              PSP_DEVINFO_DATA pdinf, LPTSTR *pptszId)
{
    BOOL fRc;
    DWORD ctchRequired;

    AssertF(*pptszId == 0);

    /*
     *  Ask for the required size then allocate it then fill it.
     *
     *  Note that we don't need to free the memory on the failure
     *  path; our caller will do the necessary memory freeing.
     */
    if(SetupDiGetDeviceInstanceId(hdev, pdinf, NULL, 0,
                                  &ctchRequired) == 0 &&
       GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    {
        HRESULT hres;

        hres = AllocCbPpv(cbCtch(ctchRequired), pptszId);

        if(SUCCEEDED(hres))
        {
            fRc = SetupDiGetDeviceInstanceId(hdev, pdinf, *pptszId,
                                             ctchRequired, NULL);
        } else
        {
            fRc = FALSE;
        }
    } else
    {
        fRc = FALSE;
    }
    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | DIHid_GetInstanceGUID |
 *
 *          Read the instance GUID from the registry, or create one if
 *          necessary.
 *
 *****************************************************************************/

BOOL INTERNAL
    DIHid_GetInstanceGUID(HKEY hk, LPGUID pguid)
{
    LONG lRc;
    DWORD cb;

    cb = cbX(GUID);
    lRc = RegQueryValueEx(hk, TEXT("GUID"), 0, 0, (PV)pguid, &cb);

    if(lRc != ERROR_SUCCESS)
    {
        DICreateGuid(pguid);
        lRc = RegSetValueEx(hk, TEXT("GUID"), 0, REG_BINARY,
                            (PV)pguid, cbX(GUID));
    }

    return lRc == ERROR_SUCCESS;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DIHid_EmptyHidList |
 *
 *          Empty the list of HID devices.
 *
 *          This function must be called under the DLL critical section.
 *
 *****************************************************************************/

void EXTERNAL
    DIHid_EmptyHidList(void)
{
    AssertF(InCrit());

    /*
     *  Free all the old strings and things in the HIDDEVICEINFO's.
     */
    if(g_phdl)
    {
        int ihdi;

        for(ihdi = 0; ihdi < g_phdl->chdi; ihdi++)
        {
            FreePpv(&g_phdl->rghdi[ihdi].pdidd);
            FreePpv(&g_phdl->rghdi[ihdi].ptszId);
            if(g_phdl->rghdi[ihdi].hk)
            {
                RegCloseKey(g_phdl->rghdi[ihdi].hk);
            }
        }

        /*
         *  We invalidated all the pointers, so make sure
         *  nobody looks at them.
         */
        g_phdl->chdi = 0;
    }

}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DIHid_CheckHidList |
 *
 *          Check the list of HID devices, and free whose what can not be opened
 *
 *          This function must be called under the DLL critical section.
 *
 *****************************************************************************/

void INTERNAL
    DIHid_CheckHidList(void)
{
    HANDLE hf;

    EnterProcI(DIHid_CheckList, (_ "x", 0x0) );

    AssertF(InCrit());

    /*
     *  Free all the information of the device cannot be opened
     */
    if(g_phdl)
    {
        int ihdi;

        for(ihdi = 0, g_phdl->chdi = 0; ihdi < g_phdl->chdiAlloc; ihdi++)
        {

            if( g_phdl->rghdi[ihdi].pdidd )
            {

                /*
                 *  Open the device
                 */
                hf = CreateFile(g_phdl->rghdi[ihdi].pdidd->DevicePath,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                0,                /* no SECURITY_ATTRIBUTES */
                                OPEN_EXISTING,
                                0,                /* attributes */
                                0);               /* template */

                if(hf == INVALID_HANDLE_VALUE)
                {                                        
#if 0
                    PHIDDEVICEINFO phdi;
                    PBUSDEVICEINFO pbdi;

                    CloseHandle(hf);
                    
                    phdi = &g_phdl->rghdi[ihdi];
                    
                    DllEnterCrit();

                    phdi = phdiFindHIDDeviceInterface(g_phdl->rghdi[ihdi].pdidd->DevicePath);
                    AssertF(phdi != NULL);
                    pbdi = pbdiFromphdi(phdi);

                    DllLeaveCrit();

                    if( pbdi != NULL )
                    {
                        if( pbdi->fDeleteIfNotConnected == TRUE )
                        {
                            lstrcpy( g_tszIdLastRemoved, pbdi->ptszId );
                            g_tmLastRemoved = GetTickCount();

                            DIBusDevice_Remove(pbdi);
                            
                            pbdi->fDeleteIfNotConnected = FALSE;
                        }
                    }
#endif                    

                    FreePpv(&g_phdl->rghdi[ihdi].pdidd);
                    FreePpv(&g_phdl->rghdi[ihdi].ptszId);

                    if(g_phdl->rghdi[ihdi].hk)
                    {
                        RegCloseKey(g_phdl->rghdi[ihdi].hk);
                    }
                    
                    ZeroX( g_phdl->rghdi[ihdi] );

                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%hs: CreateFile(%s) failed? le=%d"),
                                    s_szProc, g_phdl->rghdi[ihdi].pdidd->DevicePath, GetLastError());
                    
                    /* Skip erroneous items */

                } else
                {
                    CloseHandle(hf);
                    g_phdl->chdi++;
                }
            }
        }

        //re-order the existing devices, put them at the front of the hid list.
        for(ihdi = 0; ihdi < g_phdl->chdi; ihdi++)
        {
            if( !g_phdl->rghdi[ihdi].pdidd )
            {
                int ihdi2;

                //find the existing device from the biggest index in the hid list.
                for( ihdi2 = g_phdl->chdiAlloc; ihdi2 >= ihdi+1; ihdi2-- )
                {
                    if( g_phdl->rghdi[ihdi2].pdidd )
                    {
                        memcpy( &g_phdl->rghdi[ihdi], &g_phdl->rghdi[ihdi2], sizeof(HIDDEVICEINFO) );
                        ZeroX( g_phdl->rghdi[ihdi2] );
                    }
                }
            }
        }

    }

    ExitProc();
    return;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DIHid_CreateDeviceInstanceKeys |
 *
 *          Create the keys associaciated with a particular device.
 *
 *  @parm   IN OUT PHIDDEVICEINFO | phdi |
 *
 *          HIDDEVICEINFO we to use/update.
 *
 *  @returns
 *
 *          S_OK for a success
 *          A COM error for a failure
 *
 *****************************************************************************/

#define DIHES_UNDEFINED 0
#define DIHES_UNKNOWN   1
#define DIHES_KNOWN     2


HRESULT INTERNAL
    DIHid_CreateDeviceInstanceKeys( PHIDDEVICEINFO phdi, PBYTE pState )
{
    HRESULT hres;
    HKEY hkDin;

    USHORT uVid, uPid;

    TCHAR tszName[MAX_PATH];
    PTCHAR ptszInstance = NULL;

    EnterProcI(DIHid_CreateDeviceInstanceKeys, (_ "p", phdi));

    /*
     *  Unfortunately, we need to open our registry keys before we can open 
     *  the device so rather than ask the device for its VID and PID, we 
     *  parse it from the 
     */

    /*
     *  ISSUE-2001/01/27-MarcAnd Should avoid parsing device ID ourselves
     *  Need to find some documented way to parse out the three parts of the 
     *  device ID: class, device and instance in case the form changes.
     */

    /*
     *  The format of the device ID is a set of strings in the form 
     *  "<class>\<device>\<instance>" with variable case.
     *  For HID devices, the class should be "hid" and the instance is a set 
     *  of hex values separated by ampersands.  The device string should be 
     *  of the form vid_9999&pid_9999 but devices exposed via a gameport can 
     *  use any string that PnP accepts.
     */

    AssertF( ( phdi->ptszId[0]  == TEXT('H') ) || ( phdi->ptszId[0] == TEXT('h') ) );
    AssertF( ( phdi->ptszId[1]  == TEXT('I') ) || ( phdi->ptszId[1] == TEXT('i') ) );
    AssertF( ( phdi->ptszId[2]  == TEXT('D') ) || ( phdi->ptszId[2] == TEXT('d') ) );


    /*
     *  Assert that a defined state and a valid VID/PID on entry must both be 
     *  true or both false (so we can use the state after getting VID/PID).
     */        
    if( ( phdi->ProductID != 0 ) && ( phdi->VendorID !=0 ) )
    {
        AssertF( *pState != DIHES_UNDEFINED );
    }
    else
    {
        AssertF( *pState == DIHES_UNDEFINED );
    }

    if( phdi->ptszId[3] == TEXT('\\') )
    {
        PTCHAR ptcSrc;
        PTCHAR ptDevId;

        ptcSrc = ptDevId = &phdi->ptszId[4];

        if( ( phdi->ProductID != 0 ) && ( phdi->VendorID !=0 ) )
        {
            int iLen;
            /*
             *  Create the key name from VID / PID (because it may be 
             *  different from the value derived from the device ID).
             */
            iLen = wsprintf(tszName, VID_PID_TEMPLATE, phdi->VendorID, phdi->ProductID);

            while( *ptcSrc != TEXT('\\') )
            {
                if( *ptcSrc == TEXT('\0') )
                {
                    break;
                }
                ptcSrc++;
            }

            if( ( *ptcSrc != TEXT('\0') )
             && ( ptcSrc != ptDevId ) )
            {
                ptszInstance = &tszName[iLen+2];
                lstrcpy( ptszInstance, ptcSrc+1 );
            }
        }
        else 
        {
            PTCHAR ptcDest;
            BOOL   fFirstAmpersand = FALSE;

            /*
             *  Copy the device ID (minus "HID\") so we can corrupt the copy.
             *  Convert to upper case and find the other slash on the way.
             *  Terminate the string at either the separator slash or a second 
             *  ampersand if one is found (VID_1234&PID_1234&COL_12 or REV_12).
             *  These are device IDs so we're only really interested in keeping 
             *  real VID\PID style IDs in upper case so we don't care if this 
             *  is imperfect for other cases as long as it is reproducable.
             */

            for( ptcDest = tszName; *ptcSrc != TEXT('\0'); ptcSrc++, ptcDest++ )
            {
                if( ( *ptcSrc >= TEXT('a') ) && ( *ptcSrc <= TEXT('z') ) )
                {
                    *ptcDest = *ptcSrc - ( TEXT('a') - TEXT('A') );
                }
                else if( *ptcSrc == TEXT('&') )
                {
                    if( ( ptszInstance != NULL )
                     || !fFirstAmpersand )
                    {
                        fFirstAmpersand = TRUE;
                        *ptcDest = TEXT('&');
                    }
                    else
                    {
                        *ptcDest = TEXT('\0');
                    }
                }
                else if( *ptcSrc != TEXT('\\') )
                {
                    *ptcDest = *ptcSrc;
                }
                else
                {
                    /*
                     *  Only one slash and not the first char
                     */
                    if( ( ptszInstance != NULL ) 
                     || ( ptcDest == tszName ) )
                    {
                        ptszInstance = NULL;
                        break;
                    }

                    /*
                     *  Separate the device ID and the instance
                     */
                    *ptcDest = TEXT('\0');
                    ptszInstance = ptcDest + 1;
                }
            }

            if( ptszInstance != NULL )
            {
#ifndef UNICODE
/*
 *  ISSUE-2001/02/06-MarcAnd  Should have a ParseVIDPIDA
 *  ParseVIDPID is going to convert this string back to ANSI ifndef UNICODE
 */
                WCHAR wszName[cbszVIDPID];
                AToU( wszName, cA(wszName), ptDevId );

                if( ( ptszInstance - tszName == cbszVIDPID )
                 && ( ParseVIDPID( &uVid, &uPid, wszName ) ) )
#else
                if( ( ptszInstance - tszName == cbszVIDPID )
                 && ( ParseVIDPID( &uVid, &uPid, ptDevId ) ) )
#endif
                {
                    phdi->VendorID  = uVid;
                    phdi->ProductID = uPid;
                }
                else
                {
                    SquirtSqflPtszV(sqfl | sqflBenign,
                                TEXT("%hs: ID %s, len %d not VID PID"), 
                                s_szProc, ptDevId, ptszInstance - tszName );
                }

                /*
                 *  Terminate the instance string
                 */
                *ptcDest = TEXT('\0');
            }
        }
    }
            
    if( ptszInstance == NULL )
    {
        hres = E_INVALIDARG;
        RPF( "Ignoring invalid device ID handle \"%s\" enumerated by system" );
    }
    else
    {
        //Open our own reg key under MediaProperties\DirectInput,
        //creating it if necessary.
        hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE, 
                               REGSTR_PATH_DITYPEPROP, 
                               DI_KEY_ALL_ACCESS, 
                               REG_OPTION_NON_VOLATILE, 
                               &hkDin);

        if( SUCCEEDED(hres) )
        {
            HKEY hkVidPid;
            hres = hresMumbleKeyEx(hkDin, 
                                   (LPTSTR)tszName, 
                                   DI_KEY_ALL_ACCESS, 
                                   REG_OPTION_NON_VOLATILE, 
                                   &hkVidPid);
        
            if( SUCCEEDED(hres) )
            {
                HKEY hkDevInsts;

                /*
                 *  Need to create user subkeys even if the device ID is not 
                 *  VID/PID as an auto-detect device could use the auto-detect 
                 *  HW ID for whatever device it detects.  
                 */

                //Create the key for Calibration
                HKEY hkCal;

                hres = hresMumbleKeyEx(hkVidPid, 
                                   TEXT("Calibration"), 
                                   DI_KEY_ALL_ACCESS, 
                                   REG_OPTION_NON_VOLATILE, 
                                   &hkCal);

                if (SUCCEEDED(hres))
                {
                    //Create the key for the instance (as the user sees it).
                    //For this, need to find out how many instances of the particular device
                    //we have already enumerated.
                    int ihdi;
                    int iNum = 0;
                    TCHAR tszInst[3];

                    for( ihdi = 0; ihdi < g_phdl->chdi; ihdi++)
                    {
                        if ((g_phdl->rghdi[ihdi].VendorID == phdi->VendorID) && (g_phdl->rghdi[ihdi].ProductID == phdi->ProductID))
                        {
                            iNum++;
                        }
                    }

                    wsprintf(tszInst, TEXT("%u"), iNum);

                    hres = hresMumbleKeyEx(hkCal, 
                                       tszInst, 
                                       DI_KEY_ALL_ACCESS, 
                                       REG_OPTION_NON_VOLATILE, 
                                       &phdi->hk);
                    if (SUCCEEDED(hres))
                    {
                        DIHid_GetInstanceGUID(phdi->hk, &phdi->guid);
                    }
                    else
                    {
                        SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%hs: RegCreateKeyEx failed on Instance reg key"),
                                    s_szProc);
                    }

                    RegCloseKey(hkCal);
                }
                else
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("%hs: RegCreateKeyEx failed on Calibration reg key"),
                                s_szProc);
                }

                /*
                 *  Try to open the device (plug) instances to find out or 
                 *  update the staus of processing on this device but don't 
                 *  return any failures.
                 */
                if( SUCCEEDED( hresMumbleKeyEx(hkVidPid, 
                                       TEXT("DeviceInstances"), 
                                       DI_KEY_ALL_ACCESS, 
                                       REG_OPTION_NON_VOLATILE, 
                                       &hkDevInsts) ) )
                {
                    LONG lRc;

                    if( *pState == DIHES_UNDEFINED )
                    {
                        DWORD cb = cbX( *pState );

                        lRc = RegQueryValueEx( hkDevInsts,
                                    ptszInstance, 0, 0, pState, &cb );

                        if( lRc != ERROR_SUCCESS )
                        {
                            SquirtSqflPtszV(sqfl | sqflBenign,
                                        TEXT("%hs: RegQueryValueEx failed (%d) to get state for instance %s"),
                                        s_szProc, lRc, ptszInstance );
                            /*
                             *  Make sure it was not trashed in the failure
                             */
                            *pState = DIHES_UNDEFINED;
                        }
                    }
                    else
                    {
                        lRc = RegSetValueEx( hkDevInsts,
                                    ptszInstance, 0, REG_BINARY, pState, cbX( *pState ) );

                        if( lRc != ERROR_SUCCESS)
                        {
                            SquirtSqflPtszV(sqfl | sqflBenign,
                                        TEXT("%hs: RegSetValueEx failed (%d) to update state for instance %S"),
                                        s_szProc, lRc, ptszInstance );
                        }
                    }

                    RegCloseKey(hkDevInsts);
                }
                else
                {
                    SquirtSqflPtszV(sqfl | sqflBenign,
                                TEXT("%hs: Failed to open DeviceInstances key"),
                                s_szProc );
                }

                RegCloseKey(hkVidPid);
            }
            else
            {
                SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("%hs: RegCreateKeyEx failed on Device reg key"),
                                s_szProc);
            }

            RegCloseKey(hkDin);
        }
        else
        {
            SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("%hs: RegOpenKeyEx failed on DirectInput reg key"),
                                s_szProc);
        }
    }

    ExitOleProc();

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DIHid_GetDevInfo |
 *
 *          Get the HIDDEVICEINFO info from the device
 *
 *  @parm   HDEVINFO | hdev |
 *
 *          Device to get information
 *
 *  @parm   PSP_DEVICE_INTERFACE_DATA | pdid |
 *
 *          Describes the device
 *
 *  @parm   OUT PHIDDEVICEINFO | phdi |
 *
 *          HIDDEVICEINFO we need to collect
 *
 *  @returns
 *
 *          Nonzero on success.
 *
 *****************************************************************************/

BOOL INTERNAL
    DIHid_GetDevInfo( HDEVINFO hdev, PSP_DEVICE_INTERFACE_DATA pdid, PHIDDEVICEINFO phdi )
{
    BOOL fRc = FALSE;
    SP_DEVINFO_DATA dinf;

    EnterProcI(DIHid_GetDevInfo, (_ "xpp", hdev, pdid, phdi));

    /*
     *  Open the registry key for the device so we can obtain
     *  auxiliary information.
     */

    dinf.cbSize = cbX(SP_DEVINFO_DATA);

    /*
     *  Get the instance GUID and the path to
     *  the HID device so we can talk to it.
     */
    if (DIHid_GetDevicePath(hdev, pdid, &phdi->pdidd, &dinf) &&
        DIHid_GetDeviceInstanceId(hdev, &dinf, &phdi->ptszId))
    {
        HANDLE  hf;
        TCHAR   tszName[MAX_PATH];
        ULONG   len = sizeof(tszName);
        BOOL    fCreateOK = FALSE;
        BYTE    bNewState = DIHES_UNDEFINED;
        BYTE    bPreviousState = DIHES_UNDEFINED;


        DIHid_CreateDeviceInstanceKeys( phdi, &bPreviousState );

#if 0 /* Remove for server per Whistler bug 575181   

        //////////////////// BEGIN OF PATCH ////////////////////////
        /*
         * This part is to keep the compatibility with Win2k Gold. 
         * Some driver, like Thrustmaster driver, tries to get Joystick ID
         * from old registry key: 
         *   HKLM\SYSTEM\CurrentControlSet\Control\DeviceClasses\{4d1e55b2-f16f-11cf-88cb-001111000030}\<?????????>\#\Device Parameters\DirectX
         * See Windows bug 395416 for detail.
         */
        {
            HKEY    hkDev;
            HRESULT hres;
    
            /*
             *  Open the registry key for the device so we can obtain
             *  auxiliary information, creating it if necessary.
             */
            hkDev = SetupDiCreateDeviceInterfaceRegKey(hdev, pdid, 0,
                                                   MAXIMUM_ALLOWED, NULL, NULL);
                                                   
            if(hkDev && hkDev != INVALID_HANDLE_VALUE)
            {
                hres = hresMumbleKeyEx(hkDev, 
                                   TEXT("DirectX"), 
                                   KEY_ALL_ACCESS, 
                                   REG_OPTION_NON_VOLATILE, 
                                   &phdi->hkOld);
                if(SUCCEEDED(hres) )
                {
                    LONG lRc;
                    
                    lRc = RegSetValueEx(phdi->hkOld, TEXT("GUID"), 0, REG_BINARY,
                            (PV)&phdi->guid, cbX(GUID));
                }
            }
        }
        /////////////////// END OF PATCH /////////////////////
#endif //if 0

        /*
         *  Before we CreateFile on the device, we need to make sure the 
         *  device is not in the middle of the setup process. If a device has 
         *  no device description it is probably still being setup (plugged 
         *  in) so delay opening it to avoid having an open handle on a device 
         *  that setup is trying to update.  If that happens, setup will prompt 
         *  the user to reboot to use the device.
         *  Since HIDs are "RAW" devices (don't need drivers) don't ignore 
         *  such a device forever.
         */
        if( CM_Get_DevNode_Registry_Property(dinf.DevInst,
                                             CM_DRP_DEVICEDESC,
                                             NULL,
                                             tszName,
                                             &len,
                                             0) == CR_SUCCESS) 
        {
            /*
             * Known device.
             */
            fCreateOK = TRUE;
            bNewState = DIHES_KNOWN;
        } 
        else 
        {
            /*
             *  Unknown device.  This either means that setup has not yet 
             *  completed processing the HID or that no device description 
             *  was set for the device where it matched.
             *
             *  For now, see if we've seen this device instance before.  
             *  If we have, then if it was previously unknown assume it's 
             *  going to stay that way and start using the device.  If it 
             *  was previously known or we've never seen it before wait for 
             *  a while in case setup is just taking it's time.
             *
             *  If the device was the last one we tried to remove, then it's 
             *  OK to open it while it's still showing up.  
             *  ISSUE-2001/02/06-MarcAnd  Opening removed devices
             *  I assume this is so we get a read failure when it really goes 
             *  away but I don't know how that's better than ignoring it.
             */
            /*
             *  ISSUE-2001/01/27-MarcAnd Should keep real list with status 
             *  We should keep a complete list of all the devices we know 
             *  about with status indicating things like "pending on 
             *  setup since X" or "removed" not these globals.
             */
            if( lstrcmpi(phdi->ptszId, g_tszIdLastRemoved) == 0 ) 
            {
                fCreateOK = TRUE;
                bNewState = bPreviousState;
            } 
            else 
            {
                if( bPreviousState == DIHES_UNKNOWN )
                {
                    /*
                     *  We've seen this device before and it was Unknown so 
                     *  don't expect that to change (as Setup does not retry 
                     *  the ID search through the INFs) so just use it.
                     */
                    fCreateOK = TRUE;
                    bNewState = DIHES_UNKNOWN;
                }
                else
                {
                    if( lstrcmpi(phdi->ptszId, g_tszIdLastUnknown) == 0 ) 
                    {
                        if( GetTickCount() - g_tmLastUnknown < MSREBUILDRATE ) 
                        {
                            SquirtSqflPtszV(sqfl | sqflBenign,
                                        TEXT("%hs: DIHid_BuildHidListEntry: %s pending on setup."), 
                                        s_szProc, phdi->ptszId );
                            fRc = FALSE;
                        } 
                        else 
                        {
                            /*
                             *  Don't wait any longer but we'll need to update 
                             *  the state to "Unknown".
                             */
                            fCreateOK = TRUE;
                            bNewState = DIHES_UNKNOWN;
                            g_tszIdLastUnknown[0] = TEXT('0');
                          #ifdef XDEBUG
                            if( bPreviousState == DIHES_KNOWN )
                            {
                                SquirtSqflPtszV(sqfl | sqflBenign,
                                    TEXT("%hs: %s was known but is now unknown!"), 
                                    s_szProc, phdi->ptszId );
                            }
                          #endif
                        }
                    } 
                    else 
                    {
                        lstrcpy( g_tszIdLastUnknown, phdi->ptszId );
                        g_tmLastUnknown = GetTickCount();
                        fRc = FALSE;
                    }
                }
            }
        }

        if( fCreateOK ) 
        {
            /*
             *  bNewState should always have been set if OK to create
             */

            AssertF( bNewState != DIHES_UNDEFINED );
            /*
             *  Open the device so we can get its (real) usage page / usage.
             */
            hf = CreateFile(phdi->pdidd->DevicePath,
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            0,                /* no SECURITY_ATTRIBUTES */
                            OPEN_EXISTING,
                            0,                /* attributes */
                            0);               /* template */

            if(hf != INVALID_HANDLE_VALUE)
            {
                PHIDP_PREPARSED_DATA ppd;
                HIDD_ATTRIBUTES attr;

                if(HidD_GetPreparsedData(hf, &ppd))
                {
                    HIDP_CAPS caps;

                    if( SUCCEEDED(HidP_GetCaps(ppd, &caps)) )
                    {
                        DIHid_ParseUsagePage(phdi, &caps, ppd);
                        SquirtSqflPtszV(sqfl,
                                        TEXT("%hs: Have %s"),
                                        s_szProc, phdi->pdidd->DevicePath);
                        /*
                         *  ISSUE-2001/02/06-MarcAnd  Incorrect return possible
                         *  There's nothing to reset this to false if any of 
                         *  the following code fails.
                         */
                        fRc = TRUE;
                    }
                    else
                    {
                        SquirtSqflPtszV(sqfl | sqflError,
                                        TEXT("%hs: HidP_GetCaps(%s) failed, le= %d"),
                                        s_szProc, phdi->pdidd->DevicePath, GetLastError());
                    }

                    HidD_FreePreparsedData(ppd);

                } 
                else
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%hs: GetPreparsedData(%s) failed, le= %d"),
                                    s_szProc, phdi->pdidd->DevicePath, GetLastError());
                }

                attr.Size = cbX(attr);
                if( HidD_GetAttributes(hf, &attr) )
                {
                    if( ( phdi->ProductID != attr.ProductID )
                     || ( phdi->VendorID != attr.VendorID ) )
                    {
                        SquirtSqflPtszV(sqfl | sqflBenign,
                            TEXT("%hs: Device changed from VID_%04X&PID_%04X to VID_%04X&PID_%04X"),
                            s_szProc, phdi->VendorID, phdi->ProductID, attr.VendorID, attr.ProductID );

                        phdi->ProductID = attr.ProductID;
                        phdi->VendorID = attr.VendorID;

                        /*
                         *  Make sure we update the registry.
                         */
                        bPreviousState = DIHES_UNDEFINED;
                    }

                    if( bPreviousState != bNewState )
                    {
                        DIHid_CreateDeviceInstanceKeys( phdi, &bNewState );
                    }
                } 
                else
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%hs: HidD_GetAttributes(%s) failed"),
                                    s_szProc, phdi->pdidd->DevicePath);
                }

                DICreateStaticGuid(&phdi->guidProduct, attr.ProductID, attr.VendorID); 

                CloseHandle(hf);

            } 
            else
            {
                SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("%hs: CreateFile(%s) failed? le=%d"),
                                 s_szProc, phdi->pdidd->DevicePath, GetLastError());
            }
        }


#ifndef WINNT
        /*
        * The following part is to resolve the swap id problem in OSR.
        * If a USB joystick is not in the lowest available id, after unplug and replug,
        * VJOYD will assign the same joystick to the lowest available id, but DINPUT still
        * remembers its last id. To resolve this conflict, we need this code.
        */

        {
            VXDINITPARMS vip;
            CHAR sz[MAX_PATH];
            LPSTR pszPath;
            BOOL fFindIt = FALSE;

            for( phdi->idJoy = 0; phdi->idJoy < cJoyMax; phdi->idJoy++ )
            {
                pszPath = JoyReg_JoyIdToDeviceInterface_95(phdi->idJoy, &vip, sz);
                if(pszPath)
                {
                    if( lstrcmpiA(pszPath, (PCHAR)phdi->pdidd->DevicePath) == 0x0 ) {
                        fFindIt = TRUE;
                        break;
                    }
                }
            }

            if( fFindIt ) 
            {
                if( phdi->hk != 0x0 )
                {
                    /*
                     *  Don't worry if the registry write fails
                     */
                    RegSetValueEx(phdi->hk, TEXT("Joystick Id"), 0, 0, (PV)&phdi->idJoy, cbX(phdi->idJoy) );
                }
            } 
            else 
            {
                /*
                 *  Post Dx7 Patch. Win9x only
                 *  Some IHVs have created VJoyD mini drivers for their 
                 *  USB game controllers that are used instead of JoyHID.  
                 *  Since the interface to communicate hot-plugging with 
                 *  VJoyD has not been made public, these devices cannot 
                 *  be matched with a HID alias.  To avoid both instances 
                 *  of the same device being enumerated, mark any HID 
                 *  game controller that does not have a VJoyD alias as 
                 *  a (unknown) device type.
                 *
                 *  Post DX7a!  Only do this for game controllers
                 */
                if( GET_DIDEVICE_TYPE( phdi->osd.dwDevType ) >= DI8DEVTYPE_GAMEMIN )
                {
                    /*
                     *  Change type from joystick to device
                     */
                    phdi->osd.dwDevType &= ~(DIDEVTYPE_TYPEMASK | DIDEVTYPE_SUBTYPEMASK);
                    phdi->osd.dwDevType |= DI8DEVTYPE_DEVICE;
                }
                /*
                 *  Set to the invalid id anyway
                 */
                phdi->idJoy = -1;
            }
        }
#else
        // Executed only on WINNT
        if( phdi->hk != 0x0 )
        {
            DWORD cb;

            cb =  cbX(phdi->idJoy);

            if( RegQueryValueEx(phdi->hk, TEXT("Joystick Id"),
                   0, 0, (PV)&phdi->idJoy, &cb ) != ERROR_SUCCESS )
            {
                phdi->idJoy = JOY_BOGUSID;
            }
        }
#endif // WINNT
    } 
    else
    {
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%hs: Unable to get GUID or device path"),
                        s_szProc);
    }


    /*
     *  If we failed, then free the goo we already got.
     */
    if(!fRc)
    {
        if( phdi->hk ) 
        {
            RegCloseKey(phdi->hk);
        }
        phdi->hk = 0;
        FreePpv(&phdi->pdidd);
        FreePpv(&phdi->ptszId);
    }

    ExitProcF(fRc);

    return fRc;
}

#undef DIHES_UNDEFINED
#undef DIHES_UNKNOWN
#undef DIHES_KNOWN


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DIHid_BuildHidListEntry |
 *
 *          Builds a single entry in the list of HID devices.
 *
 *  @parm   HDEVINFO | hdev |
 *
 *          Device list being enumerated.
 *
 *  @parm   PSP_DEVICE_INTERFACE_DATA | pdid |
 *
 *          Describes the device that was enumerated.
 *
 *  @returns
 *
 *          Nonzero on success.
 *
 *****************************************************************************/

BOOL INTERNAL
    DIHid_BuildHidListEntry(HDEVINFO hdev, PSP_DEVICE_INTERFACE_DATA pdid)
{
    BOOL            fRc = TRUE;
    BOOL            fAlreadyExist = FALSE;
    PHIDDEVICEINFO  phdi;
    HIDDEVICEINFO   hdi;

    EnterProcI(DIHid_BuildHidListEntry, (_ "xp", hdev, pdid));


    if(g_phdl)
    {
        PSP_DEVICE_INTERFACE_DETAIL_DATA pdidd;

        /* GetDevicePath is expecting a NULL */
        pdidd = NULL;
        if( DIHid_GetDevicePath(hdev, pdid, &pdidd, NULL) )
        {
            int ihdi;
            
            //Check whether the device has been in the list
            for(ihdi = 0, phdi = g_phdl->rghdi; 
                ihdi < g_phdl->chdi;
                ihdi++, phdi++)
            {
                if( phdi->pdidd )
                {
                    if( lstrcmp( pdidd->DevicePath, phdi->pdidd->DevicePath ) == 0 )
                    {
                        //already in the list
                        fAlreadyExist = TRUE;

                      #ifdef WINNT
                        // Id may be changed, so refresh here. 
                        // See Windows bug 321711. -qzheng
                        if( phdi->hk != 0x0 )
                        {
                            DWORD cb;
                            cb =  cbX(phdi->idJoy);

                            if( RegQueryValueEx(phdi->hk, TEXT("Joystick Id"),
                                                0, 0, (PV)&phdi->idJoy, &cb ) != ERROR_SUCCESS )
                            {
                                phdi->idJoy = JOY_BOGUSID;
                            }
                        }
                      #endif

                        SquirtSqflPtszV(sqfl | sqflTrace,
                                        TEXT("%hs: Device %s Already Exists in HID List "), s_szProc, pdidd->DevicePath);
                        break;      
                    }
                }
            }
            FreePpv(&pdidd);
        }
        else
        {
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%hs: DIHid_GetDevicePath failed"), s_szProc, pdidd->DevicePath);
        }

        if( fAlreadyExist )
        {
            //device is already there, needn't do anything, just leave
        } else 
        {
            PBUSDEVICEINFO pbdi;

            if( g_phdl->chdi >= g_phdl->chdiAlloc )
            {
                /*
                 *  Make sure there is room for this device in the list.
                 *  Grow by doubling. 
                 */

                HRESULT hres;

                /*
                 *  Prefix warns that g_phdl would be NULL if the requested 
                 *  size is zero (mb:35353).  Assert that it is never zero.
                 */
                AssertF( cbHdlChdi(g_phdl->chdiAlloc * 2) );
                hres = ReallocCbPpv(cbHdlChdi(g_phdl->chdiAlloc * 2), &g_phdl);

                if(FAILED(hres))
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%hs: Realloc failed"), s_szProc);

                    fRc = FALSE;
                    goto done;
                }

                g_phdl->chdiAlloc *= 2;
            }

            phdi = &g_phdl->rghdi[g_phdl->chdi];

            memset( &hdi, 0, sizeof(hdi) );

            if( DIHid_GetDevInfo(hdev, pdid, &hdi) )
            {
                hdi.fAttached = TRUE;
            
                pbdi = pbdiFromphdi(&hdi);
                if( pbdi != NULL )
                {

                    /*
                     * If the devices is just being removed, and PnP is working on the
                     * removing, then we won't include it in our list.
                     */
                    if( lstrcmpi(pbdi->ptszId, g_tszIdLastRemoved) == 0 &&
                        GetTickCount() - g_tmLastRemoved < MSREBUILDRATE_FIFTH ) 
                    {
                        SquirtSqflPtszV(sqfl | sqflBenign,
                                        TEXT("%hs: DIHid_BuildHidListEntry: %s pending on removal."), 
                                        s_szProc, pbdi->ptszId );
                        
                        fRc = FALSE;
                    } else {
                        BUS_REGDATA RegData;

                        memcpy( phdi, &hdi, sizeof(hdi) );
                        g_phdl->chdi++;

                        if( SUCCEEDED(DIBusDevice_GetRegData(pbdi->hk, &RegData)) )
                        {
                            RegData.fAttachOnReboot = TRUE;
                            DIBusDevice_SetRegData(pbdi->hk, &RegData);
                        }
                    }
                } else {
                    memcpy( phdi, &hdi, sizeof(hdi) );
                    g_phdl->chdi++;
                }
            }
            else
            {
                SquirtSqflPtszV(sqfl | sqflBenign,
                    TEXT("%hs: DIHid_GetDevInfo failed, ignoring device"), s_szProc );
                fRc = FALSE;
            }
        }
    }    // end of if(g_phdl)

done:

    ExitProcF(fRc);

    return fRc;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DIHid_BuildHidList |
 *
 *          Builds the list of HID devices.
 *
 *  @parm   BOOL | fForce |
 *
 *          If nonzero, we force a rebuild of the HID list.
 *          Otherwise, we rebuild only if the list hasn't
 *          been rebuilt recently.
 *
 *****************************************************************************/

void EXTERNAL
    DIHid_BuildHidList(BOOL fForce)
{
    HRESULT hres;
    DWORD   dwTick;
    
    EnterProcI(DIHid_BuildHidList, (_ "u", fForce));

    DllEnterCrit();


    // Force implies a complete rebuild of the list
    // No hanging onto old entries. 
    if( fForce )
    {
        DIHid_EmptyHidList();
    }
    //ISSUE-2001/03/29-timgill Meltdown code change may be unnecessary

    dwTick = GetTickCount();
    
    if(!(g_flEmulation & 0x80000000) &&        /* Not disabled by emulation */
       HidD_GetHidGuid &&                      /* HID actually exists */
       (fForce ||                              /* Forcing rebuild, or */
        g_tmLastHIDRebuild == 0 ||             /* Never built before, or */
        dwTick - g_tmLastHIDRebuild > MSREBUILDRATE /* Haven't built for a while */
      #ifdef WINNT
        || dwTick - Excl_GetConfigChangedTime() < MSREBUILDRATE  /* joyConfig just Changed */
      #endif
      ))
    {
        GUID guidHid;
        HDEVINFO hdev;

        HidD_GetHidGuid(&guidHid);

        hdev = SetupDiGetClassDevs(&guidHid, 0, 0,
                                   DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
        if(hdev != INVALID_HANDLE_VALUE)
        {
            DIHid_CheckHidList();

            /*
             *  There is no way to query the number of devices.
             *  You just have to keep incrementing until you run out.
             *
             *  If we already have a g_phdl, then re-use it.  Else, create
             *  a new one.  But always realloc up to the minimum starting
             *  point.  (This upward realloc is important in case there
             *  were no HID devices the last time we checked.)
             */

            if( !g_phdl )
            {
                hres = AllocCbPpv(cbHdlChdi(chdiInit), &g_phdl);

                if(SUCCEEDED(hres))
                {
                    g_phdl->chdi = 0;
                    g_phdl->chdiAlloc = chdiInit;
                } else
                {
                    /* Skip erroneous items */
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("DIHid_BuildHidListEntry ")
                                    TEXT("Realloc g_phdl fails."));
                }
            } else
            {
                hres = S_OK;
            }


            if(SUCCEEDED(hres))
            {
                int idev;

                /*
                 *  To avoid infinite looping on
                 *  internal *boo-boo's*, break on any
                 *  error once we have tried more than
                 *  chdiMax devices, since that's the most
                 *  HID will ever give us.
                 */
                for(idev = 0; idev < chdiMax; idev++)
                {
                    SP_DEVICE_INTERFACE_DATA did;

                    AssertF(g_phdl->chdi <= g_phdl->chdiAlloc);

                    /* 
                     *  SetupDI requires that the caller initialize cbSize.
                     */
                    did.cbSize = cbX(did);
                    if(SetupDiEnumDeviceInterfaces(hdev, 0, &guidHid,
                                                   idev, &did))
                    {
                        if(!DIHid_BuildHidListEntry(hdev, &did))
                        {
                            /* Skip erroneous items */
                            SquirtSqflPtszV(sqfl | sqflError,
                                            TEXT("DIHid_BuildHidListEntry ")
                                            TEXT("failed?"));
                        }

                    } 
                    else if(GetLastError() == ERROR_NO_MORE_ITEMS)
                    {
                        break;
                    } 
                    else
                    {
                        /* Skip erroneous items */
                        SquirtSqflPtszV(sqfl | sqflError,
                                        TEXT("SetupDiEnumDeviceInterface ")
                                        TEXT("failed? le=%d"), GetLastError());
                    }

                }

            }

            SetupDiDestroyDeviceInfoList(hdev);
        }
        else
        {
            SquirtSqflPtszV(sqfl | sqflError,
                TEXT("SetupDiGetClassDevs failed le=%d"), GetLastError());
        }

      #ifdef WINNT
        if( g_phdl && g_phdl->chdi )
        {
            DIWdm_InitJoyId();
        }
      #endif
      
        g_tmLastHIDRebuild = GetTickCount();
    }

    DllLeaveCrit();

    ExitProc();

}


DWORD DIHid_DetectHideAndRevealFlags( PCHID this )
{
    //  Get hold of the Devices Parent
    //  If the Parent a HID device that we know about ? 
    //      If the parent is a gaming device ( joystick / gamepad, etc )
    //          Mark the device as being "fictional"

    DWORD dwFlags2 = 0x0;
    HDEVINFO hdev;

    
    // We only detect and hide mice and keyboard, 
    // For now, there is no reason to hide other HID devices.
    // Futhermore the scheme to detect which devices to hide is based
    // on MSHs filter driver implementation where they eject PDOs for 
    // "fictional" devices. These fictional devices show up as childern of
    // gaming devices. FredBh (HID/PM) informs us that most multi-function devices he
    // has seen (mice and kbd) have had multiple top level collections. 
    AssertF( ( GET_DIDEVICE_TYPE( this->dwDevType ) == DI8DEVTYPE_MOUSE )
          || ( GET_DIDEVICE_TYPE( this->dwDevType ) == DI8DEVTYPE_KEYBOARD ) );

    hdev = SetupDiCreateDeviceInfoList(NULL, NULL);
    if (hdev != INVALID_HANDLE_VALUE)
    {
        SP_DEVINFO_DATA dinf;
        dinf.cbSize = cbX(SP_DEVINFO_DATA);
        if (SetupDiOpenDeviceInfo(hdev, this->ptszId, NULL, 0, &dinf))
        {
            DEVINST DevInst;
            if ( (CM_Get_Parent(&DevInst, dinf.DevInst, 0x0)) == CR_SUCCESS )
            {
                TCHAR tszId[MAX_PATH];
                if ( CR_SUCCESS == CM_Get_Device_ID(DevInst, tszId, MAX_PATH, 0x0 ))
                {
                    PHIDDEVICEINFO phdi;
                    DllEnterCrit();
                    phdi = phdiFindHIDDeviceId(tszId);

                    if ( phdi )
                    {
                        DWORD dwDevType = phdi->osd.dwDevType;
                        // If the device is a HID gaming device (in the broadest definition)
                        if ( ( GET_DIDEVICE_TYPE(dwDevType) >= DI8DEVTYPE_GAMEMIN ) 
                               && ( dwDevType & DIDEVTYPE_HID ) )
                        {
                            dwFlags2 = JOYTYPE_HIDEACTIVE;
                            
                            switch (GET_DIDEVICE_TYPE( this->dwDevType ))
                            {
                                case DI8DEVTYPE_MOUSE:
                                    dwFlags2 |= JOYTYPE_MOUSEHIDE;
                                    break;
                                case DI8DEVTYPE_KEYBOARD:
                                    dwFlags2 |= JOYTYPE_KEYBHIDE;
                                    break;
                                default:
                                    AssertF(0);
                            }
                        }
                    }

                    DllLeaveCrit();

                }
            }
        }
        SetupDiDestroyDeviceInfoList(hdev);
    }
    return dwFlags2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dilib2.c ===
/*****************************************************************************
 *
 *  DILib1.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Objects exported statically into our library.
 *
 *  Contents:
 *
 *      c_dfDIKeyboard
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global DIOBJECTDATAFORMAT | c_rgdoiDIKbd[] |
 *
 *          Device object data formats for keyboard-style access.
 *
 *  @doc    EXTERNAL
 *
 *  @global DIDATAFORMAT | c_dfDIKeyboard |
 *
 *          A predefined <t DIDATAFORMAT> structure which describes a
 *          keyboard device.  This object is provided in the
 *          DINPUT.LIB library file as a convenience.
 *
 *          A pointer to this structure may be passed to
 *          <mf IDirectInputDevice::SetDataFormat> to indicate that
 *          the device will be accessed in the form of a keyboard.
 *
 *          When a device has been set to the keyboard data format,
 *          the <mf IDirectInputDevice::GetDeviceState> function
 *          behaves in the same way as the Windows <f GetKeyboardState>
 *          function:  The device state is stored in an array of
 *          256 bytes, with each byte corresponding to the state
 *          of a key.  For example, if high bit of the <c DIK_ENTER>'th
 *          byte is set, then the Enter key is being held down.
 *
 *          When a device has been set to the keyboard data format,
 *          the <mf IDirectInputDevice::GetDeviceData> function
 *          returns a <t DIDEVICEOBJECTDATA> whose <p dwOfs>
 *          field is a <c DIK_*> value which describes the
 *          key which was pressed or released.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define MAKEODF(b)                                                      \
    { &GUID_Key, b,                                                     \
      DIDFT_BUTTON | DIDFT_MAKEINSTANCE(b) | 0x80000000, }              \

#define MAKEODF16(b) \
    MAKEODF(b+0x00), \
    MAKEODF(b+0x01), \
    MAKEODF(b+0x02), \
    MAKEODF(b+0x03), \
    MAKEODF(b+0x04), \
    MAKEODF(b+0x05), \
    MAKEODF(b+0x06), \
    MAKEODF(b+0x07), \
    MAKEODF(b+0x08), \
    MAKEODF(b+0x09), \
    MAKEODF(b+0x0A), \
    MAKEODF(b+0x0B), \
    MAKEODF(b+0x0C), \
    MAKEODF(b+0x0D), \
    MAKEODF(b+0x0E), \
    MAKEODF(b+0x0F)  \

static DIOBJECTDATAFORMAT c_rgodfDIKeyboard[] = {
    MAKEODF16(0x00),
    MAKEODF16(0x10),
    MAKEODF16(0x20),
    MAKEODF16(0x30),
    MAKEODF16(0x40),
    MAKEODF16(0x50),
    MAKEODF16(0x60),
    MAKEODF16(0x70),
    MAKEODF16(0x80),
    MAKEODF16(0x90),
    MAKEODF16(0xA0),
    MAKEODF16(0xB0),
    MAKEODF16(0xC0),
    MAKEODF16(0xD0),
    MAKEODF16(0xE0),
    MAKEODF16(0xF0),
};


const DIDATAFORMAT c_dfDIKeyboard = {
    sizeof(DIDATAFORMAT),
    sizeof(DIOBJECTDATAFORMAT),
    DIDF_RELAXIS,
    256,
    cA(c_rgodfDIKeyboard),
    c_rgodfDIKeyboard,
};

#pragma END_CONST_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dilib3.c ===
/*****************************************************************************
 *
 *  DILib3.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Objects exported statically into our library.
 *
 *  Contents:
 *
 *      c_dfDIJoystick
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global DIOBJECTDATAFORMAT | c_rgdoiDIJoy[] |
 *
 *          Device object data formats for joystick-style access.
 *
 *  @doc    EXTERNAL
 *
 *  @global DIDEVICEFORMAT | c_dfDIJoystick |
 *
 *          Predefined device format for joystick-style access.
 *
 *          When a device has been set to the joystick data format,
 *          the <mf IDirectInputDevice::GetDeviceState> function
 *          returns a <t DIJOYSTATE> structure, and the
 *          <mf IDirectInputDevice::GetDeviceData> function
 *          returns a <t DIDEVICEOBJECTDATA> whose <p dwOfs>
 *          field is a <c DIJOFS_*> value which describes the
 *          object whose data is being reported.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define MAKEVAL(guid, f, type, aspect)                                  \
    { &GUID_##guid,                                                     \
      FIELD_OFFSET(DIJOYSTATE, f),                                      \
      DIDFT_##type | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL,                \
      DIDOI_ASPECT##aspect,                                             \
    }                                                                   \

#define MAKEBTN(n)                                                      \
    { 0,                                                                \
      FIELD_OFFSET(DIJOYSTATE, rgbButtons[n]),                          \
      DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL,                \
      DIDOI_ASPECTUNKNOWN,                                              \
    }                                                                   \

static DIOBJECTDATAFORMAT c_rgodfDIJoy[] = {
    MAKEVAL( XAxis,  lX,         AXIS, POSITION),
    MAKEVAL( YAxis,  lY,         AXIS, POSITION),
    MAKEVAL( ZAxis,  lZ,         AXIS, POSITION),
    MAKEVAL(RxAxis,  lRx,        AXIS, POSITION),
    MAKEVAL(RyAxis,  lRy,        AXIS, POSITION),
    MAKEVAL(RzAxis,  lRz,        AXIS, POSITION),
    MAKEVAL(Slider,rglSlider[0], AXIS, POSITION),
    MAKEVAL(Slider,rglSlider[1], AXIS, POSITION),
    MAKEVAL(POV,     rgdwPOV[0], POV,  UNKNOWN),
    MAKEVAL(POV,     rgdwPOV[1], POV,  UNKNOWN),
    MAKEVAL(POV,     rgdwPOV[2], POV,  UNKNOWN),
    MAKEVAL(POV,     rgdwPOV[3], POV,  UNKNOWN),
    MAKEBTN( 0),
    MAKEBTN( 1),
    MAKEBTN( 2),
    MAKEBTN( 3),
    MAKEBTN( 4),
    MAKEBTN( 5),
    MAKEBTN( 6),
    MAKEBTN( 7),
    MAKEBTN( 8),
    MAKEBTN( 9),
    MAKEBTN(10),
    MAKEBTN(11),
    MAKEBTN(12),
    MAKEBTN(13),
    MAKEBTN(14),
    MAKEBTN(15),
    MAKEBTN(16),
    MAKEBTN(17),
    MAKEBTN(18),
    MAKEBTN(19),
    MAKEBTN(20),
    MAKEBTN(21),
    MAKEBTN(22),
    MAKEBTN(23),
    MAKEBTN(24),
    MAKEBTN(25),
    MAKEBTN(26),
    MAKEBTN(27),
    MAKEBTN(28),
    MAKEBTN(29),
    MAKEBTN(30),
    MAKEBTN(31),
};

const DIDATAFORMAT c_dfDIJoystick = {
    sizeof(DIDATAFORMAT),
    sizeof(DIOBJECTDATAFORMAT),
    DIDF_ABSAXIS,
    sizeof(DIJOYSTATE),
    cA(c_rgodfDIJoy),
    c_rgodfDIJoy,
};

#pragma END_CONST_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dilib4.c ===
/*****************************************************************************
 *
 *  DILib4.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Objects exported statically into our library.
 *
 *  Contents:
 *
 *      c_dfDIJoystick2
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global DIOBJECTDATAFORMAT | c_rgdoiDIJoy2[] |
 *
 *          Device object data formats for joystick-style access.
 *
 *  @doc    EXTERNAL
 *
 *  @global DIDEVICEFORMAT | c_dfDIJoystick2 |
 *
 *          Predefined device format for extended joystick-style access.
 *
 *          When a device has been set to the joystick data format,
 *          the <mf IDirectInputDevice::GetDeviceState> function
 *          returns a <t DIJOYSTATE2> structure, and the
 *          <mf IDirectInputDevice::GetDeviceData> function
 *          returns a <t DIDEVICEOBJECTDATA> whose <p dwOfs>
 *          field is a <c DIJOFS_*> value which describes the
 *          object whose data is being reported.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define MAKEVAL(guid, f, type, aspect)                                  \
    { &GUID_##guid,                                                     \
      FIELD_OFFSET(DIJOYSTATE2, f),                                     \
      DIDFT_##type | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL,                \
      DIDOI_ASPECT##aspect,                                             \
    }                                                                   \

#define MAKEVALS(l, aspect)                                             \
    MAKEVAL( XAxis,l##X,           AXIS, aspect),                       \
    MAKEVAL( YAxis,l##Y,           AXIS, aspect),                       \
    MAKEVAL( ZAxis,l##Z,           AXIS, aspect),                       \
    MAKEVAL(RxAxis,l##Rx,          AXIS, aspect),                       \
    MAKEVAL(RyAxis,l##Ry,          AXIS, aspect),                       \
    MAKEVAL(RzAxis,l##Rz,          AXIS, aspect),                       \
    MAKEVAL(Slider,rgl##Slider[0], AXIS, aspect),                       \
    MAKEVAL(Slider,rgl##Slider[1], AXIS, aspect)                        \

#define MAKEPOV(n)                                                      \
    MAKEVAL(POV,     rgdwPOV[n], POV,  UNKNOWN)                         \

#define MAKEBTN(n)                                                      \
    { 0,                                                                \
      FIELD_OFFSET(DIJOYSTATE2, rgbButtons[n]),                         \
      DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL,                \
      DIDOI_ASPECTUNKNOWN,                                              \
    }                                                                   \

#define MAKEBTNS(n)                                                     \
    MAKEBTN(n + 0x00),                                                  \
    MAKEBTN(n + 0x01),                                                  \
    MAKEBTN(n + 0x02),                                                  \
    MAKEBTN(n + 0x03),                                                  \
    MAKEBTN(n + 0x04),                                                  \
    MAKEBTN(n + 0x05),                                                  \
    MAKEBTN(n + 0x06),                                                  \
    MAKEBTN(n + 0x07),                                                  \
    MAKEBTN(n + 0x08),                                                  \
    MAKEBTN(n + 0x09),                                                  \
    MAKEBTN(n + 0x0A),                                                  \
    MAKEBTN(n + 0x0B),                                                  \
    MAKEBTN(n + 0x0C),                                                  \
    MAKEBTN(n + 0x0D),                                                  \
    MAKEBTN(n + 0x0E),                                                  \
    MAKEBTN(n + 0x0F)                                                   \

static DIOBJECTDATAFORMAT c_rgodfDIJoy2[] = {
    MAKEVALS(l, POSITION),
    MAKEPOV(0),
    MAKEPOV(1),
    MAKEPOV(2),
    MAKEPOV(3),
    MAKEBTNS(0x00),
    MAKEBTNS(0x10),
    MAKEBTNS(0x20),
    MAKEBTNS(0x30),
    MAKEBTNS(0x40),
    MAKEBTNS(0x50),
    MAKEBTNS(0x60),
    MAKEBTNS(0x70),
    MAKEVALS(lV, VELOCITY),
    MAKEVALS(lA, ACCEL),
    MAKEVALS(lF, FORCE),
};

const DIDATAFORMAT c_dfDIJoystick2 = {
    sizeof(DIDATAFORMAT),
    sizeof(DIOBJECTDATAFORMAT),
    DIDF_ABSAXIS,
    sizeof(DIJOYSTATE2),
    cA(c_rgodfDIJoy2),
    c_rgodfDIJoy2,
};

#pragma END_CONST_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dijoycfg.c ===
/*****************************************************************************
*
*  DIJoyCfg.c
*
*  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
*
*  Abstract:
*
*      IDirectInputJoyConfig8
*
*  Contents:
*
*      CJoyCfg_New
*
*****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflJoyCfg


BOOL  fVjoydDeviceNotExist = TRUE;
#ifdef WINNT
WCHAR wszDITypeName[128];
#endif

    #pragma BEGIN_CONST_DATA

/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *      WARNING!  If you add a secondary interface, you must also change
 *      CJoyCfg_New!
 *
 *****************************************************************************/

Primary_Interface(CJoyCfg, IDirectInputJoyConfig8);

Interface_Template_Begin(CJoyCfg)
Primary_Interface_Template(CJoyCfg, IDirectInputJoyConfig8)
Interface_Template_End(CJoyCfg)

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CJoyCfg |
 *
 *          The <i IDirectInputJoyConfig8> object.  Note that this is
 *          aggregated onto the main <i IDirectInput> object.
 *
 *  @field  IDirectInputJoyConfig8 | djc |
 *
 *          The object (containing vtbl).
 *
 *  @field  BOOL | fAcquired:1 |
 *
 *          Set if joystick configuration has been acquired.
 *
 *  @field  BOOL | fCritInited:1 |
 *
 *          Set if the critical section has been initialized.
 *
 *  @field  HKEY | hkTypesW |
 *
 *          Read/write key to access the joystick types.
 *          This key is created only while acquired.
 *
 *  @field  DWORD | idJoyCache |
 *
 *          The identifier of the joystick in the effect shepherd cache,
 *          if there is anything in the cache at all.
 *
 *  @field  IDirectInputEffectShepherd * | pes |
 *
 *          The cached effect shepherd itself.
 *
 *  @field  LONG | cCrit |
 *
 *          Number of times the critical section has been taken.
 *          Used only in XDEBUG to check whether the caller is
 *          releasing the object while another method is using it.
 *
 *  @field  DWORD | thidCrit |
 *
 *          The thread that is currently in the critical section.
 *          Used only in DEBUG for internal consistency checking.
 *
 *  @field  CRITICAL_SECTION | crst |
 *
 *          Object critical section.  Must be taken when accessing
 *          volatile member variables.
 *
 *****************************************************************************/

typedef struct CJoyCfg
{

    /* Supported interfaces */
    IDirectInputJoyConfig8 djc;

    BOOL fAcquired:1;
    BOOL fCritInited:1;

    HKEY hkTypesW;
    HWND hwnd;

    DWORD discl;

    DWORD idJoyCache;
    LPDIRECTINPUTEFFECTSHEPHERD pes;

    RD(LONG cCrit;)
    D(DWORD thidCrit;)
    CRITICAL_SECTION crst;

} CJoyCfg, JC, *PJC;

typedef LPDIRECTINPUTJOYCONFIG8 PDJC;


    #define ThisClass CJoyCfg
    #define ThisInterface  IDirectInputJoyConfig8
    #define ThisInterfaceT IDirectInputJoyConfig8

/*****************************************************************************
 *
 *      Forward references
 *
 *      Not really needed; just a convenience, because Finalize
 *      calls Unacquire to clean up in the case where the caller forgot.
 *
 *****************************************************************************/

STDMETHODIMP CJoyCfg_InternalUnacquire(PV pdd);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   TCHAR | CJoyCfg_CharFromType |
 *
 *          Convert a predefined type number to a character.
 *
 *  @func   UINT | CJoyCfg_TypeFromChar |
 *
 *          Convert a character back to a predefined type number.
 *
 *****************************************************************************/

    #define CJoyCfg_CharFromType(t)     ((TCHAR)(L'0' + t))
    #define CJoyCfg_TypeFromChar(tch)   ((tch) - L'0')

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | IDirectInputJoyConfig8 | EnterCrit |
 *
 *          Enter the object critical section.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *****************************************************************************/

void INLINE
    CJoyCfg_EnterCrit(PJC this)
{
    EnterCriticalSection(&this->crst);
    D(this->thidCrit = GetCurrentThreadId());
    RD(InterlockedIncrement(&this->cCrit));
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | IDirectInputJoyConfig8 | LeaveCrit |
 *
 *          Leave the object critical section.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *****************************************************************************/

void INLINE
    CJoyCfg_LeaveCrit(PJC this)
{
    #ifdef XDEBUG
    AssertF(this->cCrit);
    AssertF(this->thidCrit == GetCurrentThreadId());
    if(InterlockedDecrement(&this->cCrit) == 0)
    {
        D(this->thidCrit = 0);
    }
    #endif
    LeaveCriticalSection(&this->crst);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @mfunc  BOOL | CJoyCfg | InCrit |
 *
 *          Nonzero if we are in the critical section.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *****************************************************************************/

    #ifdef DEBUG

BOOL INTERNAL
    CJoyCfg_InCrit(PJC this)
{
    return this->cCrit && this->thidCrit == GetCurrentThreadId();
}

    #endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoyCfg | IsAcquired |
 *
 *          Check that the device is acquired.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @returns
 *
 *          Returns
 *          <c S_OK> if all is well, or <c DIERR_NOTACQUIRED> if
 *          the device is not acquired.
 *
 *
 *****************************************************************************/

    #ifndef XDEBUG
\
        #define CJoyCfg_IsAcquired_(pdd, z)                                 \
       _CJoyCfg_IsAcquired_(pdd)                                    \

    #endif

    HRESULT INLINE
    CJoyCfg_IsAcquired_(PJC this, LPCSTR s_szProc)
{
    HRESULT hres;

    if(this->fAcquired)
    {
        hres = S_OK;
    } else
    {
        RPF("ERROR %s: Not acquired", s_szProc);
        hres = DIERR_NOTACQUIRED;
    }
    return hres;
}

    #define CJoyCfg_IsAcquired(pdd)                                     \
        CJoyCfg_IsAcquired_(pdd, s_szProc)                          \


/*****************************************************************************
 *
 *      CJoyCfg::QueryInterface   (from IUnknown)
 *      CJoyCfg::AddRef           (from IUnknown)
 *      CJoyCfg::Release          (from IUnknown)
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoyCfg | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoyCfg | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoyCfg | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @returns
 *
 *      Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoyCfg | QIHelper |
 *
 *      We don't have any dynamic interfaces and simply forward
 *      to <f Common_QIHelper>.
 *
 *  @parm   IN REFIID | riid |
 *
 *      The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *      Receives a pointer to the obtained interface.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoyCfg | AppFinalize |
 *
 *          We don't have any weak pointers, so we can just
 *          forward to <f Common_Finalize>.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released from the application's perspective.
 *
 *****************************************************************************/

    #ifdef DEBUG

Default_QueryInterface(CJoyCfg)
Default_AddRef(CJoyCfg)
Default_Release(CJoyCfg)

    #else

        #define CJoyCfg_QueryInterface   Common_QueryInterface
        #define CJoyCfg_AddRef           Common_AddRef
        #define CJoyCfg_Release          Common_Release

    #endif

    #define CJoyCfg_QIHelper         Common_QIHelper
    #define CJoyCfg_AppFinalize      Common_AppFinalize

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoyCfg | InternalUnacquire |
 *
 *          Do the real work of an unacquire.
 *
 *          See <mf IDirectInputJoyConfig8::Unacquire> for more
 *          information.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG88
 *
 *  @returns
 *
 *          Returns a COM error code.
 *          See <mf IDirectInputJoyConfig8::Unacquire> for more
 *          information.
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_InternalUnacquire(PJC this)
{
    HRESULT hres;
    EnterProc(CJoyCfg_InternalUnacquire, (_ "p", this));

    /*
     *  Must protect with the critical section to prevent somebody from
     *  interfering with us while we're unacquiring.
     */
    CJoyCfg_EnterCrit(this);

    if(this->fAcquired)
    {

        AssertF(this->hkTypesW);

        RegCloseKey(this->hkTypesW);

        this->hkTypesW = 0;

        Invoke_Release(&this->pes);

        Excl_Unacquire(&IID_IDirectInputJoyConfig, this->hwnd, this->discl);

        this->fAcquired = 0;
        hres = S_OK;
    } else
    {
        hres = S_FALSE;
    }

    CJoyCfg_LeaveCrit(this);

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CJoyCfg_Finalize |
 *
 *          Releases the resources of the device.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
    CJoyCfg_Finalize(PV pvObj)
{
    PJC this = pvObj;

    #ifdef XDEBUG
    if(this->cCrit)
    {
        RPF("IDirectInputJoyConfig8::Release: Another thread is using the object; crash soon!");
    }
    #endif

    if(this->fAcquired)
    {
        CJoyCfg_InternalUnacquire(this);
    }

    AssertF(this->pes == 0);

    if(this->hkTypesW)
    {
        RegCloseKey(this->hkTypesW);
    }

    if(this->fCritInited)
    {
        DeleteCriticalSection(&this->crst);
    }

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputJoyConfig8 | SetCooperativeLevel |
 *
 *          Establish the cooperativity level for the instance of
 *          the device.
 *
 *          The only cooperative levels supported for the
 *          <i IDirectInputJoyConfig8> interface are
 *          <c DISCL_EXCLUSIVE> and <c DISCL_BACKGROUND>.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @parm   HWND | hwnd |
 *
 *          The window associated with the interface. This parameter
 *          must be non-NULL and must be a top-level window.
 *
 *          It is an error to destroy the window while it is still
 *          associated with an <i IDirectInputJoyConfig8> interface.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags which describe the cooperativity level associated
 *          with the device.
 *
 *          The value must be
 *          <c DISCL_EXCLUSIVE> <vbar> <c DISCL_BACKGROUND>.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p hwnd> parameter is not a valid pointer.
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_SetCooperativeLevel(PDJC pdjc, HWND hwnd, DWORD dwFlags)
{
    HRESULT hres;
    EnterProcR(IDirectInputJoyConfig8::SetCooperativityLevel,
               (_ "pxx", pdjc, hwnd, dwFlags));

    if(SUCCEEDED(hres = hresPv(pdjc)))
    {
        PJC this = _thisPvNm(pdjc, djc);

        if(dwFlags != (DISCL_EXCLUSIVE | DISCL_BACKGROUND))
        {
            RPF("%s: Cooperative level must be "
                "DISCL_EXCLUSIVE | DISCL_BACKGROUND", s_szProc);
            hres = E_NOTIMPL;
        } else if(GetWindowPid(hwnd) == GetCurrentProcessId())
        {
            this->hwnd = hwnd;
            this->discl = dwFlags;
            hres = S_OK;
        } else
        {
            RPF("ERROR %s: window must belong to current process", s_szProc);
            hres = E_HANDLE;
        }
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputJoyConfig8 | Acquire |
 *
 *          Acquire "joystick configuration mode".  Only one application can
 *          be in joystick configuration mode at a time; subsequent
 *          applications will receive the error <c DIERR_OTHERAPPHASPRIO>.
 *
 *          After entering configuration mode, the application may
 *          make alterations to the global joystick configuration
 *          settings.  It is encouraged that the application
 *          re-check the existing settings before installing the new
 *          ones in case another application had changed the settings
 *          in the interim.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_OTHERAPPHASPRIO>: Another application is already
 *          in joystick configuration mode.
 *
 *          <c DIERR_INSUFFICIENTPRIVS>: The current user does not have
 *          the necessary permissions to alter the joystick configuration.
 *
 *          <c DIERR_DEVICECHANGE>: Another application has changed
 *          the global joystick configuration.  The interface needs
 *          to be re-initialized.
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_Acquire(PDJC pdjc)
{
    HRESULT hres;
    EnterProcR(IDirectInputJoyConfig8::Acquire, (_ "p", pdjc));

    if(SUCCEEDED(hres = hresPv(pdjc)))
    {
        PJC this = _thisPvNm(pdjc, djc);

        /*
         *  Must protect with the critical section to prevent somebody from
         *  acquiring or changing the data format while we're acquiring.
         */
        CJoyCfg_EnterCrit(this);

        if(this->discl == 0)
        {
            RPF("%s: Cooperative level not yet set", s_szProc);
            hres = E_FAIL;
            goto done;
        }

        if(this->fAcquired)
        {
            AssertF(this->hkTypesW);
            hres = S_FALSE;
        } else if(SUCCEEDED(hres = Excl_Acquire(&IID_IDirectInputJoyConfig,
                                                this->hwnd, this->discl)))
        {
            AssertF(this->hkTypesW == 0);


            hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE, 
                                   REGSTR_PATH_JOYOEM, 
                                   DI_KEY_ALL_ACCESS, 
                                   REG_OPTION_NON_VOLATILE, 
                                   &this->hkTypesW);

            if(SUCCEEDED(hres) )
            {
                this->fAcquired = 1;
            } else
            {
                RegCloseKey(this->hkTypesW);
                this->hkTypesW = 0;
                hres = DIERR_INSUFFICIENTPRIVS;
            }

        }

        done:;
        CJoyCfg_LeaveCrit(this);
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputJoyConfig8 | Unacquire |
 *
 *          Unacquire "joystick configuration mode".  Before unacquiring
 *          configuration mode, the application must perform an
 *          <mf IDirectInputJoyConfig8::SendNotify> to propagate
 *          the changes in the joystick configuration
 *          to all device drivers and applications.
 *
 *          Applications which hold interfaces to a joystick which is
 *          materially affected by a change in configuration will
 *          receive the <c DIERR_DEVICECHANGE> error code until the
 *          device is re-initialized.
 *
 *          Examples of material changes to configuration include
 *          altering the number of axes or the number of buttons.
 *          In comparison, changes to device calibration
 *          are handled internally by
 *          DirectInput and are transparent to the application.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTACQUIRED>: Joystick configuration mode was
 *          not acquired.
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_Unacquire(PDJC pdjc)
{
    HRESULT hres;
    EnterProcR(IDirectInputJoyConfig8::Unacquire, (_ "p", pdjc));

    if(SUCCEEDED(hres = hresPv(pdjc)))
    {
        PJC this = _thisPvNm(pdjc, djc);

        hres = CJoyCfg_InternalUnacquire(this);

    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputJoyConfig8 | SendNotify |
 *
 *          Notifies device drivers and applications that changes to
 *          the device configuration have been made.  An application
 *          which changes device configurations must invoke this
 *          method after the changes have been made (and before
 *          unacquiring).
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTACQUIRED>: Joystick configuration mode was
 *          not acquired.
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_SendNotify(PDJC pdjc)
{
    HRESULT hres;
    EnterProcR(IDirectInputJoyConfig8::SendNotify, (_ "p", pdjc));

    if(SUCCEEDED(hres = hresPv(pdjc)))
    {
        PJC this = _thisPvNm(pdjc, djc);

        CJoyCfg_EnterCrit(this);

        if(this->fAcquired)
        {
          #ifdef WINNT
            Excl_SetConfigChangedTime( GetTickCount() );
            PostMessage(HWND_BROADCAST, g_wmJoyChanged, 0, 0L);   
          #else
            joyConfigChanged(0);
          #endif

            /*
             *  If we don't have a joyConfigChanged, it's probably just 
             *  because we're running on NT and don't need it.
             */
            hres = S_OK;
        } else
        {
            hres = DIERR_NOTACQUIRED;
        }

        CJoyCfg_LeaveCrit(this);
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyCfg_ConvertCurrentConfigs |
 *
 *          Converts any OEMType name matching the first input string and 
 *          replaces it with the other input string.
 *
 *  @parm   IN LPTSTR | szFindType |
 *
 *          String to match.
 *
 *  @parm   IN LPTSTR | szReplaceType |
 *
 *          String to replace any matches instances.
 *
 *  @returns
 *
 *          A COM success code unless the current configuration key could not
 *          be opened, or a type that needed to be replaced could not be 
 *          overwritten.
 *
 *****************************************************************************/

HRESULT JoyCfg_ConvertCurrentConfigs( LPTSTR szFindType, LPTSTR szReplaceType )
{
    HRESULT hres;
    LONG    lRc;
    HKEY    hkCurrCfg;
    UINT    JoyId;
    TCHAR   szTestType[MAX_JOYSTRING];
    TCHAR   szTypeName[MAX_JOYSTRING];
    DWORD   cb;

    EnterProcI(JoyCfg_ConvertCurrentConfigs, (_ "ss", szFindType, szReplaceType ));

    hres = JoyReg_OpenConfigKey( (UINT)(-1), KEY_WRITE, REG_OPTION_NON_VOLATILE, &hkCurrCfg );

    if( SUCCEEDED( hres ) )
    {
        for( JoyId = 0; (JoyId < 16) || ( lRc == ERROR_SUCCESS ); JoyId++ )
        {
            wsprintf( szTypeName, REGSTR_VAL_JOYNOEMNAME, JoyId+1 );
            cb = sizeof( szTestType );
            lRc = RegQueryValueEx( hkCurrCfg, szTypeName, 0, NULL, (PBYTE)szTestType, &cb );
            if( lRc == ERROR_SUCCESS )
            {
                if( !lstrcmpi( szTestType, szFindType ) )
                {
                    cb = sizeof( szReplaceType) * (1 + lstrlen( szReplaceType ));
                    lRc = RegSetValueEx( hkCurrCfg, szTypeName, 0, REG_SZ, (PBYTE)szReplaceType, cb );
                    if( lRc != ERROR_SUCCESS )
                    {
                        SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("RegSetValueEx failed to replace type of %s 0x%08x"), 
                            szTypeName, lRc );
                        /* This is the only error that counts as an error in this loop */
                        hres = hresReg( lRc );
                    }
                }
            }
        }

    }
    else
    {
        SquirtSqflPtszV(sqfl | sqflError,
            TEXT("JoyReg_OpenConfigKey failed code 0x%08x"), hres );
    }

    ExitOleProc();

    return hres;

} /* JoyCfg_ConvertCurrentConfigs */


#ifdef WINNT
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyCfg_FixHardwareId |
 *
 *          Fixes the hardwareId for an analog type by assinging a VID/PID to 
 *          it and recreating the type using that hardwareId.
 *
 *  @parm   IN HKEY | hkTypesR |
 *
 *          Handle of key opened to the root of types.
 *
 *  @parm   IN HKEY | hkSrc |
 *
 *          Handle of key opened to the original type.
 *
 *  @parm   IN PTCHAR | ptszPrefName |
 *
 *          VID&PID name from the HardwareID if present, NULL otherwise
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The key is valid
 *          <c DI_NOEFFECT> = <c S_FALSE> The key should be ignored
 *
 *          <c OLE_E_ENUM_NOMORE> = The key has been fixed but enumeration
 *                                  must be restarted.
 *          <c DIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:  Out of memory.
 *
 *****************************************************************************/

HRESULT INTERNAL
    JoyCfg_FixHardwareId( HKEY hkTypesR, HKEY hkSrc, PTCHAR szSrcType , PTCHAR ptszPrefName)
{
    HRESULT hres;
    HKEY    hkNew = NULL;
    BYTE    PIDlow;
    DWORD   ClassLen;
    PTCHAR  szClassName;
    TCHAR   szDestType[sizeof( ANALOG_ID_ROOT ) + 2];  //Two digits will be appended
    TCHAR   szHardwareId[MAX_JOYSTRING];

    EnterProcI(JoyCfg_FixHardwareId, (_ "xxs", hkTypesR, hkSrc, szSrcType));

    hres = hresReg( RegQueryInfoKey(  hkSrc,              // handle to key to query
                                      NULL,               // Class
                                      &ClassLen,          // ClassLen
                                      NULL,               // Reserved
                                      NULL, NULL, NULL,   // NumSubKeys, MaxSubKeyLen, MaxClassLen
                                      NULL, NULL, NULL,   // NumValues, MaxValueNameLen, MaxValueLen
                                      NULL, NULL ) );     // Security descriptor, last write

    if( SUCCEEDED( hres ) )
    {
        ClassLen++;
        /*
         *  Part of mb:34633 (see below, 2 comments) was that prefix considers 
         *  the case of zero bytes being requested in the following call so 
         *  assert that we always ask for some memory otherwise checking the 
         *  result does not guarantee that the pointer is valid.
         */
        AssertF( ClassLen * sizeof(szClassName[0]) );
        hres = AllocCbPpv( ClassLen * sizeof(szClassName[0]), &szClassName );
        if( SUCCEEDED( hres ) )
        {
            hres = hresReg( RegQueryInfoKey(  hkSrc,              // handle to key to query
                                              szClassName,        // Class
                                              &ClassLen,          // ClassLen
                                              NULL,               // Reserved
                                              NULL, NULL, NULL,   // NumSubKeys, MaxSubKeyLen, MaxClassLen
                                              NULL, NULL, NULL,   // NumValues, MaxValueNameLen, MaxValueLen
                                              NULL, NULL ) );     // Security descriptor, last write
            if( FAILED( hres ) )
            {
                SquirtSqflPtszV(sqfl | sqflError,
                    TEXT("RegQueryInfoKey on type %s for class name failed 0x%04x"), 
                    szSrcType, LOWORD(hres) );
            }
        }
        else
        {
            SquirtSqflPtszV(sqfl | sqflError,
                TEXT("Failed to allocate %d bytes for class name of type %s, error 0x%04x"), 
                ClassLen, szSrcType, LOWORD(hres) );
        }
    }
    else
    {
        SquirtSqflPtszV(sqfl | sqflError,
            TEXT("RegQueryInfoKey on type %s for class name length failed 0x%04x"), 
            szSrcType, LOWORD(hres) );
        /* Make sure not to free an uninitialized pointer */
        szClassName = NULL;
    }

    if( SUCCEEDED( hres ) )
    {
        for( PIDlow = JOY_HW_PREDEFMAX+1; PIDlow; PIDlow++ )
        {
            if (ptszPrefName)
            {
                lstrcpy( szDestType, ptszPrefName);
#ifdef UNICODE
                CharUpperW(szDestType);
#else
                CharUpper(szDestType);
#endif
            }
            else
            {
                wsprintf( szDestType, TEXT("%s%02X"), ANALOG_ID_ROOT, PIDlow );
            }
            hres = hresRegCopyKey( hkTypesR, szSrcType, szClassName, hkTypesR, szDestType, &hkNew );
            if( hres == S_OK )
            {
                /*
                 *  Prefix warns that hkNew may be uninitialized (mb:34633) 
                 *  however hresRegCopyKey only returns a SUCCESS if hkNew 
                 *  is initialized to an opened key handle.
                 */
                hres = hresRegCopyBranch( hkSrc, hkNew );

                if( SUCCEEDED( hres ) )
                {
                    if (!ptszPrefName)
                    {
#ifdef MULTI_SZ_HARDWARE_IDS
                        /*
                         *  Make up the hardwareId using the assigned PID with a generic hardwareId appended
                         */
                        int CharIdx = 0;
                        while( TRUE )
                        {
                            CharIdx += wsprintf( &szHardwareId[CharIdx], TEXT("%s%s%02X"), TEXT("GamePort\\"), ANALOG_ID_ROOT, PIDlow );
                            CharIdx++;    /* Leave NULL terminator in place */
                            if( PIDlow )
                            {
                                PIDlow = 0; /* Trash this value to make the generic PID on second iteration */
                            }
                            else
                            {
                                break;
                            }
                        }
                        szHardwareId[CharIdx++] = TEXT('\0'); /* MULTI_SZ */

                        hres = hresReg( RegSetValueEx( hkNew, REGSTR_VAL_JOYOEMHARDWAREID, 0, 
                            REG_MULTI_SZ, (PBYTE)szHardwareId, (DWORD)( sizeof(szHardwareId[0]) * CharIdx ) ) );
                        if( FAILED( hres ) )
                        {
                            SquirtSqflPtszV(sqfl | sqflBenign,
                                TEXT("JoyCfg_FixHardwareId: failed to write hardware ID %s"), szHardwareId );
                        }
#else
                        /*
                         *  Make up the hardwareId using the assigned PID
                         */
                        int CharIdx = 0;
                        CharIdx = wsprintf( szHardwareId, TEXT("%s%s%02X"), TEXT("GamePort\\"), ANALOG_ID_ROOT, PIDlow );
                        CharIdx++;    /* Leave NULL terminator in place */

                        hres = hresReg( RegSetValueEx( hkNew, REGSTR_VAL_JOYOEMHARDWAREID, 0, 
                            REG_SZ, (PBYTE)szHardwareId, (DWORD)( sizeof(szHardwareId[0]) * CharIdx ) ) );
                        if( FAILED( hres ) )
                        {
                            SquirtSqflPtszV(sqfl | sqflBenign,
                                TEXT("JoyCfg_FixHardwareId: failed to write hardware ID %s"), szHardwareId );
                        }
#endif
                    }
                }

                /*
                 *  Prefix warns that hkNew may be uninitialized (mb:34633) 
                 *  however hresRegCopyKey only returns a SUCCESS if hkNew 
                 *  is initialized to an opened key handle.
                 */
                RegCloseKey( hkNew );
                if( SUCCEEDED( hres ) )
                {
                    hres = JoyCfg_ConvertCurrentConfigs( szSrcType, szDestType );
                }

                DIWinnt_RegDeleteKey( hkTypesR, ( SUCCEEDED( hres ) ) ? szSrcType
                                                                      : szDestType );
                break;
            }
            else if( SUCCEEDED( hres ) )
            {
                /*
                 *  Prefix warns that hkNew may be uninitialized (mb:37926) 
                 *  however hresRegCopyKey only returns a SUCCESS if hkNew 
                 *  is initialized to an opened key handle.
                 */
                /*
                 *  The key already existed so keep looking
                 */
                RegCloseKey( hkNew );
            }
            else
            {
                /*
                 *  RegCopyKey should have already posted errors
                 */
                break;
            }
        }
        if( !PIDlow )
        {
            SquirtSqflPtszV(sqfl | sqflBenign,
                TEXT("JoyCfg_FixHardwareId: no free analog keys for type %s"), 
                szSrcType );
            hres = DIERR_NOTFOUND;
        }
    }

    if( szClassName )
    {
        FreePpv( &szClassName );
    }


    ExitOleProc();

    return( hres );        
} /* JoyCfg_FixHardwareId */
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyCfg_CheckTypeKey |
 *
 *          Checks the contents of a type key for validity on the current OS
 *          and if not valid, try to make it so.
 *
 *          Only custom analog types can be fixed and this only needs to be 
 *          done on a WDM enabled OS as non-WDM requirements are a sub-set of
 *          the WDM ones.
 *
 *  @parm   IN HKEY | hkTypesR |
 *
 *          Handle of key opened to the root of types.
 *
 *  @parm   IN LPTSTR | szType |
 *
 *          Receives a pointer either an ansi or UNICODE key name to test.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The key is valid
 *          <c DI_NOEFFECT> = <c S_FALSE> The key should be ignored
 *
 *          <c OLE_E_ENUM_NOMORE> = The key has been fixed but enumeration
 *                                  must be restarted.
 *          <c DIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:  Out of memory.
 *
 *****************************************************************************/

HRESULT INTERNAL
    JoyCfg_CheckTypeKey( HKEY hkTypesR, LPTSTR szType )
{
    HRESULT hres;
    HKEY hk;
    LONG lRc;
    DWORD cb;

    TCHAR tszCallout[MAX_JOYSTRING];
    TCHAR tszHardwareId[MAX_JOYSTRING];
#ifdef WINNT
    JOYREGHWSETTINGS hws;
    TCHAR* ptszLastSlash=NULL;
#endif
    
    EnterProcI(JoyCfg_CheckTypeKey, (_ "xs",hkTypesR, szType));

    /*
     *  Open read only just in case we don't have better permission to any 
     *  of the type sub-keys.
     */
    lRc = RegOpenKeyEx( hkTypesR, szType, 0, KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, &hk );

    if(lRc == ERROR_SUCCESS )
    {
        /*
         *  Gather the needed results using standard registry functions so 
         *  that the exact return code is known.
         */

        lRc = RegQueryValueEx(hk, REGSTR_VAL_JOYOEMNAME, NULL, NULL, NULL, NULL );

#ifdef WINNT
        if(lRc == ERROR_SUCCESS )
        {
            cb = cbX(hws);
            lRc = RegQueryValueEx(hk, REGSTR_VAL_JOYOEMDATA, NULL, NULL, (PBYTE)&hws, &cb );
            if( ( lRc == ERROR_SUCCESS ) && ( hws.dwFlags & JOY_HWS_AUTOLOAD ) )
            {
                /*
                 *  WARNING goto
                 *  If we have a name and JOY_HWS_AUTOLOAD is set, that's all we need
                 */
                RegCloseKey( hk );
                hres = S_OK;
                goto fast_out;
            }
             
            if( lRc == ERROR_FILE_NOT_FOUND )
            {
                hws.dwFlags = 0;
                lRc = ERROR_SUCCESS;
            }
        }
#endif

        if(lRc == ERROR_SUCCESS )
        {
            cb = cbX(tszCallout);
            lRc = RegQueryValueEx(hk, REGSTR_VAL_JOYOEMCALLOUT, NULL, NULL, (PBYTE)tszCallout, &cb );
            if( lRc == ERROR_FILE_NOT_FOUND )
            {
                tszCallout[0] = TEXT('\0');
                lRc = ERROR_SUCCESS;
            }
        }

        if(lRc == ERROR_SUCCESS )
        {
            cb = cbX(tszHardwareId);
            lRc = RegQueryValueEx(hk, REGSTR_VAL_JOYOEMHARDWAREID, NULL, NULL, (PBYTE)tszHardwareId, &cb );
            if( lRc == ERROR_FILE_NOT_FOUND )
            {
                tszHardwareId[0] = TEXT('\0');
                lRc = ERROR_SUCCESS;
            }
#ifdef WINNT
            else
            {
                TCHAR* ptsz;
                for (ptsz = tszHardwareId;*ptsz!='\0';++ptsz)
                {
                    if (*ptsz == '\\')
                    {
                        ptszLastSlash = ptsz;
                    }
                }
                if (ptszLastSlash)
                {
                    ptszLastSlash++; //next char is the one we want
                }
            }
#endif
        }


        if(lRc != ERROR_SUCCESS )
        {
            RegCloseKey( hk );
        }
    }

    if(lRc == ERROR_SUCCESS )
    {
#ifdef WINNT
        SHORT DontCare;
#endif
        WCHAR wszType[18];

        TToU( wszType, cA(wszType),szType );

        /*
         *  Work out the status of this type based on the OS and the registry data
         *
         *  Note on 98 we allow WDM types to be enumerated but do not convert 
         *  analog types to WDM.  We may want to convert analog types if we get 
         *  WDM gameport drivers appear for gameports that are incompatible with 
         *  msanalog.
         */

#define HAS_VIDPID ( ParseVIDPID( &DontCare, &DontCare, wszType ) )
#define HAS_HARDWARE_ID ( tszHardwareId[0] != TEXT('\0') )
#define HAS_OEMCALLOUT ( tszCallout[0] != TEXT('\0') )
#define IS_ANALOG \
        ( tszHardwareId[ sizeof( ANALOG_ID_ROOT ) - 1 ] = TEXT('\0'), \
          ( !lstrcmpi( tszHardwareId, ANALOG_ID_ROOT ) ) )
#define IS_WIN98 (HidD_GetHidGuid)

#ifdef WINNT
        if (HAS_HARDWARE_ID)
        {
            //Need to check if there is a VID and PID in the HW ID
            if (ParseVIDPID(&DontCare, &DontCare, ptszLastSlash))
            {
                //If the type VIDPID doesn't match the HardwareId VIDPID
                //we need to fix it
                if (!lstrcmpi(ptszLastSlash,wszType))
                {
                    SquirtSqflPtszV(sqfl | sqflVerbose,
                      TEXT("OEMHW %s(%s) and/or Type %s have matching VID/PID"), 
                      tszHardwareId,ptszLastSlash,wszType);
                    hres = S_OK;
                }
                else
                {
                    hres = OLE_E_ENUM_NOMORE;
                    SquirtSqflPtszV(sqfl | sqflVerbose,
                      TEXT("OEMHW %s(%s) and/or Type %s have non-matching VID/PID. Fix Needed."), 
                      tszHardwareId,ptszLastSlash,wszType);
                }
            }
            else
            {
                hres = S_OK; //no VIDPID in the type
                SquirtSqflPtszV(sqfl | sqflVerbose,
                    TEXT("OEMHW %s(%s) and/or Type %s have no VID/PID"), 
                    tszHardwareId,ptszLastSlash,wszType);
            }
        }
        else
        {
            if (HAS_VIDPID)
            {
                hres = DIERR_MOREDATA;
            }
            else
            {
                if (HAS_OEMCALLOUT)
                {
                    hres = S_FALSE;
                }
                else
                {
                    hres = OLE_E_ENUM_NOMORE;
                }
            }
        }

#else
        hres = (IS_WIN98) ? S_OK                                                        /* Anything goes on 98 */
                          : (HAS_OEMCALLOUT) ? S_OK                                     /* Win9x device, OK */
                                             : (HAS_HARDWARE_ID) ? (IS_ANALOG) ? S_OK   /* Analog type, OK */
                                                                               : S_FALSE /* WDM device, ignore */
                                                                 : S_OK;                /* Analog type, OK */
#endif
                                                                
        switch( hres )
        {
#ifdef WINNT
        case DIERR_MOREDATA:
            /*
             *  The device is not marked as autoload but has a VID/PID type 
             *  name.  If the OEMCallout is blank or "joyhid.vxd" we'll assume 
             *  the type should be autoload and correct it.
             *  If there's any other value, we could assume either that we 
             *  have a bogus Win9x driver type key and hide it or that the 
             *  device is autoload.  
             *  Safest route, now that our expose code is smart enough to not 
             *  expose a device without a hardware ID, is to enumerate it as 
             *  non-autoload as Win2k did.  It won't work if you try to add 
             *  it but at least the type will be enumerated if the device 
             *  does show up from PnP (so nobody will get confused by a 
             *  device without a type).
             *
             *  ISSUE-2001/01/04-MarcAnd should use common joyhid string
             *  Not sure if the compiler/linker will resolve the various 
             *  instances of L"joyhid.vxd" to a single string.  Should 
             *  reference the same one to be certain.
             */

            if( !HAS_OEMCALLOUT 
             || ( !lstrcmpi( tszCallout, L"joyhid.vxd" ) ) )
            {
                HKEY hkSet;

                /*
                 *  Need to open a new handle for the key as the one we have 
                 *  is read-only.
                 */
                lRc = RegOpenKeyEx( hkTypesR, szType, 0, KEY_SET_VALUE, &hkSet );

                if( lRc == ERROR_SUCCESS )
                {
                    hws.dwFlags |= JOY_HWS_AUTOLOAD;
                    cb = cbX(hws);
                    lRc = RegSetValueEx( hkSet, REGSTR_VAL_JOYOEMDATA, 0, 
                        REG_BINARY, (PBYTE)&hws, (DWORD)( cbX(hws) ) );

                    if( lRc == ERROR_SUCCESS )
                    {
                        SquirtSqflPtszV(sqfl | sqflTrace,
                                TEXT("FIXED Type %s to have JOY_HWS_AUTOLOAD"), szType );
                    }
                    else
                    {
                        SquirtSqflPtszV(sqfl | sqflBenign,
                                TEXT("Failed to set JOY_HWS_AUTOLOAD on Type %s (rc=%d,le=%d)"), 
                                szType, lRc, GetLastError() );
                    }

                    RegCloseKey( hkSet );
                }
                else
                {
                    SquirtSqflPtszV(sqfl | sqflBenign,
                            TEXT("Failed to open Type %s to fix JOY_HWS_AUTOLOAD(rc=%d,le=%d)"), 
                            szType, lRc, GetLastError() );
                }
            }
            else
            {
                SquirtSqflPtszV(sqfl | sqflBenign,
                        TEXT("Type %s with OEMCallout<%s> has no HardwareId so cannot be added"), 
                        szType, tszCallout );
            }
            
            /*
             *  Whether or not we fixed this, we want to enumerate the key.
             */
            hres = S_OK;
            break;

        case OLE_E_ENUM_NOMORE:
            {
                HRESULT hres0;
                hres0 = JoyCfg_FixHardwareId( hkTypesR, hk, szType , ptszLastSlash);
                if( FAILED( hres0 ) )
                {
                    /*
                     *  Failed to fix type it must be ignored to avoid an infinite loop
                     */
                    SquirtSqflPtszV(sqfl | sqflBenign,
                            TEXT("Ignoring type %s as fix failed"), szType );
                    hres = S_FALSE;
                }
                else
                {
                    SquirtSqflPtszV(sqfl | sqflTrace,
                            TEXT("FIXED Type %s with HardwareId<%s> and OEMCallout<%s>"), 
                            szType, tszHardwareId, tszCallout );
                }
            }
            break;
#endif
        case S_FALSE:
            SquirtSqflPtszV(sqfl | sqflBenign,
                    TEXT("Ignoring type %s with HardwareId<%s> and OEMCallout<%s>"), 
                    szType, tszHardwareId, tszCallout );
            break;
        case S_OK:
            SquirtSqflPtszV(sqfl | sqflTrace,
                    TEXT("Enumerating type %s with HardwareId<%s> and OEMCallout<%s>"), 
                    szType, tszHardwareId, tszCallout );
            break;
        }

        RegCloseKey( hk );

#undef HAS_VIDPID
#undef HAS_HARDWARE_ID
#undef HAS_OEMCALLOUT
#undef IS_ANALOG
#undef IS_WIN98

    }
    else
    {
        SquirtSqflPtszV(sqfl | sqflBenign,
            TEXT("Ignoring type %s due to registry error 0x%08x"), szType, lRc );
        /*
         *  It seems a bit bogus, to return success for an error but this 
         *  makes sure the key is ignored and enumeration will proceed.
         */
        hres = S_FALSE;
    }
#ifdef WINNT
fast_out:;
#endif

    ExitOleProc();

    return( hres );

} /* JoyCfg_CheckTypeKey */


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIJoyCfg | SnapTypes |
 *
 *          Snapshot the list of subkeys for OEM types.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @parm   OUT LPWSTR * | ppwszz |
 *
 *          Receives a pointer to a UNICODEZZ
 *          list of type names.  Note that the returned list
 *          is pre-populated with the predefined types, too.
 *
 *          We need to snapshot the names up front because
 *          the caller might create or delete OEM types during the
 *          enumeration.
 *
 *          As we enumerate we check each key for validity and repair any 
 *          analog custom configurations that we can.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:  Out of memory.
 *
 *****************************************************************************/

HRESULT INTERNAL
    CJoyCfg_SnapTypes(PJC this, LPWSTR *ppwszz)
{
    HRESULT hres;
    LONG    lRc;
    HKEY    hkTypesR;
    DWORD   chkSub;
    DWORD   dwMaxSubKeyLen;
    BOOL    fRetry;

    EnterProcI(CJoyCfg_SnapTypes, (_ "p", this));

    RD(*ppwszz = 0);

    /*
     *  If an analog configuration needs to be fixed, the enumeration is 
     *  restarted because adding/removing keys may mess with the key indicies.
     *  Since registry keys can go stale, start from scratch.
     */
    
    do
    {
        fRetry=FALSE;

        /*
         *  Note that it is not safe to cache the registry key in
         *  the object.  If somebody deletes the registry key, our
         *  cached handle goes stale and becomes useless.
         */
        lRc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           REGSTR_PATH_JOYOEM, 0,
                           KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, &hkTypesR);

        /*
         *  Note also that if the registry key is not available,
         *  we still want to return the predefined types.
         */

        if(lRc == ERROR_SUCCESS)
        {
            lRc = RegQueryInfoKey(hkTypesR, 0, 0, 0, &chkSub,
                                  &dwMaxSubKeyLen, 0, 0, 0, 0, 0, 0);

            if(lRc == ERROR_SUCCESS  )
            {
            } else
            {
                chkSub = 0;
				dwMaxSubKeyLen = 0;
            }
        } else
        {
            hkTypesR = 0;
            chkSub = 0;
			dwMaxSubKeyLen = 0;
        }


        /*
         *  Each predefined name is of the form #n\0,
         *  which is 3 characters.
         */
        hres = AllocCbPpv(cbCwch( chkSub  * (dwMaxSubKeyLen+1) +
                                 (JOY_HW_PREDEFMAX - JOY_HW_PREDEFMIN)
                                 * 3 + 1), ppwszz);

        // Not really a bug,we never get to this point with a NULL ptr, 
        // but lets keep prefix happy Manbugs: 29340
        if(SUCCEEDED(hres) && *ppwszz != NULL ){
            DWORD dw;
            LPWSTR pwsz;

            /*
             *  First add the predef keys.
             */
            for(dw = JOY_HW_PREDEFMIN, pwsz = *ppwszz;
               dw < JOY_HW_PREDEFMAX; dw++)
            {
                *pwsz++ = L'#';
                *pwsz++ = CJoyCfg_CharFromType(dw);
                *pwsz++ = L'\0';
            }

            /*
             *  Now add the named keys.
             */
            for(dw = 0; dw < chkSub; dw++)
            {
        #ifdef UNICODE
                lRc = RegEnumKey(hkTypesR, dw, pwsz, dwMaxSubKeyLen+1);
        #else
                CHAR sz[MAX_JOYSTRING];
                lRc = RegEnumKey(hkTypesR, dw, sz, dwMaxSubKeyLen);
        #endif
                if(lRc == ERROR_SUCCESS )
                {
            #ifdef UNICODE
                    hres = JoyCfg_CheckTypeKey( hkTypesR, pwsz );
            #else
                    hres = JoyCfg_CheckTypeKey( hkTypesR, sz );
            #endif
                    if( FAILED( hres ) )
                    {
                        /*
                         *  Had to fix type so restart
                         */
                        FreePpv( ppwszz );
                        break;
                    }

                    if( hres != S_OK )
                    {
                        /*
                         *  Ignore this type
                         */
                        continue;
                    }

            #ifdef UNICODE
                    pwsz += lstrlenW(pwsz) + 1;
            #else
                    pwsz += AToU(pwsz, dwMaxSubKeyLen, sz);
            #endif
                }
                else
                {
                }
            }        

            if( SUCCEEDED( hres ) )
            {
                *pwsz = L'\0';              /* Make it ZZ */

                hres = S_OK;
            }
            else
            {
                fRetry = TRUE;
            }
        }

        if(hkTypesR)
        {
            RegCloseKey(hkTypesR);
        }

    } while( fRetry );

    ExitOleProcPpv(ppwszz);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputJoyConfig8 | EnumTypes |
 *
 *          Enumerate the joystick types currently supported by
 *          DirectInput.  A "joystick type" describes how DirectInput
 *          should communicate with a joystick device.  It includes
 *          information such as the presence and
 *          locations of each of the axes and the number of buttons
 *          supported by the device.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @parm   LPDIJOYTYPECALLBACK | lpCallback |
 *
 *          Points to an application-defined callback function.
 *          For more information, see the description of the
 *          <f DIEnumJoyTypeProc> callback function.
 *
 *  @parm   IN LPVOID | pvRef |
 *
 *          Specifies a 32-bit application-defined
 *          value to be passed to the callback function.  This value
 *          may be any 32-bit value; it is prototyped as an <t LPVOID>
 *          for convenience.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *          Note that if the callback stops the enumeration prematurely,
 *          the enumeration is considered to have succeeded.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          callback procedure returned an invalid status code.
 *
 *  @cb     BOOL CALLBACK | DIEnumJoyTypeProc |
 *
 *          An application-defined callback function that receives
 *          DirectInput joystick types as a result of a call to the
 *          <om IDirectInputJoyConfig8::EnumTypes> method.
 *
 *  @parm   IN LPCWSTR | pwszTypeName |
 *
 *          The name of the joystick type.  A buffer of <c MAX_JOYSTRING>
 *          characters will be sufficient to hold the type name.
 *          The type name should never be shown to the end user; instead,
 *          the "display name" should be shown.  Use
 *          <mf IDirectInputJoyConfig8::GetTypeInfo> to obtain the
 *          display name of a joystick type.
 *
 *          Type names that begin with a sharp character ("#")
 *          represent predefined types which cannot be modified
 *          or deleted.
 *
 *  @parm   IN OUT LPVOID | pvRef |
 *          Specifies the application-defined value given in the
 *          <mf IDirectInputJoyConfig8::EnumTypes> function.
 *
 *  @returns
 *
 *          Returns <c DIENUM_CONTINUE> to continue the enumeration
 *          or <c DIENUM_STOP> to stop the enumeration.
 *
 *  @devnote
 *
 *  EnumTypes must snapshot because people will try to get/set/delete
 *  during the enumeration.
 *
 *  EnumTypes enumerates the predefined types as "#digit".
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_EnumTypes(PDJC pdjc, LPDIJOYTYPECALLBACK ptc, LPVOID pvRef)
{
    HRESULT hres;
    EnterProcR(IDirectInputJoyConfig8::EnumTypes, (_ "ppx", pdjc, ptc, pvRef));

    if(SUCCEEDED(hres = hresPv(pdjc)) &&
       SUCCEEDED(hres = hresFullValidPfn(ptc, 1)))
    {
        PJC this = _thisPvNm(pdjc, djc);
        LPWSTR pwszKeys;

        hres = CJoyCfg_SnapTypes(this, &pwszKeys);
        if(SUCCEEDED(hres))
        {
            LPWSTR pwsz;

            /*
             *  Prefix warns that pwszKeys could be null (mb:34685)
             *  Little does it know that CJoyCfg_SnapTypes can only return a 
             *  success if the pointer is not NULL.
             */
            AssertF( pwszKeys );

            /*
             *  Surprise!  Win95 implements lstrlenW.
             */
            for(pwsz = pwszKeys; *pwsz; pwsz += lstrlenW(pwsz) + 1)
            {
                BOOL fRc;

                /*
                 *  WARNING!  "goto" here!  Make sure that nothing
                 *  is held while we call the callback.
                 */
                fRc = Callback(ptc, pwsz, pvRef);

                switch(fRc)
                {
                    case DIENUM_STOP: goto enumdoneok;
                    case DIENUM_CONTINUE: break;
                    default:
                        RPF("%s: Invalid return value from callback", s_szProc);
                        ValidationException();
                        break;
                }
            }

            FreePpv(&pwszKeys);
            hres = DIPort_SnapTypes(&pwszKeys);
            if(SUCCEEDED(hres))
            {    
                /*
                 *  Surprise!  Win95 implements lstrlenW.
                 */
                for(pwsz = pwszKeys; *pwsz; pwsz += lstrlenW(pwsz) + 1)
                {
                    BOOL fRc;
    
                    /*
                     *  WARNING!  "goto" here!  Make sure that nothing
                     *  is held while we call the callback.
                     */
                    fRc = Callback(ptc, pwsz, pvRef);
    
                    switch(fRc)
                    {
                        case DIENUM_STOP: goto enumdoneok;
                        case DIENUM_CONTINUE: break;
                        default:
                            RPF("%s: Invalid return value from callback", s_szProc);
                            ValidationException();
                            break;
                    }
                }
            }

            enumdoneok:;
            FreePpv(&pwszKeys);
            hres = S_OK;
        }

        hres = S_OK;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputJoyConfig8 | GetTypeInfo |
 *
 *          Obtain information about a joystick type.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @parm   LPCWSTR | pwszTypeName |
 *
 *          Points to the name of the type, previously obtained
 *          from a call to <mf IDirectInputJoyConfig8::EnumTypes>.
 *
 *  @parm   IN OUT LPDIJOYTYPEINFO | pjti |
 *
 *          Receives information about the joystick type.
 *          The caller "must" initialize the <e DIJOYTYPEINFO.dwSize>
 *          field before calling this method.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Zero or more <c DITC_*> flags
 *          which specify which parts of the structure pointed
 *          to by <p pjti> are to be filled in.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *          <c DIERR_NOTFOUND>: The joystick type was not found.
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_GetTypeInfo(PDJC pdjc, LPCWSTR pwszType,
                        LPDIJOYTYPEINFO pjti, DWORD fl)
{
    HRESULT hres;
    EnterProcR(IDirectInputJoyConfig8::GetTypeInfo,
               (_ "pWpx", pdjc, pwszType, pjti, fl));

    if(SUCCEEDED(hres = hresPv(pdjc)) &&
       SUCCEEDED(hres = hresFullValidReadStrW(pwszType, MAX_JOYSTRING, 1)) &&
       SUCCEEDED(hres = hresFullValidWritePxCb3(pjti,
                                                DIJOYTYPEINFO_DX8,
                                                DIJOYTYPEINFO_DX6,
                                                DIJOYTYPEINFO_DX5, 2)) &&
       SUCCEEDED( (pjti->dwSize == cbX(DIJOYTYPEINFO_DX8) )
                  ? ( hres = hresFullValidFl(fl, DITC_GETVALID, 3) )
                  : (pjti->dwSize == cbX(DIJOYTYPEINFO_DX6 ) )
                      ? ( hres = hresFullValidFl(fl, DITC_GETVALID_DX6, 3) )
                      : ( hres = hresFullValidFl(fl, DITC_GETVALID_DX5, 3) ) ) )
    {

        PJC this = _thisPvNm(pdjc, djc);
        GUID    guid;
        BOOL    fParseGuid;

#ifndef UNICODE
        TCHAR   tszType[MAX_PATH/4];

        UToT( tszType, cA(tszType), pwszType );
        fParseGuid = ParseGUID(&guid, tszType);
#else
        fParseGuid = ParseGUID(&guid, pwszType);
#endif

        if(pwszType[0] == TEXT('#'))
        {
            hres = JoyReg_GetPredefTypeInfo(pwszType, pjti, fl);
        } else if( fParseGuid )
        {
            hres = DIBusDevice_GetTypeInfo(&guid, pjti, fl);
        }else
        {
            hres = JoyReg_GetTypeInfo(pwszType, pjti, fl);
        }
        
    }

    ExitOleProcR();
    return hres;
}



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidStructStr |
 *
 *          Validate a string field in a struct.
 *
 *  @parm   IN LPCWSTR | pwsz |
 *
 *          String to be validated.
 *
 *  @parm   UINT | cwch |
 *
 *          Maximum string length.
 *
 *  @parm   LPCSTR | pszName |
 *
 *          Field name.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *****************************************************************************/

    #ifndef XDEBUG
\
        #define hresFullValidStructStr_(pwsz, cwch, pszName, z, i)             \
       _hresFullValidStructStr_(pwsz, cwch)                            \

    #endif

    #define hresFullValidStructStr(Struct, f, iarg)                          \
        hresFullValidStructStr_(Struct->f, cA(Struct->f), #f, s_szProc,iarg)\


    HRESULT INLINE
    hresFullValidStructStr_(LPCWSTR pwsz, UINT cwch, LPCSTR pszName,
                            LPCSTR s_szProc, int iarg)
{
    HRESULT hres;

    if(SUCCEEDED(hres = hresFullValidReadStrW(pwsz, cwch, iarg)))
    {
    } else
    {
    #ifdef XDEBUG
        RPF("%s: Invalid value for %s",  s_szProc, pszName);
    #endif
    }
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresValidFlags2 |
 *
 *          Validate the dwFlags2 value for SetTypeInfo.  
 *
 *  @parm   IN DWORD | dwFlags2 |
 *
 *          Flags to be validated.
 *
 *  @returns
 *
 *          <c DI_OK> = <c S_OK>: The flags appear to be valid.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: The flags are invalid.
 *
 *****************************************************************************/

#ifdef XDEBUG

#define hresValidFlags2( flags, iarg ) hresValidFlags2_( flags, s_szProc, iarg )

HRESULT INLINE hresValidFlags2_
( 
    DWORD dwFlags2,
    LPCSTR s_szProc, 
    int iarg
)

#else

#define hresValidFlags2( flags, iarg ) hresValidFlags2_( flags )

HRESULT hresValidFlags2_
( 
    DWORD dwFlags2 
)

#endif
{
    if( !( dwFlags2 & ~JOYTYPE_FLAGS2_SETVALID )
     && ( ( GET_DIDEVICE_TYPEANDSUBTYPE( dwFlags2 ) == 0 )
       || GetValidDI8DevType( dwFlags2, 0, 0 ) ) ) 
    {
        return S_OK;
    }
    else
    {
    #ifdef XDEBUG
        if( dwFlags2 & ~JOYTYPE_FLAGS2_SETVALID )
        {
            RPF("%s: Invalid flags 0x%04x in HIWORD(dwFlags2) of arg %d",  
            s_szProc, HIWORD(dwFlags2), iarg);
        }
        if( GET_DIDEVICE_TYPEANDSUBTYPE( dwFlags2 )
         &&!GetValidDI8DevType( dwFlags2, 127, JOY_HWS_HASPOV | JOY_HWS_HASZ ) ) 
        {
            RPF("%s: Invalid type:subtype 0x%02x:%02x in dwFlags2 of arg %d",  
            s_szProc, GET_DIDEVICE_TYPE( dwFlags2 ), 
            GET_DIDEVICE_SUBTYPE( dwFlags2 ), iarg );
        }
    #endif
        return E_INVALIDARG;
    }
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputJoyConfig8 | SetTypeInfo |
 *
 *          Creates a new joystick type
 *          or redefine information about an existing joystick type.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @parm   LPCWSTR | pwszTypeName |
 *
 *          Points to the name of the type.  The name of the type may
 *          not exceed MAX_JOYSTRING characters, including the terminating
 *          null character.
 *
 *          If the type name does not already exist, then it is created.
 *
 *          You cannot change the type information for a predefined type.
 *
 *          The name may not begin with
 *          a "#" character.  Types beginning with "#" are reserved
 *          by DirectInput.
 *
 *  @parm   IN LPDIJOYTYPEINFO | pjti |
 *
 *          Contains information about the joystick type.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Zero or more <c DITC_*> flags
 *          which specify which parts of the structure pointed
 *          to by <p pjti> contain values which are to be set.
 *
 *  @parm   OUT LPWSTR | pwszVIDPIDTypeName |
 *          If the type name is an OEM type not in VID_xxxx&PID_yyyy format,
 *          pwszVIDPIDTypeName will return the name in VID_xxxx&PID_yyyy
 *          format that is assigned by Dinput. 
 *          This VID_xxxx&PID_yyyy name should be used in DIJOYCONFIG.wszType
 *          field when calling SetConfig.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTACQUIRED>: Joystick configuration has not been
 *          acquired.  You must call <mf IDirectInputJoyConfig8::Acquire>
 *          before you can alter joystick configuration settings.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *          <c DIERR_READONLY>: Attempted to change a predefined type.
 *
 *****************************************************************************/

typedef struct _TYPENAME {
    WCHAR wszRealTypeName[MAX_JOYSTRING];
    WCHAR wszDITypeName[MAX_JOYSTRING/4];
} TYPENAME, *LPTYPENAME;

#ifdef WINNT
BOOL CALLBACK CJoyCfg_FindTypeProc( LPCWSTR pwszTypeName, LPVOID pv )
{
    DIJOYTYPEINFO dijti;
    LPTYPENAME lptype = (LPTYPENAME)pv;
    
    ZeroMemory( &dijti, sizeof(dijti));
    dijti.dwSize = sizeof(dijti);
    if( pwszTypeName[0] == L'\0' || pwszTypeName[0] == L'#' )
    {
        return TRUE;
    } else {
        if( SUCCEEDED(JoyReg_GetTypeInfo(pwszTypeName, &dijti, DITC_REGHWSETTINGS | DITC_DISPLAYNAME)) )
        {
            if( !lstrcmpW(dijti.wszDisplayName, lptype->wszRealTypeName) ) {
                lstrcpynW(lptype->wszDITypeName, pwszTypeName, sizeof(lptype->wszDITypeName)-1 );
                return FALSE;
            }
        }
    }

    return(TRUE);
}
#endif  // #ifdef WINNT

STDMETHODIMP
    CJoyCfg_SetTypeInfo(PDJC pdjc, LPCWSTR pwszType,
                        LPCDIJOYTYPEINFO pjti, DWORD fl, LPWSTR pwszDITypeName)
{
    HRESULT hres;
    EnterProcR(IDirectInputJoyConfig8::SetTypeInfo,
               (_ "pWpx", pdjc, pwszType, pjti, fl));


    if(SUCCEEDED(hres = hresPv(pdjc)) &&
       SUCCEEDED(hres = hresFullValidReadStrW(pwszType, MAX_JOYSTRING, 1)) &&

       SUCCEEDED(hres = hresFullValidReadPxCb3((PV)pjti,
                                               DIJOYTYPEINFO_DX8,
                                               DIJOYTYPEINFO_DX6,
                                               DIJOYTYPEINFO_DX5, 2)) &&
#ifdef WINNT
       SUCCEEDED(hres = hresFullValidFl(pjti->dwFlags1, JOYTYPE_FLAGS1_SETVALID, 3) ) &&
#endif
       SUCCEEDED( (pjti->dwSize == cbX(DIJOYTYPEINFO_DX8) )
                  ? ( hres = hresFullValidFl(fl, DITC_SETVALID, 3) )
                  : (pjti->dwSize == cbX(DIJOYTYPEINFO_DX6 ) )
                      ? ( hres = hresFullValidFl(fl, DITC_SETVALID_DX6, 3) )
                      : ( hres = hresFullValidFl(fl, DITC_SETVALID_DX5, 3) ) ) &&
       fLimpFF(fl & DITC_HARDWAREID,
               SUCCEEDED(hres = hresFullValidStructStr(pjti, wszHardwareId, 2))) &&
       fLimpFF(fl & DITC_DISPLAYNAME,
               SUCCEEDED(hres = hresFullValidStructStr(pjti, wszDisplayName, 2))) &&
#ifndef WINNT
       fLimpFF(fl & DITC_CALLOUT,
               SUCCEEDED(hres = hresFullValidStructStr(pjti, wszCallout, 2))) &&
#endif
       fLimpFF(fl & DITC_FLAGS2,
               SUCCEEDED(hres = hresValidFlags2( pjti->dwFlags2, 2)) ) &&
       fLimpFF(fl & DITC_MAPFILE,
               SUCCEEDED(hres = hresFullValidStructStr(pjti, wszMapFile, 2)))
      )
    {
        PJC this = _thisPvNm(pdjc, djc);

        CJoyCfg_EnterCrit(this);

        if(SUCCEEDED(hres = CJoyCfg_IsAcquired(this)))
        {
            switch(pwszType[0])
            {

                case L'\0':
                    RPF("%s: Invalid pwszType (null)", s_szProc);
                    hres = E_INVALIDARG;
                    break;

                case L'#':
                    RPF("%s: Invalid pwszType (predefined)", s_szProc);
                    hres = DIERR_READONLY;
                    break;

                default:
                    hres = JoyReg_SetTypeInfo(this->hkTypesW, pwszType, pjti, fl);
                    
                    if( SUCCEEDED(hres) ) {
                    #ifdef WINNT
                        TYPENAME type;
                        short DontCare;
                            
                        if( (pjti->wszHardwareId[0] == TEXT('\0')) && 
                            !(ParseVIDPID(&DontCare, &DontCare, pwszType)) )
                        {
                            lstrcpyW(type.wszRealTypeName, pwszType);
                            hres = CJoyCfg_EnumTypes(pdjc, CJoyCfg_FindTypeProc, &type);
                            if( SUCCEEDED(hres) ) {
                                if( !IsBadWritePtr((LPVOID)pwszDITypeName, lstrlenW(type.wszDITypeName)) )
                                {
                                    CharUpperW(type.wszDITypeName);
                                    lstrcpyW(pwszDITypeName, type.wszDITypeName);
                                } else {
                                    hres = ERROR_NOT_ENOUGH_MEMORY;
                                }
                            }
                        } else 
                    #endif
                        {
                            if( !IsBadWritePtr((LPVOID)pwszDITypeName, lstrlenW(pwszType)) )
                            {
                                lstrcpyW(pwszDITypeName, pwszType);
                            } else {
                                hres = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        }
                    }
                    break;
            }
        }
        CJoyCfg_LeaveCrit(this);
    }
    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputJoyConfig8 | DeleteType |
 *
 *          Removes information about a joystick type.
 *
 *          Use this method with caution; it is the caller's responsibility
 *          to ensure that no joystick refers to the deleted type.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @parm   LPCWSTR | pwszTypeName |
 *
 *          Points to the name of the type.  The name of the type may
 *          not exceed <c MAX_PATH> characters, including the terminating
 *          null character.
 *
 *          The name may not begin with
 *          a "#" character.  Types beginning with "#" are reserved
 *          by DirectInput.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTACQUIRED>: Joystick configuration has not been
 *          acquired.  You must call <mf IDirectInputJoyConfig8::Acquire>
 *          before you can alter joystick configuration settings.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_DeleteType(PDJC pdjc, LPCWSTR pwszType)
{
    HRESULT hres;
    EnterProcR(IDirectInputJoyConfig8::DeleteType, (_ "pW", pdjc, pwszType));

    if(SUCCEEDED(hres = hresPv(pdjc)) &&
       SUCCEEDED(hres = hresFullValidReadStrW( pwszType, MAX_JOYSTRING, 1)))
    {

        PJC this = _thisPvNm(pdjc, djc);

        CJoyCfg_EnterCrit(this);

        if(SUCCEEDED(hres = CJoyCfg_IsAcquired(this)))
        {
            LONG lRc;
            switch(pwszType[0])
            {

                case L'\0':
                    RPF("%s: Invalid pwszType (null)", s_szProc);
                    hres = E_INVALIDARG;
                    break;

                case L'#':
                    RPF("%s: Invalid pwszType (predefined)", s_szProc);
                    hres = DIERR_READONLY;
                    break;

                default:

#ifdef WINNT
    #ifdef UNICODE
                    lRc = DIWinnt_RegDeleteKey(this->hkTypesW, (LPTSTR)pwszType);
    #else
                    {
                        CHAR sz[MAX_PATH];
                        UToA( sz, cA(sz), pwszType );
                        lRc = DIWinnt_RegDeleteKey(this->hkTypesW, (LPTSTR)sz);
                    }
    #endif
#else
    #ifdef UNICODE
                    lRc = RegDeleteKey(this->hkTypesW, (LPTSTR)pwszType);
    #else
                    {
                        CHAR sz[MAX_PATH];
                        UToA( sz, cA(sz), pwszType );
                        lRc = RegDeleteKey(this->hkTypesW, (LPTSTR)sz);
                    }
    #endif
#endif
    
/*
    #ifdef WINNT
                        lRc = DIWinnt_RegDeleteKey(this->hkTypesW, pwszType);
    #else
                        lRc = RegDeleteKeyW(this->hkTypesW, pwszType);
    #endif
*/

                    if(lRc == ERROR_SUCCESS)
                    {
                        hres = S_OK;
                    } else
                    {
                        if(lRc == ERROR_KEY_DELETED || lRc == ERROR_BADKEY)
                        {
                            lRc = ERROR_FILE_NOT_FOUND;
                        }
                        hres = hresLe(lRc);
                    }
                    break;
            }
        }
        CJoyCfg_LeaveCrit(this);
    }
    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputJoyConfig8 | GetConfig |
 *
 *          Obtain information about a joystick's configuration.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @parm   UINT | uiJoy |
 *
 *          Joystick identification number.  This is a nonnegative
 *          integer.  To enumerate joysticks, begin with joystick
 *          zero and increment the joystick number by one until the
 *          function returns <c DIERR_NOMOREITEMS>.
 *
 *          Yes, it's different from all other DirectX enumerations.
 *
 *
 *  @parm   IN OUT LPDIJOYCONFIG | pjc |
 *
 *          Receives information about the joystick configuration.
 *          The caller "must" initialize the <e DIJOYCONFIG.dwSize>
 *          field before calling this method.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Zero or more <c DIJC_*> flags
 *          which specify which parts of the structure pointed
 *          to by <p pjc> are to be filled in.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c S_FALSE>: The specified joystick has not yet been
 *          configured.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *          <c DIERR_NOMOREITEMS>: No more joysticks.
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_GetConfig(PDJC pdjc, UINT uiJoy, LPDIJOYCONFIG pjc, DWORD fl)
{
    HRESULT hres;
    EnterProcR(IDirectInputJoyConfig8::GetConfig,
               (_ "pupx", pdjc, uiJoy, pjc, fl));

    if(SUCCEEDED(hres = hresPv(pdjc)) &&
       SUCCEEDED(hres = hresFullValidWritePxCb2(pjc,
                                                DIJOYCONFIG_DX6,
                                                DIJOYCONFIG_DX5, 2)) &&
       SUCCEEDED( (pjc->dwSize == cbX(DIJOYCONFIG)
                   ? (hres = hresFullValidFl(fl, DIJC_GETVALID, 3) )
                   : (hres = hresFullValidFl(fl, DIJC_GETVALID_DX5, 3)))) )
    {

        PJC this = _thisPvNm(pdjc, djc);

        CJoyCfg_EnterCrit(this);

        /*
         *  Note that we always get the DIJC_REGHWCONFIGTYPE because
         *  we need to check if the joystick type is "none".
         */
        hres = JoyReg_GetConfig(uiJoy, pjc, fl | DIJC_REGHWCONFIGTYPE);

        if(SUCCEEDED(hres))
        {
#ifndef WINNT           
            static WCHAR s_wszMSGAME[] = L"MSGAME.VXD";

            if(memcmp(pjc->wszCallout, s_wszMSGAME, cbX(s_wszMSGAME)) == 0)
            {
                 ; // do nothing
            } else 
#endif            
            if(fInOrder(JOY_HW_PREDEFMIN, pjc->hwc.dwType,
                        JOY_HW_PREDEFMAX))
            {
                pjc->wszType[0] = TEXT('#');
                pjc->wszType[1] = CJoyCfg_CharFromType(pjc->hwc.dwType);
                pjc->wszType[2] = TEXT('\0');

            }

            if(pjc->hwc.dwType == JOY_HW_NONE)
            {
                hres = S_FALSE;
            } else
            {
                hres = S_OK;
            }

            /*
             *  In DEBUG, re-scramble the hwc and type if the caller
             *  didn't ask for it.
             */
            if(!(fl & DIJC_REGHWCONFIGTYPE))
            {
                ScrambleBuf(&pjc->hwc, cbX(pjc->hwc));
                ScrambleBuf(&pjc->wszType, cbX(pjc->wszType));
            }
        }

        CJoyCfg_LeaveCrit(this);
    }
    ExitBenignOleProcR();
    return hres;
}

#if 0
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoyCfg | UpdateGlobalGain |
 *
 *          Create the device callback so we can talk to its driver and
 *          tell it to change the gain value.
 *
 *          This function must be called under the object critical section.
 *
 *  @cwrap  PJC | this
 *
 *  @parm   DWORD | idJoy |
 *
 *          The joystick identifier.
 *
 *  @parm   DWORD | dwCplGain |
 *
 *          New global gain.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_UpdateGlobalGain(PJC this, DWORD idJoy, DWORD dwCplGain)
{
    HRESULT hres;
    EnterProcI(CJoyCfg_UpdateGlobalGain, (_ "puu", this, idJoy, dwCplGain));

    AssertF(CJoyCfg_InCrit(this));

    /*
     *  Create the deviceeffect shepherd if we don't already have it.
     */

    if(this->pes && idJoy == this->idJoyCache)
    {
        hres = S_OK;
    } else if(idJoy < cA(rgGUID_Joystick))
    {
        PCGUID rguid;
    #ifdef DEBUG
        CREATEDCB CreateDcb;
    #endif
        IDirectInputDeviceCallback *pdcb;

        /*
         *  Assume the creation will work.
         */
        this->idJoyCache = idJoy;

        /*
         *  Out with the old...
         */
        Invoke_Release(&this->pes);

        /*
         *  And in with the new...
         */
        rguid = &rgGUID_Joystick[idJoy];

    #ifdef DEBUG
        hres = hresFindInstanceGUID(rguid, &CreateDcb, 1);
        AssertF(SUCCEEDED(hres));
        AssertF(CreateDcb == CJoy_New);
    #endif

        if(SUCCEEDED(hres = CJoy_New(0, rguid,
                                     &IID_IDirectInputDeviceCallback,
                                     (PPV)&pdcb)))
        {
            hres = pdcb->lpVtbl->CreateEffect(pdcb, &this->pes);

            Invoke_Release(&pdcb);
        }

    } else
    {
        hres = DIERR_DEVICENOTREG;
    }

    /*
     *  If we have an effect shepherd, then tell it what the new
     *  global gain is.
     */
    if(SUCCEEDED(hres))
    {
        AssertF(this->pes && idJoy == this->idJoyCache);

        hres = this->pes->lpVtbl->SetGlobalGain(this->pes, dwCplGain);
    }


    ExitOleProc();
    return hres;
}
#endif

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputJoyConfig8 | SetConfig |
 *
 *          Create or redefine configuration information about a joystick.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @parm   UINT | idJoy |
 *
 *          Zero-based joystick identification number.
 *
 *  @parm   IN LPDIJOYCONFIG | pcfg |
 *
 *          Contains information about the joystick.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Zero or more <c DIJC_*> flags
 *          which specify which parts of the structure pointed
 *          to by <p pjc> contain information to be set.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTACQUIRED>: Joystick configuration has not been
 *          acquired.  You must call <mf IDirectInputJoyConfig8::Acquire>
 *          before you can alter joystick configuration settings.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *  @devnote
 *
 *          This one is tricky.  If the type begins with a sharp, then
 *          it's an internal type.  And if it is null, then it's a
 *          custom type.
 *
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_SetConfig(PDJC pdjc, UINT idJoy, LPCDIJOYCONFIG pcfg, DWORD fl)
{
    HRESULT hres;
    EnterProcR(IDirectInputJoyConfig8::SetConfig,
               (_ "pupx", pdjc, idJoy, pcfg, fl));


    if(SUCCEEDED(hres = hresPv(pdjc)) &&
       SUCCEEDED(hres = hresFullValidReadPxCb2(pcfg,
                                               DIJOYCONFIG_DX6,
                                               DIJOYCONFIG_DX5, 2)) &&
       SUCCEEDED( (pcfg->dwSize == cbX(DIJOYCONFIG)
                   ? ( hres = hresFullValidFl(fl, DIJC_SETVALID, 3) )
                   : ( hres = hresFullValidFl(fl, DIJC_SETVALID_DX5,3)) )) &&
       fLimpFF(fl & DIJC_REGHWCONFIGTYPE,
               SUCCEEDED(hres = hresFullValidStructStr(pcfg, wszType, 2))) &&
#ifndef WINNT
       fLimpFF(fl & DIJC_CALLOUT,
               SUCCEEDED(hres = hresFullValidStructStr(pcfg, wszCallout, 2))) &&
#endif
       fLimpFF(fl & DIJC_WDMGAMEPORT,
               SUCCEEDED(hres = hresFullValidGuid(&pcfg->guidGameport, 2)))
      )
    {

        PJC this = _thisPvNm(pdjc, djc);

        CJoyCfg_EnterCrit(this);

        if(SUCCEEDED(hres = CJoyCfg_IsAcquired(this)))
        {
            JOYREGHWCONFIG jwc;

            // We just ignore the DIJC_WDMGAMEPORT flag for Win9x passed by user.
            // We will detect it ourself.
#ifndef WINNT
            fl &= ~DIJC_WDMGAMEPORT;
#endif


            if(fl & DIJC_REGHWCONFIGTYPE)
            {
                LPDWORD lpStart, lp;

                jwc = pcfg->hwc;

                /*
                 * Need to check whether the whole jwc is zero.
                 * If all are zero, we won't set it to JOY_HW_CUSTOM type.
                 * See manbug: 39542.
                 */
                for( lpStart=(LPDWORD)&jwc, lp=(LPDWORD)&jwc.dwReserved; lp >= lpStart; lp-- ) {
                    if( *lp ) {
                        break;
                    }
                }

                if( lp < lpStart ) {
                    goto _CONTINUE_SET;
                }

                jwc.dwUsageSettings &= ~JOY_US_ISOEM;

                if(pcfg->wszType[0] == TEXT('\0'))
                {
                    jwc.dwType = JOY_HW_CUSTOM;
                } else if(pcfg->wszType[0] == TEXT('#'))
                {
                    jwc.dwType = CJoyCfg_TypeFromChar(pcfg->wszType[1]);
                    if(fInOrder(JOY_HW_PREDEFMIN, jwc.dwType,
                                JOY_HW_PREDEFMAX) &&
                       pcfg->wszType[2] == TEXT('\0'))
                    {
                        /*
                         * If we want to use WDM for predefined devices, 
                         * then take away the comments.
                         *
                         *  fl |= DIJC_WDMGAMEPORT;
                         */
                    } else
                    {
                        RPF("%s: Invalid predefined type \"%ls\"",
                            s_szProc, pcfg->wszType);
                        hres = E_INVALIDARG;
                        goto done;
                    }
                } else
                {
                    /*
                     *  The precise value of jwc.dwType is not relevant.
                     *  The Windows 95 joystick control panel sets the
                     *  value to JOY_HW_PREDEFMAX + id, so we will too.
                     */
                    jwc.dwUsageSettings |= JOY_US_ISOEM;
                    jwc.dwType = JOY_HW_PREDEFMAX + idJoy;

                #ifndef WINNT
                    if( !(fl & DIJC_WDMGAMEPORT) ) {
                        HKEY hk;

                        hres = JoyReg_OpenTypeKey(pcfg->wszType, MAXIMUM_ALLOWED, REG_OPTION_NON_VOLATILE, &hk);

                        if( SUCCEEDED( hres ) ) {
                            hres = JoyReg_IsWdmGameport( hk );
                            if( SUCCEEDED(hres) ) {
                                fl |= DIJC_WDMGAMEPORT;
                            }
                            RegCloseKey( hk );
                        }
                    }
                #endif
                }
            }

_CONTINUE_SET:

          #ifdef WINNT
            fl |= DIJC_WDMGAMEPORT;

            if(
          #else
            if( (fl & DIJC_WDMGAMEPORT) && 
          #endif
                (cbX(*pcfg) >= cbX(DIJOYCONFIG_DX6)) )
            {
              #ifndef WINNT
                if( (pcfg->hwc.hws.dwFlags & JOY_HWS_ISANALOGPORTDRIVER)   // USB joystick
                    && !fVjoydDeviceNotExist )   // WDM gameport joystick and no VJOYD is used.
                {
                    /*
                     * This is in Win9X, and VJOYD devices are being used.
                     * We don't want to add WDM device at the same time.
                     */
                    hres = E_FAIL;
                }
                else
              #endif
                { 
                    DIJOYCONFIG cfg;
                    GUID guidGameport = {0xcae56030, 0x684a, 0x11d0, 0xd6, 0xf6, 0x00, 0xa0, 0xc9, 0x0f, 0x57, 0xda};
                    
                    if( fHasAllBitsFlFl( fl, DIJC_GUIDINSTANCE | DIJC_REGHWCONFIGTYPE | DIJC_GAIN | DIJC_WDMGAMEPORT ) )
                    {
                        memcpy( &cfg, pcfg, sizeof(DIJOYCONFIG) );
                    } else {
                        hres = JoyReg_GetConfig( idJoy, &cfg, DIJC_GUIDINSTANCE | DIJC_REGHWCONFIGTYPE | DIJC_GAIN | DIJC_WDMGAMEPORT);
        
                        if( SUCCEEDED(hres) ) {
                            if( fl & DIJC_GUIDINSTANCE ) {
                                 cfg.guidInstance = pcfg->guidInstance;
                            }
        
                            if( fl & DIJC_GAIN ) {
                                 cfg.dwGain = pcfg->dwGain;
                            }
        
                            if( fl & DIJC_REGHWCONFIGTYPE ) {
                                memcpy( &cfg.hwc, &pcfg->hwc, sizeof(JOYREGHWCONFIG) );
                                memcpy( &cfg.wszType, &pcfg->wszType, sizeof(pcfg->wszType) );
                            }
        
                            if( fl & DIJC_WDMGAMEPORT ) {
                                cfg.guidGameport = pcfg->guidGameport;
                            }
                        } else {
                            memcpy( &cfg, pcfg, sizeof(DIJOYCONFIG) );
                        }
                    }
                    
                    /*
                     * use standard guidGameport if it is NULL.
                     */
                    if( IsEqualGUID(&cfg.guidGameport, &GUID_NULL) )
                    {
                        memcpy( &cfg.guidGameport, &guidGameport, sizeof(GUID) ); 
                    }

                    if( IsEqualGUID(&cfg.guidInstance, &GUID_NULL) )
                    {
                        DWORD i;    
                        DIJOYCONFIG cfg2;

                        hres = DIWdm_SetConfig(idJoy, &jwc, &cfg, fl );

                        if( SUCCEEDED(hres) )
                        {
                            // We can't set the correct id from above call, so we have to find
                            // which id we set and try again.
                            for( i=0; i<16; i++ ) {
                                hres = JoyReg_GetConfig( i, &cfg2, DIJC_GUIDINSTANCE | DIJC_REGHWCONFIGTYPE | DIJC_GAIN | DIJC_WDMGAMEPORT);
                                if( SUCCEEDED(hres) && (i != idJoy) ) {
                                    if( lstrcmpW(cfg.wszType, cfg2.wszType) == 0 ) {
                                        hres = DIWdm_SetJoyId(&cfg2.guidInstance, idJoy);
                                        break;
                                    }
                                }
                            }

                            hres = JoyReg_SetConfig(idJoy, &jwc, &cfg, fl);
                        
                        }
                        goto done;
                    } else
                    {
                        /*
                         * Since pcfg is not null, we set it here to avoid calling
                         * DIWdm_JoyHidMapping. Even if it fails, it doesn't hurt anything.
                         */
                        hres = JoyReg_SetConfig(idJoy, &jwc, &cfg, fl);
                        hres = DIWdm_SetJoyId(&cfg.guidInstance, idJoy);
                        hres = JoyReg_SetConfig(idJoy, &jwc, &cfg, fl);
                    }
                }
            } else {
                hres = JoyReg_SetConfig(idJoy, &jwc, pcfg, DIJC_UPDATEALIAS | fl);
              
                if (SUCCEEDED(hres)) {
                  #ifdef WINNT
                    PostMessage(HWND_BROADCAST, g_wmJoyChanged, idJoy+1, 0L);   
                  #else
                    joyConfigChanged(0);
                    fVjoydDeviceNotExist = FALSE;
                  #endif
               }
            }

        }

        done:;
        CJoyCfg_LeaveCrit(this);
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputJoyConfig8 | DeleteConfig |
 *
 *          Delete configuration information about a joystick.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @parm   UINT | idJoy |
 *
 *          Zero-based joystick identification number.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTACQUIRED>: Joystick configuration has not been
 *          acquired.  You must call <mf IDirectInputJoyConfig8::Acquire>
 *          before you can alter joystick configuration settings.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *****************************************************************************/

DIJOYCONFIG c_djcReset = {
    cbX(c_djcReset),                    /* dwSize               */
    { 0},                              /* guidInstance         */
    { 0},                              /* hwc                  */
    DI_FFNOMINALMAX,                    /* dwGain               */
    { 0},                              /* wszType              */
    { 0},                              /* wszCallout           */
};

STDMETHODIMP
    CJoyCfg_DeleteConfig(PDJC pdjc, UINT idJoy)
{
    HRESULT hres;

    EnterProcR(IDirectInputJoyConfig8::DeleteConfig, (_ "pu", pdjc, idJoy));

    if(SUCCEEDED(hres = hresPv(pdjc)))
    {

        PJC this = _thisPvNm(pdjc, djc);

        CJoyCfg_EnterCrit(this);


        if(SUCCEEDED(hres = CJoyCfg_IsAcquired(this)))
        {

            HKEY hk;
            TCHAR tsz[MAX_JOYSTRING];
            DIJOYCONFIG dijcfg;

            hres = DIWdm_DeleteConfig(idJoy);

          #ifndef WINNT
            if( hres == DIERR_DEVICENOTREG ) {
                fVjoydDeviceNotExist = TRUE;
            }
          #endif

            /*
             *  To delete it, set everything to the Reset values and
             *  delete the configuration subkey.
             */
            if( ( SUCCEEDED(hres) || hres == DIERR_DEVICENOTREG ) &&
                SUCCEEDED(hres = JoyReg_SetConfig(idJoy, &c_djcReset.hwc,
                                                 &c_djcReset, DIJC_SETVALID)) &&
               SUCCEEDED(hres = JoyReg_OpenConfigKey(idJoy, MAXIMUM_ALLOWED,
                                                     REG_OPTION_VOLATILE, &hk)))
            {

                wsprintf(tsz, TEXT("%u"), idJoy + 1);

                // DIWinnt_RegDeleteKey:: name is a mismomer, the function
                // recursively deletes the key and all subkeys.
                DIWinnt_RegDeleteKey(hk, tsz);

                RegCloseKey(hk);

              #ifndef WINNT
                joyConfigChanged(0);
              #endif
              
                hres = S_OK;
            }
        
            if( FAILED(hres) )
            {
                if( FAILED( JoyReg_GetConfig(idJoy, &dijcfg, DIJC_REGHWCONFIGTYPE | DIJC_GUIDINSTANCE) ) )
                {
                /* No config exists, so vacuous success on delete */
                    hres = S_FALSE;
                }
            }
        }

        CJoyCfg_LeaveCrit(this);
    }
    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputJoyConfig8 | GetUserValues |
 *
 *          Obtain information about user settings for the joystick.
 *
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @parm   IN OUT LPDIJOYUSERVALUES | pjuv |
 *
 *          Receives information about the user joystick configuration.
 *          The caller "must" initialize the <e DIJOYUSERVALUES.dwSize>
 *          field before calling this method.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Zero or more <c DIJU_*> flags specifying which parts
 *          of the <t DIJOYUSERVALUES> structure contain values
 *          which are to be retrieved.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_GetUserValues(PDJC pdjc, LPDIJOYUSERVALUES pjuv, DWORD fl)
{
    HRESULT hres;
    EnterProcR(IDirectInputJoyConfig8::GetUserValues,
               (_ "ppx", pdjc, pjuv, fl));

    if(SUCCEEDED(hres = hresPv(pdjc)) &&
       SUCCEEDED(hres = hresFullValidWritePxCb(pjuv, DIJOYUSERVALUES, 2)) &&
       SUCCEEDED(hres = hresFullValidFl(fl, DIJU_GETVALID, 3)))
    {
        PJC this = _thisPvNm(pdjc, djc);

        hres = JoyReg_GetUserValues(pjuv, fl);
    }
    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidUVStr |
 *
 *          Validate a string field in a <t DIJOYUSERVALUES>.
 *
 *  @parm   IN LPCWSTR | pwsz |
 *
 *          String to be validated.
 *
 *  @parm   UINT | cwch |
 *
 *          Maximum string length.
 *
 *  @parm   LPCSTR | pszName |
 *
 *          Field name.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *****************************************************************************/

    #ifndef XDEBUG

        #define hresFullValidUVStr_(pwsz, cwch, pszName, z, i)              \
       _hresFullValidUVStr_(pwsz, cwch)                             \

    #endif

    #define hresFullValidUVStr(pjuv, f, iarg)                           \
        hresFullValidUVStr_(pjuv->f, cA(pjuv->f), #f, s_szProc,iarg)\


HRESULT INLINE
    hresFullValidUVStr_(LPCWSTR pwsz, UINT cwch, LPCSTR pszName,
                        LPCSTR s_szProc, int iarg)
{
    HRESULT hres;

    if(SUCCEEDED(hres = hresFullValidReadStrW(pwsz, cwch, iarg)))
    {
    } else
    {
    #ifdef XDEBUG
        RPF("%s: Invalid value for DIJOYUSERVALUES.%s", s_szProc, pszName);
    #endif
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputJoyConfig8 | SetUserValues |
 *
 *          Set the user settings for the joystick.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @parm   IN LPCDIJOYUSERVALUES | pjuv |
 *
 *          Contains information about the new user joystick settings.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Zero or more <c DIJU_*> flags specifying which parts
 *          of the <t DIJOYUSERVALUES> structure contain values
 *          which are to be set.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTACQUIRED>: Joystick configuration has not been
 *          acquired.  You must call <mf IDirectInputJoyConfig8::Acquire>
 *          before you can alter joystick configuration settings.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_SetUserValues(PDJC pdjc, LPCDIJOYUSERVALUES pjuv, DWORD fl)
{
    HRESULT hres;
    EnterProcR(IDirectInputJoyConfig8::SetUserValues,
               (_ "pp", pdjc, pjuv, fl));

    if(SUCCEEDED(hres = hresPv(pdjc)) &&
       SUCCEEDED(hres = hresFullValidReadPxCb(pjuv, DIJOYUSERVALUES, 2)) &&
       fLimpFF(fl & DIJU_GLOBALDRIVER,
               SUCCEEDED(hres = hresFullValidUVStr(pjuv,
                                                   wszGlobalDriver, 2))) &&
       fLimpFF(fl & DIJU_GAMEPORTEMULATOR,
               SUCCEEDED(hres = hresFullValidUVStr(pjuv,
                                                   wszGameportEmulator, 2))) &&
       SUCCEEDED(hres = hresFullValidFl(fl, DIJU_SETVALID, 3)))
    {

        PJC this = _thisPvNm(pdjc, djc);

        CJoyCfg_EnterCrit(this);

        if(SUCCEEDED(hres = CJoyCfg_IsAcquired(this)))
        {
            hres = JoyReg_SetUserValues(pjuv, fl);
        }

        CJoyCfg_LeaveCrit(this);
    }
    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputJoyConfig8 | AddNewHardware |
 *
 *          Displays the "Add New Hardware" dialog to
 *          guide the user through installing
 *          new game controller.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @parm   HWND | hwndOwner |
 *
 *          Window to act as owner window for UI.
 *
 *  @parm   REFGUID | rguidClass |
 *
 *          <t GUID> which specifies the class of the hardware device
 *          to be added.  DirectInput comes with the following
 *          class <t GUIDs> already defined:
 *
 *          <c GUID_KeyboardClass>: Keyboard devices.
 *
 *          <c GUID_MouseClass>: Mouse devices.
 *
 *          <c GUID_MediaClass>: Media devices, including joysticks.
 *
 *          <c GUID_HIDClass>: HID devices.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *          <c DIERR_INVALIDCLASSINSTALLER>: The "media" class installer
 *          could not be found or is invalid.
 *
 *          <c DIERR_CANCELLED>: The user cancelled the operation.
 *
 *          <c DIERR_BADINF>: The INF file for the device the user
 *          selected could not be found or is invalid or is damaged.
 *
 *          <c S_FALSE>: DirectInput could not determine whether the
 *          operation completed successfully.
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_AddNewHardware(PDJC pdjc, HWND hwnd, REFGUID rguid)
{
    HRESULT hres;
    EnterProcR(IDirectInputJoyConfig8::AddNewHardware,
               (_ "pxG", pdjc, hwnd, rguid));

    if(SUCCEEDED(hres = hresPv(pdjc)) &&
       SUCCEEDED(hres = hresFullValidHwnd0(hwnd, 1)) &&
       SUCCEEDED(hres = hresFullValidGuid(rguid, 2)))
    {

        PJC this = _thisPvNm(pdjc, djc);

        hres = AddNewHardware(hwnd, rguid);

    }
    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputJoyConfig8 | OpenTypeKey |
 *
 *          Open the registry key associated with a joystick type.
 *
 *          Control panel applications can use this key to store
 *          per-type persistent information, such as global
 *          configuration parameters.
 *
 *          Such private information should be kept in a subkey
 *          named "OEM"; do not store private information in the
 *          main type key.
 *
 *          Control panel applications can also use this key to
 *          read configuration information, such as the strings
 *          to use for device calibration prompts.
 *
 *          The application should use <f RegCloseKey> to close
 *          the registry key.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @parm   LPCWSTR | pwszType |
 *
 *          Points to the name of the type.  The name of the type may
 *          not exceed <c MAX_PATH> characters, including the terminating
 *          null character.
 *
 *          The name may not begin with
 *          a "#" character.  Types beginning with "#" are reserved
 *          by DirectInput.
 *
 *  @parm   REGSAM | regsam |
 *
 *          Registry security access mask.  This can be any of the
 *          values permitted by the <f RegOpenKeyEx> function.
 *          If write access is requested, then joystick
 *          configuration must first have been acquired.
 *          If only read access is requested, then acquisition is
 *          not required.
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives the opened registry key on success.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTACQUIRED>: Joystick configuration has not been
 *          acquired.  You must call <mf IDirectInputJoyConfig8::Acquire>
 *          before you can open a joystick type configuration key
 *          for writing.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *          <c MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ErrorCode)>:
 *          A Win32 error code if access to the key is denied by
 *          registry permissions or some other external factor.
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_OpenTypeKey(PDJC pdjc, LPCWSTR pwszType, REGSAM sam, PHKEY phk)
{
    HRESULT hres;
    EnterProcR(IDirectInputJoyConfig8::OpenTypeKey,
               (_ "pWx", pdjc, pwszType, sam));

    if(SUCCEEDED(hres = hresPv(pdjc)) &&
       SUCCEEDED(hres = hresFullValidReadStrW(pwszType, MAX_JOYSTRING, 1)) &&
       SUCCEEDED(hres = hresFullValidPcbOut(phk, cbX(*phk), 3)))
    {

        PJC this = _thisPvNm(pdjc, djc);

        if(pwszType[0] != TEXT('#'))
        {
            /*
             *  Attempting to get write access requires acquisition.
             */
            if(fLimpFF(IsWriteSam(sam),
                       SUCCEEDED(hres = CJoyCfg_IsAcquired(this))))
            {
                hres = JoyReg_OpenTypeKey(pwszType, sam, REG_OPTION_NON_VOLATILE, phk);
            }
        } else
        {
            RPF("%s: Invalid pwszType (predefined)", s_szProc);
            hres = E_INVALIDARG;
        }
    }
    ExitOleProcR();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputJoyConfig8 | OpenAppStatusKey |
 *
 *          Opens the root key of the application status registry keys.
 *
 *          Hardware vendors can use the sub keys of this key to inspect the 
 *          status of DirectInput applications with respect to the 
 *          functionality they use.  The key is opened with KEY_READ access.
 *
 *          Vendors are cautioned against opening these keys directly (by 
 *          finding the absolute path of the key rather than using this method) 
 *          as the absolute registry path may vary on different Windows 
 *          platforms or in future versions of DirectInput.
 *
 *          The application should use <f RegCloseKey> to close
 *          the registry key.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives the opened registry key on success.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *          <c DIERR_NOTFOUND>: The key is missing on this system.
 *          Applications should proceed as if the key were empty.
 *
 *          <c MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ErrorCode)>:
 *          A Win32 error code if access to the key is denied by
 *          registry permissions or some other external factor.
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_OpenAppStatusKey(PDJC pdjc, PHKEY phk)
{
    HRESULT hres;
    EnterProcR(IDirectInputJoyConfig8::OpenAppStatusKey,
               (_ "pp", pdjc, phk));


    if(SUCCEEDED(hres = hresPv(pdjc)) &&
       SUCCEEDED(hres = hresFullValidPcbOut(phk, cbX(*phk), 1)))
    {
        PJC this = _thisPvNm(pdjc, djc);

        hres = hresMumbleKeyEx( HKEY_CURRENT_USER, REGSTR_PATH_DINPUT, 
            KEY_READ, REG_OPTION_NON_VOLATILE, phk);
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *      CJoyCfg_New       (constructor)
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_New(PUNK punkOuter, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcI(IDirectInputJoyConfig8::<constructor>,
               (_ "p", ppvObj));

    if (SUCCEEDED(hres = hresFullValidPcbOut(ppvObj, cbX(*ppvObj), 3)))
    {
        LPVOID pvTry = NULL;
        hres = Common_NewRiid(CJoyCfg, punkOuter, riid, &pvTry);

        if(SUCCEEDED(hres))
        {
            /* Must use _thisPv in case of aggregation */
            PJC this = _thisPv(pvTry);

            this->fCritInited = fInitializeCriticalSection(&this->crst);
            if( this->fCritInited )
            {
                *ppvObj = pvTry;
                hres = S_OK;
            }
            else
            {
                Common_Unhold(this);
                *ppvObj = NULL;
                hres = E_OUTOFMEMORY;
            }
        }
    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

    #pragma BEGIN_CONST_DATA

    #define CJoyCfg_Signature        0x6766434B      /* "JCfg" */

Primary_Interface_Begin(CJoyCfg, IDirectInputJoyConfig8)
CJoyCfg_Acquire,
CJoyCfg_Unacquire,
CJoyCfg_SetCooperativeLevel,
CJoyCfg_SendNotify,
CJoyCfg_EnumTypes,
CJoyCfg_GetTypeInfo,
CJoyCfg_SetTypeInfo,
CJoyCfg_DeleteType,
CJoyCfg_GetConfig,
CJoyCfg_SetConfig,
CJoyCfg_DeleteConfig,
CJoyCfg_GetUserValues,
CJoyCfg_SetUserValues,
CJoyCfg_AddNewHardware,
CJoyCfg_OpenTypeKey,
CJoyCfg_OpenAppStatusKey,
Primary_Interface_End(CJoyCfg, IDirectInputJoyConfig8)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dijoytyp.c ===
/*****************************************************************************
 *
 *  DIJoyTyp.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Functions that pull data out of the joystick type key
 *      (wherever it is).
 *
 *  Contents:
 *
 *      ?
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflJoyType

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CType_OpenIdSubkey |
 *
 *          Given an object ID, attempt to open the subkey that
 *          corresponds to it for reading.
 *
 *  @parm   HKEY | hkType |
 *
 *          The joystick type key, possibly <c NULL> if we don't
 *          have a type key.  (For example, if it was never created.)
 *
 *  @parm   DWORD | dwId |
 *
 *          Object id.
 *
 *  @parm   REGSAM | regsam |
 *
 *          Registry security access mask.
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives the object key on success.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
    CType_OpenIdSubkey(HKEY hkType, DWORD dwId, REGSAM sam, PHKEY phk)
{
    HRESULT hres;

    EnterProc(CType_OpenIdSubkey, (_ "xx", hkType, dwId));

    *phk = 0;

    if(hkType)
    {
        /*
         *  Worst case is "Actuators\65535" which has length 15.
         */
        TCHAR tsz[32];
        LPCTSTR ptszType;

        if(dwId & DIDFT_AXIS)
        {
            ptszType = TEXT("Axes");
        } else if(dwId & DIDFT_BUTTON)
        {
            ptszType = TEXT("Buttons");
        } else if(dwId & DIDFT_POV)
        {
            ptszType = TEXT("POVs");
        } else if(dwId & DIDFT_NODATA)
        {
            ptszType = TEXT("Actuators");
        } else
        {
            hres = E_NOTIMPL;
            goto done;
        }

        // ISSUE-2001/03/29-timgill Need to scale back for pos vs state
        // MarcAnd -- I believe this means: if you're trying to
        //            look for the X axis, we should use the position
        //            instance, not the velocity one.
        wsprintf(tsz, TEXT("%s\\%u"), ptszType, DIDFT_GETINSTANCE(dwId));

        hres = hresMumbleKeyEx(hkType, tsz, sam, REG_OPTION_NON_VOLATILE, phk);

    } else
    {
        hres = DIERR_NOTFOUND;
    }

    done:;
    if(hres == DIERR_NOTFOUND)
    {
        ExitBenignOleProcPpv(phk);
    } else
    {
        ExitOleProcPpv(phk);
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CType_RegGetObjectInfo |
 *
 *          Given an object ID, look into the registry subkey for the
 *          object and extract anything we can find.
 *
 *          If we find nothing, then do nothing.
 *
 *  @parm   HKEY | hkType |
 *
 *          The joystick type key, possibly <c NULL> if we don't
 *          have a type key.  (For example, if it was never created.)
 *
 *  @parm   DWORD | dwId |
 *
 *          Object id.
 *
 *  @parm   LPDIDEVICEOBJECTINSTANCEW | pdidoiW |
 *
 *          Structure to receive information.  The
 *          <e DIDEVICEOBJECTINSTANCE.guidType>,
 *          <e DIDEVICEOBJECTINSTANCE.dwOfs>,
 *          and
 *          <e DIDEVICEOBJECTINSTANCE.dwType>
 *          <e DIDEVICEOBJECTINSTANCE.dwFlags>
 *          fields have already been filled in so we should only not override 
 *          these with default data.
 *
 *****************************************************************************/

void EXTERNAL
    CType_RegGetObjectInfo(HKEY hkType, DWORD dwId,
                           LPDIDEVICEOBJECTINSTANCEW pdidoiW)
{
    HRESULT hres;
    HKEY hk;
    EnterProc(CType_RegKeyObjectInfo, (_ "xx", hkType, dwId));

    /*
     *  Extract information about this item from the registry.
     */
    hres = CType_OpenIdSubkey(hkType, dwId, KEY_QUERY_VALUE, &hk);

    if(SUCCEEDED(hres))
    {

        DIOBJECTATTRIBUTES attr;

        /*
         *  Read the regular and HID attributes.
         */

        hres = JoyReg_GetValue(hk, TEXT("Attributes"),
                               REG_BINARY, &attr,
                               cbX(attr));

        if(SUCCEEDED(hres))
        {
            /*
             *  Copy the bit fields.
             *  PREFIX warns (333540) that attr.dwFlags is not initialized 
             *  however JoyReg_GetValue zeroes any part of the buffer after 
             *  the bytes read from the registry if the buffer size is larger 
             *  than what was read.
             */
            pdidoiW->dwFlags |= (attr.dwFlags & ~DIDOI_ASPECTMASK);

            /*
             *  Don't add FF if the dwId did not have it. 
             *  (See comment on FF attrs below for why.)
             */
            if( ( dwId & ( DIDFT_FFEFFECTTRIGGER | DIDFT_FFACTUATOR ) ) == 0 )
            {
                pdidoiW->dwFlags &= ~( DIDOI_FFACTUATOR | DIDOI_FFEFFECTTRIGGER );
            }
                

            /*
             *  Copy the aspect, but don't change
             *  the aspect from "known" to "unknown".  If the
             *  registry doesn't have an aspect, then use the
             *  aspect we got from the caller.
             */
            if((attr.dwFlags & DIDOI_ASPECTMASK) != DIDOI_ASPECTUNKNOWN)
            {
                pdidoiW->dwFlags = (pdidoiW->dwFlags & ~DIDOI_ASPECTMASK) |
                                   (attr.dwFlags & DIDOI_ASPECTMASK);
            }
        }

        /*
         *  If the caller wants force feedback info,
         *  then get it.
         */
        if(pdidoiW->dwSize >= cbX(DIDEVICEOBJECTINSTANCE_DX5W))
        {
            /*
             *  Only copy the usages if they are valid.
             *  JoyReg_GetValue zeros any buffer beyond what is read.
             */
            if(SUCCEEDED(hres) && attr.wUsagePage && attr.wUsage )
            {
                pdidoiW->wUsagePage = attr.wUsagePage;
                pdidoiW->wUsage = attr.wUsage;
            }

            /*
             *  Only try to read the FF attributes if the object supports FF
             *  This may save time but is primarily to allow us to ignore FF 
             *  attributes in the registry for objects (such as FF driving 
             *  controller pedals) which IHVs mark incorrectly.
             */
            if( dwId & ( DIDFT_FFEFFECTTRIGGER | DIDFT_FFACTUATOR ) )
            {
                /*
                 *  Assert that we can read the DIFFOBJECTATTRIBUTES
                 *  directly into the DIDEVICEOBJECTINSTANCE_DX5.
                 */
                CAssertF(FIELD_OFFSET(DIFFOBJECTATTRIBUTES,
                                      dwFFMaxForce) == 0);
                CAssertF(FIELD_OFFSET(DIFFOBJECTATTRIBUTES,
                                      dwFFForceResolution) == 4);
                CAssertF(FIELD_OFFSET(DIDEVICEOBJECTINSTANCE_DX5,
                                      dwFFMaxForce) + 4 ==
                         FIELD_OFFSET(DIDEVICEOBJECTINSTANCE_DX5,
                                      dwFFForceResolution));
                CAssertF(cbX(DIFFOBJECTATTRIBUTES) == 8);

                /*
                 *  If this doesn't work, gee that's too bad.
                 *  JoyReg_GetValue will zero-fill the error parts.
                 */
                JoyReg_GetValue(hk, TEXT("FFAttributes"),
                                REG_BINARY, &pdidoiW->dwFFMaxForce,
                                cbX(DIFFOBJECTATTRIBUTES));
            }
            else
            {
                AssertF( ( pdidoiW->dwFFMaxForce | pdidoiW->dwFFForceResolution ) == 0 );
            }
        }

        /*
         *  Read the optional custom name.
         *
         *  Note that JoyReg_GetValue(REG_SZ) uses
         *  RegQueryStringValueW, which sets the
         *  string to null on error so we don't have to.
         */
        hres = JoyReg_GetValue(hk, 0, REG_SZ,
                               pdidoiW->tszName, cbX(pdidoiW->tszName));

        if(SUCCEEDED(hres))
        {
        } else
        {
            AssertF(pdidoiW->tszName[0] == L'\0');
        }

        RegCloseKey(hk);
    } else
    {
        AssertF(pdidoiW->tszName[0] == L'\0');
    }

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CType_RegGetTypeInfo |
 *
 *          Given an object ID, look into the registry subkey for the
 *          object and extract attribute bits that should be OR'd
 *          into the object ID.
 *
 *          This needs to be done during device initialization to
 *          establish the attributes in the data format so that
 *
 *          1.  <mf IDirectInputDevice::EnumObjects> filters properly, and
 *
 *          2.  >mf IDirectInputEffect::SetParameters> can validate properly.
 *
 *  @parm   HKEY | hkType |
 *
 *          The joystick type key, possibly <c NULL> if we don't
 *          have a type key.  (For example, if it was never created.)
 *
 *  @parm   LPDIOBJECTDATAFORMAT | podf |
 *
 *          Structure to receive more information.  The
 *          <e DIOBJECTDATAFORMAT.dwType> field identifies the object.
 *
 *          On return the
 *          <e DIOBJECTDATAFORMAT.dwType>
 *          and
 *          <e DIOBJECTDATAFORMAT.dwFlags>
 *          fields are updated.
 *
 *****************************************************************************/

void EXTERNAL
    CType_RegGetTypeInfo(HKEY hkType, LPDIOBJECTDATAFORMAT podf, BOOL fPidDevice)
{
    HRESULT hres;
    HKEY hk;
    EnterProc(CType_RegKeyObjectInfo, (_ "xx", hkType, podf->dwType));

    hres = CType_OpenIdSubkey(hkType, podf->dwType, KEY_QUERY_VALUE, &hk);

    if(SUCCEEDED(hres))
    {
        DWORD dwFlags;

        CAssertF(FIELD_OFFSET(DIOBJECTATTRIBUTES, dwFlags) == 0);

        hres = JoyReg_GetValue(hk, TEXT("Attributes"),
                               REG_BINARY, &dwFlags, cbX(dwFlags));

        if(SUCCEEDED(hres))
        {
            /*
             *  Propagate the attributes into the type code.
             */
            CAssertF(DIDOI_FFACTUATOR == DIDFT_GETATTR(DIDFT_FFACTUATOR));
            CAssertF(DIDOI_FFEFFECTTRIGGER
                     == DIDFT_GETATTR(DIDFT_FFEFFECTTRIGGER));

            /*
             *  PREFIX warns (333539) that dwFlags is not initialized however 
             *  JoyReg_GetValue zeroes any part of the buffer after the bytes 
             *  read from the registry if the buffer size is larger than what 
             *  was read.
             */
            podf->dwType |= DIDFT_MAKEATTR(dwFlags);

            podf->dwFlags |= (dwFlags & ~DIDOI_ASPECTMASK);

            /*
             *  Copy the aspect, but don't change
             *  the aspect from "known" to "unknown".  If the
             *  registry doesn't have an aspect, then use the
             *  aspect we got from the caller.
             */
            if((dwFlags & DIDOI_ASPECTMASK) != DIDOI_ASPECTUNKNOWN)
            {
                podf->dwFlags = (podf->dwFlags & ~DIDOI_ASPECTMASK) |
                                (dwFlags & DIDOI_ASPECTMASK);
            }
        }

        RegCloseKey(hk);
    }else
    {
#ifndef WINNT
        // Post Dx7Gold Patch
        // This is for Win9x only.
        // On Win9x, a device that is being accessed through the vjoyd path
        // will not get forces, as the attributes necessary for FF have not
        // been appropriately marked.

        // THe following code will mark the

        DWORD dwFlags  = DIDFT_GETATTR( podf->dwType & ~DIDFT_ATTRMASK )
                        | ( podf->dwFlags & ~DIDOI_ASPECTMASK);

        if(   dwFlags != 0x0
           && fPidDevice )
        {
            hres = CType_OpenIdSubkey(hkType, podf->dwType, DI_KEY_ALL_ACCESS, &hk);

            if(SUCCEEDED(hres) )
            {

                hres = JoyReg_SetValue(hk, TEXT("Attributes"),
                                   REG_BINARY, &dwFlags, cbX(dwFlags));

                RegCloseKey(hk);
            }
         }
#endif // ! WINNT
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CType_MakeGameCtrlName |
 *
 *          Make a game controller name from the attributes of the controller.
 *          Used as a last resort when a name is needed but none is available.
 *
 *  @parm   PWCHAR | wszName |
 *
 *          Output buffer where name will be generated.
 *
 *  @parm   DWORD | dwType |
 *
 *          DI8DEVTYPE value for the controller.
 *
 *  @parm   DWORD | dwAxes |
 *
 *          The number of axes the device has.
 *
 *  @parm   DWORD | dwButtons |
 *
 *          The numer of buttons the device has.
 *
 *  @parm   DWORD | dwPOVs |
 *
 *          The number of POVs the device has.
 *
 *****************************************************************************/

void EXTERNAL
CType_MakeGameCtrlName
( 
    PWCHAR  wszOutput, 
    DWORD   dwDevType,
    DWORD   dwAxes,
    DWORD   dwButtons,
    DWORD   dwPOVs
)
{
    TCHAR tsz[64];
    TCHAR tszPOV[64];
    TCHAR tszFormat[64];
#ifndef UNICODE
    TCHAR tszOut[cA(tsz)+cA(tszFormat)+cA(tszPOV)];
#endif

    /* tszFormat = %d axis, %d button %s */
    LoadString(g_hinst, IDS_TEXT_TEMPLATE, tszFormat, cA(tszFormat));

    /* tsz = joystick, gamepad, etc. */

    if( ( GET_DIDEVICE_TYPE( dwDevType ) >= DI8DEVTYPE_JOYSTICK )
     && ( GET_DIDEVICE_TYPE( dwDevType ) <= DI8DEVTYPE_FLIGHT ) )
    {
        LoadString(g_hinst, GET_DIDEVICE_TYPE( dwDevType ) + IDS_PLAIN_STICK - DI8DEVTYPE_JOYSTICK,
                            tsz, cA(tsz));
    }
    else if( GET_DIDEVICE_TYPEANDSUBTYPE( dwDevType ) 
          == MAKE_DIDEVICE_TYPE( DI8DEVTYPE_SUPPLEMENTAL, DI8DEVTYPESUPPLEMENTAL_HEADTRACKER ) )
    {
        LoadString(g_hinst, IDS_HEAD_TRACKER, tsz, cA(tsz));
    }
    else 
    {
        LoadString(g_hinst, IDS_DEVICE_NAME, tsz, cA(tsz));
    }

    if( dwPOVs )
    {
        LoadString(g_hinst, IDS_WITH_POV, tszPOV, cA(tszPOV));
    }
    else
    {
        tszPOV[0] = TEXT( '\0' );
    }

#ifdef UNICODE
    wsprintfW(wszOutput, tszFormat, dwAxes, dwButtons, tsz, tszPOV);
#else
    wsprintfA(tszOut, tszFormat, dwAxes, dwButtons, tsz, tszPOV);
    TToU(wszOutput, cA(tszOut), tszOut);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dilist.c ===
/*****************************************************************************
 *
 *  DIList.c
 *
 *  Copyright (c) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      List management.  Really, array management, since our lists
 *      never get very big.
 *
 *      We call them "GPA"s, which stands for "Growable Pointer Array".
 *
 *      There is a more general GXA gizmo in Dr Watson, but we don't
 *      need it yet.  So far, all we need to track is unsorted
 *      lists of pointers.
 *
 *      Yes, there exists a matching concept in COMCTL32, but we can't
 *      use it because
 *
 *      (1) it's not documented,
 *      (2) COMCTL32 puts them into shared memory, which is just
 *          begging for a memory leak.
 *
 *  Contents:
 *
 *      GPA_Init
 *      GPA_Term
 *
 *****************************************************************************/

#include "dinputpr.h"


/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflGpa



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | GPA_Print |
 *
 *          Print state of the growing pointer array.
 *
 *  @parm   HGPA | hgpa |
 *
 *  @returns    void
 *
 *****************************************************************************/
void INTERNAL
GPA_Print(HGPA hgpa)
{
    int ipv;
    for (ipv = 0; ipv < hgpa->cpv; ipv++)
    {
		// 7/18/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
        SquirtSqflPtszV( sqflError,
                        TEXT("ipv=%d,hgpa->rgpv[ipv]=%p"),
                        ipv, hgpa->rgpv[ipv]);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | GPA_Append |
 *
 *          Add a new item to the growing pointer array.
 *
 *          Note that we add 8 after doubling, so that we don't get
 *          stuck if cxAlloc is zero.
 *
 *  @parm   HGPA | hgpa |
 *
 *          Handle to pointer array.
 *
 *  @parm   PV | pv |
 *
 *          Pointer to add.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
GPA_Append(HGPA hgpa, PV pv)
{
    HRESULT hres;

    if (hgpa->cpv >= hgpa->cpvAlloc) {
        hres = ReallocCbPpv(cbX(PV) * (hgpa->cpvAlloc * 2 + 8),
                            &hgpa->rgpv);
        // Prefix: Whistler 45077.   
        if (FAILED(hres) || ( hgpa->rgpv == NULL) ) {
            goto done;
        }

        hgpa->cpvAlloc = hgpa->cpvAlloc * 2 + 8;
    }

    //hgpa->rgpv[hgpa->cpv++] = pv;
    hgpa->rgpv[hgpa->cpv] = pv;
    InterlockedIncrement(&hgpa->cpv);

    hres = S_OK;


done:;
    //GPA_Print(hgpa);
    return hres;

}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | GPA_FindPtr |
 *
 *          Determine whether a pointer is in the GPA.
 *
 *  @parm   HGPA | hgpa |
 *
 *          Handle to pointer array.
 *
 *  @parm   PV | pv |
 *
 *          Pointer to locate.
 *
 *  @returns
 *
 *          Returns a COM error code on failure.
 *
 *          On success, returns the number of items left in the GPA.
 *
 *****************************************************************************/

BOOL EXTERNAL
GPA_FindPtr(HGPA hgpa, PV pv)
{
    BOOL fRc;
    int ipv;

    for (ipv = 0; ipv < hgpa->cpv; ipv++) {
        if (hgpa->rgpv[ipv] == pv) {
            fRc = TRUE;
            goto done;
        }
    }

    fRc = FALSE;

done:;
    return fRc;

}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | GPA_DeletePtr |
 *
 *          Remove the indicated pointer from the GPA.  The order of
 *          the remaining items is unspecified.
 *
 *          Note that CEm_LL_ThreadProc assumes that no items before
 *          the deleted item are affected by the deletion.
 *
 *  @parm   HGPA | hgpa |
 *
 *          Handle to pointer array.
 *
 *  @parm   PV | pv |
 *
 *          Pointer to delete.
 *
 *  @returns
 *
 *          Returns a COM error code on failure.
 *
 *          On success, returns the number of items left in the GPA.
 *
 *****************************************************************************/

STDMETHODIMP
GPA_DeletePtr(HGPA hgpa, PV pv)
{
    HRESULT hres;
    int ipv;

    for (ipv = 0; ipv < hgpa->cpv; ipv++) {
        if (hgpa->rgpv[ipv] == pv) {
            //hgpa->rgpv[ipv] = hgpa->rgpv[--hgpa->cpv];
            InterlockedDecrement(&hgpa->cpv);
            hgpa->rgpv[ipv] = hgpa->rgpv[hgpa->cpv];
            hres = hgpa->cpv;
            goto done;
        }
    }

    hres = E_FAIL;

done:;
    //GPA_Print(hgpa);
    return hres;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | GPA_Clone |
 *
 *          Copy the contents of one GPA to another.
 *
 *  @parm   HGPA | hgpaDst |
 *
 *          Handle to destination pointer array.
 *
 *  @parm   HGPA | hgpaSrc |
 *
 *          Handle to source pointer array.
 *
 *****************************************************************************/

STDMETHODIMP
GPA_Clone(HGPA hgpaDst, HGPA hgpaSrc)
{
    HRESULT hres;

    hres = AllocCbPpv(cbCxX(hgpaSrc->cpv, PV), &hgpaDst->rgpv);

    if (SUCCEEDED(hres)) {
        CopyMemory(hgpaDst->rgpv, hgpaSrc->rgpv, cbCxX(hgpaSrc->cpv, PV));
        hgpaDst->cpv = hgpaSrc->cpv;
        hgpaDst->cpvAlloc = hgpaSrc->cpvAlloc;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | GPA_Init |
 *
 *          Initialize a GPA structure with no elements.
 *
 *  @parm   HGPA | hgpa |
 *
 *          Handle to pointer array.
 *
 *****************************************************************************/

void EXTERNAL
GPA_Init(HGPA hgpa)
{
    hgpa->rgpv = 0;
    hgpa->cpv = 0;
    hgpa->cpvAlloc = 0;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | GPA_Term |
 *
 *          Clean up an existing GPA.
 *
 *  @parm   HGPA | hgpa |
 *
 *          Handle to pointer array.
 *
 *****************************************************************************/

void EXTERNAL
GPA_Term(HGPA hgpa)
{
    FreePpv(&hgpa->rgpv);
    GPA_Init(hgpa);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dimem.c ===
/*****************************************************************************
 *
 *  DIMem.c
 *
 *  Copyright (c) 1996 - 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Memory management
 *
 *  Contents:
 *
 *      ReallocCbPpv
 *      AllocCbPpv
 *      FreePpv
 *
 *****************************************************************************/

#include "dinputpr.h"

#ifdef NEED_REALLOC

/*****************************************************************************
 *
 *      ReallocCbPpv
 *
 *      Change the size of some zero-initialized memory.
 *
 *      This is the single place where all memory is allocated, resized,
 *      and freed.
 *
 *      If you realloc from a null pointer, memory is allocated.
 *      If you realloc to zero-size, memory is freed.
 *
 *      These semantics avoid boundary cases.  For example, it is no
 *      longer a problem trying to realloc something down to zero.
 *      You don't have to worry about special-casing an alloc of 0 bytes.
 *
 *      If an error is returned, the original pointer is UNCHANGED.
 *      This saves you from having to the double-switch around a realloc.
 *
 *****************************************************************************/

STDMETHODIMP EXTERNAL
ReallocCbPpv(UINT cb, PV ppvArg)
{
    HRESULT hres;
    PPV ppv = ppvArg;
    HLOCAL hloc = *ppv;
    if (cb) {                       /* Alloc or realloc */
        if (hloc) {                 /* Realloc */
            hloc = LocalReAlloc(*ppv, cb,
                                LMEM_MOVEABLE+LMEM_ZEROINIT);
        } else {                /* Alloc */
            hloc = LocalAlloc(LPTR, cb);
        }
        if (hloc) {
            *ppv = hloc;
            hres = NOERROR;
        } else {
            hres = E_OUTOFMEMORY;
        }
    } else {                    /* Freeing */
        if (hloc) {
            LocalFree(hloc);
            *ppv = 0;           /* All gone */
        } else {
                                /* Nothing to free */
        }
        hres = NOERROR;         
    }

    return hres;
}

/*****************************************************************************
 *
 *      AllocCbPpv
 *
 *      Simple wrapper that forces *ppvObj = 0 before calling Realloc.
 *
 *****************************************************************************/

STDMETHODIMP EXTERNAL
AllocCbPpv(UINT cb, PPV ppv)
{
    *ppv = 0;
    return ReallocCbPpv(cb, ppv);
}

#else

/*****************************************************************************
 *
 *      AllocCbPpv
 *
 *      Allocate memory into the ppv.
 *
 *****************************************************************************/

STDMETHODIMP EXTERNAL
AllocCbPpv(UINT cb, PPV ppv)
{
    HRESULT hres;
    *ppv = LocalAlloc(LPTR, cb);
    hres = *ppv ? NOERROR : E_OUTOFMEMORY;
    return hres;
}

/*****************************************************************************
 *
 *      FreePpv
 *
 *      Free memory from the ppv.
 *
 *****************************************************************************/

void EXTERNAL
FreePpv(PV ppv)
{
#ifdef _M_IA64
    PV pv = (PV)InterlockedExchange64(ppv, 0);
#else
    PV pv = (PV)InterlockedExchange(ppv, 0);
#endif
    if (pv) {
        FreePv(pv);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dijoyreg.c ===
/*****************************************************************************
 *
 *  DIJoyReg.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Registry access services for joystick configuration.
 *
 *  Contents:
 *
 *      JoyReg_GetConfig
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflJoyReg

#pragma BEGIN_CONST_DATA

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global JOYREGHWSETTINGS | c_rghwsPredef[] |
 *
 *          Array of predefined hardware settings.
 *
 *****************************************************************************/

JOYREGHWSETTINGS c_rghwsPredef[] = {
    /* dwFlags             dwNumButtons */
    {  0,                             2},  /* JOY_HW_2A_2B_GENERIC         */
    {  0,                             4},  /* JOY_HW_2A_4B_GENERIC         */
    {  JOY_HWS_ISGAMEPAD,             2},  /* JOY_HW_2B_GAMEPAD            */
    {  JOY_HWS_ISYOKE,                2},  /* JOY_HW_2B_FLIGHTYOKE         */
    {  JOY_HWS_HASZ | JOY_HWS_ISYOKE, 2},  /* JOY_HW_2B_FLIGHTYOKETHROTTLE */
    {  JOY_HWS_HASZ,                  2},  /* JOY_HW_3A_2B_GENERIC         */
    {  JOY_HWS_HASZ,                  4},  /* JOY_HW_3A_4B_GENERIC         */
    {  JOY_HWS_ISGAMEPAD,             4},  /* JOY_HW_4B_GAMEPAD            */
    {  JOY_HWS_ISYOKE,                4},  /* JOY_HW_4B_FLIGHTYOKE         */
    {  JOY_HWS_HASZ | JOY_HWS_ISYOKE, 4},  /* JOY_HW_4B_FLIGHTYOKETHROTTLE */
    {  JOY_HWS_HASR                 , 2},  /* JOY_HW_TWO_2A_2B_WITH_Y      */
    /* To prevent the CPL from allowing 
       a user to add a rudder to to JOY_HWS_TWO_2A_2B_WITH_Y case, we 
       will pretend that it already has a rudder. This should not be a problem 
       as this struct is internal to DInput
       */
};

/* Hardware IDs for Predefined Joystick types */
LPCWSTR c_rghwIdPredef[] =
{
    L"GAMEPORT\\VID_045E&PID_0102",  //   L"GAMEPORT\\Generic2A2B",
    L"GAMEPORT\\VID_045E&PID_0103",  //   L"GAMEPORT\\Generic2A4B",
    L"GAMEPORT\\VID_045E&PID_0104",  //   L"GAMEPORT\\Gamepad2B",
    L"GAMEPORT\\VID_045E&PID_0105",  //   L"GAMEPORT\\FlightYoke2B",
    L"GAMEPORT\\VID_045E&PID_0106",  //   L"GAMEPORT\\FlightYokeThrottle2B",
    L"GAMEPORT\\VID_045E&PID_0107",  //   L"GAMEPORT\\Generic3A2B",
    L"GAMEPORT\\VID_045E&PID_0108",  //   L"GAMEPORT\\Generic3A4B",
    L"GAMEPORT\\VID_045E&PID_0109",  //   L"GAMEPORT\\Gamepad4B",
    L"GAMEPORT\\VID_045E&PID_010A",  //   L"GAMEPORT\\FlightYoke4B",
    L"GAMEPORT\\VID_045E&PID_010B",  //   L"GAMEPORT\\FlightYokeThrottle4B",
    L"GAMEPORT\\VID_045E&PID_010C",  //   L"GAMEPORT\\YConnectTwo2A2B",
};

WCHAR c_hwIdPrefix[] = L"GAMEPORT\\";   //  Prefix for custom devices

/*****************************************************************************
 *
 *      The default global port driver.
 *
 *****************************************************************************/

WCHAR c_wszDefPortDriver[] = L"MSANALOG.VXD";

#ifdef WINNT
    #define REGSTR_SZREGKEY     TEXT("\\DINPUT.DLL\\")
#endif


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_GetValue |
 *
 *          Retrieve registry information.  If the data is short, and
 *          the type is <c REG_BINARY>, then the extra is zero-filled.
 *
 *  @parm   HKEY | hk |
 *
 *          Registry key containing fun values.
 *
 *  @parm   LPCTSTR | ptszValue |
 *
 *          Registry value name.
 *
 *  @parm   DWORD | reg |
 *
 *          Registry data type expected.
 *
 *  @parm   LPVOID | pvBuf |
 *
 *          Buffer to receive information from registry.
 *
 *  @parm   DWORD | cb |
 *
 *          Size of recipient buffer, in bytes.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c S_FALSE>: The binary read was short.  The remainder of the
 *          buffer is zero-filled.
 *
 *          <c E_FAIL>: Error reading value from registry.
 *
 *****************************************************************************/

STDMETHODIMP
JoyReg_GetValue(HKEY hk, LPCTSTR ptszValue, DWORD reg, PV pvBuf, DWORD cb)
{
    HRESULT hres;
    DWORD cbOut;
    LONG lRc;

    /*
     *  Strings must be handled differently from binaries.
     *
     *  Strings are retrieved in UNICODE and may be short.
     *
     *  Binaries are retrieved as binary (duh) and may be long.
     *
     */

    cbOut = cb;

    if (reg == REG_SZ)
    {
        lRc = RegQueryStringValueW(hk, ptszValue, pvBuf, &cbOut);
        if (lRc == ERROR_SUCCESS)
        {
            hres = S_OK;
        } else
        {
            hres = hresLe(lRc);          /* Else, something bad happened */
        }

    } else
    {

        AssertF(reg == REG_BINARY);

        lRc = RegQueryValueEx(hk, ptszValue, 0, NULL, pvBuf, &cbOut);
        if (lRc == ERROR_SUCCESS)
        {
            if (cb == cbOut)
            {
                hres = S_OK;
            } else
            {

                /*
                 *  Zero out the extra.
                 */
                ZeroBuf(pvAddPvCb(pvBuf, cbOut), cb - cbOut);
                hres = S_FALSE;
            }


        } else if (lRc == ERROR_MORE_DATA)
        {

            /*
             *  Need to double-buffer the call and throw away
             *  the extra...
             */
            LPVOID pv;

            hres = AllocCbPpv(cbOut, &pv);
            // prefix 29344, odd chance that cbOut is 0x0 
            if (SUCCEEDED(hres) && ( pv != NULL)  )
            {
                lRc = RegQueryValueEx(hk, ptszValue, 0, NULL, pv, &cbOut);
                if (lRc == ERROR_SUCCESS)
                {
                    CopyMemory(pvBuf, pv, cb);
                    hres = S_OK;
                } else
                {
                    ZeroBuf(pvBuf, cb);
                    hres = hresLe(lRc);  /* Else, something bad happened */
                }
                FreePv(pv);
            }

        } else
        {
            if (lRc == ERROR_KEY_DELETED || lRc == ERROR_BADKEY)
            {
                lRc = ERROR_FILE_NOT_FOUND;
            }
            hres = hresLe(lRc);
            ZeroBuf(pvBuf, cb);
        }
    }

#ifdef DEBUG
    /*
     *  Don't whine if the key we couldn't find was
     *  REGSTR_VAL_JOYUSERVALUES, because almost no one has it.
     */
    if (FAILED(hres) &&  lstrcmpi(ptszValue, REGSTR_VAL_JOYUSERVALUES)  )
    {

        SquirtSqflPtszV(sqfl | sqflVerbose,
                        TEXT("Unable to read %s from registry"),
                        ptszValue);
    }
#endif

    return hres;

}

#ifndef WINNT
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_IsWdmGameport |
 *
 *          To test whether the joy type is WDM device or not.
 *
 *  @parm   HKEY | hk |
 *
 *          Registry key containing fun values.
 *
 *  @returns
 *
 *          S_OK: if it uses WDM driver
 *
 *          E_FAIL>: Not uses WDM driver
 *
 *****************************************************************************/


STDMETHODIMP
JoyReg_IsWdmGameport( HKEY hk ) 
{
    HRESULT hres = E_FAIL;

    if ( hk )
    {
        WCHAR wsz[MAX_JOYSTRING];

        // Whistler PREFIX Bug #  45075, 45076
        // Wsz is not initialized
        ZeroX(wsz);

        if ( ( SUCCEEDED( JoyReg_GetValue( hk, REGSTR_VAL_JOYOEMHARDWAREID, REG_SZ, 
                                           &wsz, cbX(wsz) ) ) )
             &&( wsz[0] ) )
        {
            hres = S_OK;
        } else if ( SUCCEEDED( JoyReg_GetValue( hk, REGSTR_VAL_JOYOEMCALLOUT, REG_SZ, 
                                                &wsz, cbX(wsz) ) ) )
        {
            static WCHAR wszJoyhid[] = L"joyhid.vxd";
            int Idx;
#define WLOWER 0x0020

            CAssertF( cbX(wszJoyhid) <= cbX(wsz) ); 

            /*
             *  Since neither CharUpperW nor lstrcmpiW are really 
             *  implemented on 9x, do it by hand.
             */

            for ( Idx=cA(wszJoyhid)-2; Idx>=0; Idx-- )
            {
                if ( ( wsz[Idx] | WLOWER ) != wszJoyhid[Idx] )
                {
                    break;
                }
            }

            if ( ( Idx < 0 ) && ( wsz[cA(wszJoyhid)-1] == 0 ) )
            {
                hres = S_OK;
            }

#undef WLOWER
        }

    }

    return hres;
}
#endif /* ndef WINNT */


#if 0
/*
 * This function should be in diutil.c Putting here is just to keep it together with
 * JoyReg_IsWdmGameport();
 */
STDMETHODIMP
JoyReg_IsWdmGameportFromDeviceInstance( LPTSTR ptszDeviceInst ) 
{
    /*
     * ptszDeviceInst's format is like this: 
     *     HID\VID_045E&PID_0102\0000GAMEPORT&PVID_....
     */

    WCHAR wszDeviceInst[MAX_PATH];
    HRESULT hres = E_FAIL;

    if ( ptszDeviceInst )
    {
        memset( wszDeviceInst, 0, cbX(wszDeviceInst) );
        TToU( wszDeviceInst, MAX_PATH, ptszDeviceInst );
        wszDeviceInst[34] = 0;

        if ( memcmp( &wszDeviceInst[26], c_hwIdPrefix, 16 ) == 0 )
        {
            hres = S_OK;
        }
    }

    return hres;
}
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_SetValue |
 *
 *          Write registry information.
 *
 *  @parm   HKEY | hk |
 *
 *          Registry key containing fun values.
 *
 *  @parm   LPCTSTR | ptszValue |
 *
 *          Registry value name.
 *
 *  @parm   DWORD | reg |
 *
 *          Registry data type to set.
 *
 *  @parm   LPCVOID | pvBuf |
 *
 *          Buffer containing information to write to registry.
 *
 *  @parm   DWORD | cb |
 *
 *          Size of buffer, in bytes.  Ignored if writing a string.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c E_FAIL>: Error writing value to registry.
 *
 *****************************************************************************/

STDMETHODIMP
JoyReg_SetValue(HKEY hk, LPCTSTR ptszValue, DWORD reg, PCV pvBuf, DWORD cb)
{
    HRESULT hres;
    LONG lRc;

    /*
     *  Strings must be handled differently from binaries.
     *
     *  A null string translates into deleting the key.
     */

    if (reg == REG_SZ)
    {
        lRc = RegSetStringValueW(hk, ptszValue, pvBuf);
    } else
    {
        lRc = RegSetValueEx(hk, ptszValue, 0, reg, pvBuf, cb);
    }

    if (lRc == ERROR_SUCCESS)
    {
        hres = S_OK;
    } else
    {
        RPF("Unable to write %s to registry", ptszValue);
        hres = E_FAIL;          /* Else, something bad happened */
    }

    return hres;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_OpenTypeKey |
 *
 *          Open the joystick registry key that corresponds to a
 *          joystick type.
 *
 *  @parm   LPCWSTR | pwszTypeName |
 *
 *          The name of the type.
 *
 *  @parm   DWORD | sam |
 *
 *          Desired security access mask.
 *
 *  @parm   OUT PHKEY | phk |
 *
 *          Receives the opened registry key on success.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTFOUND>: The joystick type was not found.
 *
 *****************************************************************************/

STDMETHODIMP
JoyReg_OpenTypeKey(LPCWSTR pwszType, DWORD sam, DWORD dwOptions, PHKEY phk)
{
    HRESULT hres;
    HKEY hkTypes;
    EnterProc(JoyReg_OpenTypeKey, (_ "W", pwszType));

    /*
     *  Note that it is not safe to cache the registry key.
     *  If somebody deletes the registry key, our handle
     *  goes stale and becomes useless.
     */

    hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE, 
                           REGSTR_PATH_JOYOEM, 
                           sam, 
                           REG_OPTION_NON_VOLATILE, 
                           &hkTypes);

    if ( SUCCEEDED(hres) )
    {
#ifndef UNICODE
        TCHAR tszType[MAX_PATH];
        UToA( tszType, cA(tszType), pwszType );

        hres = hresMumbleKeyEx(hkTypes, 
                               tszType, 
                               sam, 
                               dwOptions, 
                               phk);
#else

        hres = hresMumbleKeyEx(hkTypes, 
                               pwszType, 
                               sam,
                               dwOptions, 
                               phk);
#endif     

        RegCloseKey(hkTypes);
    }

    if (FAILED(hres))
    {
        *phk = 0;
    }

    ExitBenignOleProcPpv(phk);
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_OpenPropKey |
 *
 *          Open the Dinput properties registry key that corresponds to a
 *          device type. This key contains the OEMMapFile and dwFlags2 information
 *          Nominally the location HKLM/REGSTR_PATH_PRIVATEPROPERTIES/DirectInput.
 *
 *  @parm   LPCWSTR | pwszTypeName |
 *
 *          The name of the type.
 *
 *  @parm   DWORD | sam |
 *
 *          Desired security access mask.
 *
 *  @parm   OUT PHKEY | phk |
 *
 *          Receives the opened registry key on success.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTFOUND>: The type was not found.
 *
 *****************************************************************************/

STDMETHODIMP
JoyReg_OpenPropKey(LPCWSTR pwszType, DWORD sam, DWORD dwOptions, PHKEY phk)
{
    HRESULT hres;
    HKEY hkTypes;
    EnterProc(JoyReg_OpenTypeKey, (_ "W", pwszType));

    /*
     *  Note that it is not safe to cache the registry key.
     *  If somebody deletes the registry key, our handle
     *  goes stale and becomes useless.
     */

    hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE, 
                           REGSTR_PATH_DITYPEPROP, 
                           sam, 
                           REG_OPTION_NON_VOLATILE, 
                           &hkTypes);

    if ( SUCCEEDED(hres) )
    {
#ifndef UNICODE
        TCHAR tszType[MAX_PATH];
        UToA( tszType, cA(tszType), pwszType );

        hres = hresMumbleKeyEx(hkTypes, 
                               tszType, 
                               sam, 
                               dwOptions, 
                               phk);
#else

        hres = hresMumbleKeyEx(hkTypes, 
                               pwszType, 
                               sam,
                               dwOptions, 
                               phk);
#endif     

        RegCloseKey(hkTypes);
    }

    if (FAILED(hres))
    {
        *phk = 0;
    }

    ExitBenignOleProcPpv(phk);
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_GetTypeInfo |
 *
 *          Obtain information about a non-predefined joystick type.
 *
 *  @parm   LPCWSTR | pwszTypeName |
 *
 *          The name of the type.
 *
 *  @parm   OUT LPDIJOYTYPEINFO | pjti |
 *
 *          Receives information about the joystick type.
 *          The caller is assumed to have validated the
 *          <e DIJOYCONFIG.dwSize> field.
 *
 *  @parm   DWORD | fl |
 *
 *          Zero or more <c DITC_*> flags
 *          which specify which parts of the structure pointed
 *          to by <p pjti> are to be filled in.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *          <c S_FALSE> if some of the data was not available.
 *
 *          <c DIERR_NOTFOUND>: The joystick type was not found.
 *
 *****************************************************************************/

STDMETHODIMP
JoyReg_GetTypeInfo(LPCWSTR pwszType, LPDIJOYTYPEINFO pjti, DWORD fl)
{
    HRESULT hres = S_FALSE;
    HKEY    hk;
    BOOL    fPartialData = FALSE;
    EnterProc(JoyReg_GetTypeInfo, (_ "Wx", pwszType, fl));


    ZeroX(pjti->clsidConfig);

    if( fl & ( DITC_FLAGS2 | DITC_MAPFILE ) )
    {
        /*
         *  The new registry branch is likely to be empty for many devices 
         *  so don't fail for anything here.
         */

        hres = JoyReg_OpenPropKey(pwszType, KEY_QUERY_VALUE, REG_OPTION_NON_VOLATILE, &hk);

        if( SUCCEEDED( hres ) )
        {
            if( fl & DITC_FLAGS2 )
            {
                hres = JoyReg_GetValue(hk,
                                       REGSTR_VAL_FLAGS2, REG_BINARY, 
                                       &pjti->dwFlags2, 
                                       cbX(pjti->dwFlags2) );

                pjti->dwFlags2 &= JOYTYPE_FLAGS2_GETVALID;

                if( FAILED( hres ) )
                {
                    pjti->dwFlags2 = 0x0;
                    fPartialData = TRUE;
                }
            }

            if( fl & DITC_MAPFILE )
            {
                hres = JoyReg_GetValue(hk,
                                       REGSTR_VAL_JOYOEMMAPFILE, REG_SZ,
                                       pjti->wszMapFile,
                                       cbX(pjti->wszMapFile));
                if( FAILED( hres ) )
                {
                    ZeroX(pjti->wszMapFile);
                    fPartialData = TRUE;
                }
            }

            RegCloseKey(hk);
        }
        else
        {
            pjti->dwFlags2 = 0x0;
            ZeroX(pjti->wszMapFile);
            fPartialData = TRUE;
        }

        hres = S_OK;
    }

    if( fl & DITC_INREGISTRY_DX6 )
    {
        hres = JoyReg_OpenTypeKey(pwszType, KEY_QUERY_VALUE, REG_OPTION_NON_VOLATILE, &hk);

        if (SUCCEEDED(hres))
        {

            if (fl & DITC_REGHWSETTINGS)
            {
                hres = JoyReg_GetValue(hk,
                                       REGSTR_VAL_JOYOEMDATA, REG_BINARY,
                                       &pjti->hws, cbX(pjti->hws));
                if (FAILED(hres))
                {
                    goto closedone;
                }
            }

            /*
             *  Note that this never fails.
             */
            if (fl & DITC_CLSIDCONFIG)
            {
                TCHAR tszGuid[ctchGuid];
                LONG lRc;

                lRc = RegQueryString(hk, REGSTR_VAL_CPLCLSID, tszGuid, cA(tszGuid));

                if (lRc == ERROR_SUCCESS &&
                    ParseGUID(&pjti->clsidConfig, tszGuid))
                {
                    /* Guid is good */
                } else
                {
                    ZeroX(pjti->clsidConfig);
                }
            }

            if (fl & DITC_DISPLAYNAME)
            {
                hres = JoyReg_GetValue(hk,
                                       REGSTR_VAL_JOYOEMNAME, REG_SZ,
                                       pjti->wszDisplayName,
                                       cbX(pjti->wszDisplayName));
                if (FAILED(hres))
                {
                    goto closedone;
                }
            }

#ifndef WINNT
            if (fl & DITC_CALLOUT)
            {
                hres = JoyReg_GetValue(hk,
                                       REGSTR_VAL_JOYOEMCALLOUT, REG_SZ,
                                       pjti->wszCallout,
                                       cbX(pjti->wszCallout));
                if (FAILED(hres))
                {
                    ZeroX(pjti->wszCallout);
                    hres = S_FALSE;
                    fPartialData = TRUE;
                }
            }
#endif

            if ( fl & DITC_HARDWAREID )
            {
                hres = JoyReg_GetValue(hk,
                                       REGSTR_VAL_JOYOEMHARDWAREID, REG_SZ,
                                       pjti->wszHardwareId,
                                       cbX(pjti->wszHardwareId));
                if ( FAILED(hres))
                {
                    ZeroX(pjti->wszHardwareId);
                    hres = S_FALSE;
                    fPartialData = TRUE;
                }
            }

            if ( fl & DITC_FLAGS1 )
            {
                hres = JoyReg_GetValue(hk,
                                       REGSTR_VAL_FLAGS1, REG_BINARY, 
                                       &pjti->dwFlags1, 
                                       cbX(pjti->dwFlags1) );
                if ( FAILED(hres) )
                {
                    pjti->dwFlags1 = 0x0;
                    hres = S_FALSE;
                    fPartialData = TRUE;
                }
                pjti->dwFlags1 &= JOYTYPE_FLAGS1_GETVALID;
            }
            hres = S_OK;

            closedone:;
            RegCloseKey(hk);


        } else
        {
            // ISSUE-2001/03/29-timgill debug string code should be higher
            // (MarcAnd) this really should be at least sqflError but
            // this happens a lot, probably due to not filtering out predefs
            SquirtSqflPtszV(sqfl | sqflBenign,
                            TEXT( "IDirectInputJoyConfig::GetTypeInfo: Nonexistent type %lS" ),
                            pwszType);
            hres = DIERR_NOTFOUND;
        }
    }

    if( SUCCEEDED( hres ) && fPartialData )
    {
        hres = S_FALSE;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_SetTypeInfo |
 *
 *          Store information about a non-predefined joystick type
 *          into the registry.
 *
 *  @parm   HKEY | hkTypeW |
 *
 *          Registry key to the types branch with write access.
 *
 *  @parm   LPCWSTR | pwszTypeName |
 *
 *          The name of the type.
 *
 *  @parm   IN LPCDIJOYTYPEINFO | pjti |
 *
 *          Contains information about the joystick type.
 *
 *  @parm   DWORD | fl |
 *
 *          Zero or more <c DITC_*> flags
 *          which specify which parts of the structure pointed
 *          to by <p pjti> contain values which are to be set.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTFOUND>: The joystick type was not found.
 *
 *****************************************************************************/

STDMETHODIMP
JoyReg_SetTypeInfo(HKEY hkTypesW,
                   LPCWSTR pwszType, LPCDIJOYTYPEINFO pjti, DWORD fl)
{
    HRESULT hres = S_OK;   /* Vacuous success in case of no flags set */
    LONG lRc;
    EnterProc(JoyRegSetTypeInfo, (_ "Wx", pwszType, fl));

    if( fl & ( DITC_FLAGS2 | DITC_MAPFILE ) )
    {
        HKEY hkProp;

        hres = JoyReg_OpenPropKey(pwszType, DI_KEY_ALL_ACCESS, REG_OPTION_NON_VOLATILE, &hkProp);

        if( SUCCEEDED( hres ) )
        {
            if( fl & DITC_FLAGS2 )
            {
                DWORD   dwTemp;

                /*
                 *  Read and merge any current value so that bits unused in 
                 *  DX8 can be preserved.  Although this is more work now it 
                 *  should save adding Flags3 support next time.
                 */
                AssertF( (pjti->dwFlags2 & ~JOYTYPE_FLAGS2_SETVALID) == 0x0 );

                /*
                 *  PREFIX warns (259898) that RegQueryValueEx reads the value 
                 *  of dwTemp before it is set but then it checks lpData and 
                 *  zeroes the value before it is used.
                 */
                lRc = RegQueryValueEx( hkProp, REGSTR_VAL_FLAGS2, 0, 0, 0, &dwTemp );

                if( lRc == ERROR_FILE_NOT_FOUND )
                {
                    lRc = ERROR_SUCCESS;
                    dwTemp = cbX( pjti->dwFlags2 );
                }

                if( lRc == ERROR_SUCCESS )
                {
                    if( dwTemp <= cbX( pjti->dwFlags2 ) )
                    {
                        CAssertF( cbX( dwTemp ) == cbX( pjti->dwFlags2 ) );
                        JoyReg_GetValue( hkProp, REGSTR_VAL_FLAGS2, 
                                         REG_BINARY, &dwTemp, cbX( dwTemp ) );

                        dwTemp &= ~JOYTYPE_FLAGS2_SETVALID;
                        dwTemp |= pjti->dwFlags2;

                        if( dwTemp )
                        {
                            hres = JoyReg_SetValue( hkProp, REGSTR_VAL_FLAGS2, 
                                                    REG_BINARY, (PV)&dwTemp, cbX( dwTemp ) );
                        } else
                        {
                            lRc = RegDeleteValue( hkProp, REGSTR_VAL_FLAGS2 );
                            if (lRc == ERROR_FILE_NOT_FOUND)
                            {
                                lRc = ERROR_SUCCESS;
                            }
                            hres = hresLe( lRc );
                        }
                    } 
                    else
                    {
                        /*
                         *  Need to double buffer for the extra bytes
                         */
                        PBYTE pbFlags2;

                        hres = AllocCbPpv( dwTemp, &pbFlags2 );
                        if( SUCCEEDED( hres ) )
                        {
                            if ( ERROR_SUCCESS == RegQueryValueEx(
                                                                 hkProp, REGSTR_VAL_FLAGS2, 0, NULL, pbFlags2, &dwTemp ) )
                            {
                                CAssertF( JOYTYPE_FLAGS2_SETVALID == JOYTYPE_FLAGS2_GETVALID );
                                *(PDWORD)pbFlags2 &= ~JOYTYPE_FLAGS2_SETVALID;
                                *(PDWORD)pbFlags2 |= pjti->dwFlags2;

                                if ( ERROR_SUCCESS == RegSetValueEx(
                                                                   hkProp, REGSTR_VAL_FLAGS2, 0, REG_BINARY, pbFlags2, dwTemp ) )
                                {
                                    hres = S_OK;
                                } else
                                {
                                    SquirtSqflPtszV(sqfl | sqflError,
                                                    TEXT( "IDIJC::SetTypeInfo: failed to write extended Flags2" ) );
                                    hres = E_FAIL;
                                }
                            } else
                            {
                                SquirtSqflPtszV(sqfl | sqflError,
                                                TEXT( "IDIJC::SetTypeInfo: failed to read extended Flags2" ) );
                                hres = E_FAIL;  /* Else, something bad happened */
                            }
                            FreePv( pbFlags2 );
                        }
                    }
                } 
                else
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT( "IDIJC::SetTypeInfo: failed to read size of Flags2, error %d" ), lRc );
                    hres = hresLe( lRc );
                }

                if( FAILED( hres ) )
                {
                    hres = S_FALSE;
                    goto closedoneprop;
                }
            }

            if( fl & DITC_MAPFILE )
            {
                hres = JoyReg_SetValue(hkProp,
                                       REGSTR_VAL_JOYOEMMAPFILE, REG_SZ,
                                       pjti->wszMapFile,
                                       cbX(pjti->wszMapFile));
                if( FAILED(hres) )
                {
                    hres = S_FALSE;
                    goto closedoneprop;
                }
            }

            hres = S_OK;
            closedoneprop:;

            RegCloseKey(hkProp);
        }
        else
        {
            RPF( "Failed to open DirectInput type property key" );
        }
    }

    if( hres == S_OK )
    {
        if( fl & DITC_INREGISTRY_DX6 )
        {
            HKEY hk;
            DWORD dwOptions = 0;


            if ( fl & DITC_VOLATILEREGKEY )
            {
                dwOptions = REG_OPTION_VOLATILE;
            } else
            {
                dwOptions = REG_OPTION_NON_VOLATILE;    
            }

#ifndef UNICODE
            {
                TCHAR tszType[MAX_PATH];

                UToA(tszType, cA(tszType), pwszType);

                hres = hresMumbleKeyEx(hkTypesW, 
                                       tszType, 
                                       DI_KEY_ALL_ACCESS, 
                                       dwOptions, 
                                       &hk);

            }
#else
            hres = hresMumbleKeyEx(hkTypesW, 
                                   pwszType, 
                                   DI_KEY_ALL_ACCESS, 
                                   dwOptions, 
                                   &hk);
#endif

            if ( SUCCEEDED(hres) )
            {

                if (fl & DITC_REGHWSETTINGS)
                {
                    hres = JoyReg_SetValue(hk, REGSTR_VAL_JOYOEMDATA, REG_BINARY,
                                           (PV)&pjti->hws, cbX(pjti->hws));
                    if (FAILED(hres))
                    {
                        goto closedone;
                    }
                }

                if (fl & DITC_CLSIDCONFIG)
                {
                    if (IsEqualGUID(&pjti->clsidConfig, &GUID_Null))
                    {
                        lRc = RegDeleteValue(hk, REGSTR_VAL_CPLCLSID);

                        /*
                         *  It is not an error if the key does not already exist.
                         */
                        if (lRc == ERROR_FILE_NOT_FOUND)
                        {
                            lRc = ERROR_SUCCESS;
                        }
                    } else
                    {
                        TCHAR tszGuid[ctchNameGuid];
                        NameFromGUID(tszGuid, &pjti->clsidConfig);
                        lRc = RegSetValueEx(hk, REGSTR_VAL_CPLCLSID, 0, REG_SZ,
                                            (PV)&tszGuid[ctchNamePrefix], ctchGuid * cbX(tszGuid[0]) );
                    }
                    if (lRc == ERROR_SUCCESS)
                    {
                    } else
                    {
                        hres = E_FAIL;
                        goto closedone;
                    }
                }

            /* ISSUE-2001/03/29-timgill Needs more data checking
               Should make sure string is terminated properly */
                if (fl & DITC_DISPLAYNAME)
                {
                    hres = JoyReg_SetValue(hk,
                                           REGSTR_VAL_JOYOEMNAME, REG_SZ,
                                           pjti->wszDisplayName,
                                           cbX(pjti->wszDisplayName));
                    if (FAILED(hres))
                    {
                        goto closedone;
                    }
                }

#ifndef WINNT
            /* ISSUE-2001/03/29-timgill Needs more data checking
               Should make sure string is terminated properly */
                if (fl & DITC_CALLOUT)
                {
                    hres = JoyReg_SetValue(hk,
                                           REGSTR_VAL_JOYOEMCALLOUT, REG_SZ,
                                           pjti->wszCallout,
                                           cbX(pjti->wszCallout));
                    if (FAILED(hres))
                    {
                        hres = S_FALSE;
                        //continue to go
                    }
                }
#endif

                if ( fl & DITC_HARDWAREID )
                {
                    hres = JoyReg_SetValue(hk,
                                           REGSTR_VAL_JOYOEMHARDWAREID, REG_SZ,
                                           pjti->wszHardwareId,
                                           cbX(pjti->wszHardwareId) );
                    if ( FAILED(hres) )
                    {
                        hres = S_FALSE;
                        goto closedone;
                    }
                }

                if ( fl & DITC_FLAGS1 )
                {
                    AssertF( (pjti->dwFlags1 & ~JOYTYPE_FLAGS1_SETVALID) == 0x0 );
                    hres = JoyReg_SetValue(hk,
                                           REGSTR_VAL_FLAGS1, REG_BINARY, 
                                           (PV)&pjti->dwFlags1, 
                                           cbX(pjti->dwFlags1) );
                    if ( FAILED(hres) )
                    {
                        hres = S_FALSE;
                        goto closedone;
                    }
                }

                hres = S_OK;

                closedone:;
                RegCloseKey(hk);

            } else
            {
                hres = E_FAIL;              /* Registry problem */
            }
        }
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_OpenConfigKey |
 *
 *          Open the registry key that accesses joystick configuration data.
 *
 *          Warning!  Do not cache this regkey.
 *
 *          If the user deletes the key and then re-creates it,
 *          the opened key will go stale and will become useless.
 *          You have to close the key and reopen it.
 *          To avoid worrying about that case, merely open it every time.
 *
 *  @parm   UINT | idJoy |
 *
 *          Joystick number.
 *
 *  @parm   DWORD | sam |
 *
 *          Access level desired.
 *
 *  @parm   IN DWORD  | dwOptions |
 *          Option flags to RegCreateEx
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives created registry key.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          hresLe(ERROR_FILE_NOT_FOUND): The key does not exist.
 *
 *****************************************************************************/

STDMETHODIMP
JoyReg_OpenConfigKey(UINT idJoy, DWORD sam, DWORD dwOptions, PHKEY phk)
{
    HRESULT hres;
    EnterProc(JoyReg_OpenConfigKey, (_ "uxx", idJoy, sam, dwOptions));

#ifdef WINNT
    hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE, 
                           REGSTR_PATH_JOYCONFIG REGSTR_SZREGKEY REGSTR_KEY_JOYCURR, 
                           sam, REG_OPTION_VOLATILE, phk);
#else
    
    {
        MMRESULT mmrc = MMSYSERR_ERROR;
        JOYCAPS caps;
        /*
         *  If we can't get the dev caps for the specified joystick,
         *  then use the magic joystick id "-1" to get non-specific
         *  caps.
         */
        mmrc = joyGetDevCaps(idJoy, &caps, cbX(caps));
        if ( mmrc != JOYERR_NOERROR )
        {
            mmrc = joyGetDevCaps((DWORD)-1, &caps, cbX(caps));
        }

        if (mmrc == JOYERR_NOERROR)
        {

            TCHAR tsz[cA(REGSTR_PATH_JOYCONFIG) +
                      1 +                           /* backslash */
                      cA(caps.szRegKey) +
                      1 +                           /* backslash */
                      cA(REGSTR_KEY_JOYCURR) + 1];        

            /* tsz = MediaResources\Joystick\<drv>\CurrentJoystickSettings */
            wsprintf(tsz, TEXT("%s\\%s\\") REGSTR_KEY_JOYCURR,
                     REGSTR_PATH_JOYCONFIG, caps.szRegKey);


            hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE, tsz, sam, REG_OPTION_VOLATILE, phk);

        } else
        {
            hres = E_FAIL;
        }
    }
#endif

    ExitBenignOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_OpenSaveKey |
 *
 *          Open the registry key that accesses joystick saved configurations
 *
 *          Warning!  Do not cache this regkey.
 *
 *          If the user deletes the key and then re-creates it,
 *          the opened key will go stale and will become useless.
 *          You have to close the key and reopen it.
 *          To avoid worrying about that case, merely open it every time.
 *
 *  @parm   DWORD | dwType |
 *
 *          Joystick type.
 *
 *          This is either one of the standard ones in the range
 *
 *  @parm   IN LPCDIJOYCONFIG | pcfg |
 *
 *          If the dwType represents an OEM type, this should point to a
 *          configuration data structure containing a valid wszType.
 *
 *  @parm   DWORD | sam |
 *
 *          Access level desired.
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives created registry key.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          hresLe(ERROR_FILE_NOT_FOUND): The key does not exist.
 *
 *****************************************************************************/

STDMETHODIMP
JoyReg_OpenSaveKey(DWORD dwType, LPCDIJOYCONFIG pcfg, DWORD sam, PHKEY phk)
{
    HRESULT hres;
    JOYCAPS caps;
    DWORD   dwOptions = 0;
    EnterProc(JoyReg_OpenSaveKey, (_ "upx", dwType, pcfg, sam));


#ifdef WINNT
    lstrcpy(caps.szRegKey, REGSTR_SZREGKEY );
#else

    /*
     *  use the magic joystick id "-1" to get non-specific caps.
     */

    if ( joyGetDevCaps((DWORD)-1, &caps, cbX(caps)) != JOYERR_NOERROR )
    {
        hres = E_FAIL;
    } else
#endif
    {
        TCHAR tsz[cA(REGSTR_PATH_JOYCONFIG) +
                  1 +                           /* backslash */
                  cA(caps.szRegKey) +
                  1 +                           /* backslash */
                  cA(REGSTR_KEY_JOYSETTINGS) +
                  1 +                           /* backslash */
                  max( cA(REGSTR_KEY_JOYPREDEFN), cA(pcfg->wszType) ) + 1 ];

        /* tsz = MediaResources\Joystick\<drv>\JoystickSettings\<Type> */
        if ( dwType >= JOY_HW_PREDEFMAX )
        {
            wsprintf(tsz, TEXT("%s\\%s\\%s\\%ls"),
                     REGSTR_PATH_JOYCONFIG, caps.szRegKey, REGSTR_KEY_JOYSETTINGS, pcfg->wszType);
        } else
        {
            /*
             *  We will probably never have more than the current 11 predefined
             *  joysticks.  Assume no more than 99 so %d is as many characters.
             */
            wsprintf(tsz, TEXT("%s\\%s\\%s\\" REGSTR_KEY_JOYPREDEFN),
                     REGSTR_PATH_JOYCONFIG, caps.szRegKey, REGSTR_KEY_JOYSETTINGS, dwType );
        }

        if ( pcfg->hwc.dwUsageSettings & JOY_US_VOLATILE )
            dwOptions = REG_OPTION_VOLATILE;
        else
            dwOptions = REG_OPTION_NON_VOLATILE;

        hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE, tsz, sam, dwOptions, phk);

    } 

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_GetSetConfigValue |
 *
 *          Retrieve or update configuration information about a joystick,
 *          as stored in the registry instance key.
 *
 *  @parm   HKEY | hk |
 *
 *          Registry key containing fun values.
 *
 *  @parm   LPCTSTR | ptszNValue |
 *
 *          Registry value name, with "%d" where a joystick number
 *          should be.
 *
 *  @parm   UINT | idJoy |
 *
 *          Zero-based joystick number.
 *
 *  @parm   DWORD | reg |
 *
 *          Registry data type expected.
 *
 *  @parm   LPVOID | pvBuf |
 *
 *          Buffer to receive information from registry (if getting)
 *          or containing value to set.
 *
 *  @parm   DWORD | cb |
 *
 *          Size of buffer, in bytes.
 *
 *  @parm   BOOL | fSet |
 *
 *          Nonzer if the value should be set; otherwise, it will be
 *          retrieved.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c E_FAIL>: Error reading/writing value to/from registry.
 *
 *****************************************************************************/

STDMETHODIMP
JoyReg_GetSetConfigValue(HKEY hk, LPCTSTR ptszNValue, UINT idJoy,
                         DWORD reg, PV pvBuf, DWORD cb, BOOL fSet)
{
    HRESULT hres;
    int ctch;

    /* Extra +12 because a UINT can be as big as 4 billion */
    TCHAR tsz[max(
                 max(
                    max(cA(REGSTR_VAL_JOYNCONFIG),
                        cA(REGSTR_VAL_JOYNOEMNAME)),
                    cA(REGSTR_VAL_JOYNOEMCALLOUT)),
                 cA(REGSTR_VAL_JOYNFFCONFIG)) + 12 + 1];

    ctch = wsprintf(tsz, ptszNValue, idJoy + 1);
    AssertF(ctch < cA(tsz));

    if (fSet)
    {
        hres = JoyReg_SetValue(hk, tsz, reg, pvBuf, cb);
    } else
    {
        hres = JoyReg_GetValue(hk, tsz, reg, pvBuf, cb);
    }

    return hres;

}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresIdJoypInstanceGUID |
 *
 *          Given a joystick ID obtain the corresponding GUID.
 *          This routine differs in implementation on WINNT and WIN9x
 *          On WINNT there are no predefined GUID for Joystick IDs.
 *
 *  @parm   IN UINT | idJoy |
 *
 *          Joystick identification number.
 *
 *  @parm   OUT LPGUID | lpguid |
 *
 *          Receives the joystick GUID. If no mapping exists,
 *          GUID_NULL is passed back
 *
 *  On Windows NT all joysticks are HID devices. The corresponding function
 *  for WINNT is defined in diWinnt.c
 *
 *****************************************************************************/

HRESULT EXTERNAL hResIdJoypInstanceGUID_95
(
UINT    idJoy,
LPGUID  lpguid
)
{
    HRESULT hRes;

    hRes = S_OK;
    if ( idJoy < cA(rgGUID_Joystick) )
    {
        *lpguid = rgGUID_Joystick[idJoy];
    } else
    {
        hRes = DIERR_NOTFOUND;
        ZeroX(*lpguid);
    }
    return hRes;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_GetConfigInternal |
 *
 *          Obtain information about a joystick's configuration.
 *
 *  @parm   UINT | uiJoy |
 *
 *          Joystick identification number.
 *
 *  @parm   OUT LPDIJOYCONFIG | pcfg |
 *
 *          Receives information about the joystick configuration.
 *          The caller is assumed to have validated the
 *          <e DIJOYCONFIG.dwSize> field.
 *
 *  @parm   DWORD | fl |
 *
 *          Zero or more <c DIJC_*> flags
 *          which specify which parts of the structure pointed
 *          to by <p pjc> are to be filled in.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOMOREITEMS>: No more joysticks.
 *
 *****************************************************************************/

STDMETHODIMP
JoyReg_GetConfigInternal(UINT idJoy, LPDIJOYCONFIG pcfg, DWORD fl)
{
    HRESULT hres = E_FAIL;

    EnterProc(JoyReg_GetConfigInternal, (_ "upx", idJoy, pcfg, fl));

    AssertF((fl & ~DIJC_GETVALID) == 0);

    /* We only support (0/16) joysticks */
    if ( idJoy < cJoyMax )
    {
        /* Force a rescan of all HID device list
         * Some device may have been attached
         * since we last looked
         */
        DIHid_BuildHidList(FALSE);
        
        if (fl & DIJC_GUIDINSTANCE)
        {
            hres = hResIdJoypInstanceGUID_WDM(idJoy, &pcfg->guidInstance);

         #ifndef WINNT
            if ( FAILED(hres) )
            {
                hres = hResIdJoypInstanceGUID_95(idJoy, &pcfg->guidInstance);
            }
         #endif

            if ( FAILED(hres) )
            {
                goto done;
            }
        }

        if ( fl & DIJC_INREGISTRY )
        {
            HKEY hk;
            /* Does the registry entry exist ? */
            hres = JoyReg_OpenConfigKey(idJoy, KEY_QUERY_VALUE, REG_OPTION_NON_VOLATILE , &hk);
            if (SUCCEEDED(hres))
            {
                if (fl & DIJC_REGHWCONFIGTYPE)
                {
                    hres = JoyReg_GetConfigValue(
                                                hk, REGSTR_VAL_JOYNCONFIG,
                                                idJoy, REG_BINARY,
                                                &pcfg->hwc, cbX(pcfg->hwc));
                    if (FAILED(hres))
                    {
                        goto closedone;
                    }

                    pcfg->wszType[0] = TEXT('\0');
                    if ( (pcfg->hwc.dwUsageSettings & JOY_US_ISOEM)
#ifndef WINNT
                         ||( (pcfg->hwc.dwType >= JOY_HW_PREDEFMIN) 
                             &&(pcfg->hwc.dwType <  JOY_HW_PREDEFMAX) ) 
#endif
                       )
                    {
                        hres = JoyReg_GetConfigValue(
                                                    hk, REGSTR_VAL_JOYNOEMNAME, idJoy, REG_SZ,
                                                    pcfg->wszType, cbX(pcfg->wszType));
                        if (FAILED(hres))
                        {
                            goto closedone;
                        }
                    }
                }

#ifndef WINNT
                if (fl & DIJC_CALLOUT)
                {
                    pcfg->wszCallout[0] = TEXT('\0');
                    hres = JoyReg_GetConfigValue(
                                                hk, REGSTR_VAL_JOYNOEMCALLOUT, idJoy, REG_SZ,
                                                pcfg->wszCallout, cbX(pcfg->wszCallout));
                    if (FAILED(hres))
                    {
                        ZeroX(pcfg->wszCallout);
                        hres = S_FALSE;
                        /* Note that we fall through and let hres = S_OK */
                    }
                }
#endif

                if (fl & DIJC_GAIN)
                {
                    /*
                     *  If there is no FF configuration, then
                     *  default to DI_FFNOMINALMAX gain.
                     */
                    hres = JoyReg_GetConfigValue(hk,
                                                 REGSTR_VAL_JOYNFFCONFIG,
                                                 idJoy, REG_BINARY,
                                                 &pcfg->dwGain, cbX(pcfg->dwGain));

                    if (SUCCEEDED(hres) && ISVALIDGAIN(pcfg->dwGain))
                    {
                        /* Leave it alone; it's good */
                    } else
                    {
                        pcfg->dwGain = DI_FFNOMINALMAX;
                        hres = S_FALSE;
                    }
                }

                if ( fl & DIJC_WDMGAMEPORT )
                {
                    PBUSDEVICEINFO pbdi;
                    /*
                     * If there is no Gameport Associated with this device
                     * then it must be a USB device
                     */

                    DllEnterCrit();
                    if ( pbdi = pbdiFromJoyId(idJoy) )
                    {
                        pcfg->guidGameport = pbdi->guid;
                        //lstrcpyW(pcfg->wszGameport, pbdi->wszDisplayName);
                    } else
                    {
                        ZeroX(pcfg->guidGameport);
                        hres = S_FALSE;
                    }

                    DllLeaveCrit();
                }

            } 
            
        closedone:
            if( FAILED(hres) ) {
                DIJOYTYPEINFO       dijti;

                AssertF( pcfg->dwSize == sizeof(DIJOYCONFIG_DX5) 
                      || pcfg->dwSize == sizeof(DIJOYCONFIG_DX6) );
                hres = DIWdm_JoyHidMapping(idJoy, NULL, pcfg, &dijti );
                if( FAILED(hres) ) {
                    hres = E_FAIL;
                }
            }

            RegCloseKey(hk);
        }
    } else
    {
        hres = DIERR_NOMOREITEMS;
    }

    done:
    ExitBenignOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_GetConfig |
 *
 *          Obtain information about a joystick's configuration,
 *          taking the *naive* MSGAME.VXD driver into account.
 *
 *  @parm   UINT | uiJoy |
 *
 *          Joystick identification number.
 *
 *  @parm   OUT LPDIJOYCONFIG | pcfg |
 *
 *          Receives information about the joystick configuration.
 *          The caller is assumed to have validated the
 *          <e DIJOYCONFIG.dwSize> field.
 *
 *  @parm   DWORD | fl |
 *
 *          Zero or more <c DIJC_*> flags
 *          which specify which parts of the structure pointed
 *          to by <p pjc> are to be filled in.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOMOREITEMS>: No more joysticks.
 *
 *****************************************************************************/

STDMETHODIMP
JoyReg_GetConfig(UINT idJoy, LPDIJOYCONFIG pcfg, DWORD fl)
{
    HRESULT hres;
    GUID    guid;

    EnterProc(JoyReg_GetConfig, (_ "upx", idJoy, pcfg, fl));

    AssertF((fl & ~DIJC_GETVALID) == 0);

    /* 
     * First determine if the joystick exits 
     * On NT, we use WDM driver.
     * On Win9x, if WDM fails, use static guids.
     */
    hres = hResIdJoypInstanceGUID_WDM(idJoy, &guid);

#ifndef WINNT
    if ( FAILED(hres) )
    {
        hres = hResIdJoypInstanceGUID_95(idJoy, &guid);
    }
#endif

    if ( SUCCEEDED( hres) )
    {

        hres = JoyReg_GetConfigInternal(idJoy, pcfg, fl);

      #ifndef WINNT
        /***************************************************
         *
         *  Beginning of hack for *naive* Sidewinder Gamepad.
         *
         *  The gamepad needs to be polled sixteen times 
         *  before it realizes what is going on.
         *
         ***************************************************/

        if (SUCCEEDED(hres) && (fl & DIJC_CALLOUT))
        {

            static WCHAR s_wszMSGAME[] = L"MSGAME.VXD";

            if (memcmp(pcfg->wszCallout, s_wszMSGAME, cbX(s_wszMSGAME)) == 0)
            {
                SquirtSqflPtszV(sqfl,
                                TEXT("Making bonus polls for Sidewinder"));

                /*
                 *  Sigh.  It's a Sidewinder.  Make sixteen
                 *  bonus polls to shake the stick into submission.
                 *
                 *  There's no point in doing this over and over if we're 
                 *  in some kind of loop so make sure a "reasonable" 
                 *  length of time has passed since last time we tried.
                 *  3 seconds is a little less than the current CPL 
                 *  background refresh rate.
                 */

                if ( !g_dwLastBonusPoll || ( GetTickCount() - g_dwLastBonusPoll > 3000 ) )
                {
                    JOYINFOEX ji;
                    int i;
                    DWORD dwWait;

                    ji.dwSize = cbX(ji);
                    ji.dwFlags = JOY_RETURNALL;
                        
                    for (i = 0; i < 16; i++)
                    {
                        MMRESULT mmrc = joyGetPosEx(idJoy, &ji);
                        SquirtSqflPtszV(sqfl,
                                        TEXT("joyGetPosEx(%d) = %d"),
                                        idJoy, mmrc);
                        /*
                         *  Sleep 10ms between each poll because that
                         *  seems to help a bit.
                         */
                        Sleep(10);
                    }

                    /*
                     *  Bonus hack!  Now sleep for some time.  
                     *  The amount of time we need to sleep is CPU-speed 
                     *  dependent, so we'll grab the sleep time from the 
                     *  registry to allow us to tweak it later.
                     *
                     *  What a shame.
                     */
                    dwWait = RegQueryDIDword(NULL, REGSTR_VAL_GAMEPADDELAY, 100);
                    if (dwWait > 10 * 1000)
                    {
                        dwWait = 10 * 1000;
                    }

                    Sleep(dwWait);

                    /*
                     *  And then check again.
                     */
                    hres = JoyReg_GetConfigInternal(idJoy, pcfg, fl);

                    g_dwLastBonusPoll = GetTickCount();
                }
            }

        }
        /***************************************************
         *
         *  End of hack for *naive* Sidewinder Gamepad.
         *
         ***************************************************/

      #endif
      
    }

    return hres;
}


#ifndef WINNT
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_JoyIdToDeviceInterface_95 |
 *
 *          Given a joystick ID number, obtain the device interface
 *          corresponding to it.
 *
 *  @parm   UINT | idJoy |
 *
 *          Joystick ID number, zero-based.
 *
 *  @parm   PVXDINITPARMS | pvip |
 *
 *          Receives init parameters from the driver.
 *
 *  @parm   LPTSTR | ptszBuf |
 *
 *          A buffer of size <c MAX_PATH> in which the device interface
 *          path is built.  Note that we can get away with a buffer of
 *          this size, since the code path exists only on Windows 95,
 *          and Windows 95 does not support paths longer than <c MAX_PATH>.
 *          (I.e., there ain't no \\?\ support in Win95.)
 *
 *  @returns
 *
 *          A pointer to the part of the <p ptszBuf> buffer that
 *          contains the actual device interface path.
 *
 *****************************************************************************/

LPSTR EXTERNAL
JoyReg_JoyIdToDeviceInterface_95(UINT idJoy, PVXDINITPARMS pvip, LPSTR ptszBuf)
{
    UINT cwch;
    HRESULT hres;
    LPSTR ptszRc;

    hres = Hel_Joy_GetInitParms(idJoy, pvip);
    if (SUCCEEDED(hres))
    {

        /*
         *  The length counter includes the terminating null.
         */
        cwch = LOWORD(pvip->dwFilenameLengths);

        /*
         *  The name that comes from HID is "\DosDevices\blah"
         *  but we want to use "\\.\blah".  So check if it indeed
         *  of the form "\DosDevices\blah" and if so, convert it.
         *  If not, then give up.
         *
         *  For the string to possibly be a "\DosDevices\", it
         *  needs to be of length 12 or longer.
         */

        if (cwch >= 12 && cwch < MAX_PATH)
        {

            /*
             *  WideCharToMultiByte does parameter validation so we
             *  don't have to.
             */
            WideCharToMultiByte(CP_ACP, 0, pvip->pFilenameBuffer, cwch,
                                ptszBuf, MAX_PATH, 0, 0);

            /*
             *  The 11th (zero-based) character must be a backslash.
             *  And the value of cwch had better be right.
             */
            if (ptszBuf[cwch-1] == ('\0') && ptszBuf[11] == ('\\'))
            {

                /*
                 *  Wipe out the backslash and make sure the lead-in
                 *  is "\DosDevices".
                 */
                ptszBuf[11] = ('\0');
                if (lstrcmpiA(ptszBuf, ("\\DosDevices")) == 0)
                {
                    /*
                     *  Create a "\\.\" at the start of the string.
                     *  Note!  This code never runs on Alphas so we
                     *  can do evil unaligned data accesses.
                     *
                     *  (Actually, 8 is a multiple of 4, so everything
                     *  is aligned after all.)
                     */
                    *(LPDWORD)&ptszBuf[8] = 0x5C2E5C5C;

                    ptszRc = &ptszBuf[8];
                } else
                {
                    ptszRc = NULL;
                }
            } else
            {
                ptszRc = NULL;
            }
        } else
        {
            ptszRc = NULL;
        }
    } else
    {
        ptszRc = NULL;
    }

    return ptszRc;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | JoyReg_SetCalibration |
 *
 *          Store information about a joystick's configuration,
 *          shadowing the information back into the HID side of
 *          things as well.
 *
 *  @parm   UINT | uiJoy |
 *
 *          Joystick identification number.
 *
 *  @parm   LPJOYREGHWCONFIG | phwc |
 *
 *          Contains information about the joystick capabilities.
 *          This value supercedes the value in the <p pcfg>.
 *
 *  @parm   LPCDIJOYCONFIG | pcfg |
 *
 *          Contains information about the joystick configuration.
 *          The caller is assumed to have validated all fields.
 *
 *****************************************************************************/

STDMETHODIMP
TFORM(CDIObj_FindDevice)(PV pdiT, REFGUID rguid,
                         LPCTSTR ptszName, LPGUID pguidOut);

void EXTERNAL
JoyReg_SetCalibration(UINT idJoy, LPJOYREGHWCONFIG phwc)
{
    HRESULT hres;
    VXDINITPARMS vip;
    GUID guid;
    CHAR tsz[MAX_PATH];
    LPSTR pszPath;
    TCHAR ptszPath[MAX_PATH];
    EnterProc(JoyReg_SetCalibration, (_ "up", idJoy, phwc));

    pszPath = JoyReg_JoyIdToDeviceInterface_95(idJoy, &vip, tsz);

    if ( pszPath )
#ifdef UNICODE
        AToU( ptszPath, MAX_PATH, pszPath );
#else
        lstrcpy( (LPSTR)ptszPath, pszPath );
#endif

    if (pszPath &&
        SUCCEEDED(CDIObj_FindDeviceInternal(ptszPath, &guid)))
    {
        IDirectInputDeviceCallback *pdcb;
#ifdef DEBUG
        CREATEDCB CreateDcb;
#endif

#ifdef DEBUG

        /*
         *  If the associated HID device got unplugged, then
         *  the instance GUID is no more.  So don't get upset
         *  if we can't find it.  But if we do find it, then
         *  it had better be a HID device.
         *
         *  CHid_New will properly fail if the associated
         *  device is not around.
         */
        hres = hresFindInstanceGUID(&guid, &CreateDcb, 1);
        AssertF(fLimpFF(SUCCEEDED(hres), CreateDcb == CHid_New));
#endif

        if (SUCCEEDED(hres = CHid_New(0, &guid,
                                      &IID_IDirectInputDeviceCallback,
                                      (PPV)&pdcb)))
        {
            LPDIDATAFORMAT pdf;

            /*
             *  The VXDINITPARAMS structure tells us where JOYHID
             *  decided to place each of the axes.  Follow that
             *  table to put them into their corresponding location
             *  in the HID side.
             */
            hres = pdcb->lpVtbl->GetDataFormat(pdcb, &pdf);
            if (SUCCEEDED(hres))
            {
                UINT uiAxis;
                DIPROPINFO propi;

                propi.pguid = DIPROP_SPECIFICCALIBRATION;

                /*
                 *  For each axis...
                 */
                for (uiAxis = 0; uiAxis < 6; uiAxis++)
                {
                    DWORD dwUsage = vip.Usages[uiAxis];
                    /*
                     *  If the axis is mapped to a usage...
                     */
                    if (dwUsage)
                    {
                        /*
                         *  Convert the usage into an object index.
                         */
                        hres = pdcb->lpVtbl->MapUsage(pdcb, dwUsage,
                                                      &propi.iobj);
                        if (SUCCEEDED(hres))
                        {
                            DIPROPCAL cal;

                            /*
                             *  Convert the old-style calibration into
                             *  a new-style calibration.
                             */
#define CopyCalibration(f, ui) \
                cal.l##f = (&phwc->hwv.jrvHardware.jp##f.dwX)[ui]

                            CopyCalibration(Min, uiAxis);
                            CopyCalibration(Max, uiAxis);
                            CopyCalibration(Center, uiAxis);

#undef CopyCalibration


                            /*
                             *  Set the calibration property on the object.
                             */
                            propi.dwDevType =
                            pdf->rgodf[propi.iobj].dwType;
                            hres = pdcb->lpVtbl->SetProperty(pdcb, &propi,
                                                             &cal.diph);
                        }
                    }
                }
            }

            Invoke_Release(&pdcb);
        }
    }

    ExitProc();
}
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_SetHWConfig |
 *
 *          Store information about a joystick's <t JOYREGHWCONFIG>.
 *
 *  @parm   UINT | uiJoy |
 *
 *          Joystick identification number.
 *
 *  @parm   LPJOYREGHWCONFIG | phwc |
 *
 *          Contains information about the joystick capabilities.
 *          This value supercedes the value in the <p pcfg>.
 *
 *  @parm   LPCDIJOYCONFIG | pcfg |
 *
 *          Contains information about the joystick configuration.
 *          The caller is assumed to have validated all fields.
 *
 *  @parm   HKEY | hk |
 *
 *          The type key we are munging.
 *
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/

HRESULT INTERNAL
JoyReg_SetHWConfig(UINT idJoy, LPJOYREGHWCONFIG phwc, LPCDIJOYCONFIG pcfg,
                   HKEY hk)
{
    HRESULT hres;
    HKEY hkSave;
    DWORD dwSam;

    /*
     *  The caller has set phwc->dwType, so use it to determine
     *  where the data comes from or goes to.
     */
    if ( phwc->dwType == JOY_HW_NONE )
    {
        /*
         *  Nothing to do
         */
    } else if ( phwc->dwType == JOY_HW_CUSTOM )
    {
        /*
        /*  ISSUE-2001/03/29-timgill Custom HWConfig not handled correctly
         *  We don't know the type name and the only time we can look
         *  it up is when were modifying an existing config so although we
         *  could store the config, we'd never be able to get it back.
         *  Should return no better than S_FALSE.  This will have to wait.
         */
    } else
    {
        /*
         *  Try to access saved values
         */

        // ISSUE-2001/03/29-timgill Dangerous type cast
        PDWORD pdw = (PDWORD)&phwc->hwv;

        dwSam = KEY_QUERY_VALUE;

        while ( pdw < &phwc->dwType )
        {
            if ( *pdw )
            {
                /*
                 *  Real config data so write it
                 */
                dwSam = KEY_SET_VALUE;
                break;
            }
            pdw++;
        }

        /*
         *  If the device is autoloaded and yet the user is manually assigning it
         *  to an ID, set the volatile flag.  The flag will be set to the driver
         *  defined value if a driver ever gets hotplug assigned to this ID but if
         *  not, this makes sure that the settings are removed on next reboot.
         */
        if (phwc->hws.dwFlags & JOY_HWS_AUTOLOAD)
        {
            phwc->dwUsageSettings |= JOY_US_VOLATILE;
        }

        hres = JoyReg_OpenSaveKey( phwc->dwType, pcfg, dwSam, &hkSave );

        if ( SUCCEEDED(hres) )
        {
            if ( dwSam == KEY_SET_VALUE )
            {
                hres = JoyReg_SetConfigValue(hkSave, REGSTR_VAL_JOYNCONFIG,
                                             idJoy, REG_BINARY,
                                             phwc, cbX(*phwc));
                if ( FAILED(hres) )
                {
                    // Report the error but live with it
                    RPF("JoyReg_SetConfig: failed to set saved config %08x", hres );
                }
            } else
            {
                JOYREGHWCONFIG hwc;

                /*
                 *  Read it into an extra buffer because we only want it
                 *  if it's complete.
                 */
                hres = JoyReg_GetConfigValue(hkSave, REGSTR_VAL_JOYNCONFIG,
                                             idJoy, REG_BINARY,
                                             &hwc, cbX(hwc));
                if ( hres == S_OK )
                {
                    // Assert hws is first and no gap before dwUsageSettings
                    CAssertF( FIELD_OFFSET( JOYREGHWCONFIG, hws ) == 0 );
                    CAssertF( FIELD_OFFSET( JOYREGHWCONFIG, dwUsageSettings ) == sizeof( hwc.hws ) );

                    // Copy the whole structure except the hws
                    memcpy( &phwc->dwUsageSettings, &hwc.dwUsageSettings, 
                            sizeof( hwc ) - sizeof( hwc.hws ) );
                }
            }

            RegCloseKey( hkSave );
        }
        /*
         *  If we failed to read, there's probably nothing there and the
         *  structure is set up already for a blank config.
         *  If we failed to write there probably not much we can do
         */
    }


    hres = JoyReg_SetConfigValue(hk, REGSTR_VAL_JOYNCONFIG,
                                 idJoy, REG_BINARY,
                                 phwc, cbX(*phwc));
    if (FAILED(hres))
    {
        goto done;
    }

    if (phwc->dwUsageSettings & JOY_US_ISOEM)
    {

        hres = JoyReg_SetConfigValue(
                                    hk, REGSTR_VAL_JOYNOEMNAME, idJoy, REG_SZ,
                                    pcfg->wszType, cbX(pcfg->wszType));

    } else
    {
        hres = JoyReg_SetConfigValue(
                                    hk, REGSTR_VAL_JOYNOEMNAME, idJoy, REG_SZ,
                                    0, 0);
    }

    done:;

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_SetConfig |
 *
 *          Store information about a joystick's configuration.
 *
 *  @parm   UINT | uiJoy |
 *
 *          Joystick identification number.
 *
 *  @parm   JOYREGHWCONFIG | phwc |
 *
 *          Contains information about the joystick capabilities.
 *          This value supercedes the value in the <p pcfg>.
 *          It may be modified if we needed to load the config
 *          info from the saved settings.
 *
 *  @parm   LPCDIJOYCONFIG | pcfg |
 *
 *          Contains information about the joystick configuration.
 *          The caller is assumed to have validated all fields.
 *
 *  @parm   DWORD | fl |
 *
 *          Zero or more <c DIJC_*> flags
 *          which specify which parts of the structures pointed
 *          to by <p phwc> and <p pjc> are to be written out.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/

JOYREGHWVALUES      null_hwv = { 0};

STDMETHODIMP
JoyReg_SetConfig(UINT idJoy, LPJOYREGHWCONFIG phwc,
                 LPCDIJOYCONFIG pcfg, DWORD fl)
{
    HRESULT hres;
    EnterProc(JoyReg_SetConfig, (_ "uppx", idJoy, phwc, pcfg, fl));

    AssertF((fl & ~DIJC_INTERNALSETVALID) == 0);

    if (idJoy < cJoyMax )
    {

        if (fl & DIJC_INREGISTRY)
        {
            HKEY hk;
            DWORD dwOptions = 0;

            hres = JoyReg_OpenConfigKey(idJoy, KEY_SET_VALUE, dwOptions, &hk);

            if (SUCCEEDED(hres))
            {

                if (fl & DIJC_REGHWCONFIGTYPE)
                {
                    hres = JoyReg_SetHWConfig(idJoy, phwc, pcfg, hk);

                    if (FAILED(hres))
                    {
                        goto closedone;
                    }

#ifndef WINNT
                    if (fl & DIJC_UPDATEALIAS)
                    {
                        JoyReg_SetCalibration(idJoy, phwc);
                    }
#endif

                }

#ifndef WINNT
                if (fl & DIJC_CALLOUT)
                {
                    hres = JoyReg_SetConfigValue(
                                                hk, REGSTR_VAL_JOYNOEMCALLOUT, idJoy, REG_SZ,
                                                pcfg->wszCallout, cbX(pcfg->wszCallout));
                    if (FAILED(hres))
                    {
                        hres = S_FALSE;
                        //continue to go
                    }
                }
#endif

                if (fl & DIJC_GAIN)
                {
                    if (ISVALIDGAIN(pcfg->dwGain))
                    {

                        /*
                         *  If restoring to nominal, then the key
                         *  can be deleted; the default value will
                         *  be assumed subsequently.
                         */
                        if (pcfg->dwGain == DI_FFNOMINALMAX)
                        {
                            hres = JoyReg_SetConfigValue(hk,
                                                         TEXT("Joystick%dFFConfiguration"),
                                                         idJoy, REG_SZ, 0, 0);
                        } else
                        {
                            hres = JoyReg_SetConfigValue(hk,
                                                         TEXT("Joystick%dFFConfiguration"),
                                                         idJoy, REG_BINARY,
                                                         &pcfg->dwGain, cbX(pcfg->dwGain));
                        }

                        if (FAILED(hres))
                        {
                            hres = S_FALSE;
                            goto closedone;
                        }
                    } else
                    {
                        RPF("ERROR: SetConfig: Invalid dwGain");
                        hres = E_INVALIDARG;
                        goto closedone;
                    }
                }

                hres = S_OK;

                closedone:;
                RegCloseKey(hk);
            }
        } else
        {
            hres = S_OK;
        }

    } else
    {
        hres = E_FAIL;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   int | ibJoyPosAxis |
 *
 *          Returns the offset of the <p iAxis>'th joystick axis
 *          in the <t JOYPOS> structure.
 *
 *  @parm   int | iAxis |
 *
 *          The index of the requested axis.  X, Y, Z, R, U and V are
 *          respctively zero through five.
 *
 *  @returns
 *
 *          The offset relative to the structure.
 *
 *****************************************************************************/

#define ibJoyPosAxis(iAxis)                                         \
        (FIELD_OFFSET(JOYPOS, dwX) + cbX(DWORD) * (iAxis))          \

#define pJoyValue(jp, i)                                            \
        (LPDWORD)pvAddPvCb(&(jp), ibJoyPosAxis(i))                  \

/*
 *  The following doesn't do anything at runtime.  It is a compile-time
 *  check that everything is okay.
 */
void INLINE
JoyReg_CheckJoyPosAxis(void)
{
#define CheckAxis(x)    \
        CAssertF(ibJoyPosAxis(iJoyPosAxis##x) == FIELD_OFFSET(JOYPOS, dw##x))

    CheckAxis(X);
    CheckAxis(Y);
    CheckAxis(Z);
    CheckAxis(R);
    CheckAxis(U);
    CheckAxis(V);

#undef CheckAxis
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_IsValidUserValues |
 *
 *          Retermine whether the values are ostensibly valid.
 *
 *  @parm   IN LPCDIJOYUSERVALUES | pjuv |
 *
 *          Contains information about the user joystick configuration.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:
 *          Something looks bad.
 *
 *****************************************************************************/

STDMETHODIMP
JoyReg_IsValidUserValues(LPCDIJOYUSERVALUES pjuv)
{
    HRESULT hres;
    int iAxis;

    /*
     *  First set up the values to values that are out of range so
     *  that we will fall back to defaults.
     */
    for (iAxis = 0; iAxis < cJoyPosAxisMax; iAxis++)
    {
        if ((int)*pJoyValue(pjuv->ruv.jrvRanges.jpMax, iAxis) < 0)
        {
            RPF("JOYUSERVALUES: Negative jpMax not a good idea");
            goto bad;
        }
        if (*pJoyValue(pjuv->ruv.jrvRanges.jpMin, iAxis) >
            *pJoyValue(pjuv->ruv.jrvRanges.jpMax, iAxis))
        {
            RPF("JOYUSERVALUES: Min > Max not a good idea");
            goto bad;
        }

        if (!fInOrder(0, *pJoyValue(pjuv->ruv.jpDeadZone, iAxis), 100))
        {
            RPF("JOYUSERVALUES: DeadZone > 100 not a good idea");
            goto bad;
        }
    }

    hres = S_OK;

    return hres;

    bad:;
    hres = E_INVALIDARG;
    return hres;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_GetUserValues |
 *
 *          Obtain information about user settings for the joystick.
 *
 *
 *  @parm   IN OUT LPDIJOYUSERVALUES | pjuv |
 *
 *          Receives information about the user joystick configuration.
 *          The caller is assumed to have validated the
 *          <e DIJOYUSERVALUES.dwSize> field.
 *
 *  @parm   DWORD | fl |
 *
 *          Zero or more <c DIJU_*> flags specifying which parts
 *          of the <t DIJOYUSERVALUES> structure contain values
 *          which are to be retrieved.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *****************************************************************************/

STDMETHODIMP
JoyReg_GetUserValues(LPDIJOYUSERVALUES pjuv, DWORD fl)
{
    HRESULT hres;
    HKEY hk;
    LONG lRc;
    EnterProc(JoyReg_GetUserValues, (_ "px", pjuv, fl));

    hres = S_OK;                    /* If nothing happens, then success */

    if (fl & DIJU_USERVALUES)
    {

        /*
         *  Okay, now get the user settings.
         *
         *  If anything goes wrong, then just limp with the default values.
         */
        lRc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_JOYCONFIG,
                           0, KEY_QUERY_VALUE, &hk);
        if (lRc == ERROR_SUCCESS)
        {

            hres = JoyReg_GetValue(hk, REGSTR_VAL_JOYUSERVALUES,
                                   REG_BINARY, &pjuv->ruv, cbX(pjuv->ruv));
            if (SUCCEEDED(hres))
            {
                /*
                 *  Sanity-check the values.  If anything is screwy,
                 *  then fall back to the defaults.
                 */
                hres = JoyReg_IsValidUserValues(pjuv);

            }

            if (FAILED(hres))
            {
                /*
                 *  Oh well.  Just use the default values, then.
                 *
                 *  Stolen from ibmjoy\msjstick.c.
                 */
                ZeroMemory(&pjuv->ruv, cbX(pjuv->ruv));

#define DEFAULT_RANGE_MAX 65535
#define DEFAULT_TIMEOUT   5000
#define DEFAULT_DEADZONE  5

                pjuv->ruv.jrvRanges.jpMax.dwX = DEFAULT_RANGE_MAX;
                pjuv->ruv.jrvRanges.jpMax.dwY = DEFAULT_RANGE_MAX;
                pjuv->ruv.jrvRanges.jpMax.dwZ = DEFAULT_RANGE_MAX;
                pjuv->ruv.jrvRanges.jpMax.dwR = DEFAULT_RANGE_MAX;
                pjuv->ruv.jrvRanges.jpMax.dwU = DEFAULT_RANGE_MAX;
                pjuv->ruv.jrvRanges.jpMax.dwV = DEFAULT_RANGE_MAX;
                pjuv->ruv.jpDeadZone.dwX = DEFAULT_DEADZONE;
                pjuv->ruv.jpDeadZone.dwY = DEFAULT_DEADZONE;
                pjuv->ruv.dwTimeOut = DEFAULT_TIMEOUT;
            }

            RegCloseKey(hk);
        }
    }

    if (fl & DIJU_INDRIVERREGISTRY)
    {
        hres = JoyReg_OpenConfigKey((UINT)-1, KEY_QUERY_VALUE, FALSE, &hk);

        if (SUCCEEDED(hres))
        {

            if (fl & DIJU_GLOBALDRIVER)
            {
                /*
                 *  If it doesn't work, then return the default value
                 *  of "MSANALOG.VXD".  We can't blindly use
                 *  JoyReg_GetValue, because that treats a nonexistent
                 *  value as having a default of the null string.
                 */
                lRc = RegQueryValueEx(hk, REGSTR_VAL_JOYOEMCALLOUT,
                                      0, 0, 0, 0);
                if ((lRc == ERROR_SUCCESS || lRc == ERROR_MORE_DATA) &&
                    SUCCEEDED(
                             hres = JoyReg_GetValue(hk, REGSTR_VAL_JOYOEMCALLOUT,
                                                    REG_SZ, pjuv->wszGlobalDriver,
                                                    cbX(pjuv->wszGlobalDriver))))
                {
                    /* Yay, it worked */
                } else
                {
                    CopyMemory(pjuv->wszGlobalDriver,
                               c_wszDefPortDriver,
                               cbX(c_wszDefPortDriver));
                }

            }

            if (fl & DIJU_GAMEPORTEMULATOR)
            {

                /*
                 *  If it doesn't work, then just return a null string.
                 */
                hres = JoyReg_GetValue(hk, REGSTR_VAL_JOYGAMEPORTEMULATOR,
                                       REG_SZ, pjuv->wszGameportEmulator,
                                       cbX(pjuv->wszGameportEmulator));
                if (FAILED(hres))
                {
                    pjuv->wszGameportEmulator[0] = TEXT('\0');
                }

            }

            RegCloseKey(hk);
        }

    }

    /*
     *  Warning!  CJoy_InitRanges() assumes this never fails.
     */
    hres = S_OK;

    ExitOleProcR();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_SetUserValues |
 *
 *          Store information about user settings for the joystick.
 *
 *
 *  @parm   IN LPCDIJOYUSERVALUES | pjuv |
 *
 *          Contains information about the user joystick configuration.
 *          The caller is assumed to have validated the
 *          <e DIJOYUSERVALUES.dwSize> field.
 *
 *  @parm   DWORD | fl |
 *
 *          Zero or more <c DIJU_*> flags specifying which parts
 *          of the <t DIJOYUSERVALUES> structure contain values
 *          which are to be set.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *****************************************************************************/

STDMETHODIMP
JoyReg_SetUserValues(LPCDIJOYUSERVALUES pjuv, DWORD fl)
{
    HRESULT hres = E_FAIL;
    HKEY hk;
    EnterProc(JoyReg_SetUserValues, (_ "px", pjuv, fl));

    if (fl & DIJU_USERVALUES)
    {

        /*
         *  See if the values are sane.
         */
        if (fl & DIJU_USERVALUES)
        {
            hres = JoyReg_IsValidUserValues(pjuv);
            if (FAILED(hres))
            {
                goto done;
            }
        }

        /*
         *  Off to the registry we go.
         */

        hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE, 
                               REGSTR_PATH_JOYCONFIG, 
                               DI_KEY_ALL_ACCESS, 
                               REG_OPTION_NON_VOLATILE, 
                               &hk);

        if (SUCCEEDED(hres))
        {

            hres = JoyReg_SetValue(hk, REGSTR_VAL_JOYUSERVALUES,
                                   REG_BINARY, &pjuv->ruv,
                                   cbX(pjuv->ruv));
            RegCloseKey(hk);

            if (FAILED(hres))
            {
                goto done;
            }
        } else
        {
            goto done;
        }
    }

    if (fl & DIJU_INDRIVERREGISTRY)
    {

        hres = JoyReg_OpenConfigKey((UINT)-1, KEY_SET_VALUE, FALSE, &hk);

        if (SUCCEEDED(hres))
        {

            if (fl & DIJU_GLOBALDRIVER)
            {
                /*
                 *  This is a weird key.  The default value is
                 *  "MSANALOG.VXD", so if we get a null string, we
                 *  can't use JoyReg_SetValue, because that will
                 *  delete the key.
                 */
                if (pjuv->wszGlobalDriver[0])
                {
                    hres = JoyReg_SetValue(hk, REGSTR_VAL_JOYOEMCALLOUT,
                                           REG_SZ, pjuv->wszGlobalDriver,
                                           cbX(pjuv->wszGlobalDriver));
                } else
                {
                    LONG lRc;
                    lRc = RegSetValueEx(hk, REGSTR_VAL_JOYOEMCALLOUT, 0,
                                        REG_SZ, (PV)TEXT(""), cbCtch(1));
                    if (lRc == ERROR_SUCCESS)
                    {
                        hres = S_OK;
                    } else
                    {
                        RPF("Unable to write %s to registry",
                            REGSTR_VAL_JOYOEMCALLOUT);
                        hres = E_FAIL;  /* Else, something bad happened */
                    }
                }
                if (FAILED(hres))
                {
                    goto regdone;
                }
            }

            if (fl & DIJU_GAMEPORTEMULATOR)
            {

                hres = JoyReg_SetValue(hk, REGSTR_VAL_JOYGAMEPORTEMULATOR,
                                       REG_SZ, pjuv->wszGameportEmulator,
                                       cbX(pjuv->wszGameportEmulator));
                if (FAILED(hres))
                {
                    goto regdone;
                }
            }

            regdone:;
            RegCloseKey(hk);

        } else
        {
            goto done;
        }
    }

    done:;
    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_OpenFFKey |
 *
 *          Given a type key, move to its force feedback subkey.
 *
 *  @parm   HKEY | hkType |
 *
 *          The parent type key.
 *
 *  @parm   REGSAM | sam |
 *
 *          Access level desired.
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives created registry key.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTFOUND>: Couldn't open the key.
 *
 *****************************************************************************/

STDMETHODIMP
JoyReg_OpenFFKey(HKEY hkType, REGSAM sam, PHKEY phk)
{
    HRESULT hres;
    EnterProc(JoyReg_OpenFFKey, (_ "xx", hkType, sam));

    *phk = 0;

    if (hkType)
    {
        if (RegOpenKeyEx(hkType, TEXT("OEMForceFeedback"), 0, sam, phk) == 0)
        {
            hres = S_OK;
        } else
        {
            hres = E_FAIL;
        }
    } else
    {
        hres = DIERR_NOTFOUND;
    }

    ExitBenignOleProc();
    return hres;
}



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   TCHAR | CJoyCfg_CharFromType |
 *
 *          Convert a predefined type number to a character.
 *
 *  @func   UINT | CJoyCfg_TypeFromChar |
 *
 *          Convert a character back to a predefined type number.
 *
 *****************************************************************************/

#define JoyCfg_CharFromType(t)     ((TCHAR)(L'0' + t))
#define JoyCfg_TypeFromChar(tch)   ((tch) - L'0')

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   HRESULT | JoyReg_GetPredefTypeInfo |
 *
 *          Obtain information about a predefined joystick type.
 *
 *  @parm   LPCWSTR | pwszType |
 *
 *          Points to the name of the type.  It is known to begin
 *          with a "#".  The remainder has not yet been parsed.
 *
 *  @parm   IN OUT LPDIJOYTYPEINFO | pjti |
 *
 *          Receives information about the joystick type,
 *          already validated.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Zero or more <c DITC_*> flags
 *          which specify which parts of the structure pointed
 *          to by <p pjti> are to be filled in.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTFOUND>: The joystick type was not found.
 *
 *****************************************************************************/

HRESULT EXTERNAL
JoyReg_GetPredefTypeInfo(LPCWSTR pwszType, LPDIJOYTYPEINFO pjti, DWORD fl)
{
    HRESULT hres;
    UINT itype;
    EnterProcI(JoyReg_GetPredefTypeInfo, (_ "Wpx", pwszType, pjti, fl));

    AssertF(pwszType[0] == L'#');

    itype = JoyCfg_TypeFromChar(pwszType[1]);

    if (fInOrder(JOY_HW_PREDEFMIN, itype, JOY_HW_PREDEFMAX) &&
        pwszType[2] == L'\0')
    {
        /*
         *  No real point in checking the bits in fl, since
         *  setting it up is so easy.
         */
        pjti->hws = c_rghwsPredef[itype - JOY_HW_PREDEFMIN];
        LoadStringW(g_hinst, IDS_PREDEFJOYTYPE + itype,
                    pjti->wszDisplayName, cA(pjti->wszDisplayName));
        pjti->wszCallout[0] = L'\0';

        ZeroX(pjti->clsidConfig);

        pjti->dwFlags1 = 0x0;

        if ( fl & DITC_HARDWAREID )
        {
            lstrcpyW(pjti->wszHardwareId, c_rghwIdPredef[itype-JOY_HW_PREDEFMIN] );
        }

        pjti->dwFlags2 = 0x0;

        pjti->wszMapFile[0] = L'\0';

        hres = S_OK;
    } else
    {
        hres = DIERR_NOTFOUND;
    }

    ExitOleProc();
    return hres;
}


#if 0  //don't delete it now.
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyCfg_GetIDByOemName |
 *
 *          Get the Id by OEMNAME
 *
 *  @parm   IN LPTSTR | szOEMNAME |
 *
 *          String used to find the ID.
 *
 *  @parm   IN LPUNIT | lpID |
 *
 *          The ID to get.
 *
 *  @returns
 *
 *          A COM success code unless the current configuration key could not
 *          be opened, or could not find the OEMNAME.
 *
 *****************************************************************************/

HRESULT EXTERNAL JoyReg_GetIDByOemName( LPTSTR szOemName, PUINT pId )
{
    HRESULT hres = E_FAIL;
    LONG    lRc;
    HKEY    hkCurrCfg;
    UINT    JoyId;
    TCHAR   szTestName[MAX_JOYSTRING];
    TCHAR   szOemNameKey[MAX_JOYSTRING];
    DWORD   cb;

    EnterProcI(JoyReg_GetIDByOemName, (_ "sp", szOemName, pId ));

    hres = JoyReg_OpenConfigKey( (UINT)(-1), KEY_WRITE, REG_OPTION_NON_VOLATILE, &hkCurrCfg );

    if ( SUCCEEDED( hres ) )
    {
        for ( JoyId = 0; (JoyId < 16) || ( lRc == ERROR_SUCCESS ); JoyId++ )
        {
            wsprintf( szOemNameKey, REGSTR_VAL_JOYNOEMNAME, JoyId+1 );
            cb = sizeof( szTestName );
            lRc = RegQueryValueEx( hkCurrCfg, szOemNameKey, 0, NULL, (PBYTE)szTestName, &cb );
            if ( lRc == ERROR_SUCCESS )
            {
                if ( !lstrcmpi( szOemName, szTestName ) )
                {
                    *pId = JoyId;
                    pId ++;
                    hres = S_OK;
                    break;
                }
            }
        }

    } else
    {
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("JoyReg_OpenConfigKey failed code 0x%08x"), hres );
    }

    ExitOleProc();

    return hres;

} /* JoyReg_GetIDByOemName */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dimapshp.c ===
/*****************************************************************************
 *
 *  dimapshp.c
 *
 *  Copyright (c) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      The IDirectInputMapperW shepherd.
 *
 *      The shepherd does the annoying work of babysitting the
 *      IDirectInputMapperW.
 *
 *      It makes sure nobody parties on bad handles.
 *
 *      It handles cross-process (or even intra-process) effect
 *      management.
 *
 *  Contents:
 *
 *      CMapShep_New
 *
 *****************************************************************************/

#include "dinputpr.h"
#ifdef UNICODE
#undef _UNICODE
#define _UNICODE
#endif // !UNICODE


/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflEShep/*Should we use own area?*/

#pragma BEGIN_CONST_DATA


/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *****************************************************************************/

  Primary_Interface(CMapShep, IDirectInputMapShepherd);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CMapShep |
 *
 *          The <i IDirectInputMapShepherd> object, which
 *          babysits an <i IDirectInputMapperW>.
 *
 *  @field  IDirectInputMapShepherd | dms |
 *
 *          DirectInputMapShepherd object (containing vtbl).
 *
 *  @field  IDirectInputMapperW * | pdimap |
 *
 *          Delegated mapper interface.
 *
 *  @field  HINSTANCE | hinstdimapdll |
 *
 *          The instance handle of the DLL that contains the mapper.
 *
 *****************************************************************************/

typedef struct CMapShep {

    /* Supported interfaces */
    IDirectInputMapShepherd dms;

	IDirectInputMapperW* pdimap;

    HINSTANCE hinstdimapdll;

} CMapShep, MS, *PMS;

typedef IDirectInputMapShepherd DMS, *PDMS;
#define ThisClass CMapShep
#define ThisInterface IDirectInputMapShepherd

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputMapShepherd | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *//**************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputMapShepherd | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputMapShepherd | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *//**************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputMapShepherd | QIHelper |
 *
 *          We don't have any dynamic interfaces and simply forward
 *          to <f Common_QIHelper>.
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *//**************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputMapShepherd | AppFinalize |
 *
 *          We don't have any weak pointers, so we can just
 *          forward to <f Common_Finalize>.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released from the application's perspective.
 *
 *****************************************************************************/

#ifdef DEBUG

Default_QueryInterface(CMapShep)
Default_AddRef(CMapShep)
Default_Release(CMapShep)

#else

#define CMapShep_QueryInterface   Common_QueryInterface
#define CMapShep_AddRef           Common_AddRef
#define CMapShep_Release          Common_Release

#endif

#define CMapShep_QIHelper         Common_QIHelper
#define CMapShep_AppFinalize      Common_AppFinalize

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CMapShep_Finalize |
 *
 *          Clean up our instance data.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
CMapShep_Finalize(PV pvObj)
{
    PMS this = pvObj;

	Invoke_Release(&this->pdimap);

	if( this->hinstdimapdll)
    {
        FreeLibrary(this->hinstdimapdll);
        this->hinstdimapdll = NULL;
    }

}

/*****************************************************************************
 * ForceUnload
 *****************************************************************************/

void INTERNAL
CMapShep_ForceUnload(PV pvObj)/**why are this two functions same??????**/
{
   PMS this = pvObj;

   Invoke_Release(&this->pdimap);

	if( this->hinstdimapdll)
    {
        FreeLibrary(this->hinstdimapdll);
        this->hinstdimapdll = NULL;
    }

}


/*****************************************************************************
 * InitDll
 *****************************************************************************/

HRESULT INTERNAL
CMapShep_InitDll(PMS this,REFGUID lpDeviceGUID,LPCWSTR lpcwstrFileName)
{

	//do _CreateInstance()
    HRESULT hres = S_OK;

	if (this->hinstdimapdll == NULL)
	{
        hres = _CreateInstance(&IID_IDirectInputMapClsFact/*should be CLSID_CDIMap*/,
					TEXT("dimap.dll"), NULL, &IID_IDirectInputMapIW,
					(LPVOID*) & this->pdimap, &this->hinstdimapdll);
	    if (SUCCEEDED(hres) && this->pdimap != NULL)
		{
			hres = this->pdimap->lpVtbl->Initialize(this->pdimap,
					lpDeviceGUID, lpcwstrFileName, 0);
			if(!SUCCEEDED(hres))
				CMapShep_Finalize(this);
		}
	}
                                           
    return hres;
}


/*****************************************************************************
 * GetActionMap
 *****************************************************************************/

STDMETHODIMP
CMapShep_GetActionMapW
        (
		PDMS pdms,
        REFGUID lpDeviceGUID,
        LPCWSTR lpcwstrFileName,
        LPDIACTIONFORMATW lpDIActionFormat,
        LPCWSTR lpcwstrUserName,
		LPFILETIME lpFileTime,
        DWORD dwFlags
        )
{
	PMS this;
    HRESULT hres = S_OK;
    EnterProcI(IDirectInputMapShepherd::GetActionMapW, (_ "p", pdms));

    this = _thisPvNm(pdms, dms);

    if (!this->hinstdimapdll)
	{
		hres = CMapShep_InitDll(this, lpDeviceGUID, lpcwstrFileName);
	}

	//call the fn
	if (SUCCEEDED(hres) && this->pdimap != NULL)
    {
	    hres = this->pdimap->lpVtbl->GetActionMap(this->pdimap,
				lpDIActionFormat, lpcwstrUserName, lpFileTime, dwFlags );
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 * SaveActionMap
 *****************************************************************************/

STDMETHODIMP
CMapShep_SaveActionMapW
        (
		PDMS pdms,
        REFGUID lpDeviceGUID,
        LPCWSTR lpcwstrFileName,
        LPDIACTIONFORMATW lpDIActionFormat,
		LPCWSTR lpcwstrUserName,
		DWORD dwFlags)
{
	PMS this;
    HRESULT hres = S_OK;
    EnterProcI(IDirectInputMapShepherd::SaveActionMapW, (_ "p", pdms));

    this = _thisPvNm(pdms, dms);

    if (!this->hinstdimapdll)
	{
		hres = CMapShep_InitDll(this, lpDeviceGUID, lpcwstrFileName);
	}

	//call the fn
	if (SUCCEEDED(hres) && this->pdimap != NULL)
    {
	    hres = this->pdimap->lpVtbl->SaveActionMap(this->pdimap,
				lpDIActionFormat, lpcwstrUserName, dwFlags );
    }

//	CMapShep_Finalize(this);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 * GetImageInfo
 *****************************************************************************/

STDMETHODIMP
CMapShep_GetImageInfoW
        (
		PDMS pdms,
        REFGUID lpDeviceGUID,
        LPCWSTR lpcwstrFileName,
        LPDIDEVICEIMAGEINFOHEADERW lpdiDevImageInfoHeader
        )
{
	PMS this;
    HRESULT hres = S_OK;
    EnterProcI(IDirectInputMapShepherd::GetImageInfoW, (_ "p", pdms));

    this = _thisPvNm(pdms, dms);

    if (!this->hinstdimapdll)
	{
		hres = CMapShep_InitDll(this, lpDeviceGUID, lpcwstrFileName);
	}

	//call the fn
	if (SUCCEEDED(hres) && this->pdimap != NULL)
    {
	    hres = this->pdimap->lpVtbl->GetImageInfo(this->pdimap,
				lpdiDevImageInfoHeader );
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputMapShepherd | New |
 *
 *          Create a new instance of an IDirectInputMapShepherd object.
 *
 *  @parm   IN PUNK | punkOuter |
 *
 *          Controlling unknown for aggregation.
 *
 *  @parm   IN RIID | riid |
 *
 *          Desired interface to new object.
 *
 *  @parm   OUT PPV | ppvObj |
 *
 *          Output pointer for new object.
 *
 *  @returns
 *
 *          Standard OLE <t HRESULT>.
 *
 *****************************************************************************/

STDMETHODIMP
CMapShep_New(PUNK punkOuter, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcR(IDirectInputMapShepherd::<constructor>, (_ "G", riid));


    hres = Common_NewRiid(CMapShep, punkOuter, riid, ppvObj);

    if (SUCCEEDED(hres)) {
        /* Must use _thisPv in case of aggregation */
        PMS this = _thisPv(*ppvObj);
		this->hinstdimapdll = NULL;

/* In case of mapper we do this inside each method...		
		if (SUCCEEDED(hres = CMap_InitDll(this))) {
      } else {
            Invoke_Release(ppvObj);
        }*/		
    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

//#define CEShep_Signature        0x50454853      /* "SHEP" */

Interface_Template_Begin(CMapShep)
    Primary_Interface_Template(CMapShep, IDirectInputMapShepherd)
Interface_Template_End(CMapShep)

Primary_Interface_Begin(CMapShep, IDirectInputMapShepherd)
    CMapShep_GetActionMapW,
    CMapShep_SaveActionMapW,
    CMapShep_GetImageInfoW,
Primary_Interface_End(CMapShep, IDirectInputMapShepherd)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dijoyhid.c ===
/*****************************************************************************
 *
 *  DIHid.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      WINNT implementation of JOYHID.
 *
 *  Contents:
 *
 *      DIWdm_JoyHidMapping
 *      JoyReg_JoyIdToDeviceInterface
 *
 *****************************************************************************/

#include "dinputpr.h"

#undef  sqfl
#define sqfl sqflWDM

#include "dijoyhid.h"

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT EXTERNAL | DIWdm_JoyHidMapping |
 *
 *          Does the work done by JoyHid on Win9x. This function
 *          maps the Joystick ID to a HID device and talks to the
 *          HID device to obtain its capabilities.
 *
 *  @parm   IN int | idJoy |
 *
 *          The Id of the joystick to be located.
 *
 *  @parm   OUT PVXDINITPARAMS | pvip | OPTIONAL
 *          Address of a VXDINITPARAMS structure that is filled out
 *          by this function. This is an optional parameter
 *          and can be NULL
 *
 *  @parm   OUT LPDIJOYCONFIG | pcfg  |
 *          Address of a DIJOYCONFIG structure that is filled out
 *          by this function. This is an optional parameter.
 *
 *  @parm   IN OUT LPDIJOYTYPEINFO | pdijti | 
 *          Address of a DIJOYTYPEINFO structure that is filled out
 *          by this function. This is an optional parameter.
 *          If passed in, the hws.dwFlags is used to initialize the 
 *          same flags in the DIJOYCONFIG structure.
 *
 *  @returns    HRESULT
 *          Returns a COM error code
 *
 *****************************************************************************/
/*
 *  ISSUE-2001/03/29-timgill function uses too much stack space
 *  This function uses over 4K of stack space! 
 *  This causes the Win9x build to choke looking for _chkstk.
 *  Hack by forcing caller to pass pcfg and pdijti
 */
HRESULT EXTERNAL
    DIWdm_JoyHidMapping
    (
    IN  int             idJoy,
    OUT PVXDINITPARMS   pvip,   OPTIONAL
    OUT LPDIJOYCONFIG   pcfg,   OPTIONAL
    IN OUT LPDIJOYTYPEINFO pdijti 
    )
{
    HRESULT         hres;
    PHIDDEVICEINFO  phdi;
    VXDINITPARMS    vip;
    DWORD           wCaps = 0;
    DIPROPINFO      propi;                            
    DIPROPSTRING    dips;
    DIPROPDWORD     dipd;
    BOOL            fBadCalData = FALSE;

    EnterProc(DIWdm_JoyHidMapping, (_ "uxx", idJoy, pvip, pcfg));

    // AssertF(InCrit());

    if( pvip == NULL )
    {
        ZeroX(vip);
        vip.dwSize = cbX(vip);
        pvip = &vip;
    }

    AssertF(pdijti != NULL );

    /*
     *  Copy the type info because JOY_HWS_ISYOKE, JOY_HWS_ISCARCTRL and 
     *  JOY_HWS_ISHEADTRACKER have no simple equivalents in HID so would 
     *  otherwise get lost.  No harm done if it's zero.
     *  Note, the dwFlags is built in pvip then copied elsewhere.
     */
    pvip->dwFlags = pdijti->hws.dwFlags;

    phdi = phdiFindJoyId(idJoy);
    if( phdi != NULL )
    {
        IDirectInputDeviceCallback *pdcb;

        hres = CHid_New(0, &phdi->guid,
                        &IID_IDirectInputDeviceCallback,
                        (PPV)&pdcb);
        if( SUCCEEDED(hres) )
        {
            DIDEVCAPS dc;

            hres = pdcb->lpVtbl->GetCapabilities(pdcb, &dc );
            if( SUCCEEDED(hres) )
            {
                DIDEVICEINSTANCEW didi;

                didi.dwSize = cbX(didi);

                hres = pdcb->lpVtbl->GetDeviceInfo(pdcb, &didi);
                if( SUCCEEDED(hres) )
                {
                    LPDIDATAFORMAT pdf;

                    hres = pdcb->lpVtbl->GetDataFormat(pdcb, &pdf);
                    if( SUCCEEDED(hres) )
                    {
                        DIPROPCAL dipc;
                        DWORD axis, pov = 0;

                        ZeroBuf(pvip->Usages, 6 * cbX(pvip->Usages[0]));

                        hres = pdcb->lpVtbl->MapUsage(pdcb, CheckHatswitch->dwUsage, &propi.iobj);
                        if(SUCCEEDED(hres) )
                        {
                            pvip->dwPOV1usage      = CheckHatswitch->dwUsage;
                            pvip->dwFlags         |= CheckHatswitch->dwFlags;
                            wCaps                 |= CheckHatswitch->dwCaps;

                            propi.pguid = DIPROP_GRANULARITY;
                            propi.dwDevType = pdf->rgodf[propi.iobj].dwType;
                            hres = pdcb->lpVtbl->GetProperty(pdcb, &propi, &dipd.diph);
                            if( SUCCEEDED( hres ) )
                            {
                                if( dipd.dwData >= 9000 ) // 4 directional POV
                                {
                                    wCaps |= JOYCAPS_POV4DIR;
                                    
                                    if( pcfg != NULL ) {
                                        pcfg->hwc.hwv.dwPOVValues[JOY_POVVAL_FORWARD]   = JOY_POVFORWARD;
                                        pcfg->hwc.hwv.dwPOVValues[JOY_POVVAL_BACKWARD]  = JOY_POVBACKWARD;
                                        pcfg->hwc.hwv.dwPOVValues[JOY_POVVAL_LEFT]      = JOY_POVLEFT;
                                        pcfg->hwc.hwv.dwPOVValues[JOY_POVVAL_RIGHT]     = JOY_POVRIGHT;
                                    }
                                } else // Continuous POV
                                {
                                    wCaps |= JOYCAPS_POVCTS;
                                }
                            }
                        } 

                        for( axis = 0; axis < cA(AxesUsages)-1; axis++ ) 
                        {
                            USAGES *pUse = &AxesUsages[axis];
                            DWORD   dwCurAxisPos = pUse->dwAxisPos;

                            if( pvip->Usages[dwCurAxisPos] != 0) {
                                continue;
                            } else {
                                int i;
                                BOOL bHasUsed = FALSE;
                                
                                for( i = 0; i < (int)dwCurAxisPos; i++ ) {
                                    if( pvip->Usages[i] == pUse->dwUsage ) {
                                        bHasUsed = TRUE;
                                        break;
                                    }
                                }
                                
                                if( bHasUsed ) {
                                    continue;
                                }
                            }
                            
                            hres = pdcb->lpVtbl->MapUsage(pdcb, pUse->dwUsage, &propi.iobj);
                            if(SUCCEEDED(hres) )
                            {
                                pvip->Usages[dwCurAxisPos] = pUse->dwUsage;
                                pvip->dwFlags     |= pUse->dwFlags;
                                wCaps             |= pUse->dwCaps;

                                propi.pguid = DIPROP_CALIBRATION;
                                propi.dwDevType = pdf->rgodf[propi.iobj].dwType;
                                hres = pdcb->lpVtbl->GetProperty(pdcb, &propi, &dipc.diph);
                                if( SUCCEEDED(hres) && pcfg != NULL )
                                {

#ifdef WINNT
                                    (&pcfg->hwc.hwv.jrvHardware.jpMin.dwX)[dwCurAxisPos] 
                                        = dipc.lMin;
                                    (&pcfg->hwc.hwv.jrvHardware.jpMax.dwX)[dwCurAxisPos] 
                                        = dipc.lMax;
                                    (&pcfg->hwc.hwv.jrvHardware.jpCenter.dwX)[dwCurAxisPos] 
                                        = CCal_Midpoint(dipc.lMin, dipc.lMax);
#else
                                    DIPROPRANGE diprp;
                                    DIPROPRANGE diprl;
                                    
                                    propi.pguid = DIPROP_PHYSICALRANGE;
                                    propi.dwDevType = pdf->rgodf[propi.iobj].dwType;
                                    hres = pdcb->lpVtbl->GetProperty(pdcb, &propi, &diprp.diph);
                                    if( SUCCEEDED( hres ) )
                                    {
                                        propi.pguid = DIPROP_LOGICALRANGE;
                                        propi.dwDevType = pdf->rgodf[propi.iobj].dwType;
                                        hres = pdcb->lpVtbl->GetProperty(pdcb, &propi, &diprl.diph);
                                        if( SUCCEEDED( hres ) )
                                        {
                                            LONG lMin, lMax;

                                            lMin = (&pcfg->hwc.hwv.jrvHardware.jpMin.dwX)[dwCurAxisPos] 
                                                = CHid_CoordinateTransform( (PLMINMAX)&diprp.lMin, (PLMINMAX)&diprl.lMin, dipc.lMin );
                                            lMax = (&pcfg->hwc.hwv.jrvHardware.jpMax.dwX)[dwCurAxisPos] 
                                                = CHid_CoordinateTransform( (PLMINMAX)&diprp.lMin, (PLMINMAX)&diprl.lMin, dipc.lMax );
                                            (&pcfg->hwc.hwv.jrvHardware.jpCenter.dwX)[dwCurAxisPos] 
                                                = CCal_Midpoint(lMin, lMax);

                                            if( lMin >= lMax ) {
                                                fBadCalData = TRUE;
                                                break;
                                            }
                                        }

                                    }
#endif

                                }
                            }
                        } //for (axis=0...
                    }  //GetDataFormat

                    pvip->hres                  =   S_OK;
                    pvip->dwSize                =   cbX(*pvip);          /* Which version of VJOYD are we? */
                    pvip->dwFlags              |=   JOY_HWS_AUTOLOAD;    /* Describes the device */

                    if(didi.wUsage ==  HID_USAGE_GENERIC_GAMEPAD) {
                        pvip->dwFlags |= JOY_HWS_ISGAMEPAD;
                    }

                    pvip->dwId                  =   idJoy;               /* Internal joystick ID */
                    pvip->dwFirmwareRevision    =   dc.dwFirmwareRevision;
                    pvip->dwHardwareRevision    =   dc.dwHardwareRevision;
                    pvip->dwFFDriverVersion     =   dc.dwFFDriverVersion;
                    pvip->dwFilenameLengths     =   lstrlen(phdi->pdidd->DevicePath);
                    pvip->pFilenameBuffer       =   phdi->pdidd->DevicePath;

                    //pvip->Usages[6];
                    //pvip->dwPOV1usage =   0x0;
                    pvip->dwPOV2usage =   0x0;
                    pvip->dwPOV3usage =   0x0;

                    /* Fill all fields of cfg */

                    if( pcfg != NULL ) {
                        AssertF( pcfg->dwSize == sizeof(DIJOYCONFIG_DX5) 
                              || pcfg->dwSize == sizeof(DIJOYCONFIG_DX6) );
                        pcfg->guidInstance            =   phdi->guid;
                        pcfg->hwc.hws.dwNumButtons    =   dc.dwButtons;
                        pcfg->hwc.hws.dwFlags         =   pvip->dwFlags;
    
                        //pcfg.hwc.hwv.jrvHardware
                        //pcfg.hwc.hwv.dwPOVValues
    
                        pcfg->hwc.hwv.dwCalFlags      =   0x0;
    
                        if( ( LOWORD(phdi->guidProduct.Data1) == MSFT_SYSTEM_VID )
                          &&( ( HIWORD(phdi->guidProduct.Data1) >= MSFT_SYSTEM_PID + JOY_HW_PREDEFMIN) 
                            &&( HIWORD(phdi->guidProduct.Data1) < MSFT_SYSTEM_PID + JOY_HW_PREDEFMAX ) ) )
                        {
                            pcfg->hwc.dwType          =    HIWORD(phdi->guidProduct.Data1) - MSFT_SYSTEM_PID;
                            pcfg->hwc.dwUsageSettings =    JOY_US_PRESENT | JOY_US_VOLATILE;
                        }
                        else
                        {
                            /*
                             *  This value really does not matter much but ideally 
                             *  should be greater than or equal to JOY_HW_PREDEFMAX
                             *  Add idJoy for best compatiblity with the old CPLs.
                             */
                            pcfg->hwc.dwType          =    idJoy + JOY_HW_PREDEFMAX;
                            pcfg->hwc.dwUsageSettings =    JOY_US_PRESENT | JOY_US_VOLATILE | JOY_US_ISOEM;
                        }
                        
                        if(pcfg && pvip->Usages[ecRz]) {
                            pcfg->hwc.dwUsageSettings |= JOY_US_HASRUDDER;
                        }
    
                        pcfg->hwc.dwReserved          =    0x0;
    
                        /*
                         *  Default gain to nominal max so it does not get written
                         *  to the registry unless it has some other value.
                         */
                        pcfg->dwGain                  =    DI_FFNOMINALMAX;
    
                        propi.pguid     = DIPROP_FFGAIN;
                        propi.dwDevType = DIPH_DEVICE;
                        propi.iobj      = 0xFFFFFFFF;
                        hres = pdcb->lpVtbl->GetProperty(pdcb, &propi, &dipd.diph);
                        if( SUCCEEDED(hres) )
                        {
                            pcfg->dwGain  =  dipd.dwData;
                        } else
                        {
                            // Failure to get gain is not crutial
                            hres = S_OK;     
                        }
    
    
                        if( pcfg->hwc.dwType >= JOY_HW_PREDEFMAX )
                        {
        #ifndef UNICODE
                            char szType[20];
        #endif
                            /*
                             * This should work, but it doesn't in Win98, bug!
                             *
                             *  wsprintfW(pcfg->wszType, L"VID_%04X&PID_%04X",
                             *    LOWORD(didi.guidProduct.Data1), HIWORD(didi.guidProduct.Data1));
                             */
        
        #ifdef UNICODE
                            wsprintf(pcfg->wszType, VID_PID_TEMPLATE,
                                LOWORD(phdi->guidProduct.Data1), HIWORD(phdi->guidProduct.Data1));
        #else
                            wsprintf(szType, VID_PID_TEMPLATE,
                                LOWORD(phdi->guidProduct.Data1), HIWORD(phdi->guidProduct.Data1));
                            AToU(pcfg->wszType, cA(pcfg->wszType), szType);
        #endif
                        }
                        else
                        {
                            /*
                             *  Predefined types do not have type strings for the 
                             *  uses the callers of this function need.
                             */
                            ZeroX(pcfg->wszType);
                        }
    
#ifdef WINNT
                        // No callout on NT
                        ZeroX(pcfg->wszCallout);
#else
                        lstrcpyW( pcfg->wszCallout, L"joyhid.vxd" );
#endif
                    } // end of filling pcfg's fields
    
    
                    pdijti->dwSize            = cbX(*pdijti);
                    pdijti->hws.dwNumButtons  = dc.dwButtons;
                    pdijti->hws.dwFlags       = pvip->dwFlags;
                    ZeroX(pdijti->clsidConfig);


                    propi.pguid     = DIPROP_INSTANCENAME;
                    propi.dwDevType = DIPH_DEVICE;
                    propi.iobj      = 0xFFFFFFFF;
                    hres = pdcb->lpVtbl->GetProperty(pdcb, &propi, &dips.diph);

                    if( hres != S_OK && lstrlenW(pdijti->wszDisplayName) != 0x0 )
                    {
                        // Failure to get friendly name
                        // We will try and use the OEM name from the registry
                        lstrcpyW(dips.wsz, pdijti->wszDisplayName);                     
                        //pdcb->lpVtbl->SetProperty(pdcb, &propi, &dips.diph);

                    }else if( SUCCEEDED(hres) )
                    {
                        // Use friendly name in the registry 
                        lstrcpyW(pdijti->wszDisplayName, dips.wsz);
                        hres = S_OK;
                    }
                } // GetDeviceInfo FAILED
            } // GetCapabilities FAILED

            Invoke_Release(&pdcb);
        }
    } else // No HID device for JoyID
    {
        hres = E_FAIL;
    }

    if( fBadCalData ) {
        hres = E_FAIL;
    }

    ExitProcX(hres);
    return hres;
}



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_JoyIdToDeviceInterface |
 *
 *          Given a joystick ID number, obtain the device interface
 *          corresponding to it.
 *
 *  @parm   UINT | idJoy |
 *
 *          Joystick ID number, zero-based.
 *
 *  @parm   PVXDINITPARMS | pvip |
 *
 *          Receives init parameters from the driver.
 *
 *  @parm   LPTSTR | ptszBuf |
 *
 *          A buffer of size <c MAX_PATH> in which the device interface
 *          path is built.
 *
 *  @returns
 *          A pointer to the part of the <p ptszBuf> buffer that
 *          contains the actual device interface path.
 *
 *****************************************************************************/

LPTSTR EXTERNAL
    JoyReg_JoyIdToDeviceInterface_NT
    (
    IN  UINT idJoy,
    OUT PVXDINITPARMS pvip,
    OUT LPTSTR ptszBuf
    )
{
    HRESULT hres;
    DIJOYCONFIG     cfg;
    DIJOYTYPEINFO   dijti;

    DllEnterCrit();

    ZeroX(cfg);
    ZeroX(dijti);

    cfg.dwSize = cbX(cfg);
    dijti.dwSize = cbX(dijti);

    hres = DIWdm_JoyHidMapping(idJoy, pvip, &cfg, &dijti );

    if( SUCCEEDED(hres ) )
    {
        AssertF( lstrlen(pvip->pFilenameBuffer) < MAX_PATH );
        lstrcpy(ptszBuf, pvip->pFilenameBuffer);
    }

    DllLeaveCrit();

    return ptszBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dilib5.c ===
/*****************************************************************************
 *
 *  DILib5.c
 *
 *  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Objects exported statically into our library.
 *
 *  Contents:
 *
 *      c_dfDIMouse2
 *
 *****************************************************************************/

#include "dinputpr.h"


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global DIOBJECTDATAFORMAT | c_rgdoiDIMouse2[] |
 *
 *          Device object data formats for mouse-style access.
 *
 *  @global DIDEVICEFORMAT | c_dfDIMouse2 |
 *
 *          Device format for mouse-style access.
 *
 *          A pointer to this structure may be passed to
 *          <mf IDirectInputDevice::SetDataFormat> to indicate that
 *          the device will be accessed in the form of a mouse.
 *
 *          When a device has been set to the mouse data format,
 *          the <mf IDirectInputDevice::GetDeviceState> function
 *          returns a <t DIMOUSESTATE2> structure, and the
 *          <mf IDirectInputDevice::GetDeviceData> function
 *          returns a <t DIDEVICEOBJECTDATA> whose <p dwOfs>
 *          field is a <c DIMOFS_*> value which describes the
 *          object whose data is being reported.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

static DIOBJECTDATAFORMAT c_rgodfDIMouse2[] = {
    { &GUID_XAxis, FIELD_OFFSET(DIMOUSESTATE2,        lX),       DIDFT_AXIS | DIDFT_ANYINSTANCE, },
    { &GUID_YAxis, FIELD_OFFSET(DIMOUSESTATE2,        lY),       DIDFT_AXIS | DIDFT_ANYINSTANCE, },
    { &GUID_ZAxis, FIELD_OFFSET(DIMOUSESTATE2,        lZ),       DIDFT_AXIS | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE2, rgbButtons[0]), DIDFT_BUTTON | DIDFT_ANYINSTANCE, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE2, rgbButtons[1]), DIDFT_BUTTON | DIDFT_ANYINSTANCE, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE2, rgbButtons[2]), DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE2, rgbButtons[3]), DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE2, rgbButtons[4]), DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE2, rgbButtons[5]), DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE2, rgbButtons[6]), DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE2, rgbButtons[7]), DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL, },
};

const DIDATAFORMAT c_dfDIMouse2 = {
    sizeof(DIDATAFORMAT),
    sizeof(DIOBJECTDATAFORMAT),
    DIDF_RELAXIS,
    sizeof(DIMOUSESTATE2),
    cA(c_rgodfDIMouse2),
    c_rgodfDIMouse2,
};

#pragma END_CONST_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dinputi.h ===
/***************************************************************************
 *
 *  Copyright (C) 1996 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dinputi.h
 *  Content:    DirectInput internal include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *   1996.05.07 raymondc Lost a bet
 *
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifdef __cplusplus
extern "C" {
#endif

    /***************************************************************************
     *
     *  Debug / RDebug / Retail
     *
     *  If either DEBUG or RDEBUG, set XDEBUG.
     *
     *  Retail defines nothing.
     *
     ***************************************************************************/

#if defined(DEBUG) || defined(RDEBUG)
    #define XDEBUG
#endif

    /***************************************************************************
     *
     *                            Turning off stuff...
     *
     *  Turn off these things, because they confuse the bilingualism macros.
     *  Instead, we call then IMumbleT.
     *
     ***************************************************************************/

#undef IDirectInput
#undef IDirectInput2
#undef IDirectInput7
#undef IDirectInput8
#undef IDirectInputDevice
#undef IDirectInputDevice2
#undef IDirectInputDevice7
#undef IDirectInputDevice8

    /*
     *  And <mmsystem.h> defines JOY_POVCENTERED incorrectly...
     */
#undef  JOY_POVCENTERED
#define JOY_POVCENTERED     0xFFFFFFFF

    /*
     *  And older versions of windows.h don't have this definition.
     */
#ifndef HasOverlappedIoCompleted
    #define HasOverlappedIoCompleted(lpOverlapped) \
            ((lpOverlapped)->Internal != STATUS_PENDING)
#endif

    /***************************************************************************
     *
     *                            Abbreviations....
     *
     *  Give shorter names to things we talk about frequently.
     *
     ***************************************************************************/

    typedef LPDIRECTINPUT8  PDI , *PPDI ;
    typedef LPDIRECTINPUT8A PDIA, *PPDIA;
    typedef LPDIRECTINPUT8W PDIW, *PPDIW;

    typedef LPDIRECTINPUTDEVICE8  PDID , *PPDID ;
    typedef LPDIRECTINPUTDEVICE8A PDIDA, *PPDIDA;
    typedef LPDIRECTINPUTDEVICE8W PDIDW, *PPDIDW;

    typedef LPDIRECTINPUTEFFECT  PDIE , *PPDIE ;

    typedef DIOBJECTDATAFORMAT   ODF,   *PODF;
    typedef const ODF                   *PCODF;

    typedef LPUNKNOWN PUNK;
    typedef LPVOID PV, *PPV;
    typedef CONST VOID *PCV;
    typedef REFIID RIID;
    typedef CONST GUID *PCGUID;

    /***************************************************************************
     *
     *      GetProcAddress'd KERNEL32 and USER32 functions.
     *
     ***************************************************************************/
    typedef DWORD (WINAPI *OPENVXDHANDLE)(HANDLE);
    typedef BOOL  (WINAPI *CANCELIO)(HANDLE);
    typedef DWORD (WINAPI *MSGWAITFORMULTIPLEOBJECTSEX)
    (DWORD, LPHANDLE, DWORD, DWORD, DWORD);

    typedef BOOL (WINAPI *TRYENTERCRITICALSECTION)(LPCRITICAL_SECTION);

    extern OPENVXDHANDLE _OpenVxDHandle;
    extern CANCELIO _CancelIO;
    extern MSGWAITFORMULTIPLEOBJECTSEX _MsgWaitForMultipleObjectsEx;
#ifdef XDEBUG
    extern TRYENTERCRITICALSECTION _TryEnterCritSec;
    BOOL WINAPI FakeTryEnterCriticalSection(LPCRITICAL_SECTION lpCrit_sec);
#endif

    DWORD WINAPI
        FakeMsgWaitForMultipleObjectsEx(DWORD, LPHANDLE, DWORD, DWORD, DWORD);

    BOOL WINAPI FakeCancelIO(HANDLE h);


    /***************************************************************************
     *
     *      Our global variables - see dinput.c for documentation
     *
     ***************************************************************************/

    extern HINSTANCE g_hinst;
#ifndef WINNT
    extern HANDLE g_hVxD;
    extern HANDLE g_hVjoyd;
    extern DWORD g_dwLastBonusPoll;
#endif
    extern DWORD g_flEmulation;
    extern LPDWORD g_pdwSequence;

#ifdef USE_SLOW_LL_HOOKS
    extern HHOOK g_hhkLLHookCheck;
    #define g_fUseLLHooks   ((BOOL)(UINT_PTR)g_hhkLLHookCheck)
#endif

    extern HANDLE g_hmtxGlobal;
    extern HANDLE g_hfm;
    extern struct SHAREDOBJECTPAGE *g_psop;
    extern UINT g_wmJoyChanged;
    extern HANDLE g_hmtxJoy;
    extern HINSTANCE g_hinstSetupapi;
    extern LONG g_lWheelGranularity;

    extern int g_cdtoMax;
    extern int g_cdto;
    extern struct _DEVICETOUSER *g_pdto;

    extern BOOL g_fRawInput;
  #ifdef USE_WM_INPUT
    extern HWND g_hwndThread;
    extern HANDLE g_hEventAcquire;
    extern HANDLE g_hEventThread;
    extern HANDLE g_hEventHid;
  #endif
  
    extern PDWORD g_rgdwCRCTable;

    typedef struct _DIAPPHACKS
    {
        BOOL    fReacquire;
        BOOL    fNoSubClass;
        int     nMaxDeviceNameLength;
    } DIAPPHACKS, *LPDIAPPHACKS;

    extern DIAPPHACKS g_AppHacks;
    extern DWORD g_dwAppDate;
    extern DWORD g_dwAppFileLen;
    extern DWORD g_dwLastMsgSent;
    extern UINT g_wmDInputNotify;

    /*****************************************************************************
     *
     *                      Baggage
     *
     *      Stuff I carry everywhere.
     *
     *****************************************************************************/

#define INTERNAL NTAPI  /* Called only within a translation unit */
#define EXTERNAL NTAPI  /* Called from other translation units */
#define INLINE static __inline

#define BEGIN_CONST_DATA data_seg(".text", "CODE")
#define END_CONST_DATA data_seg(".data", "DATA")

    /*
     *  Arithmetic on pointers.
     */
#define pvSubPvCb(pv, cb) ((PV)((PBYTE)pv - (cb)))
#define pvAddPvCb(pv, cb) ((PV)((PBYTE)pv + (cb)))
#define cbSubPvPv(p1, p2) ((PBYTE)(p1) - (PBYTE)(p2))

    /*
     * Convert an object (X) to a count of bytes (cb).
     */
#define cbX(X) sizeof(X)

    /*
     * Convert an array name (A) to a generic count (c).
     */
#define cA(a) (cbX(a)/cbX(a[0]))

    /*
     * Convert a count of X's (cx) into a count of bytes
     * and vice versa.
     */
#define  cbCxX(cx, X) ((cx) * cbX(X))
#define  cxCbX(cb, X) ((cb) / cbX(X))

    /*
     * Convert a count of chars (cch), tchars (ctch), wchars (cwch),
     * or dwords (cdw) into a count of bytes, and vice versa.
     */
#define  cbCch(cch)  cbCxX( cch,  CHAR)
#define cbCwch(cwch) cbCxX(cwch, WCHAR)
#define cbCtch(ctch) cbCxX(ctch, TCHAR)
#define  cbCdw(cdw)  cbCxX( cdw, DWORD)

#define  cchCb(cb) cxCbX(cb,  CHAR)
#define cwchCb(cb) cxCbX(cb, WCHAR)
#define ctchCb(cb) cxCbX(cb, TCHAR)
#define  cdwCb(cb) cxCbX(cb, DWORD)

    /*
     * Zero an arbitrary buffer.  It is a common error to get the second
     * and third parameters to memset backwards.
     */
#define ZeroBuf(pv, cb) memset(pv, 0, cb)

    /*
     * Zero an arbitrary object.
     */
#define ZeroX(x) ZeroBuf(&(x), cbX(x))

    /*
     * land -- Logical and.  Evaluate the first.  If the first is zero,
     * then return zero.  Otherwise, return the second.
     */

#define fLandFF(f1, f2) ((f1) ? (f2) : 0)

    /*
     * lor -- Logical or.  Evaluate the first.  If the first is nonzero,
     * return it.  Otherwise, return the second.
     *
     * Unfortunately, due to the *nature* of the C language, this can
     * be implemented only with a GNU extension.  In the non-GNU case,
     * we return 1 if the first is nonzero.
     */

#if defined(__GNUC__)
    #define fLorFF(f1, f2) ((f1) ?: (f2))
#else
    #define fLorFF(f1, f2) ((f1) ? 1 : (f2))
#endif

    /*
     * limp - logical implication.  True unless the first is nonzero and
     * the second is zero.
     */
#define fLimpFF(f1, f2) (!(f1) || (f2))

    /*
     * leqv - logical equivalence.  True if both are zero or both are nonzero.
     */
#define fLeqvFF(f1, f2) (!(f1) == !(f2))

    /*
     *  fInOrder - checks that i1 <= i2 < i3.
     */
#define fInOrder(i1, i2, i3) ((unsigned)((i2)-(i1)) < (unsigned)((i3)-(i1)))

    /*
     *  fHasAllBitsFlFl - checks that all bits in fl2 are set in fl1.
     */
    BOOL INLINE
        fHasAllBitsFlFl(DWORD fl1, DWORD fl2)
    {
        return (fl1 & fl2) == fl2;
    }

    /*
     *  fEqualMask - checks that all masked bits are equal
     */
    BOOL INLINE
        fEqualMaskFlFl(DWORD flMask, DWORD fl1, DWORD fl2)
    {
        return ((fl1 ^ fl2) & flMask) == 0;
    }

    /*
     * Words to keep preprocessor happy.
     */
#define comma ,
#define empty

    /*
     *  Atomically exchange one value for another.
     */
#if defined(_M_IA64) || defined(_M_AMD64)
#define InterlockedExchange64 _InterlockedExchange64
#ifndef RC_INVOKED
#pragma intrinsic(_InterlockedExchange64)
#endif /*RC_INVOKED*/
#define pvExchangePpvPv(ppv, pv) \
        InterlockedExchange((ppv), (pv))
#define pvExchangePpvPv64(ppv, pv) \
        InterlockedExchange64((PLONGLONG)(ppv), (LONGLONG)(pv))
#else /*_M_IA64*/
#define pvExchangePpvPv(ppv, pv) \
        (PV)InterlockedExchange((PLONG)(ppv), (LONG)(pv))
#define pvExchangePpvPv64(ppv, pv) \
        (PV)InterlockedExchange((PLONG)(ppv), (LONG)(pv))
#endif /*_M_IA64*/

    /*
     *  Creating HRESULTs from a USHORT or from a LASTERROR.
     */
#define hresUs(us) MAKE_HRESULT(SEVERITY_SUCCESS, 0, (USHORT)(us))
#define hresLe(le) MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, (USHORT)(le))
    /*
     *  or a registry function return code
     */
    HRESULT INLINE
        hresReg( LONG lRc )
    {
        return( (lRc) ? MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, (USHORT)(lRc))
                      : S_OK );
    }

    /***************************************************************************
     *
     *  Debugging macros needed by inline functions
     *
     *  The build of debugging goo is in debug.h
     *
     ***************************************************************************/

    int EXTERNAL AssertPtszPtszLn(LPCTSTR ptszExpr, LPCTSTR ptszFile, int iLine);

#ifdef DEBUG

    #define AssertFPtsz(c, ptsz) \
        ((c) ? 0 : AssertPtszPtszLn(ptsz, TEXT(__FILE__), __LINE__))
    #define ValidateF(c, arg) \
        ((c) ? 0 : (RPF arg, ValidationException(), 0))
    #define ConfirmF(c) \
    ((c) ? 0 : AssertPtszPtszLn(TEXT(#c), TEXT(__FILE__), __LINE__))

#else   /* !DEBUG */

    #define AssertFPtsz(c, ptsz)
    #define ValidateF(c, arg)
    #define ConfirmF(c)     (c)

#endif

    /*
     *  CAssertF - compile-time assertion.
     */
#define CAssertF(c)     switch(0) case c: case 0:

#define AssertF(c)      AssertFPtsz(c, TEXT(#c))

    /***************************************************************************
     *
     *                            Validation Code....
     *
     *  "If it crashes in retail, it must crash in debug."
     *
     *  What we don't want is an app that works fine under debug, but crashes
     *  under retail.
     *
     *  So if we find an invalid parameter in debug that would not have been
     *  detected by retail, let it pass through after a warning.  That way,
     *  the invalid parameter continues onward through the system and creates
     *  as much (or more) havoc in debug as it would under retail.
     *
     *  There used to be _fFastValidXxx functions, but the decision was made
     *  to do full validation always, except in inner-loop methods.
     *
     *  The hresFullValidXxx functions return HRESULTs instead of BOOLs.
     *
     *  Values for Xxx:
     *
     *      Hwnd      - hwnd = window handle
     *      Pdw       - pdw = pointer to a dword
     *      PdwOut    - pdw = pointer to a dword that will be set initially to 0
     *      Pfn       - pfn = function pointer
     *      riid      - riid = pointer to IID
     *      guid      - pguid = pointer to GUID
     *      Esc       - pesc = pointer to DIEFFESCAPE
     *
     *      ReadPx    - p -> structure for reading, X = structure name
     *      WritePx   - p -> structure for writing, X = structure name
     *
     *      ReadPxCb  - p -> structure for reading, X = structure name
     *                  first field of structure is dwSize which must be
     *                  equal to cbX(X).
     *
     *      WritePxCb - p -> structure for writing, X = structure name
     *                  first field of structure is dwSize which must be
     *                  equal to cbX(X).
     *
     *      WritePxCb2 - p -> structure for writing, X = structure name
     *                  first field of structure is dwSize which must be
     *                  equal to cbX(X) or cbX(X2).
     *
     *      ReadPvCb  - p -> buffer, cb = size of buffer
     *      WritePvCb - p -> buffer, cb = size of buffer
     *
     *      Pobj      - p -> internal interface
     *
     *      fl        - fl = incoming flags, flV = valid flags
     *
     ***************************************************************************/

#ifndef XDEBUG

    /*
     *  Wrappers that throw away the szProc and iarg info.
     */

    #define hresFullValidHwnd_(hwnd, z, i)                          \
       _hresFullValidHwnd_(hwnd)                                    \

    #define hresFullValidPcbOut_(pdw, cb, z, i)                         \
       _hresFullValidPcbOut_(pdw, cb)                                   \

    #define hresFullValidReadPxCb_(pv, cb, pszProc, iarg)           \
       _hresFullValidReadPxCb_(pv, cb)                              \

    #define hresFullValidReadPvCb_(pv, cb, pszProc, iarg)           \
       _hresFullValidReadPvCb_(pv, cb)                              \

    #define hresFullValidReadPxCb3_(pv, cb, cb2, cb3, pszProc, iarg)          \
       _hresFullValidReadPxCb3_(pv, cb, cb2, cb3)                   \

    #define hresFullValidWritePxCb_(pv, cb, pszProc, iarg)          \
       _hresFullValidWritePxCb_(pv, cb)                             \

    #define hresFullValidWritePxCb3_(pv, cb, cb2, cb3, pszProc, iarg)          \
       _hresFullValidWritePxCb3_(pv, cb, cb2, cb3)                  \

    #define hresFullValidWriteNoScramblePxCb_(pv, cb, pszProc, iarg)\
       _hresFullValidWriteNoScramblePxCb_(pv, cb)                   \

    #define hresFullValidWritePvCb_(pv, cb, pszProc, iarg)          \
       _hresFullValidWritePvCb_(pv, cb)                             \

    #define hresFullValidFl_(fl, flV, pszProc, iarg)                \
       _hresFullValidFl_(fl, flV)                                   \

    #define hresFullValidPfn_(pfn, pszProc, iarg)                   \
       _hresFullValidPfn_(pfn)                                      \

    #define hresFullValidPitf_(punk, pszProc, iarg)                 \
       _hresFullValidPitf_(punk)                                    \

    #define hresFullValidReadStrA_(psz, cch, pszProc, iarg)         \
       _hresFullValidReadStrA_(psz, cch)                            \

    #define hresFullValidReadStrW_(pwsz, cwch, pszProc, iarg)       \
       _hresFullValidReadStrW_(pwsz, cwch)                          \

    #define hresFullValidHwnd0_(hwnd, pszProc, iarg)                \
       _hresFullValidHwnd0_(hwnd)                                   \

    #define hresFullValidPitf0_(punk, pszProc, iarg)                \
       _hresFullValidPitf0_(punk)                                   \

    #define hresFullValidPesc_(pesc, pszProc, iarg)                 \
       _hresFullValidPesc_(pesc)                                    \

    #define hresFullValidWriteLargePvCb_(pv, cb, pszProc, iarg)     \
       _hresFullValidWriteLargePvCb_(pv, cb)                        \

#endif

    /*
     *  The actual functions.
     */

    STDMETHODIMP hresFullValidHwnd_(HWND hwnd, LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidPcbOut_(PV pdw, UINT cb, LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidReadPxCb_(PCV pv, UINT cb, LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidReadPvCb_(PCV pv, UINT cb, LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidReadPxCb3_(PV pv, UINT cb, UINT cb2, UINT cb3, LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidWritePxCb_(PV pv, UINT cb, LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidWritePxCb3_(PV pv, UINT cb, UINT cb2, UINT cb3, LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidWritePvCb_(PV pv, UINT cb, LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidFl_(DWORD fl, DWORD flV, LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidPfn_(FARPROC pfn, LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidPitf_(PUNK punk, LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidReadStrA_(LPCSTR psz, UINT cch,
                                        LPCSTR s_szProc, int iarg);
    STDMETHODIMP hresFullValidReadStrW_(LPCWSTR pwsz, UINT cwch,
                                        LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidPesc_(LPDIEFFESCAPE pesc, LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidWriteLargePvCb_(PV pv, UINT cb, LPCSTR pszProc, int iarg);

#ifdef XDEBUG

    STDMETHODIMP
        hresFullValidWriteNoScramblePxCb_(PV pv, UINT cb, LPCSTR s_szProc, int iarg);

    #define hresFullValidWriteNoScramblePvCb_(pv, cb, pszProc, iarg)    \
        hresFullValidWritePvCb_(pv, cb, pszProc, MAKELONG(iarg, 1)) \

#else

    /*
     *  Retail doesn't scramble.
     */
    #define _hresFullValidWriteNoScramblePxCb_  \
        _hresFullValidWritePxCb_                \

    #define _hresFullValidWriteNoScramblePxCb3_  \
        _hresFullValidWritePxCb3_                \

    #define hresFullValidWriteNoScramblePvCb_   \
        hresFullValidWritePvCb_                 \

#endif

    HRESULT INLINE
        hresFullValidHwnd0_(HWND hwnd, LPCSTR pszProc, int iarg)
    {
        HRESULT hres;
        if(hwnd)
        {
            hres = hresFullValidHwnd_(hwnd, pszProc, iarg);
        } else
        {
            hres = S_OK;
        }
        return hres;
    }

    HRESULT INLINE
        hresFullValidPitf0_(PUNK punk, LPCSTR pszProc, int iarg)
    {
        HRESULT hres;
        if(punk)
        {
            hres = hresFullValidPitf_(punk, pszProc, iarg);
        } else
        {
            hres = S_OK;
        }
        return hres;
    }

    /*
     *  Wrappers for derived types.
     */

#define hresFullValidRiid_(riid, s_szProc, iarg)                    \
        hresFullValidReadPvCb_(riid, cbX(IID), s_szProc, iarg)      \

    /*
     *  Wrapers that add the szProc and iarg info.
     */

#define hresFullValidHwnd(hwnd, iarg)                               \
        hresFullValidHwnd_(hwnd, s_szProc, iarg)                    \

#define hresFullValidPcbOut(pdw, cb, i)                             \
        hresFullValidPcbOut_(pdw, cb, s_szProc, i)                  \

#define hresFullValidReadPdw_(pdw, z, i)                            \
        hresFullValidReadPvCb_(pdw, cbX(DWORD), z, i)               \

#define hresFullValidRiid(riid, iarg)                               \
        hresFullValidRiid_(riid, s_szProc, iarg)                    \

#define hresFullValidGuid(pguid, iarg)                              \
        hresFullValidReadPvCb_(pguid, cbX(GUID), s_szProc, iarg)    \

#define hresFullValidReadPxCb(pv, X, iarg)                          \
        hresFullValidReadPxCb_(pv, cbX(X), s_szProc, iarg)          \

#define hresFullValidReadPxCb2(pv, X, X2, iarg)                     \
        hresFullValidReadPxCb_(pv, MAKELONG(cbX(X), cbX(X2)),       \
                               s_szProc, iarg)                      \

#define hresFullValidReadPvCb(pv, cb, iarg)                         \
        hresFullValidReadPvCb_(pv, cb, s_szProc, iarg)              \

#define hresFullValidReadPx(pv, X, iarg)                            \
        hresFullValidReadPvCb_(pv, cbX(X), s_szProc, iarg)          \

#define hresFullValidReadPxCb3(pv, X, X2, X3, iarg)                 \
        hresFullValidReadPxCb3_(pv, cbX(X), cbX(X2), cbX(X3),       \
                                s_szProc, iarg)                     \

#define hresFullValidWritePxCb(pv, X, iarg)                         \
        hresFullValidWritePxCb_(pv, cbX(X), s_szProc, iarg)         \

#define hresFullValidWritePxCb2(pv, X, X2, iarg)                    \
        hresFullValidWritePxCb_(pv, MAKELONG(cbX(X), cbX(X2)),      \
                                s_szProc, iarg)                     \

#define hresFullValidWritePxCb3(pv, X, X2, X3, iarg)                \
        hresFullValidWritePxCb3_(pv, cbX(X), cbX(X2), cbX(X3),      \
                                s_szProc, iarg)                     \

#define hresFullValidWriteNoScramblePxCb(pv, X, iarg)               \
        hresFullValidWriteNoScramblePxCb_(pv, cbX(X), s_szProc, iarg)\

#define hresFullValidWriteNoScramblePxCb2(pv, X, X2, iarg)          \
        hresFullValidWriteNoScramblePxCb_(pv, MAKELONG(cbX(X), cbX(X2)),\
                                s_szProc, iarg)\

#define hresFullValidWritePvCb(pv, cb, iarg)                        \
        hresFullValidWritePvCb_(pv, cb, s_szProc, iarg)             \

#define hresFullValidWriteNoScramblePvCb(pv, cb, iarg)              \
        hresFullValidWriteNoScramblePvCb_(pv, cb, s_szProc, iarg)   \

#define hresFullValidWritePx(pv, X, iarg)                           \
        hresFullValidWritePvCb_(pv, cbX(X), s_szProc, iarg)         \

#define hresFullValidReadPdw(pdw, iarg)                             \
        hresFullValidReadPdw_(pdw, s_szProc, iarg)                  \

#define hresFullValidWritePguid(pguid, iarg)                        \
        hresFullValidWritePx(pguid, GUID, iarg)                     \

#define hresFullValidFl(fl, flV, iarg)                              \
        hresFullValidFl_(fl, flV, s_szProc, iarg)                   \

#define hresFullValidPfn(pfn, iarg)                                 \
        hresFullValidPfn_((FARPROC)(pfn), s_szProc, iarg)           \

#define hresFullValidPitf(pitf, iarg)                               \
        hresFullValidPitf_((PUNK)(pitf), s_szProc, iarg)            \

#define hresFullValidReadStrA(psz, cch, iarg)                       \
        hresFullValidReadStrA_(psz, cch, s_szProc, iarg)            \

#define hresFullValidReadStrW(pwsz, cwch, iarg)                     \
        hresFullValidReadStrW_(pwsz, cwch, s_szProc, iarg)          \

#define hresFullValidHwnd0(hwnd, iarg)                              \
        hresFullValidHwnd0_(hwnd, s_szProc, iarg)                   \

#define hresFullValidPitf0(pitf, iarg)                              \
        hresFullValidPitf0_((PUNK)(pitf), s_szProc, iarg)           \

#define hresFullValidPesc(pesc, iarg)                               \
        hresFullValidPesc_(pesc, s_szProc, iarg)                    \

#define hresFullValidWriteLargePvCb(pv, cb, iarg)                   \
        hresFullValidWriteLargePvCb_(pv, cb, s_szProc, iarg)        \

    /*****************************************************************************
     *
     *  @doc INTERNAL
     *
     *  @func   void | ValidationException |
     *
     *          Raises a parameter validation exception in XDEBUG.
     *
     *****************************************************************************/

#define ecValidation (ERROR_SEVERITY_ERROR | hresLe(ERROR_INVALID_PARAMETER))

#ifdef XDEBUG
    #define ValidationException() RaiseException(ecValidation, 0, 0, 0)
#else
    #define ValidationException()
#endif

    /*****************************************************************************
     *
     *      Bilingualism
     *
     *      Special macros that help writing ANSI and UNICODE versions of
     *      the same underlying interface.
     *
     *****************************************************************************/

    /*
     *  _THAT is something you tack onto the end of a "bilingual" interface.
     *  In debug, it expands to the magic third argument which represents
     *  the vtbl the object should have.  In retail, it expands to nothing.
     */
#ifdef XDEBUG
    #define _THAT , PV vtblExpected
    #define THAT_ , vtblExpected
#else
    #define _THAT
    #define THAT_
#endif


    /*
     *  CSET_STUBS creates stubs for ANSI and UNICODE versions of the
     *  same procedure that is not character set-sensitive.
     *
     *  mf   - method function name
     *  arg1 - argument list in prototype form
     *  arg2 - argument list for calling (with _riid appended).
     *
     *  It is assumed that the caller has already defined the symbols
     *  ThisClass and ThisInterface[AWT].
     *
     *  This macro should be used only in DEBUG.  In retail, the common
     *  procedure handles both character sets directly.
     */
#ifdef XDEBUG

    #define   CSET_STUBS(mf, arg1, arg2)                                \
          CSET_STUB(TFORM, mf, arg1, arg2)                              \
          CSET_STUB(SFORM, mf, arg1, arg2)                              \

    #define   CSET_STUB(FORM, mf, arg1, arg2)                           \
         _CSET_STUB(FORM, mf, arg1, arg2, ThisClass, ThisInterface)     \

    #define  _CSET_STUB(FORM, mf, arg1, arg2, cls, itf)                 \
        __CSET_STUB(FORM, mf, arg1, arg2, cls, itf)                     \

    #define __CSET_STUB(FORM, mf, arg1, arg2, cls, itf)                 \
STDMETHODIMP                                                            \
FORM(cls##_##mf) arg1                                                   \
{                                                                       \
    PV vtblExpected = Class_Vtbl(ThisClass, FORM(ThisInterfaceT));      \
    return cls##_##mf arg2;                                             \
}                                                                       \

#endif

    /*
     * TFORM(x) expands to x##A if ANSI or x##W if UNICODE.
     *          This T-izes a symbol, in the sense of TCHAR or PTSTR.
     *
     * SFORM(x) expands to x##W if ANSI or x##A if UNICODE.
     *          This anti-T-izes a symbol.
     */

#ifdef UNICODE
    #define _TFORM(x) x##W
    #define _SFORM(x) x##A
#else
    #define _TFORM(x) x##A
    #define _SFORM(x) x##W
#endif

#define TFORM(x)    _TFORM(x)
#define SFORM(x)    _SFORM(x)

#ifdef UNICODE
    typedef  CHAR     SCHAR;
#else
    typedef WCHAR     SCHAR;
#endif

    typedef       SCHAR * LPSSTR;
    typedef const SCHAR * LPCSSTR;

    /*
     *  SToT(dst, cchDst, src) - convert S to T
     *  TToS(dst, cchDst, src) - convert T to S
     *
     *  Remember, "T" means "ANSI if ANSI, or UNICODE if UNICODE",
     *  and "S" is the anti-T.
     *
     *  So SToT converts to the preferred character set, and TToS converts
     *  to the alternate character set.
     *
     */

#define AToU(dst, cchDst, src) \
    MultiByteToWideChar(CP_ACP, 0, src, -1, dst, cchDst)
#define UToA(dst, cchDst, src) \
    WideCharToMultiByte(CP_ACP, 0, src, -1, dst, cchDst, 0, 0)

#ifdef UNICODE
    #define SToT AToU
    #define TToS UToA
    #define AToT AToU
    #define TToU(dst, cchDst, src)  lstrcpyn(dst, src, cchDst)
    #define UToT(dst, cchDst, src)  lstrcpyn(dst, src, cchDst)
#else
    #define SToT UToA
    #define TToS AToU
    #define AToT(dst, cchDst, src)  lstrcpyn(dst, src, cchDst)
    #define TToU AToU
    #define UToT UToA
#endif

    /*****************************************************************************
     *
     *      Unicode wrappers for Win95
     *
     *****************************************************************************/


#ifndef UNICODE

    #define LoadStringW     _LoadStringW
    int EXTERNAL LoadStringW(HINSTANCE hinst, UINT ids, LPWSTR pwsz, int cwch);

    #define RegDeleteKeyW   _RegDeleteKeyW
    LONG EXTERNAL RegDeleteKeyW(HKEY hk, LPCWSTR pwsz);

#endif

    /*****************************************************************************
     *
     *      Registry access functions
     *
     *****************************************************************************/

//our own version of KEY_ALL_ACCESS, that does not use WRITE_DAC and WRITE_OWNER (see Whistler bug 318865)
#define DI_DAC_OWNER (WRITE_DAC | WRITE_OWNER)
#define DI_KEY_ALL_ACCESS (KEY_ALL_ACCESS & ~DI_DAC_OWNER)

    LONG EXTERNAL
        RegQueryString(HKEY hk, LPCTSTR ptszValue, LPTSTR ptszBuf, DWORD ctchBuf);

    LONG EXTERNAL RegQueryStringValueW(HKEY hk, LPCTSTR ptszValue,
                                       LPWSTR pwszBuf, LPDWORD pcbBuf);

    LONG EXTERNAL RegSetStringValueW(HKEY hk, LPCTSTR ptszValue, LPCWSTR pwszBuf);

    DWORD EXTERNAL RegQueryDIDword(LPCTSTR ptszPath, LPCTSTR ptszValue, DWORD dwDefault);

    STDMETHODIMP
        hresMumbleKeyEx(HKEY hk, LPCTSTR ptszKey, REGSAM sam, DWORD dwOptions, PHKEY phk);

    STDMETHODIMP
        hresRegCopyValues( HKEY hkSrc, HKEY hkDest );

    STDMETHODIMP
        hresRegCopyKey( HKEY hkSrcRoot, PTCHAR szSrcName, PTCHAR szClass, HKEY hkDestRoot, PTCHAR szDestName, HKEY *phkSub );

    STDMETHODIMP
        hresRegCopyKeys( HKEY hkSrc, HKEY hkRoot, PDWORD OPTIONAL pMaxNameLen );

    STDMETHODIMP
        hresRegCopyBranch( HKEY hkSrc, HKEY hkDest );

    /*****************************************************************************
     *
     *      Common Object Managers for the Component Object Model
     *
     *      OLE wrapper macros and structures.  For more information, see
     *      the beginning of common.c
     *
     *****************************************************************************/

    /*****************************************************************************
     *
     *      Pre-vtbl structures
     *
     *      Careful!  If you change these structures, you must also adjust
     *      common.c accordingly.
     *
     *****************************************************************************/

    typedef struct PREVTBL
    {                /* Shared vtbl prefix */
        RIID riid;                          /* Type of this object */
        LONG lib;                          /* offset from start of object */
    } PREVTBL, *PPREVTBL;

    typedef struct PREVTBLP
    {               /* Prefix for primary vtbl */
#ifdef DEBUG
        LPCTSTR tszClass;                   /* Class name (for squirties) */
#endif
        PPV rgvtbl;                         /* Array of standard vtbls */
        UINT cbvtbl;                        /* Size of vtbl array in bytes */
        STDMETHOD(QIHelper)(PV pv, RIID riid, PPV ppvOut); /* QI helper */
        STDMETHOD_(void,AppFinalizeProc)(PV pv);/* App finalization procedure */
        STDMETHOD_(void,FinalizeProc)(PV pv);/* Finalization procedure */
        PREVTBL prevtbl;                    /* lib must be zero */
    } PREVTBLP, *PPREVTBLP;

    /*
     *      A fuller implementation is in common.c.  Out here, we need only
     *      concern ourselves with getting to the primary interface.
     */

#define _thisPv(pitf)                                                   \
        pvSubPvCb(pitf, (*(PPREVTBL*)(pitf))[-1].lib)

#define _thisPvNm(pitf, nm)                                             \
        pvSubPvCb(pitf, FIELD_OFFSET(ThisClass, nm))                    \

#ifndef XDEBUG

    #define hresPvVtbl_(pv, vtbl, pszProc)                              \
       _hresPvVtbl_(pv, vtbl)                                           \

#endif

    HRESULT EXTERNAL
        hresPvVtbl_(PV pv, PV vtbl, LPCSTR pszProc);

#define hresPvVtbl(pv, vtbl)                                            \
        hresPvVtbl_(pv, vtbl, s_szProc)                                 \

#define hresPvI(pv, I)                                                  \
        hresPvVtbl(pv, Class_Vtbl(ThisClass, I))                        \

#define hresPv(pv)                                                      \
        hresPvI(pv, ThisInterface)                                      \

#define hresPvA(pv)                                                     \
        hresPvI(pv, ThisInterfaceA)                                     \

#define hresPvW(pv)                                                     \
        hresPvI(pv, ThisInterfaceW)                                     \

#ifdef XDEBUG

    #define hresPvT(pv)                                                 \
        hresPvVtbl(pv, vtblExpected)                                    \

#else

    #define hresPvT(pv)                                                 \
        hresPv(pv)                                                      \

#endif

    /*****************************************************************************
     *
     *      Declaring interfaces
     *
     *      The extra level of indirection on _Primary_Interface et al
     *      allow the interface name to be a macro which expands to the
     *      *real* name of the interface.
     *
     *****************************************************************************/

#define __Class_Vtbl(C, I)              &c_##I##_##C##VI.vtbl
#define  _Class_Vtbl(C, I)            __Class_Vtbl(C, I)
#define   Class_Vtbl(C, I)             _Class_Vtbl(C, I)

#define Num_Interfaces(C)               cA(c_rgpv##C##Vtbl)

#ifdef  DEBUG

    #define Simple_Interface(C)             Primary_Interface(C, IUnknown); \
                                        Default_QueryInterface(C)       \
                                        Default_AddRef(C)               \
                                        Default_Release(C)
    #define Simple_Vtbl(C)                  Class_Vtbl(C)
    #define Simple_Interface_Begin(C)       Primary_Interface_Begin(C, IUnknown)
    #define Simple_Interface_End(C)         Primary_Interface_End(C, IUnknown)

#else

    #define Simple_Interface(C)             Primary_Interface(C, IUnknown)
    #define Simple_Vtbl(C)                  Class_Vtbl(C)
    #define Simple_Interface_Begin(C)                                   \
        struct S_##C##Vtbl c_##I##_##C##VI = { {                        \
            c_rgpv##C##Vtbl,                                            \
            cbX(c_rgpv##C##Vtbl),                                       \
            C##_QIHelper,                                               \
            C##_AppFinalize,                                            \
            C##_Finalize,                                               \
            { &IID_##IUnknown, 0 },                                     \
        }, {                                                            \
            Common##_QueryInterface,                                    \
            Common##_AddRef,                                            \
            Common##_Release,                                           \

    #define Simple_Interface_End(C)                                     \
        } };                                                            \

#endif

#define _Primary_Interface(C, I)                                        \
        extern struct S_##C##Vtbl {                                     \
            PREVTBLP prevtbl;                                           \
            I##Vtbl vtbl;                                               \
        } c_##I##_##C##VI                                               \

#define Primary_Interface(C, I)                                         \
       _Primary_Interface(C, I)                                         \

#ifdef DEBUG
    #define _Primary_Interface_Begin(C, I)                              \
        struct S_##C##Vtbl c_##I##_##C##VI = { {                        \
            TEXT(#C),                                                   \
            c_rgpv##C##Vtbl,                                            \
            cbX(c_rgpv##C##Vtbl),                                       \
            C##_QIHelper,                                               \
            C##_AppFinalize,                                            \
            C##_Finalize,                                               \
            { &IID_##I, 0, },                                           \
        }, {                                                            \
            C##_QueryInterface,                                         \
            C##_AddRef,                                                 \
            C##_Release,                                                \

#else
    #define _Primary_Interface_Begin(C, I)                              \
        struct S_##C##Vtbl c_##I##_##C##VI = { {                        \
            c_rgpv##C##Vtbl,                                            \
            cbX(c_rgpv##C##Vtbl),                                       \
            C##_QIHelper,                                               \
            C##_AppFinalize,                                            \
            C##_Finalize,                                               \
            { &IID_##I, 0, },                                           \
        }, {                                                            \
            C##_QueryInterface,                                         \
            C##_AddRef,                                                 \
            C##_Release,                                                \

#endif

#define Primary_Interface_Begin(C, I)                                   \
       _Primary_Interface_Begin(C, I)                                   \

#define Primary_Interface_End(C, I)                                     \
        } };                                                            \

#define _Secondary_Interface(C, I)                                      \
        extern struct S_##I##_##C##Vtbl {                               \
            PREVTBL prevtbl;                                            \
            I##Vtbl vtbl;                                               \
        } c_##I##_##C##VI                                               \

#define Secondary_Interface(C, I)                                       \
       _Secondary_Interface(C, I)                                       \

    /*
     *  Secret backdoor for the "private" IUnknown in common.c
     */
#define _Secondary_Interface_Begin(C, I, ofs, Pfx)                      \
        struct S_##I##_##C##Vtbl c_##I##_##C##VI = { {                  \
            &IID_##I,                                                   \
            ofs,                                                        \
        }, {                                                            \
            Pfx##QueryInterface,                                        \
            Pfx##AddRef,                                                \
            Pfx##Release,                                               \

#define Secondary_Interface_Begin(C, I, nm)                             \
       _Secondary_Interface_Begin(C, I, FIELD_OFFSET(C, nm), Common_)   \

#define _Secondary_Interface_End(C, I)                                  \
        } };                                                            \

#define Secondary_Interface_End(C, I, nm)                               \
       _Secondary_Interface_End(C, I)                                   \

#define Interface_Template_Begin(C)                                     \
        PV c_rgpv##C##Vtbl[] = {                                        \

#define Primary_Interface_Template(C, I)                                \
        Class_Vtbl(C, I),                                               \

#define Secondary_Interface_Template(C, I)                              \
        Class_Vtbl(C, I),                                               \

#define Interface_Template_End(C)                                       \
        };                                                              \


    STDMETHODIMP Common_QueryInterface(PV, RIID, PPV);
    STDMETHODIMP_(ULONG) Common_AddRef(PV pv);
    STDMETHODIMP_(ULONG) Common_Release(PV pv);

    STDMETHODIMP_(void) Common_Hold(PV pv);
    STDMETHODIMP_(void) Common_Unhold(PV pv);

    STDMETHODIMP Common_QIHelper(PV, RIID, PPV);
    void EXTERNAL Common_Finalize(PV);

#define Common_AppFinalize      Common_Finalize

#ifndef XDEBUG

    #define _Common_New_(cb, punkOuter, vtbl, pvpObj, z)            \
       __Common_New_(cb, punkOuter, vtbl, pvpObj)                   \

    #define _Common_NewRiid_(cb, vtbl, punkOuter, riid, pvpObj, z)  \
       __Common_NewRiid_(cb, vtbl, punkOuter, riid, pvpObj)         \

#endif

    STDMETHODIMP
        _Common_New_(ULONG cb, PUNK punkOuter, PV vtbl, PPV ppvObj, LPCSTR s_szProc);

    STDMETHODIMP
        _Common_NewRiid_(ULONG cb, PV vtbl, PUNK punkOuter, RIID riid, PPV pvpObj,
                         LPCSTR s_szProc);

#define Common_NewCb(cb, C, punkOuter, ppvObj)                          \
       _Common_New_(cb, punkOuter, Class_Vtbl(C, ThisInterface), ppvObj, s_szProc)

#define Common_New(C, punkOuter, ppvObj)                                \
        Common_NewCb(cbX(C), C, punkOuter, ppvObj)                      \

#define Common_NewCbRiid(cb, C, punkOuter, riid, ppvObj) \
       _Common_NewRiid_(cb, Class_Vtbl(C, ThisInterface), punkOuter, riid, ppvObj, s_szProc)

#define Common_NewRiid(C, punkOuter, riid, ppvObj) \
   _Common_NewRiid_(cbX(C), Class_Vtbl(C, ThisInterface), punkOuter, riid, ppvObj, s_szProc)

#ifdef DEBUG
    PV EXTERNAL Common_IsType(PV pv);
#else
    #define Common_IsType
#endif
#define Assert_CommonType Common_IsType

    STDMETHODIMP Forward_QueryInterface(PV pv, RIID riid, PPV ppvObj);
    STDMETHODIMP_(ULONG) Forward_AddRef(PV pv);
    STDMETHODIMP_(ULONG) Forward_Release(PV pv);

    void EXTERNAL Invoke_Release(PV pv);

#define Common_DumpObjects()

    /*****************************************************************************
     *
     *      OLE wrappers
     *
     *      These basically do the same as IUnknown_Mumble, except that they
     *      avoid side-effects in evaluation by being inline functions.
     *
     *****************************************************************************/

    HRESULT INLINE
        OLE_QueryInterface(PV pv, RIID riid, PPV ppvObj)
    {
        PUNK punk = pv;
        return punk->lpVtbl->QueryInterface(punk, riid, ppvObj);
    }

    ULONG INLINE
        OLE_AddRef(PV pv)
    {
        PUNK punk = pv;
        return punk->lpVtbl->AddRef(punk);
    }

    ULONG INLINE
        OLE_Release(PV pv)
    {
        PUNK punk = pv;
        return punk->lpVtbl->Release(punk);
    }

    /*****************************************************************************
     *
     *      Macros that forward to the common handlers after squirting.
     *      Use these only in DEBUG.
     *
     *      It is assumed that sqfl has been #define'd to the appropriate sqfl.
     *
     *****************************************************************************/

#ifdef  DEBUG

    #define Default_QueryInterface(Class)                       \
STDMETHODIMP                                                    \
Class##_QueryInterface(PV pv, RIID riid, PPV ppvObj)            \
{                                                               \
    SquirtSqflPtszV(sqfl, TEXT(#Class) TEXT("_QueryInterface()")); \
    return Common_QueryInterface(pv, riid, ppvObj);             \
}                                                               \

// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
    #define Default_AddRef(Class)                               \
STDMETHODIMP_(ULONG)                                            \
Class##_AddRef(PV pv)                                           \
{                                                               \
    ULONG ulRc = Common_AddRef(pv);                             \
    SquirtSqflPtszV(sqfl, TEXT(#Class) TEXT("_AddRef(%p) -> %d"), pv, ulRc); \
    return ulRc;                                                \
}                                                               \

// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.    
    #define Default_Release(Class)                              \
STDMETHODIMP_(ULONG)                                            \
Class##_Release(PV pv)                                          \
{                                                               \
    ULONG ulRc = Common_Release(pv);                            \
    SquirtSqflPtszV(sqfl, TEXT(#Class) TEXT("_Release(%p) -> %d"), pv, ulRc); \
    return ulRc;                                                \
}                                                               \

#endif

    /*****************************************************************************
     *
     *      Paranoid callbacks
     *
     *      Callback() performs a callback.  The callback must accept exactly
     *      two parameters, both pointers.  (All our callbacks are like this.)
     *      And it must return a BOOL.
     *
     *****************************************************************************/

    typedef BOOL (FAR PASCAL * DICALLBACKPROC)(LPVOID, LPVOID);

#ifdef XDEBUG
    BOOL EXTERNAL Callback(DICALLBACKPROC, PVOID, PVOID);
#else
    #define Callback(pec, pv1, pv2) pec(pv1, pv2)
#endif

#if 0
    /*****************************************************************************
     *
     *      Groveling into a CONTEXT structure.
     *
     *      This is used to check that a callback procedure is properly
     *      prototyped.  We save the stack register before calling the
     *      procedure and compare it with the stack register on the way back.
     *      If they are different, explode!
     *
     *      ctxEsp is the name of the stack pointer register.
     *
     *****************************************************************************/

    typedef struct STACKINFO
    {
        CONTEXT ctxPre;             /* Thread context before call */
        CONTEXT ctxPost;            /* Thread context after call */
    } STACKINFO, *PSTACKINFO;

    #ifdef XDEBUG

        #if defined(_X86_)
            #define ctxEsp  Esp

        #elif defined(_ALPHA_)
            #define ctxEsp  IntSp

        #elif defined(_MIPS_)
            #define ctxEsp  IntSp

        #elif defined(_PPC_)
            #define ctxEsp  Gpr1

        #else
            #pragma message("I don't know what the stack register is called on this platform")
        #endif

    #endif

    #ifdef ctxEsp

        #define DECLARE_STACKINFO()                                         \
    STACKINFO si                                                            \

        #define PRE_CALLBACK()                                              \
    si.ctxPre.ContextFlags = CONTEXT_CONTROL;                               \
    GetThreadContext(GetCurrentThread(), &si.ctxPre)                        \

        #define POST_CALLBACK()                                             \
    si.ctxPost.ContextFlags = CONTEXT_CONTROL;                              \
    if (GetThreadContext(GetCurrentThread(), &si.ctxPost) &&                \
        si.ctxPre.ctxEsp != si.ctxPost.ctxEsp) {                            \
        RPF("DINPUT: Incorrectly prototyped callback! Crash soon!");        \
        ValidationException();                                              \
    }                                                                       \

    #else

        #define DECLARE_STACKINFO()
        #define PRE_CALLBACK()
        #define POST_CALLBACK()

    #endif

#endif

    /*****************************************************************************
     *
     *      Alternative message cracker macros
     *
     *      Basically the same as HANDLE_MSG, except that it stashes the
     *      answer into hres.
     *
     *****************************************************************************/

#define HRES_MSG(this, msg, fn) \
    case msg: hres = HANDLE_##msg(this, wParam, lParam, fn); break

    /*****************************************************************************
     *
     *      Registry keys and value names
     *
     *****************************************************************************/

#define REGSTR_PATH_DINPUT      TEXT("Software\\Microsoft\\DirectInput")
#define REGSTR_KEY_APPHACK      TEXT("Compatibility")
#define REGSTR_KEY_TEST         TEXT("Test")
#define REGSTR_KEY_KEYBTYPE     REGSTR_KEY_TEST TEXT("\\KeyboardType")
#define REGSTR_VAL_EMULATION    TEXT("Emulation")
#define REGSTR_VAL_GAMEPADDELAY TEXT("GamepadDelay")
#define REGSTR_VAL_JOYNFFCONFIG TEXT("Joystick%dFFConfiguration")
#define REGSTR_VAL_JOYGAMEPORTEMULATOR TEXT("OEMEmulator")
#define REGSTR_VAL_CPLCLSID     TEXT("ConfigCLSID")
#define REGSTR_KEY_JOYPREDEFN   TEXT("predef%d")
#define REGSTR_VAL_JOYOEMCALLOUT TEXT("OEMCallout")
#define REGSTR_VAL_JOYOEMHARDWAREID TEXT("OEMHardwareID")
#define REGSTR_VAL_FLAGS1       TEXT("Flags1")
#define REGSTR_VAL_FLAGS2       TEXT("Flags2")

#define REGSTR_PATH_DITYPEPROP  REGSTR_PATH_PRIVATEPROPERTIES TEXT("\\DirectInput")
#define REGSTR_VAL_JOYOEMMAPFILE TEXT("OEMMapFile")

    /*****************************************************************************
     *
     *      Registered window messages
     *
     *****************************************************************************/

#define MSGSTR_JOYCHANGED       TEXT("MSJSTICK_VJOYD_MSGSTR")

    /*****************************************************************************
     *
     *      mem.c - Memory management
     *
     *      Be extremely careful with FreePv, because it doesn't work if
     *      the pointer is null.
     *
     *****************************************************************************/

#define NEED_REALLOC

    STDMETHODIMP EXTERNAL ReallocCbPpv(UINT cb, PV ppvObj);
    STDMETHODIMP EXTERNAL AllocCbPpv(UINT cb, PV ppvObj);

#ifdef NEED_REALLOC
    #define FreePpv(ppv) (void)ReallocCbPpv(0, ppv)
#else
    void EXTERNAL FreePpv(PV ppv);
    #define FreePpv(ppv) FreePpv(ppv)
#endif
#define FreePv(pv) LocalFree((HLOCAL)(pv))

    /*****************************************************************************
     *
     *      diutil.c - Misc utilities
     *
     *****************************************************************************/

    extern GUID GUID_Null;

#define ctchGuid    (1 + 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)

    BOOL EXTERNAL ParseGUID(LPGUID pGUID, LPCTSTR ptsz);
    BOOL EXTERNAL ParseVIDPID(PUSHORT puVID, PUSHORT puPID , LPCWSTR ptsz);

#define ctchNamePrefix  12              /* 12 = strlen("DirectInput.") */
#define ctchNameGuid    (ctchNamePrefix + ctchGuid)
    void EXTERNAL NameFromGUID(LPTSTR ptszBuf, PCGUID pGUID);

    typedef STDMETHOD(CREATEDCB)(PUNK, REFGUID, RIID, PPV);

    typedef struct DIOBJECTSTATICDATA
    {
        union
        {
            PCGUID rguidInstance;       /* If a static device */
            UINT   uiButtons;           /* If a HID mouse */
        };
        DWORD   dwDevType;
        union
        {
            CREATEDCB CreateDcb;        /* If a static device */
            UINT      uiAxes;           /* If a HID mouse */
        };
    } DIOBJECTSTATICDATA, *PDIOBJECTSTATICDATA, **PPDIOBJECTSTATICDATA;

    HRESULT EXTERNAL hresRunControlPanel(LPCTSTR ptszCpl);

    HRESULT EXTERNAL DiActionFormatAtoW(const LPDIACTIONFORMATA lpDiAfA,
                                        LPDIACTIONFORMATW* lplpDiAfW);
    
    HRESULT EXTERNAL DiActionFormatWtoW(const LPDIACTIONFORMATW lpDiAfW0,
                                        LPDIACTIONFORMATW* lplpDiAfW);

    void FreeDiActionFormatW(LPDIACTIONFORMATW* lplpDiAfW );


    void EXTERNAL ObjectInfoWToA(LPDIDEVICEOBJECTINSTANCEA pdoiA,
                                 LPCDIDEVICEOBJECTINSTANCEW pdoiW);

    void EXTERNAL EffectInfoWToA(LPDIEFFECTINFOA pdeiA,
                                 LPCDIEFFECTINFOW pdeiW);


#ifndef XDEBUG

    #define hresFindInstanceGUID_(pGUID, pcdcb, z, i)               \
       _hresFindInstanceGUID_(pGUID, pcdcb)                         \

    #define hresValidInstanceVer_(hinst, dwVer, z)                  \
       _hresValidInstanceVer_(hinst, dwVer)                         \

#endif

    HRESULT EXTERNAL hresFindInstanceGUID_(PCGUID pGUID, CREATEDCB *pcdcb,
                                           LPCSTR s_szProc, int iarg);

    HRESULT EXTERNAL
        hresValidInstanceVer_(HINSTANCE hinst, DWORD dwVersion, LPCSTR s_szProc);

#define hresFindInstanceGUID(pGuid, pcdcb, iarg)                    \
        hresFindInstanceGUID_(pGuid, pcdcb, s_szProc, iarg)         \

#define hresValidInstanceVer(hinst, dwVer)                          \
        hresValidInstanceVer_(hinst, dwVer, s_szProc)               \

    HRESULT EXTERNAL DupEventHandle(HANDLE h, LPHANDLE phOut);
    DWORD EXTERNAL GetWindowPid(HWND hwnd);

    PV EXTERNAL pvFindResource(HINSTANCE hinst, DWORD id, LPCTSTR rt);

    void EXTERNAL GetNthString(LPWSTR pwsz, UINT ids, UINT ui);

#define GetNthButtonString(pwsz, ui)    \
        GetNthString(pwsz, IDS_BUTTONTEMPLATE, ui)

#define GetNthAxisString(pwsz, ui)      \
        GetNthString(pwsz, IDS_AXISTEMPLATE, ui)

#define GetNthPOVString(pwsz, ui)       \
        GetNthString(pwsz, IDS_POVTEMPLATE, ui)

    HRESULT EXTERNAL hresDupPtszPptsz(LPCTSTR ptszSrc, LPTSTR *pptszDst);

    BOOL EXTERNAL fInitializeCriticalSection(LPCRITICAL_SECTION pCritSec);

    void EXTERNAL DiCharUpperW(LPWSTR pwsz);

    typedef int ( __stdcall * COMP_FUNC )( PV, PV );

    void ptrPartialQSort( PPV ppL, PPV ppR, COMP_FUNC fpCompare );

    void ptrInsertSort( PPV ppBase, PPV ppLast, COMP_FUNC fpCompare );

    void __cdecl shortsort (char *lo,char *hi,unsigned width,int (__cdecl *comp)(const void *, const void *));

    STDMETHODIMP GetWideUserName
    (
    LPCSTR lpszUserName,
    LPCWSTR lpwszUserName,
    LPWSTR  *ppwszGoodUserName
    );

    DWORD EXTERNAL GetValidDI8DevType
    (   
    DWORD dwDevType,
    DWORD dwNumButtons,
    DWORD dwFlags
    );

    HRESULT DIGetKeyNameText( UINT index, DWORD dwDevType, LPWSTR lpwszName, int nSize );

#define WIN_UNKNOWN_OS 0
#define WIN95_OS       1
#define WIN98_OS       2
#define WINME_OS       3
#define WINNT_OS       4
#define WINWH_OS       5

    DWORD INTERNAL DIGetOSVersion();

    /*****************************************************************************
     *
     *      dilist.c
     *
     *****************************************************************************/

    /*****************************************************************************
     *
     *  @doc    INTERNAL
     *
     *  @struct GPA |
     *
     *          Growable pointer array.
     *
     *  @field  PPV | rgpv |
     *
     *          The base of the array of pointers.
     *
     *  @field  int | cpv |
     *
     *          The number of pointers in use in the array.
     *
     *  @field  int | cpvAlloc |
     *
     *          The number of pointers allocated in the array.
     *
     *****************************************************************************/

    typedef struct GPA
    {

        PPV rgpv;
        int cpv;
        int cpvAlloc;

    } GPA, *HGPA;

    void EXTERNAL GPA_Init(HGPA hgpa);
    void EXTERNAL GPA_Term(HGPA hgpa);

    STDMETHODIMP GPA_Append(HGPA hgpa, PV pv);
    BOOL EXTERNAL GPA_FindPtr(HGPA hgpa, PV pv);
    STDMETHODIMP GPA_DeletePtr(HGPA hgpa, PV pv);
    STDMETHODIMP GPA_Clone(HGPA hgpaDst, HGPA hgpaSrc);

    /*****************************************************************************
     *
     *  @doc    INTERNAL
     *
     *  @func   void | GPA_InitFromZero |
     *
     *          Initialize a GPA structure that is already zero-initialized.
     *
     *  @parm   HGPA | hgpa |
     *
     *          Handle to pointer array.
     *
     *****************************************************************************/

    /*
     *  Nothing needs to be done; zero-init is just fine.
     *
     *  Note: didev.c also has a global GPA, and it assumes that zero-init
     *  is just fine.
     */
#define GPA_InitFromZero(hgpa)

    /*****************************************************************************
     *
     *      dioledup.c
     *
     *****************************************************************************/

    STDMETHODIMP
        DICoCreateInstance(LPTSTR ptszClsid, LPUNKNOWN punkOuter,
                           RIID riid, PPV ppvOut, HINSTANCE *phinst);

    /*****************************************************************************
     *
     *      diexcl.c - Exclusive access management
     *
     *      We also keep GUID uniqueness goo up here, because it is
     *      diexcl.c that manages shared memory.
     *
     *****************************************************************************/

    STDMETHODIMP Excl_Acquire(PCGUID pguid, HWND hwnd, DWORD discl);
    void EXTERNAL Excl_Unacquire(PCGUID pguid, HWND hwnd, DWORD discl);
    STDMETHODIMP Excl_Init(void);

    LONG  EXTERNAL Excl_UniqueGuidInteger(void);
    DWORD EXTERNAL Excl_GetConfigChangedTime();
    void  EXTERNAL Excl_SetConfigChangedTime(DWORD tm);

    /*****************************************************************************
     *
     *  @doc    INTERNAL
     *
     *  @struct GLOBALJOYSTATE |
     *
     *          Structure that records global joystick state information.
     *
     *  @field  DWORD | dwTag |
     *
     *          Counter used to keep track of how many times each joystick's
     *          force feedback driver has been reset.  This is used to make
     *          sure that nobody messes with a joystick that he doesn't own.
     *
     *          Each time the joystick is reset, the corresponding counter
     *          is incremented.  Before we do anything to a device, we check
     *          if the reset counter matches the value stored in the
     *          object.  If not, then it means that the device has been
     *          reset in the meantime and no longer belongs to the caller.
     *
     *  @field  DWORD | dwCplGain |
     *
     *          Control panel (global) gain setting for the joystick.
     *
     *  @field  DWORD | dwDevGain |
     *
     *          Most recent device (local) gain applied to the joystick.
     *
     *          This is cached so that when the global gain changes,
     *          we know what physical gain to apply as a result.
     *
     *****************************************************************************/

    typedef struct GLOBALJOYSTATE
    {
        DWORD   dwTag;
        DWORD   dwCplGain;
        DWORD   dwDevGain;
    } GLOBALJOYSTATE, *PGLOBALJOYSTATE;

    /*****************************************************************************
     *
     *  @doc    INTERNAL
     *
     *  @struct SHAREDOBJECTHEADER |
     *
     *          A simple header comes in front of the array of objects.
     *
     *          WARNING!  This structure may not change between DEBUG and
     *          RETAIL.  Otherwise, you have problems if one DirectInput
     *          app is using DEBUG and another is using RETAIL.
     *
     *          The global <c g_gsop> variable points to one of these things,
     *          suitably cast.
     *
     *  @field  int | cso |
     *
     *          Number of <t SHAREDOBJECT>s currently in use.  The array
     *          is kept packed for simplicity.
     *
     *  @field  DWORD | dwSequence |
     *
     *          Global sequence number used during data collection.
     *          (Not used if we have a VxD to manage a "really global"
     *          sequence number.)
     *
     *  @field  int | cguid |
     *
     *          Unique integer for GUID generation.
     *
     *  @field  DWORD | rgdwJoy[cMaxJoy] |
     *
     *          Counter used to keep track of how many times each joystick's
     *          force feedback driver has been reset.  This is used to make
     *          sure that nobody messes with a joystick that they don't own.
     *
     *          Each time the joystick is reset, the corresponding counter
     *          is incremented.  Before we do anything to a device, we check
     *          if the reset counter matches the value stored in the
     *          object.  If not, then it means that the device has been
     *          reset in the meantime and no longer belongs to the caller.
     *
     *          Note!  We support up to 16 joysticks.  Hope that'll be enough
     *          for a while.
     *
     *  @field  GLOBALJOYSTATE | rggjs[cMaxJoy] |
     *
     *          Global settings for each joystick.
     *
     *  @field  DWORD | tmConfigChanged
     *
     *          The tick count of last config changed.
     *
     *****************************************************************************/

#define cJoyMax     16              /* Up to 16 joysticks */
    typedef struct SHAREDOBJECTHEADER
    {
        int cso;
        DWORD dwSequence;
        int cguid;
        GLOBALJOYSTATE rggjs[cJoyMax];
        DWORD tmConfigChanged;
    } SHAREDOBJECTHEADER, *PSHAREDOBJECTHEADER;

#define g_psoh  ((PSHAREDOBJECTHEADER)g_psop)

    /*****************************************************************************
     *
     *  @doc    INTERNAL
     *
     *  @topic  The Worker Thread |
     *
     *          Some emulation behaviors (low-level hooks, HID) require
     *          a worker thread to do the data collection.  We multiplex
     *          all such work onto a single worker thread (known as
     *          simple "the" worker thread).
     *
     *          The thread is spun up when the first client needs it
     *          and is taken down when the last client has been released.
     *
     *          To prevent race conditions from crashing us, we addref
     *          our DLL when the thread exists and have the thread
     *          perform a FreeLibrary as its final act.
     *
     *****************************************************************************/

    #define WORKER_THREAD

    /*****************************************************************************
     *
     *      diem.c - Emulation
     *
     *****************************************************************************/

    HRESULT EXTERNAL CEm_AcquireInstance(PVXDINSTANCE *ppvi);
    HRESULT EXTERNAL CEm_UnacquireInstance(PVXDINSTANCE *ppvi);
    HRESULT EXTERNAL CEm_SetBufferSize(PVXDDWORDDATA pvdd);
    HRESULT EXTERNAL CEm_DestroyInstance(PVXDINSTANCE *ppvi);

    HRESULT EXTERNAL CEm_SetDataFormat(PVXDDATAFORMAT pvdf);

    HRESULT EXTERNAL CEm_Mouse_CreateInstance(PVXDDEVICEFORMAT pdevf,
                                              PVXDINSTANCE *ppviOut);

    HRESULT EXTERNAL CEm_Mouse_InitButtons(PVXDDWORDDATA pvdd);

    HRESULT EXTERNAL CEm_Kbd_CreateInstance(PVXDDEVICEFORMAT pdevf,
                                            PVXDINSTANCE *ppviOut);

    HRESULT EXTERNAL CEm_Kbd_InitKeys(PVXDDWORDDATA pvdd);

    HRESULT EXTERNAL CEm_Joy_CreateInstance(PVXDDEVICEFORMAT pdevf,
                                            PVXDINSTANCE *ppviOut);

    HRESULT EXTERNAL CEm_Joy_Ping(PVXDINSTANCE *ppvi);

    HRESULT EXTERNAL CEm_HID_CreateInstance(PVXDDEVICEFORMAT pdevf,
                                            PVXDINSTANCE *ppviOut);

    /*****************************************************************************
     *
     *      diemm.c - Mouse Emulation
     *
     *****************************************************************************/

    void EXTERNAL    CEm_Mouse_AddState(LPDIMOUSESTATE_INT pms, DWORD tm);

    /*****************************************************************************
     *
     *      dinput.c - Basic DLL stuff
     *
     *****************************************************************************/

    void EXTERNAL DllEnterCrit_(LPCTSTR lptszFile, UINT line);
    void EXTERNAL DllLeaveCrit_(LPCTSTR lptszFile, UINT line);

#ifdef DEBUG
    BOOL EXTERNAL DllInCrit(void);
    #define DllEnterCrit() DllEnterCrit_(TEXT(__FILE__), __LINE__)
    #define DllLeaveCrit() DllLeaveCrit_(TEXT(__FILE__), __LINE__)
#else
    #define DllEnterCrit() DllEnterCrit_(NULL, 0x0)
    #define DllLeaveCrit() DllLeaveCrit_(NULL, 0x0)
#endif

    void EXTERNAL DllAddRef(void);
    void EXTERNAL DllRelease(void);

    BOOL EXTERNAL DllLoadLibrary(void);
    void EXTERNAL DllFreeLibrary(void);

#ifdef DEBUG

    extern UINT g_thidCrit;

    #define InCrit() (g_thidCrit == GetCurrentThreadId())

#endif

    /*
     *  Describes the CLSIDs we provide to OLE.
     */

    typedef STDMETHOD(CREATEFUNC)(PUNK punkOuter, RIID riid, PPV ppvOut);

    typedef struct CLSIDMAP
    {
        REFCLSID rclsid;        /* The clsid */
        CREATEFUNC pfnCreate;   /* How to create it */
        UINT    ids;            /* String that describes it */
    } CLSIDMAP, *PCLSIDMAP;

#ifdef DEBUG
    #define DEMONSTRATION_FFDRIVER
#ifdef DOWNLEVEL_COM
    #define cclsidmap   5       /* DirectInput, DirectInputDevice, DirectInput8, DirectInputDevice8, DIEffectDiver */
#else
    #define cclsidmap   3       /* DirectInput8, DirectInputDevice8, DIEffectDiver */
#endif
#else
#ifdef DOWNLEVEL_COM
    #define cclsidmap   4       /* CLSID_DirectInput, CLSID_DirectInputDevice, CLSID_DirectInput8, CLSID_DirectInputDevice8 */
#else
    #define cclsidmap   2       /* CLSID_DirectInput8, CLSID_DirectInputDevice8 */
#endif
#endif

    extern CLSIDMAP c_rgclsidmap[cclsidmap];

    /*****************************************************************************
     *
     *      dicf.c - IClassFactory implementation
     *
     *****************************************************************************/

    STDMETHODIMP CDIFactory_New(CREATEFUNC pfnCreate, RIID riid, PPV ppvObj);

    /*****************************************************************************
     *
     *      didenum.c - IDirectInput device enumeration
     *
     *****************************************************************************/
    
    typedef struct _CDIDEnum CDIDEnum;

    extern GUID rgGUID_Joystick[cJoyMax];

#define GUID_Joystick (rgGUID_Joystick[0])

    void EXTERNAL CDIDEnum_Release(CDIDEnum *pde);
    STDMETHODIMP CDIDEnum_Next(CDIDEnum *pde, LPDIDEVICEINSTANCEW pddiW);
    STDMETHODIMP CDIDEnum_InternalNext(CDIDEnum *pde, LPDIDEVICEINSTANCEW pddiW, LPDIRECTINPUTDEVICE8W *ppdid8W);
    STDMETHODIMP CDIDEnum_New(PDIW pdiW, DWORD dwDevType, DWORD edfl, DWORD dwVer, CDIDEnum **);

    /*****************************************************************************
     *
     *      diobj.c - IDirectInput implementation
     *
     *****************************************************************************/

    HRESULT EXTERNAL CDIObj_TestDeviceFlags(PDIDW pdidW, DWORD diedfl);
    HRESULT EXTERNAL CDIObj_TestDeviceFlagsInternal(PDIDW pdidW, DWORD diedfl);
    HRESULT EXTERNAL CDIObj_FindDeviceInternal(LPCTSTR ptszName, LPGUID pguidOut);

    STDMETHODIMP CDIObj_New(PUNK punkOuter, RIID riid, PPV ppvOut);

    typedef struct _DIMAPPER {
        LPCWSTR                  lpszUserName;
        LPDIACTIONFORMATW        pDiActionFormat;
        LPDIENUMDEVICESBYSEMANTICSCBW pecW;
        LPVOID                   pvRef;
        DWORD                    dwFlags;
    } DIMAPPER, *LPDIMAPPER;

    typedef struct _DIORDERDEV {
        DWORD dwOrder;
        DWORD dwFlags;
        LPDIRECTINPUTDEVICE8W pdid8W;
        DIDEVICEINSTANCEW ddiW;
        FILETIME ftTimeStamp;
    } DIORDERDEV, *LPDIORDERDEV;

    /*****************************************************************************
     *
     *      diaddhw.c - AddNewHardware
     *
     *****************************************************************************/

    HRESULT EXTERNAL AddNewHardware(HWND hwnd, REFGUID rguid);

    /*****************************************************************************
     *
     *      dijoycfg.c - IDirectInputJoyConfig implementation
     *
     *****************************************************************************/

    STDMETHODIMP CJoyCfg_New(PUNK punkOuter, RIID riid, PPV ppvOut);

    /*****************************************************************************
     *
     *  @doc    INLINE
     *
     *  @method BOOL | IsWriteSam |
     *
     *          Nonzero if the registry security access mask will
     *          obtain (or attempt to obtain) write access.
     *
     *  @parm   REGSAM | regsam |
     *
     *          Registry security access mask.
     *
     *****************************************************************************/

    BOOL INLINE
        IsWriteSam(REGSAM sam)
    {
        return sam & (KEY_SET_VALUE | KEY_CREATE_SUB_KEY | MAXIMUM_ALLOWED);
    }

    /*****************************************************************************
     *
     *      dijoyreg.c - Joystick registry services
     *
     *****************************************************************************/
    extern LPCWSTR c_rghwIdPredef[];

    STDMETHODIMP JoyReg_OpenTypeKey(LPCWSTR pwszType, DWORD sam, DWORD dwOptions, PHKEY phk);
    STDMETHODIMP JoyReg_OpenPropKey(LPCWSTR pwszType, DWORD sam, DWORD dwOptions, PHKEY phk);    
    STDMETHODIMP JoyReg_OpenFFKey(HKEY hkType, REGSAM sam, PHKEY phk);

    STDMETHODIMP
        JoyReg_OpenConfigKey(UINT idJoy, DWORD sam, DWORD dwOptions, PHKEY phk);

    STDMETHODIMP JoyReg_GetTypeInfo(LPCWSTR pwszType,
                                    LPDIJOYTYPEINFO pjti, DWORD fl);
    STDMETHODIMP JoyReg_SetTypeInfo(HKEY hkTypesW, LPCWSTR pwszType,
                                    LPCDIJOYTYPEINFO pjti, DWORD fl);

    STDMETHODIMP JoyReg_GetConfig(UINT idJoy, LPDIJOYCONFIG pcfg, DWORD fl);
    STDMETHODIMP JoyReg_SetConfig(UINT idJoy, LPJOYREGHWCONFIG phwc,
                                  LPCDIJOYCONFIG pcfg, DWORD fl);

    STDMETHODIMP JoyReg_GetUserValues(LPDIJOYUSERVALUES pjuv, DWORD fl);
    STDMETHODIMP JoyReg_SetUserValues(LPCDIJOYUSERVALUES pjuv, DWORD fl);


    STDMETHODIMP
        JoyReg_GetSetConfigValue(HKEY hk, LPCTSTR ptszNValue, UINT idJoy,
                                 DWORD reg, PV pvBuf, DWORD cb, BOOL fSet);

#define GSCV_GET        0
#define GSCV_SET        1

#define JoyReg_GetConfigValue(hk, ptsz, id, reg, pv, cb) \
        JoyReg_GetSetConfigValue(hk, ptsz, id, reg, pv, cb, GSCV_GET)

#define JoyReg_SetConfigValue(hk, ptsz, id, reg, pv, cb) \
        JoyReg_GetSetConfigValue(hk, ptsz, id, reg, (PV)(pv), cb, GSCV_SET)


    STDMETHODIMP
        JoyReg_GetValue(HKEY hk, LPCTSTR ptszValue, DWORD reg, PV pvBuf, DWORD cb);

#ifndef WINNT
    STDMETHODIMP
        JoyReg_IsWdmGameport(HKEY hk);
#endif

#if 0
    STDMETHODIMP
        JoyReg_IsWdmGameportFromDeviceInstance( LPTSTR ptszDeviceInst );
#endif

    STDMETHODIMP
        JoyReg_SetValue(HKEY hk, LPCTSTR ptszValue, DWORD reg, PCV pvBuf, DWORD cb);

#ifndef WINNT
    LPSTR EXTERNAL
        JoyReg_JoyIdToDeviceInterface_95(UINT idJoy, PVXDINITPARMS pvip, LPSTR ptszBuf);
#endif

    HRESULT EXTERNAL
        JoyReg_GetPredefTypeInfo(LPCWSTR pwszType, LPDIJOYTYPEINFO pjti, DWORD fl);

    HRESULT EXTERNAL
        hResIdJoypInstanceGUID_95( UINT idJoy, LPGUID  lpguid);

    HRESULT EXTERNAL
        hResIdJoypInstanceGUID_WDM( UINT idJoy, LPGUID  lpguid);

#ifdef WINNT
#define hResIdJoypInstanceGUID(id,lpguid)  hResIdJoypInstanceGUID_WDM(id, lpguid)
#else
#define hResIdJoypInstanceGUID(id,lpguid)  hResIdJoypInstanceGUID_95(id, lpguid)
#endif

#if 0
    HRESULT EXTERNAL JoyReg_GetIDByOemName( LPTSTR szOemName, PUINT pId );
#endif
/*****************************************************************************
*
*      didev.c - IDirectInputDevice implementation
*
*****************************************************************************/

    void EXTERNAL DeviceInfoWToA(LPDIDEVICEINSTANCEA pdiA,
                                 LPCDIDEVICEINSTANCEW pdiW);

    void EXTERNAL Device8WTo8A(LPDIRECTINPUTDEVICE8A *ppdid8A, LPDIRECTINPUTDEVICE8W pdid8W);

    STDMETHODIMP CDIDev_New(PUNK punkOuter, RIID riid, PPV ppvObj);

    /*****************************************************************************
     *
     *      CDIDev_Enter/LeaveCrit are secret backdoors to allow emulation
     *      and effects
     *      to take the device critical section when updating buffers.
     *
     *      CDIDev_InCrit is used for assertion checking.
     *
     *      CDIDev_IsExclAcquired is used by effects to make sure the parent
     *      is acquired for exclusive before attempting to download.
     *
     *      CDIDev_SyncShepHandle is used to get the joystick "tag" which
     *      is used by dieshep.c to determine who owns the joystick.
     *
     *****************************************************************************/

    void EXTERNAL CDIDev_EnterCrit_(struct CDIDev *this, LPCTSTR lptszFile, UINT line);
    void EXTERNAL CDIDev_LeaveCrit_(struct CDIDev *this, LPCTSTR lptszFile, UINT line);

#ifdef DEBUG
    BOOL INTERNAL CDIDev_InCrit(struct CDIDev *this);
    #define CDIDev_EnterCrit(cdidev) CDIDev_EnterCrit_(cdidev, TEXT(__FILE__), __LINE__)
    #define CDIDev_LeaveCrit(cdidev) CDIDev_LeaveCrit_(cdidev, TEXT(__FILE__), __LINE__)
#else
    #define CDIDev_EnterCrit(cdidev) CDIDev_EnterCrit_(cdidev, NULL, 0x0);
    #define CDIDev_LeaveCrit(cdidev) CDIDev_LeaveCrit_(cdidev, NULL, 0x0);
#endif

#ifndef XDEBUG

    #define CDIDev_IsExclAcquired_(pdd, z)                          \
       _CDiDev_IsExclAcquired_(pdd)                                 \

#endif

    STDMETHODIMP CDIDev_IsExclAcquired_(struct CDIDev *this, LPCSTR s_szProc);

#define CDIDev_IsExclAcquired(pdd)                                  \
        CDIDev_IsExclAcquired_(pdd, s_szProc)                       \


    STDMETHODIMP CDIDev_SyncShepHandle(struct CDIDev *this, PSHEPHANDLE psh);

    /*****************************************************************************
     *
     *      CDIDev_SetNotifyEvent is used by the emulation code to
     *      notify the application when the state of the device changes.
     *
     *****************************************************************************/

    void EXTERNAL CDIDev_SetNotifyEvent(struct CDIDev *this);
    void EXTERNAL CDIDev_SetForcedUnacquiredFlag(struct CDIDev *this);

    /*****************************************************************************
     *
     *      CDIDev_NotifyCreate/DestroyEvent is used by CDIEff to
     *      let the parent know when a child effect comes or goes.
     *
     *      CDIDev_FindEffectGUID is used by CDIEff to convert an
     *      effect GUID into an effect cookie dword.
     *
     *      CDIDev_ConvertObjects converts item identifiers in various ways.
     *
     *****************************************************************************/

    HRESULT EXTERNAL
        CDIDev_NotifyCreateEffect(struct CDIDev *this, struct CDIEff *pdeff);
    HRESULT EXTERNAL
        CDIDev_NotifyDestroyEffect(struct CDIDev *this, struct CDIEff *pdeff);

    /*****************************************************************************
     *
     *  @doc    INTERNAL
     *
     *  @struct EFFECTMAPINFO |
     *
     *          Information about an effect, much like a
     *          <t DIEFFECTINFO>, but containing the
     *          effect ID, too.
     *
     *  @field  DWORD | dwId |
     *
     *          The effect ID.  This comes first so we can copy
     *          an <t EFFECTMAPINFO> into a <t DIEFFECTINFO>
     *          all at one go.
     *
     *  @field  GUID | guid |
     *
     *          The effect GUID.
     *
     *  @field  DWORD | dwEffType |
     *
     *          The effect type and flags.
     *
     *  @field  WCHAR | wszName[MAX_PATH] |
     *
     *          The name for the effect.
     *
     *****************************************************************************/

    typedef struct EFFECTMAPINFO
    {
        DIEFFECTATTRIBUTES attr;
        GUID    guid;
        WCHAR   wszName[MAX_PATH];
    } EFFECTMAPINFO, *PEFFECTMAPINFO;
    typedef const EFFECTMAPINFO *PCEFFECTMAPINFO;

    #ifndef XDEBUG

        #define CDIDev_FindEffectGUID_(this, rguid, pemi, z, i)     \
       _CDIDev_FindEffectGUID_(this, rguid, pemi)                   \

    #endif

    #define CDIDev_FindEffectGUID(this, rguid, pemi, iarg)          \
        CDIDev_FindEffectGUID_(this, rguid, pemi, s_szProc, iarg)   \


    STDMETHODIMP
        CDIDev_FindEffectGUID_(struct CDIDev *this, REFGUID rguid,
                               PEFFECTMAPINFO pemi, LPCSTR s_szProc, int iarg);

    STDMETHODIMP
        CDIDev_ConvertObjects(struct CDIDev *this, UINT cdw, LPDWORD rgdw, UINT fl);

    /*
     *  Note that the bonus DEVCO flags live inside the DIDFT_INSTANCEMASK.
     */
    #define DEVCO_AXIS              DIDFT_AXIS
    #define DEVCO_BUTTON            DIDFT_BUTTON
    #define DEVCO_TYPEMASK          DIDFT_TYPEMASK

    #define DEVCO_FFACTUATOR        DIDFT_FFACTUATOR
    #define DEVCO_FFEFFECTTRIGGER   DIDFT_FFEFFECTTRIGGER
    #define DEVCO_ATTRMASK          DIDFT_ATTRMASK

    #define DEVCO_FROMID            0x00000100
    #define DEVCO_FROMOFFSET        0x00000200
    #define DEVCO_FROMMASK          0x00000300
    #define DEVCO_TOID              0x00001000
    #define DEVCO_TOOFFSET          0x00002000
    #define DEVCO_TOMASK            0x00003000


    #if ((DEVCO_FROMMASK | DEVCO_TOMASK) & DIDFT_INSTANCEMASK) !=       \
     (DEVCO_FROMMASK | DEVCO_TOMASK)
        #error DEVCO_FROMMASK and DEVCI_TOMASK should not escape DIDFT_INSTANCEMASK.
    #endif

    #define DEVCO_VALID          (DEVCO_TYPEMASK |      \
                                 DEVCO_ATTRMASK |       \
                                 DEVCO_FROMMASK |       \
                                 DEVCO_TOMASK)


    /*****************************************************************************
     *
     *      dieffv.c - IDirectInputEffectDriver for VJoyD joysticks
     *
     *****************************************************************************/

    STDMETHODIMP CEffVxd_New(PUNK punkOuter, RIID riid, PPV ppvOut);

    /*****************************************************************************
     *
     *      dieshep.c - IDirectInputEffectShepherd
     *
     *****************************************************************************/

    STDMETHODIMP CEShep_New(HKEY hk, PUNK punkOuter, RIID riid, PPV ppvOut);

    /*****************************************************************************
     *
     *      digendef.c - Default IDirectInputDeviceCallback
     *
     *****************************************************************************/

    /*
     *  We can't call it a DCB because winbase.h already has one for
     *  comm goo.
     */

    typedef IDirectInputDeviceCallback DICB, *PDICB;

    STDMETHODIMP
        CDefDcb_Acquire(PDICB pdcb);

    STDMETHODIMP
        CDefDcb_Unacquire(PDICB pdcb);

    STDMETHODIMP
        CDefDcb_GetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPDIPROPHEADER pdiph);

    STDMETHODIMP
        CDefDcb_SetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPCDIPROPHEADER pdiph);

    STDMETHODIMP
        CDefDcb_SetEventNotification(PDICB pdcb, HANDLE h);

    STDMETHODIMP
        CDefDcb_SetCooperativeLevel(PDICB pdcb, HWND hwnd, DWORD dwFlags);

    STDMETHODIMP
        CDefDcb_CookDeviceData(PDICB pdcb, DWORD cdod, LPDIDEVICEOBJECTDATA rgdod);

    STDMETHODIMP
        CDefDcb_CreateEffect(PDICB pdcb, LPDIRECTINPUTEFFECTSHEPHERD *ppes);

    STDMETHODIMP
        CDefDcb_GetFFConfigKey(PDICB pdcb, DWORD sam, PHKEY phk);

    STDMETHODIMP
        CDefDcb_SendDeviceData(PDICB pdcb, DWORD cbdod, LPCDIDEVICEOBJECTDATA rgdod,
                               LPDWORD pdwInOut, DWORD fl);

    STDMETHODIMP
        CDefDcb_Poll(IDirectInputDeviceCallback *pdcb);

    STDMETHODIMP
        CDefDcb_GetVersions(IDirectInputDeviceCallback *pdcb, LPDIDRIVERVERSIONS pvers);

    STDMETHODIMP
        CDefDcb_MapUsage(IDirectInputDeviceCallback *pdcb, DWORD dwUsage, PINT piOut);

    STDMETHODIMP_(DWORD)
        CDefDcb_GetUsage(IDirectInputDeviceCallback *pdcb, int iobj);

    STDMETHODIMP
        CDefDcb_SetDIData(PDICB pdcb, DWORD dwVer, LPVOID lpdihacks);

    STDMETHODIMP
        CDefDcb_BuildDefaultActionMap(PDICB pdcb, LPDIACTIONFORMATW pActionFormat,
                                    DWORD dwFlags, REFGUID guidInst);

    /*****************************************************************************
     *
     *      digenx.c - IDirectInputDeviceCallback that does nothing
     *
     *****************************************************************************/

    extern IDirectInputDeviceCallback c_dcbNil;

#define c_pdcbNil       &c_dcbNil

    /*****************************************************************************
     *
     *      digenm.c - IDirectInputDeviceCallback for mouse
     *
     *****************************************************************************/

    STDMETHODIMP CMouse_New(PUNK punkOuter, REFGUID rguid, RIID riid, PPV ppvOut);

    /*****************************************************************************
     *
     *      digenk.c - IDirectInputDeviceCallback for keyboard
     *
     *****************************************************************************/
    extern BYTE g_rgbKbdRMap[];
    STDMETHODIMP CKbd_New(PUNK punkOuter, REFGUID rguid, RIID riid, PPV ppvOut);

    /*****************************************************************************
     *
     *      digenj.c - IDirectInputDeviceCallback for joystick
     *
     *****************************************************************************/

    STDMETHODIMP CJoy_New(PUNK punkOuter, REFGUID rguid, RIID riid, PPV ppvOut);

    /*****************************************************************************
     *
     *  @doc    INTERNAL
     *
     *  @func   UINT | ibJoyPosAxisFromPosAxis |
     *
     *          Returns the offset of the <p iAxis>'th joystick axis
     *          in the <t JOYPOS> structure.
     *
     *  @parm   UINT | uiAxis |
     *
     *          The index of the requested axis.  X, Y, Z, R, U and V are
     *          respctively zero through five.
     *
     *  @returns
     *
     *          The offset relative to the structure.
     *
     *****************************************************************************/

#define _ibJoyPosAxisFromPosAxis(uiAxis)   \
         (FIELD_OFFSET(JOYPOS, dwX) + cbX(DWORD) * (uiAxis))

    UINT INLINE
        ibJoyPosAxisFromPosAxis(UINT uiPosAxis)
    {
#define CheckAxis(x)                                            \
        CAssertF(_ibJoyPosAxisFromPosAxis(iJoyPosAxis##x)       \
                            == FIELD_OFFSET(JOYPOS, dw##x))     \

        CheckAxis(X);
        CheckAxis(Y);
        CheckAxis(Z);
        CheckAxis(R);
        CheckAxis(U);
        CheckAxis(V);

#undef CheckAxis

        return _ibJoyPosAxisFromPosAxis(uiPosAxis);
    }

    /*****************************************************************************
     *
     *      dieffj.c - Dummy IDirectInputEffectDriver for joystick
     *
     *****************************************************************************/

    STDMETHODIMP CJoyEff_New(PUNK punkOuter, RIID riid, PPV ppvOut);

    /*****************************************************************************
     *
     *      dihid.c - IDirectInputDeviceCallback for generic HID devices
     *
     *****************************************************************************/
    STDMETHODIMP CHid_New(PUNK punkOuter, REFGUID rguid, RIID riid, PPV ppvOut);

    /*****************************************************************************
     *
     *      dieff.c - IDirectInputEffect implementation
     *
     *****************************************************************************/

    STDMETHODIMP
        CDIEff_New(struct CDIDev *pdev, LPDIRECTINPUTEFFECTSHEPHERD pes,
                   PUNK punkOuter, RIID riid, PPV ppvObj);

    /*****************************************************************************
     *
     *      dihidusg.c - HID usage converters
     *
     *****************************************************************************/

    /*****************************************************************************
     *
     *  @doc    INTERNAL
     *
     *  @struct HIDUSAGEMAP |
     *
     *          This structure maps HID usages to GUIDs
     *          or legacy joystick axes.
     *
     *  @field  DWORD | dwUsage |
     *
     *          Packed usage via <f DIMAKEUSAGEDWORD>.
     *
     *  @field  BYTE | bPosAxis |
     *
     *          <t JOYPOS> axis number, where 0 = X, 1 = Y, ..., 5 = V.
     *
     *  @field  BYTE | bSemFlag |
     *
     *          DISEM_FLAGS_* value for axis.
     *
     *  @field  BYTE | bReserved1 |
     *
     *          Byte reserved to improve alignment
     *
     *  @field  BYTE | bReserved2 |
     *
     *          Byte reserved to improve alignment
     *
     *  @field  DWORD | dwSemHint |
     *
     *          A root of a semantic generally appropriate for this axis.
     *
     *  @field  PCGUID | pguid |
     *
     *          Corresponding <t GUID>.
     *
     *****************************************************************************/

    typedef struct HIDUSAGEMAP
    {

        DWORD   dwUsage;
        BYTE    bPosAxis;
        BYTE    bSemFlag;
        BYTE    bReserved1;
        BYTE    bReserved2;
        DWORD   dwSemHint;
        PCGUID  pguid;

    } HIDUSAGEMAP, *PHIDUSAGEMAP;

    PHIDUSAGEMAP EXTERNAL UsageToUsageMap(DWORD dwUsage);

    /*
     *  Flags defined for dwSemHint
     *  The names have the same suffixes as the equivalent HID usages
     *  Values are ORed together for a summary of a device's default semantics
     */
    #define DISEM_HINT_X            0x00000001
    #define DISEM_HINT_Y            0x00000002
    #define DISEM_HINT_Z            0x00000004
    #define DISEM_HINT_WHEEL        0x00000004
    #define DISEM_HINT_RX           0x00000008
    #define DISEM_HINT_RY           0x00000010
    #define DISEM_HINT_RZ           0x00000020
    #define DISEM_HINT_SIXDOF       0x0000003F
    #define DISEM_HINT_THROTTLE     0x00000040
    #define DISEM_HINT_POV          0x00000080
    #define DISEM_HINT_HATSWITCH    0x00000080
    #define DISEM_HINT_ACCELERATOR  0x00000100
    #define DISEM_HINT_BRAKE        0x00000200
    #define DISEM_HINT_CLUTCH       0x00000400
    #define DISEM_HINT_SHIFTER      0x00000800
    #define DISEM_HINT_STEERING     0x00001000
    #define DISEM_HINT_RUDDER       0x00002000
    #define DISEM_HINT_SLIDER       0x00004000
    #define DISEM_HINT_DIAL         0x00004000
    #define DISEM_HINT_ABSOLUTE     0x00008000

    DWORD EXTERNAL GuidToUsage(PCGUID pguid);

    UINT EXTERNAL
        GetHIDString(DWORD Usage, DWORD UsagePage, LPWSTR pwszBuf, UINT cwch);

    void EXTERNAL InsertCollectionNumber(UINT icoll, LPWSTR pwszBuf);

    /*****************************************************************************
     *
     *      disubcls.c - Subclassing
     *
     *****************************************************************************/

    typedef LRESULT
        (CALLBACK *SUBCLASSPROC)(HWND hwnd, UINT wm, WPARAM wp,
                                 LPARAM lp, UINT_PTR uId, ULONG_PTR dwRef);

    BOOL EXTERNAL
        SetWindowSubclass(HWND hwnd, SUBCLASSPROC pfnSubclass, UINT_PTR uId, ULONG_PTR dwRef);

    BOOL EXTERNAL
        GetWindowSubclass(HWND hwnd, SUBCLASSPROC pfnSubclass, UINT_PTR uId, ULONG_PTR *pdwRef);

    BOOL EXTERNAL
        RemoveWindowSubclass(HWND hwnd, SUBCLASSPROC pfnSubclass, UINT_PTR uId);

    LRESULT EXTERNAL
        DefSubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp);

    /*****************************************************************************
     *
     *      dical.c - Axis ramps and calibration
     *
     *      Structure names begin with "Joy" for historical reasons.
     *
     *****************************************************************************/

#if defined(_X86_)

    LONG EXTERNAL CCal_MulDiv(LONG lA, LONG lB, LONG lC);

#else

    #define CCal_MulDiv     MulDiv

#endif

    /*****************************************************************************
     *
     *  @doc    INTERNAL
     *
     *  @struct JOYRAMP |
     *
     *          Parameters for a "ramp".  A ramp looks like this:
     *
     *             r       !
     *             e    dy -      *---
     *             t       !     /
     *             u       !    /
     *             r       !   /
     *             n     y ---*
     *             e       !
     *             d       +--!---!---
     *                        x   dx
     *
     *                  physical position
     *
     *
     *          y, dy = baseline and height
     *
     *          x, dx = initiation level and width
     *
     *          The mapping is
     *
     *
     *          (-infty, x    ] -> y
     *          (x,      x+dx ) -> (y, y+dy)
     *          [x+dx,   infty) -> y+dy
     *
     *          It is very important that the middle range not be taken
     *          if dx = 0.
     *
     *  @field  int | x |
     *
     *          Horizontal value below which we return the baseline.
     *
     *  @field  DWORD | dx |
     *
     *          Width of the ramp.  Beyond this point, we return the
     *          full height.
     *
     *  @field  int | y |
     *
     *          Baseline.
     *
     *  @field  int | dy |
     *
     *          Total height.
     *
     *****************************************************************************/

    typedef struct JOYRAMP
    {

        int     x;
        int     y;
        DWORD   dx;
        int     dy;

    } JOYRAMP, *PJOYRAMP;

    typedef const JOYRAMP *PCJOYRAMP;

    /*****************************************************************************
     *
     *  @doc    INTERNAL
     *
     *  @struct JOYRANGECONVERT |
     *
     *          Parameters for range conversion.
     *
     *          The conversion curve is in five sections.
     *
     *
     *
     *                 !
     *             lmax-                     *----
     *         r       !                    /
     *         e       !                   /
     *         t       !                  /
     *         u     lc-          *------*
     *         r       !         /
     *         n       !        /
     *         e       !       /
     *         d   lmin-------*
     *                 !
     *                 +-!----!---!------!----!----!--
     *                pmin  smin dmin  dmax  smax  pmax
     *
     *                                !
     *                                pc
     *
     *
     *                        physical position
     *
     *
     *      lmin/lmax = logical min/max - This is the smallest/largest
     *          position the app will ever see.
     *
     *      lc = logical center
     *
     *      pmin/pmax = physical min/max - This is the position determined by
     *          calibration to be the value which the hardware reports
     *          when the device is physically at its bottom/upper limit.  Note
     *          that the hardware might report values outside this range.
     *
     *      pc = physical center - This is the nominal neutral location for
     *           the axis
     *
     *      dmin/dmax = dead zone min/max - This is the zone around which
     *          the center is artificially expanded.
     *
     *      smin/smax = saturation min/max - This is the level at which
     *          we treat the axis as being at its most extreme position.
     *
     *  @field  BOOL | fRaw |
     *
     *          Is the axis in raw mode?  If so, then no cooking is performed.
     *
     *  @field  JOYRAMP | rmpLow |
     *
     *          The ramp for below-center.
     *
     *  @field  JOYRAMP | rmpHigh |
     *
     *          The ramp for above-center.
     *
     *  @field  DWORD | dwPmin |
     *
     *          Physical minimum.
     *
     *  @field  DWORD | dwPmax |
     *
     *          Physical maximum.
     *
     *  @field  LONG | lMin |
     *
     *          Logical minimum.
     *
     *  @field  LONG | lCenter |
     *
     *          Logical center.
     *
     *  @field  LONG | lMax |
     *
     *          Logical maximum.
     *
     *  @field  DWORD | dwPc |
     *
     *          Physical center.
     *
     *  @field  DWORD | dwDz |
     *
     *          Dead zone (in ten thousandths, 10000 = 100%).
     *
     *  @field  DWORD | dwSat |
     *
     *          Saturation level (in ten thousands, 10000 = 100%).
     *
     *  @field  BOOL | fPolledPOV |
     *
     *          Whether the axis is a polled POV. Usable only when the axis is a POV.
     *
     *  @field  LONG | lMinPOV[5] |
     *
     *          Mininum ranges of POV directions. Usable only when the axis is a POV.
     *
     *  @field  LONG | lMaxPOV[5] |
     *
     *          Maxinum ranges of POV directions. Usable only when the axis is a POV.
     *
     *
     *****************************************************************************/

    /*
     *  Number of range divisions.  We work in ten thousandths.
     */
#define RANGEDIVISIONS      10000

    typedef struct JOYRANGECONVERT
    {

        BOOL fRaw;
        JOYRAMP rmpLow;
        JOYRAMP rmpHigh;

        DWORD dwPmin;
        DWORD dwPmax;
        DWORD dwPc;
        LONG lMin;
        LONG lMax;
        LONG lC;
        DWORD dwDz;
        DWORD dwSat;

        DWORD  dwCPointsNum;
        CPOINT cp[MAXCPOINTSNUM];  //4 is for deadzone(2) and saturation(2)

      #ifdef WINNT
        BOOL  fPolledPOV;
        LONG  lMinPOV[5];
        LONG  lMaxPOV[5];
      #endif
    } JOYRANGECONVERT, *PJOYRANGECONVERT;

    typedef const JOYRANGECONVERT *PCJOYRANGECONVERT;

    /*****************************************************************************
     *
     *      dical.c functions
     *
     *****************************************************************************/

    void EXTERNAL CCal_CookRange(PJOYRANGECONVERT this, LONG UNALIGNED *pl);
    void EXTERNAL CCal_RecalcRange(PJOYRANGECONVERT this);

    STDMETHODIMP
        CCal_GetProperty(PJOYRANGECONVERT this, REFGUID rguid, LPDIPROPHEADER pdiph);

    STDMETHODIMP
        CCal_SetProperty(PJOYRANGECONVERT this, LPCDIPROPINFO ppropi,
                         LPCDIPROPHEADER pdiph, HKEY hkType);

    /*****************************************************************************
     *
     *  @doc    INTERNAL
     *
     *  @func   LONG | CCal_Midpoint |
     *
     *          Return the midpoint of two values.  Note, however, that
     *          we round <y upward> instead of downward.  This is important,
     *          because many people set the ranges to something like
     *          0 .. 0xFFFF, and we want the midpoint to be 0x8000.
     *
     *          Care must be taken that the intermediate sum does not overflow.
     *
     *  @parm   LONG | lMin |
     *
     *          Lower limit.
     *
     *  @parm   LONG | lMax |
     *
     *          Upper limit.
     *
     *  @returns
     *
     *          The midpoint.
     *
     *****************************************************************************/

    LONG INLINE
        CCal_Midpoint(LONG lMin, LONG lMax)
    {
        /*
         *  Can't do "lMax + lMin" because that might overflow.
         */
        AssertF(lMax >= lMin);
        return lMin + (UINT)(lMax - lMin + 1) / 2;
    }

    /*****************************************************************************
     *
     *      dijoytyp.c
     *
     *****************************************************************************/

    STDMETHODIMP CType_OpenIdSubkey(HKEY, DWORD, REGSAM, PHKEY);
    void EXTERNAL CType_RegGetObjectInfo(HKEY hkType, DWORD dwId,
                                         LPDIDEVICEOBJECTINSTANCEW pdidoiW);
    void EXTERNAL CType_RegGetTypeInfo(HKEY hkType, LPDIOBJECTDATAFORMAT podf, BOOL bHid);
    void EXTERNAL CType_MakeGameCtrlName(PWCHAR wszOutput, DWORD dwDevType, 
        DWORD dwAxes, DWORD dwButtons, DWORD dwPOVs );


    /*****************************************************************************
     *
     *      didevdf.c
     *
     *****************************************************************************/

    HRESULT CDIDev_ActionMap_IsValidMapObject(LPDIACTIONFORMATW paf
        #ifdef XDEBUG
            comma LPCSTR pszProc
            comma UINT argnum
        #endif
    );

    STDMETHODIMP CMap_ValidateActionMapSemantics( LPDIACTIONFORMATW paf,
        DWORD               dwFlags
    );

    STDMETHODIMP CMap_BuildDefaultSysActionMap( LPDIACTIONFORMATW paf, 
        DWORD dwFlags, DWORD dwPhysicalGenre, REFGUID guidDevInst, 
        LPDIDATAFORMAT dfDev, DWORD dwButtonZeroInst
    );

    typedef struct _DIDOBJDEFSEM
    {
        DWORD   dwID;               /* object id of control */
        DWORD   dwSemantic;         /* default semantic match */
    } DIDOBJDEFSEM, *PDIDOBJDEFSEM;

    STDMETHODIMP CMap_BuildDefaultDevActionMap( LPDIACTIONFORMATW paf, DWORD dwFlags,
        REFGUID guidDevInst, PDIDOBJDEFSEM rgObjSem,
        DWORD dwNumAxes, DWORD dwNumPOVs, DWORD dwNumButtons );

    STDMETHODIMP CMap_DeviceValidateActionMap( PV pdd, LPDIACTIONFORMATW paf, DWORD dwFlags, 
                                               PDWORD pdwOut );

    STDMETHODIMP CMap_InitializeCRCTable( void );

    HRESULT CMap_GetDeviceUserName( REFGUID guidDevInst, LPWSTR wszOwner );

    /*****************************************************************************
     *
     *      diaphack.c
     *
     *****************************************************************************/

    BOOL EXTERNAL AhGetAppHacks(LPTSTR tszAppId);
    HRESULT EXTERNAL     AhAppRegister(DWORD dwVer, DWORD dwMapper);


    /*****************************************************************************
     *
     *      dimapshp.c - IDirectInputMapShepherd
     *
     *****************************************************************************/

    STDMETHODIMP CMapShep_New(PUNK punkOuter, RIID riid, PPV ppvObj);

    HRESULT INTERNAL
    _CreateInstance(REFCLSID rclsid, LPCTSTR ptszDll, LPUNKNOWN punkOuter,
                RIID riid, PPV ppvOut, HINSTANCE *phinst);

    /*****************************************************************************
     *
     *      diraw.c
     *
     *****************************************************************************/
  #ifdef USE_WM_INPUT
    #define DIRAW_NONEXCL       0
    #define DIRAW_EXCL          1
    #define DIRAW_NOHOTKEYS     2
    
    HRESULT CDIRaw_RegisterRawInputDevice( UINT uirim, DWORD dwOrd, HWND hwnd);
    HRESULT CDIRaw_UnregisterRawInputDevice( UINT uirim, HWND hwnd );
    BOOL    CDIRaw_OnInput(MSG *pmsg);
    HRESULT INTERNAL CDIRaw_Mouse_InitButtons();
    int     EXTERNAL DIRaw_GetKeyboardType(int nTypeFlag);
  #endif

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dinputrc.h ===
/***************************************************************************
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dinputrc.h
 *  Content:    DirectInput internal resource header file
 *
 ***************************************************************************/


/*****************************************************************************
 *
 *  Strings
 *
 *****************************************************************************/

/*
 *  IDS_STDMOUSE
 *
 *      Friendly name for the standard mouse device.
 */
#define IDS_STDMOUSE            16

/*
 *  IDS_STDKEYBOARD
 *
 *      Friendly name for the standard keyboard device.
 */
#define IDS_STDKEYBOARD         17

/*
 *  IDS_STDJOYSTICK
 *
 *      Friendly name for the standard joystick devices.
 *
 *      This string contains a %d.
 */
#define IDS_STDJOYSTICK         18

/*
 *  IDS_DIRECTINPUT
 *
 *      CLSID name for OLE registration.
 */
#define IDS_DIRECTINPUT8         19

/*
 *  IDS_DIRECTINPUTDEVICE
 *
 *      CLSID name for OLE registration.
 */
#define IDS_DIRECTINPUTDEVICE8   20

/*
 *  IDS_BUTTONTEMPLATE
 *
 *      Template for generic button name.
 */
#define IDS_BUTTONTEMPLATE      28

/*
 *  IDS_AXISTEMPLATE
 *
 *      Template for generic axis name.
 */
#define IDS_AXISTEMPLATE        29

/*
 *  IDS_POVTEMPLATE
 *
 *      Template for generic POV name.
 */
#define IDS_POVTEMPLATE         30

/*
 *  IDS_COLLECTIONTEMPLATE
 *
 *      Template for generic collection name.
 */
#define IDS_COLLECTIONTEMPLATE  31

/*
 *  IDS_COLLECTIONTEMPLATEFORMAT
 *
 *      Template for generic collection name with room for a "%s"
 *      where the friendly name is kept.
 */
#define IDS_COLLECTIONTEMPLATEFORMAT 32


/*
 *  IDS_STDGAMEPORT
 *
 *      Friendly name for the standard gameport devices.
 *
 *      This string contains a %d.
 */

#define IDS_STDGAMEPORT         33

/*
 *  IDS_STDSERIALPORT
 *
 *      Friendly name for the standard serialport devices.
 *
 *      This string contains a %d.
 */

#define IDS_STDSERIALPORT       34

/*
 *  IDS_UNKNOWNTEMPLATE
 *
 *      Template for Unknown device object.
 */
#define IDS_UNKNOWNTEMPLATE     35

/*
 *  IDS_DEFAULTUSER
 *
 *      Default name for user if no other could be found.
 *      (was unused IDS_UNKNOWNTEMPLATEFORMAT)
 */
#define IDS_DEFAULTUSER         36

/*
 *  IDS_MOUSEOBJECT+0 ... IDS_MOUSEOBJECT+255
 *
 *      Friendly names for mouse device objects.
 */
#define IDS_MOUSEOBJECT         0x0100


/*
 *  IDS_KEYBOARDOBJECT_UNKNOWN
 *
 *      Name for key for which no string name could be found.
 */
#define IDS_KEYBOARDOBJECT_UNKNOWN  0x01FF

/*
 *  IDS_KEYBOARDOBJECT+0 ... IDS_KEYBOARDOBJECT+255
 *
 *      Friendly names for keyboard objects.
 */
#define IDS_KEYBOARDOBJECT      0x0200

/*
 *  IDS_JOYSTICKOBJECT+0 ... IDS_JOYSTICKOBJECT+255
 *
 *      Friendly names for joystick objects.
 */
#define IDS_JOYSTICKOBJECT      0x0300

/*
 *  IDS_PREDEFJOYTYPE+0 ... IDS_PREDEFJOYTYPE+255
 *
 *      Friendly names for predefined joystick types.
 */
#define IDS_PREDEFJOYTYPE       0x0400

/* Gap of 256 string IDs for alignment */

/*
 *  IDS_PAGE_GENERIC+0 ... IDS_PAGE_GENERIC+511
 *
 *      Friendly names for HID Usage Page = Generic
 */
#define IDS_PAGE_GENERIC        0x0600

/*
 *  IDS_PAGE_VEHICLE+0 ... IDS_PAGE_VEHICLE+511
 *
 *      Friendly names for HID Usage Page = Vehicle
 */
#define IDS_PAGE_VEHICLE        0x0800

/*
 *  IDS_PAGE_VR+0 ... IDS_PAGE_VR+511
 *
 *      Friendly names for HID Usage Page = VR
 */
#define IDS_PAGE_VR             0x0A00

/*
 *  IDS_PAGE_SPORT+0 ... IDS_PAGE_SPORT+511
 *
 *      Friendly names for HID Usage Page = Sport Controls
 */
#define IDS_PAGE_SPORT          0x0C00

/*
 *  IDS_PAGE_GAME+0 ... IDS_PAGE_GAME+511
 *
 *      Friendly names for HID Usage Page = Game Controls
 */
#define IDS_PAGE_GAME           0x0E00

/*
 *  IDS_PAGE_LED+0 ... IDS_PAGE_LED+511
 *
 *      Friendly names for HID Usage Page = LEDs
 */
#define IDS_PAGE_LED            0x1000

/*
 *  IDS_PAGE_TELEPHONY+0 ... IDS_PAGE_TELEPHONY+511
 *
 *      Friendly names for HID Usage Page = Telephony
 */
#define IDS_PAGE_TELEPHONY      0x1200

/*
 *  IDS_PAGE_CONSUMER+0 ... IDS_PAGE_CONSUMER+511
 *
 *      Friendly names for HID Usage Page = Consumer
 */
#define IDS_PAGE_CONSUMER       0x1400

/*
 *  IDS_PAGE_DIGITIZER+0 ... IDS_PAGE_DIGITIZER+511
 *
 *      Friendly names for HID Usage Page = Digitizer
 */
#define IDS_PAGE_DIGITIZER      0x1600

/*
 *  IDS_PAGE_KEYBOARD+0 ... IDS_PAGE_KEYBOARD+511
 *
 *      Friendly names for HID Usage Page = Keyboard
 */
#define IDS_PAGE_KEYBOARD       0x1800


/*
 *  IDS_PAGE_PID+0 ... IDS_PAGE_PID+511
 *
 *      Friendly names for HID Usage Page = PID
 */
#define IDS_PAGE_PID            0x1A00

/*****************************************************************************
 *
 *  RCDATA
 *
 *  Japanese keyboard translation tables are stored in resources.
 *
 *  This lets us change them at the last minute without too much risk.
 *
 *  It also keeps them out of our image.
 *
 *****************************************************************************/

#define IDDATA_KBD_NEC98        1
#define IDDATA_KBD_NEC98LAPTOP  IDDATA_KBD_NEC98    /* The same */
#define IDDATA_KBD_NEC98_106    2
#define IDDATA_KBD_JAPAN106     3
#define IDDATA_KBD_JAPANAX      4
#define IDDATA_KBD_J3100        5
#define IDDATA_KBD_PCENH        6
#define IDDATA_KBD_NEC98_NT     7
#define IDDATA_KBD_NEC98LAPTOP_NT IDDATA_KBD_NEC98_NT /* The same */
#define IDDATA_KBD_NEC98_106_NT 8

/*****************************************************************************
 *
 *  RCDATA
 *
 *  The mapping between HID usages
 *
 *  This lets us change them at the last minute without too much risk.
 *
 *  It also keeps them out of our image.
 *
 *****************************************************************************/

#define IDDATA_HIDMAP           9

/*****************************************************************************
 * Template for Generic Joystick Names
 *
 * Modified from MsJstick.
 *
 * Assigning a default name to A HID device, when there is none in the registry
 *
 * Note, string IDs for PLAIN_STICK, GAMEPAD, DRIVE_CTRL and FLIGHT_CTRL must 
 * stay contiguous and in order.
 *
 *****************************************************************************/


#define IDS_TEXT_TEMPLATE    0x0002000
#define IDS_PLAIN_STICK      0x0002001
#define IDS_GAMEPAD          0x0002002
#define IDS_DRIVE_CTRL       0x0002003
#define IDS_FLIGHT_CTRL      0x0002004
#define IDS_HEAD_TRACKER     0x0002005
#define IDS_DEVICE_NAME      0x0002006
#define IDS_WITH_POV         0x0002007

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\diobj.c ===
/*****************************************************************************
 *
 *  DIObj.c
 *
 *  Copyright (c) 1996 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      The IDirectInput main interface.
 *
 *  Contents:
 *
 *      CDIObj_New
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflDi


#define DIDEVTYPE_DEVICE_ORDER            1
#define DIDEVTYPE_HID_MOUSE_ORDER         2
#define DIDEVTYPE_HID_KEYBOARD_ORDER      3
#define DIDEVTYPE_MOUSE_ORDER             4
#define DIDEVTYPE_KEYBOARD_ORDER          5
#define DIDEVTYPE_SUPPLEMENTAL_ORDER      6
#define MAX_ORDER                         (DI8DEVTYPE_MAX - DI8DEVTYPE_MIN + DIDEVTYPE_SUPPLEMENTAL_ORDER + 2)
#define INVALID_ORDER                     (MAX_ORDER + 1)

#define MAX_DEVICENUM                     32

DIORDERDEV g_DiDevices[MAX_DEVICENUM];  //all devices that are attached
int g_nCurDev;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CDIObj |
 *
 *          The <i IDirectInput> object, from which other things come.
 *
 *          The A and W versions are simply alternate interfaces on the same
 *          underlying object.
 *
 *          There really isn't anything interesting in the structure
 *          itself.
 *
 *
 *  @field  IDirectInputA | diA |
 *
 *          ANSI DirectInput object (containing vtbl).
 *
 *  @field  IDirectInputW | diW |
 *
 *          UNICODE DirectInput object (containing vtbl).
 *
 *  @field  IDirectInputJoyConfig *| pdjc |
 *
 *          Aggregated joystick configuration interface (if created).
 *
 *  @field  BOOL | fCritInited:1 |
 *
 *          Set if the critical section has been initialized.
 *
 *  @field  CRITICAL_SECTION | crst |
 *
 *          Critical section that guards thread-sensitive data.
 *****************************************************************************/

typedef struct CDIObj
{

    /* Supported interfaces */
    TFORM(IDirectInput8)   TFORM(di);
    SFORM(IDirectInput8)   SFORM(di);

    DWORD dwVersion;

    IDirectInputJoyConfig *pdjc;

    BOOL fCritInited:1;

    CRITICAL_SECTION crst;

} CDIObj, DDI, *PDDI;

#define ThisClass CDIObj

    #define ThisInterface TFORM(IDirectInput8)
    #define ThisInterfaceA      IDirectInput8A
    #define ThisInterfaceW      IDirectInput8W
    #define ThisInterfaceT      IDirectInput8

/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *****************************************************************************/

Primary_Interface(CDIObj, TFORM(ThisInterfaceT));
Secondary_Interface(CDIObj, SFORM(ThisInterfaceT));

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *//**************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *****************************************************************************/

#ifdef DEBUG

Default_QueryInterface(CDIObj)
Default_AddRef(CDIObj)
Default_Release(CDIObj)

#else

    #define CDIObj_QueryInterface   Common_QueryInterface
    #define CDIObj_AddRef           Common_AddRef
    #define CDIObj_Release          Common_Release

#endif

#define CDIObj_AppFinalize      Common_AppFinalize

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @mfunc   void | CDIObj | EnterCrit |
 *
 *          Enter the object critical section.
 *
 *  @doc    INTERNAL
 *
 *  @mfunc   void | CDIObj | LeaveCrit |
 *
 *          Leave the object critical section.
 *
 *****************************************************************************/

void INLINE
CDIObj_EnterCrit(PDDI this)
{
    EnterCriticalSection(&this->crst);
}
void INLINE
CDIObj_LeaveCrit(PDDI this)
{
    LeaveCriticalSection(&this->crst);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @mfunc  HRESULT | IDirectInput | QIHelper |
 *
 *          We will dynamically create <i IDirectInputJoyConfig>
 *          and aggregate it with us.
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interfacethis->pdix[iobj].dwOfs.
 *
 *****************************************************************************/

STDMETHODIMP
CDIObj_QIHelper(PDDI this, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcI(CDIObj_QIHelper, (_ "pG", this, riid));

    if ( IsEqualIID(riid, &IID_IDirectInputJoyConfig8) )
    {

        *ppvObj = 0;                /* In case the New fails */

        CDIObj_EnterCrit(this);
        if ( this->pdjc == 0 )
        {
            hres = CJoyCfg_New((PUNK)this, &IID_IUnknown, (PPV)&this->pdjc);
        } else
        {
            hres = S_OK;
        }
        CDIObj_LeaveCrit(this);

        if ( SUCCEEDED(hres) )
        {
            /*
             *  This QI will addref us if it succeeds.
             */
            hres = OLE_QueryInterface(this->pdjc, riid, ppvObj);
        } else
        {
            this->pdjc = 0;
        }

    } else
    {
        hres = Common_QIHelper(this, riid, ppvObj);
    }

    ExitOleProcPpv(ppvObj);
    return(hres);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CDIObj_Finalize |
 *
 *          Clean up our instance data.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
CDIObj_Finalize(PV pvObj)
{
    PDDI this = pvObj;

    Invoke_Release(&this->pdjc);

    if ( this->fCritInited )
    {
        DeleteCriticalSection(&this->crst);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInput | CreateDeviceHelper |
 *
 *          Creates and initializes an instance of a device which is
 *          specified by the GUID and IID.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   IN PCGUID | pguid |
 *
 *          See <mf IDirectInput::CreateDevice>.
 *
 *  @parm   OUT PPV | ppvObj |
 *
 *          See <mf IDirectInput::CreateDevice>.
 *
 *  @parm   IN LPUNKNOWN | punkOuter |
 *
 *          See <mf IDirectInput::CreateDevice>.
 *
 *  @parm   IN RIID | riid |
 *
 *          The interface the application wants to create.  This will
 *          be either <i IDirectInputDeviceA> or <i IDirectInputDeviceW>.
 *          If the object is aggregated, then this parameter is ignored.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
CDIObj_CreateDeviceHelper(PDDI this, PCGUID pguid, PPV ppvObj,
                          PUNK punkOuter, RIID riid)
{
    HRESULT hres;
    EnterProc(CDIObj_CreateDeviceHelper,
              (_ "pGxG", this, pguid, punkOuter, riid));

    /*
     *  CDIDev_New will validate the punkOuter and ppvObj.
     *
     *  IDirectInputDevice_Initialize will validate the pguid.
     *
     *  riid is known good (since it came from CDIObj_CreateDeviceW
     *  or CDIObj_CreateDeviceA).
     */

    hres = CDIDev_New(punkOuter, punkOuter ? &IID_IUnknown : riid, ppvObj);

    if ( SUCCEEDED(hres) && punkOuter == 0 )
    {
        PDID pdid = *ppvObj;
        hres = IDirectInputDevice_Initialize(pdid, g_hinst,
                                             this->dwVersion, pguid);
        if ( SUCCEEDED(hres) )
        {
        } else
        {
            Invoke_Release(ppvObj);
        }

    }

    ExitOleProcPpv(ppvObj);
    return(hres);

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput | CreateDevice |
 *
 *          Creates and initializes an instance of a device which is
 *          specified by the GUID and IID.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   REFGUID | rguid |
 *          Identifies the instance of the
 *          device for which the indicated interface
 *          is requested.  The <mf IDirectInput::EnumDevices> method
 *          can be used to determine which instance GUIDs are supported by
 *          the system.
 *
 *  @parm   OUT LPDIRECTINPUTDEVICE * | lplpDirectInputDevice |
 *          Points to where to return
 *          the pointer to the <i IDirectInputDevice> interface, if successful.
 *
 *  @parm   IN LPUNKNOWN | punkOuter | Pointer to controlling unknown
 *          for OLE aggregation, or 0 if the interface is not aggregated.
 *          Most callers will pass 0.
 *
 *  @comm   Calling this function with <p punkOuter> = NULL
 *          is equivalent to creating the object via
 *          <f CoCreateInstance>(&CLSID_DirectInputDevice, NULL,
 *          CLSCTX_INPROC_SERVER, <p riid>, <p lplpDirectInputDevice>);
 *          then initializing it with <f Initialize>.
 *
 *          Calling this function with <p punkOuter> != NULL
 *          is equivalent to creating the object via
 *          <f CoCreateInstance>(&CLSID_DirectInputDevice, <p punkOuter>,
 *          CLSCTX_INPROC_SERVER, &IID_IUnknown, <p lplpDirectInputDevice>).
 *          The aggregated object must be initialized manually.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p ppvOut> parameter is not a valid pointer.
 *
 *          <c DIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:
 *          Out of memory.
 *
 *          <c DIERR_NOINTERFACE> = <c E_NOINTERFACE>
 *          The specified interface is not supported by the object.
 *
 *          <c DIERR_DEVICENOTREG> = The device instance does not
 *          correspond to a device that is registered with DirectInput.
 *
 *****************************************************************************/

STDMETHODIMP
CDIObj_CreateDeviceW(PV pdiW, REFGUID rguid, PPDIDW ppdidW, PUNK punkOuter)
{
    HRESULT hres;
    EnterProcR(IDirectInput8::CreateDevice,
               (_ "pGp", pdiW, rguid, punkOuter));

    if ( SUCCEEDED(hres = hresPvI(pdiW, ThisInterfaceW)) )
    {
        PDDI this = _thisPvNm(pdiW, diW);

        hres = CDIObj_CreateDeviceHelper(this, rguid, (PPV)ppdidW,
                                         punkOuter, &IID_IDirectInputDevice8W);
    }

    ExitOleProcPpv(ppdidW);
    return(hres);
}

STDMETHODIMP
CDIObj_CreateDeviceA(PV pdiA, REFGUID rguid, PPDIDA ppdidA, PUNK punkOuter)
{
    HRESULT hres;
    EnterProcR(IDirectInput8::CreateDevice,
               (_ "pGp", pdiA, rguid, punkOuter));

    if ( SUCCEEDED(hres = hresPvI(pdiA, ThisInterfaceA)) )
    {
        PDDI this = _thisPvNm(pdiA, diA);

        hres = CDIObj_CreateDeviceHelper(this, rguid, (PPV)ppdidA,
                                         punkOuter, &IID_IDirectInputDevice8A);
    }

    ExitOleProcPpv(ppdidA);
    return(hres);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIObj_TestDeviceFlags |
 *
 *          Determines whether the device matches the specified flags.
 *          Phantom devices are treated as not really there.
 *
 *  @parm   PDIDW | pdidW |
 *
 *          Device to be queried.
 *
 *  @parm   DWORD | edfl |
 *
 *          Enumeration flags.  It is one or more <c DIEDFL_*> values.
 *
 *          The bits in the enumeration flags are in two categories.*
 *
 *          Normal flags are the ones whose presence requires that
 *          the corresponding bit in the device flags also be set.
 *
 *          Inverted flags (<c DIEDFL_INCLUDEMASK>) are the ones whose
 *          absence requires that the corresponding bit in the device
 *          flags also be absent.
 *
 *          By inverting the inclusion flags in both the enumeration
 *          flags and the actual device flags, and then treating the
 *          whole thing as a bunch of normal flags, we get the desired
 *          behavior for the inclusion flags.
 *
 *  @returns
 *
 *          <c S_OK> if the device meets the criteria.
 *
 *          <c S_FALSE> if the device does not meet the criteria.
 *          Note that <mf DirectInput::GetDeviceStatus> relies on
 *          this specific return value.
 *
 *          Other error code as appropriate.
 *
 *****************************************************************************/

HRESULT EXTERNAL
CDIObj_TestDeviceFlags(PDIDW pdidW, DWORD edfl)
{
    HRESULT hres;
    DIDEVCAPS_DX3 dc;
    EnterProcI(CDIObj_TestDeviceFlags, (_ "px", pdidW, edfl));

    /*
     *  We intentionally use a DIDEVCAPS_DX3 because going for
     *  a full DIDEVCAPS_DX5 requires us to load the force
     *  feedback driver which is pointless for our current
     *  goal.
     */
    dc.dwSize = cbX(dc);

    hres = IDirectInputDevice_GetCapabilities(pdidW, (PV)&dc);

    AssertF(dc.dwSize == cbX(dc));

    CAssertF(DIEDFL_ATTACHEDONLY == DIDC_ATTACHED);
    CAssertF(DIEDFL_FORCEFEEDBACK == DIDC_FORCEFEEDBACK);
    CAssertF(DIEDFL_INCLUDEALIASES == DIDC_ALIAS);
    CAssertF(DIEDFL_INCLUDEPHANTOMS == DIDC_PHANTOM);
    CAssertF(DIEDFL_INCLUDEHIDDEN == DIDC_HIDDEN);

    if ( SUCCEEDED(hres) )
    {
        if ( fHasAllBitsFlFl(dc.dwFlags ^ DIEDFL_INCLUDEMASK,
                             edfl ^ DIEDFL_INCLUDEMASK) )
        {
            hres = S_OK;
        } else
        {
            /*
             *  Note: DX3 and DX5 returned E_DEVICENOTREG for
             *  phantom devices.  Now we return S_FALSE. Let's
             *  hope nobody gets upset.
             */
            hres = S_FALSE;
        }
    }

    ExitOleProc();
    return(hres);
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput | EnumDevices |
 *
 *          Enumerates the DirectInput devices that are attached to
 *          or could be attached to the computer.
 *
 *          For example, an external game port may support a joystick
 *          or a steering wheel, but only one can be plugged in at a
 *          time.  <mf IDirectInput::EnumDevices> will enumerate both
 *          devices.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   DWORD | dwDevType |
 *
 *          Device type filter.  If 0, then all device types are
 *          enumerated.  Otherwise, it is either a <c DIDEVCLASS_*> value,
 *          indicating the device class that should be enumerated or a
 *          <c DIDEVTYPE_*> value, indicating the device type that should be 
 *          enumerated.
 *
 *  @parm   LPDIENUMDEVICESCALLBACK | lpCallback |
 *          Points to an application-defined callback function.
 *          For more information, see the description of the
 *          <f DIEnumDevicesProc> callback function.
 *
 *  @parm   IN LPVOID | pvRef |
 *          Specifies a 32-bit application-defined
 *          value to be passed to the callback function.  This value
 *          may be any 32-bit value; it is prototyped as an <t LPVOID>
 *          for convenience.
 *
 *  @parm   DWORD | fl |
 *          Optional flags which control the enumeration.  The
 *          following flags are defined and may be combined.
 *
 *          <c DIEDFL_ATTACHEDONLY>: Enumerate only attached devices.
 *
 *          <c DIEDFL_FORCEFEEDBACK>: Enumerate only devices which
 *          support force feedback.  This flag is new for DirectX 5.0.
 *
 *          <c DIEDFL_INCLUDEALIASES>: Include alias devices in the
 *          enumeration.  If this flag is not specified, then devices
 *          which are aliases of other devices (indicated by the
 *          <c DIDC_ALIAS> flag in the <e DIDEVCAPS.dwFlags> field
 *          of the <t DIDEVCAPS> structure) will be excluded from
 *          the enumeration.  This flag is new for DirectX 5.0a.
 *
 *          <c DIEDFL_INCLUDEPHANTOMS>: Include phantom devices in the
 *          enumeration.  If this flag is not specified, then devices
 *          which are phantoms (indicated by the
 *          <c DIDC_PHANTOM> flag in the <e DIDEVCAPS.dwFlags> field
 *          of the <t DIDEVCAPS> structure) will be excluded from
 *          the enumeration.  This flag is new for DirectX 5.0a.
 *
 *          The default is
 *          <c DIEDFL_ALLDEVICES>: Enumerate all installed devices.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *          Note that if the callback stops the enumeration prematurely,
 *          the enumeration is considered to have succeeded.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p fl> parameter contains invalid flags, or the callback
 *          procedure returned an invalid status code.
 *
 *  @cb     BOOL CALLBACK | DIEnumDevicesProc |
 *
 *          An application-defined callback function that receives
 *          DirectInput devices as a result of a call to the
 *          <om IDirectInput::EnumDevices> method.
 *
 *  @parm   IN LPDIDEVICEINSTANCE | lpddi |
 *
 *          Structure that describes the device instance.
 *
 *
 *  @parm   IN OUT LPVOID | pvRef |
 *          Specifies the application-defined value given in the
 *          <mf IDirectInput::EnumDevices> function.
 *
 *  @returns
 *
 *          Returns <c DIENUM_CONTINUE> to continue the enumeration
 *          or <c DIENUM_STOP> to stop the enumeration.
 *
 *//**************************************************************************
 *
 *      In DEBUG/RDEBUG, if the callback returns a bogus value, raise
 *      a validation exception.
 *
 *****************************************************************************/

HRESULT INLINE
CDIObj_EnumDevices_IsValidTypeFilter(DWORD dwDevType)
{
    HRESULT hres;

    /*
     *  First make sure the type mask is okay.
     */
    if( ( GET_DIDEVICE_TYPE( dwDevType ) < DI8DEVCLASS_MAX )
     || ( ( GET_DIDEVICE_TYPE( dwDevType ) >= DI8DEVTYPE_MIN )
       && ( GET_DIDEVICE_TYPE( dwDevType ) < DI8DEVTYPE_MAX ) ) )
    {
        /*
         *  Now make sure attribute masks are okay.
         */
        if ( dwDevType & DIDEVTYPE_ENUMMASK & ~DIDEVTYPE_ENUMVALID )
        {
            RPF("IDirectInput::EnumDevices: Invalid dwDevType");
            hres = E_INVALIDARG;
        } else
        {
            hres = S_OK;
        }

    } else
    {
        RPF("IDirectInput::EnumDevices: Invalid dwDevType");
        hres = E_INVALIDARG;
    }
    return(hres);
}

STDMETHODIMP
CDIObj_EnumDevicesW(PV pdiW, DWORD dwDevType,
                    LPDIENUMDEVICESCALLBACKW pec, LPVOID pvRef, DWORD fl)
{
    HRESULT hres;
    EnterProcR(IDirectInput8::EnumDevices,
               (_ "pxppx", pdiW, dwDevType, pec, pvRef, fl));

    if ( SUCCEEDED(hres = hresPvI(pdiW, ThisInterfaceW)) &&
         SUCCEEDED(hres = hresFullValidPfn(pec, 2)) &&
         SUCCEEDED(hres = CDIObj_EnumDevices_IsValidTypeFilter(dwDevType)) &&
         SUCCEEDED(hres = hresFullValidFl(fl, DIEDFL_VALID, 4)) )
    {
        PDDI this = _thisPvNm(pdiW, diW);

        if ( SUCCEEDED(hres = hresValidInstanceVer(g_hinst, this->dwVersion)) )
        {

            CDIDEnum *pde;

            hres = CDIDEnum_New(&this->diW, dwDevType, fl, this->dwVersion, &pde);
            if ( SUCCEEDED(hres) )
            {
                DIDEVICEINSTANCEW ddiW;
                ddiW.dwSize = cbX(ddiW);

                while ( (hres = CDIDEnum_Next(pde, &ddiW)) == S_OK )
                {
                    BOOL fRc;

                    /*
                     *  WARNING!  "goto" here!  Make sure that nothing
                     *  is held while we call the callback.
                     */
                    fRc = Callback(pec, &ddiW, pvRef);

                    switch ( fRc )
                    {
                        case DIENUM_STOP: goto enumdoneok;
                        case DIENUM_CONTINUE: break;
                        default:
                            RPF("%s: Invalid return value from callback", s_szProc);
                            ValidationException();
                            break;
                    }
                }

                AssertF(hres == S_FALSE);
                enumdoneok:;
                CDIDEnum_Release(pde);

                hres = S_OK;
            }
        }
    }

    ExitOleProcR();
    return(hres);
}


BOOL INTERNAL CDIObj_InternalDeviceEnumProcW(LPDIDEVICEINSTANCEW pddiW, LPDIRECTINPUTDEVICE8W pdid8W, LPVOID pv);


STDMETHODIMP
CDIObj_InternalEnumDevicesW(PV pdiW, DWORD dwDevType, LPVOID pvRef, DWORD fl)
{
    HRESULT hres;
    CDIDEnum *pde;
        
    PDDI this = _thisPvNm(pdiW, diW);

    hres = CDIDEnum_New(&this->diW, dwDevType, fl, this->dwVersion, &pde);
    if ( SUCCEEDED(hres) )
    {
        DIDEVICEINSTANCEW ddiW;
        LPDIRECTINPUTDEVICE8W pdid8W;

        ddiW.dwSize = cbX(ddiW);

        while ( (hres = CDIDEnum_InternalNext(pde, &ddiW, &pdid8W)) == S_OK )
        {
            BOOL fRc;

            fRc = CDIObj_InternalDeviceEnumProcW(&ddiW, pdid8W, pvRef);

            switch ( fRc )
            {
                case DIENUM_STOP: goto enumdoneok;
                case DIENUM_CONTINUE: break;
                default:
                    ValidationException();
                    break;
            }
        }

        AssertF(hres == S_FALSE);
        enumdoneok:;
        CDIDEnum_Release(pde);

        hres = S_OK;
    }

    return(hres);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | CDIObj_EnumDevicesCallbackA |
 *
 *          Wrapper function for <mf IDirectInput::EnumDevices>
 *          which translates the UNICODE parameters to ANSI.
 *
 *  @parm   IN LPCDIDECICEINSTANCEW | pdiW |
 *
 *          Same as <mf IDirectInput::EnumDevices>.
 *
 *  @parm   IN OUT PV | pvRef |
 *
 *          Pointer to <t struct ENUMDEVICESINFO> which describes
 *          the original callback.
 *
 *  @returns
 *
 *          Returns whatever the original callback returned.
 *
 *****************************************************************************/

typedef struct ENUMDEVICESINFO
{
    LPDIENUMDEVICESCALLBACKA pecA;
    PV pvRef;
} ENUMDEVICESINFO, *PENUMDEVICESINFO;

BOOL CALLBACK
CDIObj_EnumDevicesCallback(LPCDIDEVICEINSTANCEW pdiW, PV pvRef)
{
    PENUMDEVICESINFO pedi = pvRef;
    BOOL fRc;
    DIDEVICEINSTANCEA diA;
    EnterProc(CDIObj_EnumDevicesCallback,
              (_ "GGxWWp", &pdiW->guidInstance, &pdiW->guidProduct,
               &pdiW->dwDevType,
               pdiW->tszProductName, pdiW->tszInstanceName,
               pvRef));

    diA.dwSize = cbX(diA);
    DeviceInfoWToA(&diA, pdiW);

    fRc = pedi->pecA(&diA, pedi->pvRef);

    ExitProcX(fRc);
    return(fRc);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputA | EnumDevices |
 *
 *          ANSI version of <mf IDirectInput::EnumDevices>.
 *          We wrap the operation.
 *
 *  @parm   IN LPGUID | lpGUIDDeviceType |
 *          Same as <mf IDirectInput::EnumDevices>.
 *
 *  @parm   LPDIENUMDEVICESCALLBACKA | lpCallbackA |
 *          Same as <mf IDirectInput::EnumDevices>, except ANSI.
 *
 *  @parm   IN LPVOID | pvRef |
 *          Same as <mf IDirectInput::EnumDevices>.
 *
 *  @parm   DWORD | fl |
 *          Same as <mf IDirectInput::EnumDevices>.
 *
 *****************************************************************************/

STDMETHODIMP
CDIObj_EnumDevicesA(PV pdiA, DWORD dwDevType,
                    LPDIENUMDEVICESCALLBACKA pec, LPVOID pvRef, DWORD fl)
{
    HRESULT hres;
    EnterProcR(IDirectInput8::EnumDevices,
               (_ "pxppx", pdiA, dwDevType, pec, pvRef, fl));

    /*
     *  EnumDevicesW will validate the rest.
     */
    if ( SUCCEEDED(hres = hresPvI(pdiA, ThisInterfaceA)) &&
         SUCCEEDED(hres = hresFullValidPfn(pec, 1)) )
    {
        ENUMDEVICESINFO edi = { pec, pvRef};
        PDDI this = _thisPvNm(pdiA, diA);
        hres = CDIObj_EnumDevicesW(&this->diW, dwDevType,
                                   CDIObj_EnumDevicesCallback, &edi, fl);
    }

    ExitOleProcR();
    return(hres);
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput | GetDeviceStatus |
 *
 *          Determine whether a device is currently attached.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   REFGUID | rguid |
 *
 *          Identifies the instance of the
 *          device whose status is being checked.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The device is attached.
 *
 *          <c DI_NOTATTACHED> = <c S_FALSE>: The device is not
 *          attached.
 *
 *          <c E_FAIL>: DirectInput could not determine
 *          whether the device is attached.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          device does not exist.
 *
 *****************************************************************************/

STDMETHODIMP
CDIObj_GetDeviceStatus(PV pdi, REFGUID rguid _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInput8::GetDeviceStatus, (_ "pG", pdi, rguid));

    if ( SUCCEEDED(hres = hresPvT(pdi)) )
    {
        PDDI this = _thisPv(pdi);
        PDIDW pdidW;

        hres = IDirectInput_CreateDevice(&this->diW, rguid, (PV)&pdidW, 0);
        if ( SUCCEEDED(hres) )
        {
            hres = CDIObj_TestDeviceFlags(pdidW, DIEDFL_ATTACHEDONLY);
            OLE_Release(pdidW);
        }
    }

    ExitOleProc();
    return(hres);
}

#ifdef XDEBUG

CSET_STUBS(GetDeviceStatus, (PV pdi, REFGUID rguid), (pdi, rguid THAT_))

#else

    #define CDIObj_GetDeviceStatusA         CDIObj_GetDeviceStatus
    #define CDIObj_GetDeviceStatusW         CDIObj_GetDeviceStatus

#endif

#ifdef DO_THE_IMPOSSIBLE

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput | SetAttachedDevice |
 *
 *          Informs DirectInput that a new device has been attached
 *          to the system by the user.  This is useful when an application
 *          asks the user to attach a currently installed device but does
 *          not want to launch the DirectInput control panel.
 *
 *          DirectInput needs to be informed that the device has
 *          been attached for internal bookkeeping purposes.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   IN LPDIRECTINPUTDEVICE | lpDIDevice |
 *
 *          Identifies the device which has been attached.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The device is attached.
 *
 *  @devnote
 *
 *          This method is not implemented in the current release
 *          of DirectInput.
 *
 *          This won't work.  We need to receive a port, too.
 *          And how can the app create a <p lpDIDevice> in the
 *          first place for a device that does not exist?
 *          I guess I just don't understand.
 *
 *****************************************************************************/

STDMETHODIMP
CDIObj_SetAttachedDevice(PV pdi, PV pdid _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInput8::SetAttachedDevice, (_ "pp", pdi, pdid));

    if ( SUCCEEDED(hres = hresPvT(pdi)) )
    {
        PDDI this = _thisPv(pdi);

        hres = E_NOTIMPL;
    }

    ExitOleProc();
    return(hres);
}

    #ifdef XDEBUG

CSET_STUBS(SetAttachedDevice, (PV pdi, PV pdid), (pdi, pdid THAT_))

    #else

        #define CDIObj_SetAttachedDeviceA       CDIObj_SetAttachedDevice
        #define CDIObj_SetAttachedDeviceW       CDIObj_SetAttachedDevice

    #endif

#endif

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput | RunControlPanel |
 *
 *          Run the DirectInput control panel so that the user can
 *          install a new input device or modify the setup.
 *
 *          This function will not run third-party control panels.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   IN HWND | hwndOwner |
 *
 *          Identifies the window handle that will be used as the
 *          parent window for subsequent UI.  NULL is a valid parameter,
 *          indicating that there is no parent window.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          No flags are currently defined.  This parameter "must" be
 *          zero.
 *
 *  @returns
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The device is attached.
 *
 *  @devnote
 *
 *          The <p dwFlags> is eventually going to allow
 *          <c DIRCP_MODAL> to request a modal control panel.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

STDMETHODIMP
CDIObj_RunControlPanel(PV pdi, HWND hwndOwner, DWORD fl _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInput8::RunControlPanel, (_ "pxx", pdi, hwndOwner, fl));

    if ( SUCCEEDED(hres = hresPvT(pdi)) &&
         SUCCEEDED(hres = hresFullValidHwnd0(hwndOwner, 1)) &&
         SUCCEEDED(hres = hresFullValidFl(fl, DIRCP_VALID, 2)) )
    {

        PDDI this = _thisPv(pdi);

        if ( SUCCEEDED(hres = hresValidInstanceVer(g_hinst, this->dwVersion)) )
        {

            /*
             *  We used to run "directx.cpl,@0,3" but directx.cpl is not
             *  redistributable; it comes only with the SDK.  So we just
             *  run the system control panel.
             */

            hres = hresRunControlPanel(TEXT(""));
        }
    }

    ExitOleProc();
    return(hres);
}

#ifdef XDEBUG

CSET_STUBS(RunControlPanel, (PV pdi, HWND hwndOwner, DWORD fl),
           (pdi, hwndOwner, fl THAT_))

#else

    #define CDIObj_RunControlPanelA         CDIObj_RunControlPanel
    #define CDIObj_RunControlPanelW         CDIObj_RunControlPanel

#endif

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput | Initialize |
 *
 *          Initialize a DirectInput object.
 *
 *          The <f DirectInputCreate> method automatically
 *          initializes the DirectInput object device after creating it.
 *          Applications normally do not need to call this function.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   IN HINSTANCE | hinst |
 *
 *          Instance handle of the application or DLL that is creating
 *          the DirectInput object.
 *
 *          See the section titled "Initialization and Versions"
 *          for more information.
 *
 *  @parm   DWORD | dwVersion |
 *
 *          Version number of the dinput.h header file that was used.
 *
 *          See the section titled "Initialization and Versions"
 *          for more information.
 *
 *  @returns
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The device is attached.
 *
 *          <c DIERR_DIERR_OLDDIRECTINPUTVERSION>: The application
 *          requires a newer version of DirectInput.
 *
 *          <c DIERR_DIERR_BETADIRECTINPUTVERSION>: The application
 *          was written for an unsupported prerelease version
 *          of DirectInput.
 *
 *****************************************************************************/

STDMETHODIMP
CDIObj_Initialize(PV pdi, HINSTANCE hinst, DWORD dwVersion _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInput8::Initialize, (_ "pxx", pdi, hinst, dwVersion));

    if ( SUCCEEDED(hres = hresPvT(pdi)) )
    {
        PDDI this = _thisPv(pdi);

        if ( SUCCEEDED(hres = hresValidInstanceVer(hinst, dwVersion)) )
        {
            this->dwVersion = dwVersion;
        }

    }

#ifndef DX_FINAL_RELEASE
{
        #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
        SYSTEMTIME st;
        GetSystemTime(&st);

        if ( st.wYear > DX_EXPIRE_YEAR ||
             ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH)))
        ) {
            MessageBox(0, DX_EXPIRE_TEXT,
                          TEXT("Microsoft DirectInput"), MB_OK);
        }
}
#endif

    ExitOleProc();
    return(hres);
}

#ifdef XDEBUG

CSET_STUBS(Initialize, (PV pdi, HINSTANCE hinst, DWORD dwVersion),
           (pdi, hinst, dwVersion THAT_))

#else

    #define CDIObj_InitializeA              CDIObj_Initialize
    #define CDIObj_InitializeW              CDIObj_Initialize

#endif


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIObj_FindDeviceInternal |
 *
 *          The worker function for
 *          <mf IDirectInput2::FindDevice> which works only for HID devices.
 *
 *          For more details, see <mf IDirectInput2::FindDevice>.
 *
 *  @parm   LPCTSTR | ptszName |
 *
 *          The name of the device relative to the class <t GUID>.
 *
 *  @parm   OUT LPGUID | pguidOut |
 *
 *          Pointer to a <t GUID> which receives the instance
 *          <t GUID> for the device, if the device is found.
 *
 *****************************************************************************/

HRESULT EXTERNAL
CDIObj_FindDeviceInternal(LPCTSTR ptszName, LPGUID pguidOut)
{
    HRESULT hres;

    /*
     *  Look twice.  If it's not found the first time,
     *  then refresh the cache and try again in case
     *  it was for a device that was recently added.
     *  (In fact, it will likely be a device that was
     *  recently added, because FindDevice is usually
     *  called in response to a Plug and Play event.)
     */
    hres = hresFindHIDDeviceInterface(ptszName, pguidOut);
    if ( FAILED(hres) )
    {
        DIHid_BuildHidList(TRUE);
        hres = hresFindHIDDeviceInterface(ptszName, pguidOut);
    }
    return(hres);
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput2 | FindDevice |
 *
 *          Obtain the instance <t GUID> for a device given
 *          its class <t GUID> and an opaque name.
 *
 *          This method can be used by applications which register
 *          for Plug and Play notifications and are notified by
 *          Plug and Play that a new device has been added
 *          to the system.  The Plug and Play notification will
 *          be in the form of a class <t GUID> and a device name.
 *          The application can pass the <t GUID> and name to
 *          this method to obtain the instance <t GUID> for
 *          the device, which can then be passed to
 *          <mf IDirectInput::CreateDevice> or
 *          <mf IDirectInput::GetDeviceStatus>.
 *
 *  @cwrap  LPDIRECTINPUT2 | lpDirectInput2
 *
 *  @parm   REFGUID | rguidClass |
 *
 *          Class <t GUID> identifying the device class
 *          for the device the application wishes to locate.
 *
 *          The application obtains the class <t GUID> from the
 *          Plug and Play device arrival notification.
 *
 *  @parm   LPCTSTR | ptszName |
 *
 *          The name of the device relative to the class <t GUID>.
 *
 *          The application obtains the class name from the
 *          Plug and Play device arrival notification.
 *
 *  @parm   OUT LPGUID | pguidInstance |
 *
 *          Pointer to a <t GUID> which receives the instance
 *          <t GUID> for the device, if the device is found.
 *
 *  @returns
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The device was found, and its
 *          instance <t GUID> has been stored in <p pguidInstance>.
 *
 *          <c DIERR_DEVICENOTREG> = The <t GUID> and name do not
 *          correspond to a device that is registered with DirectInput.
 *          For example, they may refer to a storage device rather
 *          than an input device.
 *
 *****************************************************************************/

    #define cchNameMax      MAX_PATH

STDMETHODIMP
TFORM(CDIObj_FindDevice)(PV pdiT, REFGUID rguid,
                         LPCTSTR ptszName, LPGUID pguidOut)
{
    HRESULT hres;
    EnterProcR(IDirectInput8::FindDevice,
               (_ "pGs", pdiT, rguid, ptszName));

    if ( SUCCEEDED(hres = TFORM(hresPv)(pdiT)) &&
         SUCCEEDED(hres = hresFullValidGuid(rguid, 1)) &&
         SUCCEEDED(hres = TFORM(hresFullValidReadStr)(ptszName,
                                                      cchNameMax, 2)) &&
         SUCCEEDED(hres = hresFullValidWritePvCb(pguidOut, cbX(GUID), 3)) )
    {

        if ( IsEqualIID(rguid, &GUID_HIDClass) )
        {
            hres = CDIObj_FindDeviceInternal(ptszName, pguidOut);
        } else
        {
            hres = DIERR_DEVICENOTREG;
        }
    }

    ExitOleProc();
    return(hres);
}

STDMETHODIMP
SFORM(CDIObj_FindDevice)(PV pdiS, REFGUID rguid,
                         LPCSSTR psszName, LPGUID pguidOut)
{
    HRESULT hres;
    TCHAR tsz[cchNameMax];
    EnterProcR(IDirectInput8::FindDevice,
               (_ "pGS", pdiS, rguid, psszName));

    /*
     *  TFORM(CDIObj_FindDevice) will validate the rguid and pguidOut.
     */
    if ( SUCCEEDED(hres = SFORM(hresPv)(pdiS)) &&
         SUCCEEDED(hres = SFORM(hresFullValidReadStr)(psszName, cA(tsz), 2)) )
    {
        PDDI this = _thisPvNm(pdiS, SFORM(di));

        SToT(tsz, cA(tsz), psszName);

        hres = TFORM(CDIObj_FindDevice)(&this->TFORM(di), rguid, tsz, pguidOut);
    }

    ExitOleProc();
    return(hres);
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @mfunc  HRESULT | IDirectInput | New |
 *
 *          Create a new instance of an IDirectInput object.
 *
 *  @parm   IN PUNK | punkOuter |
 *
 *          Controlling unknown for aggregation.
 *
 *  @parm   IN RIID | riid |
 *          Desired interface to new object.
 *
 *  @parm   OUT PPV | ppvObj |
 *          Output pointer for new object.
 *
 *  @returns
 *
 *          Standard OLE <t HRESULT>.
 *
 *****************************************************************************/

STDMETHODIMP
CDIObj_New(PUNK punkOuter, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcR(IDirectInput8::CreateInstance, (_ "Gp", riid, ppvObj));

    hres = Excl_Init();
    
    if ( SUCCEEDED(hres) )
    {

        /*
         *  Note that we cannot use Common_NewRiid for an object
         *  that aggregates other interfaces!
         *
         *  The reason is that Common_NewRiid will perform
         *  a QI as part of the initialization, but we cannot handle
         *  the QI until after we've been initialized and are
         *  ready to mess with aggregated goo.
         */

        if ( SUCCEEDED(hres = hresFullValidRiid(riid, 2)) )
        {
            if ( fLimpFF(punkOuter, IsEqualIID(riid, &IID_IUnknown)) )
            {

                hres = Common_New(CDIObj, punkOuter, ppvObj);

                if ( SUCCEEDED(hres) )
                {
                    PDDI this = _thisPv(*ppvObj);
                    
                    this->fCritInited = fInitializeCriticalSection(&this->crst);
                    if ( this->fCritInited )
                    {
                        /*
                         *  Only after the object is ready do we QI for the
                         *  requested interface.  And the reason is that the
                         *  QI might cause us to create an aggregated buddy,
                         *  which we can't do until we've been initialized.
                         *
                         *  Don't do this extra QI if we are ourselves aggregated,
                         *  or we will end up giving the wrong punk to the caller!
                         */
                        if ( punkOuter == 0 )
                        {
                            hres = OLE_QueryInterface(this, riid, ppvObj);
                            OLE_Release(this);
                        }
                        if ( FAILED(hres) )
                        {
                            Invoke_Release(ppvObj);
                        }
                    } else
                    {
                        Common_Unhold(this);
                        *ppvObj = NULL;
                        hres = E_OUTOFMEMORY;
                    }
                }
            } else
            {
                RPF("CreateDevice: IID must be IID_IUnknown if created for aggregation");
                *ppvObj = 0;
                hres = CLASS_E_NOAGGREGATION;
            }
        }
    }

    ExitOleProcPpvR(ppvObj);
    return(hres);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | CDIObj_IsDeviceUsedByUser |
 *
 *          To Test whether the device is used by the user as specified by pdm->lpszUserName.
 *
 *  @parm   IN LPDIDEVICEINSTANCEW | pddiW |
 *
 *          Device Instance.
 *
 *  @parm   IN LPDIMAPPER | pdm |
 *
 *          pointer to DIMAPPER structure
 *
 *  @returns
 *
 *          TRUE: device is used by the user
 *          FALSE: otherwise
 *
 *****************************************************************************/

BOOL INTERNAL
CDIObj_IsDeviceUsedByUser( LPDIDEVICEINSTANCEW pddiW, LPDIMAPPER pdm )
{
    HRESULT hres;
    BOOL fRtn = FALSE;
    WCHAR wszUserName[UNLEN+1];

    hres = CMap_GetDeviceUserName( &pddiW->guidInstance, wszUserName );

    if( hres == S_OK ) {
        DWORD dwLen = 0;

        dwLen = lstrlenW(pdm->lpszUserName);
        if(memcmp(pdm->lpszUserName, wszUserName, dwLen*2) == 0)
        {
            fRtn = TRUE;
        }    
    }

    return(fRtn);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | CDIObj_IsDeviceAvailable |
 *
 *          To Test whether the device is still available.
 *
 *  @parm   IN LPDIDEVICEINSTANCEW | pddiW |
 *
 *          Device Instance.
 *
 *  @parm   IN LPDIMAPPER | pdm |
 *
 *          pointer to DIMAPPER structure
 *
 *  @returns
 *
 *          TRUE: device is available
 *          FALSE: not available
 *
 *****************************************************************************/

BOOL INTERNAL
CDIObj_IsDeviceAvailable( LPDIDEVICEINSTANCEW pddiW, LPDIMAPPER pdm )
{
    HRESULT hres;
    BOOL fAvailable = FALSE;
    WCHAR wszUserName[UNLEN+1];

    hres = CMap_GetDeviceUserName( &pddiW->guidInstance, wszUserName );

    if( hres != S_OK ) {
        fAvailable = TRUE;
    }

    return(fAvailable);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | CDIObj_IsUserConfigured |
 *
 *          To Test whether the device has been configured by user.
 *
 *  @parm   IN LPDIDEVICEINSTANCEW | pddiW |
 *
 *          Device Instance.
 *
 *  @parm   IN LPDIMAPPER | pdm |
 *
 *          pointer to DIMAPPER structure
 *
 *  @returns
 *
 *          TRUE: user configured
 *          FALSE: not configured
 *
 *****************************************************************************/

BOOL INTERNAL
CDIObj_IsUserConfigured( LPDIDEVICEINSTANCEW pddiW, LPDIMAPPER pdm )
{
    LPDIACTIONFORMATW pdiaf = pdm->pDiActionFormat;
    BOOL fConfigured = FALSE;
    DWORD i;

    for ( i=0; i<pdiaf->dwNumActions; i++ )
    {
        if ( IsEqualGUID(&pdiaf->rgoAction[i].guidInstance, &pddiW->guidInstance) )
        {
            fConfigured = (pdiaf->rgoAction[i].dwHow & DIAH_USERCONFIG) ? TRUE: FALSE;
            break;
        }
    }

    return(fConfigured);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   int | CDIObj_GetMappedActionNum |
 *
 *          Get the number of the actions which have been mapped to controls.
 *
 *  @parm   IN LPDIDEVICEINSTANCEW | pddiW |
 *
 *          Device Instance.
 *
 *  @parm   IN LPDIMAPPER | pdm |
 *
 *          Pointer to DIMAPPER structure
 *
 *  @returns
 *
 *          Number of mapped actions
 *
 *****************************************************************************/

int INTERNAL
CDIObj_GetMappedActionNum( LPDIDEVICEINSTANCEW pddiW, LPDIMAPPER pdm )
{
    LPDIACTIONFORMATW pdiaf = pdm->pDiActionFormat;
    DWORD i;
    int num = 0;

    for ( i=0; i<pdiaf->dwNumActions; i++ )
    {
        if ( IsEqualGUID(&pdiaf->rgoAction[i].guidInstance, &pddiW->guidInstance) )
        {
            if ( pdiaf->rgoAction[i].dwHow & DIAH_MAPMASK )
            {
                num++;
            }
        }
    }

    return(num);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | CDIObj_GetMappedPriorities |
 *
 *          Get the priorities of the mapeed actions.
 *
 *  @parm   IN LPDIDEVICEINSTANCEW | pddiW |
 *
 *          Device Instance.
 *
 *  @parm   IN LPDIMAPPER | pdm |
 *
 *          Pointer to DIMAPPER structure
 *
 *  @returns
 *
 *          The priorities of mapped actions. Can be DIEDBS_MAPPEDPRI1,
 *          DIEDBS_MAPPEDPRI2, or the OR of both.
 *
 *****************************************************************************/

DWORD INTERNAL
CDIObj_GetMappedPriorities( LPDIDEVICEINSTANCEW pddiW, LPDIMAPPER pdm )
{
    LPDIACTIONFORMATW pdiaf = pdm->pDiActionFormat;
    DWORD i;
    DWORD pri = 0;

    for ( i=0; i<pdiaf->dwNumActions; i++ )
    {
        if( pri == ( DIEDBS_MAPPEDPRI1 | DIEDBS_MAPPEDPRI2 ) ) {
            break;
        }

        if ( IsEqualGUID(&pdiaf->rgoAction[i].guidInstance, &pddiW->guidInstance) &&
             pdiaf->rgoAction[i].dwHow & DIAH_MAPMASK
        )
        {
            if( DISEM_PRI_GET(pdiaf->rgoAction[i].dwSemantic) == 0 )
            {
                pri |= DIEDBS_MAPPEDPRI1;
            } else if( DISEM_PRI_GET(pdiaf->rgoAction[i].dwSemantic) == 1 ) {
                pri |= DIEDBS_MAPPEDPRI2;
            }
        }
    }

    return(pri);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   int | CDIObj_GetDeviceOrder |
 *
 *          Get the number of the actions which have been mapped to controls.
 *
 *  @parm   IN LPDIDEVICEINSTANCEW | pddiW |
 *
 *          Device Instance.
 *
 *  @parm   IN LPDIMAPPER | pdm |
 *
 *          pointer to DIMAPPER structure
 *
 *  @returns
 *
 *          The order of the device
 *
 *  @comm
 *         The order (DWORD) is consisted of three parts:
 *             HIWORD: HIBYTE: the order defined in the genre
 *                     LOWBYTE: none, can be used later
 *             LOWORD: HIBYTE - mapped action number
 *                     LOWBYTE - Force Feedback (1) or not (0)
 *
 *****************************************************************************/

#define GET_MAPPED_ACTION_NUM(x) ((x & 0x0000ff00) >> 8)

DWORD INTERNAL
CDIObj_GetDeviceOrder( LPDIDEVICEINSTANCEW pddiW, LPDIMAPPER pdm )
{
    WORD wHighWord, wLowWord;
    BYTE byDevOrder, byFF, byMappedActions;
    DWORD dwGenre, dwJoyType;
    BYTE byOrder;

    AssertF(pddiW);
    AssertF(pdm->pDiActionFormat);

    if ( CDIObj_IsUserConfigured( pddiW, pdm ) )
    {
        byDevOrder = MAX_ORDER;
    } else
    {
        switch( GET_DIDEVICE_TYPE(pddiW->dwDevType) )
        {
            case DI8DEVTYPE_DEVICE:
                if( !(pdm->dwFlags & DIEDBSFL_NONGAMINGDEVICES) ) 
                {
                    byDevOrder = INVALID_ORDER;    
                } else {
                    byDevOrder = DIDEVTYPE_DEVICE_ORDER;
                }

                break;
    
            case DI8DEVTYPE_MOUSE:
                if( pddiW->dwDevType & DIDEVTYPE_HID ) 
                {
                    if( !(pdm->dwFlags & DIEDBSFL_MULTIMICEKEYBOARDS) ) {
                        byDevOrder = INVALID_ORDER;    
                    } else {
                        byDevOrder = DIDEVTYPE_HID_MOUSE_ORDER;
                    }
                } else {
                    byDevOrder = DIDEVTYPE_MOUSE_ORDER;
                }

                break;

            case DI8DEVTYPE_KEYBOARD:
                if( pddiW->dwDevType & DIDEVTYPE_HID ) 
                {
                    if( !(pdm->dwFlags & DIEDBSFL_MULTIMICEKEYBOARDS) ) {
                        byDevOrder = INVALID_ORDER;    
                    } else {
                        byDevOrder = DIDEVTYPE_HID_KEYBOARD_ORDER;
                    }
                } else {
                    byDevOrder = DIDEVTYPE_KEYBOARD_ORDER;
                }
                
                break;
    
            case DI8DEVTYPE_JOYSTICK:
            case DI8DEVTYPE_GAMEPAD:
            case DI8DEVTYPE_DRIVING:
            case DI8DEVTYPE_FLIGHT:
            case DI8DEVTYPE_1STPERSON:
            case DI8DEVTYPE_SCREENPOINTER:
            case DI8DEVTYPE_REMOTE:
            case DI8DEVTYPE_DEVICECTRL:
                dwJoyType = GET_DIDEVICE_TYPE(pddiW->dwDevType);
                dwGenre = DISEM_VIRTUAL_GET(pdm->pDiActionFormat->dwGenre);
    
                AssertF(dwGenre <= DISEM_MAX_GENRE);
                AssertF(dwJoyType < DI8DEVTYPE_MAX);
                AssertF(dwJoyType != 0);
    
                for ( byOrder=DI8DEVTYPE_MIN; byOrder<DI8DEVTYPE_MAX; byOrder++ )
                {
                    if ( DiGenreDeviceOrder[dwGenre][byOrder-DI8DEVTYPE_MIN] == dwJoyType )
                    {
                        break;
                    }
                }
    
                /*
                 * If the device is not on the default list, set its order as 
                 *  DIDEVTYPE_NOTDEFAULTDEVICE_ORDER + 1
                 */
                byDevOrder = DI8DEVTYPE_MAX - byOrder + DIDEVTYPE_SUPPLEMENTAL_ORDER + 1;
                break;
    

            case DI8DEVTYPE_SUPPLEMENTAL:
                byDevOrder = DIDEVTYPE_SUPPLEMENTAL_ORDER;
                break;

        } 
    }

    if( byDevOrder != INVALID_ORDER ) {
        byFF = IsEqualGUID(&pddiW->guidFFDriver, &GUID_Null) ? 0 : 1;
        byMappedActions = (UCHAR) CDIObj_GetMappedActionNum( pddiW, pdm );
    
        wLowWord = MAKEWORD( byFF, byMappedActions );
        wHighWord = MAKEWORD( 0, byDevOrder );

        return(MAKELONG( wLowWord, wHighWord ));
    } else {
        return 0;
    }

}

/*****************************************************************************
 *
 *      CDIObj_DeviceEnumProc
 *
 *      Device enumeration procedure which is called one for each device.
 *
 *****************************************************************************/

BOOL INTERNAL
CDIObj_InternalDeviceEnumProcW(LPDIDEVICEINSTANCEW pddiW, LPDIRECTINPUTDEVICE8W pdid8W, LPVOID pv)
{
    LPDIMAPPER pdm = pv;
    HRESULT hres = S_OK;
    BOOL fRc = DIENUM_CONTINUE;
    BOOL fContinue = FALSE;
    DWORD dwDevOrder;

    if ( g_nCurDev >= MAX_DEVICENUM )
    {
        fRc = DIENUM_STOP;
        goto _done;
    }

    AssertF(pdid8W);
    AssertF(pdm->pDiActionFormat);

    hres = pdid8W->lpVtbl->BuildActionMap(pdid8W, pdm->pDiActionFormat, pdm->lpszUserName, 
                                          pdm->lpszUserName ? DIDBAM_DEFAULT : DIDBAM_HWDEFAULTS);

    if ( SUCCEEDED(hres) )
    {
        if ( (pdm->dwFlags & DIEDBSFL_AVAILABLEDEVICES) || 
             (pdm->dwFlags & DIEDBSFL_THISUSER) ) 
        {
            if( ((pdm->dwFlags & DIEDBSFL_AVAILABLEDEVICES) && CDIObj_IsDeviceAvailable(pddiW,pdm)) ||
                ((pdm->dwFlags & DIEDBSFL_THISUSER) && CDIObj_IsDeviceUsedByUser(pddiW,pdm))
            ) {
                fContinue = TRUE;
            }
        } else {
            fContinue = TRUE;
        }
             
        if( fContinue && 
            ((dwDevOrder = CDIObj_GetDeviceOrder(pddiW, pdm)) != 0) )
        {
#ifdef DEBUG
            DWORD   dbgRef;
#endif

#ifdef DEBUG
            dbgRef =
#endif
            pdid8W->lpVtbl->AddRef(pdid8W);
            g_DiDevices[g_nCurDev].dwOrder = dwDevOrder;
            g_DiDevices[g_nCurDev].dwFlags = CDIObj_GetMappedPriorities( pddiW, pdm );
            g_DiDevices[g_nCurDev].pdid8W = pdid8W;
            memcpy( &g_DiDevices[g_nCurDev].ftTimeStamp, &pdm->pDiActionFormat->ftTimeStamp, sizeof(FILETIME) );
            memcpy( &g_DiDevices[g_nCurDev].ddiW, pddiW, sizeof(*pddiW) );
            g_nCurDev ++;

            fRc = DIENUM_CONTINUE;
        }
    }

    _done:
    
    return(fRc);
}

/*****************************************************************************
 *
 *      compare
 *
 *      Compare func used in shortsort
 *
 *****************************************************************************/

int __cdecl compare( const void *arg1, const void *arg2 )
{
    DWORD dw1 = ((LPDIORDERDEV)arg1)->dwOrder;
    DWORD dw2 = ((LPDIORDERDEV)arg2)->dwOrder;

    /*
     * Compare the device order
     * If necessary, we can compare seperately: devtype, mapped action number, FF device
     */
    if ( dw1 < dw2 )
    {
        return(1);
    } else if ( dw1 > dw2 )
    {
        return(-1);
    } else
    {
        return(0);
    }
}

void FreeDiActionFormatW(LPDIACTIONFORMATW* lplpDiAfW )
{
    FreePpv(lplpDiAfW);
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | IsValidMapObjectA |
 *
 *          Validates a LPDIACTIONFORMATW including strings
 *
 *  @parm   const LPDIACTIONFORMATW | lpDiAfW | 
 *
 *          Original.
 *
 *  @returns
 *
 *          Standard OLE <t HRESULT>.
 *
 *****************************************************************************/
HRESULT
IsValidMapObjectA
(
    LPDIACTIONFORMATA paf
#ifdef XDEBUG
    comma LPCSTR pszProc
    comma UINT argnum
#endif
)
{
    HRESULT hres;

    hres  = CDIDev_ActionMap_IsValidMapObject
    ( (LPDIACTIONFORMATW)paf
#ifdef XDEBUG
    comma pszProc
    comma argnum
#endif
    );

    if( SUCCEEDED( hres ) )
    {
        if( paf->dwSize != cbX(DIACTIONFORMATA) )
        {
            D( RPF("IDirectInputDevice::%s: Invalid DIACTIONFORMATA.dwSize 0x%08x",
                pszProc, paf->dwSize ); )
            hres = E_INVALIDARG;
        }
    }

    if(SUCCEEDED(hres))
    {
        DWORD i;
        LPDIACTIONA lpDiAA;
        // Compute the size for each of the text strings in array of DIACTIONs
        for ( i = 0x0, lpDiAA = paf->rgoAction;
            i < paf->dwNumActions && SUCCEEDED(hres) ;
            i++, lpDiAA++ )
        {
            // Handle the NULL ptr case
            if ( NULL != lpDiAA->lptszActionName )
            {
                hres = hresFullValidReadStrA_(lpDiAA->lptszActionName, MAX_JOYSTRING, pszProc, argnum);
            }
        }
    }

    return hres;
}



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | IsValidMapObjectW |
 *
 *          Validates a LPDIACTIONFORMATW including strings
 *
 *  @parm   const LPDIACTIONFORMATW | lpDiAfW | 
 *
 *          Original.
 *
 *  @returns
 *
 *          Standard OLE <t HRESULT>.
 *
 *****************************************************************************/
HRESULT
IsValidMapObjectW
(
    LPDIACTIONFORMATW paf
#ifdef XDEBUG
    comma LPCSTR pszProc
    comma UINT argnum
#endif
)
{
    HRESULT hres;

    hres  = CDIDev_ActionMap_IsValidMapObject
    ( paf
#ifdef XDEBUG
    comma pszProc
    comma argnum
#endif
    );

    if( SUCCEEDED( hres ) )
    {
        if( paf->dwSize != cbX(DIACTIONFORMATW) )
        {
            D( RPF("IDirectInputDevice::%s: Invalid DIACTIONFORMATW.dwSize 0x%08x",
                pszProc, paf->dwSize ); )
            hres = E_INVALIDARG;
        }
    }
    
    if(SUCCEEDED(hres))
    {
        DWORD i;
        LPDIACTIONW lpDiAW;
        // Compute the size for each of the text strings in array of DIACTIONs
        for ( i = 0x0, lpDiAW = paf->rgoAction;
            i < paf->dwNumActions && SUCCEEDED(hres) ;
            i++, lpDiAW++ )
        {
            // Handle the NULL ptr case
            if ( NULL != lpDiAW->lptszActionName )
            {
                hres = hresFullValidReadStrW_(lpDiAW->lptszActionName, MAX_JOYSTRING, pszProc, argnum);
            }
        }
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DiActionFormatWtoW |
 *
 *          Copies LPDIACTIONFORMATW to  LPDIACTIONFORMATW
 *
 *  @parm   const LPDIACTIONFORMATW | lpDiAfW | 
 *
 *          Original.
 *
 *  @parm   LPDIACTIONFORMATW* | lplpDiAfW | 
 *
 *          Address of a pointer to a <t DIACTIONFORMATW> that receives the converted
 *          ACTIONFORMAT.
 *  @returns
 *
 *          Standard OLE <t HRESULT>.
 *
 *****************************************************************************/

HRESULT EXTERNAL DiActionFormatWtoW
(
    const LPDIACTIONFORMATW lpDiAfW0,
    LPDIACTIONFORMATW* lplpDiAfW
)
{
    DWORD cbAlloc;
    PDWORD pdwStrLen0, pdwStrLen;
    LPDIACTIONFORMATW lpDiAfW;
    LPDIACTIONW lpDiAW0;
    LPDIACTIONW lpDiAW;
    DWORD i;
    HRESULT hres;

    EnterProcI(DiActionFormatWtoW, (_ "xx", lpDiAfW0, lplpDiAfW));

    // Internal function, no validation

    *lplpDiAfW = NULL;

    /*
     *  PREFIX complains (mb:37926 - items 3 & 4) that we could be requesting 
     *  a zero byte allocation which would not allocate anything.  This is 
     *  never the case because CDIDev_ActionMap_IsValidMapObject tests that 
     *  dwNumActions is less than 2^24.  Assert in debug for extra safety.
     */
    AssertF( (lpDiAfW0->dwNumActions +1) * cbX(*pdwStrLen0) );
    hres = AllocCbPpv( (lpDiAfW0->dwNumActions +1) * cbX(*pdwStrLen0) , &pdwStrLen0);

    if ( SUCCEEDED(hres) )
    {
        pdwStrLen = pdwStrLen0;
        // Compute the amount of memory required to clone the DIACTIONFORMATA
        cbAlloc =
        /* 1: The Action Format array */
        lpDiAfW0->dwSize
        /* 2: Each of the DIACTION arrays */
        + lpDiAfW0->dwActionSize * lpDiAfW0->dwNumActions;

        // Compute the size for each of the text strings in array of DIACTIONs
        for ( i = 0x0, lpDiAW0 = lpDiAfW0->rgoAction;
            i < lpDiAfW0->dwNumActions ;
            i++, lpDiAW0++ )
        {
            // Handle the NULL ptr case
            if ( !lpDiAW0->lptszActionName )
            {
                *pdwStrLen++ = 0;
            }
            else
            {
                if ( (UINT_PTR)lpDiAW0->lptszActionName > (UINT_PTR)0xFFFF )
                {
                    /* 3: Text string in each DIACTION array*/
                    // Conversion from A to U, need  multiplier
                    *pdwStrLen = cbX(lpDiAW0->lptszActionName[0]) * ( lstrlenW(lpDiAW0->lptszActionName) + 1 );
                    cbAlloc += *pdwStrLen++;
                }
                else
                { 
                    // Use resource strings
                    WCHAR wsz[MAX_PATH];
                    if (lpDiAfW0->hInstString > 0)
                    {
                        //find out the length of the string
                        *pdwStrLen = LoadStringW(lpDiAfW0->hInstString, lpDiAW0->uResIdString, (LPWSTR) &wsz, MAX_PATH);
                    }
                    else
                    {
                        *pdwStrLen = 0;
                    }
                    cbAlloc += *pdwStrLen++;
                }
            }
        }

        if ( SUCCEEDED( hres = AllocCbPpv(cbAlloc, &lpDiAfW) ) )
        {
            DWORD dwLen;
            DWORD cb;

            pdwStrLen = pdwStrLen0;

            // 1: Copy the DIACTIONFORMAT
            *lpDiAfW = *lpDiAfW0;
            cb = lpDiAfW0->dwSize;

            // 2: Block copy the DIACTION array
            lpDiAfW->rgoAction = (LPDIACTIONW)( (char*)lpDiAfW + cb);
            dwLen = lpDiAfW0->dwActionSize * lpDiAfW0->dwNumActions;
            memcpy(lpDiAfW->rgoAction, lpDiAfW0->rgoAction, dwLen);
            cb += dwLen;

            // 3: ActionName
            for ( i = 0x0, lpDiAW0=lpDiAfW0->rgoAction, lpDiAW=lpDiAfW->rgoAction;
                i < lpDiAfW0->dwNumActions ;
                i++, lpDiAW0++, lpDiAW++ )
            {
                if ( (UINT_PTR)lpDiAW0->lptszActionName > (UINT_PTR)0xFFFF )
                {
                    WCHAR* wsz =  (WCHAR*) ((char*)lpDiAfW+cb);
                    lpDiAW->lptszActionName = wsz;

                    dwLen = *pdwStrLen++;

                    memcpy(wsz, lpDiAW0->lptszActionName, dwLen);

                    cb += dwLen  ;
                } else
                {
                    //  Handle resource strings
                    //  OK for now, as long as UI always uses CloneDiActionFormatW
                    WCHAR* wsz =  (WCHAR*) ((char*)lpDiAfW+cb);

                    dwLen = *pdwStrLen++;
                    if ((dwLen != 0) && (LoadStringW(lpDiAfW0->hInstString, lpDiAW0->uResIdString, wsz, dwLen)))
                    {
                        //If we found a length last time there must be a resource module
                        AssertF( lpDiAfW0->hInstString > 0 );

                        //Found and loaded the string
                        lpDiAW->lptszActionName = wsz;
                    }
                    else
                    {
                        //No hinstance or length 0 or didn't load the string
                        lpDiAW->lptszActionName = NULL;
                    }

                    cb += dwLen;
                }
            }


            // If we have not done something goofy, the memory allocates should match
            // the memory we used
            AssertF(cbAlloc == cb );

            *lplpDiAfW = lpDiAfW;
        }

        FreePpv(&pdwStrLen0);
    }

    ExitOleProc();
    return(hres);
}

/*****************************************************************************
 *
 *      CDIMap_EnumDevicesBySemantics
 *
 *      Enum Suitable Devices.
 *
 *****************************************************************************/

STDMETHODIMP CDIObj_EnumDevicesBySemanticsW(
                                           PV                       pDiW,
                                           LPCWSTR                  lpszUserName,
                                           LPDIACTIONFORMATW        pDiActionFormat,
                                           LPDIENUMDEVICESBYSEMANTICSCBW   pecW,
                                           LPVOID                   pvRef,
                                           DWORD                    dwFlags
                                           )
{
    HRESULT hres;

    EnterProcR(IDirectInput8::EnumDevicesBySemantics,
               (_ "pppppx", pDiW, lpszUserName, pDiActionFormat, pecW, pvRef, dwFlags));

    if ( SUCCEEDED(hres = hresPvI(pDiW, ThisInterfaceW)) &&
         SUCCEEDED(hres = IsValidMapObjectW(pDiActionFormat D(comma s_szProc comma 2))) &&
         (lpszUserName == NULL || SUCCEEDED(hres = hresFullValidReadStrW(lpszUserName, UNLEN+1, 1))) &&
         SUCCEEDED(hres = hresFullValidPfn(pecW, 3)) &&
         SUCCEEDED(hres = hresFullValidFl(dwFlags, DIEDBSFL_VALID, 5)) &&
         SUCCEEDED(hres = CMap_ValidateActionMapSemantics(pDiActionFormat, DIDBAM_PRESERVE))
       )
    {
        PDDI this = _thisPvNm(pDiW, diW);

        if ( SUCCEEDED(hres = hresValidInstanceVer(g_hinst, this->dwVersion)) )
        {
            DIMAPPER dm;
            LPDIACTIONFORMATW lpDiAfW;

            if ( SUCCEEDED(hres= DiActionFormatWtoW(pDiActionFormat, &lpDiAfW)) )
            {
                dm.lpszUserName = lpszUserName;
                dm.pDiActionFormat = lpDiAfW;
                dm.pecW = pecW;
                dm.pvRef = pvRef;
                dm.dwFlags = dwFlags;

                if( dwFlags == 0 ) {
                    dwFlags |= DIEDFL_ATTACHEDONLY;
                }

                dwFlags &= ~DIEDBSFL_AVAILABLEDEVICES;
                dwFlags &= ~DIEDBSFL_THISUSER;
                dwFlags &= ~DIEDBSFL_MULTIMICEKEYBOARDS;
                dwFlags &= ~DIEDBSFL_NONGAMINGDEVICES;

                ZeroX(g_DiDevices);
                g_nCurDev = 0;
    
                hres = CDIObj_InternalEnumDevicesW( pDiW,
                                                    0,  //enum all tyeps of devices
                                                    (LPVOID)&dm,
                                                    dwFlags //only enum attached devices
                                                  );
    
                /*
                 * For short array sorting (size <= 8), shortsort is better than qsort.
                 */
                if ( SUCCEEDED(hres) && g_nCurDev )
                {
                    int ndev;
                    int nNewDev = -1;
                    FILETIME ft = { 0, 0 };
                    FILETIME ftMostRecent;
    
                    shortsort( (char *)&g_DiDevices[0], (char *)&g_DiDevices[g_nCurDev-1], sizeof(DIORDERDEV), compare );
                    SquirtSqflPtszV(sqflDi | sqflVerbose,
                                    TEXT("EnumDevicesBySemantics: %d devices enumed"), g_nCurDev );
    
                    for ( ndev=0; ndev<g_nCurDev; ndev++ )
                    {
                        if( (g_DiDevices[ndev].ftTimeStamp.dwHighDateTime != DIAFTS_NEWDEVICEHIGH) &&
                            (g_DiDevices[ndev].ftTimeStamp.dwLowDateTime != DIAFTS_NEWDEVICELOW) &&
                            (CompareFileTime(&g_DiDevices[ndev].ftTimeStamp, &ft) == 1)   ) // first device is newer
                        {
                            nNewDev = ndev;
                            memcpy( &ft, &g_DiDevices[ndev].ftTimeStamp, sizeof(FILETIME) );
                        }
                    }

                    if( nNewDev != -1 ) {
                        g_DiDevices[nNewDev].dwFlags |= DIEDBS_RECENTDEVICE;
                        memcpy( &ftMostRecent, &g_DiDevices[nNewDev].ftTimeStamp, sizeof(FILETIME) );
                    }

                    for ( ndev=0; ndev<g_nCurDev; ndev++ )
                    {
                        // find RECENT devices and set flag.
                        if( (nNewDev != -1) && (ndev != nNewDev) ) {
                            if( (ftMostRecent.dwHighDateTime == g_DiDevices[ndev].ftTimeStamp.dwHighDateTime) &&
                                (ftMostRecent.dwLowDateTime - g_DiDevices[ndev].ftTimeStamp.dwLowDateTime < 100000000 ) )//10 seconds difference
                            {
                                g_DiDevices[ndev].dwFlags |= DIEDBS_RECENTDEVICE;
                            }
                        }
                        
                        // find NEW devices and set flag
                        if( (g_DiDevices[ndev].ftTimeStamp.dwLowDateTime == DIAFTS_NEWDEVICELOW) &&
                            (g_DiDevices[ndev].ftTimeStamp.dwHighDateTime == DIAFTS_NEWDEVICEHIGH) ) 
                        {
                                g_DiDevices[ndev].dwFlags |= DIEDBS_NEWDEVICE;
                        }
                    }
                    
                    if( !IsBadCodePtr((PV)pecW) ) {
                        for ( ndev=0; ndev<g_nCurDev; ndev++ )
                        {
                            LPDIDEVICEINSTANCEW pddiW = &g_DiDevices[ndev].ddiW;

                            SquirtSqflPtszV(sqflDi | sqflVerbose,
                                            TEXT("EnumDevicesBySemantics: device %d - %s: %d action(s) mapped"),
                                            ndev+1, pddiW->tszProductName, GET_MAPPED_ACTION_NUM(g_DiDevices[ndev].dwOrder) );

                            if ( pddiW )
                            {
#ifdef DEBUG
                                DWORD   dbgRef;
#endif
                                DWORD   dwDeviceRemaining = g_nCurDev-ndev-1;

                                AssertF(g_DiDevices[ndev].pdid8W);
                                AssertF(g_DiDevices[ndev].pdid8W->lpVtbl);

                                if( g_DiDevices[ndev].pdid8W && g_DiDevices[ndev].pdid8W->lpVtbl ) 
                                {
                                    BOOL fRc;

                                    fRc = pecW(pddiW, g_DiDevices[ndev].pdid8W, g_DiDevices[ndev].dwFlags, dwDeviceRemaining, pvRef);

                                    if( fRc == DIENUM_STOP ) {
                                        for ( ; ndev<g_nCurDev; ndev++ ) {
                                            g_DiDevices[ndev].pdid8W->lpVtbl->Release(g_DiDevices[ndev].pdid8W);
                                        }

                                        break;
                                    }

#ifdef DEBUG
                                    dbgRef =
#endif
                                    g_DiDevices[ndev].pdid8W->lpVtbl->Release(g_DiDevices[ndev].pdid8W);
                                }
                            }
                        }
                    }
                }
                
                FreeDiActionFormatW(&lpDiAfW);
            }
        }
    }

    ExitOleProcR();
    return(hres);
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | CDIObj_EnumDevicesBySemanticsCallbackA |
 *
 *          Wrapper function for <mf IDirectInput::EnumDevicesBySemantics>
 *          which translates the UNICODE parameters to ANSI.
 *
 *  @parm   IN LPCDIDECICEINSTANCEW | pdiW |
 *
 *          Same as <mf IDirectInput::EnumDevices>.
 *
 *  @parm   IN OUT PV | pvRef |
 *
 *          Pointer to <t struct ENUMDEVICESBYSEMANTICSINFO> which describes
 *          the original callback.
 *
 *  @returns
 *
 *          Returns whatever the original callback returned.
 *
 *****************************************************************************/

typedef struct ENUMDEVICESBYSEMANTICSINFO
{
    LPDIENUMDEVICESBYSEMANTICSCBA pecA;
    PV pvRef;
} ENUMDEVICESBYSEMANTICSINFO, *PENUMDEVICESBYSEMANTICSINFO;

BOOL CALLBACK
CDIObj_EnumDevicesBySemanticsCallback(LPCDIDEVICEINSTANCEW pdiW, LPDIRECTINPUTDEVICE8W pdid8W, DWORD dwFlags, DWORD dwDeviceRemaining, PV pvRef)
{
    PENUMDEVICESBYSEMANTICSINFO pesdi = pvRef;
    BOOL fRc;
    DIDEVICEINSTANCEA diA;
    LPDIRECTINPUTDEVICE8A pdid8A = NULL;

    EnterProc(CDIObj_EnumDevicesBySemanticsCallback,
              (_ "GGxWWp", &pdiW->guidInstance, &pdiW->guidProduct,
               &pdiW->dwDevType,
               pdiW->tszProductName, pdiW->tszInstanceName,
               pvRef));

    diA.dwSize = cbX(diA);
    DeviceInfoWToA(&diA, pdiW);
    Device8WTo8A(&pdid8A, pdid8W);

    fRc = pesdi->pecA(&diA, pdid8A, dwFlags, dwDeviceRemaining, pesdi->pvRef);

    ExitProcX(fRc);
    return(fRc);
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput | EnumDevicesBySemantics |
 *
 *          Enumerates devices suitable for the application specified
 *          <t DIACTIONFORMAT>.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  ISSUE-2001/03/29-timgill Need to fix auto docs
 *  @parm   LPTSTR  | lptszActionMap |
 *
 *          Friendly name for the application.
 *
 *  @parm   REFGUID | rguid |
 *
 *          Unique GUID to identify the application.
 *
 *  @returns
 *
 *          Standard OLE <t HRESULT>.
 *
 *****************************************************************************/
STDMETHODIMP CDIObj_EnumDevicesBySemanticsA
(
PV                       pDiA,
LPCSTR                   lpszUserName,
LPDIACTIONFORMATA        pDiActionFormat,
LPDIENUMDEVICESBYSEMANTICSCBA   pecA,
LPVOID                   pvRef,
DWORD                    dwFlags
)
{
    HRESULT hres;

    EnterProcR(IDirectInput8::EnumDevicesBySemantics,
               (_ "pppppx", pDiA, lpszUserName, pDiActionFormat, pecA, pvRef, dwFlags));

    /*
     *  EnumDevicesBySemanticsW will validate the rest.
     */
    if ( SUCCEEDED(hres = hresPvI(pDiA, ThisInterfaceA)) &&
         SUCCEEDED(hres = IsValidMapObjectA(pDiActionFormat D(comma s_szProc comma 2))) &&
         (lpszUserName == NULL || SUCCEEDED(hres = hresFullValidReadStrA(lpszUserName, UNLEN+1, 1))) &&
         SUCCEEDED(hres = hresFullValidPfn(pecA, 3)) &&
         SUCCEEDED(hres = hresFullValidFl(dwFlags, DIEDBSFL_VALID, 5))
       )
    {
        PDDI this = _thisPvNm(pDiA, diA);
        ENUMDEVICESBYSEMANTICSINFO esdi = { pecA, pvRef};
        WCHAR wszUserName[MAX_PATH];
        DIACTIONFORMATW diafW;
        LPDIACTIONW rgoActionW;

        wszUserName[0] = L'\0';
        if( lpszUserName ) {
            AToU(wszUserName, MAX_PATH, lpszUserName);
        }

        /*
         *  Assert that the structure can be copied as:
         *      a)  dwSize
         *      b)  everything else
         *      c)  the app name
         */
        CAssertF( FIELD_OFFSET( DIACTIONFORMATW, dwSize ) == 0 );
        CAssertF( FIELD_OFFSET( DIACTIONFORMATA, dwSize ) == 0 );

        CAssertF( FIELD_OFFSET( DIACTIONFORMATW, dwSize ) + cbX( ((LPDIACTIONFORMATW)0)->dwSize )
               == FIELD_OFFSET( DIACTIONFORMATW, dwActionSize ) );
        #if defined(_WIN64)
            CAssertF( ( ( cbX( DIACTIONFORMATW ) - cbX( ((LPDIACTIONFORMATW)0)->tszActionMap ) )
                      - ( cbX( DIACTIONFORMATA ) - cbX( ((LPDIACTIONFORMATA)0)->tszActionMap ) ) 
                    < MAX_NATURAL_ALIGNMENT ) );
        #else
            CAssertF( ( cbX( DIACTIONFORMATW ) - cbX( ((LPDIACTIONFORMATW)0)->tszActionMap ) )
                   == ( cbX( DIACTIONFORMATA ) - cbX( ((LPDIACTIONFORMATA)0)->tszActionMap ) ) );
        #endif

        CAssertF( FIELD_OFFSET( DIACTIONFORMATW, tszActionMap ) 
               == FIELD_OFFSET( DIACTIONFORMATA, tszActionMap ) );
        CAssertF( cA( ((LPDIACTIONFORMATW)0)->tszActionMap ) == cA( ((LPDIACTIONFORMATA)0)->tszActionMap ) );

        //Init diafW fields
        diafW.dwSize = cbX(DIACTIONFORMATW);

        memcpy( &diafW.dwActionSize, &pDiActionFormat->dwActionSize, 
            FIELD_OFFSET( DIACTIONFORMATW, tszActionMap ) - FIELD_OFFSET( DIACTIONFORMATW, dwActionSize ) );

        AToU(diafW.tszActionMap,  cbX(pDiActionFormat->tszActionMap), pDiActionFormat->tszActionMap);

        if ( SUCCEEDED( hres = AllocCbPpv( cbCxX(pDiActionFormat->dwNumActions, DIACTIONW), &rgoActionW) ) )
        {
            memcpy( rgoActionW, pDiActionFormat->rgoAction, sizeof(DIACTIONA) * pDiActionFormat->dwNumActions );
            diafW.rgoAction = rgoActionW;

            hres = CDIObj_EnumDevicesBySemanticsW(&this->diW, wszUserName,
                                                  &diafW,
                                                  CDIObj_EnumDevicesBySemanticsCallback,
                                                  &esdi, dwFlags);
            FreePpv(&rgoActionW);
        }
    }

    ExitOleProcR();
    return(hres);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresValidSurface |
 *
 *          Tests the interface pointer for a valid surface of sufficient 
 *          dimensions to display the UI and with a supported pixel format.
 *
 *  @parm   IUnknown* | lpUnkDDSTarget | 
 *
 *          Pointer to an interface which must be validated as a COM object
 *          before calling this function.
 *
 *  @returns
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpUnkDDSTarget> parameter is not valid.
 *          A DirectDraw or D3D error if one was returned.
 *          or a Standard OLE <t HRESULT>.
 *
 *****************************************************************************/


HRESULT INLINE hresValidSurface
(
    IUnknown*   lpUnkDDSTarget
) 
{
    HRESULT     hres;
    IUnknown*   lpSurface = NULL;

/*
 *  Short on time, so take short-cuts in validation debug error messages
 */
#ifdef XDEBUG
    CHAR        s_szProc[] = "IDirectInput8::ConfigureDevices";
#endif
    #define     ArgIS   2

    if( SUCCEEDED( hres = lpUnkDDSTarget->lpVtbl->QueryInterface( 
        lpUnkDDSTarget, &IID_IDirect3DSurface8, (LPVOID*)&lpSurface ) ) )
    {
        D3DSURFACE_DESC SurfDesc;

        hres = ((IDirect3DSurface8*)lpSurface)->lpVtbl->GetDesc( ((IDirect3DSurface8*)lpSurface), &SurfDesc );

        if( FAILED( hres ) )
        {
            RPF( "%s: Arg %d: Unable to GetDesc on surface, error 0x%08x", s_szProc, ArgIS, hres );
            /*
             *  D3D returns real HRESULTs which can be returned to the caller
             */
        }
        else
        {
            if( ( SurfDesc.Width < 640 ) || ( SurfDesc.Height < 480 ) )
            {
                RPF( "%s: Arg %d: cannot use %d by %d surface", 
                    s_szProc, ArgIS, SurfDesc.Width, SurfDesc.Height );
                hres = E_INVALIDARG;
            }
            else
            {
                switch( SurfDesc.Format )
                {
                case D3DFMT_R8G8B8:
                case D3DFMT_A8R8G8B8:
                case D3DFMT_X8R8G8B8:
                case D3DFMT_R5G6B5:
                case D3DFMT_X1R5G5B5:
                case D3DFMT_A1R5G5B5:
                    SquirtSqflPtszV(sqfl | sqflVerbose,
                        TEXT("ConfigureDevices: validated %d by %d format %d surface"), 
                        SurfDesc.Width, SurfDesc.Height, SurfDesc.Format );
                    break;
                default:
                    RPF( "%s: Arg %d: cannot use surface format %d ", s_szProc, ArgIS, SurfDesc.Format );
                    hres = E_INVALIDARG;
                    break;
                }
            }
        }
    }
    else
    {
        DDSURFACEDESC2 SurfDesc;
        SurfDesc.dwSize = cbX( SurfDesc );

        if( SUCCEEDED(hres = lpUnkDDSTarget->lpVtbl->QueryInterface(
            lpUnkDDSTarget, &IID_IDirectDrawSurface7, (LPVOID*) &lpSurface)) )
        {
            hres = ((IDirectDrawSurface7*)lpSurface)->lpVtbl->GetSurfaceDesc( ((IDirectDrawSurface7*)lpSurface), &SurfDesc );
        }
        else if( SUCCEEDED(hres = lpUnkDDSTarget->lpVtbl->QueryInterface(
            lpUnkDDSTarget, &IID_IDirectDrawSurface4, (LPVOID*) &lpSurface )) )
        {
            hres = ((IDirectDrawSurface4*)lpSurface)->lpVtbl->GetSurfaceDesc( ((IDirectDrawSurface4*)lpSurface), &SurfDesc );
        }

        if( FAILED( hres ) )
        {
            if( lpSurface )
            {
                RPF( "%s: Arg %d: failed GetSurfaceDesc, error 0x%08x", s_szProc, ArgIS, hres );
            }
            else
            {
                RPF( "%s: Arg %d: failed QI for supported surface interfaces from %p, error 0x%08x", 
                    s_szProc, ArgIS, lpSurface, hres );
            }
            /*
             *  DDraw returns real HRESULTs which can be returned to the caller
             */
        }
        else if( ( SurfDesc.dwWidth < 640 ) || ( SurfDesc.dwHeight < 480 ) )
        {
            RPF( "%s: Arg %d: cannot use %d by %d surface", 
                s_szProc, ArgIS, SurfDesc.dwWidth, SurfDesc.dwHeight );
            hres = E_INVALIDARG;
        }
        else
        {
            /*
             *  Check for the eqivalent of the DX8 surfaces: 
             *      A8R8G8B8, X8R8G8B8, R8G8B8, A1R5G5B5, X1R5G5B5, R5G6B5
             */
            if( SurfDesc.ddpfPixelFormat.dwFlags & DDPF_RGB )
            {
                if( SurfDesc.ddpfPixelFormat.dwRGBBitCount > 16 )
                {
                    AssertF( ( SurfDesc.ddpfPixelFormat.dwRGBBitCount == 32 )
                           ||( SurfDesc.ddpfPixelFormat.dwRGBBitCount == 24 ) );
                    /*
                     *  All of these must be R8 G8 B8
                     */
                    if( ( SurfDesc.ddpfPixelFormat.dwRBitMask == 0x00FF0000 )
                     && ( SurfDesc.ddpfPixelFormat.dwGBitMask == 0x0000FF00 )
                     && ( SurfDesc.ddpfPixelFormat.dwBBitMask == 0x000000FF ) )
                    {
                        SquirtSqflPtszV(sqfl | sqflVerbose,
                            TEXT("ConfigureDevices: validated %d by %d format R8G8B8 %d bit surface"), 
                            SurfDesc.dwWidth, SurfDesc.dwHeight, SurfDesc.ddpfPixelFormat.dwRGBBitCount );
                    }
                    else
                    {
                        RPF( "%s: Arg %d: cannot use surface pixel format", s_szProc, ArgIS );
                        hres = E_INVALIDARG;
                    }
                }
                else
                {
                    if( SurfDesc.ddpfPixelFormat.dwRGBBitCount == 16 )
                    {
                        /*
                         *  Allow R5 G5 B5 and R5 G6 B5
                         */
                        if( ( SurfDesc.ddpfPixelFormat.dwBBitMask == 0x0000001F )
                         && ( ( SurfDesc.ddpfPixelFormat.dwGBitMask == 0x000003E0 )
                           && ( SurfDesc.ddpfPixelFormat.dwRBitMask == 0x00007C00 ) )
                         || ( ( SurfDesc.ddpfPixelFormat.dwGBitMask == 0x000007E0 )
                           && ( SurfDesc.ddpfPixelFormat.dwRBitMask == 0x0000F800 ) ) )
                        {
                            SquirtSqflPtszV(sqfl | sqflVerbose,
                                TEXT("ConfigureDevices: validated %d by %d format 16 bit surface"), 
                                SurfDesc.dwWidth, SurfDesc.dwHeight );
                        }
                        else
                        {
                            RPF( "%s: Arg %d: cannot use 16 bit surface pixel format", s_szProc, ArgIS );
                            hres = E_INVALIDARG;
                        }
                    }
                    else
                    {
                        RPF( "%s: Arg %d: cannot use %d bit surface pixel format", 
                            s_szProc, ArgIS, SurfDesc.ddpfPixelFormat.dwRGBBitCount );
                        hres = E_INVALIDARG;
                    }
                }
            }
            else
            {
                RPF( "%s: Arg %d: cannot use non RGB surface, Surface.dwFlags = 0x%08x", 
                    s_szProc, ArgIS, SurfDesc.ddpfPixelFormat.dwFlags );
                hres = E_INVALIDARG;
            }
        }
    }

    if( lpSurface != NULL )
    {
        lpSurface->lpVtbl->Release( lpSurface );
    }

    return hres;

    #undef ArgIS
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput | ConfigureDevices |
 *
 *          Configures the devices by attaching mappings provided  in
 *          <t DIACTIONFORMAT> to appropriate device controls.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   LPCTSTR       | lpctszUserName | 
 *
 *          User Name.
 *
 *  @parm   LPDIACTIONFORMAT | lpDiActionFormat |
 *
 *          Pointer to the <t DIACTIONFORMAT> structure containing the action map.
 *
 *
 *  @returns
 *
 *          Standard OLE <t HRESULT>.
 *
 *****************************************************************************/


STDMETHODIMP CDIObj_ConfigureDevicesCore
(
PV                                                          pDiW,
LPDICONFIGUREDEVICESCALLBACK                                lpdiCallback,
LPDICONFIGUREDEVICESPARAMSW                                 lpdiCDParams,
DWORD                                                       dwFlags,
LPVOID                                                      pvRefData                                               
)

{
    //the real ConfigureDevices()
    //some stuff should have been validated already
    HRESULT hres = S_OK;

    EnterProcI(IDirectInput8::ConfigureDevicesCore,
              (_ "pppup", pDiW, lpdiCallback,lpdiCDParams, dwFlags, pvRefData));

    if( SUCCEEDED( hres = hresFullValidFl( dwFlags, DICD_VALID, 3 ) )
     && SUCCEEDED( hres = hresFullValidReadPvCb( &(lpdiCDParams->dics), sizeof(DICOLORSET), 2 ) ) )
    {
        /*
         *  lpUnkDDSTarget and lpdiCallback are "coupled", because the only 
         *  function of the callback is to display the updates to the surface
         *  either they are both NULL, or they are both non-NULL and valid.
         *  otherwise, it is an error.
         */
        if( lpdiCallback == NULL )
        {
            if( lpdiCDParams->lpUnkDDSTarget == NULL )
            {
                hres = S_OK;
            }
            else
            {
                RPF( "%s: Arg %d or %d: neither or both of callback and surface must be NULL", 
                    s_szProc, 1, 2 );
                hres = E_INVALIDARG;
            }
        }
        else if( lpdiCDParams->lpUnkDDSTarget == NULL )
        {
            RPF( "%s: Arg %d or %d: neither or both of surface and callback must be NULL", 
                s_szProc, 2, 1 );
            hres = E_INVALIDARG;
        }
        else if( SUCCEEDED( hres = hresFullValidPfn( lpdiCallback, 1 ) )
              && SUCCEEDED( hres = hresFullValidPitf( lpdiCDParams->lpUnkDDSTarget, 2 ) ) )
        {
            hres = hresValidSurface( lpdiCDParams->lpUnkDDSTarget );
        }

        if( SUCCEEDED( hres ) )
        {
            //load the framework
            HINSTANCE hinst;
            IDirectInputActionFramework* pDIAcFrame = NULL;
            TCHAR tszName[ctchNameGuid];
            TCHAR tszClsid[ctchGuid];

            NameFromGUID(tszName, &CLSID_CDirectInputActionFramework);
            memcpy(tszClsid, &tszName[ctchNamePrefix], cbX(tszClsid) );

            hres = DICoCreateInstance(tszClsid, NULL, &IID_IDIActionFramework, (LPVOID*) & pDIAcFrame, &hinst);

            if( SUCCEEDED(hres) )
            {
                //for getting default user name, if needed
                LPWSTR pwszUserName = NULL;

                //can't pass NULL user name down to the framework -- need to get the default user name
                if( lpdiCDParams->lptszUserNames == NULL )
                {
                    hres = GetWideUserName(NULL, NULL, &pwszUserName);
                    lpdiCDParams->lptszUserNames = pwszUserName;
                    lpdiCDParams->dwcUsers = 1;
                }

                if( SUCCEEDED(hres) )
                {
                    //call the framework
                    hres = pDIAcFrame->lpVtbl->ConfigureDevices
                                            (
                                            pDIAcFrame,
                                            lpdiCallback,
                                            lpdiCDParams,
                                            dwFlags,
                                            pvRefData);

                    if( SUCCEEDED(hres) )
                    {
                        SquirtSqflPtszV( sqfl | sqflVerbose,
                            TEXT("Default Remapping UI returned 0x%08x"), hres );
                    }
                    else
                    {
                        SquirtSqflPtszV( sqfl | sqflError,
                            TEXT("Default Remapping UI returned error 0x%08x"), hres );
                    }

                    //release pwsUserName, if we have used it
                    FreePpv(&pwszUserName);
                }

                FreeLibrary( hinst );
            }
        }
    }

    ExitOleProc();
    return hres;
}




STDMETHODIMP CDIObj_ConfigureDevicesW
(
PV                                                          pDiW,
LPDICONFIGUREDEVICESCALLBACK                                lpdiCallback,
LPDICONFIGUREDEVICESPARAMSW                                 lpdiCDParams,
DWORD                                                       dwFlags,
LPVOID                                                      pvRefData
)
{
    HRESULT hres = S_OK;


    EnterProcR(IDirectInput8::ConfigureDevices,
               (_ "pppxp", pDiW, lpdiCallback,lpdiCDParams, dwFlags, pvRefData));
               
    //validate all the ptrs
    if ( (SUCCEEDED(hres = hresPvI(pDiW, ThisInterfaceW)) &&
         (SUCCEEDED(hres = hresFullValidReadPvCb(lpdiCDParams, sizeof(DICONFIGUREDEVICESPARAMSW), 2))) &&
         ((lpdiCDParams->lptszUserNames == NULL) || (SUCCEEDED(hres = hresFullValidReadStrW((LPWSTR)(lpdiCDParams->lptszUserNames), MAX_JOYSTRING * (lpdiCDParams->dwcUsers), 2)))) &&
    (SUCCEEDED(hres = hresFullValidReadPvCb(lpdiCDParams->lprgFormats, lpdiCDParams->dwcFormats*sizeof(DIACTIONFORMATW), 2)))))
    {

    if( lpdiCDParams->dwSize != cbX(DICONFIGUREDEVICESPARAMSW) )
        {
            RPF("IDirectInput::%s: Invalid DICONFIGUREDEVICESPARAMSW.dwSize 0x%08x",
                lpdiCDParams->dwSize ); 
            hres = E_INVALIDARG;
        }

        if (SUCCEEDED(hres))
    {

        PDDI this = _thisPvNm(pDiW, diW);

        //params structure
        DICONFIGUREDEVICESPARAMSW diconfparamsW;
        //to translate each DIACTIONFORMAT
        LPDIACTIONFORMATW* lpDiAfW = NULL;
        //the cloning array of DIACTIONFORMATs
        LPDIACTIONFORMATW* lpDAFW = NULL;
        //to traverse the old array
        LPDIACTIONFORMATW lpDIFormat;
        //to traverse the new array
        LPDIACTIONFORMATW lpDIF;
        //user names
        LPWSTR lpUserNames = NULL;
        //DIACTIONFORMATs cloned
        DWORD clonedF = 0;
        //length of user names
        DWORD strLen = 0;
    
        //zero out
        ZeroMemory(&diconfparamsW, sizeof(DICONFIGUREDEVICESPARAMSW));
        //set the size
        diconfparamsW.dwSize = sizeof(DICONFIGUREDEVICESPARAMSW);


        //1. Validate and translate each LPDIACTIONFORMAT in the array
        lpDIFormat = (lpdiCDParams->lprgFormats);
        //allocate the new array
        hres = AllocCbPpv(lpdiCDParams->dwcFormats * sizeof(DIACTIONFORMATW), &diconfparamsW.lprgFormats);
        if (FAILED(hres))
        { 
            goto cleanup;
        }
        lpDIF = diconfparamsW.lprgFormats;
        //allocate the cloning array
        hres = AllocCbPpv(lpdiCDParams->dwcFormats * sizeof(DIACTIONFORMATW), &lpDAFW);
        if (FAILED(hres))
        { 
            goto cleanup;
        }
        lpDiAfW = lpDAFW;
        //clone
        for (clonedF = 0; clonedF < lpdiCDParams->dwcFormats; clonedF ++)
        {
                //validate
            hres = IsValidMapObjectW(lpDIFormat D(comma s_szProc comma 2));
            if (FAILED(hres))
            {
                goto cleanup;
            }
            //translate
            hres = DiActionFormatWtoW(lpDIFormat, lpDiAfW); 
            if (FAILED(hres))
            {
                goto cleanup;
            }
            //save
            *lpDIF = *(*lpDiAfW);
            //move on
            lpDIFormat++;
            lpDiAfW++;
            lpDIF++;
        }
        //if everything went fine, should have cloned all
        AssertF(clonedF == lpdiCDParams->dwcFormats);

        //2. Copy the user names
        if (lpdiCDParams->lptszUserNames != NULL)
        {
            DWORD countN;
            WCHAR* lpName = lpdiCDParams->lptszUserNames;
            for (countN = 0; countN < lpdiCDParams->dwcUsers; countN ++)
            {
                DWORD Len;
                hres = hresFullValidReadStrW(lpName, MAX_JOYSTRING, 2);
                if (FAILED(hres))
                {
                    goto cleanup;
                }
                Len = lstrlenW(lpName);
                //if length is 0  -- and we haven't reached the correct user count yet -
                //then it is an error
                if (Len == 0)
                {
                    hres = DIERR_INVALIDPARAM;
                    goto cleanup;
                }
                //move on to the next user name
                strLen += Len + 1;
                lpName += Len + 1;
            }
            //if everything went fine, should have traversed all the user names
            AssertF(countN == lpdiCDParams->dwcUsers);
            //allocate
                        hres = AllocCbPpv( (strLen + 1) * 2, &lpUserNames );
                if (FAILED(hres))
                        {
                goto cleanup;
                        }
            //copy
                memcpy(lpUserNames, lpdiCDParams->lptszUserNames, strLen*2);
            diconfparamsW.lptszUserNames = lpUserNames;
         }
  

        //3. Populate the rest of the structure
        diconfparamsW.dwcUsers = lpdiCDParams->dwcUsers;
        diconfparamsW.dwcFormats = clonedF;
        diconfparamsW.hwnd = lpdiCDParams->hwnd;
        diconfparamsW.dics = lpdiCDParams->dics;
        diconfparamsW.lpUnkDDSTarget = lpdiCDParams->lpUnkDDSTarget;
                
        //4. Call the framework
        hres = CDIObj_ConfigureDevicesCore
                        (
                        &this->diW,
                        lpdiCallback,
                        &diconfparamsW,
                        dwFlags,
                        pvRefData);

cleanup:;

        //free the space for the new array
        FreePpv(&diconfparamsW.lprgFormats);
        //free as many DIACTIONFORMATs as were created
        if (lpDAFW)
        {
            lpDiAfW = lpDAFW;
            for (clonedF; clonedF > 0; clonedF--)
            {
                FreeDiActionFormatW(lpDiAfW);
                lpDiAfW++;      
            }
            //delete the entire block
            FreePpv(&lpDAFW);
        }

        //delete the user names
        FreePpv(&lpUserNames);

         }
    }

    ExitOleProc();
    return(hres);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DiActionFormatAtoW |
 *
 *          Copies LPDIACTIONFORMATA to  LPDIACTIONFORMATW
 *
 *  @parm   const LPDIACTIONFORMATA | lpDiAfA | 
 *
 *          Original.
 *
 *  @parm   LPDIACTIONFORMATW* | lplpDiAfW |
 *
 *          Address of a pointer to a <t DIACTIONFORMATW> that receives the converted
 *          ACTIONFORMAT.
 *  @returns
 *
 *          Standard OLE <t HRESULT>.
 *
 *****************************************************************************/

HRESULT EXTERNAL DiActionFormatAtoW
(
const LPDIACTIONFORMATA lpDiAfA,
LPDIACTIONFORMATW* lplpDiAfW
)
{
    DWORD cbAlloc;
    PDWORD pdwStrLen, pdwStrLen0;
    LPDIACTIONFORMATW lpDiAfW;
    LPDIACTIONA lpDiAA;
    LPDIACTIONW lpDiAW;
    DWORD i;
    HRESULT hres;

    EnterProcI(DiActionFormatAtoW, (_ "xx", lpDiAfA, lplpDiAfW));

    // Internal function, no validation

    *lplpDiAfW = NULL;

    /*
     *  PREFIX complains (mb:37926 - item 2) that we could be requesting a 
     *  zero byte allocation which would not allocate anything.  This is 
     *  never the case because CDIDev_ActionMap_IsValidMapObject tests that 
     *  dwNumActions is less than 2^24.  Assert in debug for extra safety.
     */
    AssertF( (lpDiAfA->dwNumActions +1)*cbX(*pdwStrLen0) );
    hres = AllocCbPpv( (lpDiAfA->dwNumActions +1)*cbX(*pdwStrLen0) , &pdwStrLen0);

    if ( SUCCEEDED(hres) )
    {
        // Compute the amount of memory required to clone the DIACTIONFORMATA
        cbAlloc =
        /* 1: The wide form of the Action Format array */
        cbX(DIACTIONFORMATW)
        /* 2: Each of the DIACTION arrays */
        + lpDiAfA->dwActionSize * lpDiAfA->dwNumActions;

        pdwStrLen = pdwStrLen0;

        // Compute the size for each of the text strings in array of DIACTIONs
        for ( i = 0x0, lpDiAA = lpDiAfA->rgoAction;
            i < lpDiAfA->dwNumActions ;
            i++, lpDiAA++ )
        {
            // Handle the NULL ptr case
            if ( NULL != lpDiAA->lptszActionName )
            {
                /* 3: Text string in each DIACTION array*/
                // Conversion from A to U, need  multiplier
                // ISSUE-2001/03/29-timgill (MarcAnd), A to U conversions are not always 1 to 1.
                *pdwStrLen =  lstrlenA(lpDiAA->lptszActionName) + 1;
                cbAlloc += cbX(lpDiAW->lptszActionName[0]) * ( *pdwStrLen++ );
            }
        }

        if ( SUCCEEDED( hres = AllocCbPpv(cbAlloc, &lpDiAfW) ) )
        {
            DWORD dwLen;
            DWORD cb;

            pdwStrLen = pdwStrLen0;

            // 1: Copy the DIACTIONFORMAT
            /*
             *  Assert that the structure can be copied as:
             *      a)  dwSize
             *      b)  everything else
             *      c)  the app name
             */
            CAssertF( FIELD_OFFSET( DIACTIONFORMATW, dwSize ) == 0 );
            CAssertF( FIELD_OFFSET( DIACTIONFORMATA, dwSize ) == 0 );

            CAssertF( FIELD_OFFSET( DIACTIONFORMATW, dwSize ) + cbX( ((LPDIACTIONFORMATW)0)->dwSize )
                   == FIELD_OFFSET( DIACTIONFORMATW, dwActionSize ) );
            #if defined(_WIN64)
                CAssertF( ( ( cbX( DIACTIONFORMATW ) - cbX( ((LPDIACTIONFORMATW)0)->tszActionMap ) )
                          - ( cbX( DIACTIONFORMATA ) - cbX( ((LPDIACTIONFORMATA)0)->tszActionMap ) ) 
                        < MAX_NATURAL_ALIGNMENT ) );
            #else
                CAssertF( ( cbX( DIACTIONFORMATW ) - cbX( ((LPDIACTIONFORMATW)0)->tszActionMap ) )
                       == ( cbX( DIACTIONFORMATA ) - cbX( ((LPDIACTIONFORMATA)0)->tszActionMap ) ) );
            #endif

            CAssertF( FIELD_OFFSET( DIACTIONFORMATW, tszActionMap ) 
                   == FIELD_OFFSET( DIACTIONFORMATA, tszActionMap ) );
            CAssertF( cA( ((LPDIACTIONFORMATW)0)->tszActionMap ) == cA( ((LPDIACTIONFORMATA)0)->tszActionMap ) );

            //  Init counts and lpDiAfW fields 
            dwLen = lpDiAfA->dwActionSize * lpDiAfA->dwNumActions;
            cb = lpDiAfW->dwSize = cbX(DIACTIONFORMATW);

            memcpy( &lpDiAfW->dwActionSize, &lpDiAfA->dwActionSize, 
                FIELD_OFFSET( DIACTIONFORMATW, tszActionMap ) - FIELD_OFFSET( DIACTIONFORMATW, dwActionSize ) );

            AToU(lpDiAfW->tszActionMap,  cbX(lpDiAfA->tszActionMap), lpDiAfA->tszActionMap);


            // 2: Block copy the DIACTION array
            CAssertF(cbX(*lpDiAfW->rgoAction) == cbX(*lpDiAfA->rgoAction) )
            lpDiAfW->rgoAction = (LPDIACTIONW)( (char*)lpDiAfW + cb);
            dwLen = lpDiAfA->dwActionSize * lpDiAfA->dwNumActions;
            memcpy(lpDiAfW->rgoAction, lpDiAfA->rgoAction, dwLen);
            cb += dwLen;

            // 3: ActionName
            // Convert each of the strings in the ACTION array  from A to W
            for ( i = 0x0, lpDiAA=lpDiAfA->rgoAction, lpDiAW=lpDiAfW->rgoAction;
                i < lpDiAfW->dwNumActions ;
                i++, lpDiAA++, lpDiAW++ )
            {
                if ( lpDiAA->lptszActionName != NULL )
                {
                    WCHAR* wsz =  (WCHAR*) ((char*)lpDiAfW+cb);
                    lpDiAW->lptszActionName = wsz;

                    dwLen = (*pdwStrLen++);

                    AToU( wsz, dwLen, lpDiAA->lptszActionName);

                    cb += dwLen * cbX(lpDiAW->lptszActionName[0]) ;
                } else
                {
                    //  Resource strings are handled in DiActionFormatWtoW
                    //  OK for now, as long as UI always uses CloneDiActionFormatW
                    lpDiAW->lptszActionName = NULL;
                }
            }


            // If we have not done something goofy, the memory allocates should match
            // the memory we used
            AssertF(cbAlloc == cb );
            *lplpDiAfW = lpDiAfW;

        }
        FreePpv(&pdwStrLen0);
    }

    ExitOleProc();
    return(hres);
}


STDMETHODIMP CDIObj_ConfigureDevicesA
(
PV                                                          pDiA,
LPDICONFIGUREDEVICESCALLBACK                                lpdiCallback,
LPDICONFIGUREDEVICESPARAMSA                                 lpdiCDParams,
DWORD                                                       dwFlags,
LPVOID                                                      pvRefData
)
{

    HRESULT hres = S_OK;

    EnterProcR(IDirectInput8::ConfigureDevices,
               (_ "pppxp", pDiA, lpdiCallback, lpdiCDParams, dwFlags, pvRefData));

    /*
     *  ConfigureDevicesCore will validate the rest.
     */
    if ( (SUCCEEDED(hres = hresPvI(pDiA, ThisInterfaceA)) &&
          (SUCCEEDED(hres = hresFullValidReadPvCb(lpdiCDParams, sizeof(DICONFIGUREDEVICESPARAMSA), 2)) &&
          ((lpdiCDParams->lptszUserNames == NULL) || (SUCCEEDED(hres = hresFullValidReadStrA((LPSTR)(lpdiCDParams->lptszUserNames), MAX_JOYSTRING * (lpdiCDParams->dwcUsers), 2)))) &&
      (SUCCEEDED(hres = hresFullValidReadPvCb(lpdiCDParams->lprgFormats, lpdiCDParams->dwcFormats*sizeof(DIACTIONFORMATA), 2))))))

    {

        if( lpdiCDParams->dwSize != cbX(DICONFIGUREDEVICESPARAMSA) )
        {
            RPF("IDirectInput::%s: Invalid DICONFIGUREDEVICESPARAMSA.dwSize 0x%08x",
                lpdiCDParams->dwSize );
            hres = E_INVALIDARG;
        }


    if (SUCCEEDED(hres))
    {

        PDDI this = _thisPvNm(pDiA, diA);

        //params structure
        DICONFIGUREDEVICESPARAMSW diconfparamsW;
        //to translate each DIACTIONFORMAT
        LPDIACTIONFORMATW* lpDiAfW = NULL;
        //the new array of DIACTIONFORMATs
        LPDIACTIONFORMATW* lpDAFW = NULL;
        //to traverse the old array
        LPDIACTIONFORMATA lpDIFormat;
        //to traverse the new array
        LPDIACTIONFORMATW lpDIF;
        //to keep the new user name
        LPWSTR lpUserNames = NULL;
        //to know how many DIACTIONFORMATS we have cloned successfully
        DWORD clonedF = 0;
        //kength of user names string
        DWORD strLen = 0;

        //zero out
        ZeroMemory(&diconfparamsW, sizeof(DICONFIGUREDEVICESPARAMSW));
        //set the size
        diconfparamsW.dwSize = sizeof(DICONFIGUREDEVICESPARAMSW);

        //1. Validate and translate each LPDIACTIONFORMAT in the array
        lpDIFormat = (lpdiCDParams->lprgFormats);
        //allocate the new array
        hres = AllocCbPpv(lpdiCDParams->dwcFormats * sizeof(DIACTIONFORMATW), &diconfparamsW.lprgFormats);
        if (FAILED(hres))
        { 
            goto cleanup;
        }
        lpDIF = diconfparamsW.lprgFormats;
        //allocate the cloning array
        hres = AllocCbPpv(lpdiCDParams->dwcFormats * sizeof(DIACTIONFORMATW), &lpDAFW);
        if (FAILED(hres))
        { 
            goto cleanup;
        }
        lpDiAfW = lpDAFW;
        //clone
        for (clonedF = 0; clonedF < lpdiCDParams->dwcFormats; clonedF ++)
        {
                //validate
            hres = IsValidMapObjectA(lpDIFormat D(comma s_szProc comma 2));
            if (FAILED(hres))
            {
                goto cleanup;
            }
            //translate
            hres = DiActionFormatAtoW(lpDIFormat, lpDiAfW); 
            if (FAILED(hres))
            {
                goto cleanup;
            }
            //save
            *lpDIF = *(*lpDiAfW);
            //move on
            lpDIFormat++;
            lpDiAfW++;
            lpDIF++;
        }
        //if everything went fine, should have cloned all
        AssertF(clonedF == lpdiCDParams->dwcFormats);       
                 
        
        //2. Copy the user names
        if (lpdiCDParams->lptszUserNames != NULL)
        {
            DWORD countN;
            DWORD Len;
            //to traverse new user names
            WCHAR* lpNameW;
            CHAR* lpName = lpdiCDParams->lptszUserNames;
            //go throught all the user names
            for ( countN = 0; countN < lpdiCDParams->dwcUsers; countN ++)
            {  
                hres = hresFullValidReadStrA(lpName, MAX_JOYSTRING, 2);
                if (FAILED(hres))
                {
                    goto cleanup;
                }
                Len = lstrlenA(lpName);
                //if length is 0  -- and we haven't reached the correct user count yet -
                //then it is an error
                if (Len == 0)
                {
                    hres = DIERR_INVALIDPARAM;
                    goto cleanup;
                }
                //move on to the next user name
                strLen += Len + 1;
                lpName += Len + 1;
            }   
            //if everything went fine, should have traversed all the user names
            AssertF(countN == lpdiCDParams->dwcUsers);
            //allocate
            hres = AllocCbPpv( (strLen + 1) * 2, &lpUserNames );
            if (FAILED(hres))
            {
                goto cleanup;
            }
            //translate
            //AToU stops at the first '\0', so we have to go in a loop
            lpName = lpdiCDParams->lptszUserNames;
            lpNameW = lpUserNames;
            //go throught all the user names
            for ( countN = 0; countN < lpdiCDParams->dwcUsers; countN ++)
            {  
                Len = lstrlenA(lpName);
                AToU(lpNameW, Len + 1, lpName);
                lpName += Len + 1;
                lpNameW += Len + 1;
            }
            //save
            diconfparamsW.lptszUserNames = lpUserNames;
        }

                
        //3. Populate the rest of the structure
        diconfparamsW.dwcUsers = lpdiCDParams->dwcUsers;
        diconfparamsW.dwcFormats = clonedF;
        diconfparamsW.hwnd = lpdiCDParams->hwnd;
        diconfparamsW.dics = lpdiCDParams->dics;
        diconfparamsW.lpUnkDDSTarget = lpdiCDParams->lpUnkDDSTarget;
                        
        //4.Call the framework
        hres = CDIObj_ConfigureDevicesCore
                        (
                        &this->diW,
                        lpdiCallback,
                        &diconfparamsW,
                        dwFlags,
                        pvRefData);
    
        


cleanup:;

        //free the sapce for the array
        FreePpv(&diconfparamsW.lprgFormats);
        //free as many DIACTIONFORMATs as were created
        if (lpDAFW)
        {
            lpDiAfW = lpDAFW;
            for (clonedF; clonedF > 0; clonedF--)
            {
                FreeDiActionFormatW(lpDiAfW);
                lpDiAfW++;      
            }
            //delete the entire block
            FreePpv(&lpDAFW);
        }    
        //free the user names, if allocated
        FreePpv(&lpUserNames);
    }
    }

    ExitOleProc();
    return(hres);
}


/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define CDIObj_Signature        0x504E4944      /* "DINP" */

Interface_Template_Begin(CDIObj)
Primary_Interface_Template(CDIObj, TFORM(ThisInterfaceT))
Secondary_Interface_Template(CDIObj, SFORM(ThisInterfaceT))
Interface_Template_End(CDIObj)

Primary_Interface_Begin(CDIObj, TFORM(ThisInterfaceT))
TFORM(CDIObj_CreateDevice),
TFORM(CDIObj_EnumDevices),
TFORM(CDIObj_GetDeviceStatus),
TFORM(CDIObj_RunControlPanel),
TFORM(CDIObj_Initialize),
TFORM(CDIObj_FindDevice),
TFORM(CDIObj_EnumDevicesBySemantics),
TFORM(CDIObj_ConfigureDevices),
Primary_Interface_End(CDIObj, TFORM(ThisInterfaceT))

Secondary_Interface_Begin(CDIObj, SFORM(ThisInterfaceT), SFORM(di))
SFORM(CDIObj_CreateDevice),
SFORM(CDIObj_EnumDevices),
SFORM(CDIObj_GetDeviceStatus),
SFORM(CDIObj_RunControlPanel),
SFORM(CDIObj_Initialize),
SFORM(CDIObj_FindDevice),
SFORM(CDIObj_EnumDevicesBySemantics),
SFORM(CDIObj_ConfigureDevices),
Secondary_Interface_End(CDIObj, SFORM(ThisInterfaceT), SFORM(di))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dinput.c ===
/*****************************************************************************
 *
 *  DInput.c
 *
 *  Copyright (c) 1996 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *
 *
 *  Contents:
 *
 *      DirectInput8Create()
 *      DllGetClassObject()
 *      DllCanUnloadNow()
 *      DllMain()
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *  The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflDll

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @topic  The DirectInput synchronization hierarchy |
 *
 *  Extreme caution must be exercised to ensure that the synchronization
 *  hierarchy is preserved.  Failure to observe these rules will result
 *  in a deadlock.
 *
 *  @ex
 *
 *  In the following list, locks must be taken in the order specified.
 *  Furthermore, the Dll critical section and the cross-process mutexes
 *  may never be taken simultaneously.  (They should be considered
 *  to be at the bottom of the hierarchy.)
 *
 *  |
 *
 *      DirectInputEffect
 *      DirectInputDevice
 *      Dll critical section
 *      The cross-process global mutex
 *      The cross-process joystick mutex
 *
 ***************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global DWORD | g_cRef |
 *
 *          DLL reference count.
 *
 *  @global HINSTANCE | g_hinst |
 *
 *          DLL instance handle.
 *
 *  @global LONG | g_lLoadLibrary |
 *
 *          Number of times we have been artificially <f LoadLibrary>'d
 *          to prevent ourselves from being unloaded by a non-OLE
 *          application.  Actually, it's the number of times minus one,
 *          so we can use the interlocked functions to tell whether
 *          the first <f LoadLibrary> is happening or the last
 *          <f FreeLibrary> is happening.
 *
 *          We perform a physical <f LoadLibrary> or <f FreeLibrary>
 *          only on the transition, so as to avoid overflowing the
 *          counter in KERNEL32.
 *
 *  @global HANDLE | g_hVxD |
 *
 *          Handle to VxD, if available.   Win9x only!
 *
 *  @global OPENVXDHANDLE | OpenVxDHandle |
 *
 *          Address of Win9x-only KERNEL32 entry point to convert
 *          a process handle into a VxD handle.  Win9x only!
 *
 *  @global DWORD | g_dwLastBonusPoll |
 *
 *          Last time a bonus poll was made to tickle the SideWinder 
 *          drivers.                                Win9x only!
 *
 *  @global CRITICAL_SECTION | g_crstDll |
 *
 *          Per-process critical section to protect process-global
 *          variables.
 *
 *  @global DWORD | g_flEmulation |
 *
 *          Flags that describe what levels of forced emulation are
 *          active.
 *
 *  @global HHOOK | g_hhkLLHookCheck |
 *
 *          Used only temporarily to test whether low-level hooks
 *          are supported on the system.
 *
 *  @global HANDLE | g_hmtxGlobal |
 *
 *          System-global mutex that protects shared memory blocks
 *          which describe device exclusive acquisition information.
 *
 *  @global HANDLE | g_hfm |
 *
 *          Handle to the file mapping that describes the shared
 *          memory block.  NT requires us to keep the handle open
 *          so that the associated name remains in the namespace.
 *
 *  @global PSHAREDOBJECTPAGE | g_psop |
 *
 *          Pointer to the shared memory block itself.
 *
 *  @global HANDLE | g_hmtxJoy |
 *
 *          System-global mutex that protects shared memory blocks
 *          which describe joystick effects.
 *
 *  @global UINT | g_wmJoyChanged |
 *
 *          Registered window message which is broadcast when joysticks
 *          are reconfigured.
 *
 *  @global LONG | g_lWheelGranularity |
 *
 *          The wheel granularity.  One hardware "click" of the mouse
 *          wheel results in this much reported motion.
 *
 *  @global int | g_cdtoMax |
 *
 *          Total number of elements in the g_pdto array.
 *
 *  @global int | g_cdto |
 *
 *          Number of occupied elements in the g_pdto array.
 *
 *  @global PDWORD | g_rgdwCRCTable |
 *
 *          Pointer to the array of values used for CRC generation.
 *
 *  @global PDEVICETOUSER | g_pdto |
 *
 *          Pointer to the device to owner array.
 *
 *  @global BOOL | g_fCritInited |
 *
 *          True if g_crstDll has been initialized.
 *
 *  @global DIAPPHACKS | g_AppHacks | 
 *
 *          Application hacks.  Initialized to:
 *              fReacquire              FALSE
 *              fNoSubClass             FALSE
 *              nMaxDeviceNameLength    MAX_PATH
 *
 *  @global DWORD | g_dwAppDate |
 *
 *          Application link date stamp, used in generating application ID
 *
 *  @global DWORD | g_dwAppFileLen |
 *
 *          Application file length, used in generating application ID
 *
 *  @global DWORD | g_dwLastMsgSent |
 *
 *          Last message WPARAM broadcast in a g_wmDInputNotify message.
 *          This is one of the DIMSGWP_* values or zero if no message has yet 
 *          been broadcast.  This value only ever increases as applications 
 *          cannot become less identifed as they proceed.  This value is used 
 *          as a test of 
 *
 *  @global UINT | g_wmDInputNotify |
 *
 *          Registered window message which is broadcast when a change of 
 *          application status is detected.
 *
 *
 *****************************************************************************/

DWORD g_cRef;
HINSTANCE g_hinst;
HINSTANCE g_hinstDbg;
LONG g_lLoadLibrary = -1;
#ifndef WINNT
HANDLE g_hVxD = INVALID_HANDLE_VALUE;
OPENVXDHANDLE _OpenVxDHandle;
DWORD g_dwLastBonusPoll;
#endif
CRITICAL_SECTION g_crstDll;
DWORD g_flEmulation;
LPDWORD g_pdwSequence;

#ifdef USE_SLOW_LL_HOOKS
HHOOK g_hhkLLHookCheck;
#endif

HANDLE g_hmtxGlobal;
HANDLE g_hfm;
struct SHAREDOBJECTPAGE *g_psop;
HANDLE g_hmtxJoy;
UINT g_wmJoyChanged;
LONG g_lWheelGranularity;

int g_cdtoMax;
int g_cdto;
struct _DEVICETOUSER *g_pdto;

PDWORD g_rgdwCRCTable;

BOOL g_fCritInited;

#ifdef WORKER_THREAD
MSGWAITFORMULTIPLEOBJECTSEX _MsgWaitForMultipleObjectsEx =
FakeMsgWaitForMultipleObjectsEx;
#endif

CANCELIO _CancelIO = FakeCancelIO;

#ifdef XDEBUG
TRYENTERCRITICALSECTION _TryEnterCritSec = FakeTryEnterCriticalSection;
int g_cCrit = -1;
UINT g_thidCrit;
HANDLE g_thhandleCrit;
#endif

#ifdef DEBUG
TCHAR g_tszLogFile[MAX_PATH];
#endif

DIAPPHACKS g_AppHacks = {FALSE,FALSE,MAX_PATH};
DWORD g_dwAppDate;
DWORD g_dwAppFileLen;
DWORD g_dwLastMsgSent;
UINT  g_wmDInputNotify;

BOOL  g_fRawInput;

#ifdef USE_WM_INPUT
  HWND   g_hwndThread;
  HANDLE g_hEventAcquire;
  HANDLE g_hEventThread;
  HANDLE g_hEventHid;
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllEnterCrit |
 *
 *          Take the DLL critical section.
 *
 *          The DLL critical section is the lowest level critical section.
 *          You may not attempt to acquire any other critical sections or
 *          yield while the DLL critical section is held.  Failure to
 *          comply is a violation of the semaphore hierarchy and will
 *          lead to deadlocks.
 *
 *****************************************************************************/

void EXTERNAL
DllEnterCrit_(LPCTSTR lptszFile, UINT line)
{            

#ifdef XDEBUG
    if ( ! _TryEnterCritSec(&g_crstDll) )
    {
        SquirtSqflPtszV(sqflCrit, TEXT("Dll CritSec blocked @%s,%d"), lptszFile, line);    
        EnterCriticalSection(&g_crstDll);
    }

    if (++g_cCrit == 0)
    {
        g_thidCrit     = GetCurrentThreadId();
        g_thhandleCrit = GetCurrentThread();

        SquirtSqflPtszV(sqflCrit, TEXT("Dll CritSec Entered @%s,%d"), lptszFile, line);    
    }
    AssertF(g_thidCrit == GetCurrentThreadId());
#else
    EnterCriticalSection(&g_crstDll);
#endif

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | IsThreadActive |
 *
 *          Check if the thread is still active.
 *
 *****************************************************************************/

BOOL IsThreadActive( HANDLE hThread )
{
    DWORD dwExitCode = 0;

    return (NULL != hThread
            && GetExitCodeThread(hThread, &dwExitCode)
            && STILL_ACTIVE == dwExitCode
            );
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllLeaveCrit |
 *
 *          Leave the DLL critical section.
 *
 *****************************************************************************/

void EXTERNAL
DllLeaveCrit_(LPCTSTR lptszFile, UINT line)
{
#ifdef XDEBUG
    if( IsThreadActive(g_thhandleCrit) ) {
        AssertF(g_thidCrit == GetCurrentThreadId());
    } else {
        SquirtSqflPtszV(sqflCrit, TEXT("Current thread has died."));
    }
    
    AssertF(g_cCrit >= 0);
    if (--g_cCrit < 0)
    {
        g_thidCrit = 0;
    }
    SquirtSqflPtszV(sqflCrit, TEXT("Dll CritSec Leaving @%s,%d"), lptszFile, line);    
#endif
    LeaveCriticalSection(&g_crstDll);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllInCrit |
 *
 *          Nonzero if we are in the DLL critical section.
 *
 *****************************************************************************/

#ifdef XDEBUG

BOOL INTERNAL
DllInCrit(void)
{        
    return g_cCrit >= 0 && g_thidCrit == GetCurrentThreadId();
}

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllAddRef |
 *
 *          Increment the reference count on the DLL.
 *
 *****************************************************************************/

void EXTERNAL
DllAddRef(void)
{
    InterlockedIncrement((LPLONG)&g_cRef);
    SquirtSqflPtszV(sqfl, TEXT("DllAddRef -> %d"), g_cRef);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllRelease |
 *
 *          Decrement the reference count on the DLL.
 *
 *****************************************************************************/

void EXTERNAL
DllRelease(void)
{
    InterlockedDecrement((LPLONG)&g_cRef);
    SquirtSqflPtszV(sqfl, TEXT("DllRelease -> %d"), g_cRef);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | DllLoadLibrary |
 *
 *          Increment the DLL load count.
 *
 *          This is to prevent a non-OLE application from unloading us
 *          while we still have windows subclassed.
 *
 *****************************************************************************/

BOOL EXTERNAL
DllLoadLibrary(void)
{
    BOOL fRes = TRUE;

    AssertF(InCrit());      

    if (InterlockedIncrement(&g_lLoadLibrary) == 0)
    {
        TCHAR tsz[MAX_PATH - 1];

        /*
         *  See hresValidInstanceVer_ for an explanation of why
         *  we need to pass cA() - 1 instead of cA().
         */
        if ( !GetModuleFileName(g_hinst, tsz, cA(tsz) - 1)
             || !LoadLibrary(tsz) )
        {
            /*
             *  Restore the refcount.
             *  There is no race condition here because we are always called 
             *  InCrit so the refcount after the restore can only be the same 
             *  as it was when we entered.  If this should change, we would 
             *  need to take extra precautions as two threads could try to 
             *  LoadLibrary at the same time.  As only one would do the 
             *  physical load, there is no way to let the other know if the 
             *  load failed.
             */
            InterlockedDecrement(&g_lLoadLibrary);
            fRes = FALSE;
            RPF( "LoadLibrary( self ) failed!, le = %d", GetLastError() );
        }
    }
    SquirtSqflPtszV(sqfl, TEXT("DllLoadLibrary -> %d"), g_lLoadLibrary);

    return fRes;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllFreeLibraryAndExitThread |
 *
 *          Worker thread which frees the library in a less dangerous
 *          (I'm loathe to say "safe") manner.
 *
 *          ThreadProcs are prototyped to return a void but since the return 
 *          would follow some form of ExitThread, it will never be reached so 
 *          this function is declared to return void and cast.
 *
 *  @parm   LPVOID | pvContext |
 *
 *          Unused context information.
 *
 *****************************************************************************/

void INTERNAL
DllFreeLibraryAndExitThread(LPVOID pvContext)
{
    /*
     *  Sleep for one extra second to make extra sure that the
     *  DllFreeLibrary thread is out and gone.
     */
    SleepEx(1000, FALSE);

    FreeLibraryAndExitThread(g_hinst, 0);

    /*NOTREACHED*/
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllFreeLibrary |
 *
 *          Decrement the DLL load count.
 *
 *          This undoes a previous <f DllLoadLibrary>.
 *
 *          We can't blindly do a <f FreeLibrary>, because we might
 *          be freeing our last reference, and then we will die because
 *          we won't exist when the <f FreeLibrary> returns.
 *
 *          If we are in the wacky case, then we spin a low-priority
 *          thread whose job is to free us. We create it at low priority
 *          so it will lose the race with this thread, which is busy
 *          getting out of the way.
 *
 *****************************************************************************/

void EXTERNAL
DllFreeLibrary(void)
{
    if (InterlockedDecrement(&g_lLoadLibrary) < 0)
    {
        if (g_cRef)
        {
            /*
             *  There are other references to us, so we can just
             *  go away quietly.
             */
            FreeLibrary(g_hinst);
        } else
        {
            /*
             *  This is the last reference, so we need to create a
             *  worker thread which will call <f FreeLibraryAndExitThread>.
             */
            DWORD thid;
            HANDLE hth;

            hth = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)DllFreeLibraryAndExitThread,
                               0, CREATE_SUSPENDED, &thid);
            if (hth)
            {
                SetThreadPriority(hth, THREAD_PRIORITY_IDLE);
                ResumeThread(hth);
                CloseHandle(hth);
            }
        }
    }
    SquirtSqflPtszV(sqfl, TEXT("DllFreeLibrary -> %d"), g_lLoadLibrary);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DllGetClassObject |
 *
 *          Create an <i IClassFactory> instance for this DLL.
 *
 *  @parm   REFCLSID | rclsid |
 *
 *          The object being requested.
 *
 *  @parm   RIID | riid |
 *
 *          The desired interface on the object.
 *
 *  @parm   PPV | ppvOut |
 *
 *          Output pointer.
 *
 *  @comm
 *          The artificial refcount inside <f DllClassObject> helps
 *          to avoid the race condition described in <f DllCanUnloadNow>.
 *          It's not perfect, but it makes the race window smaller.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#ifdef  DEMONSTRATION_FFDRIVER

/*
 *  Build the fake force feedback driver for internal testing.
 */

GUID CLSID_EffectDriver = {
    0x25E609E2,0xB259,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00
};

#endif

CLSIDMAP c_rgclsidmap[cclsidmap] = {
    {   &CLSID_DirectInput8,         CDIObj_New,     IDS_DIRECTINPUT8,},
    {   &CLSID_DirectInputDevice8,   CDIDev_New,     IDS_DIRECTINPUTDEVICE8,},
#ifdef  DEMONSTRATION_FFDRIVER
    {   &CLSID_EffectDriver,        CJoyEff_New,    0,},
#endif
};

#pragma END_CONST_DATA

STDAPI
DllGetClassObject(REFCLSID rclsid, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    UINT iclsidmap;
    EnterProcR(DllGetClassObject, (_ "G", rclsid));

    if ( g_fCritInited )
    {
        DllAddRef();
        for (iclsidmap = 0; iclsidmap < cA(c_rgclsidmap); iclsidmap++)
        {
            if (IsEqualIID(rclsid, c_rgclsidmap[iclsidmap].rclsid))
            {
                hres = CDIFactory_New(c_rgclsidmap[iclsidmap].pfnCreate,
                                      riid, ppvObj);
                goto done;
            }
        }
        SquirtSqflPtszV(sqfl | sqflError, TEXT("%S: Wrong CLSID"), s_szProc);
        *ppvObj = 0;
        hres = CLASS_E_CLASSNOTAVAILABLE;

        done:;

        ExitOleProcPpv(ppvObj);
        DllRelease();
    } else
    {
        hres = E_OUTOFMEMORY;
        RPF( "Failing DllGetClassObject due to lack of DLL critical section" );
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DllCanUnloadNow |
 *
 *          Determine whether the DLL has any outstanding interfaces.
 *
 *          There is an unavoidable race condition between
 *          <f DllCanUnloadNow> and the creation of a new
 *          <i IClassFactory>:  Between the time we return from
 *          <f DllCanUnloaDNow> and the caller inspects the value,
 *          another thread in the same process may decide to call
 *          <f DllGetClassObject>, thus suddenly creating an object
 *          in this DLL when there previously was none.
 *
 *          It is the caller's responsibility to prepare for this
 *          possibility; there is nothing we can do about it.
 *
 *  @returns
 *
 *          Returns <c S_OK> if the DLL can unload, <c S_FALSE> if
 *          it is not safe to unload.
 *
 *****************************************************************************/

STDMETHODIMP
DllCanUnloadNow(void)
{
    HRESULT hres;
#ifdef DEBUG
    if (IsSqflSet(sqfl))
    {
        SquirtSqflPtszV(sqfl, TEXT("DllCanUnloadNow() - g_cRef = %d"), g_cRef);
        Common_DumpObjects();
    }
#endif
    hres = g_cRef ? S_FALSE : S_OK;
    return hres;
}

#ifdef USE_SLOW_LL_HOOKS

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | DllLlHookTest |
 *
 *          Tiny hook procedure used to test whether LL hooks are
 *          supported by the operating system.
 *
 *          This function is almost never called.  We install the
 *          hook and immediately remove it.  The only time it
 *          manages to get called is if the user moves the mouse
 *          or presses a key during the microsecond that we exist.
 *
 *          Wait!  In fact, this function is *never* called.  We
 *          do not process messages at any point the hook is installed,
 *          so in fact nothing happens at all.
 *
 *  @parm   int | nCode |
 *
 *          Hook code.
 *
 *  @parm   WPARAM | wp |
 *
 *          Hook-specific code.
 *
 *  @parm   LPARAM | lp |
 *
 *          Hook-specific code.
 *
 *  @returns
 *
 *          Always chains to previous hook.
 *
 *****************************************************************************/

LRESULT CALLBACK
DllLlHookTest(int nCode, WPARAM wp, LPARAM lp)
{
    /*
     *  Note that there is not actually anything wrong here,
     *  but it is a theoretically impossible condition, so I want to
     *  know when it happens.
     */
    AssertF(!TEXT("DllLlHookTest - Unexpected hook"));
    return CallNextHookEx(g_hhkLLHookCheck, nCode, wp, lp);
}

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllProcessAttach |
 *
 *          Called when the DLL is loaded.
 *
 *          We are not interested in thread attaches and detaches,
 *          so we disable thread notifications for performance reasons.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

TCHAR c_tszKernel32[] = TEXT("KERNEL32");

#ifndef WINNT
char c_szOpenVxDHandle[] = "OpenVxDHandle";
#endif

void INTERNAL
DllProcessAttach(void)
{
    HINSTANCE hinstK32;
#ifdef DEBUG

    WriteProfileString(0, 0, 0);   /* Flush the win.ini cache */
    Sqfl_Init();
    GetProfileString(TEXT("DEBUG"), TEXT("LogFile"), TEXT(""),
                     g_tszLogFile, cA(g_tszLogFile));
    SquirtSqflPtszV(sqfl, TEXT("LoadDll - DInput"));
    SquirtSqflPtszV(sqfl, TEXT("Version %x"), DIRECTINPUT_VERSION );
    SquirtSqflPtszV(sqfl, TEXT("Built %s at %s\n"), TEXT(__DATE__), TEXT(__TIME__) );
#endif


    /*
     *  Disabling thread library calls is important so that
     *  we don't deadlock with ourselves over the critical
     *  section when we spin up the worker thread to handle
     *  low-level hooks.
     */
    DisableThreadLibraryCalls(g_hinst);

    g_fCritInited = fInitializeCriticalSection(&g_crstDll);
    if ( !g_fCritInited )
    {
        RPF( "Failed to initialize DLL critical section" );
    }

    hinstK32 = GetModuleHandle( c_tszKernel32 );


    {
        CANCELIO tmp;

        tmp = (CANCELIO)GetProcAddress(hinstK32, "CancelIo");
        if (tmp)
        {
            _CancelIO = tmp;
        } else
        {
            AssertF(_CancelIO == FakeCancelIO);
        }
    }

#ifdef WINNT
    /*
     *  For now, only look for TryEnterCriticalSection on NT as it is not 
     *  implemented on 9x but the stub is annoying on 98 with dbg kernels.
     */
    {
#ifdef XDEBUG
        TRYENTERCRITICALSECTION tmpCrt;

        tmpCrt = (TRYENTERCRITICALSECTION)GetProcAddress(hinstK32, "TryEnterCriticalSection");
        if (tmpCrt)
        {
            _TryEnterCritSec = tmpCrt;            
        } else
        {
            AssertF(_TryEnterCritSec == FakeTryEnterCriticalSection);
        }
#endif
    }

#else
    _OpenVxDHandle = (OPENVXDHANDLE)GetProcAddress(hinstK32, c_szOpenVxDHandle);
#endif

#ifdef WORKER_THREAD
    {
        MSGWAITFORMULTIPLEOBJECTSEX tmp;

        tmp = (MSGWAITFORMULTIPLEOBJECTSEX)
              GetProcAddress(GetModuleHandle(TEXT("USER32")),
                             "MsgWaitForMultipleObjectsEx");
        if (tmp)
        {
            _MsgWaitForMultipleObjectsEx = tmp;
        } else
        {
            AssertF(_MsgWaitForMultipleObjectsEx ==
                    FakeMsgWaitForMultipleObjectsEx);
        }
    }

    /*
     *  We cannot initialize g_hmtxGlobal here, because we
     *  have no way to report the error back to the caller.
     */
#endif

#ifdef USE_SLOW_LL_HOOKS

    /*
     *  Determine whether low-level input hooks are supported.
     */
    g_hhkLLHookCheck = SetWindowsHookEx(WH_MOUSE_LL, DllLlHookTest,
                                        g_hinst, 0);
    if (g_hhkLLHookCheck)
    {
        UnhookWindowsHookEx(g_hhkLLHookCheck);
    }

#endif

    /*
     *  Warning!  Do not call ExtDll_Init during PROCESS_ATTACH!
     */
    g_wmJoyChanged   = RegisterWindowMessage(MSGSTR_JOYCHANGED);
    g_wmDInputNotify = RegisterWindowMessage(DIRECTINPUT_NOTIFICATION_MSGSTRING);

  #ifdef USE_WM_INPUT
    g_fRawInput      = (DIGetOSVersion() == WINWH_OS);
    if( g_fRawInput ) {
        g_hEventAcquire  = CreateEvent(0x0, 0, 0, 0x0);
        g_hEventThread   = CreateEvent(0x0, 0, 0, 0x0);
        g_hEventHid      = CreateEvent(0x0, 0, 0, 0x0);
    }
  #endif

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllProcessDetach |
 *
 *          Called when the DLL is unloaded.
 *
 *****************************************************************************/

void INTERNAL
DllProcessDetach(void)
{
    extern PLLTHREADSTATE g_plts;

    SquirtSqflPtszV(sqfl | sqflMajor,
                    TEXT("DINPUT8: ProcessDetach. PID:%08x, TID:%08x."),
                    GetCurrentProcessId(), GetCurrentThreadId() );


  #ifdef USE_WM_INPUT
    if (g_hEventAcquire)
    {
        CloseHandle(g_hEventAcquire);
    }

    if (g_hEventThread)
    {
        CloseHandle(g_hEventThread);
    }

    if (g_hEventHid)
    {
        CloseHandle(g_hEventHid);
    }
  #endif

#ifndef WINNT
    if (g_hVxD != INVALID_HANDLE_VALUE)
    {
        CloseHandle(g_hVxD);
    }
#endif

    if (g_psop)
    {
        UnmapViewOfFile(g_psop);
    }

    if (g_hfm)
    {
        CloseHandle(g_hfm);
    }

    if (g_hmtxGlobal)
    {
        CloseHandle(g_hmtxGlobal);
    }

    if (g_hmtxJoy)
    {
        CloseHandle(g_hmtxJoy);
    }

    FreePpv( &g_pdto );
    FreePpv( &g_rgdwCRCTable );

    ExtDll_Term();

    if ( g_fCritInited )
    {
        DeleteCriticalSection(&g_crstDll);
    }

    if ( g_hinstDbg )
    {
        FreeLibrary(g_hinstDbg);
    }
    /*
     *  Output message last so that anything that follows is known to be bad.
     */
    if (g_cRef )
    {
        RPF("unloaded before all objects released. (cRef:%d)\r\n", g_cRef);
    }

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | DllMain |
 *
 *          Called to notify the DLL about various things that can happen.
 *
 *  @parm   HINSTANCE | hinst |
 *
 *          The instance handle of this DLL.
 *
 *  @parm   DWORD | dwReason |
 *
 *          Notification code.
 *
 *  @parm   LPVOID | lpReserved |
 *
 *          Not used.
 *
 *  @returns
 *
 *          Returns <c TRUE> to allow the DLL to load.
 *
 *****************************************************************************/

BOOL APIENTRY
DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason)
    {
    
    case DLL_PROCESS_ATTACH:
        g_hinst = hinst;
        DllProcessAttach();
        SquirtSqflPtszV(sqfl | sqflMajor,
                        TEXT("DINPUT8: DLL_PROCESS_ATTACH hinst=0x%p, lpReserved=0x%p"),
                        hinst, lpReserved );
        break;

    case DLL_PROCESS_DETACH:
        DllProcessDetach();
        SquirtSqflPtszV(sqfl | sqflMajor,
                        TEXT("DINPUT8: DLL_PROCESS_DETACH hinst=0x%p, lpReserved=0x%p"),
                        hinst, lpReserved );
        break;
    }
    return 1;
}

/*****************************************************************************
 *
 *  @doc EXTERNAL
 *
 *  @topic Definitions and Ground Rules |
 *
 *  The phrase "undefined behavior" refers to behavior which is not
 *  covered by this specification due to violations of a constraint.
 *  No constraint is imposed by the specification as to the result of
 *  undefined behavior.  It may range from silently ignoring the
 *  situation to a complete system crash.
 *
 *  If this specification does not prescribe a behavior for a particular
 *  situation, the behavior is "undefined".
 *
 *  The phrase "It is an error" indicates that failure to comply
 *  is a violation of the DirectInput specification and results
 *  in "undefined behavior".
 *
 *  The word "shall" is to be interpreted as a
 *  requirement on an application; conversely, "shall not" is to be
 *  interpreted as a prohibition.  Violation of a requirement or
 *  prohibition "is an error".
 *
 *  The word "may" indicates that the indicated behavior is possible
 *  but is not required.
 *
 *  The word "should" indicates a strong suggestion.
 *  If the application violates a "should" requirement, then DirectInput
 *  "may" fail the operation.
 *
 *  Pointer parameters to functions "shall not" be NULL unless explicitly
 *  documented as OPTIONAL.  "It is an error" to pass a pointer to an object
 *  of the wrong type, to an object which is not allocated, or to an
 *  object which has been freed or <f Release>d.
 *
 *  Unless indicated otherwise,
 *  an object pointed to by a pointer parameter documented as an
 *  IN parameter "shall not" be modified by the called procedure.
 *  Conversely, a pointer parameter documented
 *  as an OUT parameter "shall" point to a modifiable object.
 *
 *  When a bitmask of flags is defined, all bits not defined by this
 *  specification are reserved.  Applications "shall not" set reserved
 *  bits and "shall" ignore reserved bits should they be received.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @topic  Initialization and Versions |
 *
 *          In several places, DirectInput requires you to pass an instance
 *          handle and a version number.
 *
 *          The instance handle must correspond to the application or
 *          DLL that is initializing the DirectInput object.
 *
 *          DirectInput uses this value to determine whether the
 *          application or DLL has been certified and to establish
 *          any special behaviors that may be necessary for
 *          backwards-compatibility.
 *
 *          It is an error for a DLL to pass the handle of the
 *          parent application.  For example, an ActiveX control
 *          embedded in a web page which uses DirectInput must
 *          pass its own instance handle and not the handle of the
 *          web browser.  This ensures that DirectInput recognizes
 *          the control and can enable any special behaviors
 *          for the control the behave properly.
 *
 *          The version number parameter specifies which version of
 *          DirectInput the DirectInput subsystem should emulate.
 *
 *          Applications designed for the latest version of DirectInput
 *          should pass the value <c DIRECTINPUT_VERSION> as defined
 *          in dinput.h.
 *
 *          Applications designed for previous versions of DirectInput
 *          should pass a value corresponding to the version of
 *          DirectInput they were designed for.  For example, an
 *          application that was designed to run on DirectInput 3.0
 *          should pass a value of 0x0300.
 *
 *          If you #define <c DIRECTINPUT_VERSION> to 0x0300 before
 *          including the dinput.h header file, then the dinput.h
 *          header file will generate DirectInput 3.0-compatible
 *          structure definitions.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DirectInputCreateHelper |
 *
 *          This function creates a new DirectInput object
 *          which supports the <i IDirectInput> COM interface.
 *
 *          On success, the function returns a pointer to the new object in
 *          *<p lplpDirectInput>.
 *
 *  @parm   IN HINSTANCE | hinst |
 *
 *          Instance handle of the application or DLL that is creating
 *          the DirectInput object.
 *
 *  @parm   DWORD | dwVersion |
 *
 *          Version number of the dinput.h header file that was used.
 *
 *  @parm   OUT PPV | ppvObj |
 *          Points to where to return
 *          the pointer to the <i IDirectInput> interface, if successful.
 *
 *  @parm   IN LPUNKNOWN | punkOuter | Pointer to controlling unknown.
 *
 *  @parm   RIID | riid |
 *
 *          The interface the application wants to create.  This will
 *          be either <i IDirectInputA> or <i IDirectInputW>.
 *          If the object is aggregated, then this parameter is ignored.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM>
 *
 *          <c DIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:
 *          Out of memory.
 *
 *****************************************************************************/

STDMETHODIMP
DirectInputCreateHelper(HINSTANCE hinst, DWORD dwVer,
                        PPV ppvObj, PUNK punkOuter, RIID riid)
{
    HRESULT hres;
    EnterProc(DirectInputCreateHelper,
              (_ "xxxG", hinst, dwVer, punkOuter, riid));

    if (SUCCEEDED(hres = hresFullValidPcbOut(ppvObj, cbX(*ppvObj), 3)))
    {
        if( g_fCritInited )
        {
            LPVOID pvTry = NULL;
            hres = CDIObj_New(punkOuter,
                              punkOuter ? &IID_IUnknown : riid, &pvTry);

            if( SUCCEEDED( hres ) )
            {
                AhAppRegister( dwVer, 0x0 );
            }
                
            if (SUCCEEDED(hres) && punkOuter == 0)
            {
                LPDIRECTINPUT pdi = pvTry;
                hres = pdi->lpVtbl->Initialize(pdi, hinst, dwVer);
                if (SUCCEEDED(hres))
                {
                    *ppvObj = pvTry;
                } else
                {
                    Invoke_Release(&pvTry);
                    *ppvObj = NULL;
                }
            }
        } else
        {
            RPF( "Failing DirectInputCreate due to lack of DLL critical section" );
            hres = E_OUTOFMEMORY;
        }
    }

    ExitOleProcPpv(ppvObj);
    return hres;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   HRESULT | DirectInput8Create |
 *
 *          <bnew> This function creates a new DirectInput8 object
 *          which supports the <i IDirectInput8> COM interfaces. This function 
 *          allows the app to pass an IID so it does not have to do an extra
 *          QI off some initial interface in order to obtain the one it 
 *          really wanted.  
 *
 *          On success, the function returns a pointer to the new object in
 *          *<p ppvOut>.
 *          <enew>
 *
 *  @parm   IN HINSTANCE | hinst |
 *
 *          Instance handle of the application or DLL that is creating
 *          the DirectInput object.
 *
 *          See the section titled "Initialization and Versions"
 *          for more information.
 *
 *  @parm   DWORD | dwVersion |
 *
 *          Version number of the dinput.h header file that was used.
 *
 *          See the section titled "Initialization and Versions"
 *          for more information.
 *
 *  @parm   REFIID | riidtlf |
 *
 *          The desired interface interface. Currently, valid values are 
 *          IID_IDirectInput8A and IID_IDirectInput8W.
 *
 *  @parm   OUT LPVOID | *ppvOut |
 *
 *          Points to where to return
 *          the pointer to the <i IDirectInput8> interface, if successful.
 *
 *  @parm   IN LPUNKNOWN | punkOuter | Pointer to controlling unknown
 *          for OLE aggregation, or 0 if the interface is not aggregated.
 *          Most callers will pass 0.
 *
 *          Note that if aggregation is requested, the object returned
 *          in *<p lplpDirectInput> will be a pointer to an
 *          <i IUnknown> rather than an <i IDirectInput8>, as required
 *          by OLE aggregation.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lplpDirectInput> parameter is not a valid pointer.
 *
 *          <c DIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:
 *          Out of memory.
 *
 *          <c DIERR_DIERR_OLDDIRECTINPUTVERSION>: The application
 *          requires a newer version of DirectInput.
 *
 *          <c DIERR_DIERR_BETADIRECTINPUTVERSION>: The application
 *          was written for an unsupported prerelease version
 *          of DirectInput.
 *
 *  @comm   Calling this function with <p punkOuter> = NULL
 *          is equivalent to creating the object via
 *          <f CoCreateInstance>(&CLSID_DirectInput8, <p punkOuter>,
 *          CLSCTX_INPROC_SERVER, <p refiid>, <p lplpDirectInput>);
 *          then initializing it with <f Initialize>.
 *
 *          Calling this function with <p punkOuter> != NULL
 *          is equivalent to creating the object via
 *          <f CoCreateInstance>(&CLSID_DirectInput8, <p punkOuter>,
 *          CLSCTX_INPROC_SERVER, &IID_IUnknown, <p lplpDirectInput>).
 *          The aggregated object must be initialized manually.
 *
 *          Since the IID is passed, there is no need for separate ANSI and 
 *          UNICODE versions of this service however as with other system
 *          services which are sensitive to character set issues,
 *          macros in the header file map a generic version of the IID name 
 *          to the appropriate IID for the character set variation.
 *
 *****************************************************************************/

STDMETHODIMP
DirectInput8Create(HINSTANCE hinst, DWORD dwVer, REFIID riidltf, LPVOID *ppvOut, LPUNKNOWN punkOuter)
{
    HRESULT hres = E_NOINTERFACE;

#ifndef XDEBUG
    TCHAR tszGuid[ctchNameGuid];
    TCHAR tszKey[ctchGuid + 40];    /* 40 is more than enough */
    ULONG lRc;
    HKEY hk;
#endif

    EnterProc(DirectInput8Create, (_ "xxGx", hinst, dwVer, riidltf, ppvOut, punkOuter));

    /* Need to maintain a refcount to keep the Dll Around */
    DllAddRef();

#ifndef XDEBUG
    /* 
     * To provide the Dx CPL with a mechanism to allow developers to hot swap dinput8 
     * retail and debug bits
     *  In the retail version, we will check the CLSID//"CLSID_DirectInput8"/InProcServer32
     *  If it is found that the last n characters of the Dll name matches "Dinput8D.dll" then
     *  we will LoadLibrary Dinput8.dll and call the DirectInput8Create function in dinput8d.dll
     * 
     */    
    // Convert guid to name
    NameFromGUID(tszGuid, &CLSID_DirectInput8);
    // The NameFromGUID function adds a prefix, which is easily gotten rid of
    wsprintf(tszKey, TEXT("CLSID\\%s\\InProcServer32"), tszGuid+ctchNamePrefix);
    // Open the CLSID registry key
    lRc = RegOpenKeyEx(HKEY_CLASSES_ROOT, tszKey, 0,
                       KEY_QUERY_VALUE, &hk);
    if (lRc == ERROR_SUCCESS)
    {
        TCHAR tszDll[MAX_PATH];
        int cb;
        cb = cbX(tszDll);
        lRc = RegQueryValue(hk, 0, tszDll, &cb);
        if (lRc == ERROR_SUCCESS)
        {
            // We are only interested in the last few TCHARs for our comparison
            cb =  lstrlen(tszDll ) - lstrlen(TEXT("dinput8d.dll"));
            if ( ( cb >= 0x0 ) && 
                 ( 0x0 == lstrcmpi(TEXT("dinput8d.dll"), &tszDll[cb])) )
            {
                // We should use the debug binary
                g_hinstDbg = LoadLibrary(tszDll);
                if (g_hinstDbg)
                {
                    typedef HRESULT ( WINAPI * DIRECTINPUTCREATE8) ( HINSTANCE hinst, DWORD dwVersion, REFIID riidltf, LPVOID *ppvOut, LPUNKNOWN punkOuter);
                    DIRECTINPUTCREATE8 _DirectInputCreate8;

                    AssertF(g_hinstDbg != g_hinst );
                    
                    _DirectInputCreate8 = (DIRECTINPUTCREATE8)GetProcAddress( g_hinstDbg, "DirectInput8Create");
                    if ( _DirectInputCreate8 && 
                         g_hinstDbg != g_hinst )
                    {
                        hres = _DirectInputCreate8(hinst, dwVer, riidltf, ppvOut, punkOuter);
                    }
                }
            }
        }
        RegCloseKey(hk);
    }

    if( hres == E_NOINTERFACE)
#endif /* XDEBUG */
    //Can't create an IDirectInputJoyConfig8 interface through this mechanism, only IDirectInput8 interface!
    if (!IsEqualIID(riidltf, &IID_IDirectInputJoyConfig8))
    {
        hres = DirectInputCreateHelper(hinst, dwVer, ppvOut, punkOuter,
                                       riidltf);
    }
    

    DllRelease();

    ExitOleProcPpv(ppvOut);
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dinputpr.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dinputpr.h
 *  Content:    private DirectInput include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *   96.05.08   raymondc Because it's there
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifndef __DINPUTPR_INCLUDED__
    #define __DINPUTPR_INCLUDED__

    #ifndef WIN32_LEAN_AND_MEAN
        #define WIN32_LEAN_AND_MEAN
    #endif
    #define Not_VxD


/***************************************************************************
 *
 *  Make sure we know what platform we are building for.
 *
 *  INITGUID is defined by guidlib, who doesn't care what platform we
 *  are building for.  (GUIDs are platform-independent.)
 *
 ***************************************************************************/

    #ifndef INITGUID
        #if defined(WINNT) + defined(WIN95) != 1
            #error Must define exactly one of WINNT or WIN95
        #endif
    #endif

/***************************************************************************
 *
 *  Deciding whether we should use UNICODE
 *
 *  Use UNICODE on everything that isn't an X86, because NT is the only
 *  thing that runs on them.
 *
 *  If we *are* X86, then do UNICODE only if the command line says so.
 *
 ***************************************************************************/

    #ifndef _X86_
        #ifndef UNICODE
            #define UNICODE
        #endif
    #endif

    #pragma warning(disable:4115)           /* rpcndr.h: parenthesized type */
    #pragma warning(disable:4201)           /* winnt.h: nameless union */
    #pragma warning(disable:4214)           /* winnt.h: unsigned bitfields */
    #pragma warning(disable:4514)           /* winnt.h: fiber goo */
    #pragma warning(error:4101)             /* unreferenced local variable */


    #define STRICT

    #include <windows.h>
    #include <windowsx.h>
    #include <mmsystem.h>
    #include <mmreg.h>
    #include <objbase.h>
    #include <regstr.h>
    #include <math.h>


    #define DIRECTINPUT_VERSION 0x0800
    #include <dinput.h>
    #include "dinputp.h"
    
    /*
     *  Do sanity checks on header version
     */
    #ifndef DIRECTINPUT_HEADER_VERSION
        #error  DIRECTINPUT_HEADER_VERSION not defined.
    #else
        #if( DIRECTINPUT_HEADER_VERSION < 0x0800 ) 
            #if( DIRECTINPUT_HEADER_VERSION != DIRECTINPUT_VERSION )
                #error Mis-matched DInput header.
            #else
                #define DIRECTINPUT_INTERNAL_VERSION DIRECTINPUT_HEADER_VERSION 
            #endif
        #else
            #define DIRECTINPUT_INTERNAL_VERSION DIRECTINPUT_VERSION
        #endif
    #endif

    #if (_WIN32_WINNT >= 0x0501)
        #define USE_WM_INPUT 1
    #endif

    #ifndef GUIDLIB

/*
 *  Old versions of commctrl.h do not #include <prsht.h> automatically;
 *  therefore we must include it so that <setupapi.h> won't barf.
 *  Fortunately, prsht.h is idempotent, so an extra #include won't hurt.
 */
        #include <prsht.h>

        #include <setupapi.h>
        #include <hidsdi.h>
        #include <cfgmgr32.h>
        #include <winioctl.h>


#ifndef WINNT
        /*
         *  The version of basetyps.h hidclass.h includes on Win9x builds
         *  causes redefinition errors for DEFINE_GUID since we already have
         *  it from objbase.h so we have to null the include.
         */
        #define _BASETYPS_H_
#endif

        #include <hidclass.h>
        #include <stdio.h>

    #endif

    #include <dinputd.h>
    #include "dinputdp.h"
    #include "dinputv.h"
    #include "disysdef.h"
    #include "dinputi.h"
    #include "dihel.h"
    #include "debug.h"
    #include "diem.h"
    #include "..\dimap\dimap.h"
    #include "diextdll.h"
    #include "dihid.h"
    #include "dinputrc.h"

    #include "diwinnt.h"
#ifdef GUIDLIB
    #include <winioctl.h>
#endif
    #include "diport.h"
    #include "gameport.h"
    #include "winuser.h"
    #include "dbt.h"
    #include <lmcons.h>

    #ifdef WINNT
        #include "aclapi.h"
    #endif
    #include "diRiff.h"

    #include "verinfo.h"
    
    #include "ddraw.h"
    #include "d3d8.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dinputv.h ===
/*==========================================================================
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dinputv.h
 *  Content:    private DirectInput VxD include file
 *
 ***************************************************************************/

#ifndef __DINPUTV_INCLUDED__
#define __DINPUTV_INCLUDED__

/* XLATOFF */
#ifdef __cplusplus
extern "C" {
#endif
/* XLATON */



/****************************************************************************
 *
 *      DeviceIOCtl codes for DINPUT.VXD
 *
 *      IOCTL_FIRST is where DINPUT keeps its IOCTL codes.  Modify it
 *      if necessary to move DINPUT's IOCTLs to a new location.
 *
 *      All DINPUT IOCTLs are private between DINPUT.DLL and DINPUT.VXD.
 *      You can change them with impunity.
 *
 ***************************************************************************/

#define IOCTL_FIRST     0x0100

/* H2INCSWITCHES -t -f */

#if 0
/* Declare some types so h2inc will get them */
typedef LONG HWND;
typedef LONG DWORD;
#endif

/* Declare some more types for Win9x builds and h2inc */
#ifndef MAXULONG_PTR
typedef DWORD   ULONG_PTR;
typedef DWORD   *PULONG_PTR;
typedef DWORD   UINT_PTR;
typedef DWORD   *PULONG_PTR;
#endif //MAXULONG_PTR

/****************************************************************************
 *
 *      The shared portion of the VXDINSTANCE structure.
 *
 *      Instance "handles" are really pointers to a VXDINSTANCE structure.
 *
 ***************************************************************************/

typedef struct VXDINSTANCE {            /* vi */
    ULONG   fl;                         /* Flags */
    void *  pState;                     /* Instantaneous device state */
    DIDEVICEOBJECTDATA_DX3  *pBuffer;   /* Device object data buffer */
    DIDEVICEOBJECTDATA_DX3  *pEnd;      /* End of buffer */
    DIDEVICEOBJECTDATA_DX3  *pHead;     /* Where new data appears */
    DIDEVICEOBJECTDATA_DX3  *pTail;     /* Oldest object data */
    ULONG   fOverflow;                  /* Did the buffer overflow? */
                                        /* (exactly 0 or 1) */
    struct CDIDev *pdd;                 /* For misc communication */
    HWND hwnd;                          /* The cooperative window */
} VXDINSTANCE, *PVXDINSTANCE;

#define VIFL_CAPTURED_BIT   0
#define VIFL_CAPTURED       0x00000001  /* Device is captured (exclusive) */

#define VIFL_ACQUIRED_BIT   1
#define VIFL_ACQUIRED       0x00000002  /* Device is acquired */

#define VIFL_RELATIVE_BIT   2
#define VIFL_RELATIVE       0x00000004  /* Device wants relative data */

#define VIFL_EMULATED_BIT   3
#define VIFL_EMULATED       0x00000008  /* Device uses emulation */

#define VIFL_UNPLUGGED_BIT  4
#define VIFL_UNPLUGGED      0x00000010  /* Device is disconnected */

#define VIFL_NOWINKEY_BIT   5
#define VIFL_NOWINKEY       0x00000020  /* The Window Key are disabled */

#ifdef WANT_TO_FIX_MANBUG43879
  #define VIFL_FOREGROUND_BIT 7
  #define VIFL_FOREGROUND     0x00000080  /* Device is foreground */
#endif

#define VIFL_INITIALIZE_BIT 8
#define VIFL_INITIALIZE     0x00000100  /* This flag is set during the acquisition
                                           of a HID device so that we can get the
                                           initial device state successfully. */

/*
 *  The high word of fl contains device-specific flags.  They are
 *  currently used to record emulation information, and they aren't
 *  really device-specific because we have so few emulation flags.
 *
 *  The high word is just the emulation flags shifted upwards.
 */
#define DIGETEMFL(fl)       ((fl) >> 16)
#define DIMAKEEMFL(fl)      ((fl) << 16)

/****************************************************************************
 *
 *      System-defined IOCTL codes
 *
 ***************************************************************************/

#define IOCTL_GETVERSION        0x0000

/****************************************************************************
 *
 *      DINPUT-class IOCTLs
 *
 ***************************************************************************/

/*
 *  IN: None
 *
 *  OUT: None
 *
 *  The foreground window has lost activation.  Force all exclusively
 *  acquired devices to be unacquired.
 *
 *  This IOCTL is no longer used.  (Actually, it was never used.)
 *
 */
#define IOCTL_INPUTLOST         (IOCTL_FIRST + 0)


typedef struct VXDDEVICEFORMAT { /* devf */
    ULONG   cbData;             /* Size of device data */
    ULONG   cObj;               /* Number of objects in data format */
    DIOBJECTDATAFORMAT *rgodf;  /* Array of descriptions */
    ULONG_PTR   dwExtra;            /* Extra dword for private communication */
    DWORD   dwEmulation;        /* Flags controlling emulation */
} VXDDEVICEFORMAT, *PVXDDEVICEFORMAT;

/*
 *  IN: An instance handle that needs to be cleaned up.
 *
 *  OUT: None.
 *
 */
#define IOCTL_DESTROYINSTANCE   (IOCTL_FIRST + 1)

/*
 *  pDfOfs is an array of DWORDs.  Each entry corresponds to a byte in the
 *  device data format the meaning depends on the DLL client but it must 
 *  always be -1 if the client isn't tracking this object.  In DX7 and 
 *  before the value is the offset in the *client* data format which records 
 *  the data.  In DX8 the value is the device object index for the object 
 *  reporting at this device offset.
 *
 *  For example, for DX7, if the object at device offset 4 is to be reported 
 *  at client data offset 12, then pDfOfs[4] = 12.
 *
 *  For DX8, if the first two device objects are DWORD values then the object 
 *  at device offset 4 is the second object so pDfOfs[4] = 1.
 */
typedef struct VXDDATAFORMAT {  /* vdf */
    VXDINSTANCE *pvi;           /* Instance identifier */
    ULONG   cbData;             /* Size of device data */
    DWORD * pDfOfs;             /* Array of data format offsets */
} VXDDATAFORMAT, *PVXDDATAFORMAT;

/*
 *  IN: PVXDDATAFORMAT.
 *
 *  OUT: None
 *
 *  The application has changed the data format.  Notify the VxD so that
 *  data can be collected appropriately.
 *
 */
#define IOCTL_SETDATAFORMAT     (IOCTL_FIRST + 2)

/*
 *  IN: An instance handle to be acquired.
 *
 *  OUT: None.
 *
 */
#define IOCTL_ACQUIREINSTANCE   (IOCTL_FIRST + 3)

/*
 *  IN: An instance handle to be unacquired.
 *
 *  OUT: None.
 *
 */
#define IOCTL_UNACQUIREINSTANCE (IOCTL_FIRST + 4)

typedef struct VXDDWORDDATA {   /* vdd */
    VXDINSTANCE *pvi;           /* Instance identifier */
    ULONG   dw;                 /* Some dword */
} VXDDWORDDATA, *PVXDDWORDDATA;

/*
 *  IN: VXDDWORDDATA (dw = ring 0 handle)
 *
 *  OUT: None.
 *
 */
#define IOCTL_SETNOTIFYHANDLE   (IOCTL_FIRST + 5)

/*
 *  IN: VXDDWORDDATA (dw = buffer size)
 *
 *  OUT: None.
 *
 */
#define IOCTL_SETBUFFERSIZE     (IOCTL_FIRST + 6)

/****************************************************************************
 *
 *      Mouse class IOCTLs
 *
 ***************************************************************************/

/*
 *  IN: VXDDEVICEFORMAT (dwExtra = number of axes)
 *
 *  OUT: Instance handle
 */
#define IOCTL_MOUSE_CREATEINSTANCE (IOCTL_FIRST + 7)

/*
 *  IN: VXDDWORDDATA; dw is a BYTE[4] of initial mouse button states
 *
 *  OUT: None
 */
#define IOCTL_MOUSE_INITBUTTONS (IOCTL_FIRST + 8)

/****************************************************************************
 *
 *      Keyboard class IOCTLs
 *
 ***************************************************************************/

/*
 *  IN: VXDDEVICEFORMAT (dwExtra = keyboard type translation table)
 *
 *  OUT: Instance handle
 */
#define IOCTL_KBD_CREATEINSTANCE (IOCTL_FIRST + 9)

/*
 *  IN: VXDDWORDDATA; dw is a bitmask
 *      1 = KANA key is down, 2 = CAPITAL key is down
 *
 *  OUT: None
 */
#define IOCTL_KBD_INITKEYS       (IOCTL_FIRST + 10)

/****************************************************************************
 *
 *      Joystick class IOCTLs
 *
 ***************************************************************************/

/*
 *  IN: VXDDEVICEFORMAT (dwExtra = joystick id number)
 *
 *  OUT: Instance handle
 */
#define IOCTL_JOY_CREATEINSTANCE (IOCTL_FIRST + 11)

/*
 *  IN: An instance handle to be pinged
 *
 *  OUT: Instance handle
 */
#define IOCTL_JOY_PING           (IOCTL_FIRST + 12)

/*
 *  IN: DWORD external joystick ID
 *
 *  OUT: VXDINITPARMS containing goo we get from VJOYD.
 *
 */
typedef struct VXDINITPARMS {   /* vip */
    ULONG   hres;               /* result */
    ULONG   dwSize;             /* Which version of VJOYD are we? */
    ULONG   dwFlags;            /* Describes the device */
    ULONG   dwId;               /* Internal joystick ID */
    ULONG   dwFirmwareRevision;
    ULONG   dwHardwareRevision;
    ULONG   dwFFDriverVersion;
    ULONG   dwFilenameLengths;
    void *  pFilenameBuffer;
    DWORD   Usages[6];          /* X, Y, Z, R, U, V */
    DWORD   dwPOV0usage;
    DWORD   dwPOV1usage;
    DWORD   dwPOV2usage;
    DWORD   dwPOV3usage;
} VXDINITPARMS, *PVXDINITPARMS;

/*
 * Flags returned in VXDINITPARMS
 */
#define VIP_UNIT_ID             0x00000001L /* unit id is valid */
#define VIP_ISHID               0x00000002L /* This is a HID device */
#define VIP_SENDSNOTIFY         0x00000004L /* Driver will notify */

#define IOCTL_JOY_GETINITPARMS   (IOCTL_FIRST + 13)

/*
 *  IN: VXDFFIO describing FF I/O request
 *
 *      pvArgs points to an array of arguments.  We rely on several
 *      quirks of fate for this to work.
 *
 *      1.  STDCALL pushes arguments on the stack from right to left,
 *          so the address of the first argument can be used as a
 *          structure pointer.
 *
 *      2.  All the VJOYD interfaces pass arguments in registers.
 *
 *      3.  The registers used by VJOYD interfaces are always in the
 *          order eax, ecx, edx, esi, edi, matching the order in which
 *          the arguments are passed to IDirectInputEffectDriver.
 *
 *  OUT: HRESULT containing result code
 *
 */
/* XLATOFF */
#include <pshpack4.h>
/* XLATON */
typedef struct VXDFFIO { /* ffio */
    DWORD   dwIOCode;           /* I/O code */
    void *  pvArgs;             /* Array of arguments */
} VXDFFIO, *PVXDFFIO;
/* XLATOFF */
#include <poppack.h>
/* XLATON */

#define FFIO_ESCAPE             0
#define FFIO_SETGAIN            1
#define FFIO_SETFFSTATE         2
#define FFIO_GETFFSTATE         3
#define FFIO_DOWNLOADEFFECT     4
#define FFIO_DESTROYEFFECT      5
#define FFIO_STARTEFFECT        6
#define FFIO_STOPEFFECT         7
#define FFIO_GETEFFECTSTATUS    8
#define FFIO_MAX                9

#define IOCTL_JOY_FFIO           (IOCTL_FIRST + 14)

/****************************************************************************
 *
 *      Misc services
 *
 ***************************************************************************/

/*
 *  IN: Nothing
 *
 *  OUT: Pointer to dword sequence pointer
 */
#define IOCTL_GETSEQUENCEPTR    (IOCTL_FIRST + 15)

/****************************************************************************
 *
 *      Back to Joystick
 *
 ***************************************************************************/

/*
 *  Define these again, because NT doesn't have vjoyd
 *  and because vjoyd.inc doesn't define them.
 */
#define JOYPF_X             0x00000001
#define JOYPF_Y             0x00000002
#define JOYPF_Z             0x00000004
#define JOYPF_R             0x00000008
#define JOYPF_U             0x00000010
#define JOYPF_V             0x00000020
#define JOYPF_POV0          0x00000040
#define JOYPF_POV1          0x00000080
#define JOYPF_POV2          0x00000100
#define JOYPF_POV3          0x00000200
#define JOYPF_POV(n)        (JOYPF_POV0 << (n))
#define JOYPF_BTN0          0x00000400
#define JOYPF_BTN1          0x00000800
#define JOYPF_BTN2          0x00001000
#define JOYPF_BTN3          0x00002000
#define JOYPF_ALLAXES       0x0000003F
#define JOYPF_ALLCAPS       0x00003FFF

#define JOYPF_POSITION      0x00010000
#define JOYPF_VELOCITY      0x00020000
#define JOYPF_ACCELERATION  0x00040000
#define JOYPF_FORCE         0x00080000
#define JOYPF_ALLMODES      0x000F0000
#define JOYPF_NUMMODES      4

/*
 *  IN: DWORD external joystick ID
 *
 *  OUT: array of DWORDs listing which axes are valid where
 *
 */
typedef struct VXDAXISCAPS {    /* vac */
    DWORD   dwPos;              /* Axis positions */
    DWORD   dwVel;              /* Axis velocities */
    DWORD   dwAccel;            /* Axis accelerations */
    DWORD   dwForce;            /* Axis forces */
} VXDAXISCAPS, *PVXDAXISCAPS;

#define IOCTL_JOY_GETAXES       (IOCTL_FIRST + 16)

/****************************************************************************
 *
 *      Mouse random
 *
 ***************************************************************************/

/*
 *  IN: Nothing
 *
 *  OUT: Pointer to dword wheel granularity.
 */
#define IOCTL_MOUSE_GETWHEEL    (IOCTL_FIRST + 17)

/****************************************************************************
 *
 *      New IOCTLs for DX8, stuck on the end to improve chances of cross 
 *      version compatibility.
 *
 ***************************************************************************/

/*
 *  IN: Nothing
 *
 *  OUT: Nothing
 */
#define IOCTL_JOY_CONFIGCHANGED    (IOCTL_FIRST + 18)

/*
 *  IN: An instance handle to be pinged
 *
 *  OUT: Instance handle
 *
 *  This is used by the post dinput.dll versions of the DLL to avoid 
 *  unacquiring all instances of a device on a poll failure.
 */
#define IOCTL_JOY_PING8           (IOCTL_FIRST + 19)

/****************************************************************************
 *
 *      End of IOCTL table
 *
 ***************************************************************************/

#define IOCTL_MAX               (IOCTL_FIRST + 20)


/* XLATOFF */
#ifdef __cplusplus
};
#endif
/* XLATON */

#endif  /* __DINPUTV_INCLUDED__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\diport.c ===
/*****************************************************************************
 *
 *  DIPort.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Support functions for Gameport/Serialport enumeration.
 *
 *  Contents:
 *
 *
 *
 *****************************************************************************/

#include "dinputpr.h"

/*
 * We can reuse some code from diHidEnm.c
 */
#define DIPort_GetDevicePath(hdev, pdid, didd, dinf) \
        DIHid_GetDevicePath(hdev, pdid, didd, dinf)

#define DIPort_GetDeviceInstanceId(hdev, pdinf, tszId) \
        DIHid_GetDeviceInstanceId(hdev, pdinf, tszId)

#define DIPort_GetInstanceGUID(hk, lpguid)  \
        DIHid_GetInstanceGUID(hk, lpguid)

#define DIPort_GetRegistryProperty(ptszId, dwProperty, pdiph)    \
        DIHid_GetRegistryProperty(ptszId, dwProperty, pdiph)

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#undef  sqfl
#define sqfl sqflPort

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global PBUSDEVICE | g_pBusDevice |
 *
 *          List of known GamePort/SerialPort devices.
 *
 *****************************************************************************/

static BUSDEVICE g_pBusDevice[] =
{
    {
        D(TEXT("GamePort Bus") comma)
        NULL,
        &GUID_GAMEENUM_BUS_ENUMERATOR,
        0x0,
        IOCTL_GAMEENUM_EXPOSE_HARDWARE,
        IOCTL_GAMEENUM_REMOVE_HARDWARE,
        IOCTL_GAMEENUM_PORT_DESC,
        IOCTL_GAMEENUM_PORT_PARAMETERS,
        IOCTL_GAMEENUM_EXPOSE_SIBLING,
        IOCTL_GAMEENUM_REMOVE_SELF,
        IDS_STDGAMEPORT,
        JOY_HWS_ISGAMEPORTBUS
    },

    /***************
    No defination for serial port devices yet !
    {
        D(TEXT("SerialPort Bus") comma )
        NULL,
        &GUID_SERENUM_BUS_ENUMERATOR,
        0x0,
        IOCTL_SERIALENUM_EXPOSE_HARDWARE,
        IOCTL_SERIALENUM_REMOVE_HARDWARE,
        IOCTL_SERIALENUM_PORT_DESC,
        IOCTL_SERIALENUM_PORT_PARAMETERS,
        IOCTL_SERIALENUM_EXPOSE_SIBLING,
        IOCTL_SERIALENUM_REMOVE_SELF,
        IDS_STDSERIALPORT,
        JOY_HWS_ISSERIALPORTBUS
    },
    ****************/
};


#pragma BEGIN_CONST_DATA

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL INTERNAL | SearchDevTree |
 *
 *          Helper routine that searches the device tree for
 *          a desired device device.
 *
 *  @parm   IN DEVINST | dnStart |
 *          Starting point for the search.
 *
 *  @parm   IN DEVINST | dnSeek |
 *          The device instance we are looking for.
 *
 *  @parm   IN PULONG   | pRecurse |
 *          To limit the number of recursions.
 *
 *  @returns    BOOL
 *          True on success.
 *
 *****************************************************************************/
CONFIGRET INTERNAL
    SearchDevTree
    (
    DEVINST dnStart,
    DEVINST dnSeek,
    PUINT   pRecurse
    )
{
#define MAX_RECURSION   ( 4 )

    CONFIGRET   cr;

    EnterProcI(SearchDevTree, (_"xxx", dnStart, dnSeek, pRecurse));

    cr = CR_SUCCESS;
    for( *pRecurse = 0x0; *pRecurse < MAX_RECURSION && cr == CR_SUCCESS; (*pRecurse)++)
    {
        cr = CM_Get_Parent(&dnSeek, dnSeek, 0 );
        if( dnStart == dnSeek )
        {
            break;  
        }
    }    
    if( dnStart != dnSeek )
    {
        cr = CR_NO_SUCH_DEVNODE;
    }
#undef MAX_RECURSION

#if 0 // Using Recursion 
    if( *pRecurse > MAX_RECURSION )
    {
        return CR_NO_SUCH_DEVNODE;
    }

    if( dnSeek == dnStart )
    {
        return CR_SUCCESS;
    }

    do
    {
        DEVINST dnNode;

        cr = CM_Get_Child(&dnNode, dnStart, 0 );
        if( cr == CR_SUCCESS )
        {
            CAssertF(CR_SUCCESS == 0x0 );
            if( CR_SUCCESS == SearchDevTree(dnNode, dnSeek, pRecurse) )
            {
                return cr;
            }
        }
        cr = CM_Get_Sibling(&dnStart, dnStart, 0);

    }while( cr == CR_SUCCESS );
#endif  // No recursion 

    return cr;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PBUSDEVICEINFO | pbdiFromphdi |
 *
 *          Locates Gameport/Serialport information given a device instance of
 *          one of its children.
 *          Returns NULL if the device instance is not a child of
 *          any known gameports/serialports
 *
 *          Internal Routine, parameters already validated.
 *
 *          The DLL critical must be held across the call; once the
 *          critical section is released, the returned pointer becomes
 *          invalid.
 *
 *  @parm   IN PHIDDEVICEINFO | phdi |
 *
 *          Address of a HIDDEVICEINFO structure
 *
 *  @returns
 *
 *          Pointer to the <t BUSDEVICEINFO> that describes
 *          the parent bus.
 *
 *****************************************************************************/
PBUSDEVICEINFO INTERNAL
    pbdiFromphdi
    (
    IN PHIDDEVICEINFO phdi
    )
{
    PBUSDEVICEINFO pbdi_Found;
    PBUSDEVICE     pBusDevice;
    int iBusType;

    EnterProcI(pbdiFromphdi, (_"x", phdi));

    AssertF(InCrit());
    AssertF(phdi != NULL );

    pbdi_Found = NULL;
    for( iBusType = 0x0, pBusDevice = g_pBusDevice;
       iBusType < cA(g_pBusDevice) && pbdi_Found == NULL;
       iBusType++, pBusDevice++ )
    {
        HDEVINFO hdev;
        /*
         *  Now talk to SetupApi to get info about the device.
         */
        hdev = SetupDiCreateDeviceInfoList(NULL, NULL);

        if(hdev != INVALID_HANDLE_VALUE  )
        {
            SP_DEVINFO_DATA dinf_hid;

            ZeroX(dinf_hid);

            dinf_hid.cbSize = cbX(SP_DEVINFO_DATA);

            /* Get SP_DEVINFO_DATA for the HID device */
            if( pBusDevice->pbdl != NULL  &&
                phdi!= NULL  &&
                SetupDiOpenDeviceInfo(hdev, phdi->ptszId, NULL, 0, &dinf_hid))
            {
                int igdi;
                PBUSDEVICEINFO pbdi;
                SP_DEVINFO_DATA dinf_bus;

                ZeroX(dinf_bus);

                dinf_bus.cbSize = cbX(SP_DEVINFO_DATA);

                /*
                 * Loop through all known gameports/serialports and look for a gameport/serialport
                 * that is a parent of the HID device
                 */

                for(igdi = 0, pbdi = pBusDevice->pbdl->rgbdi;
                   igdi < pBusDevice->pbdl->cgbi && pbdi_Found == NULL ;
                   igdi++, pbdi++)
                {
                    if(SetupDiOpenDeviceInfo(hdev, pbdi->ptszId, NULL, 0, &dinf_bus))
                    {
                        ULONG Recurse = 0x0;
                        if( CR_SUCCESS == SearchDevTree(dinf_bus.DevInst, dinf_hid.DevInst, &Recurse) )
                        {
                            pbdi_Found = pbdi;
                            break;
                        }
                    }
                }
            }
            SetupDiDestroyDeviceInfoList(hdev);
        }
    }
    ExitProcX((UINT_PTR)pbdi_Found);
    return pbdi_Found;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PBUSDEVICEINFO | pbdiFromGUID |
 *
 *          Locates Gameport/Serialport information given a device instance of
 *          one of its children.
 *          Returns NULL if the device instance is not a child of
 *          any known gameports/serialports
 *
 *          Internal Routine, parameters already validated.
 *
 *          The DLL critical must be held across the call; once the
 *          critical section is released, the returned pointer becomes
 *          invalid.
 *
 *  @parm   IN PCGUID | pguid |
 *
 *          The instance GUID to be located.
 *
 *  @returns
 *
 *          Pointer to the <t BUSDEVICEINFO> that describes
 *          the parent bus.
 *
 *****************************************************************************/
PBUSDEVICEINFO EXTERNAL
    pbdiFromGUID
    (
    IN PCGUID pguid
    )
{
    PBUSDEVICEINFO pbdi_Found;
    PBUSDEVICE     pBusDevice;
    int iBusType;

    EnterProcI(pbdiFromGUID, (_"G", &pguid));

    AssertF(InCrit());

    pbdi_Found = NULL;
    for( iBusType = 0x0, pBusDevice = g_pBusDevice;
       iBusType < cA(g_pBusDevice) && pbdi_Found == NULL;
       iBusType++, pBusDevice++ )
    {
        /*
         * Loop through all known gameports/serialports and look for a gameport/serialport
         * that is a parent of the HID device
         */
        PBUSDEVICEINFO pbdi;
        int igdi;
        for(igdi = 0, pbdi = pBusDevice->pbdl->rgbdi;
           igdi < pBusDevice->pbdl->cgbi && pbdi_Found == NULL ;
           igdi++, pbdi++)
        {
            if( IsEqualGUID(pguid, &pbdi->guid)  )
            {
                pbdi_Found = pbdi;
            }
        }
    }
    ExitProcX((UINT_PTR)pbdi_Found);
    return pbdi_Found;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PHIDDEVICEINFO | phdiFrompbdi |
 *
 *          Locates a HID device attached to a given Gameport/Serialport
 *          Returns NULL if no devices are currently attached to a known port.
 *
 *          Internal Routine, parameters already validated.
 *
 *          The DLL critical must be held across the call; once the
 *          critical section is released, the returned pointer becomes
 *          invalid.
 *
 *  @parm   IN PBUSDEVICEINFO | pbdi |
 *
 *          Address of the <t BUSDEVICEINFO> structure that
 *          describes the gameport/serialport.
 *
 *  @returns
 *
 *          Pointer to one of the <t HIDDEVICEINFO> that describes
 *          the device. ( Gamport may have multiple devices attached ).
 *
 *****************************************************************************/

PHIDDEVICEINFO INTERNAL
    phdiFrompbdi
    (
    IN PBUSDEVICEINFO pbdi
    )
{
    PHIDDEVICEINFO phdi_Found;
    HDEVINFO hdev;

    EnterProcI(phdiFrompbdi, (_"x", pbdi));

    AssertF(InCrit());
    AssertF(pbdi != NULL );

    /* Enumurate the HID devices */
    DIHid_BuildHidList(TRUE);

    phdi_Found = NULL;
    /*
     *  Now talk to SetupApi to get info about the device.
     */
    hdev = SetupDiCreateDeviceInfoList(NULL, NULL);

    if(hdev != INVALID_HANDLE_VALUE)
    {
        SP_DEVINFO_DATA dinf_bus;

        dinf_bus.cbSize = cbX(SP_DEVINFO_DATA);

        if( pbdi != NULL && SetupDiOpenDeviceInfo(hdev, pbdi->ptszId, NULL, 0, &dinf_bus))
        {
            int ihdi;
            PHIDDEVICEINFO phdi;
            SP_DEVINFO_DATA dinf_hid;
            dinf_hid.cbSize = cbX(SP_DEVINFO_DATA);

            if( g_phdl )
            {
                for(ihdi = 0, phdi = g_phdl->rghdi ;
                   ihdi < g_phdl->chdi && phdi_Found == NULL ;
                   ihdi++, phdi++)
                {
                    if(SetupDiOpenDeviceInfo(hdev, phdi->ptszId, NULL, 0, &dinf_hid))
                    {
                        ULONG Recurse = 0x0;
                        if(CR_SUCCESS == SearchDevTree(dinf_bus.DevInst, dinf_hid.DevInst, &Recurse) )
                        {
                            phdi_Found = phdi;
                        }
                    }
                }
            }
        }
        SetupDiDestroyDeviceInfoList(hdev);
    }

    ExitProcX((UINT_PTR)phdi_Found);
    return phdi_Found;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   PPORTDEVICEINFO | pbdiFromJoyId |
 *
 *          Locates Gameport/Serialport information given a device id of
 *          a joystick .
 *
 *          Returns NULL if the device instance is not a child of
 *          any known gameports/serialports
 *
 *          Internal Routine, parameters already validated.
 *
 *          The DLL critical must be held across the call; once the
 *          critical section is released, the returned pointer becomes
 *          invalid.
 *
 *  @parm   IN int | idJoy |
 *
 *          The Joystick ID of the child device that will be associated
 *          to a known gameport/serialport.
 *
 *  @returns
 *
 *          Pointer to the <t BUSDEVICEINFO> that describes
 *          the device.
 *
 *****************************************************************************/

PBUSDEVICEINFO EXTERNAL
    pbdiFromJoyId
    (
    IN int idJoy
    )
{
    GUID guid;
    HRESULT hres;
    PBUSDEVICEINFO pbdi;

    EnterProcI(pbdiFromJoyId, (_"x", idJoy));
    AssertF(InCrit());

    pbdi = NULL;

    /* Find the GUID that corresponds to the Joystick ID */
    hres = hResIdJoypInstanceGUID_WDM(idJoy, &guid);
    
#ifndef WINNT
    if( FAILED(hres) ) {
        hres = hResIdJoypInstanceGUID_95(idJoy, &guid);
    }
#endif

    if( SUCCEEDED(hres) )
    {
        PHIDDEVICEINFO phdi;
        phdi = phdiFindHIDInstanceGUID(&guid);

        if( phdi != NULL )
        {
            pbdi = pbdiFromphdi(phdi);
        }
    }

    ExitProcX((UINT_PTR)pbdi);
    return pbdi;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | DIBusDevice_Expose |
 *
 *  Attaches a gameport/serialport device to the Gameport/SerialPort Bus
 *
 *  @parm   IN PBUSDEVICEINFO | pbdi |
 *          Address of a BUSDEVICEINFO structure.
 *
 *  @parm   IN OUT PBUS_REGDATA    | pRegData |
 *          Gameport/Serialport specific data. The Handle to the opened device
 *          is returned in this structure
 *
 *
 *  @returns
 *          BOOL. True indicates success.
 *
 *****************************************************************************/

HRESULT EXTERNAL
    DIBusDevice_Expose
    (
    IN     PBUSDEVICEINFO  pbdi,
    IN OUT PBUS_REGDATA    pRegData
    )
{
    HRESULT hres;
    BOOL frc;
    PHIDDEVICEINFO  phdi;

    EnterProcI(DIBusDevice_Expose, (_ "pp", pbdi, pRegData));

    AssertF(DllInCrit() );
    AssertF(pbdi!= NULL );

    phdi = phdiFrompbdi(pbdi);

    if( pRegData && pRegData->dwSize != cbX(*pRegData) )
    {
        hres = E_INVALIDARG;
    } else if( phdi != NULL )
    {
        hres = E_ACCESSDENIED;
    } else
    {
        HANDLE hf;
		BUS_REGDATA RegDataTest;

        /* There is a weird condition where the HID device does not appear on a previous
         * Add, (drivers not loaded, user cancelled loading of some files, etc
         * In such cases we need to tell GameEnum to remove the device before proceeding
         * any further
         */
        if( pbdi->fAttached || pRegData->hHardware != NULL )
        {
            DIBusDevice_Remove(pbdi);
        }
        AssertF(pbdi->fAttached == FALSE);

		// Change for Windows bug 575181 -- make sure we can write to the registry
		// before we expose the device; otherwise we might not be able to remove it!
		ZeroMemory(&RegDataTest, cbX(RegDataTest));
		RegDataTest.dwSize = cbX(RegDataTest);
		if (FAILED(DIBusDevice_SetRegData(pbdi->hk,  &RegDataTest)))
		{
			// We couldn't write to the registy; return E_ACCESSDENIED
			hres = E_ACCESSDENIED;
		}
		else
		{
        // Open a File handle to the gameport/serialport device so we can send it IOCTLS
        hf = CreateFile(pbdi->pdidd->DevicePath,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        0,                /* no SECURITY_ATTRIBUTES */
                        OPEN_EXISTING,
                        0,                /* attributes */
                        0);               /* template */

        if( hf != INVALID_HANDLE_VALUE )
        {
            DWORD cbRc;
            GAMEENUM_PORT_DESC  Desc;
            Desc.Size = cbX(Desc) ;

            Sleep(50);  //need sleep a while to wait for the device is ready to accept commands.
            
            /* Get the gameport bus properties */
            frc = DeviceIoControl (hf,
                                   pbdi->pBusDevice->ioctl_DESC,
                                   &Desc, cbX(Desc),
                                   &Desc, cbX(Desc),
                                   &cbRc, NULL);
            if( frc  && cbRc == cbX(Desc) )
            {
                PGAMEENUM_EXPOSE_HARDWARE pExpose;
                DWORD cbExpose;
                cbExpose = cbX(*pExpose) + cbX(pRegData->wszHardwareId);

                hres = AllocCbPpv( cbExpose, & pExpose);

                if( SUCCEEDED(hres ) )
                {
                    typedef struct _OEMDATA
                    {
                        ULONG   uVID_uPID;
                        ULONG   joy_hws_dwFlags;
                        ULONG   dwFlags1;
                        ULONG   Reserved;
                    } OEMDATA, *POEMDATA;

                    POEMDATA    pOemData = (POEMDATA)(&pExpose->OemData);
                    CAssertF(2*sizeof(*pOemData) == sizeof(pExpose->OemData))

                    pOemData->uVID_uPID = MAKELONG(pRegData->uVID, pRegData->uPID);
                    pOemData->joy_hws_dwFlags = pRegData->hws.dwFlags;
                    pOemData->dwFlags1 = pRegData->dwFlags1;

                    /*
                     *  Make sure only known analog devices cause the 
                     *  compatible hardware ID to be exposed.
                     *  This is done so that no in-box drivers will match for 
                     *  an unsupported digital joystick so users will be 
                     *  prompted to use an unsigned IHV driver rather than 
                     *  silently loading the generic analog joystick driver.
                     */
                    if( ( pRegData->dwFlags1 & JOYTYPE_ANALOGCOMPAT )
                     || ( ( pRegData->uVID == MSFT_SYSTEM_VID )
                       && ( ( pRegData->uPID & 0xff00 ) == MSFT_SYSTEM_PID ) ) )
                    {
                        pExpose->Flags = GAMEENUM_FLAG_COMPATIDCTRL;
                    }
                    else
                    {
                        pExpose->Flags = GAMEENUM_FLAG_COMPATIDCTRL | GAMEENUM_FLAG_NOCOMPATID ;
                    }

                    pExpose->Size            = cbX(*pExpose) ;
                    pExpose->PortHandle      = Desc.PortHandle;
                    pExpose->NumberJoysticks = pRegData->nJoysticks;

                    pRegData->nAxes          = 2;

                    if( pExpose->NumberJoysticks != 2 )
                    {
                        AssertF( pExpose->NumberJoysticks == 1);
                        if( pRegData->hws.dwFlags & JOY_HWS_HASZ )
                        {
                            pRegData->nAxes++;
                        }
                        if( pRegData->hws.dwFlags & JOY_HWS_HASR )
                        {
                            pRegData->nAxes++;
                        }
                        pExpose->NumberButtons   = (USHORT)pRegData->hws.dwNumButtons;
                    }
                    else
                    {
                        pOemData++;
                        pOemData->uVID_uPID = MAKELONG(pRegData->uVID, pRegData->uPID);
                        pOemData->joy_hws_dwFlags = JOY_HWS_XISJ2X | JOY_HWS_YISJ2Y;
                        pExpose->NumberButtons = 2;
                    }

                    pExpose->NumberAxis = pRegData->nAxes;

                    /*
                     *  The SideWinder driver uses the OEMData field in a 
                     *  sibling expose to pass internal data (this ptrs) from 
                     *  one instance to another.  Since these fields are 
                     *  supposed to be for the OEMData we have a Flags1 field 
                     *  to allow the data to be zeroed for a DInput expose for 
                     *  drivers that don't want the normal data.
                     */

                    if ( pRegData->dwFlags1 & JOYTYPE_ZEROGAMEENUMOEMDATA )                      
                    {
                        ZeroBuf(pExpose->OemData, sizeof(pExpose->OemData) );
                    }

                    CopyMemory(pExpose->HardwareIDs, pRegData->wszHardwareId, cbX(pRegData->wszHardwareId) );

                    Sleep(50);

                    if( frc = DeviceIoControl (hf,
                                               pbdi->pBusDevice->ioctl_EXPOSE,
                                               pExpose, cbExpose,
                                               pExpose, cbExpose,
                                               &cbRc, NULL )
                        && cbRc == cbExpose )
                    {
                        PVOID hHardwareOld = pRegData->hHardware;

                        pbdi->fAttached = TRUE;
                        pRegData->hHardware = pExpose->HardwareHandle;
                        DIBusDevice_SetRegData(pbdi->hk,  pRegData);

                        /*
                         * If we have dealt with this device before then the hHardwareOld
                         * will be non null, and we have sufficient reason to believe that the
                         * expose will succeed.
                         *
                         * This test needs to be removed to fix manbug: 39554. 
                         * For new created device, we need wait for a while to let phdi be ready.
                         * 
                         */
                        //if(hHardwareOld)
                        {
                            int i;

                            for(i = 0; (i < 20) && (phdiFrompbdi(pbdi) == NULL); i++ )
                            {
                                Sleep(50);
                            }
                        }

                    } else // DeviceIOControl (EXPOSE) Failed
                    {
                        hres = E_FAIL;
                        SquirtSqflPtszV(sqfl | sqflError,
                                        TEXT("%S: IOCTL_PORTENUM_EXPOSE_HARDWARE failed  ")
                                        TEXT("Error = %d"),
                                        s_szProc, GetLastError());
                    }
                    FreePpv(&pExpose);
                } else // Alloc failed
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%S: AllocCbPpv  failed  "),
                                    s_szProc);
                }
            } else // IOCTL FAILED
            {
                hres = E_FAIL;
                SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("%S: IOCTL_PORTENUM_PORT_DESC failed ")
                                TEXT("Error = %d"),
                                s_szProc, GetLastError());
            }

            CloseHandle(hf);
        } else
        {
            hres = E_FAIL;
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%S: CreateFile(%s) failed  ")
                            TEXT("Error = %d"),
                            s_szProc, pbdi->pdidd->DevicePath, GetLastError());
        }
		}
    }
    ExitBenignProcX(hres);

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | DIBusDevice_Remove |
 *
 *  Removes the FDO for a gameport/serialport device.
 *
 *  @parm   IN HANDLE | hf |
 *          Handle to the GamePort/SerialPort Bus device file object
 *
 *  @parm   IN PPORT_REGDATA    | pRegData |
 *          Structure that contains registry data. What we need from here is the
 *          handle to the hardware.
 *
 *  @returns
 *          BOOL. True for success.
 *
 *****************************************************************************/

HRESULT INTERNAL
    DIBusDevice_Remove
    (
    IN PBUSDEVICEINFO  pbdi
    )
{
    HRESULT hres;
    BUS_REGDATA RegData;

    EnterProcI(DIBus_Remove, (_ "p", pbdi));

    hres = DIBusDevice_GetRegData(pbdi->hk,  &RegData);

    //
    //  Delete our registry goo, so this device
    //  will not show up on subsequent reboots
    //
    DIBusDevice_SetRegData(pbdi->hk,  NULL);

    if( SUCCEEDED(hres) )
    {
        HANDLE hf;
        BOOL frc;

        // Open a File handle to the gameport/serialport device so we can send it IOCTLS
        hf = CreateFile(pbdi->pdidd->DevicePath,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        0,                /* no SECURITY_ATTRIBUTES */
                        OPEN_EXISTING,
                        0,                /* attributes */
                        0);               /* template */

        if( hf != INVALID_HANDLE_VALUE )
        {

            DWORD cbRc;
            GAMEENUM_REMOVE_HARDWARE Remove;

            Remove.Size = cbX(Remove);
            Remove.HardwareHandle = RegData.hHardware;

            frc = DeviceIoControl (hf,
                                   pbdi->pBusDevice->ioctl_REMOVE,
                                   &Remove, cbX(Remove),
                                   &Remove, cbX(Remove),
                                   &cbRc, NULL) ;
            if( frc &&  cbRc == cbX(Remove) )
            {
                pbdi->fAttached = FALSE;
            } else // DeviceIoControl ( REMOVE_HARDWARE ) Failed
            {
                hres = E_FAIL;
                SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("%S: DeviceIOControl(REMOVE_HARDWARE) failed  ")
                                TEXT("Error = %d"),
                                s_szProc, GetLastError());
            }
            CloseHandle(hf);
        }
    }

    ExitBenignOleProc();

    return hres;
}




/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DIPort_SetRegData |
 *
 *          Sets up registry data under the $hk$/Config subkey for the gameport
 *          device.
 *
 *  @parm   IN HKEY | hk |
 *          A handle to the parent key where the registry data will be written.
 *
 *  @parm   IN PGAMEPORT_REGDATA | pRegData |
 *          Pointer to a structure containing data to be written to the registry.
 *
 *  @returns
 *          BOOL. True for success
 *
 *****************************************************************************/
HRESULT INTERNAL
    DIBusDevice_SetRegData
    (
    IN HKEY hk,
    IN PBUS_REGDATA pRegData
    )
{
    LONG    lrc;
    HRESULT hres = S_OK;

    EnterProcI(DIPort_SetRegData, (_ "xpx", hk, pRegData ));

    if( pRegData != NULL )
    {

        if( ( lrc =  RegSetValueEx(hk, TEXT("Config"), 0, REG_BINARY,
                                   (PV) (pRegData), cbX(*pRegData)) )  == ERROR_SUCCESS )
        {
            hres = S_OK;
        } else // RegSetValueEx FAILED
        {
            hres = E_FAIL;
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%S: RegSetValueEx() failed ")
                            TEXT("Error = %d"),
                            s_szProc, lrc);
        }
    } else
    {
        lrc = RegDeleteValue(hk, TEXT("Config"));
    }

    ExitOleProc();
    return (hres);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DIPort_GetRegData |
 *
 *          Gets registry data from the $hk$/Config subkey for the gameport
 *          device.
 *
 *  @parm   IN HKEY | hk |
 *          A handle to the parent key where the registry.
 *
 *  @parm   IN PGAMEPORT_REGDATA | pRegData |
 *          Address of a pointer to the structure where the registry data
 *          will be read into.
 *
 *  @returns
 *          HRESULT
 *****************************************************************************/
HRESULT INTERNAL
    DIBusDevice_GetRegData
    (
    IN HKEY hk,
    OUT PBUS_REGDATA pRegData
    )
{
    LONG    lRc;
    DWORD cb;
    HRESULT hres;

    EnterProcI(DIPort_GetRegData, (_ "xpx", hk, pRegData ));

    cb = cbX(*pRegData);

    lRc = RegQueryValueEx( hk, TEXT("Config"), 0, 0 , (PV)(pRegData), &cb );

    if( lRc == ERROR_SUCCESS && pRegData->dwSize == cbX(*pRegData ) )
    {
        hres = S_OK;
    } else
    {
        DIBusDevice_SetRegData(hk, NULL );
        ZeroX(*pRegData);
        hres = E_FAIL;

        SquirtSqflPtszV(sqfl | sqflBenign,
                        TEXT("%S: RegQueryValueEx(Config) failed ")
                        TEXT("Error = %d, ( pRegData->cbSize(%d) == cbX(*pRegData)(%d)) "),
                        s_szProc, lRc, pRegData->dwSize, cbX(*pRegData) );
    }

    ExitBenignOleProc();
    return ( hres ) ;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DIBus_BuildListEntry |
 *
 *          Builds a single entry in the list of GAMEPORT/SERIALPORT devices.
 *
 *  @parm   HDEVINFO | hdev |
 *
 *          Device list being enumerated.
 *
 *  @parm   PSP_DEVICE_INTERFACE_DATA | pdid |
 *
 *          Describes the device that was enumerated.
 *
 *  @returns
 *
 *          Nonzero on success.
 *
 *****************************************************************************/

BOOL INTERNAL
    DIBusDevice_BuildListEntry
    (
    HDEVINFO hdev,
    PSP_DEVICE_INTERFACE_DATA pdid,
    PBUSDEVICE pBusDevice
    )
{
    BOOL fRc = TRUE;
    //HKEY hkDev;
	HKEY hkDin;
    PBUSDEVICEINFO pbdi;
    PBUSDEVICELIST pbdl;
    PSP_DEVICE_INTERFACE_DETAIL_DATA pdidd;
    BOOL    fAlreadyExist;

    HRESULT hres;

    EnterProcI(DIBus_BuildListEntry, (_ "xp", hdev, pdid));

    pbdl = pBusDevice->pbdl;

    fAlreadyExist = FALSE;

    /* GetDevicePath is expecting a NULL */
    pdidd = NULL;
    
    if( DIPort_GetDevicePath(hdev, pdid, &pdidd, NULL) )
    {
        int ibdi;
        //Check whether the device has been in the list
        for( ibdi = 0; ibdi < pbdl->cgbi; ibdi++)
        {
            if( pbdl->rgbdi[ibdi].pdidd )
            {
                if( lstrcmp( pdidd->DevicePath, pbdl->rgbdi[ibdi].pdidd->DevicePath ) == 0 )
                {
                    //already in the list
                    fAlreadyExist = TRUE;
                    break;
                }
            }
        }
        FreePpv(&pdidd);
    }

    if( fAlreadyExist == TRUE )
    {
        fRc = TRUE;
    } else
    {
        /*
         *  Make sure there is room for this device in the list.
         *  Grow by doubling.
         */
        if( pbdl->cgbi >= pbdl->cgbiAlloc)
        {
            /*
             *  Assert that we never ask for zero bytes here
             */
            AssertF( cbGdlCbdi( pbdl->cgbiAlloc * 2) );
            hres = ReallocCbPpv( cbGdlCbdi( pbdl->cgbiAlloc * 2), &pBusDevice->pbdl );
            if( FAILED(hres) )
            {
                SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("%S: Realloc failed"), s_szProc);
                fRc = FALSE;
                goto done;
            }
            /*
             *  Prefix warns (Win:170673) that pBusDevice->pbdl could be zero 
             *  if we asked for zero bytes above but the size requested cannot 
             *  be zero so this has been asserted.  Note the fix for (W:45084) 
             *  was incorrect so it has been removed.
             */
            pbdl = pBusDevice->pbdl;
            pbdl->cgbiAlloc *= 2;
        }

        AssertF( pbdl->cgbi < pbdl->cgbiAlloc);
        pbdi        = &pbdl->rgbdi[pbdl->cgbi];
        pbdi->pBusDevice = pBusDevice;
        pbdi->hk    = 0;
        pbdi->idJoy = JOY_BOGUSID;

        /*
         *  Open the registry key for the device so we can obtain
         *  auxiliary information.
         */
        {
			//Open our own reg key under MediaProperties/DirectInput,
			//creating it if necessary.
			hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE, 
								   REGSTR_PATH_DITYPEPROP,
								   DI_KEY_ALL_ACCESS, 
								   REG_OPTION_NON_VOLATILE, 
								   &hkDin);
			if (SUCCEEDED(hres))
			{
				//Create the Gameports reg key
				HKEY hkGameports;
				hres = hresMumbleKeyEx(hkDin,
									   TEXT("Gameports"),
									   DI_KEY_ALL_ACCESS,
									   REG_OPTION_NON_VOLATILE,
									   &hkGameports);
				if (SUCCEEDED(hres))
				{
					//Create a reg key corresponding to the instance number.
					//Since we do this for every gameport enumerated, the number in the list
					//indicates the instance number.
					TCHAR tszInst[3];
					wsprintf(tszInst, TEXT("%u"), pbdl->cgbi);

					hres = hresMumbleKeyEx(hkGameports,
									   tszInst,
									   DI_KEY_ALL_ACCESS,
									   REG_OPTION_NON_VOLATILE,
									   &pbdi->hk);

					if(SUCCEEDED(hres))
					{
						SP_DEVINFO_DATA dinf;
						dinf.cbSize = cbX(SP_DEVINFO_DATA);

						/*
						 *  Get the instance GUID and the path to
						 *  the GAMEPORT/SERIALPORT device so we can talk to it.
						 */
						if(DIPort_GetDevicePath(hdev, pdid, &pbdi->pdidd, &dinf) &&
						   DIPort_GetDeviceInstanceId(hdev, &dinf, &pbdi->ptszId) &&
						   DIPort_GetInstanceGUID(pbdi->hk, &pbdi->guid) )
						{
							HANDLE hf;
							hf = CreateFile(pbdi->pdidd->DevicePath,
											GENERIC_READ | GENERIC_WRITE,
											FILE_SHARE_READ | FILE_SHARE_WRITE,
											0,                /* no SECURITY_ATTRIBUTES */
											OPEN_EXISTING,
											0,                /* attributes */
											0);               /* template */

							if( hf != INVALID_HANDLE_VALUE )
							{

								BUS_REGDATA  RegData;
								ZeroX(RegData);

								CloseHandle(hf);

								// Bump up the counter
								fRc = TRUE;
								pbdl->cgbi++;

								hres = DIBus_InitId(pBusDevice->pbdl);

								if( SUCCEEDED(hres) )
								{
									hres = DIBusDevice_GetRegData(pbdi->hk, &RegData);
								}

								if(  SUCCEEDED(hres)  )
								{
									/* There is a pathological case which can cause endless bluescreen's
									 * If the HID driver causes a bluescreen, and we keep reattaching
									 * it, we are sunk !!
									 * To guard against this possiblity we reattach a device on reboot
									 * only if we are sure that it succeeded the first time around
									 */
									if( RegData.fAttachOnReboot == FALSE )
									{
										DIBusDevice_Remove(pbdi);

										SquirtSqflPtszV(sqfl | sqflError,
														TEXT("%S: DIPortDevice_Expose FAILED, ")
														TEXT("Driver did not load property the first time around "),
														s_szProc);
									} else if( pbdi->fAttached == FALSE )
									{
										hres = DIBusDevice_Expose( pbdi,  &RegData );
										if( SUCCEEDED( hres ) || hres == E_ACCESSDENIED )
										{
											pbdi->fAttached = TRUE;
										} else
										{
											SquirtSqflPtszV(sqfl | sqflError,
															TEXT("%S: DIPortDevice_Expose FAILED ")
															TEXT("hres = %d"),
															s_szProc, hres);
										}
									}
								}

							} else
							{
								fRc = FALSE;

								SquirtSqflPtszV(sqfl | sqflError,
												TEXT("%S: CreateFile(%s) failed  ")
												TEXT("Error = %d"),
												s_szProc, pbdi->pdidd->DevicePath, GetLastError());
							}

						} else
						{
							SquirtSqflPtszV(sqfl | sqflError,
											TEXT("%S: Unable to get device path"),
											s_szProc);
							pbdi->hk = 0x0;
							fRc = FALSE;
						}

						/*
						 *  If we failed, then free the goo we already got.
						 */
						if(!fRc)
						{
							if( pbdi->hk )
								RegCloseKey(pbdi->hk);
							pbdi->hk = 0;
							FreePpv(&pbdi->pdidd);
							FreePpv(&pbdi->ptszId);
							fRc = FALSE;
						}

					} else
					{
						SquirtSqflPtszV(sqfl | sqflError,
										TEXT("%S: RegCreateKeyEx failed on Instance, error "),
										s_szProc);
						fRc = FALSE;
					}

					RegCloseKey(hkGameports);

				} else // RegCreateKeyEx FAILED
				{
					SquirtSqflPtszV(sqfl | sqflError,
									TEXT("%S: RegCreateKeyEx failed on Gameports, error "),
									s_szProc);
					fRc = FALSE;
				}

				RegCloseKey(hkDin);
			}
			else
			{
				SquirtSqflPtszV(sqfl | sqflError,
									TEXT("%S: RegOpenKeyEx failed on DirectInput"),
									s_szProc);
				fRc = FALSE;
			}

        } 
    }
    done:;
    ExitProcF(fRc);
    return fRc;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   void | DIPort_EmptyList |
 *
 *          Empty the list of GAMEPORT/SERIALPORT devices.
 *
 *          This function must be called under the DLL critical section.
 *
 *****************************************************************************/

void INTERNAL
    DIBus_EmptyList
    (
    PBUSDEVICELIST *ppbdl
    )
{
    PBUSDEVICELIST pbdl = *ppbdl;

    AssertF(InCrit());

    if( pbdl )
    {
        int igdi;
        for(igdi = 0; igdi < pbdl->cgbi; igdi++)
        {
            FreePpv(&pbdl->rgbdi[igdi].pdidd);
            FreePpv(&pbdl->rgbdi[igdi].ptszId);
            if( pbdl->rgbdi[igdi].hk)
            {
                RegCloseKey( pbdl->rgbdi[igdi].hk);
            }
        }
        /*
         *  We invalidated all the pointers, so make sure
         *  nobody looks at them.
         */
        pbdl->cgbi = 0;
        FreePpv(&pbdl);
        *ppbdl = NULL;
    }
}

void EXTERNAL
    DIBus_FreeMemory()
{
    int iBusType;
    PBUSDEVICE pBusDevice;

    for( iBusType = 0x0, pBusDevice = g_pBusDevice;
       iBusType < cA(g_pBusDevice);
       iBusType++, pBusDevice++ )
    {
        DIBus_EmptyList(&pBusDevice->pbdl);
    }
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   void | DIPort_InitId |
 *
 *          Initializes Joystick IDs for JoyConfig and legacy APIs
 *          Store the joystick IDs the registry under the %%DirectX/JOYID key.
 *
 *****************************************************************************/

#undef  PORTID_BOGUS
#define PORTID_BOGUS    ( 0xffffffff )

HRESULT EXTERNAL
    DIBus_InitId(PBUSDEVICELIST pbdl)
{
    HRESULT hres = FALSE;
    LONG    lRc;
    DWORD   cb;
    int     igdi;
    BOOL    fNeedId;
    BOOL    rfPortId[cgbiMax];     /* Bool Array for to determine which IDs are in use */
    PBUSDEVICEINFO pbdi;

    EnterProcI(DIBus_InitId, (_ ""));

    fNeedId = FALSE;

    AssertF(DllInCrit());

    ZeroX(rfPortId );


    if( pbdl != NULL )
    {
        /* Iterate over to find used IDs */
        for( igdi = 0, pbdi = pbdl->rgbdi ;
           igdi < pbdl->cgbi ;
           igdi++, pbdi++ )
        {
            pbdi->idPort = PORTID_BOGUS;  // Default
        
            cb = cbX(pbdi->idPort);
            if( ( lRc = RegQueryValueEx(pbdi->hk, TEXT("ID"),
                                        0, 0, (PV)&pbdi->idPort, &cb) == ERROR_SUCCESS ) )
            {
                if(    rfPortId[pbdi->idPort]           // Collision in GameId
                       || pbdi->idPort > cgbiMax  )       // Wrror
                {
                    pbdi->idPort = PORTID_BOGUS;
                    fNeedId = TRUE;
                } else  // Valid idPort
                {
                    rfPortId[pbdi->idPort] = TRUE;

                }
            } else // RegQueryValue("ID") does not exist
            {
                fNeedId = TRUE;
            }
        }

        if( fNeedId )
        {
            /*
             * We have Examined all GamePort/SerialPort Ids found used IDs
             * and determined some device needs an Id
             */
            /* Iterate to assign unused Id's */
            for( igdi = 0, pbdi = pbdl->rgbdi;
               igdi < pbdl->cgbi ;
               igdi++, pbdi++ )
            {
                if( pbdi->idPort == PORTID_BOGUS  )
                {
                    /* Get an Unused ID */
                    for( pbdi->idPort = 0x0;
                       pbdi->idPort < cgbiMax;
                       pbdi->idPort++ )
                    {
                        if( rfPortId[pbdi->idPort] == FALSE )
                            break;
                    }
                    rfPortId[pbdi->idPort] = TRUE;

                    if( lRc = RegSetValueEx(pbdi->hk, TEXT("ID"), 0, REG_BINARY,
                                            (PV)&pbdi->idPort, cbX(pbdi->idPort)) == ERROR_SUCCESS )
                    {

                    } else
                    {
                        SquirtSqflPtszV(sqfl | sqflError,
                                        TEXT("%S: RegSetValueEx(JOYID) FAILED ")
                                        TEXT("Error = %d"),
                                        s_szProc, lRc);
                        hres = FALSE;
                    }
                }
            }
        }
    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DIBus_CheckList |
 *
 *          Check the list of HID devices and free any that cannot be opened
 *
 *          This function must be called under the DLL critical section.
 *
 *****************************************************************************/

void INTERNAL
    DIBus_CheckList(PBUSDEVICELIST pbdl)
{
    HANDLE hf;

    AssertF(InCrit());

    /*
     *  Free all the information of the device that cannot be opened
     */
    if(pbdl)
    {
        int ibdi;

        PBUSDEVICEINFO pbdi;
        for(ibdi = 0, pbdl->cgbi = 0; ibdi < pbdl->cgbiAlloc; ibdi++)
        {
            pbdi = &pbdl->rgbdi[ibdi];
            if( pbdi && pbdi->pdidd )
            {
                /*
                 *  Open the device
                 */
                hf = CreateFile(pbdi->pdidd->DevicePath,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                0,                /* no SECURITY_ATTRIBUTES */
                                OPEN_EXISTING,
                                0,                /* attributes */
                                0);               /* template */

                if(hf == INVALID_HANDLE_VALUE)
                {
                    FreePpv(&pbdi->pdidd);
                    FreePpv(&pbdi->ptszId);
                    if(pbdi->hk)
                    {
                        RegCloseKey(pbdi->hk);
                    }
                    ZeroX( pbdi );
                } else
                {
                    pbdl->cgbi++;
                    CloseHandle(hf);
                }
            }
        }

        //re-order the existing devices, put them at the front of the hid list.
        for(ibdi = 0; ibdi < pbdl->cgbi; ibdi++)
        {
            if( !pbdl->rgbdi[ibdi].pdidd )
            {
                int ibdi2;

                //find the existing device from the biggest index in the hid list.
                for( ibdi2 = pbdl->cgbiAlloc; ibdi2 >= ibdi+1; ibdi2-- )
                {
                    if( pbdl->rgbdi[ibdi2].pdidd )
                    {
                        memcpy( &pbdl->rgbdi[ibdi], &pbdl->rgbdi[ibdi2], sizeof(BUSDEVICEINFO) );
                        ZeroX( pbdl->rgbdi[ibdi2] );
                    }
                }
            }
        }

    }

    return;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   void | DIBus_BuildList |
 *
 *          Builds the list of GAMEPORT/SERIALPORT devices.
 *
 *  @parm   BOOL | fForce |
 *
 *          If nonzero, we force a rebuild of the GAMEPORT/SERIALPORT list.
 *          Otherwise, we rebuild only if the list hasn't
 *          been rebuilt recently.
 *
 *****************************************************************************/

#define MSREBUILDRATE       20000                /* Twenty seconds */

ULONG EXTERNAL
    DIBus_BuildList( IN BOOL fForce )
{
    HRESULT hres;
    PBUSDEVICE pBusDevice;
    ULONG cDevices;
    int iBusType;
    DWORD    dwTickCount;

    EnterProcI(DIBus_BuildList, (_ "u", fForce));

    DllEnterCrit();

    /*
     *  Decide whether or not to rebuild once (don't want to half rebuild)
     */
    dwTickCount = GetTickCount();

    // Force implies a complete rebuild of the list. 
    if(fForce) 
    {
        DIBus_FreeMemory();
    }
    
    DIHid_BuildHidList(fForce);

    hres = S_OK;
    for( cDevices = iBusType = 0x0, pBusDevice = g_pBusDevice;
       iBusType < cA(g_pBusDevice);
       iBusType++, pBusDevice++ )
    {
        PBUSDEVICELIST pbdl;
        pbdl = pBusDevice->pbdl;

        if( HidD_GetHidGuid &&                          /* HID support */
            ( fForce ||                                 /* Forcing rebuild, or */
              pBusDevice->tmLastRebuild == 0 ||         /* Never built before, or */
              dwTickCount - pBusDevice->tmLastRebuild > MSREBUILDRATE )
          )
        {
            HDEVINFO hdev;

            /* delete devices that disappeared since we last looked */
            DIBus_CheckList(pbdl);

            hdev = SetupDiGetClassDevs((LPGUID)pBusDevice->pcGuid, 0, 0,
                                       DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);

            if(hdev != INVALID_HANDLE_VALUE)
            {
                /*
                 *  There is no way to query the number of devices.
                 *  You just have to keep incrementing until you run out.
                 *
                 *  If we already have a pbdl, then re-use it.  Else, create
                 *  a new one.  Alloc up to the minimum starting point.
                 */

                if( pBusDevice->pbdl == NULL )
                {
                    /*
                     *  Prefix warns that we leak this memory (mb:34688) but 
                     *  we keep a reference in our global list so we can free 
                     *  the memory when we're done with it.
                     */
                    hres = AllocCbPpv(cbGdlCbdi(cgbiInit), &pBusDevice->pbdl );

                    if(SUCCEEDED(hres))
                    {
                        pbdl = pBusDevice->pbdl;
                        pbdl->cgbi = 0;
                        pbdl->cgbiAlloc = cgbiInit;
                    }
                }

                if( SUCCEEDED(hres) )
                {
                    int idev;

                    /*
                     *  To avoid infinite looping on
                     *  internal *boo-boo's*, break on any
                     *  error once we have tried more than
                     *  cgbiMax devices, since that's the most
                     *  GAMEPORT/SERIALPORT will ever give us.
                     */
                    for(idev = 0; idev < cgbiMax; idev++)
                    {
                        SP_DEVICE_INTERFACE_DATA did;

                        AssertF( pbdl->cgbi <= pbdl->cgbiAlloc);

                        /* 
                         *  Note, pnp.c doesn't initialize this so we have to
                         */
                        did.cbSize = cbX(did);
                        if(SetupDiEnumDeviceInterfaces(hdev, 0, (LPGUID)pBusDevice->pcGuid,
                                                       idev, &did))
                        {
                            if(DIBusDevice_BuildListEntry(hdev, &did, &g_pBusDevice[iBusType] ))
                            {
                                //pbdl->cgbi++;
                            } else
                            {
                                /* Skip erroneous items */
                                SquirtSqflPtszV(sqfl | sqflError,
                                                TEXT("DIBus_BuildListEntry ")
                                                TEXT("failed?"));
                            }

                        } else

                            if(GetLastError() == ERROR_NO_MORE_ITEMS)
                        {
                            break;

                        } else
                        {
                            /* Skip erroneous items */
                            SquirtSqflPtszV(sqfl | sqflError,
                                            TEXT("SetupDiEnumDeviceInterface ")
                                            TEXT("failed? le=%d"), GetLastError());
                        }

                    }

                }

                SetupDiDestroyDeviceInfoList(hdev);
                pBusDevice->tmLastRebuild = GetTickCount();
            }
        }

        if(pbdl) { cDevices += pbdl->cgbi; }
    }
    
    /* New gameport devices may be exposed. Pick them up too */
    DIHid_BuildHidList(FALSE);
    
    DllLeaveCrit();
    ExitProc();
    return (cDevices);
}

PBUSDEVICELIST EXTERNAL
    pbdlFromGUID
    (
    IN PCGUID pcGuid
    )
{
    PBUSDEVICELIST  pbdl_Found = NULL;
    PBUSDEVICE      pBusDevice;
    int iBusType;

    for( iBusType = 0x0, pBusDevice = g_pBusDevice;
       iBusType < cA(g_pBusDevice);
       iBusType++, pBusDevice++ )
    {
        if( IsEqualGUID(pBusDevice->pcGuid, pcGuid) )
        {
            pbdl_Found = pBusDevice->pbdl;
            break;
        }
    }
    return pbdl_Found;
}




/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DIBusDevice_ExposeEx |
 *
 *          Attache a HID device to all available ports.
 *
 *  @parm   IN HANDLE | hf |
 *          Handle the the Gameport/SerialPort File object
 *
 *  @parm   IN OUT PBUS_REGDATA    | pRegData |
 *          Gameport/Serialport specific data. The Handle to the opened device
 *          is returned in this structure
 *
 *
 *  @returns
 *          BOOL. True indicates success.
 *
 *****************************************************************************/
HRESULT EXTERNAL
    DIBusDevice_ExposeEx
    (
    IN PBUSDEVICELIST  pbdl,
    IN PBUS_REGDATA    pRegData
    )
{
    HRESULT hres = DIERR_DEVICENOTREG;

    EnterProcI(DIBusDevice_ExposeEx, (_ "xx", pbdl, pRegData));

    /*
     * The return code a little strange for this function
     * If the Expose succeeds for any gameport then
     * we will return that error code.
     * If the expose fails for all gameports,
     * then we will return the amalgam of
     * all the error codes.
     */
    if( pbdl->cgbi != 0x0 )
    {
		HRESULT hres1 = DIERR_DEVICENOTREG;
		int ibdi;
        hres = S_OK;
		
		for( ibdi = 0x0; ibdi < pbdl->cgbi; ibdi++)
		{
			HRESULT hres0;
			PBUSDEVICEINFO   pbdi;
			
			hres0 = DIERR_DEVICENOTREG;
			pbdi = &(pbdl->rgbdi[ibdi]);
			
			if( pbdi->fAttached == FALSE )
			{
				pbdi->fDeleteIfNotConnected = TRUE;
				hres0 = DIBusDevice_Expose(pbdi, pRegData);
				if( FAILED(hres0) )
				{
					hres |= hres0;
				} else
				{
					hres1 = hres0;
				}
			} else {
				hres = DIERR_DEVICEFULL;
			}
		}
		
		if(SUCCEEDED(hres1))
		{
			hres = hres1;
		}
	}

    ExitOleProc();
    return hres;
}



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DIBusDevice_GetTypeInfo |
 *
 *          Gets typeinfo for bus device.
 *
 *  @parm   IN PCGUID | pcguid |
 *          GUID that identifies the gameport
 *
 *  @parm   OUT LPDIJOTYPEINFO    | pjti |
 *          Typeinfo stuct filled in by this function
 *
 *  @parm   IN DWORD | fl |
 *          Flags that specify what fields to fill out.
 *
 *  @returns
 *          HRESULT.
 *
 *****************************************************************************/
HRESULT EXTERNAL
    DIBusDevice_GetTypeInfo
    (
    PCGUID pcguid,
    LPDIJOYTYPEINFO pjti,
    DWORD           fl
    )
{
    HRESULT hres;
    PBUSDEVICEINFO pbdi;
    EnterProcI(DIBusDevice_GetTypeInfo, (_ "Gp", pcguid, pjti));

    hres = E_FAIL;
    DllEnterCrit();

    if( NULL != ( pbdi = pbdiFromGUID(pcguid) ) )
    {
        DIPROPSTRING dips;

        if(fl & DITC_REGHWSETTINGS)
        {
            pjti->hws.dwFlags = pbdi->pBusDevice->dwJOY_HWS_ISPORTBUS | JOY_HWS_AUTOLOAD ;
            pjti->hws.dwNumButtons = MAKELONG( pbdi->idPort, 0x0 );
        }

        if( fl & DITC_CLSIDCONFIG )
        {
            pjti->clsidConfig = pbdi->guid;
        }

        if(fl & DITC_DISPLAYNAME)
        {
            if(FAILED( hres = DIPort_GetRegistryProperty(pbdi->ptszId, SPDRP_FRIENDLYNAME, &dips.diph) ) )
            {
                if( FAILED( hres = DIPort_GetRegistryProperty(pbdi->ptszId, SPDRP_DEVICEDESC, &dips.diph) ) )
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%S: No device name | friendly name for gameport %d "),
                                    s_szProc, pbdi->idPort);
                }
            }
            if( SUCCEEDED(hres) )
            {
                /*
                 *  Prefix warns (Wi:228282) that dips.wsz could be 
                 *  uninitialized however one of the above GetRegistryProperty 
                 *  functions has succeeded leaving a worst case of a NULL 
                 *  terminator having been copied there.
                 */
                lstrcpyW(pjti->wszDisplayName, dips.wsz);
            }
        }

    #ifndef WINNT
        if(fl & DITC_CALLOUT)
        {
            ZeroX(pjti->wszCallout);
        }
    #endif
    
        if(fl & DITC_HARDWAREID)
        {
            ZeroX(pjti->wszHardwareId);
        }

        if( fl & DITC_FLAGS1 )
        {
            pjti->dwFlags1 = 0x0;
        }

        hres = S_OK;
    } else
    {
        hres = E_FAIL;
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%S: GUID not a port GUID "),
                        s_szProc);
    }

    DllLeaveCrit();
    ExitProcX(hres);

    return hres;

}


HRESULT EXTERNAL DIPort_SnapTypes(LPWSTR *ppwszz)
{
    LONG cDevices;
    HRESULT hres = E_FAIL;

    cDevices = DIBus_BuildList(FALSE);

    if( cDevices)
    {
        DllEnterCrit();
        hres = AllocCbPpv(cbCwch( cDevices  * MAX_JOYSTRING) , ppwszz);
        if( SUCCEEDED(hres) )
        {
            int iBusType, igdi;
            PBUSDEVICE     pBusDevice;
            LPWSTR pwsz = *ppwszz;

            for(iBusType = 0x0, pBusDevice = g_pBusDevice;
               iBusType < 1;
               iBusType++, pBusDevice++ )
            {
                PBUSDEVICEINFO pbdi;
                for(igdi = 0, pbdi = pBusDevice->pbdl->rgbdi;
                   igdi < pBusDevice->pbdl->cgbi;
                   igdi++, pbdi++)
                {
                    TCHAR tszGuid[MAX_JOYSTRING];
                    NameFromGUID(tszGuid, &pbdi->guid);

                    #ifdef UNICODE
                        lstrcpyW(pwsz, &tszGuid[ctchNamePrefix]);
                        pwsz += lstrlenW(pwsz) + 1;
                    #else
                        TToU(pwsz, cA(pwsz), &tszGuid[ctchNamePrefix]);
                        pwsz += lstrlenW(pwsz) + 1;
                    #endif
                }
            }
            *pwsz = L'\0';              /* Make it ZZ */
        }
        DllLeaveCrit();
    }
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\diriff.h ===
#ifndef __RIFF_H__
#define __RIFF_H__
/****************************************************************************

	MODULE:     	RIFF.H
	Tab settings: 	Every 4 spaces

	Copyright 1996, Microsoft Corporation, 	All Rights Reserved.

	PURPOSE:    	Classes for reading and writing RIFF files
    
	CLASSES:
		CRIFFFile	Encapsulates common RIFF file functionality

	Author(s):	Name:
	----------	----------------
		DMS		Daniel M. Sangster

	Revision History:
	-----------------
	Version Date            Author  Comments
	1.0  	25-Jul-96       DMS     Created

	COMMENTS:
****************************************************************************/


// the four-character codes (FOURCC) needed for .FRC RIFF format

#define FCC_FORCE_EFFECT_RIFF		mmioFOURCC('F','O','R','C')

#define FCC_INFO_LIST				mmioFOURCC('I','N','F','O')
#define FCC_INFO_NAME_CHUNK			mmioFOURCC('I','N','A','M')
#define FCC_INFO_COMMENT_CHUNK		mmioFOURCC('I','C','M','T')
#define FCC_INFO_SOFTWARE_CHUNK		mmioFOURCC('I','S','F','T')
#define FCC_INFO_COPYRIGHT_CHUNK	mmioFOURCC('I','C','O','P')

#define FCC_TARGET_DEVICE_CHUNK		mmioFOURCC('t','r','g','t')

#define FCC_TRACK_LIST				mmioFOURCC('t','r','a','k')

#define FCC_EFFECT_LIST				mmioFOURCC('e','f','c','t')
#define FCC_ID_CHUNK				mmioFOURCC('i','d',' ',' ')
#define FCC_DATA_CHUNK				mmioFOURCC('d','a','t','a')
#define FCC_IMPLICIT_CHUNK			mmioFOURCC('i','m','p','l')
#define FCC_SPLINE_CHUNK			mmioFOURCC('s','p','l','n')

#define MAX_SIZE_SNAME              (64)

HRESULT RIFF_Open
    (
    LPCSTR          lpszFilename,
    UINT            nOpenFlags,
    PHANDLE         lphmmio,
    LPMMCKINFO      lpmmck,
    PDWORD          pdwEffectSize
    );

HRESULT
    RIFF_ReadEffect
    (
    HMMIO           hmmio, 
    LPDIFILEEFFECT  lpDiFileEf 
    );


HRESULT RIFF_WriteEffect
    (
     HMMIO          hmmio,
     LPDIFILEEFFECT lpDiFileEf
     );


HRESULT RIFF_Close
    (
    HMMIO           hmmio, 
    UINT            nFlags
    );

#endif //__RIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dioledup.c ===
/*****************************************************************************
 *
 *  DIOleDup.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Functions that sort-of duplicate what OLE does.
 *
 *  Contents:
 *
 *      DICoCreateInstance
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflOleDup


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | _CreateInstance |
 *
 *          Worker function for <f DICoCreateInstance>.
 *
 *  @parm   REFCLSID | rclsid |
 *
 *          The <t CLSID> to create.
 *
 *  @parm   LPCTSTR | ptszDll |
 *
 *          The name of the DLL to load.
 *
 *  @parm   LPUNKNOWN | punkOuter |
 *
 *          Controlling unknown for aggregation.
 *
 *  @parm   RIID | riid |
 *
 *          Interface to obtain.
 *
 *  @parm   PPV | ppvOut |
 *
 *          Receives a pointer to the created object if successful.
 *
 *  @parm   HINSTANCE * | phinst |
 *
 *          Receives the instance handle of the in-proc DLL that was
 *          loaded.  <f FreeLibrary> this DLL when you are finished
 *          with the object.
 *
 *          Note that since we don't implement a binder, this means
 *          that you cannot give the returned pointer away to anybody
 *          you don't control; otherwise, you won't know when to
 *          free the DLL.
 *
 *  @returns
 *
 *          Standard OLE status code.
 *
 *****************************************************************************/

HRESULT INTERNAL
_CreateInstance(REFCLSID rclsid, LPCTSTR ptszDll, LPUNKNOWN punkOuter,
                RIID riid, PPV ppvOut, HINSTANCE *phinst)
{
    HRESULT hres;
    HINSTANCE hinst;

    hinst = LoadLibrary(ptszDll);
    if (hinst) {
        LPFNGETCLASSOBJECT DllGetClassObject;

        DllGetClassObject = (LPFNGETCLASSOBJECT)
                            GetProcAddress(hinst, "DllGetClassObject");

        if (DllGetClassObject) {
            IClassFactory *pcf;

            hres = DllGetClassObject(rclsid, &IID_IClassFactory, &pcf);
            if (SUCCEEDED(hres)) {
                hres = pcf->lpVtbl->CreateInstance(pcf, punkOuter,
                                                   riid, ppvOut);
                pcf->lpVtbl->Release(pcf);

                /*
                 *  Some people forget to adhere to
                 *  the OLE spec, which requires that *ppvOut be
                 *  set to zero on failure.
                 */
                if (FAILED(hres)) {
                    if (*ppvOut) {
                        RPF("ERROR! CoCreateInstance: %s forgot to zero "
                            "out *ppvOut on failure path", ptszDll);
                    }
                    *ppvOut = 0;
                }

            }
        } else {
            /*
             *  DLL does not export GetClassObject.
             */
            hres = REGDB_E_CLASSNOTREG;
        }

        if (SUCCEEDED(hres)) {
            *phinst = hinst;
        } else {
            FreeLibrary(hinst);
        }
    } else {
        /*
         *  DLL does not exist.
         */
        hres = REGDB_E_CLASSNOTREG;
    }

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DICoCreateInstance |
 *
 *          Private version of CoCreateInstance that doesn't use OLE.
 *
 *  @parm   LPTSTR | ptszClsid |
 *
 *          The string version of the <t CLSID> to create.
 *
 *  @parm   LPUNKNOWN | punkOuter |
 *
 *          Controlling unknown for aggregation.
 *
 *  @parm   RIID | riid |
 *
 *          Interface to obtain.
 *
 *  @parm   PPV | ppvOut |
 *
 *          Receives a pointer to the created object if successful.
 *
 *  @parm   HINSTANCE * | phinst |
 *
 *          Receives the instance handle of the in-proc DLL that was
 *          loaded.  <f FreeLibrary> this DLL when you are finished
 *          with the object.
 *
 *          Note that since we don't implement a binder, this means
 *          that you cannot give the returned pointer away to anybody
 *          you don't control; otherwise, you won't know when to
 *          free the DLL.
 *
 *  @returns
 *
 *          Standard OLE status code.
 *
 *****************************************************************************/

STDMETHODIMP
DICoCreateInstance(LPTSTR ptszClsid, LPUNKNOWN punkOuter,
                   RIID riid, PPV ppvOut, HINSTANCE *phinst)
{
    HRESULT hres;
    CLSID clsid;
    EnterProcI(DICoCreateInstance, (_ "spG", ptszClsid, punkOuter, riid));

    *ppvOut = 0;
    *phinst = 0;

    if (ParseGUID(&clsid, ptszClsid)) {
        HKEY hk;
        LONG lRc;
        TCHAR tszKey[ctchGuid + 40];    /* 40 is more than enough */

        /*
         *  Look up the CLSID in HKEY_CLASSES_ROOT.
         */
        wsprintf(tszKey, TEXT("CLSID\\%s\\InProcServer32"), ptszClsid);

        lRc = RegOpenKeyEx(HKEY_CLASSES_ROOT, tszKey, 0,
                           KEY_QUERY_VALUE, &hk);
        if (lRc == ERROR_SUCCESS) {
            TCHAR tszDll[MAX_PATH];
            DWORD cb;

            cb = cbX(tszDll);
            lRc = RegQueryValue(hk, 0, tszDll, &cb);

            if (lRc == ERROR_SUCCESS) {
                TCHAR tszModel[20];     /* more than enough */

                lRc = RegQueryString(hk, TEXT("ThreadingModel"),
                                     tszModel, cA(tszModel));
                if (lRc == ERROR_SUCCESS &&
                    ((lstrcmpi(tszModel, TEXT("Both"))==0x0) ||
                     (lstrcmpi(tszModel, TEXT("Free"))==0x0))) {

                    hres = _CreateInstance(&clsid, tszDll, punkOuter,
                                           riid, ppvOut, phinst);

                } else {
                    /*
                     *  No threading model or bad threading model.
                     */
                    hres = REGDB_E_CLASSNOTREG;
                }
            } else {
                /*
                 *  No InprocServer32.
                 */
                hres = REGDB_E_CLASSNOTREG;
            }

            RegCloseKey(hk);

        } else {
            /*
             *  CLSID not registered.
             */
            hres = REGDB_E_CLASSNOTREG;
        }
    } else {
        /*
         *  Invalid CLSID string.
         */
        hres = REGDB_E_CLASSNOTREG;
    }

    ExitOleProcPpv(ppvOut);
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dithunk.h ===
/*****************************************************************************
 *
 *  DiThunk.h
 *
 *  Copyright (c) 1997-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Template thunks for Windows 95 device manager.
 *
 *****************************************************************************/
/*****************************************************************************
 *
 *  dithunk.c
 *
 *****************************************************************************/

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct KERNELPROCADDR |
 *
 *          Kernel procedure addresses.
 *
 *          Careful!  This must match dithunk.c::c_rgpszKernel32.
 *
 ***************************************************************************/

typedef struct KERNELPROCADDR { /* kpa */

    /* By ordinal */
    HINSTANCE   (NTAPI *LoadLibrary16)(LPCSTR);
    BOOL        (NTAPI *FreeLibrary16)(HINSTANCE);
    FARPROC     (NTAPI *GetProcAddress16)(HINSTANCE, LPCSTR);

    /* By name */
    LPVOID      (NTAPI   *MapLS)(LPVOID);
    void        (NTAPI   *UnMapLS)(LPVOID);
    LPVOID      (NTAPI   *MapSL)(LPVOID);
    LPVOID      (NTAPI   *MapSLFix)(LPVOID);
    void        (NTAPI   *UnMapSLFixArray)(int, LPVOID);

    /* Warning: GetKernelProcAddresses assumes that QT_Thunk is last */
    void        (__cdecl *QT_Thunk)(void);

} KERNELPROCADDR;

extern KERNELPROCADDR g_kpa;

int __cdecl TemplateThunk(FARPROC fp, PCSTR pszSig, ...);

#define MAKELP(sel, ofs)            (PV)MAKELPARAM(ofs, sel)

BOOL EXTERNAL Thunk_GetKernelProcAddresses(void);

HINSTANCE EXTERNAL
Thunk_GetProcAddresses(FARPROC *rgfp, LPCSTR *rgpsz,
                       UINT cfp, LPCSTR pszLibrary);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\diregutl.c ===
/*****************************************************************************
 *
 *  DIRegUtl.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Registry utility functions.
 *
 *  Contents:
 *
 *
 *****************************************************************************/
#include "dinputpr.h"

/*****************************************************************************
 *
 *  The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflRegUtils


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LONG | RegQueryString |
 *
 *          Wrapper for <f RegQueryValueEx> that reads a
 *          string value from the registry.  An annoying quirk
 *          is that on Windows NT, the returned string might
 *          not end in a null terminator, so we might need to add
 *          one manually.
 *
 *  @parm   IN HKEY | hk |
 *
 *          Parent registry key.
 *
 *  @parm   LPCTSTR | ptszValue |
 *
 *          Value name.
 *
 *  @parm   LPTSTR | ptsz |
 *
 *          Output buffer.
 *
 *  @parm   DWORD | ctchBuf |
 *
 *          Size of output buffer.
 *
 *  @returns
 *
 *          Registry error code.
 *
 *****************************************************************************/

LONG EXTERNAL
    RegQueryString(HKEY hk, LPCTSTR ptszValue, LPTSTR ptszBuf, DWORD ctchBuf)
{
    LONG lRc;
    DWORD reg;

    #ifdef UNICODE
    DWORD cb;

    /*
     *  NT quirk: Non-null terminated strings can exist.
     */
    cb = cbCtch(ctchBuf);
    lRc = RegQueryValueEx(hk, ptszValue, 0, &reg, (PV)ptszBuf, &cb);
    if(lRc == ERROR_SUCCESS)
    {
        if(reg == REG_SZ)
        {
            /*
             *  Check the last character.  If it is not NULL, then
             *  append a NULL if there is room.
             */
            DWORD ctch = ctchCb(cb);
            if(ctch == 0)
            {
                ptszBuf[ctch] = TEXT('\0');
            } else if(ptszBuf[ctch-1] != TEXT('\0'))
            {
                if(ctch < ctchBuf)
                {
                    ptszBuf[ctch] = TEXT('\0');
                } else
                {
                    lRc = ERROR_MORE_DATA;
                }
            }
        } else
        {
            lRc = ERROR_INVALID_DATA;
        }
    }


    #else

    /*
     *  This code is executed only on Win95, so we don't have to worry
     *  about the NT quirk.
     */

    lRc = RegQueryValueEx(hk, ptszValue, 0, &reg, (PV)ptszBuf, &ctchBuf);

    if(lRc == ERROR_SUCCESS && reg != REG_SZ)
    {
        lRc = ERROR_INVALID_DATA;
    }


    #endif

    return lRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LONG | RegQueryStringValueW |
 *
 *          Wrapper for <f RegQueryValueEx> that handles ANSI/UNICODE
 *          issues, as well as treating a nonexistent key as if it
 *          were a null string.
 *
 *          Note that the value name is still a <t LPCTSTR>.
 *
 *          It is assumed that the thing being read is a string.
 *          Don't use this function to read binary data.
 *
 *          You cannot use this function to query the necessary
 *          buffer size (again, because I'm lazy).  It's not as
 *          simple as doubling the ansi size, because DBCS may
 *          result in a non-linear translation function.
 *
 *  @parm   IN HKEY | hk |
 *
 *          Parent registry key.
 *
 *  @parm   LPCTSTR | ptszValue |
 *
 *          Value name.
 *
 *  @parm   LPWSTR | pwsz |
 *
 *          UNICODE output buffer.
 *
 *  @parm   LPDWORD | pcbBuf |
 *
 *          Size of UNICODE output buffer.  May not exceed
 *          cbCwch(MAX_PATH).
 *
 *  @returns
 *
 *          Registry error code.  On error, the output buffer is
 *          set to a null string.  On an ERROR_MORE_DATA, the
 *          output buffer is null-terimated.
 *
 *****************************************************************************/

LONG EXTERNAL
    RegQueryStringValueW(HKEY hk, LPCTSTR ptszValue,
                         LPWSTR pwszBuf, LPDWORD pcbBuf)
{
    LONG lRc;

    #ifdef UNICODE

    AssertF(*pcbBuf > 0);
    AssertF(*pcbBuf <= cbCwch(MAX_PATH));

    /*
     *  NT quirk: Non-null terminated strings can exist.
     */
    lRc = RegQueryString(hk, ptszValue, pwszBuf, ctchCb(*pcbBuf));

    #else

    /*
     *  NT quirk: Non-null terminated strings can exist.  Fortunately,
     *  this code is executed only on Win95, which terminates properly.
     */
    DWORD cb;
    TCHAR tszBuf[MAX_PATH];

    AssertF(*pcbBuf > 0);
    AssertF(*pcbBuf <= cbCwch(MAX_PATH));

    /*
     *  ISSUE-2001/03/29-timgill Incorrect size returned in single case
     *  Note that we do not get the size perfect in the DBCS case.
     *
     *  Fortunately, the slop is on the high end, where hopefully
     *  nobody lives or will notice.
     *
     *  Is it worth fixing?
     */

    cb = cwchCb(*pcbBuf);
    lRc = RegQueryValueEx(hk, ptszValue, 0, 0, (PV)tszBuf, &cb);

    if(lRc == ERROR_SUCCESS)
    {
        DWORD cwch;

        /*
         *  Convert the string up to UNICODE.
         */
        cwch = AToU(pwszBuf, cwchCb(*pcbBuf), tszBuf);
        *pcbBuf = cbCwch(cwch);

        /*
         *  If the buffer was not big enough, the return value
         *  will be zero.
         */
        if(cwch == 0 && tszBuf[0])
        {
            lRc = ERROR_MORE_DATA;
        } else
        {
            lRc = ERROR_SUCCESS;
        }

    }
    #endif

    /*
     *  If the buffer was too small, then null-terminate it just
     *  to make sure.
     */
    if(lRc == ERROR_MORE_DATA)
    {
        if(*pcbBuf)
        {
            pwszBuf[cwchCb(*pcbBuf)-1] = TEXT('\0');
        }
    } else

        /*
         *  If it was some other error, then wipe out the buffer
         *  so the caller won't get confused.
         */
        if(lRc != ERROR_SUCCESS)
    {
        pwszBuf[0] = TEXT('\0');
        /*
         *  If the error was that the key doesn't exist, then
         *  treat it as if it existed with a null string.
         */
        if(lRc == ERROR_FILE_NOT_FOUND)
        {
            lRc = ERROR_SUCCESS;
        }
    }

    return lRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LONG | RegSetStringValueW |
 *
 *          Wrapper for <f RegSetValueEx> that handles ANSI/UNICODE
 *          issues, as well as converting null strings into nonexistent
 *          values.
 *
 *          Note that the value name is still a <t LPCTSTR>.
 *
 *          It is assumed that the thing being written is a string.
 *          Don't use this function to write binary data.
 *
 *  @parm   IN HKEY | hk |
 *
 *          Parent registry key.
 *
 *  @parm   LPCTSTR | ptszValue |
 *
 *          Value name.
 *
 *  @parm   LPCWSTR | pwsz |
 *
 *          UNICODE value to write.  A null pointer is valid, indicating
 *          that the key should be deleted.
 *
 *  @returns
 *
 *          Registry error code.
 *
 *****************************************************************************/

LONG EXTERNAL
    RegSetStringValueW(HKEY hk, LPCTSTR ptszValue, LPCWSTR pwszData)
{
    DWORD cwch;
    LONG lRc;

    if(pwszData)
    {
        cwch = lstrlenW(pwszData);
    } else
    {
        cwch = 0;
    }

    if(cwch)
    {
#ifdef UNICODE
        lRc = RegSetValueExW(hk, ptszValue, 0, REG_SZ,
                             (PV)pwszData, cbCwch(cwch+1));
#else

        DWORD ctch;
        TCHAR tszBuf[MAX_PATH];

        /*
         *  Convert the string down to ANSI.
         */
        ctch = UToA(tszBuf, cA(tszBuf), pwszData);

        if(ctch)
        {
            lRc = RegSetValueEx(hk, ptszValue, 0, REG_SZ,
                                (PV)tszBuf, cbCtch(ctch+1));
        } else
        {
            lRc = ERROR_CANTWRITE;
        }

#endif

    } else
    {
        lRc = RegDeleteValue(hk, ptszValue);

        /*
         *  It is not an error if the key does not already exist.
         */
        if(lRc == ERROR_FILE_NOT_FOUND)
        {
            lRc = ERROR_SUCCESS;
        }
    }

    return lRc;
}

#ifndef UNICODE
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LONG | RegDeleteKeyW |
 *
 *          Wrapper for <f RegDeleteKeyA> on non-UNICODE platforms.
 *
 *  @parm   IN HKEY | hk |
 *
 *          Parent registry key.
 *
 *  @parm   LPCWSTR | pwsz |
 *
 *          Subkey name.
 *
 *  @returns
 *
 *          Registry error code.
 *
 *****************************************************************************/

LONG EXTERNAL
    RegDeleteKeyW(HKEY hk, LPCWSTR pwsz)
{
    LONG lRc;
    CHAR szBuf[MAX_PATH];

    /*
     *  Convert the string down to ANSI.
     */
    UToA(szBuf, cA(szBuf), pwsz);

    lRc = RegDeleteKeyA(hk, szBuf);

    return lRc;
}
#endif


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresMumbleKeyEx |
 *
 *          Either open or create the key, depending on the degree
 *          of access requested.
 *
 *  @parm   HKEY | hk |
 *
 *          Base key.
 *
 *  @parm   LPCTSTR | ptszKey |
 *
 *          Name of subkey, possibly NULL.
 *
 *  @parm   REGSAM | sam |
 *
 *          Security access mask.
 *
 *  @parm   DWORD   | dwOptions |
 *          Options for RegCreateEx
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives output key.
 *
 *  @returns
 *
 *          Return value from <f RegOpenKeyEx> or <f RegCreateKeyEx>,
 *          converted to an <t HRESULT>.
 *
 *****************************************************************************/

STDMETHODIMP
    hresMumbleKeyEx(HKEY hk, LPCTSTR ptszKey, REGSAM sam, DWORD dwOptions, PHKEY phk)
{
    HRESULT hres;
    LONG lRc;

    /*
     *  If caller is requesting write access, then try opening it for writing;
	 *  if that fails with access denied error, then try opening it for reading;
	 *  if key doesn't exist, create the key.
     *  Else just open it.
     */
    if(IsWriteSam(sam))
    {
		// on WinXP, we strip out WRITE_DAC and WRITE_OWNER bits
		if (DIGetOSVersion() == WINWH_OS)
		{
			sam &= ~DI_DAC_OWNER;
		}
        lRc = RegOpenKeyEx(hk, ptszKey, 0, sam, phk);

        if( lRc == ERROR_SUCCESS )
        {
            // Don't need to create it already exists
        } else
        {
			// Change for server per Whistler bug 575181
			// If error is access denied, try opening the key for reading
			if (lRc == ERROR_ACCESS_DENIED)
			{
				lRc = RegOpenKeyEx(hk, ptszKey, 0, KEY_READ, phk);
			}
			else
			{
				// Try to create it
				lRc = RegCreateKeyEx
						(
						hk,									// handle of an open key
						ptszKey,							// address of subkey name
						0,									// reserved
						NULL,								// address of class string
						dwOptions,							// special options flag
						sam,                                // desired security access
						NULL,								// inherit the parent's secuirty descriptor
						phk,								// address of buffer for opened handle
						0						            // address of disposition value buffer);
						);
			}
		}

    } else
    {
        lRc = RegOpenKeyEx(hk, ptszKey, 0, sam, phk);
    }

    if(lRc == ERROR_SUCCESS)
    {
        hres = S_OK;
    } else
    {
        if(lRc == ERROR_KEY_DELETED || lRc == ERROR_BADKEY)
        {
            lRc = ERROR_FILE_NOT_FOUND;
        }
        hres = hresLe(lRc);
    }

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LONG | RegQueryDIDword |
 *
 *          Read a dword value from a sub key of the DirectInput part of the 
 *          registry.
 *
 *  @parm   LPCTSTR | ptszSubKey |
 *
 *          Optional path from root of DirectInput registry.
 *
 *  @parm   LPCTSTR | ptszValue |
 *
 *          Value name.
 *
 *  @parm   DWORD | dwDefault |
 *
 *          Default value to use if there was an error.
 *
 *  @returns
 *
 *          The value read, or the default.
 *
 *****************************************************************************/

DWORD EXTERNAL
    RegQueryDIDword(LPCTSTR ptszPath, LPCTSTR ptszValue, DWORD dwDefault)
{
    HKEY hk;
    DWORD dw;

    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_DINPUT, 0,
                    KEY_QUERY_VALUE, &hk) == 0)
    {
        DWORD cb = cbX(dw);

        if( ptszPath )
        {
            HKEY hkSub;

            if(RegOpenKeyEx(hk, ptszPath, 0,
                            KEY_QUERY_VALUE, &hkSub) == 0)
            {
                RegCloseKey( hk );
                hk = hkSub;
            }
        }

        if(RegQueryValueEx(hk, ptszValue, 0, 0, (LPBYTE)&dw, &cb) == 0 &&
           cb == cbX(dw))
        {
        } else
        {
            dw = dwDefault;
        }
        RegCloseKey(hk);
    } else
    {
        dw = dwDefault;
    }
    return dw;
}


//
// A registry key that is opened by an application can be deleted
// without error by another application in both Windows 95 and
// Windows NT. This is by design.
DWORD EXTERNAL
    DIWinnt_RegDeleteKey
    (
    HKEY hStartKey ,
    LPCTSTR pKeyName
    )
{

    #define MAX_KEY_LENGTH  ( 256 )
    DWORD   dwRtn, dwSubKeyLength;
    TCHAR   szSubKey[MAX_KEY_LENGTH]; // (256) this should be dynamic.
    HKEY    hKey;

    // do not allow NULL or empty key name
    if( pKeyName &&  lstrlen(pKeyName))
    {
        if( (dwRtn=RegOpenKeyEx(hStartKey,pKeyName,
                                0, KEY_ENUMERATE_SUB_KEYS | DELETE, &hKey )) == ERROR_SUCCESS)
        {
            while(dwRtn == ERROR_SUCCESS )
            {
                dwSubKeyLength = MAX_KEY_LENGTH;
                dwRtn=RegEnumKeyEx(
                                  hKey,
                                  0,       // always index zero
                                  szSubKey,
                                  &dwSubKeyLength,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL
                                  );

                if(dwRtn == ERROR_SUCCESS)
                {
                    dwRtn = DIWinnt_RegDeleteKey(hKey, szSubKey);
                } else if(dwRtn == ERROR_NO_MORE_ITEMS)
                {
                    dwRtn = RegDeleteKey(hStartKey, pKeyName);
                    break;
                }
            }
            RegCloseKey(hKey);
            // Do not save return code because error
            // has already occurred
        }
    } else
        dwRtn = ERROR_BADKEY;

    return dwRtn;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresRegCopyValues |
 *
 *          Copy all the values from one key to another.
 *
 *  @parm   HKEY | hkSrc |
 *
 *          Key with values to be copied 
 *              (must be opened with at least KEY_READ access).
 *
 *  @parm   HKEY | hkDest |
 *
 *          Key to receive copies (must be opened with at least KEY_WRITE).
 *
 *  @returns
 *
 *          S_OK if all values were successfully copied
 *          S_FALSE if there were no values to copy.
 *          Or a memory allocation error code or the failing registry function 
 *          return code converted to a <t HRESULT>.
 *
 *****************************************************************************/
STDMETHODIMP
    hresRegCopyValues( HKEY hkSrc, HKEY hkDest )
{
    HRESULT hres;
    LONG    lRc;
    DWORD   cItems;
    DWORD   MaxNameLen;
    DWORD   MaxDataLen;
    DWORD   NameLen;
    DWORD   DataLen;
    PTCHAR  tszName;
    PBYTE   pData;
    DWORD   Type;

    EnterProcI(hresRegCopyValues, (_ "xx", hkSrc, hkDest));

    lRc = RegQueryInfoKey( hkSrc,           // Key, 
                           NULL, NULL, NULL,// Class, cbClass, Reserved,
                           NULL, NULL, NULL,// NumSubKeys, MaxSubKeyLen, MaxClassLen,
                           &cItems,         // NumValues, 
                           &MaxNameLen,     // MaxValueNameLen,
                           &MaxDataLen,     // MaxValueLen,
                           NULL, NULL );    // Security descriptor, last write

    if( lRc == ERROR_SUCCESS )
    {
        if( cItems )
        {
            MaxNameLen++; // Take account of NULL terminator
            hres = AllocCbPpv( MaxDataLen + MaxNameLen * sizeof(tszName[0]), &pData );
            if( FAILED(hres) )
            {
                SquirtSqflPtszV(sqfl | sqflError,
                    TEXT("Out of memory copying registry values") );
            }
            else
            {
                tszName = (PTCHAR)(pData + MaxDataLen);

                do
                {
                    DataLen = MaxDataLen;
                    NameLen = MaxNameLen;
                    lRc = RegEnumValue( hkSrc, --cItems, tszName, &NameLen,
                                         NULL, &Type, pData, &DataLen );
                    if( lRc != ERROR_SUCCESS )
                    {
                        SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("RegEnumValues failed during copy values, code 0x%08x"), lRc );
                        break;
                    }
                    else
                    {
                        lRc = RegSetValueEx( hkDest, tszName, 0, Type, pData, DataLen );
                        if( lRc != ERROR_SUCCESS )
                        {
                            SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("Failed to copy value %s code %x"), tszName, lRc );
                            break;
                        }
                    }
                } while( cItems );

                FreePpv( &pData );

                if( lRc != ERROR_SUCCESS )
                {
                    hres = hresReg( lRc );
                }
                else
                {
                    hres = S_OK;
                }
            }
        }
        else
        {
            SquirtSqflPtszV(sqfl, TEXT("No values to copy") );
            hres = S_FALSE;
        }
    }
    else
    {
        SquirtSqflPtszV(sqfl | sqflBenign,
            TEXT("RegQueryInfoKey failed during value copy, code 0x%08x"), lRc );
        hres = hresReg(lRc);
    }

    ExitOleProc();

    return( hres );
} /* hresRegCopyValues */


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresRegCopyKey |
 *
 *          Make an empty copy of a key.
 *
 *  @parm   HKEY | hkSrcRoot |
 *
 *          The Key under the key name to be copied exists.
 *              (must be opened with at least KEY_READ).
 *
 *  @parm   PTCHAR | szSrcName |
 *          Name of key to copy
 *
 *  @parm   PTCHAR | szClass |
 *          Class of key to copy
 *
 *  @parm   HKEY | hkDestRoot |
 *
 *          The Key under which the copy will be created
 *              (must be opened with at least KEY_WRITE).
 *
 *  @parm   PTCHAR | szSrcName |
 *          Name of new key
 *
 *  @parm   PHKEY | phkSub |
 *
 *          The optional pointer to an HKEY to recieve the opened key if it is 
 *          successfully created.  If this is NULL, the key is closed.
 *
 *  @returns
 *
 *          S_OK if the new key was created.
 *          S_FALSE if the new key already existed
 *          Or the return value of a failing registry function or 
 *          GetSecurityInfo converted to a <t HRESULT>.
 *
 *****************************************************************************/
STDMETHODIMP
    hresRegCopyKey( HKEY hkSrcRoot, PTCHAR szSrcName, PTCHAR szClass, 
        HKEY hkDestRoot, PTCHAR szDestName, HKEY *phkSub )
{
    LONG    lRc;
    HKEY    hkSub;
    DWORD   dwDisposition;
    HRESULT hres;


#ifdef WINNT
    HKEY                    hkSrc;
#endif

    EnterProcI(hresRegCopyKey, (_ "xssxs", hkSrcRoot, szSrcName, szClass, hkDestRoot, szDestName));
#ifdef WINNT

    lRc = RegOpenKeyEx( hkSrcRoot, szSrcName, 0, KEY_READ, &hkSrc );

    if( lRc == ERROR_SUCCESS )
    {
        SECURITY_ATTRIBUTES     sa;
        SECURITY_INFORMATION    si;

        sa.nLength = sizeof( sa );
        sa.bInheritHandle = TRUE;
        si = OWNER_SECURITY_INFORMATION;

        lRc = GetSecurityInfo( hkSrc, SE_REGISTRY_KEY, 
                               si,           
                               NULL, NULL, // Don't care about SID or SID group
                               NULL, NULL, // Don't care about DACL or SACL
                               &sa.lpSecurityDescriptor );

        RegCloseKey( hkSrc );

        if( lRc == ERROR_SUCCESS )
        {
            lRc = RegCreateKeyEx(  hkDestRoot,
                                   szDestName,
                                   0,
                                   szClass,
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_WRITE,
                                   &sa,
                                   &hkSub,
                                   &dwDisposition );

            LocalFree( sa.lpSecurityDescriptor );
            if( lRc != ERROR_SUCCESS ) 
            {
                SquirtSqflPtszV(sqfl | sqflBenign,
                    TEXT("Failed to RegCreateKeyEx for key name %s, code 0x%08x"), szDestName, lRc );
            }
        }
        else
        {
            SquirtSqflPtszV(sqfl | sqflBenign,
                TEXT("Failed to GetSecurityInfo for key name %s, code 0x%08x"), szSrcName, lRc );
        }
    }
    else
    {
        SquirtSqflPtszV(sqfl | sqflBenign,
            TEXT("Failed to RegOpenKeyEx for key name %s, code 0x%08x"), szSrcName, lRc );
    }

#else
    /* On Win9x the source is not used as the name and class is all we need */
    hkSrcRoot;
    szSrcName;

    lRc = RegCreateKeyEx(  hkDestRoot,
                           szDestName,
                           0,
                           szClass,
                           REG_OPTION_NON_VOLATILE,
                           KEY_WRITE,
                           NULL,
                           &hkSub,
                           &dwDisposition );
    if( lRc != ERROR_SUCCESS ) 
    {
        SquirtSqflPtszV(sqfl | sqflBenign,
            TEXT("Failed to RegCreateKeyEx for key name %s, code 0x%08x"), szDestName, lRc );
    }
#endif /* WINNT */

    if( lRc == ERROR_SUCCESS ) 
    {
        if( phkSub )
        {
            *phkSub = hkSub;
        }
        else
        {
            RegCloseKey( hkSub );
        }
        
        hres =( dwDisposition == REG_CREATED_NEW_KEY ) ? S_OK : S_FALSE;
    }
    else
    {
        hres = hresReg( lRc );
    }

    ExitOleProc();

    return( hres );

} /* hresRegCopyKey */

                    


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresRegCopyKeys |
 *
 *          Copy all the keys under the source key to the root.
 *
 *  @parm   HKEY | hkSrc |
 *
 *          Key be copied (must be opened with at least KEY_READ access).
 *
 *  @parm   HKEY | hkRoot |
 *
 *          The Key under which the copy will be created
 *              (must be opened with at least KEY_WRITE).
 *
 *  @parm   PDWORD | pMaxNameLen |
 *
 *          An optional pointer to a value which will be filled with the number 
 *          of characters, incl. the NULL terminator, in the longest key name.
 *
 *  @returns
 *
 *          S_OK if all keys were successfully copied
 *          S_FALSE if there were no keys to copy.
 *          Or the memory allocation error code or the failing registry 
 *          function return code converted to a <t HRESULT>.
 *
 *****************************************************************************/
STDMETHODIMP
    hresRegCopyKeys( HKEY hkSrc, HKEY hkRoot, PDWORD OPTIONAL pMaxNameLen )
{
    HRESULT             hres;
    LONG                lRc;
    DWORD               cSubKeys;
    DWORD               MaxNameLen;
    DWORD               cbName;
    PTCHAR              szKeyName;
    DWORD               MaxClassLen;
    DWORD               cbClass;
    PTCHAR              szClassName;

    EnterProcI(hresRegCopyKeys, (_ "xx", hkSrc, hkRoot ));

    lRc = RegQueryInfoKey(  hkSrc,              // handle to key to query
                            NULL, NULL, NULL,   // Class, cbClass, Reserved
                            &cSubKeys,          // NumSubKeys
                            &MaxNameLen,        // MaxSubKeyLen
                            &MaxClassLen,       // MaxClassLen
                            NULL, NULL, NULL,   // NumValues, MaxValueNameLen, MaxValueLen
                            NULL, NULL );       // Security descriptor, last write

    if( lRc == ERROR_SUCCESS )
    {
        if( cSubKeys )
        {
            // Make space for NULL terminators
            MaxNameLen++;
            MaxClassLen++;

            if( pMaxNameLen )
            {
                *pMaxNameLen = MaxNameLen;
            }

            /*
             *  There are keys to copy so allocate buffer sapce for the key and 
             *  key class names.
             */
            /*
             *  Prefix warns (mb:34678) that things would go horribly wrong if 
             *  (MaxNameLen + MaxClassLen) * sizeof(szClassName[0]) == 0 
             *  however this cannot happen unless RegQueryInfoKey has some 
             *  catestrophic failure _and_ returned OK.
             */
            AssertF( (MaxNameLen + MaxClassLen) * sizeof(szClassName[0]) != 0 );
            hres = AllocCbPpv( (MaxNameLen + MaxClassLen) * sizeof(szClassName[0]), &szKeyName );
            if( FAILED( hres ) )
            {
                SquirtSqflPtszV(sqfl | sqflError,
                    TEXT("Out of memory copying subkeys") );
            }
            else
            {
                szClassName = &szKeyName[MaxNameLen];

                cSubKeys--;
                do
                {
                    cbName = MaxNameLen;
                    cbClass = MaxClassLen;

                    lRc = RegEnumKeyEx( hkSrc,      // Key containing subkeys to enumerate
                                        cSubKeys,   // index of subkey to enumerate
                                        szKeyName,  // address of buffer for subkey name
                                        &cbName,    // address for size of subkey buffer
                                        NULL,       // reserved
                                        szClassName,// address of buffer for class string
                                        &cbClass,   // address for size of class buffer
                                        NULL );     // address for time key last written to

                    if( lRc == ERROR_SUCCESS )
                    {
                        hres = hresRegCopyKey( hkSrc, szKeyName, szClassName, hkRoot, szKeyName, NULL );
                    }
                    else
                    {
                        SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("RegEnumKeyEx failed during copy keys, code 0x%08x"), lRc );
                        hres = hresReg( hres );
                    }

                    if( FAILED( hres ) )
                    {
                        break;
                    }
                } while( cSubKeys-- ); 
                FreePpv(&szKeyName);
            }
        }
        else
        {
            SquirtSqflPtszV(sqfl, TEXT("No keys to copy") );
            hres = S_FALSE;
        }
    }
    else
    {
        SquirtSqflPtszV(sqfl | sqflBenign,
            TEXT("RegQueryInfoKey failed during value key, code 0x%08x"), lRc );
        hres = hresReg(lRc);
    }

    ExitOleProc();    

    return( hres );
} /* hresRegCopyKeys */


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresRegCopyBranch |
 *
 *          Copy the contents of one key including sub-keys to another.
 *          Since this function calls itself to copy the contents of subkeys,
 *          the local variables should be kept to a minimum.
 *
 *  @parm   HKEY | hkSrc |
 *
 *          Key to be copied (must be opened with at least KEY_READ access).
 *
 *  @parm   HKEY | hkDest |
 *
 *          Key to receive copy (must be opened with at least KEY_WRITE).
 *
 *  @returns
 *
 *          S_OK if the copy completed succesfully 
 *          or the return value from <f hresRegCopyValues>, 
 *          <f hresRegCopyKeys>, memory allocation error or a registry 
 *          function failure code converted to a <t HRESULT>.
 *
 *****************************************************************************/

STDMETHODIMP
    hresRegCopyBranch( HKEY hkSrc, HKEY hkDest )
{
    HKEY    hkSrcSub; 
    HKEY    hkDestSub;
    HRESULT hres;
    DWORD   dwIdx;
    DWORD   cbMaxName;
    DWORD   cbKeyName;
    PTCHAR  szKeyName;

    EnterProcI(hresRegCopyBranch, (_ "xx", hkSrc, hkDest));

    hres = hresRegCopyValues( hkSrc, hkDest );

    if( SUCCEEDED( hres ) )
    {
        hres = hresRegCopyKeys( hkSrc, hkDest, &cbMaxName );

        if( hres == S_FALSE )
        {
            /* No keys to recurse into */
            hres = S_OK;
        }
        else if( hres == S_OK )
        {
            /*
             *  Assert that a non-zero size buffer is requested
             */
            AssertF( cbMaxName * sizeof(szKeyName[0]) );
            hres = AllocCbPpv( cbMaxName * sizeof(szKeyName[0]), &szKeyName );

            if( SUCCEEDED( hres ) )
            {
                for( dwIdx=0; SUCCEEDED( hres ); dwIdx++ )
                {
                    cbKeyName = cbMaxName;

                    /*
                     *  Prefix warns (mb:34669 & win:170672) that szKeyName 
                     *  could be NULL if the above alloc was for zero bytes.  
                     *  This cannot happen as cbMaxName is the length of the 
                     *  longest key name, incremented to leave space for null 
                     *  termination on a successful call to RegQueryInfoKey 
                     *  when at least one key was found.
                     */
                    hres = hresReg( RegEnumKeyEx( hkSrc, dwIdx, 
                                                  szKeyName, &cbKeyName,
                                                  NULL, NULL, NULL, NULL ) );  // Reserved, szClass, cbClass, Last Write
                    if( SUCCEEDED( hres ) )
                    {
                        hres = hresReg( RegOpenKeyEx( hkSrc, szKeyName, 0, KEY_READ, &hkSrcSub ) );

                        if( SUCCEEDED( hres ) )
                        {
                            hres = hresReg( RegOpenKeyEx( hkDest, szKeyName, 0, KEY_WRITE, &hkDestSub ) );
                            if( SUCCEEDED( hres ) )
                            {
                                hres = hresRegCopyBranch( hkSrcSub, hkDestSub );
                            }
                            else
                            {
                                SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("Failed to open destination subkey %s for recursion, code 0x%04x"),
                                    szKeyName, LOWORD(hres) );
                            }
                        }
                        else
                        {
                            SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("Failed to open source subkey %s for recursion, code 0x%04x"),
                                szKeyName, LOWORD(hres) );
                        }
                    }
                    else
                    {
                        if( hres == hresReg( ERROR_NO_MORE_ITEMS ) )
                        {
                            /* Recursed all keys */
                            hres = S_OK;
                            break;
                        }
                        else
                        {
                            SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("Failed RegEnumKeyEx during subkey recursion, code 0x%04x"),
                                LOWORD(hres) );
                        }
                    }
                }

                FreePpv( &szKeyName );
            }
            else
            {
                SquirtSqflPtszV(sqfl | sqflError,
                    TEXT("Out of memory recursing subkeys") );
            }
        }
        else
        {
            if( SUCCEEDED( hres ) )
            {
                RPF( "Unexpected success code 0x%08x from hresRegCopyKeys", hres );
            }
        }
    }

    ExitOleProc();

    return( hres );

} /* hresRegCopyBranch */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\direg.c ===
/*****************************************************************************
 *
 *  DIReg.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      OLE self-registration.
 *
 *  Contents:
 *
 *      DllRegisterServer()
 *      DllUnregisterServer()
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *  The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflDll

/*****************************************************************************
 *
 *      RegSetStringEx
 *
 *      Add a REG_SZ to hkey\sub::value.
 *
 *****************************************************************************/

void INTERNAL
RegSetStringEx(HKEY hk, LPCTSTR ptszValue, LPCTSTR ptszData)
{
    LONG lRc = RegSetValueEx(hk, ptszValue, 0, REG_SZ,
                             (PV)ptszData, cbCtch(lstrlen(ptszData)+1));
}

/*****************************************************************************
 *
 *      RegDelStringEx
 *
 *      Remove a REG_SZ from hkey\sub::value.  The data is ignored.
 *      It's passed so that RegDelStringEx matches the prototype for a
 *      REGSTRINGACTION.
 *
 *****************************************************************************/

void INTERNAL
RegDelStringEx(HKEY hk, LPCTSTR ptszValue, LPCTSTR ptszData)
{
    LONG lRc = RegDeleteValue(hk, ptszValue);
}

/*****************************************************************************
 *
 *      RegCloseFinish
 *
 *      Just close the subkey already.
 *
 *****************************************************************************/

void INTERNAL
RegCloseFinish(HKEY hk, LPCTSTR ptszSub, HKEY hkSub)
{
    LONG lRc = RegCloseKey(hkSub);
}

/*****************************************************************************
 *
 *      RegDelFinish
 *
 *      Delete a key if there is nothing in it.
 *
 *      OLE unregistration rules demand that you not delete a key if OLE
 *      has added something to it.
 *
 *****************************************************************************/

void INTERNAL
RegDelFinish(HKEY hk, LPCTSTR ptszSub, HKEY hkSub)
{
    LONG lRc;
    DWORD cKeys = 0, cValues = 0;
    RegQueryInfoKey(hkSub, 0, 0, 0, &cKeys, 0, 0, &cValues, 0, 0, 0, 0);
    RegCloseKey(hkSub);
    if ((cKeys | cValues) == 0) {

#ifdef WINNT
        lRc = DIWinnt_RegDeleteKey(hk, ptszSub);
#else
        lRc = RegDeleteKey(hk, ptszSub);
#endif

    } else {
        lRc = 0;
    }
}


#ifdef WINNT //The following are only used on WINNT

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | RegSetPermissionsOnDescendants |
 *
 *			Sets the specified permissions on all descendants of the specified key.
 *
 *  @parm   HKEY | hKey |
 *
 *          The reg key on whose descendants we're operating.
 *
 *  @parm   SECURITY_DESCRIPTOR* | psd |
 *
 *          Ptr to the SECURITY_DESCRIPTOR we're using.
 *
 *  @returns
 *
 *          Nothing.
 *			Note that this recurses while having TCHAR szKeyName[MAX_PATH+1]
 *			for each level. If stack space is a concern, can allocate it on the heap,
 *			and free after obtain the HKEY (i.e. before recursing).
 *
 *****************************************************************************/

void INTERNAL
RegSetPermissionsOnDescendants(HKEY hKey, SECURITY_DESCRIPTOR* psd)
{
	DWORD dwIndex = 0;
	LONG lRetCode = ERROR_SUCCESS;

	while (lRetCode == ERROR_SUCCESS)
	{
		TCHAR szKeyName[MAX_PATH+1];
		DWORD cbKeyName = MAX_PATH+1;
		lRetCode = RegEnumKeyEx(hKey, 
							dwIndex,
							szKeyName,
							&cbKeyName,
							NULL, NULL, NULL, NULL);

		if (lRetCode == ERROR_SUCCESS)
		{
			LONG lRetSub;
			HKEY hkSubKey;
			lRetSub = RegOpenKeyEx(hKey, szKeyName, 0, DI_KEY_ALL_ACCESS | WRITE_DAC, &hkSubKey);
			if (lRetSub == ERROR_SUCCESS)
			{
				//set security on it and its descendants
				lRetSub = RegSetKeySecurity(hkSubKey,
											(SECURITY_INFORMATION)DACL_SECURITY_INFORMATION,
											psd);
				RegSetPermissionsOnDescendants(hkSubKey, psd);
				RegCloseKey(hkSubKey);
					
				if(lRetSub != ERROR_SUCCESS) 
				{
					RPF("Couldn't RegSetKeySecurity on %hs", szKeyName);
				}
			}
			else
			{
				RPF("Couldn't open enumed subkey %hs", szKeyName);
			}

			dwIndex++;
		}
	}

}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | RegSetSecurity |
 *
 *      Set the security of 
 *        SYSTEM\\CurrentControlSet\\Control\\MediaProperties\\PrivateProperties\\Joystick\\OEM
 *        SYSTEM\\CurrentControlSet\\Control\\MediaResources\\Joystick\\Dinput.dll
 *      to be accessible to Everyone on Win2K,
 *.		to be accessible to Everyone but without WRITE_DAC and WRITE_OWNER permissions on WinXP;
 *        SYSTEM\\CurrentControlSet\\Control\\MediaProperties\\PrivateProperties\\DirectInput
 *		to be accessible to Everyone but without WRITE_DAC and WRITE_OWNER permissions on Win2k and WinXP.
 *
 *  @returns
 *
 *          S_OK on success, E_FAIL on error.
 *
 *****************************************************************************/

HRESULT INTERNAL
RegSetSecurity(void)
{
    HKEY hkJoy, hkDin, hkPP, hkMedR, hkJDi;
    LONG lRetCode;
	
    // Changed for server per Whistler bug 575181
    // open / create the keys
    //
	//MediaProperties/PrivateProperties/DirectInput
	lRetCode = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        REGSTR_PATH_PRIVATEPROPERTIES,
        0,
        KEY_WRITE,
        &hkPP
        );

	if(lRetCode != ERROR_SUCCESS) {
		RPF("Couldn't open REGSTR_PATH_PRIVATEPROPERTIES");
        return E_FAIL;
    }
    
	lRetCode = RegCreateKeyEx(
        hkPP,
        TEXT("DirectInput"),
        0,
		NULL,
		REG_OPTION_NON_VOLATILE,
        DI_KEY_ALL_ACCESS,
		NULL,
        &hkDin,
		NULL
        );

	RegCloseKey(hkPP);

    if(lRetCode != ERROR_SUCCESS) {
		RPF("Couldn't open DirectInput");
        return E_FAIL;
    }

	RegCloseKey(hkDin);

	//MediaResources/Joystick/Dinput.dll
	lRetCode = RegOpenKeyEx(
		HKEY_LOCAL_MACHINE,
		REGSTR_PATH_MEDIARESOURCES,
		0,
		KEY_WRITE,
		&hkMedR
		);

	if(lRetCode != ERROR_SUCCESS) {
		RPF("Couldn't open REGSTR_PATH_MEDIARESOURCES");
		return E_FAIL;
	}

	   
	lRetCode = RegCreateKeyEx(
		hkMedR,
		TEXT("Joystick"),
		0,
		NULL,
		REG_OPTION_NON_VOLATILE,
		KEY_WRITE,
		NULL,
		&hkJoy,
		NULL
        );

	RegCloseKey(hkMedR);

	if(lRetCode != ERROR_SUCCESS) {
		RPF("Couldn't open Joystick");
		return E_FAIL;
	}

	lRetCode = RegCreateKeyEx(
		hkJoy,
		TEXT("Dinput.dll"),
		0,
		NULL,
		REG_OPTION_NON_VOLATILE,
		DI_KEY_ALL_ACCESS,
		NULL,
		&hkJDi,
		NULL
		);

	RegCloseKey(hkJoy);
    
	if(lRetCode != ERROR_SUCCESS) {
		RPF("Couldn't open Dinput.dll");
		return E_FAIL;
	}

	RegCloseKey(hkJDi);

    return S_OK;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DummyRegSetSecurity |
 *
 *			Do nothing
 *
 *  @returns
 *
 *          S_OK.
 *
 *****************************************************************************/

HRESULT INTERNAL
DummyRegSetSecurity(void)
{
	return S_OK;
}

#endif //WINNT


/*****************************************************************************
 *
 *      REGVTBL
 *
 *      Functions for dorking with a registry key, either coming or going.
 *
 *****************************************************************************/

typedef struct REGVTBL {
    /* How to create/open a key */
    LONG (INTERNAL *KeyAction)(HKEY hk, LPCTSTR ptszSub, PHKEY phkOut);

    /* How to create/delete a string */
    void (INTERNAL *StringAction)(HKEY hk, LPCTSTR ptszValue, LPCTSTR ptszData);

    /* How to finish using a key */
    void (INTERNAL *KeyFinish)(HKEY hk, LPCTSTR ptszSub, HKEY hkSub);
 
#ifdef WINNT
    /* How to set security on OEM key */
    HRESULT (INTERNAL *SetSecurity)( void );
#endif //WINNT

} REGVTBL, *PREGVTBL;
typedef const REGVTBL *PCREGVTBL;

#ifdef WINNT
const REGVTBL c_vtblAdd = { RegCreateKey, RegSetStringEx, RegCloseFinish, RegSetSecurity };
const REGVTBL c_vtblDel = {   RegOpenKey, RegDelStringEx,   RegDelFinish, DummyRegSetSecurity };
#else
const REGVTBL c_vtblAdd = { RegCreateKey, RegSetStringEx, RegCloseFinish };
const REGVTBL c_vtblDel = {   RegOpenKey, RegDelStringEx,   RegDelFinish };
#endif //WINNT

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllServerAction |
 *
 *          Register or unregister our objects with OLE/COM/ActiveX/
 *          whatever its name is.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

extern const TCHAR c_tszNil[];

#define ctchClsid       ctchGuid

const TCHAR c_tszClsidGuid[] =
TEXT("CLSID\\{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}");

const TCHAR c_tszInProcServer32[] = TEXT("InProcServer32");
const TCHAR c_tszThreadingModel[] = TEXT("ThreadingModel");
const TCHAR c_tszBoth[] = TEXT("Both");

#pragma END_CONST_DATA

void INTERNAL
DllServerAction(PCREGVTBL pvtbl)
{
    TCHAR tszThisDll[MAX_PATH];
    UINT iclsidmap;

    GetModuleFileName(g_hinst, tszThisDll, cA(tszThisDll));

    for (iclsidmap = 0; iclsidmap < cclsidmap; iclsidmap++) {
        TCHAR tszClsid[7+ctchClsid];
        HKEY hkClsid;
        HKEY hkSub;
        REFCLSID rclsid = c_rgclsidmap[iclsidmap].rclsid;

        wsprintf(tszClsid, c_tszClsidGuid,
                 rclsid->Data1, rclsid->Data2, rclsid->Data3,
                 rclsid->Data4[0], rclsid->Data4[1],
                 rclsid->Data4[2], rclsid->Data4[3],
                 rclsid->Data4[4], rclsid->Data4[5],
                 rclsid->Data4[6], rclsid->Data4[7]);

        if (pvtbl->KeyAction(HKEY_CLASSES_ROOT, tszClsid, &hkClsid) == 0) {
            TCHAR tszName[127];

            /* Do the type name */
            LoadString(g_hinst, c_rgclsidmap[iclsidmap].ids,
                       tszName, cA(tszName));
            pvtbl->StringAction(hkClsid, 0, tszName);

            /* Do the in-proc server name and threading model */
            if (pvtbl->KeyAction(hkClsid, c_tszInProcServer32, &hkSub) == 0) {
                pvtbl->StringAction(hkSub, 0, tszThisDll);
                pvtbl->StringAction(hkSub, c_tszThreadingModel, c_tszBoth);
                pvtbl->KeyFinish(hkClsid, c_tszInProcServer32, hkSub);
            }

            pvtbl->KeyFinish(HKEY_CLASSES_ROOT, tszClsid, hkClsid);

        }
    }
    
  #ifdef WINNT
    pvtbl->SetSecurity();
  #endif
}



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllRegisterServer |
 *
 *          Register our classes with OLE/COM/ActiveX/whatever its name is.
 *
 *****************************************************************************/

void EXTERNAL
DllRegisterServer(void)
{
    DllServerAction(&c_vtblAdd);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllUnregisterServer |
 *
 *          Unregister our classes from OLE/COM/ActiveX/whatever its name is.
 *
 *****************************************************************************/

void EXTERNAL
DllUnregisterServer(void)
{
    DllServerAction(&c_vtblDel);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\diriff.c ===
/****************************************************************************

    MODULE:     	RIFF.CPP
    Tab settings: 	Every 4 spaces

    Copyright 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Classes for reading and writing RIFF files
    
    CLASSES:
        CRIFFFile	Encapsulates common RIFF file functionality

    Author(s):	Name:
    ----------	----------------
        DMS		Daniel M. Sangster

    Revision History:
    -----------------
    Version Date            Author  Comments
    1.0  	25-Jul-96       DMS     Created

    COMMENTS:
****************************************************************************/
#include "dinputpr.h"
#define sqfl sqflDev


/* 
 * This function converts MMIO errors to HRESULTS
 */
HRESULT INLINE hresMMIO(UINT mmioErr)
{
    switch(mmioErr)
    {
    case 0x0:                       return  S_OK;
    case MMIOERR_FILENOTFOUND:      return  hresLe(ERROR_FILE_NOT_FOUND);/* file not found */
    case MMIOERR_OUTOFMEMORY:       return  hresLe(ERROR_OUTOFMEMORY);  /* out of memory */
    case MMIOERR_CANNOTOPEN:        return  hresLe(ERROR_OPEN_FAILED);  /* cannot open */
    case MMIOERR_CANNOTCLOSE:       return  S_FALSE;                    /* cannot close */
    case MMIOERR_CANNOTREAD:        return  hresLe(ERROR_READ_FAULT);   /* cannot read */
    case MMIOERR_CANNOTWRITE:       return  hresLe(ERROR_WRITE_FAULT);  /* cannot write */
    case MMIOERR_CANNOTSEEK:        return  hresLe(ERROR_SEEK);         /* cannot seek */
    case MMIOERR_CANNOTEXPAND:      return  hresLe(ERROR_SEEK);           /* cannot expand file */
    case MMIOERR_CHUNKNOTFOUND:     return  hresLe(ERROR_SECTOR_NOT_FOUND);  /* chunk not found */
    case MMIOERR_UNBUFFERED:        return  E_FAIL;
    case MMIOERR_PATHNOTFOUND:      return  hresLe(ERROR_PATH_NOT_FOUND);/* path incorrect */
    case MMIOERR_ACCESSDENIED:      return  hresLe(ERROR_ACCESS_DENIED); /* file was protected */
    case MMIOERR_SHARINGVIOLATION:  return  hresLe(ERROR_SHARING_VIOLATION); /* file in use */
    case MMIOERR_NETWORKERROR:      return  hresLe(ERROR_UNEXP_NET_ERR); /* network not responding */
    case MMIOERR_TOOMANYOPENFILES:  return  hresLe(ERROR_TOO_MANY_OPEN_FILES); /* no more file handles  */
    case MMIOERR_INVALIDFILE:       return  hresLe(ERROR_BAD_FORMAT);    /* default error file error */
    default:                        return  E_FAIL;   
    }

}


HRESULT INLINE RIFF_Ascend(HMMIO hmmio, LPMMCKINFO lpmmckinfo)
{
    return hresMMIO( mmioAscend(hmmio, lpmmckinfo, 0) );
}

HRESULT INLINE RIFF_Descend(HMMIO hmmio, LPMMCKINFO lpmmckinfo, LPMMCKINFO lpmmckinfoParent, UINT nFlags)
{
    return hresMMIO(mmioDescend(hmmio, lpmmckinfo, lpmmckinfoParent, nFlags));
}

HRESULT INLINE RIFF_CreateChunk(HMMIO hmmio, LPMMCKINFO lpmmckinfo, UINT nFlags)
{
    // set cksize to zero to overcome a bug in release version of mmioAscend
    // which does not correctly write back the size of the chunk
    lpmmckinfo->cksize = 0;

    return hresMMIO(mmioCreateChunk(hmmio, lpmmckinfo, nFlags));
}


HRESULT INLINE RIFF_Read(HMMIO hmmio, LPVOID pBuf, LONG nCount)
{
    return (nCount == mmioRead(hmmio, (char*)pBuf, nCount)) ? S_OK: hresLe(ERROR_READ_FAULT);
}          

HRESULT INLINE RIFF_Write(HMMIO hmmio, const LPVOID pBuf, LONG nCount)
{
    return ( nCount == mmioWrite(hmmio, (char*)pBuf, nCount)) ? S_OK : hresLe(ERROR_WRITE_FAULT);
}

HRESULT RIFF_Close(HMMIO hmmio, UINT nFlags)
{
    return hresMMIO(mmioClose(hmmio, nFlags));
}

/*
 * Opens a RIFF file for read / write
 * Reads/Writes a GUID that servers as our signature
 */
HRESULT RIFF_Open
    (
    LPCSTR      lpszFilename,
    UINT        nOpenFlags,
    PHANDLE     phmmio,
    LPMMCKINFO  lpmmck,
    PDWORD      pdwEffectSz
    )
{
    HRESULT     hres = S_OK;
    MMIOINFO    mmInfo;
    HMMIO       hmmio;
	LPSTR		lpszFile = (LPSTR)lpszFilename;

    ZeroX(mmInfo);

	//There is a problem in mmio that causes somewhat unpredictable behaviour  under certain conditions --
	//in particular, if using drag-n-drop, it may happen so that mmioOpenA() opens 1 file for reading
	//and completely different file for writing, if only the file name is specified.
	//So we need to check whether we have only the file name or the path (path will contain a \).
	if (strchr(lpszFilename, '\\') == NULL)
	{
		//Put the current directory before the file name to give the absolute path.
		//Apparently mmio doesn't have a problem if given absolute path.
		CHAR szFullPath[MAX_PATH];
		DWORD dwWritten = GetFullPathNameA(lpszFilename, MAX_PATH, (LPSTR)&szFullPath, NULL);
		if (( dwWritten != 0) && (dwWritten <= MAX_PATH))
		{
			lpszFile = (LPSTR)&szFullPath;
		}
	}

	//There is a problem in mmioOpenA() that makes it leak when the file specified to open for reading
	//doesn't exist.
	//To avoid the leak, we need to check overselves whether we're opening for reading and 
	//whether the file exists.
	if( nOpenFlags == ( MMIO_READ | MMIO_ALLOCBUF) )
    {
		HANDLE h = CreateFileA(lpszFile, 
							GENERIC_READ,
							0,
							NULL,
							OPEN_EXISTING,
							FILE_ATTRIBUTE_NORMAL,
							NULL);
		if (h == INVALID_HANDLE_VALUE)
		{
			//set the error code
			hres = hresLe(GetLastError());
			goto done;
		}
		else
		{
			//the file is there; close handle
			CloseHandle(h);
		}
	}


    // go ahead and open the file, if we can
    hmmio = mmioOpenA(lpszFile, &mmInfo, nOpenFlags);

    if(mmInfo.wErrorRet)
    {
        hres = hresMMIO(mmInfo.wErrorRet);
        AssertF(FAILED(hres));
    }

   // if( nOpenFlags & ( MMIO_READ | MMIO_ALLOCBUF) )
	 if( nOpenFlags == ( MMIO_READ | MMIO_ALLOCBUF) )
    {
        if(SUCCEEDED(hres))
        {
            // locate and descend into FORC RIFF chunk
            lpmmck->fccType = FCC_FORCE_EFFECT_RIFF;
            hres = RIFF_Descend(hmmio, lpmmck, NULL, MMIO_FINDRIFF);
        }

        if(SUCCEEDED(hres))
        {
            GUID GUIDVersion;
            //read the guid
            hres = RIFF_Read(hmmio, &GUIDVersion, sizeof(GUID));

            if(SUCCEEDED(hres))
            {
                if(IsEqualGUID(&GUIDVersion, &GUID_INTERNALFILEEFFECT))
                {
                
                } else
                {
                    hres = hresLe(ERROR_BAD_FORMAT);
                }
            }
        }

    } 
	//else if( nOpenFlags & ( MMIO_WRITE | MMIO_ALLOCBUF) )
	else if( nOpenFlags & ( MMIO_WRITE) )
    {

        // create the FORC RIFF chunk
        lpmmck->fccType = FCC_FORCE_EFFECT_RIFF;
        hres = RIFF_CreateChunk(hmmio, lpmmck, MMIO_CREATERIFF);

        if(SUCCEEDED(hres))
        {
            //write the version GUID
            hres = RIFF_Write(hmmio, (PV)&GUID_INTERNALFILEEFFECT, sizeof(GUID));
        }
    } else
    {
        hres = E_FAIL;
    }

    *phmmio = hmmio;

done:;
    return hres;
}



/*****************************************************************************
 *
 * internal
 * RIFF_ReadEffect
 *
 *  Reads a single Effect from a RIFF file
 *  
 *  The callee bears the responsibility to free the TypeSpecificParameterBlock
 *  for the effect.
 *       
 *
 *****************************************************************************/

#ifdef _M_IA64
//This is hack to read 32 bit files on ia64, since someone decided to write 
//pointers to file.
//Copied from dinput.h and modified.
typedef struct DIEFFECT_FILE32 {
    DWORD dwSize;                   /* sizeof(DIEFFECT)     */
    DWORD dwFlags;                  /* DIEFF_*              */
    DWORD dwDuration;               /* Microseconds         */
    DWORD dwSamplePeriod;           /* Microseconds         */
    DWORD dwGain;
    DWORD dwTriggerButton;          /* or DIEB_NOTRIGGER    */
    DWORD dwTriggerRepeatInterval;  /* Microseconds         */
    DWORD cAxes;                    /* Number of axes       */

/*Make sure size is same on both 1386 and ia64.
    LPDWORD rgdwAxes;
    LPLONG rglDirection;
    LPDIENVELOPE lpEnvelope;
*/  DWORD rgdwAxes;                 /* Array of axes        */
    DWORD rglDirection;             /* Array of directions  */
    DWORD lpEnvelope;               /* Optional             */

    DWORD cbTypeSpecificParams;     /* Size of params       */

/*Make sure size is same on both 1386 and ia64.
    LPVOID lpvTypeSpecificParams;
*/  DWORD lpvTypeSpecificParams;    /* Pointer to params    */

//#if(DIRECTINPUT_VERSION >= 0x0600)//Out since file format does not change.
    DWORD  dwStartDelay;            /* Microseconds         */
//#endif /* DIRECTINPUT_VERSION >= 0x0600 *///Out since file format does not change.
} DIEFFECT_FILE32, *LPDIEFFECT_FILE32;
#endif /*_M_IA64*/

HRESULT
    RIFF_ReadEffect
    (
    HMMIO      hmmio, 
    LPDIFILEEFFECT lpDiFileEf 
    )
{
    HRESULT hres = E_FAIL;
    MMCKINFO mmckinfoEffectLIST;
    MMCKINFO mmckinfoDataCHUNK;
    LPDIEFFECT peff = (LPDIEFFECT)lpDiFileEf->lpDiEffect;

    // descend into the effect list
    mmckinfoEffectLIST.fccType = FCC_EFFECT_LIST;
    hres = RIFF_Descend(hmmio, &mmckinfoEffectLIST, NULL, MMIO_FINDLIST);
   
    if(SUCCEEDED(hres))
    {
        //read the name
        hres = RIFF_Read(hmmio, lpDiFileEf->szFriendlyName, MAX_SIZE_SNAME);
    }

    if(SUCCEEDED(hres))
    {
#ifdef _M_IA64

        DIEFFECT_FILE32 eff32;
        //read the effect structure
        hres = RIFF_Read(hmmio, &eff32, sizeof(eff32));

        AssertF( eff32.dwSize == sizeof(eff32) );
        if( eff32.dwSize != sizeof(eff32) )
        {
            hres = ERROR_BAD_FORMAT;
        }
        else
        {
            peff->dwSize=sizeof(*peff);
            peff->dwFlags=eff32.dwFlags;
            peff->dwDuration=eff32.dwDuration;
            peff->dwSamplePeriod=eff32.dwSamplePeriod;
            peff->dwGain=eff32.dwGain;
            peff->dwTriggerButton=eff32.dwTriggerButton;
            peff->dwTriggerRepeatInterval=eff32.dwTriggerRepeatInterval;
            peff->cAxes=eff32.cAxes;
            peff->cbTypeSpecificParams=eff32.cbTypeSpecificParams;
            peff->lpvTypeSpecificParams=(LPVOID)(DWORD_PTR)eff32.lpvTypeSpecificParams;
            peff->dwStartDelay=eff32.dwStartDelay;
        }

#else /*_M_IA64*/

        // Reading the effect structure will zap out the following,
        // so we make a copy before the read.
        LPDIENVELOPE    lpEnvelope  = peff->lpEnvelope;
        LPDWORD         rgdwAxes    = peff->rgdwAxes;
        LPLONG          rglDirection= peff->rglDirection;
        
        //read the effect structure
        hres = RIFF_Read(hmmio, peff, sizeof(DIEFFECT));
        
        AssertF( peff->dwSize == sizeof(DIEFFECT) );
        if( peff->dwSize != sizeof(DIEFFECT) )
        {
            hres = ERROR_BAD_FORMAT;
        }
        else
        {
            if(peff->lpEnvelope)		peff->lpEnvelope    =   lpEnvelope;
            if(peff->rgdwAxes)			peff->rgdwAxes      =   rgdwAxes;
            if(peff->rglDirection)		peff->rglDirection  =   rglDirection;
        }

#endif /*_M_IA64*/

	    if(SUCCEEDED(hres))
        {    
            AssertF(peff->cAxes < DIEFFECT_MAXAXES);
            if(peff->cAxes >= DIEFFECT_MAXAXES)
            {
                hres = ERROR_BAD_FORMAT;
            }
        }
    }

	if(SUCCEEDED(hres))
    {
        // read the Effect GUID
        hres = RIFF_Read(hmmio, &lpDiFileEf->GuidEffect, sizeof(GUID));
    }


	if(SUCCEEDED(hres))
    {
        UINT nRepeatCount;
        //read in the repeat count
        hres = RIFF_Read(hmmio, &nRepeatCount, sizeof(nRepeatCount));
    }


    if(SUCCEEDED(hres) && peff->rgdwAxes)
    {
        // descend the data chunk
        mmckinfoDataCHUNK.ckid = FCC_DATA_CHUNK;
        hres = RIFF_Descend(hmmio, &mmckinfoDataCHUNK, NULL, MMIO_FINDCHUNK);
		if(SUCCEEDED(hres))
		{
			//read the axes
			hres = RIFF_Read(hmmio, peff->rgdwAxes, cbX(*peff->rgdwAxes)*(peff->cAxes));
			hres = RIFF_Ascend(hmmio, &mmckinfoDataCHUNK);
		}
	}

    if(SUCCEEDED(hres) && peff->rglDirection)
    {
		//descend the data chunk
        mmckinfoDataCHUNK.ckid = FCC_DATA_CHUNK;
        hres = RIFF_Descend(hmmio, &mmckinfoDataCHUNK, NULL, MMIO_FINDCHUNK);
		if(SUCCEEDED(hres))
		{
			//read the direction
			hres = RIFF_Read(hmmio, peff->rglDirection, cbX(*peff->rglDirection)*(peff->cAxes));
			hres = RIFF_Ascend(hmmio, &mmckinfoDataCHUNK);
		}
    }

    if(SUCCEEDED(hres) && peff->lpEnvelope )
    {
	
		//descend the data chunk
        mmckinfoDataCHUNK.ckid = FCC_DATA_CHUNK;
        hres = RIFF_Descend(hmmio, &mmckinfoDataCHUNK, NULL, MMIO_FINDCHUNK);
		if(SUCCEEDED(hres))
		{
			hres = RIFF_Read(hmmio, peff->lpEnvelope, sizeof(DIENVELOPE));
			hres = RIFF_Ascend(hmmio, &mmckinfoDataCHUNK);
		}
    }


    if(SUCCEEDED(hres) && (peff->cbTypeSpecificParams > 0))
    {
        // get the param structure, if any 
        hres = AllocCbPpv( peff->cbTypeSpecificParams, &peff->lpvTypeSpecificParams );

        if( SUCCEEDED( hres ) )
        {
			//descend the data chunk
			mmckinfoDataCHUNK.ckid = FCC_DATA_CHUNK;
			hres = RIFF_Descend(hmmio, &mmckinfoDataCHUNK, NULL, MMIO_FINDCHUNK);
			if(SUCCEEDED(hres))
			{
				hres = RIFF_Read(hmmio, peff->lpvTypeSpecificParams, peff->cbTypeSpecificParams);
				hres = RIFF_Ascend(hmmio, &mmckinfoDataCHUNK);
			}
        }
    }


    if(SUCCEEDED(hres))
    {
		 // ascend the effect chunk
		 hres = RIFF_Ascend(hmmio, &mmckinfoEffectLIST);
    }
    return hres;
}


/*
 * RIFF_WriteEffect
 *
 *  Writes a single Effect structure to a RIFF file
 *
 *  The effect structure is quite complex. It contains pointers
 *  to a number of other structures. This function checks for
 *  valid data before it writes out the effect structure
 */

HRESULT RIFF_WriteEffect
    (HMMIO hmmio,
     LPDIFILEEFFECT    lpDiFileEf
    )
{

    HRESULT hres = E_FAIL;
    LPDIEFFECT peff = (LPDIEFFECT)lpDiFileEf->lpDiEffect;
    MMCKINFO mmckinfoEffectLIST;
    MMCKINFO mmckinfoDataCHUNK;
	LPDWORD rgdwAxes = NULL;
	LPLONG rglDirection = NULL;
	LPDIENVELOPE lpEnvelope = NULL;
	LPVOID lpvTypeSpecPar = NULL;

    EnterProcI(RIFF_WriteEffect, (_ "xx", hmmio, lpDiFileEf));

    // create the effect LIST
    mmckinfoEffectLIST.fccType = FCC_EFFECT_LIST;
    hres = RIFF_CreateChunk(hmmio, &mmckinfoEffectLIST, MMIO_CREATELIST);

	//save the effect ptrs and write flags to the file, instead of ptrs
	if (peff->rgdwAxes)
	{
		rgdwAxes = peff->rgdwAxes;
		peff->rgdwAxes = (LPDWORD)DIEP_AXES;
	}
	if (peff->rglDirection)
	{
		rglDirection = peff->rglDirection;
		peff->rglDirection = (LPLONG)DIEP_DIRECTION;
	}
	if (peff->lpEnvelope)
	{
		lpEnvelope = peff->lpEnvelope;
		peff->lpEnvelope = (LPDIENVELOPE)DIEP_ENVELOPE;
	}
	if ((peff->cbTypeSpecificParams > 0) && (peff->lpvTypeSpecificParams != NULL))
	{
		lpvTypeSpecPar = peff->lpvTypeSpecificParams;
		peff->lpvTypeSpecificParams = (LPVOID)DIEP_TYPESPECIFICPARAMS;
	}

	
    if(SUCCEEDED(hres))
    {
        hres = hresFullValidReadStrA(lpDiFileEf->szFriendlyName, MAX_JOYSTRING,1);

        if(SUCCEEDED(hres))
        {
            //write the name, only MAX_SIZE_SNAME characters
            hres = RIFF_Write(hmmio, lpDiFileEf->szFriendlyName, MAX_SIZE_SNAME);
        }
    }

    if(SUCCEEDED(hres))
    {
        hres = (peff && IsBadReadPtr(peff, cbX(DIEFFECT_DX5))) ? E_POINTER : S_OK;
        if(SUCCEEDED(hres))
        {
            hres = (peff && IsBadReadPtr(peff, peff->dwSize)) ? E_POINTER : S_OK;
        }
        
        if(SUCCEEDED(hres))
        {
            //write the effect structure
#ifdef _M_IA64
            DIEFFECT_FILE32 eff32;
            ZeroMemory(&eff32,sizeof(eff32));
            eff32.dwSize=sizeof(eff32);
            eff32.dwFlags=peff->dwFlags;
            eff32.dwDuration=peff->dwDuration;
            eff32.dwSamplePeriod=peff->dwSamplePeriod;
            eff32.dwGain=peff->dwGain;
            eff32.dwTriggerButton=peff->dwTriggerButton;
            eff32.dwTriggerRepeatInterval=peff->dwTriggerRepeatInterval;
            eff32.cAxes=peff->cAxes;
            eff32.cbTypeSpecificParams=peff->cbTypeSpecificParams;
            eff32.lpvTypeSpecificParams=(DWORD)(DWORD_PTR)peff->lpvTypeSpecificParams;
            eff32.dwStartDelay=peff->dwStartDelay;
            hres = RIFF_Write(hmmio, &eff32, eff32.dwSize);
#else /*_M_IA64*/
            hres = RIFF_Write(hmmio, peff, peff->dwSize);
#endif /*_M_IA64*/
        }
    }

	//restore the ptrs
	if (rgdwAxes != NULL)
	{
		peff->rgdwAxes = rgdwAxes;
	}

	if (rglDirection != NULL)
	{
		peff->rglDirection = rglDirection;
	}

	if (lpEnvelope != NULL)
	{
		peff->lpEnvelope = lpEnvelope;
	}

	if (lpvTypeSpecPar != NULL)
	{
		peff->lpvTypeSpecificParams = lpvTypeSpecPar;
	}


	if(SUCCEEDED(hres))
    {
        // write the Effect GUID
        hres = RIFF_Write(hmmio, &lpDiFileEf->GuidEffect, sizeof(GUID));
    }


	//write 1 as the repeat count
	if(SUCCEEDED(hres))
    {
		UINT nRepeatCount = 1;
        hres = RIFF_Write(hmmio, &nRepeatCount, sizeof(DWORD));
    }


    if(SUCCEEDED(hres) && rgdwAxes )
    {
        hres = (IsBadReadPtr(rgdwAxes, (*rgdwAxes)*cbX(peff->cAxes))) ? E_POINTER : S_OK;
        if(SUCCEEDED(hres))
        {
			// create the data CHUNK
			mmckinfoDataCHUNK.ckid = FCC_DATA_CHUNK;
			hres = RIFF_CreateChunk(hmmio, &mmckinfoDataCHUNK, 0);
			//write the axes
			if(SUCCEEDED(hres))
			{
				hres = RIFF_Write(hmmio, rgdwAxes, sizeof(*rgdwAxes)*(peff->cAxes));
				hres = RIFF_Ascend(hmmio, &mmckinfoDataCHUNK);
			}
        }
    }

    if(SUCCEEDED(hres) && rglDirection)
    {

        hres = (IsBadReadPtr(rglDirection, cbX(*rglDirection)*(peff->cAxes))) ? E_POINTER : S_OK;
        if(SUCCEEDED(hres))
        {
			// create the data CHUNK
			mmckinfoDataCHUNK.ckid = FCC_DATA_CHUNK;
			hres = RIFF_CreateChunk(hmmio, &mmckinfoDataCHUNK, 0);
			if(SUCCEEDED(hres))
			{
				//write the direction
				hres = RIFF_Write(hmmio, rglDirection, sizeof(*rglDirection)*(peff->cAxes));
				hres = RIFF_Ascend(hmmio, &mmckinfoDataCHUNK);
			}
        }
    }


    //write the envelope, if one is present
    if(SUCCEEDED(hres) &&
       (lpEnvelope != NULL) )
    {

        hres = (IsBadReadPtr(lpEnvelope, cbX(*lpEnvelope))) ? E_POINTER : S_OK;
        if(SUCCEEDED(hres))
        {
			// create the data CHUNK
			mmckinfoDataCHUNK.ckid = FCC_DATA_CHUNK;
			hres = RIFF_CreateChunk(hmmio, &mmckinfoDataCHUNK, 0);
			//write the envelope
			if(SUCCEEDED(hres))
			{
				hres = RIFF_Write(hmmio, lpEnvelope, lpEnvelope->dwSize);
				hres = RIFF_Ascend(hmmio, &mmckinfoDataCHUNK);
			}
        }
    }


    //write the type-specific
    if(SUCCEEDED(hres) &&
       (peff->cbTypeSpecificParams > 0) && 
       (peff->lpvTypeSpecificParams != NULL) )
    {

        hres = (IsBadReadPtr(lpvTypeSpecPar, peff->cbTypeSpecificParams)) ? E_POINTER : S_OK;
        if(SUCCEEDED(hres))
        {
			// create the data CHUNK
			mmckinfoDataCHUNK.ckid = FCC_DATA_CHUNK;
			hres = RIFF_CreateChunk(hmmio, &mmckinfoDataCHUNK, 0);
			//write the params
			if(SUCCEEDED(hres))
			{
				hres = RIFF_Write(hmmio, lpvTypeSpecPar, peff->cbTypeSpecificParams);
				hres = RIFF_Ascend(hmmio, &mmckinfoDataCHUNK);
			}
        }
    }


    if(SUCCEEDED(hres))
    {
        // ascend the effect chunk
        hres = RIFF_Ascend(hmmio, &mmckinfoEffectLIST);
    }

    ExitOleProc();
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\diraw.c ===
/*****************************************************************************
 *
 *  DIRaw.c
 *
 *  Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      DirectInput Raw Input Device processor.
 *
 *  Contents:
 *
 *      CDIRaw_RegisterRawInputDevice
 *      CDIRaw_UnregisterRawInputDevice
 *      CDIRaw_ProcessInput
 *      CDIRaw_OnInput
 *
 *****************************************************************************/

#include "dinputpr.h"

#ifdef USE_WM_INPUT

#include "ntddkbd.h"

#define sqfl sqflRaw

extern DIMOUSESTATE_INT s_msEd; //in diemm.c
extern ED s_edMouse;            //in diemm.c
extern ED s_edKbd;              //in diemk.c
extern LPBYTE g_pbKbdXlat;      //in diemk.c

static RAWMOUSE s_absrm;
static BOOL s_fFirstRaw;

#ifndef RIDEV_INPUTSINK
  // RIDEV_INPUTSINK is defined in winuserp.h
  #define RIDEV_INPUTSINK   0x00000100
#endif

#ifndef RIDEV_NOHOTKEYS
  #define RIDEV_NOHOTKEYS   0x00000200
#endif

RAWINPUTDEVICE ridOn[] = {
    { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_MOUSE,    RIDEV_INPUTSINK },
    { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_MOUSE,    RIDEV_NOLEGACY | RIDEV_CAPTUREMOUSE },
    { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_KEYBOARD, RIDEV_INPUTSINK },
    { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_KEYBOARD, RIDEV_NOLEGACY | RIDEV_NOHOTKEYS },
    { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_KEYBOARD, RIDEV_NOHOTKEYS },
};

RAWINPUTDEVICE ridOff[] = {
    { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_MOUSE,    RIDEV_REMOVE },
    { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_KEYBOARD, RIDEV_REMOVE },
};


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULE | CDIRaw_RegisterRawInputDevice |
 *
 *          register raw input device.
 *
 *  @parm   IN UINT | uirim |
 *
 *          the type of device: RIM_TYPEMOUSE or RIM_TYPEKEYBOARD
 *
 *  @parm   IN DWORD | dwOrd |
 *
 *          dwOrd determines which item of ridOn will be used for registration.
 *
 *  @parm   IN HWND | hwnd |
 *
 *          the window handler used by RegisterRawInputDevices.
 *
 *  @returns
 *
 *          S_OK - successful
 *          E_FAIL - otherwise
 *
 *****************************************************************************/

HRESULT CDIRaw_RegisterRawInputDevice( UINT uirim, DWORD dwOrd, HWND hwnd)
{
    HRESULT hres;

    AssertF( (uirim == RIM_TYPEMOUSE) || (uirim == RIM_TYPEKEYBOARD) );

    if( hwnd ) {
        ridOn[uirim*2+dwOrd].hwndTarget = hwnd;
    }

    if( RegisterRawInputDevices &&
        RegisterRawInputDevices(&ridOn[uirim*2+dwOrd], 1, sizeof(RAWINPUTDEVICE)) ) {
        SquirtSqflPtszV(sqfl, TEXT("RegisterRawInputDevice: %s, mode: %s, hwnd: 0x%08lx"),
                            uirim==0 ? TEXT("mouse"):TEXT("keyboard"), 
                            dwOrd==0 ? TEXT("NONEXCL") : dwOrd==1 ? TEXT("EXCL") : TEXT("NOWIN"),
                            hwnd);
        hres = S_OK;
    } else {
        hres = E_FAIL;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULE | CDIRaw_UnregisterRawInputDevice |
 *
 *          unregister raw input device.
 *
 *  @parm   IN UINT | uirim |
 *
 *          the type of device: RIM_TYPEMOUSE or RIM_TYPEKEYBOARD
 *
 *  @parm   IN HWND | hwnd |
 *
 *          the window handler used by RegisterRawInputDevices.
 *
 *  @returns
 *
 *          S_OK - successful
 *          E_FAIL - otherwise
 *
 *****************************************************************************/

HRESULT CDIRaw_UnregisterRawInputDevice( UINT uirim, HWND hwnd )
{
    HRESULT hres;

    AssertF( (uirim == RIM_TYPEMOUSE) || (uirim == RIM_TYPEKEYBOARD) );

    if( hwnd ) {
        ridOn[uirim].hwndTarget = hwnd;
    }

    if( RegisterRawInputDevices &&
        RegisterRawInputDevices(&ridOff[uirim], 1, sizeof(RAWINPUTDEVICE)) ) {
        SquirtSqflPtszV(sqfl, TEXT("UnregisterRawInputDevice: %s, hwnd: 0x%08lx"),
                            uirim==0 ? TEXT("mouse"):TEXT("keyboard"), hwnd);
        hres = S_OK;
    } else {
        hres = E_FAIL;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CDIRaw_ProcessInput |
 *
 *          Process raw input device data.
 *
 *  @parm   IN PRAWINPUT | pRawInput |
 *
 *          pointer to RAWINPUT data
 *
 *  @returns
 *
 *          void
 *
 *****************************************************************************/

void CDIRaw_ProcessInput(PRAWINPUT pRawInput)
{
    HANDLE hDevice = pRawInput->header.hDevice;

    if ( g_plts ) {
        if( g_plts->rglhs[LLTS_MSE].cHook && pRawInput->header.dwType == RIM_TYPEMOUSE )
        {
            DIMOUSESTATE_INT ms;
            RAWMOUSE        *prm = &pRawInput->data.mouse;

            memcpy(ms.rgbButtons, s_msEd.rgbButtons, cbX(ms.rgbButtons));

            if( prm->usFlags & MOUSE_MOVE_ABSOLUTE ) {
                if( s_fFirstRaw ) {
                    memcpy( &s_absrm, prm, sizeof(RAWMOUSE) );
                    s_fFirstRaw = FALSE;
                    return;
                } else {
                    RAWMOUSE rm;

                    memcpy( &rm, prm, sizeof(RAWMOUSE) );

                    prm->lLastX -= s_absrm.lLastX;
                    prm->lLastY -= s_absrm.lLastY;
                    if ( prm->usButtonFlags & RI_MOUSE_WHEEL ) {
                        prm->usButtonData -= s_absrm.usButtonData;
                    }

                    memcpy( &s_absrm, &rm, sizeof(RAWMOUSE) );
                }
            }

            ms.lX = prm->lLastX;
            ms.lY = prm->lLastY;
            if ( prm->usButtonFlags & RI_MOUSE_WHEEL ) {
                ms.lZ = (short)prm->usButtonData;
            } else {
                ms.lZ = 0;
            }

            if( prm->usButtonFlags & RI_MOUSE_LEFT_BUTTON_DOWN ) {
                ms.rgbButtons[0] = 0x80;
            } else if (prm->usButtonFlags & RI_MOUSE_LEFT_BUTTON_UP ) {
                ms.rgbButtons[0] = 0x00;
            }

            if( prm->usButtonFlags & RI_MOUSE_RIGHT_BUTTON_DOWN ) {
                ms.rgbButtons[1] = 0x80;
            } else if (prm->usButtonFlags & RI_MOUSE_RIGHT_BUTTON_UP) {
                ms.rgbButtons[1] = 0x00;
            }

            if( prm->usButtonFlags & RI_MOUSE_MIDDLE_BUTTON_DOWN ) {
                ms.rgbButtons[2] = 0x80;
            } else if( prm->usButtonFlags & RI_MOUSE_MIDDLE_BUTTON_UP ) {
                ms.rgbButtons[2] = 0x00;
            }

            if( prm->usButtonFlags & RI_MOUSE_BUTTON_4_DOWN ) {
                ms.rgbButtons[3] = 0x80;
            } else if( prm->usButtonFlags & RI_MOUSE_BUTTON_4_UP ) {
                ms.rgbButtons[3] = 0x00;
            }

            if( prm->usButtonFlags & RI_MOUSE_BUTTON_5_DOWN ) {
                ms.rgbButtons[4] = 0x80;
            } else if ( prm->usButtonFlags & RI_MOUSE_BUTTON_5_UP ) {
                ms.rgbButtons[4] = 0x00;
            }

            #if 0
            {
                char buf[128];
                static DWORD cnt = 0;

                wsprintfA(buf, "%d: x: %ld (%ld), y: %ld (%ld), z: %ld, rgb[0]: 0x%lx, rgb[4]: 0x%lx", cnt, prm->lLastX,ms.lX, prm->lLastY, ms.lY, (short)prm->usButtonData,*(DWORD *)ms.rgbButtons,*(DWORD *)&ms.rgbButtons[4]);
                RPF(buf);
                cnt++;
            }
            #endif

            CEm_Mouse_AddState(&ms, GetTickCount());

        } else
        if ( g_plts->rglhs[LLTS_KBD].cHook && pRawInput->header.dwType == RIM_TYPEKEYBOARD ) {
            RAWKEYBOARD *prk = &pRawInput->data.keyboard;
            BYTE bAction, bScan;
            static BOOL fE1 = FALSE;

            bAction = (prk->Flags & KEY_BREAK) ? 0 : 0x80;
            bScan   = (BYTE)prk->MakeCode;

            if( prk->Flags & KEY_E0 ) {
                if( bScan == 0x2A ) {  //special extra scancode when pressing PrtScn
                    return;
                } else {
                    bScan |= 0x80;
                }
            } else if( prk->Flags & KEY_E1 ) {  //special key: PAUSE
                fE1 = TRUE;

                // now, we need to bypass 0x1d key for compitibility with low level hook.
                if( bScan == 0x1d ) {
                    return;
                }
            }

            if( fE1 ) {
                // This is the work around for bug 288535.
                // But we really don't want to fix it in this way.
                //if( !bAction ) {
                //  Sleep(80);
                //}
                bScan |= 0x80;
                fE1 = FALSE;
            }

            AssertF(g_pbKbdXlat);
            if( bScan != 0x45 && bScan != 0xc5 ) {
                bScan = g_pbKbdXlat[bScan];
            }

            #if 0
            {
                char buf[128];
                static DWORD cnt = 0;
                
                wsprintfA(buf, "%d: bAction: 0x%lx, bScan: 0x%lx, Flags: 0x%lx, Make: 0x%lx", cnt, bAction, bScan, prk->Flags,prk->MakeCode);
                RPF(buf);
                cnt++;
            }
            #endif

            CEm_AddEvent(&s_edKbd, bAction, bScan, GetTickCount());
        }
    }

    return;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CDIRaw_OnInput |
 *
 *          WM_INPUT message handler used by CEm_LL_ThreadProc (in diem.c).
 *
 *  @parm   IN MSG * | pmsg |
 *
 *          pointer to MSG
 *
 *  @returns
 *
 *          TRUE = Successful
 *          FALSE = otherwise
 *
 *****************************************************************************/

BOOL CDIRaw_OnInput(MSG *pmsg)
{
    BOOL  fRtn = FALSE;
    HRAWINPUT hRawInput = (HRAWINPUT)pmsg->lParam;
    PRAWINPUT pRawInput;
    UINT cbSize;
    BYTE pbBuf[512];
    BOOL fMalloc;
    UINT uiRtn;

    //
    // Firstly, get the size of this Raw Input.
    //
    if ( (uiRtn = GetRawInputData(hRawInput, RID_INPUT, NULL, &cbSize, sizeof(RAWINPUTHEADER))) != 0) {
        return FALSE;
    }

    //
    // Allocate required memory.
    //
    if( cbSize < cbX(pbBuf) ) {
        pRawInput = (PRAWINPUT)pbBuf;
        fMalloc = FALSE;
    } else {
        pRawInput = (PRAWINPUT)malloc(cbSize);
        if (pRawInput == NULL) {
            RPF("Failed to allocate pRawInput\n");
            return FALSE;
        }
        fMalloc = TRUE;
    }

    //
    // Receive the content of the Raw Input.
    //
    if (GetRawInputData(hRawInput, RID_INPUT, pRawInput, &cbSize, sizeof(RAWINPUTHEADER)) > 0) {
        //
        // Call the handler of ours, to start/continue/stop drawing.
        //
        CDIRaw_ProcessInput(pRawInput);
    }

    // no longer needed.
    if( fMalloc ) {
        free(pRawInput);
        pRawInput = NULL;
    }

    return fRtn;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIRaw_Mouse_InitButtons |
 *
 *          Initialize the mouse state in preparation for acquisition.
 *
 *****************************************************************************/

HRESULT INTERNAL
CDIRaw_Mouse_InitButtons(void)
{
    if (s_edMouse.cAcquire < 0) {
        s_fFirstRaw = TRUE;
    }

    return S_OK;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   int | DIRaw_GetKeyboardType |
 *
 *          Return keyboard type (nTypeFlag==0) or subtype (nTypeFlag==1).
 *
 *****************************************************************************/

int EXTERNAL
DIRaw_GetKeyboardType(int nTypeFlag)
{
    PRAWINPUTDEVICELIST pList = NULL;
    UINT  uiNumDevices = 0;
    DWORD dwType;
    int   nResult = 0;

    if (GetRawInputDeviceList(NULL, &uiNumDevices, sizeof(RAWINPUTDEVICELIST)) == (UINT)-1) {
        SquirtSqflPtszV(sqfl, TEXT("DIRaw_GetKeyboardType: failed to get the number of devices."));
        goto _DIRAWGKT_EXIT;
    }

    if( uiNumDevices ) {
        pList = malloc(sizeof(RAWINPUTDEVICELIST) * uiNumDevices);
        if( !pList ) {
            SquirtSqflPtszV(sqfl, TEXT("DIRaw_GetKeyboardType: malloc failed."));
            goto _DIRAWGKT_EXIT;
        }
        
        if (GetRawInputDeviceList(pList, &uiNumDevices, sizeof(RAWINPUTDEVICELIST)) == (UINT)-1) {
            SquirtSqflPtszV(sqfl, TEXT("DIRaw_GetKeyboardType:  failed to get device list."));
            goto _DIRAWGKT_EXIT;
        } else {
            UINT  i;
            UINT  uiLen;
            UINT  cbSize;
            RID_DEVICE_INFO info;

            info.cbSize = sizeof(RID_DEVICE_INFO);

            for (i = 0; i<uiNumDevices; ++i) 
            {
                if (pList[i].dwType == RIM_TYPEKEYBOARD) 
                {
                    uiLen = 0;

                    // Get device name
                    if (GetRawInputDeviceInfo(pList[i].hDevice, RIDI_DEVICENAME, NULL, &uiLen)) {
                        continue;
                    }

                    // Get device type info.
                    cbSize = sizeof(RID_DEVICE_INFO);
                    if (GetRawInputDeviceInfo(pList[i].hDevice, RIDI_DEVICEINFO, &info, &cbSize) == (UINT)-1) {
                        continue;
                    }

                    if( nTypeFlag == 0 || nTypeFlag == 1)   //keyboard type or subtype
                    {
                        dwType = info.keyboard.dwType;
                        if( dwType == 4 || dwType == 7 || dwType == 8 ) {
                            nResult = (nTypeFlag==0) ? info.keyboard.dwType : info.keyboard.dwSubType;
                            break;
                        }
                    } else 
                    {
                        RPF("DIRaw_GetKeyboardType: wrong argument, %d is not supported.", nTypeFlag);
                    }
                }
            }
        }
    }

_DIRAWGKT_EXIT:
    if( pList ) {
        free(pList);
    }

    if( !nResult ) {
        nResult = GetKeyboardType(nTypeFlag);
    }

    SquirtSqflPtszV(sqfl, TEXT("DIRaw_GetKeyboardType: %s: %d"),
                          nTypeFlag==0 ? TEXT("type"):TEXT("sybtype"), nResult);
    
    return nResult;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\guids.c ===
/*****************************************************************************
 *
 *  guids.c
 *
 *  Copyright (c) 1998 - 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *****************************************************************************/

#define INITGUID
#include <dinputpr.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\diport.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       digsport.h
 *  Content:    DirectInput internal include file for HID
 *
 ***************************************************************************/


#ifndef __DIPORT_H
    #define __DIPORT_H

/* Forward define */
typedef struct _BUSDEVICE BUSDEVICE, *PBUSDEVICE;



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct BUS_REGDATA
 *          Persistent Data, written to the registry for each gameport device. 
 *          Contains information on how to reexpose the analog joystick device
 *          on reboot. 
 *
 *  @field  DWORD | dwSize |
 *          Size of the structure. 
 *
 *  @field  USHORT | uVID |
 *          Vendor ID.
 *
 *  @field  USHORT | uPID |
 *          Product ID.
 *
 *  @field  USHORT | nJoysticks |
 *          Number of joysticks attached to this gameport. 
 *
 *  @field  USHORT | nAxes |
 *          Number of axes in each joystick. 
 *
 *  @field  PVOID | hHardwareHandle |
 *          Hardware handle returned by EXPOSE IOCTL to gameenum.
 *          Needed to remove the joystick device. 
 *
 *  @field  BOOLEAN | fAttachOnReboot |
 *          Flag that is cleared when a device is exposed and set when 
 *          the device is found to be OK.  Used to prevent reloading 
 *          of a device that crashes immediately.
 *
 *  @field  JOYREGHWSSETTINGS | hws |
 *          Joystick Hardware settings. 
 *
 *  @field  WCHAR | wszHardwareId |
 *          PnP hardware ID for the joystick. 
 * 
 *****************************************************************************/

typedef struct _BUS_REGDATA
{
    /* Size of structure */
    DWORD               dwSize;
    /* VID PID for this device */
    USHORT              uVID;
    USHORT              uPID;
    /* Number of joysticks to expose */
    USHORT              nJoysticks;
    USHORT              nAxes;
    /* Hardware settings for joystick */
    PVOID               hHardware;
    /* Flag whether or not device should be re-exposed */
    BOOLEAN             fAttachOnReboot;
    /* Joystick Hardware settings */
    JOYREGHWSETTINGS    hws;
    DWORD               dwFlags1;
    /* An array of (zero terminated wide character
     * strings).  The array itself also null terminated
     */
    WCHAR   wszHardwareId[MAX_JOYSTRING];

} BUS_REGDATA, *PBUS_REGDATA;



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct BUSDEVICEINFO
 *          Data about each instance of bus devices ( gameport / serial port, etc .. )
 *
 *  @field  PBUSDEVICE | pBusDevice |
 *          Address of the BusDevice struct.
 *
 *  @field  PSP_DEVICE_INTERFACE_DETAIL_DATA | pdidd |
 *          Device interface detail data. 
 *
 *  @field  GUID | guid |
 *          Instance GUID for the device.
 *
 *  @field  int | idPort |
 *          Unique ID for the gameport. 
 *
 *  @field  int | idJoy |
 *          Id of one of the joysticks attached to this gameport. 
 *
 *  @field  HKEY | hk |
 *          Registry key that contains configuration information.
 *          Sadly, we must keep it open because there is no way to
 *          obtain the name of the key, and the only way to open the
 *          key is inside an enumeration.
 *
 *  @field  LPTSTR  | ptszId |
 *          Device path to access the gameport for read / write. 
 *
 *  @field  BOOL    | fAttached |
 *          True is device is attached.
 *
 *  @field  BOOL    | fDeleteIfNotConnected |
 *          Flag that indicates that the device should be deleted if it
 *          is not connected. 
 *
 *******************************************************************************/

typedef struct _BUSDEVICEINFO
{
    PBUSDEVICE pBusDevice;
    PSP_DEVICE_INTERFACE_DETAIL_DATA    pdidd;
    GUID                                guid;
    int                                 idPort;
    int                                 idJoy;
    HKEY                                hk;
    LPTSTR                              ptszId;
    BOOL                                fAttached;
    BOOL                                fDeleteIfNotConnected;
} BUSDEVICEINFO, *PBUSDEVICEINFO;


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct BUSDEVICELIST |
 *
 *          Records information about all the HID devices.
 *
 *  @field  int | cbdi |
 *
 *          Number of items in the list that are in use.
 *
 *  @field  int | cbdiAlloc |
 *
 *          Number of items allocated in the list.
 *
 *  @field  BUSDEVICEINFO | rgbdi[0] |
 *
 *          Variable-size array of device information structures.
 *
 *****************************************************************************/

typedef struct _BUSDEVICELIST
{
    int cgbi;
    int cgbiAlloc;
    BUSDEVICEINFO rgbdi[0];
} BUSDEVICELIST, *PBUSDEVICELIST;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct BUSDEVICE |
 *
 *          Data specific to each bus ( gameport / serialPort ).
 *
 *  @field  PBUSDEVICE | pbdl |
 *          List of devices on a bus. 
 *
 *  @field  PCGUID  | pcGuid |
 *          Device GUID for the bus. 
 *
 *  @field  DWORD   | tmLastRebuild |
 *          Last time the bus device list was rebuild. 
 *
 *  @field  const int | ioctl_EXPOSE |
 *          IOCTL to expose a device.
 *
 *  @field  const int | ioclt_REMOVE |
 *          IOCTL to remove a device. 
 *
 *  @field  const int | ioctl_DESC |
 *          IOCTL to obtain description of the bus.
 *
 *  @field  const int | ioctl_PARAMETERS |
 *
 *  @field  const int | ioctl_EXPOSE_SIBLING |
 *
 *  @field  const int | ioctl_REMOVE_SELF |
 *
 *  @field  const int | dw_IDS_STDPORT |
 *          index into the IDS String table for text associated with device.
 *
 *  @field  const int | dw_JOY_HWS_ISPORTBUS |
 *
 *****************************************************************************/

typedef struct _BUSDEVICE
{
    D(TCHAR wszBusType[MAX_PATH];)
    PBUSDEVICELIST pbdl;
    PCGUID pcGuid;
    DWORD tmLastRebuild;
    const int ioctl_EXPOSE;
    const int ioctl_REMOVE;
    const int ioctl_DESC;
    const int ioctl_PARAMETERS;
    const int ioctl_EXPOSE_SIBLING;
    const int ioctl_REMOVE_SELF;
    const int dwIDS_STDPORT;
    const int dwJOY_HWS_ISPORTBUS;
} BUSDEVICE, *PBUSDEVICE;

extern BUSDEVICE g_pBusDevice[];


    #define cbGdlCbdi(cbdi)         FIELD_OFFSET(BUSDEVICELIST, rgbdi[cbdi])

/*
 *  We choose our starting point at 2 devices, since most machines
 *  will have one gameport/serialport bus.
 *  The maximum number is chosen at randomn
 */

    #define cgbiMax                 32
    #define cgbiInit                2   // Most machines will have only one gameport bus, two serialports


    #define MAX_PORT_BUSES  16


PBUSDEVICEINFO INTERNAL
    pbdiFromphdi
    (
    IN PHIDDEVICEINFO phdi
    );

PHIDDEVICEINFO INTERNAL
    phdiFrompbdi
    (
    IN PBUSDEVICEINFO pbdi
    );

PBUSDEVICEINFO EXTERNAL
    pbdiFromJoyId
    (
    IN int idJoy
    );

PBUSDEVICEINFO EXTERNAL
    pbdiFromGUID
    (
    IN PCGUID pguid    
    );

HRESULT EXTERNAL
    DIBusDevice_Expose
    (
    IN HANDLE hf,
    IN OUT PBUS_REGDATA pRegData
    );


HRESULT INTERNAL
    DIBusDevice_Remove
    (
    IN PBUSDEVICEINFO  pbdi
    );


HRESULT INTERNAL
    DIBusDevice_SetRegData
    (
    IN HKEY hk,
    IN PBUS_REGDATA pRegData
    );


HRESULT INTERNAL
    DIBusDevice_GetRegData
    (
    IN HKEY hk,
    OUT PBUS_REGDATA pRegData
    );


BOOL INTERNAL
    DIBusDevice_BuildListEntry
    (
    HDEVINFO hdev,
    PSP_DEVICE_INTERFACE_DATA pdid,
    PBUSDEVICE pBusDevice
    );


void INTERNAL
    DIBus_EmptyList
    (
    PBUSDEVICELIST *ppbdl 
    );

void EXTERNAL
    DIBus_FreeMemory();

HRESULT EXTERNAL
    DIBus_InitId
    (
     PBUSDEVICELIST pbdl
    );


ULONG EXTERNAL
    DIBus_BuildList
    (
    IN BOOL fForce
    );

PBUSDEVICELIST EXTERNAL 
    pbdlFromGUID
    ( 
    IN PCGUID pcGuid 
    );

HRESULT EXTERNAL
    DIBusDevice_ExposeEx
    (
    IN PBUSDEVICELIST  pbdl,
    IN PBUS_REGDATA    pRegData
    );

HRESULT EXTERNAL
    DIBusDevice_GetTypeInfo
    (
        PCGUID guid,
        LPDIJOYTYPEINFO pjti,
        DWORD fl
    );

HRESULT EXTERNAL DIPort_SnapTypes(LPWSTR *ppwszz);

#endif /* __DIPORT_H */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\makefile.inc ===
$(O)\guids.obj: ..\guids.c
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$@" $(USECXX_FLAG) "$(MAKEDIR)\$**"
$(NP_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\disubcls.c ===
/*****************************************************************************
 *
 *  DISubCls.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      "Safe subclassing" code, stolen from comctl32.
 *
 *      Originally written by francish.  Stolen by raymondc.
 *
 *  Contents:
 *
 *      SetWindowSubclass
 *      GetWindowSubclass
 *      RemoveWindowSubclass
 *      DefSubclassProc
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflSubclass

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @topic  DirectInput Subclassing |
 *
 *
 * This module defines helper functions that make subclassing windows safe(er)
 * and easy(er).  The code maintains a single property on the subclassed window
 * and dispatches various "subclass callbacks" to its clients a required.  The
 * client is provided reference data and a simple "default processing" API.
 *
 * Semantics:
 *  A "subclass callback" is identified by a unique pairing of a callback
 * function pointer and an unsigned ID value.  Each callback can also store a
 * single DWORD of reference data, which is passed to the callback function
 * when it is called to filter messages.  No reference counting is performed
 * for the callback, it may repeatedly call the SetWindowSubclass API to alter
 * the value of its reference data element as desired.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct SUBCLASS_CALL |
 *
 *          Structure which tracks a single subclassing client.
 *
 *          Although a linked list would have made the code slightly
 *          simpler, this module uses a packed callback array to avoid
 *          unneccessary fragmentation.
 *
 *  @field  SUBCLASSPROC | pfnSubclass |
 *
 *          The subclass procedure.  If this is zero, it means that
 *          the node is dying and should be ignored.
 *
 *  @field  UINT | uIdSubclass |
 *
 *          Unique subclass identifier.
 *
 *  @field  DWORD | dwRefData |
 *
 *          Optional reference data for subclass procedure.
 *
 *****************************************************************************/

typedef struct SUBCLASS_CALL {
    SUBCLASSPROC    pfnSubclass;
    UINT_PTR        uIdSubclass;
    ULONG_PTR       dwRefData;
} SUBCLASS_CALL, *PSUBCLASS_CALL;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct SUBCLASS_FRAME |
 *
 *          Structure which tracks the state of an active call to the
 *          window's window procedure.
 *
 *          Each time the window procedure is entered, we create a new
 *          <t SUBCLASS_FRAME>, which remains active until the last
 *          subclass procedure returns, at which point the frame is
 *          torn down.
 *
 *          The subclass frames are stored on the stack.  So walking
 *          the frame chain causes you to wander through the stack.
 *
 *  @field  UINT | uCallIndex |
 *
 *          Index of next callback to call.
 *
 *  @field  UINT | uDeepestCall |
 *
 *          Deepest <e SUBCLASS_FRAME.uCallIndex> on the stack.
 *
 *  @field  SUBCLASS_FRAME * | pFramePrev |
 *
 *          The previous subclass frame.
 *
 *  @field  PSUBCLASS_HEADER | pHeader |
 *
 *          The header associated with this frame.
 *
 *****************************************************************************/

typedef struct SUBCLASS_FRAME {
    UINT uCallIndex;
    UINT uDeepestCall;
    struct SUBCLASS_FRAME *pFramePrev;
    struct SUBCLASS_HEADER *pHeader;
} SUBCLASS_FRAME, *PSUBCLASS_FRAME;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct SUBCLASS_HEADER |
 *
 *          Structure which tracks the subclass goo associated with
 *          a window.  A pointer to this structure is kept in a private
 *          window property.
 *
 *  @field  UINT | uRefs |
 *
 *          Subclass count.  This is the number of valid entries
 *          in the <p CallArray>.
 *
 *  @field  UINT | uAlloc |
 *
 *          Number of allocated <t SUBCLASS_CALL> nodes in the array.
 *
 *  @field  UINT | uCleanup |
 *
 *          Index of the call node to clean up.
 *
 *  @field  WORD | dwThreadId |
 *
 *          Thread id of the window with which the structure is associated.
 *
 *  @field  PSUBCLASS_FRAME | pFrameCur |
 *
 *          Pointer to the current subclass frame.
 *
 *  @field  SUBCLASS_CALL | CallArray[1] |
 *
 *          Base of the packed call node array.
 *
 *****************************************************************************/

typedef struct SUBCLASS_HEADER {
    UINT uRefs;
    UINT uAlloc;
    UINT uCleanup;
    DWORD dwThreadId;
    PSUBCLASS_FRAME pFrameCur;
    SUBCLASS_CALL CallArray[1];
} SUBCLASS_HEADER, *PSUBCLASS_HEADER;

#define CALLBACK_ALLOC_GRAIN (3)        /* 1 defproc, 1 subclass, 1 spare */

LRESULT CALLBACK
MasterSubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp);


LRESULT INTERNAL
CallNextSubclassProc(PSUBCLASS_HEADER pHeader, HWND hwnd, UINT wm,
                     WPARAM wp, LPARAM lp);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | SubclassDeath |
 *
 *          This function is called if we ever enter one of our subclassing
 *          procedures without our reference data (and hence without the
 *          previous <t WNDPROC>).
 *
 *          Hitting this represents a catastrophic failure in the
 *          subclass code.
 *
 *          The function resets the <t WNDPROC> of the window to
 *          <f DefWindowProc> to avoid faulting.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window that just got hosed.
 *
 *  @parm   UINT | wm |
 *
 *          Window message that caused us to realize that we are hosed.
 *
 *  @parm   WPARAM | wp |
 *
 *          Meaning depends on window message.
 *
 *  @parm   LPARAM | lp |
 *
 *          Meaning depends on window message.
 *
 *****************************************************************************/


LRESULT INTERNAL
SubclassDeath(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp)
{
    /*
     * WE SHOULD NEVER EVER GET HERE
     */
    // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
	SquirtSqflPtszV(sqfl | sqflError,
                    TEXT("Fatal! SubclassDeath in window %p"),
                    hwnd);
    AssertF(0);

    /*
     * We call the outside world, so we'd better not have the critsec.
     */
    AssertF(!InCrit());

    /*
     * In theory, we could save the original WNDPROC in a separate property,
     * but that just wastes memory for something that should never happen.
     */
#ifdef WINNT
    SetWindowLongPtr( hwnd, GWLP_WNDPROC, (LONG_PTR)(DefWindowProc));
#else
    SubclassWindow(hwnd, DefWindowProc);
#endif

    return DefWindowProc(hwnd, wm, wp, lp);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   WNDPROC | GetWindowProc |
 *
 *          Returns the <t WNDPROC> of the specified window.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window to be inspected.
 *
 *  @returns
 *
 *          The <t WNDPROC> of the specified window.
 *
 *****************************************************************************/

WNDPROC INLINE
GetWindowProc(HWND hwnd)
{
#ifdef WINNT
    return (WNDPROC)GetWindowLongPtr(hwnd, GWLP_WNDPROC);
#else
    return (WNDPROC)GetWindowLong(hwnd, GWL_WNDPROC);
#endif
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global ATOM | g_atmDISubclass |
 *
 *          This is the global <t ATOM> we use to store our
 *          <t SUBCLASS_HEADER> property on whatever windows come our way.
 *
 *          If the <p WIN95_HACK> symbol is defined, then we will work
 *          around a bug in Windows 95 where Windows "helpfully"
 *          <f GlobalDeleteAtom>'s all properties that are on a window
 *          when the window dies.  See Francis's original explanation
 *          in subclass.c.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

TCHAR c_tszDISubclass[] = TEXT("DirectInputSubclassInfo");

#pragma END_CONST_DATA

#ifdef WIN95_HACK
ATOM g_atmDISubclass;
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PSUBCLASS_HEADER | FastGetSubclassHeader |
 *
 *          Obtains the <t SUBCLASS_HEADER> for the specified window.
 *
 *          This function succeeds on any thread, although the value
 *          is meaningless from the wrong process.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @returns
 *
 *          Pointer to the <t SUBCLASS_HEADER> associated with the window,
 *          or <c NULL> if the window is not subclassed by us.
 *
 *****************************************************************************/

PSUBCLASS_HEADER INLINE
FastGetSubclassHeader(HWND hwnd)
{
#ifdef WIN95_HACK
    /*
     *  The right thing happens if g_atmDISubclass is 0, namely,
     *  the property is not found.  Unfortunately, NT RIPs when
     *  you do this, so we'll be polite and not RIP.
     */
    if (g_atmDISubclass) {
        return (PSUBCLASS_HEADER)GetProp(hWnd, (PV)g_atmDISubclass);
    } else {
        return 0;
    }
#else
    return (PSUBCLASS_HEADER)GetProp(hwnd, c_tszDISubclass);
#endif
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PSUBCLASS_HEADER | GetSubclassHeader |
 *
 *          Obtains the <t SUBCLASS_HEADER> for the specified window.
 *          It fails if the caller is in the wrong process, but will
 *          allow the caller to get the header from a different thread.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @returns
 *
 *          Pointer to the <t SUBCLASS_HEADER> associated with the window,
 *          or <c NULL> if the window is not subclass by us yet, or 1 
 *          if it belongs to another process.
 *
 *****************************************************************************/

PSUBCLASS_HEADER INTERNAL
GetSubclassHeader(HWND hwnd)
{
    DWORD idProcess;

    /*
     *  Make sure we're in the right process.
     *
     *  Must use our helper function to catch bad scenarios like
     *  the goofy Windows 95 console window which lies about its
     *  owner.
     */

    idProcess = GetWindowPid(hwnd);

    if (idProcess == GetCurrentProcessId()) {   /* In the right process */
        return FastGetSubclassHeader(hwnd);
    } else {
        if (idProcess) {
            // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
			SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("XxxWindowSubclass: ")
                            TEXT("wrong process for window %p"), hwnd);
        }
        return (PSUBCLASS_HEADER)1;
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | SetSubclassHeader |
 *
 *          Sets the <t SUBCLASS_HEADER> for the specified window.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @parm   PSUBCLASS_HEADER | pHeader |
 *
 *          The value to set.
 *
 *  @parm   PSUBCLASS_FRAME | pFrameFixup |
 *
 *          The active frames, which need to be walked and fixed up
 *          to refer to the new <t SUBCLASS_HEADER>.
 *
 *****************************************************************************/

BOOL INTERNAL
SetSubclassHeader(HWND hwnd, PSUBCLASS_HEADER pHeader,
                  PSUBCLASS_FRAME pFrameFixup)
{
    BOOL fRc;

    AssertF(InCrit());      /* We are partying on the header and frame list */

#ifdef WIN95_HACK
    if (g_atmDISubclass == 0) {
        ATOM atm;
        /*
         *  HACK: we are intentionally incrementing the refcount on this atom
         *  WE DO NOT WANT IT TO GO BACK DOWN so we will not delete it in
         *  process detach (see comments for g_atmDISubclass in subclass.c
         *  for more info).
         */
        atm = GlobalAddAtom(c_tszDISubclass);
        if (atm) {
            g_atmDISubclass = atm;  /* In case the old atom got nuked */
        }
    }
#endif

    /*
     *  Update the frame list if required.
     */
    while (pFrameFixup) {
        pFrameFixup->pHeader = pHeader;
        pFrameFixup = pFrameFixup->pFramePrev;
    }

    /*
     *  If we have a window to update, then update/remove the property
     *  as required.
     */
    if (hwnd) {
        if (!pHeader) {
#ifdef WIN95_HACK
            /*
             * HACK: we remove with an ATOM so the refcount won't drop
             *          (see comments for g_atmDISubclass above)
             */
            RemoveProp(hwnd, (PV)g_atmDISubclass);
#else
			// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
            SquirtSqflPtszV(sqfl, TEXT("SetSubclassHeader: Removing %p"),
                            pHeader);
            RemoveProp(hwnd, c_tszDISubclass);
#endif
            fRc = 1;
        } else {
#ifdef WIN95_HACK
            /*
             * HACK: we add using a STRING so the refcount will go up
             *          (see comments for g_atmDISubclass above)
             */
#endif
            // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
			SquirtSqflPtszV(sqfl, TEXT("SetSubclassHeader: Adding %p"),
                            pHeader);
            fRc = SetProp(hwnd, c_tszDISubclass, pHeader);
            if (!fRc) {
                // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
				SquirtSqflPtszV(sqfl | sqflError, TEXT("SetWindowSubclass: ")
                                TEXT("couldn't subclass window %p"), hwnd);
            }
        }
    } else {
        fRc = 1;                /* Weird vacuous success */
    }

    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | FreeSubclassHeader |
 *
 *          Toss the subclass header for the specified window.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @parm   PSUBCLASS_HEADER | pHeader |
 *
 *          The value being tossed.
 *
 *****************************************************************************/

void INTERNAL
FreeSubclassHeader(HWND hwnd, PSUBCLASS_HEADER pHeader)
{
    AssertF(InCrit());          /* we will be removing the subclass header */

    /*
     *  Sanity checking...
     */
    if (pHeader) {
        // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
		SquirtSqflPtszV(sqfl, TEXT("FreeSubclassHeader: Freeing %p"),
                        pHeader);
        SetSubclassHeader(hwnd, 0, pHeader->pFrameCur); /* Clean up the header */
        LocalFree(pHeader);
    } else {
        AssertF(0);
    }

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ReallocSubclassHeader |
 *
 *          Change the size of the subclass header as indicated.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @parm   PSUBCLASS_HEADER | pHeader |
 *
 *          The current header.
 *
 *  @parm   UINT | uCallbacks |
 *
 *          Desired size.
 *
 *****************************************************************************/

PSUBCLASS_HEADER INTERNAL
ReAllocSubclassHeader(HWND hwnd, PSUBCLASS_HEADER pHeader, UINT uCallbacks)
{
    UINT uAlloc;

    AssertF(InCrit());      /* we will be replacing the subclass header */

    /*
     *  Granularize the allocation.
     */
    uAlloc = CALLBACK_ALLOC_GRAIN *
        ((uCallbacks + CALLBACK_ALLOC_GRAIN - 1) / CALLBACK_ALLOC_GRAIN);

    /*
     *  Do we need to change the allocation?
     */
    if (!pHeader || (uAlloc != pHeader->uAlloc)) {
        /*
         * compute bytes required
         */
        uCallbacks = uAlloc * sizeof(SUBCLASS_CALL) + sizeof(SUBCLASS_HEADER);

        /*
         * And try to alloc / realloc.
         */
        if (SUCCEEDED(ReallocCbPpv(uCallbacks, &pHeader))) {
            /*
             * Update info.
             */
            pHeader->uAlloc = uAlloc;

            if (SetSubclassHeader(hwnd, pHeader, pHeader->pFrameCur)) {
            } else {
                FreeSubclassHeader(hwnd, pHeader);
                pHeader = 0;
            }
        } else {
            pHeader = 0;
        }
    }

    AssertF(pHeader);
    return pHeader;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | CallOriginalWndProc |
 *
 *          This procedure is the default <t SUBCLASSPROC> which is always
 *          installed when we subclass a window.  The original window
 *          procedure is installed as the reference data for this
 *          callback.  It simply calls the original <t WNDPROC> and
 *          returns its result.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @parm   UINT | wm |
 *
 *          Window message that needs to go to the original <t WNDPROC>.
 *
 *  @parm   WPARAM | wp |
 *
 *          Meaning depends on window message.
 *
 *  @parm   LPARAM | lp |
 *
 *          Meaning depends on window message.
 *
 *  @parm   UINT | uIdSubclass |
 *
 *          ID number (not used).
 *
 *  @parm   DWORD | dwRefData |
 *
 *          Reference data for subclass procedure (original <t WNDPROC>).
 *
 *****************************************************************************/

LRESULT CALLBACK
CallOriginalWndProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp,
                    UINT_PTR uIdSubclass, ULONG_PTR dwRefData)
{
    /*
     * dwRefData should be the original window procedure
     */
    AssertF(dwRefData);

    /*
     * and call it.
     */
    return CallWindowProc((WNDPROC)dwRefData, hwnd, wm, wp, lp);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PSUBCLASS_HEADER | AttachSubclassHeader |
 *
 *          This procedure makes sure that a given window is subclassed by us.
 *          It maintains a reference count on the data structures associated
 *          with our subclass.  if the window is not yet subclassed by us
 *          then this procedure installs our subclass procedure and
 *          associated data structures.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *****************************************************************************/

PSUBCLASS_HEADER INTERNAL
AttachSubclassHeader(HWND hwnd)
{
    PSUBCLASS_HEADER pHeader;

    /*
     *  We party on the subclass call chain here
     */
    AssertF(InCrit());

    /*
     *  Yes, we subclass the window out of context, but we are careful
     *  to avoid race conditions.  There is still a problem if some
     *  other DLL tries to un-subclass a window just as we are subclassing
     *  it.  But there's nothing you can do about it, and besides,
     *  what are the odds...?
     */

    /*
     * If haven't already subclassed the window then do it now
     */
    pHeader = GetSubclassHeader(hwnd);

    if( pHeader == (PSUBCLASS_HEADER)1 )
    {
        /*
         * It's all gone horribly wrong.
         * This can happen when the application uses joyXXX functions in Winmm.dll.
         */
        pHeader = 0;
    }
    else if (pHeader == 0) {
        /*
         * attach our header data to the window
         * we need space for two callbacks:
         * the subclass and the original proc
         */
        pHeader = ReAllocSubclassHeader(hwnd, 0, 2);
        if (pHeader) {
            SUBCLASS_CALL *pCall;

            /*
             *  Set up the first node in the array to call
             *  the original WNDPROC.  Do this before subclassing
             *  to avoid a race if the window receives a message
             *  after we have installed our subclass but before
             *  we can save the original WNDPROC.
             */
            AssertF(pHeader->uAlloc);

            pCall = pHeader->CallArray;
            pCall->pfnSubclass = CallOriginalWndProc;
            pCall->uIdSubclass = 0;
            pCall->dwRefData   = (ULONG_PTR)GetWindowProc(hwnd);

            /*
             * init our subclass refcount...
             */
            pHeader->uRefs = 1;

            pHeader->dwThreadId = GetWindowThreadProcessId(hwnd, NULL);

            /*
             *  Super-paranoid.  We must must not race with another
             *  instance of ourselves trying to un-subclass.
             */
            AssertF(InCrit());

            /*
             *  Save the new "old" wndproc in case we raced with
             *  somebody else trying to subclass.
             */
#ifdef WINNT
            pCall->dwRefData = (ULONG_PTR)SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)MasterSubclassProc);
#else
            pCall->dwRefData = (DWORD)SubclassWindow(hwnd, MasterSubclassProc);
#endif
            if (pCall->dwRefData) {
                DllLoadLibrary();   /* Make sure we don't get unloaded */
            } else {                /* clean up and get out */
                FreeSubclassHeader(hwnd, pHeader);
                pHeader = 0;
            }
        }
    }

    return pHeader;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DetachSubclassHeader |
 *
 *          This procedure attempts to detach the subclass header from
 *          the specified window.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @parm   PSUBCLASS_HEADER | pHeader |
 *
 *          Header to detach.
 *
 *  @parm   BOOL | fForce |
 *
 *          Nonzero if we should detach even if we are not the top-level
 *          subclass.
 *
 *****************************************************************************/

void INTERNAL
DetachSubclassHeader(HWND hwnd, PSUBCLASS_HEADER pHeader, BOOL fForce)
{
    WNDPROC wndprocOld;

    AssertF(InCrit());      /* we party on the subclass call chain here */
    AssertF(pHeader);       /* fear */

    /*
     *  If we are not being forced to remove and the window is still
     *  valid then sniff around a little and decide if it's a good
     *  idea to detach now.
     */
    if (!fForce && hwnd) {
        AssertF(pHeader == FastGetSubclassHeader(hwnd)); /* paranoia */

        /* should always have the "call original" node */
        AssertF(pHeader->uRefs);

        /*
         *  We can't have active clients.
         *  We can't have people still on our stack.
         */
        if (pHeader->uRefs <= 1 && !pHeader->pFrameCur) {

            /*
             *  We must be in the correct context.
             */
            if (pHeader->dwThreadId == GetCurrentThreadId()) {

                /*
                 *  We kept the original window procedure as refdata for our
                 *  CallOriginalWndProc subclass callback.
                 */
                wndprocOld = (WNDPROC)pHeader->CallArray[0].dwRefData;
                AssertF(wndprocOld);

                /*
                 *  Make sure we are the top of the subclass chain.
                 */
                if (GetWindowProc(hwnd) == MasterSubclassProc) {

                    /*
                     * go ahead and try to detach
                     */
#ifdef WINNT
                    if (SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)wndprocOld)) {
#else
                    if (SubclassWindow(hwnd, wndprocOld)) {
#endif
                        SquirtSqflPtszV(sqfl, TEXT("DetachSubclassHeader: ")
                                        TEXT("Unhooked"));
                    } else {
                        AssertF(0);         /* just plain shouldn't happen */
                        goto failed;
                    }
                } else {            /* Not at top of chain; can't do it */
                    SquirtSqflPtszV(sqfl, TEXT("DetachSubclassHeader: ")
                                    TEXT("Somebody else subclassed"));
                    goto failed;
                }
            } else {                /* Out of context. Try again later. */
                SendNotifyMessage(hwnd, WM_NULL, 0, 0L);
                goto failed;
            }
        } else {
			// 7/18/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
            SquirtSqflPtszV(sqfl, TEXT("DetachSubclassHeader: ")
                            TEXT("Still %d users, %p frame"),
                            pHeader->uRefs, pHeader->pFrameCur);
            goto failed;
        }
    }

#if 0
#ifdef DEBUG
    {
    /*
     * warn about anybody who hasn't unhooked yet
     */
    UINT uCur;    
    SUBCLASS_CALL *pCall;
    
    uCur = pHeader->uRefs;
    pCall = pHeader->CallArray + uCur;
    /* don't complain about our 'call original' node */
    while (--uCur) {
        pCall--;
        if (pCall->pfnSubclass) {
            /*
             * always warn about these they could be leaks
             */
            // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
			SquirtSqflPtszV(sqfl | sqflError, TEXT("warning: orphan subclass: ")
                            TEXT("fn %p, id %08x, dw %08x"),
                            pCall->pfnSubclass, pCall->uIdSubclass,
                            pCall->dwRefData);
        }
    }
    }
#endif
#endif
    /*
     * free the header now
     */
    FreeSubclassHeader(hwnd, pHeader);

    DllFreeLibrary();               /* Undo LoadLibrary when we hooked */


failed:;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | PurgeSingleCallNode |
 *
 *          Purges a single dead node in the call array.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @parm   PSUBCLASS_HEADER | pHeader |
 *
 *          The header associated with the window.
 *          The <p uCleanup> field is the index of the node being
 *          cleaned up.
 *
 *****************************************************************************/

void INTERNAL
PurgeSingleCallNode(HWND hwnd, PSUBCLASS_HEADER pHeader)
{

    AssertF(InCrit());      /* we will try to re-arrange the call array */

    if (pHeader->uCleanup) {/* Sanity check */
        UINT uRemain;

        SquirtSqflPtszV(sqfl,
                TEXT("PurgeSingleCallNode: Purging number %d"),
                pHeader->uCleanup);

        /*
         * and a little paranoia
         */
        AssertF(pHeader->CallArray[pHeader->uCleanup].pfnSubclass == 0);

        AssertF(fLimpFF(pHeader->pFrameCur,
                        pHeader->uCleanup < pHeader->pFrameCur->uDeepestCall));

        /*
         * are there any call nodes above the one we're about to remove?
         */
        uRemain = pHeader->uRefs - pHeader->uCleanup;
        if (uRemain > 0) {
            /*
             * yup, need to fix up the array the hard way
             */
            SUBCLASS_CALL *pCall;
            SUBCLASS_FRAME *pFrame;
            UINT uCur, uMax;

            /*
             * move the remaining nodes down into the empty space
             */
            pCall = pHeader->CallArray + pHeader->uCleanup;
            /*
             *  Since the souce and destination overlap (unless there's only 
             *  one node remaining) the behavior of memcpy is undefined.
             *  memmove (aka MoveMemory) would guarantee the correct 
             *  behavior but requires the runtime library.
             *  Since this is the only function we require in retail from the 
             *  RTL, it is not worth the 22% bloat we gain from using the 
             *  static version and using the dynamic version is a load time 
             *  and redist test hit.  So copy the array one element at a time.
             */
            for( uCur = 0; uCur < uRemain; uCur++ )
            {
                memcpy( &pCall[uCur], &pCall[uCur+1], sizeof(*pCall) );
            }

            /*
             * update the call indices of any active frames
             */
            uCur = pHeader->uCleanup;
            pFrame = pHeader->pFrameCur;
            while (pFrame) {
                if (pFrame->uCallIndex >= uCur) {
                    pFrame->uCallIndex--;

                    if (pFrame->uDeepestCall >= uCur) {
                        pFrame->uDeepestCall--;
                    }
                }

                pFrame = pFrame->pFramePrev;
            }

            /*
             * now search for any other dead call nodes in the remaining area
             */
            uMax = pHeader->uRefs - 1;  /* we haven't decremented uRefs yet */
            while (uCur < uMax && pCall->pfnSubclass)  {
                pCall++;
                uCur++;
            }
            pHeader->uCleanup = (uCur < uMax) ? uCur : 0;
        } else {
            /*
             * No call nodes above.  This case is easy.
             */
            pHeader->uCleanup = 0;
        }

        /*
         * finally, decrement the client count
         */
        pHeader->uRefs--;
        SquirtSqflPtszV(sqfl, TEXT("warning: PurgeSingleCallNode: ")
                        TEXT("Still %d refs"), pHeader->uRefs);

    } else {
        AssertF(0);         /* Nothing to do! */
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CompactSubclassHeader |
 *
 *          Attempts to compact the subclass array, freeing the
 *          subclass header if the array is empty.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @parm   PSUBCLASS_HEADER | pHeader |
 *
 *          The header associated with the window.
 *
 *****************************************************************************/

void INTERNAL
CompactSubclassHeader(HWND hwnd, PSUBCLASS_HEADER pHeader)
{
    AssertF(InCrit());      /* we will try to re-arrange the call array */

    /*
     * we must handle the "window destroyed unexpectedly during callback" case
     */
    if (hwnd) {
        /*
         *  Clean out as many dead callbacks as possible.
         *
         *  The "DeepestCall" test is an optimization so we don't go
         *  purging call nodes when no active frame cares.
         *
         *  (I'm not entirely conviced of this.  I mean, we have to
         *  purge it eventually anyway, right?)
         */
        while (pHeader->uCleanup &&
               fLimpFF(pHeader->pFrameCur,
                       pHeader->uCleanup < pHeader->pFrameCur->uDeepestCall)) {
            PurgeSingleCallNode(hwnd, pHeader);
        }

        /*
         * do we still have clients?
         */
        if (pHeader->uRefs > 1) {
            SquirtSqflPtszV(sqfl, TEXT("CompactSubclassHeader: ")
                            TEXT("Still %d users"), pHeader->uRefs);
            /*
             * yes, shrink our allocation, leaving room for at least one client
             */
            ReAllocSubclassHeader(hwnd, pHeader, pHeader->uRefs + 1);
            goto done;
        }
    }

    /*
     *  There are no clients left, or the window is gone.
     *  Try to detach and free
     */
    DetachSubclassHeader(hwnd, pHeader, FALSE);

done:;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PSUBCLASS_CALL | FindCallRecord |
 *
 *          Searches for a call record with the specified subclass proc
 *          and id, and returns its address.  If no such call record is
 *          found then NULL is returned.
 *
 *          This is a helper function used when we need to track down
 *          a callback because the client is changing its refdata or
 *          removing it.
 *
 *  @parm   PSUBCLASS_HEADER | pHeader |
 *
 *          The header in which to search.
 *
 *  @parm   SUBCLASSPROC | pfnSubclass |
 *
 *          Subclass callback procedure to locate.
 *
 *  @parm   UINT | uIdSubclass |
 *
 *          Instance identifier associated with the callback.
 *
 *****************************************************************************/

SUBCLASS_CALL * INTERNAL
FindCallRecord(PSUBCLASS_HEADER pHeader, SUBCLASSPROC pfnSubclass,
               UINT_PTR uIdSubclass)
{
    SUBCLASS_CALL *pCall;
    UINT uCallIndex;

    AssertF(InCrit());      /* we'll be scanning the call array */

    /*
     * scan the call array.  note that we assume there is always at least
     * one member in the table (our CallOriginalWndProc record)
     */
    uCallIndex = pHeader->uRefs;
    pCall = &pHeader->CallArray[uCallIndex];
    do {
        uCallIndex--;
        pCall--;
        if ((pCall->pfnSubclass == pfnSubclass) &&
            (pCall->uIdSubclass == uIdSubclass))
        {
            return pCall;
        }
    } while (uCallIndex != (UINT)-1);

    return NULL;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | GetWindowSubclass |
 *
 *          Retrieves the reference data for the specified window
 *          subclass callback.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @parm   SUBCLASSPROC | pfnSubclass |
 *
 *          Subclass callback procedure to locate.
 *
 *  @parm   UINT | uIdSubclass |
 *
 *          Instance identifier associated with the callback.
 *
 *  @parm   LPDWORD | pdwRefData |
 *
 *          Output pointer.
 *
 *****************************************************************************/

BOOL EXTERNAL
GetWindowSubclass(HWND hwnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass,
                  PULONG_PTR pdwRefData)
{
    BOOL fRc;
    ULONG_PTR dwRefData;

    DllEnterCrit();

    /*
     * sanity
     */
    if (IsWindow(hwnd) && pfnSubclass) {
        PSUBCLASS_HEADER pHeader;
        SUBCLASS_CALL *pCall;

        /*
         * if we've subclassed it and they are a client then get the refdata
         */
        pHeader = GetSubclassHeader(hwnd);
        if (pHeader &&
            (pHeader != (PSUBCLASS_HEADER)1) && 
            (pCall = FindCallRecord(pHeader, pfnSubclass, uIdSubclass)) != 0) {
            /*
             * fetch the refdata and note success
             */
            fRc = 1;
            dwRefData = pCall->dwRefData;
        } else {
            fRc = 0;
            dwRefData = 0;
        }

    } else {                            /* Invalid window handle */
        // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
		SquirtSqflPtszV(sqfl | sqflError, TEXT("GetWindowSubclass: ")
                        TEXT("Bad window %p or callback %p"),
                        hwnd, pfnSubclass);
        fRc = 0;
        dwRefData = 0;
    }

    /*
     * we always fill in/zero pdwRefData regradless of result
     */
    if (pdwRefData) {
        *pdwRefData = dwRefData;
    }

    DllLeaveCrit();

    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | SetWindowSubclass |
 *
 *          Installs/updates a window subclass callback.  Subclass
 *          callbacks are identified by their callback address and id pair.
 *          If the specified callback/id pair is not yet installed then
 *          the procedure installs the pair.  If the callback/id pair is
 *          already installed, then this procedure changes the reference
 *          data for the pair.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @parm   SUBCLASSPROC | pfnSubclass |
 *
 *          Subclass callback procedure to install or modify.
 *
 *  @parm   UINT | uIdSubclass |
 *
 *          Instance identifier associated with the callback.
 *
 *  @parm   DWORD | dwRefData |
 *
 *          Reference data to associate with the callback/id.
 *
 *****************************************************************************/

BOOL EXTERNAL
SetWindowSubclass(HWND hwnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass,
                  ULONG_PTR dwRefData)
{
    BOOL fRc;

    /*
     * sanity
     */
    if (IsWindow(hwnd) && pfnSubclass) {
        SUBCLASS_HEADER *pHeader;

        /*
         * we party on the subclass call chain here
         */
        DllEnterCrit();

        /*
         * actually subclass the window
         */
        /*
         *  Prefix gets confused (mb:34501) by this.  I assume this is because 
         *  AttachSubclassHeader returns a pointer to allocated memory but we 
         *  allow the pointer to go out of context without saving it.  This is 
         *  OK because AttachSubclassHeader already saved it for us.
         */
        pHeader = AttachSubclassHeader(hwnd);
        if (pHeader) {
            SUBCLASS_CALL *pCall;

            /*
             * find a call node for this caller
             */
            pCall = FindCallRecord(pHeader, pfnSubclass, uIdSubclass);
            if (pCall == NULL) {
                /*
                 * not found, alloc a new one
                 */
                SUBCLASS_HEADER *pHeaderT =
                    ReAllocSubclassHeader(hwnd, pHeader, pHeader->uRefs + 1);

                if (pHeaderT) {
                    pHeader = pHeaderT;
                    pCall = &pHeader->CallArray[pHeader->uRefs++];
                } else {
                    /*
                     * re-query in case it is already gone
                     */
                    pHeader = FastGetSubclassHeader(hwnd);
                    if (pHeader) {
                        CompactSubclassHeader(hwnd, pHeader);
                    }
                    goto bail;
                }

            }

            /*
             * fill in the subclass call data
             */
            pCall->pfnSubclass = pfnSubclass;
            pCall->uIdSubclass = uIdSubclass;
            pCall->dwRefData   = dwRefData;

            // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
			SquirtSqflPtszV(sqfl,
                    TEXT("SetWindowSubclass: Added %p/%d as %d"),
                    pfnSubclass, uIdSubclass, pHeader->uRefs - 1);

            fRc = 1;

        } else {                        /* Unable to subclass */
        bail:;
            fRc = 0;
        }
        DllLeaveCrit();
    } else {
        fRc = 0;                        /* Invalid parameter */
    }

    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | RemoveWindowSubclass |
 *
 *          Removes a subclass callback from a window.
 *          Subclass callbacks are identified by their
 *          callback address and id pair.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @parm   SUBCLASSPROC | pfnSubclass |
 *
 *          Subclass callback procedure to remove.
 *
 *  @parm   UINT | uIdSubclass |
 *
 *          Instance identifier associated with the callback.
 *
 *****************************************************************************/

BOOL EXTERNAL
RemoveWindowSubclass(HWND hwnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass)
{
    BOOL fRc;

    /*
     * sanity
     */
    if (IsWindow(hwnd) && pfnSubclass) {
        SUBCLASS_HEADER *pHeader;

        /*
         * we party on the subclass call chain here
         */
        DllEnterCrit();

        /*
         * obtain our subclass data and find the callback to remove.
         */
        pHeader = GetSubclassHeader(hwnd);
        if (pHeader && (pHeader != (PSUBCLASS_HEADER)1) ) {
            SUBCLASS_CALL *pCall;

            /*
             * find the callback to remove
             */
            pCall = FindCallRecord(pHeader, pfnSubclass, uIdSubclass);

            if (pCall) {
                UINT uCall;

                /*
                 *  disable this node.
                 */
                pCall->pfnSubclass = 0;

                /*
                 *  Remember that we have something to clean up.
                 *
                 *  Set uCleanup to the index of the shallowest node that
                 *  needs to be cleaned up.  CompactSubclassHeader will
                 *  clean up everything from uCleanup onward.
                 */

                uCall = (UINT)(pCall - pHeader->CallArray);
                if (fLimpFF(pHeader->uCleanup, uCall < pHeader->uCleanup)) {
                    pHeader->uCleanup = uCall;
                }

                // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
				SquirtSqflPtszV(sqfl,
                        TEXT("RemoveWindowSubclass: Removing %p/%d as %d"),
                        pfnSubclass, uIdSubclass, uCall);

                /*
                 * now try to clean up any unused nodes
                 */
                CompactSubclassHeader(hwnd, pHeader);

                /*
                 * the call above can realloc or free the subclass
                 * header for this window, so make sure we don't use it.
                 */
                D(pHeader = 0);

                fRc = 1;

            } else {                /* Not found */
                fRc = 0;
            }
        } else {                    /* Never subclassed (ergo not found) */
            fRc = 0;
        }

        /*
         * release the critical section and return the result
         */
        DllLeaveCrit();
    } else {
        fRc = 0;                    /* Validation failed */
    }
    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | DefSubclassProc |
 *
 *          Calls the next handler in the window's subclass chain.
 *          The last handler in the subclass chain is installed by us,
 *          and calls the original window procedure for the window.
 *
 *          Every subclass procedure should call <f DefSubclassProc>
 *          in order to allow the message to be processed by other handlers.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @parm   UINT | wm |
 *
 *          Window message that needs to go to the original <t WNDPROC>.
 *
 *  @parm   WPARAM | wp |
 *
 *          Meaning depends on window message.
 *
 *  @parm   LPARAM | lp |
 *
 *          Meaning depends on window message.
 *
 *****************************************************************************/

LRESULT EXTERNAL
DefSubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp)
{
    LRESULT lResult;

    /*
     * make sure the window is still valid
     */
    if (IsWindow(hwnd)) {
        PSUBCLASS_HEADER pHeader;

        /*
         * take the critical section while we figure out who to call next
         */
        AssertF(!InCrit());
        DllEnterCrit();

        /*
         * complain if we are being called improperly
         */
        pHeader = FastGetSubclassHeader(hwnd);
        if (pHeader &&
            pHeader->pFrameCur &&
            GetCurrentThreadId() == pHeader->dwThreadId) {

            /*
             * call the next proc in the subclass chain
             *
             * WARNING: this call temporarily releases the critical section
             * WARNING: pHeader is invalid when this call returns
             */
            lResult = CallNextSubclassProc(pHeader, hwnd, wm, wp, lp);
            D(pHeader = 0);

        } else {
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("DefSubclassProc: Called improperly"));
            lResult = 0;
        }
        DllLeaveCrit();

    } else {
        // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
		SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("DefSubclassProc: %P not a window"),
                        hwnd);
        lResult = 0;
    }

    return lResult;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | UpdateDeepestCall |
 *
 *          Updates the deepest call index for the specified frame.
 *
 *  @parm   PSUBCLASS_FRAME | pFrame |
 *
 *          Frame in question.
 *
 *****************************************************************************/

void INTERNAL
UpdateDeepestCall(SUBCLASS_FRAME *pFrame)
{
    AssertF(InCrit());  /* we are partying on the frame list */

    /*
     *  My deepest call equals my current call or my parent's
     *  deepest call, whichever is deeper.
     */
    if (pFrame->pFramePrev &&
        (pFrame->pFramePrev->uDeepestCall < pFrame->uCallIndex)) {
        pFrame->uDeepestCall = pFrame->pFramePrev->uDeepestCall;
    } else {
        pFrame->uDeepestCall = pFrame->uCallIndex;
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | EnterSubclassFrame |
 *
 *          Sets up a new subclass frame for the specified header,
 *          saving away the previous one.
 *
 *  @parm   PSUBCLASS_HEADER | pHeader |
 *
 *          Header in question.
 *
 *  @parm   PSUBCLASS_FRAME | pFrame |
 *
 *          Brand new frame to link in.
 *
 *****************************************************************************/

void INLINE
EnterSubclassFrame(PSUBCLASS_HEADER pHeader, SUBCLASS_FRAME *pFrame)
{
    AssertF(InCrit());  /* we are partying on the header and frame list */

    /*
     * fill in the frame and link it into the header
     */
    pFrame->uCallIndex   = pHeader->uRefs + 1;
    pFrame->pFramePrev   = pHeader->pFrameCur;
    pFrame->pHeader      = pHeader;
    pHeader->pFrameCur   = pFrame;

    /*
     * initialize the deepest call index for this frame
     */
    UpdateDeepestCall(pFrame);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | LeaveSubclassFrame |
 *
 *          Tear down the current subclass frame, restoring the previous one.
 *
 *  @parm   PSUBCLASS_FRAME | pFrame |
 *
 *          Frame going away.
 *
 *****************************************************************************/

PSUBCLASS_HEADER INLINE
LeaveSubclassFrame(SUBCLASS_FRAME *pFrame)
{
    PSUBCLASS_HEADER pHeader;

    AssertF(InCrit());  /* we are partying on the header */

    /*
     * unlink the frame from its header (if it still exists)
     */
    pHeader = pFrame->pHeader;
    if (pHeader) {
        pHeader->pFrameCur = pFrame->pFramePrev;
    }

    return pHeader;
}

#ifdef SUBCLASS_HANDLEEXCEPTIONS

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | SubclassFrameException |
 *
 *          Clean up when a exception is thrown from a subclass frame.
 *
 *  @parm   PSUBCLASS_FRAME | pFrame |
 *
 *          Frame to clean up.
 *
 *****************************************************************************/

void INTERNAL
SubclassFrameException(SUBCLASS_FRAME *pFrame)
{
    /*
     * clean up the current subclass frame
     */
    AssertF(!InCrit());
    DllEnterCrit();

    SquirtSqflPtszV(sqfl | sqflError, TEXT("SubclassFrameException: ")
                    TEXT("cleaning up subclass frame after exception"));
    LeaveSubclassFrame(pFrame);
    DllLeaveCrit();
}

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | MasterSubclassProc |
 *
 *          The window procedure we install to dispatch subclass
 *          callbacks.
 *
 *          It maintains a linked list of "frames" through the stack
 *          which allow <f DefSubclassProc> to call the right subclass
 *          procedure in multiple-message scenarios.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window under attack.
 *
 *  @parm   UINT | wm |
 *
 *          Window message.
 *
 *  @parm   WPARAM | wp |
 *
 *          Meaning depends on window message.
 *
 *  @parm   LPARAM | lp |
 *
 *          Meaning depends on window message.
 *
 *****************************************************************************/

LRESULT CALLBACK
MasterSubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp)
{
    SUBCLASS_HEADER *pHeader;
    LRESULT lResult;

    /*
     * prevent people from partying on the callback chain while we look at it
     */
    AssertF(!InCrit());
    DllEnterCrit();

    /*
     * We'd better have our data.
     */
    pHeader = FastGetSubclassHeader(hwnd);
    if (pHeader) {
        SUBCLASS_FRAME Frame;

        /*
         * set up a new subclass frame and save away the previous one
         */
        EnterSubclassFrame(pHeader, &Frame);

#ifdef SUBCLASS_HANDLEEXCEPTIONS
        __try    /* protect our state information from exceptions */
#endif
        {
            /*
             * go ahead and call the subclass chain on this frame
             *
             * WARNING: this call temporarily releases the critical section
             * WARNING: pHeader is invalid when this call returns
             */
            lResult =
                CallNextSubclassProc(pHeader, hwnd, wm, wp, lp);
            D(pHeader = 0);
        }
#ifdef SUBCLASS_HANDLEEXCEPTIONS
        __except (SubclassFrameException(&Frame), EXCEPTION_CONTINUE_SEARCH)
        {
            AssertF(0);
        }
#endif

        AssertF(InCrit());

        /*
         * restore the previous subclass frame
         */
        pHeader = LeaveSubclassFrame(&Frame);

        /*
         *  Do postprocessing if the header is still here.
         */
        if (pHeader) {

            /*
             *  was the window nuked (somehow)
             *  without us seeing the WM_NCDESTROY?
             */
            if (!IsWindow(hwnd)) {
                /*
                 * EVIL! somebody subclassed after us and didn't pass on WM_NCDESTROY
                 */
                AssertF(!TEXT("unknown subclass proc swallowed a WM_NCDESTROY"));

                /* go ahead and clean up now */
                hwnd = 0;
                wm = WM_NCDESTROY;
            }

            /*
             * if we are returning from a WM_NCDESTROY then we need to clean up
             */
            if (wm == WM_NCDESTROY) {
                DetachSubclassHeader(hwnd, pHeader, TRUE);
            } else {

                /*
                 * is there any pending cleanup, or are all our clients gone?
                 */
                if (pHeader->uCleanup ||
                    (!pHeader->pFrameCur && (pHeader->uRefs <= 1))) {
                    CompactSubclassHeader(hwnd, pHeader);
                    D(pHeader = 0);
                }
            }

            /*
             * all done
             */

        } else {
            /*
             *  Header is gone.  We already cleaned up in a nested frame.
             */
        }
        DllLeaveCrit();
        AssertF(!InCrit());

    } else {                            /* Our property vanished! */
        DllLeaveCrit();
        lResult = SubclassDeath(hwnd, wm, wp, lp);
    }

    return lResult;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   UINT | EnterSubclassCallback |
 *
 *          Finds the next callback in the subclass chain and updates
 *          <p pFrame> to indicate that we are calling it.
 *
 *  @parm   PSUBCLASS_HEADER | pHeader |
 *
 *          Controlling header.
 *
 *  @parm   PSUBCLASS_FRAME | pFrame |
 *
 *          Frame to update.
 *
 *  @parm   SUBCLASS_CALL * | pCallChosen |
 *
 *          The call selected for calling.
 *
 *****************************************************************************/

UINT INTERNAL
EnterSubclassCallback(PSUBCLASS_HEADER pHeader, SUBCLASS_FRAME *pFrame,
                      SUBCLASS_CALL *pCallChosen)
{
    SUBCLASS_CALL *pCall;
    UINT uDepth;

    /*
     * we will be scanning the subclass chain and updating frame data
     */
    AssertF(InCrit());

    /*
     * scan the subclass chain for the next callable subclass callback
     * Assert that the loop will terminate.
     */
    AssertF(pHeader->CallArray[0].pfnSubclass);
    pCall = pHeader->CallArray + pFrame->uCallIndex;
    uDepth = 0;
    do {
        uDepth++;
        pCall--;

    } while (!pCall->pfnSubclass);

    /*
     * copy the callback information for the caller
     */
    pCallChosen->pfnSubclass = pCall->pfnSubclass;
    pCallChosen->uIdSubclass = pCall->uIdSubclass;
    pCallChosen->dwRefData   = pCall->dwRefData;

    /*
     * adjust the frame's call index by the depth we entered
     */
    pFrame->uCallIndex -= uDepth;

    /*
     * keep the deepest call index up to date
     */
    UpdateDeepestCall(pFrame);

    return uDepth;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | LeaveSubclassCallback |
 *
 *          Get out one level.
 *
 *  @parm   PSUBCLASS_FRAME | pFrame |
 *
 *          Frame to update.
 *
 *  @parm   UINT | uDepth |
 *
 *          Who just finished.
 *
 *****************************************************************************/

void INLINE
LeaveSubclassCallback(SUBCLASS_FRAME *pFrame, UINT uDepth)
{
    /*
     * we will be updating subclass frame data
     */
     AssertF(InCrit());

    /*
     * adjust the frame's call index by the depth we entered and return
     */
    pFrame->uCallIndex += uDepth;

    /*
     * keep the deepest call index up to date
     */
    UpdateDeepestCall(pFrame);
}

#ifdef SUBCLASS_HANDLEEXCEPTIONS

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | SubclassCallbackException |
 *
 *          Clean up when a subclass callback throws an exception.
 *
 *  @parm   PSUBCLASS_FRAME | pFrame |
 *
 *          Frame to clean up.
 *
 *  @parm   UINT | uDepth |
 *
 *          Where we were.
 *
 *****************************************************************************/

void INTERNAL
SubclassCallbackException(SUBCLASS_FRAME *pFrame, UINT uDepth)
{
    /*
     * clean up the current subclass callback
     */
    AssertF(!InCrit());
    DllEnterCrit();
    SquirtSqflPtszV(sqfl | sqflError, TEXT("SubclassCallbackException: ")
                    TEXT("cleaning up subclass callback after exception"));
    LeaveSubclassCallback(pFrame, uDepth);
    DllLeaveCrit();
}

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | CallNextSubclassProc |
 *
 *          Calls the next subclass callback in the subclass chain.
 *
 *          WARNING: this call temporarily releases the critical section.
 *
 *          WARNING: <p pHeader> is invalid when this call returns.
 *
 *  @parm   PSUBCLASS_HEADER | pHeader |
 *
 *          The header that is tracking the state.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window under attack.
 *
 *  @parm   UINT | wm |
 *
 *          Window message.
 *
 *  @parm   WPARAM | wp |
 *
 *          Meaning depends on window message.
 *
 *  @parm   LPARAM | lp |
 *
 *          Meaning depends on window message.
 *
 *****************************************************************************/

LRESULT INTERNAL
CallNextSubclassProc(PSUBCLASS_HEADER pHeader, HWND hwnd, UINT wm,
                     WPARAM wp, LPARAM lp)
{
    SUBCLASS_CALL Call;
    SUBCLASS_FRAME *pFrame;
    LRESULT lResult;
    UINT uDepth;

    AssertF(InCrit());  /* sanity */
    AssertF(pHeader);   /* paranoia */

    /*
     * get the current subclass frame
     */
    pFrame = pHeader->pFrameCur;
    AssertF(pFrame);

    /*
     * get the next subclass call we need to make
     */
    uDepth = EnterSubclassCallback(pHeader, pFrame, &Call);

    /*
     * leave the critical section so we don't deadlock in our callback
     *
     * WARNING: pHeader is invalid when this call returns
     */
    DllLeaveCrit();
    D(pHeader = 0);

    /*
     * we call the outside world so prepare to deadlock if we have the critsec
     */
    AssertF(!InCrit());

#ifdef SUBCLASS_HANDLEEXCEPTIONS
    __try    /* protect our state information from exceptions */
#endif
    {
        /*
         * call the chosen subclass proc
         */
        AssertF(Call.pfnSubclass);

        lResult = Call.pfnSubclass(hwnd, wm, wp, lp,
                                   Call.uIdSubclass, Call.dwRefData);
    }
#ifdef SUBCLASS_HANDLEEXCEPTIONS
    __except (SubclassCallbackException(pFrame, uDepth),
        EXCEPTION_CONTINUE_SEARCH)
    {
        AssertF(0);
    }
#endif

    /*
     * we left the critical section before calling out so re-enter it
     */
    AssertF(!InCrit());
    DllEnterCrit();

    /*
     * finally, clean up and return
     */
    LeaveSubclassCallback(pFrame, uDepth);
    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\bc9x\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\dithunk.c ===
/*****************************************************************************
 *
 *  DiThunk.c
 *
 *  Copyright (c) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Template thunks for Windows 95 device manager.
 *
 *  Contents:
 *
 *      Thunk_Init
 *      Thunk_Term
 *
 *****************************************************************************/

#include "dinputpr.h"
#include "dithunk.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflThunk


KERNELPROCADDR g_kpa;

#pragma BEGIN_CONST_DATA

/*
 *  Careful!  This must match KERNELPROCADDR ...
 */
static LPCSTR c_rgpszKernel32[] = {
    (LPVOID) 35,            /* LoadLibrary16 */
    (LPVOID) 36,            /* FreeLibrary16 */
    (LPVOID) 37,            /* GetProcAddress16 */

    "MapLS",
    "UnMapLS",
    "MapSL",
    "MapSLFix",
    "UnMapSLFixArray",
    "QT_Thunk",
};

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | TemplateThunk |
 *
 *          Call down, passing all sorts of random parameters.
 *
 *          Parameter signature is as follows:
 *
 *          p = 0:32 pointer to convert to 16:16 pointer
 *
 *          l = a 32-bit integer
 *
 *          s = a 16-bit integer
 *
 *
 *          P = returns a pointer
 *
 *          L = returns a 32-bit integer
 *
 *          S = returns a 16-bit signed integer
 *
 *          U = returns a 16-bit unsigned integer
 *
 ***************************************************************************/

#pragma warning(disable:4035)           /* no return value (duh) */

#ifdef WIN95
#ifdef SLOW_BUT_READABLE

__declspec(naked) int
TemplateThunk(FARPROC fp, PCSTR pszSig, ...)
{
    BYTE rgbThunk[60];          /* For private use of QT_Thunk */
    LPVOID *ppvArg;
    int i;
    LPVOID pv;
    int iRc;

    __asm {

        /* Function prologue */
        push    ebp;
        mov     ebp, esp;
        sub     esp, __LOCAL_SIZE;
        push    ebx;
        push    edi;
        push    esi;

    }

    /* Thunk all the parameters according to the signature */
    ppvArg = (LPVOID)(&pszSig+1);
    for (i = 0; ; i++) {
        pv = ppvArg[i];
        switch (pszSig[i]) {
        case 'p':
            pv = ppvArg[i] = MapLS(pv);
            __asm push pv;
            break;

        case 'l':
            __asm push pv;
            break;

        case 's':
            __asm mov eax, pv;
            __asm push ax;
            break;

        default: goto doneThunk;
        }
    }

doneThunk:;

    /* Call the 16:16 procedure */
    __asm {
        mov     edx, fp;
        mov     ebx, ebp;
        lea     ebp, rgbThunk+64;               /* Required by QT_Thunk */
    }
        g_kpa.QT_Thunk();
    __asm {
        mov     ebp, ebx;
        shl     eax, 16;                        /* Convert DX:AX to EAX */
        shrd    eax, edx, 16;
        mov     iRc, eax;
    }

    /* Now unthunk the parameters */
    ppvArg = (LPVOID)(&pszSig+1);
    for (i = 0; ; i++) {
        switch (pszSig[i]) {
        case 'p':
            UnMapLS(ppvArg[i]);
            break;

        case 'l':
        case 's':
            break;

        default: goto doneUnthunk;
        }
    }

doneUnthunk:;

    /* Thunk the return value */
    switch (pszSig[i]) {
    case 'L':
        break;

    case 'U':
        iRc = LOWORD(iRc);
        break;

    case 'S':
        iRc = (short)iRc;
        break;

    case 'P':
        iRc = (int)MapSL((LPVOID)iRc);
        break;
    }

    __asm {
        mov     eax, iRc;
        pop     esi;
        pop     edi;
        pop     ebx;
        mov     esp, ebp;
        pop     ebp;
        ret;
    }
}

#else               /* Fast but illegible */

__declspec(naked) int
TemplateThunk(FARPROC fp, PCSTR pszSig, ...)
{
    __asm {

        /* Function prologue */
        push    ebp;
        mov     ebp, esp;
        sub     esp, 60;                /* QT_Thunk needs 60 bytes */
        push    ebx;
        push    edi;
        push    esi;

        /* Thunk all the parameters according to the signature */

        lea     esi, pszSig+4;          /* esi -> next arg */
        mov     ebx, pszSig;            /* ebx -> signature string */
thunkLoop:;
        mov     al, [ebx];
        inc     ebx;                    /* al = pszSig++ */
        cmp     al, 'p';                /* Q: Pointer? */
        jz      thunkPtr;               /* Y: Do the pointer */
        cmp     al, 'l';                /* Q: Long? */
        jz      thunkLong;              /* Y: Do the long */
        cmp     al, 's';                /* Q: Short? */
        jnz     thunkDone;              /* N: Done */

                                        /* Y: Do the short */
        lodsd;                          /* eax = *ppvArg++ */
        push    ax;                     /* Push the short */
        jmp     thunkLoop;

thunkPtr:
        lodsd;                          /* eax = *ppvArg++ */
        push    eax;
        call    dword ptr g_kpa.MapLS;  /* Map it */
        mov     [esi][-4], eax;         /* Save it for unmapping */
        push    eax;
        jmp     thunkLoop;

thunkLong:
        lodsd;                          /* eax = *ppvArg++ */
        push    eax;
        jmp     thunkLoop;
thunkDone:

        /* Call the 16:16 procedure */

        mov     edx, fp;
        call    dword ptr g_kpa.QT_Thunk;
        shl     eax, 16;                /* Convert DX:AX to EDX */
        shld    edx, eax, 16;

        /* Translate the return code according to the signature */

        mov     al, [ebx][-1];          /* Get return code type */
        cmp     al, 'P';                /* Pointer? */
        jz      retvalPtr;              /* Y: Do the pointer */
        cmp     al, 'S';                /* Signed? */
        jz      retvalSigned;           /* Y: Do the signed short */
        cmp     al, 'U';                /* Unsigned? */
        mov     edi, edx;               /* Assume long or void */
        jnz     retvalOk;               /* N: Then long or void */

        movzx   edi, dx;                /* Sign-extend short */
        jmp     retvalOk;

retvalPtr:
        push    edx;                    /* Pointer */
        call    dword ptr g_kpa.MapSL;  /* Map it up */
        jmp     retvalOk;

retvalSigned:                           /* Signed */
        movsx   edi, dx;                /* Sign-extend short */
        jmp     retvalOk;

retvalOk:                               /* Return value in EDI */

        /* Now unthunk the parameters */

        lea     esi, pszSig+4;          /* esi -> next arg */
        mov     ebx, pszSig;            /* ebx -> signature string */
unthunkLoop:;
        mov     al, [ebx];
        inc     ebx;                    /* al = pszSig++ */
        cmp     al, 'p';                /* Pointer? */
        jz      unthunkPtr;             /* Y: Do the pointer */
        cmp     al, 'l';                /* Long? */
        jz      unthunkSkip;            /* Y: Skip it */
        cmp     al, 's';                /* Short? */
        jnz     unthunkDone;            /* N: Done */
unthunkSkip:
        lodsd;                          /* eax = *ppvArg++ */
        jmp     unthunkLoop;

unthunkPtr:
        lodsd;                          /* eax = *ppvArg++ */
        push    eax;
        call    dword ptr g_kpa.UnMapLS;/* Unmap it */
        jmp     unthunkLoop;

unthunkDone:

        /* Done */

        mov     eax, edi;
        pop     esi;
        pop     edi;
        pop     ebx;
        mov     esp, ebp;
        pop     ebp;
        ret;
    }
}

#endif

#else // Not X86
int __cdecl TemplateThunk(FARPROC fp, PCSTR pszSig, ...)
{
    return 0;
}
#endif

#pragma BEGIN_CONST_DATA

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   FARPROC | GetProcOrd |
 *
 *          GetProcAddress on a DLL by ordinal.
 *
 *          Win95 does not let you GetProcAddress on KERNEL32 by ordinal,
 *          so we need to do it the evil way.
 *
 *  @parm   HINSTANCE | hinstDll |
 *
 *          The instance handle of the DLL we want to get the ordinal
 *          from.  The only DLL you need to use this function for is
 *          KERNEL32.
 *
 *  @parm   UINT | ord |
 *
 *          The ordinal you want to retrieve.
 *
 ***************************************************************************/

#define poteExp(pinth) (&(pinth)->OptionalHeader. \
                          DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT])

FARPROC NTAPI
GetProcOrd(HINSTANCE hinstDll, UINT ord)
{
    FARPROC fp;

    /*
     *  Make sure the MZ header is good.
     */

    PIMAGE_DOS_HEADER pidh = (LPVOID)hinstDll;
    if (!IsBadReadPtr(pidh, sizeof(*pidh)) &&
        pidh->e_magic == IMAGE_DOS_SIGNATURE) {

        /*
         *  Make sure the PE header is good.
         */
        PIMAGE_NT_HEADERS pinth = pvAddPvCb(pidh, pidh->e_lfanew);
        if (!IsBadReadPtr(pinth, sizeof(*pinth)) &&
            pinth->Signature == IMAGE_NT_SIGNATURE) {

            /*
             *  Make sure the export table is good and the ordinal
             *  is within range.
             */
            PIMAGE_EXPORT_DIRECTORY pedt =
                              pvAddPvCb(pidh, poteExp(pinth)->VirtualAddress);
            if (!IsBadReadPtr(pedt, sizeof(*pedt)) &&
                (ord - pedt->Base) < pedt->NumberOfFunctions) {

                PDWORD peat = pvAddPvCb(pidh, (DWORD)pedt->AddressOfFunctions);
                fp = (FARPROC)pvAddPvCb(pidh, peat[ord - pedt->Base]);
                if ((DWORD)cbSubPvPv(fp, peat) >= poteExp(pinth)->Size) {
                    /* fp is valid */
                } else {                /* Note: We don't support forwarding */
                    fp = 0;
                }
            } else {
                fp = 0;
            }
        } else {
            fp = 0;
        }
    } else {
        fp = 0;
    }

    return fp;
}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | GetKernelProcAddresses |
 *
 *          Get all the necessary proc addresses from Kernel.
 *
 ***************************************************************************/

BOOL EXTERNAL
Thunk_GetKernelProcAddresses(void)
{
    DllEnterCrit();

    if (g_kpa.QT_Thunk == 0) {
        HINSTANCE hinstK32 = GetModuleHandle(TEXT("KERNEL32"));

        if (hinstK32) {
            int i;
            FARPROC *rgfpKpa = (LPVOID)&g_kpa;

            for (i = 0; i < cA(c_rgpszKernel32); i++) {
                if (HIWORD((UINT_PTR)c_rgpszKernel32[i])) {
                    rgfpKpa[i] = GetProcAddress(hinstK32, c_rgpszKernel32[i]);
                } else {
                    rgfpKpa[i] = GetProcOrd(hinstK32, (UINT)(UINT_PTR)c_rgpszKernel32[i]);
                }
                if (!rgfpKpa[i]) break;     /* Aigh! */
            }
        }
    }

    DllLeaveCrit();

    return (BOOL)(UINT_PTR)g_kpa.QT_Thunk;

}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HINSTANCE | ThunkGetProcAddresses |
 *
 *          Get all the necessary proc addresses.
 *
 ***************************************************************************/

HINSTANCE EXTERNAL
Thunk_GetProcAddresses(FARPROC *rgfp, LPCSTR *rgpsz,
                       UINT cfp, LPCSTR pszLibrary)
{
    HINSTANCE hinst;

    hinst = g_kpa.LoadLibrary16(pszLibrary);
    if (hinst >= (HINSTANCE)32) {
        UINT ifp;
        for (ifp = 0; ifp < cfp; ifp++) {
            rgfp[ifp] = g_kpa.GetProcAddress16(hinst, rgpsz[ifp]);
            if (!rgfp[ifp]) {
                g_kpa.FreeLibrary16(hinst);
                hinst = 0;
                break;
            }
        }
    } else {
        hinst = 0;
    }

    return hinst;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\bcnt\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\daytona\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\win9x\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\diwinnt.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DIWdm.h
 *  Content:    DirectInput internal include file for Winnt
 *
 ***************************************************************************/
#ifndef DIWdm_H
#define DIWdm_H

#define JOY_BOGUSID    ( cJoyMax + 1 )

HRESULT EXTERNAL
DIWdm_SetJoyId
(
    IN PCGUID   guid,
    IN int      idJoy
);

PHIDDEVICEINFO EXTERNAL
phdiFindJoyId
(
    IN  int idJoy
);

HRESULT INTERNAL
DIWdm_SetLegacyConfig
(
    IN  int idJoy
);

BOOL EXTERNAL
DIWdm_InitJoyId( void );

DWORD EXTERNAL
DIWinnt_RegDeleteKey
(
    IN HKEY hStartKey ,
    IN LPCTSTR pKeyName
);

HRESULT EXTERNAL
DIWdm_SetConfig
(
    UINT idJoy,
    LPJOYREGHWCONFIG jwc,
    LPCDIJOYCONFIG pcfg,
    DWORD fl
);

HRESULT EXTERNAL
DIWdm_DeleteConfig
(
    int idJoy
);


HRESULT EXTERNAL
DIWdm_JoyHidMapping
(
    IN  int             idJoy,
    OUT PVXDINITPARMS   pvip,   OPTIONAL
    OUT LPDIJOYCONFIG   pcfg,   OPTIONAL
    OUT LPDIJOYTYPEINFO pdijti  OPTIONAL
);

LPTSTR EXTERNAL
JoyReg_JoyIdToDeviceInterface
(
    IN  UINT            idJoy,
    OUT PVXDINITPARMS   pvip,
    OUT LPTSTR          ptszBuf
);

#endif // DIWdm_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\diutil.c ===
/*****************************************************************************
 *
 *  DIUtil.c
 *
 *  Copyright (c) 1996 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Misc helper functions.
 *
 *  Contents:
 *
 *
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflUtil


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LPCTSTR | _ParseHex |
 *
 *          Parse a hex string encoding cb bytes (at most 4), then expect 
 *          the tchDelim to appear afterwards.  If tchDelim is 0, then no 
 *          delimiter is expected.
 *
 *          Store the result into the indicated LPBYTE (using only the
 *          size requested), updating it, and return a pointer to the
 *          next unparsed character, or 0 on error.
 *
 *          If the incoming pointer is also 0, then return 0 immediately.
 *          
 *  @parm   IN LPCTSTR | ptsz |
 *
 *          The string to parse.  
 *
 *  @parm   IN OUT LPBYTE * | ppb |
 *
 *          Pointer to the address of the destination buffer.
 *
 *  @parm   IN int | cb |
 *
 *          The size in bytes of the buffer.
 *
 *  @parm   IN TCHAR | tchDelim |
 *
 *          The delimiter charater to end the sequence or zero if none is 
 *          expected.
 *
 *  @returns
 *
 *          Returns a pointer to the next unparsed character, or 0 on error.
 *
 *  @comm
 *          Stolen from TweakUI.
 *
 *          Prefix takes a strong dislike to this function, reporting that 
 *          all callers could use uninitialized memory when the function 
 *          succeeds.
 *          The problem appears to be that Prefix is unable to determine that 
 *          if the source string can successfully be read, the destination is 
 *          always completely filled (the whole passed destination size) with 
 *          the binary value of the source string.  Since all callers always 
 *          pass the size of the variable to which the destination buffer 
 *          pointer points, the memory is always completely initialized but 
 *          it seems reasonable that Prefix would raise a warning. 
 *
 *****************************************************************************/

LPCTSTR INTERNAL
    _ParseHex(LPCTSTR ptsz, LPBYTE *ppb, int cb, TCHAR tchDelim)
{
    if(ptsz)
    {
        int i = cb * 2;
        DWORD dwParse = 0;

        do
        {
            DWORD uch;
            uch = (TBYTE)*ptsz - TEXT('0');
            if(uch < 10)
            {             /* a decimal digit */
            } else
            {
                uch = (*ptsz | 0x20) - TEXT('a');
                if(uch < 6)
                {          /* a hex digit */
                    uch += 10;
                } else
                {
                    return 0;           /* Parse error */
                }
            }
            dwParse = (dwParse << 4) + uch;
            ptsz++;
        } while(--i);

        if(tchDelim && *ptsz++ != tchDelim) return 0; /* Parse error */

        for(i = 0; i < cb; i++)
        {
            (*ppb)[i] = ((LPBYTE)&dwParse)[i];
        }
        *ppb += cb;
    }
    return ptsz;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | ParseGUID |
 *
 *          Take a string and convert it into a GUID, return success/failure.
 *
 *  @parm   OUT LPGUID | lpGUID |
 *
 *          Receives the parsed GUID on success.
 *
 *  @parm   IN LPCTSTR | ptsz |
 *
 *          The string to parse.  The format is
 *
 *      { <lt>dword<gt> - <lt>word<gt> - <lt>word<gt>
 *                      - <lt>byte<gt> <lt>byte<gt>
 *                      - <lt>byte<gt> <lt>byte<gt> <lt>byte<gt>
 *                        <lt>byte<gt> <lt>byte<gt> <lt>byte<gt> }
 *
 *  @returns
 *
 *          Returns zero if <p ptszGUID> is not a valid GUID.
 *
 *
 *  @comm
 *
 *          Stolen from TweakUI.
 *
 *****************************************************************************/

BOOL EXTERNAL
    ParseGUID(LPGUID pguid, LPCTSTR ptsz)
{
    if(lstrlen(ptsz) == ctchGuid - 1 && *ptsz == TEXT('{'))
    {
        ptsz++;
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 4, TEXT('-'));
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 2, TEXT('-'));
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 2, TEXT('-'));
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1, TEXT('-'));
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1, TEXT('}'));
        return (BOOL)(UINT_PTR)ptsz;
    } else
    {
        return 0;
    }
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | ParseVIDPID |
 *
 *          Take a string formatted as VID_%04&PID_%04.
 *
 *  @parm   OUT PUSHORT | puVID |
 *
 *          Receives the parsed VID.
 *  
 *  @parm   OUT PUSHORT | puPID |
 *      
 *          Receives the parsed PID. 
 *
 *  @parm   IN LPCTSTR | ptsz |
 *
 *
 *  @returns
 *
 *          Returns zero on failure.
 *
 *
 *  @comm
 *
 *          Stolen from TweakUI.
 *
 *****************************************************************************/

//                    VID _ XXXX  &  PID  _ YYYY
#define ctchVIDPID  ( 3 + 1 + 4 + 1 + 3 + 1 + 4 )

#define VID_        TEXT("VID_")
#define VID_offset  (3+1)
#define PID_        TEXT("&PID_")
#define PID_offset  (3+1+4+1+3+1)

BOOL EXTERNAL
    ParseVIDPID(PUSHORT puVID, PUSHORT puPID , LPCWSTR pwsz)
{    
    LPCTSTR ptsz;    
#ifndef UNICODE
    TCHAR    tsz[MAX_JOYSTRING];
    UToT( tsz, cA(tsz), pwsz );
    ptsz = tsz;
#else
   ptsz = pwsz;
#endif

    if( _ParseHex(ptsz+VID_offset, (LPBYTE *)&puVID, 2, TEXT('&'))  &&
        _ParseHex(ptsz+PID_offset, (LPBYTE *)&puPID, 2, 0) )
        {
            return TRUE;
        }
   return FALSE;
}




/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | NameFromGUID |
 *
 *          Convert a GUID into an ASCII string that will be used
 *          to name it in the global namespace.
 *
 *          We use the name "DirectInput.{guid}".
 *
 *          Names are used in the following places:
 *
 *          <c g_hmtxGlobal> names a mutex based on
 *          <c IID_IDirectInputW> to gate access to the
 *          shared memory block used to manage exclusive access.
 *
 *          <c g_psop> names a shared memory block based on
 *          <c IID_IDirectInputDeviceW> to record information
 *          about exclusive access.
 *
 *          <c g_hmtxJoy> names a mutex based on
 *          <c IID_IDirectInputDevice2A> to gate access to the
 *          shared memory block used to track joystick effects.
 *
 *  @parm   LPTSTR | ptszBuf |
 *
 *          Output buffer to receive the converted name.  It must
 *          be <c ctchNameGuid> characters in size.
 *
 *  @parm   PCGUID | pguid |
 *
 *          The GUID to convert.
 *
 *
 *****************************************************************************/

    #pragma BEGIN_CONST_DATA

/* Note: If you change this string, you need to change ctchNameGuid to match */
TCHAR c_tszNameFormat[] =
    TEXT("DirectInput.{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}");

    #pragma END_CONST_DATA


void EXTERNAL
    NameFromGUID(LPTSTR ptszBuf, PCGUID pguid)
{
    int ctch;

    ctch = wsprintf(ptszBuf, c_tszNameFormat,
                    pguid->Data1, pguid->Data2, pguid->Data3,
                    pguid->Data4[0], pguid->Data4[1],
                    pguid->Data4[2], pguid->Data4[3],
                    pguid->Data4[4], pguid->Data4[5],
                    pguid->Data4[6], pguid->Data4[7]);

    AssertF(ctch == ctchNameGuid - 1);
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PV | pvFindResource |
 *
 *          Handy wrapper that finds and loads a resource.
 *
 *  @parm   IN HINSTANCE | hinst |
 *
 *          Module instance handle.
 *
 *  @parm   DWORD | id |
 *
 *          Resource identifier.
 *
 *  @parm   LPCTSTR | rt |
 *
 *          Resource type.
 *
 *  @returns
 *
 *          Pointer to resource, or 0.
 *
 *****************************************************************************/

PV EXTERNAL
    pvFindResource(HINSTANCE hinst, DWORD id, LPCTSTR rt)
{
    HANDLE hrsrc;
    PV pv;

    hrsrc = FindResource(hinst, (LPTSTR)(LONG_PTR)(id), rt);
    if(hrsrc)
    {
        pv = LoadResource(hinst, hrsrc);
    } else
    {
        pv = 0;
    }
    return pv;
}

#ifndef UNICODE

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   UINT | LoadStringW |
 *
 *          Implementation of LoadStringW for platforms on which Unicode is
 *          not supported.  Does exactly what LoadStringW would've done
 *          if it existed.
 *
 *  @parm   IN HINSTANCE | hinst |
 *
 *          Module instance handle.
 *
 *  @parm   UINT | ids |
 *
 *          String id number.
 *
 *  @parm   LPWSTR | pwsz |
 *
 *          UNICODE output buffer.
 *
 *  @parm   UINT | cwch |
 *
 *          Size of UNICODE output buffer.
 *
 *  @returns
 *
 *          Number of characters copied, not including terminating null.
 *
 *  @comm
 *
 *          Since the string is stored in the resource as UNICODE,
 *          we just take it out ourselves.  If we go through
 *          <f LoadStringA>, we may end up losing characters due
 *          to character set translation.
 *
 *****************************************************************************/

int EXTERNAL
    LoadStringW(HINSTANCE hinst, UINT ids, LPWSTR pwsz, int cwch)
{
    PWCHAR pwch;

    AssertF(cwch);
    ScrambleBuf(pwsz, cbCwch(cwch));

    /*
     *  String tables are broken up into "bundles" of 16 strings each.
     */
    pwch = pvFindResource(hinst, 1 + ids / 16, RT_STRING);
    if(pwch)
    {
        /*
         *  Now skip over the strings in the resource until we
         *  hit the one we want.  Each entry is a counted string,
         *  just like Pascal.
         */
        for(ids %= 16; ids; ids--)
        {
            pwch += *pwch + 1;
        }
        cwch = min(*pwch, cwch - 1);
        memcpy(pwsz, pwch+1, cbCwch(cwch)); /* Copy the goo */
    } else
    {
        cwch = 0;
    }
    pwsz[cwch] = TEXT('\0');            /* Terminate the string */
    return cwch;
}

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | GetNthString |
 *
 *          Generate a generic numbered object name.
 *
 *  @parm   LPWSTR | pwsz |
 *
 *          Output buffer of <c MAX_PATH> characters.
 *
 *  @parm   UINT | ids |
 *
 *          String containing number template.
 *
 *  @parm   UINT | ui |
 *
 *          Button number.
 *
 *****************************************************************************/

void EXTERNAL
    GetNthString(LPWSTR pwsz, UINT ids, UINT ui)
{
    TCHAR tsz[256];
#ifndef UNICODE
    TCHAR tszOut[MAX_PATH];
#endif

    LoadString(g_hinst, ids, tsz, cA(tsz));
#ifdef UNICODE
    wsprintfW(pwsz, tsz, ui);
#else
    wsprintf(tszOut, tsz, ui);
    TToU(pwsz, MAX_PATH, tszOut);
#endif
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresRunControlPanel |
 *
 *          Run the control panel with the specified applet.
 *
 *  @parm   LPCTSTR | ptszApplet |
 *
 *          Applet name.
 *
 *  @returns
 *
 *          <c S_OK> if we started the applet.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

TCHAR c_tszControlExeS[] = TEXT("control.exe %s");

#pragma END_CONST_DATA

HRESULT EXTERNAL
    hresRunControlPanel(LPCTSTR ptszCpl)
{
    HRESULT hres;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    TCHAR tsz[MAX_PATH];
    EnterProc(hresRunControlPanel, (_ "s", ptszCpl));

    ZeroX(si);
    si.cb = cbX(si);
    wsprintf(tsz, c_tszControlExeS, ptszCpl);
    if(CreateProcess(0, tsz, 0, 0, 0, 0, 0, 0, &si, &pi))
    {
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
        hres = S_OK;
    } else
    {
        hres = hresLe(GetLastError());
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ObjectInfoWToA |
 *
 *          Convert a <t DIDEVICEOBJECTINSTANCEW>
 *          to a <t DIDEVICEOBJECTINSTANCE_DX3A>
 *          or a <t DIDEVICEOBJECTINSTANCE_DX5A>.
 *
 *  @parm   LPDIDIDEVICEOBJECTINSTANCEA | pdoiA |
 *
 *          Destination.
 *
 *  @parm   LPCDIDIDEVICEOBJECTINSTANCEW | pdoiW |
 *
 *          Source.
 *
 *****************************************************************************/

void EXTERNAL
    ObjectInfoWToA(LPDIDEVICEOBJECTINSTANCEA pdoiA,
                   LPCDIDEVICEOBJECTINSTANCEW pdoiW)
{
    EnterProc(ObjectInfoWToA, (_ "pp", pdoiA, pdoiW));

    AssertF(pdoiW->dwSize == sizeof(DIDEVICEOBJECTINSTANCEW));

    AssertF(IsValidSizeDIDEVICEOBJECTINSTANCEA(pdoiA->dwSize));
    pdoiA->guidType  = pdoiW->guidType;
    pdoiA->dwOfs     = pdoiW->dwOfs;
    pdoiA->dwType    = pdoiW->dwType;
    pdoiA->dwFlags   = pdoiW->dwFlags;

    UToA(pdoiA->tszName, cA(pdoiA->tszName), pdoiW->tszName);

    if(pdoiA->dwSize >= cbX(DIDEVICEOBJECTINSTANCE_DX5A))
    {
        pdoiA->dwFFMaxForce        = pdoiW->dwFFMaxForce;
        pdoiA->dwFFForceResolution = pdoiW->dwFFForceResolution;
        pdoiA->wCollectionNumber   = pdoiW->wCollectionNumber;
        pdoiA->wDesignatorIndex    = pdoiW->wDesignatorIndex;
        pdoiA->wUsagePage          = pdoiW->wUsagePage;
        pdoiA->wUsage              = pdoiW->wUsage;
        pdoiA->dwDimension         = pdoiW->dwDimension;
        pdoiA->wExponent           = pdoiW->wExponent;
        pdoiA->wReportId           = pdoiW->wReportId;
    }

    ExitProc();
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | EffectInfoWToA |
 *
 *          Convert a <t DIEFFECTINFOW> to a <t DIEFFECTINFOA>
 *
 *  @parm   LPDIEFFECTINFOA | pdeiA |
 *
 *          Destination.
 *
 *  @parm   LPCDIEFFECTINFOW | pdeiW |
 *
 *          Source.
 *
 *****************************************************************************/

void EXTERNAL
    EffectInfoWToA(LPDIEFFECTINFOA pdeiA, LPCDIEFFECTINFOW pdeiW)
{
    EnterProc(EffectInfoWToA, (_ "pp", pdeiA, pdeiW));

    AssertF(pdeiW->dwSize == sizeof(DIEFFECTINFOW));

    AssertF(pdeiA->dwSize == cbX(*pdeiA));
    pdeiA->guid            = pdeiW->guid;
    pdeiA->dwEffType       = pdeiW->dwEffType;
    pdeiA->dwStaticParams  = pdeiW->dwStaticParams;
    pdeiA->dwDynamicParams = pdeiW->dwDynamicParams;

    UToA(pdeiA->tszName, cA(pdeiA->tszName), pdeiW->tszName);
    ExitProc();
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresValidInstanceVer |
 *
 *          Check the <t HINSTANCE> and version number received from
 *          an application.
 *
 *  @parm   HINSTANCE | hinst |
 *
 *          Purported module instance handle.
 *
 *  @parm   DWORD | dwVersion |
 *
 *          Version the application is asking for.
 *
 *****************************************************************************/

HRESULT EXTERNAL
    hresValidInstanceVer_(HINSTANCE hinst, DWORD dwVersion, LPCSTR s_szProc)
{
    HRESULT hres;
    TCHAR tszScratch[4];

    EnterProcS(hresValidInstanceVer, (_ "xxs", hinst, dwVersion, s_szProc));
    /*
     *  You would think that passing a zero-sized buffer to
     *  GetModuleFileName would return the necessary buffer size.
     *
     *  You would be right.  Except that the Win95 validation layer
     *  doesn't realize that this was a valid scenario, so the call
     *  fails in the validation layer and never reached Kernel.
     *
     *  So we read it into a small scratch buffer.  The scratch buffer
     *  must be at least 2 characters; if we passed only 1, then
     *  GetModuleFileName won't be able to write any characters and
     *  will return 0.
     *
     *  Now it turns out that there's a bug in NT where, if you
     *  pass a buffer size of 4, but the actual name is longer than
     *  4, it writes 4 characters, PLUS A NULL TERMINATOR, thereby
     *  smashing your stack and making you fault randomly.
     *
     *  I spent two hours trying to figure that out.
     *
     *  Therefore, you must pass one *less* than the buffer size
     *  to GetModuleFileName, because it will overwrite your buffer
     *  by one.
     */

    if( ( hinst != 0 )
     && GetModuleFileName(hinst, tszScratch, cA(tszScratch) - 1) )
    {
        if(dwVersion == DIRECTINPUT_INTERNAL_VERSION)
        {
            hres = S_OK;
        } else if ( dwVersion == 0 ) {
            RPF("%s: DinputInput object has not been initialized, or the version is given as 0.",
                s_szProc);
            hres = DIERR_NOTINITIALIZED;
        } else if(dwVersion < DIRECTINPUT_VERSION)
        {
            RPF("%s: Incorrect dwVersion(0x%x); program was written with beta SDK. This version 0x%x",
                s_szProc, dwVersion, DIRECTINPUT_VERSION);
            hres = DIERR_BETADIRECTINPUTVERSION;
        } else
        {
            RPF("%s: Incorrect dwVersion(0x%x); program needs newer version of dinput. This version 0x%x",
                s_szProc, dwVersion, DIRECTINPUT_VERSION);
            hres = DIERR_OLDDIRECTINPUTVERSION;
        }

    } else
    {
        RPF("%s: Invalid HINSTANCE", s_szProc);
        hres = E_INVALIDARG;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DupEventHandle |
 *
 *          Duplicate an event handle intra-process-ly.  If the incoming
 *          handle is NULL, then so is the output handle (and the call
 *          succeeds).
 *
 *  @parm   HANDLE | h |
 *
 *          Source handle.
 *
 *  @parm   LPHANDLE | phOut |
 *
 *          Receives output handle.
 *
 *****************************************************************************/

HRESULT EXTERNAL
    DupEventHandle(HANDLE h, LPHANDLE phOut)
{
    HRESULT hres;
    EnterProc(DupEventHandle, (_ "p", h));

    if(h)
    {
        HANDLE hProcessMe = GetCurrentProcess();
        if(DuplicateHandle(hProcessMe, h, hProcessMe, phOut,
                           EVENT_MODIFY_STATE, 0, 0))
        {
            hres = S_OK;
        } else
        {
            hres = hresLe(GetLastError());
        }
    } else
    {
        *phOut = h;
        hres = S_OK;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | GetWindowPid |
 *
 *          Simple wrapper that returns the PID of a window.
 *
 *          Here is also where we do goofy hacks for DOS boxes
 *          on Win95.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window handle.
 *
 *  @returns
 *
 *          PID or 0.
 *
 *****************************************************************************/

DWORD EXTERNAL
    GetWindowPid(HWND hwnd)
{
    DWORD pid;

    if(IsWindow(hwnd) &&
       GetWindowThreadProcessId(hwnd, &pid) )
    {
#ifndef WINNT
           /*
            *  The Winoldap console window belongs to another
            *  process but Win95 lies and says that it belongs
            *  to you but it doesn't.
            */
            if ( GetProp(hwnd, TEXT("flWinOldAp")) != 0 )
            {
                pid = 0;
            }
#endif
    } else
    {
        pid = 0;
    }

    return pid;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresDupPtszPptsz |
 *
 *          OLEish version of strdup.
 *
 *  @parm   LPCTSTR | ptszSrc |
 *
 *          Source string being duplicated.
 *
 *  @parm   LPTSTR * | pptszDst |
 *
 *          Receives the duplicated string.
 *
 *  @returns
 *
 *          <c S_OK> or an error code.
 *
 *****************************************************************************/

HRESULT EXTERNAL
    hresDupPtszPptsz(LPCTSTR ptszSrc, LPTSTR *pptszDst)
{
    HRESULT hres;

    hres = AllocCbPpv(cbCtch(lstrlen(ptszSrc) + 1), pptszDst);

    if(SUCCEEDED(hres))
    {
        lstrcpy(*pptszDst, ptszSrc);
        hres = S_OK;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | fInitializeCriticalSection |
 *
 *          Initialize the give critical section, returning 0 if an exception 
 *          is thrown, else 0.
 *
 *  @parm   LPCRITICAL_SECTION | pCritSec |
 *
 *          Pointer to an uninitialized critical section.
 *
 *****************************************************************************/

BOOL EXTERNAL
    fInitializeCriticalSection(LPCRITICAL_SECTION pCritSec)
{
    BOOL fres = 1;
    EnterProc(fInitializeCriticalSection, (_ "" ));

    AssertF( pCritSec );
    __try
    {
        InitializeCriticalSection( pCritSec );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        fres = 0;
    }

    ExitProcF( fres );
    return fres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DiCharUpperW |
 *
 *          This function converts a wide-character string or a single wide-character
 *          to uppercase. Since Win9x doesn't implement CharUpperW, we have to implement
 *          ourselves.
 *
 *  @parm   LPWSTR | pwsz |
 *
 *          The string to be converted
 *
 *  @returns
 *
 *          void
 *
 *****************************************************************************/

void EXTERNAL 
    DiCharUpperW(LPWSTR pwsz)
{
    int idx;
    int iLen = lstrlenW(pwsz);

    #define DIFF  (L'a' - L'A')
    
    for( idx=0; idx<iLen; idx++ )
    {
        if( (pwsz[idx] >= L'a') && (pwsz[idx] <= L'z') ){
            pwsz[idx] -= DIFF;
        }
    }

    #undef DIFF
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ptrSwap |
 *
 *          swaps the pointers pointed to by the two parameters
 *
 *  @parm   void ** | ppA |
 *
 *          pointer to first pointer
 *
 *  @parm   void ** | ppB |
 *
 *          pointer to second pointer
 *
 *****************************************************************************/
void __inline ptrSwap( PPV ppA, PPV ppB )
{
    PV pTemp = *ppB;
    *ppB = *ppA;
    *ppA = pTemp;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ptrPartialQSort |
 *
 *          Partially sort the passed (sub)set of an array of pointers to 
 *          structures such that resultant array is contains sub arrays which 
 *          are sorted with respect to each other though locally unsorted.
 *          Once partially sorted, a simple sort may be used to complete the 
 *          sort.
 *
 *  @parm   void ** | ppL |
 *          Pointer to lowest element in the (sub)array to sort
 *
 *  @parm   void ** | ppR |
 *          Pointer to highest element in the (sub)array to sort
 *
 *  @parm   COMP_FUNC | fpCompare | 
 *          Pointer to function returning analog of strcmp for strings, but 
 *          supplied by caller for comparing elements of the array.
 *
 *****************************************************************************/

void ptrPartialQSort
( 
    PPV         ppL, 
    PPV         ppR, 
    COMP_FUNC   fpCompare 
)
{
    while( ( ppR - ppL ) > 8 )
    {
        /*
         *  First pick a pivot by sorting the first last and middle
         *  values in the sub array.
         */
        {
            PPV ppMid = ppL + ( ( ppR - ppL ) / 2 );

            if( fpCompare( *ppL, *ppMid ) > 0 )
            {
                ptrSwap( ppL, ppMid );
            }
            if( fpCompare( *ppL, *ppR ) > 0 )
            {
                ptrSwap( ppL, ppR );
            }
            if( fpCompare( *ppMid, *ppR ) > 0 )
            {
                ptrSwap( ppMid, ppR );
            }

            /*
             *  Now we have a reasonable chance of a good pivot, move it 
             *  out of the way.
             */
            ptrSwap( ppMid, ppR-1 );
        }

        /*
         *  Now sort the remainder into high and low parts
         */

        {
            PPV ppHi = ppR - 1;
            PV  pPivot = *ppHi;
            PPV ppLo = ppL;

            for( ;; )
            {
                while( fpCompare( *(++ppLo), pPivot ) < 0 );

                while( fpCompare( *(--ppHi), pPivot ) > 0 );

                if( ppLo >= ppHi ) break;

                ptrSwap( ppLo, ppHi );
            }
        
            /*
             *  Put the pivot back between the two parts as it must be in 
             *  order relative to all the items on each side of it.
             */
            ptrSwap( ppLo, ppR - 1 );

            /*
             *  Recurse on the smaller part and continue with the larger
             */
            if( ppLo - ppL > ppR - ppLo )
            {
                /*
                 *  Left part is larger
                 */
                ptrPartialQSort( ppLo + 1, ppR, fpCompare );
                ppR = ppLo - 1;
            }
            else
            {
                /*
                 *  Right part is larger
                 */
                ptrPartialQSort( ppL, ppLo - 1, fpCompare );
                ppL = ppLo + 1;
            }
        }
    }
}



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ptrInsertSort |
 *
 *          Sort the passed (sub)set of an array of pointers to structures.
 *          This sort is not suitable for large arrays.
 *
 *  @parm   void ** | ppBase |
 *          Pointer to lowest element in the (sub)array to sort
 *
 *  @parm   void ** | ppLast |
 *          Pointer to highest element in the (sub)array to sort
 *
 *  @parm   COMP_FUNC | fpCompare | 
 *          Pointer to function returning analog of strcmp for strings, but 
 *          supplied by caller for comparing elements of the array.
 *
 *****************************************************************************/

void ptrInsertSort
( 
    PPV         ppBase, 
    PPV         ppLast, 
    COMP_FUNC   fpCompare 
)
{
    
    PPV ppOuter;

    for( ppOuter = ppBase + 1; ppOuter <= ppLast; ppOuter++ )
    {
        PV  pTemp = *ppOuter;
        PPV ppInner;

        for( ppInner = ppOuter - 1; ppInner >= ppBase; ppInner-- )
        {
            if( fpCompare( pTemp, *ppInner ) > 0 )
            {
                *(ppInner+1) = *ppInner;
            }
            else
            {
                break;
            }
        }

        *(ppInner+1) = pTemp;
    }
        
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | swap |
 *
 *          swaps the two array elements of size width
 *
 *  @parm   char * | a |
 *
 *          pointer to first elements to swap
 *
 *  @parm   char * | b |
 *
 *          pointer to second elements to swap
 *
 *  @parm   unsigned | width |
 *
 *          width in bytes of each array element
 *
 *  @returns
 *
 *          void
 *
 *****************************************************************************/

static void __cdecl swap (
    char *a,
    char *b,
    unsigned width
    )
{
    char tmp;

    if ( a != b )
    {
        /* Do the swap one character at a time to avoid potential alignment
           problems. */
        while ( width-- ) {
            tmp = *a;
            *a++ = *b;
            *b++ = tmp;
        }
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | shortsort |
 *
 *      sorts the sub-array of elements between lo and hi (inclusive)
 *      side effects:  sorts in place
 *      assumes that lo is less than hi
 *
 *  @parm   char * | lo |
 *          pointer to low element to sort
 *
 *  @parm   char * | hi |
 *          pointer to high element to sort
 *
 *  @parm   unsigned | width |
 *          width in bytes of each array element
 *
 *  @parm   int (*func)() | comp | 
 *           pointer to function returning analog of strcmp for
 *           strings, but supplied by user for comparing the array elements.
 *           it accepts 2 pointers to elements and returns neg if 1 lt 2, 0 if
 *           1 eq 2, pos if 1 gt 2.
 *
 *  @returns
 *
 *          void
 *
 *****************************************************************************/

void __cdecl shortsort (
    char *lo,
    char *hi,
    unsigned width,
    int (__cdecl *comp)(const void *, const void *)
    )
{
    char *p, *max;

    /* Note: in assertions below, i and j are alway inside original bound of
       array to sort. */

    while (hi > lo) {
        /* A[i] <= A[j] for i <= j, j > hi */
        max = lo;
        for (p = lo+width; p <= hi; p += width) {
            /* A[i] <= A[max] for lo <= i < p */
            if (comp(p, max) > 0) {
                max = p;
            }
            /* A[i] <= A[max] for lo <= i <= p */
        }

        /* A[i] <= A[max] for lo <= i <= hi */

        swap(max, hi, width);

        /* A[i] <= A[hi] for i <= hi, so A[i] <= A[j] for i <= j, j >= hi */

        hi -= width;

        /* A[i] <= A[j] for i <= j, j > hi, loop top condition established */
    }
    /* A[i] <= A[j] for i <= j, j > lo, which implies A[i] <= A[j] for i < j,
       so array is sorted */
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | GetWideUserName |
 *
 *          Get a wide string for a user.
 *          If both of the IN parameters are NULL, memory is allocated for a
 *          MULTI_SZ string and set to the output pointer.  The sting is 
 *          filled with the current user name if available, else a localizable 
 *          default sting.
 *          If a UNICODE name is supplied, it is validated and assigned to the 
 *          output string pointer.  
 *          If an ANSI name is supplied, it is validated and memory is 
 *          allocated into which the translated SZ UNICODE name is written.
 *          Note it is the caller's responsibility to free the memory in 
 *          either of the cases in which is is allocated.
 *          Also note that in the case of an error no memory needs to be
 *          freed.
 *
 *  @parm   LPCSTR | lpszUserName |
 *
 *          A specific ANSI user name.
 *
 *  @parm   LPCWSTR | lpwszUserName |
 *
 *          A specific UNICODE user name.
 *
 *  @parm   LPWSTR* | ppwszGoodUserName |
 *
 *          A pointer to a pointer to the wide user name.
 *
 *  @returns
 *
 *          <c S_OK> if the output string is valid
 *          or an error code reflecting what went wrong.
 *
 *****************************************************************************/
STDMETHODIMP GetWideUserName
(
    IN  LPCSTR lpszUserName,
    IN  LPCWSTR lpwszUserName,
    OUT LPWSTR  *ppwszGoodUserName
)
{
    HRESULT hres = S_OK;

    EnterProcI(GetWideUserName, (_ "AW", lpszUserName, lpwszUserName ));

    if( lpwszUserName )
    {
        /*
         *  Just validate and copy the pointer
         */
        if( SUCCEEDED( hres = hresFullValidReadStrW( lpwszUserName, UNLEN+1, 2 ) ) )
        {
            *ppwszGoodUserName = (LPWSTR)lpwszUserName;
        }
    }
    else if( lpszUserName )
    {
        /*
         *  If an ANSI user name has been passed translate it
         */
        if( SUCCEEDED( hres = hresFullValidReadStrA( lpszUserName, UNLEN+1, 1 ) ) )
        {
            int UserNameLen = lstrlenA( lpszUserName ) + 1;

            hres = AllocCbPpv( cbX(*lpwszUserName) * UserNameLen, ppwszGoodUserName );
            if( SUCCEEDED( hres ) )
            {
                AToU( *ppwszGoodUserName, UserNameLen, lpszUserName );
            }
        }
    }
    else
    {
        DWORD   dwUserNameLen = UNLEN + 1;

#ifdef WINNT
        hres = AllocCbPpv( (dwUserNameLen+1) * 2, ppwszGoodUserName );
        if( SUCCEEDED( hres ) )
        {
            if( GetUserNameW( *ppwszGoodUserName, &dwUserNameLen ) )
            {
#else
        hres = AllocCbPpv( (dwUserNameLen+1) * 3, ppwszGoodUserName );
        if( SUCCEEDED( hres ) )
        {
            if( GetUserNameA( (PCHAR)(&((*ppwszGoodUserName)[UNLEN+2])), &dwUserNameLen ) )
            {
                AToU( *ppwszGoodUserName, dwUserNameLen, (PCHAR)(&((*ppwszGoodUserName)[UNLEN+2])) );
#endif
                /*
                 *  We allocated _and_zeroed_ an extra wchar for double 
                 *  termination.  Assert nobody messed it up and then 
                 *  make sure we don't free the extra.
                 */
                AssertF( (*ppwszGoodUserName)[dwUserNameLen] == L'\0' );
                dwUserNameLen++;
            }
            else
            {
                /*
                 *  If we felt the need, we could follow this recovery path
                 *  only if ( GetLastError() == ERROR_NOT_LOGGED_ON ) and
                 *  report some error or follow some alternate recovery
                 *  otherwise but unless a problem is found with always using
                 *  the default, this seems safer.
                 */
                dwUserNameLen = LoadStringW( g_hinst, IDS_DEFAULTUSER, *ppwszGoodUserName, UNLEN+1 );
                if( dwUserNameLen )
                {
                    /*
                     *  Double terminate the string for ConfigureDevices
                     */
                    dwUserNameLen += 2; 
                    (*ppwszGoodUserName)[dwUserNameLen-1] = L'\0';    
                    SquirtSqflPtszV(sqflUtil | sqflBenign,
                        TEXT("Failed to GetUserName, using default") );
                }
                else
                {
                    SquirtSqflPtszV(sqflUtil | sqflError,
                        TEXT("Failed to GetUserName and default, le = %d"), GetLastError() );
                    hres = E_FAIL;
                }
            }

            /*
             *  Chances are we have way more space than we need
             *  NOTE, in the failure case, this reallocs to zero thus
             *  freeing the memory.
             *  If we have a valid sting, failure to realloc just means
             *  using more memory that we need to for a little while.
             *  If we don't have a string, ReallocCbPpv cannot fail.
             */
            ReallocCbPpv( dwUserNameLen*2, ppwszGoodUserName );


#ifndef WINNT
        }
    }
#else       /*  Reduce bracket matching insanity even though these don't match */
        }
    }
#endif

#ifdef XDEBUG
    if( SUCCEEDED( hres ) )
    {
        AssertF( SUCCEEDED( hresFullValidReadStrW( *ppwszGoodUserName, UNLEN+1, 2 ) ) );
    }
    else
    {
        /*
         *  If a passed string was invalid, we never allocated any memory so 
         *  don't worry about this uninitialized output value for this error.
         */
        if( hres != E_INVALIDARG )
        {
            AssertF( *ppwszGoodUserName == NULL );
        }
    }
#endif

    ExitOleProc();

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | GetValidDI8DevType |
 *
 *          Return a valid type and subtype based on the ones passed, the 
 *          number of buttons and axis/pov caps.
 *          
 *  @parm   DWORD | dwDevType |
 *
 *          Value to be checked, only the type and sub type bits are used.
 *
 *  @parm   DWORD | dwNumButtons |
 *
 *          Number of buttons on device, only used when checking devices mja
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags determining any axis/pov requirements. mja
 *
 *  @returns
 *
 *          Zero if the type and subtype are not a valid combination for DX8.
 *          
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define MAKE_DI8TYPE_LIMITS( type ) { type##_MIN, type##_MAX, type##_MIN_BUTTONS, type##_MIN_CAPS },
struct
{
    BYTE SubTypeMin;
    BYTE SubTypeMax;
    BYTE MinButtons;
    BYTE HWCaps;
}   c_rgSubTypeDetails[] = {
    { 0, 1, 0, 0 },   /* DI8DEVTYPEDEVICE has no subtype or limits */
    MAKE_DI8TYPE_LIMITS( DI8DEVTYPEMOUSE )
    MAKE_DI8TYPE_LIMITS( DI8DEVTYPEKEYBOARD )
    MAKE_DI8TYPE_LIMITS( DI8DEVTYPEJOYSTICK )
    MAKE_DI8TYPE_LIMITS( DI8DEVTYPEGAMEPAD )
    MAKE_DI8TYPE_LIMITS( DI8DEVTYPEDRIVING )
    MAKE_DI8TYPE_LIMITS( DI8DEVTYPEFLIGHT )
    MAKE_DI8TYPE_LIMITS( DI8DEVTYPE1STPERSON )
    MAKE_DI8TYPE_LIMITS( DI8DEVTYPEDEVICECTRL )
    MAKE_DI8TYPE_LIMITS( DI8DEVTYPESCREENPTR )
    MAKE_DI8TYPE_LIMITS( DI8DEVTYPEREMOTE )
    MAKE_DI8TYPE_LIMITS( DI8DEVTYPESUPPLEMENTAL )
};
#undef MAKE_DI8TYPE_LIMITS

#pragma END_CONST_DATA


DWORD EXTERNAL GetValidDI8DevType
(   
    DWORD dwDevType,
    DWORD dwNumButtons,
    DWORD dwFlags
)
{
    BYTE bDevTypeIdx = GET_DIDEVICE_TYPE( dwDevType ) - DI8DEVTYPE_MIN;

    CAssertF( cA( c_rgSubTypeDetails ) == DI8DEVTYPE_MAX - DI8DEVTYPE_MIN );

    if( ( (__int8)bDevTypeIdx >= 0 )
     && ( bDevTypeIdx < DI8DEVTYPE_MAX - DI8DEVTYPE_MIN ) 
     && ( GET_DIDEVICE_SUBTYPE( dwDevType ) >= c_rgSubTypeDetails[bDevTypeIdx].SubTypeMin )
     && ( GET_DIDEVICE_SUBTYPE( dwDevType ) < c_rgSubTypeDetails[bDevTypeIdx].SubTypeMax ) )
    {
        /*
         *  MinButtons of zero means no minimum buttons OR caps
         */
        if( !c_rgSubTypeDetails[bDevTypeIdx].MinButtons
         || ( ( dwNumButtons >= c_rgSubTypeDetails[bDevTypeIdx].MinButtons )
           && ( ( dwFlags & c_rgSubTypeDetails[bDevTypeIdx].HWCaps )
             == c_rgSubTypeDetails[bDevTypeIdx].HWCaps ) ) )
        {
            return dwDevType & ( DIDEVTYPE_TYPEMASK | DIDEVTYPE_SUBTYPEMASK );
        }
        else
        {
            return ( dwDevType & DIDEVTYPE_TYPEMASK ) | MAKE_DIDEVICE_TYPE( 0, DI8DEVTYPE_LIMITEDGAMESUBTYPE );
        }
    }
    else
    {
        return 0;
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | DIGetKeyNameTextHelper |
 *
 *          return key name of a key.
 *          
 *  @parm   IN UINT | uiScanCode |
 *
 *          scan code of the key.
 *
 *  @parm   OUT LPWSTR | lpwszName |
 *
 *          The buffer that will hold the returned key name.
 *
 *  @parm   int | nSize |
 *
 *          The length of lpwszName.
 *
 *  @returns
 *
 *          TRUE - if successfully get a key name.
 *          FALSE - otherwise
 *
 *****************************************************************************/

BOOL DIGetKeyNameTextHelper( UINT uiScanCode, LPWSTR lpwszName, int nSize )
{
    HKL   hkl;
    DWORD dwThread, dwProcessId;
    UINT  uiVk;
    BYTE  kbuf[256] = "";
    int   nResult;

    // we only want to use this method to resolve alpha & punct keys.
    if( uiScanCode > 0x53 ) {  
        return FALSE;
    }
    
    //Get the active window's thread
    dwThread=GetWindowThreadProcessId(GetActiveWindow(), &dwProcessId);
    //Get the active window's keyboard layout
    hkl=GetKeyboardLayout(dwThread);
    
    uiVk = MapVirtualKeyEx( uiScanCode, 3, hkl );
#ifdef WINNT
    nResult = ToUnicodeEx(uiVk, uiScanCode, kbuf, lpwszName, nSize, 0, hkl);
#else
    nResult = ToAsciiEx(uiVk, uiScanCode, kbuf, lpwszName, 0, hkl);
#endif

    if( (nResult != 1) || 
        (!iswalpha(lpwszName[0]) && !iswpunct(lpwszName[0])) ) 
    {
        return FALSE;
    } else {
        WCHAR wc;
        
        wc = towupper( lpwszName[0] );
        lpwszName[0] = wc;
    }
    
    return TRUE;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULE | DIGetKeyNameText |
 *
 *          return key name of a key.
 *          
 *  @parm   IN UINT | index |
 *
 *          the index of g_rgbKbdRMap[].
 *
 *  @parm   IN DWORD | dwDevType |
 *
 *          the DevType of the key.
 *
 *  @parm   OUT LPWSTR | lpwszName |
 *
 *          The buffer that will hold the returned key name.
 *
 *  @parm   int | nSize |
 *
 *          The length of lpwszName.
 *
 *  @returns
 *
 *          S_OK - if successfully get a key name.
 *          DIERR_OBJECTNOTFOUND - otherwise
 *
 *****************************************************************************/

HRESULT DIGetKeyNameText( UINT index, DWORD dwDevType, LPWSTR lpwszName, int nSize )
{
    HRESULT hres;
    DWORD dwScancode;
    LONG  lp;
    DWORD dw;
    BOOL  fSpecKey = FALSE;
    DWORD dwSpecKeys[] = { 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,  //number
                           0x90, 0x99, 0xa0, 0xa1, 0xa2, 0xa4, 0xae, 0xb0, 0xb2, 
                           0xde, 0xdf, 0xe3, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 
                           0xeb, 0xec, 0xed };
        
    dwScancode = (DWORD)g_rgbKbdRMap[index];
    lp =  ((dwScancode & 0x7F) << 16) | ((dwScancode & 0x80) << 17);
    
    for( dw = 0; dw < cA(dwSpecKeys); dw++ ) {
        if( dwSpecKeys[dw] == dwScancode ) {
            fSpecKey = TRUE;
            break;
        }
    }
        
    if( !fSpecKey ) {   
        if( !DIGetKeyNameTextHelper(dwScancode, lpwszName, nSize) ) {
            GetKeyNameTextW(lp, lpwszName, nSize);
          #ifndef UNICODE
            if( GetLastError() == ERROR_CALL_NOT_IMPLEMENTED )
            {
                CHAR szName[MAX_PATH];
                GetKeyNameTextA( lp, szName, cA(szName) );
                AToU( lpwszName, cA(szName), szName );
            }
          #endif
        }
    }
        
    if( lpwszName[0] == TEXT('\0') &&
        (dwScancode != 0x56 && dwScancode != 0x73 && dwScancode != 0x7E )
    ) {
        LoadStringW(g_hinst,
                    IDS_KEYBOARDOBJECT + DIDFT_GETINSTANCE(dwDevType),
                    lpwszName, nSize);
    }
    
    if( lpwszName[0] == L'\0' ) {
        hres = DIERR_OBJECTNOTFOUND;
    } else {
        hres = S_OK;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | DIGetOSVersion |
 *
 *          Return the OS version on which DInput8.dll is running.
 *          
 *  @returns
 *
 *          WIN95_OS, WIN98_OS, WINME_OS, WINNT_OS, WINWH_OS, or WIN_UNKNOWN_OS.
 *
 *****************************************************************************/

DWORD DIGetOSVersion()
{
    OSVERSIONINFO osVerInfo;
    DWORD dwVer;

    if( GetVersion() < 0x80000000 ) {
        dwVer = WINNT_OS;
    } else {
        dwVer = WIN95_OS;  //assume Windows 95 for safe
    }

    osVerInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );

    // If GetVersionEx is supported, then get more details.
    if( GetVersionEx( &osVerInfo ) )
    {
        // Win2K
        if( osVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT )
        {
            // Whistler: Major = 5 & Build # > 2195
            if( osVerInfo.dwMajorVersion == 5 && osVerInfo.dwBuildNumber > 2195 )
            {
                dwVer = WINWH_OS;
            } else {
                dwVer = WINNT_OS;
            }
        }
        // Win9X
        else
        {
            if( (HIBYTE(HIWORD(osVerInfo.dwBuildNumber)) == 4) ) 
            {
                // WinMe: Major = 4, Minor = 90
                if( (LOBYTE(HIWORD(osVerInfo.dwBuildNumber)) == 90) )
                {
                    dwVer = WINME_OS;
                } else if ( (LOBYTE(HIWORD(osVerInfo.dwBuildNumber)) > 0) ) {
                    dwVer = WIN98_OS;
                } else {
                    dwVer = WIN95_OS;
                }
            }
        }
    }

    return dwVer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\valid.c ===
/*****************************************************************************
 *
 *  Valid.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Validate services.  On a validation error that would not have
 *      been caught in retail, we throw an exception.
 *
 *  Contents:
 *
 *      fFullValidPhwnd
 *      fFullValidPpdw
 *      fFullValidPpfn
 *      fFullValidReadPx
 *      fFullValidWritePx
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidHwnd |
 *
 *          Validate a window handle completely.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window handle to validate.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_HANDLE> if the parameter is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidHwnd_(HWND hwnd, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    if (IsWindow(hwnd)) {
        hres = S_OK;
    } else {
        RPF("ERROR %s: arg %d: not a window handle", s_szProc, iarg);
        hres = E_HANDLE;
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidPvCb_ |
 *
 *          Validate that a buffer is readable or writeable.
 *
 *  @parm   PV | pv |
 *
 *          Buffer address.
 *
 *  @parm   UINT | cb |
 *
 *          Size of buffer in bytes.
 *
 *  @parm   PFNBAD | pfnBad |
 *
 *          Function that determines whether the buffer is bad.
 *          Should be <f IsBadReadPtr> or <f IsBadWritePtr>.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *          High word indicates how many bytes should not be
 *          scrambled.
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the parameter is invalid.
 *
 *****************************************************************************/

typedef BOOL (WINAPI *PFNBAD)(PCV pv, UINT_PTR cb);

#ifndef XDEBUG

#define hresFullValidPvCb_(pv, cb, pfnBad, z, i)                    \
       _hresFullValidPvCb_(pv, cb, pfnBad)                          \

#endif

STDMETHODIMP
hresFullValidPvCb_(PCV pv, UINT cb, PFNBAD pfnBad, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    if (!pfnBad(pv, LOWORD(cb))) {
        hres = S_OK;
    } else {
        RPF("ERROR %s: arg %d: invalid pointer", s_szProc, LOWORD(iarg));
        hres = E_POINTER;
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidWritePvCb_ |
 *
 *          Validate that a buffer is writeable.  Also scrambles it
 *          if special goo doesn't need to be done.
 *
 *  @parm   PV | pv |
 *
 *          Buffer address.
 *
 *  @parm   UINT | cb |
 *
 *          Size of buffer in bytes.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the parameter is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidWritePvCb_(PV pv, UINT cb, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    hres = hresFullValidPvCb_(pv, cb, (PFNBAD)IsBadWritePtr, s_szProc, iarg);
#ifdef XDEBUG
    if (SUCCEEDED(hres) && HIWORD(iarg) == 0) {
        ScrambleBuf(pv, cb);
    }
#endif
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidWriteLargePvCb_ |
 *
 *          Validate that a large buffer is writeable.  
 *          "Large" means 64K or more. 
 *          Also scrambles it if special goo doesn't need to be done.
 *
 *  @parm   PV | pv |
 *
 *          Buffer address.
 *
 *  @parm   UINT | cb |
 *
 *          Size of buffer in bytes.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the parameter is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidWriteLargePvCb_(PV pv, UINT cb, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    if( !IsBadWritePtr( pv, cb ) ) 
    {
        hres = S_OK;
    } else {
        RPF("ERROR %s: arg %d: invalid pointer", s_szProc, LOWORD(iarg));
        hres = E_POINTER;
    }
#ifdef XDEBUG
    if (SUCCEEDED(hres) && HIWORD(iarg) == 0) {
        ScrambleBuf(pv, cb);
    }
#endif
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidReadPvCb_ |
 *
 *          Validate that a buffer is readable.
 *
 *  @parm   PV | pv |
 *
 *          Buffer address.
 *
 *  @parm   UINT | cb |
 *
 *          Size of buffer in bytes.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the parameter is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidReadPvCb_(PCV pv, UINT cb, LPCSTR s_szProc, int iarg)
{
    return hresFullValidPvCb_(pv, cb, (PFNBAD)IsBadReadPtr, s_szProc, iarg);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidPxCb_ |
 *
 *          Validate that a sized structure is readable or writeable.
 *
 *  @parm   PCV | pv |
 *
 *          Structure address.  The first field of the structure must
 *          be a <p dwSize>.  If the structure is being validated for
 *          writing, then all fields beyond the <p dwSize> are scrambled
 *          in XDEBUG.
 *
 *  @parm   UINT | cbHiLo |
 *
 *          Expected sizes of the structure.  One valid size is in the
 *          low word.  An optional alternate valid size is in the high
 *          word.  (The alternate valid size is needed because some
 *          structures changed size between DirectX 3 and DirectX 5.)
 *
 *  @parm   STRUCTPROC | pfnStruct |
 *
 *          Function which validates that a structure is readable or writable.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the buffer is not readable or writeable.
 *
 *          <c E_INVALIDARG> if the buffer size is incorrect.
 *
 *****************************************************************************/

typedef STDMETHOD(STRUCTPROC)(PCV pv, UINT cb
                                   RD(comma LPCSTR s_szProc comma int iarg));

#ifndef XDEBUG

#define hresFullValidPxCb_(pv, cbHiLo, pfnStruct, z, i)             \
       _hresFullValidPxCb_(pv, cbHiLo, pfnStruct)                   \

#endif

STDMETHODIMP
hresFullValidPxCb_(PCV pv, UINT cbHiLo, STRUCTPROC pfnStruct,
                   LPCSTR s_szProc, int iarg)
{
    HRESULT hres;

    /*
     *  Raymond frequently suffers a brain lapse and passes
     *  a cbX(LPMUMBLE) instead of a cbX(MUMBLE).
     */
    AssertF(LOWORD(cbHiLo) != cbX(DWORD));
    AssertF(HIWORD(cbHiLo) != cbX(DWORD));

    if (!IsBadReadPtr(pv, cbX(DWORD))) {

        DWORD cbIn = *(LPDWORD)pv;

        /*
         *  The leading "cbIn &&" prevents the HIWORD(cbHiLo)==0 case from
         *  accidentally allowing a size of zero to sneak past.
         */

        if (cbIn && (cbIn == LOWORD(cbHiLo) || cbIn == HIWORD(cbHiLo))) {

            hres = pfnStruct(pv, cbIn RD(comma s_szProc comma iarg));
            if (SUCCEEDED(hres)) {
                if (HIWORD(iarg)) {
                    ScrambleBuf(pvAddPvCb(pv, HIWORD(iarg)),
                                cbIn - HIWORD(iarg));
                }
            }
        } else {
            RPF("ERROR %s: arg %d: invalid dwSize x%x", s_szProc, LOWORD(iarg), cbIn);
            hres = E_INVALIDARG;
        }
    } else {
        RPF("ERROR %s: arg %d: invalid pointer", s_szProc, LOWORD(iarg));
        hres = E_POINTER;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidPxCb3_ |
 *
 *          Validate that a sized structure is readable or writeable.
 *
 *  @parm   PCV | pv |
 *
 *          Structure address.  The first field of the structure must
 *          be a <p dwSize>.  If the structure is being validated for
 *          writing, then all fields beyond the <p dwSize> are scrambled
 *          in XDEBUG.
 *
 *  @parm   UINT | cb |
 *
 *          Expected sizes of the structure.
 *
 *  @parm   UINT | cb2 |
 *
 *          Expected sizes of the alternate structure.
 *
 *  @parm   UINT | cb3 |
 *
 *          Expected sizes of the alternate structure.
 *
 *  @parm   STRUCTPROC | pfnStruct |
 *
 *          Function which validates that a structure is readable or writable.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the buffer is not readable or writeable.
 *
 *          <c E_INVALIDARG> if the buffer size is incorrect.
 *
 *****************************************************************************/

#ifndef XDEBUG

#define hresFullValidPxCb3_(pv, cb, cb2, cb3, pfnStruct, z, i)             \
       _hresFullValidPxCb3_(pv, cb, cb2, cb3, pfnStruct)                   \

#endif

STDMETHODIMP
hresFullValidPxCb3_(PCV pv, UINT cb, UINT cb2, UINT cb3, STRUCTPROC pfnStruct,
                   LPCSTR s_szProc, int iarg)
{
    HRESULT hres;

    /*
     *  Raymond frequently suffers a brain lapse and passes
     *  a cbX(LPMUMBLE) instead of a cbX(MUMBLE).
     */
    AssertF(cb  != cbX(DWORD));
    AssertF(cb2 != cbX(DWORD));
    AssertF(cb3 != cbX(DWORD));

    if (!IsBadReadPtr(pv, cbX(DWORD))) {

        DWORD cbIn = *(LPDWORD)pv;

        /*
         *  The leading "cbIn &&" prevents the HIWORD(cbHiLo)==0 case from
         *  accidentally allowing a size of zero to sneak past.
         */

        if (cbIn && (cbIn == cb || cbIn == cb2 || cbIn == cb3)) {

            hres = pfnStruct(pv, cbIn RD(comma s_szProc comma iarg));
            if (SUCCEEDED(hres)) {
                if (HIWORD(iarg)) {
                    ScrambleBuf(pvAddPvCb(pv, HIWORD(iarg)),
                                cbIn - HIWORD(iarg));
                }
            }
        } else {
            RPF("ERROR %s: arg %d: invalid dwSize", s_szProc, LOWORD(iarg));
            hres = E_INVALIDARG;
        }
    } else {
        RPF("ERROR %s: arg %d: invalid pointer", s_szProc, LOWORD(iarg));
        hres = E_POINTER;
    }

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidWritePxCb_ |
 *
 *          Validate that a sized structure is writeable.  The contents
 *          of the structure are scrambled before returning.
 *
 *  @parm   PV | pv |
 *
 *          Structure address.  The first field of the structure must
 *          be a <p dwSize>.
 *
 *  @parm   UINT | cbHiLo |
 *
 *          Expected sizes of the structure.  One valid size is in the
 *          low word.  An optional alternate valid size is in the high
 *          word.  (The alternate valid size is needed because some
 *          structures changed size between DirectX 3 and DirectX 5.)
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the buffer is not writeable.
 *
 *          <c E_INVALIDARG> if the buffer size is incorrect.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidWritePxCb_(PV pv, UINT cb, LPCSTR s_szProc, int iarg)
{
    /*
     *  We need to distinguish hresFullValidWritePvCb_ and
     *  _hresFullValidWritePvCb_ manually, because the preprocessor
     *  can't do it.
     *
     *  We also need to put a cbX(DWORD) into the high word of the iarg
     *  so that the size field won't get demolished.
     */
#ifdef XDEBUG
    return hresFullValidPxCb_(pv, cb, (STRUCTPROC)hresFullValidWritePvCb_,
                                      s_szProc, MAKELONG(iarg, cbX(DWORD)));
#else
    return hresFullValidPxCb_(pv, cb, (STRUCTPROC)_hresFullValidWritePvCb_,
                                      s_szProc, iarg);
#endif
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidReadPxCb3_ |
 *
 *          Validate that a sized structure is readable.  The contents
 *          of the structure are scrambled before returning.
 *
 *  @parm   PV | pv |
 *
 *          Structure address.  The first field of the structure must
 *          be a <p dwSize>.
 *
 *  @parm   UINT | cb |
 *
 *          One expected size of the structure.  
 *
 *  @parm   UINT | cb2 |
 *
 *          Expected sizes of the alternate structure.
 *
 *  @parm   UINT | cb3 |
 *
 *          Expected sizes of the alternate structure.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the buffer is not readable.
 *
 *          <c E_INVALIDARG> if the buffer size is incorrect.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidReadPxCb3_(PV pv, UINT cb, UINT cb2, UINT cb3, LPCSTR s_szProc, int iarg)
{
    /*
     *  We need to distinguish hresFullValidReadPvCb_ and
     *  _hresFullValidReadPvCb_ manually, because the preprocessor
     *  can't do it.
     */
#ifdef XDEBUG
    return hresFullValidPxCb3_(pv, cb, cb2, cb3, (STRUCTPROC)hresFullValidReadPvCb_,
                                      s_szProc, iarg);
#else
    return hresFullValidPxCb3_(pv, cb, cb2, cb3, (STRUCTPROC)_hresFullValidReadPvCb_,
                                      s_szProc, iarg);
#endif
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidWritePxCb3_ |
 *
 *          Validate that a sized structure is writeable.  The contents
 *          of the structure are scrambled before returning.
 *
 *  @parm   PV | pv |
 *
 *          Structure address.  The first field of the structure must
 *          be a <p dwSize>.
 *
 *  @parm   UINT | cb |
 *
 *          Expected sizes of the structure.  One valid size is in the
 *          low word.  An optional alternate valid size is in the high
 *          word.  (The alternate valid size is needed because some
 *          structures changed size between DirectX 3 and DirectX 5.)
 *
 *  @parm   UINT | cb2 |
 *
 *          Expected sizes of the alternate structure.
 *
 *  @parm   UINT | cb3 |
 *
 *          Expected sizes of the alternate structure.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the buffer is not writeable.
 *
 *          <c E_INVALIDARG> if the buffer size is incorrect.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidWritePxCb3_(PV pv, UINT cb, UINT cb2, UINT cb3, LPCSTR s_szProc, int iarg)
{
    /*
     *  We need to distinguish hresFullValidWritePvCb_ and
     *  _hresFullValidWritePvCb_ manually, because the preprocessor
     *  can't do it.
     *
     *  We also need to put a cbX(DWORD) into the high word of the iarg
     *  so that the size field won't get demolished.
     */
#ifdef XDEBUG
    return hresFullValidPxCb3_(pv, cb, cb2, cb3, (STRUCTPROC)hresFullValidWritePvCb_,
                                      s_szProc, MAKELONG(iarg, cbX(DWORD)));
#else
    return hresFullValidPxCb3_(pv, cb, cb2, cb3, (STRUCTPROC)_hresFullValidWritePvCb_,
                                      s_szProc, iarg);
#endif
}

#ifdef XDEBUG

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidWriteNoScramblePxCb_ |
 *
 *          Validate that a sized structure is writeable.  The contents
 *          of the structure are not scrambled.
 *
 *  @parm   PV | pv |
 *
 *          Structure address.  The first field of the structure must
 *          be a <p dwSize>.
 *
 *  @parm   UINT | cbHiLo |
 *
 *          Expected sizes of the structure.  One valid size is in the
 *          low word.  An optional alternate valid size is in the high
 *          word.  (The alternate valid size is needed because some
 *          structures changed size between DirectX 3 and DirectX 5.)
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the buffer is not writeable.
 *
 *          <c E_INVALIDARG> if the buffer size is incorrect.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidWriteNoScramblePxCb_(PV pv, UINT cb, LPCSTR s_szProc, int iarg)
{
    return hresFullValidPxCb_(pv, cb, (STRUCTPROC)hresFullValidWritePvCb_,
                                      s_szProc, MAKELONG(iarg, cb));
}
#endif


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidReadPxCb_ |
 *
 *          Validate that a sized structure is readable.
 *
 *  @parm   PV | pv |
 *
 *          Structure address.  The first field of the structure must
 *          be a <p dwSize>.
 *
 *  @parm   UINT | cbHiLo |
 *
 *          Expected sizes of the structure.  One valid size is in the
 *          low word.  An optional alternate valid size is in the high
 *          word.  (The alternate valid size is needed because some
 *          structures changed size between DirectX 3 and DirectX 5.)
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the buffer is not readable.
 *
 *          <c E_INVALIDARG> if the buffer size is incorrect.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidReadPxCb_(PCV pv, UINT cb, LPCSTR s_szProc, int iarg)
{
    /*
     *  We need to distinguish hresFullValidReadPvCb_ and
     *  _hresFullValidReadPvCb_ manually, because the preprocessor
     *  can't do it.
     */
#ifdef XDEBUG
    return hresFullValidPxCb_(pv, cb, hresFullValidReadPvCb_, s_szProc, iarg);
#else
    return hresFullValidPxCb_(pv, cb, _hresFullValidReadPvCb_, s_szProc, iarg);
#endif
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidFl_ |
 *
 *          Validate that no invalid flags are passed.
 *
 *  @parm   DWORD | fl |
 *
 *          Flags passed by the caller.
 *
 *  @parm   DWORD | flV |
 *
 *          Flags which are valid.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_INVALIDARG> if the parameter is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidFl_(DWORD fl, DWORD flV, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    if ((fl & ~flV) == 0) {
        hres = S_OK;
    } else {
        RPF("ERROR %s: arg %d: invalid flags", s_szProc, iarg);
        hres = E_INVALIDARG;
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidPfn_ |
 *
 *          Validate that the parameter is a valid code pointer.
 *
 *          Actually, <f IsValidCodePtr> on Win32 is broken, but
 *          tough.
 *
 *  @parm   FARPROC | pfn |
 *
 *          Procedure to "validate".
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_INVALIDARG> if the parameter is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidPfn_(FARPROC pfn, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    if (!IsBadCodePtr(pfn)) {
        hres = S_OK;
    } else {
        RPF("ERROR %s: arg %d: invalid callback address", s_szProc, iarg);
        hres = E_INVALIDARG;
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidPitf_ |
 *
 *          Validate that the parameter is an interface pointer.
 *
 *          We don't look at it very hard.
 *
 *  @parm   PUNK | punk |
 *
 *          <i IUnknown> to "validate".
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the pointer itself is bogus.
 *
 *          <c E_INVALIDARG> if something inside the pointer is bogus.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidPitf_(PUNK punk, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;

    if (!IsBadReadPtr(punk, cbX(*punk))) {
        IUnknownVtbl *pvtbl = punk->lpVtbl;
        if (!IsBadReadPtr(pvtbl, cbX(*pvtbl))) {
            if (!IsBadCodePtr((FARPROC)pvtbl->QueryInterface) &&
                !IsBadCodePtr((FARPROC)pvtbl->AddRef) &&
                !IsBadCodePtr((FARPROC)pvtbl->Release)) {
                hres = S_OK;
            } else {
                RPF("ERROR %s: arg %d: invalid pointer", s_szProc, iarg);
                hres = E_INVALIDARG;
            }
        } else {
            RPF("ERROR %s: arg %d: invalid pointer", s_szProc, iarg);
            hres = E_INVALIDARG;
        }
    } else {
        RPF("ERROR %s: arg %d: invalid pointer", s_szProc, iarg);
        hres = E_POINTER;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidPcbOut_ |
 *
 *          Validate that the parameter is a valid place to stick an
 *          output result.  We also smas it to zero.
 *
 *  @parm   PV | pcb |
 *
 *          Pointer to "validate".
 *
 *  @parm   UINT | cb |
 *
 *          Size of data pcb points to.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the pointer itself is bogus.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidPcbOut_(PV pcb, UINT cb, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    if (!IsBadWritePtr(pcb, cb)) {
        memset(pcb,0,cb);
        hres = S_OK;
    } else {
        RPF("ERROR %s: arg %d: invalid pointer", s_szProc, iarg);
        hres = E_POINTER;
    }
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidReadStrA_ |
 *
 *          Validate that the parameter is a valid readable
 *          ANSI string of maximum length <p cch>.
 *
 *          Note that we cannot use <f IsBadStringPtr> because
 *          <f IsBadStringPtr> handles the "string too long"
 *          case incorrectly.  Instead, we use <f lstrlenA>.
 *
 *  @parm   LPCSTR | psz |
 *
 *          String to "validate".
 *
 *  @parm   UINT | cch |
 *
 *          Maximum string length, including null terminator.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_INVALIDARG> if the pointer itself is bogus.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidReadStrA_(LPCSTR psz, UINT cch, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    UINT cchT;

    /*
     *  lstrlenA returns 0 if the parameter is invalid.
     *  It also returns 0 if the string is null.
     */
    cchT = (UINT)lstrlenA(psz);

    if (cchT == 0) {
        /*
         *  The ambiguous case.  See if it's really a null string.
         */
        if (IsBadReadPtr(psz, cbCch(1)) || psz[0]) {
            RPF("ERROR %s: arg %d: invalid ANSI string", s_szProc, iarg);
            hres = E_INVALIDARG;
        } else {
            hres = S_OK;
        }
    } else if (cchT < cch) {
        hres = S_OK;
    } else {
        RPF("ERROR %s: arg %d: invalid ANSI string", s_szProc, iarg);
        hres = E_INVALIDARG;
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidReadStrW_ |
 *
 *          Validate that the parameter is a valid readable
 *          UNICODE string of maximum length <p cwch>.
 *
 *          Note that we cannot use <f IsBadStringPtr> because
 *          <f IsBadStringPtr> handles the "string too long"
 *          case incorrectly.  Instead, we use <f lstrlenW>.
 *
 *  @parm   LPCWSTR | pwsz |
 *
 *          String to "validate".
 *
 *  @parm   UINT | cwch |
 *
 *          Maximum string length, including null terminator.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_INVALIDARG> if the pointer itself is bogus.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidReadStrW_(LPCWSTR pwsz, UINT cwch, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    UINT cwchT;

    hres = E_INVALIDARG;
    /*
     *  lstrlenW returns 0 if the parameter is invalid.
     *  It also returns 0 if the string is null.
     */
    cwchT = (UINT)lstrlenW(pwsz);

    if (cwchT == 0) {
        /*
         *  The ambiguous case.  See if it's really a null string.
         */
        if (IsBadReadPtr(pwsz, cbCwch(1)) || pwsz[0]) {
            RPF("ERROR %s: arg %d: invalid UNICODE string", s_szProc, iarg);
            hres = E_INVALIDARG;
        } else {
            hres = S_OK;
        }
    } else if (cwchT < cwch) {
        hres = S_OK;
    } else {
        RPF("ERROR %s: arg %d: invalid UNICODE string", s_szProc, iarg);
        hres = E_INVALIDARG;
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidPesc_ |
 *
 *          Validate that the parameter is a valid <t DIEFFESCAPE>
 *          structure.
 *
 *          This is merely a wrapper around other validation methods.
 *
 *  @parm   LPDIEFFESCAPE | pesc |
 *
 *          Structure to "validate".
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_INVALIDARG> if the pointer itself is bogus.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidPesc_(LPDIEFFESCAPE pesc, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;

    if (SUCCEEDED(hres = hresFullValidWriteNoScramblePxCb(pesc, DIEFFESCAPE,
                                                          iarg)) &&
        SUCCEEDED(hres = hresFullValidReadPvCb(pesc->lpvInBuffer,
                                               pesc->cbInBuffer, iarg)) &&
        SUCCEEDED(hres = hresFullValidWriteNoScramblePvCb(pesc->lpvOutBuffer,
                                                pesc->cbOutBuffer, iarg))) {
    } else {
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\sources.inc ===
!IF 0

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Sources.inc

    Abstract:

    Common makefile settings for DInput.

Author:

    RaymondC and a-MarcAn 1996-10-17

History:
    Date        By          Reason
    ====        ==          ======
    1996-       RaymondC    first version
    1996-10-17  a-MarcAn    tidied and adjusted for checkin to windows\media
			    disabled NTTARGETFILE0
    1996-12-06  RaymondC    Split NT and 95 versions
    1997-01-09  a-MarcAn    Set to OS version 0x403

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

!ifndef DXROOT
DXROOT=$(BASEDIR)\MultiMedia\DirectX
!endif

!INCLUDE $(DXROOT)\Project.mk

# we have to be able to run w/ all versions of IE but prsht.h insists
# on IE 4.0 if you pass WIN32_WINNT_VERSION of 0x0500
WIN32_IE_VERSION=0x0400

!IFDEF TARGET_WIN95
#
# CHICAGO_PRODUCT: Suppress -DWINNT
# USE_MAPSYM: Create a .sym file
# ALT_PROJECT_TARGET: Alternate drop point (yes, they call it `chicago')
# WIN32_DEFINE: The things we #define; _WIN32_WINNT is the important one
#               because it's that one that gives us WH_*_LL.
#               We need 0x0403 to get WH_*_LL in SP3 tree
#
DLLBASE=0x70000000
CHICAGO_PRODUCT = 1
ALT_PROJECT_TARGET = WIN9x
C_DEFINES=$(C_DEFINES) -DWIN95 -D_X86_
WIN32_DEFINE = -DWIN32=100 -D_WIN32_WINDOWS=0x0400 -D_WIN32_WINNT=0x0400

! IF $(FREEBUILD)
#Win9x Free Build
#USE_NOLIBS=1
TARGETLIBS= $(SDK_LIB_PATH)\exsup.lib
#DLLENTRY=DllMain
DLLENTRY=_DllMainCRTStartup        
! ELSE
# Win9x Chk Build        
USE_LIBCMT=1
DLLENTRY=_DllMainCRTStartup

! ENDIF

! ELSE
#Win2k Build
DLLENTRY=DllMain

! IF defined( DIRECTX_REDIST )
WIN32_WINNT_VERSION=0x0500
! ENDIF

C_DEFINES=$(C_DEFINES) -DWINNT -DUNICODE

!ENDIF

USE_MAPSYM = 1

C_DEFINES=$(C_DEFINES) -DNOWINRES -DUSE_SLOW_LL_HOOKS -DHID_SUPPORT

MAJORCOMP=windows
MINORCOMP=media
UMTYPE=windows

TARGETNAME=dinput8

!IF !$(FREEBUILD) && defined( DIRECTX_REDIST )
TARGETNAME=$(TARGETNAME)d
!ENDIF

TARGETTYPE=DYNLINK
TARGETPATH=obj


INCLUDES=$(INCLUDES); \
        ..\;\
        $(DXROOT)\inc;\

CONDITIONAL_INCLUDES=\
    commctrl.rh      \
    version.h        \
    ieverp.h         \
    $(CONDITIONAL_INCLUDES)

NTTARGETFILES=

#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           $(SDK_LIB_PATH)\kernel32.lib     \
	   $(SDK_LIB_PATH)\advapi32.lib     \
	   $(SDK_LIB_PATH)\user32.lib       \
	   $(SDK_LIB_PATH)\uuid.lib         \
           $(TARGETLIBS)         

LINKER_FLAGS=$(LINKER_FLAGS) -SECTION:share,RWS

!IF !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
!endif


SOURCES=\
    ..\assert.c     \
    ..\common.c     \
    ..\diaphack.c   \
    ..\dicf.c       \
    ..\didev.c      \
    ..\didevdf.c    \
    ..\didevef.c    \
    ..\diem.c       \
    ..\diemm.c      \
    ..\diemk.c      \
    ..\diemh.c      \
    ..\digenj.c     \
    ..\dical.c      \
    ..\dijoytyp.c   \
    ..\dieffj.c     \
    ..\dieffv.c     \
    ..\dieshep.c    \
    ..\digenk.c     \
    ..\digenm.c     \
    ..\digenx.c     \
    ..\digendef.c   \
    ..\dihel.c      \
    ..\dimem.c      \
    ..\dinput.c     \
    ..\diobj.c      \
    ..\dieff.c      \
    ..\didenum.c    \
    ..\dihidenm.c   \
    ..\dihidusg.c   \
    ..\dihid.c      \
    ..\dihidini.c   \
    ..\dihiddat.c   \
    ..\diguid.c     \
    ..\dijoycfg.c   \
    ..\dithunk.c    \
    ..\diaddhw.c    \
    ..\dijoyreg.c   \
    ..\direg.c      \
    ..\disubcls.c   \
    ..\diexcl.c     \
    ..\diutil.c     \
    ..\dilist.c     \
    ..\dioledup.c   \
    ..\diregutl.c   \
    ..\diextdll.c   \
    ..\valid.c      \
    ..\diwinnt.c    \
    ..\dijoyhid.c   \
    ..\diport.c     \
    ..\dinput.rc    \
    ..\guids.c      \
    ..\diriff.c     \
    ..\diraw.c      \
    ..\dilib1.c     \
    ..\dilib2.c     \
    ..\dilib3.c     \
    ..\dilib4.c     \
    ..\dilib5.c     \
    ..\dimapshp.c   \

DLLDEF=..\dinput.def

PRECOMPILED_INCLUDE=..\dinputpr.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\dx8\dll\diwinnt.c ===
/*****************************************************************************
 *
 *  DIWdm.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      WINNT specific functions.
 *
 *  Contents:
 *
 *      hResIdJoyInstanceGUID
 *      DIWdm_SetLegacyConfig
 *      DIWdm_InitJoyId
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflWDM

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DIWdm_SetJoyId |
 *          Given a guid for a HID device and a Joystick ID.
 *          This function will swap the old joystick ID for the device
 *          specified by the guid ( pcguid ) for the new ID specified in 
 *          idJoy
 *
 *  @parm   IN UINT | idJoy |
 *
 *          The Joyid the the HID device specified  by pcguid should have. 
 *
 *  @parm   OUT LPGUID | pcguid |
 *
 *          GUID that specifies a HID device. 
 *
 *  @returns
 *          HRESULT
 *
 *****************************************************************************/
HRESULT EXTERNAL
    DIWdm_SetJoyId
    (
    IN PCGUID   pcguid,
    IN int      idJoy
    )
{
    PHIDDEVICEINFO  phdi;
    HRESULT         hres;
    BOOL            fConfigChanged = FALSE;

    EnterProcI(DIWdm_SetJoyId, (_"Gu", pcguid, idJoy));

    //PostDx7 patch:
    // No point setting the joystick entries in the registry
    // if the ID of the joystick is -1.
    if( idJoy == -1 )
    {
        return E_FAIL;
    }

    DllEnterCrit();

    hres = S_OK;

    /* Get pointer to HIDDEVICEINFO from the GUID */
    phdi = phdiFindHIDInstanceGUID(pcguid);
    if(phdi != NULL )
    {
        PHIDDEVICEINFO  phdiSwap = NULL;
        GUID            guidInstanceOld;
        LONG            lRc;
        int             idJoySwap;

        /* Swap the ID's */
        idJoySwap = phdi->idJoy;
        phdi->idJoy = idJoy;

        phdiSwap = NULL;
        /* Get the GUID for the old ID */
        if( SUCCEEDED( hres = hResIdJoypInstanceGUID_WDM(idJoySwap, &guidInstanceOld)) )
        {
            /* Get pointer to HIDDEVICEINFO for old ID */
            phdiSwap  = phdiFindHIDInstanceGUID(&guidInstanceOld);
            if( phdiSwap )
            {
                phdiSwap->idJoy = idJoySwap;
            } else
            {
                // Old device disappeared !
            }

        } else
        {
            DIJOYCONFIG c_djcReset = {
                cbX(c_djcReset),                   /* dwSize               */
                { 0},                              /* guidInstance         */
                { 0},                              /* hwc                  */
                DI_FFNOMINALMAX,                   /* dwGain               */
                { 0},                              /* wszType              */
                { 0},                              /* wszCallout           */
            };

            hres = JoyReg_SetConfig(idJoySwap, &c_djcReset.hwc,&c_djcReset, DIJC_SETVALID) ;
            if( FAILED(hres) )
            {
                SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("%S: JoyReg_SetConfig to NULL FAILED  "),
                                s_szProc );
            }

        }

        /* Set the new ID and LegacyConfig */
        if( phdi )
        {
            if( lRc = RegSetValueEx(phdi->hk, TEXT("Joystick Id"), 0, REG_BINARY,
                                    (PV)&idJoy, cbX(idJoy)) == ERROR_SUCCESS )
            {
                /*
                 * This extra RegSetValueEx on "Joystick Id" is to keep the 
                 * compatibility with Win2k Gold. 
                 * See Windows bug 395416 for detail.
                 */
                RegSetValueEx(phdi->hkOld, TEXT("Joystick Id"), 0, REG_BINARY,
                                    (PV)&idJoy, cbX(idJoy));

                if( SUCCEEDED( hres = DIWdm_SetLegacyConfig(idJoy)) )
                {
                    fConfigChanged = TRUE;
                }
            }
        }

        /* Set old ID and legacy Config */
        if( (phdiSwap != NULL) && (phdiSwap != phdi) )
        {
            if( lRc = RegSetValueEx(phdiSwap->hk, TEXT("Joystick Id"), 0, REG_BINARY,
                                    (PV)&idJoySwap, cbX(idJoySwap)) == ERROR_SUCCESS )
            {
                /*
                 * This extra RegSetValueEx on "Joystick Id" is to keep the 
                 * compatibility with Win2k Gold. 
                 * See Windows bug 395416 for detail.
                 */
                RegSetValueEx(phdiSwap->hkOld, TEXT("Joystick Id"), 0, REG_BINARY,
                                    (PV)&idJoySwap, cbX(idJoySwap));

                if( SUCCEEDED( hres = DIWdm_SetLegacyConfig(idJoySwap) ) )
                {
                    fConfigChanged = TRUE;
                }
            }
        } else if( phdiSwap == NULL )
        {
            // Old Device disappeared !
            if( SUCCEEDED( hres = DIWdm_SetLegacyConfig(idJoySwap) ) )
            {
               fConfigChanged = TRUE;
            }
        }
    } else
    {
        hres = E_FAIL;
        RPF("ERROR %s: invalid guid.", s_szProc);
    }

  #ifndef WINNT
    if( SUCCEEDED(hres) )
    {
        /*
         * Make sure the new Ids do not cause any collisions
         */
        DIWdm_InitJoyId();
    }
  #endif

    if( fConfigChanged ) {
      #ifdef WINNT
        Excl_SetConfigChangedTime( GetTickCount() );
        PostMessage(HWND_BROADCAST, g_wmJoyChanged, 0, 0L);   
      #else
        joyConfigChanged(0);
      #endif
    }

    DllLeaveCrit();

    ExitOleProc();

    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   HRESULT | hResIdJoyInstanceGUID_WDM |
 *
 *          Maps a HID JoyStick ID to a DeviceInstance GUID
 *
 *          The parameters have already been validated.
 *
 *
 *  @parm   IN UINT | idJoy |
 *
 *          The Joyid of the HID device to be located.
 *
 *  @parm   OUT LPGUID | lpguid |
 *
 *          The Device Instance GUID corresponding to the JoystickID
 *          If a mapping is not found GUID_NULL is passed back in lpguid
 *
 *  @returns
 *          HRESULT
 *
 *****************************************************************************/
HRESULT EXTERNAL hResIdJoypInstanceGUID_WDM
    (
    IN  UINT idJoy,
    OUT LPGUID lpguid
    )
{
    HRESULT hres = DIERR_NOTFOUND;
    EnterProc( hResIdJoypInstanceGUID_WDM, ( _ "ux", idJoy, lpguid) );

    /* Zap the guid for failure case */
    ZeroBuf(lpguid, cbX(*lpguid) );

    if( idJoy > cJoyMax )
    {
        hres = DIERR_NOMOREITEMS;
    } else
    {
        DllEnterCrit();    

        /* Build the HID list if it is too old */
        DIHid_BuildHidList(FALSE);

        /* Make sure there is some HID device */
        if(g_phdl)
        {
            int ihdi;
            PHIDDEVICEINFO  phdi;

            /* Search over all HID devices */
            for(ihdi = 0, phdi = g_phdl->rghdi;
               ihdi < g_phdl->chdi;
               ihdi++, phdi++)
            {
                /* Check for matching ID */
                if(idJoy == (UINT)phdi->idJoy)
                {
                    hres = S_OK;
                    /* Copy the GUID */
                    *lpguid = phdi->guid;
                    break;
                }
            }
        }
        DllLeaveCrit();
    }

    ExitBenignOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PHIDDEVICEINFO | phdiFindJoyId |
 *
 *          Locates information given a joystick ID for a HID device.
 *
 *          The parameters have already been validated.
 *
 *          The DLL critical must be held across the call; once the
 *          critical section is released, the returned pointer becomes
 *          invalid.
 *
 *  @parm   IN int | idJoy |
 *
 *          The Id of the joystick to be located.
 *
 *  @returns
 *
 *          Pointer to the <t HIDDEVICEINFO> that describes
 *          the device.
 *
 *****************************************************************************/

PHIDDEVICEINFO EXTERNAL
    phdiFindJoyId(int idJoy )
{
    PHIDDEVICEINFO phdi;

    EnterProcI(phdiFindJoyId, (_"u", idJoy));

    /* We should have atleast one HID device */
    if(g_phdl)
    {
        int ihdi;

        /* Loop over all HID devices */
        for(ihdi = 0, phdi = g_phdl->rghdi; ihdi < g_phdl->chdi;
           ihdi++, phdi++)
        {
            /* Match */
            if(idJoy == phdi->idJoy)
            {
                goto done;
            }
        }
    }
    phdi = 0;

    done:;

    ExitProcX((UINT_PTR)phdi);
    return phdi;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DIWdm_SetLegacyConfig |
 *
 *          Sets up the registry keys so that a joystick HID device
 *          can be "seen" by legacy APIs and the Control Panel.
 *          Primarily, this routine sets up the structs that are passed
 *          to JoyReg_SetConfig routine.
 *
 *  @parm   IN int  | idJoy |
 *
 *          Joystick ID.
 *
 *  @returns HRESULT 
 *
 *****************************************************************************/
//ISSUE-2001/03/29-timgill Fix unicode madness
HRESULT INTERNAL DIWdm_SetLegacyConfig
    (
    IN  int idJoy
    )
{
    HRESULT hres;
    DIJOYCONFIG         cfg;
    BOOL                fNeedType;
    BOOL                fNeedConfig;
    BOOL                fNeedNone;
    HKEY                hk;
    DIJOYTYPEINFO       dijti;
    PHIDDEVICEINFO      phdi;
    WCHAR               wszType[cA(VID_PID_TEMPLATE)];
#ifndef UNICODE
    char szType[cbX(VID_PID_TEMPLATE)];
#endif

    EnterProcI(DIWdm_SetLegacyConfig, (_ "u", idJoy));

    if( idJoy == -1 )
    {
        // Dx7Gold Patch:
        // ID == -1 implies this device is not joystick.
        // Do not write any entries to the registry
        return E_FAIL;
    }

    ZeroX(dijti);
    dijti.dwSize = cbX(dijti);

    fNeedType = fNeedConfig = TRUE;
    fNeedNone = FALSE;


    /*
     *  1. Find out what the WinMM registry data is saying now
     */
    CAssertF( JOY_HW_NONE == 0 );
    hres = JoyReg_OpenConfigKey(idJoy, KEY_QUERY_VALUE, 0x0, &hk);
    if( SUCCEEDED(hres) )
    {
        /* Get the type name from the registry */
        JoyReg_GetConfigValue(
                             hk, REGSTR_VAL_JOYNOEMNAME, idJoy, REG_SZ,
                             &cfg.wszType, cbX(cfg.wszType) );
        hres = JoyReg_GetConfigValue(
                                    hk, REGSTR_VAL_JOYNCONFIG, idJoy, REG_BINARY,
                                    &cfg.hwc, cbX(cfg.hwc) );
        RegCloseKey(hk);
    } else
    {
        cfg.wszType[0] = '\0';
    }
    if( FAILED( hres ) )
    {
        cfg.hwc.dwType = JOY_HW_NONE;
    }

    /*
     *  2. If the config info is in sync with WDM then don't rewrite 
     */
    phdi = phdiFindJoyId(idJoy);
    if( phdi )
    {
        /*
         *  The type key for HID devices is "VID_xxxx&PID_yyyy",
         *  mirroring the format used by plug and play.
         */

        if( ( LOWORD(phdi->guidProduct.Data1) == MSFT_SYSTEM_VID )
            &&( ( HIWORD(phdi->guidProduct.Data1) >= MSFT_SYSTEM_PID + JOY_HW_PREDEFMIN ) 
                &&( HIWORD(phdi->guidProduct.Data1) < MSFT_SYSTEM_PID + JOY_HW_PREDEFMAX ) ) )
        {
            /* Predefined type definitions don't go into the registry */
            fNeedType = FALSE;

            /*
             *  Predefined types are determined by the dwType value so fix 
             *  only it if that is wrong.
             */
            if( cfg.hwc.dwType + MSFT_SYSTEM_PID == HIWORD(phdi->guidProduct.Data1) )
            {
                fNeedConfig = FALSE;
            } else
            {
                /*
                 *  Get type info so that JOY_HWS_* flags start with correct values.
                 */
                wszType[0] = L'#';
                wszType[1] = L'0' + HIWORD(phdi->guidProduct.Data1) - MSFT_SYSTEM_PID;
                wszType[2] = L'\0';
                JoyReg_GetPredefTypeInfo(wszType, &dijti, DITC_INREGISTRY | DITC_DISPLAYNAME);        
            }
        } else
        {
            /*
             * This should work, but it doesn't in Win98.
             *
             *   ctch = wsprintfW(wszType, L"VID_%04X&PID_%04X",
             *                LOWORD(phdi->guidProduct.Data1), HIWORD(phdi->guidProduct.Data1));
             */

#ifdef UNICODE
            wsprintfW(wszType, VID_PID_TEMPLATE,
                      LOWORD(phdi->guidProduct.Data1), HIWORD(phdi->guidProduct.Data1));
            CharUpperW(wszType);
#else
            wsprintf(szType, VID_PID_TEMPLATE,
                     LOWORD(phdi->guidProduct.Data1), HIWORD(phdi->guidProduct.Data1));
            CharUpper( szType );
            AToU( wszType, cA(wszType), szType );
#endif
        }
    } else
    {
        /*
         *  There is no WDM device so flag for deletion if the WinMM data is wrong
         */
        if( ( cfg.hwc.dwType != JOY_HW_NONE ) || ( cfg.wszType[0] != L'\0' ) )
        {
            fNeedNone = TRUE;
            fNeedType = fNeedConfig = FALSE;
        }
    }


    if( fNeedType ) /* Not already decided against (predefined type) */
    {
        /* Does the registry have the correct device ? */

        /*
         * lstrcmpW doesn't work in Win9x, bad. We have to use our own DiChauUpperW, 
         * then memcmp. Also, the wsprintf template has to use 'X' not 'x'.
         */
        
        DiCharUpperW(cfg.wszType);
        if( (memcmp(cfg.wszType, wszType, cbX(wszType)) == 0x0) 
            && (cfg.hwc.dwType >= JOY_HW_PREDEFMAX) )
        {
            fNeedConfig = FALSE;   
        }

        /* Check the type key */
        hres = JoyReg_GetTypeInfo(wszType, &dijti, DITC_INREGISTRY);
        if( SUCCEEDED(hres) )
        {
            fNeedType = FALSE;
        }
    }

    /*
     *  No failures up to this point should be returned
     */
    hres = S_OK;


    /*
     *  3. If something is missing, find the data from WDM and set it straight
     */
    if( fNeedType || fNeedConfig )
    {
        if( fNeedConfig ) {
            ZeroX(cfg);
            cfg.dwSize   = cbX(cfg);

            hres = DIWdm_JoyHidMapping(idJoy, NULL, &cfg, &dijti );
        } else {

            hres = DIWdm_JoyHidMapping(idJoy, NULL, NULL, &dijti );
        }

        if( SUCCEEDED(hres) )
        {
            if( fNeedType == TRUE)
            {
                hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE, 
                                       REGSTR_PATH_JOYOEM, 
                                       DI_KEY_ALL_ACCESS, 
                                       REG_OPTION_NON_VOLATILE, 
                                       &hk);

                if( SUCCEEDED(hres) )
                {
                    hres = JoyReg_SetTypeInfo(hk,
                                              cfg.wszType,
                                              &dijti,
                                              DITC_REGHWSETTINGS | DITC_DISPLAYNAME | DITC_HARDWAREID );
                    if( SUCCEEDED(hres ) )
                    {
                    } else // SetTypeinfo FAILED
                        SquirtSqflPtszV(sqfl | sqflError,
                                        TEXT("%S: JoyReg_SetTypeInfo FAILED  "),
                                        s_szProc );

                    RegCloseKey(hk);
                } else // SetTypeinfo FAILED
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%S: JoyReg_OpenTypeKey FAILED  "),
                                    s_szProc );
            }

            if( fNeedConfig )
            {
                hres = JoyReg_SetConfig(idJoy,
                                        &cfg.hwc,
                                        &cfg,
                                        DIJC_INREGISTRY);

                if( SUCCEEDED(hres) )
                {
                  #ifdef WINNT
                    Excl_SetConfigChangedTime( GetTickCount() );
                    PostMessage (HWND_BROADCAST, g_wmJoyChanged, idJoy+1, 0L);
                  #else
                    joyConfigChanged(0);
                  #endif
                } else
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT(",JoyReg_SetConfig FAILED hres=%d"),
                                    hres);
                }
            }
        } else // DIWdm_GetJoyHidMapping FAILED 
        {
            fNeedNone = TRUE;
        }
    }

    /*
     *  4. If WinMM has data for a device that WDM does not, delete it
     */
    if( fNeedNone )
    {
        ZeroX( cfg );
        cfg.dwSize = cbX( cfg );
        cfg.dwGain = DI_FFNOMINALMAX;

        if(SUCCEEDED(hres = JoyReg_SetConfig(idJoy, &cfg.hwc,
                                             &cfg, DIJC_SETVALID)) &&
           SUCCEEDED(hres = JoyReg_OpenConfigKey(idJoy, MAXIMUM_ALLOWED,
                                                 REG_OPTION_VOLATILE, &hk)))
        {
            TCHAR tsz[MAX_JOYSTRING];

            wsprintf(tsz, TEXT("%u"), idJoy + 1);
          #ifdef WINNT
            DIWinnt_RegDeleteKey(hk, tsz);
          #else
            RegDeleteKey(hk, tsz);
          #endif
            RegCloseKey(hk);

            hres = S_OK;
        }
    }

    ExitProcX(hres);

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DIWdm_InitJoyId |
 *
 *          Initializes Joystick IDs for JoyConfig and legacy APIs
 *          Store the joystick IDs the registry under the %%DirectX/JOYID key.
 *
 *****************************************************************************/

BOOL EXTERNAL
    DIWdm_InitJoyId( void )
{
    BOOL    fRc;
    LONG    lRc;
    int     ihdi;
    int     idJoy;
    BOOL    fNeedId;
    BOOL    rfJoyId[cJoyMax];     /* Bool Array for to determine which IDs are in use */
    PHIDDEVICEINFO phdi;
    HRESULT hres = E_FAIL;

    EnterProcI(DIWdm_InitJoyId, (_ ""));

    DllEnterCrit();

    fRc = TRUE;
    ZeroX(rfJoyId );
    fNeedId = FALSE;


    /* Iterate over all HID devices to find used IDs */
    for( ihdi = 0, phdi = g_phdl->rghdi ;
       (g_phdl != NULL) && (phdi != NULL) && (phdi->fAttached) && (ihdi < g_phdl->chdi) ;
       ihdi++, phdi++ )
    {
        /* We need joyIDs only for HID game controller devices */
        if( ( GET_DIDEVICE_TYPE( phdi->osd.dwDevType ) >= DI8DEVTYPE_GAMEMIN ) 
         && ( phdi->osd.dwDevType & DIDEVTYPE_HID ) )
        {
            idJoy = phdi->idJoy ;

            /* Validate the ID. */
            if( idJoy < cJoyMax && rfJoyId[idJoy] != TRUE )
            {
                rfJoyId[idJoy] = TRUE;
                hres = DIWdm_SetLegacyConfig(idJoy);
                if( FAILED ( hres ) )
                {
                    fRc = FALSE;
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%S: DIWdm_SetLegacyConfig() FAILED ")
                                    TEXT("idJoy=%d FAILED hres = %d"),
                                    s_szProc, idJoy, hres );
                }
            } else 
            {
                /* ID either over the limit OR is already used */
                phdi->idJoy = JOY_BOGUSID;
                fNeedId = TRUE;
            }
        }
    }

    /* Are there devices that need an ID */
    if( fNeedId )
    {
        /*
         * We have Examined all Joystick Ids found used IDs
         * and determined some device needs an Id
         */
        /* Iterate to assign unused Id's */
        for( ihdi = 0, phdi = g_phdl->rghdi;
           ihdi < g_phdl->chdi ;
           ihdi++, phdi++ )
        {
            /* We need joyIDs only for HID game controller devices */
            if( ( GET_DIDEVICE_TYPE( phdi->osd.dwDevType ) >= DI8DEVTYPE_GAMEMIN ) 
             && ( phdi->osd.dwDevType & DIDEVTYPE_HID ) )
            {
                idJoy = phdi->idJoy;
                if( idJoy == JOY_BOGUSID  )
                {
                    /* Get an Unused ID */
                    for(idJoy = 0x0;
                       idJoy < cJoyMax;
                       idJoy++ )
                    {
                        if( rfJoyId[idJoy] == FALSE )
                            break;
                    }

                    if( idJoy < cJoyMax )
                    {
                        rfJoyId[idJoy] = TRUE;
                        phdi->idJoy  = idJoy;
                        if( lRc = RegSetValueEx(phdi->hk, TEXT("Joystick Id"), 0, REG_BINARY,
                                                (PV)&idJoy, cbX(idJoy)) == ERROR_SUCCESS )
                        {
                            /*
                             * This extra RegSetValueEx on "Joystick Id" is to keep the 
                             * compatibility with Win2k Gold. 
                             * See Windows bug 395416 for detail.
                             */
                            RegSetValueEx(phdi->hkOld, TEXT("Joystick Id"), 0, REG_BINARY,
                                                (PV)&idJoy, cbX(idJoy));

                            /* Setup Registry data for legacy API's */
                            hres = DIWdm_SetLegacyConfig(idJoy);

                            if( FAILED ( hres ) )
                            {
                                fRc = FALSE;
                                SquirtSqflPtszV(sqfl | sqflError,
                                                TEXT("%S: DIWdm_SetLegacyConfig() FAILED")
                                                TEXT(" idJoy=%d hres = %d"),
                                                s_szProc, idJoy, hres );
                            }
                        } else
                        {
                            SquirtSqflPtszV(sqfl | sqflError,
                                            TEXT("%S: RegSetValueEx(JOYID) FAILED ")
                                            TEXT("Error = %d"),
                                            s_szProc, lRc);
                            fRc = FALSE;
                        }
                    }
                }
            }
        }
    }

    DllLeaveCrit();

    ExitBenignProcF(fRc);

    return fRc;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   HRESULT | DIWdm_SetConfig |
 *
 *          Sets config for analog joysticks. This function is an
 *          extention of the JoyCfg_SetConfig function for NT.
 *          It associates a gameport/serialport bus with a legacy (HID) device and
 *          sends an IOCTL to the gameport/serialport bus to attach the device.
 *          The IOCLT takes the hardware ID[] which is got from
 *          the Joystick OEM types entry
 *          (HKLM\CurrentControlSet\Control\Media\PrivateProperties\Joystick\OEM)
 *          Some time later PnP realizes that a new device has been added, and hunts for
 *          an inf file that matches the HardwareId.
 *
 *          When the new HID device finally shows up, we look for the gameport/serialport that
 *          the HID device is associated with and try to give it the requested idJoy.
 *
 *
 *  @parm   IN UINT | idJoy |
 *
 *          ID of Joystick
 *
 *  @parm   IN LPJOYREGHWCONFIG | pjwc |
 *
 *          Address of JOYREGHWCONFIG structure that contains config info for the joystick
 *
 *  @parm   IN LPCDIJOYCONFIG  | pcfg |
 *
 *          Address of DIJOYCONFIG structure that contains config info for the joystick
 *
 *  @parm   IN DWORD | fl |
 *
 *          Flags
 *
 *  @returns
 *
 *          DIERR_INVALIDPARAM  This function needs DX6.1a functionality.
 *          DIERR_UNSUPPORTED   Autoload devices cannot be added through this API. 
 *          DIERR_NOTFOUND      TypeInfo not found in the registry.
 *          E_ACCESSDENIED      Gameport is configured to use another device.
 *          E_FAIL              CreateFile on Gameport device failed. 
 *                              Could not send IOCTL to gameport device.    
 *
 *****************************************************************************/

HRESULT EXTERNAL
    DIWdm_SetConfig
    (
    IN UINT             idJoy,
    IN LPJOYREGHWCONFIG pjwc,
    IN LPCDIJOYCONFIG   pcfg,
    IN DWORD            fl
    )
{
    HRESULT hres;
    EnterProc(DIWdm_SetConfig, (_"uppu", idJoy, pjwc, pcfg, fl));

    DllEnterCrit();

    hres = E_FAIL;

    if( pcfg->dwSize < cbX(DIJOYCONFIG_DX6 ))
    {
        /* This function needs DX5B2 functionality */
        hres = DIERR_INVALIDPARAM;
    } else if( pjwc->hws.dwFlags & JOY_HWS_AUTOLOAD )
    {
        /* Device cannot be autoload */
        hres = DIERR_UNSUPPORTED;
    } else
    {
        DIJOYTYPEINFO dijti;
        BUS_REGDATA RegData;

        ZeroX(dijti);
        dijti.dwSize = cbX(dijti);

        ZeroX(RegData);
        RegData.dwSize     = cbX(RegData);
        RegData.nJoysticks = 1; 

        /* Is this a predefined joystick type ? */
        if(pcfg->wszType[0] == TEXT('#'))
        {
#define JoyCfg_TypeFromChar(tch)   ((tch) - L'0')
            hres = JoyReg_GetPredefTypeInfo(pcfg->wszType,
                                            &dijti, DITC_INREGISTRY | DITC_HARDWAREID);

            RegData.uVID = MSFT_SYSTEM_VID;
            RegData.uPID = MSFT_SYSTEM_PID + JoyCfg_TypeFromChar(pcfg->wszType[1]);

            if(JoyCfg_TypeFromChar(pcfg->wszType[1]) == JOY_HW_TWO_2A_2B_WITH_Y  )
            {
                RegData.nJoysticks = 2;
                pjwc->hws.dwFlags = 0x0;
            }
#undef JoyCfg_TypeFromChar
        } else
        {
            hres = JoyReg_GetTypeInfo(pcfg->wszType,
                                      &dijti, DITC_INREGISTRY | DITC_HARDWAREID | DITC_DISPLAYNAME );

            if( SUCCEEDED(hres) )
            {
                USHORT uVID, uPID;
                PWCHAR pCurrChar;
                PWCHAR pLastSlash = NULL;

                /* Find the last slash in the hardwareId, any VID/PID should follow directly */
                for( pCurrChar = dijti.wszHardwareId; *pCurrChar != L'\0'; pCurrChar++ )
                {
                    if( *pCurrChar == L'\\' )
                    {
                        pLastSlash = pCurrChar;
                    }
                }

                /*
                 *  If the hardware ID has no separator, treat the device as 
                 *  though JOY_HWS_AUTOLOAD were set because we cannot expose 
                 *  a non-PnP device without a hardware ID.
                 */
                if( pLastSlash++ )
                {
                    /* 
                     *  If the hardwareId does contain a VIDPID, try the type 
                     *  name.  Some auto-detect types require this.
                     *
                     *  Prefix gets messed up in ParseVIDPID (mb:34573) and warns 
                     *  that uVID is uninitialized when ParseVIDPID returns TRUE.
                     */
                    if( ParseVIDPID( &uVID, &uPID, pLastSlash )
                     || ParseVIDPID( &uVID, &uPID, pcfg->wszType ) )
                    {
                        RegData.uVID = uVID;
                        RegData.uPID = uPID;        
                    }
                    else
                    {
                        SquirtSqflPtszV(sqfl | sqflBenign,
                                        TEXT("%hs: cannot find VID and PID for non-PnP type %ls"),
                                        s_szProc, pcfg->wszType);
                    }
                }
                else
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%hs: invalid hardware ID for non-PnP type %ls"),
                                    s_szProc, pcfg->wszType);
                    hres = DIERR_UNSUPPORTED;
                }


            }
        }



        if( SUCCEEDED(hres) )
        {
            PBUSDEVICEINFO pbdi;
            PBUSDEVICELIST pbdl;

            /* Copy over the hardwareID */
            lstrcpyW(RegData.wszHardwareId, dijti.wszHardwareId);
            RegData.hws = pjwc->hws;
            RegData.dwFlags1 = dijti.dwFlags1;

            pbdi = pbdiFromGUID(&pcfg->guidGameport);

            // Attach device to the gameport
            if( pbdi )
            {
                // Set the Joystick ID for the gameport/serialport
                pbdi->idJoy = idJoy;

                // We know which instance of the gameport. 
                hres = DIBusDevice_Expose(pbdi, &RegData); 
            } else if( NULL != ( pbdl = pbdlFromGUID(&pcfg->guidGameport ) ) )
            {
                // We don't kwow which instance of the gameport
                // only which bus. 
                // We will expose the device on all instances of the
                // gameport and later delete devices when we find they
                // are not connected. 
                hres = DIBusDevice_ExposeEx(pbdl, &RegData);
            } else
            {
                hres = DIERR_DEVICENOTREG;
            }


            if( SUCCEEDED(hres) )
            {
                /* Device is not present */
                pjwc->dwUsageSettings &= ~JOY_US_PRESENT;

                /* Definately volatile */
                pjwc->dwUsageSettings |=  JOY_US_VOLATILE;

            }
        }
    }

    ExitOleProc();
    DllLeaveCrit();

    return hres;
} /* DIWdm_SetConfig */

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   HRESULT | DIWdm_DeleteConfig |
 *
 *          WDM extension for JoyCfd::DeleteConfig. On WDM a legacy(HID) device will
 *          keep reappearing as long as the gameport bus is aware of it. So when a
 *          legacy(HID) device is deleted, we need to find out he associated gameport bus
 *          and tell him to stop attaching the device.
 *
 *  @parm   IN UINT | idJoy |
 *
 *          ID of Joystick
 *
 *  @returns
 *
 *          HRESULT code
 *          DIERR_DEVICENOTREG:     Device is not a WDM device
 *          DIERR_UNSUPPORTED:      Device is WDM but not gameport
 *          S_OK:                   Device Persistance removed.  
 *
 *****************************************************************************/


HRESULT EXTERNAL
    DIWdm_DeleteConfig( int idJoy )
{
    HRESULT hres = S_OK;
    PBUSDEVICEINFO  pbdi = NULL;
    PHIDDEVICEINFO  phdi = NULL;

    EnterProcI(DIWdm_DeleteConfig, (_"u", idJoy));
    DllEnterCrit();

    DIHid_BuildHidList(FALSE);

    /*
     * pbdi (BUSDEVICEINFO) must be obtained before we remove the device
     */
    phdi = phdiFindJoyId(idJoy);
    if(phdi != NULL )
    {
        pbdi = pbdiFromphdi(phdi);
    } else
    {
        hres = DIERR_DEVICENOTREG;
        goto _done;
    }


    if( SUCCEEDED(hres) 
        && phdi != NULL 
        && pbdi != NULL )
    {
        lstrcpy( g_tszIdLastRemoved, pbdi->ptszId );
        g_tmLastRemoved = GetTickCount();

        // If the device is a bus device ( Non USB )
        // it needs some help in removal. 
        hres = DIBusDevice_Remove(pbdi); 

        //If the device has been successfully removed,
        //then we need remember it in phdi list in case
        //the PnP doesn't function well.
        if( pbdi->fAttached == FALSE )
        {
            phdi->fAttached = FALSE;
        }

    } else
    {
        //HDEVINFO hdev;

        // Device is USB, we do not support removing
        // USB devices from the CPL. User is encouraged to 
        // Yank out the device or go to the device manager to 
        // remove it. 

        // This is true in Win2K. But in Win9X, since VJOYD also works with USB,
        // when we swap id, we need delete it first.

        hres = DIERR_UNSUPPORTED;
        
#if 0
        // In case we wanted to support removing USB devices from 
        // the game cpl. Here is the code ... 

        /*
         *  Talk to SetupApi to delete the device.
         *  This should not be necessary, but I have
         *  to do this to work around a PnP bug whereby
         *  the device is not removed after I send a remove
         *  IOCTL to gameenum.
         */
        hdev = SetupDiCreateDeviceInfoList(NULL, NULL);
        if( phdi && hdev != INVALID_HANDLE_VALUE)
        {
            SP_DEVINFO_DATA dinf;

            dinf.cbSize = cbX(SP_DEVINFO_DATA);

            /* Get SP_DEVINFO_DATA for the HID device */
            if(SetupDiOpenDeviceInfo(hdev, phdi->ptszId, NULL, 0, &dinf))
            {
                /* Delete the device */
                if( SetupDiCallClassInstaller(DIF_REMOVE,
                                              hdev,
                                              &dinf) )
                {
                    // SUCCESS 
                } else
                {
                    hres = E_FAIL;
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%S: SetupDiClassInstalled(DIF_REMOVE) FAILED  "),
                                    s_szProc );
                }
            }
            SetupDiDestroyDeviceInfoList(hdev);
        }
#endif
    }

_done:

    /*
     * Force a remake of the HID list
     * Some devices may have disappered
     * It helps to sleep for some time to give
     * PnP and its worker threads to spin.
     */
    Sleep(10);

    DIHid_BuildHidList(TRUE);
    DllLeaveCrit();

    ExitOleProc();

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\ihvmap\sources.inc ===
!IF 0

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sources.

    Abstract:

	Causes mapper files to be binplaced

Author:

    MarcAnd

History:
    Date        By          Reason
    ====        ==          ======
    00-11-09    MarcAnd     first version
    01-04-12    TimGill	    357981
        
!ENDIF

!IFNDEF DXROOT
DXROOT = $(BASEDIR)\MultiMedia\DirectX
!ENDIF

TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=

!INCLUDE $(DXROOT)\Project.mk

SOURCES= 


MISCFILES=\
    ACTC094.ini \
    ..\ACT_RS.ini\
    ..\ACT_RS.png \
    ..\GlmDA.ini \
    ..\GlmDA.png \
    ..\GlmDA_G.ini \
    ..\GlmDigGP.ini \
    ..\GlmDigGP.png \
    ..\GlmDGP_G.ini \
    ..\GR3001.ini \
    ..\GR3001_G.ini \
    ..\GR3001.png \
    ..\GR4001.ini \
    ..\GR4001.png \
    ..\GR4001_G.ini \
    ..\GR4001_G.png \
    ..\GR4003.ini \
    ..\GR4003.png \
    ..\GR4005.ini \
    ..\GR4005.png \
    ..\Hammer.ini \
    ..\IA3002.ini \
    ..\IA3002_1.png \
    ..\IA3002_2.png \
    ..\IA3002_G.ini \
    ..\LGC202.ini \
    ..\LGC202.png \
    ..\LGC207.ini \
    ..\LGC207.png \
    ..\LGC209.ini \
    ..\LGC209.png \
    ..\LGC20A.ini \
    ..\LGC20A.png \
    ..\LGC291.ini \
    ..\LGC291.png \
    ..\MS1B.ini \
    ..\MS1B.png \
    ..\MS1B_01.png \
    ..\MS1B_02.png \
    ..\MS1B_03.png \
    ..\MS1B_04.png \
    ..\MS1B_05.png \
    ..\MS1B_06.png \
    ..\MS1B_07.png \
    ..\MS1B_08.png \
    ..\MS1B_09.png \
    ..\MS1B_10.png \
    ..\MS26.ini \
    ..\MS26.png \
    ..\MS26_01.png \
    ..\MS26_02.png \
    ..\MS26_03.png \
    ..\MS26_04.png \
    ..\MS26_05.png \
    ..\MS26_06.png \
    ..\MS26_07.png \
    ..\MS26_08.png \
    ..\MS27.ini \
    ..\MS27.png \
    ..\MS27_1.png \
    ..\MS27_2.png \
    ..\MS27_3.png \
    ..\MS27_4.png \
    ..\MS27_5.png \
    ..\MS28.ini \
    ..\MS28.png \
    ..\MS28_1.png \
    ..\MS28_2.png \
    ..\MS28_3.png \
    ..\MS28_4.png \
    ..\MS28_5.png \
    ..\MS28_6.png \
    ..\MS28_7.png \
    ..\MS28_8.png \
    ..\MS34.ini \
    ..\MS34.png \
    ..\MS34_01.png \
    ..\MS34_02.png \
    ..\MS34_03.png \
    ..\MS34_04.png \
    ..\MS34_05.png \
    ..\MS34_06.png \
    ..\MS34_07.png \
    ..\MS34_08.png \
    ..\MS34_G.ini \
    ..\MS3B.ini \
    ..\MS3B.png \
    ..\MS3B_1.png \
    ..\MS3B_2.png \
    ..\MS3B_3.png \
    ..\MS3B_4.png \
    ..\MS3B_a.png \
    ..\MS3B_c.png \
    ..\MS3B_m.png \
    ..\MS3B_t.png \
    ..\MS56.ini \
    ..\MS56.png \
    ..\MS56_1.png \
    ..\MS56_10.png \
    ..\MS56_2.png \
    ..\MS56_3.png \
    ..\MS56_4.png \
    ..\MS56_5.png \
    ..\MS56_6.png \
    ..\MS56_7.png \
    ..\MS56_8.png \
    ..\MS56_9.png \
    ..\MS6.ini \
    ..\MS6.png \
    ..\MS6_1.png \
    ..\MS6_10.png \
    ..\MS6_2.png \
    ..\MS6_3.png \
    ..\MS6_4.png \
    ..\MS6_5.png \
    ..\MS6_6.png \
    ..\MS6_7.png \
    ..\MS6_8.png \
    ..\MS6_9.png \
    ..\MS6_G.ini \
    ..\MS7.ini \
    ..\MS7.png \
    ..\MS7_1.png \
    ..\MS7_2.png \
    ..\MS7_3.png \
    ..\MS7_4.png \
    ..\MS7_5.png \
    ..\MS7_6.png \
    ..\MS7_7.png \
    ..\MS7_8.png \
    ..\MS7_9.png \
    ..\MS7_G.ini \
    ..\MS8.ini \
    ..\MS8.png \
    ..\MS8_1.png \
    ..\MS8_10.png \
    ..\MS8_2.png \
    ..\MS8_3.png \
    ..\MS8_4.png \
    ..\MS8_5.png \
    ..\MS8_6.png \
    ..\MS8_7.png \
    ..\MS8_8.png \
    ..\MS8_9.png \
    ..\MS8_G.ini \
    ..\MSE.ini \
    ..\MSE.png \
    ..\MSE_1.png \
    ..\MSE_10.png \
    ..\MSE_2.png \
    ..\MSE_3.png \
    ..\MSE_4.png \
    ..\MSE_5.png \
    ..\MSE_6.png \
    ..\MSE_7.png \
    ..\MSE_8.png \
    ..\MSE_9.png \
    ..\MSE_G.ini \
    ..\MSF1F.ini \
    ..\MSF1F.png \
    ..\MSF1F_1.png \
    ..\MSF1F_10.png \
    ..\MSF1F_2.png \
    ..\MSF1F_3.png \
    ..\MSF1F_4.png \
    ..\MSF1F_5.png \
    ..\MSF1F_6.png \
    ..\MSF1F_7.png \
    ..\MSF1F_8.png \
    ..\MSF1F_9.png \
    ..\MSPRW.ini \
    ..\MSPRW.png \
    ..\MSPRW_1.png \
    ..\MSPRW_2.png \
    ..\MSPRW_3.png \
    ..\MSPRW_4.png \
    ..\MSPRW_5.png \
    ..\MSPRW_6.png \
    ..\MSPRW_7.png \
    ..\MSPRW_8.png \
    ..\RaiderPD.ini \
    ..\SV-262E1.png \
    ..\SV-262E3.png \
    ..\SV-262E4.png \
    ..\SV2511.png \
    ..\SV2512.png
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\pid\assert.c ===
/*****************************************************************************
 *
 *  Assert.c
 *
 *  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Assertions and squirties.
 *
 *  Contents:
 *
 *      SquirtSqflPtszV
 *      AssertPtszPtszLn
 *      ArgsPalPszV
 *      EnterSqflPszPal
 *      ExitSqflPalHresPpv
 *
 *****************************************************************************/

#include "pidpr.h"

#ifdef XDEBUG

/*****************************************************************************
 *
 *      WarnPszV
 *
 *      Display a message, suitable for framing.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

TCHAR c_tszPrefix[] = TEXT("PID: ");

#pragma END_CONST_DATA

void EXTERNAL
WarnPtszV(LPCTSTR ptsz, ...)
{
    va_list ap;
    TCHAR tsz[1024];

    lstrcpy(tsz, c_tszPrefix);
    va_start(ap, ptsz);
#ifdef WIN95
	{
		char *psz = NULL;
		char szDfs[1024]={0};
		strcpy(szDfs,ptsz);									// make a local copy of format string
		while (psz = strstr(szDfs,"%p"))					// find each %p
			*(psz+1) = 'x';									// replace %p with %x
	    wvsprintf(tsz + cA(c_tszPrefix) - 1, szDfs, ap);	// use the local format string
	}
#else
	{
		wvsprintf(tsz + cA(c_tszPrefix) - 1, ptsz, ap);
	}
#endif
    va_end(ap);
    lstrcat(tsz, TEXT("\r\n"));
    OutputDebugString(tsz);
}

#endif

#ifdef DEBUG

/*****************************************************************************
 *
 *      Globals
 *
 *****************************************************************************/

BYTE g_rgbSqfl[sqflMaxArea];

TCHAR g_tszLogFile[MAX_PATH];

/*****************************************************************************
 *
 *      Sqfl_Init
 *
 *      Load our initial Sqfl settings from win.ini[debug].
 *
 *      We take one sqfl for each area, of the form
 *
 *      dinput.n=v
 *
 *      where n = 0, ..., sqflMaxArea-1, and where v is one of the
 *      hiword sqfl values.
 *
 *      The default value for all areas is to squirt only errors.
 *
 *****************************************************************************/

void EXTERNAL
Sqfl_Init(void)
{
    int sqfl;
    TCHAR tsz[20];

    sqfl = 0x0;
    wsprintf(tsz, TEXT("PID"));
    g_rgbSqfl[sqfl] = (BYTE)
                      GetProfileInt(TEXT("DEBUG"), tsz, HIWORD(0x0));

    for (sqfl = 0; sqfl < sqflMaxArea; sqfl++) {
        wsprintf(tsz, TEXT("PID.%d"), sqfl);
        g_rgbSqfl[sqfl] = (BYTE)
                          GetProfileInt(TEXT("DEBUG"), tsz, g_rgbSqfl[0]);
    }

}

/*****************************************************************************
 *
 *      SquirtPtsz
 *
 *      Squirt a message to the debugger and maybe a log file.
 *
 *****************************************************************************/

void INTERNAL
SquirtPtsz(LPCTSTR ptsz)
{
    OutputDebugString(ptsz);
    if (g_tszLogFile[0]) {
        HANDLE h = CreateFile(g_tszLogFile, GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
        if (h != INVALID_HANDLE_VALUE) {
#ifdef UNICODE
            CHAR szBuf[1024];
#endif
            SetFilePointer(h, 0, 0, FILE_END);
#ifdef UNICODE
            _lwrite((HFILE)(UINT_PTR)h, szBuf, UToA(szBuf, cA(szBuf), ptsz));
#else
            _lwrite((HFILE)(UINT_PTR)h, ptsz, cbCtch(lstrlen(ptsz)));
#endif
            CloseHandle(h);
        }
    }
}

/*****************************************************************************
 *
 *      SquirtPtszA
 *
 *      Squirt an ANSI message to the debugger and maybe a log file.
 *
 *****************************************************************************/

#ifdef UNICODE

void INTERNAL
SquirtPtszA(LPCSTR psz)
{
    OutputDebugStringA(psz);
    if (g_tszLogFile[0]) {
        HANDLE h = CreateFile(g_tszLogFile, GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
        if (h != INVALID_HANDLE_VALUE) {
            _lwrite((HFILE)(UINT_PTR)h, psz, cbCch(lstrlenA(psz)));
            CloseHandle(h);
        }
    }
}

#else

#define SquirtPtszA                 SquirtPtsz

#endif

/*****************************************************************************
 *
 *      SquirtSqflPtszV
 *
 *      Squirt a message with a trailing crlf.
 *
 *****************************************************************************/

void EXTERNAL
SquirtSqflPtszV(SQFL sqfl, LPCTSTR ptsz, ...)
{
    if (IsSqflSet(sqfl)) {
        va_list ap;
        TCHAR tsz[1024];
        va_start(ap, ptsz);
#ifdef WIN95
	{
		char *psz = NULL;
		char szDfs[1024]={0};
		strcpy(szDfs,ptsz);									// make a local copy of format string
		while (psz = strstr(szDfs,"%p"))					// find each %p
			*(psz+1) = 'x';									// replace %p with %x
        wvsprintf(tsz, szDfs, ap);							// use the local format string
	}
#else
	{
        wvsprintf(tsz, ptsz, ap);
	}
#endif
        va_end(ap);
        lstrcat(tsz, TEXT("\r\n"));
        SquirtPtsz(tsz);
    }
}

/*****************************************************************************
 *
 *      AssertPtszPtszLn
 *
 *      Something bad happened.
 *
 *****************************************************************************/

int EXTERNAL
AssertPtszPtszLn(LPCTSTR ptszExpr, LPCTSTR ptszFile, int iLine)
{
    SquirtSqflPtszV(sqflAlways, TEXT("Assertion failed: `%s' at %s(%d)"),
                    ptszExpr, ptszFile, iLine);
    DebugBreak();
    return 0;
}

/*****************************************************************************
 *
 *      Procedure call tracing is gross because of the C preprocessor.
 *
 *      Oh, if only we had support for m4...
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *      dwSafeGetPdw
 *
 *      Deference a dword, but don't barf if the dword is bad.
 *
 *****************************************************************************/

DWORD INTERNAL
dwSafeGetPdw(LPDWORD pdw)
{
    if (IsBadReadPtr(pdw, cbX(*pdw))) {
        return 0xBAADBAAD;
    } else {
        return *pdw;
    }
}

/*****************************************************************************
 *
 *      ArgsPszV
 *
 *      Collect arguments to a procedure.
 *
 *      psz -> ASCIIZ format string
 *      ... = argument list
 *
 *      The characters in the format string are listed in EmitPal.
 *
 *****************************************************************************/

void EXTERNAL
ArgsPalPszV(PARGLIST pal, LPCSTR psz, ...)
{
    va_list ap;
    va_start(ap, psz);
    if (psz) {
        PPV ppv;
        pal->pszFormat = psz;
        for (ppv = pal->rgpv; *psz; psz++) {
            *ppv++ = va_arg(ap, PV);
        }
    } else {
        pal->pszFormat = "";
    }
}

/*****************************************************************************
 *
 *      EmitPal
 *
 *      OutputDebugString the information, given a pal.  No trailing
 *      carriage return is emitted.
 *
 *      pal      -> place where info was saved
 *
 *      Format characters:
 *
 *      p   - 32-bit flat pointer
 *      x   - 32-bit hex integer
 *      s   - TCHAR string
 *      S   - SCHAR string
 *      A   - ANSI string
 *      W   - UNICODE string
 *      G   - GUID
 *      u   - unsigned integer
 *      C   - clipboard format
 *
 *****************************************************************************/

void INTERNAL
EmitPal(PARGLIST pal)
{
    char sz[MAX_PATH];
    int i;
    SquirtPtsz(pal->ptszProc);
    SquirtPtsz(TEXT("("));
    for (i = 0; pal->pszFormat[i]; i++) {
        if (i) {
            SquirtPtsz(TEXT(", "));
        }
        switch (pal->pszFormat[i]) {

        case 'p':                               /* flat pointer */
// 7/18/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
#ifdef WIN95
            wsprintfA(sz, "%x", pal->rgpv[i]);
#else
			wsprintfA(sz, "%p", pal->rgpv[i]);
#endif
            SquirtPtszA(sz);
            break;
        case 'x':                               /* hex */
            wsprintfA(sz, "%x", pal->rgpv[i]);
            SquirtPtszA(sz);
            break;

        case 's':                               /* TCHAR string */
            if (pal->rgpv[i] && lstrlen(pal->rgpv[i])) {
                SquirtPtsz(pal->rgpv[i]);
            }
            break;

#ifdef  UNICODE
        case 'S':                               /* SCHAR string */
#endif
        case 'A':                               /* ANSI string */
            if (pal->rgpv[i] && lstrlenA(pal->rgpv[i])) {
                SquirtPtszA(pal->rgpv[i]);
            }
            break;

#ifndef UNICODE
        case 'S':                               /* SCHAR string */
#endif
        case 'W':                               /* UNICODE string */
            if (pal->rgpv[i] && lstrlenW(pal->rgpv[i])) {
#ifdef  UNICODE
                OutputDebugStringW(pal->rgpv[i]);
#else
                UToA(sz, cA(sz), pal->rgpv[i]);
                SquirtPtszA(sz);
#endif
            }
            break;

        case 'G':                               /* GUID */
            wsprintfA(sz, "%08x",
                      HIWORD((DWORD)(UINT_PTR)pal->rgpv[i])
                        ? dwSafeGetPdw((LPDWORD)pal->rgpv[i])
                        : (UINT_PTR)pal->rgpv[i]);
            SquirtPtszA(sz);
            break;

        case 'u':                               /* 32-bit unsigned decimal */
            wsprintfA(sz, "%u", pal->rgpv[i]);
            SquirtPtszA(sz);
            break;

        case 'C':
            if (GetClipboardFormatNameA((UINT)(UINT_PTR)pal->rgpv[i], sz, cA(sz))) {
            } else {
                wsprintfA(sz, "[%04x]", pal->rgpv[i]);
            }
            SquirtPtszA(sz);
            break;

        default: AssertF(0);                    /* Invalid */
        }
    }
    SquirtPtsz(TEXT(")"));
}

/*****************************************************************************
 *
 *      EnterSqflPtsz
 *
 *      Mark entry to a procedure.  Arguments were already collected by
 *      ArgsPszV.
 *
 *      If sqfl contains the sqflBenign flag, then any error we detect
 *      should be classified as sqflBenign and not sqflError.
 *
 *      sqfl     -> squirty flags
 *      ptszProc -> procedure name
 *      pal      -> place to save the name and get the format/args
 *
 *****************************************************************************/

void EXTERNAL
EnterSqflPszPal(SQFL sqfl, LPCTSTR ptszProc, PARGLIST pal)
{
    pal->ptszProc = ptszProc;
    sqfl |= sqflIn;
    if (IsSqflSet(sqfl)) {
        EmitPal(pal);
        SquirtPtsz(TEXT("\r\n"));
    }
}

void EXTERNAL
ExitSqflPalHresPpv(SQFL sqfl, PARGLIST pal, HRESULT hres, PPV ppvObj)
{
    BOOL fInternalError;
    SQFL sqflIsError;
    DWORD le = GetLastError();

    if (sqfl & sqflBenign) {
        sqfl &= ~sqflBenign;
        sqflIsError = sqflBenign;
    } else {
        sqflIsError = sqflError;
    }

    sqfl |= sqflOut;
    fInternalError = 0;
    if (ppvObj == ppvVoid || ppvObj == ppvDword) {
    } else if (ppvObj == ppvBool) {
        if (hres == 0) {
            sqfl |= sqflIsError;
        }
    } else {
        if (FAILED(hres)) {
            if (fLimpFF(ppvObj && !IsBadWritePtr(ppvObj, cbX(*ppvObj)),
                        *ppvObj == 0)) {
            } else {
                fInternalError = 1;
            }
            if (hres == E_NOTIMPL) {    /* E_NOTIMPL is always benign */
                sqfl |= sqflBenign;
            } else {
                sqfl |= sqflIsError;
            }
        }
    }

    if (IsSqflSet(sqfl) || fInternalError) {
        EmitPal(pal);
        SquirtPtsz(TEXT(" -> "));
        if (ppvObj != ppvVoid) {
            TCHAR tszBuf[32];
            wsprintf(tszBuf, TEXT("%08x"), hres);
            SquirtPtsz(tszBuf);
            if (HIWORD((UINT_PTR)ppvObj)) {
                wsprintf(tszBuf, TEXT(" [%08x]"),
                         dwSafeGetPdw((LPDWORD)ppvObj));
                SquirtPtsz(tszBuf);
            } else if (ppvObj == ppvDword) {
                wsprintf(tszBuf, TEXT(" [%08x]"), hres);
                SquirtPtsz(tszBuf);
            } else if (ppvObj == ppvBool) {
                wsprintf(tszBuf, hres ? TEXT(" OK ") :
                                 TEXT(" le=[%d]"), le);
                SquirtPtsz(tszBuf);
            }
        }
        SquirtPtsz(TEXT("\r\n"));
        AssertF(!fInternalError);
    }

    /*
     *  This redundant test prevents a breakpoint on SetLastError()
     *  from being hit constantly.
     */
    if (le != GetLastError()) {
        SetLastError(le);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\pid\dimem.c ===
/*****************************************************************************
 *
 *  Dimem.c
 *
 *  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *      dimem.c - Memory management
 *
 *      WARNING!  These do not go through OLE allocation.  Use these
 *      only for private allocation.
 *
 *****************************************************************************/

#include "PIDpr.h"

#ifdef NEED_REALLOC

/*****************************************************************************
 *
 *      ReallocCbPpv
 *
 *      Change the size of some zero-initialized memory.
 *
 *      This is the single place where all memory is allocated, resized,
 *      and freed.
 *
 *      If you realloc from a null pointer, memory is allocated.
 *      If you realloc to zero-size, memory is freed.
 *
 *      These semantics avoid boundary cases.  For example, it is no
 *      longer a problem trying to realloc something down to zero.
 *      You don't have to worry about special-casing an alloc of 0 bytes.
 *
 *      If an error is returned, the original pointer is UNCHANGED.
 *      This saves you from having to the double-switch around a realloc.
 *
 *****************************************************************************/

STDMETHODIMP EXTERNAL
ReallocCbPpv(UINT cb, PV ppvArg)
{
    HRESULT hres;
    PPV ppv = ppvArg;
    HLOCAL hloc = *ppv;
    if (cb) {                       /* Alloc or realloc */
        if (hloc) {                 /* Realloc */
            hloc = LocalReAlloc(*ppv, cb,
                                LMEM_MOVEABLE+LMEM_ZEROINIT);
        } else {                /* Alloc */
            hloc = LocalAlloc(LPTR, cb);
        }
        hres = hloc ? NOERROR : E_OUTOFMEMORY;
    } else {                    /* Freeing */
        if (hloc) {
            LocalFree(hloc);
            hloc = 0;
            hres = NOERROR;     /* All gone */
        } else {
            hres = NOERROR;     /* Nothing to free */
        }
    }

    if (SUCCEEDED(hres)) {
        *ppv = hloc;
    }
    return hres;
}

/*****************************************************************************
 *
 *      AllocCbPpv
 *
 *      Simple wrapper that forces *ppvObj = 0 before calling Realloc.
 *
 *****************************************************************************/

STDMETHODIMP EXTERNAL
AllocCbPpv(UINT cb, PPV ppv)
{
    *ppv = 0;
    return ReallocCbPpv(cb, ppv);
}

#else

/*****************************************************************************
 *
 *      AllocCbPpv
 *
 *      Allocate memory into the ppv.
 *
 *****************************************************************************/

STDMETHODIMP EXTERNAL
AllocCbPpv(UINT cb, PPV ppv)
{
    HRESULT hres;
    *ppv = LocalAlloc(LPTR, cb);
    hres = *ppv ? NOERROR : E_OUTOFMEMORY;
    return hres;
}

/*****************************************************************************
 *
 *      FreePpv
 *
 *      Free memory from the ppv.
 *
 *****************************************************************************/

void EXTERNAL
FreePpv(PV ppv)
{
    PV pv = (PV)InterlockedExchange(ppv, 0);
    if (pv) {
        FreePv(pv);
    }
}

#endif


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresDupPtszPptsz |
 *
 *          OLEish version of strdup.
 *
 *  @parm   LPCTSTR | ptszSrc |
 *
 *          Source string being duplicated.
 *
 *  @parm   LPTSTR * | pptszDst |
 *
 *          Receives the duplicated string.
 *
 *  @returns
 *
 *          <c S_OK> or an error code.
 *
 *****************************************************************************/

HRESULT EXTERNAL
    hresDupPtszPptsz(LPCTSTR ptszSrc, LPTSTR *pptszDst)
{
    HRESULT hres;

    hres = AllocCbPpv(cbCtch(lstrlen(ptszSrc) + 1), pptszDst);

    if(SUCCEEDED(hres))
    {
        lstrcpy(*pptszDst, ptszSrc);
        hres = S_OK;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\pid\debug.h ===
/***************************************************************************
 *  Debug.h
 *
 *  Copyright (C) 1996-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Content:    DirectInput debugging macros
 *
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *   1996.05.07 raymondc Somebody had to
 *
 *@@END_MSINTERNAL
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 ***************************************************************************/

#ifndef _INC_DEBUG
#define _INC_DEBUG

#ifdef __cplusplus
extern "C"
{
#endif

#ifdef XDEBUG
    #define RD(x)       x
    #ifdef DEBUG
        #define D(x)    x
    #else
        #define D(x)
    #endif
#else
    #define RD(x)
    #define D(x)
#endif

/*****************************************************************************
 *
 *	assert.c - Assertion stuff
 *
 *      A sqfl is in multiple parts.
 *
 *      The low word specifies the area that is generating the message.
 *
 *      The high word contains flags that describe why this squirty
 *      is being generated.
 *
 *****************************************************************************/

typedef enum _SQFL{
    /*
     *  Areas.
     */
    sqflAlways          = 0x0000,       /* Unconditional */
    sqflDll             = 0x0001,       /* Dll bookkeeping */
    sqflFactory         = 0x0002,       /* IClassFactory */
    sqflDi              = 0x0003,       /* IDirectInput */
    sqflHid             = 0x0004,       
    sqflReg             = 0x0005,       /* Registry Setup */
    sqflInit            = 0x0006,       /* Initialization */
    sqflEff             = 0x0007,       /* Effect Block Download */
    sqflParam           = 0x0008,       /* Parameter Block(s) Download */
    sqflOp              = 0x0009,       /* PID device Operation */
    sqflRead            = 0x000A,
    sqflEffDrv          = 0x000B,
    sqflParams          = 0x000C,       /* Incoming parameters */
    sqflCrit            = 0x000D,       /* Critical Section */
    sqflMaxArea,                        /* Last area */

    /*
     *  Flags which may be combined.  For now, they all fit into a byte.
     */
    sqflTrace           = 0x00010000,   /* Trace squirties */
    sqflIn              = 0x00020000,   /* Function entry */
    sqflOut             = 0x00040000,   /* Function exit */
    sqflBenign          = 0x00080000,   /* Not a bad error */
    sqflError           = 0x00100000,   /* A bad error */
    sqflVerbose         = 0x00200000,   /* Really verbose */
} SQFL;                                 /* squiffle */

#ifdef XDEBUG
void EXTERNAL WarnPtszV(LPCTSTR ptsz, ...);
void EXTERNAL SquirtSqflPtszV(SQFL sqfl, LPCTSTR ptsz, ...);
#endif

#ifndef DEBUG
#define SquirtSqflPtszV sizeof
#endif

#ifdef XDEBUG
    #define RPF WarnPtszV
#else
    #define WarnPtszV sizeof
    #define RPF sizeof
    #define s_tszProc 0
    #define iarg 0
#endif

/*****************************************************************************
 *
 *      Buffer scrambling
 *
 *      All output buffers should be scrambled on entry to any function.
 *
 *      Each output bitmask should set an unused bit randomly to ensure
 *      that callers ignore bits that aren't defined.
 *
 *****************************************************************************/

#ifdef XDEBUG

void EXTERNAL ScrambleBuf(LPVOID pv, UINT cb);
void EXTERNAL ScrambleBit(LPDWORD pdw, DWORD flMask);

#else

#define ScrambleBuf(pv, cb)
#define ScrambleBit(pdw, flRandom)

#endif

/*****************************************************************************
 *
 *      Procedure enter/exit tracking.
 *
 *      Start a procedure with
 *
 *      EnterProc(ProcedureName, (_ "format", arg, arg, arg, ...));
 *      EnterProcS(ProcedureName, (_ "format", arg, arg, arg, ...));
 *      EnterProcI(ProcedureName, (_ "format", arg, arg, arg, ...));
 *      EnterProcR(ProcedureName, (_ "format", arg, arg, arg, ...));
 *
 *      The format string is documented in EmitPal.
 *
 *      Suffixing an "S" indicates that the macro should not generate
 *      a procedure name because there is a formal parameter with the
 *      name s_tszProc.  This is a hack.
 *
 *      Suffixing an "R" indicates that the macro should generate a
 *      procedure name in RDEBUG.
 *
 *      Suffixing an "I" indicates that the macro should emit a dummy
 *      procedure name in RDEBUG because the interface is internal.
 *
 *      No suffix means that the macro should be active only in the
 *      DEBUG build and should vanish in RDEBUG (and RETAIL).
 *
 *      End a procedure with one of the following:
 *
 *          ExitProc();
 *
 *              Procedure returns no value.
 *
 *          ExitProcX();
 *
 *              Procedure returns an arbitrary DWORD.
 *
 *          ExitProcF();
 *
 *              Procedure returns a BOOL, where FALSE is an error.
 *
 *          ExitOleProc();
 *
 *              Procedure returns an HRESULT (named "hres").
 *
 *          ExitOleProcPpv(ppvOut);
 *
 *              Procedure returns an HRESULT (named "hres") and, on success,
 *              puts a new object in ppvOut.
 *
 *      The ExitBenign* versions consider any error to be benign.
 *
 *****************************************************************************/

#define cpvArgMax	10	/* Max of 10 args per procedure */

typedef struct ARGLIST {
    LPCTSTR ptszProc;
    LPCSTR pszFormat;
    PV rgpv[cpvArgMax];
} ARGLIST, *PARGLIST;

void EXTERNAL ArgsPalPszV(PARGLIST pal, LPCSTR psz, ...);
void EXTERNAL EnterSqflPszPal(SQFL sqfl, LPCTSTR psz, PARGLIST pal);
void EXTERNAL ExitSqflPalHresPpv(SQFL, PARGLIST, HRESULT, PPV);
void EXTERNAL Sqfl_Init(void);

#ifdef DEBUG

extern BYTE g_rgbSqfl[sqflMaxArea];

BOOL INLINE
IsSqflSet(SQFL sqfl)
{
    WORD wHi;
    if (LOWORD(sqfl) == sqflAlways) {
        return TRUE;
    }
    wHi = HIWORD(sqfl);
    if (wHi == 0) {
        wHi = HIWORD(sqflTrace);
    }

    return g_rgbSqfl[LOWORD(sqfl)] & wHi;
}

#endif

#define _SetupEnterProc(nm)                             \
        static TCHAR s_tszProc[] = TEXT(#nm);           \
        ARGLIST _al[1]                                  \

#define _ _al,

#define ppvDword ((PPV)1)
#define ppvVoid  ((PPV)2)
#define ppvBool  ((PPV)3)

#define _DoEnterProc(v)                                 \
        ArgsPalPszV v;                                  \
        EnterSqflPszPal(sqfl, s_tszProc, _al)           \

#define _EnterProc(nm, v)                               \
        _SetupEnterProc(nm);                            \
        _DoEnterProc(v)                                 \

#define _ExitOleProcPpv(ppv)                            \
        ExitSqflPalHresPpv(sqfl, _al, hres, (PPV)(ppv)) \

#define _ExitOleProc()                                  \
        _ExitOleProcPpv(0)                              \

#define _ExitProc()                                     \
        ExitSqflPalHresPpv(sqfl, _al, 0, ppvVoid)       \

#define _ExitProcX(x)                                   \
        ExitSqflPalHresPpv(sqfl, _al, (HRESULT)(x), ppvDword) \

#define _ExitProcF(x)                                   \
        ExitSqflPalHresPpv(sqfl, _al, (HRESULT)(x), ppvBool) \

#define _ExitBenignOleProcPpv(ppv)                      \
        ExitSqflPalHresPpv(sqfl | sqflBenign, _al, hres, (PPV)(ppv)) \

#define _ExitBenignOleProc()                            \
        _ExitBenignOleProcPpv(0)                        \

#define _ExitBenignProc()                               \
        ExitSqflPalHresPpv(sqfl | sqflBenign, _al, 0, ppvVoid) \

#define _ExitBenignProcX(x)                                   \
        ExitSqflPalHresPpv(sqfl | sqflBenign, _al, (HRESULT)(x), ppvDword) \

#define _ExitBenignProcF(x)                                   \
        ExitSqflPalHresPpv(sqfl | sqflBenign, _al, (HRESULT)(x), ppvBool) \

#if defined(DEBUG)

#define EnterProc           _EnterProc
#define ExitOleProcPpv      _ExitOleProcPpv
#define ExitOleProc         _ExitOleProc
#define ExitProc            _ExitProc
#define ExitProcX           _ExitProcX
#define ExitProcF           _ExitProcF
#define ExitBenignOleProcPpv    _ExitBenignOleProcPpv
#define ExitBenignOleProc       _ExitBenignOleProc
#define ExitBenignProc          _ExitBenignProc
#define ExitBenignProcX         _ExitBenignProcX
#define ExitBenignProcF         _ExitBenignProcF

#define EnterProcS(nm, v)                               \
        static TCHAR s_tszProc2[] = TEXT(#nm);          \
        ARGLIST _al[1];                                 \
        ArgsPalPszV v;                                  \
        EnterSqflPszPal(sqfl, s_tszProc2, _al)          \

#define EnterProcI          _EnterProc
#define EnterProcR          _EnterProc
#define ExitOleProcPpvR     _ExitOleProcPpv
#define ExitOleProcR        _ExitOleProc
#define ExitProcR           _ExitProc
#define ExitProcXR          _ExitProcX
#define ExitProcFR          _ExitProcF
#define ExitBenignOleProcPpvR   _ExitBenignOleProcPpv
#define ExitBenignOleProcR      _ExitBenignOleProc
#define ExitBenignProcR         _ExitBenignProc
#define ExitBenignProcXR        _ExitBenignProcX
#define ExitBenignProcFR        _ExitBenignProcF

#elif defined(RDEBUG)

#define EnterProc(nm, v)
#define ExitOleProcPpv(ppv)
#define ExitOleProc()
#define ExitProc()
#define ExitProcX(x)
#define ExitProcF(x)
#define ExitBenignOleProcPpv(ppv)
#define ExitBenignOleProc()
#define ExitBenignProc()
#define ExitBenignProcX(x)
#define ExitBenignProcF(x)

#define EnterProcS(nm, v)
#define EnterProcI(nm, v)   static TCHAR s_tszProc[] = TEXT("")
#define EnterProcR(nm, v)   static TCHAR s_tszProc[] = TEXT(#nm)
#define ExitOleProcPpvR(ppv)
#define ExitOleProcR()
#define ExitProcR()
#define ExitProcXR()
#define ExitProcFR()
#define ExitBenignOleProcPpvR(ppv)
#define ExitBenignOleProcR()
#define ExitBenignProcR()
#define ExitBenignProcXR()
#define ExitBenignProcFR()

#else

#define EnterProc(nm, v)
#define ExitOleProcPpv(ppv)
#define ExitOleProc()
#define ExitProc()
#define ExitProcX(x)
#define ExitProcF(x)
#define ExitBenignOleProcPpv(ppv)
#define ExitBenignOleProc()
#define ExitBenignProc()
#define ExitBenignProcX(x)
#define ExitBenignProcF(x)

#define EnterProcS(nm, v)
#define EnterProcI(nm, v)
#define EnterProcR(nm, v)
#define ExitOleProcPpvR(ppv)
#define ExitOleProcR()
#define ExitProcR()
#define ExitProcXR(x)
#define ExitProcFR(x)
#define ExitBenignOleProcPpvR(ppv)
#define ExitBenignOleProcR()
#define ExitBenignProcR()
#define ExitBenignProcXR()
#define ExitBenignProcFR()

#endif

#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\pid\baggage.h ===
/***************************************************************************
 *  Baggage.h
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       pidi.h
 *  Content:    DirectInput PID internal include file
 *
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *   1999.01.04 OmSharma Lost a bet
 *
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


/***************************************************************************
 *
 *  Debug / RDebug / Retail
 *
 *  If either DEBUG or RDEBUG, set XDEBUG.
 *
 *  Retail defines nothing.
 *
 ***************************************************************************/

#if defined(DEBUG) || defined(RDEBUG) || defined(_DBG)
    #define XDEBUG
#endif

typedef LPUNKNOWN PUNK;
typedef LPVOID PV, *PPV;
typedef CONST VOID *PCV;
typedef REFIID RIID;
typedef CONST GUID *PCGUID;

#define INTERNAL NTAPI  /* Called only within a translation unit */
#define EXTERNAL NTAPI  /* Called from other translation units */
#define INLINE static __inline

#define INTERNAL NTAPI  /* Called only within a translation unit */
#define EXTERNAL NTAPI  /* Called from other translation units */
#define INLINE static __inline

#define BEGIN_CONST_DATA data_seg(".text", "CODE")
#define END_CONST_DATA data_seg(".data", "DATA")

/*
 *  Arithmetic on pointers.
 */
#define pvSubPvCb(pv, cb) ((PV)((PBYTE)pv - (cb)))
#define pvAddPvCb(pv, cb) ((PV)((PBYTE)pv + (cb)))
#define cbSubPvPv(p1, p2) ((PBYTE)(p1) - (PBYTE)(p2))

/*
 * Convert an object (X) to a count of bytes (cb).
 */
#define cbX(X) sizeof(X)

/*
 * Convert an array name (A) to a generic count (c).
 */
#define cA(a) (cbX(a)/cbX(a[0]))

/*
 * Convert a count of X's (cx) into a count of bytes
 * and vice versa.
 */
#define  cbCxX(cx, X) ((cx) * cbX(X))
#define  cxCbX(cb, X) ((cb) / cbX(X))

/*
 * Convert a count of chars (cch), tchars (ctch), wchars (cwch),
 * or dwords (cdw) into a count of bytes, and vice versa.
 */
#define  cbCch(cch)  cbCxX( cch,  CHAR)
#define cbCwch(cwch) cbCxX(cwch, WCHAR)
#define cbCtch(ctch) cbCxX(ctch, TCHAR)
#define  cbCdw(cdw)  cbCxX( cdw, DWORD)

#define  cchCb(cb) cxCbX(cb,  CHAR)
#define cwchCb(cb) cxCbX(cb, WCHAR)
#define ctchCb(cb) cxCbX(cb, TCHAR)
#define  cdwCb(cb) cxCbX(cb, DWORD)

/*
 * Zero an arbitrary buffer.  It is a common error to get the second
 * and third parameters to memset backwards.
 */
#define ZeroBuf(pv, cb) memset(pv, 0, cb)

/*
 * Zero an arbitrary object.
 */
#define ZeroX(x) ZeroBuf(&(x), cbX(x))

/*
 * land -- Logical and.  Evaluate the first.  If the first is zero,
 * then return zero.  Otherwise, return the second.
 */

#define fLandFF(f1, f2) ((f1) ? (f2) : 0)

/*
 * lor -- Logical or.  Evaluate the first.  If the first is nonzero,
 * return it.  Otherwise, return the second.
 *
 * Unfortunately, due to the *nature* of the C language, this can
 * be implemented only with a GNU extension.  In the non-GNU case,
 * we return 1 if the first is nonzero.
 */

#if defined(__GNUC__)
    #define fLorFF(f1, f2) ((f1) ?: (f2))
#else
    #define fLorFF(f1, f2) ((f1) ? 1 : (f2))
#endif

/*
 * limp - logical implication.  True unless the first is nonzero and
 * the second is zero.
 */
#define fLimpFF(f1, f2) (!(f1) || (f2))

/*
 * leqv - logical equivalence.  True if both are zero or both are nonzero.
 */
#define fLeqvFF(f1, f2) (!(f1) == !(f2))

/*
 *  fInOrder - checks that i1 <= i2 < i3.
 */
#define fInOrder(i1, i2, i3) ((unsigned)((i2)-(i1)) < (unsigned)((i3)-(i1)))

/*
 *  fHasAllBitsFlFl - checks that all bits in fl2 are set in fl1.
 */
BOOL INLINE
    fHasAllBitsFlFl(DWORD fl1, DWORD fl2)
{
    return (fl1 & fl2) == fl2;
}

/*
 *  fEqualMask - checks that all masked bits are equal
 */
BOOL INLINE
    fEqualMaskFlFl(DWORD flMask, DWORD fl1, DWORD fl2)
{
    return ((fl1 ^ fl2) & flMask) == 0;
}

#define NEED_REALLOC

STDMETHODIMP EXTERNAL ReallocCbPpv(UINT cb, PV ppvObj);
STDMETHODIMP EXTERNAL AllocCbPpv(UINT cb, PV ppvObj);

#ifdef NEED_REALLOC
    #define FreePpv(ppv) (void)ReallocCbPpv(0, ppv)
#else
void EXTERNAL FreePpv(PV ppv);
    #define FreePpv(ppv) FreePpv(ppv)
#endif
#define FreePv(pv) LocalFree((HLOCAL)(pv))



HRESULT EXTERNAL hresDupPtszPptsz(LPCTSTR ptszSrc, LPTSTR *pptszDst);

#define AToU(dst, cchDst, src) \
    MultiByteToWideChar(CP_ACP, 0, src, -1, dst, cchDst)
#define UToA(dst, cchDst, src) \
    WideCharToMultiByte(CP_ACP, 0, src, -1, dst, cchDst, 0, 0)


/***************************************************************************
 *
 *  Debugging macros needed by inline functions
 *
 *  The build of debugging goo is in debug.h
 *
 ***************************************************************************/

int EXTERNAL AssertPtszPtszLn(LPCTSTR ptszExpr, LPCTSTR ptszFile, int iLine);

#ifdef DEBUG

    #define AssertFPtsz(c, ptsz) \
        ((c) ? 0 : AssertPtszPtszLn(ptsz, TEXT(__FILE__), __LINE__))
    #define ValidateF(c, arg) \
        ((c) ? 0 : (RPF arg, ValidationException(), 0))
    #define ConfirmF(c) \
	((c) ? 0 : AssertPtszPtszLn(TEXT(#c), TEXT(__FILE__), __LINE__))

#else   /* !DEBUG */

    #define AssertFPtsz(c, ptsz)
    #define ValidateF(c, arg)
    #define ConfirmF(c)     (c)

#endif

/*
 *  CAssertF - compile-time assertion.
 */
#define CAssertF(c)     switch(0) case c: case 0:

#define AssertF(c)      AssertFPtsz(c, TEXT(#c))


#define Clamp( MIN_, VAL_, MAX_ )  ( (VAL_ < MIN_) ? MIN_ : ((VAL_ > MAX_) ? MAX_ : VAL_) )
#define Clip( VAL_, MAX_)          ( (VAL_ > MAX_) ? MAX_ : VAL_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\pid\clsfact.c ===
/*****************************************************************************
 *
 *  Clsfact.c
 *
 *  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *
 *  Abstract:
 *
 *      Class factory.
 *
 *****************************************************************************/

#include "PIDpr.h"

/*****************************************************************************
 *
 *      CClassFactory_AddRef
 *
 *      Optimization: Since the class factory is static, reference
 *      counting can be shunted to the DLL itself.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
CClassFactory_AddRef(IClassFactory *pcf)
{
    return DllAddRef();
}


/*****************************************************************************
 *
 *      CClassFactory_Release
 *
 *      Optimization: Since the class factory is static, reference
 *      counting can be shunted to the DLL itself.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
CClassFactory_Release(IClassFactory *pcf)
{
    return DllRelease();
}

/*****************************************************************************
 *
 *      CClassFactory_QueryInterface
 *
 *      Our QI is very simple because we support no interfaces beyond
 *      ourselves.
 *
 *****************************************************************************/

STDMETHODIMP
CClassFactory_QueryInterface(IClassFactory *pcf, REFIID riid, LPVOID *ppvOut)
{
    HRESULT hres;

    if (IsEqualIID(riid, &IID_IUnknown) ||
        IsEqualIID(riid, &IID_IClassFactory)) {
        CClassFactory_AddRef(pcf);
        *ppvOut = pcf;
        hres = S_OK;
    } else {
        *ppvOut = 0;
        hres = E_NOINTERFACE;
    }
    return hres;
}

/*****************************************************************************
 *
 *      CClassFactory_CreateInstance
 *
 *      Create the effect driver object itself.
 *
 *****************************************************************************/

STDMETHODIMP
CClassFactory_CreateInstance(IClassFactory *pcf, IUnknown *punkOuter,
                             REFIID riid, LPVOID *ppvObj)
{
    HRESULT hres;

    if (punkOuter == 0) {
        hres = PID_New(riid, ppvObj);
    } else {
        /*
         *  We don't support aggregation.
         */
        hres = CLASS_E_NOAGGREGATION;
    }

    return hres;
}

/*****************************************************************************
 *
 *      CClassFactory_LockServer
 *
 *****************************************************************************/

STDMETHODIMP
CClassFactory_LockServer(IClassFactory *pcf, BOOL fLock)
{

    if (fLock) {
        DllAddRef();
    } else {
        DllRelease();
    }

    return S_OK;
}

/*****************************************************************************
 *
 *      The VTBL for our Class Factory
 *
 *****************************************************************************/

IClassFactoryVtbl CClassFactory_Vtbl = {
    CClassFactory_QueryInterface,
    CClassFactory_AddRef,
    CClassFactory_Release,
    CClassFactory_CreateInstance,
    CClassFactory_LockServer,
};

/*****************************************************************************
 *
 *      Our static class factory.
 *
 *****************************************************************************/

IClassFactory g_cf = { &CClassFactory_Vtbl };

/*****************************************************************************
 *
 *      CClassFactory_New
 *
 *****************************************************************************/

STDMETHODIMP
CClassFactory_New(REFIID riid, LPVOID *ppvOut)
{
    HRESULT hres;

    /*
     *  Attempt to obtain the desired interface.  QueryInterface
     *  will do an AddRef if it succeeds.
     */
    hres = CClassFactory_QueryInterface(&g_cf, riid, ppvOut);

    return hres;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\pid\guids.c ===
#define INITGUID
#include <pidpr.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\pid\makefile.inc ===
$(O)\guids.obj: ..\guids.c
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$@" $(USECXX_FLAG) "$(MAKEDIR)\$**"
$(NP_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\pid\main.c ===
/*****************************************************************************
 *
 *  Main.c
 *  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Template effect driver that doesn't actually do anything.
 *
 *****************************************************************************/

#include "PIDpr.h"
/*****************************************************************************
 *
 *      Static globals:  Initialized at PROCESS_ATTACH and never modified.
 *
 *****************************************************************************/

HINSTANCE g_hinst = NULL;              /* This DLL's instance handle */
PSHAREDMEMORY g_pshmem = NULL;         /* Our shared memory block */
HANDLE g_hfm = NULL;                   /* Handle to file mapping object */
HANDLE g_hmtxShared = NULL;            /* Handle to mutex that protects g_pshmem */

CANCELIO CancelIo_ = FakeCancelIO;

#ifdef DEBUG
LONG   g_cCrit = 0;
ULONG   g_thidCrit = 0;
PTCHAR   g_rgUsageTxt[PIDUSAGETXT_MAX];    // Cheat sheet for PID usages
#endif
TRYENTERCRITICALSECTION TryEnterCriticalSection_ = FakeTryEnterCriticalSection;

/*****************************************************************************
 *
 *      Dynamic Globals.  There should be as few of these as possible.
 *
 *      All access to dynamic globals must be thread-safe.
 *
 *****************************************************************************/

LONG g_cRef = 0;                   /* Global reference count */
CRITICAL_SECTION g_crst;        /* Global critical section */

/*****************************************************************************
 *
 *      DllAddRef / DllRelease
 *
 *      Adjust the DLL reference count.
 *
 *****************************************************************************/

STDAPI_(ULONG)
DllAddRef(void)
{
    return (ULONG)InterlockedIncrement((LPLONG)&g_cRef);
}

STDAPI_(ULONG)
DllRelease(void)
{
    return (ULONG)InterlockedDecrement((LPLONG)&g_cRef);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllEnterCrit |
 *
 *          Take the DLL critical section.
 *
 *          The DLL critical section is the lowest level critical section.
 *          You may not attempt to acquire any other critical sections or
 *          yield while the DLL critical section is held.  Failure to
 *          comply is a violation of the semaphore hierarchy and will
 *          lead to deadlocks.
 *
 *****************************************************************************/

void EXTERNAL
 DllEnterCrit_(LPCTSTR lptszFile, UINT line)
{            
#ifdef DEBUG
    if( ! TryEnterCriticalSection_(&g_crst) )
    {
        SquirtSqflPtszV(sqflCrit, TEXT("Dll CritSec blocked @%s,%d"), lptszFile, line);    
        EnterCriticalSection(&g_crst);
    }
    
    if (g_cCrit++ == 0) {
        g_thidCrit = GetCurrentThreadId();
    
        SquirtSqflPtszV(sqflCrit, TEXT("Dll CritSec Entered @%s,%d"), lptszFile, line);    
    }
    AssertF(g_thidCrit == GetCurrentThreadId());
#else
    EnterCriticalSection(&g_crst);
#endif

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllLeaveCrit |
 *
 *          Leave the DLL critical section.
 *
 *****************************************************************************/

void EXTERNAL
DllLeaveCrit_(LPCTSTR lptszFile, UINT line)
{
#ifdef DEBUG
    AssertF(g_thidCrit == GetCurrentThreadId());
    AssertF(g_cCrit >= 0);
    if (--g_cCrit < 0) {
        g_thidCrit = 0;
    }
    SquirtSqflPtszV(sqflCrit, TEXT("Dll CritSec Leaving @%s,%d"), lptszFile, line);    
#endif
    LeaveCriticalSection(&g_crst);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllInCrit |
 *
 *          Nonzero if we are in the DLL critical section.
 *
 *****************************************************************************/

#ifdef DEBUG

BOOL INTERNAL
DllInCrit(void)
{        
    return g_cCrit >= 0 && g_thidCrit == GetCurrentThreadId();
}

#endif

/*****************************************************************************
 *
 *      DllGetClassObject
 *
 *      OLE entry point.  Produces an IClassFactory for the indicated GUID.
 *
 *****************************************************************************/

STDAPI
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
    HRESULT hres;

    if (IsEqualGUID(rclsid, &IID_IDirectInputPIDDriver)) {
        hres = CClassFactory_New(riid, ppvObj);
    } else {
        *ppvObj = 0;
        hres = CLASS_E_CLASSNOTAVAILABLE;
    }
    return hres;
}

/*****************************************************************************
 *
 *      DllCanUnloadNow
 *
 *      OLE entry point.  Fail iff there are outstanding refs.
 *
 *****************************************************************************/

STDAPI
DllCanUnloadNow(void)
{
    return g_cRef ? S_FALSE : S_OK;
}

/*****************************************************************************
 *
 *      DllNameFromGuid
 *
 *      Create the string version of a GUID.
 *
 *****************************************************************************/

STDAPI_(void)
DllNameFromGuid(LPTSTR ptszBuf, LPCGUID pguid)
{
    wsprintf(ptszBuf,
             TEXT("{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
             pguid->Data1, pguid->Data2, pguid->Data3,
             pguid->Data4[0], pguid->Data4[1],
             pguid->Data4[2], pguid->Data4[3],
             pguid->Data4[4], pguid->Data4[5],
             pguid->Data4[6], pguid->Data4[7]);
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | FakeCancelIO |
 *
 *          Stub function which doesn't do anything but
 *          keeps us from crashing.
 *
 *  @parm   HANDLE | h |
 *
 *          The handle whose I/O is supposed to be cancelled.
 *
 *****************************************************************************/

BOOL WINAPI
    FakeCancelIO(HANDLE h)
{
    AssertF(0);
    return FALSE;
}
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | FakeTryEnterCriticalSection |
 *
 *          We use TryEnterCriticalSection in DEBUG to detect deadlock
 *          If the function does not exist, just enter CritSection and report
 *          true. This compromises some debug functionality.           
 *
 *  @parm   LPCRITICAL_SECTION | lpCriticalSection |
 *
 *          Address of Critical Section to be entered. 
 *
 *****************************************************************************/

BOOL WINAPI
    FakeTryEnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
{
    EnterCriticalSection(lpCriticalSection);
    return TRUE;
}
/*****************************************************************************
 *
 *      DllOnProcessAttach
 *
 *      Initialize the DLL.
 *
 *****************************************************************************/

STDAPI_(BOOL)
DllOnProcessAttach(HINSTANCE hinst)
{
    TCHAR tszName[256];
    HINSTANCE hinstK32;
    TCHAR c_tszKernel32[] = TEXT("KERNEL32");
    
    // Cache the instance handle
    g_hinst = hinst;
    
    hinstK32 = GetModuleHandle( c_tszKernel32 );
    if(hinstK32 != INVALID_HANDLE_VALUE)
    {
        CANCELIO tmp;
        TRYENTERCRITICALSECTION tmpCrt;

        tmp = (CANCELIO)GetProcAddress(hinstK32, "CancelIo");
        if (tmp) {
            CancelIo_ = tmp;
        } else {
            AssertF(CancelIo_ == FakeCancelIO);
        }

        tmpCrt = (TRYENTERCRITICALSECTION)GetProcAddress(hinstK32, "TryEnterCriticalSection");
        if(tmpCrt)
        {
            TryEnterCriticalSection_ = tmpCrt;            
        }else
        {
            AssertF(TryEnterCriticalSection_ == FakeTryEnterCriticalSection);
        }
    }

    #ifdef DEBUG
    Sqfl_Init();
    #endif
    /*
     *  Performance tweak: We do not need thread notifications.
     */
    DisableThreadLibraryCalls(hinst);

    /*
     *  !!IHV!! Initialize your DLL here.
     */

    __try 
    {
        InitializeCriticalSection(&g_crst);
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        return FALSE; // usually out of memory condition
    }

    /*
     *  Create our mutex that protects the shared memory block.
     *  If it already exists, then we get access to the one that
     *  already exists.
     *
     *  The name of the shared memory block is GUID_MyMutex.
     */
    DllNameFromGuid(tszName, &GUID_MyMutex);

    g_hmtxShared = CreateMutex(NULL, FALSE, tszName);

    if (g_hmtxShared == NULL) {
        return FALSE;
    }

    /*
     *  Create our shared memory block.  If it already exists,
     *  then we get access to the one that already exists.
     *  If it doesn't already exist, then it gets created
     *  zero-filled (which is what we want anyway).
     *
     *  The name of the shared memory block is GUID_MySharedMemory.
     */
    DllNameFromGuid(tszName, &GUID_MySharedMemory);

    g_hfm = CreateFileMapping(INVALID_HANDLE_VALUE, NULL,
                              PAGE_READWRITE, 0,
                              sizeof(SHAREDMEMORY),
                              tszName);

    if (g_hfm == NULL) {
        CloseHandle(g_hmtxShared);
        g_hmtxShared = NULL;

        return FALSE;
    }

    g_pshmem = MapViewOfFile(g_hfm, FILE_MAP_WRITE | FILE_MAP_READ,
                      0, 0, 0);
    
    if (g_pshmem == NULL) {
        CloseHandle(g_hmtxShared);
        g_hmtxShared = NULL;

        CloseHandle(g_hfm);
        g_hfm = NULL;
        return FALSE;
    }

    return TRUE;

}

/*****************************************************************************
 *
 *      DllOnProcessDetach
 *
 *      De-initialize the DLL.
 *
 *****************************************************************************/

STDAPI_(void)
DllOnProcessDetach(void)
{
    /*
     *  !!IHV!! De-initialize your DLL here.
     */

    if (g_pshmem != NULL) {
        UnmapViewOfFile(g_pshmem);
        g_pshmem = NULL;
    }

    if (g_hfm != NULL) {
        CloseHandle(g_hfm);
        g_hfm = NULL;
    }

    if (g_hmtxShared != NULL) {
        CloseHandle(g_hmtxShared);
        g_hmtxShared = NULL;
    }

    DeleteCriticalSection(&g_crst);
}

/*****************************************************************************
 *
 *      DllEntryPoint
 *
 *      DLL entry point.
 *
 *****************************************************************************/

STDAPI_(BOOL)
DllEntryPoint(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason) {

    case DLL_PROCESS_ATTACH:
        return DllOnProcessAttach(hinst);

    case DLL_PROCESS_DETACH:
        DllOnProcessDetach();
        break;
    }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\pid\effdrv.c ===
/*****************************************************************************
 *
 *  EffDrv.c
 *
 *  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Effect driver.
 *
 *      WARNING!  Since the effect driver is marked ThreadingModel="Both",
 *      all methods must be thread-safe.
 *
 *****************************************************************************/
#include "PIDpr.h"

#define sqfl    (sqflEffDrv)
/*****************************************************************************
 *
 *      CPidDrv - Effect driver
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *      PID_AddRef
 *
 *      Increment our object reference count (thread-safely) and return
 *      the new reference count.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
PID_AddRef(IDirectInputEffectDriver *ped)
{
    CPidDrv *this = (CPidDrv *)ped;

    InterlockedIncrement((LPLONG)&this->cRef);
    

    return this->cRef;
}


/*****************************************************************************
 *
 *      PID_Release
 *
 *      Decrement our object reference count (thread-safely) and
 *      destroy ourselves if there are no more references.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
PID_Release(IDirectInputEffectDriver *ped)
{
    ULONG ulRc;
    CPidDrv *this = (CPidDrv *)ped;

    if(InterlockedDecrement((LPLONG)&this->cRef) == 0)
    {
		DllRelease(); 
        PID_Finalize(ped);
        LocalFree(this);
        ulRc = 0;
    } else
    {
        ulRc = this->cRef;
    }

    return ulRc;
}

/*****************************************************************************
 *
 *      PID_QueryInterface
 *
 *      Our QI is very simple because we support no interfaces beyond
 *      ourselves.
 *
 *      riid - Interface being requested
 *      ppvOut - receives new interface (if successful)
 *
 *****************************************************************************/

STDMETHODIMP
    PID_QueryInterface(IDirectInputEffectDriver *ped, REFIID riid, LPVOID *ppvOut)
{
    HRESULT hres;

    if(IsEqualIID(riid, &IID_IUnknown) ||
       IsEqualIID(riid, &IID_IDirectInputEffectDriver))
    {
        PID_AddRef(ped);
        *ppvOut = ped;
        hres = S_OK;
    } else
    {
        *ppvOut = 0;
        hres = E_NOINTERFACE;
    }
    return hres;
}

/*****************************************************************************
 *
 *      PID_DeviceID
 *
 *          DirectInput uses this method to inform us of
 *          the identity of the device.
 *
 *          For example, if a device driver is passed
 *          dwExternalID = 2 and dwInternalID = 1,
 *          then this means the interface will be used to
 *          communicate with joystick ID number 2, which
 *          corresonds to physical unit 1 in VJOYD.
 *
 *  dwDirectInputVersion
 *
 *          The version of DirectInput that loaded the
 *          effect driver.
 *
 *  dwExternalID
 *
 *          The joystick ID number being used.
 *          The Windows joystick subsystem allocates external IDs.
 *
 *  fBegin
 *
 *          Nonzero if access to the device is beginning.
 *          Zero if the access to the device is ending.
 *
 *  dwInternalID
 *
 *          Internal joystick id.  The device driver manages
 *          internal IDs.
 *
 *  lpReserved
 *
 *          Reserved for future use (HID).
 *
 *  Returns:
 *
 *          S_OK if the operation completed successfully.
 *
 *          Any DIERR_* error code may be returned.
 *
 *          Private driver-specific error codes in the range
 *          DIERR_DRIVERFIRST through DIERR_DRIVERLAST
 *          may be returned.
 *
 *****************************************************************************/

STDMETHODIMP
    PID_DeviceID(IDirectInputEffectDriver *ped,
                     DWORD dwDirectInputVersion,
                     DWORD dwExternalID, DWORD fBegin,
                     DWORD dwInternalID, LPVOID pvReserved)
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres = S_OK;
    LPDIHIDFFINITINFO   init = (DIHIDFFINITINFO*)pvReserved;

    EnterProcI(PID_DeviceID, (_"xxxxxx", ped, dwDirectInputVersion, dwExternalID, fBegin, dwInternalID, pvReserved));
    
    DllEnterCrit();

    if(  init == NULL )
    {
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%s: FAIL init == NULL "),
                        s_tszProc );
        hres = DIERR_PID_NOTINITIALIZED;
    }
    
    if(    SUCCEEDED(hres) 
        && (init->dwSize < cbX(*init) ) )
    {
        
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%s: FAIL init->dwSize(%d) expecting(%d) "),
                        s_tszProc, init->dwSize, cbX(*init) );
        hres = DIERR_PID_NOTINITIALIZED;
    
    }

    if( SUCCEEDED(hres) )
    {

#ifdef UNICODE
        lstrcpy(this->tszDeviceInterface, init->pwszDeviceInterface );
#else // !UNICODE
        {
            TCHAR   tszDeviceInterface[MAX_DEVICEINTERFACE];
            UToA(tszDeviceInterface, MAX_DEVICEINTERFACE, init->pwszDeviceInterface);

            lstrcpy(this->tszDeviceInterface, tszDeviceInterface);
        }
#endif

        if( FAILED(hres) )
        {
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%s: FAIL:0x%x Invalid string(%s) "),
                            s_tszProc, hres, init->pwszDeviceInterface );
        }
        
        if( SUCCEEDED(hres) && IsEqualGUID(&init->GuidInstance, &GUID_NULL ) )
        {
            hres = DIERR_PID_NOTINITIALIZED;

            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%s: FAIL:init->GuidInstance is NULL "),
                            s_tszProc );
        }
        
        this->GuidInstance = init->GuidInstance;

        /* Record the DI version number */
        this->dwDirectInputVersion = dwDirectInputVersion;

        /* Keep the external ID as a cookie for access to the driver functionality */
        this->dwID = dwExternalID;
    }

    if( SUCCEEDED(hres) )
    {
        /* Ping the device to make sure it is fine */
        hres = PID_Init(ped);
    }

    /*
     *  Remember the unit number because that tells us which of
     *  our devices we are talking to.  The DirectInput external
     *  joystick number is useless to us.  (We don't care if we
     *  are joystick 1 or joystick 2.)
     *
     *  Note that although our other methods are given an external
     *  joystick Id, we don't use it.  Instead, we use the unit
     *  number that we were given here.
     *
     *  Our hardware supports only MAX_UNITS units.
     */

     DllLeaveCrit();

     ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *      PID_GetVersions
 *
 *          Obtain version information about the force feedback
 *          hardware and driver.
 *
 *  pvers
 *
 *          A structure which should be filled in with version information
 *          describing the hardware, firmware, and driver.
 *
 *          DirectInput will set the dwSize field
 *          to sizeof(DIDRIVERVERSIONS) before calling this method.
 *
 *  Returns:
 *
 *          S_OK if the operation completed successfully.
 *
 *          E_NOTIMPL to indicate that DirectInput should retrieve
 *          version information from the VxD driver instead.
 *
 *          Any DIERR_* error code may be returned.
 *
 *          Private driver-specific error codes in the range
 *          DIERR_DRIVERFIRST through DIERR_DRIVERLAST
 *          may be returned.
 *
 *****************************************************************************/

STDMETHODIMP
    PID_GetVersions(IDirectInputEffectDriver *ped, LPDIDRIVERVERSIONS pvers)
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres;

    EnterProc(PID_GetVersions, (_"xx", ped, pvers));

    DllEnterCrit();

    if(pvers->dwSize >= sizeof(DIDRIVERVERSIONS))
    {
        /*
         *  Tell DirectInput how much of the structure we filled in.
         */
        pvers->dwSize = sizeof(DIDRIVERVERSIONS);

        /*
         *  In real life, we would detect the version of the hardware
         *  that is connected to unit number this->dwUnit.
         */
        pvers->dwFirmwareRevision = 0x0;
        pvers->dwHardwareRevision = this->attr.ProductID;
        pvers->dwFFDriverVersion =  PID_DRIVER_VERSION;
        hres = S_OK;
    } else
    {
        hres = E_INVALIDARG;
    }

    DllLeaveCrit();

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *      PID_Escape
 *
 *          DirectInput uses this method to communicate
 *          IDirectInputDevice2::Escape and
 *          IDirectInputEFfect::Escape methods to the driver.
 *
 *  dwId
 *
 *          The joystick ID number being used.
 *
 *  dwEffect
 *
 *          If the application invoked the
 *          IDirectInputEffect::Escape method, then
 *          dwEffect contains the handle (returned by
 *          mf IDirectInputEffectDriver::DownloadEffect)
 *          of the effect at which the command is directed.
 *
 *          If the application invoked the
 *          mf IDirectInputDevice2::Escape method, then
 *          dwEffect is zero.
 *
 *  pesc
 *
 *          Pointer to a DIEFFESCAPE structure which describes
 *          the command to be sent.  On success, the
 *          cbOutBuffer field contains the number
 *          of bytes of the output buffer actually used.
 *
 *          DirectInput has already validated that the
 *          lpvOutBuffer and lpvInBuffer and fields
 *          point to valid memory.
 *
 *  Returns:
 *
 *          S_OK if the operation completed successfully.
 *
 *          Any DIERR_* error code may be returned.
 *
 *          Private driver-specific error codes in the range
 *          DIERR_DRIVERFIRST through DIERR_DRIVERLAST
 *          may be returned.
 *
 *****************************************************************************/

STDMETHODIMP
    PID_Escape(IDirectInputEffectDriver *ped,
                   DWORD dwId, DWORD dwEffect, LPDIEFFESCAPE pesc)
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres;

    EnterProc(PID_Escape, (_"xxxx", ped, dwId, dwEffect, pesc));

    hres = E_NOTIMPL;
    
    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *      PID_GetForceFeedbackState
 *
 *          Retrieve the force feedback state for the device.
 *
 *  dwId
 *
 *          The external joystick number being addressed.
 *
 *  pds
 *
 *          Receives device state.
 *
 *          DirectInput will set the dwSize field
 *          to sizeof(DIDEVICESTATE) before calling this method.
 *
 *  Returns:
 *
 *          S_OK on success.
 *
 *          Any DIERR_* error code may be returned.
 *
 *          Private driver-specific error codes in the range
 *          DIERR_DRIVERFIRST through DIERR_DRIVERLAST
 *          may be returned.
 *
 *****************************************************************************/

STDMETHODIMP
    PID_GetForceFeedbackState(IDirectInputEffectDriver *ped,
                                  DWORD dwId, LPDIDEVICESTATE pds)
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres;
    USHORT  LinkCollection;

    EnterProcI(PID_GetFFState, (_"xxx", ped, dwId, pds));

    DllEnterCrit();

    hres = PID_GetLinkCollectionIndex(ped,g_PoolReport.UsagePage,g_PoolReport.Collection,0x0,&LinkCollection);
	if (SUCCEEDED(hres))
    {
        hres = PID_GetReport
				(ped, 
				 &g_PoolReport,
				 LinkCollection,
				 this->pReport[g_PoolReport.HidP_Type], 
				 this->cbReport[g_PoolReport.HidP_Type] 
				);

		if (SUCCEEDED(hres))
		{
			 if (FAILED(PID_ParseReport
					(
					ped,
					&g_PoolReport,
					LinkCollection,
					&this->ReportPool,
					cbX(this->ReportPool),
					this->pReport[g_PoolReport.HidP_Type],
					this->cbReport[g_PoolReport.HidP_Type]
					)))
			{
				SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%s: FAIL to parse report."),
                        s_tszProc);
			}
		}
		else
		{
			SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%s: FAIL to get report."),
                        s_tszProc);

		}
    }
	else
	{
		SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%s: FAIL to get Link Collection Index."),
                        s_tszProc);

	}
    
    if( ((PUNITSTATE)(g_pshmem + this->iUnitStateOffset))->cEfDownloaded !=  this->ReportPool.uRomETCount )
    {
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%s: PID driver downloaded %d effects, device claims it has %d"),
                        s_tszProc, ((PUNITSTATE)(g_pshmem + this->iUnitStateOffset))->cEfDownloaded, this->ReportPool.uRomETCount );

    }

    if(SUCCEEDED(hres))
    {
        /*
         *  Start out empty and then work our way up.
         */
        pds->dwState = this->dwState;

        /*
         *  If there are no effects, then DIGFFS_EMPTY.
         */
        // ISSUE-2001/03/29-timgill Should use this->ReportPool.uRomETCount == 0x0  
        if(((PUNITSTATE)(g_pshmem + this->iUnitStateOffset))->cEfDownloaded == 0x0 )
        {
            pds->dwState |= DIGFFS_EMPTY;
            
            // No effects playing and device is not paused
            if(!( pds->dwState & DIGFFS_PAUSED ) )
            {
                pds->dwState |= DIGFFS_STOPPED;
            }
        }
    
		//if everything has succeeded, this->ReportPool.uRamPoolSz shouldn't be 0. 
		if (this->ReportPool.uRamPoolSz != 0)
		{
			if( this->uDeviceManaged & PID_DEVICEMANAGED )
			{
				pds->dwLoad = 100 * ( this->dwUsedMem /  this->ReportPool.uRamPoolSz ); 
			}else
			{
				pds->dwLoad = 100 * ( ((PUNITSTATE)(g_pshmem + this->iUnitStateOffset))->cbAlloc / this->ReportPool.uRamPoolSz  ); 
			}
		}
		else
		{
			SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%s: this->ReportPool.uRamPoolSz = 0."),
                        s_tszProc);
			hres = E_FAIL;
		}
    }

    DllLeaveCrit();
    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *      PID_StartEffect
 *
 *          Begin playback of an effect.
 *
 *          If the effect is already playing, then it is restarted
 *          from the beginning.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwEffect |
 *
 *          The effect to be played.
 *
 *  @parm   DWORD | dwMode |
 *
 *          How the effect is to affect other effects.
 *
 *          This parameter consists of zero or more
 *          DIES_* flags.  Note, however, that the driver
 *          will never receive the DIES_NODOWNLOAD flag;
 *          the DIES_NODOWNLOAD flag is managed by
 *          DirectInput and not the driver.
 *
 *  @parm   DWORD | dwCount |
 *
 *          Number of times the effect is to be played.
 *
 *  Returns:
 *
 *          S_OK on success.
 *
 *          Any other DIERR_* error code may be returned.
 *
 *          Private driver-specific error codes in the range
 *          DIERR_DRIVERFIRST through DIERR_DRIVERLAST
 *          may be returned.
 *
 *
 *****************************************************************************/

STDMETHODIMP
    PID_StartEffect(IDirectInputEffectDriver *ped, DWORD dwId, DWORD dwEffect,
                        DWORD dwMode, DWORD dwCount)
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres;

    EnterProc(PID_StartEffect, (_"xxxxx", ped, dwId, dwEffect, dwMode, dwCount));

    DllEnterCrit();

    hres = PID_EffectOperation
           (
           ped, 
           dwId, 
           dwEffect,
           dwMode | PID_DIES_START, 
           dwCount,
		   TRUE,
		   0,
		   1
           );

	if (SUCCEEDED(hres))
	{
		//set the status to DIEGES_PLAYING.
		//we do this because of the following: if an app calls Start(), and then immediately
		//calls GetEffectStatus(), it might happen that our second thread (pidrd.c) 
		//would not have time to update the status of the effect to DIEGES_PLAYING
		//(see Whistler bug 287035).
		//GetEffectStatus() returns (pEffectState->lEfState & DIEGES_PLAYING).
		//at this point, we know that the call to WriteFile() has succeeded, and that
		//all the data has been written (see PID_SendReportBl() in pidhid.c) --
		//so we might as well set the status.
		PEFFECTSTATE pEffectState =  PeffectStateFromBlockIndex(this, dwEffect); 
		pEffectState->lEfState |= DIEGES_PLAYING;
	}

    
    DllLeaveCrit();
    return hres;

    ExitOleProc();
}

/*****************************************************************************
 *
 *      PID_StopEffect
 *
 *          Halt playback of an effect.
 *
 *  dwId
 *
 *          The external joystick number being addressed.
 *
 *  dwEffect
 *
 *          The effect to be stopped.
 *
 *  Returns:
 *
 *          S_OK on success.
 *
 *          Any other DIERR_* error code may be returned.
 *
 *          Private driver-specific error codes in the range
 *          DIERR_DRIVERFIRST through DIERR_DRIVERLAST
 *          may be returned.
 *
 *
 *****************************************************************************/

STDMETHODIMP
    PID_StopEffect(IDirectInputEffectDriver *ped, DWORD dwId, DWORD dwEffect)
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres;

    EnterProc(PID_StopEffect, (_"xxxx", ped, dwId, dwEffect));

    DllEnterCrit();

    hres = PID_EffectOperation
           (
           ped, 
           dwId, 
           dwEffect,
           PID_DIES_STOP, 
           0x0,
		   TRUE,
		   0,
		   1
           );

	if (SUCCEEDED(hres))
		{
			//set the status to ~(DIEGES_PLAYING).
			//we do this because of the following: if an app calls Stop(), and then immediately
			//calls GetEffectStatus(), it might happen that our second thread (pidrd.c) 
			//would not have time to update the status of the effect to DIEGES_PLAYING
			//(see Whistler bug 287035).
			//GetEffectStatus() returns (pEffectState->lEfState & DIEGES_PLAYING).
			//at this point, we know that the call to WriteFile() has succeeded, and that
			//all the data has been written (see PID_SendReportBl() in pidhid.c) --
			//so we might as well set the status.
			PEFFECTSTATE pEffectState =  PeffectStateFromBlockIndex(this, dwEffect); 
			pEffectState->lEfState &= ~(DIEGES_PLAYING);
	}

    ExitOleProc();

    DllLeaveCrit();

    return hres;
}

/*****************************************************************************
 *
 *      PID_GetEffectStatus
 *
 *          Obtain information about an effect.
 *
 *  dwId
 *
 *          The external joystick number being addressed.
 *
 *  dwEffect
 *
 *          The effect to be queried.
 *
 *  pdwStatus
 *
 *          Receives the effect status in the form of zero
 *          or more DIEGES_* flags.
 *
 *  Returns:
 *
 *          S_OK on success.
 *
 *          Any other DIERR_* error code may be returned.
 *
 *          Private driver-specific error codes in the range
 *          DIERR_DRIVERFIRST through DIERR_DRIVERLAST
 *          may be returned.
 *
 *
 *****************************************************************************/

STDMETHODIMP
    PID_GetEffectStatus(IDirectInputEffectDriver *ped, DWORD dwId, DWORD dwEffect,
                            LPDWORD pdwStatus)
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres;

    EnterProc(PID_GetEffectStatus, (_"xxxx", ped, dwId, dwEffect, pdwStatus));

    DllEnterCrit();

    *pdwStatus = 0x0;
    hres = PID_ValidateEffectIndex(ped, dwEffect);

    if(SUCCEEDED(hres) )
    {     
        PEFFECTSTATE    pEffectState =  PeffectStateFromBlockIndex(this,dwEffect); 
            *pdwStatus = (pEffectState->lEfState & DIEGES_PLAYING);
    }
    
    DllLeaveCrit();

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *      The VTBL for our effect driver
 *
 *****************************************************************************/

IDirectInputEffectDriverVtbl PID_Vtbl = {
    PID_QueryInterface,
    PID_AddRef,
    PID_Release,
    PID_DeviceID,
    PID_GetVersions,
    PID_Escape,
    PID_SetGain,
    PID_SendForceFeedbackCommand,
    PID_GetForceFeedbackState,
    PID_DownloadEffect,
    PID_DestroyEffect,
    PID_StartEffect,
    PID_StopEffect,
    PID_GetEffectStatus,
};

/*****************************************************************************
 *
 *      PID_New
 *
 *****************************************************************************/

STDMETHODIMP
    PID_New(REFIID riid, LPVOID *ppvOut)
{
    HRESULT hres;
    CPidDrv *this;

    this = LocalAlloc(LPTR, sizeof(CPidDrv));
    if(this)
    {

        /*
         *  Initialize the basic object management goo.
         */
        this->ed.lpVtbl = &PID_Vtbl;
        this->cRef = 1;
        DllAddRef();

        /*
         *  !!IHV!! Do instance initialization here.
         *
         *  (e.g., open the driver you are going to IOCTL to)
         *
         *  DO NOT RESET THE DEVICE IN YOUR CONSTRUCTOR!
         *
         *  Wait for the SendForceFeedbackCommand(SFFC_RESET)
         *  to reset the device.  Otherwise, you may reset
         *  a device that another application is still using.
         */

        this->hdevOvrlp = this->hdev = INVALID_HANDLE_VALUE;
        
        /*
         *  Attempt to obtain the desired interface.  QueryInterface
         *  will do an AddRef if it succeeds.
         */
        hres = PID_QueryInterface(&this->ed, riid, ppvOut);
        PID_Release(&this->ed);

    } else
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\pid\pidhid.c ===
/*****************************************************************************
 *  PidHid.c
 *
 *  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      HID utility routines for PID .
 *
 *****************************************************************************/
#include "PidPr.h"

#define sqfl        (   sqflHid   )

/*****************************************************************************
 *
 *      PID_GetReportId
 *
 *          Obtain the HID report ID given the usage, usagePage and LinkCollection
 *
 *  IDirectInputEffectDriver | ped |
 *
 *          The effect driver interface
 *
 *  PPIDREPORT | pPidReport |
 *
 *          Address of PIDREPORT structure
 *
 *  USHORT | uLinkCollection |
 *  
 *          LinkCollection ID
 *
 *  OUT UCHAR * | pReportId |
 *
 *          Report ID. Undefined if unsuccessful 
 *
 *  Returns:
 *      
 *  HRESULT 
 *          Error code
 *
 *****************************************************************************/
STDMETHODIMP
    PID_GetReportId
    (
    IDirectInputEffectDriver *ped,
    PPIDREPORT  pPidReport, 
    USHORT  uLinkCollection,
    UCHAR* pReportId
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres = S_OK;

    EnterProcI(PID_GetReportId, (_"xxxx", ped, pPidReport, pReportId));

    if( SUCCEEDED(hres) )
    {
        HIDP_VALUE_CAPS ValCaps;
        USHORT cAValCaps = 0x1;
        USAGE  Usage = DIGETUSAGE(pPidReport->rgPidUsage->dwUsage);
        USAGE  UsagePage = DIGETUSAGEPAGE(pPidReport->rgPidUsage->dwUsage);

        hres = HidP_GetSpecificValueCaps
               (
               pPidReport->HidP_Type,
               UsagePage,
               uLinkCollection,
               Usage,
               &ValCaps,
               &cAValCaps,
               this->ppd 
               );

        // If the report has no values, only buttons
        if(hres == HIDP_STATUS_USAGE_NOT_FOUND )
        {
            // Guarded Laziness 
            CAssertF(cbX(HIDP_VALUE_CAPS) == cbX(HIDP_BUTTON_CAPS) ); 
            CAssertF(FIELD_OFFSET(HIDP_VALUE_CAPS, ReportID) == FIELD_OFFSET(HIDP_BUTTON_CAPS, ReportID) );

            hres = HidP_GetSpecificButtonCaps
                   (
                   pPidReport->HidP_Type,
                   UsagePage,
                   uLinkCollection,
                   0x0,
                   (PHIDP_BUTTON_CAPS)&ValCaps,
                   &cAValCaps,
                   this->ppd 
                   );
        }

        if( SUCCEEDED(hres ) || ( hres == HIDP_STATUS_BUFFER_TOO_SMALL) )
        {
            (*pReportId) = ValCaps.ReportID;
            hres = S_OK;
        } else
        {
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%s: FAIL HidP_GetValCaps for CollectionId%d (%x %x:%s) "),
                            s_tszProc, uLinkCollection, UsagePage, Usage, PIDUSAGETXT(UsagePage,Usage) );
        }
    }

    ExitOleProc();

    return hres;
}
/*****************************************************************************
 *
 *      PID_GetCollectionIndex
 *
 *          Obtain the collection index for collection usage page & usage.
 *
 *
 *          The external joystick number being addressed.
 *
 *  dwEffect
 *
 *          The effect to be queried.
 *
 *  pdwStatus
 *
 *          Receives the effect status in the form of zero
 *          or more DIEGES_* flags.
 *
 *  Returns:
 *          Collection Index ( 0 .. NumberLinkCollectionNodes -1 ) on success
 *          0x0 on failure
 *
 *****************************************************************************/
STDMETHODIMP
    PID_GetLinkCollectionIndex
    (
    IDirectInputEffectDriver *ped,
    USAGE UsagePage, 
    USAGE Collection,
    USHORT Parent,
    PUSHORT puLinkCollection )
{
    CPidDrv *this = (CPidDrv *)ped;
    USHORT indx;
    HRESULT hres;
    PHIDP_LINK_COLLECTION_NODE  pLinkCollection;

    EnterProcI(PID_GetLinkCollectionIndex, (_"xxxxx", this, UsagePage, Collection, Parent, puLinkCollection));
    hres = DIERR_PID_USAGENOTFOUND;

    *puLinkCollection = 0x0;
    for(indx = 0x0, pLinkCollection = this->pLinkCollection; 
       indx < this->caps.NumberLinkCollectionNodes; 
       indx++, pLinkCollection++ )
    {

        if( pLinkCollection->LinkUsagePage == UsagePage && 
            pLinkCollection->LinkUsage     == Collection )
        {
            if( Parent && Parent != pLinkCollection->Parent )
            {
                continue;
            }
            *puLinkCollection = indx;
            hres = S_OK;
            break;
        }
    }

    if( FAILED(hres) )
    {
        SquirtSqflPtszV(sqfl | sqflVerbose,
                        TEXT("%s: FAIL No LinkCollection for (%x %x:%s) "),
                        s_tszProc, UsagePage, Collection, PIDUSAGETXT(UsagePage,Collection) );
    }else
    {
        SquirtSqflPtszV(sqfl | sqflVerbose,
                        TEXT("%s: LinkCollection for (%x %x:%s)=%x "),
                        s_tszProc, UsagePage, Collection, PIDUSAGETXT(UsagePage,Collection), *puLinkCollection );
    }

    ExitBenignOleProc();
    return (hres) ;
}


//Helper fn to tell us when we're dealing w/ an "absolute" usage, since they require special handling
BOOL PID_IsUsageAbsoluteLike
    (
	IDirectInputEffectDriver *ped,
    USHORT			Usage
    )
{
	//"Absolute-like" usages need special handling, 
	//since we can't simply translate data into logical units by scaling
	//but need to calculate exponent, etc.
	//and then use special procedure to set the values
	//"Absolute" usages are all time usages as well as trigger button usages
	if ((Usage == HID_USAGE_PID_DURATION) || (Usage ==HID_USAGE_PID_SAMPLE_PERIOD ) ||
		(Usage == HID_USAGE_PID_TRIGGER_REPEAT_INTERVAL) || (Usage == HID_USAGE_PID_START_DELAY) ||
		(Usage == HID_USAGE_PID_ATTACK_TIME ) ||(Usage == HID_USAGE_PID_FADE_TIME) || 
		(Usage == HID_USAGE_PID_PERIOD) || (Usage == HID_USAGE_PID_TRIGGER_BUTTON))
	{
		return TRUE;
	}

	return FALSE;
}


//Helper fn to tell us when we're dealing w/ a magnitude that can be both positive and negative, 
//since we have to scale those differently
BOOL PID_IsUsagePositiveNegative
    (
	IDirectInputEffectDriver *ped,
    USHORT			Usage,
	USHORT			LinkCollection
    )
{
	BOOL isPosNeg = FALSE;
	//All the usages corresponding to the structures given by LONGs can be positive or negative.
	//Exception is the direction / angle, which should already be scaled into the range 0 - 360 * DI_DEGREES, 
	//so should be treated as only positive.
	//Another exception is DICONDITION.lDeadband, which is defined as a LONG, but our headers
	//say it can only be in the range 0 to DI_FFNOMINALMAX.
	if ((Usage == HID_USAGE_PID_CP_OFFSET) ||
		(Usage == HID_USAGE_PID_POSITIVE_COEFFICIENT) || (Usage == HID_USAGE_PID_NEGATIVE_COEFFICIENT) ||
		(Usage == HID_USAGE_PID_RAMP_START) ||(Usage == HID_USAGE_PID_RAMP_END) || 
		(Usage == HID_USAGE_PID_OFFSET))
	{
		isPosNeg = TRUE;
	}

	//Magnitude of the constant force and the magnitude of the periodic force are defined to be the same thing,
	//but only the constant force magnitude can be both positive and negative.
	//To distinguish them, need to look at the collection. 
	//Get constant force's collection and compare.
	if (Usage == HID_USAGE_PID_MAGNITUDE)
	{
		USHORT ConstCollection = 0x0;
		PID_GetLinkCollectionIndex(ped, g_Constant.UsagePage, g_Constant.Collection, 0x0, &ConstCollection);
		if (LinkCollection == ConstCollection)
		{
			isPosNeg = TRUE;
		}
	}

	return isPosNeg;
}


STDMETHODIMP
    PID_PackValue
    (
    IDirectInputEffectDriver *ped,
    PPIDREPORT  pPidReport,
    USHORT      LinkCollection,
    PVOID       pvData,
    UINT        cbData,
    PCHAR       pReport,
    ULONG       cbReport
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT     hres;
    PPIDUSAGE   pPidUsage;
    UINT        indx;

    EnterProcI( PID_PackValue, (_"xxxxxxx", ped, pPidReport, LinkCollection, pvData, cbData, pReport, cbReport));

    hres = S_OK;
    // Loop over all data values in the PID Report
    for(indx = 0x0, pPidUsage = pPidReport->rgPidUsage; 
       indx < pPidReport->cAPidUsage;
       indx++, pPidUsage++ )
    {
        // Make sure the offsets are valid
        if( pPidUsage->DataOffset < cbData )
        {
            LONG        lValue;
            NTSTATUS    ntStat;
            USHORT      Usage     = DIGETUSAGE(pPidUsage->dwUsage);
            USHORT      UsagePage = DIGETUSAGEPAGE(pPidUsage->dwUsage);

		    lValue = *((LONG*)((UCHAR*)pvData+pPidUsage->DataOffset));

			ntStat = HidP_SetScaledUsageValue 
					 (
					 pPidReport->HidP_Type,
					 UsagePage,
					 LinkCollection,
					 Usage,
					 lValue,
					 this->ppd,
					 pReport,
					 cbReport
					 );

			if( FAILED(ntStat) )
			{
				// HidP_SetScaledUsageValue FAILED

				SquirtSqflPtszV(sqfl | sqflBenign,
							TEXT("%s: FAIL HidP_SetScaledUsageValue:0x%x for(%x,%x,%x:%s)=0x%x "),
							s_tszProc, ntStat, 
							LinkCollection, UsagePage, Usage,
							PIDUSAGETXT(UsagePage,Usage), 
							lValue );

				// Try to set the unscaled value to get something that might make sense
				if( ntStat != HIDP_STATUS_USAGE_NOT_FOUND )
				{
					lValue = -1;
					// The range could be messed up. 
					ntStat = HidP_SetUsageValue 
							 (
							 pPidReport->HidP_Type,
							 UsagePage,
							 LinkCollection,
							 Usage,
							 lValue,
							 this->ppd,
							 pReport,
							 cbReport
							 );
					if(FAILED(ntStat) )
					{
					SquirtSqflPtszV(sqfl | sqflBenign,
								TEXT("%s: FAIL HidP_SetUsageValue:0x%x for(%x,%x,%x:%s)=0x%x "),
								s_tszProc, ntStat, 
								LinkCollection, UsagePage, Usage,
								PIDUSAGETXT(UsagePage,Usage), 
								lValue );
					}
				}
			
			} else
			{
				SquirtSqflPtszV(sqfl | sqflVerbose,
							TEXT("%s: HidP_SetScaledUsageValue:0x%x for(%x,%x,%x:%s)=0x%x "),
							s_tszProc, ntStat, 
							LinkCollection, UsagePage, Usage,
							PIDUSAGETXT(UsagePage,Usage), 
							lValue );
			}
		} else
		{
            //SquirtSqflPtszV(sqfl | sqflBenign,
            //                TEXT("%s: FAIL Invalid Offset(%d), max(%d) "),
            //                s_tszProc, pPidUsage->DataOffset, cbData );
		}
    }
    ExitOleProc();
    return hres;
}


//blocking version -- used for creating a new effect or destroying an effect, and for custom forces
STDMETHODIMP 
    PID_SendReportBl
    (
    IDirectInputEffectDriver *ped,
    PUCHAR  pReport,
    UINT    cbReport,
    HIDP_REPORT_TYPE    HidP_Type
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres;

    EnterProcI( PID_SendReportBl, (_"xxxx", ped, pReport, cbReport, HidP_Type));

    hres = S_OK;
    if( HidP_Type == HidP_Output )
    {
        BOOL frc;
        UINT cbWritten;

        frc = WriteFile (this->hdev,
                         pReport,
                         cbReport,
                         &cbWritten,
                         NULL);

        if( frc != TRUE || cbWritten != cbReport )
        {
            LONG lrc = GetLastError();
            hres = hresLe(lrc);
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%s: FAIL WriteFile():%d (cbWritten(0x%x) cbReport(0x%x) Le(0x%x)"),
                            s_tszProc, frc, cbWritten, cbReport, lrc );

        }
    } else if( HidP_Type == HidP_Feature )
    {
        hres = HidD_SetFeature
               (this->hdev,
                pReport,
                cbReport
               );
        if(FAILED(hres) )
        {
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%s: FAIL SendD_Feature() hres:0x%x"),
                            s_tszProc, hres );

        }

    } else
    {
        hres = DIERR_PID_USAGENOTFOUND;
    }
    ExitOleProc();
    return hres;
}


STDMETHODIMP 
    PID_SendReport
    (
    IDirectInputEffectDriver *ped,
    PUCHAR  pReport,
    UINT    cbReport,
    HIDP_REPORT_TYPE    HidP_Type,
	BOOL	bBlocking,
	UINT	blockNr,
	UINT	totalBlocks
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres = S_OK;

    EnterProcI( PID_SendReport, (_"xxxx", ped, pReport, cbReport, HidP_Type));

	if (bBlocking == TRUE)
	{
		hres = PID_SendReportBl(ped, pReport, cbReport, HidP_Type);
	}
	else
	{
		AssertF(this->hThread != 0x0);
		AssertF(this->hWrite != 0x0);
		AssertF(this->hWriteComplete != 0x0);

		//blockNr is 0-based.
		AssertF(totalBlocks > 0);
		AssertF(blockNr < totalBlocks);

		if( HidP_Type == HidP_Output )
		{
			//WaitForMultipleObjects() till the completion event becomes set.
			//we save each report into the appropriate place in the array.
			//when we get all the reports, we set the event to signal to the other thread to write.
			// Windows bug 627797 -- do not use INFINITE wait, so that we don't hang the app
			//if smth goes wrong w/ the previous write, but instead use the blocking version.
			DWORD dwWait = WaitForMultipleObjects(1, &this->hWriteComplete, FALSE, 1000);
			if (dwWait == WAIT_OBJECT_0)
			{
				AssertF(this->dwWriteAttempt == 0);
				//save the report data
				ZeroMemory(this->pWriteReport[blockNr], this->cbWriteReport[blockNr]);
				memcpy(this->pWriteReport[blockNr], pReport, cbReport);
				this->cbWriteReport[blockNr] = (USHORT)cbReport;
				if (blockNr == totalBlocks-1)
				{
					this->totalBlocks = totalBlocks;
					this->blockNr = 0;
					ResetEvent(this->hWriteComplete);
					SetEvent(this->hWrite);
				}
			}
			else
			{
				//The wait interval has expired, or an error has occured
				RPF( TEXT("Waiting for the write completion event ended without the event being signaled, dwWait = %u"), dwWait);
				//call the blocking version
				hres = PID_SendReportBl(ped, pReport, cbReport, HidP_Type);
			}

		} else if( HidP_Type == HidP_Feature )
		{
			hres = HidD_SetFeature
					 (this->hdev,
					pReport,
					cbReport
					  );
			if(FAILED(hres) )
			{
				SquirtSqflPtszV(sqfl | sqflError,
								TEXT("%s: FAIL SendD_Feature() hres:0x%x"),
								s_tszProc, hres );

			}

		} else
		{
			hres = DIERR_PID_USAGENOTFOUND;
		}
	}

    ExitOleProc();
    return hres;
}

STDMETHODIMP
    PID_ParseReport
    (
    IDirectInputEffectDriver *ped,
    PPIDREPORT  pPidReport,
    USHORT      LinkCollection,
    PVOID       pvData,
    UINT        cbData,
    PCHAR       pReport,
    ULONG       cbReport
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres;
    PPIDUSAGE   pPidUsage;
    UINT        indx;
    EnterProcI( PID_ParseReport, (_"xxxxxxx", ped, pPidReport, pvData, cbData, pReport, cbReport));

    hres = S_OK;
    // Loop over all data values in the PID Report
    for(indx = 0x0, pPidUsage = pPidReport->rgPidUsage; 
       indx < pPidReport->cAPidUsage;
       indx++, pPidUsage++ )
    {
        // Make sure the offsets are valid
        if( pPidUsage->DataOffset < cbData )
        {
            LONG        lValue;
            NTSTATUS    ntStat;
            USHORT      Usage     = DIGETUSAGE(pPidUsage->dwUsage);
            USHORT      UsagePage = DIGETUSAGEPAGE(pPidUsage->dwUsage);

            ntStat = HidP_GetScaledUsageValue 
                     (
                     pPidReport->HidP_Type,
                     UsagePage,
                     LinkCollection,
                     Usage,
                     &lValue,
                     this->ppd,
                     pReport,
                     cbReport
                     );

            if(SUCCEEDED(ntStat))
            {
                *((LONG*)((UCHAR*)pvData+pPidUsage->DataOffset)) = lValue;
            } else
            {
                hres |= E_NOTIMPL;
                                SquirtSqflPtszV(sqfl | sqflBenign,
                                                TEXT("%s: FAIL HidP_GetScaledUsageValue:0x%x for(%x,%x,%x:%s)"),
                                                s_tszProc, ntStat, 
                                                LinkCollection, UsagePage, Usage,
                                                PIDUSAGETXT(UsagePage,Usage) );
            }
        } else
        {

            SquirtSqflPtszV(sqfl | sqflBenign,
                            TEXT("%s: FAIL Invalid Offset(%d), max(%d) "),
                            s_tszProc, pPidUsage->DataOffset, cbData );
        }
    }
    ExitBenignOleProc();
    return hres;
}



STDMETHODIMP 
    PID_GetReport
    (
    IDirectInputEffectDriver *ped,
    PPIDREPORT  pPidReport,
    USHORT      LinkCollection,
    PVOID       pReport,
    UINT        cbReport
    )
{
    HRESULT hres = S_OK;
    CPidDrv *this = (CPidDrv *)ped;
    UCHAR       ReportId;
    EnterProcI( PID_GetReport, (_"xxxxx", ped, pPidReport, LinkCollection, pReport, cbReport));

    if( SUCCEEDED(hres) )
    {
        hres = PID_GetReportId(ped, pPidReport, LinkCollection, &ReportId);

        if(SUCCEEDED(hres) )
        {
            AssertF(pPidReport->HidP_Type == HidP_Feature);

            if(SUCCEEDED(hres) )
            {
                ZeroBuf(pReport, cbReport);

                /*
                 *  The Win9x headers do not yet have use HidP_InitializeReportForID 
                 *  use MAXULONG_PTR to tell the header sets apart so that we can still build
                 */

#ifdef WINNT    
                /*hres*=*/HidP_InitializeReportForID 
                    (
                    pPidReport->HidP_Type,  //ReportType,
                    ReportId,               //ReportID,
                    this->ppd,              //PreparsedData
                    pReport,                //Report
                    cbReport                //ReportLength
                    );
#else
                (*(PUCHAR)pReport) = ReportId;
                hres = S_OK;
#endif
                if( FAILED(hres) )
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%s: FAIL HidP_InitializeReportForId:0x%x for Type(%d) CollectionId%d ReportID%d "),
                                    s_tszProc, hres, pPidReport->HidP_Type, LinkCollection, ReportId );
                }

                if(    SUCCEEDED(hres) 
                       && pPidReport->HidP_Type == HidP_Feature )
                {
                    BOOL frc;
                    frc = HidD_GetFeature 
                          (
                          this->hdev,     // HidDeviceObject,
                          pReport,        // ReportBuffer,
                          cbReport       //ReportBufferLength
                          );

                    if( frc != TRUE )
                    {
                        hres = DIERR_PID_USAGENOTFOUND;
                    }
                }
            }
        }
    }
    ExitOleProc();
    return(hres);
}


/*****************************************************************************
 *
 *      PID_ComputeScalingFactors
 *
 *      Dinput units for various parameters are well defined. The device may choose
 *      to implement the units that it is most comfortable with. This routine
 *      computes scaling factors that are to be used when scaling DINPUT parameters
 *      before they are send to the device. 
 *
 *  IDirectInputEffectDriver | ped |
 *
 *          The effect driver interface
 *
 *  PPIDREPORT | pPidReport |
 *
 *          Address of PIDREPORT structure
 *
 *  USHORT | uLinkCollection |
 *  
 *          LinkCollection ID
 *
 *  IN OUT PVOID | pvData | 
 *
 *          Parameter data. On entry value is the nominal scale used by Dinput.
 *          For example: Angles: DI_DEGREES, DI_FFNOMINALMAX, DI_SECONDS 
 *
 *  IN UINT | cbData | 
 *
 *          Number of valid DWORDS in pvData
 *
 *  Returns:
 *      
 *  HRESULT 
 *          Error code
 *          E_NOTIMPL:						Did not find any usage / usage Page 
 *          DIERR_PID_INVALIDSCALING:		Unsupported device scaling parameters.
 *          S_OK:							Scaling value for at least one parameter was found
 *
 *****************************************************************************/

STDMETHODIMP
    PID_ComputeScalingFactors
    (
    IDirectInputEffectDriver *ped,
    PPIDREPORT  pPidReport,
    USHORT      LinkCollection,
    PVOID       pvData,
    UINT        cbData,
	PVOID		pvOffset,
	UINT		cbOffset
    )
{
    HRESULT hres = E_NOTIMPL;
    CPidDrv *this = (CPidDrv *)ped;
    UINT indx;
    PPIDUSAGE   pPidUsage;

    EnterProcI( PID_ComputeScalingFactors, (_"xxxxxxx", ped, pPidReport, LinkCollection, pvData, cbData, pvOffset, cbOffset));

    // Loop over all data values in the PID Report
    for(indx = 0x0, pPidUsage = pPidReport->rgPidUsage; 
       indx < pPidReport->cAPidUsage;
       indx++, pPidUsage++ )
    {
        // Make sure the offsets are valid
        if (( pPidUsage->DataOffset < cbData ) && (pPidUsage->DataOffset < cbOffset))
        {
            NTSTATUS    ntStat;
            HIDP_VALUE_CAPS ValCaps;
            USHORT      cAValCaps = 0x1;

            USHORT      Usage     = DIGETUSAGE(pPidUsage->dwUsage);
            USHORT      UsagePage = DIGETUSAGEPAGE(pPidUsage->dwUsage);
            PDWORD      pdwValue;
			PDWORD      pdwOffset;    
            DWORD       dwScale = 0x1;
			DWORD		dwOffset = 0x0;

            pdwValue = ((DWORD*)((UCHAR*)pvData+pPidUsage->DataOffset));
			pdwOffset = ((DWORD*)((UCHAR*)pvOffset+pPidUsage->DataOffset));

            ntStat = HidP_GetSpecificValueCaps 
                     (
                     pPidReport->HidP_Type,
                     UsagePage,
                     LinkCollection,
                     Usage,
                     &ValCaps,
                     &cAValCaps,
                     this->ppd
                     );

            if(SUCCEEDED(ntStat))
            {
		//some units are "absolute" and thus don't need to be scaled to the limits.
				//for them, we just find out the correct units
		if (PID_IsUsageAbsoluteLike(ped, Usage))
		{
			if( ! ValCaps.Units )
			{
				SquirtSqflPtszV(sqfl | sqflVerbose,
						TEXT("%s:No Units(%x,%x %x:%s) Max:%d Scale:%d "),
						s_tszProc, LinkCollection, UsagePage, Usage, PIDUSAGETXT(UsagePage,Usage),
						ValCaps.PhysicalMax, dwScale );
				// No units, scaling exponent is default = 1
				hres = S_FALSE;
			} else
			{
				LONG UnitExp;
				UnitExp = (LONG)ValCaps.UnitsExp ;

				if( UnitExp > 0x0 )
				{
					RPF(TEXT("Driver does not support Units (%x,%x %x:%s) Exp:%d Max:%d"),
						LinkCollection, UsagePage, Usage, PIDUSAGETXT(UsagePage,Usage), ValCaps.UnitsExp, ValCaps.PhysicalMax ) ;
					hres = DIERR_PID_INVALIDSCALING;
				}else
				{
					hres = S_OK;
				}

				if(SUCCEEDED(hres) )
				{
					dwScale = (*pdwValue);
					for(; UnitExp; UnitExp++ )
				{
					dwScale /= 10;
				}

				if( dwScale == 0 )
				{
					RPF(TEXT("Driver does not support Units (%x,%x %x:%s) Exp:%d Max:%d"),
						LinkCollection, UsagePage, Usage, PIDUSAGETXT(UsagePage,Usage), ValCaps.UnitsExp, ValCaps.PhysicalMax ) ;
					dwScale = 0x1;
					hres = DIERR_PID_INVALIDSCALING;
				}else
				{ 
					hres = S_OK;
				}
			}
			SquirtSqflPtszV(sqfl | sqflVerbose,
                                    TEXT("%s: (%x,%x %x:%s) Exp%d Max:%d Scale:%d "),
                                    s_tszProc, LinkCollection, UsagePage, Usage, PIDUSAGETXT(UsagePage,Usage),
                                    ValCaps.UnitsExp, ValCaps.PhysicalMax, (*pdwValue) );
			}
		}
		else
		{
			//for everything else, get Physical and /or Logical  Min/ Max
			//From PID spec, doesn't have to have a Physical / Logical Min, but does have to have either Physical or Logical Max
			if ((!ValCaps.PhysicalMax) && (!ValCaps.LogicalMax))
			{
				RPF(TEXT("Driver does not have either Physical Max or Logical Max for (%x,%x %x:%s)"),
					LinkCollection, UsagePage, Usage, PIDUSAGETXT(UsagePage,Usage)) ;
				hres = DIERR_PID_INVALIDSCALING;
			}
			else
			{
				//Compute the scaling value from either Physical or Logical Min/ Max and store it
				int Scale = 0;
				int Min = 0;
				int Max = 0;
				if (ValCaps.PhysicalMax)
				{
					Max = ValCaps.PhysicalMax;
					if (ValCaps.PhysicalMin)
					{
						Min = ValCaps.PhysicalMin;
					}
				}
				else 
				{
					Max = ValCaps.LogicalMax;
					if (ValCaps.LogicalMin)
					{
						Min = ValCaps.LogicalMin;
					}
				}
#ifdef DEBUG
				//if Min/max are not in correct order, print a message so that we know if there are any problems w/ the forces
				if (Min >= Max)
				{
					RPF(TEXT("Maximum of the device's range is %d, not bigger than minimum %d"), Max, Min);
				}
#endif
				//certain magnitudes can be both positive and negative -- for those, we need to know the device's offset
				if (PID_IsUsagePositiveNegative(ped, Usage, LinkCollection))
				{
					
					Scale = (Max - Min)/2; 
					dwOffset = (Max + Min)/2; 

				}
				//other magnitudes can only be positive
				else
				{
					Scale = Max - Min;
					dwOffset = Min;
				}
				//for angular usages, multiply by DI_FFNOMINALMAX and divide by 360 * DI_DEGREES
				//we are doing this since later we will have no way of knowing that the values represent angles,
				//and will thus divide all the values by DI_FFNOMINALMAX
				if (*pdwValue == 360 * DI_DEGREES)
				{
					dwScale = MulDiv(Scale, DI_FFNOMINALMAX, (360 * DI_DEGREES));
				}
				else
				{
					dwScale = Scale;
				}
				hres = S_OK;
			}
		}

            } else
            {
                // HidP_SetScaledUsageValue FAILED
                SquirtSqflPtszV(sqfl | sqflBenign,
                                TEXT("%s: FAIL HidP_GetSpecificValueCaps:0x%x for(%x,%x,%x:%s)=0x%x "),
                                s_tszProc, ntStat, 
                                LinkCollection, UsagePage, Usage,
                                PIDUSAGETXT(UsagePage,Usage), 
                                dwScale );
            }

            (*pdwValue) = dwScale;
			(*pdwOffset) = dwOffset;
        } else
        {
            //SquirtSqflPtszV(sqfl | sqflVerbose,
            //                TEXT("%s: FAIL Invalid Offset(%d), max(%d) "),
            //                s_tszProc, pPidUsage->DataOffset, cbData );
        }
    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *      PID_ApplyScalingFactors
 *
 *      Dinput units for various parameters are well defined. The device may choose
 *      to implement the units that it is most comfortable with. This routine
 *      apply scaling factors that are to be used when scaling DINPUT parameters
 *      before they are send to the device. 
 *
 *  IDirectInputEffectDriver | ped |
 *
 *      The effect driver interface
 *
 *  PPIDREPORT | pPidReport |
 *
 *      Address of PIDREPORT structure
 *
 *  IN PVOID | pvScale |
 *  
 *      Scaling values
 *
 *  IN UINT | cbScale | 
 *
 *      Number of scaling values.
 *
 *  IN OUT PVOID | pvData | 
 *
 *      Array of data values.
 *
 *  IN UINT | cbData | 
 *
 *      Number of data values. 
 *
 *  Returns:
 *      
 *  HRESULT 
 *          Error code
 *          E_NOTIMPL:						Did not find any usage / usage Page 
 *          DIERR_PID_INVALIDSCALING:				Unsupported device scaling parameters.
 *          S_OK:						Scaling value for at least one parameter was found
 *
 *****************************************************************************/


STDMETHODIMP
    PID_ApplyScalingFactors
    (
    IDirectInputEffectDriver *ped,
    PPIDREPORT  pPidReport,
    PVOID       pvScale,
    UINT        cbScale,
	PVOID		pvOffset,
	UINT		cbOffset,
    PVOID       pvData,
    UINT        cbData
    )
{
    HRESULT hres = S_OK;
    CPidDrv *this = (CPidDrv *)ped;
    UINT indx;
    PPIDUSAGE   pPidUsage;
    EnterProcI( PID_ApplyScalingFactors, (_"xxxxxxxx", ped, pPidReport, pvScale, cbScale, pvOffset, cbOffset, pvData, cbData));
    // Loop over all data values in the PID Report
    for(indx = 0x0, pPidUsage = pPidReport->rgPidUsage; 
       indx < pPidReport->cAPidUsage;
       indx++, pPidUsage++ )
    {
        // Make sure we the offsets are valid
        if( (pPidUsage->DataOffset < cbData) &&
            (pPidUsage->DataOffset < cbScale) && ((pPidUsage->DataOffset < cbOffset) ))
        {
			PUINT      pValue;        
			PUINT      pScale;
			PUINT	   pOffset;

			pValue = ((PUINT)((UCHAR*)pvData    +pPidUsage->DataOffset));
			pScale = ((PUINT)((UCHAR*)pvScale   +pPidUsage->DataOffset));
			pOffset = ((PUINT)((UCHAR*)pvOffset   +pPidUsage->DataOffset));

			//"absolute"-like usages need special handling, because they don't need to be scaled to the max device values
			if (PID_IsUsageAbsoluteLike(ped, DIGETUSAGE(pPidUsage->dwUsage)))
			{
				if( (*pScale) > 0x1 )
				{
					(*pValue) /= (*pScale) ;    
				}
			}
			//for everything else, do a calculation based on Logical or Physical Min/ Max
			else
			{
				(int)(*pValue) = MulDiv((*pScale), (*pValue), DI_FFNOMINALMAX) + (*pOffset);
			}
        } else
        {
            //SquirtSqflPtszV(sqfl | sqflBenign,
            //                TEXT("%s: FAIL Invalid Offset(%d), max(%d) "),
            //                s_tszProc, pPidUsage->DataOffset, cbData );
        }
    }

    ExitOleProc();
    return hres;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\pid\pidi.h ===
/*****************************************************************************
 *
 *  Pidi.h
 *
 *  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Internal header for PID driver.
 *
 *****************************************************************************/
#define hresLe(le) MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, (USHORT)(le))
#define HidP_Max                                        (HidP_Feature+1)

#define REGSTR_PATH_VID_PID_TEMPLATE    REGSTR_PATH_JOYOEM TEXT("\\VID_%04X&PID_%04X")
#define REGSTR_OEM_FF_TEMPLATE          REGSTR_PATH_VID_PID_TEMPLATE TEXT("\\OEMForceFeedback")
#define REGSTR_EFFECTS                  TEXT("Effects")
#define REGSTR_ATTRIBUTES               TEXT("Attributes")
#define REGSTR_CLSID                    TEXT("CLSID")
#define REGSTR_CREATEDBY                TEXT("CreatedBy")
#define MAX_DEVICEINTERFACE             (1024)

#define PIDMAKEUSAGEDWORD(Usage) \
    DIMAKEUSAGEDWORD(HID_USAGE_PAGE_PID, HID_USAGE_PID_##Usage )

#define DIGETUSAGEPAGE(UsageAndUsagePage)   ((USAGE)(HIWORD(UsageAndUsagePage)))
#define DIGETUSAGE(    UsageAndUsagePage)   ((USAGE)(LOWORD(UsageAndUsagePage)))
#define MAKE_PIDUSAGE( Usage, Offset )      { PIDMAKEUSAGEDWORD(Usage), Offset }
#define MAKE_HIDUSAGE( UsagePage, Usage, Offset )   { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_##UsagePage, Usage), Offset }


#define PID_DIES_START      (0x80000000)
#define PID_DIES_STOP       (0x40000000)
#define PIDALLOC_INIT       (0xF)

#define HID_VALUE           (0x01)
#define HID_BUTTON          (0x02)
#define HID_COLLECTION      (0x04)

#define MAX_ORDINALS        (8)
#define MAX_BUTTONS         (0xff)
#define MAX_AXES            (8)

/*
 *  Device-specific errors for USB/PID force feedback devices. 
 */

/*
 *  The requested usage was not found.
 */
#define  DIERR_PID_USAGENOTFOUND	DIERR_DRIVERFIRST + 1

/*
 *  The parameter block couldn't be	downloaded to the device.
 */
#define DIERR_PID_BLOCKLOADERROR	DIERR_DRIVERFIRST + 2

/*
 *  PID initialization failed.
 */
#define DIERR_PID_NOTINITIALIZED	DIERR_DRIVERFIRST + 3

/*
 *  The provided values couldn't be scaled.
 */
#define DIERR_PID_INVALIDSCALING	DIERR_DRIVERFIRST + 4


typedef CONST GUID *LPCGUID;
#ifndef MAXULONG_PTR
typedef DWORD   ULONG_PTR;
typedef DWORD   *PULONG_PTR;
typedef DWORD   UINT_PTR;
typedef DWORD   *PULONG_PTR;
#endif //MAXULONG_PTR


/*****************************************************************************
 *
 *      For each active unit, one of these structures exists to keep
 *      track of which effects are "in use".
 *
 *      Our imaginary hardware does not do dynamic memory allocation;
 *      there are merely 16 "slots", and each "slot" can be "in use"
 *      or "free".
 *
 *****************************************************************************/

#define MAX_UNITS        4
#define GLOBAL_EFFECT_MEMSZ ( 1024 )

typedef struct _PIDMEM{
    ULONG       uOfSz;
    INT_PTR     iNext;
} PIDMEM, *PPIDMEM;


#define PIDMEM_OFFSET(pMem)  ( HIWORD(pMem->uOfSz) )
#define PIDMEM_SIZE(pMem)    ( LOWORD(pMem->uOfSz) )
#define PIDMEM_OFSZ(Offset, Size)    ( MAKELONG((Size), (Offset)) ) 

#define GET_NEXTOFFSET(pMem) ( PIDMEM_OFFSET(pMem) + PIDMEM_SIZE(pMem) )


typedef struct _EFFECTSTATE{
    ULONG   lEfState;
    PIDMEM  PidMem[];
} EFFECTSTATE, *PEFFECTSTATE;


typedef struct _UNITSTATE {
    GUID    GuidInstance;
    USHORT  cEfDownloaded;
    USHORT  nAlloc;
    USHORT  cbAlloc;
    PIDMEM  Guard[2];
    UCHAR   State[GLOBAL_EFFECT_MEMSZ];
} UNITSTATE, *PUNITSTATE;

/*****************************************************************************
 *
 *      Since the information to track each unit is so small, we pack them
 *      together into a single shared memory block to save memory.
 *
 *      We use our own GUID as the name of the memory block to avoid
 *      collisions with other named memory blocks.
 *
 *****************************************************************************/

typedef struct SHAREDMEMORY {
    UNITSTATE rgus[MAX_UNITS];
} SHAREDMEMORY, *PSHAREDMEMORY;



typedef struct _REPORTPOOL
{
    ULONG   uRamPoolSz;
    ULONG   uRomPoolSz;
    ULONG   uRomETCount;
    ULONG   uSimulEfMax;
    ULONG   uPoolAlign;
} REPORTPOOL, *PREPORTPOOL;

typedef struct _SZPOOL
{
    ULONG   uSzEffect;
    ULONG   uSzEnvelope;
    ULONG   uSzCondition;
    ULONG   uSzCustom;
    ULONG   uSzPeriodic;
    ULONG   uSzConstant;
    ULONG   uSzRamp;
    ULONG   uSzCustomData;
} SZPOOL,  *PSZPOOL;

typedef struct _DIUSAGEANDINST
{
    DWORD   dwUsage;
    DWORD   dwType;    
} DIUSAGEANDINST, *PDIUSAGEANDINST;

#define MAX_BLOCKS 4 //we can send up to 4 blocks at a time -- 1 effect block, 2 param blocks & 1 effect operation block

typedef struct CPidDrv
{

    /* Supported interfaces */
    IDirectInputEffectDriver ed;

    ULONG               cRef;           /* Object reference count */

    /*
     *  !!IHV!!  Add additional instance data here.
     *  (e.g., handle to driver you want to IOCTL to)
     */

    DWORD               dwDirectInputVersion;

    DWORD               dwID;

    TCHAR                tszDeviceInterface[MAX_DEVICEINTERFACE];
    GUID                GuidInstance;

    HANDLE              hdev;

    PHIDP_PREPARSED_DATA    \
        ppd;

    HIDD_ATTRIBUTES     attr;

    HIDP_CAPS           caps;

    PUCHAR              pReport[HidP_Max];
    USHORT              cbReport[HidP_Max];

	//here we store reports that need to be written in a non-blocking way
	PUCHAR				pWriteReport[MAX_BLOCKS];  
	USHORT				cbWriteReport[MAX_BLOCKS];

    PHIDP_LINK_COLLECTION_NODE  pLinkCollection;

    USHORT              cMaxEffects;
    USHORT              cMaxParameters;
    /*
     *  We remember the unit number because that tells us
     *  which I/O port we need to send the commands to.
     */
    DWORD               dwUnit;         /* Device unit number */

    UINT                uDeviceManaged;

    UINT                cFFObjMax;
    UINT                cFFObj;
    PDIUSAGEANDINST     rgFFUsageInst;


    REPORTPOOL          ReportPool;             
    SZPOOL              SzPool;

    INT_PTR				iUnitStateOffset;       

    DIEFFECT            DiSEffectScale;
	DIEFFECT            DiSEffectOffset;
    DIENVELOPE          DiSEnvScale;
	DIENVELOPE          DiSEnvOffset;
    DICONDITION         DiSCondScale;
	DICONDITION         DiSCondOffset;
    DIRAMPFORCE         DiSRampScale;
	DIRAMPFORCE         DiSRampOffset;
    DIPERIODIC          DiSPeriodicScale;
	DIPERIODIC          DiSPeriodicOffset;
    DICONSTANTFORCE     DiSConstScale;
	DICONSTANTFORCE     DiSConstOffset;
    DICUSTOMFORCE       DiSCustomScale;
	DICUSTOMFORCE       DiSCustomOffset;

    DWORD               DiSEffectAngleScale[MAX_ORDINALS];
	DWORD               DiSEffectAngleOffset[MAX_ORDINALS];
    DWORD               DiSCustomSample[MAX_ORDINALS];

	HIDP_VALUE_CAPS		customCaps[3];
	HIDP_VALUE_CAPS		customDataCaps;

    HANDLE              hThread;
    DWORD               idThread; 
    ULONG               cThreadRef;
    HANDLE              hdevOvrlp;
    OVERLAPPED          o;
	HANDLE				hWrite;
	HANDLE				hWriteComplete;
	DWORD				dwWriteAttempt;
	UINT				totalBlocks; //how many total blocks we need to write
	UINT				blockNr; //the block we're currently writing
    DWORD               dwState;
    DWORD               dwUsedMem;

} CPidDrv, *PCPidDrv;


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct EFFECTMAPINFO |
 *
 *          Information about an effect, much like a
 *          <t DIEFFECTINFO>, but containing the
 *          effect ID, too.
 *
 *  @field  DWORD | dwId |
 *
 *          The effect ID.  This comes first so we can copy
 *          an <t EFFECTMAPINFO> into a <t DIEFFECTINFO>
 *          all at one go.
 *
 *  @field  GUID | guid |
 *
 *          The effect GUID.
 *
 *  @field  DWORD | dwEffType |
 *
 *          The effect type and flags.
 *
 *  @field  WCHAR | wszName[MAX_PATH] |
 *
 *          The name for the effect.
 *
 *****************************************************************************/

typedef struct _EFFECTMAPINFO
{
    DIEFFECTATTRIBUTES attr;
    PCGUID  pcguid;
    TCHAR   tszName[MAX_PATH];
} EFFECTMAPINFO, *PEFFECTMAPINFO;
typedef const EFFECTMAPINFO *PCEFFECTMAPINFO;

typedef struct  _PIDSUPPORT
{
    DWORD   dwDIFlags;
    DWORD   dwPidUsage;
    USAGE   Type;
    HIDP_REPORT_TYPE  HidP_Type;
} PIDSUPPORT, *PPIDSUPPORT;

typedef struct _PIDUSAGE
{
    DWORD   dwUsage;
    UINT    DataOffset;
} PIDUSAGE, *PPIDUSAGE;

typedef struct _PIDREPORT
{
    HIDP_REPORT_TYPE    HidP_Type;    

    USAGE               UsagePage;
    USAGE               Collection;


    UINT                cbXData;
    UINT                cAPidUsage;
    PPIDUSAGE           rgPidUsage;
} PIDREPORT, *PPIDREPORT;

extern  PIDREPORT   g_BlockIndex;
extern  PIDREPORT   g_Effect;
extern  PIDREPORT   g_Condition;
extern  PIDREPORT   g_Periodic;
extern  PIDREPORT   g_Ramp;
extern  PIDREPORT   g_Envelope;
extern  PIDREPORT   g_Constant;
extern  PIDREPORT   g_Direction;
extern  PIDREPORT   g_TypeSpBlockOffset;
extern  PIDREPORT   g_PoolReport;
extern  PIDREPORT   g_BlockIndexIN;
extern  PIDREPORT   g_Custom;
extern  PIDREPORT   g_CustomSample;
extern  PIDREPORT   g_CustomData;

#pragma BEGIN_CONST_DATA
static PIDUSAGE c_rgUsgDirection[]=
{
    MAKE_HIDUSAGE(GENERIC, HID_USAGE_GENERIC_RX, 0*cbX(ULONG)),
    MAKE_HIDUSAGE(GENERIC, HID_USAGE_GENERIC_RY, 1*cbX(ULONG)),
    MAKE_HIDUSAGE(GENERIC, HID_USAGE_GENERIC_RZ, 2*cbX(ULONG)),
};
/*
 *  Define translation table for ordinals to HID usages 
 */
static PIDUSAGE     c_rgUsgOrdinals[] =
{
    MAKE_HIDUSAGE(ORDINAL,  0x1, 0*cbX(ULONG)),
    MAKE_HIDUSAGE(ORDINAL,  0x2, 1*cbX(ULONG)),
    MAKE_HIDUSAGE(ORDINAL,  0x3, 2*cbX(ULONG)),
    MAKE_HIDUSAGE(ORDINAL,  0x4, 3*cbX(ULONG)),
    MAKE_HIDUSAGE(ORDINAL,  0x5, 4*cbX(ULONG)),
    MAKE_HIDUSAGE(ORDINAL,  0x6, 5*cbX(ULONG)),
    MAKE_HIDUSAGE(ORDINAL,  0x7, 6*cbX(ULONG)),
    MAKE_HIDUSAGE(ORDINAL,  0x8, 7*cbX(ULONG)),
};
#pragma END_CONST_DATA


    typedef BOOL    (WINAPI *CANCELIO)(HANDLE);
    typedef BOOL    (WINAPI *TRYENTERCRITICALSECTION)(LPCRITICAL_SECTION);

    BOOL WINAPI FakeCancelIO(HANDLE h);
    BOOL WINAPI FakeTryEnterCriticalSection(LPCRITICAL_SECTION lpCrit_sec);

    extern CANCELIO CancelIo_;
    extern TRYENTERCRITICALSECTION TryEnterCriticalSection_;


/*****************************************************************************
 *
 *      Constant globals:  Never change.  Ever.
 *
 *****************************************************************************/
DEFINE_GUID(GUID_MySharedMemory,    0x1dc900bf,0xbcac,0x11d2,0xa9,0x19,0x00,0xc0,0x4f,0xb9,0x86,0x38); 
DEFINE_GUID(GUID_MyMutex,           0x4368208f,0xbcac,0x11d2,0xa9,0x19,0x00,0xc0,0x4f,0xb9,0x86,0x38);

/*****************************************************************************
 *
 *      Static globals:  Initialized at PROCESS_ATTACH and never modified.
 *
 *****************************************************************************/

extern HINSTANCE g_hinst;       /* This DLL's instance handle */
extern PSHAREDMEMORY g_pshmem;  /* Our shared memory block */
extern HANDLE g_hfm;            /* Handle to file mapping object */
extern HANDLE g_hmtxShared;     /* Handle to mutex that protects g_pshmem */

/*****************************************************************************
 *
 *      Prototypes
 *
 *****************************************************************************/

STDMETHODIMP
    PID_DownloadEffect
    (
    IDirectInputEffectDriver *ped,
    DWORD dwId, 
    DWORD dwEffectId,
    LPDWORD pdwEffect, 
    LPCDIEFFECT peff, 
    DWORD dwFlags
    );


STDMETHODIMP
    PID_DoParameterBlocks
    (
    IDirectInputEffectDriver *ped,
    DWORD dwId, 
    DWORD dwEffectId,
    DWORD dwEffectIndex, 
    LPCDIEFFECT peff, 
    DWORD dwFlags,
    PUINT puParameter,
	BOOL  bBlocking,
	UINT  totalBlocks
    );

STDMETHODIMP
    PID_EffectOperation
    (
    IDirectInputEffectDriver *ped, 
    DWORD dwId, 
    DWORD dwEffect,
    DWORD dwMode, 
    DWORD dwCount,
	BOOL  bBlocking,
	UINT  blockNr,
	UINT  totalBlocks
    );

STDMETHODIMP
    PID_SetGain
    (
    IDirectInputEffectDriver *ped, 
    DWORD dwId, 
    DWORD dwGain
    );


STDMETHODIMP
    PID_SendForceFeedbackCommand
    (
    IDirectInputEffectDriver *ped,
    DWORD dwId, 
    DWORD dwCommand
    );


STDMETHODIMP
    PID_GetLinkCollectionIndex
    (
    IDirectInputEffectDriver *ped,
    USAGE UsagePage, 
    USAGE Collection,
    USHORT Parent,
    PUSHORT puLinkCollection 
    );

STDMETHODIMP 
    PID_Init
    (
    IDirectInputEffectDriver *ped
    );

STDMETHODIMP
    PID_InitFFAttributes
    (
    IDirectInputEffectDriver *ped 
    );

STDMETHODIMP 
    PID_Finalize
    (
    IDirectInputEffectDriver *ped
    );

STDMETHODIMP
    PID_InitRegistry
    (
    IDirectInputEffectDriver *ped
    );

STDMETHODIMP 
    PID_Support
    (
    IDirectInputEffectDriver *ped,
    UINT        cAPidSupport,
    PPIDSUPPORT rgPidSupport,
    PDWORD      pdwFlags
    );

STDMETHODIMP
    PID_PackValue
    (
    IDirectInputEffectDriver *ped,
    PPIDREPORT  pPidReport,
    USHORT      LinkCollection,
    PVOID       pvData,
    UINT        cbData,
    PCHAR       pReport,
    ULONG       cbReport
    );

STDMETHODIMP
    PID_ParseReport
    (
    IDirectInputEffectDriver *ped,
    PPIDREPORT  pPidReport,
    USHORT      LinkCollection,
    PVOID       pvData,
    UINT        cbData,
    PCHAR       pReport,
    ULONG       cbReport
    );

STDMETHODIMP 
    PID_SendReport
    (
    IDirectInputEffectDriver *ped,
    PUCHAR  pReport,
    UINT    cbReport,
    HIDP_REPORT_TYPE    HidP_Type,
	BOOL	bBlocking,
	UINT	blockNr,
	UINT	totalBlocks
    );

STDMETHODIMP 
    PID_GetReport
    (
    IDirectInputEffectDriver *ped,
    PPIDREPORT  pPidReport,
    USHORT      LinkCollection,
    PVOID       pReport,
    UINT        cbReport
    );


STDMETHODIMP 
    PID_NewEffectIndex
    (
    IDirectInputEffectDriver *ped,
    LPDIEFFECT  lpdieff,
    DWORD    dwEffectId,
    PDWORD   pdwEffect 
    );

STDMETHODIMP 
    PID_ValidateEffectIndex
    (
    IDirectInputEffectDriver *ped,
    DWORD   pdwEffect 
    );

STDMETHODIMP 
    PID_DestroyEffect
    (
    IDirectInputEffectDriver *ped,
    DWORD   dwId,
    DWORD   dwEffect
    );

STDMETHODIMP
    PID_GetParameterOffset
    (
    IDirectInputEffectDriver *ped,
    DWORD      dwEffectIndex,
    UINT       uParameterBlock,
    DWORD      dwSz,
    PLONG      plValue
    );


STDMETHODIMP
    PID_ComputeScalingFactors
    (
    IDirectInputEffectDriver *ped,
    PPIDREPORT  pPidReport,
    USHORT      LinkCollection,
    PVOID       pvData,
    UINT        cbData,
	PVOID       pvOffset,
    UINT        cbOffset
    );


STDMETHODIMP
    PID_ApplyScalingFactors
    (
    IDirectInputEffectDriver *ped,
    PPIDREPORT  pPidReport,
    PVOID       pvScale,
    UINT        cbScale,
	PVOID       pvOffset,
    UINT        cbOffset,
    PVOID       pvData,
    UINT        cbData
    );

STDMETHODIMP
    PID_GetReportId
    (
    IDirectInputEffectDriver *ped,
    PPIDREPORT  pPidReport, 
    USHORT  uLinkCollection,
    UCHAR* pReportId
    );

VOID INTERNAL
    PID_ThreadProc(CPidDrv* this);

STDMETHODIMP_(ULONG)
PID_AddRef(IDirectInputEffectDriver *ped);


STDMETHODIMP_(ULONG)
PID_Release(IDirectInputEffectDriver *ped);


void EXTERNAL
    NameFromGUID(LPTSTR ptszBuf, PCGUID pguid);

#ifdef DEBUG

    #define PIDUSAGETXT_MAX ( 0xAC )

extern PTCHAR   g_rgUsageTxt[PIDUSAGETXT_MAX];    // Cheat sheet for EffectNames
    
    #define PIDUSAGETXT(UsagePage, Usage )  \
        ( ( UsagePage == HID_USAGE_PAGE_PID && Usage < PIDUSAGETXT_MAX) ? g_rgUsageTxt[Usage] : NULL )  

    void PID_CreateUsgTxt();
    
#else

#define  PID_CreateUsgTxt() 
#define  PIDUSAGETXT(UsagePage, Usage)       ( NULL )

#endif


PEFFECTSTATE INLINE PeffectStateFromBlockIndex(PCPidDrv this, UINT Index )
{
    return (PEFFECTSTATE)(&((PUNITSTATE)(g_pshmem + this->iUnitStateOffset))->State[0] + (Index-1) * ((FIELD_OFFSET(EFFECTSTATE,PidMem)) + this->cMaxParameters*cbX(PIDMEM)));
}

#define PID_EFFECT_RESET        (0x0000000)
#define PID_EFFECT_BUSY         (0x8000000)
#define PID_EFFECT_STARTED      (0x4000000)
#define PID_EFFECT_STARTED_SOLO (0x2000000)


#define PID_DRIVER_VERSION  (0x0000001)

#define PID_DEVICEMANAGED   (0x1)
#define PID_SHAREDPARAM     (0x2)



/*****************************************************************************
 *
 *      Dll global functions
 *
 *****************************************************************************/

void EXTERNAL DllEnterCrit_(LPCTSTR lptszFile, UINT line);
void EXTERNAL DllLeaveCrit_(LPCTSTR lptszFile, UINT line);

#ifdef DEBUG
    BOOL EXTERNAL DllInCrit(void);
    #define DllEnterCrit() DllEnterCrit_(TEXT(__FILE__), __LINE__)
    #define DllLeaveCrit() DllLeaveCrit_(TEXT(__FILE__), __LINE__)
#else
    #define DllEnterCrit() DllEnterCrit_(NULL, 0x0)
    #define DllLeaveCrit() DllLeaveCrit_(NULL, 0x0)
#endif

STDAPI_(ULONG) DllAddRef(void);
STDAPI_(ULONG) DllRelease(void);

/*****************************************************************************
 *
 *      Class factory
 *
 *****************************************************************************/

STDAPI CClassFactory_New(REFIID riid, LPVOID *ppvObj);

/*****************************************************************************
 *
 *      Effect driver
 *
 *****************************************************************************/

STDAPI PID_New(REFIID riid, LPVOID *ppvObj);


#ifndef WINNT
    /***************************************************************************
     *
     *      KERNEL32 prototypes missing from Win98 headers.
     *
     ***************************************************************************/
    WINBASEAPI BOOL WINAPI CancelIo( HANDLE hFile );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\pid\pidop.c ===
/*****************************************************************************
 *
 *  PidOp.c
 *
 *  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      PID device Operation .
 *
 *****************************************************************************/
#include "pidpr.h"

#define sqfl            ( sqflOp )

#pragma BEGIN_CONST_DATA

static PIDUSAGE    c_rgUsgGain[] =
{
    MAKE_PIDUSAGE(DEVICE_GAIN,  0x0 )
};

static PIDREPORT DeviceGain =
{
    HidP_Output,
    HID_USAGE_PAGE_PID,
    HID_USAGE_PID_DEVICE_GAIN_REPORT,
    cbX(DWORD),
    cA(c_rgUsgGain),
    c_rgUsgGain
};




PIDUSAGE    c_rgUsgOperationReport[] =
{
    MAKE_PIDUSAGE(LOOP_COUNT,               0x0),
};

static PIDREPORT OperationReport =
{
    HidP_Output,
    HID_USAGE_PAGE_PID,
    HID_USAGE_PID_EFFECT_OPERATION_REPORT,
    cbX(DWORD),
    cA(c_rgUsgOperationReport),
    c_rgUsgOperationReport
};


static PIDREPORT DeviceControlReport =
{
    HidP_Output,
    HID_USAGE_PAGE_PID,
    HID_USAGE_PID_DEVICE_CONTROL,
    0x0,
    0x0,
    NULL
};


#pragma END_CONST_DATA

STDMETHODIMP
    PID_EffectOperation
    (
    IDirectInputEffectDriver *ped, 
    DWORD dwId, 
    DWORD dwEffect,
    DWORD dwMode, 
    DWORD dwCount,
	BOOL  bBlocking,
	UINT  blockNr,
	UINT  totalBlocks
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres = S_OK;

    EnterProcI( PID_EffectOperation, (_"xxxxx", ped, dwId, dwEffect, dwMode, dwCount ));

    hres = PID_ValidateEffectIndex(ped, dwEffect);
    // Allocate Memory for the report 
    if( SUCCEEDED(hres) )
    {
        USHORT  cbReport;
        PUCHAR  pReport;

        USHORT LinkCollection;
        AssertF(OperationReport.HidP_Type == HidP_Output);

        cbReport = this->cbReport[OperationReport.HidP_Type];
        pReport = this->pReport[OperationReport.HidP_Type];

        PID_GetLinkCollectionIndex(ped, OperationReport.UsagePage, OperationReport.Collection, 0x0, &LinkCollection );
        // Set the Effect Structure 
        if( SUCCEEDED(hres) )
        {
            ZeroBuf(pReport, cbReport);

            // Set Effect Operation
            if( SUCCEEDED(hres) )
            {
                USAGE   Usage;
                USAGE   UsagePage;
                NTSTATUS  ntStat;
                UINT    nUsages = 0x1;
                USAGE   LinkCollection0;
                PEFFECTSTATE    pEffectState =  PeffectStateFromBlockIndex(this,dwEffect); 

                UsagePage = OperationReport.UsagePage;

                PID_GetLinkCollectionIndex(ped, OperationReport.UsagePage, HID_USAGE_PID_EFFECT_OPERATION, 0x0, &LinkCollection0);

                if( dwMode & DIES_SOLO )
                {
                    Usage = HID_USAGE_PID_OP_EFFECT_START_SOLO;
                    pEffectState->lEfState |= PID_EFFECT_STARTED_SOLO;
                } else if( dwMode & PID_DIES_START )
                {
                    Usage = HID_USAGE_PID_OP_EFFECT_START;
                    pEffectState->lEfState |= PID_EFFECT_STARTED;
                } else if(dwMode & PID_DIES_STOP )
                {
                    Usage = HID_USAGE_PID_OP_EFFECT_STOP;
                    pEffectState->lEfState &= ~(PID_EFFECT_STARTED | PID_EFFECT_STARTED_SOLO);
                } else
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%s: FAIL Could not understand dwMode=0x%x"),
                                    s_tszProc, dwMode ); 

                    hres = E_NOTIMPL;
                }

                ntStat = HidP_SetUsages 
                         (
                         OperationReport.HidP_Type,
                         UsagePage,
                         LinkCollection0,
                         &Usage,
                         &nUsages,
                         this->ppd,
                         pReport,
                         cbReport);

                if( FAILED(hres) )
                {
                    SquirtSqflPtszV(sqfl | sqflBenign,
                                    TEXT("%s: FAIL HidP_SetUsages:0x%x for(%x,%x,%x:%s)"),
                                    s_tszProc, ntStat, 
                                    LinkCollection0, UsagePage, Usage,
                                    PIDUSAGETXT(UsagePage,Usage) );
                } else
                {
                    SquirtSqflPtszV(sqfl | sqflVerbose,
                                    TEXT("%s: HidP_SetUsages:0x%x for(%x,%x,%x:%s)"),
                                    s_tszProc, ntStat, 
                                    LinkCollection0, UsagePage, Usage,
                                    PIDUSAGETXT(UsagePage,Usage) );
                }
            }

            // Set the Loop Count
            if( SUCCEEDED(hres) )
            {
                PID_PackValue
                    (
                    ped,
                    &OperationReport,
                    LinkCollection,
                    &dwCount,
                    cbX(dwCount),
                    pReport,
                    cbReport
                    );

                // Set the Block Index
                PID_PackValue
                    (
                    ped,
                    &g_BlockIndex,
                    LinkCollection,
                    &dwEffect,
                    cbX(dwEffect),
                    pReport,
                    cbReport
                    );
            }

            if( SUCCEEDED(hres) )
            {
				hres = PID_SendReport(ped, pReport, cbReport, OperationReport.HidP_Type, bBlocking, blockNr, totalBlocks); 
            }
        }
    }
    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *      PID_SetGain
 *
 *          Set the overall device gain.
 *
 *  dwId
 *
 *          The joystick ID number being used.
 *
 *  dwGain
 *
 *          The new gain value.
 *
 *          If the value is out of range for the device, the device
 *          should use the nearest supported value and return
 *          DI_TRUNCATED.
 *
 *  Returns:
 *
 *
 *          S_OK if the operation completed successfully.
 *
 *          DI_TRUNCATED if the value was out of range and was
 *          changed to the nearest supported value.
 *
 *          Any DIERR_* error code may be returned.
 *
 *          Private driver-specific error codes in the range
 *          DIERR_DRIVERFIRST through DIERR_DRIVERLAST
 *          may be returned.
 *
 *****************************************************************************/
STDMETHODIMP
    PID_SetGain
    (
    IDirectInputEffectDriver *ped, 
    DWORD dwId, 
    DWORD dwGain
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres = S_OK;

    EnterProc( PID_SetGain, (_"xxx", ped, dwId, dwGain));
    DllEnterCrit();

    // Allocate Memory for the report 
    if( SUCCEEDED(hres) )
    {
        USHORT  cbReport;
        PUCHAR  pReport;

        USHORT LinkCollection;

        AssertF(DeviceGain.HidP_Type == HidP_Output);
        cbReport = this->cbReport[DeviceGain.HidP_Type];
        pReport = this->pReport[DeviceGain.HidP_Type];

        PID_GetLinkCollectionIndex(ped, DeviceGain.UsagePage, DeviceGain.Collection, 0x0, &LinkCollection );
        // Set the Effect Structure 
        if( SUCCEEDED(hres) )
        {
            ZeroBuf(pReport, cbReport);

            // Set the Loop Count
            if( SUCCEEDED(hres) )
            {
                hres = PID_PackValue
                       (
                       ped,
                       &DeviceGain,
                       LinkCollection,
                       &dwGain,
                       cbX(dwGain),
                       pReport,
                       cbReport
                       );
            }

            if( SUCCEEDED(hres) )
            {
                hres = PID_SendReport(ped, pReport, cbReport, DeviceGain.HidP_Type, FALSE, 0, 1); 
            }
        }
    }
    DllLeaveCrit();

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *      PID_SendForceFeedbackCommand
 *
 *          Send a command to the device.
 *
 *  dwId
 *
 *          The external joystick number being addressed.
 *
 *  dwCommand
 *
 *          A DISFFC_* value specifying the command to send.
 *
 *  Returns:
 *
 *          S_OK on success.
 *
 *          Any DIERR_* error code may be returned.
 *
 *          Private driver-specific error codes in the range
 *          DIERR_DRIVERFIRST through DIERR_DRIVERLAST
 *          may be returned.
 *
 *****************************************************************************/
STDMETHODIMP
    PID_SendForceFeedbackCommand
    (
    IDirectInputEffectDriver *ped,
    DWORD dwId, 
    DWORD dwCommand
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres = S_OK;
    USAGE Usages[6];
    PUSAGE pUsages = &Usages[0];
    UINT nUsages;

    EnterProcI( PID_SendForceFeedbackCommand, (_"xxx", ped, dwId, dwCommand));

    DllEnterCrit();

    if( dwCommand & DISFFC_RESET )
    {
        DWORD indx;
        *pUsages++ = HID_USAGE_PID_DC_DEVICE_RESET;
        for(indx = 1 ; 
           (indx <= this->cMaxEffects) && (((PUNITSTATE)(g_pshmem + this->iUnitStateOffset))->cEfDownloaded != 0x0 );
           indx++ )
        {
            PID_DestroyEffect(ped, dwId, indx);
        }
        this->dwState = DIGFFS_STOPPED;
    }
    if( dwCommand & DISFFC_STOPALL )
    {
        *pUsages++ = HID_USAGE_PID_DC_STOP_ALL_EFFECTS;
        this->dwState = DIGFFS_STOPPED;
    }
    if( dwCommand & DISFFC_PAUSE )
    {
        *pUsages++ = HID_USAGE_PID_DC_DEVICE_PAUSE;
    }
    if( dwCommand & DISFFC_CONTINUE )
    {
        *pUsages++ = HID_USAGE_PID_DC_DEVICE_CONTINUE;
    }
    if( dwCommand & DISFFC_SETACTUATORSON)
    {
        *pUsages++ = HID_USAGE_PID_DC_ENABLE_ACTUATORS;
    }
    if(dwCommand & DISFFC_SETACTUATORSOFF)
    {
        *pUsages++ = HID_USAGE_PID_DC_DISABLE_ACTUATORS;
    }

    nUsages = (UINT)(pUsages - &Usages[0]);
    if(nUsages == 0x0 )
    {
        hres = E_NOTIMPL;
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%s: FAIL Do not understand dwCommand(0x%x) "),
                        s_tszProc, dwCommand);
    }

    if( SUCCEEDED(hres) )
    {
        USHORT  cbReport;
        PUCHAR  pReport;
        USHORT  LinkCollection;

        AssertF(DeviceControlReport.HidP_Type == HidP_Output);

        cbReport = this->cbReport[DeviceControlReport.HidP_Type];
        pReport =  this->pReport[DeviceControlReport.HidP_Type];

        PID_GetLinkCollectionIndex(ped, DeviceControlReport.UsagePage, DeviceControlReport.Collection, 0x0, &LinkCollection );
        // Set the Effect Structure 
        if( SUCCEEDED(hres) )
        {
            USHORT  UsagePage;
            NTSTATUS    ntStat;
            ZeroBuf(pReport, cbReport);
            UsagePage = OperationReport.UsagePage;

            ntStat = HidP_SetUsages 
                     (
                     OperationReport.HidP_Type,
                     UsagePage,
                     LinkCollection,
                     &Usages[0],
                     &nUsages,
                     this->ppd,
                     pReport,
                     cbReport);

            if( FAILED(ntStat) )
            {
                SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("%s: FAIL HidP_SetUsages:0x%x for(%x,%x,%x:%s)"),
                                s_tszProc, ntStat, 
                                LinkCollection, UsagePage, Usages[0],
                                PIDUSAGETXT(UsagePage,Usages[0]) );
                hres = ntStat;
            } else
            {
                SquirtSqflPtszV(sqfl | sqflVerbose,
                                TEXT("%s: HidP_SetUsages:0x%x for(%x,%x,%x:%s)"),
                                s_tszProc, ntStat, 
                                LinkCollection,UsagePage, Usages[0],
                                PIDUSAGETXT(UsagePage,Usages[0]) );
            }

            if( SUCCEEDED(hres) )
            {
                hres = PID_SendReport(ped, pReport, cbReport, OperationReport.HidP_Type, TRUE, 0, 1); //we block on this call
            }
        }
    }

    DllLeaveCrit();

    ExitOleProc();
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\pid\pideff.c ===
/*****************************************************************************
 *
 *  PidEff.c
 *  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Download PID Effect Block.
 *
 *****************************************************************************/
#include "pidpr.h"

#define sqfl            ( sqflEff )

#pragma BEGIN_CONST_DATA

/*
 * The structure c_rgUsgEffects, aids in translating elements in the DIEFFECT
 * structure to PID usages 
 */
static PIDUSAGE c_rgUsgEffect[] =
{
    MAKE_PIDUSAGE(DURATION,               FIELD_OFFSET(DIEFFECT,dwDuration)       ),
    MAKE_PIDUSAGE(SAMPLE_PERIOD,          FIELD_OFFSET(DIEFFECT,dwSamplePeriod)   ),
    MAKE_PIDUSAGE(GAIN,                   FIELD_OFFSET(DIEFFECT,dwGain)           ),
    MAKE_PIDUSAGE(TRIGGER_BUTTON,         FIELD_OFFSET(DIEFFECT,dwTriggerButton)  ), 
    MAKE_PIDUSAGE(TRIGGER_REPEAT_INTERVAL,FIELD_OFFSET(DIEFFECT,dwTriggerRepeatInterval) ),
#if DIRECTINPUT_VERSION  >= 0x600
        MAKE_PIDUSAGE(START_DELAY            ,FIELD_OFFSET(DIEFFECT,dwStartDelay)),
#endif
};

/* 
 * g_Effect provides context to the c_rgUsgEffect struct 
 */
PIDREPORT g_Effect =
{
    HidP_Output,                        // Effect Blocks can only be output reports 
    HID_USAGE_PAGE_PID,                 // Usage Page
    HID_USAGE_PID_SET_EFFECT_REPORT,    // Collection 
    cbX(DIEFFECT),                      // Size of incoming data
    cA(c_rgUsgEffect),                  // number of elements in c_rgUsgEffect
    c_rgUsgEffect                       // how elements of DIEFFECT are translated to PID
}; 

/* 
 *  Effect block index to PID usage 
 */
static PIDUSAGE    c_rgUsgBlockIndex[] =
{
    MAKE_PIDUSAGE(EFFECT_BLOCK_INDEX,  0x0 ),
};

/*
 * For some PID transactions block index is output report 
 */
PIDREPORT g_BlockIndex =
{
    HidP_Output,                        // Report Type
    HID_USAGE_PAGE_PID,                 // Usage Page
    0x0,                                // Any collection                            
    cbX(DWORD),                         // size of incoming data
    cA(c_rgUsgBlockIndex),              // translation table for effect block index to PID usages
    c_rgUsgBlockIndex
};

/* 
 * In the PID state report, block index is an input report
 */

PIDREPORT g_BlockIndexIN =
{
    HidP_Input,
    HID_USAGE_PAGE_PID,
    HID_USAGE_PID_STATE_REPORT,                                                            
    cbX(DWORD),
    cA(c_rgUsgBlockIndex),
    c_rgUsgBlockIndex
};



//CAssertF(MAX_ORDINALS == cA(c_rgUsgOrdinals));

PIDREPORT   g_TypeSpBlockOffset =
{
    HidP_Output,                        // For PID ordinals output reports
    HID_USAGE_PAGE_PID,                 // Usage Page
    HID_USAGE_PID_TYPE_SPECIFIC_BLOCK_OFFSET,  
    cA(c_rgUsgOrdinals)*cbX(DWORD),     // sizeof incoming data
    cA(c_rgUsgOrdinals),                // number of elements
    c_rgUsgOrdinals                     // translation table 
};

#pragma END_CONST_DATA

PIDREPORT   g_Direction =
{
    HidP_Output,                        // For PID ordinals output reports
    HID_USAGE_PAGE_PID,                 // Usage Page
    HID_USAGE_PID_DIRECTION,            
    0x0,
    0x0,
    NULL
};


/*****************************************************************************
 *
 *      hresFinddwUsageFromdwFlags
 *
 *      Given the flags for a DEVICEOBJECTINSTANCE, find the usage and usage page
 *      On init we enum the device and cache the 
 *      DeviceObjects marked as actuators and Effect Triggers. 
 *
 *****************************************************************************/
HRESULT
    hresFinddwUsageFromdwFlags
    (
    IDirectInputEffectDriver *ped,
    DWORD dwFlags,
    DWORD *pdwUsage
    )
{
    HRESULT hres = S_OK;
    CPidDrv *this = (CPidDrv *)ped;

    EnterProcI( PID_hresFinddwUsageFromdwFlags, (_"xxx", ped, dwFlags, pdwUsage ));

    // Init FF attributes 
    hres = PID_InitFFAttributes(ped);

    if( SUCCEEDED(hres) )
    {
        /* Better be a FF object ( actuator / Trigger ) */
        if(   dwFlags & DIDFT_FFACTUATOR 
              || dwFlags & DIDFT_FFEFFECTTRIGGER )
        {
            hres = S_OK;
        } else
        {
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%s:FAIL dwFlags(0x%x) not FFACTUATOR | FFEFFECTTRIGGER "),
                            s_tszProc, dwFlags );
            hres = E_UNEXPECTED;
        }

        if( SUCCEEDED(hres) )
        {
            UINT cFFObj;
            hres = E_NOTIMPL;

            /* Loop through the all the objects we found during enum */
            for(cFFObj = 0x0;
               cFFObj < this->cFFObj;
               cFFObj++ )
            {
                PDIUSAGEANDINST pdiUI = this->rgFFUsageInst + cFFObj;

                if( pdiUI->dwType == dwFlags )
                {
                    *pdwUsage = pdiUI->dwUsage;
                    hres = S_OK;
                    break;
                }
            }
        }
    }
    if( FAILED(hres) )
    {
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%s:FAIL No mapping for dwFlags(0x%x)  "),
                        s_tszProc, dwFlags );
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *      PID_NewEffectIndex
 *
 *      Gets a new effect index. 
 *
 *      For host managed devices, we assign an unused effect ID. 
 *      For device managed, we get the effectID from the device 
 *
 *****************************************************************************/
STDMETHODIMP 
    PID_NewEffectIndex
    (
    IDirectInputEffectDriver *ped,
    LPDIEFFECT  peff,
    DWORD       dwEffectId,
    PDWORD      pdwEffect 
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres;
    USHORT dwEffect;

    EnterProcI(PID_NewEffectIndex, (_"xx", this, pdwEffect));

    AssertF(*pdwEffect == 0);

    // Default assumption is that the device is full.
    hres = DIERR_DEVICEFULL; 

    if( this->uDeviceManaged & PID_DEVICEMANAGED )
    {
        PVOID   pReport;
        UINT    cbReport;
        USHORT  LinkCollection = 0x0;
        USHORT  TLinkCollection = 0x0;

        UINT    nUsages = 0x1;
        USAGE   Usage;
        USAGE   Collection = HID_USAGE_PID_CREATE_NEW_EFFECT;
        USAGE   UsagePage; 
        HIDP_REPORT_TYPE  HidP_Type = HidP_Feature;

        cbReport = this->cbReport[HidP_Type];
        pReport = this->pReport[HidP_Type];

        ZeroBuf(pReport, cbReport);

        // Usage and Usage page determine type of new effect
        Usage       = DIGETUSAGE(dwEffectId);
        UsagePage   = DIGETUSAGEPAGE(dwEffectId);  

        hres = PID_GetLinkCollectionIndex(ped, UsagePage, Collection, 0x0, &LinkCollection );
        if( SUCCEEDED(hres) )
        {
            Collection = HID_USAGE_PID_EFFECT_TYPE;
            hres = PID_GetLinkCollectionIndex(ped, UsagePage, Collection, LinkCollection, &TLinkCollection ); 
        }

        if( SUCCEEDED(hres) )
        {

            hres = HidP_SetUsages 
                   (
                   HidP_Type,
                   UsagePage,
                   TLinkCollection,
                   &Usage,
                   &nUsages,
                   this->ppd,
                   pReport,
                   cbReport);

        }

        if( SUCCEEDED(hres) && PIDMAKEUSAGEDWORD(ET_CUSTOM) == dwEffectId )
        {
            DICUSTOMFORCE DiParam;
            LONG lValue;
            int nBytes;

            AssertF(peff->cbTypeSpecificParams <= cbX(DiParam) );
            memcpy(&DiParam, peff->lpvTypeSpecificParams, cbX(DiParam));

            //how many bytes do we need per sample?
            nBytes    =    (   this->customCaps[   0].BitSize    +    this->customCaps[   1].BitSize    +    this->customCaps[   2].BitSize)/8;

            lValue = DiParam.cSamples * nBytes;

            hres = HidP_SetScaledUsageValue 
                   (
                   HidP_Type,
                   HID_USAGE_PAGE_GENERIC,
                   LinkCollection,
                   HID_USAGE_GENERIC_BYTE_COUNT,
                   lValue,
                   this->ppd,
                   pReport,
                   cbReport
                   );

        }

        // Send the report
        if( SUCCEEDED(hres) )
        {
            hres = PID_SendReport(ped, pReport, cbReport, HidP_Type, TRUE, 0, 1); 
        }

        // Get back the effect ID
        if( SUCCEEDED(hres) )
        {
            PIDREPORT   BlockIndex = g_BlockIndex;
            USHORT      LinkCollection;

            BlockIndex.Collection = HID_USAGE_PID_BLOCK_LOAD_REPORT;
            BlockIndex.HidP_Type  = HidP_Feature; 

            hres =  PID_GetLinkCollectionIndex
                    (ped,
                     BlockIndex.UsagePage,
                     BlockIndex.Collection,
                     0x0,
                     &LinkCollection);

            if( SUCCEEDED(hres) )
            {
                PUCHAR pReport =  this->pReport[BlockIndex.HidP_Type];
                UINT   cbReport = this->cbReport[BlockIndex.HidP_Type];
                PID_GetReport(ped, &BlockIndex, LinkCollection, pReport, cbReport );

                // Get the EffectIndex
                hres = PID_ParseReport
                       (
                       ped,
                       &BlockIndex,
                       LinkCollection,
                       pdwEffect,
                       cbX(*pdwEffect),
                       pReport,
                       cbReport
                       );

				
                if( SUCCEEDED(hres ) )
                {
                    NTSTATUS ntStat;
                    USAGE   rgUsageList[MAX_BUTTONS];
                    UINT  cUsageList = MAX_BUTTONS;
                    PID_GetLinkCollectionIndex(ped, HID_USAGE_PAGE_PID, HID_USAGE_PID_BLOCK_LOAD_STATUS, LinkCollection, &LinkCollection );

                    ntStat = HidP_GetUsages
                             (
                             BlockIndex.HidP_Type,
                             HID_USAGE_PAGE_PID, 
                             LinkCollection, 
                             rgUsageList, 
                             &cUsageList,
                             this->ppd,
                             pReport,
                             cbReport);

                    if(SUCCEEDED(ntStat) )
                    {
						if (cUsageList != 0)
						{
							if( rgUsageList[0] == HID_USAGE_PID_BLOCK_LOAD_FULL )
							{
								hres = DIERR_DEVICEFULL;
							} else if(rgUsageList[0] == HID_USAGE_PID_BLOCK_LOAD_ERROR )
							{
								hres = DIERR_PID_BLOCKLOADERROR;
							} else
							{
								AssertF(rgUsageList[0] == HID_USAGE_PID_BLOCK_LOAD_SUCCESS);
							}
						}
						else
						{
							//because of issues w/ some chipsets (see Whistler bugs 231235, 304863),
							//cUsageList can be 0.
							//so warn the user.
							RPF(TEXT("Unable to get the effect load status -- may be a USB chipset issue!"));
							RPF(TEXT("The effect may not play correctly!"));
						}
                    }
                }

                if(SUCCEEDED(hres))
                {
                    NTSTATUS ntStat;
                    UsagePage = HID_USAGE_PAGE_PID;
                    Usage = HID_USAGE_PID_RAMPOOL_AVAILABLE;

                    ntStat = HidP_GetScaledUsageValue 
                             (
                             HidP_Feature,
                             UsagePage,
                             LinkCollection,
                             Usage,
                             &this->dwUsedMem,
                             this->ppd,
                             pReport,
                             cbReport
                             );

                    if(FAILED(ntStat) )
                    {
                        // Reset the amount of used memory
                        this->dwUsedMem = 0x0 ;

                        SquirtSqflPtszV(sqfl | sqflError,
                                        TEXT("%s: FAIL HidP_GetScaledUsageValue:0x%x for(%x, %x,%x:%s)"),
                                        s_tszProc, ntStat, 
                                        LinkCollection, UsagePage, Usage, 
                                        PIDUSAGETXT(UsagePage,Usage) );
                    }
                }

            }
        }

	 if( SUCCEEDED(hres) )
        {

            PEFFECTSTATE    pEffectState =  PeffectStateFromBlockIndex(this,*pdwEffect);    
            // Serialize access to for new effect
            WaitForSingleObject(g_hmtxShared, INFINITE);

            AssertF(! (pEffectState->lEfState & PID_EFFECT_BUSY ));

            pEffectState->lEfState |= PID_EFFECT_BUSY;    
            hres = S_OK;

            ReleaseMutex(g_hmtxShared);

        }
    } else
    {
        // Serialize access to common memory block
        WaitForSingleObject(g_hmtxShared, INFINITE);

        for(dwEffect = 1; 
           dwEffect <= this->cMaxEffects; 
           dwEffect++)
        {
            PEFFECTSTATE    pEffectState =  PeffectStateFromBlockIndex(this,dwEffect);    
            if( ! ( pEffectState->lEfState & PID_EFFECT_BUSY ) )
            {
                pEffectState->lEfState |= PID_EFFECT_BUSY;    
                *pdwEffect =  dwEffect;

                ZeroBuf(pEffectState->PidMem, cbX(pEffectState->PidMem[0]) * this->cMaxParameters );
                hres = S_OK;
                break;
            }
        }
        ReleaseMutex(g_hmtxShared);
    }

    if( SUCCEEDED(hres) )
    {
        ((PUNITSTATE)(g_pshmem + this->iUnitStateOffset))->cEfDownloaded++;
    } else
    {
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%s:FAIL Could not create new effects, already have %d "),
                        s_tszProc, ((PUNITSTATE)(g_pshmem + this->iUnitStateOffset))->cEfDownloaded );
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *      PID_ValidateEffectIndex
 *
 *      Validates an effect index. 
 *
 *****************************************************************************/
STDMETHODIMP  PID_ValidateEffectIndex
    (
    IDirectInputEffectDriver *ped,
    DWORD   dwEffect 
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres;
    PEFFECTSTATE    pEffectState =  PeffectStateFromBlockIndex(this, dwEffect);    

    EnterProc(PID_ValidateEffectIndex, (_"xx", this, dwEffect));

    if( pEffectState->lEfState & PID_EFFECT_BUSY )
    {
        hres = S_OK;
    } else
    {
        hres = E_HANDLE;
    }


    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *      PID_DestroyEffect
 *
 *          Remove an effect from the device.
 *
 *          If the effect is playing, the driver should stop it
 *          before unloading it.
 *
 *  dwId
 *
 *          The external joystick number being addressed.
 *
 *  dwEffect
 *
 *          The effect to be destroyed.
 *
 *  Returns:
 *
 *          S_OK on success.
 *
 *          Any other DIERR_* error code may be returned.
 *
 *          Private driver-specific error codes in the range
 *          DIERR_DRIVERFIRST through DIERR_DRIVERLAST
 *          may be returned.
 *
 *
 *      Makes an effect Index available for reuse. Deallocates parameter block
 *      memory. 
 *
 *****************************************************************************/
STDMETHODIMP 
    PID_DestroyEffect
    (
    IDirectInputEffectDriver *ped,
    DWORD   dwId,
    DWORD   dwEffect 
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres=S_OK;

    EnterProc(PID_DestroyEffectIndex, (_"xx", this, dwEffect));

    DllEnterCrit();

    // Stop the Effect 
    hres = PID_EffectOperation
           (
           ped, 
           dwId, 
           dwEffect,
           PID_DIES_STOP, 
           0x0,
		   TRUE,
		   0,
		   1
           );


    if(SUCCEEDED(hres) && 
       ( this->uDeviceManaged & PID_DEVICEMANAGED ) )
    {
        // Device Managed memory needs to be freed explicitly. 

        USHORT  cbReport;
        PUCHAR  pReport;
        PIDREPORT   BlockIndex = g_BlockIndex;
        USHORT      LinkCollection;

        cbReport = this->cbReport[BlockIndex.HidP_Type];
        pReport = this->pReport[BlockIndex.HidP_Type];

        ZeroBuf(pReport, cbReport);

        BlockIndex.Collection = HID_USAGE_PID_BLOCK_FREE_REPORT;
        BlockIndex.HidP_Type  = HidP_Output; 

        PID_GetLinkCollectionIndex
            (ped,
             BlockIndex.UsagePage,
             BlockIndex.Collection,
             0x0,
             &LinkCollection);

        hres = PID_PackValue
               (
               ped,
               &BlockIndex,
               LinkCollection,
               &dwEffect,
               cbX(dwEffect),
               pReport,
               cbReport
               );
        if(SUCCEEDED(hres) )
        {
            hres = PID_SendReport(ped, pReport, cbReport, BlockIndex.HidP_Type, TRUE, 0, 1); 
        }
    }

    if( SUCCEEDED(hres) )
    {
        PEFFECTSTATE    pEffectState =  PeffectStateFromBlockIndex(this,dwEffect);    
        UINT    nAlloc, uParam;

        WaitForSingleObject(g_hmtxShared, INFINITE);

        pEffectState->lEfState = PID_EFFECT_RESET;

        for( uParam = 0x0; uParam < this->cMaxParameters; uParam++ )
        {
            PPIDMEM         pMem = &pEffectState->PidMem[uParam] ;

            if( PIDMEM_SIZE(pMem) )
            {
                PPIDMEM pTmp;
				PUNITSTATE pUnitState = (PUNITSTATE)(g_pshmem + this->iUnitStateOffset);

                for(nAlloc = 0x0, pTmp = &(pUnitState->Guard[0]); 
                   nAlloc < pUnitState->nAlloc; 
                   nAlloc++, pTmp = (PPIDMEM)((PUCHAR)pUnitState + pTmp->iNext))
                {
                    if( (PPIDMEM)(pTmp->iNext) == (PPIDMEM)((PUCHAR)pMem - (PUCHAR)pUnitState ))
                    {
                        pTmp->iNext = pMem->iNext;
                        pUnitState->nAlloc--;
                        pUnitState->cbAlloc -= PIDMEM_SIZE(pMem);
                        pMem->iNext = 0;
                        pMem->uOfSz = 0x0;
                        break;
                    }

                }
            }
        }
        ReleaseMutex(g_hmtxShared);
    }

    if( SUCCEEDED(hres) )
    {
        ((PUNITSTATE)(g_pshmem + this->iUnitStateOffset))->cEfDownloaded--;
    }

    DllLeaveCrit();

    ExitOleProc(); 
    return hres;
}


/*****************************************************************************
 *
 *      PID_SanitizeEffect
 *
 *      Sanitize the parameters in the DIEFFECT structure. 
 *      Clip values of magnitude, time, etc .. 
 *      Convert the axes array to usage, usage page from the DINPUT obj instances.
 *      Convert and scale angles. 
 *
 *****************************************************************************/
HRESULT PID_SanitizeEffect
    (
    IDirectInputEffectDriver *ped,
    LPDIEFFECT lpeff,
    DWORD      dwFlags
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres = S_OK;
    UINT nAxis;
    EnterProc( PID_SanitizeEffect, (_"xxx", ped, lpeff, dwFlags));

    if(   ( dwFlags & DIEP_TRIGGERBUTTON )
          && lpeff->dwTriggerButton != -1 )
    {
        DWORD   dwUsage;
        hres = hresFinddwUsageFromdwFlags(ped, lpeff->dwTriggerButton, &dwUsage);
        if( SUCCEEDED(hres) )
        {
            USAGE Usage = DIGETUSAGE(dwUsage);
            USAGE UsagePage = DIGETUSAGEPAGE(dwUsage);  
            lpeff->dwTriggerButton = Usage;
        } else
        {
            lpeff->dwTriggerButton = 0x0;
        }
    } else
    {
        lpeff->dwTriggerButton = 0x0;
    }


    for(nAxis = 0x0; 
       nAxis < lpeff->cAxes; 
       nAxis++ )
    {
        DWORD   dwUsage;
        hres = hresFinddwUsageFromdwFlags(ped, lpeff->rgdwAxes[nAxis], &dwUsage);
        if(SUCCEEDED(hres) )
        {
            lpeff->rgdwAxes[nAxis] = dwUsage;
        }

		//if we have only 1 axis and direction of 0 or 360, make sure the direction matches the axis!
		//if direction is not 0, we do not know what the app wants, so let it be.
		if ((lpeff->cAxes == 1) && (lpeff->rglDirection[nAxis] % 360*DI_DEGREES == 0))
		{
#ifndef HID_USAGE_SIMULATION_STEERING
#define	HID_USAGE_SIMULATION_STEERING       ((USAGE) 0xC8)
#endif
#ifndef HID_USAGE_SIMULATION_ACCELERATOR 
#define	HID_USAGE_SIMULATION_ACCELERATOR    ((USAGE) 0xC4)
#endif
#ifndef HID_USAGE_SIMULATION_BRAKE
#define	HID_USAGE_SIMULATION_BRAKE          ((USAGE) 0xC5)
#endif
			//if it is X-axis or steering on the wheel, set direction to 90 degrees
			if ((DIGETUSAGE(lpeff->rgdwAxes[nAxis]) == HID_USAGE_GENERIC_X) || (DIGETUSAGE(lpeff->rgdwAxes[nAxis]) == HID_USAGE_SIMULATION_STEERING))
			{
				lpeff->rglDirection[nAxis] = 90*DI_DEGREES;
			}
			//if it is Y-axis or accelerator or brake, set direction to 0
			else if ((DIGETUSAGE(lpeff->rgdwAxes[nAxis]) == HID_USAGE_GENERIC_Y) || (DIGETUSAGE(lpeff->rgdwAxes[nAxis]) == HID_USAGE_SIMULATION_ACCELERATOR) ||
				(DIGETUSAGE(lpeff->rgdwAxes[nAxis]) == HID_USAGE_SIMULATION_BRAKE))
			{
				lpeff->rglDirection[nAxis] = 0x0;
			}
		}
		else
		//we have more than 1 axes or direction is non-0 for 1-axis effect; leave the direction along
		{
			lpeff->rglDirection[nAxis] %= 360*DI_DEGREES;
			if(lpeff->rglDirection[nAxis] < 0)
			{
				lpeff->rglDirection[nAxis] += 360*DI_DEGREES;
			}
		}
    }

	
    // Clip the values to min / max

    lpeff->dwGain   = Clip(lpeff->dwGain,  DI_FFNOMINALMAX);

    // Scale to units that device expects
    PID_ApplyScalingFactors(ped, &g_Effect, &this->DiSEffectScale, this->DiSEffectScale.dwSize, &this->DiSEffectOffset, this->DiSEffectOffset.dwSize, lpeff, lpeff->dwSize );

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *      CPidDrv_DownloadEffect
 *
 *          Send an effect to the device.
 *
 *  dwId
 *
 *          The external joystick number being addressed.
 *
 *  dwEffectId
 *
 *          Internal identifier for the effect, taken from
 *          the DIEFFECTATTRIBUTES structure for the effect
 *          as stored in the registry.
 *
 *  pdwEffect
 *
 *          On entry, contains the handle of the effect being
 *          downloaded.  If the value is zero, then a new effect
 *          is downloaded.  If the value is nonzero, then an
 *          existing effect is modified.
 *
 *          On exit, contains the new effect handle.
 *
 *          On failure, set to zero if the effect is lost,
 *          or left alone if the effect is still valid with
 *          its old parameters.
 *
 *          Note that zero is never a valid effect handle.
 *
 *  peff
 *
 *          The new parameters for the effect.  The axis and button
 *          values have been converted to object identifiers
 *          as follows:
 *
 *          - One type specifier:
 *
 *              DIDFT_RELAXIS,
 *              DIDFT_ABSAXIS,
 *              DIDFT_PSHBUTTON,
 *              DIDFT_TGLBUTTON,
 *              DIDFT_POV.
 *
 *          - One instance specifier:
 *
 *              DIDFT_MAKEINSTANCE(n).
 *
 *          Other bits are reserved and should be ignored.
 *
 *          For example, the value 0x0200104 corresponds to
 *          the type specifier DIDFT_PSHBUTTON and
 *          the instance specifier DIDFT_MAKEINSTANCE(1),
 *          which together indicate that the effect should
 *          be associated with button 1.  Axes, buttons, and POVs
 *          are each numbered starting from zero.
 *
 *  dwFlags
 *
 *          Zero or more DIEP_* flags specifying which
 *          portions of the effect information has changed from
 *          the effect already on the device.
 *
 *          This information is passed to drivers to allow for
 *          optimization of effect modification.  If an effect
 *          is being modified, a driver may be able to update
 *          the effect in situ and transmit to the device
 *          only the information that has changed.
 *
 *          Drivers are not, however, required to implement this
 *          optimization.  All fields in the DIEFFECT structure
 *          pointed to by the peff parameter are valid, and
 *          a driver may choose simply to update all parameters of
 *          the effect at each download.
 *
 *  Returns:
 *
 *          S_OK on success.
 *
 *          DI_TRUNCATED if the parameters of the effect were
 *          successfully downloaded, but some of them were
 *          beyond the capabilities of the device and were truncated.
 *
 *          DI_EFFECTRESTARTED if the parameters of the effect
 *          were successfully downloaded, but in order to change
 *          the parameters, the effect needed to be restarted.
 *
 *          DI_TRUNCATEDANDRESTARTED if both DI_TRUNCATED and
 *          DI_EFFECTRESTARTED apply.
 *
 *          Any other DIERR_* error code may be returned.
 *
 *          Private driver-specific error codes in the range
 *          DIERR_DRIVERFIRST through DIERR_DRIVERLAST
 *          may be returned.
 *
 *****************************************************************************/

STDMETHODIMP
    PID_DownloadEffect
    (
    IDirectInputEffectDriver *ped,
    DWORD dwId, 
    DWORD dwEffectId,
    LPDWORD pdwEffect, 
    LPCDIEFFECT peff, 
    DWORD dwFlags
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres = S_OK;
    DIEFFECT    eff;
    DWORD       rgdwAxes[MAX_AXES];
    LONG        rglDirection[MAX_AXES];
	UINT        uParameter = 0x0 ;
	UINT		totalBlocks = 0x0;
	BOOL		bBlocking = FALSE;

    EnterProcI( PID_DownloadEffectBlock, (_"xxxxxx", ped, dwId, dwEffectId, pdwEffect, peff, dwFlags));

    AssertF(peff->cAxes <= MAX_AXES);

    DllEnterCrit();

    // If new effect is being downloaded  
    if( *pdwEffect == 0x0 )
    {
        // Verify that dwEffectId is supported
        DWORD dwJunk;
        PIDSUPPORT  pidSupport;
        pidSupport.dwPidUsage = dwEffectId;
        pidSupport.HidP_Type = HidP_Output;
        pidSupport.Type      = HID_BUTTON;

        hres = PID_Support
               (
               ped,
               0x1,
               &pidSupport,
               &dwJunk
               );

        if(FAILED(hres))
        {
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%s:FAIL dwEffectId(0x%x) not supported"),
                            s_tszProc, dwEffectId );
        }
    }


    if( SUCCEEDED(hres) )
    {
        // Make a local copy of the effect structure
        // And sanitize the effect struct
        eff = *peff;
        memcpy(rgdwAxes, peff->rgdwAxes,eff.cAxes*cbX(*(eff.rgdwAxes)));
        memcpy(rglDirection, peff->rglDirection, eff.cAxes*cbX(*(eff.rglDirection)));
        eff.rgdwAxes = rgdwAxes;
        eff.rglDirection = rglDirection;
        hres = PID_SanitizeEffect(ped, &eff, dwFlags);
    }

    // Allocate new effect index or Validate Existing index 
    if( SUCCEEDED(hres) )
    {
        if( *pdwEffect != 0x0 )
        {
             hres = PID_ValidateEffectIndex(ped, *pdwEffect);
        }
        else
        {
             if (! (dwFlags & DIEP_NODOWNLOAD))
             {
                  hres = PID_NewEffectIndex(ped, &eff, dwEffectId, pdwEffect);
				  //block the first time around
				  bBlocking = TRUE;
             }
        }
    }

    if (dwFlags & DIEP_NODOWNLOAD)
    {
        goto done;
    }

	//if the DIEP_NORESTART flag is passed, we have no block because this may fail
	//if the device can't update the parameters on the fly
	if (dwFlags & DIEP_NORESTART)
	{
		bBlocking = TRUE;
	}

    if( SUCCEEDED(hres) )
    {
		//count up how many total blocks we will have in this download
		//check wether we're sending the effect block
		if (dwFlags & ( DIEP_DURATION | DIEP_SAMPLEPERIOD | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL | DIEP_AXES | DIEP_DIRECTION | DIEP_STARTDELAY ) )
		{
			totalBlocks ++;
		}
		//check whether we're sending the type-specific params
		if (dwFlags & DIEP_TYPESPECIFICPARAMS)
		{
			//this is slightly different, in that conditions can have 1 type-specific block PER AXIS,
			//i.e. currently up to 2
			//so if we have a DICONDITION, we check how many type-specific blocks we've got
			if ((dwEffectId == PIDMAKEUSAGEDWORD(ET_SPRING)) ||
						(dwEffectId == PIDMAKEUSAGEDWORD(ET_DAMPER)) ||
						(dwEffectId == PIDMAKEUSAGEDWORD(ET_INERTIA)) ||
						(dwEffectId == PIDMAKEUSAGEDWORD(ET_FRICTION)))
			{
				totalBlocks +=(eff.cbTypeSpecificParams)/sizeof(DICONDITION);
				//DICONDITIONS also can't have envelopes
				dwFlags &= ~DIEP_ENVELOPE;
			}
			else
			{
				totalBlocks++;
			}
		}
		//check whether we're sending the envelope
		if ((dwFlags & DIEP_ENVELOPE) && (eff.lpEnvelope != NULL))
		{
			totalBlocks++;
		}
		//check whether we need to send the start reprot
		if (dwFlags & DIEP_START)
		{
			totalBlocks++;
		}
		//make sure that we haven't got more than the maximum
		AssertF(totalBlocks <= MAX_BLOCKS);

        // Do the parameter block
        if(     SUCCEEDED(hres) 
                &&  ( dwFlags & ( DIEP_TYPESPECIFICPARAMS | DIEP_ENVELOPE)  )
          )
        {
            hres =  PID_DoParameterBlocks
                    (
                    ped,
                    dwId, 
                    dwEffectId,
                    *pdwEffect, 
                    &eff, 
                    dwFlags,
                    &uParameter,
					bBlocking,
					totalBlocks
                    );
        }

        // Now do the effect report 
        if( SUCCEEDED(hres) 
            && ( dwFlags & ( DIEP_DURATION | DIEP_SAMPLEPERIOD | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL | DIEP_AXES | DIEP_DIRECTION | DIEP_STARTDELAY ) ) )
        {
            USHORT  cbReport;
            PUCHAR  pReport;

            AssertF(g_Effect.HidP_Type == HidP_Output);
            cbReport = this->cbReport[g_Effect.HidP_Type];
            pReport = this->pReport[g_Effect.HidP_Type];

            // Set the Effect Structure 
            if( SUCCEEDED(hres) )
            {
                USHORT  LinkCollection;
                PID_GetLinkCollectionIndex(ped, g_Effect.UsagePage, g_Effect.Collection, 0x0, &LinkCollection );

                ZeroBuf(pReport, cbReport);

                // Do the common elements of the effect structure
                hres = PID_PackValue
                       (
                       ped,
                       &g_Effect,
                       LinkCollection,
                       &eff,
                       eff.dwSize,
                       pReport,
                       cbReport
                       );


                // Set the Effect Block Index
                if( SUCCEEDED(hres) )
                {
                    hres = PID_PackValue
                           (
                           ped,
                           &g_BlockIndex,
                           LinkCollection,
                           pdwEffect,
                           cbX(*pdwEffect),
                           pReport,
                           cbReport
                           );
                }

                // Set Direction and axis attributes
                if( SUCCEEDED(hres) )
                {
                    USHORT  DirectionCollection;

                    PID_GetLinkCollectionIndex(ped, g_Direction.UsagePage, g_Direction.Collection, 0x0, &DirectionCollection );
                    PID_ApplyScalingFactors(ped, &g_Direction, &this->DiSEffectAngleScale, cbX(this->DiSEffectAngleScale), &this->DiSEffectAngleOffset, cbX(this->DiSEffectAngleOffset), eff.rglDirection, eff.cAxes*cbX(LONG) );

                    hres = PID_PackValue
                           (
                           ped,
                           &g_Direction,
                           DirectionCollection,
                           eff.rglDirection,
                           eff.cAxes * cbX(LONG),
                           pReport,
                           cbReport
                           );


                    if(SUCCEEDED(hres) && 
                      ! ( eff.dwFlags & DIEFF_CARTESIAN ) )
                    {
                        // Direction Enable
                        USHORT  Usage;
                        USHORT  UsagePage;
                        UINT    nUsages = 0x1;
                        NTSTATUS  ntStat;

                        // Direction Enable is in the set effect collection
                        UsagePage = g_Effect.UsagePage;
                        Usage = HID_USAGE_PID_DIRECTION_ENABLE;

                        ntStat = HidP_SetUsages 
                                 (
                                 HidP_Output,
                                 UsagePage,
                                 LinkCollection,
                                 &Usage,
                                 &nUsages,
                                 this->ppd,
                                 pReport,
                                 cbReport);


                        if( FAILED(ntStat) )
                        {
                            SquirtSqflPtszV(sqfl | sqflError,
                                            TEXT("%s: FAIL HidP_SetUsages:0x%x for(%x,%x,%x:%s)"),
                                            s_tszProc, ntStat, 
                                            LinkCollection, UsagePage, Usage,
                                            PIDUSAGETXT(UsagePage,Usage) );

                        } else
                        {
                            SquirtSqflPtszV(sqfl | sqflVerbose,
                                            TEXT("%s: HidP_SetUsages:0x%x for(%x,%x,%x:%s)"),
                                            s_tszProc, ntStat, 
                                            LinkCollection,UsagePage, Usage,
                                            PIDUSAGETXT(UsagePage,Usage) );
                        }



                    } else  //if(  dwFlags  & DIEP_AXES )
                    {
                        UINT    nAxis;
                        USHORT  LinkCollection_AE=0x0;

                        if(SUCCEEDED(PID_GetLinkCollectionIndex(ped, HID_USAGE_PAGE_PID, HID_USAGE_PID_AXES_ENABLE, 0x0, &LinkCollection_AE)))
                        {
                            // ISSUE-2001/03/29-timgill Need to support axes within pointer collections
                            // PID spec indicates a pointer collection, 
                            // Do we want to support axes enables within a pointer 
                            // collection ? 

                            // See if there is a pointer collection 

                        }

                        for(nAxis = 0x0; 
                           nAxis < eff.cAxes; 
                           nAxis++ )
                        {
                            UINT    nUsages = 0x1;
                            USHORT  Usage = DIGETUSAGE(eff.rgdwAxes[nAxis]);
                            USHORT  UsagePage = DIGETUSAGEPAGE(eff.rgdwAxes[nAxis]);
                            NTSTATUS ntStat;

                            //ISSUE-2001/03/29-timgill For now we assume any collection
                            ntStat = HidP_SetUsages 
                                     (
                                     HidP_Output,
                                     UsagePage,
                                     0x0,       
                                     &Usage,
                                     &nUsages,
                                     this->ppd,
                                     pReport,
                                     cbReport);

                            if( FAILED(ntStat) )
                            {
                                SquirtSqflPtszV(sqfl | sqflError,
                                                TEXT("%s: FAIL HidP_SetUsages:0x%x for(%x,%x,%x:%s)"),
                                                s_tszProc, ntStat, 
                                                0x0, UsagePage, Usage,
                                                PIDUSAGETXT(UsagePage,Usage) );
                                hres = ntStat;
                                break;
                            } else
                            {
                                SquirtSqflPtszV(sqfl | sqflVerbose,
                                                TEXT("%s: HidP_SetUsages:0x%x for(%x,%x,%x:%s)"),
                                                s_tszProc, ntStat, 
                                                0x0, UsagePage, Usage,
                                                PIDUSAGETXT(UsagePage, Usage) );
                            }
                        }
                    }
                }
                if(  SUCCEEDED(hres) 
                     && !( this->uDeviceManaged & PID_DEVICEMANAGED ) 
                  )
                {
                    // Need parameter block offsets
                    UINT indx;
                    USHORT LinkCollection;
                    LONG rglValue[MAX_ORDINALS];

                    PID_GetLinkCollectionIndex(ped,  g_Effect.UsagePage, g_TypeSpBlockOffset.Collection, 0x0, &LinkCollection );

                    for(indx = 0x0; indx < this->cMaxParameters; indx++ )
                    {
                        hres = PID_GetParameterOffset(ped, *pdwEffect, indx, 0x0, &rglValue[indx]); 
                        if(FAILED(hres))
                        {
                            break;
                        }
                    }
                    if(SUCCEEDED(hres))
                    {
                        hres = PID_PackValue
                               (
                               ped,
                               &g_TypeSpBlockOffset,
                               LinkCollection,
                               rglValue,
                               this->cMaxParameters*cbX(LONG),
                               pReport,
                               cbReport
                               );
                    }
                }

                // Set the Effect Type
                if( SUCCEEDED(hres) )
                {
                    USAGE   UsagePage = DIGETUSAGEPAGE(dwEffectId);
                    USAGE   Usage     = DIGETUSAGE(dwEffectId);

                    UINT    nUsages = 0x1;
                    USHORT  LinkCollection_ET;
                    NTSTATUS  ntStat;

                    PID_GetLinkCollectionIndex(ped, g_Effect.UsagePage, HID_USAGE_PID_EFFECT_TYPE, 0x0, &LinkCollection_ET);

                    ntStat = HidP_SetUsages 
                             (
                             HidP_Output,
                             UsagePage,
                             LinkCollection_ET,
                             &Usage,
                             &nUsages,
                             this->ppd,
                             pReport,
                             cbReport);
                    if( FAILED(ntStat) )
                    {
                        SquirtSqflPtszV(sqfl | sqflError,
                                        TEXT("%s: FAIL HidP_SetUsages:0x%x for(%x,%x,%x:%s)"),
                                        s_tszProc, ntStat, 
                                        LinkCollection_ET, UsagePage, Usage,
                                        PIDUSAGETXT(UsagePage,Usage) );
                        hres = ntStat;

                    } else
                    {
                        SquirtSqflPtszV(sqfl | sqflVerbose,
                                        TEXT("%s: HidP_SetUsages:0x%x for(%x,%x,%x:%s)"),
                                        s_tszProc, ntStat, 
                                        LinkCollection_ET, UsagePage, Usage,
                                        PIDUSAGETXT(UsagePage,Usage) );
                    }
                }


                if( SUCCEEDED(hres) )
                {
                    hres = PID_SendReport(ped, pReport, cbReport, g_Effect.HidP_Type, bBlocking, uParameter, totalBlocks);
					uParameter ++;
                }
            }
        }
    }

    if( FAILED(hres) )
    {
        PID_DestroyEffect(ped, dwId, *pdwEffect);
    }

    if(   SUCCEEDED(hres)
          && (dwFlags & DIEP_START) )
    {
        hres = PID_EffectOperation
               (
               ped, 
               dwId, 
               *pdwEffect,
               PID_DIES_START, 
               0x1,
			   bBlocking,
			   uParameter,
			   totalBlocks
               );

		if (SUCCEEDED(hres))
		{

			//set the status to DIEGES_PLAYING.
			//we do this because of the following: if an app calls Start(), and then immediately
			//calls GetEffectStatus(), it might happen that our second thread (pidrd.c) 
			//would not have time to update the status of the effect to DIEGES_PLAYING
			//(see Whistler bug 287035).
			//GetEffectStatus() returns (pEffectState->lEfState & DIEGES_PLAYING).
			//in the blocking case, we know that the call to WriteFile() has succeeded, and that
			//all the data has been written (see PID_SendReportBl() in pidhid.c) --
			//so we might as well set the status.
			//in the non-blocking case, the data can be buffered anyway -- so we might as well set the status.
			PEFFECTSTATE    pEffectState =  PeffectStateFromBlockIndex(this, *pdwEffect); 
			pEffectState->lEfState |= DIEGES_PLAYING;
		}
			   
    }

done:;

    DllLeaveCrit();

    ExitOleProc();
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\pid\pidparam.c ===
/*****************************************************************************
 *
 *  PidParam.c
 *
 *  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Download PID parameter block(s) .
 *
 *****************************************************************************/
#include "pidpr.h"

#define sqfl            ( sqflParam )

//struct to keep in relevant data for g_Custom
typedef struct PIDCUSTOM
{
	DWORD DataOffset;
	DWORD cSamples;
	DWORD dwSamplePeriod;
} PIDCUSTOM, *PPIDCUSTOM;


#pragma BEGIN_CONST_DATA

static PIDUSAGE  c_rgUsgEnvelope[] =
{
    MAKE_PIDUSAGE(ATTACK_LEVEL,           FIELD_OFFSET(DIENVELOPE,dwAttackLevel)  ),
    MAKE_PIDUSAGE(ATTACK_TIME,            FIELD_OFFSET(DIENVELOPE,dwAttackTime)   ),
    MAKE_PIDUSAGE(FADE_LEVEL,             FIELD_OFFSET(DIENVELOPE,dwFadeLevel)    ),
    MAKE_PIDUSAGE(FADE_TIME,              FIELD_OFFSET(DIENVELOPE,dwFadeTime)     ),
};

PIDREPORT g_Envelope =
{
    HidP_Output,
    HID_USAGE_PAGE_PID,
    HID_USAGE_PID_SET_ENVELOPE_REPORT,
    cbX(DIENVELOPE),
    cA(c_rgUsgEnvelope),
    c_rgUsgEnvelope
};

static PIDUSAGE    c_rgUsgCondition[] =
{
    MAKE_PIDUSAGE(CP_OFFSET,              FIELD_OFFSET(DICONDITION, lOffset)      ),
    MAKE_PIDUSAGE(POSITIVE_COEFFICIENT,   FIELD_OFFSET(DICONDITION, lPositiveCoefficient)),
    MAKE_PIDUSAGE(NEGATIVE_COEFFICIENT,   FIELD_OFFSET(DICONDITION, lNegativeCoefficient)),
    MAKE_PIDUSAGE(POSITIVE_SATURATION,    FIELD_OFFSET(DICONDITION, dwPositiveSaturation)),
    MAKE_PIDUSAGE(NEGATIVE_SATURATION,    FIELD_OFFSET(DICONDITION, dwNegativeSaturation)),
    MAKE_PIDUSAGE(DEAD_BAND,              FIELD_OFFSET(DICONDITION, lDeadBand)),
};

PIDREPORT g_Condition =
{
    HidP_Output,
    HID_USAGE_PAGE_PID,
    HID_USAGE_PID_SET_CONDITION_REPORT,
    cbX(DICONDITION),
    cA(c_rgUsgCondition),
    c_rgUsgCondition
};

static PIDUSAGE    c_rgUsgPeriodic[] =
{
    MAKE_PIDUSAGE(OFFSET,                 FIELD_OFFSET(DIPERIODIC,lOffset)),
    MAKE_PIDUSAGE(MAGNITUDE,              FIELD_OFFSET(DIPERIODIC,dwMagnitude)),
    MAKE_PIDUSAGE(PHASE,                  FIELD_OFFSET(DIPERIODIC,dwPhase)),
    MAKE_PIDUSAGE(PERIOD,                 FIELD_OFFSET(DIPERIODIC,dwPeriod)),
};

PIDREPORT g_Periodic =
{
    HidP_Output,
    HID_USAGE_PAGE_PID,
    HID_USAGE_PID_SET_PERIODIC_REPORT,
    cbX(DIPERIODIC),
    cA(c_rgUsgPeriodic),
    c_rgUsgPeriodic
};

static PIDUSAGE    c_rgUsgConstant[] =
{
    MAKE_PIDUSAGE(MAGNITUDE,              FIELD_OFFSET(DICONSTANTFORCE, lMagnitude)),
};

PIDREPORT g_Constant =
{
    HidP_Output,
    HID_USAGE_PAGE_PID,
    HID_USAGE_PID_SET_CONSTANT_FORCE_REPORT,
    cbX(DICONSTANTFORCE),
    cA(c_rgUsgConstant),
    c_rgUsgConstant
};


static PIDUSAGE    c_rgUsgRamp[] =
{
    MAKE_PIDUSAGE(RAMP_START,             FIELD_OFFSET(DIRAMPFORCE, lStart)),
    MAKE_PIDUSAGE(RAMP_END,               FIELD_OFFSET(DIRAMPFORCE, lEnd)),
};

PIDREPORT g_Ramp =
{
    HidP_Output,
    HID_USAGE_PAGE_PID,
    HID_USAGE_PID_SET_RAMP_FORCE_REPORT,
    cbX(DIRAMPFORCE),
    cA(c_rgUsgRamp),
    c_rgUsgRamp
};

static PIDUSAGE c_rgUsgCustom[]=
{
	MAKE_PIDUSAGE(CUSTOM_FORCE_DATA_OFFSET, FIELD_OFFSET(PIDCUSTOM, DataOffset)),
	MAKE_PIDUSAGE(SAMPLE_COUNT,				FIELD_OFFSET(PIDCUSTOM, cSamples)),
	MAKE_PIDUSAGE(SAMPLE_PERIOD,			FIELD_OFFSET(PIDCUSTOM, dwSamplePeriod)),
};

PIDREPORT g_Custom =
{
    HidP_Output,
    HID_USAGE_PAGE_PID,
    HID_USAGE_PID_SET_CUSTOM_FORCE_REPORT,
    cbX(PIDCUSTOM),
    cA(c_rgUsgCustom),
    c_rgUsgCustom,
};   


static PIDUSAGE c_rgUsgCustomData[]=
{
	MAKE_PIDUSAGE(CUSTOM_FORCE_DATA_OFFSET, 0x0),
	MAKE_HIDUSAGE(GENERIC, HID_USAGE_GENERIC_BYTE_COUNT, 0x0),
    MAKE_PIDUSAGE(CUSTOM_FORCE_DATA, 0x0 ),

};

PIDREPORT g_CustomData =
{
    HidP_Output,
    HID_USAGE_PAGE_PID,
    HID_USAGE_PID_CUSTOM_FORCE_DATA_REPORT,
    cbX(DWORD),
    cA(c_rgUsgCustomData),
    c_rgUsgCustomData,
};   

static PIDUSAGE c_rgUsgDirectionAxes[]=
{
    MAKE_HIDUSAGE(GENERIC, HID_USAGE_GENERIC_X, 0*cbX(ULONG)),
    MAKE_HIDUSAGE(GENERIC, HID_USAGE_GENERIC_Y, 1*cbX(ULONG)),
    MAKE_HIDUSAGE(GENERIC, HID_USAGE_GENERIC_Z, 2*cbX(ULONG)),
};

PIDREPORT g_CustomSample =
{
    HidP_Output,
    HID_USAGE_PAGE_PID,
    HID_USAGE_PID_DOWNLOAD_FORCE_SAMPLE ,
    cbX(DWORD),
    cA(c_rgUsgDirectionAxes),
    c_rgUsgDirectionAxes,
};   


static PIDUSAGE    c_rgUsgParameterOffset[] =
{
    MAKE_PIDUSAGE(PARAMETER_BLOCK_OFFSET,  0x0 ),
};

static PIDREPORT g_ParameterOffset =
{
    HidP_Output,
    HID_USAGE_PAGE_PID,
    0x0,
    cbX(DWORD),
    cA(c_rgUsgParameterOffset),
    c_rgUsgParameterOffset
};

#pragma END_CONST_DATA

//global variable to keep in relevant data for g_Custom
PIDCUSTOM g_PidCustom;


STDMETHODIMP
    PID_GetParameterOffset
    (
    IDirectInputEffectDriver *ped,
    DWORD      dwEffectIndex,
    UINT       uParameter,
    DWORD      dwSz,
    PLONG      plValue
    )
{

    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres = S_OK;
    USHORT  uOffset = (USHORT)-1;
    PEFFECTSTATE    pEffectState =  PeffectStateFromBlockIndex(this,dwEffectIndex);    
    PPIDMEM         pMem = &pEffectState->PidMem[uParameter];

    EnterProcI( PID_GetParameterOffset, (_"xxxxx", ped, dwEffectIndex, uParameter, dwSz, plValue));

    AssertF(uParameter < this->cMaxParameters);

    *plValue = 0x0;
    hres = PID_ValidateEffectIndex(ped, dwEffectIndex);
    if(SUCCEEDED(hres))
    {
        // We have already allocated memory, 
        // Just return the last size
        if( PIDMEM_SIZE(pMem) != 0x0 )
        {
            uOffset = PIDMEM_OFFSET(pMem);
        } else if( dwSz == 0x0 )
        {
            // Logitech device wants parameter blocks to 
            // set to -1 if they do not exist
            uOffset = (USHORT)-1;
        } else
        {
            // New Allocation
            PPIDMEM pTmp, pNext;
            UINT nAlloc;
            USHORT uSz;
			PUNITSTATE pUnitState = (PUNITSTATE)(g_pshmem + this->iUnitStateOffset);
			hres = DIERR_OUTOFMEMORY;

            // Align memory request
            uSz = (USHORT)((dwSz / this->ReportPool.uPoolAlign + 1) * (this->ReportPool.uPoolAlign));

            AssertF(uSz >= (USHORT)this->ReportPool.uPoolAlign);
            //To be doubly sure.
            uSz = max( uSz, (USHORT)this->ReportPool.uPoolAlign);

            WaitForSingleObject(g_hmtxShared, INFINITE);

            for(nAlloc = 0x0, pTmp = &(pUnitState->Guard[0]), pNext = (PPIDMEM)((PUCHAR)pUnitState + pTmp->iNext);  
               nAlloc < pUnitState->nAlloc && pTmp != &(pUnitState->Guard[1]);
               nAlloc++, pTmp = pNext, pNext = (PPIDMEM)((PUCHAR)pUnitState + pTmp->iNext))
            {

                SquirtSqflPtszV(sqfl | sqflVerbose,
                                TEXT("%d %x(%x), Next:%x (%x) "),
                                nAlloc, pTmp, pTmp->uOfSz, pNext, pNext->uOfSz  );

                AssertF(pNext != NULL );
				// If pNext == pUnitState, it means that the offset is 0.
				// The offset of 0 is invalid.
				AssertF((PUCHAR)pNext != (PUCHAR)pUnitState);

                // Is there space in the cracks
                if( GET_NEXTOFFSET(pTmp) + uSz < PIDMEM_OFFSET(pNext)  )
                {
                    pMem->iNext   = (PUCHAR)pNext - (PUCHAR)pUnitState;
                    pTmp->iNext   = (PUCHAR)pMem - (PUCHAR)pUnitState;

                    uOffset       = GET_NEXTOFFSET(pTmp) ;
                    pMem->uOfSz   = PIDMEM_OFSZ(uOffset, uSz);

                    pUnitState->nAlloc++;
                    pUnitState->cbAlloc += uSz;
                    hres = S_OK;

                    SquirtSqflPtszV(sqfl | sqflVerbose,
                                    TEXT("%d %p (%x), Next: %p (%x) "),
                                    nAlloc, pMem, pMem->uOfSz, pNext, pNext->uOfSz  );

                    break;
                }

            }

            ReleaseMutex(g_hmtxShared);
        }
    }

    if( SUCCEEDED(hres) )
    {
        *plValue = (ULONG)uOffset;
    } else
    {
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%s:FAIL  Could not allocate %d bytes, UsedMem:%d, Allocs%d"),
                        s_tszProc, dwSz, ((PUNITSTATE)(g_pshmem + this->iUnitStateOffset))->cbAlloc, ((PUNITSTATE)(g_pshmem + this->iUnitStateOffset))->nAlloc );
    }


    ExitOleProc();

    return hres;
}

HRESULT
    PID_SendParameterBlock
    (
    IDirectInputEffectDriver *ped,
    DWORD       dwEffectIndex,
    DWORD       dwMemSz,
    PUINT       puParameter,
    PPIDREPORT  pPidReport,
    PVOID       pvData,
    UINT        cbData,
	BOOL		bBlocking,
	UINT		totalBlocks
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres=S_OK;

    PUCHAR   pReport;
    UINT    cbReport;

    EnterProcI( PID_SendParameterBlock, (_"xxxxx", ped, dwEffectIndex, dwMemSz, pPidReport, pvData, cbData));

    AssertF(pPidReport->HidP_Type == HidP_Output);

    cbReport = this->cbReport[pPidReport->HidP_Type];
    pReport  = this->pReport[pPidReport->HidP_Type];

    if( *puParameter >= this->cMaxParameters )
    {
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%s:FAIL Only support %d parameter blocks per effect "),
                        s_tszProc, *puParameter );

        hres = E_NOTIMPL;
    }

    if( SUCCEEDED(hres) )
    {
        USHORT  LinkCollection;
        ZeroBuf(pReport, cbReport);

        PID_GetLinkCollectionIndex(ped, pPidReport->UsagePage, pPidReport->Collection, 0x0, &LinkCollection);

        hres = PID_PackValue
               (
               ped,
               pPidReport,
               LinkCollection,
               pvData,
               cbData,
               pReport,
               cbReport
			   );

        // For device managed memory, we need to send the 
        // effect index 
        if( SUCCEEDED(hres) )
        {
            if( this->uDeviceManaged & PID_DEVICEMANAGED )
            {
                // Must be a valid effect ID
                AssertF(dwEffectIndex != 0x0 ); 

                /*hres =*/

                PID_PackValue
                    (
                    ped,
                    &g_BlockIndex,
                    LinkCollection,
                    &dwEffectIndex,
                    cbX(dwEffectIndex),
                    pReport,
                    cbReport
                    ); 

                // Send down the paramter block index
                /*hres =*/PID_PackValue
                    (
                    ped,
                    &g_ParameterOffset,
                    LinkCollection,
                    puParameter,
                    cbX(*puParameter),
                    pReport,
                    cbReport
                    );
            } else
            {
                LONG lValue;

                hres = PID_GetParameterOffset(ped, dwEffectIndex, *puParameter, dwMemSz, &lValue); 

                if( SUCCEEDED(hres) )
                {
                    hres = PID_PackValue
                           (
                           ped,
                           &g_ParameterOffset,
                           LinkCollection,
                           &lValue,
                           cbX(lValue),
                           pReport,
                           cbReport
                           );
                }
            }
        }

        if( SUCCEEDED(hres) )
        {
			hres = PID_SendReport(ped, pReport, cbReport, pPidReport->HidP_Type, bBlocking, *puParameter, totalBlocks); 
        }

        if(SUCCEEDED(hres))
        {
            (*puParameter)++;
        }
    }
    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *      PID_DownloadCustomForceData
 *
 *      Download custom force sample data to the device.
 *
 *****************************************************************************/

STDMETHODIMP
    PID_DownloadCustomForceData
    (
    IDirectInputEffectDriver *ped,
    DWORD dwEffectIndex, 
    PUINT puParameter,
    LPCDICUSTOMFORCE pCustom, 
    LPCDIEFFECT     peff
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres = S_OK;
    PCHAR pData = NULL;
	PCHAR pBuff = NULL;
    USHORT cbData;
	USHORT nBytes;
	USHORT bitsX;
	USHORT bitsY;
	USHORT bitsZ;
	LPLONG pSample;
    
    EnterProcI( PID_DownloadCustomForceData, (_"xxx", ped, dwEffectIndex, pCustom,  puParameter ));

	//zero out g_PidCustom
	g_PidCustom.cSamples = g_PidCustom.DataOffset = g_PidCustom.dwSamplePeriod = 0;

	//get bytes per sample and allocate the buffer
	bitsX = this->customCaps[0].BitSize;
	bitsY = this->customCaps[1].BitSize;
	bitsZ = this->customCaps[2].BitSize;

	//byte count must be multiple of 8!
	if ((bitsX%8 != 0) || (bitsY%8 != 0) || (bitsZ%8 != 0))
	{

		 SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%s:FAIL Download Force Sample report fields that are not multiples of 8 are not supported!\n"),
                            s_tszProc );
		hres = E_NOTIMPL;
	}

	//report count shouldn't be bigger than 1!
	AssertF(this->customCaps[0].ReportCount <= 1);
	AssertF(this->customCaps[1].ReportCount <= 1);
	AssertF(this->customCaps[2].ReportCount <= 1);

	if (SUCCEEDED(hres))
	{
		nBytes = (bitsX + bitsY + bitsZ)/8;
		cbData  = (USHORT) (pCustom->cSamples * nBytes);
		hres = AllocCbPpv(cbData, &pBuff);

		if( pBuff != NULL)
		{
			//determine which effect axis corresponds to which report axis
			LONG Offset[3] = {-1, -1, -1};
			int nAxis = 0;
			int nChannel = 0;
			int nSample = 0;
			
			for (nChannel = 0; nChannel < (int)pCustom->cChannels, nChannel < (int)peff->cAxes; nChannel ++)
			{
				for (nAxis = 0; nAxis < 3; nAxis ++)
				{
					if (DIGETUSAGE(peff->rgdwAxes[nChannel]) == DIGETUSAGE(g_CustomSample.rgPidUsage[nAxis].dwUsage))
					{
						Offset[nAxis] = nChannel;
					}
				}
			}
			
			
			
			ZeroBuf(pBuff, cbData);

			pData = pBuff;
			pSample = pCustom->rglForceData;

			//scale all the samples
			//loop through samples
			for (nSample = 0; nSample < (int)pCustom->cSamples; nSample ++)
			{
				//loop through report axis
				for (nAxis = 0; nAxis < 3; nAxis++)
				{
					LONG lSampleValue = 0;

					//check if this axis is used
					if (Offset[nAxis] == -1)
					{
						pData += this->customCaps[nAxis].BitSize/8;
						continue;
					}

					lSampleValue = *(pSample + Offset[nAxis]);


					switch (this->customCaps[nAxis].BitSize)
					{
					case 8:
						//8-bit reports
						{
							(*((BYTE*)pData)) = (BYTE)(this->customCaps[nAxis].LogicalMin + ((lSampleValue + DI_FFNOMINALMAX) * (this->customCaps[nAxis].LogicalMax - this->customCaps[nAxis].LogicalMin))/(2*DI_FFNOMINALMAX));
							pData++;
							break;
						}
					case 16:
						//16-bit reports
						{

							(*((SHORT*)pData)) = (SHORT)(this->customCaps[nAxis].LogicalMin + ((lSampleValue + DI_FFNOMINALMAX) * (this->customCaps[nAxis].LogicalMax - this->customCaps[nAxis].LogicalMin))/(2*DI_FFNOMINALMAX));
							pData++;
							break;
						}
					case 32:
						//assume 32-bit reports as default
						{
							(*((LONG*)pData)) = (LONG)(this->customCaps[nAxis].LogicalMin + ((lSampleValue + DI_FFNOMINALMAX) * (this->customCaps[nAxis].LogicalMax - this->customCaps[nAxis].LogicalMin))/(2*DI_FFNOMINALMAX));
							pData++;
							break;
						}
					default:
						{
							SquirtSqflPtszV(sqfl | sqflError,
								TEXT("%s:FAIL Download Force Sample report fields that are not 8, 16 or 32 are not supported\n"),
								s_tszProc );
							hres = E_NOTIMPL;
						}
					}

				}

				pSample += pCustom->cChannels;


			}

		}

		if(SUCCEEDED(hres))
		{
			PCHAR   pReport;
			UINT    cbReport;
			HIDP_REPORT_TYPE  HidP_Type = HidP_Output;
			USAGE UsagePage = HID_USAGE_PAGE_PID;
			USAGE UsageData = HID_USAGE_PID_CUSTOM_FORCE_DATA;
			USAGE UsageOffset = HID_USAGE_PID_CUSTOM_FORCE_DATA_OFFSET;
			USHORT  LinkCollection = 0x0;

			cbReport = this->cbReport[g_CustomData.HidP_Type];
			pReport  = this->pReport[g_CustomData.HidP_Type];
  
			if ((this->customDataCaps.ReportCount > 0) && (this->customDataCaps.BitSize >=8))
			{
				USHORT nOffset = 0;
				LONG lOffset = 0;
				USHORT nIncrement = (this->customDataCaps.ReportCount * this->customDataCaps.BitSize)/8;
					
				// For memory managed device allocate enough memory
				// holding the custom force samples
				if( ! (this->uDeviceManaged & PID_DEVICEMANAGED ))
				{
					hres = PID_GetParameterOffset(ped, dwEffectIndex, *puParameter, this->SzPool.uSzCustom, &lOffset); 
				}

				pData = pBuff;

				if (SUCCEEDED(hres))
				{

					//send data in a loop
					for (nOffset = 0; nOffset < cbData; nOffset += nIncrement)
					{
						//create a new buffer and copy data into it
						PCHAR pIncrement = NULL;
						hres = AllocCbPpv(nIncrement, &pIncrement);

						if (pIncrement != NULL)
						{
							ZeroBuf(pIncrement, nIncrement);
							memcpy(pIncrement, pData, min((cbData - nOffset), nIncrement));

							ZeroBuf(pReport, cbReport);

							//set the byte count
							hres = HidP_SetScaledUsageValue
								(
								HidP_Type,
								HID_USAGE_PAGE_GENERIC,
								LinkCollection,
								HID_USAGE_GENERIC_BYTE_COUNT,
								(LONG)nIncrement,
								this->ppd,
								pReport,
								cbReport
								);
								


							//set the offset
							hres = HidP_SetScaledUsageValue
								(
								HidP_Type,
								UsagePage,
								0x0,
								//LinkCollection,
								UsageOffset,
								(LONG) (nOffset + lOffset),
								this->ppd,
								pReport,
								cbReport
								);
							
							
					
							//set the data
							hres  = HidP_SetUsageValueArray 
								(
								HidP_Type,          //  IN    HIDP_REPORT_TYPE     ReportType,
								UsagePage, //  IN    USAGE                UsagePage,
								0x0,                //  IN    USHORT               LinkCollection, // Optional
								UsageData,
								pIncrement,              //  IN    PCHAR                UsageValue,
								nIncrement,             //  IN    USHORT               UsageValueByteLength,
								this->ppd,          //  IN    PHIDP_PREPARSED_DATA PreparsedData,
								pReport,            //  OUT   PCHAR                Report,
								cbReport            //  IN    ULONG                ReportLength
								);

			
							//set the effect index
							PID_PackValue
								(
								ped,
								&g_BlockIndex,
								LinkCollection,
								&dwEffectIndex,
								cbX(dwEffectIndex),
								pReport,
								cbReport
								);
															

							//send the report
							hres = PID_SendReport(ped, pReport, cbReport, HidP_Type, TRUE, 0, 1);
					
							pData += nIncrement;

							FreePpv(&pIncrement);
						}
					}

					//put data into g_PidCustom
					g_PidCustom.DataOffset = (DWORD)lOffset;
					g_PidCustom.cSamples = pCustom->cSamples;
					//ISSUE-2001/03/29-timgill May need to do real scaling.
					g_PidCustom.dwSamplePeriod = pCustom->dwSamplePeriod/1000; //in milliseconds

					//and increment puParameter
					(*puParameter)++;

				}			
			}
			else
			{
				//do nothing
			}

			FreePpv(&pBuff);
		}
	
    }

	ExitOleProc();
    return hres;
}



STDMETHODIMP
    PID_DoParameterBlocks
    (
    IDirectInputEffectDriver *ped,
    DWORD dwId, 
    DWORD dwEffectId,
    DWORD dwEffectIndex, 
    LPCDIEFFECT peff, 
    DWORD dwFlags,
    PUINT puParameter,
	BOOL  bBlocking,
	UINT totalBlocks
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres = S_OK;

    EnterProcI( PID_DoParameterBlocks, (_"xxxxxxx", ped, dwId, dwEffectId, dwEffectIndex, peff, dwFlags, puParameter ));

    if( SUCCEEDED(hres)
        && (dwFlags & DIEP_TYPESPECIFICPARAMS) )
    {
        AssertF(peff->lpvTypeSpecificParams != NULL);        
        AssertF(peff->cbTypeSpecificParams != 0x0 ); 

        switch(dwEffectId)
        {
        case PIDMAKEUSAGEDWORD(ET_CONSTANT) :
            {
                DICONSTANTFORCE DiParam;
                AssertF(peff->cbTypeSpecificParams <= cbX(DiParam) );
                memcpy(&DiParam, peff->lpvTypeSpecificParams, cbX(DiParam));
                // Constant Force:
                // Scale the magnitude.
                DiParam.lMagnitude = Clamp(-DI_FFNOMINALMAX,  DiParam.lMagnitude, DI_FFNOMINALMAX);

                PID_ApplyScalingFactors(ped, &g_Constant, &this->DiSConstScale, cbX(this->DiSConstScale), &this->DiSConstOffset, cbX(this->DiSConstOffset), &DiParam, cbX(DiParam) );

                hres = PID_SendParameterBlock
                       (
                       ped,
                       dwEffectIndex,
                       this->SzPool.uSzConstant,
                       puParameter,
                       &g_Constant,
                       &DiParam,
                       cbX(DiParam),
					   bBlocking,
					   totalBlocks
                       );
                break;
            }

        case PIDMAKEUSAGEDWORD(ET_RAMP):
            {
                // Ramp Force
                DIRAMPFORCE DiParam;
                AssertF(peff->cbTypeSpecificParams <= cbX(DiParam) );
                memcpy(&DiParam, peff->lpvTypeSpecificParams, cbX(DiParam));

                //Scale the magnitude
                DiParam.lStart  = Clamp(-DI_FFNOMINALMAX, DiParam.lStart,    DI_FFNOMINALMAX);
                DiParam.lEnd    = Clamp(-DI_FFNOMINALMAX, DiParam.lEnd,      DI_FFNOMINALMAX);


                PID_ApplyScalingFactors(ped, &g_Ramp, &this->DiSRampScale, cbX(this->DiSRampScale), &this->DiSRampOffset, cbX(this->DiSRampOffset), &DiParam, cbX(DiParam) );
                hres = PID_SendParameterBlock
                       (
                       ped,
                       dwEffectIndex, 
                       this->SzPool.uSzRamp,
                       puParameter,
                       &g_Ramp,
                       &DiParam,
                       cbX(DiParam),
					   bBlocking,		
					   totalBlocks
                       );
                break;
            }

        case PIDMAKEUSAGEDWORD(ET_SQUARE):
        case PIDMAKEUSAGEDWORD(ET_SINE):
        case PIDMAKEUSAGEDWORD(ET_TRIANGLE):
        case PIDMAKEUSAGEDWORD(ET_SAWTOOTH_UP):
        case PIDMAKEUSAGEDWORD(ET_SAWTOOTH_DOWN):
            {
                DIPERIODIC DiParam;
                AssertF(peff->cbTypeSpecificParams <= cbX(DiParam) );
                memcpy(&DiParam, peff->lpvTypeSpecificParams, cbX(DiParam));

                //Scale the parameters
                DiParam.dwMagnitude =   Clip(                 DiParam.dwMagnitude,    DI_FFNOMINALMAX);
                DiParam.lOffset =       Clamp(-DI_FFNOMINALMAX,  DiParam.lOffset,        DI_FFNOMINALMAX);
                //Wrap the phase around
                DiParam.dwPhase %= (360*DI_DEGREES);

                PID_ApplyScalingFactors(ped, &g_Periodic, &this->DiSPeriodicScale, cbX(this->DiSPeriodicScale), &this->DiSPeriodicOffset, cbX(this->DiSPeriodicOffset), &DiParam, cbX(DiParam) );
                hres = PID_SendParameterBlock
                       (
                       ped,
                       dwEffectIndex, 
                       this->SzPool.uSzPeriodic,
                       puParameter,
                       &g_Periodic,
                       &DiParam,
                       cbX(DiParam),
					   bBlocking,
					   totalBlocks
                       );
                break;
            }
        case PIDMAKEUSAGEDWORD(ET_SPRING):
        case PIDMAKEUSAGEDWORD(ET_DAMPER):
        case PIDMAKEUSAGEDWORD(ET_INERTIA):
        case PIDMAKEUSAGEDWORD(ET_FRICTION):
            {  
                LPDICONDITION lpCondition;
				DWORD nStruct;
				DWORD cStruct = (peff->cbTypeSpecificParams)/sizeof(DICONDITION);
				AssertF(cStruct <= peff->cAxes);

                for(nStruct = 0x0, lpCondition = (LPDICONDITION)peff->lpvTypeSpecificParams; 
                   nStruct < cStruct && SUCCEEDED(hres);  
                   nStruct++, lpCondition++ )
                {
                    DICONDITION DiCondition;
                    DiCondition = *lpCondition;

                    //Scale the values
                    DiCondition.lOffset =               Clamp(-DI_FFNOMINALMAX,  DiCondition.lOffset,                DI_FFNOMINALMAX);
                    DiCondition.lPositiveCoefficient =  Clamp(-DI_FFNOMINALMAX,  DiCondition.lPositiveCoefficient,   DI_FFNOMINALMAX);
                    DiCondition.lNegativeCoefficient =  Clamp(-DI_FFNOMINALMAX,  DiCondition.lNegativeCoefficient,   DI_FFNOMINALMAX); 
                    DiCondition.dwPositiveSaturation =  Clip(                    DiCondition.dwPositiveSaturation,   DI_FFNOMINALMAX); 
                    DiCondition.dwNegativeSaturation =  Clip(                    DiCondition.dwNegativeSaturation,   DI_FFNOMINALMAX); 
                    DiCondition.lDeadBand =             Clamp(0,				 DiCondition.lDeadBand,              DI_FFNOMINALMAX);

                    PID_ApplyScalingFactors(ped, &g_Condition, &this->DiSCondScale, cbX(this->DiSCondScale), &this->DiSCondOffset, cbX(this->DiSCondOffset), &DiCondition, cbX(DiCondition) );
                    hres = PID_SendParameterBlock
                           (
                           ped,
                           dwEffectIndex,
                           this->SzPool.uSzCondition,
                           puParameter,
                           &g_Condition,
                           &DiCondition,
                           sizeof(DiCondition),
						   bBlocking,
						   totalBlocks
                           );
                }

				//Conditions can't have envelopes! 
                //So if there's a flag indicating an envelope, take it out.
                dwFlags &= ~(DIEP_ENVELOPE);

                break;
            }

        case PIDMAKEUSAGEDWORD(ET_CUSTOM):
            {
                // Custom Force
                DICUSTOMFORCE DiParam;
                AssertF(peff->cbTypeSpecificParams <= cbX(DiParam) );
                memcpy(&DiParam, peff->lpvTypeSpecificParams, cbX(DiParam));

				// Download Custom Force -- always a blocking call
				hres = PID_DownloadCustomForceData(ped, dwEffectIndex, puParameter, &DiParam, peff);

                if( SUCCEEDED(hres) )
                {
					// Set custom Effect parameter block header -- always a blocking call
					hres = PID_SendParameterBlock
						   (
						   ped,
						   dwEffectIndex, 
						   this->SzPool.uSzCustom,
						   puParameter,
						   &g_Custom,
						   &g_PidCustom,
						   cbX(DiParam),
						   TRUE,
						   totalBlocks
						   );
						   
                }

				break;
            }
        default:
           
            hres = DIERR_PID_USAGENOTFOUND;

            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%s:FAIL  Unknown parameter block for dwEffectId(0x%x)"),
                            s_tszProc, dwEffectId );

            break;

        }
    }

    if(    SUCCEEDED(hres) 
           && (dwFlags & DIEP_ENVELOPE)  
           && peff->lpEnvelope != NULL )
    {
        DIENVELOPE DiEnv;
        DiEnv = *peff->lpEnvelope;

        //Scale the values
        DiEnv.dwAttackLevel =   Clip(DiEnv.dwAttackLevel,    DI_FFNOMINALMAX);
        DiEnv.dwFadeLevel =     Clip(DiEnv.dwFadeLevel,      DI_FFNOMINALMAX);
        
        PID_ApplyScalingFactors(ped, &g_Envelope, &this->DiSEnvScale, cbX(this->DiSEnvScale), &this->DiSEnvOffset, cbX(this->DiSEnvOffset), &DiEnv, DiEnv.dwSize );

        hres = PID_SendParameterBlock
               (
               ped,
               dwEffectIndex,
               this->SzPool.uSzEnvelope,
               puParameter,
               &g_Envelope,
               &DiEnv,
               DiEnv.dwSize,
			   bBlocking,
			   totalBlocks
               );

    }
    ExitOleProc();
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\pid\pidpr.h ===
#ifdef DBG
#define DEBUG
#endif

#include "dinput.h"
#include "dinputd.h"

#include "baggage.h"

#include "hidsdi.h"
#include "regstr.h"
#include "PIDi.h"
#include "PidUsg.h"

#include "debug.h"

//for the LONG_MAX define
#include "limits.h"

#ifdef WINNT
#include "aclapi.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\pid\pidinit.c ===
/*****************************************************************************
 *
 *  PidInit.c
 *  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
 *  Abstract:
 *
 *      Initialization code .
 *
 *****************************************************************************/
#include "pidpr.h"

#define sqfl            ( sqflInit )

#define NudgeWorkerThread(thid)                                         \
        PostThreadMessage(thid, WM_NULL, 0x0, (LPARAM)NULL)

#pragma BEGIN_CONST_DATA


static PIDUSAGE    c_rgUsgPool[] =
{
    MAKE_PIDUSAGE(SIMULTANEOUS_EFFECTS_MAX,     FIELD_OFFSET(REPORTPOOL,uSimulEfMax)),
    MAKE_PIDUSAGE(RAM_POOL_SIZE,                FIELD_OFFSET(REPORTPOOL,uRamPoolSz)),
    MAKE_PIDUSAGE(ROM_POOL_SIZE,                FIELD_OFFSET(REPORTPOOL,uRomPoolSz)),
    MAKE_PIDUSAGE(ROM_EFFECT_BLOCK_COUNT,       FIELD_OFFSET(REPORTPOOL,uRomETCount)),
    MAKE_PIDUSAGE(POOL_ALIGNMENT,               FIELD_OFFSET(REPORTPOOL,uPoolAlign)),
};

static PIDUSAGE    c_rgUsgPoolSz[] =
{
    MAKE_PIDUSAGE(SET_CONSTANT_FORCE_REPORT,    FIELD_OFFSET(SZPOOL, uSzConstant)),
    MAKE_PIDUSAGE(SET_ENVELOPE_REPORT,          FIELD_OFFSET(SZPOOL, uSzEnvelope)),
    MAKE_PIDUSAGE(SET_CONDITION_REPORT,         FIELD_OFFSET(SZPOOL, uSzCondition)),                 
    MAKE_PIDUSAGE(SET_CUSTOM_FORCE_REPORT,      FIELD_OFFSET(SZPOOL, uSzCustom)),
    MAKE_PIDUSAGE(SET_PERIODIC_REPORT,          FIELD_OFFSET(SZPOOL, uSzPeriodic)),
    MAKE_PIDUSAGE(SET_RAMP_FORCE_REPORT,        FIELD_OFFSET(SZPOOL, uSzRamp)),
    MAKE_PIDUSAGE(SET_EFFECT_REPORT,            FIELD_OFFSET(SZPOOL, uSzEffect)),
    MAKE_PIDUSAGE(CUSTOM_FORCE_DATA_REPORT,     FIELD_OFFSET(SZPOOL, uSzCustomData)),
};


static PIDREPORT PoolSz =
{
    HidP_Feature,
    HID_USAGE_PAGE_PID,
    HID_USAGE_PID_PARAMETER_BLOCK_SIZE,
    cbX(SZPOOL),
    cA(c_rgUsgPoolSz),
    c_rgUsgPoolSz
};


PIDREPORT g_PoolReport =
{
    HidP_Feature,
    HID_USAGE_PAGE_PID,
    HID_USAGE_PID_POOL_REPORT,
    cbX(REPORTPOOL),
    cA(c_rgUsgPool),
    c_rgUsgPool
};

static PIDSUPPORT g_PoolSupport[] =
{
    {PID_DEVICEMANAGED,     PIDMAKEUSAGEDWORD(DEVICE_MANAGED_POOL),         HID_BUTTON,   HidP_Feature},
    {PID_SHAREDPARAM,       PIDMAKEUSAGEDWORD(SHARED_PARAMETER_BLOCKS),     HID_BUTTON,   HidP_Feature},
};


#pragma END_CONST_DATA


/*****************************************************************************
 *
 *      PID_InitSharedMem
 *
 *      Inits our Shared Memory
 *
 *****************************************************************************/

HRESULT  INTERNAL
    PID_InitSharedMem
    (
    IDirectInputEffectDriver *ped
    )
{
    HRESULT hres = S_OK;
    CPidDrv *this = (CPidDrv *)ped;

    EnterProcI( PID_InitSharedMem, (_"x", ped));

    // Get hold of global memory to keep the EffectState 
    if( SUCCEEDED(hres) )
    {
        UINT unitID;
        hres = DIERR_PID_NOTINITIALIZED;
        WaitForSingleObject(g_hmtxShared, INFINITE);
        for(unitID = 0; unitID < MAX_UNITS; unitID++)
        {

            GUID*  pGuid = &g_pshmem->rgus[unitID].GuidInstance;
#ifdef DEBUG
            TCHAR   lpName[MAX_PATH];
            NameFromGUID(lpName, pGuid);

            SquirtSqflPtszV(sqfl | sqflVerbose,
                            TEXT("%s:UnitId(%d): GUID %s"),
                            s_tszProc, unitID, lpName );
#endif

            if(  IsEqualGUID(pGuid, &this->GuidInstance) )
            {
                this->iUnitStateOffset = (&g_pshmem->rgus[unitID] - (PUNITSTATE)g_pshmem);
                hres = S_OK;
            } else if( IsEqualGUID(pGuid, &GUID_NULL ) )
            {
				PUNITSTATE pUnitState;
                this->iUnitStateOffset = (&g_pshmem->rgus[unitID] - (PUNITSTATE)g_pshmem);
				pUnitState = (PUNITSTATE)(g_pshmem + this->iUnitStateOffset);
                pUnitState->GuidInstance = this->GuidInstance;
                pUnitState->nAlloc = 0x0;
                ZeroBuf(pUnitState->State,GLOBAL_EFFECT_MEMSZ );
                hres = S_OK;
            }
            if( SUCCEEDED(hres) )
            {
                break;
            }
        }

        if(SUCCEEDED(hres) )
        {
			PUNITSTATE pUnitState = (PUNITSTATE)(g_pshmem + this->iUnitStateOffset);
            PPIDMEM pGuard = pUnitState->Guard;
            INT_PTR iGuard1 = (PUCHAR)&pUnitState->Guard[0] - (PUCHAR)pUnitState, iGuard2 = (PUCHAR)&pUnitState->Guard[1] - (PUCHAR)pUnitState;

            pGuard->uOfSz = PIDMEM_OFSZ(0x0, 0x0 );
            pGuard->iNext =  iGuard2;

            pGuard++;

            pGuard->uOfSz   = PIDMEM_OFSZ(this->ReportPool.uRamPoolSz, 0x0);
            pGuard->iNext   = iGuard1;

            pUnitState->nAlloc = 0x2;

            pUnitState->cEfDownloaded = (USHORT)this->ReportPool.uRomETCount;
        }


        ReleaseMutex(g_hmtxShared);

        if( FAILED(hres) )
        {
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%s:FAIL Could not find free unitID"),
                            s_tszProc );

        }
    }
    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *      PID_InitScaling
 *
 *      Inits Scaling Coefficients
 *
 *****************************************************************************/
PID_InitScaling
    (
    IDirectInputEffectDriver *ped
    )
{
    HRESULT hres = S_OK;
    CPidDrv *this = (CPidDrv *)ped;
    USHORT LinkCollection;
    UINT indx;
    EnterProc( PID_InitScaling, (_"x", ped));


    // Scaling Exponents and Offsets
    this->DiSEffectScale.dwSize =  this->DiSEffectOffset.dwSize = sizeof(DIEFFECT);     /* sizeof(DIEFFECT)     */
    //this->DiSEffect.dwFlags                /* DiEffect*              */
    this->DiSEffectScale.dwDuration    =  DI_SECONDS ;/* Microseconds         */
    this->DiSEffectScale.dwSamplePeriod = DI_SECONDS ;/* Microseconds         */
    this->DiSEffectScale.dwGain          = DI_FFNOMINALMAX;
    this->DiSEffectScale.dwTriggerButton = 0x0;   /* or DIEB_NOTRIGGER    */
    this->DiSEffectScale.dwTriggerRepeatInterval = DI_SECONDS; /* Microseconds         */
    //this->DiSEffect.cAxes;                       /* Number of axes       */
    //this->DiSEffect.rgdwAxes;                    /* Array of axes        */
    //this->DiSEffect.rglDirection;                /* Array of directions  */
    //this->DiSEffect.lpEnvelope;                  /* Optional             */
    //this->DiSEffect.cbTypeSpecificParams;        /* Size of params       */
    //this->DiSEffect.lpvTypeSpecificParams;       /* Pointer to params    */
#if DIRECTINPUT_VERSION  >= 0x600
    this->DiSEffectScale.dwStartDelay    =   DI_SECONDS;    // Start delay
#endif


    if(SUCCEEDED(PID_GetLinkCollectionIndex(ped, g_Effect.UsagePage, g_Effect.Collection,     0x0, &LinkCollection )))
    {
        PID_ComputeScalingFactors(ped, &g_Effect,     LinkCollection, &this->DiSEffectScale,   this->DiSEffectScale.dwSize, &this->DiSEffectOffset,   this->DiSEffectOffset.dwSize);
    }

    this->DiSEnvScale.dwSize  = this->DiSEnvOffset.dwSize = sizeof(DIENVELOPE);      /* sizeof(DIENVELOPE)   */
    this->DiSEnvScale.dwAttackLevel   = DI_FFNOMINALMAX;
    this->DiSEnvScale.dwAttackTime    = DI_SECONDS; /* Microseconds         */
    this->DiSEnvScale.dwFadeLevel     = DI_FFNOMINALMAX;
    this->DiSEnvScale.dwFadeTime      = DI_SECONDS; /* Microseconds         */


    if(SUCCEEDED(PID_GetLinkCollectionIndex(ped, g_Envelope.UsagePage, g_Envelope.Collection, 0x0, &LinkCollection)))
    {
        PID_ComputeScalingFactors(ped, &g_Envelope,   LinkCollection, &this->DiSEnvScale,      this->DiSEnvScale.dwSize, &this->DiSEnvOffset,      this->DiSEnvOffset.dwSize);
    }

    this->DiSPeriodicScale.dwMagnitude    = DI_FFNOMINALMAX;
    this->DiSPeriodicScale.lOffset        = DI_FFNOMINALMAX;
    this->DiSPeriodicScale.dwPhase        = 360 * DI_DEGREES;
    this->DiSPeriodicScale.dwPeriod       = DI_SECONDS;

    if(SUCCEEDED(PID_GetLinkCollectionIndex(ped, g_Periodic.UsagePage, g_Periodic.Collection, 0x0, &LinkCollection)))
    {
        PID_ComputeScalingFactors(ped, &g_Periodic,   LinkCollection, &this->DiSPeriodicScale, cbX(this->DiSPeriodicScale), &this->DiSPeriodicOffset, cbX(this->DiSPeriodicOffset));
    }

    this->DiSRampScale.lStart           =
        this->DiSRampScale.lEnd             = DI_FFNOMINALMAX;


    if(SUCCEEDED(PID_GetLinkCollectionIndex(ped, g_Ramp.UsagePage,     g_Ramp.Collection,     0x0, &LinkCollection)))
    {
        PID_ComputeScalingFactors(ped, &g_Ramp,       LinkCollection, &this->DiSRampScale, cbX(this->DiSRampScale), &this->DiSRampOffset, cbX(this->DiSRampOffset));
    }

    this->DiSCondScale.lOffset               =
        this->DiSCondScale.lPositiveCoefficient  =
        this->DiSCondScale.lNegativeCoefficient  =
        this->DiSCondScale.dwPositiveSaturation  =
        this->DiSCondScale.dwNegativeSaturation  =
        this->DiSCondScale.lDeadBand             = DI_FFNOMINALMAX;

    if(SUCCEEDED(PID_GetLinkCollectionIndex(ped, g_Condition.UsagePage,g_Condition.Collection,0x0, &LinkCollection)))
    {
        PID_ComputeScalingFactors(ped, &g_Condition,  LinkCollection, &this->DiSCondScale, cbX(this->DiSCondScale), &this->DiSCondOffset, cbX(this->DiSCondOffset));
    }

    this->DiSConstScale.lMagnitude           = DI_FFNOMINALMAX;

    if(SUCCEEDED(PID_GetLinkCollectionIndex(ped, g_Constant.UsagePage, g_Constant.Collection, 0x0, &LinkCollection)))
    {
        PID_ComputeScalingFactors(ped, &g_Constant,   LinkCollection, &this->DiSConstScale,cbX(this->DiSConstScale), &this->DiSConstOffset,cbX(this->DiSConstOffset));
    }

    this->DiSCustomScale.dwSamplePeriod     =      DI_SECONDS;

    if(SUCCEEDED(PID_GetLinkCollectionIndex(ped, g_Custom.UsagePage,   g_Custom.Collection,   0x0, &LinkCollection)))
    {
        PID_ComputeScalingFactors(ped, &g_Custom,   LinkCollection, &this->DiSCustomScale, cbX(this->DiSCustomScale), &this->DiSCustomOffset, cbX(this->DiSCustomOffset));
    }



    // Direction could be ordinals
    g_Direction.cbXData     = cA(c_rgUsgOrdinals)*cbX(DWORD); 
    g_Direction.cAPidUsage  = cA(c_rgUsgOrdinals);
    g_Direction.rgPidUsage  = c_rgUsgOrdinals;

    if(SUCCEEDED(PID_GetLinkCollectionIndex(ped, g_Direction.UsagePage, g_Direction.Collection, 0x0, &LinkCollection)))
    {
        HRESULT hres1;

        for(indx = 0x0; indx < MAX_ORDINALS; indx++)
        {
            this->DiSEffectAngleScale[indx]            = 360 * DI_DEGREES;
        }

        hres1 = PID_ComputeScalingFactors(ped, &g_Direction,   LinkCollection, &this->DiSEffectAngleScale[0], cbX(this->DiSEffectAngleScale), &this->DiSEffectAngleOffset[0], cbX(this->DiSEffectAngleOffset));

        // Direction could be angles
        if(hres1 == E_NOTIMPL )
        {
            g_Direction.cbXData     = cA(c_rgUsgDirection)*cbX(DWORD); 
            g_Direction.cAPidUsage  = cA(c_rgUsgDirection);
            g_Direction.rgPidUsage  = c_rgUsgDirection;

            // Reset the nominal values
            for(indx = 0x0; indx < MAX_ORDINALS; indx++)
            {
                this->DiSEffectAngleScale[indx]            = 360 * DI_DEGREES;
            }

            hres1 = PID_ComputeScalingFactors(ped, &g_Direction,   LinkCollection, &this->DiSEffectAngleScale[0], cbX(this->DiSEffectAngleScale), &this->DiSEffectAngleOffset[0], cbX(this->DiSEffectAngleOffset));    

            if( hres1 == E_NOTIMPL )
            {
                // Could be direction Vectors
                // Not sure how vectors are implemented in PID

                SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("%s:FAIL Cannot understand the direction collection\n")
                                TEXT("\t\t Supported usages are {Rx, Ry, Rz} or {Ordinals} \n"),
                                s_tszProc );
            }
        }
    }

    for(indx = 0x0; indx < MAX_ORDINALS; indx++)
    {
        this->DiSCustomSample[indx]            = DI_FFNOMINALMAX;
    }

    if(SUCCEEDED(PID_GetLinkCollectionIndex(ped, g_CustomSample.UsagePage,   g_CustomSample.Collection,   0x0, &LinkCollection)) )
    {  
		//get the custom data for each axis
   		USHORT  cAValCaps   = 0x1;
  		USAGE   UsagePage;  
		USAGE   Usage[3] = {HID_USAGE_GENERIC_X, HID_USAGE_GENERIC_Y, HID_USAGE_GENERIC_Z};
		NTSTATUS ntSt[3];
		int nAxis = 0;

       	UsagePage = HID_USAGE_PAGE_GENERIC;
       
		for (nAxis = 0; nAxis < 3; nAxis ++)
		{
			cAValCaps = 0x1;
   			ntSt[nAxis] = HidP_GetSpecificValueCaps
       						(
               				g_CustomSample.HidP_Type,
               				UsagePage,
               				LinkCollection,
               				Usage[nAxis],
               				&this->customCaps[nAxis],
               				&cAValCaps,
							this->ppd
               				);

			if (FAILED(ntSt[nAxis]))
			{
				this->customCaps[nAxis].BitSize = 0;
				this->customCaps[nAxis].LogicalMin = this->customCaps[nAxis].LogicalMax = 0;
			}
		}
               			
	

		if ((FAILED(ntSt[0])) && (FAILED(ntSt[1])) && (FAILED(ntSt[2])))
		{
			 SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%s:FAIL Cannot understand the download force sample collection\n")
                            TEXT("\t\t Supported usages are {X, Y, Z} \n"),
                            s_tszProc );

		}

		
		//get how many bytes of custom data can send at a time
		if (SUCCEEDED(PID_GetLinkCollectionIndex(ped, g_CustomData.UsagePage, g_CustomData.Collection, 0x0, &LinkCollection )))
		{

			USAGE UsageData = HID_USAGE_PID_CUSTOM_FORCE_DATA;
			NTSTATUS ntst;
			cAValCaps = 0x1;
			UsagePage = HID_USAGE_PAGE_PID;

			ntst = HidP_GetSpecificValueCaps
				   (
				   g_CustomData.HidP_Type,
				   UsagePage,
				   LinkCollection,
				   UsageData,
				   &this->customDataCaps,
				   &cAValCaps,
				   this->ppd
				   );

			if (FAILED(ntst))
			{
				this->customDataCaps.BitSize = 0;
			}
			

		}
	
	

   }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *      DIEnumProc
 *
 *      Enum and cache  FF device objects
 *
 *****************************************************************************/

BOOL CALLBACK
    DIEnumProc(LPCDIDEVICEOBJECTINSTANCE pinst, LPVOID pv)
{
    BOOL frc = DIENUM_CONTINUE;
    HRESULT hres = S_OK;
    CPidDrv* this = (CPidDrv*) pv;

    EnterProc( DIEnumProc, (_"xx", pinst, pv ));

    if(  (pinst->dwFlags & DIDOI_FFACTUATOR )
         ||(pinst->dwFlags & DIDOI_FFEFFECTTRIGGER ))
    {
        AssertF(this->cFFObj <= this->cFFObjMax);
        if( this->cFFObj == this->cFFObjMax )
        {
            /* Grow by doubling */
            this->cFFObjMax = max(PIDALLOC_INIT, 2*this->cFFObjMax);
            hres = ReallocCbPpv(this->cFFObjMax * cbX(DIUSAGEANDINST), &this->rgFFUsageInst);
        }

        if( SUCCEEDED(hres) )
        {
            PDIUSAGEANDINST pdiUI = this->rgFFUsageInst + this->cFFObj;
            pdiUI->dwUsage   = DIMAKEUSAGEDWORD(pinst->wUsagePage, pinst->wUsage);
            pdiUI->dwType    = pinst->dwType ;
        }

        this->cFFObj++;
    }
    if( FAILED(hres) )
    {
        frc = DIENUM_STOP;
    }

    ExitProcF(frc);
    return frc;
}

STDMETHODIMP
    PID_InitFFAttributes
    (
    IDirectInputEffectDriver *ped 
    )
{
    HRESULT hres = S_OK;
    CPidDrv *this = (CPidDrv *)ped;

    EnterProcI( PID_Init, (_"x", ped));

    // We cannot call this function at init, because DInput call us before the device 
    // has been completely initialized. 
    if( this->cFFObj )
    {
        hres = S_FALSE; // Already initialized
    } else
    {
        // We need to get the Usage & UsagePage 
        // for device objects marked as 
        // FF Triggers and FF Actuators

		//If we are called with DInput version not larger than 7, load dinput.dll w/ IID_DirectInput7
		//else load dinput8.dll.
		if (this->dwDirectInputVersion <= 0x0700)
		{	
			HINSTANCE hinst = LoadLibrary(TEXT("dinput.dll"));
			if (hinst)
			{
				typedef HRESULT ( WINAPI * DIRECTINPUTCREATEEX) ( HINSTANCE hinst, DWORD dwVersion, REFIID riidltf, LPVOID *ppvOut, LPUNKNOWN punkOuter);
                DIRECTINPUTCREATEEX _DirectInputCreateEx;
				LPDIRECTINPUT   lpDI;
                _DirectInputCreateEx = (DIRECTINPUTCREATEEX)GetProcAddress(hinst, "DirectInputCreateEx");
				if (_DirectInputCreateEx)
				{
					hres = _DirectInputCreateEx(g_hinst, this->dwDirectInputVersion, &IID_IDirectInput7, &lpDI, NULL );
					if( SUCCEEDED(hres) )
					{
						LPDIRECTINPUTDEVICE   pdid;
						hres = IDirectInput_CreateDevice(lpDI, &this->GuidInstance, &pdid, NULL);
						/* Create the device object */
						if( SUCCEEDED(hres) )
						{
							hres = IDirectInputDevice2_EnumObjects
								   (
								   pdid,   
								   DIEnumProc,
								   ped,
								   DIDFT_ALL //DIDFT_FFEFFECTTRIGGER | DIDFT_FFACTUATOR
								   );

							IDirectInput_Release(pdid);
						}
						IDirectInput_Release(lpDI);
					}
				}
				else //!DirectInputCreateEx
				{
					//Something is horribly wrong here if we can't find the Create fn!
					//Return the same error code that CDIDev_CreateEffectDriver() returns if there was an error loading FF driver
					hres = DIERR_UNSUPPORTED;
				}

				FreeLibrary(hinst);
			}
			else // !hinst
			{
				//Something is horribly wrong here if we came through Dinput but can't load it!
				//Return the same error code that CDIDev_CreateEffectDriver() returns if there was an error loading FF driver
				hres = DIERR_UNSUPPORTED;
			}
		}
		else
		{
			HINSTANCE hinst = LoadLibrary(TEXT("dinput8.dll"));
			if (hinst)
			{
				typedef HRESULT ( WINAPI * DIRECTINPUT8CREATE) ( HINSTANCE hinst, DWORD dwVersion, REFIID riidltf, LPVOID *ppvOut, LPUNKNOWN punkOuter);
                DIRECTINPUT8CREATE _DirectInput8Create;
				LPDIRECTINPUT8   lpDI;
                _DirectInput8Create = (DIRECTINPUT8CREATE)GetProcAddress(hinst, "DirectInput8Create");
				if (_DirectInput8Create)
				{
					hres = _DirectInput8Create(g_hinst, this->dwDirectInputVersion, &IID_IDirectInput8, &lpDI, NULL );
					if( SUCCEEDED(hres) )
					{
						LPDIRECTINPUTDEVICE8   pdid;
						hres = IDirectInput8_CreateDevice(lpDI, &this->GuidInstance, &pdid, NULL);
						/* Create the device object */
						if( SUCCEEDED(hres) )
						{
							hres = IDirectInputDevice8_EnumObjects
								   (
								   pdid,   
								   DIEnumProc,
								   ped,
								   DIDFT_ALL //DIDFT_FFEFFECTTRIGGER | DIDFT_FFACTUATOR
								   );

							IDirectInput_Release(pdid);
						}
						IDirectInput_Release(lpDI);
					}
				}
				else //!DirectInput8Create
				{
					//Something is horribly wrong here if we can't find the Create fn!
					//Return the same error code that CDIDev_CreateEffectDriver() returns if there was an error loading FF driver
					hres = DIERR_UNSUPPORTED;
				}

				FreeLibrary(hinst);
			}
			else // !hinst
			{
				//Something is horribly wrong here if we came through Dinput but can't load it!
				//Return the same error code that CDIDev_CreateEffectDriver() returns if there was an error loading FF driver
				hres = DIERR_UNSUPPORTED;
			}
		}
    }
    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *      PID_Init
 *
 *      Inits PID device
 *
 *****************************************************************************/

STDMETHODIMP 
    PID_Init
    (
    IDirectInputEffectDriver *ped
    )
{
    HRESULT hres = S_OK;
    CPidDrv *this = (CPidDrv *)ped;
    USHORT LinkCollection;

    EnterProcI( PID_Init, (_"x", ped));

    PID_CreateUsgTxt();

    AssertF( this->hdev == INVALID_HANDLE_VALUE );

    if( SUCCEEDED(hres) )
    {
        this->hdev = CreateFile(this->tszDeviceInterface,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                0,                  /* no SECURITY_ATTRIBUTES */
                                OPEN_EXISTING,
                                0x0,                /* attributes */
                                0);                 /* template */

        if( this->hdev == INVALID_HANDLE_VALUE )
        {
            hres = E_HANDLE;

            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%s:FAIL CreateFile"),
                            s_tszProc );

        }
    }

    if( SUCCEEDED(hres) )
    {
        // Get all the HID goo 
        if( HidD_GetAttributes(this->hdev, &this->attr) &&
            HidD_GetPreparsedData(this->hdev, &this->ppd) &&
            SUCCEEDED(HidP_GetCaps(this->ppd, &this->caps)) )
        {
            // Success
        } else
        {
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%s: FAIL HID init  "),
                            s_tszProc );

            hres = DIERR_PID_NOTINITIALIZED;
        }
    }

    if( SUCCEEDED(hres) )
    {
        // Get collection info
        hres = AllocCbPpv(cbX(*this->pLinkCollection) * this->caps.NumberLinkCollectionNodes,
                          &this->pLinkCollection); 

        if( SUCCEEDED(hres) && (this->pLinkCollection != NULL) )
        {
            ULONG cALinkCollection=this->caps.NumberLinkCollectionNodes;

            hres = HidP_GetLinkCollectionNodes 
                   (
                   this->pLinkCollection, 
                   &cALinkCollection,
                   this->ppd
                   );        
        }
    }

    if(SUCCEEDED(hres) )
    {
        UINT indx;
        this->cbReport[HidP_Input]    =  this->caps.InputReportByteLength;
        this->cbReport[HidP_Output]   =  this->caps.OutputReportByteLength;
        this->cbReport[HidP_Feature]  =  this->caps.FeatureReportByteLength;
		//write reports are output reports
		for( indx = 0x0; indx < MAX_BLOCKS; indx++ )
        {
			this->cbWriteReport[indx]			  =  this->caps.OutputReportByteLength;
		}

        for( indx = 0x0; indx < HidP_Max; indx++ )
        {
            hres = AllocCbPpv(this->cbReport[indx], &this->pReport[indx]);
            if( FAILED(hres) )
            {
                break;
            }
        }
		for( indx = 0x0; indx < MAX_BLOCKS; indx++ )
        {
            hres = AllocCbPpv(this->cbWriteReport[indx], &this->pWriteReport[indx]);
            if( FAILED(hres) )
            {
                break;
            }
        }	
    }

    if( SUCCEEDED(hres) )
    {
        hres = PID_InitRegistry(ped);
    }

    if(SUCCEEDED(PID_GetLinkCollectionIndex(ped,g_PoolReport.UsagePage,g_PoolReport.Collection,0x0,&LinkCollection)))
    {
        PUCHAR pReport =  this->pReport[g_PoolReport.HidP_Type];
        UINT   cbReport = this->cbReport[g_PoolReport.HidP_Type];

        PID_GetReport
            (ped, 
             &g_PoolReport,
             LinkCollection,
             pReport, 
             cbReport 
            );

        PID_ParseReport
            (
            ped,
            &g_PoolReport,
            LinkCollection,
            &this->ReportPool,
            cbX(this->ReportPool),
            pReport,
            cbReport
            );
    }


    SquirtSqflPtszV(sqfl | sqflVerbose,
                    TEXT("%s:RamPoolSz:0x%x"),
                    s_tszProc, this->ReportPool.uRamPoolSz );

    if(SUCCEEDED(PID_GetLinkCollectionIndex(ped,PoolSz.UsagePage,PoolSz.Collection,0x0,&LinkCollection)) )
    {
        PUCHAR pReport =  this->pReport[PoolSz.HidP_Type];
        UINT   cbReport = this->cbReport[PoolSz.HidP_Type];

        PID_GetReport
            (ped, 
             &PoolSz,
             LinkCollection,
             pReport,     
             cbReport 
            );

        PID_ParseReport
            (
            ped,
            &PoolSz,
            LinkCollection,
            &this->SzPool,
            cbX(this->SzPool),
            pReport,
            cbReport
            );
    }


    PID_Support(ped, cA(g_PoolSupport), g_PoolSupport,  &this->uDeviceManaged);

    // Determine max number of parameter blocks per effect ? 
    if( SUCCEEDED(hres)  )
    {
        USHORT LinkCollection;
        hres = PID_GetLinkCollectionIndex(ped, HID_USAGE_PAGE_PID, HID_USAGE_PID_TYPE_SPECIFIC_BLOCK_OFFSET, 0x0, &LinkCollection );

        if( SUCCEEDED(hres) )
        {
            USHORT cAValCaps;
            cAValCaps = 0x0;

            HidP_GetSpecificValueCaps 
                (
                HidP_Output,
                HID_USAGE_PAGE_ORDINALS,
                LinkCollection,
                0x0,
                NULL,
                &cAValCaps,
                this->ppd
                );
            this->cMaxParameters = cAValCaps;
        } else
        {
            this->cMaxParameters = 0x2;
            hres = S_OK;
        }
    }


    if( SUCCEEDED(hres))
    {
        hres = PID_InitSharedMem(ped);
    }

    if( SUCCEEDED(hres ) )
    {
        hres = PID_InitScaling(ped);
    }

    if( SUCCEEDED(hres) )
    {
        // Determine Max effects that can be downloaded to the device
        HIDP_VALUE_CAPS ValCaps;
        USHORT  cAValCaps   = 0x1;
        USAGE   UsagePage   = DIGETUSAGEPAGE(g_BlockIndex.rgPidUsage[0].dwUsage);
        USAGE   Usage       = DIGETUSAGE(g_BlockIndex.rgPidUsage[0].dwUsage);      
        hres = HidP_GetSpecificValueCaps
               (
               g_BlockIndex.HidP_Type,
               UsagePage,
               0x0,
               Usage,
               &ValCaps,
               &cAValCaps,
               this->ppd
               );

        if( SUCCEEDED(hres) || ( hres == HIDP_STATUS_BUFFER_TOO_SMALL ) )
        {
            hres = S_OK;
            this->cMaxEffects = (USHORT) ( ValCaps.PhysicalMax - ValCaps.PhysicalMin );
        } else
        {
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%s: FAIL HidP_GetValCaps for  (%x %x:%s) "),
                            s_tszProc , UsagePage, Usage, PIDUSAGETXT(UsagePage,Usage) );
        }
    }

    this->cMaxEffects = (USHORT)min(this->cMaxEffects, 
                                    GLOBAL_EFFECT_MEMSZ / ((FIELD_OFFSET(EFFECTSTATE,PidMem)) + this->cMaxParameters*cbX(PIDMEM)) );


    if( this->ReportPool.uSimulEfMax == 0x0 )
    {
        this->ReportPool.uSimulEfMax  = 0xff;

        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%s: FAIL HID dwSimulEfMax == 0x0 defaults to %d  "),
                        s_tszProc, this->cMaxEffects );
    }


    if( SUCCEEDED(hres) )
    {
        TCHAR tsz[MAX_PATH];

        AssertF(this->hThread == 0x0 );
		AssertF(this->hWrite == 0x0);
		AssertF(this->hWriteComplete == 0x0);

        if( GetModuleFileName(g_hinst, tsz, cA(tsz))
            &&LoadLibrary(tsz) == g_hinst)
        {
            InterlockedIncrement(&this->cThreadRef);
            AssertF(this->cThreadRef == 0x1 );
            AssertF(this->hThread == 0x0 );

			this->hWrite = CreateEvent(NULL, FALSE, FALSE, NULL);
			if (this->hWrite == 0x0)
			{
				goto event_thread_error;
			}
			this->hWriteComplete = CreateEvent(NULL, TRUE, TRUE, NULL);
			if (this->hWriteComplete == 0x0)
			{
				goto event_thread_error;
			}
            this->hThread= CreateThread(0, 0, (LPTHREAD_START_ROUTINE)PID_ThreadProc, this,
                                        0, &this->idThread);
		
            if (this->hThread == 0x0)
            {
event_thread_error:;
				//close the event handles
				if (this->hWrite != 0x0)
				{
					CloseHandle(this->hWrite);
					this->hWrite = 0x0;
				}
				if (this->hWriteComplete != 0x0)
				{
					CloseHandle(this->hWriteComplete);
					this->hWriteComplete = 0x0;
				}

                hres = DIERR_PID_NOTINITIALIZED;
                FreeLibrary(g_hinst);
                InterlockedDecrement(&this->cThreadRef);
            }
        }
    }

    ExitOleProc();
    return hres;
}



/*****************************************************************************
 *
 *      PID_Finalize
 *
 *      Destroys PID device specific memory
 *
 *****************************************************************************/
STDMETHODIMP 
    PID_Finalize
    (
    IDirectInputEffectDriver *ped
    )
{
    HRESULT hres = S_OK;
    CPidDrv *this = (CPidDrv *)ped;
    HANDLE hdev;    
    UINT indx;

    EnterProc( PID_Finalize, (_"x", ped));

    DllEnterCrit();

    // Assasinate the thread
	InterlockedDecrement(&this->cThreadRef);

    AssertF(this->cThreadRef == 0x0 );
    // Wait for the thread to die before we go about releasing
    // memory

    do
    {
		DWORD dwWait;

        NudgeWorkerThread(this->idThread);
        Sleep(0);

		dwWait = WaitForSingleObject(this->hThread, 500 ) ;

        if( WAIT_TIMEOUT == dwWait)
        {
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%s: Waiting for worker Thread %d to die"),
                            s_tszProc,this->idThread );
        }

		//if didn't timeout, and thread didn't die, then we can get into an infinite loop.
		//so close the handle.
		if ((WAIT_ABANDONED == dwWait) || (WAIT_FAILED == dwWait))
		{
			if( this->hdevOvrlp != INVALID_HANDLE_VALUE )
			{
				HANDLE hdevOvr;
				hdevOvr = this->hdevOvrlp;
				this->hdevOvrlp = INVALID_HANDLE_VALUE;
				CancelIo_(hdevOvr);
				Sleep(0);
				CloseHandle(hdevOvr);
			}

			AssertF(this->hdevOvrlp == INVALID_HANDLE_VALUE);

		}

    }while( this->hdevOvrlp != INVALID_HANDLE_VALUE );

    // Close the handle 
    if( this->hdev != INVALID_HANDLE_VALUE)
    {
        hdev = this->hdev;
        this->hdev = INVALID_HANDLE_VALUE;
        CloseHandle(hdev);
    }

    // Free PreParseData
    if( this->ppd )
    {
        HidD_FreePreparsedData(this->ppd);
        this->ppd = NULL;
    }

    // Free HIDP_VALUE_CAPS data
    FreePpv(&this->rgFFUsageInst);
    FreePpv(&this->pLinkCollection);

    for(indx = 0x0; indx < HidP_Max; indx++ )
    {
        FreePpv(&this->pReport[indx]);
    }
	for(indx = 0x0; indx < MAX_BLOCKS; indx++ )
    {
        FreePpv(&this->pWriteReport[indx]);
    }

    DllLeaveCrit();
    ExitOleProc();
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\pid\daytona\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\pid\pidrd.c ===
/*****************************************************************************
 *
 *  PidRd.c
 *
 *  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *
 *
 *  Abstract:
 *
 *      Read input data from PID device .
 *
 *****************************************************************************/

#include "pidpr.h"

#define sqfl    (sqflRead)

BOOL INTERNAL
    PID_IssueRead(PCPidDrv this);

BOOL INTERNAL
    PID_IssueWrite(PCPidDrv this);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PCHID | pchidFromPo |
 *
 *          Given an interior pointer to an <t OVERLAPPED>, retrieve
 *          a pointer to the parent <t CHid>.
 *
 *  @parm   LPOVERLAPPED | po |
 *
 *          The pointer to convert.
 *
 *****************************************************************************/

PCPidDrv INLINE
    pCPidDrvFromPo(LPOVERLAPPED po)
{
    return (CPidDrv*) pvSubPvCb(po, FIELD_OFFSET(CPidDrv, o));
}

void CALLBACK
    PID_ReadComplete(DWORD dwError, DWORD cbRead, LPOVERLAPPED po)
{
    PCPidDrv this = pCPidDrvFromPo(po);

    //EnterProc( PID_ReadComplete, (_"xxx", dwError, cbRead, po ));

    if( !IsBadReadPtr(this, cbX(this))
        &&this->cThreadRef
        && dwError == 0
        //&&( this->o.InternalHigh == this->cbReport[HidP_Input] )
        &&( this->hdevOvrlp != INVALID_HANDLE_VALUE ) )
    {
		HRESULT hres;
		PUCHAR  pReport;
		UINT    cbReport;

		USHORT  LinkCollection = 0x0;
		USAGE   rgUsages[MAX_BUTTONS] ;
		USAGE   UsagePage   =   HID_USAGE_PAGE_PID;
		ULONG   cAUsages    =  MAX_BUTTONS;
		BOOL    fEffectPlaying = FALSE;
		LONG    lEffectIndex;

		pReport  = this->pReport[HidP_Input];
		cbReport = this->cbReport[HidP_Input];
	
		// If the report does not belong to the PID usage page
		// we should be out of here really quick.
		hres = HidP_GetUsages
				   (HidP_Input,
					UsagePage,
					LinkCollection,
					rgUsages,
					&cAUsages,
					this->ppd,
					pReport,
					cbReport
				   );
		if( SUCCEEDED(hres ) )
		{
			UINT indx;
			DWORD dwState =  DIGFFS_ACTUATORSOFF | DIGFFS_USERFFSWITCHOFF | DIGFFS_POWEROFF | DIGFFS_SAFETYSWITCHOFF;
			for(indx = 0x0; indx < cAUsages; indx++ )
			{
				USAGE Usage = rgUsages[indx];
				switch(Usage)
				{
				case HID_USAGE_PID_EFFECT_PLAYING:
					fEffectPlaying = TRUE;
					break;
				case  HID_USAGE_PID_DEVICE_PAUSED:
					dwState |= DIGFFS_PAUSED;
					break;
				case  HID_USAGE_PID_ACTUATORS_ENABLED:
					dwState |= DIGFFS_ACTUATORSON;
					dwState &= ~(DIGFFS_ACTUATORSOFF);
					break;
				case  HID_USAGE_PID_ACTUATOR_OVERRIDE_SWITCH:
					dwState |= DIGFFS_USERFFSWITCHON;
					dwState &= ~(DIGFFS_USERFFSWITCHOFF);
					break;
				case  HID_USAGE_PID_SAFETY_SWITCH:
					dwState |= DIGFFS_SAFETYSWITCHON;
					dwState &= ~(DIGFFS_SAFETYSWITCHOFF);
					break;
				case  HID_USAGE_PID_ACTUATOR_POWER:
					dwState |= DIGFFS_POWERON;
					dwState &= ~(DIGFFS_POWEROFF);
					break;
				default:
					SquirtSqflPtszV(sqfl | sqflVerbose,
										TEXT("%s: Unsupported input status usage (%x,%x:%s) "),
										TEXT("PID_ReadComplete"),
										UsagePage, Usage,
										PIDUSAGETXT(UsagePage,Usage) );

					break;
				}

				this->dwState = dwState;
			}

			hres = PID_ParseReport(
									  &this->ed,
									  &g_BlockIndexIN,
									  LinkCollection,
									  &lEffectIndex,
									  cbX(lEffectIndex),
									  pReport,
									  cbReport
									  );

			if( SUCCEEDED(hres) )
			{
				PEFFECTSTATE    pEffectState =  PeffectStateFromBlockIndex(this,lEffectIndex);

				if(fEffectPlaying)
				{
					pEffectState->lEfState |= DIEGES_PLAYING;
				} else
				{
					pEffectState->lEfState &= ~(DIEGES_PLAYING);
				}
			}
		}

        // Issue another read
        PID_IssueRead(this);
    } else
    {
        // Boo!
    }
    //ExitProc();
}


BOOL INTERNAL
    PID_IssueRead(PCPidDrv this)
{
    BOOL fRc = FALSE;

    if(  !IsBadReadPtr(this, cbX(this))
       && this->cThreadRef )
    {
        fRc = ReadFileEx(this->hdevOvrlp, this->pReport[HidP_Input],
                         this->cbReport[HidP_Input], &this->o,
                         PID_ReadComplete);
        if (fRc == FALSE)
		{
			SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("FAIL ReadFileEx"));
        }
    }
	else
	{
		RPF(TEXT("Bad this pointer or thread ref count!"));
	}
    return fRc;
}


void CALLBACK
    PID_WriteComplete(DWORD dwError, DWORD cbWritten, LPOVERLAPPED po)
{
    PCPidDrv this = pCPidDrvFromPo(po);

    //EnterProc( PID_ReadComplete, (_"xxx", dwError, cbRead, po ));

    if( !IsBadReadPtr(this, cbX(this))
        &&(this->cThreadRef)
        //&&( this->o.InternalHigh == this->cbWriteReport[this->blockNr] )
		&&(this->hWriteComplete)
		&&(this->hWrite)
        &&( this->hdevOvrlp != INVALID_HANDLE_VALUE ) )
    {
		//if we didn't get an error & wrote everything -- or if we already tried
		//twice -- we move on
		if ( ((dwError == 0) && (cbWritten == this->cbWriteReport [this->blockNr]))
			|| (this->dwWriteAttempt != 0)
			)
		{
			//print a message if couldn't write a particular block
			if ((dwError != 0) || (cbWritten != this->cbWriteReport [this->blockNr]))
			{
                SquirtSqflPtszV(sqfl | sqflError,
                    TEXT("Couldn't write block %u after two tries, giving up on this block."), 
                    this->blockNr);
			}
			//move on
			this->dwWriteAttempt = 0;
			this->blockNr++;
			if (this->blockNr < this->totalBlocks)
			{
				//write the next block
				if (PID_IssueWrite(this) == FALSE)
				{
					//in case of failure, the callback will never be called and the completion event never set,
					//so need to set it here.
					SetEvent(this->hWriteComplete);
				}
			}
			else
			{
				//we are done w/ this update
				AssertF(this->blockNr == this->totalBlocks);
				SetEvent(this->hWriteComplete);
			}
		}
		else
		{
			//this is the first time we tried to write a particular block, and we failed;
			//we will try once more
            SquirtSqflPtszV(sqfl | sqflBenign,
                TEXT("Couldn't write block %u on first attempt, retrying."), 
                this->blockNr);
			this->dwWriteAttempt = 1;
			if (PID_IssueWrite(this) == FALSE)
			{
				//in case of failure, the callback will never be called and the completion event never set,
				//so need to set it here.
				this->dwWriteAttempt = 0;
				SetEvent(this->hWriteComplete);
			}
		}
    } else
    {
        //need to set the completion event, otherwise we will keep waiting...
		RPF(TEXT("Bad this pointer or thread ref count or handle!"));
		this->dwWriteAttempt = 0;
		SetEvent(this->hWriteComplete);
    }
    //ExitProc();
}


BOOL INTERNAL
    PID_IssueWrite(PCPidDrv this)
{
    BOOL fRc = FALSE;
	
    if(  !IsBadReadPtr(this, cbX(this))
       && this->cThreadRef )
    {
        fRc = WriteFileEx(this->hdevOvrlp, this->pWriteReport[this->blockNr],
                         this->cbWriteReport[this->blockNr], &this->o,
                         PID_WriteComplete);
		if (fRc == FALSE)
		{
			SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("FAIL WriteFileEx"));
        }
    }
	else
	{
		RPF(TEXT("Bad this pointer or thread ref count!"));
	}
    return fRc;
}

VOID INTERNAL
    PID_ThreadProc(CPidDrv* this)
{
    MSG msg;

    EnterProc( PID_ThreadProc, (_"x", this ));
    AssertF(this->hdevOvrlp == INVALID_HANDLE_VALUE );

    this->hdevOvrlp = CreateFile(this->tszDeviceInterface,
                                 GENERIC_READ | GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 0,                      /* no SECURITY_ATTRIBUTES */
                                 OPEN_EXISTING,
                                 FILE_FLAG_OVERLAPPED,   /* attributes */
                                 0);                     /* template */


    if( this->hdevOvrlp == INVALID_HANDLE_VALUE )
    {
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%s:FAIL CreateFile(OverLapped)"),
                        s_tszProc );
    }
	else
	//fix for mb 35282 -- no use calling PID_IssueRead() w/ an INVALID_HANDLE_VALUE for a file handle
	{

		if( PID_IssueRead(this) )
		{
			do
			{
				DWORD dwRc;
				do
				{
					AssertF(this->hWrite != 0x0);
					AssertF(this->hWriteComplete != 0x0);

					dwRc = MsgWaitForMultipleObjectsEx(1, &this->hWrite, INFINITE, QS_ALLINPUT,
													   MWMO_ALERTABLE);

					if (dwRc == WAIT_OBJECT_0)
					{
						if (PID_IssueWrite(this) == FALSE)
						{
							//in case of failure, the callback will never be called and the completion event never set,
							//so need to set it here.
							SetEvent(this->hWriteComplete);
						}
					}

				} while ((dwRc == WAIT_IO_COMPLETION) || (dwRc == WAIT_OBJECT_0));

				while(PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
				{
					TranslateMessage(&msg);
					DispatchMessage(&msg);
				}

			} while(this->cThreadRef);

			if( this->hdevOvrlp != INVALID_HANDLE_VALUE )
			{
				HANDLE hdev;
				hdev = this->hdevOvrlp;
                                this->hdevOvrlp = INVALID_HANDLE_VALUE;
				CancelIo_(hdev);
				Sleep(0);
				CloseHandle(hdev);
			}
		}
	}

	//close the event handles as well
	if (this->hWrite != 0x0)
	{
		CloseHandle(this->hWrite);
		this->hWrite = 0x0;
	}
	if (this->hWriteComplete != 0x0)
	{
		CloseHandle(this->hWriteComplete);
		this->hWriteComplete = 0x0;
	}

    if(this->hThread)
    {
        HANDLE hdev = this->hThread;
        this->hThread = NULL;
        CloseHandle(hdev);
    }


    FreeLibraryAndExitThread(g_hinst, 0);
    ExitProc();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\pid\win9x\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\pid\sources.inc ===
!ifndef DXROOT
DXROOT=$(BASEDIR)\MultiMedia\DirectX
!endif

!INCLUDE $(DXROOT)\Project.mk
MAJORCOMP=windows
MINORCOMP=media
UMTYPE=windows

TARGETNAME=pid
TARGETTYPE=DYNLINK
TARGETPATH=obj

!ifndef DXROOT
DXROOT=..\..
!endif

INCLUDES=$(INCLUDES); \
         ..\; \
         $(DXROOT)\inc;\

NTTARGETFILES=

#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           $(SDK_LIB_PATH)\kernel32.lib     \
	   $(SDK_LIB_PATH)\advapi32.lib     \
	   $(SDK_LIB_PATH)\user32.lib       \
           $(SDK_LIB_PATH)\hid.lib          \
           $(SDK_LIB_PATH)\uuid.lib         \

DLLENTRY=DllEntryPoint

LINKER_FLAGS=-SECTION:share,RWS

SOURCES=                \
        ..\pid.rc       \
        ..\assert.c     \
        ..\clsfact.c    \
        ..\dimem.c      \
        ..\effdrv.c     \
        ..\guids.c      \
        ..\main.c       \
        ..\pidHid.c     \
        ..\pidOp.c      \
        ..\pidParam.c   \
        ..\pideff.c     \
        ..\pidinit.c    \
        ..\pidreg.c     \
        ..\pidrd.c      \
        ..\usgtxt.c     \

DLLDEF=..\pid.def

PRECOMPILED_INCLUDE=..\PIDpr.h         

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\pid\pidusg.h ===
#include "hidusage.h"

#ifndef HID_USAGE_PAGE_ORDINALS
    #define HID_USAGE_PAGE_ORDINALS                         ((USAGE) 0x0A)
#endif


#define HID_USAGE_PAGE_PID                                  ((USAGE) 0x0F)

#define HID_USAGE_PID_PHYSICAL_INTERFACE_DEVICE             ((USAGE) 0x01) 


#define HID_USAGE_PID_NORMAL                                ((USAGE) 0x20) 
#define HID_USAGE_PID_SET_EFFECT_REPORT                     ((USAGE) 0x21)
#define HID_USAGE_PID_EFFECT_BLOCK_INDEX                    ((USAGE) 0x22)
#define HID_USAGE_PID_PARAMETER_BLOCK_OFFSET                ((USAGE) 0x23)
#define HID_USAGE_PID_ROM_FLAG                              ((USAGE) 0x24)
#define HID_USAGE_PID_EFFECT_TYPE                           ((USAGE) 0x25)
#define HID_USAGE_PID_ET_CONSTANT                           ((USAGE) 0x26)
#define HID_USAGE_PID_ET_RAMP                               ((USAGE) 0x27)
#define HID_USAGE_PID_ET_CUSTOM                             ((USAGE) 0x28)


#define HID_USAGE_PID_ET_SQUARE                             ((USAGE) 0x30)
#define HID_USAGE_PID_ET_SINE                               ((USAGE) 0x31)
#define HID_USAGE_PID_ET_TRIANGLE                           ((USAGE) 0x32)
#define HID_USAGE_PID_ET_SAWTOOTH_UP                        ((USAGE) 0x33)
#define HID_USAGE_PID_ET_SAWTOOTH_DOWN                      ((USAGE) 0x34)


#define HID_USAGE_PID_ET_SPRING                             ((USAGE) 0x40)
#define HID_USAGE_PID_ET_DAMPER                             ((USAGE) 0x41)
#define HID_USAGE_PID_ET_INERTIA                            ((USAGE) 0x42)
#define HID_USAGE_PID_ET_FRICTION                           ((USAGE) 0x43)



#define HID_USAGE_PID_DURATION                              ((USAGE) 0x50)
#define HID_USAGE_PID_SAMPLE_PERIOD                         ((USAGE) 0x51)
#define HID_USAGE_PID_GAIN                                  ((USAGE) 0x52)
#define HID_USAGE_PID_TRIGGER_BUTTON                        ((USAGE) 0x53)
#define HID_USAGE_PID_TRIGGER_REPEAT_INTERVAL               ((USAGE) 0x54)
#define HID_USAGE_PID_AXES_ENABLE                           ((USAGE) 0x55)
#define HID_USAGE_PID_DIRECTION_ENABLE                      ((USAGE) 0x56)
#define HID_USAGE_PID_DIRECTION                             ((USAGE) 0x57)
#define HID_USAGE_PID_TYPE_SPECIFIC_BLOCK_OFFSET            ((USAGE) 0x58)
#define HID_USAGE_PID_BLOCK_TYPE                            ((USAGE) 0x59)
#define HID_USAGE_PID_SET_ENVELOPE_REPORT                   ((USAGE) 0x5A)
#define HID_USAGE_PID_ATTACK_LEVEL                          ((USAGE) 0x5B)
#define HID_USAGE_PID_ATTACK_TIME                           ((USAGE) 0x5C)
#define HID_USAGE_PID_FADE_LEVEL                            ((USAGE) 0x5D)
#define HID_USAGE_PID_FADE_TIME                             ((USAGE) 0x5E)
#define HID_USAGE_PID_SET_CONDITION_REPORT                  ((USAGE) 0x5F)


#define HID_USAGE_PID_CP_OFFSET                             ((USAGE) 0x60)
#define HID_USAGE_PID_POSITIVE_COEFFICIENT                  ((USAGE) 0x61)
#define HID_USAGE_PID_NEGATIVE_COEFFICIENT                  ((USAGE) 0x62)
#define HID_USAGE_PID_POSITIVE_SATURATION                   ((USAGE) 0x63)
#define HID_USAGE_PID_NEGATIVE_SATURATION                   ((USAGE) 0x64)
#define HID_USAGE_PID_DEAD_BAND                             ((USAGE) 0x65)
#define HID_USAGE_PID_DOWNLOAD_FORCE_SAMPLE                 ((USAGE) 0x66)
#define HID_USAGE_PID_ISOCH_CUSTOM_FORCE_ENABLE             ((USAGE) 0x67)
#define HID_USAGE_PID_CUSTOM_FORCE_DATA_REPORT              ((USAGE) 0x68)
#define HID_USAGE_PID_CUSTOM_FORCE_DATA                     ((USAGE) 0x69)
#define HID_USAGE_PID_CUSTOM_FORCE_VENDOR_DEFINED           ((USAGE) 0x6A)
#define HID_USAGE_PID_SET_CUSTOM_FORCE_REPORT               ((USAGE) 0x6B)
#define HID_USAGE_PID_CUSTOM_FORCE_DATA_OFFSET				((USAGE) 0x6C)
#define HID_USAGE_PID_SAMPLE_COUNT                          ((USAGE) 0x6D)
#define HID_USAGE_PID_SET_PERIODIC_REPORT                   ((USAGE) 0x6E)
#define HID_USAGE_PID_OFFSET                                ((USAGE) 0x6F)


#define HID_USAGE_PID_MAGNITUDE                             ((USAGE) 0x70)
#define HID_USAGE_PID_PHASE                                 ((USAGE) 0x71)
#define HID_USAGE_PID_PERIOD                                ((USAGE) 0x72)
#define HID_USAGE_PID_SET_CONSTANT_FORCE_REPORT             ((USAGE) 0x73)
#define HID_USAGE_PID_SET_RAMP_FORCE_REPORT                 ((USAGE) 0x74)
#define HID_USAGE_PID_RAMP_START                            ((USAGE) 0x75)
#define HID_USAGE_PID_RAMP_END                              ((USAGE) 0x76)
#define HID_USAGE_PID_EFFECT_OPERATION_REPORT               ((USAGE) 0x77)
#define HID_USAGE_PID_EFFECT_OPERATION                      ((USAGE) 0x78)
#define HID_USAGE_PID_OP_EFFECT_START                       ((USAGE) 0x79)
#define HID_USAGE_PID_OP_EFFECT_START_SOLO                  ((USAGE) 0x7A)
#define HID_USAGE_PID_OP_EFFECT_STOP                        ((USAGE) 0x7B)
#define HID_USAGE_PID_LOOP_COUNT                            ((USAGE) 0x7C)
#define HID_USAGE_PID_DEVICE_GAIN_REPORT                    ((USAGE) 0x7D)
#define HID_USAGE_PID_DEVICE_GAIN                           ((USAGE) 0x7E)
#define HID_USAGE_PID_POOL_REPORT                           ((USAGE) 0x7F)


#define HID_USAGE_PID_RAM_POOL_SIZE                         ((USAGE) 0x80)
#define HID_USAGE_PID_ROM_POOL_SIZE                         ((USAGE) 0x81)
#define HID_USAGE_PID_ROM_EFFECT_BLOCK_COUNT                ((USAGE) 0x82)
#define HID_USAGE_PID_SIMULTANEOUS_EFFECTS_MAX              ((USAGE) 0x83)
#define HID_USAGE_PID_POOL_ALIGNMENT                        ((USAGE) 0x84)
#define HID_USAGE_PID_POOL_MOVE_REPORT                      ((USAGE) 0x85)
#define HID_USAGE_PID_MOVE_SOURCE                           ((USAGE) 0x86)
#define HID_USAGE_PID_MOVE_DESTINATION                      ((USAGE) 0x87)
#define HID_USAGE_PID_MOVE_LENGTH                           ((USAGE) 0x88)
#define HID_USAGE_PID_BLOCK_LOAD_REPORT                     ((USAGE) 0x89)
#define HID_USAGE_PID_HANDSHAKE_KEY                         ((USAGE) 0x8A)
#define HID_USAGE_PID_BLOCK_LOAD_STATUS                     ((USAGE) 0x8B)
#define HID_USAGE_PID_BLOCK_LOAD_SUCCESS                    ((USAGE) 0x8C)
#define HID_USAGE_PID_BLOCK_LOAD_FULL                       ((USAGE) 0x8D)
#define HID_USAGE_PID_BLOCK_LOAD_ERROR                      ((USAGE) 0x8E)
#define HID_USAGE_PID_BLOCK_HANDLE                          ((USAGE) 0x8F)


#define HID_USAGE_PID_BLOCK_FREE_REPORT                     ((USAGE) 0x90)
#define HID_USAGE_PID_TYPE_SPECIFIC_BLOCK_HANDLE            ((USAGE) 0x91)
#define HID_USAGE_PID_STATE_REPORT                          ((USAGE) 0x92)
#define HID_USAGE_PID_EFFECT_STATE                          ((USAGE) 0x93)
#define HID_USAGE_PID_EFFECT_PLAYING                        ((USAGE) 0x94)

#define HID_USAGE_PID_DEVICE_CONTROL                        ((USAGE) 0x96)
#define HID_USAGE_PID_DC_ENABLE_ACTUATORS                   ((USAGE) 0x97)
#define HID_USAGE_PID_DC_DISABLE_ACTUATORS                  ((USAGE) 0x98)
#define HID_USAGE_PID_DC_STOP_ALL_EFFECTS                   ((USAGE) 0x99)
#define HID_USAGE_PID_DC_DEVICE_RESET                       ((USAGE) 0x9A)
#define HID_USAGE_PID_DC_DEVICE_PAUSE                       ((USAGE) 0x9B)
#define HID_USAGE_PID_DC_DEVICE_CONTINUE                    ((USAGE) 0x9C)

#define HID_USAGE_PID_DEVICE_PAUSED                         ((USAGE) 0x9F)


#define HID_USAGE_PID_ACTUATORS_ENABLED                     ((USAGE) 0xA0)

#define HID_USAGE_PID_SAFETY_SWITCH                         ((USAGE) 0xA4)
#define HID_USAGE_PID_ACTUATOR_OVERRIDE_SWITCH              ((USAGE) 0xA5)
#define HID_USAGE_PID_ACTUATOR_POWER                        ((USAGE) 0xA6)
#define HID_USAGE_PID_START_DELAY                           ((USAGE) 0xA7)
#define HID_USAGE_PID_PARAMETER_BLOCK_SIZE                  ((USAGE) 0xA8)
#define HID_USAGE_PID_DEVICE_MANAGED_POOL                   ((USAGE) 0xA9)
#define HID_USAGE_PID_SHARED_PARAMETER_BLOCKS               ((USAGE) 0xAA)
#define HID_USAGE_PID_CREATE_NEW_EFFECT                     ((USAGE) 0xAB)
#define HID_USAGE_PID_RAMPOOL_AVAILABLE                     ((USAGE) 0xAC)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\pid\pidreg.c ===
/*****************************************************************************
 *
 *  PidReg.c
 *
 *  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Update registry information for PID device.
 *
 *****************************************************************************/

#include "pidpr.h"

#define sqfl            ( sqflReg )

#pragma BEGIN_CONST_DATA
/*
;---------------------------------------
;
;   Force feedback registry settings for GUID_Sine.
;
;   GUID_Sine is a predefined GUID; applications which want
;   to use a sine effect independent of hardware will
;   request a GUID_Sine.
;
;   The default value is the friendly name for the effect.
;
HKLM,%KEY_OEM%\XYZZY.FFDrv1\OEMForceFeedback\Effects\%GUID_Sine%,,,"%Sine.Desc%"
;
;   The Attributes value contains a DIEFFECTATTRIBUTES structure.
;
;   The effect ID is the number that is passed by DirectInput to the
;   effect driver to identify the effect (thereby saving the effect
;   driver the trouble of parsing GUIDs all the time).
;
;   Our effect is a periodic effect whose optional envelope
;   supports attack and fade.
;
;   Our hardware supports changing the following parameters when
;   the effect is not playing (static): Duration, gain, trigger button,
;   axes, direction, envelope, type-specific parameters.  We do not
;   support sample period or trigger repeat interval.
;
;   Our hardware does not support changing any parameters while an
;   effect is playing (dynamic).
;
;   Our hardware prefers receiving multiple-axis direction information
;   in polar coordinates.
;
;   dwEffectId      = EFFECT_SINE
;                   = 723               = D3,02,00,00
;   dwEffType       = DIEFT_PERIODIC | DIEFT_FFATTACK | DIEFT_FFFADE | DIEFT_STARTDELAY
;                   = 0x00000603        = 03,06,00,00
;   dwStaticParams  = DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON |
;                     DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE |
;                     DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY
;                   = 0x000001ED        = ED,01,00,00
;   dwDynamicParams = 0x00000000        = 00,00,00,00
;   dwCoords        = DIEFF_POLAR
;                   = 0x00000020        = 20,00,00,00
*/
static EFFECTMAPINFO g_EffectMapInfo[] =
{
    {
        PIDMAKEUSAGEDWORD(ET_CONSTANT),
        DIEFT_CONSTANTFORCE | DIEFT_FFATTACK | DIEFT_FFFADE | DIEFT_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL | DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL | DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEFF_POLAR,
        &GUID_ConstantForce,
        TEXT("GUID_ConstantForce"),
    },

    {
        PIDMAKEUSAGEDWORD(ET_RAMP),
        DIEFT_RAMPFORCE | DIEFT_FFATTACK | DIEFT_FFFADE | DIEFT_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL | DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL | DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEFF_POLAR,
        &GUID_RampForce,
        TEXT("GUID_RampForce"),
    },

    {
        PIDMAKEUSAGEDWORD(ET_SQUARE),
        DIEFT_PERIODIC | DIEFT_FFATTACK | DIEFT_FFFADE | DIEFT_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL |  DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL |  DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEFF_POLAR,
        &GUID_Square,
        TEXT("GUID_Square"),
    },

    {
        PIDMAKEUSAGEDWORD(ET_SINE),
        DIEFT_PERIODIC | DIEFT_FFATTACK | DIEFT_FFFADE | DIEFT_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL |  DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL |  DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEFF_POLAR,
        &GUID_Sine,
        TEXT("GUID_Sine"),
    },

    {
        PIDMAKEUSAGEDWORD(ET_TRIANGLE),
        DIEFT_PERIODIC | DIEFT_FFATTACK | DIEFT_FFFADE | DIEFT_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL |  DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL |  DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEFF_POLAR,
        &GUID_Triangle,
        TEXT("GUID_Triangle"),
    },

    {
        PIDMAKEUSAGEDWORD(ET_SAWTOOTH_UP),
        DIEFT_PERIODIC | DIEFT_FFATTACK | DIEFT_FFFADE | DIEFT_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL |  DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL |  DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEFF_POLAR,
        &GUID_SawtoothUp,
        TEXT("GUID_SawtoothUp"),
    },

    {
        PIDMAKEUSAGEDWORD(ET_SAWTOOTH_DOWN),
        DIEFT_PERIODIC | DIEFT_FFATTACK | DIEFT_FFFADE | DIEFT_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL |  DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL |  DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEFF_POLAR,
        &GUID_SawtoothDown,
        TEXT("GUID_SawtoothDown"),
    },

    {
        PIDMAKEUSAGEDWORD(ET_SPRING),
        DIEFT_CONDITION | DIEFT_SATURATION | DIEFT_DEADBAND | DIEFT_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN |  DIEP_AXES | DIEP_DIRECTION | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN |  DIEP_AXES | DIEP_DIRECTION | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEFF_POLAR,
        &GUID_Spring,
        TEXT("GUID_Spring"),
    },

    {
        PIDMAKEUSAGEDWORD(ET_DAMPER),
        DIEFT_CONDITION | DIEFT_SATURATION | DIEFT_DEADBAND | DIEFT_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN |  DIEP_AXES | DIEP_DIRECTION | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN |  DIEP_AXES | DIEP_DIRECTION | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEFF_POLAR,
        &GUID_Damper,
        TEXT("GUID_Damper"),
    },

    {
        PIDMAKEUSAGEDWORD(ET_INERTIA),
        DIEFT_CONDITION | DIEFT_SATURATION | DIEFT_DEADBAND | DIEFT_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN |  DIEP_AXES | DIEP_DIRECTION | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN |  DIEP_AXES | DIEP_DIRECTION | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEFF_POLAR,
        &GUID_Inertia,
        TEXT("GUID_Inertia"),
    },

    {
        PIDMAKEUSAGEDWORD(ET_FRICTION),
        DIEFT_CONDITION | DIEFT_SATURATION | DIEFT_DEADBAND | DIEFT_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN |  DIEP_AXES | DIEP_DIRECTION | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN |  DIEP_AXES | DIEP_DIRECTION | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEFF_POLAR,
        &GUID_Friction,
        TEXT("GUID_Friction"),
    },


    {
        PIDMAKEUSAGEDWORD(ET_CUSTOM),
        DIEFT_CUSTOMFORCE | DIEFT_SATURATION | DIEFT_DEADBAND | DIEFT_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL |  DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEP_DURATION | DIEP_GAIN | DIEP_TRIGGERBUTTON | DIEP_TRIGGERREPEATINTERVAL |  DIEP_AXES | DIEP_DIRECTION | DIEP_ENVELOPE | DIEP_TYPESPECIFICPARAMS | DIEP_STARTDELAY,
        DIEFF_POLAR,
        &GUID_CustomForce,
        TEXT("GUID_CustomForce"),
    },
};


static PIDSUPPORT g_DIeft[] =
{
    {DIEFT_CONSTANTFORCE,           PIDMAKEUSAGEDWORD(SET_CONSTANT_FORCE_REPORT),   HID_COLLECTION, 0x0},
    {DIEFT_RAMPFORCE,               PIDMAKEUSAGEDWORD(SET_RAMP_FORCE_REPORT),       HID_COLLECTION, 0x0},
    {DIEFT_PERIODIC,                PIDMAKEUSAGEDWORD(SET_PERIODIC_REPORT),         HID_COLLECTION, 0x0},
    {DIEFT_CONDITION,               PIDMAKEUSAGEDWORD(SET_CONDITION_REPORT),        HID_COLLECTION, 0x0},
    {DIEFT_CUSTOMFORCE,             PIDMAKEUSAGEDWORD(SET_CUSTOM_FORCE_REPORT),     HID_COLLECTION, 0x0},
    //{DIEFT_HARDWARE,              ????                                                   },
    {DIEFT_FFATTACK,                PIDMAKEUSAGEDWORD(ATTACK_LEVEL),                HID_VALUE,      HidP_Output},
    {DIEFT_FFFADE,                  PIDMAKEUSAGEDWORD(FADE_LEVEL),                  HID_VALUE,      HidP_Output},
    {DIEFT_SATURATION,              PIDMAKEUSAGEDWORD(POSITIVE_SATURATION),         HID_VALUE,      HidP_Output},
    {DIEFT_POSNEGCOEFFICIENTS,      PIDMAKEUSAGEDWORD(NEGATIVE_COEFFICIENT),        HID_VALUE,      HidP_Output},
    {DIEFT_POSNEGSATURATION,        PIDMAKEUSAGEDWORD(NEGATIVE_SATURATION),         HID_VALUE,      HidP_Output},
    {DIEFT_DEADBAND,                PIDMAKEUSAGEDWORD(DEAD_BAND),                   HID_VALUE,      HidP_Output},
#if DIRECTINPUT_VERSION  >= 0x600
    {DIEFT_STARTDELAY,              PIDMAKEUSAGEDWORD(START_DELAY),                 HID_VALUE,      HidP_Output},
#endif
};


static PIDSUPPORT g_DIep[] =
{
    {DIEP_DURATION,                 PIDMAKEUSAGEDWORD(DURATION),                    HID_VALUE,      HidP_Output},
    {DIEP_SAMPLEPERIOD,             PIDMAKEUSAGEDWORD(SAMPLE_PERIOD),               HID_VALUE,      HidP_Output},
    {DIEP_GAIN,                     PIDMAKEUSAGEDWORD(GAIN),                        HID_VALUE,      HidP_Output},
    {DIEP_TRIGGERBUTTON,            PIDMAKEUSAGEDWORD(TRIGGER_BUTTON),              HID_VALUE,      HidP_Output},
    {DIEP_TRIGGERREPEATINTERVAL,    PIDMAKEUSAGEDWORD(TRIGGER_REPEAT_INTERVAL),     HID_VALUE,      HidP_Output},
    {DIEP_AXES,                     PIDMAKEUSAGEDWORD(AXES_ENABLE),                 HID_COLLECTION, 0x0},
    {DIEP_DIRECTION,                PIDMAKEUSAGEDWORD(DIRECTION),                   HID_COLLECTION, 0x0},
    {DIEP_ENVELOPE,                 PIDMAKEUSAGEDWORD(SET_ENVELOPE_REPORT),         HID_COLLECTION, 0x0},
#if DIRECTINPUT_VERSION  >= 0x600
    {DIEP_STARTDELAY,              PIDMAKEUSAGEDWORD(START_DELAY),                 HID_VALUE,      HidP_Output},
#endif
};


static PIDSUPPORT g_DIeff[] =
{
    {DIEFF_POLAR,                 PIDMAKEUSAGEDWORD(DIRECTION_ENABLE),         HID_BUTTON,   HidP_Output},
// PID devices do not support Cartesian
//    {DIEFF_ CARTESIAN,             PIDMAKEUSAGEDWORD(AXES_ENABLE),              HID_COLLECTION,0x0},
};

#pragma END_CONST_DATA

//our own version of KEY_ALL_ACCESS, that does not use WRITE_DAC and WRITE_OWNER (see Whistler bug 318865, 370734)
#define DI_DAC_OWNER (WRITE_DAC | WRITE_OWNER)
#define DI_KEY_ALL_ACCESS (KEY_ALL_ACCESS & ~DI_DAC_OWNER) 
// we need to know on which OS we're running, to to have appropriate reg key permissions (see Whistler bug  318865, 370734)
#define WIN_UNKNOWN_OS 0
#define WIN95_OS       1
#define WIN98_OS       2
#define WINME_OS       3
#define WINNT_OS       4
#define WINWH_OS       5


STDMETHODIMP
    PID_Support
    (
    IDirectInputEffectDriver *ped,
    UINT        cAPidSupport,
    PPIDSUPPORT rgPidSupport,
    PDWORD      pdwFlags
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres;
    UINT    indx;
    PPIDSUPPORT pPidSupport;

    EnterProcI(PID_Support, (_"xxxx", ped, cAPidSupport, rgPidSupport, pdwFlags));

    hres = S_OK;
    for( indx = 0x0, pPidSupport = rgPidSupport;
       indx < cAPidSupport;
       indx++, pPidSupport++
       )
    {

        USAGE   Usage = DIGETUSAGE(pPidSupport->dwPidUsage);
        USAGE   UsagePage = DIGETUSAGEPAGE(pPidSupport->dwPidUsage);

        if( pPidSupport->Type == HID_COLLECTION )
        {
            HRESULT hres0;
            USHORT  LinkCollection;
            hres0 = PID_GetLinkCollectionIndex(ped, UsagePage, Usage , 0x0, &LinkCollection);
            if( SUCCEEDED(hres0) )
            {
                *pdwFlags |= pPidSupport->dwDIFlags;
            } else
            {
                hres |= E_NOTIMPL;

                SquirtSqflPtszV(sqfl | sqflBenign,
                                TEXT("%s: FAIL PID_GetCollectionIndex:0x%x for(%x,%x,%x:%s)"),
                                s_tszProc, hres0,
                                LinkCollection,UsagePage, Usage,
                                PIDUSAGETXT(UsagePage,Usage)
                               );
            }
        } else if( pPidSupport->Type == HID_VALUE   )
        {
            NTSTATUS ntStat;
            HIDP_VALUE_CAPS ValCaps;
            USHORT  cAValCaps = 0x1;

            ntStat = HidP_GetSpecificValueCaps
                     (
                     pPidSupport->HidP_Type,                     //ReportType
                     UsagePage,                                  //UsagePage
                     0x0,                                        //LinkCollection,
                     Usage,                                      //Usage
                     &ValCaps,                                   //ValueCaps,
                     &cAValCaps,                                 //ValueCapsLength,
                     this->ppd                                   //Preparsed Data
                     );

            if(    SUCCEEDED(ntStat )
                   || ntStat == HIDP_STATUS_BUFFER_TOO_SMALL)
            {
                *pdwFlags |= pPidSupport->dwDIFlags;
            } else
            {
                hres |= E_NOTIMPL;

                SquirtSqflPtszV(sqfl | sqflBenign,
                                TEXT("%s: FAIL HidP_GetSpValCaps:0x%x for(%x,%x,%x:%s)"),
                                s_tszProc, ntStat,
                                0x0,UsagePage, Usage,
                                PIDUSAGETXT(UsagePage,Usage)
                               );
            }
        } else if( pPidSupport->Type == HID_BUTTON )
        {
            NTSTATUS ntStat;
            HIDP_BUTTON_CAPS ButtonCaps;
            USHORT    cAButtonCaps = 0x1;

            ntStat = HidP_GetSpecificButtonCaps
                     (
                     pPidSupport->HidP_Type,                     //ReportType
                     UsagePage,                                  //UsagePage
                     0x0,                                        //LinkCollection,
                     Usage,                                      //Usage
                     &ButtonCaps,                                //ValueCaps,
                     &cAButtonCaps,                              //ValueCapsLength,
                     this->ppd                                   //Preparsed Data
                     );

            if(    SUCCEEDED(ntStat )
                   || ntStat == HIDP_STATUS_BUFFER_TOO_SMALL)
            {
                *pdwFlags |= pPidSupport->dwDIFlags;
            } else
            {
                hres |= E_NOTIMPL;
                SquirtSqflPtszV(sqfl | sqflBenign,
                                TEXT("%s: FAIL HidP_GetSpButtonCaps:0x%x for(%x,%x,%x:%s)"),
                                s_tszProc, ntStat,
                                0x0,UsagePage, Usage,
                                PIDUSAGETXT(UsagePage,Usage)
                               );
            }
        } else
        {
            hres |= DIERR_PID_USAGENOTFOUND;
        }
    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | NameFromGUID |
 *
 *          Convert a GUID into an ASCII string that will be used
 *          to name it in the global namespace.
 *
 *
 *  @parm   LPTSTR | ptszBuf |
 *
 *          Output buffer to receive the converted name.  It must
 *          be <c ctchNameGuid> characters in size.
 *
 *  @parm   PCGUID | pguid |
 *
 *          The GUID to convert.
 *
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

/* Note: If you change this string, you need to change ctchNameGuid to match */
TCHAR c_tszNameFormat[] =
    TEXT("{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}");

#pragma END_CONST_DATA

#define ctchGuid    (1 + 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)

void EXTERNAL
    NameFromGUID(LPTSTR ptszBuf, PCGUID pguid)
{
    int ctch;

    ctch = wsprintf(ptszBuf, c_tszNameFormat,
                    pguid->Data1, pguid->Data2, pguid->Data3,
                    pguid->Data4[0], pguid->Data4[1],
                    pguid->Data4[2], pguid->Data4[3],
                    pguid->Data4[4], pguid->Data4[5],
                    pguid->Data4[6], pguid->Data4[7]);

    AssertF(ctch == ctchGuid - 1);
}

#define hresLe(le) MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, (USHORT)(le))

BOOL INLINE
    IsWriteSam(REGSAM sam)
{
    return sam & (KEY_SET_VALUE | KEY_CREATE_SUB_KEY | MAXIMUM_ALLOWED);
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | PID_GetOSVersion |
 *
 *          Return the OS version on which pid.dll is running.
 *          
 *  @returns
 *
 *          WIN95_OS, WIN98_OS, WINME_OS, WINNT_OS, WINWH_OS, or WIN_UNKNOWN_OS.
 *
 *****************************************************************************/

DWORD PID_GetOSVersion()
{
    OSVERSIONINFO osVerInfo;
    DWORD dwVer;

    if( GetVersion() < 0x80000000 ) {
        dwVer = WINNT_OS;
    } else {
        dwVer = WIN95_OS;  //assume Windows 95 for safe
    }

    osVerInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );

    // If GetVersionEx is supported, then get more details.
    if( GetVersionEx( &osVerInfo ) )
    {
        // Win2K
        if( osVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT )
        {
            // Whistler: Major = 5 & Build # > 2195
            if( osVerInfo.dwMajorVersion == 5 && osVerInfo.dwBuildNumber > 2195 )
            {
                dwVer = WINWH_OS;
            } else {
                dwVer = WINNT_OS;
            }
        }
        // Win9X
        else
        {
            if( (HIBYTE(HIWORD(osVerInfo.dwBuildNumber)) == 4) ) 
            {
                // WinMe: Major = 4, Minor = 90
                if( (LOBYTE(HIWORD(osVerInfo.dwBuildNumber)) == 90) )
                {
                    dwVer = WINME_OS;
                } else if ( (LOBYTE(HIWORD(osVerInfo.dwBuildNumber)) > 0) ) {
                    dwVer = WIN98_OS;
                } else {
                    dwVer = WIN95_OS;
                }
            }
        }
    }

    return dwVer;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresMumbleKeyEx |
 *
 *          Either open or create the key, depending on the degree
 *          of access requested.
 *
 *  @parm   HKEY | hk |
 *
 *          Base key.
 *
 *  @parm   LPCTSTR | ptszKey |
 *
 *          Name of subkey, possibly NULL.
 *
 *  @parm   REGSAM | sam |
 *
 *          Security access mask.
 *
 *  @parm   DWORD   | dwOptions |
 *          Options for RegCreateEx
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives output key.
 *
 *  @returns
 *
 *          Return value from <f RegOpenKeyEx> or <f RegCreateKeyEx>,
 *          converted to an <t HRESULT>.
 *
 *****************************************************************************/

STDMETHODIMP
    hresMumbleKeyEx(HKEY hk, LPCTSTR ptszKey, REGSAM sam, DWORD dwOptions, PHKEY phk)
{
    HRESULT hres;
    LONG lRc;
	BOOL bWinXP = FALSE;


    EnterProc(hresMumbleKeyEx, (_"xsxxx", hk, ptszKey, sam, dwOptions, phk));
    /*
     *  If caller is requesting write access, then create the key.
     *  Else just open it.
     */
    if(IsWriteSam(sam))
    {
		// on WinXP, we strip out WRITE_DAC and WRITE_OWNER bits
		if (PID_GetOSVersion() == WINWH_OS)
		{
			sam &= ~DI_DAC_OWNER;
			bWinXP = TRUE;
		}

        lRc = RegOpenKeyEx(hk, ptszKey, 0, sam, phk);

        if( lRc == ERROR_SUCCESS )
        {
            // Don't need to create it already exists
        } else
        {
#ifdef WINNT
            EXPLICIT_ACCESS     ExplicitAccess;
            PACL                pACL;
            DWORD               dwErr;
            SECURITY_DESCRIPTOR SecurityDesc;
            DWORD               dwDisposition;
            SECURITY_ATTRIBUTES sa;
			PSID pSid = NULL;
			SID_IDENTIFIER_AUTHORITY authority = SECURITY_WORLD_SID_AUTHORITY;


            // Describe the access we want to create the key with
            ZeroMemory (&ExplicitAccess, sizeof(ExplicitAccess) );
            //set the access depending on the OS (see Whistler bug 318865)
			if (bWinXP == TRUE)
			{
				ExplicitAccess.grfAccessPermissions = DI_KEY_ALL_ACCESS;
			}
			else
			{
				ExplicitAccess.grfAccessPermissions = KEY_ALL_ACCESS;
			}
            ExplicitAccess.grfAccessMode = GRANT_ACCESS;     
            ExplicitAccess.grfInheritance =  SUB_CONTAINERS_AND_OBJECTS_INHERIT;

			if (AllocateAndInitializeSid(
						&authority,
						1, 
						SECURITY_WORLD_RID,  0, 0, 0, 0, 0, 0, 0,
						&pSid
						))
			{
				BuildTrusteeWithSid(&(ExplicitAccess.Trustee), pSid );

				dwErr = SetEntriesInAcl( 1, &ExplicitAccess, NULL, &pACL );


				if( dwErr == ERROR_SUCCESS )
				{
					AssertF( pACL );

					if( InitializeSecurityDescriptor( &SecurityDesc, SECURITY_DESCRIPTOR_REVISION ) )
					{
						if( SetSecurityDescriptorDacl( &SecurityDesc, TRUE, pACL, FALSE ) )
						{
							// Initialize a security attributes structure.
							sa.nLength = sizeof (SECURITY_ATTRIBUTES);
							sa.lpSecurityDescriptor = &SecurityDesc;
							sa.bInheritHandle = TRUE;// Use the security attributes to create a key.

							lRc = RegCreateKeyEx
								  (
								  hk,									// handle of an open key
								  ptszKey,								// address of subkey name
								  0,									// reserved
								  NULL,									// address of class string
								  dwOptions,							// special options flag
								  ExplicitAccess.grfAccessPermissions,	// desired security access
								  &sa,									// address of key security structure
								  phk,									// address of buffer for opened handle
								  &dwDisposition						// address of disposition value buffer);
								  );

						}
						else
						{
							SquirtSqflPtszV( sqflError | sqflReg,
											 TEXT("SetSecurityDescriptorDacl failed lastError=0x%x "),
											 GetLastError());
						}
					}
					else
					{
						SquirtSqflPtszV( sqflError | sqflReg,
										 TEXT("InitializeSecurityDescriptor failed lastError=0x%x "),
										 GetLastError());
					}

					LocalFree( pACL );
				}
				else
				{
					SquirtSqflPtszV( sqflError | sqflReg,
									 TEXT("SetEntriesInACL failed, dwErr=0x%x"), dwErr );
				}
			}
			else
			{
			   SquirtSqflPtszV( sqflError | sqflReg,
				   TEXT("AllocateAndInitializeSid failed"));

			}

			//Cleanup pSid
			if (pSid != NULL)
			{
				FreeSid(pSid);
			}

            if( lRc != ERROR_SUCCESS )
            {
				SquirtSqflPtszV( sqflError,
							TEXT("Failed to create regkey %s with security descriptor, lRc=0x%x "),
							ptszKey, lRc);
            }
#else
            lRc = RegCreateKeyEx(hk, ptszKey, 0, 0,
                                 dwOptions,
                                 sam, 0, phk, 0);
#endif
        }

    } else
    {
        lRc = RegOpenKeyEx(hk, ptszKey, 0, sam, phk);
    }

    if(lRc == ERROR_SUCCESS)
    {
        hres = S_OK;
    } else
    {
        if(lRc == ERROR_KEY_DELETED || lRc == ERROR_BADKEY)
        {
            lRc = ERROR_FILE_NOT_FOUND;
        }
        hres = hresLe(lRc);
    }

    ExitOleProc();
    return hres;

}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | PID_CreateFFKeys |
 *
 *          Given a handle to a PID device, create the registry entries to enable
 *          force feedback.
 *
 *  @parm   HANDLE | hdev |
 *
 *          Handle to the PID device.
 *
 *  @parm   HKEY | hkFF |
 *
 *          Force Feedback registry key.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTFOUND>: Couldn't open the key.
 *
 *****************************************************************************/
STDMETHODIMP
    PID_CreateFFKeys
    (
    IDirectInputEffectDriver *ped,
    HKEY        hkFF
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres;
    UINT uEffect;
    HKEY hkEffect;

    EnterProc(PID_CreateFFKey, (_"xx", ped, hkFF));

    hres = hresMumbleKeyEx(hkFF, REGSTR_EFFECTS, KEY_ALL_ACCESS, REG_OPTION_NON_VOLATILE, &hkEffect);

    if( SUCCEEDED(hres) )
    {
        DWORD   dwDIef, dwDIep, dwDIeff;
        dwDIef = dwDIep = dwDIeff = 0x0;

        /*
         * Determine supported flags for effectType and Effect Params
         * based on the PID descriptors
         */
        PID_Support(ped, cA(g_DIeft), g_DIeft,  &dwDIef);
        PID_Support(ped, cA(g_DIep),  g_DIep,   &dwDIep);
        PID_Support(ped, cA(g_DIeff), g_DIeff,  &dwDIeff);

        // All effects support DIEP_TYPESPECIFICPARAMS
        dwDIep |= DIEP_TYPESPECIFICPARAMS;

        for( uEffect = 0x0; uEffect < cA(g_EffectMapInfo); uEffect++ )
        {
            EFFECTMAPINFO   emi = g_EffectMapInfo[uEffect];
            PIDSUPPORT  PidSupport;
            DWORD   dwJunk;
            HRESULT hres0;

            PidSupport.dwPidUsage = emi.attr.dwEffectId;
            PidSupport.Type       = HID_BUTTON;
            PidSupport.HidP_Type  = HidP_Output;

            hres0 = PID_Support(ped, 0x1, &PidSupport, &dwJunk);

            if( SUCCEEDED(hres0) )
            {
                TCHAR tszName[ctchGuid];
                HKEY hk;

                NameFromGUID(tszName, emi.pcguid);

                hres = hresMumbleKeyEx(hkEffect, tszName, KEY_ALL_ACCESS, REG_OPTION_NON_VOLATILE, &hk);

                if( SUCCEEDED(hres) )
                {
                    LONG lRc;
                    lRc = RegSetValueEx(hk, 0x0, 0x0, REG_SZ, (char*)emi.tszName, lstrlen(emi.tszName) * cbX(emi.tszName[0]));

                    if( lRc == ERROR_SUCCESS )
                    {
                        /*
                         * Modify generic attribute flags depending
                         * on PID firmware descriptors
                         */
                        emi.attr.dwEffType          &= dwDIef;
                        emi.attr.dwStaticParams     &= dwDIep;
                        emi.attr.dwDynamicParams    &= dwDIep;
                        emi.attr.dwCoords           &= dwDIeff;

                        lRc = RegSetValueEx(hk, REGSTR_ATTRIBUTES, 0x0, REG_BINARY, (char*)&emi.attr, cbX(emi.attr) ) ;

                        if( lRc == ERROR_SUCCESS )
                        {

                        } else
                        {
                            hres = REGDB_E_WRITEREGDB;
                        }
                    } else
                    {
                        hres = REGDB_E_WRITEREGDB;
                    }
                    RegCloseKey(hk);
                }
            }
        }
        RegCloseKey(hkEffect);
    }

    ExitOleProc();
    return hres;
}
/*****************************************************************************
 *
 *      PID_InitRegistry
 *
 *      This function updates the registry for a specified device.
 *
 *  LPTSTR  ptszDeviceInterface
 *
 *
 *  Returns:
 *
 *          S_OK if the operation completed successfully.
 *
 *          Any DIERR_* error code may be returned.
 *
 *          Private driver-specific error codes in the range
 *          DIERR_DRIVERFIRST through DIERR_DRIVERLAST
 *          may be returned.
 *
 *****************************************************************************/

STDMETHODIMP
    PID_InitRegistry
    (
    IDirectInputEffectDriver *ped
    )
{
    CPidDrv *this = (CPidDrv *)ped;
    HRESULT hres;
    TCHAR tszType[MAX_JOYSTRING];
    HKEY hkFF;

    EnterProc(PID_InitRegistry, (_"x", ped));

    wsprintf(tszType, REGSTR_OEM_FF_TEMPLATE, this->attr.VendorID, this->attr.ProductID);

	//If there is no pid version written, -- or it is less then the "last known good version" (today it is 0x0720), 
	//overwrite the previous key.
    hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE, tszType, KEY_READ, REG_OPTION_NON_VOLATILE, &hkFF );
    if( SUCCEEDED(hres) )
    {
		DWORD dwCreatedBy = 0x0;
		DWORD dwSize = cbX(dwCreatedBy);

		hres = E_FAIL;
		if ((RegQueryValueEx(hkFF, REGSTR_CREATEDBY, 0x0, 0x0, (BYTE*)&dwCreatedBy, &dwSize) == ERROR_SUCCESS) &&
			(dwCreatedBy >= 0x0720))
		{
			hres = S_OK;
		}
		RegCloseKey(hkFF);
    }
	if (FAILED(hres))
    {
		
        hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE, tszType, KEY_ALL_ACCESS, REG_OPTION_NON_VOLATILE, &hkFF);

        if( SUCCEEDED(hres)  )
        {
            hres = PID_CreateFFKeys(ped, hkFF );
            if( SUCCEEDED(hres) )
            {
				DWORD dwCreatedBy = DIRECTINPUT_HEADER_VERSION;
                LONG lRc;
                DWORD dwSize;
                DWORD dwType;

                //DX8a Do not overwrite an existing CLSID as we may have 
                //been loaded by an IHV with their own CLSID.  In DX8, this 
                //was always written causing some IHV drivers to be ignored.
                //Allow long values as a lot of people write strings with 
                //garbage after a null terminated string 
                //For now, DInput won't load such a CLSID but just in case
        		lRc = RegQueryValueEx( hkFF, REGSTR_CLSID, NULL, &dwType, NULL, &dwSize );
                if( ( lRc == ERROR_SUCCESS ) 
                 && ( dwType == REG_SZ )
                 && ( dwSize >= ctchGuid - 1 ) )
                {
#ifdef DEBUG
                    TCHAR tszDbg[MAX_PATH];
                    dwSize = cbX(tszDbg);
        		    if( RegQueryValueEx( hkFF, REGSTR_CLSID, NULL, NULL, (BYTE*)tszDbg, &dwSize ) 
                     || !dwSize )
                    {
                        tszDbg[0] = TEXT('?');
                        tszDbg[1] = TEXT('\0');
                    }
                    SquirtSqflPtszV(sqfl | sqflBenign,
                        TEXT("RegistryInit: Not overwiting existing CLSID %s"), tszDbg );
#endif
                }
                else
                {
                    TCHAR tszGuid[ctchGuid];

                    NameFromGUID(tszGuid, &IID_IDirectInputPIDDriver);

                    AssertF( lstrlen(tszGuid) * cbX(tszGuid[0]) == cbX(tszGuid) - cbX(tszGuid[0]) );

                    lRc = RegSetValueEx(hkFF, REGSTR_CLSID, 0x0, REG_SZ, (char*)tszGuid, cbX(tszGuid) - cbX(tszGuid[0]));
                    if( lRc == ERROR_SUCCESS )
                    {

                    } else
                    {
                        hres = REGDB_E_WRITEREGDB;
                    }
                }

				//set "CreatedBy" value
				lRc = RegSetValueEx(hkFF, REGSTR_CREATEDBY, 0x0, REG_BINARY, (BYTE*) &dwCreatedBy, cbX(dwCreatedBy));
                if( lRc == ERROR_SUCCESS )
                {

                } else
                {
                    hres = REGDB_E_WRITEREGDB;
                }
            }

            if(SUCCEEDED(hres) )
            {
                DIFFDEVICEATTRIBUTES diff;
                LONG lRc;

                diff.dwFlags = 0x0;
                diff.dwFFSamplePeriod       =
                diff.dwFFMinTimeResolution  = DI_SECONDS;

                lRc = RegSetValueEx(hkFF, REGSTR_ATTRIBUTES, 0x0, REG_BINARY, (char*)&diff, cbX(diff) ) ;
                if(lRc == ERROR_SUCCESS)
                {

                } else
                {
                    hres = REGDB_E_WRITEREGDB;
                }
            }
            RegCloseKey(hkFF);
        }
    }
    ExitOleProc();

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmusic.inc ===
#
# Makefile things everyone needs
#
!ifndef DXROOT
DXROOT=$(BASEDIR)\multimedia\DirectX
!endif

#
# Include correct verinfo.h
# 
INCLUDES=$(DXROOT)\inc;$(INCLUDES)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dinput\pid\usgtxt.c ===
/*****************************************************************************
 *
 *  UsgTxt.c
 *
 *  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      PID usages strings for help with debugging.
 *
 *****************************************************************************/
#include "pidpr.h"

#ifdef DEBUG

void PID_CreateUsgTxt()
{
    g_rgUsageTxt[0x01]=    TEXT("Physical Interface Device");

    g_rgUsageTxt[0x20]=    TEXT("Normal");
    g_rgUsageTxt[0x21]=    TEXT("Set Effect Report");
    g_rgUsageTxt[0x22]=    TEXT("Effect Block Index");
    g_rgUsageTxt[0x23]=    TEXT("Parameter Block Offset");
    g_rgUsageTxt[0x24]=    TEXT("ROM Flag");
    g_rgUsageTxt[0x25]=    TEXT("Effect Type");
    g_rgUsageTxt[0x26]=    TEXT("ET Constant Force");
    g_rgUsageTxt[0x27]=    TEXT("ET Ramp");
    g_rgUsageTxt[0x28]=    TEXT("ET Custom Force Data");


    g_rgUsageTxt[0x30]=    TEXT("ET Square");
    g_rgUsageTxt[0x31]=    TEXT("ET Sine");
    g_rgUsageTxt[0x32]=    TEXT("ET Triangle");
    g_rgUsageTxt[0x33]=    TEXT("ET SawTooth Up");
    g_rgUsageTxt[0x34]=    TEXT("ET SawTooth Down");

    g_rgUsageTxt[0x40]=    TEXT("ET Spring");
    g_rgUsageTxt[0x41]=    TEXT("ET Damper");
    g_rgUsageTxt[0x42]=    TEXT("ET Inertia");
    g_rgUsageTxt[0x43]=    TEXT("ET Friction");

    g_rgUsageTxt[0x50]=    TEXT("Duration");
    g_rgUsageTxt[0x51]=    TEXT("Sample Period");
    g_rgUsageTxt[0x52]=    TEXT("Gain");
    g_rgUsageTxt[0x53]=    TEXT("Trigger Button");
    g_rgUsageTxt[0x54]=    TEXT("Trigger Repeat Interval");
    g_rgUsageTxt[0x55]=    TEXT("Axes Enable");
    g_rgUsageTxt[0x56]=    TEXT("Direction Enable");
    g_rgUsageTxt[0x57]=    TEXT("Direction");
    g_rgUsageTxt[0x58]=    TEXT("Type Specific Block Offset");
    g_rgUsageTxt[0x59]=    TEXT("Block Type");
    g_rgUsageTxt[0x5A]=    TEXT("Set Envelope Report");
    g_rgUsageTxt[0x5B]=    TEXT("Attack Level");
    g_rgUsageTxt[0x5C]=    TEXT("Attack Time");
    g_rgUsageTxt[0x5D]=    TEXT("Fade Level");
    g_rgUsageTxt[0x5E]=    TEXT("Fade Time");
    g_rgUsageTxt[0x5F]=    TEXT("Set Condition Report");

    g_rgUsageTxt[0x60]=    TEXT("CP Offset");
    g_rgUsageTxt[0x61]=    TEXT("Positive Coefficient");
    g_rgUsageTxt[0x62]=    TEXT("Negative Coefficient");
    g_rgUsageTxt[0x63]=    TEXT("Positive Saturation");
    g_rgUsageTxt[0x64]=    TEXT("Negative Saturation");
    g_rgUsageTxt[0x65]=    TEXT("Dead Band");
    g_rgUsageTxt[0x66]=    TEXT("Download Force Sample");
    g_rgUsageTxt[0x67]=    TEXT("Isoch Custom Force Enable");
    g_rgUsageTxt[0x68]=    TEXT("Custom Force Data Report");
    g_rgUsageTxt[0x69]=    TEXT("Custom Force Data");
    g_rgUsageTxt[0x6A]=    TEXT("Custom Force Vendor Defined Data");
    g_rgUsageTxt[0x6B]=    TEXT("Set Custom Force Report");
    g_rgUsageTxt[0x6C]=    TEXT("Custom Force Data Offset");
    g_rgUsageTxt[0x6D]=    TEXT("Sample Count");
    g_rgUsageTxt[0x6E]=    TEXT("Set Periodic Report");
    g_rgUsageTxt[0x6F]=    TEXT("Offset");

    g_rgUsageTxt[0x70]=    TEXT("Magnitude");
    g_rgUsageTxt[0x71]=    TEXT("Phase");
    g_rgUsageTxt[0x72]=    TEXT("Period");
    g_rgUsageTxt[0x73]=    TEXT("Set Constant Force Report");
    g_rgUsageTxt[0x74]=    TEXT("Set Ramp Force Report");
    g_rgUsageTxt[0x75]=    TEXT("Ramp Start");
    g_rgUsageTxt[0x76]=    TEXT("Ramp End");
    g_rgUsageTxt[0x77]=    TEXT("Effect Operation Report");
    g_rgUsageTxt[0x78]=    TEXT("Effect Operation");
    g_rgUsageTxt[0x79]=    TEXT("Op Effect Start");
    g_rgUsageTxt[0x7A]=    TEXT("Op Effect Start Solo");
    g_rgUsageTxt[0x7B]=    TEXT("Op Effect Stop");
    g_rgUsageTxt[0x7C]=    TEXT("Loop Count");
    g_rgUsageTxt[0x7D]=    TEXT("Device Gain Report");
    g_rgUsageTxt[0x7E]=    TEXT("Device Gain");
    g_rgUsageTxt[0x7F]=    TEXT("PID Pool Report");

    g_rgUsageTxt[0x80]=    TEXT("RAM Pool Size");
    g_rgUsageTxt[0x81]=    TEXT("ROM Pool Size");
    g_rgUsageTxt[0x82]=    TEXT("ROM Effect Block Count");
    g_rgUsageTxt[0x83]=    TEXT("Simultaneous Effects Max");
    g_rgUsageTxt[0x84]=    TEXT("Pool Alignment");
    g_rgUsageTxt[0x85]=    TEXT("PID Pool Move Report");
    g_rgUsageTxt[0x86]=    TEXT("Move Source");
    g_rgUsageTxt[0x87]=    TEXT("Move Destination");
    g_rgUsageTxt[0x88]=    TEXT("Move Length");
    g_rgUsageTxt[0x89]=    TEXT("PID Block Load Report");
    g_rgUsageTxt[0x8A]=    TEXT("Handshake Key");
    g_rgUsageTxt[0x8B]=    TEXT("Block Load Status");
    g_rgUsageTxt[0x8C]=    TEXT("Block Load Success");
    g_rgUsageTxt[0x8D]=    TEXT("Block Load Full");
    g_rgUsageTxt[0x8E]=    TEXT("Blodk Load Error");
    g_rgUsageTxt[0x8F]=    TEXT("Block Handle");

    g_rgUsageTxt[0x90]=    TEXT("PID Block Free Report");
    g_rgUsageTxt[0x91]=    TEXT("Type Specific Block Handle");
    g_rgUsageTxt[0x92]=    TEXT("PID State Report");
    g_rgUsageTxt[0x93]=    TEXT("PID Effect State");
    g_rgUsageTxt[0x94]=    TEXT("ES Playing");
    g_rgUsageTxt[0x95]=    TEXT("ES Stopped");
    g_rgUsageTxt[0x96]=    TEXT("PID Device Control");
    g_rgUsageTxt[0x97]=    TEXT("DC Enable Actuators");
    g_rgUsageTxt[0x98]=    TEXT("DC Disable Actuators");
    g_rgUsageTxt[0x99]=    TEXT("DC Stop All Effects");
    g_rgUsageTxt[0x9A]=    TEXT("DC Device Reset");
    g_rgUsageTxt[0x9B]=    TEXT("DV Device Pause");
    g_rgUsageTxt[0x9C]=    TEXT("DC Device Continue");
    g_rgUsageTxt[0x9D]=    TEXT("Device State");

    g_rgUsageTxt[0x9F]=    TEXT("Device Paused");

    g_rgUsageTxt[0xA0]=    TEXT("Actuators Enabled");
    g_rgUsageTxt[0xA4]=    TEXT("Safety Switch");
    g_rgUsageTxt[0xA5]=    TEXT("Actuator Override Switch");
    g_rgUsageTxt[0xA6]=    TEXT("Actuator Power");
    g_rgUsageTxt[0xA7]=    TEXT("Start Delay");
    g_rgUsageTxt[0xA8]=    TEXT("Parameter Block Size");
    g_rgUsageTxt[0xA9]=    TEXT("Device Managed Pool");
    g_rgUsageTxt[0xAA]=    TEXT("Shared Parameter Blocks");
    g_rgUsageTxt[0xAB]=    TEXT("Create New Effect Report");
    g_rgUsageTxt[0xAC]=    TEXT("RAM pool avaliable");

    CAssertF( 0xAC == PIDUSAGETXT_MAX);
    
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmband\alist.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// alist.cpp
//
#include "alist.h"

LONG AListItem::GetCount(void) const
{
    LONG l;
    const AListItem *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

AListItem* AListItem::Cat(AListItem *pItem)
{
    AListItem *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

AListItem* AListItem::Remove(AListItem *pItem)
{
    AListItem *li,*prev;

    //treat remove(NULL) same as item not found in list
   if (pItem==NULL) 
   return this;

    if(pItem==this)
    {
        li = m_pNext;
        m_pNext = NULL;
        return li;
    }
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);

    // SetNext on pItem to NULL
    pItem->SetNext(NULL);

    return this;
}

AListItem* AListItem::GetPrev(AListItem *pItem) const
{
    const AListItem *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (AListItem*)prev;
}

AListItem * AListItem::GetItem(LONG index)

{
	AListItem *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) 
	{
		index--;
	}
	return (scan);
}

void AList::InsertBefore(AListItem *pItem,AListItem *pInsert)

{
	AListItem *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}

void AList::AddTail(AListItem *pItem)
{
    if (m_pHead == NULL)
    {
        AddHead(pItem);
    }
    else
    {
        m_pHead = m_pHead->AddTail(pItem);
    }
}

void AList::Reverse()

{
    AList Temp;
    AListItem *pItem;
    while (pItem = RemoveHead())
    {
        Temp.AddHead(pItem);
    }
    m_pHead = Temp.GetHead();
}

BOOL AList::IsMember(AListItem *pItem)

{
    AListItem *pScan = GetHead();
    for (;pScan;pScan = pScan->GetNext())
    {
        if (pItem == pScan) return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmband\bandinst.h ===
//
// bandinst.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Note: Originally written by Robert K. Amenn
//

#ifndef BANDINST_H
#define BANDINST_H

#include "dmusicc.h"
#include "alist.h"

struct IDirectMusicPerformance;
struct IDirectMusicPerformanceP;
struct IDirectMusicAudioPath;
class CBandInstrumentList;
class CBand;
class CBandTrk;

class CDownloadedInstrument : public AListItem
{
public:
	CDownloadedInstrument() 
    {
	    m_pDLInstrument = NULL; 
	    m_pPort = NULL; 
	    m_cRef = 1;
    }
	~CDownloadedInstrument();
	CDownloadedInstrument* GetNext(){return(CDownloadedInstrument*)AListItem::GetNext();}

public:
	IDirectMusicDownloadedInstrument* m_pDLInstrument;
	IDirectMusicPort*				  m_pPort;
	long							  m_cRef;

}; 

class CDownloadList : public AList
{
public:
	CDownloadList(){}
    ~CDownloadList() { Clear(); }
    void Clear();
    CDownloadedInstrument* GetHead(){return(CDownloadedInstrument *)AList::GetHead();}
	CDownloadedInstrument* GetItem(LONG lIndex){return(CDownloadedInstrument*)AList::GetItem(lIndex);}
    CDownloadedInstrument* RemoveHead(){return(CDownloadedInstrument *)AList::RemoveHead();}
	void Remove(CDownloadedInstrument* pDownloadedInstrument){AList::Remove((AListItem *)pDownloadedInstrument);}
	void AddTail(CDownloadedInstrument* pDownloadedInstrument){AList::AddTail((AListItem *)pDownloadedInstrument);}
};

//////////////////////////////////////////////////////////////////////
// Class CBandInstrument

class CBandInstrument : public AListItem
{
friend CBand;
friend CBandTrk;

public:
	CBandInstrument();
	~CBandInstrument();
	CBandInstrument* GetNext(){return(CBandInstrument*)AListItem::GetNext();}
    HRESULT Download(IDirectMusicPerformanceP *pPerformance, 
                                  IDirectMusicAudioPath *pPath,
                                  DWORD dwMIDIMode);
    HRESULT Unload(IDirectMusicPerformanceP *pPerformance, IDirectMusicAudioPath *pPath);

private:
    HRESULT DownloadAddRecord(IDirectMusicPort *pPort);
    HRESULT BuildNoteRangeArray(DWORD *pNoteRangeMap, DMUS_NOTERANGE **ppNoteRanges, DWORD *pdwNumNoteRanges);
	DWORD								m_dwPatch;			// Patch used with DLS Collection		
	DWORD								m_dwAssignPatch;	// Patch used with Download overrides m_dwPatch
	DWORD								m_dwChannelPriority;
	BYTE								m_bPan;
	BYTE								m_bVolume;
	short								m_nTranspose;
	BOOL								m_fGMOnly;
	BOOL								m_fNotInFile;
	DWORD								m_dwFullPatch; // if m_fGMOnly is true, this contains the original, premodified, m_dwPatch
	DWORD								m_dwPChannel;
	DWORD								m_dwFlags;
	DWORD								m_dwNoteRanges[4];
	short								m_nPitchBendRange;
	IDirectMusicCollection*				m_pIDMCollection;
	CDownloadList                  		m_DownloadList;
};

//////////////////////////////////////////////////////////////////////
// Class CBandInstrumentList

class CBandInstrumentList : public AList
{
public:
	CBandInstrumentList(){}
    ~CBandInstrumentList() { Clear(); }
    void Clear();
    CBandInstrument* GetHead(){return(CBandInstrument *)AList::GetHead();}
	CBandInstrument* GetItem(LONG lIndex){return(CBandInstrument*)AList::GetItem(lIndex);}
    CBandInstrument* RemoveHead(){return(CBandInstrument *)AList::RemoveHead();}
	void Remove(CBandInstrument* pBandInstrument){AList::Remove((AListItem *)pBandInstrument);}
	void AddTail(CBandInstrument* pBandInstrument){AList::AddTail((AListItem *)pBandInstrument);}
};

// CDestination keeps track of which performance or audiopath the band was downloaded to.

class CDestination : public AListItem
{
public:
	CBandInstrument* GetNext(){return(CBandInstrument*)AListItem::GetNext();}
    IUnknown *          m_pDestination; // Performance or audiopath this download was sent to. This is a weak reference, no AddRef.
};

class CDestinationList : public AList
{
public:
	CDestinationList(){}
    ~CDestinationList() { Clear(); }
    void Clear();
    CDestination* GetHead(){return(CDestination *)AList::GetHead();}
	CDestination* GetItem(LONG lIndex){return(CDestination*)AList::GetItem(lIndex);}
    CDestination* RemoveHead(){return(CDestination *)AList::RemoveHead();}
	void Remove(CDestination* pDestination){AList::Remove((AListItem *)pDestination);}
	void AddTail(CDestination* pDestination){AList::AddTail((AListItem *)pDestination);}
};


#endif // #ifndef BANDINST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmband\bandinst.cpp ===
//
// bandinst.cpp
// 
// Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
//
// Note: Originally written by Robert K. Amenn 
//

#include "debug.h"
#include "bandinst.h"

//////////////////////////////////////////////////////////////////////
// Class CDownloadedInstrument

//////////////////////////////////////////////////////////////////////
// CDownloadedInstrument::CDownloadedInstrument

CDownloadedInstrument::~CDownloadedInstrument()
{
	if(m_pDLInstrument)
	{
		if (m_pPort)
        {
            if (FAILED(m_pPort->UnloadInstrument(m_pDLInstrument)))
            {
                Trace(1,"Error: UnloadInstrument failed\n");    
            }
        }
        m_pDLInstrument->Release();
	}

	if(m_pPort)
	{
		m_pPort->Release();
	}
}


//////////////////////////////////////////////////////////////////////
// Class CBandInstrument

//////////////////////////////////////////////////////////////////////
// CBandInstrument::CBandInstrument

CBandInstrument::CBandInstrument() 
{
    m_dwPatch = 0;
    m_dwAssignPatch = 0;
    m_bPan = 0;
    m_bVolume = 0;
    m_dwPChannel = 0;
    m_dwFlags = 0;
    m_nTranspose = 0;
    m_fGMOnly = false;
    m_fNotInFile = false;
    m_pIDMCollection = NULL;
	ZeroMemory(m_dwNoteRanges, sizeof(m_dwNoteRanges));
}

//////////////////////////////////////////////////////////////////////
// CBandInstrument::~CBandInstrument

CBandInstrument::~CBandInstrument()
{
	if(m_pIDMCollection)
	{
		m_pIDMCollection->Release();
	}
}

void CDownloadList::Clear()

{
    CDownloadedInstrument *pDownload;
    while (pDownload = RemoveHead())
    {
        delete pDownload;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmband\bandtrk.cpp ===
//
// bandtrk.cpp
//
// Copyright (c) 1997-2001 Microsoft Corporation
//

#include "debug.h"
#include "dmusicc.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "..\shared\dmstrm.h"
#include "..\shared\validate.h"
#include "bandtrk.h"

extern long g_cComponent;

//////////////////////////////////////////////////////////////////////
// Class CBandTrk

//////////////////////////////////////////////////////////////////////
// CBandTrk::CBandTrk

CBandTrk::CBandTrk() :
m_dwValidate(0),
m_bAutoDownload(false),
m_fLockAutoDownload(false),
m_dwFlags(0),
m_cRef(1),
m_fCSInitialized(FALSE)
{
    InterlockedIncrement(&g_cComponent);

    InitializeCriticalSection(&m_CriticalSection);
    // Note: on pre-Blackcomb OS's, this call can raise an exception; if it
    // ever pops in stress, we can add an exception handler and retry loop.
    // (Not all calls to 'new CBandTrk' are protected in handlers.)

    m_fCSInitialized = TRUE;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::~CBandTrk

CBandTrk::~CBandTrk()
{
    if (m_fCSInitialized)
    {
        m_MidiModeList.CleanUp();
        while(!BandList.IsEmpty())
        {
            CBand* pBand = BandList.RemoveHead();
            pBand->Release();
        }

        DeleteCriticalSection(&m_CriticalSection);
    }

    InterlockedDecrement(&g_cComponent);
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CBandTrk::QueryInterface

STDMETHODIMP CBandTrk::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(CBandTrk::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    if(iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack8*>(this);
    }
    else if(iid == IID_IDirectMusicBandTrk)
    {
        *ppv = static_cast<IDirectMusicBandTrk*>(this);
    }
    else if(iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if(iid == IID_IPersist)
    {
        *ppv = static_cast<IPersist*>(this);
    }
    else
    {
        Trace(4,"Warning: Request to query unknown interface on Band Track object\n");
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::AddRef

STDMETHODIMP_(ULONG) CBandTrk::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::Release

STDMETHODIMP_(ULONG) CBandTrk::Release()
{
    if(!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CBandTrk::GetClassID( CLSID* pClassID )
{
    V_INAME(CBandTrk::GetClassID);
    V_PTR_WRITE(pClassID, CLSID);
    *pClassID = CLSID_DirectMusicBandTrack;
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

//////////////////////////////////////////////////////////////////////
// CBandTrk::Load

STDMETHODIMP CBandTrk::Load(IStream* pIStream)
{
    V_INAME(CBandTrk::Load);
    V_PTR_READ(pIStream, IStream);

    HRESULT hrDLS = S_OK;

    EnterCriticalSection(&m_CriticalSection);

    m_MidiModeList.CleanUp();
    // If we have been previously loaded, cleanup bands
    if(!BandList.IsEmpty())
    {
        m_bAutoDownload = true;
        while(!BandList.IsEmpty())
        {
            CBand* pBand = BandList.RemoveHead();
            pBand->Release();
        }

        ++m_dwValidate;
    }

    CRiffParser Parser(pIStream);
    RIFFIO ckMain;
    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);
    if (Parser.NextChunk(&hr))
    {
        if ((ckMain.ckid == FOURCC_RIFF) &&
            (ckMain.fccType == DMUS_FOURCC_BANDTRACK_FORM))
        {
            RIFFIO ckNext;    // Descends into the children chunks.
            Parser.EnterList(&ckNext);
            while (Parser.NextChunk(&hr))
            {
                switch(ckNext.ckid)
                {
                case DMUS_FOURCC_BANDTRACK_CHUNK:
                    DMUS_IO_BAND_TRACK_HEADER ioDMBndTrkHdr;
                    hr = Parser.Read(&ioDMBndTrkHdr, sizeof(DMUS_IO_BAND_TRACK_HEADER));
                    if(SUCCEEDED(hr))
                    {
                        m_bAutoDownload = ioDMBndTrkHdr.bAutoDownload ? true : false;
                        m_fLockAutoDownload = true;
                    }
                    break;
                case FOURCC_LIST:
                    switch(ckNext.fccType)
                    {
                    case  DMUS_FOURCC_BANDS_LIST:
                        hr = BuildDirectMusicBandList(&Parser);
                        if (hr != S_OK)
                        {
                            hrDLS = hr;
                        }
                        break;
                    }
                }
            }
            Parser.LeaveList();
        }
    }
    Parser.LeaveList();

    LeaveCriticalSection(&m_CriticalSection);

    if (hr == S_OK && hrDLS != S_OK)
    {
        hr = hrDLS;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack

//////////////////////////////////////////////////////////////////////
// CBandTrk::Init

STDMETHODIMP CBandTrk::Init(IDirectMusicSegment* pSegment)
{
    V_INAME(CBandTrk::Init);
    V_INTERFACE(pSegment);

    HRESULT hr = S_OK;
    DWORD dwNumPChannels = 0;
    DWORD *pdwPChannels = NULL;

    EnterCriticalSection(&m_CriticalSection);

    CBand* pBand = BandList.GetHead();
    for(; pBand; pBand = pBand->GetNext())
    {
        dwNumPChannels += pBand->GetPChannelCount();
    }

    if(dwNumPChannels > 0)
    {
        pdwPChannels = new DWORD[dwNumPChannels];
        if(pdwPChannels)
        {
            pBand = BandList.GetHead();
            for(DWORD dwPos = 0; pBand; pBand = pBand->GetNext())
            {
                DWORD dwNumWritten;
                pBand->GetPChannels(pdwPChannels + dwPos, &dwNumWritten);
                dwPos += dwNumWritten;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if(SUCCEEDED(hr))
        {
            hr = pSegment->SetPChannelsUsed(dwNumPChannels, pdwPChannels);
        }

        delete [] pdwPChannels;
    }

    LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::InitPlay

STDMETHODIMP CBandTrk::InitPlay(IDirectMusicSegmentState* pSegmentState,
                                           IDirectMusicPerformance* pPerformance,
                                           void** ppStateData,
                                           DWORD dwVirtualTrackID,
                                           DWORD dwFlags)
{
    V_INAME(CBandTrk::InitPlay);
    V_INTERFACE(pSegmentState);
    V_INTERFACE(pPerformance);
    assert(ppStateData);

    EnterCriticalSection(&m_CriticalSection);

    CBandTrkStateData* pBandTrkStateData = new CBandTrkStateData;

    // If we can not allocate the memory we need to set ppStateData to NULL
    // and return S_OK since the caller always expects S_OK;
    *ppStateData = pBandTrkStateData;
    if(pBandTrkStateData == NULL)
    {
        LeaveCriticalSection(&m_CriticalSection);
        return E_OUTOFMEMORY;
    }

    // Need to save State Data
    pBandTrkStateData->m_pSegmentState = pSegmentState;
    pBandTrkStateData->m_pPerformance = pPerformance;
    pBandTrkStateData->m_dwVirtualTrackID = dwVirtualTrackID; // Determines instance of Band Track

    CBand* pBand = BandList.GetHead();
    pBandTrkStateData->m_pNextBandToSPE = pBand;

    BOOL fGlobal; // if the performance has been set with an autodownload preference,
                // use that. otherwise, assume autodownloading is off, unless it has
                // been locked (i.e. specified on the band track.)
    if( SUCCEEDED( pPerformance->GetGlobalParam( GUID_PerfAutoDownload, &fGlobal, sizeof(BOOL) )))
    {
        if( !m_fLockAutoDownload )
        {
            // it might seem like we can just assign m_bAutoDownload = fGlobal,
            // but that's bitten me before, so I'm being paranoid today. (markburt)
            if( fGlobal )
            {
                m_bAutoDownload = true;
            }
            else
            {
                m_bAutoDownload = false;
            }
        }
    }
    else if( !m_fLockAutoDownload )
    {
        m_bAutoDownload = false;
    }
    // Call SetParam to download all instruments used by the track's bands
    // This is the auto-download feature that can be turned off with a call to SetParam
    if(m_bAutoDownload)
    {
        IDirectMusicAudioPath *pPath = NULL;
        IDirectMusicSegmentState8 *pState8;
        if (SUCCEEDED(pSegmentState->QueryInterface(IID_IDirectMusicSegmentState8,(void **)&pState8)))
        {
            pState8->GetObjectInPath(0,DMUS_PATH_AUDIOPATH,0,GUID_NULL,0,
                                                    IID_IDirectMusicAudioPath,(void **) &pPath);
            pState8->Release();
        }
        if (pPath)
        {
            SetParam(GUID_DownloadToAudioPath,0,(void *)pPath);
            pPath->Release();
        }
        else
        {
            SetParam(GUID_DownloadToAudioPath, 0, (void *)pPerformance);
        }
    }

    LeaveCriticalSection(&m_CriticalSection);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::EndPlay

STDMETHODIMP CBandTrk::EndPlay(void* pStateData)
{
    assert(pStateData);

    EnterCriticalSection(&m_CriticalSection);

    // Call SetParam to unload all instruments used by the track's bands
    // This is the auto-unload feature that can be turned off with a call to SetParam
    if(m_bAutoDownload)
    {
        IDirectMusicPerformance *pPerformance = ((CBandTrkStateData *)pStateData)->m_pPerformance;
        IDirectMusicSegmentState *pSegmentState = ((CBandTrkStateData *)pStateData)->m_pSegmentState;
        IDirectMusicAudioPath *pPath = NULL;
        IDirectMusicSegmentState8 *pState8;
        if (SUCCEEDED(pSegmentState->QueryInterface(IID_IDirectMusicSegmentState8,(void **)&pState8)))
        {
            pState8->GetObjectInPath(0,DMUS_PATH_AUDIOPATH,0,GUID_NULL,0,
                                                    IID_IDirectMusicAudioPath,(void **) &pPath);
            pState8->Release();
        }
        if (pPath)
        {
            SetParam(GUID_UnloadFromAudioPath,0,(void *)pPath);
            pPath->Release();
        }
        else
        {
            SetParam(GUID_UnloadFromAudioPath, 0, (void *)pPerformance);
        }
    }

    if(pStateData)
    {
        delete ((CBandTrkStateData *)pStateData);
    }

    LeaveCriticalSection(&m_CriticalSection);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::PlayEx

STDMETHODIMP CBandTrk::PlayEx(void* pStateData,REFERENCE_TIME rtStart,
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID)
{
    HRESULT hr;
    EnterCriticalSection(&m_CriticalSection);
    if (dwFlags & DMUS_TRACKF_CLOCK)
    {
        // Convert all reference times to millisecond times. Then, just use same MUSIC_TIME
        // variables.
        hr = PlayMusicOrClock(pStateData,(MUSIC_TIME)(rtStart / REF_PER_MIL),(MUSIC_TIME)(rtEnd / REF_PER_MIL),
            (MUSIC_TIME)(rtOffset / REF_PER_MIL),rtOffset,dwFlags,pPerf,pSegSt,dwVirtualID,TRUE);
    }
    else
    {
        hr = PlayMusicOrClock(pStateData,(MUSIC_TIME)rtStart,(MUSIC_TIME)rtEnd,
            (MUSIC_TIME)rtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;

}

//////////////////////////////////////////////////////////////////////
// CBandTrk::Play

STDMETHODIMP CBandTrk::Play(
    void *pStateData,
    MUSIC_TIME mtStart,
    MUSIC_TIME mtEnd,
    MUSIC_TIME mtOffset,
    DWORD dwFlags,
    IDirectMusicPerformance* pPerf,
    IDirectMusicSegmentState* pSegSt,
    DWORD dwVirtualID)
{
    EnterCriticalSection(&m_CriticalSection);
    HRESULT hr = PlayMusicOrClock(pStateData,mtStart,mtEnd,mtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

HRESULT CBandTrk::PlayMusicOrClock(
    void *pStateData,
    MUSIC_TIME mtStart,
    MUSIC_TIME mtEnd,
    MUSIC_TIME mtOffset,
    REFERENCE_TIME rtOffset,
    DWORD dwFlags,
    IDirectMusicPerformance* pPerf,
    IDirectMusicSegmentState* pSegSt,
    DWORD dwVirtualID,
    bool fClockTime)
{
    assert(pPerf);
    assert(pSegSt);
    assert(pStateData);

    // Caller expects S_OK or S_END. Since we have no state info we can not do anything
    if(pStateData == NULL)
    {
        return DMUS_S_END;
    }

    EnterCriticalSection(&m_CriticalSection);
    if( dwFlags & (DMUS_TRACKF_SEEK | DMUS_TRACKF_FLUSH | DMUS_TRACKF_DIRTY |
        DMUS_TRACKF_LOOP) )
    {
        // need to reset the PChannel Map in case of any of these flags.
        CBand* pBand = BandList.GetHead();
        DWORD dwGroupBits = 0xffffffff;
        IDirectMusicSegment* pSeg;
        if( SUCCEEDED(pSegSt->GetSegment(&pSeg)))
        {
            pSeg->GetTrackGroup(this, &dwGroupBits);
            pSeg->Release();
        }

        for(; pBand; pBand = pBand->GetNext())
        {
            pBand->m_PChMap.Reset();
            pBand->m_dwGroupBits = dwGroupBits;
        }
    }

    CBandTrkStateData* pBandTrkStateData = (CBandTrkStateData *)pStateData;

    // Seek if we're starting, looping, or if we've been reloaded
    if ((dwFlags & DMUS_TRACKF_LOOP) || (dwFlags & DMUS_TRACKF_START) || (pBandTrkStateData->dwValidate != m_dwValidate))
    {
        // When we start playing a segment, we need to catch up with all the band changes
        // that happened before the start point.  The instruments that sound when we start
        // playing in the middle of a segment should sound the same as if we had played the
        // segment to that point from the beginning.
        pBandTrkStateData->m_fPlayPreviousInSeek = !!(dwFlags & DMUS_TRACKF_START);

        Seek(pBandTrkStateData, mtStart, mtOffset, rtOffset, fClockTime);

        pBandTrkStateData->dwValidate = m_dwValidate; // if we were reloading, we're now adjusted
    }

    // Send all Patch changes between mtStart & mtEnd
    // If any fail try next one
    CBand* pBand = (CBand *)(pBandTrkStateData->m_pNextBandToSPE);

    for( ; pBand && pBand->m_lTimeLogical < mtEnd;
            pBand = pBand->GetNext())
    {
        pBand->SendMessages(pBandTrkStateData, mtOffset, rtOffset, fClockTime);
    }

    // Save position for next time
    pBandTrkStateData->m_pNextBandToSPE = pBand;

    LeaveCriticalSection(&m_CriticalSection);

    return pBand == NULL ? DMUS_S_END : S_OK;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::GetParam

STDMETHODIMP CBandTrk::GetParam(REFGUID rguidDataType,
                                           MUSIC_TIME mtTime,
                                           MUSIC_TIME* pmtNext,
                                           void* pData)
{
    V_INAME(CBandTrk::GetParam);
    V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
    V_PTR_WRITE(pData,1);
    V_REFGUID(rguidDataType);

    HRESULT hr = S_OK;
    EnterCriticalSection( &m_CriticalSection );
    if (rguidDataType == GUID_BandParam)
    {
        CBand* pScan = BandList.GetHead();
        if (pScan)
        {
            CBand* pBand = pScan;
            for (pScan = pScan->GetNext(); pScan; pScan = pScan->GetNext())
            {
                if (mtTime < pScan->m_lTimeLogical) break;
                pBand = pScan;
            }
            // make a copy of the band found
            CBand *pNewBand = new CBand;

            if (pNewBand)
            {
                CBandInstrument* pBandInstrument = pBand->m_BandInstrumentList.GetHead();
                for(; pBandInstrument && SUCCEEDED(hr); pBandInstrument = pBandInstrument->GetNext())
                {
                    hr = pNewBand->Load(pBandInstrument);
                }
                if (FAILED(hr))
                {
                    // Don't leak.
                    delete pNewBand;
                }
                else
                {
                    pNewBand->m_lTimeLogical = pBand->m_lTimeLogical;
                    pNewBand->m_lTimePhysical = pBand->m_lTimePhysical;

                    pNewBand->m_dwFlags |= DMB_LOADED;
                    pNewBand->m_dwMidiMode = pBand->m_dwMidiMode;
                }

            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
            if (SUCCEEDED(hr))
            {
                IDirectMusicBand* pIDMBand = NULL;
                pNewBand->QueryInterface(IID_IDirectMusicBand, (void**)&pIDMBand);
                // The constructor initialized the ref countto 1, so release the QI
                pNewBand->Release();
                DMUS_BAND_PARAM *pBandParam = reinterpret_cast<DMUS_BAND_PARAM *>(pData);
                pBandParam->pBand = pIDMBand;
                pBandParam->mtTimePhysical = pBand->m_lTimePhysical;
                if (pmtNext)
                {
                    *pmtNext = (pScan != NULL) ? pScan->m_lTimeLogical : 0;
                }
                hr = S_OK;
            }
        }
        else
        {
            Trace(4,"Warning: Band Track unable to find Band for GetParam call.\n");
            hr = DMUS_E_NOT_FOUND;
        }
    }
    else
    {
        hr = DMUS_E_GET_UNSUPPORTED;
    }
    LeaveCriticalSection( &m_CriticalSection );
    return hr;

}

//////////////////////////////////////////////////////////////////////
// CBandTrk::SetParam

STDMETHODIMP CBandTrk::SetParam(REFGUID rguidDataType,
                                           MUSIC_TIME mtTime,
                                           void* pData)
{
    V_INAME(CBandTrk::SetParam);
    V_REFGUID(rguidDataType);

    HRESULT hr = S_OK;

    if((pData == NULL)
       && (rguidDataType != GUID_Enable_Auto_Download)
       && (rguidDataType != GUID_Disable_Auto_Download)
       && (rguidDataType != GUID_Clear_All_Bands)
       && (rguidDataType != GUID_IgnoreBankSelectForGM))
    {
        Trace(1,"Error: Invalid NULL pointer passed to Band Track for SetParam call.\n");
        return E_POINTER;
    }

    EnterCriticalSection(&m_CriticalSection);

    if(rguidDataType == GUID_DownloadToAudioPath)
    {
        IDirectMusicAudioPath* pPath = (IDirectMusicAudioPath*)pData;
        V_INTERFACE(pPath);
        HRESULT hrFail = S_OK;
        DWORD dwSuccess = 0;
        CBand* pBand = BandList.GetHead();
        for(; pBand; pBand = pBand->GetNext())
        {
            if (FAILED(hr = pBand->DownloadEx(pPath))) // If not S_OK, download is only partial.
            {
                hrFail = hr;
            }
            else
            {
                dwSuccess++;
            }
        }
        // If we had a failure, return it if we had no successes.
        // Else return S_FALSE for partial success.
        if (FAILED(hrFail) && dwSuccess)
        {
            hr = S_FALSE;
        }
    }
    else if(rguidDataType == GUID_UnloadFromAudioPath)
    {
        IDirectMusicAudioPath* pPath = (IDirectMusicAudioPath*)pData;
        V_INTERFACE(pPath);
        CBand* pBand = BandList.GetHead();
        for(; pBand; pBand = pBand->GetNext())
        {
            pBand->UnloadEx(pPath);
        }
    }
    else if(rguidDataType == GUID_Download)
    {
        IDirectMusicPerformance* pPerf = (IDirectMusicPerformance*)pData;
        V_INTERFACE(pPerf);
        CBand* pBand = BandList.GetHead();
        for(; pBand; pBand = pBand->GetNext())
        {
            if (pBand->DownloadEx(pPerf) != S_OK) // If not S_OK, download is only partial.
            {
                hr = S_FALSE;
            }
        }
    }
    else if(rguidDataType == GUID_Unload)
    {
        IDirectMusicPerformance* pPerf = (IDirectMusicPerformance*)pData;
        V_INTERFACE(pPerf);
        CBand* pBand = BandList.GetHead();
        for(; pBand; pBand = pBand->GetNext())
        {
            pBand->UnloadEx(pPerf);
        }
    }
    else if(rguidDataType == GUID_Enable_Auto_Download)
    {
        m_bAutoDownload = true;
        m_fLockAutoDownload = true;
    }
    else if(rguidDataType == GUID_Disable_Auto_Download)
    {
        m_bAutoDownload = false;
        m_fLockAutoDownload = true;
    }
    else if(rguidDataType == GUID_Clear_All_Bands)
    {
        while(!BandList.IsEmpty())
        {
            CBand* pBand = BandList.RemoveHead();
            pBand->Release();
        }
    }
    else if(rguidDataType == GUID_BandParam)
    {
        DMUS_BAND_PARAM *pBandParam = reinterpret_cast<DMUS_BAND_PARAM *>(pData);
        IDirectMusicBand *pBand = pBandParam->pBand;
        V_INTERFACE(pBand);
        // If you can QI pData for private interface IDirectMusicBandPrivate
        // pBand is of type CBand.
        IDirectMusicBandPrivate *pBandPrivate = NULL;
        hr = pBand->QueryInterface(IID_IDirectMusicBandPrivate, (void **)&pBandPrivate);

        if(FAILED(hr))
        {
            LeaveCriticalSection(&m_CriticalSection);
            return hr;
        }

        pBandPrivate->Release();

        CBand *pBandObject = static_cast<CBand *>(pBand);
        pBandObject->m_lTimeLogical = mtTime;
        pBandObject->m_lTimePhysical = pBandParam->mtTimePhysical;

        hr = AddBand(pBand);
    }
    else if(rguidDataType == GUID_IDirectMusicBand)
    {
        IDirectMusicBand *pBand = (IDirectMusicBand *)pData;
        V_INTERFACE(pBand);
        // If you can QI pData for private interface IDirectMusicBandPrivate
        // pData is of type CBand.
        IDirectMusicBandPrivate *pBandPrivate = NULL;
        hr = pBand->QueryInterface(IID_IDirectMusicBandPrivate, (void **)&pBandPrivate);

        if(FAILED(hr))
        {
            LeaveCriticalSection(&m_CriticalSection);
            return hr;
        }

        pBandPrivate->Release();

        CBand *pBandObject = static_cast<CBand *>(pBand);
        pBandObject->m_lTimeLogical = mtTime;
        pBandObject->m_lTimePhysical = pBandObject->m_lTimeLogical;

        hr = AddBand(pBand);
    }
    else if(rguidDataType == GUID_IgnoreBankSelectForGM)
    {
        CBand* pBand = BandList.GetHead();
        for(; pBand; pBand = pBand->GetNext())
        {
            pBand->MakeGMOnly();
        }
    }
    else if(rguidDataType == GUID_ConnectToDLSCollection)
    {
        IDirectMusicCollection* pCollect = (IDirectMusicCollection*)pData;
        V_INTERFACE(pData);
        CBand* pBand = BandList.GetHead();
        for(; pBand; pBand = pBand->GetNext())
        {
            pBand->ConnectToDLSCollection(pCollect);
        }
    }
    else
    {
        Trace(3,"Warning: Invalid SetParam call on Band Track, GUID is unknown.\n");
        hr = DMUS_E_TYPE_UNSUPPORTED;
    }

    LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::GetParamEx

STDMETHODIMP CBandTrk::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags)
{
    HRESULT hr;
    MUSIC_TIME mtNext;
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        hr = GetParam(rguidType,(MUSIC_TIME) (rtTime / REF_PER_MIL), &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext * REF_PER_MIL;
        }
    }
    else
    {
        hr = GetParam(rguidType,(MUSIC_TIME) rtTime, &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext;
        }
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::SetParamEx

STDMETHODIMP CBandTrk::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags)
{
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        rtTime /= REF_PER_MIL;
    }
    return SetParam(rguidType, (MUSIC_TIME) rtTime, pParam);
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::IsParamSupported

STDMETHODIMP CBandTrk::IsParamSupported(REFGUID rguidDataType)
{
    V_INAME(CBandTrk::IsParamSupported);
    V_REFGUID(rguidDataType);

    // Return S_OK if the object supports the GUID and S_FALSE otherwise
    if(rguidDataType == GUID_Download ||
       rguidDataType == GUID_Unload ||
       rguidDataType == GUID_DownloadToAudioPath ||
       rguidDataType == GUID_UnloadFromAudioPath ||
       rguidDataType == GUID_Enable_Auto_Download ||
       rguidDataType == GUID_Disable_Auto_Download ||
       rguidDataType == GUID_Clear_All_Bands ||
       rguidDataType == GUID_IDirectMusicBand ||
       rguidDataType == GUID_BandParam ||
       rguidDataType == GUID_IgnoreBankSelectForGM ||
       rguidDataType == GUID_ConnectToDLSCollection)
    {
        return S_OK;
    }
    else
    {
        return DMUS_E_TYPE_UNSUPPORTED;
    }
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::AddNotificationType

STDMETHODIMP CBandTrk::AddNotificationType(REFGUID rguidNotify)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::RemoveNotificationType

STDMETHODIMP CBandTrk::RemoveNotificationType(REFGUID rguidNotify)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::Clone

STDMETHODIMP CBandTrk::Clone(MUSIC_TIME mtStart,
                                        MUSIC_TIME mtEnd,
                                        IDirectMusicTrack** ppTrack)
{
    V_INAME(CBandTrk::Clone);
    V_PTRPTR_WRITE(ppTrack);

    if ((mtStart < 0 ) || (mtStart > mtEnd))
    {
        Trace(1,"Error: Invalid range %ld to %ld sent to Band Track Clone command.\n",mtStart,mtEnd);
        return E_INVALIDARG;
    }
    HRESULT hr = E_OUTOFMEMORY;
    IDirectMusicBandTrk *pBandTrack = NULL;
    CBandTrk *pNew = new CBandTrk;
    if (pNew)
    {
        hr = pNew->QueryInterface(IID_IDirectMusicBandTrk,(void**)&pBandTrack);
        if(SUCCEEDED(hr))
        {
            hr = LoadClone(pBandTrack, mtStart, mtEnd);
            if(SUCCEEDED(hr))
            {
                hr = pBandTrack->QueryInterface(IID_IDirectMusicTrack, (void **)ppTrack);
                if (SUCCEEDED(hr))
                {
                    pBandTrack->Release();
                }
            }
            pBandTrack->Release();
        }
        if (FAILED(hr))
        {
            delete pNew;
        }
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicCommon

//////////////////////////////////////////////////////////////////////
// CBandTrk::GetName

STDMETHODIMP CBandTrk::GetName(BSTR* pbstrName)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicBandTrk

//////////////////////////////////////////////////////////////////////
// CBandTrk::AddBand

STDMETHODIMP CBandTrk::AddBand(DMUS_IO_PATCH_ITEM* pPatchEvent)
{
    if(pPatchEvent == NULL)
    {
        return E_POINTER;
    }

    CBand *pNewBand = new CBand;

    HRESULT hr;

    if(pNewBand == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = pNewBand->Load(*pPatchEvent);
    }

    if(SUCCEEDED(hr))
    {
        hr = InsertBand(pNewBand);
    }

    if(FAILED(hr) && pNewBand)
    {
        delete pNewBand;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::AddBand

HRESULT CBandTrk::AddBand(IDirectMusicBand* pIDMBand)
{
    if(pIDMBand == NULL)
    {
        return E_POINTER;
    }

    // If you can QI pIDMBand for private interface IDirectMusicBandPrivate
    // pIDMBand is of type CBand.
    IDirectMusicBandPrivate* pIDMBandP = NULL;
    HRESULT hr = pIDMBand->QueryInterface(IID_IDirectMusicBandPrivate, (void **)&pIDMBandP);

    if(SUCCEEDED(hr))
    {
        pIDMBandP->Release();

        CBand *pNewBand = (CBand *) pIDMBand;
        pNewBand->AddRef();

        hr = InsertBand(pNewBand);

        if(FAILED(hr))
        {
            pNewBand->Release();
        }
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// Internal

//////////////////////////////////////////////////////////////////////
// CBandTrk::BuildDirectMusicBandList
// This method loads all of the bands.

HRESULT CBandTrk::BuildDirectMusicBandList(CRiffParser *pParser)
{
    RIFFIO ckNext;

    HRESULT hrDLS = S_OK;

    HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);
    while (pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
        case FOURCC_LIST :
            switch(ckNext.fccType)
            {
            case DMUS_FOURCC_BAND_LIST:
                hr = ExtractBand(pParser);
                if (hr != S_OK)
                {
                    hrDLS = hr;
                }
                break;
            }
            break;
        }
    }
    pParser->LeaveList();
    if (hr == S_OK && hrDLS != S_OK)
    {
        hr = hrDLS;
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::ExtractBand

HRESULT
CBandTrk::ExtractBand(CRiffParser *pParser)
{
    HRESULT hrDLS = S_OK;

    RIFFIO ckNext;
    CBand *pBand = new CBand;
    if(pBand == NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = S_OK;
    bool fFoundChunk2 = false;
    pParser->EnterList(&ckNext);
    while (pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
        case DMUS_FOURCC_BANDITEM_CHUNK2:
            fFoundChunk2 = true;
            DMUS_IO_BAND_ITEM_HEADER2 ioDMBndItemHdr2;
            hr = pParser->Read(&ioDMBndItemHdr2, sizeof(DMUS_IO_BAND_ITEM_HEADER2));
            if(SUCCEEDED(hr))
            {
                pBand->m_lTimeLogical = ioDMBndItemHdr2.lBandTimeLogical;
                pBand->m_lTimePhysical = ioDMBndItemHdr2.lBandTimePhysical;
            }
            break;
        case DMUS_FOURCC_BANDITEM_CHUNK:
            // if there is both a CHUNK and a CHUNK2, use the info from CHUNK2
            if (fFoundChunk2)
                break;
            DMUS_IO_BAND_ITEM_HEADER ioDMBndItemHdr;
            hr = pParser->Read(&ioDMBndItemHdr, sizeof(DMUS_IO_BAND_ITEM_HEADER));
            if(SUCCEEDED(hr))
            {
                pBand->m_lTimeLogical = ioDMBndItemHdr.lBandTime;
                pBand->m_lTimePhysical = pBand->m_lTimeLogical;
            }
            break;
        case FOURCC_RIFF:
            switch(ckNext.fccType)
            {
            case DMUS_FOURCC_BAND_FORM:
                pParser->SeekBack();
                hr = LoadBand(pParser->GetStream(), pBand);
                pParser->SeekForward();
                if (hr != S_OK)
                {
                    hrDLS = hr;
                }
                break;
            }
            break;
        default:
            break;

        }

    }
    pParser->LeaveList();

    if(SUCCEEDED(hr))
    {
        hr = AddBand(pBand);
    }

    pBand->Release();

    if (hr == S_OK && hrDLS != S_OK)
    {
        hr = hrDLS;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::LoadBand

HRESULT CBandTrk::LoadBand(IStream *pIStream, CBand* pBand)
{
    assert(pIStream);
    assert(pBand);

    IPersistStream *pIPersistStream = NULL;

    HRESULT hr = pBand->QueryInterface(IID_IPersistStream, (void **)&pIPersistStream);

    if(SUCCEEDED(hr))
    {
        hr = pIPersistStream->Load(pIStream);
        pIPersistStream->Release();
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::LoadClone

HRESULT CBandTrk::LoadClone(IDirectMusicBandTrk* pBandTrack,
                                       MUSIC_TIME mtStart,
                                       MUSIC_TIME mtEnd)
{
    assert(pBandTrack);
    assert(mtStart <= mtEnd);

    EnterCriticalSection(&m_CriticalSection);

    HRESULT hr = S_OK;

    if (mtStart > 0)
    {
        // We will take all the bands before the start time and create a single new band
        // at logical time zero, physical time either -1 or one tick before the physical time
        // of the first band after the start time, that accumulates all the instrument changes
        // from the earlier bands.

        TList<SeekEvent> SEList; // Build a list of all the instrument changes for the new band
        DWORD dwLastMidiMode = 0; // Keep track of the MIDI mode of the last band we encounter

        for( CBand* pBand = BandList.GetHead();
                pBand && pBand->m_lTimeLogical < mtStart;
                pBand = pBand->GetNext())
        {
            for(CBandInstrument* pInstrument = (pBand->m_BandInstrumentList).GetHead();
                    pInstrument && SUCCEEDED(hr);
                    pInstrument = pInstrument->GetNext())
            {
                // replace if we already have an entry on that channel
                hr = FindSEReplaceInstr(SEList,
                                        pInstrument->m_dwPChannel,
                                        pInstrument);

                // otherwise add an entry
                if(hr == S_FALSE)
                {
                    TListItem<SeekEvent>* pSEListItem = new TListItem<SeekEvent>;
                    if(pSEListItem)
                    {
                        SeekEvent& rSeekEvent = pSEListItem->GetItemValue();
                        rSeekEvent.m_dwPChannel = pInstrument->m_dwPChannel;
                        rSeekEvent.m_pInstrument = pInstrument;
                        rSeekEvent.m_pParentBand = pBand;
                        dwLastMidiMode = pBand->m_dwMidiMode;
                        SEList.AddHead(pSEListItem);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
        }

        // Make sure the physical time of the new band is less than any bands being cloned.
        MUSIC_TIME mtNewPhysicalTime = -1;
        if (pBand && pBand->m_lTimePhysical <= mtStart)
        {
            mtNewPhysicalTime = (pBand->m_lTimePhysical - mtStart) - 1;
        }

        // Create the new band from the instrument list
        TListItem<SeekEvent>* pSEListItem = SEList.GetHead();
        if(SUCCEEDED(hr) && pSEListItem)
        {
            CBand *pNewBand = new CBand;

            if(pNewBand)
            {
                for(; pSEListItem && SUCCEEDED(hr); pSEListItem = pSEListItem->GetNext())
                {
                    SeekEvent& rSeekEvent = pSEListItem->GetItemValue();
                    hr = pNewBand->Load(rSeekEvent.m_pInstrument);
                }

                pNewBand->m_lTimeLogical = 0;
                pNewBand->m_lTimePhysical = mtNewPhysicalTime;
                pNewBand->m_dwFlags |= DMB_LOADED;
                pNewBand->m_dwMidiMode = dwLastMidiMode;

                if(SUCCEEDED(hr))
                {
                    hr = pBandTrack->AddBand(pNewBand);
                }

                pNewBand->Release();
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    // Copy all the bands between the start and the end time
    if(SUCCEEDED(hr))
    {
        for(CBand* pBand = BandList.GetHead();
                pBand && SUCCEEDED(hr);
                pBand = pBand->GetNext())
        {
            // If mtStart is 0, accept bands with negative times.
            if ((!mtStart || (pBand->m_lTimeLogical >= mtStart)) && pBand->m_lTimeLogical < mtEnd)
            {
                CBand *pNewBand = new CBand;

                if (pNewBand)
                {
                    CBandInstrument* pBandInstrument = pBand->m_BandInstrumentList.GetHead();
                    for(; pBandInstrument && SUCCEEDED(hr); pBandInstrument = pBandInstrument->GetNext())
                    {
                        hr = pNewBand->Load(pBandInstrument);
                    }

                    pNewBand->m_lTimeLogical = pBand->m_lTimeLogical - mtStart;
                    pNewBand->m_lTimePhysical = pBand->m_lTimePhysical - mtStart;

                    pNewBand->m_dwFlags |= DMB_LOADED;
                    pNewBand->m_dwMidiMode = pBand->m_dwMidiMode;

                    if(SUCCEEDED(hr))
                    {
                        hr = pBandTrack->AddBand(pNewBand);
                    }

                    pNewBand->Release();
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }

    LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::Seek

HRESULT CBandTrk::Seek(CBandTrkStateData* pBandTrkStateData,
                       MUSIC_TIME mtStart,
                       MUSIC_TIME mtOffset,
                       REFERENCE_TIME rtOffset,
                       bool fClockTime)
{
    assert(pBandTrkStateData);

    EnterCriticalSection(&m_CriticalSection);

    HRESULT hr = S_OK;

    CBand *pBand;

    int iPrevBandCount = 0; // count how many bands before mtStart
    for (pBand = BandList.GetHead();
            pBand && pBand->m_lTimeLogical < mtStart;
            pBand = pBand->GetNext())
    {
        ++iPrevBandCount;
    }

    // pBand now holds the first band >= mtStart (or NULL if none)
    // This is the next band that will be played.
    assert(!pBand || pBand->m_lTimeLogical >= mtStart);

    if (pBandTrkStateData->m_fPlayPreviousInSeek)
    {
        // When this flag is on not only do we need to find the first band, but we also
        // need to play all the bands before the start point and schedule them to play
        // in the correct order just beforehand.

        // (Note that we're going to order them according to their logical times.  If
        //  two bands's logical/physical times cross each other we'll play them in
        //  incorrect order in terms of physical time.  That's OK because giving
        //  band A with a logical time before band B, yet giving A a physical time
        //  after B is considered an authoring inconsistency.  We'll play band A first.)

        // We will line up the bands just before the following time...
        MUSIC_TIME mtPrevBandQueueStart =
            (pBand && pBand->m_lTimePhysical < mtStart)
                ? pBand->m_lTimePhysical    // put previous bands before next band to play if (due to anticipation) its physical time precedes the start time we're seeking
                : mtStart;                  // otherwise put them just before the start time

        for (pBand = BandList.GetHead();
                pBand && pBand->m_lTimeLogical < mtStart;
                pBand = pBand->GetNext())
        {
            CBandInstrument* pInstrument = (pBand->m_BandInstrumentList).GetHead();
            for (; pInstrument && SUCCEEDED(hr); pInstrument = pInstrument->GetNext())
            {
                pBand->SendInstrumentAtTime(pInstrument, pBandTrkStateData, mtPrevBandQueueStart - iPrevBandCount, mtOffset, rtOffset, fClockTime);
            }
            --iPrevBandCount;
        }
        assert(iPrevBandCount == 0);
    }

    if(SUCCEEDED(hr))
    {
        // Set the state data to the next band to play
        assert(!pBand || pBand->m_lTimeLogical >= mtStart);
        pBandTrkStateData->m_pNextBandToSPE = pBand;
    }

    LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::FindSEReplaceInstr

// If SEList contains an entry on channel dwPChannel, replace the instrument with pInstrument and return S_OK
// Otherwise return S_FALSE
HRESULT CBandTrk::FindSEReplaceInstr(TList<SeekEvent>& SEList,
                                                DWORD dwPChannel,
                                                CBandInstrument* pInstrument)
{
    assert(pInstrument);

    EnterCriticalSection(&m_CriticalSection);

    TListItem<SeekEvent>* pSEListItem = SEList.GetHead();

    for( ; pSEListItem; pSEListItem = pSEListItem->GetNext())
    {
        SeekEvent& rSeekEvent = pSEListItem->GetItemValue();
        if(rSeekEvent.m_dwPChannel == dwPChannel)
        {
            rSeekEvent.m_pInstrument = pInstrument;
            LeaveCriticalSection(&m_CriticalSection);
            return S_OK;
        }
    }

    LeaveCriticalSection(&m_CriticalSection);

    return S_FALSE;
}

//////////////////////////////////////////////////////////////////////
// CBandTrk::InsertBand

HRESULT CBandTrk::InsertBand(CBand* pNewBand)
{
    if (!pNewBand) return E_POINTER;

    EnterCriticalSection(&m_CriticalSection);

    TListItem<StampedGMGSXG>* pPair = m_MidiModeList.GetHead();
    for ( ; pPair; pPair = pPair->GetNext() )
    {
        StampedGMGSXG& rPair = pPair->GetItemValue();
        if (rPair.mtTime > pNewBand->m_lTimeLogical)
        {
            break;
        }
        pNewBand->SetGMGSXGMode(rPair.dwMidiMode);
    }

    CBand* pBand = BandList.GetHead();
    CBand* pPrevBand = NULL;

    if(pBand == NULL)
    {
        // Handles case where there is no band in the list
        BandList.AddHead(pNewBand);
    }
    else
    {
        while(pBand != NULL && pNewBand->m_lTimeLogical > pBand->m_lTimeLogical)
        {
            pPrevBand = pBand;
            pBand = pBand->GetNext();
        }

        if(pPrevBand)
        {
            // Handles the cases of inserting a band in the middle of list
            // and at the end
            CBand* pTemp = pPrevBand->GetNext();
            pPrevBand->SetNext(pNewBand);
            pNewBand->SetNext(pTemp);
        }
        else
        {
            // Handles case where pNewBand->m_lTimeLogical < all pBand->m_lTimeLogical in list
            BandList.AddHead(pNewBand);
        }
    }

    LeaveCriticalSection(&m_CriticalSection);

    return S_OK;
}


STDMETHODIMP CBandTrk::Compose(
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack)
{
    return E_NOTIMPL;
}

STDMETHODIMP CBandTrk::Join(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack)
{
    V_INAME(IDirectMusicTrack::Join);
    V_INTERFACE(pNewTrack);
    V_INTERFACE_OPT(pContext);
    V_PTRPTR_WRITE_OPT(ppResultTrack);

    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CriticalSection);

    if (ppResultTrack)
    {
        hr = Clone(0, mtJoin, ppResultTrack);
        if (SUCCEEDED(hr))
        {
            hr = ((CBandTrk*)*ppResultTrack)->JoinInternal(pNewTrack, mtJoin, dwTrackGroup);
        }
    }
    else
    {
        hr = JoinInternal(pNewTrack, mtJoin, dwTrackGroup);
    }

    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

HRESULT CBandTrk::JoinInternal(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        DWORD dwTrackGroup)
{
    HRESULT hr = S_OK;
    CBandTrk* pOtherTrack = (CBandTrk*)pNewTrack;
    for(CBand* pBand = pOtherTrack->BandList.GetHead();
            pBand && SUCCEEDED(hr);
            pBand = pBand->GetNext())
    {
        CBand *pNewBand = new CBand;
        if (pNewBand)
        {
            CBandInstrument* pBandInstrument = pBand->m_BandInstrumentList.GetHead();
            for(; pBandInstrument && SUCCEEDED(hr); pBandInstrument = pBandInstrument->GetNext())
            {
                hr = pNewBand->Load(pBandInstrument);
            }

            pNewBand->m_lTimeLogical = pBand->m_lTimeLogical + mtJoin;
            pNewBand->m_lTimePhysical = pBand->m_lTimePhysical + mtJoin;
            pNewBand->m_dwFlags |= DMB_LOADED;
            pNewBand->m_dwMidiMode = pBand->m_dwMidiMode;

            if(SUCCEEDED(hr))
            {
                hr = AddBand(pNewBand);
            }

            pNewBand->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmband\debug.cpp ===
//
// Debug.CPP
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
// @doc INTERNAL
//
// @module Debug | Debug services for DMusic.DLL
//

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#include "debug.h"

#ifdef DBG

#define MODULE "DMBAND"

// @globalv Section in WIN.INI for all debug settings
const char szDebugSection[] = "debug";

// @globalv Key in WIN.INI for our debug level. All messages with
// a level of this number or lower will be displayed.
const char szDebugKey[] = MODULE;

// @globalv Key in WIN.INI [debug] section which determines if assert calls
// DebugBreak or not
//
const char szAssertBreak[] = "AssertBreak";

// @globalv Prefix for all debug outputs
//
const char szDebugPrefix[] = MODULE ": ";

// @globalv The current debug level. 
static int giDebugLevel;

// @globalv Do asserts break?
static BOOL gfAssertBreak;

// @func Sets the debug level from WIN.INI
// 
void DebugInit(
    void)
{
    giDebugLevel = GetProfileInt(szDebugSection, szDebugKey, 0);
    gfAssertBreak = GetProfileInt(szDebugSection, szAssertBreak, 0);


    // Nepotism at its finest
    DebugTrace(-1, "Debug level is %d\n", giDebugLevel);
}

// @func Send a debug trace out.
//
// @comm Any message with a level less than or equal to the current debug
// level will be displayed using the OutputDebugString API. This means either
// the IDE Debug window if the app is running in that context or WDEB if
// it's running.
//
static BOOL fNeedPrefix = TRUE;
void DebugTrace(
    int iDebugLevel,        // @parm The debug level of this message
    LPSTR pstrFormat,       // @parm A printf style format string
    ...)                    // @parm | ... | Variable paramters based on <p pstrFormat>
{
    char sz[512];
    

    if (iDebugLevel != -1 && iDebugLevel > giDebugLevel)
    {
        return;
    }

    va_list va;

    va_start(va, pstrFormat);
    vsprintf(sz, pstrFormat, va);
    va_end(va);

    if (fNeedPrefix)
    {
        OutputDebugString(szDebugPrefix);
    }
    
    OutputDebugString(sz);

    // Let them construct multiple piece trace outs w/o
    // prefixing each one
    //
    fNeedPrefix = FALSE;
    for (;*pstrFormat && !fNeedPrefix; ++pstrFormat)
    {
        if (*pstrFormat == '\n')
        {
            fNeedPrefix = TRUE;
        }
    }
}

void DebugAssert(
    LPSTR szExp, 
    LPSTR szFile, 
    ULONG ulLine)
{
    DebugTrace(0, "ASSERT: \"%s\" %s@%lu\n", szExp, szFile, ulLine);
    if (gfAssertBreak)
    {
        DebugBreak();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmband\debug.h ===
//
// debug.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note:
//

#ifndef DEBUG_H
#define DEBUG_H

#include <windows.h>

#define DM_DEBUG_CRITICAL		1	// Used to include critical messages
#define DM_DEBUG_NON_CRITICAL	2	// Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS			3	// Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW		4	// Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL			5	// Used to include all debug messages

// Default to no debug output compiled
//
#define Trace
#define TraceI
#define assert(exp) ((void)0)

#ifdef DBG

// Checked build: include at least external debug spew
//
extern void DebugInit(void);
extern void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...);
extern void DebugAssert(LPSTR szExp, LPSTR szFile, ULONG ulLine);

# undef Trace
# define Trace DebugTrace

# undef assert
# define assert(exp) (void)( (exp) || (DebugAssert(#exp, __FILE__, __LINE__), 0) )

// If internal build flag set, include everything
//
# ifdef DMUSIC_INTERNAL
#  undef TraceI
#  define TraceI DebugTrace
# endif

#endif  // #ifdef DBG

#endif  // #ifndef DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmband\bandtrk.h ===
//
// bandtrk.h
// 
// Copyright (c) 1997-2000 Microsoft Corporation
//

#ifndef BANDTRK_H
#define BANDTRK_H

#include "dmbndtrk.h"
#include "dmbandp.h"

class SeekEvent;

struct IDirectMusicPerformance;
class CRiffParser;

//////////////////////////////////////////////////////////////////////
// Class CBandTrk

class CBandTrk : public IDirectMusicTrack8, public IDirectMusicBandTrk, public IPersistStream
{
    friend CBand;
public:
	// IUnknown
    //
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IPersist
    STDMETHODIMP GetClassID(CLSID* pClassID);

    // IPersistStream
    STDMETHODIMP IsDirty() {return S_FALSE;}
    STDMETHODIMP Load(IStream* pStream);
    STDMETHODIMP Save(IStream* pStream, BOOL fClearDirty) {return E_NOTIMPL;}
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize) {return E_NOTIMPL;}

	// IDirectMusicTrack
	STDMETHODIMP Init(IDirectMusicSegment* pSegment);

	STDMETHODIMP InitPlay(IDirectMusicSegmentState* pSegmentState,
						  IDirectMusicPerformance* pPerformance,
						  void** ppStateData,
						  DWORD dwVirtualTrackID,
                          DWORD dwFlags);

	STDMETHODIMP EndPlay(void* pStateData);

	STDMETHODIMP Play(void* pStateData,
					  MUSIC_TIME mtStart,
					  MUSIC_TIME mtEnd,
					  MUSIC_TIME mtOffset,
					  DWORD dwFlags,
					  IDirectMusicPerformance* pPerf, 
					  IDirectMusicSegmentState* pSegSt, 
					  DWORD dwVirtualID);

	STDMETHODIMP GetParam(REFGUID rguidDataType, 
						 MUSIC_TIME mtTime, 
						 MUSIC_TIME* pmtNext,
						 void* pData);

	STDMETHODIMP SetParam(REFGUID rguidDataType, 
						 MUSIC_TIME mtTime, 
						 void* pData);
	
	STDMETHODIMP IsParamSupported(REFGUID rguidDataType);

	STDMETHODIMP AddNotificationType(REFGUID rguidNotify);

	STDMETHODIMP RemoveNotificationType(REFGUID rguidNotify);

	STDMETHODIMP Clone(	MUSIC_TIME mtStart,
						MUSIC_TIME mtEnd,
						IDirectMusicTrack** ppTrack);
// IDirectMusicTrack8 
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;

	// IDirectMusicCommon
	STDMETHODIMP GetName(BSTR* pbstrName);

	// IDirectMusicBandTrk (Private Interface)
	STDMETHODIMP AddBand(DMUS_IO_PATCH_ITEM* BandEvent);
	STDMETHODIMP AddBand(IDirectMusicBand* pIDMBand);
	STDMETHODIMP SetGMGSXGMode(MUSIC_TIME mtTime, DWORD dwMidiMode)
	{
		TListItem<StampedGMGSXG>* pPair = new TListItem<StampedGMGSXG>;
		if (!pPair) return E_OUTOFMEMORY;
		pPair->GetItemValue().mtTime = mtTime;
		pPair->GetItemValue().dwMidiMode = dwMidiMode;

		TListItem<StampedGMGSXG>* pScan = m_MidiModeList.GetHead();
		TListItem<StampedGMGSXG>* pPrev = NULL;
		
		if(!pScan)
		{
			// Empty list
			m_MidiModeList.AddHead(pPair);
		}
		else
		{
			while(pScan && pPair->GetItemValue().mtTime > pScan->GetItemValue().mtTime)
			{
				pPrev = pScan;
				pScan = pScan->GetNext();
			}	
			
			if(pPrev)
			{
				// Insert in the middle or end of list
				pPair->SetNext(pScan);
				pPrev->SetNext(pPair);
			}
			else
			{
				// Insert at beginning
				m_MidiModeList.AddHead(pPair);
			}
		}

		CBand* pBand = BandList.GetHead();
		for(; pBand; pBand = pBand->GetNext())
		{
			// only set bands affected by new mode
			if ( (pBand->m_lTimeLogical >= pPair->GetItemValue().mtTime) &&
				 ( !pScan || pBand->m_lTimeLogical < pScan->GetItemValue().mtTime) )
			{
				pBand->SetGMGSXGMode(dwMidiMode);
			}
		}
		return S_OK;
	}

	// Class
	CBandTrk();
	~CBandTrk();

private:
	HRESULT BuildDirectMusicBandList(CRiffParser *pParser);
	

	HRESULT  ExtractBand(CRiffParser *pParser);

	HRESULT LoadBand(IStream *pIStream, CBand* pBand);

	HRESULT LoadClone(IDirectMusicBandTrk* pBandTrack,
					  MUSIC_TIME mtStart, 
					  MUSIC_TIME mtEnd);

	HRESULT InsertBand(CBand* pNewBand);
	HRESULT Seek(CBandTrkStateData* pBandTrkStateData,
				 MUSIC_TIME mtStart, 
				 MUSIC_TIME mtOffset,
				 REFERENCE_TIME rtOffset,
				 bool fClockTime);

	HRESULT FindSEReplaceInstr(TList<SeekEvent>& SEList,
							   DWORD dwPChannel,
							   CBandInstrument* pInstrument);

	// Shared implentation of play for either music or clock time.
    HRESULT PlayMusicOrClock(
        void *pStateData,	
        MUSIC_TIME mtStart,	
        MUSIC_TIME mtEnd,
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
	    DWORD dwFlags,		
	    IDirectMusicPerformance* pPerf,	
	    IDirectMusicSegmentState* pSegSt,
	    DWORD dwVirtualID,
        bool fClockTime);

	HRESULT CBandTrk::JoinInternal(
		IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		DWORD dwTrackGroup);

private:
	CRITICAL_SECTION m_CriticalSection;
    BOOL m_fCSInitialized;
	DWORD m_dwValidate; // used to validate state data
	CBandList BandList;
	bool m_bAutoDownload;
	bool m_fLockAutoDownload; // if true, this flag indicates that we've specifically
								// commanded the band to autodownload. Otherwise,
								// it gets its preference from the performance via
								// GetGlobalParam.
	DWORD m_dwFlags;
	TList<StampedGMGSXG> m_MidiModeList; // List of time-stamped midi mode messages
	long m_cRef;
};

//////////////////////////////////////////////////////////////////////
// Class BandTrkStateData

class CBandTrkStateData
{
public: 
	CBandTrkStateData() : 
	m_pSegmentState(NULL),
	m_pPerformance(NULL),
	m_pNextBandToSPE(NULL),
	m_fPlayPreviousInSeek(FALSE),
	m_dwVirtualTrackID(0),
	dwValidate(0){}

	~CBandTrkStateData(){}

public:		
	IDirectMusicSegmentState*	m_pSegmentState;
	IDirectMusicPerformance*	m_pPerformance;
	IDirectMusicBand*			m_pNextBandToSPE;
	DWORD						m_dwVirtualTrackID;
	BOOL						m_fPlayPreviousInSeek;
	DWORD						dwValidate;
};

//////////////////////////////////////////////////////////////////////
// Class SeekEvent

class SeekEvent
{
public:
	SeekEvent() :
	m_pParentBand(NULL),
	m_pInstrument(NULL),
	m_dwPChannel(0) {}
	
	~SeekEvent(){}

public:
	CBand*	m_pParentBand;
	CBandInstrument*	m_pInstrument;
	DWORD				m_dwPChannel;
};

#endif // #ifndef BANDTRK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmband\dmbdll.cpp ===
//
// dmbdll.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Note: Dll entry points as well IDirectMusicBandFactory & 
// IDirectMusicBandTrkFactory implementations.
// Originally written by Robert K. Amenn with significant parts
// stolen from code written by Jim Geist
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

#include <objbase.h>
#include "debug.h"
#include "debug.h"
#include "..\shared\oledll.h"
#include "dmbandp.h"
#include "bandtrk.h"

//////////////////////////////////////////////////////////////////////
// Globals

// Registry Info (band)
TCHAR g_szBandFriendlyName[]    = TEXT("DirectMusicBand");
TCHAR g_szBandVerIndProgID[]    = TEXT("Microsoft.DirectMusicBand");
TCHAR g_szBandProgID[]          = TEXT("Microsoft.DirectMusicBand.1");

// Registry Info (band track)
TCHAR g_szBandTrackFriendlyName[]    = TEXT("DirectMusicBandTrack");
TCHAR g_szBandTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicBandTrack");
TCHAR g_szBandTrackProgID[]          = TEXT("Microsoft.DirectMusicBandTrack.1");

// Dll's hModule
HMODULE g_hModule = NULL;

// Count of active components and class factory server locks
long g_cComponent = 0;
long g_cLock = 0;

//////////////////////////////////////////////////////////////////////
// Standard calls needed to be an inproc server

//////////////////////////////////////////////////////////////////////
// DllCanUnloadNow

STDAPI DllCanUnloadNow()
{
    if(g_cComponent || g_cLock) 
	{
		return S_FALSE;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DllGetClassObject

STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
	IUnknown* pIUnknown = NULL;
    DWORD dwTypeID = 0;
    if(clsid == CLSID_DirectMusicBand)
    {
        dwTypeID = CLASS_BAND;
    }
    else if(clsid == CLSID_DirectMusicBandTrack) 
    {
        dwTypeID = CLASS_BANDTRACK;
    }
    else
    {
		return CLASS_E_CLASSNOTAVAILABLE;
	}
    pIUnknown = static_cast<IUnknown*> (new CClassFactory(dwTypeID));
    if(pIUnknown) 
    {
        HRESULT hr = pIUnknown->QueryInterface(iid, ppv);
        pIUnknown->Release();
        return hr;
    }
	return E_OUTOFMEMORY;
}


//////////////////////////////////////////////////////////////////////
// DllUnregisterServer

STDAPI DllUnregisterServer()
{
	HRESULT hr = UnregisterServer(CLSID_DirectMusicBand,
								  g_szBandFriendlyName,
								  g_szBandVerIndProgID,
								  g_szBandProgID);

	if(SUCCEEDED(hr))
	{
		hr = UnregisterServer(CLSID_DirectMusicBandTrack,
							  g_szBandTrackFriendlyName,
							  g_szBandTrackVerIndProgID,
							  g_szBandTrackProgID);  
	}

	return hr;

}

//////////////////////////////////////////////////////////////////////
// DllRegisterServer

STDAPI DllRegisterServer()
{
	HRESULT hr = RegisterServer(g_hModule,
								CLSID_DirectMusicBand,
								g_szBandFriendlyName,
								g_szBandVerIndProgID,
								g_szBandProgID);
	if(SUCCEEDED(hr))
	{
		hr = RegisterServer(g_hModule,
							CLSID_DirectMusicBandTrack,
							g_szBandTrackFriendlyName,
							g_szBandTrackVerIndProgID,
							g_szBandTrackProgID);
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////
// Standard Win32 DllMain

//////////////////////////////////////////////////////////////////////
// DllMain

#ifdef DBG
static char* aszReasons[] =
{
    "DLL_PROCESS_DETACH",
    "DLL_PROCESS_ATTACH",
    "DLL_THREAD_ATTACH",
    "DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

BOOL APIENTRY DllMain(HINSTANCE hModule,
				      DWORD dwReason,
				      void *lpReserved)
{
	static int nReferenceCount = 0;

#ifdef DBG
    if(dwReason < nReasons)
    {
		Trace(DM_DEBUG_STATUS, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
    }
    else
    {
		Trace(DM_DEBUG_STATUS, "DllMain: Unknown dwReason <%u>\n", dwReason);
    }
#endif

    switch(dwReason)
    {
		case DLL_PROCESS_ATTACH:
		    if(++nReferenceCount == 1)
			{

			#ifdef DBG
				DebugInit();
			#endif

				if(!DisableThreadLibraryCalls(hModule))
				{
					Trace(DM_DEBUG_STATUS, "DisableThreadLibraryCalls failed.\n");
				}

				g_hModule = hModule;
			}
			break;

#ifdef DBG
		case DLL_PROCESS_DETACH:
		    if(--nReferenceCount == 0)
			{
				TraceI(-1, "Unloading g_cLock %d  g_cComponent %d\n", g_cLock, g_cComponent);
                // Assert if we still have some objects hanging around
                assert(g_cComponent == 0);
                assert(g_cLock == 0);
			}
			break;
#endif
    
    }
	
    return TRUE;
}

// CClassFactory::QueryInterface
//
HRESULT __stdcall
CClassFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

CClassFactory::CClassFactory(DWORD dwClassType)

{
	m_cRef = 1;
    m_dwClassType = dwClassType;
	InterlockedIncrement(&g_cLock);
}

CClassFactory::~CClassFactory()

{
	InterlockedDecrement(&g_cLock);
}

// CClassFactory::AddRef
//
ULONG __stdcall
CClassFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CClassFactory::Release
//
ULONG __stdcall
CClassFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CClassFactory::CreateInstance
//
//
HRESULT __stdcall
CClassFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

    if (pUnknownOuter) 
    {
         return CLASS_E_NOAGGREGATION;
    }
    if(ppv == NULL)
	{
		return E_POINTER;
	}

    switch (m_dwClassType)
    {
    case CLASS_BAND:
        {
            CBand *pDMB;
    
            try
            {
                pDMB = new CBand;
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            if(pDMB == NULL) 
	        {
		        hr = E_OUTOFMEMORY;
                break;
            }

            hr = pDMB->QueryInterface(iid, ppv);
            pDMB->Release();
        }
        break;
    case CLASS_BANDTRACK:
        {
            CBandTrk *pDMBT;

            try 
            {
                pDMBT = new CBandTrk;
            } 
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
                break;
            }
    
	        if(pDMBT == NULL) 
	        {
		        hr = E_OUTOFMEMORY;
                break;
            }

            hr = pDMBT->QueryInterface(iid, ppv);
    
            pDMBT->Release();
        }
        break;
    }
    return hr;
}

// CClassFactory::LockServer
//
HRESULT __stdcall
CClassFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmband\dmbandp.h ===
//
// dmbandp.h
// 
// Copyright (c) 1997-2000 Microsoft Corporation
//
//

#ifndef DMBANDP_H
#define DMBANDP_H

#include "dmusici.h"
#include "dmusicf.h"
#include "bandinst.h"
#include "dmbndtrk.h"
#include "..\shared\validate.h"
#include "PChMap.h"
#include "..\shared\dmusicp.h"

class CRiffParser;

#define REF_PER_MIL		10000		// For converting from reference time to mils 

#define DM_LEGACY_BAND_COLLECTION_NAME_LEN	(32)

#define MIDI_PROGRAM_CHANGE	0xc0
#define MIDI_CONTROL_CHANGE	0xb0
#define MIDI_CC_BS_MSB		0x00
#define MIDI_CC_BS_LSB		0x20
#define MIDI_CC_VOLUME		0x07
#define MIDI_CC_PAN			0x0a

// registered parameter numbers
#define RPN_PITCHBEND   0x00

#define FOURCC_BAND_FORM	mmioFOURCC('A','A','B','N')
#define FOURCC_BAND         mmioFOURCC('b','a','n','d')

// This structure is the format used by band files created with SuperJam and
// earlier versions of Jazz. It was taken from band.h found in the Band Editor 
// subdirectory of the Jazz project tree.

#pragma pack(2)

typedef struct ioBandLegacy
{
    wchar_t wstrName[20];		// Band name
    BYTE    abPatch[16];		// GM
    BYTE    abVolume[16];
    BYTE    abPan[16];
    signed char achOctave[16];
    char    fDefault;			// This band is the style's default band
    char    chPad;			
    WORD    awDLSBank[16];		// if GM bit set use abPatch
								// if GS bit set, use this plus abDLSPatch
								// else use both as a DLS
    BYTE    abDLSPatch[16];
    GUID    guidCollection;
//  wchar_t wstrCollection[16];
    char    szCollection[32];  // this only needs to be single-wide chars
} ioBandLegacy;

#pragma pack()

#define DMB_LOADED	 (1 << 0)	/* Set when band has been loaded */
#define DMB_DEFAULT	 (1 << 1)	/* Set when band is default band for a style */

class CBandInstrument;
class CBandTrkStateData;

//////////////////////////////////////////////////////////////////////
// Class CBand

class CBand : 
	public IDirectMusicBand,
	public IDirectMusicBandP,
	public IDirectMusicBandPrivate, 
	public IPersistStream, 
	public IDirectMusicObject, 
	public AListItem
{
friend class CBandTrk;

public:
	enum {DMBAND_NUM_LEGACY_INSTRUMENTS = 16};

	// IUnknown
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // IPersist functions
    STDMETHODIMP GetClassID(CLSID* pClassID) {return E_NOTIMPL;}

    // IPersistStream functions
    STDMETHODIMP IsDirty() {return S_FALSE;}
    STDMETHODIMP Load(IStream* pStream);
    STDMETHODIMP Save(IStream* pStream, BOOL fClearDirty) {return E_NOTIMPL;}
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize) {return E_NOTIMPL;}

	// IDirectMusicObject 
	STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

	// IDirectMusicBand
	STDMETHODIMP CreateSegment(IDirectMusicSegment** ppSegment);
	STDMETHODIMP Download(IDirectMusicPerformance* pPerformance);
	STDMETHODIMP Unload(IDirectMusicPerformance* pPerformance);

    /* IDirectMusicBand8 */
    STDMETHODIMP DownloadEx( IUnknown *pAudioPath) ;     
    STDMETHODIMP UnloadEx( IUnknown *pAudioPath) ;  

	// IDirectMusicBandPrivate
	STDMETHODIMP GetFlags(DWORD* dwFlags)
	{
		V_INAME(CBand::GetFlags);

		// Make sure we have a valid pointer
		V_PTR_WRITE(dwFlags, DWORD);

		*dwFlags = m_dwFlags;

		return S_OK;
	}
	STDMETHODIMP SetGMGSXGMode(DWORD dwMidiMode)
	{
		m_dwMidiMode = dwMidiMode;
		return S_OK;
	}

	// Class
	CBand();
	~CBand();

private:
	CBand* GetNext(){return(CBand*)AListItem::GetNext();}

	HRESULT ParseLegacyDescriptor(CRiffParser *pParser, LPDMUS_OBJECTDESC pDesc);
	HRESULT ParseDirectMusicDescriptor(CRiffParser *pParser, LPDMUS_OBJECTDESC pDesc);

	HRESULT LoadDirectMusicBand(CRiffParser *pParser, IDirectMusicLoader *pIDMLoader);
	HRESULT LoadLegacyBand(CRiffParser *pParser, IDirectMusicLoader *pIDMLoader);

	HRESULT BuildLegacyInstrumentList(const ioBandLegacy& iob,
									  IDirectMusicLoader* pIDMLoader);

	HRESULT	ExtractBandInstrument(CRiffParser *pParser,
								  IDirectMusicLoader* pIDMLoader);
	
	HRESULT	GetCollectionRefAndLoad(CRiffParser *pParser,
									IDirectMusicLoader *pIDMLoader, 
									CBandInstrument *pBandInstrument);
	
	HRESULT Load(DMUS_IO_PATCH_ITEM& rPatchEvent); // Assumes event come from a MIDI file
	HRESULT Load(CBandInstrument* pInstrument); // Assumes Instrument come from a band during cloning

	HRESULT SendMessages(CBandTrkStateData* pBTStateData,
						 MUSIC_TIME mtOffset,
						 REFERENCE_TIME rtOffset,
						 bool fClockTime);

    HRESULT AllocPMsgFromGenericTemplate(
	                    DWORD dwType,
	                    IDirectMusicPerformance *pPerformance,
	                    DMUS_PMSG **ppMsg,
	                    ULONG cb,
	                    DMUS_PMSG *pMsgGenericFields);

    HRESULT StampSendFreePMsg(
				        IDirectMusicPerformance *pPerformance,
				        IDirectMusicGraph *pGraph,
				        DMUS_PMSG *pMsg);

	HRESULT SendInstrumentAtTime(CBandInstrument* pInstrument,
								 CBandTrkStateData* pBTStateData,
								 MUSIC_TIME mtTimeToPlay,
								 MUSIC_TIME mtOffset,
								 REFERENCE_TIME rtOffset,
								 bool fClockTime);
	HRESULT LoadCollection(IDirectMusicCollection** ppIDMCollection,
						   char* szCollection,
						   IDirectMusicLoader* pIDMLoader);
	DWORD GetPChannelCount();
	HRESULT GetPChannels(DWORD *pdwPChannels, DWORD *pdwNumWritten);
	bool IsGS(DMUS_IO_PATCH_ITEM& rPatchEvent);
	bool XGInHardware(
			IDirectMusicPerformance *pPerformance,
            IDirectMusicSegmentState *pSegState,
			DWORD dwPChannel);
	HRESULT ConnectToDLSCollection(IDirectMusicCollection *pCollection);
	HRESULT MakeGMOnly();

private:
	CRITICAL_SECTION			m_CriticalSection;
    BOOL                        m_fCSInitialized;
	CBandInstrumentList			m_BandInstrumentList;
	MUSIC_TIME					m_lTimeLogical;
	MUSIC_TIME					m_lTimePhysical;
	DWORD						m_dwFlags;				
	long						m_cRef;
	CPChMap						m_PChMap;
	DWORD						m_dwGroupBits;
	DWORD						m_dwMidiMode; // midi mode message
// IDirectMusicObject variables
	DWORD	            m_dwValidData;
	GUID	            m_guidObject;
	FILETIME	        m_ftDate;                       /* Last edited date of object. */
	DMUS_VERSION	    m_vVersion;                 /* Version. */
	WCHAR	            m_wszName[DMUS_MAX_NAME];			/* Name of object.       */
	WCHAR	            m_wszCategory[DMUS_MAX_CATEGORY];	/* Category for object */
	WCHAR               m_wszFileName[DMUS_MAX_FILENAME];	/* File path. */

};

//////////////////////////////////////////////////////////////////////
// Class CBandList

class CBandList : public AList
{

public:
	CBandList(){}
	~CBandList() 
	{
		while(!IsEmpty())
		{
			CBand* pBand = RemoveHead();
			delete pBand;
		}
	}

    CBand* GetHead(){return(CBand *)AList::GetHead();}
	CBand* GetItem(LONG lIndex){return(CBand*)AList::GetItem(lIndex);}
    CBand* RemoveHead(){return(CBand *)AList::RemoveHead();}
	void Remove(CBand* pBand){AList::Remove((AListItem *)pBand);}
	void AddTail(CBand* pBand){AList::AddTail((AListItem *)pBand);}
};

class CClassFactory : public IClassFactory
{
public:
	// IUnknown
    //
	STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	// Interface IClassFactory
    //
	STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
	STDMETHODIMP LockServer(BOOL bLock); 

	// Constructor
    //
	CClassFactory(DWORD dwToolType);

	// Destructor
	~CClassFactory(); 

private:
	long m_cRef;
    DWORD m_dwClassType;
};

// We use one class factory to create all classes. We need an identifier for each 
// type so the class factory knows what it is creating.

#define CLASS_BAND          1
#define CLASS_BANDTRACK     2

#endif // #ifndef DMBANDP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmband\dmband.cpp ===
//
// dmband.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation
//

#define INITGUID
#include <objbase.h>

#include "debug.h"
#include "dmksctrl.h"
#include "dmusicc.h"
#include "dmusici.h"
#include "..\shared\dmstrm.h"
#include "dmbandp.h"
#include "bandtrk.h"
#include "debug.h"

#define MAX_LEGACY_BAND_NAME 20
#define MAX_LEGACY_COLLECTION_NAME 32

extern long g_cComponent;

static GUID nullGUID = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

//////////////////////////////////////////////////////////////////////
// Class CBand

//////////////////////////////////////////////////////////////////////
// CBand::CBand

CBand::CBand() 
{
    m_lTimeLogical = 0;
    m_lTimePhysical = 0;
    m_dwFlags = 0;
    m_dwGroupBits = 0xffffffff;
    m_dwMidiMode = 0;
    m_cRef = 1;
    m_fCSInitialized = FALSE;
    InterlockedIncrement(&g_cComponent);
    // Do this first since it can throw an exception
    //
    InitializeCriticalSection(&m_CriticalSection);
    m_fCSInitialized = TRUE;
    m_dwValidData = 0;
}

//////////////////////////////////////////////////////////////////////
// CBand::~CBand

CBand::~CBand()
{
    if (m_fCSInitialized)
    {
        m_BandInstrumentList.Clear();
        DeleteCriticalSection(&m_CriticalSection);  
    }
    
    InterlockedDecrement(&g_cComponent);
}

void CBandInstrumentList::Clear()

{
    CBandInstrument* pBandInstrument;
    while(pBandInstrument = RemoveHead())
    {
        delete pBandInstrument;
    }
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CBand::QueryInterface

STDMETHODIMP 
CBand::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(CBand::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    *ppv = NULL;

    if(iid == IID_IUnknown || iid == IID_IDirectMusicBand)
    {
        *ppv = static_cast<IDirectMusicBand*>(this);
    } 
    else if(iid == IID_IDirectMusicBandP)
    {
        *ppv = static_cast<IDirectMusicBandP*>(this);
    }
    else if(iid == IID_IDirectMusicBandPrivate)
    {
        *ppv = static_cast<IDirectMusicBandPrivate*>(this);
    }
    else if(iid == IID_IDirectMusicObject)
    {
        *ppv = static_cast<IDirectMusicObject*>(this);
    }
    else if(iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if(iid == IID_IPersist)
    {
        *ppv = static_cast<IPersist*>(this);
    }

    if (*ppv == NULL)
        return E_NOINTERFACE;
    
    reinterpret_cast<IUnknown*>(this)->AddRef();
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CBand::AddRef

STDMETHODIMP_(ULONG)
CBand::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CBand::Release

STDMETHODIMP_(ULONG)
CBand::Release()
{
    if (!InterlockedDecrement(&m_cRef)) 
    {
        m_cRef = 100; // artificial reference count to prevent reentrency due to COM aggregation
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IPersistStream

//////////////////////////////////////////////////////////////////////
// CBand::Load

STDMETHODIMP CBand::Load(IStream* pStream)
{
    V_INAME(CBand::Load);
    V_PTR_READ(pStream, IStream);

    // Get the loader from stream if it has one
    // so we can open required collections
    IDirectMusicLoader* pIDMLoader = NULL;
    IDirectMusicGetLoader *pIDMGetLoader = NULL;
    
    if (SUCCEEDED(pStream->QueryInterface(IID_IDirectMusicGetLoader,(void **)&pIDMGetLoader)))
    {
        pIDMGetLoader->GetLoader(&pIDMLoader);
        pIDMGetLoader->Release();
    }
    else
    {
        Trace(1,"Error: Band unable to reference DLS Collections because IStream does not support Loader.\n");
        return DMUS_E_UNSUPPORTED_STREAM;
    }

    EnterCriticalSection(&m_CriticalSection);

    // If we have been previously loaded, clean up instruments
    if(m_dwFlags & DMB_LOADED)
    {
        m_dwValidData = 0;
        m_BandInstrumentList.Clear();
        m_lTimeLogical = 0;
        m_lTimePhysical = 0;
        m_dwFlags = 0;
    }

    RIFFIO ckMain;
    HRESULT hr = S_OK;

    CRiffParser Parser(pStream);
    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr))
    {
        if (ckMain.fccType == FOURCC_BAND_FORM)
        {
            hr = LoadLegacyBand(&Parser, pIDMLoader);       
        }
        else if(ckMain.fccType == DMUS_FOURCC_BAND_FORM)
        {
            hr = LoadDirectMusicBand(&Parser, pIDMLoader);
        }
        else
        {
            Trace(1,"Error: Failure Parsing Band - invalid chunk ID.\n");
            hr = DMUS_E_INVALID_BAND;
        }
    }
    
    if(FAILED(hr))
    {
        m_BandInstrumentList.Clear();
    }
    
    if(pIDMLoader)
    {
        pIDMLoader->Release();
    }
    
    LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicBand

//////////////////////////////////////////////////////////////////////
// CBand::CreateSegment

STDMETHODIMP CBand::CreateSegment(IDirectMusicSegment** ppSegment)   
{
    V_INAME(IDirectMusicBand::CreateSegment);
    V_PTRPTR_WRITE(ppSegment);

    HRESULT hr = CoCreateInstance(CLSID_DirectMusicSegment,
                                  NULL,
                                  CLSCTX_INPROC,
                                  IID_IDirectMusicSegment,
                                  (void**)ppSegment);

    if(SUCCEEDED(hr))
    {
        IDirectMusicTrack* pDMTrack = NULL;
        CBandTrk *pBandTrack;

        // Create Band track

        pBandTrack = new CBandTrk;

        if (pBandTrack)
        {
            pBandTrack->QueryInterface(IID_IDirectMusicTrack,(void**)&pDMTrack);
            // Add band to track
            m_lTimePhysical--; // Subtract one from the time when creating the segment.  This is somewhat arbitrary.  (See NT5 bug 226848.)
            hr = pBandTrack->AddBand(static_cast<IDirectMusicBand*>(this));
            m_lTimePhysical++; // add the one back in
            // Set Auto-download to off
            pBandTrack->m_bAutoDownload = false;
            pBandTrack->m_fLockAutoDownload = true;

            // Insert track into segment
            hr = (*ppSegment)->InsertTrack(pDMTrack, 1);
            pDMTrack->Release();
            pBandTrack->Release(); // We don't need the original count created by the constructor.
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(FAILED(hr))
    {
        if(*ppSegment)
        {
            (*ppSegment)->Release();
            *ppSegment = NULL;
        }
    }

    return hr;
}


HRESULT CBandInstrument::Download(IDirectMusicPerformanceP *pPerformance, 
                                  IDirectMusicAudioPath *pPath,
                                  DWORD dwMidiMode)

{
    DWORD dwPChannel;
    HRESULT hr = S_OK;
    // First, if there is an audiopath, convert the band's pchannel to performance pchannel.
    if (pPath) 
    {
        hr = pPath->ConvertPChannel(m_dwPChannel,&dwPChannel);
        if (FAILED(hr))
        {
            Trace(1,"Error: Couldn't download to Audiopath because pchannel %ld is out of bounds\n",m_dwPChannel);
            // Not a valid pchannel on this audiopath.
            return hr;
        }
    }
    else
    {
        dwPChannel = m_dwPChannel;
    }

    // We need to get the port we will be downloading to. 
    IDirectMusicPort *pPort = NULL;
    DWORD dwGMFlags;
    BOOL fDownload = TRUE;

    hr = pPerformance->GetPortAndFlags(dwPChannel,&pPort,&dwGMFlags);

    // Once we know the port, we can find out whether a download has
    // already occured. And, if not, we'll use that to do the download.
    if (SUCCEEDED(hr))
    {
        CDownloadedInstrument* pDLInstrument = m_DownloadList.GetHead();

        for(; pDLInstrument; pDLInstrument = pDLInstrument->GetNext())
        {
            if (pDLInstrument->m_pPort == pPort)
            {
                // Increment reference counter and leave.
                pDLInstrument->m_cRef++;
                pPort->Release();
                return S_OK;
            }
        }

        // Okay, didn't find it, so we need to create a download record and download it. 

        if(m_fNotInFile && !m_fGMOnly)
        {
            // Unless we've set the GMOnly flag, don't download an instrument 
            // that was automatically generated from the midi
            // parsing to give a patchless channel an instrument.
            fDownload = FALSE;
        }

        else if (m_pIDMCollection == NULL)
        {
            // Can not download this instrument but still want to add a record and continue with others.
            // If instrument is a GM and GS instrument it may still play if GM or GS is supported in hardware.
            fDownload = FALSE;
            Trace(2,"Warning: No collection, unable to download instrument %lx on PChannel %ld\n",m_dwPatch,m_dwPChannel);
        }

        if (m_dwFlags & DMUS_IO_INST_GS)
        {
            // If this is a GS instrument, determine whether it needs to be downloaded.
            if ((dwGMFlags & DM_PORTFLAGS_GM) && (m_dwFlags & DMUS_IO_INST_GM))
            {
                // The synth has a GM set in ROM, and this is a GM instrument,
                // and the instrument does not specifically requests that it use the
                // DLS version in gm.dls.
                if (!(m_dwFlags & DMUS_IO_INST_USE_DEFAULT_GM_SET) )
                {
                    fDownload = FALSE;
                }
            }
            else if (dwGMFlags & DM_PORTFLAGS_GS)
            {
                // If the synth has a GS set, the problem is simpler, since it is going to be very similar to our 
                // gm.dls set, so it is okay to use it.
                fDownload = FALSE;
            }
        }

        if( dwMidiMode ) // if this is anything, it indicates we were loaded from a midi file
        {
            // if we're not an XG file, make sure channel 9 is drums
            if( (dwMidiMode != DMUS_MIDIMODEF_XG) &&
                (m_dwPChannel == 9) )
            {
                m_dwPatch |= 0x80000000;
            }
        }

        // Okay, ready to download...

        if (fDownload)
        {
            hr = DownloadAddRecord(pPort);
            // Use fallbacks for XG mode
            if( FAILED(hr) && dwMidiMode == DMUS_MIDIMODEF_XG )
            {
                DWORD dwOldPatch = m_dwPatch;
                DWORD dwOldFlags = m_dwFlags;
                DWORD dwOldAssignPatch = m_dwAssignPatch;
                // If this band failed, try clearing the MSB. If it was an XG or GS instrument,
                // and the collection doesn't have the instrument, clearing the MSB is a
                // good fallback. If that doesn't work, try clearing the LSB.
                // Also, if this band is XG see if it is on the drum channel. If so, 
                // try setting the drum bit.
                if( (m_dwPatch & 0x00ff0000) == 0x007f0000 )
                {
                    // XG drums. Try GM drums instead, but keep program change
                    m_dwPatch &= 0xff0000ff; // clear MSB and LSB
                    m_dwPatch |= 0x80000000; // set drum bit
                    m_dwFlags |= DMUS_IO_INST_ASSIGN_PATCH;
                    m_dwAssignPatch = dwOldPatch & 0x00ffffff;
                    hr = DownloadAddRecord(pPort);
                    if( FAILED(hr) )
                    {
                        // If that didn't work, try unsetting the program change
                        m_dwPatch = 0x80000000;
                        hr = DownloadAddRecord(pPort);
                    }
                }
                else
                {
                    if( (m_dwPatch & 0x00ff0000) != 0x007e0000 )
                    {
                        m_dwPatch &= 0xffff00ff; // clear LSB
                        hr = DownloadAddRecord(pPort);
                        if( FAILED(hr) )
                        {
                            if( m_dwPatch & 0x0000ff00 )
                            {
                                m_dwPatch &= 0xff0000ff; // clear MSB & LSB
                                hr = DownloadAddRecord(pPort);
                            }
                        }
                    }
                }
                if (FAILED(hr))
                {
                    // Revert back to original values
                    m_dwPatch = dwOldPatch;
                    m_dwFlags = dwOldFlags;
                    m_dwAssignPatch = dwOldAssignPatch;
                }
            }
        }
        pPort->Release();
    }
    else
    {
        Trace(1,"Error: Unable to download to Performance because pchannel %ld is not initialized on the performance.\n",m_dwPChannel);
    }
    return hr;
}



//////////////////////////////////////////////////////////////////////
// CBand::DownloadEx

STDMETHODIMP
CBand::DownloadEx(IUnknown *pAudioPath)  
{
    V_INAME(CBand::DownloadEx);
    V_PTR_READ(pAudioPath, IUnknown);
    BOOL fGotOneDown = FALSE;
    BOOL fNoInit = FALSE;
    IDirectMusicPerformance *pPerformance = NULL;
    IDirectMusicAudioPath *pPath = NULL;

    // If the band doesn't have any instruments, return immediately with S_FALSE.
    if (m_BandInstrumentList.IsEmpty())
    {
        Trace(2,"Warning: Trying to download an empty band\n");
        return S_FALSE;
    }
    HRESULT hr = pAudioPath->QueryInterface(IID_IDirectMusicAudioPath,(void **)&pPath);
    if (SUCCEEDED(hr))
    {
        hr = pPath->GetObjectInPath(0,DMUS_PATH_PERFORMANCE,0,CLSID_DirectMusicPerformance,0,IID_IDirectMusicPerformance,(void **)&pPerformance);
    }
    else
    {
        hr = pAudioPath->QueryInterface(IID_IDirectMusicPerformance,(void **)&pPerformance);
    }
    if (SUCCEEDED(hr))
    {
        EnterCriticalSection(&m_CriticalSection);
        IDirectMusicPerformanceP *pPerfp;
        hr = pPerformance->QueryInterface(IID_IDirectMusicPerformanceP, (void **)&pPerfp);
        if (SUCCEEDED(hr))
        {
            DWORD dwSuccess = 0;
            HRESULT hrTemp = S_OK;
            CBandInstrument* pBandInstrument = m_BandInstrumentList.GetHead();
            for( ; SUCCEEDED(hr) && pBandInstrument != NULL; pBandInstrument = pBandInstrument->GetNext())
            {
                hr = pBandInstrument->Download(pPerfp,pPath,m_dwMidiMode);
                if (FAILED(hr))
                {
                    if (hr == DMUS_E_NOT_INIT)
                    {
                        Trace(1,"Error: Performance is not initialized - Band download terminated.\n");
                        // Performance is not initialized. Leave now.
                        break;
                    }
                    hrTemp = hr;
                    hr = S_FALSE;
                }
                else
                {
                    // At least one succeeded.
                    dwSuccess++;
                }
            }
            // If we had a failure but it was not performance not initialized and we did have at least one
            // successful download, return a partial download success code.
            if (FAILED(hrTemp))
            {
                // Was this a partial download?
                if ((hr != DMUS_E_NOT_INIT) &&  dwSuccess)
                {
                    hr = DMUS_S_PARTIALDOWNLOAD;
                }
                // Otherwise, make sure we don't return S_FALSE for hr!
                else
                {
                    hr = hrTemp;
                }
            }
            pPerfp->Release();
        }
        LeaveCriticalSection(&m_CriticalSection);
    }
    if (pPath) pPath->Release();
    if (pPerformance) pPerformance->Release();
    return hr;
}

STDMETHODIMP
CBand::Download(
    IDirectMusicPerformance* pPerformance)  // @parm Performance to download instruments
                                            // to. The performance manages the mapping
                                            // of PChannels to DirectMusic ports.
{
    V_INAME(CBand::Download);
    V_PTR_READ(pPerformance, IDirectMusicPerformance);
    return DownloadEx(pPerformance);
}

HRESULT CBandInstrument::Unload(IDirectMusicPerformanceP *pPerformance, IDirectMusicAudioPath *pPath)

{
    DWORD dwPChannel;
    HRESULT hr = S_OK;
    // First, if there is an audiopath, convert the band's pchannel to performance pchannel.
    if (pPath) 
    {
        hr = pPath->ConvertPChannel(m_dwPChannel,&dwPChannel);
        if (FAILED(hr))
        {
            Trace(1,"Error: Couldn't download to Audiopath because pchannel %ld is out of bounds\n",m_dwPChannel);
            // Not a valid pchannel on this audiopath.
            return hr;
        }
    }
    else
    {
        dwPChannel = m_dwPChannel;
    }

    // We need to get the port we will be unloading from.
    IDirectMusicPort *pPort = NULL;
    DWORD dwGMFlags;

    hr = pPerformance->GetPortAndFlags(dwPChannel,&pPort,&dwGMFlags);

    if (SUCCEEDED(hr))
    {
        hr = S_FALSE; // Just in case we don't find the download record.
        CDownloadedInstrument* pDLInstrument = m_DownloadList.GetHead();

        for(; pDLInstrument; pDLInstrument = pDLInstrument->GetNext())
        {
            if (pDLInstrument->m_pPort == pPort)
            {
                pDLInstrument->m_cRef--;
                if(!pDLInstrument->m_cRef)
                {
                    m_DownloadList.Remove(pDLInstrument);
                    if (FAILED(pPort->UnloadInstrument(pDLInstrument->m_pDLInstrument)))
                    {
                        Trace(1, "Error: UnloadInstrument %ld failed\n",m_dwPatch);    
                    }
                    pDLInstrument->m_pDLInstrument->Release();
                    pDLInstrument->m_pDLInstrument = NULL;
                    delete pDLInstrument;
                }
                hr = S_OK;
                break;
            }
        }
        pPort->Release();
    } 
    else if (!pPath && m_DownloadList.GetCount() == 1)
    {
        CDownloadedInstrument* pDLInstrument = m_DownloadList.GetHead();

        pDLInstrument->m_cRef--;

        if (!pDLInstrument->m_cRef)
        {
            m_DownloadList.Remove(pDLInstrument);
            if (FAILED(pDLInstrument->m_pPort->UnloadInstrument(pDLInstrument->m_pDLInstrument)))
            {
                Trace(1, "Error: UnloadInstrument %ld failed\n",m_dwPatch);    
            }
            pDLInstrument->m_pDLInstrument->Release();
            pDLInstrument->m_pDLInstrument = NULL;
            delete pDLInstrument;
        }
        hr = S_OK;
    }

    return hr;        
}



//////////////////////////////////////////////////////////////////////
// CBand::UnloadEx

STDMETHODIMP
CBand::UnloadEx(IUnknown *pAudioPath)  

{
    V_INAME(CBand::UnloadEx);
    V_PTR_READ(pAudioPath, IUnknown);

    IDirectMusicPerformance *pPerformance = NULL;
    IDirectMusicAudioPath *pPath = NULL;

    HRESULT hr = pAudioPath->QueryInterface(IID_IDirectMusicAudioPath,(void **)&pPath);
    if (SUCCEEDED(hr))
    {
        hr = pPath->GetObjectInPath(0,DMUS_PATH_PERFORMANCE,0,CLSID_DirectMusicPerformance,0,IID_IDirectMusicPerformance,(void **)&pPerformance);
    }
    else
    {
        hr = pAudioPath->QueryInterface(IID_IDirectMusicPerformance,(void **)&pPerformance);
    }

    if (SUCCEEDED(hr))
    {
        hr = S_FALSE; // Returns this for empty band.
        EnterCriticalSection(&m_CriticalSection);
        IDirectMusicPerformanceP *pPerfp;
        hr = pPerformance->QueryInterface(IID_IDirectMusicPerformanceP, (void **)&pPerfp);
        if (SUCCEEDED(hr))
        {
            CBandInstrument* pBandInstrument = m_BandInstrumentList.GetHead();
            
            for( ; pBandInstrument != NULL; pBandInstrument = pBandInstrument->GetNext())
            {
                hr = pBandInstrument->Unload(pPerfp,pPath);
            }
            pPerfp->Release();
        }
        
        LeaveCriticalSection(&m_CriticalSection);
    }
    if (pPath) pPath->Release();
    if (pPerformance) pPerformance->Release();
    return hr;
}

STDMETHODIMP
CBand::Unload(
    IDirectMusicPerformance* pPerformance)  // @parm Performance to unload instruments
                                            // from. The performance manages the mapping
         
                                            // of PChannels to DirectMusic ports.
{
    V_INAME(CBand::Unload);
    V_PTR_READ(pPerformance, IDirectMusicPerformance);
    return UnloadEx(pPerformance);
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicObject

//////////////////////////////////////////////////////////////////////
// CBand::GetDescriptor

STDMETHODIMP CBand::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    V_INAME(CBand::GetDescriptor);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC);
    if (pDesc->dwSize)
    {
        V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);
    }
    else
    {
        pDesc->dwSize = sizeof(DMUS_OBJECTDESC);
    }
    pDesc->guidClass = CLSID_DirectMusicBand;
    pDesc->guidObject = m_guidObject;
    pDesc->ftDate = m_ftDate;
    pDesc->vVersion = m_vVersion;
    memcpy( pDesc->wszName, m_wszName, sizeof(m_wszName) );
    memcpy( pDesc->wszCategory, m_wszCategory, sizeof(m_wszCategory) );
    memcpy( pDesc->wszFileName, m_wszFileName, sizeof(m_wszFileName) );
    pDesc->dwValidData = ( m_dwValidData | DMUS_OBJ_CLASS );
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CBand::SetDescriptor

STDMETHODIMP CBand::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CBand::SetDescriptor);
    V_PTR_READ(pDesc, DMUS_OBJECTDESC);
    if (pDesc->dwSize)
    {
        V_STRUCTPTR_READ(pDesc, DMUS_OBJECTDESC);
    }
    
    HRESULT hr = E_INVALIDARG;
    DWORD dw = 0;

    if( pDesc->dwValidData & DMUS_OBJ_OBJECT )
    {
        m_guidObject = pDesc->guidObject;
        dw |= DMUS_OBJ_OBJECT;
    }
    if( pDesc->dwValidData & DMUS_OBJ_NAME )
    {
        memcpy( m_wszName, pDesc->wszName, sizeof(WCHAR)*DMUS_MAX_NAME );
        dw |= DMUS_OBJ_NAME;
    }
    if( pDesc->dwValidData & DMUS_OBJ_CATEGORY )
    {
        memcpy( m_wszCategory, pDesc->wszCategory, sizeof(WCHAR)*DMUS_MAX_CATEGORY );
        dw |= DMUS_OBJ_CATEGORY;
    }
    if( ( pDesc->dwValidData & DMUS_OBJ_FILENAME ) ||
        ( pDesc->dwValidData & DMUS_OBJ_FULLPATH ) )
    {
        memcpy( m_wszFileName, pDesc->wszFileName, sizeof(WCHAR)*DMUS_MAX_FILENAME );
        dw |= (pDesc->dwValidData & (DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH));
    }
    if( pDesc->dwValidData & DMUS_OBJ_VERSION )
    {
        m_vVersion = pDesc->vVersion;
        dw |= DMUS_OBJ_VERSION;
    }
    if( pDesc->dwValidData & DMUS_OBJ_DATE )
    {
        m_ftDate = pDesc->ftDate;
        dw |= DMUS_OBJ_DATE;
    }
    m_dwValidData |= dw;
    if( pDesc->dwValidData & (~dw) )
    {
        hr = S_FALSE; // there were extra fields we didn't parse;
        pDesc->dwValidData = dw;
    }
    else
    {
        hr = S_OK;
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBand::ParseDescriptor

STDMETHODIMP CBand::ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc) 
{
    V_INAME(CBand::ParseDescriptor);
    V_PTR_READ(pStream, IStream);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC);
    if (pDesc->dwSize)
    {
        V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);
    }
    else
    {
        pDesc->dwSize = sizeof(DMUS_OBJECTDESC);
    }
    
    RIFFIO ckMain;
    HRESULT hr = S_OK;

    CRiffParser Parser(pStream);
    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr))
    {
        pDesc->guidClass = CLSID_DirectMusicBand;
        pDesc->dwValidData |= DMUS_OBJ_CLASS;
        if (ckMain.fccType == FOURCC_BAND_FORM)
        {
            hr = ParseLegacyDescriptor(&Parser, pDesc);             
        }
        else if(ckMain.fccType == DMUS_FOURCC_BAND_FORM)
        {
            hr = ParseDirectMusicDescriptor(&Parser, pDesc);
        }
        else
        {
            Trace(2,"Warning: ParseDescriptor failed because this is not a Band file.\n"); 
            hr = DMUS_E_INVALID_BAND;
        }
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////
// Internal

//////////////////////////////////////////////////////////////////////
// CBand::ParseLegacyDescriptor

HRESULT CBand::ParseLegacyDescriptor(CRiffParser *pParser, LPDMUS_OBJECTDESC pDesc)
{
    RIFFIO ckNext;
    HRESULT hr = S_OK;

    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        if (ckNext.ckid == FOURCC_BAND)
        {
            ioBandLegacy Band;
            hr = pParser->Read( &Band, sizeof(Band) );
            if( SUCCEEDED(hr) )
            {
                pDesc->dwValidData |= DMUS_OBJ_NAME;
                wcsncpy(pDesc->wszName, Band.wstrName, MAX_LEGACY_BAND_NAME);
                pDesc->wszName[MAX_LEGACY_BAND_NAME - 1] = 0;
            }
        }
    }
    return hr;
}


//////////////////////////////////////////////////////////////////////
// CBand::ParseDirectMusicDescriptor
HRESULT CBand::ParseDirectMusicDescriptor(CRiffParser *pParser, LPDMUS_OBJECTDESC pDesc)
{
    RIFFIO ckNext;
    RIFFIO ckUNFO;
    HRESULT hr = S_OK;
    DWORD dwValidData = pDesc->dwValidData;

    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
        case DMUS_FOURCC_GUID_CHUNK:
            hr = pParser->Read( &pDesc->guidObject, sizeof(GUID) );
            dwValidData |= DMUS_OBJ_OBJECT;
            break;
        case DMUS_FOURCC_VERSION_CHUNK:
            hr = pParser->Read( &pDesc->vVersion, sizeof(DMUS_VERSION) );
            dwValidData |= DMUS_OBJ_VERSION;
            break;
        case DMUS_FOURCC_CATEGORY_CHUNK:
            hr = pParser->Read( &pDesc->wszCategory, sizeof(pDesc->wszCategory) );
            pDesc->wszCategory[DMUS_MAX_CATEGORY - 1] = 0;
            dwValidData |= DMUS_OBJ_CATEGORY;
        case DMUS_FOURCC_DATE_CHUNK:
            hr = pParser->Read( &pDesc->ftDate, sizeof(FILETIME) );
            dwValidData |= DMUS_OBJ_DATE;
            break;
        case FOURCC_LIST:
            switch(ckNext.fccType)
            {
            case DMUS_FOURCC_UNFO_LIST:
                pParser->EnterList(&ckUNFO);
                while (pParser->NextChunk(&hr))
                {
                    if (( ckUNFO.ckid == DMUS_FOURCC_UNAM_CHUNK ) || 
                        (ckUNFO.ckid == mmioFOURCC('I','N','A','M')))
                    {
                        hr = pParser->Read(&pDesc->wszName, sizeof(pDesc->wszName));
                        pDesc->wszName[DMUS_MAX_NAME - 1] = 0;
                        dwValidData |= DMUS_OBJ_NAME;
                    }
                }
                pParser->LeaveList();
                break;            
            }
            break;
        }
    }
    if (SUCCEEDED(hr))
    {
        pDesc->dwValidData = dwValidData;
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBand::LoadLegacyBand

HRESULT CBand::LoadLegacyBand(CRiffParser *pParser, IDirectMusicLoader* pIDMLoader)
{
    RIFFIO ckNext;
    HRESULT hr = S_OK;

    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        if (ckNext.ckid == FOURCC_BAND)
        {
            ioBandLegacy Band;
            hr = pParser->Read( &Band, sizeof(Band) );
            if( SUCCEEDED(hr) )
            {
                wcsncpy(m_wszName, Band.wstrName, MAX_LEGACY_BAND_NAME);
                m_wszName[MAX_LEGACY_BAND_NAME - 1] = 0;
                m_dwValidData |= DMUS_OBJ_NAME;
                hr = BuildLegacyInstrumentList(Band, pIDMLoader);
                if (SUCCEEDED(hr))
                {
                    m_dwFlags |= DMB_LOADED;
                    if(Band.fDefault)
                    {
                        m_dwFlags |= DMB_DEFAULT;
                    }
                }
            }
        }
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBand::LoadDirectMusicBand

HRESULT CBand::LoadDirectMusicBand(CRiffParser *pParser, IDirectMusicLoader *pIDMLoader)
{
    HRESULT hrDLS = S_OK;

    RIFFIO ckNext;
    RIFFIO ckChild;
    HRESULT hr = S_OK;

    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
        case DMUS_FOURCC_GUID_CHUNK:
            hr = pParser->Read( &m_guidObject, sizeof(GUID) );
            m_dwValidData |= DMUS_OBJ_OBJECT;
            break;
        case DMUS_FOURCC_VERSION_CHUNK:
            hr = pParser->Read( &m_vVersion, sizeof(DMUS_VERSION) );
            m_dwValidData |= DMUS_OBJ_VERSION;
            break;
        case DMUS_FOURCC_CATEGORY_CHUNK:
            hr = pParser->Read( &m_wszCategory, sizeof(WCHAR)*DMUS_MAX_CATEGORY );
            m_wszCategory[DMUS_MAX_CATEGORY - 1] = 0;
            m_dwValidData |= DMUS_OBJ_CATEGORY;
            break;
        case DMUS_FOURCC_DATE_CHUNK:
            hr = pParser->Read( &m_ftDate, sizeof(FILETIME) );
            m_dwValidData |= DMUS_OBJ_DATE;
            break;
        case FOURCC_LIST:
            switch(ckNext.fccType)
            {
            case DMUS_FOURCC_UNFO_LIST:
                pParser->EnterList(&ckChild);
                while (pParser->NextChunk(&hr))
                {
                    if (( ckChild.ckid == DMUS_FOURCC_UNAM_CHUNK ) || 
                        (ckChild.ckid == mmioFOURCC('I','N','A','M')))
                    {
                        hr = pParser->Read(&m_wszName, sizeof(m_wszName));
                        m_wszName[DMUS_MAX_NAME - 1] = 0;
                        m_dwValidData |= DMUS_OBJ_NAME;
                    }
                }
                pParser->LeaveList();
                break;
            case DMUS_FOURCC_INSTRUMENTS_LIST:
                pParser->EnterList(&ckChild);
                while (pParser->NextChunk(&hr))
                {
                    if ((ckChild.ckid == FOURCC_LIST) && 
                        (ckChild.fccType == DMUS_FOURCC_INSTRUMENT_LIST))
                    {
                        hr = ExtractBandInstrument(pParser, pIDMLoader);
                        if (hr != S_OK)
                        {
                            hrDLS = hr;
                        }
                    }
                }
                pParser->LeaveList();
                break;
            }
        }
    }
    pParser->LeaveList();

    if (hr == S_OK && hrDLS != S_OK)
    {
        hr = hrDLS;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBand::BuildLegacyInstrumentList

HRESULT CBand::BuildLegacyInstrumentList(const ioBandLegacy& iob,
                                            IDirectMusicLoader* pIDMLoader)
{
    // Legacy band channel to pchannel translation table
    static char sj_translation_table[] = { -1, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3 };

    HRESULT hrGM = S_OK;
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_CriticalSection);
    
    char szCollection[DM_LEGACY_BAND_COLLECTION_NAME_LEN];
    
    for(DWORD i = 0; SUCCEEDED(hr) && i < DMBAND_NUM_LEGACY_INSTRUMENTS; i++)
    {
        CBandInstrument* pBandInstrument = new CBandInstrument();
        if(pBandInstrument)
        {
            if(iob.awDLSBank[i] & 0x8000) 
            {
                // We have a plain old GM collection where MSB & LSB are both zero
                pBandInstrument->m_dwPatch = 0;
                pBandInstrument->m_dwPatch |= (iob.abPatch[i] & 0x7F);
                pBandInstrument->m_dwFlags |= (DMUS_IO_INST_GM | DMUS_IO_INST_GS);
            }
            else
            {
                if(iob.awDLSBank[i] & 0x4000)
                {
                    // We has a GS collection with valid MSB and LSB numbers
                    pBandInstrument->m_dwPatch = 0;
                    pBandInstrument->m_dwPatch |= (iob.abDLSPatch[i] & 0x7F);
                    pBandInstrument->m_dwPatch |= (iob.awDLSBank[i] & 0x7F) << 8; // Set LSB
                    pBandInstrument->m_dwPatch |= ((iob.awDLSBank[i] >> 7) & 0x7F) << 16; // Set MSB
                    pBandInstrument->m_dwFlags |= (DMUS_IO_INST_BANKSELECT | DMUS_IO_INST_GS | DMUS_IO_INST_GM);
                }
                else
                {
                    if(iob.szCollection[0] == '\0')
                    {
                        // We have no unique DLS file so we will assume GM
                        pBandInstrument->m_dwPatch = 0;
                        pBandInstrument->m_dwPatch |= (iob.abPatch[i] & 0x7F);
                        pBandInstrument->m_dwFlags |= (DMUS_IO_INST_GM | DMUS_IO_INST_GS);
                    }
                    else
                    {
                        // We have a unique DLS file
                        pBandInstrument->m_dwPatch = 0;
                        pBandInstrument->m_dwPatch |= (iob.abDLSPatch[i] & 0x7F);
                        pBandInstrument->m_dwPatch |= (iob.awDLSBank[i] & 0x7F) << 8; // Set LSB
                        pBandInstrument->m_dwPatch |= ((iob.awDLSBank[i] >> 7) & 0x7F) << 16; // Set MSB
                        pBandInstrument->m_dwFlags |= (DMUS_IO_INST_BANKSELECT);
                        lstrcpyn(szCollection, iob.szCollection, MAX_LEGACY_COLLECTION_NAME);
                        szCollection[MAX_LEGACY_COLLECTION_NAME - 1] = '\0';
                    }
                }
            }
            
            pBandInstrument->m_dwFlags |= (DMUS_IO_INST_TRANSPOSE | DMUS_IO_INST_PAN | DMUS_IO_INST_VOLUME | DMUS_IO_INST_PATCH);
            pBandInstrument->m_bPan = iob.abPan[i];
            pBandInstrument->m_bVolume = iob.abVolume[i];
            pBandInstrument->m_dwPChannel = sj_translation_table[i + 1];
            // Set drum-kit bit if a drum-kit
            if(pBandInstrument->m_dwPChannel % 16 == 9)
            {
                pBandInstrument->m_dwPatch |= 0x80000000;
            }

            pBandInstrument->m_nTranspose = iob.achOctave[i];
            
            pBandInstrument->m_pIDMCollection = NULL;

            // We will try to load the collection but if we can not we will continure
            // and use the default GM on the card
            
            if(pIDMLoader && (pBandInstrument->m_dwFlags & DMUS_IO_INST_GM || pBandInstrument->m_dwFlags & DMUS_IO_INST_GS))
            {
                HRESULT hrTemp = LoadCollection(&(pBandInstrument->m_pIDMCollection),
                                    NULL,
                                    pIDMLoader);
                if (FAILED(hrTemp))
                {
                    hrGM = hrTemp;
                }
            }
            else if(pIDMLoader)
            {
                HRESULT hrTemp = LoadCollection(&(pBandInstrument->m_pIDMCollection),
                                    szCollection,
                                    pIDMLoader);
                if (FAILED(hrTemp))
                {
                    hrGM = hrTemp;
                }
            }
            
            m_BandInstrumentList.AddHead(pBandInstrument);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    LeaveCriticalSection(&m_CriticalSection);

    // This function expects the caller to cleanup m_BandInstrumentList on any errors
    if (SUCCEEDED(hrGM) || hr != S_OK)
    {
        return hr;
    }
    else
    {
        return DMUS_S_PARTIALLOAD;
    }
}

//////////////////////////////////////////////////////////////////////
// CBand::ExtractBandInstrument

HRESULT CBand::ExtractBandInstrument(CRiffParser *pParser,
                                    IDirectMusicLoader* pIDMLoader)
{
    CBandInstrument* pBandInstrument = new CBandInstrument();
    
    if(pBandInstrument == NULL)
    {
        return E_OUTOFMEMORY;
    }


    RIFFIO ckNext;
    HRESULT hrGM = S_OK;
    HRESULT hr = S_OK;
    
    pParser->EnterList(&ckNext);
    while (pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
        case  DMUS_FOURCC_INSTRUMENT_CHUNK:
            {
                DMUS_IO_INSTRUMENT ioDMInst;
                ZeroMemory( &ioDMInst, sizeof(DMUS_IO_INSTRUMENT) );
                hr = pParser->Read(&ioDMInst, sizeof(DMUS_IO_INSTRUMENT));
                if(SUCCEEDED(hr))
                {
                    pBandInstrument->m_dwPatch = ioDMInst.dwPatch;
                    pBandInstrument->m_dwAssignPatch = ioDMInst.dwAssignPatch;
                    pBandInstrument->m_bPan = ioDMInst.bPan;
                    pBandInstrument->m_bVolume = ioDMInst.bVolume;
                    pBandInstrument->m_dwPChannel = ioDMInst.dwPChannel;
                    pBandInstrument->m_nTranspose = ioDMInst.nTranspose;
                    pBandInstrument->m_dwFlags = ioDMInst.dwFlags;
                    pBandInstrument->m_dwChannelPriority = ioDMInst.dwChannelPriority;
                    pBandInstrument->m_nPitchBendRange = ioDMInst.nPitchBendRange;

                    CopyMemory(&(pBandInstrument->m_dwNoteRanges[0]),
                               &(ioDMInst.dwNoteRanges[0]),
                               (sizeof(DWORD) * 4));
                    
                    pBandInstrument->m_pIDMCollection = NULL;

                }
            }
            break;
        case FOURCC_LIST :
            switch(ckNext.fccType)
            {
            case DMUS_FOURCC_REF_LIST:
                // We can only load if we have a valid loader
                if(pIDMLoader)
                {
                    HRESULT hrTemp = GetCollectionRefAndLoad(pParser,pIDMLoader,pBandInstrument);
                    if (FAILED(hrTemp))
                    {
                        hrGM = hrTemp;
                    }

                }
                break;
            }
            break;
        }
    }
    pParser->LeaveList();

    if(SUCCEEDED(hr))
    {
        if(pIDMLoader && 
           pBandInstrument->m_pIDMCollection == NULL &&
           (pBandInstrument->m_dwFlags & (DMUS_IO_INST_GM | DMUS_IO_INST_GS | DMUS_IO_INST_XG)) )
        {
            HRESULT hrTemp = LoadCollection(&(pBandInstrument->m_pIDMCollection),
                                NULL,
                                pIDMLoader);
            if (FAILED(hrTemp))
            {
                hrGM = hrTemp;
            }
        }

        m_BandInstrumentList.AddHead(pBandInstrument);
    }
    else
    {
        delete pBandInstrument;
    }

    if (SUCCEEDED(hrGM) || hr != S_OK)
    {
        return hr;
    }
    else
    {
        return DMUS_S_PARTIALLOAD;
    }
}

//////////////////////////////////////////////////////////////////////
// CBand::GetCollectionRefAndLoad

HRESULT CBand::GetCollectionRefAndLoad(CRiffParser *pParser,
                                        IDirectMusicLoader *pIDMLoader, 
                                        CBandInstrument *pBandInstrument)
{
    DMUS_OBJECTDESC desc;
    desc.dwValidData = 0;
    desc.dwSize = sizeof(desc);

    RIFFIO ckNext;
    HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);
    while (pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
        case  DMUS_FOURCC_REF_CHUNK:
            DMUS_IO_REFERENCE ioDMRef;
            hr = pParser->Read(&ioDMRef, sizeof(DMUS_IO_REFERENCE));
            desc.guidClass = ioDMRef.guidClassID;
            desc.dwValidData |= ioDMRef.dwValidData;
            desc.dwValidData |= DMUS_OBJ_CLASS;
            break;
        case DMUS_FOURCC_GUID_CHUNK:
            hr = pParser->Read(&(desc.guidObject), sizeof(GUID));
            desc.dwValidData |=  DMUS_OBJ_OBJECT;
            break;
        case DMUS_FOURCC_DATE_CHUNK:
            hr = pParser->Read(&(desc.ftDate), sizeof(FILETIME));
            desc.dwValidData |=  DMUS_OBJ_DATE;
            break;
        case DMUS_FOURCC_NAME_CHUNK:
            hr = pParser->Read(desc.wszName, sizeof(desc.wszName));
            desc.wszName[DMUS_MAX_NAME - 1] = 0;
            desc.dwValidData |=  DMUS_OBJ_NAME;
            break;
        case DMUS_FOURCC_FILE_CHUNK:
            hr = pParser->Read(desc.wszFileName, sizeof(desc.wszFileName));
            desc.wszFileName[DMUS_MAX_FILENAME - 1] = 0;
            desc.dwValidData |=  DMUS_OBJ_FILENAME;
            break;
        case DMUS_FOURCC_CATEGORY_CHUNK:
            hr = pParser->Read(desc.wszCategory, sizeof(desc.wszCategory));
            desc.wszCategory[DMUS_MAX_CATEGORY - 1] = 0;
            desc.dwValidData |=  DMUS_OBJ_CATEGORY;
            break;
        case DMUS_FOURCC_VERSION_CHUNK:
            DMUS_IO_VERSION dmioVer;
            hr = pParser->Read(&dmioVer, sizeof(DMUS_IO_VERSION));
            desc.vVersion.dwVersionMS = dmioVer.dwVersionMS;
            desc.vVersion.dwVersionLS = dmioVer.dwVersionLS;
            desc.dwValidData |= DMUS_OBJ_VERSION;
            break;
        }
    }
    pParser->LeaveList();

    if(SUCCEEDED(hr))
    {
        hr = pIDMLoader->GetObject(&desc,IID_IDirectMusicCollection, (void**)&(pBandInstrument->m_pIDMCollection));
    }
#ifdef DBG
    if (FAILED(hr))
    {
        if (desc.dwValidData &  DMUS_OBJ_FILENAME)
        {
            Trace(1,"Error: Unable to load DLS Collection from file %ls for instrument %lx\n",
                desc.wszFileName, pBandInstrument->m_dwPatch);
        }
        else if (desc.dwValidData & DMUS_OBJ_NAME)
        {
            Trace(1,"Error: Unable to load DLS Collection %ls for instrument %lx\n",
                desc.wszName, pBandInstrument->m_dwPatch);
        }
        else
        {
            Trace(1,"Error: Unable to load DLS Collection for instrument %lx\n",
                pBandInstrument->m_dwPatch);
        }
    }
#endif
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBand::Load

HRESULT CBand::Load(DMUS_IO_PATCH_ITEM& rPatchEvent)
{
    // This method is used to load PatchEvents generated by the parsing of a MIDI file.
    // Each PatchEvent represents a program change and possibly a bank select. Using 
    // this information this method will generate a band with one instrument.

    HRESULT hr = S_OK;

    EnterCriticalSection(&m_CriticalSection);
    
    CBandInstrument* pBandInstrument = NULL;

    pBandInstrument = new CBandInstrument();
        
    if(pBandInstrument)
    {
        pBandInstrument->m_dwFlags |= rPatchEvent.dwFlags;

        if(pBandInstrument->m_dwFlags & DMUS_IO_INST_PATCH)
        {
            pBandInstrument->m_dwPatch |= (rPatchEvent.byPChange & 0x7F); // Program change
        }

        if(pBandInstrument->m_dwFlags & DMUS_IO_INST_BANKSELECT)
        {
            pBandInstrument->m_dwPatch |= (rPatchEvent.byLSB & 0x7F) << 8; // Set LSB
            pBandInstrument->m_dwPatch |= (rPatchEvent.byMSB & 0x7F) << 16; // Set MSB
        }

        if(IsGS(rPatchEvent))
        {
            pBandInstrument->m_dwFlags |= DMUS_IO_INST_GS;
            if( (rPatchEvent.byLSB == 0) && (rPatchEvent.byMSB == 0) )
            {
                pBandInstrument->m_dwFlags |= DMUS_IO_INST_GM;
            }
        }

        pBandInstrument->m_dwPChannel = (rPatchEvent.byStatus & 0xF);
        pBandInstrument->m_pIDMCollection = rPatchEvent.pIDMCollection;
        pBandInstrument->m_fNotInFile = rPatchEvent.fNotInFile;
        if(pBandInstrument->m_pIDMCollection)
        {
            (pBandInstrument->m_pIDMCollection)->AddRef();
        }
        
        // Set the time for the band. Since this band will have only one instrument in
        // it we use the time for PatchEvent as the time for the band
        m_lTimeLogical = rPatchEvent.lTime;
        m_lTimePhysical = m_lTimeLogical;
        
        m_BandInstrumentList.AddHead(pBandInstrument);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    if(SUCCEEDED(hr))
    {
        m_dwFlags |= DMB_LOADED;
    }
    else
    {
        if(pBandInstrument)
        {
            delete pBandInstrument;
        }
    }

    LeaveCriticalSection(&m_CriticalSection);
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBand::Load

HRESULT CBand::Load(CBandInstrument* pInstrument)
{
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_CriticalSection);
    
    CBandInstrument* pBandInstrument = NULL;

    pBandInstrument = new CBandInstrument();
        
    if(pBandInstrument)
    {
        pBandInstrument->m_dwPatch = pInstrument->m_dwPatch;
        pBandInstrument->m_dwAssignPatch = pInstrument->m_dwAssignPatch;
        pBandInstrument->m_dwPChannel = pInstrument->m_dwPChannel;
        pBandInstrument->m_dwFlags = pInstrument->m_dwFlags;
        pBandInstrument->m_bPan = pInstrument->m_bPan;
        pBandInstrument->m_bVolume = pInstrument->m_bVolume;
        pBandInstrument->m_nTranspose = pInstrument->m_nTranspose;
        pBandInstrument->m_pIDMCollection = pInstrument->m_pIDMCollection;

        CopyMemory(pBandInstrument->m_dwNoteRanges, pInstrument->m_dwNoteRanges, sizeof(pInstrument->m_dwNoteRanges)); 
        if(pBandInstrument->m_pIDMCollection)
        {
            (pBandInstrument->m_pIDMCollection)->AddRef();
        }

        m_BandInstrumentList.AddHead(pBandInstrument);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if(SUCCEEDED(hr))
    {
        m_dwFlags |= DMB_LOADED;
    }
    else
    {
        if(pBandInstrument)
        {
            delete pBandInstrument;
        }
    }

    LeaveCriticalSection(&m_CriticalSection);
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBand::SendMessages

HRESULT CBand::SendMessages(CBandTrkStateData* pBTStateData,
                               MUSIC_TIME mtOffset,
                               REFERENCE_TIME rtOffset,
                               bool fClockTime)
{
    if(pBTStateData == NULL)
    {   
        return E_POINTER;
    }
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_CriticalSection);

    CBandInstrument* pInstrument = m_BandInstrumentList.GetHead();
    for( ; pInstrument && SUCCEEDED(hr); pInstrument = pInstrument->GetNext())
    {
        if( pInstrument->m_fNotInFile && !pInstrument->m_fGMOnly )
        {
            // don't send program changes for instruments that were automatically
            // generated by midi file parsing, unless we've set GMOnly.
            continue;
        }
        hr = SendInstrumentAtTime(pInstrument, pBTStateData, m_lTimePhysical, mtOffset, rtOffset, fClockTime);
    }
    
    LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

HRESULT CBand::AllocPMsgFromGenericTemplate(
    DWORD dwType,
    IDirectMusicPerformance *pPerformance,
    DMUS_PMSG **ppMsg,
    ULONG cb,
    DMUS_PMSG *pMsgGenericFields)
{
    HRESULT hr = pPerformance->AllocPMsg(cb, ppMsg);
    if (SUCCEEDED(hr))
    {
        DWORD dwSize = (*ppMsg)->dwSize; // Remember the size.
        assert(dwSize == cb);
        ZeroMemory(*ppMsg, cb); // Clear it - ensures we zero the non-DMUS_PMSG_PART fields.
        CopyMemory(*ppMsg, pMsgGenericFields, sizeof(*pMsgGenericFields)); // Copy the DMUS_PMSG_PART fields.

        // Fill in the correct size and type
        (*ppMsg)->dwSize = dwSize;
        (*ppMsg)->dwType = dwType;
    }
    return hr;
}

HRESULT CBand::StampSendFreePMsg(
                IDirectMusicPerformance *pPerformance,
                IDirectMusicGraph *pGraph,
                DMUS_PMSG *pMsg)
{
    // Let the graph set the delivery parameters.
    HRESULT hr = pGraph->StampPMsg(pMsg);
    if (SUCCEEDED(hr))
        hr = pPerformance->SendPMsg(pMsg);
    if (FAILED(hr))
        hr = pPerformance->FreePMsg(pMsg);
    return hr;
}

HRESULT CBand::SendInstrumentAtTime(CBandInstrument* pInstrument, 
                                       CBandTrkStateData* pBTStateData, 
                                       MUSIC_TIME mtTimeToPlay,
                                       MUSIC_TIME mtOffset,
                                       REFERENCE_TIME rtOffset,
                                       bool fClockTime)
{
    if(pInstrument == NULL || pBTStateData == NULL)
    {
        return E_POINTER;
    }

    IDirectMusicGraph *pGraph = NULL;
    IDirectMusicPerformance *pPerformance = pBTStateData->m_pPerformance;
    DWORD dwVirtualTrackID = pBTStateData->m_dwVirtualTrackID;
    DWORD dwPatch = 0;
    BOOL fMute;
    DWORD dwPChannel;

    // Get the mute/pchannel reassignment.
    MUSIC_TIME mtParam = ( m_lTimeLogical < 0 ) ? 0 : m_lTimeLogical;
    m_PChMap.GetInfo( pInstrument->m_dwPChannel, mtParam, mtOffset, m_dwGroupBits,
        pPerformance, &fMute, &dwPChannel, fClockTime );
    if( fMute )
        return S_OK;

    HRESULT hr = pBTStateData->m_pSegmentState->QueryInterface(IID_IDirectMusicGraph,
                                                               reinterpret_cast<void**>(&pGraph));
    if(FAILED(hr))
        return hr;

    EnterCriticalSection(&m_CriticalSection);

    DMUS_PMSG pmsgGeneric; // template for stamping out the common fields in the various specific kinds of messages
    ZeroMemory(&pmsgGeneric, sizeof(pmsgGeneric));
    if (fClockTime)
    {
        pmsgGeneric.rtTime =  mtTimeToPlay * REF_PER_MIL + rtOffset;
        pmsgGeneric.dwFlags |= DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
    }
    else
    {
        pmsgGeneric.mtTime =  mtTimeToPlay + mtOffset;
        pmsgGeneric.dwFlags |= DMUS_PMSGF_MUSICTIME;
    }
    pmsgGeneric.dwPChannel = dwPChannel;
    pmsgGeneric.dwVirtualTrackID = dwVirtualTrackID;
    pmsgGeneric.dwGroupID = m_dwGroupBits;

    if(pInstrument->m_dwFlags & DMUS_IO_INST_PATCH)
    {
        if(pInstrument->m_dwFlags & DMUS_IO_INST_BANKSELECT)
        {
            if(pInstrument->m_dwFlags & DMUS_IO_INST_ASSIGN_PATCH)
            {
                dwPatch = pInstrument->m_dwAssignPatch & 0x007F7F00;            
            }
            else
            {
                dwPatch = pInstrument->m_dwPatch & 0x007F7F00;

                // if the m_fGMOnly flag is set, and either we're GS or we're XG and
                // the instument's port supports XG, use the full patch
                if (pInstrument->m_fGMOnly || (pInstrument->m_dwFlags & DMUS_IO_INST_XG))
                {
                    bool fXG = XGInHardware(pPerformance,pBTStateData->m_pSegmentState,pInstrument->m_dwPChannel);
                    if(pInstrument->m_fGMOnly)
                    {
                        if ( m_dwMidiMode & DMUS_MIDIMODEF_GS )
                        {
                            dwPatch = pInstrument->m_dwFullPatch & 0x007F7F00;
                        }
                        if ( (m_dwMidiMode & DMUS_MIDIMODEF_XG) && fXG )
                        {
                            dwPatch = pInstrument->m_dwFullPatch & 0x007F7F00;
                        }
                    }
                    // If the instrument is an XG instrument and the hardware doesn't support
                    // XG, strip off the bank selects.
                    if ( (pInstrument->m_dwFlags & DMUS_IO_INST_XG) && !fXG)
                    {
                        dwPatch = 0;
                    }
                }
            }
        }

        // Now, get the program change.
        if(pInstrument->m_dwFlags & DMUS_IO_INST_ASSIGN_PATCH)
        {
            dwPatch |= pInstrument->m_dwAssignPatch & 0x7f; 
        }
        else
        {
            dwPatch |= pInstrument->m_dwPatch & 0x7f;   
        }

        DMUS_PATCH_PMSG *pMsg = NULL;
        hr = AllocPMsgFromGenericTemplate(DMUS_PMSGT_PATCH, pPerformance, reinterpret_cast<DMUS_PMSG**>(&pMsg), sizeof(*pMsg), &pmsgGeneric);
        if(SUCCEEDED(hr))
        {
            // DMUS_PATCH_PMSG members that need to be initialized 
            pMsg->byInstrument = (BYTE) dwPatch & 0x7F;
            pMsg->byMSB = (BYTE) ((dwPatch >> 16) & 0x7F);
            pMsg->byLSB = (BYTE) ((dwPatch >> 8) & 0x7F);

            hr = StampSendFreePMsg(pPerformance, pGraph, reinterpret_cast<DMUS_PMSG*>(pMsg));
        }
    }

    if(pInstrument->m_dwFlags & DMUS_IO_INST_TRANSPOSE)
    {
        DMUS_TRANSPOSE_PMSG *pMsg = NULL;
        hr = AllocPMsgFromGenericTemplate(DMUS_PMSGT_TRANSPOSE, pPerformance, reinterpret_cast<DMUS_PMSG**>(&pMsg), sizeof(*pMsg), &pmsgGeneric);
        if(SUCCEEDED(hr))
        {
            // DMUS_TRANSPOSE_PMSG members that need to be initialized 
            pMsg->nTranspose = pInstrument->m_nTranspose;

            hr = StampSendFreePMsg(pPerformance, pGraph, reinterpret_cast<DMUS_PMSG*>(pMsg));
        }
    }

    if(pInstrument->m_dwFlags & DMUS_IO_INST_VOLUME)
    {
        // Set Volume
        DMUS_MIDI_PMSG* pMsg = NULL;
        hr = AllocPMsgFromGenericTemplate(DMUS_PMSGT_MIDI, pPerformance, reinterpret_cast<DMUS_PMSG**>(&pMsg), sizeof(*pMsg), &pmsgGeneric);

        if(SUCCEEDED(hr))
        {
            // DMUS_MIDI_PMSG members that need to be initialized 
            pMsg->bStatus = MIDI_CONTROL_CHANGE;
            pMsg->bByte1 = MIDI_CC_VOLUME;
            pMsg->bByte2 = pInstrument->m_bVolume;

            hr = StampSendFreePMsg(pPerformance, pGraph, reinterpret_cast<DMUS_PMSG*>(pMsg));
        }
    }

    if(pInstrument->m_dwFlags & DMUS_IO_INST_PAN)
    {
        // Set Pan
        DMUS_MIDI_PMSG* pMsg = NULL;
        hr = AllocPMsgFromGenericTemplate(DMUS_PMSGT_MIDI, pPerformance, reinterpret_cast<DMUS_PMSG**>(&pMsg), sizeof(*pMsg), &pmsgGeneric);

        if(SUCCEEDED(hr))
        {
            // DMUS_MIDI_PMSG members that need to be initialized 
            pMsg->bStatus = MIDI_CONTROL_CHANGE;
            pMsg->bByte1 = MIDI_CC_PAN;
            pMsg->bByte2 = pInstrument->m_bPan;

            hr = StampSendFreePMsg(pPerformance, pGraph, reinterpret_cast<DMUS_PMSG*>(pMsg));
        }
    }

    if(pInstrument->m_dwFlags & DMUS_IO_INST_CHANNEL_PRIORITY)
    {
        DMUS_CHANNEL_PRIORITY_PMSG *pMsg = NULL;
        hr = AllocPMsgFromGenericTemplate(DMUS_PMSGT_CHANNEL_PRIORITY, pPerformance, reinterpret_cast<DMUS_PMSG**>(&pMsg), sizeof(*pMsg), &pmsgGeneric);
        if(SUCCEEDED(hr))
        {
            // DMUS_CHANNEL_PRIORITY_PMSG members that need to be initialized 
            pMsg->dwChannelPriority = pInstrument->m_dwChannelPriority;

            hr = StampSendFreePMsg(pPerformance, pGraph, reinterpret_cast<DMUS_PMSG*>(pMsg));
        }
    }

    if(pInstrument->m_dwFlags & DMUS_IO_INST_PITCHBENDRANGE)
    {
        DMUS_CURVE_PMSG *pMsg = NULL;
        hr = AllocPMsgFromGenericTemplate(DMUS_PMSGT_CURVE, pPerformance, reinterpret_cast<DMUS_PMSG**>(&pMsg), sizeof(*pMsg), &pmsgGeneric);
        if(SUCCEEDED(hr))
        {
            pMsg->dwFlags |= DMUS_PMSGF_DX8; // pitch band is a DX8-only flag

            // DMUS_CURVE_PMSG members that need to be initialized 
            pMsg->nEndValue = pInstrument->m_nPitchBendRange << 7;
            pMsg->nOffset = static_cast<short>(m_lTimePhysical - m_lTimeLogical);
            pMsg->bType = DMUS_CURVET_RPNCURVE;
            pMsg->bCurveShape = DMUS_CURVES_INSTANT;
            pMsg->wParamType = RPN_PITCHBEND;
            // Leave as zero: mtDuration, mtOriginalStart, mtResetDuration, nStartValue, nResetValue,
            //                wMeasure, bBeat, bGrid, wMergeIndex

            hr = StampSendFreePMsg(pPerformance, pGraph, reinterpret_cast<DMUS_PMSG*>(pMsg));
        }
    }

    pGraph->Release();
    
    LeaveCriticalSection(&m_CriticalSection);

    return hr;
}


//////////////////////////////////////////////////////////////////////
// CBand::LoadCollection

HRESULT CBand::LoadCollection(IDirectMusicCollection** ppIDMCollection,
                                 char* pszCollection,
                                 IDirectMusicLoader* pIDMLoader)
{
    // Any changes made to this function should also be made to LoadCollection
    // in dmime.dll

    assert(ppIDMCollection);
    assert(pIDMLoader);

    DMUS_OBJECTDESC desc;
    ZeroMemory(&desc, sizeof(desc));
    desc.dwSize = sizeof(desc);

    desc.guidClass = CLSID_DirectMusicCollection;

    if(pszCollection == NULL)
    {
        desc.guidObject = GUID_DefaultGMCollection;
        desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_OBJECT);
    }
    else
    {
        MultiByteToWideChar(CP_ACP, 0, pszCollection, -1, desc.wszName, DMUS_MAX_NAME);
        desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_NAME);
    }

    HRESULT hr = pIDMLoader->GetObject(&desc,IID_IDirectMusicCollection, (void**)ppIDMCollection);
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBand::GetPChannelCount

DWORD CBand::GetPChannelCount()
{
    EnterCriticalSection(&m_CriticalSection);

    DWORD dwCount = 0;
    CBandInstrument* pInstrument = m_BandInstrumentList.GetHead();
    for( ; pInstrument; pInstrument = pInstrument->GetNext())
    {
        dwCount++;
    }
    
    LeaveCriticalSection(&m_CriticalSection);

    return dwCount;
}

//////////////////////////////////////////////////////////////////////
// CBand::GetPChannels

HRESULT CBand::GetPChannels(DWORD *pdwPChannels, DWORD *pdwNumWritten)
{
    assert(pdwPChannels);
    assert(pdwNumWritten);

    EnterCriticalSection(&m_CriticalSection);
    
    *pdwNumWritten = 0;

    CBandInstrument* pInstrument = m_BandInstrumentList.GetHead();
    for(; pInstrument; pInstrument = pInstrument->GetNext())
    {
        *pdwPChannels++ = pInstrument->m_dwPChannel;
        (*pdwNumWritten)++;
    }

    LeaveCriticalSection(&m_CriticalSection);

    return S_OK;
}

HRESULT CBandInstrument::BuildNoteRangeArray(DWORD *pNoteRangeMap, DMUS_NOTERANGE **ppNoteRanges, DWORD *pdwNumNoteRanges)
{
    const int c_iIn = 0;
    const int c_iOut = 1;

    HRESULT hr = S_OK;

    // Count the number of DMUS_NOTERANGE structures we need to allocate
    DWORD dwNRNum = 0;
    int nState = c_iOut;
    for(int i = 0; i < 4; i++)
    {
        DWORD dwTemp = pNoteRangeMap[i];
        DWORD dwBitPos = 0;
        while(dwBitPos < 32)
        {
            if(dwTemp & 0x1ul)
            {
                if(nState == c_iOut)
                {
                    nState = c_iIn;
                    dwNRNum++;
                }
            }
            else
            {
                nState = c_iOut;
            }
            
            dwTemp = dwTemp >> 1;
            dwBitPos++;
        }   
    }

    // If the NoteRangeMap is empty or full we do nothing
    // since this will cause NULL to be returned which means we 
    // want to download the complete instrument
    if(dwNRNum && dwNRNum < 128)
    {
        *ppNoteRanges = new DMUS_NOTERANGE[dwNRNum];
        if(*ppNoteRanges)
        {
            DWORD dwNRIdx = 0;

            for(dwNRIdx = 0; dwNRIdx < dwNRNum; dwNRIdx++)
            {
                (*ppNoteRanges)[dwNRIdx].dwLowNote = 0;
                (*ppNoteRanges)[dwNRIdx].dwHighNote = 127;
            }

            dwNRIdx = 0;
            nState = c_iOut;
            for(int i = 0; i < 4; i++)
            {
                DWORD dwTemp = pNoteRangeMap[i];
                DWORD dwBitPos = 0;
                while(dwBitPos < 32)
                {
                    if(dwTemp & 0x1ul)
                    {
                        if(nState == c_iOut)
                        {
                            nState = c_iIn;
                            (*ppNoteRanges)[dwNRIdx].dwLowNote = dwBitPos + (i * 32);
                        }
                    }
                    else if(nState == c_iIn)
                    {
                        (*ppNoteRanges)[dwNRIdx].dwHighNote = dwBitPos + (i * 32) - 1;
                        nState = c_iOut;
                        dwNRIdx++;
                    }
                    
                    dwTemp = dwTemp >> 1;
                    dwBitPos++;
                }   
            }

            assert(nState == c_iIn ? dwNRIdx == dwNRNum - 1 : dwNRIdx == dwNRNum);

            *pdwNumNoteRanges = dwNRNum;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        *ppNoteRanges = NULL;
        *pdwNumNoteRanges = 0;
    }
    
    return hr;  
}


//////////////////////////////////////////////////////////////////////
// CBand::IsGS

bool CBand::IsGS(DMUS_IO_PATCH_ITEM& rPatchEvent)
{
    BYTE    bMSB = 0;
    BYTE    bPatch = 0;

    if( rPatchEvent.dwFlags & DMUS_IO_INST_BANKSELECT )
    {
        if( rPatchEvent.byLSB != 0 ) return FALSE; // LSB must be 0 for GS
        bMSB = rPatchEvent.byMSB;
    }
    if( rPatchEvent.dwFlags & DMUS_IO_INST_PATCH )
    {
        bPatch = rPatchEvent.byPChange & 0x7F;
    }

    if( bMSB == 0)
    {
        // If this is a drum kit (on MIDI channel 10)
        if( (rPatchEvent.byStatus  & 0xF) == 10 )
        {
            if ((bPatch == 0x0)  ||
                (bPatch == 0x08) ||
                (bPatch == 0x10) ||
                (bPatch == 0x18) ||
                (bPatch == 0x19) ||
                (bPatch == 0x20) ||
                (bPatch == 0x28) ||
                (bPatch == 0x30) || 
                (bPatch == 0x38) )
            {
                return  true;
            }
            else
                return false;
        }
        else return true;//is GM
    }
    // check for GS
    switch (bMSB)
    {
        case 6:
        case 7:
            if (bPatch == 0x7D) return true;
            break;
        case 24:
            if ((bPatch == 0x04) || (bPatch == 0x06)) return true;
            break;
        case 9:
            if ((bPatch == 0x0E) || (bPatch == 0x76) || (bPatch == 0x7D)) return true;
            break;
        case 2:
            if ( (bPatch == 0x66) || (bPatch == 0x78) || ((bPatch > 0x79)&&(bPatch < 0x80) )) return true;
            break;
        case 3:
            if ((bPatch > 0x79) && (bPatch < 0x80)) return true;
            break;
        case 4:
        case 5:
            if ( (bPatch == 0x7A) || ((bPatch > 0x7B)&&(bPatch < 0x7F) )) return true;
            break;
        case 32:
            if ((bPatch == 0x10) ||
                (bPatch == 0x11) ||
                (bPatch == 0x18) ||
                (bPatch == 0x34) ) return true;
            break;
        case 1:
            if ((bPatch == 0x26) ||
                (bPatch == 0x39) ||
                (bPatch == 0x3C) ||
                (bPatch == 0x50) ||
                (bPatch == 0x51) ||
                (bPatch == 0x62) ||
                (bPatch == 0x66) ||
                (bPatch == 0x68) ||
                ((bPatch > 0x77) && (bPatch < 0x80))) return true;
                break;
        case 16:
            switch (bPatch)
            {
                case 0x00:
                    return true;
                    break;
                case 0x04:
                    return true;
                    break;
                case 0x05:
                    return true;
                    break;
                case 0x06:
                    return true;
                    break;
                case 0x10:
                    return true;
                    break;
                case 0x13:
                    return true;
                    break;
                case 0x18:
                    return true;
                    break;
                case 0x19:
                    return true;
                    break;
                case 0x1C:
                    return true;
                    break;
                case 0x27:
                    return true;
                    break;
                case 0x3E:
                    return true;
                    break;
                case 0x3F:
                    return true;
                    break;
                default:
                    return false;
            }
            break;
        case 8:
            if ((bPatch < 0x07) || ((bPatch == 0x7D)))
            {
                return true;
            }
            else if ((bPatch > 0x3F) && (bPatch < 0x50))
            {
                return false;
            }
            else if ((bPatch > 0x4F) && (bPatch < 0x72)  )
            {
                if ((bPatch == 0x50) || 
                    (bPatch == 0x51) ||
                    (bPatch == 0x6B))
                {
                    return true;
                }
                return false;
            }
            else if ((bPatch > 0x1F) && (bPatch < 0x40))
            {
                if ((bPatch > 0x25) && (bPatch < 0x29) ||
                    (bPatch > 0x3C)  ||
                    (bPatch == 0x30) || 
                    (bPatch == 0x32) )
                {
                    return true;
                }
                return false;
            }
            else if ((bPatch > 0x0A) && (bPatch < 0x12) && 
                     (bPatch != 0x0D) && (bPatch != 0x0F))
            {
                return true;
            }
            else if ((bPatch > 0x0F) && (bPatch < 0x20))
            {
                if (bPatch > 0x17)
                {
                    return true;
                }
                else if ( (bPatch == 0x13) || (bPatch == 0x15) )
                    return true;
                else
                    return false;
            }
            break;
        default:
            return false;
    }
    return false;
}

HRESULT CBandInstrument::DownloadAddRecord(IDirectMusicPort *pPort)

{
    IDirectMusicInstrument* pInstrument = NULL;
    
    HRESULT hr = m_pIDMCollection->GetInstrument(m_dwPatch, &pInstrument);
    
    if (FAILED(hr) && (m_dwFlags & (DMUS_IO_INST_GM | DMUS_IO_INST_GS | DMUS_IO_INST_XG)))
    {
        // If drums, set to standard drums.
        if (m_dwPatch & 0x80000000)
        {
            m_dwPatch = 0;
        }
        // Else make this a GM melodic instrument.
        else
        {
            m_dwPatch &= 0x7F;
        }
        hr = m_pIDMCollection->GetInstrument(m_dwPatch, &pInstrument);
    }

    if(SUCCEEDED(hr) && m_dwFlags & DMUS_IO_INST_ASSIGN_PATCH)
    {
        hr = pInstrument->SetPatch(m_dwAssignPatch);
    }
    
    if(SUCCEEDED(hr))
    {
        CDownloadedInstrument* pDLInstrument = new CDownloadedInstrument;

        if(pDLInstrument)
        {
            pDLInstrument->m_pPort = pPort;
            pPort->AddRef();
            pDLInstrument->m_cRef = 1;

            DMUS_NOTERANGE *pNoteRanges = NULL;
            DWORD dwNumNoteRanges = 0;
            if(m_dwFlags & DMUS_IO_INST_NOTERANGES)
            {
                BuildNoteRangeArray(m_dwNoteRanges, &pNoteRanges, &dwNumNoteRanges);
            }
            hr = pPort->DownloadInstrument( pInstrument, 
                                            &pDLInstrument->m_pDLInstrument, 
                                            pNoteRanges, 
                                            dwNumNoteRanges );
            if (pNoteRanges)
            {
                delete [] pNoteRanges;
            }

            if(SUCCEEDED(hr))
            {
                m_DownloadList.AddHead(pDLInstrument);              
            }
            else
            {
                delete pDLInstrument;
#ifdef DBG
                if (hr == DMUS_E_NOT_INIT)
                {
                    Trace(0,"Error: Download failed because performance not initialized\n"); 
                }
                else
                {
                    Trace(1,"Error: Unable to download instrument %lx to PChannel %ld\n",
                        m_dwPatch,m_dwPChannel); 
                }
#endif
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
            Trace(0,"Error: Memory allocation failure - Unable to download instrument\n"); 
        }
    }
    else
    {
        Trace(1,"Error: Unable to download instrument %lx; not in dls collection\n",m_dwPatch);
    }

    if (pInstrument)
    {
        pInstrument->Release();
    }
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CBand::XGInHardware

bool CBand::XGInHardware(
            IDirectMusicPerformance *pPerformance,
            IDirectMusicSegmentState *pSegState,
            DWORD dwPChannel)
{
    DWORD dwGMFlags = 0;        
    // If this is playing via an audiopath, we need to access the audiopath to 
    // convert the pchannels so we can use them to access the right port.
    IDirectMusicSegmentState8 *pState8;
    if (SUCCEEDED(pSegState->QueryInterface(IID_IDirectMusicSegmentState8,(void **) &pState8)))
    {
        IDirectMusicAudioPath *pAudioPath;
        if (SUCCEEDED(pState8->GetObjectInPath(DMUS_PCHANNEL_ALL,DMUS_PATH_AUDIOPATH,0,
            GUID_All_Objects,0,IID_IDirectMusicAudioPath,(void **) &pAudioPath)))
        {
            pAudioPath->ConvertPChannel(dwPChannel, &dwPChannel);
            pAudioPath->Release();
        }
        pState8->Release();
    }
    // Now, use the PChannel and the performance to read the flags.
    IDirectMusicPort *pPort = NULL;
    IDirectMusicPerformanceP *pPerfp;
    if (SUCCEEDED(pPerformance->QueryInterface(IID_IDirectMusicPerformanceP, (void **)&pPerfp)))
    {
        if (SUCCEEDED(pPerfp->GetPortAndFlags(dwPChannel,&pPort,&dwGMFlags)))
        {
            pPort->Release();
        }
        pPerfp->Release();
    }
    return ((dwGMFlags & DM_PORTFLAGS_XG) && TRUE);
}


//////////////////////////////////////////////////////////////////////
// CBand::MakeGMOnly

HRESULT CBand::MakeGMOnly()
{
    EnterCriticalSection(&m_CriticalSection);

    CBandInstrument* pBandInstrument = m_BandInstrumentList.GetHead();

    for( ; pBandInstrument != NULL; pBandInstrument = pBandInstrument->GetNext())
    {
        pBandInstrument->m_fGMOnly = true;
        pBandInstrument->m_dwFullPatch = pBandInstrument->m_dwPatch;

        DWORD dwTemp = pBandInstrument->m_dwPatch;
        pBandInstrument->m_dwPatch = (dwTemp & 0x7F);

        // If a drum kit set drum kit flag
        if( m_dwMidiMode == DMUS_MIDIMODEF_XG )
        {
            if( (dwTemp & 0x00ff0000) == 0x007f0000 )
            {
                // XG drums. Keep this msb, as it is taken care of in the :Download function.
                pBandInstrument->m_dwPatch |= 0x007f0000;
            }
        }
        if(dwTemp & 0x80000000)
        {
            pBandInstrument->m_dwPatch |= 0x80000000;
        }
    }
    
    LeaveCriticalSection(&m_CriticalSection);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CBand::ConnectToDLSCollection

HRESULT CBand::ConnectToDLSCollection(IDirectMusicCollection *pCollection)
{
    assert(pCollection);

    EnterCriticalSection(&m_CriticalSection);

    CBandInstrument* pBandInstrument = m_BandInstrumentList.GetHead();

    for( ; pBandInstrument != NULL; pBandInstrument = pBandInstrument->GetNext())
    {
        if(pBandInstrument->m_pIDMCollection == NULL)
        {
            pCollection->AddRef();
            pBandInstrument->m_pIDMCollection = pCollection;
        }
        else
        {
            if( m_dwMidiMode ) // if this is anything, it indicates we were loaded from a midi file
            {
                // if we're not an XG file, make sure channel 9 is drums
                if( (m_dwMidiMode != DMUS_MIDIMODEF_XG) &&
                    (pBandInstrument->m_dwPChannel == 9) )
                {
                    pBandInstrument->m_dwPatch |= 0x80000000;
                }
            }
            // if we get an instrument from this collection, set the band's collection
            // pointer to it instead.
            IDirectMusicInstrument* pInstrument = NULL;
            
            if( SUCCEEDED( pCollection->GetInstrument(pBandInstrument->m_dwPatch, &pInstrument)))
            {
                pBandInstrument->m_pIDMCollection->Release();
                pBandInstrument->m_pIDMCollection = pCollection;
                pCollection->AddRef();
                pInstrument->Release();
            }
        }
    }

    LeaveCriticalSection(&m_CriticalSection);   
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmband\oledll.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
//
//
#ifndef _OLEDLL_
#define _OLEDLL_

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID);

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID);

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue);
				 
HRESULT CLSIDToStr(const CLSID &clsid,
				   TCHAR *szStr,
				   int cbStr);

HRESULT StrToCLSID(TCHAR *szStr,
				   CLSID &clsid,
				   int cbStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmband\dmstrm.cpp ===
//
// dmstrm.cpp
// 
// Copyright (c) 1995-2000 Microsoft Corporation
//

#include "debug.h"
#include "dmusicc.h"
#include "..\shared\dmstrm.h"
#include "..\shared\validate.h"

CRiffParser::CRiffParser(IStream *pStream)

{
    assert(pStream);
    m_fDebugOn = FALSE;
    m_pStream = pStream; 
    m_pParent = NULL;
    m_pChunk = NULL;
    m_lRead = 0;
    m_fFirstPass = TRUE;
    m_fComponentFailed = FALSE;
    m_fInComponent = FALSE;
}

void CRiffParser::EnterList(RIFFIO *pChunk)

{
    assert (pChunk);
    pChunk->lRead = 0;
    pChunk->pParent = m_pChunk; // Previous chunk (could be NULL.)
    m_pParent = m_pChunk;
    m_pChunk = pChunk;
    m_fFirstPass = TRUE;
}

void CRiffParser::LeaveList()

{
    assert (m_pChunk);
    if (m_pChunk)
    {
        m_pChunk = m_pChunk->pParent;
        if (m_pChunk)
        {
            m_pParent = m_pChunk->pParent;
        }
    }
}

BOOL CRiffParser::NextChunk(HRESULT * pHr)

{
    BOOL fMore = FALSE;
    if (SUCCEEDED(*pHr))
    {
        // If this is the first time we've entered this list, there is no previous chunk.
        if (m_fFirstPass)
        {
            // Clear the flag.
            m_fFirstPass = FALSE;
        }
        else
        {
            // Clean up the previous pass.
            *pHr = LeaveChunk();
        }
        // Find out if there are more chunks to read.
        fMore = MoreChunks();
        // If so, and we don't have any failure, go ahead and read the next chunk header.
        if (fMore && SUCCEEDED(*pHr))
        {
            *pHr = EnterChunk();
        }
    }
    else
    {
#ifdef DBG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            Trace(0,"Error parsing %s, Read %ld of %ld\n",szName,m_pChunk->lRead,RIFF_ALIGN(m_pChunk->cksize));
        }
#endif
        // If we were in a component, it's okay to fail. Mark that fact by setting
        // m_fComponentFailed then properly pull out of the chunk so we can
        // continue reading.
        if (m_fInComponent) 
        {
            m_fComponentFailed = TRUE;
            // We don't need to check for first pass, because we must have gotten
            // that far. Instead, we just clean up from the failed chunk.
            // Note that this sets the hresult to S_OK, which is what we want.
            // Later, the caller needs to call ComponentFailed() to find out if
            // this error occured.
            *pHr = LeaveChunk();
        }
        else
        {
            // Clean up but leave the error code.
            LeaveChunk();
        }
    }
    return fMore && SUCCEEDED(*pHr);
}

BOOL CRiffParser::MoreChunks()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        if (m_pParent)
        {
            // Return TRUE if there's enough room for another chunk.
            return (m_pParent->lRead < (m_pParent->cksize - 8));
        }
        else
        {
            // This must be a top level chunk, in which case there would only be one to read.
            return (m_pChunk->lRead == 0);
        }
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return false;
}

HRESULT CRiffParser::EnterChunk()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Read the chunk header
	    HRESULT hr = m_pStream->Read(m_pChunk, 2 * sizeof(DWORD), NULL);
        if (SUCCEEDED(hr) && (long)m_pChunk->cksize < 0)
        {
            // This size is clearly too big for a valid chunk.
            hr = DMUS_E_DESCEND_CHUNK_FAIL;
        }
        if (SUCCEEDED(hr))
        {
#ifdef DBG
            char szName[5];
            if (m_fDebugOn)
            {
                szName[4] = 0;
                strncpy(szName,(char *)&m_pChunk->ckid,4);
                ULARGE_INTEGER ul;
                LARGE_INTEGER li;
                li.QuadPart = 0;
                m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

                Trace(0,"Entering %s, Length %ld, File position is %ld",szName,m_pChunk->cksize,(long)ul.QuadPart);
            }
#endif
            // Clear bytes read field.
            m_pChunk->lRead = 0;
            // Check to see if this is a container (LIST or RIFF.)
            if((m_pChunk->ckid == FOURCC_RIFF) || (m_pChunk->ckid == FOURCC_LIST))
		    {
			    hr = m_pStream->Read(&m_pChunk->fccType, sizeof(DWORD), NULL);
                if (SUCCEEDED(hr))
                {
                    m_pChunk->lRead += sizeof(DWORD);
#ifdef DBG
                    if (m_fDebugOn)
                    {
                        strncpy(szName,(char *)&m_pChunk->fccType,4);
                        Trace(0," Type %s",szName);
                    }
#endif
                }
                else
                {
                    Trace(1,"Error: Unable to read file.\n");
                }
		    }
#ifdef DBG
            if (m_fDebugOn) Trace(0,"\n");
#endif
        }
        else
        {
            Trace(1,"Error: Unable to read file.\n");
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::LeaveChunk()

{
    HRESULT hr = S_OK;
    assert(m_pChunk);
    if (m_pChunk)
    {
        m_fInComponent = false;
        // Get the rounded up size of the chunk.
        long lSize = RIFF_ALIGN(m_pChunk->cksize);
        // Increment the parent's count of bytes read so far.
        if (m_pParent)
        {
            m_pParent->lRead += lSize + (2 * sizeof(DWORD));
            if (m_pParent->lRead > RIFF_ALIGN(m_pParent->cksize))
            {
                Trace(1,"Error: Unable to read file.\n");
                hr = DMUS_E_DESCEND_CHUNK_FAIL; // Goofy error name, but need to be consistent with previous versions.
            }
        }
#ifdef DBG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            ULARGE_INTEGER ul;
            LARGE_INTEGER li;
            li.QuadPart = 0;
            m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

            Trace(0,"Leaving %s, Read %ld of %ld, File Position is %ld\n",szName,m_pChunk->lRead,lSize,(long)ul.QuadPart);
        }
#endif
        // If we haven't actually read this entire chunk, seek to the end of it.
        if (m_pChunk->lRead < lSize)
        {
            LARGE_INTEGER li;
            li.QuadPart = lSize - m_pChunk->lRead;
            hr = m_pStream->Seek(li,STREAM_SEEK_CUR,NULL);
            // There's a chance it could fail because we are at the end of file with an odd length chunk.
            if (FAILED(hr))
            {
                // If there's a parent, see if this is the last chunk.
                if (m_pParent)
                {
                    if (m_pParent->cksize >= (m_pParent->lRead - 1))
                    {
                        hr = S_OK;
                    }
                }
                // Else, see if we are an odd length.
                else if (m_pChunk->cksize & 1)
                {
                    hr = S_OK;
                }
            }
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Read(void *pv,ULONG cb)

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't read beyond the end of the chunk.
        if (((long)cb + m_pChunk->lRead) > m_pChunk->cksize)
        {
            cb -= (cb - (m_pChunk->cksize - m_pChunk->lRead));
        }
        HRESULT hr = m_pStream->Read(pv,cb,NULL);
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += cb;
        }
        else
        {
            Trace(1,"Error: Unable to read %ld bytes from file.\n",cb);
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Skip(ULONG ulBytes)

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't scan beyond the end of the chunk.
        if (((long)ulBytes + m_pChunk->lRead) > m_pChunk->cksize)
        {
            ulBytes -= (ulBytes - (m_pChunk->cksize - m_pChunk->lRead));
        }
        LARGE_INTEGER li;
        li.HighPart = 0;
		li.LowPart = ulBytes;
        HRESULT hr = m_pStream->Seek( li, STREAM_SEEK_CUR, NULL );
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += ulBytes;
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}


void CRiffParser::MarkPosition()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        LARGE_INTEGER li;
        ULARGE_INTEGER ul;
        li.HighPart = 0;
        li.LowPart = 0;
        m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        m_pChunk->liPosition.QuadPart = (LONGLONG) ul.QuadPart;
    }
}

HRESULT CRiffParser::SeekBack()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Move back to the start of the current chunk. Also, store the
        // absolute position because that will be useful later when we need to seek to the
        // end of this chunk.
        ULARGE_INTEGER ul;
        LARGE_INTEGER li;
        li.QuadPart = 0;
        li.QuadPart -= (m_pChunk->lRead + (2 * sizeof(DWORD))); 
        HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        // Now, save the absolute position for the end of this chunk.
        m_pChunk->liPosition.QuadPart = ul.QuadPart + 
            RIFF_ALIGN(m_pChunk->cksize) + (2 * sizeof(DWORD));
        m_pChunk->lRead = 0;
        return hr;
    }
    return E_FAIL;
}

HRESULT CRiffParser::SeekForward()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        m_pChunk->lRead = RIFF_ALIGN(m_pChunk->cksize);
        return m_pStream->Seek(m_pChunk->liPosition, STREAM_SEEK_SET, NULL);
    }
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmband\dmbndtrk.h ===
/*
   dmbndtrk.h
   
   Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.

   Note: Contains private interfaces support by objects contained within 
		 dmband.dll. Originally written by Robert K. Amenn 
*/

#ifndef DMBNDTRK_H
#define DMBNDTRK_H

#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#ifdef __cplusplus
extern "C" {
#endif

struct IDirectMusicBand;

typedef struct _DMUS_IO_PATCH_ITEM
{
    MUSIC_TIME                  lTime;
    BYTE                        byStatus;
    BYTE                        byPChange;
    BYTE                        byMSB;
    BYTE                        byLSB;
    DWORD                       dwFlags;
	BOOL						fNotInFile; // set to true if this patch item was automatically generated
    IDirectMusicCollection*     pIDMCollection;
    struct _DMUS_IO_PATCH_ITEM* pNext;  
} DMUS_IO_PATCH_ITEM;

typedef enum enumDMUS_MIDIMODEF_FLAGS
{       
    DMUS_MIDIMODEF_GM = 0x1,
    DMUS_MIDIMODEF_GS = 0x2,
    DMUS_MIDIMODEF_XG = 0x4,
} DMUS_MIDIMODEF_FLAGS;

struct StampedGMGSXG
{
	MUSIC_TIME mtTime;
	DWORD dwMidiMode;
};

/* Private Interface IDirectMusicBandTrk */

interface IDirectMusicBandTrk;

#ifndef __cplusplus 
typedef interface IDirectMusicBandTrk IDirectMusicBandTrk;
#endif

typedef IDirectMusicBandTrk __RPC_FAR *LPDIRECTMUSICBANDTRK;

#undef  INTERFACE
#define INTERFACE  IDirectMusicBandTrk
DECLARE_INTERFACE_(IDirectMusicBandTrk, IUnknown)
{
	/* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	/* IDirectMusicBandTrk */
	STDMETHOD(AddBand)				(THIS_ DMUS_IO_PATCH_ITEM*) PURE;
	STDMETHOD(AddBand)				(THIS_ IDirectMusicBand* pIDMBand) PURE;
	STDMETHOD(SetGMGSXGMode)		(THIS_ MUSIC_TIME mtTime, DWORD dwMidiMode) PURE;
};

/* Private Interface IDirectMusicBandPrivate */

interface IDirectMusicBandPrivate;

#ifndef __cplusplus 
typedef interface IDirectMusicBandPrivate IDirectMusicBandPrivate;
#endif

typedef IDirectMusicBandPrivate __RPC_FAR *LPDIRECTMUSICBANDP;

#undef  INTERFACE
#define INTERFACE  IDirectMusicBandPrivate 
DECLARE_INTERFACE_(IDirectMusicBandPrivate, IUnknown)
{
	/* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	/* IDirectMusicBandPrivate */
	STDMETHOD(GetFlags)				(THIS_ DWORD* dwFlags) PURE;
	STDMETHOD(SetGMGSXGMode)		(THIS_ DWORD dwMidiMode) PURE;
};

DEFINE_GUID(IID_IDirectMusicBandTrk, 0x53466056, 0x6dc4, 0x11d1, 0xbf, 0x7b, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);
DEFINE_GUID(IID_IDirectMusicBandPrivate,0xda54db81, 0x837d, 0x11d1, 0x86, 0xbc, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);

#ifdef __cplusplus
}; /* extern "C" */
#endif

#endif /* #ifndef DMBNDTRK_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmband\opnew.cpp ===
// Copyright (c) 1999 Microsoft Corporation
// OpNew.cpp
//
// Override operator new[] so that we ignore the new_handler mechanism.
//
//
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include "Debug.h"

LPVOID __cdecl operator new(size_t cbBuffer)
{
    LPVOID p;

    p = malloc(cbBuffer ? cbBuffer : 1);
    return p;
}

void __cdecl operator delete(LPVOID p)
{
    free(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmband\pchmap.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
/* This is a class to manage tracking mutes for the SeqTrack and BandTrack. */
#include "PChMap.h"
#include "debug.h"
#include "dmusicf.h"

CPChMap::CPChMap()
{
}

CPChMap::~CPChMap()
{
}

// Reset sets all item's mtNext time values to -1, so they are gotten again.
void CPChMap::Reset(void)
{
	TListItem<PCHMAP_ITEM>* pItem;
	
	for( pItem = m_PChMapList.GetHead(); pItem; pItem = pItem->GetNext() )
	{
		PCHMAP_ITEM& rItem = pItem->GetItemValue();
		rItem.mtNext = -1;
		rItem.dwPChMap = rItem.dwPChannel;
        rItem.fMute = 0;
	}
}

// GetInfo calls the performance's GetData to get the current Mute Track information.
// Reset() will be called upon any invalidation or seek, which will set the
// internal times to -1 so this will be accurate in case of a new controlling segment.
// You must provide the pfMute and pdwNewPCh parameters to this function, or
// it will crash.
void CPChMap::GetInfo( DWORD dwPCh, MUSIC_TIME mtTime, MUSIC_TIME mtOffset, DWORD dwGroupBits,
					   IDirectMusicPerformance* pPerf, BOOL* pfMute, DWORD* pdwNewPCh, BOOL fClockTime )
{
	TListItem<PCHMAP_ITEM>* pItem;
	
	for( pItem = m_PChMapList.GetHead(); pItem; pItem = pItem->GetNext() )
	{
		PCHMAP_ITEM& rCheck = pItem->GetItemValue();
		if( rCheck.dwPChannel == dwPCh ) break;
	}
	if( NULL == pItem )
	{
		PCHMAP_ITEM item;
		item.mtNext = -1;
		item.dwPChannel = item.dwPChMap = dwPCh;
		item.fMute = FALSE;
		pItem = new TListItem<PCHMAP_ITEM>(item);
		if( NULL == pItem )
		{
			// error, out of memory.
			*pfMute = FALSE;
			*pdwNewPCh = dwPCh;
			return;
		}
		m_PChMapList.AddHead(pItem);
	}
	PCHMAP_ITEM& rItem = pItem->GetItemValue();
	if( mtTime >= rItem.mtNext )
	{
		DMUS_MUTE_PARAM muteParam;
		MUSIC_TIME mtNext;
		muteParam.dwPChannel = dwPCh;
        if (fClockTime)
        {
            MUSIC_TIME mtMusic;
            REFERENCE_TIME rtTime = (mtTime + mtOffset) * 10000;
            pPerf->ReferenceToMusicTime(rtTime,&mtMusic);
		    if( SUCCEEDED(pPerf->GetParam( GUID_MuteParam, dwGroupBits, 0, mtMusic, 
			    &mtNext, (void*)&muteParam )))
		    {
                REFERENCE_TIME rtNext;
                // Convert to absolute reference time.
                pPerf->MusicToReferenceTime(mtNext + mtMusic,&rtNext);
                rtNext -= rtTime;   // Subtract out to get the delta.
			    rItem.mtNext = (MUSIC_TIME)(rtTime / 10000);  // Convert to delta in milliseconds. BUGBUG What if there's a tempo change?
			    rItem.dwPChMap = muteParam.dwPChannelMap;
			    rItem.fMute = muteParam.fMute;
		    }
		    else
		    {
			    // no mute track, or no mute on this pchannel.
			    // keep the current mapping.
			    rItem.mtNext = 0x7fffffff;
		    }

        }
        else
        {
		    if( SUCCEEDED(pPerf->GetParam( GUID_MuteParam, dwGroupBits, 0, mtTime + mtOffset, 
			    &mtNext, (void*)&muteParam )))
		    {
			    rItem.mtNext = mtNext;
			    rItem.dwPChMap = muteParam.dwPChannelMap;
			    rItem.fMute = muteParam.fMute;
		    }
		    else
		    {
			    // no mute track, or no mute on this pchannel.
			    // keep the current mapping.
			    rItem.mtNext = 0x7fffffff;
		    }
        }
	}
	*pfMute = rItem.fMute;
	*pdwNewPCh = rItem.dwPChMap;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmcompos\debug.h ===
//
// debug.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note:
//

#ifndef DEBUG_H
#define DEBUG_H

#include <windows.h>

#define DM_DEBUG_CRITICAL		1	// Used to include critical messages
#define DM_DEBUG_NON_CRITICAL	2	// Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS			3	// Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW		4	// Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL			5	// Used to include all debug messages

// Default to no debug output compiled
//
#define Trace
#define TraceI
#define assert(exp) ((void)0)

#ifdef DBG

// Checked build: include at least external debug spew
//
extern void DebugInit(void);
extern void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...);
extern void DebugAssert(LPSTR szExp, LPSTR szFile, ULONG ulLine);

# undef Trace
# define Trace DebugTrace

# undef assert
# define assert(exp) (void)( (exp) || (DebugAssert(#exp, __FILE__, __LINE__), 0) )

// If internal build flag set, include everything
//
# ifdef DMUSIC_INTERNAL
#  undef TraceI
#  define TraceI DebugTrace
# endif

#endif  // #ifdef DBG

#endif  // #ifndef DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmcompos\composin.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       composin.h
//
//--------------------------------------------------------------------------

// ComposIn.h --- include file for the composition engine

#ifndef __COMPOSINH__
#define __COMPOSINH__

#include "dmusici.h"
#include "dmusicf.h"
#include "str.h"
#include "tlist.h"

#include "aariff.h"
#include "templats.h"

#include "sjpers.h"

#include "debug.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmband\oledll.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// oledll.cpp
//
// Handle standard stuff for OLE server DLL
//
#include <objbase.h>
#include "debug.h"
#include <iostream.h>

#include "oledll.h"

#ifdef UNICODE
#ifndef UNDER_CE
#error DirectMusic Win NT/9x must be compiled without UNICODE
#endif
#endif

static const TCHAR g_szCLSID[]           = TEXT("CLSID");
static const TCHAR g_szCLSIDSlash[]      = TEXT("CLSID\\");
static const TCHAR g_szInProc32[]        = TEXT("InProcServer32");
static const TCHAR g_szProgIDKey[]       = TEXT("ProgID");
static const TCHAR g_szVerIndProgIDKey[] = TEXT("VersionIndependentProgID");
static const TCHAR g_szCurVer[]          = TEXT("CurVer"); 
static const TCHAR g_szThreadingModel[]	= TEXT("ThreadingModel");
static const TCHAR g_szBoth[]		    = TEXT("Both");

static const int CLSID_STRING_SIZE = 39;

static LONG RegSetDefValue(LPCTSTR pstrKey, LPCTSTR pstrSubkey, LPCTSTR pstrValueName, LPCTSTR pstrValue);
static void RegRemoveSubtree(HKEY hk, LPCTSTR pstrChild);

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    LONG lr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    TCHAR szModule[512];
    lr = ::GetModuleFileName(hModule, szModule, sizeof(szModule));
    assert(lr);

    lr = 0;

    lr |= RegSetDefValue(szClsKey, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szClsKey, g_szInProc32, NULL, szModule);
	lr |= RegSetDefValue(szClsKey, g_szInProc32, g_szThreadingModel, g_szBoth);
    lr |= RegSetDefValue(szClsKey, g_szProgIDKey, NULL, szProgID);
    lr |= RegSetDefValue(szClsKey, g_szVerIndProgIDKey, NULL, szVerIndProgID);

    lr |= RegSetDefValue(szVerIndProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szVerIndProgID, g_szCLSID, NULL, szCLSID);
    lr |= RegSetDefValue(szVerIndProgID, g_szCurVer, NULL, szProgID);
    
	lr |= RegSetDefValue(szProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szProgID, g_szCLSID, NULL, szCLSID);

#if 0 
    if (lr) {
        UnregisterServer(clsid,
                         szFriendlyName,
                         szVerIndProgID,
                         szProgID);
        // ???
        //
        return S_OK;
    }
#endif

    return S_OK;
}

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    RegRemoveSubtree(HKEY_CLASSES_ROOT, szClsKey);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szVerIndProgID);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szProgID);

    return S_OK;
}

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    HKEY hk;
	DWORD dw;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);
	lstrcat(szClsKey, TEXT("\\"));
    if (szKey)
    {
	    lstrcat(szClsKey, szKey);
    }

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
					 szClsKey,
					 0,
					 KEY_READ,
					 &hk)) {
		return FALSE;
	}

	if (RegQueryValueEx(hk,
						NULL,
						NULL,
						&dw,
						(LPBYTE)pValue,
						pcbValue)) {
		RegCloseKey(hk);
		return FALSE;
	}

	RegCloseKey(hk);
	
	return TRUE;
}

HRESULT
CLSIDToStr(const CLSID &clsid,
           TCHAR *szStr,
           int cbStr)
{
    // XXX What to return here?
    //
    assert(cbStr >= CLSID_STRING_SIZE);
    
	LPOLESTR wszCLSID = NULL;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
    if (!SUCCEEDED(hr)) {
        return hr;
    }

#ifdef UNICODE
    lstrcpy(szStr, wszCLSID);
#else
	// Covert from wide characters to non-wide.
	wcstombs(szStr, wszCLSID, cbStr);
#endif

	// Free memory.
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

HRESULT
StrToCLSID(TCHAR *szStr,
		   CLSID &clsid,
		   int cbStr)
{
#ifdef UNICODE
    return CLSIDFromString(szStr, &clsid);
#else    
	WCHAR wsz[512];
    if (cbStr > 512)
    {
        cbStr = 512;
    }

	mbstowcs(wsz, szStr, cbStr);

	return CLSIDFromString(wsz, &clsid);
#endif
}
   

static LONG
RegSetDefValue(LPCTSTR pstrKey,
               LPCTSTR pstrSubkey,
			   LPCTSTR pstrValueName,
               LPCTSTR pstrValue)
{
    HKEY hk;
    LONG lr;
    TCHAR sz[1024];
    LPCTSTR pstr;

    if (!pstrSubkey) {
        pstr = pstrKey;
    } else {
        lstrcpy(sz, pstrKey);
        lstrcat(sz, TEXT("\\"));
        lstrcat(sz, pstrSubkey);
        pstr = sz;
    }

    lr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                        pstr,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hk,
                        NULL);
    if (lr) {
        return lr;
    }

    lr = RegSetValueEx(hk,
                       pstrValueName,
                       0,
                       REG_SZ,
                       (CONST BYTE*)pstrValue,
                       1+lstrlen(pstrValue));
    RegCloseKey(hk);

    return lr;
}

static void
RegRemoveSubtree(HKEY hk,
                 LPCTSTR pstrChild)
{
    LONG lResult;
    HKEY hkChild;

    lResult = RegOpenKeyEx(hk,
                           pstrChild,
                           0,
                           KEY_ALL_ACCESS,
                           &hkChild);
    if (lResult) {
        return;
    }

#ifndef UNDER_CE    // CE doesn't support RegEnumKey()
    TCHAR szSubkey[256];

    // NOTE: Unlike regular enumeration, we always grab the 0th item
    // and delete it.
    //
    while (!RegEnumKey(hkChild, 0, szSubkey, sizeof(szSubkey))) {
        RegRemoveSubtree(hkChild, szSubkey);
    }
#endif    

    RegCloseKey(hkChild);
    RegDeleteKey(hk, pstrChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmband\pchmap.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
/* This is a class to manage tracking mutes for the SeqTrack and BandTrack. */

#ifndef _PCHMAP__
#define _PCHMAP__
#include "dmusici.h"
#include "..\dmstyle\tlist.h"

struct PCHMAP_ITEM
{
	MUSIC_TIME	mtNext;
	DWORD		dwPChannel;
	DWORD		dwPChMap;
	BOOL		fMute;
};

class CPChMap
{
public:
	CPChMap();
	~CPChMap();
	void Reset(void);
	void GetInfo( DWORD dwPCh, MUSIC_TIME mtTime, MUSIC_TIME mtOffset, DWORD dwGroupBits,
				  IDirectMusicPerformance* pPerf, BOOL* pfMute, DWORD* pdwNewPCh , BOOL fClockTime);
private:
	TList<PCHMAP_ITEM>	m_PChMapList;
};
#endif // _PCHMAP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmcompos\dmcmpdll.cpp ===
//
// dmcmpdll.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Note: Dll entry points as well as Class Factory implementations.
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

#include <objbase.h>
#include "debug.h"
#include "debug.h"

#include "..\shared\oledll.h"

#include <initguid.h>
#include "dmusici.h"
#include "DMCompP.h"
#include "dmpers.h"
#include "dmcompos.h"
#include "dmtempl.h"
#include "spsttrk.h"
#include "perstrk.h"
#include "..\shared\Validate.h"
#include "..\dmstyle\dmstyleP.h"
#include "..\dmime\dmgraph.h"

//////////////////////////////////////////////////////////////////////
// Globals

// Version information 
//
TCHAR g_szComposerFriendlyName[]    = TEXT("DirectMusicComposer");
TCHAR g_szComposerVerIndProgID[]    = TEXT("Microsoft.DirectMusicComposer");
TCHAR g_szComposerProgID[]          = TEXT("Microsoft.DirectMusicComposer.1");

TCHAR g_szChordMapFriendlyName[]    = TEXT("DirectMusicChordMap");
TCHAR g_szChordMapVerIndProgID[]    = TEXT("Microsoft.DirectMusicChordMap");
TCHAR g_szChordMapProgID[]          = TEXT("Microsoft.DirectMusicChordMap.1");

TCHAR g_szChordMapTrackFriendlyName[]    = TEXT("DirectMusicChordMapTrack");
TCHAR g_szChordMapTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicChordMapTrack");
TCHAR g_szChordMapTrackProgID[]          = TEXT("Microsoft.DirectMusicChordMapTrack.1");

TCHAR g_szSignPostTrackFriendlyName[]    = TEXT("DirectMusicSignPostTrack");
TCHAR g_szSignPostTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicSignPostTrack");
TCHAR g_szSignPostTrackProgID[]          = TEXT("Microsoft.DirectMusicSignPostTrack.1");

TCHAR g_szTemplateFriendlyName[]    = TEXT("DirectMusicTemplate");
TCHAR g_szTemplateVerIndProgID[]    = TEXT("Microsoft.DirectMusicTemplate");
TCHAR g_szTemplateProgID[]          = TEXT("Microsoft.DirectMusicTemplate.1");

// Dll's hModule
//
HMODULE g_hModule = NULL;

// Count of active components and class factory server locks
//
long g_cComponent = 0;
long g_cLock = 0;

//////////////////////////////////////////////////////////////////////
// CDirectMusicPersonalityFactory::QueryInterface

HRESULT __stdcall
CDirectMusicPersonalityFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(CDirectMusicPersonalityFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPersonalityFactory::AddRef

ULONG __stdcall
CDirectMusicPersonalityFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPersonalityFactory::Release

ULONG __stdcall
CDirectMusicPersonalityFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPersonalityFactory::CreateInstance

HRESULT __stdcall
CDirectMusicPersonalityFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CDMPers *pDM;
    
    try
    {    
        pDM = new CDMPers;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPersonalityFactory::LockServer

HRESULT __stdcall
CDirectMusicPersonalityFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicComposerFactory::QueryInterface

HRESULT __stdcall
CDirectMusicComposerFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(CDirectMusicComposerFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicComposerFactory::AddRef

ULONG __stdcall
CDirectMusicComposerFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicComposerFactory::Release

ULONG __stdcall
CDirectMusicComposerFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicComposerFactory::CreateInstance

HRESULT __stdcall
CDirectMusicComposerFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

//    DebugBreak();
    
    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CDMCompos *pDM = new CDMCompos;
    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicComposerFactory::LockServer

HRESULT __stdcall
CDirectMusicComposerFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicTemplateFactory::QueryInterface

HRESULT __stdcall
CDirectMusicTemplateFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(CDirectMusicTemplateFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicTemplateFactory::AddRef

ULONG __stdcall
CDirectMusicTemplateFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicTemplateFactory::Release

ULONG __stdcall
CDirectMusicTemplateFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicTemplateFactory::CreateInstance

HRESULT __stdcall
CDirectMusicTemplateFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

//    DebugBreak();
    
    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CDMTempl *pDM;

    try
    {
        pDM = new CDMTempl;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicTemplateFactory::LockServer

HRESULT __stdcall
CDirectMusicTemplateFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicSignPostTrackFactory::QueryInterface

HRESULT __stdcall
CDirectMusicSignPostTrackFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(CDirectMusicSignPostTrackFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicSignPostTrackFactory::AddRef

ULONG __stdcall
CDirectMusicSignPostTrackFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicSignPostTrackFactory::Release

ULONG __stdcall
CDirectMusicSignPostTrackFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicSignPostTrackFactory::CreateInstance

HRESULT __stdcall
CDirectMusicSignPostTrackFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

//    DebugBreak();
    
    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CSPstTrk *pDM;

    try
    {
        pDM = new CSPstTrk;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicSignPostTrackFactory::LockServer

HRESULT __stdcall
CDirectMusicSignPostTrackFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPersonalityTrackFactory::QueryInterface

HRESULT __stdcall
CDirectMusicPersonalityTrackFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    V_INAME(CDirectMusicPersonalityTrackFactory::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPersonalityTrackFactory::AddRef

ULONG __stdcall
CDirectMusicPersonalityTrackFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPersonalityTrackFactory::Release

ULONG __stdcall
CDirectMusicPersonalityTrackFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPersonalityFactory::CreateInstance

HRESULT __stdcall
CDirectMusicPersonalityTrackFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CPersonalityTrack *pDM;

    try
    {
        pDM = new CPersonalityTrack;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(iid, ppv);
    pDM->Release();
    
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicPersonalityTrackFactory::LockServer

HRESULT __stdcall
CDirectMusicPersonalityTrackFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Standard calls needed to be an inproc server

//////////////////////////////////////////////////////////////////////
// DllCanUnloadNow

STDAPI DllCanUnloadNow()
{
    if (g_cComponent || g_cLock) {
        return S_FALSE;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DllGetClassObject

STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
	IUnknown* pIUnknown = NULL;

    if(clsid == CLSID_DirectMusicChordMap)
    {

		pIUnknown = static_cast<IUnknown*> (new CDirectMusicPersonalityFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else if(clsid == CLSID_DirectMusicComposer) 
    {
        pIUnknown = static_cast<IUnknown*> (new CDirectMusicComposerFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else if(clsid == CLSID_DMTempl) 
    {
        pIUnknown = static_cast<IUnknown*> (new CDirectMusicTemplateFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else if(clsid == CLSID_DirectMusicSignPostTrack) 
    {
        pIUnknown = static_cast<IUnknown*> (new CDirectMusicSignPostTrackFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else if(clsid == CLSID_DirectMusicChordMapTrack) 
    {
        pIUnknown = static_cast<IUnknown*> (new CDirectMusicPersonalityTrackFactory);
        if(!pIUnknown) 
        {
			return E_OUTOFMEMORY;
        }
    }
    else
    {
		return CLASS_E_CLASSNOTAVAILABLE;
	}

    HRESULT hr = pIUnknown->QueryInterface(iid, ppv);
    pIUnknown->Release();

    return hr;
}

//////////////////////////////////////////////////////////////////////
// DllUnregisterServer

STDAPI DllUnregisterServer()
{
    UnregisterServer(CLSID_DirectMusicChordMap,
                     g_szChordMapFriendlyName,
                     g_szChordMapVerIndProgID,
                     g_szChordMapProgID);

    UnregisterServer(CLSID_DirectMusicComposer,
                     g_szComposerFriendlyName,
                     g_szComposerVerIndProgID,
                     g_szComposerProgID);

    UnregisterServer(CLSID_DMTempl,
                     g_szTemplateFriendlyName,
                     g_szTemplateVerIndProgID,
                     g_szTemplateProgID);

    UnregisterServer(CLSID_DirectMusicSignPostTrack,
                     g_szSignPostTrackFriendlyName,
                     g_szSignPostTrackVerIndProgID,
                     g_szSignPostTrackProgID);
 
	UnregisterServer(CLSID_DirectMusicChordMapTrack,
                     g_szChordMapTrackFriendlyName,
                     g_szChordMapTrackVerIndProgID,
                     g_szChordMapTrackProgID);


    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DllRegisterServer

STDAPI DllRegisterServer()
{
    RegisterServer(g_hModule,
                   CLSID_DirectMusicChordMap,
                     g_szChordMapFriendlyName,
                     g_szChordMapVerIndProgID,
                     g_szChordMapProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicComposer,
                     g_szComposerFriendlyName,
                     g_szComposerVerIndProgID,
                     g_szComposerProgID);

    RegisterServer(g_hModule,
                   CLSID_DMTempl,
                     g_szTemplateFriendlyName,
                     g_szTemplateVerIndProgID,
                     g_szTemplateProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicSignPostTrack,
                     g_szSignPostTrackFriendlyName,
                     g_szSignPostTrackVerIndProgID,
                     g_szSignPostTrackProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicChordMapTrack,
                     g_szChordMapTrackFriendlyName,
                     g_szChordMapTrackVerIndProgID,
                     g_szChordMapTrackProgID);

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Standard Win32 DllMain

//////////////////////////////////////////////////////////////////////
// DllMain

#ifdef DBG
static char* aszReasons[] =
{
    "DLL_PROCESS_DETACH",
    "DLL_PROCESS_ATTACH",
    "DLL_THREAD_ATTACH",
    "DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

BOOL APIENTRY DllMain(HINSTANCE hModule,
                      DWORD dwReason,
                      void *lpReserved)
{
    static int nReferenceCount = 0;

#ifdef DBG
    if (dwReason < nReasons)
    {
        TraceI(0, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
    }
    else
    {
        TraceI(0, "DllMain: Unknown dwReason <%u>\n", dwReason);
    }
#endif

    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            if (++nReferenceCount == 1)
            {
                #ifdef DBG
                    DebugInit();
                #endif

                if (!DisableThreadLibraryCalls(hModule))
                {
                    TraceI(0, "DisableThreadLibraryCalls failed.\n");
                }

                g_hModule = hModule;

            }
			break;


#ifdef DBG
        case DLL_PROCESS_DETACH:
            if (--nReferenceCount == 0)
            {
                TraceI(-1, "Unloading g_cLock %d  g_cComponent %d\n", g_cLock, g_cComponent);
                
                // Assert if we still have some objects hanging around
                assert(g_cComponent == 0);
                assert(g_cLock == 0);
            }

            break;
#endif            
            
    }

        
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmband\sources.inc ===
!IF 0

Copyright (c) 1989-1999 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Jim Geist (JimGe) 29-Aug-97

NOTE:   Commented description of this file is in \nt\oak\bin\sources.tpl

!ENDIF

!include ..\..\dmusic.inc

MAJORCOMP=windows
MINORCOMP=directx

TARGETNAME = dmband

!IF !$(FREEBUILD) && defined( DIRECTX_REDIST )
TARGETNAME=$(TARGETNAME)d
!ENDIF


TARGETPATH=obj
TARGETTYPE=DYNLINK
UMTYPE=windows
DLLDEF=..\dmband.def
DLLENTRY=_DllMainCRTStartup
USE_MAPSYM=1
USE_MSVCRT=1
USE_IOSTREAM=1

!if !$(FREEBUILD)

!if "$(BuildMode)" == "internal"
C_DEFINES = $(C_DEFINES) -DDEBUG=1
!else
C_DEFINES = $(C_DEFINES) -DRDEBUG=1
!endif

!endif

C_DEFINES= $(C_DEFINES) -D_WIN32


#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           $(SDK_LIB_PATH)\kernel32.lib		\
	   $(SDK_LIB_PATH)\advapi32.lib		\
           $(SDK_LIB_PATH)\ole32.lib        \
           $(SDK_LIB_PATH)\uuid.lib

INCLUDES=$(INCLUDES);   \
    ..\..\shared


SOURCES=..\bandinst.cpp        \
..\alist.cpp				   \
..\bandtrk.cpp                 \
..\debug.cpp                   \
..\dmband.cpp                  \
..\dmbdll.cpp                  \
..\oledll.cpp                  \
..\pchmap.cpp                  \
..\dmstrm.cpp				   \
..\dmband.rc                   \
..\opnew.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmcompos\aariff.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       aariff.h
//
//--------------------------------------------------------------------------

//
// aariff.h
//

#include <objbase.h>

#ifndef __AARIFF__
#define __AARIFF__
#include <windows.h>
#include <mmsystem.h>
#define FixBytes(a1,a2)

// {0D5057E1-8889-11CF-B9DA-00AA00C08146}
DEFINE_GUID( IID_IAARIFFStream, 0xd5057e1, 0x8889, 0x11cf, 0xb9, 0xda, 0x0, 0xaa, 0x0, 0xc0, 0x81, 0x46 );
#undef INTERFACE
#define INTERFACE IAARIFFStream
DECLARE_INTERFACE_(IAARIFFStream, IUnknown)
{
    // IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // IMKRIFFStream members
    STDMETHOD_(UINT, Descend)(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags) PURE;
    STDMETHOD_(UINT, Ascend)(LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD_(UINT, CreateChunk)(LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD(SetStream)(LPSTREAM pStream) PURE;
    STDMETHOD_(LPSTREAM, GetStream)() PURE;
};

struct CFileStream : IStream
{
///// object state
    ULONG           m_cRef;         // object reference count
    HANDLE          m_hfile;        // file handle

// construction and destruction
    CFileStream( HANDLE hfile ) : m_cRef( 1 ), m_hfile( hfile ) {}
#ifdef _MAC
    ~CFileStream() { FSClose( (int) m_hfile ); }
#else
    ~CFileStream() { CloseHandle( m_hfile ); }
#endif

///// IUnknown methods
    STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
    {
        if( IsEqualIID( riid, IID_IUnknown ) ||
            IsEqualIID( riid, IID_IStream ) )
        {
            *ppvObj = (IStream *) this;
            AddRef();
            return NOERROR;
        }
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_cRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if( --m_cRef == 0L )
        {
            delete this;
            return 0;
        }
       return m_cRef;
    }

    /* IStream methods */
    STDMETHODIMP Read( void* pv, ULONG cb, ULONG* pcbRead )
    {
		DWORD dw;

		if( ReadFile( m_hfile, pv, cb, &dw, NULL ) &&
			dw == cb )
		{
			if( pcbRead != NULL )
			{
				*pcbRead = dw;
			}
			return S_OK;
		}
		return E_FAIL;
    }
    STDMETHODIMP Write( const void* pv, ULONG cb, ULONG* pcbWritten )
    {
		DWORD dw;

		if( WriteFile( m_hfile, pv, cb, &dw, NULL ) &&
			dw == cb )
		{
			if( pcbWritten != NULL )
			{
				*pcbWritten = dw;
			}
			return S_OK;
		}
        return E_FAIL;
	}
    STDMETHODIMP Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition )
    {
		DWORD dw;

		dw = SetFilePointer( m_hfile, dlibMove.LowPart, &dlibMove.HighPart, dwOrigin );
		if( dw == (DWORD)-1 )
		{
			return E_FAIL;
		}
		if( plibNewPosition != NULL )
		{
			plibNewPosition->LowPart = dw;
	        plibNewPosition->HighPart = dlibMove.HighPart;
		}
        return S_OK;
	}
    STDMETHODIMP SetSize( ULARGE_INTEGER /*libNewSize*/ )
    { return E_NOTIMPL; }
    STDMETHODIMP CopyTo( IStream* /*pstm */, ULARGE_INTEGER /*cb*/,
                         ULARGE_INTEGER* /*pcbRead*/,
                         ULARGE_INTEGER* /*pcbWritten*/ )
    { return E_NOTIMPL; }
    STDMETHODIMP Commit( DWORD /*grfCommitFlags*/ )
    { return E_NOTIMPL; }
    STDMETHODIMP Revert()
    { return E_NOTIMPL; }
    STDMETHODIMP LockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                             DWORD /*dwLockType*/ )
    { return E_NOTIMPL; }
    STDMETHODIMP UnlockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                               DWORD /*dwLockType*/)
    { return E_NOTIMPL; }
    STDMETHODIMP Stat( STATSTG* /*pstatstg*/, DWORD /*grfStatFlag*/ )
    { return E_NOTIMPL; }
    STDMETHODIMP Clone( IStream** /*ppstm*/ )
    { return E_NOTIMPL; }
};

struct CRIFFStream : IAARIFFStream
{
///// object state
    ULONG       m_cRef;         // object reference count
    IStream*    m_pStream;      // stream to operate on

///// construction and destruction
    CRIFFStream(IStream* pStream)
    {
        m_cRef = 1;
		// replaced a call to SetStream with the following to avoid releasing an
		// unallocated stream
        m_pStream = pStream;
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
    }
    ~CRIFFStream()
    {
        if( m_pStream != NULL )
        {
            m_pStream->Release();
        }
    }

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
        if( IsEqualIID( riid, IID_IUnknown ) ||
            IsEqualIID( riid, IID_IAARIFFStream ) )
        {
            *ppvObj = (IAARIFFStream*)this;
            AddRef();
            return NOERROR;
        }
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_cRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if( --m_cRef == 0L )
        {
            delete this;
            return 0;
        }
        return m_cRef;
    }

// IAARIFFStream methods
    STDMETHODIMP_(UINT) Descend( LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags );
    STDMETHODIMP_(UINT) Ascend( LPMMCKINFO lpck, UINT wFlags );
    STDMETHODIMP_(UINT) CreateChunk( LPMMCKINFO lpck, UINT wFlags );
    STDMETHOD(SetStream)(LPSTREAM pStream)
    {
        if( m_pStream != NULL )
        {
            m_pStream->Release();
        }
        m_pStream = pStream;
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
        return S_OK;
    }
    STDMETHOD_(LPSTREAM, GetStream)()
    {
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
        return m_pStream;
    }

// private methods
    long MyRead( void *pv, long cb );
    long MyWrite( const void *pv, long cb );
    long MySeek( long lOffset, int iOrigin );
};

// seeks to a 32-bit position in a stream.
HRESULT __inline StreamSeek( LPSTREAM pStream, long lSeekTo, DWORD dwOrigin )
{
	LARGE_INTEGER li;

	if( lSeekTo < 0 )
	{
		li.HighPart = -1;
	}
	else
	{
        li.HighPart = 0;
	}
	li.LowPart = lSeekTo;
	return pStream->Seek( li, dwOrigin, NULL );
}

// returns the current 32-bit position in a stream.
DWORD __inline StreamTell( LPSTREAM pStream )
{
	LARGE_INTEGER li;
    ULARGE_INTEGER ul;
#ifdef DBG
    HRESULT hr;
#endif

    li.HighPart = 0;
    li.LowPart = 0;
#ifdef DBG
    hr = pStream->Seek( li, STREAM_SEEK_CUR, &ul );
    if( FAILED( hr ) )
#else
    if( FAILED( pStream->Seek( li, STREAM_SEEK_CUR, &ul ) ) )
#endif
    {
        return 0;
    }
    return ul.LowPart;
}

// this function gets a long that is formatted the correct way
// i.e. the motorola way as opposed to the intel way
BOOL __inline GetMLong( LPSTREAM pStream, DWORD& dw )
{
    union uLong
	{
		unsigned char buf[4];
        DWORD dw;
	} u;
    unsigned char ch;

    if( FAILED( pStream->Read( u.buf, 4, NULL ) ) )
    {
        return FALSE;
    }

#ifndef _MAC
    // swap bytes
    ch = u.buf[0];
    u.buf[0] = u.buf[3];
    u.buf[3] = ch;

    ch = u.buf[1];
    u.buf[1] = u.buf[2];
    u.buf[2] = ch;
#endif

    dw = u.dw;
    return TRUE;
}

BOOL __inline IsGUIDZero( REFGUID guid )
{
    GUID g;

    memset( &g, 0, sizeof( g ) );
    return IsEqualGUID( g, guid );
}

// misc function prototypes

STDAPI AllocFileStream( LPCSTR szFileName, DWORD dwDesiredAccess, IStream **ppstream );
STDAPI AllocRIFFStream( IStream* pStream, IAARIFFStream** ppRiff );

#endif  // __AARIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmcompos\debug.cpp ===
//
// Debug.CPP
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
// @doc INTERNAL
//
// @module Debug | Debug services for DMusic.DLL
//

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#include "debug.h"

#ifdef DBG

#define MODULE "DMCOMPOS"

// @globalv Section in WIN.INI for all debug settings
const char szDebugSection[] = "debug";

// @globalv Key in WIN.INI for our debug level. All messages with
// a level of this number or lower will be displayed.
const char szDebugKey[] = MODULE;

// @globalv Key in WIN.INI [debug] section which determines if assert calls
// DebugBreak or not
//
const char szAssertBreak[] = "AssertBreak";

// @globalv Prefix for all debug outputs
//
const char szDebugPrefix[] = MODULE ": ";

// @globalv The current debug level. 
static int giDebugLevel;

// @globalv Do asserts break?
static BOOL gfAssertBreak;

// @func Sets the debug level from WIN.INI
// 
void DebugInit(
    void)
{
    giDebugLevel = GetProfileInt(szDebugSection, szDebugKey, 0);
    gfAssertBreak = GetProfileInt(szDebugSection, szAssertBreak, 0);


    // Nepotism at its finest
    DebugTrace(-1, "Debug level is %d\n", giDebugLevel);
}

// @func Send a debug trace out.
//
// @comm Any message with a level less than or equal to the current debug
// level will be displayed using the OutputDebugString API. This means either
// the IDE Debug window if the app is running in that context or WDEB if
// it's running.
//
static BOOL fNeedPrefix = TRUE;
void DebugTrace(
    int iDebugLevel,        // @parm The debug level of this message
    LPSTR pstrFormat,       // @parm A printf style format string
    ...)                    // @parm | ... | Variable paramters based on <p pstrFormat>
{
    char sz[512];
    

    if (iDebugLevel != -1 && iDebugLevel > giDebugLevel)
    {
        return;
    }

    va_list va;

    va_start(va, pstrFormat);
    vsprintf(sz, pstrFormat, va);
    va_end(va);

    if (fNeedPrefix)
    {
        OutputDebugString(szDebugPrefix);
    }
    
    OutputDebugString(sz);

    // Let them construct multiple piece trace outs w/o
    // prefixing each one
    //
    fNeedPrefix = FALSE;
    for (;*pstrFormat && !fNeedPrefix; ++pstrFormat)
    {
        if (*pstrFormat == '\n')
        {
            fNeedPrefix = TRUE;
        }
    }
}

void DebugAssert(
    LPSTR szExp, 
    LPSTR szFile, 
    ULONG ulLine)
{
    DebugTrace(0, "ASSERT: \"%s\" %s@%lu\n", szExp, szFile, ulLine);
    if (gfAssertBreak)
    {
        DebugBreak();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmcompos\dmcomp2.cpp ===
//
// DMComp2.cpp : Further implementation of CDMCompos
//
// Copyright (c) 1999-2001 Microsoft Corporation
//
// @doc EXTERNAL
//

#include "DMCompos.h"
#include "debug.h"

#include "DMPers.h"
#include "DMTempl.h"
#include "..\shared\Validate.h"
#include "..\dmstyle\iostru.h"

V_INAME(DMCompose)

void CDMCompos::ChordConnections2(TList<DMChordEntry>& ChordMap,
                                  CompositionCommand& rCommand,
                                  SearchInfo *pSearch,
                                  short nBPM,
                                  DMChordData *pCadence1,
                                  DMChordData *pCadence2)
{
    int mint, maxt, top, bottom, total;
    short oldbeats = pSearch->m_nBeats;
    //, error;
    TListItem<PlayChord> *pChord;
    SearchInfo tempSearch;
    // Compose a chord list.
    pSearch->m_nMinBeats = 0;
    pSearch->m_nMaxBeats = 0;
    pSearch->m_nChords = 0;
    pSearch->m_Fail.m_nTooManybeats = 0;
    pSearch->m_Fail.m_nTooFewbeats = 0;
    pSearch->m_Fail.m_nTooManychords = 0;
    pSearch->m_Fail.m_nTooFewchords = 0;
    if (pCadence1 || pCadence2)
    {
        pSearch->m_nMinBeats++;
        pSearch->m_nMaxBeats = nBPM;
        pSearch->m_nChords++;
        if (pCadence1 && pCadence2)
        {
            pSearch->m_nMinBeats++;
            pSearch->m_nChords++;
        }
    }
    tempSearch = *pSearch;
    rCommand.m_PlayList.RemoveAll();
    Compose(ChordMap, pSearch, rCommand);
    pChord = rCommand.m_PlayList.GetHead();
    /////////
    *pSearch = tempSearch;
    pSearch->m_nBeats = oldbeats;
    // Tally the min and max beats.
    mint = 0;
    maxt = 0;
    for (; pChord; pChord = pChord->GetNext())
    {
        mint += pChord->GetItemValue().m_nMinbeats;
        maxt += pChord->GetItemValue().m_nMaxbeats;
    }
    pChord = rCommand.m_PlayList.GetHead();
    // If no chord connection was found, create one.
    if (!pChord)
    {
        int nextDuration = oldbeats;
        pChord = AddCadence(rCommand.m_PlayList, &pSearch->m_Start, 0);
        if (pChord)
        {
            pChord->GetItemValue().m_nMinbeats = 0;
        }
        if (pCadence1)
        {
            AddCadence(rCommand.m_PlayList, pCadence1, nextDuration);
            mint++;
            maxt += nextDuration;
            nextDuration = nBPM + 1;
        }
        if (pCadence2)
        {
            AddCadence(rCommand.m_PlayList, pCadence2, nextDuration);
            mint++;
            maxt += nextDuration;
            nextDuration = nBPM + 1;
        }
        AddCadence(rCommand.m_PlayList, &pSearch->m_Start, nextDuration);
        mint++;
        maxt += nextDuration;
    }
    else
    {
        int chordCount = (int) rCommand.m_PlayList.GetCount();
        int avMax;
        if (chordCount > 1) chordCount--;
        avMax = maxt / chordCount;
        if (avMax < 1) avMax = 1;
        if (pCadence1)
        {
            if (pCadence2)
            {
                AddCadence(rCommand.m_PlayList, pCadence2, avMax);
                maxt += avMax;
                mint++;
            }
            AddCadence(rCommand.m_PlayList, &pSearch->m_End, avMax);
            maxt += avMax;
            mint++;
        }
        else if (pCadence2)
        {
            AddCadence(rCommand.m_PlayList, &pSearch->m_End, avMax);
            maxt += avMax;
            mint++;
        }
    }
    // Prepare a ratio to apply to each connection.
    top = pSearch->m_nBeats - mint;
    bottom = maxt - mint;
    if (bottom <= 0) bottom = 1;
    // Assign each connection a time based on the ratio.
    total = 0;
    pChord = rCommand.m_PlayList.GetHead();
    for (; pChord; pChord = pChord->GetNext())
    {
        PlayChord& rChord = pChord->GetItemValue();
        int beat = rChord.m_nMaxbeats - rChord.m_nMinbeats;
        beat *= top;
        beat += (bottom >> 1);
        beat /= bottom;
        if (beat < rChord.m_nMinbeats) beat = rChord.m_nMinbeats;
        if (beat > rChord.m_nMaxbeats) beat = rChord.m_nMaxbeats;
        total += beat;
        rChord.m_nBeat = (short)total;
    }
    // We should now have a close approximation of the correct time.
    // Stretch or shrink the range to fit exactly.  Err on the side
    // of too long, since jostleback will scrunch them back in place.
    // But DON'T violate min/max for each chord.
    pChord = rCommand.m_PlayList.GetHead();
    int lastbeat = 0;
    for (; pChord; pChord = pChord->GetNext())
    {
        PlayChord& rChord = pChord->GetItemValue();
        int newbeat = (rChord.m_nBeat * pSearch->m_nBeats) + total - 1;
        newbeat /= total;
        if ((newbeat - lastbeat) < rChord.m_nMinbeats) newbeat = lastbeat + rChord.m_nMinbeats;
        if ((newbeat - lastbeat) > rChord.m_nMaxbeats) newbeat = lastbeat + rChord.m_nMaxbeats;
        rChord.m_nBeat = (short)newbeat;
        lastbeat = newbeat;
        if (!pChord->GetNext()) total = rChord.m_nBeat;
    }
    // Now we should have times close to the real thing.
    pChord = rCommand.m_PlayList.GetItem(rCommand.m_PlayList.GetCount() - 1);
    if (pChord)
    {
        JostleBack(rCommand.m_PlayList, pChord, pSearch->m_nBeats - total);
    }
    // Now, add the starting time offset to each chord.
    // And, remove the straggler last chord.
    AlignChords(rCommand.m_PlayList.GetHead(), 0, nBPM);
    pChord = rCommand.m_PlayList.GetHead();
    for (; pChord; )
    {
        pChord->GetItemValue().m_nMeasure =
            (short)( ( pChord->GetItemValue().m_nBeat / nBPM ) + rCommand.m_nMeasure );
        pChord->GetItemValue().m_nBeat %= nBPM;
        if (pChord->GetNext())
        {
            pChord = pChord->GetNext();
        }
        else
        {
            rCommand.m_PlayList.Remove(pChord);
            delete pChord;
            break;
        }
    }
}

void CDMCompos::ComposePlayList2(TList<PlayChord>& PlayList,
                            IDirectMusicStyle* pStyle,
                            IDirectMusicChordMap* pPersonality,
                            TList<TemplateCommand>& rCommandList)
{
    // Extract the style's time signature.
    DMUS_TIMESIGNATURE TimeSig;
    pStyle->GetTimeSignature(&TimeSig);
    short nBPM = TimeSig.bBeatsPerMeasure;
    IDMPers* pDMP;
    pPersonality->QueryInterface(IID_IDMPers, (void**)&pDMP);
    DMPersonalityStruct* pPers;
    pDMP->GetPersonalityStruct((void**)&pPers);
    TList<DMChordEntry> &ChordMap = pPers->m_ChordMap;
    TList<DMSignPost> &SignPostList = pPers->m_SignPostList;
    TListItem<DMSignPost> *pSign = SignPostList.GetHead();
    for (; pSign; pSign = pSign->GetNext())
    {
        pSign->GetItemValue().m_dwTempFlags = 0;
    }
    // Assign specific root sign posts, then letter based sign posts.
    TList<CompositionCommand> CommandList;
    TListItem<TemplateCommand>* pTC = rCommandList.GetHead();
    for(; pTC; pTC = pTC->GetNext())
    {
        TemplateCommand& rTC = pTC->GetItemValue();
        TListItem<CompositionCommand>* pNew = new TListItem<CompositionCommand>;
        if (pNew)
        {
            CompositionCommand& rNew = pNew->GetItemValue();
            rNew.m_nMeasure = rTC.m_nMeasure;
            rNew.m_Command = rTC.m_Command;
            rNew.m_dwChord = rTC.m_dwChord;
            rNew.m_pSignPost = NULL;
            rNew.m_pFirstChord = NULL;
            CommandList.AddTail(pNew);
        }
    }
    ChooseSignPosts(SignPostList.GetHead(), CommandList.GetHead(),DMUS_SIGNPOSTF_ROOT, false);
    ChooseSignPosts(SignPostList.GetHead(), CommandList.GetHead(),DMUS_SIGNPOSTF_LETTER, false);
    ChooseSignPosts(SignPostList.GetHead(), CommandList.GetHead(),DMUS_SIGNPOSTF_ROOT, true);
    ChooseSignPosts(SignPostList.GetHead(), CommandList.GetHead(),DMUS_SIGNPOSTF_LETTER, true);
    // Now, we should have a chord assigned for each node in the template.
    TListItem<CompositionCommand>* pCommand = CommandList.GetHead();
    for (; pCommand; pCommand = pCommand->GetNext())
    {
        CompositionCommand& rCommand = pCommand->GetItemValue();
        if (rCommand.m_dwChord == 0) continue;   // Only command, no chord.
        if (rCommand.m_pSignPost)
        {
            TListItem<CompositionCommand>* pNext = GetNextChord(pCommand);
            if (pNext)
            {
                CompositionCommand& rNext = pNext->GetItemValue();
                SearchInfo *pSearch = &rCommand.m_SearchInfo;
                DMChordData *pCadence1 = NULL;
                DMChordData *pCadence2 = NULL;
                pSearch->m_Start = rCommand.m_pSignPost->GetItemValue().m_ChordData;
                if (rNext.m_dwChord & DMUS_SIGNPOSTF_CADENCE)
                {
                    pSign = rNext.m_pSignPost;
                    DMSignPost& rSign = pSign->GetItemValue();
                    if (rSign.m_dwFlags & DMUS_SPOSTCADENCEF_1)
                    {
                        pSearch->m_End = rSign.m_aCadence[0];
                        pCadence1 = &rSign.m_aCadence[0];
                        if (rSign.m_dwFlags & DMUS_SPOSTCADENCEF_2)
                        {
                            pCadence2 = &rSign.m_aCadence[1];
                        }
                    }
                    else if (rSign.m_dwFlags & DMUS_SPOSTCADENCEF_2)
                    {
                        pSearch->m_End = rSign.m_aCadence[1];
                        pCadence2 = &rSign.m_aCadence[1];
                    }
                    else
                    {
                        pSearch->m_End = rSign.m_ChordData;
                    }
                }
                else
                {
                    pSearch->m_End = rNext.m_pSignPost->GetItemValue().m_ChordData;
                }
                //**********pSearch->m_nActivity = (short) wActivity;
                pSearch->m_nBeats = (short)( (rNext.m_nMeasure - rCommand.m_nMeasure) * nBPM );
                pSearch->m_nMaxChords = (short)( pSearch->m_nBeats  );
                pSearch->m_nMinChords = 0;  // should be 1?
                FindEarlierSignpost(CommandList.GetHead(), pCommand, pSearch);
                // rCommand holds the playlist and the measure used by ChordConnections
                // (it should be passed by reference since the playlist changes)
                ChordConnections2(ChordMap, rCommand, pSearch, nBPM, pCadence1, pCadence2);
            }
            else
            {
                AddChord(rCommand.m_PlayList, &rCommand.m_pSignPost->GetItemValue().m_ChordData,
                    rCommand.m_nMeasure,0);
            }
        }
    }
    // Take all the Chord references and fold 'em into one list.
    pCommand = CommandList.GetHead();
    for (; pCommand; pCommand = pCommand->GetNext())
    {
        PlayList.Cat(pCommand->GetItemValue().m_PlayList.GetHead());
        pCommand->GetItemValue().m_PlayList.RemoveAll();
    }
    CleanUpBreaks(PlayList, CommandList.GetHead());
    pDMP->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmcompos\dmcompos.h ===
// DMCompos.h : Declaration of the CDMCompos
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// @doc EXTERNAL
//
// 

#ifndef __DMCOMPOS_H_
#define __DMCOMPOS_H_

#include "ComposIn.h"
#include "DMCompP.h"
#include "..\dmstyle\dmstyleP.h"
#include "..\shared\dmusicp.h"

#define SUBCHORD_STANDARD_CHORD 1
#define SUBCHORD_BASS 0

#define NC_SELECTED 1               // This is the active connector.
#define NC_PATH     2               // For walking the tree.
#define NC_NOPATH   4               // Failed tree walk.
#define NC_TREE     8               // For displaying a tree.

#define COMPOSEF_USING_DX8  1

inline WORD ClocksPerBeat(DMUS_TIMESIGNATURE& TimeSig)
{ return DMUS_PPQ * 4 / TimeSig.bBeat; }

inline DWORD ClocksPerMeasure(DMUS_TIMESIGNATURE& TimeSig)
{ return ClocksPerBeat(TimeSig) * TimeSig.bBeatsPerMeasure; }

inline WORD ClocksToMeasure(DWORD dwTotalClocks, DMUS_TIMESIGNATURE& TimeSig)
{ return (WORD) (dwTotalClocks / ClocksPerMeasure(TimeSig)); }

struct DMSignPostStruct
{
    MUSIC_TIME  m_mtTime;
    DWORD       m_dwChords;
    WORD        m_wMeasure;
};

struct DMExtendedChord
{
    DMExtendedChord() { m_nRefCount = 0; }
    void AddRef() { m_nRefCount++; }
    BOOL Release() { m_nRefCount--; if (m_nRefCount <= 0) { delete this; return TRUE; } else return FALSE; }
    BOOL    Equals(DMExtendedChord& rhsChord);  

    DWORD   m_dwChordPattern;
    DWORD   m_dwScalePattern;
    DWORD   m_dwInvertPattern;
    BYTE    m_bRoot;
    BYTE    m_bScaleRoot;
    WORD    m_wCFlags;
    DWORD   m_dwParts;
    int     m_nRefCount;
};

struct DMChordData
{
    DMChordData() : m_pSubChords(NULL) {}   // Default constructor
    DMChordData(DMChordData& rChord);       // Copy constructor
    DMChordData(DMUS_CHORD_PARAM& DMC);         // conversion from DMUS_CHORD_PARAM
    HRESULT Read(IAARIFFStream* pIRiffStream, MMCKINFO* pckParent, DMExtendedChord** apChordDB);
    void    Release();
    BOOL    Equals(DMChordData& rhsChord);  
    DWORD   GetChordPattern();
    char    GetRoot();
    void    SetRoot(char chNewRoot);

    String          