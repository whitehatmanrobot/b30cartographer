or()) != NERR_Success)
       )
    {
        ReportError( err );
        return;
    }

}

/*******************************************************************

    NAME:	SHARE_2::~SHARE_2

    SYNOPSIS:	Destructor for SHARE_2 class

    HISTORY:
	t-yis	8/9/91		Created

********************************************************************/

SHARE_2::~SHARE_2()
{
    memsetf((LPVOID)_nlsPassword.QueryPch(),
            0,
            _nlsPassword.QueryTextSize()) ;
}


/*******************************************************************

    NAME:	SHARE_2::I_GetInfo

    SYNOPSIS:	Get information about the share

    EXIT:	Returns API error code

    HISTORY:
	t-yis	    8/9/91	    Created
	jonn	    10/31/1991	    Removed SetBufferSize

********************************************************************/

APIERR SHARE_2::I_GetInfo( VOID )
{

    BYTE *pBuffer = NULL;
    APIERR err = ::MNetShareGetInfo ( QueryServer(), QueryName(), 2,
			&pBuffer );
    SetBufferPtr( pBuffer );
    if ( err != NERR_Success )
	return err ;

    struct share_info_2 *lpsi2 = (struct share_info_2 *) QueryBufferPtr();
    UIASSERT( lpsi2 != NULL );

    // Don't want to call SetPath because we don't need to validate the path
    _nlsPath = lpsi2->shi2_path;

#if defined(WIN32)
    SetAdminOnly( (lpsi2->shi2_type & STYPE_SPECIAL) != 0 );
    lpsi2->shi2_type &= ~STYPE_SPECIAL;
#endif

    if (   (( err = _nlsPath.QueryError()) != NERR_Success )
	|| (( err = SetPermissions( (UINT)lpsi2->shi2_permissions )) != NERR_Success )
	|| (( err = SetMaxUses( (UINT)lpsi2->shi2_max_uses )) != NERR_Success )
	|| (( err = SetCurrentUses( (UINT)lpsi2->shi2_current_uses )) != NERR_Success )
	|| (( err = SetPassword( lpsi2->shi2_passwd )) != NERR_Success )
	|| (( err = SetResourceType( (UINT)lpsi2->shi2_type)) != NERR_Success )
	|| (( err = SetComment( lpsi2->shi2_remark )) != NERR_Success )
       )
    {
        return err;
    }

    return NERR_Success;

}


/*******************************************************************

    NAME:	SHARE_2::I_CreateNew

    SYNOPSIS:	Sets up object for subsequent WriteNew

    EXIT:	Returns a standard LANMAN error code

    NOTES:	Name validation and memory allocation are done
		at this point, not at construction.  The string-valued
		fields are only valid in the NLS_STR members and are not
		valid in the buffer until WriteNew.

    HISTORY:
	t-yis    8/9/91	    Created
        JonN    05/08/92    Calls ClearBuffer()

********************************************************************/

APIERR SHARE_2::I_CreateNew( VOID )
{

    APIERR err = NERR_Success;

    if (   (( err = W_CreateNew()) != NERR_Success )
	|| (( err = ResizeBuffer( sizeof( share_info_2 ))) != NERR_Success )
	|| (( err = ClearBuffer()) != NERR_Success )
       )
    {
	return err;
    }

    struct share_info_2 *lpsi2 = (struct share_info_2 *) QueryBufferPtr();
    UIASSERT( lpsi2 != NULL );

    /*
     *  All fields of user_info_2 are listed here.  All are commented
     *  out because the effective values are stored in an NLS_SLR or
     *  other data member
     */

    // lpsi2->shi2_netname = _nlsShareName.QueryPch();
    // lpsi2->shi2_type = _uResourceType;
    // lpsi2->shi2_remark = _nlsComment.QueryPch();
    // lpsi2->shi2_permissions = _fsPermissions;
    // lpsi2->shi2_max_uses = _usMaxUses;
    // lpsi2->shi2_current_uses = _usCurrentUses;
    // lpsi2->shi2_path = _nlsPath.QueryPch();
    // lpsi2->shi2_passwd = _nlsPassword.QueryPch();

    return NERR_Success;

}

/*******************************************************************

    NAME:	SHARE_2::W_CreateNew

    SYNOPSIS:	Sets default on the new share

    EXIT:	Returns an API error code

    HISTORY:
	t-yis	8/9/91		Created

********************************************************************/

APIERR SHARE_2::W_CreateNew( VOID )
{

    APIERR err = SHARE_1::W_CreateNew();

    if ( err != NERR_Success )
    {
	return err;
    }

    // The following statements sets the values of data members
    // We bypass the set methods so that we could assign invalid values

    _fs2lPermissions = 0;
    // 0xFFFF = -1 in unsigned short, use 0xFFFF to get rid of warnings
    _uMaxUses = (UINT)-1;
    _uCurrentUses = 0;
    _nlsPath = NULL;
    _nlsPassword = NULL;

    if (   ((err = _nlsPath.QueryError()) != NERR_Success )
        || ((err = _nlsPassword.QueryError()) != NERR_Success )
       )
    {
        return err;
    }

    return NERR_Success;

}

/*******************************************************************

    NAME:	SHARE_2::CloneFrom

    SYNOPSIS:	Copies information on the share

    ENTRY:	share2 - reference to the share to copy info. from

    EXIT:	Returns an API error code

    NOTES:	W_CloneFrom copies all member objects, but it does not
    		update the otherwise unused pointers in the API buffer.
		This is left for the outermost routine, CloneFrom().
		Only the otherwise unused pointers need to be fixed
		here, the rest will be fixed in WriteInfo/WriteNew.

    HISTORY:
	t-yis	8/9/91		Created
	rustanl 8/27/91 	Changed param from * to &

********************************************************************/

APIERR SHARE_2::CloneFrom( const SHARE_2 & share2 )
{

    APIERR err = W_CloneFrom( share2 );

    if ( err != NERR_Success )
    {
	ReportError( err );
	return err;
    }

    /*
     *  No unused pointers - don't need to fix up pointers
     */

    return NERR_Success;

}


/*******************************************************************

    NAME:	SHARE_2::W_CloneFrom

    SYNOPSIS:	Copies information on the share

    ENTRY:	share2 - reference to the share to copy info. from

    EXIT:	Returns an API error code

    HISTORY:
	t-yis	8/9/91		Created
	rustanl 8/27/91 	Changed param from * to &

********************************************************************/

APIERR SHARE_2::W_CloneFrom( const SHARE_2 & share2 )
{

    APIERR err = SHARE_1::W_CloneFrom( share2 );

    // Don't want to call SetPath because we don't need to validate the path
    _nlsPath = share2.QueryPath();

    if (   ( err != NERR_Success )
	|| (( err = _nlsPath.QueryError()) != NERR_Success)
	|| (( err = SetPermissions( share2.QueryPermissions())) != NERR_Success)
	|| (( err = SetMaxUses( share2.QueryMaxUses())) != NERR_Success)
	|| (( err = SetCurrentUses( share2.QueryCurrentUses())) != NERR_Success)
	|| (( err = SetPassword( share2.QueryPassword())) != NERR_Success)
       )
    {
	return err;
    }

    return NERR_Success;

}

/*******************************************************************

    NAME:	SHARE_2::SetWriteBuffer

    SYNOPSIS:	Helper function for WriteNew and WriteInfo -- loads
		current values into the API buffer

    ENTRY:      fNew - TRUE if we are creating a new share, FALSE otherwise

    EXIT:	Returns API error code

    HISTORY:
	t-yis    8/9/91	    Created

********************************************************************/

APIERR SHARE_2::SetWriteBuffer( BOOL fNew )
{

    struct share_info_2 *lpsi2 = (struct share_info_2 *) QueryBufferPtr();
    UIASSERT( lpsi2 != NULL );

    // If no share name is null, return error
    // Share name is validated in SetName() already
    if ( QueryName() == NULL )
       return ERROR_INVALID_PARAMETER;

    // shi2_netname is a array within share_info_2 rather than a pointer
    COPYTOARRAY( lpsi2->shi2_netname, (TCHAR *)QueryName() );

    lpsi2->shi2_type = QueryResourceType();
    lpsi2->shi2_permissions = QueryPermissions();
    lpsi2->shi2_max_uses = QueryMaxUses();
    lpsi2->shi2_path = (TCHAR *) QueryPath();

    lpsi2->shi2_remark = (TCHAR *) QueryComment();

    // When creating a new share ( fNew is true), we need to pass
    // NULL instead of empty string as comment because of ADMIN$ and IPC$.
    // However, when clearing the comment via NetShareSetInfo, an
    // empty string needs to be passed instead of NULL.

    if ( fNew )
    {
        ALIAS_STR nls( lpsi2->shi2_remark );
        if ( nls.QueryTextLength() == 0 )
            lpsi2->shi2_remark = NULL;
    }

    // password is validated in SetPassword(), so don't need to validate again
    // NULL password is acceptable.

    // shi2_passwd is an array within share_info_2  rather than a pointer
    COPYTOARRAY( lpsi2->shi2_passwd, (TCHAR *)QueryPassword() );

    return NERR_Success;

}


/*******************************************************************

    NAME:	SHARE_2::I_WriteInfo

    SYNOPSIS:	Writes information about the share

    EXIT:	Returns API error code

    HISTORY:
	t-yis	    8/9/91	    Created

********************************************************************/

APIERR SHARE_2::I_WriteInfo( VOID )
{

    APIERR err = SetWriteBuffer( FALSE );
    if ( err != NERR_Success )
        return err;

    return ::MNetShareSetInfo ( QueryServer(),
               		        QueryName(), 2,
			        QueryBufferPtr(),
			        sizeof( share_info_2 ), PARMNUM_ALL);

}


/*******************************************************************

    NAME:	SHARE_2::I_WriteNew

    SYNOPSIS:	Creates a new share

    ENTRY:

    EXIT:	Returns an API error code

    NOTES:	

    HISTORY:
	t-yis	    8/9/91	    Created

********************************************************************/

APIERR SHARE_2::I_WriteNew( VOID )
{

    APIERR err = SetWriteBuffer( TRUE );
    if ( err != NERR_Success )
	return err;

    return ::MNetShareAdd ( QueryServer(), 2,
			    QueryBufferPtr(),
			    sizeof( struct share_info_2 ));

}


/*******************************************************************

    NAME:	SHARE_2::SetPermissions

    SYNOPSIS:	Set the permissions of the share

    ENTRY:	fs2lPermissions -	permissions

    EXIT:	Returns an API error code

    HISTORY:
	t-yis	 8/9/91		Created	

********************************************************************/

APIERR SHARE_2::SetPermissions( UINT fs2lPermissions )
{

    // Validate Permissions
    if ( IsValidationOn() )
    {
        if ( (fs2lPermissions & ACCESS_ALL) > ACCESS_ALL )
            return ERROR_INVALID_PARAMETER;
    }

    _fs2lPermissions = fs2lPermissions;
    return NERR_Success;

}

/*******************************************************************

    NAME:	SHARE_2::SetMaxUses

    SYNOPSIS:	Set the maximum concurrent connections allowed
                on the share

    ENTRY:	usMaxUses - maximum uses

    EXIT:	Returns an API error code

    HISTORY:
	t-yis	 8/9/91		Created	

********************************************************************/

APIERR SHARE_2::SetMaxUses( UINT uMaxUses )
{
    _uMaxUses = uMaxUses;
    return NERR_Success;
}

/*******************************************************************

    NAME:	SHARE_2::SetCurrentUses

    SYNOPSIS:	Set the current number of connections
                This value is ignored in WriteInfo/WriteNew

    ENTRY:	uCurrentUses - current uses

    EXIT:	Returns an API error code

    HISTORY:
	t-yis	 8/9/91		Created	

********************************************************************/

APIERR SHARE_2::SetCurrentUses( UINT uCurrentUses )
{
    _uCurrentUses = uCurrentUses;
    return NERR_Success;
}

/*******************************************************************

    NAME:	SHARE_2::SetPath

    SYNOPSIS:	Set the local path name of the share

    ENTRY:	pszPath - local path

    EXIT:	Returns an API error code

    HISTORY:
	t-yis	 8/9/91		Created	

********************************************************************/

APIERR SHARE_2::SetPath( const TCHAR *pszPath )
{


    ALIAS_STR nlsPath( pszPath );
    APIERR err = NERR_Success;

    if ( IsValidationOn() )
    {
        ULONG ulType; // ulType is not used, it's just a place holder
        if ( nlsPath.QueryTextLength() != 0 )
            err = ::I_MNetPathType( NULL, pszPath, &ulType, 0L);
    }

    if ( err == NERR_Success)
    {
        _nlsPath = nlsPath;

        err = _nlsPath.QueryError();
        if ( err != NERR_Success )
            _nlsPath.Reset();
    }

    return err;
}

/*******************************************************************

    NAME:	SHARE_2::SetPassword

    SYNOPSIS:	Set the password of the share on share-level server

    ENTRY:	pszPassword  - password

    EXIT:	Returns an API error code

    HISTORY:
	t-yis	 8/9/91		Created	

********************************************************************/

APIERR SHARE_2::SetPassword( const TCHAR *pszPassword )
{
    APIERR err = NERR_Success;

    if ( pszPassword != NULL )
    {
        if ( IsValidationOn() )
        {
            err = ::I_MNetNameValidate( NULL, pszPassword,
                                        NAMETYPE_SHAREPASSWORD, 0L);
        }

        if ( err == NERR_Success )
   	{
	    ALIAS_STR nlsPassword( pszPassword );
	    err = _nlsPassword.CopyFrom( nlsPassword );
	    if ( err != NERR_Success )
		_nlsPassword.Reset();
	}
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\lmosrv.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    lmosrv.cxx
    Class definitions for the SERVER_0, SERVER_1, and SERVER_2 classes.

    The SERVER_x classes are used to manipulate servers.  The classes
    are structured as follows:

        LOC_LM_OBJ
            SERVER_0
                SERVER_1
                    SERVER_2


    FILE HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        RustanL     10-Dec-1990 Added meat for SERVER_0
        KevinL      08-Jan-1991 Added SERVER_TYPE
        BenG        11-Feb-1991 Uses lmui.hxx
        ChuckC      20-Mar-1991 Cleanup construction/GetInfo
        KeithMo     01-May-1991 Added QueryDomainRole to SERVER_2
                                and SERVER_TYPE.
        KevinL      12-Aug-1991 Made SERVER_2 provide SERVER_1 funcs.
        TerryK      18-Sep-1991 Change COMPUTER's parent class to
                                LOC_LM_OBJ
        TerryK      29-Sep-1991 Add nlsComment field to the server
                                objects
        TerryK      30-Sep-1991 Code review change. Attend: jonn
                                keithmo terryk
        KeithMo     02-Oct-1991 Removed QueryDomainRole() methods.
        TerryK      07-Oct-1991 types change for NT
        KeithMo     08-Oct-1991 Now includes LMOBJP.HXX.
        TerryK      10-Oct-1991 WIN 32 conversion
        TerryK      21-Oct-1991 change UINT to USHORT2ULONG
        JonN        31-Oct-1991 Removed SetBufferSize
        KeithMo     25-Nov-1991 Rewrote almost everything.
        KeithMo     04-Dec-1991 Code review changes (from 12/04,
                                Beng, EricCh, KeithMo, TerryK).
        KeithMo     08-Sep-1992 Fixed problems with long server names.

*/

#include "pchlmobj.hxx"  // Precompiled header


//
//  IBM Lan Server version number
//

#define CURRENT_MAJOR_VER 2
#define IBMLS_MAJ         1
#define IBMLS_MIN         2


//
//  SERVER_0 methods
//

/*******************************************************************

    NAME:       SERVER_0 :: SERVER_0

    SYNOPSIS:   SERVER_0 class constructor.

    ENTRY:      pszServerName           - Name of the target server.

    EXIT:       The object is constructed.

    HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        TerryK      18-Sep-1991 Remove MakeConstruction
        KeithMo     25-Nov-1991 Recreated in the new class structure.

********************************************************************/
SERVER_0 :: SERVER_0( const TCHAR * pszServerName )
  : LOC_LM_OBJ( pszServerName )
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

}   // SERVER_0 :: SERVER_0


/*******************************************************************

    NAME:       SERVER_0 :: ~SERVER_0

    SYNOPSIS:   SERVER_0 class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        KeithMo     25-Nov-1991 Recreated in the new class structure.

********************************************************************/
SERVER_0 :: ~SERVER_0( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // SERVER_0 :: ~SERVER_0


/*******************************************************************

    NAME:       SERVER_0 :: I_GetInfo

    SYNOPSIS:   Virtual callout used by NEW_LM_OBJ to invoke the
                NetXxxGetInfo API (info-level 0).

    EXIT:       The API has been invoked, and any "persistant" data
                has been cached.  For SERVER_0, there is no data
                to cache.

    RETURNS:    APIERR                  - The result of the API.

    HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        TerryK      18-Sep-1991 change GetInfo to I_GetInfo
        KeithMo     25-Nov-1991 Recreated in the new class structure.

********************************************************************/
APIERR SERVER_0 :: I_GetInfo( VOID )
{
    BYTE * pbBuffer = NULL;

    //
    //  Invoke the API.  Note that the mapping layer will allocate
    //  the buffer for us.  We must free this buffer before we
    //  return the API result.
    //

    APIERR err = ::MNetServerGetInfo( QueryName(),
                                      SERVER_INFO_LEVEL( 0 ),
                                      &pbBuffer );

    ::MNetApiBufferFree( &pbBuffer );

    return err;

}   // SERVER_0 :: I_GetInfo



//
//  SERVER_1 methods
//

/*******************************************************************

    NAME:       SERVER_1 :: SERVER_1

    SYNOPSIS:   SERVER_1 class constructor.

    ENTRY:      pszServerName           - Name of the target server.

    EXIT:       The object is constructed.

    HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        TerryK      18-Sep-1991 Remove MakeConstruction
        KeithMo     25-Nov-1991 Recreated in the new class structure.

********************************************************************/
SERVER_1 :: SERVER_1( const TCHAR * pszServerName )
  : SERVER_0( pszServerName ),
    _nMajorVer( 0 ),
    _nMinorVer( 0 ),
    _lServerType( 0 ),
    _nlsComment()
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_nlsComment )
    {
        ReportError( _nlsComment.QueryError() );
        return;
    }

}   // SERVER_1 :: SERVER_1


/*******************************************************************

    NAME:       SERVER_1 :: ~SERVER_1

    SYNOPSIS:   SERVER_1 class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        TerryK      19-Sep-1991 Remove delete pBuffer
        KeithMo     25-Nov-1991 Recreated in the new class structure.

********************************************************************/
SERVER_1 :: ~SERVER_1( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // SERVER_1 :: ~SERVER_1


/*******************************************************************

    NAME:       SERVER_1 :: I_GetInfo

    SYNOPSIS:   Virtual callout used by NEW_LM_OBJ to invoke the
                NetXxxGetInfo API (info-level 1).

    EXIT:       The API has been invoked, and any "persistant" data
                has been cached.  For SERVER_1, this includes the
                major/minor versions, server type, and server comment.

    RETURNS:    APIERR                  - The result of the API.

    HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        TerryK      19-Sep-1991 Change GetInfo to I_GetInfo
        jonn        13-Oct-1991 Removed SetBufferSize
        KeithMo     25-Nov-1991 Recreated in the new class structure.

********************************************************************/
APIERR SERVER_1 :: I_GetInfo( VOID )
{
    BYTE * pbBuffer = NULL;

    //
    //  Invoke the API.
    //

    APIERR err = ::MNetServerGetInfo( QueryName(),
                                      SERVER_INFO_LEVEL( 1 ),
                                      &pbBuffer );

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  Tell NEW_LM_OBJ where the buffer is.
    //

    SetBufferPtr( pbBuffer );

    struct server_info_1 * psi1 = (struct server_info_1 *)pbBuffer;

    //
    //  Extract the major/minor version numbers.
    //

    SetMajorMinorVer( (UINT)( psi1->sv1_version_major & MAJOR_VERSION_MASK ),
                      (UINT)( psi1->sv1_version_minor ) );

    //
    //  Extract the server type.
    //

    SetServerType( psi1->sv1_type );

    //
    //  Save away the server comment.  Note that this may fail.
    //

    return SetComment( psi1->sv1_comment );

}   // SERVER_1 :: I_GetInfo


/*******************************************************************

    NAME:       SERVER_1 :: I_WriteInfo

    SYNOPSIS:   Virtual callout used by NEW_LM_OBJ to invoke the
                NetXxxSetInfo API (info-level 1).

    EXIT:       If successful, the target server has been updated.

    RETURNS:    APIERR                  - The result of the API.

    HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        TerryK      19-Sep-1991 Change WriteInfo to I_WriteInfo
        KeithMo     25-Nov-1991 Recreated in the new class structure.

********************************************************************/
APIERR SERVER_1 :: I_WriteInfo( VOID )
{
    //
    //  Update the server_info_1 structure.
    //

    APIERR err = W_Write();

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  Invoke the API to do the actual server update.
    //

    return ::MNetServerSetInfo ( QueryServer(),
                                 SERVER_INFO_LEVEL( 1 ),
                                 QueryBufferPtr(),
                                 sizeof( struct server_info_1 ),
                                 PARMNUM_ALL );

}   // SERVER_1 :: I_WriteInfo


/*******************************************************************

    NAME:       SERVER_1 :: W_Write

    SYNOPSIS:   Helper function for WriteNew and WriteInfo -- loads
                current values into the API buffer.

    EXIT:       The API buffer has been filled.

    RETURNS:    APIERR                  - The result of the API.

    HISTORY:
        TerryK      19-Sep-1991 Created.
        DavidHov    28-May-1992 Changed to allow for NULL server name

********************************************************************/
APIERR SERVER_1 :: W_Write( VOID )
{
    const TCHAR * pszServer = QueryName() ;
    struct server_info_1 * psi1 = (struct server_info_1 *)QueryBufferPtr();

    ASSERT( psi1 != NULL );

    if ( pszServer )
    {
        ASSERT( ::strlenf(pszServer) <= MAX_PATH );

        COPYTOARRAY( psi1->sv1_name, (TCHAR *) pszServer );
    }

    psi1->sv1_version_major = QueryMajorVer();
    psi1->sv1_version_minor = QueryMinorVer();
    psi1->sv1_type          = QueryServerType();
    psi1->sv1_comment       = (TCHAR *)QueryComment();

    return NERR_Success;

}   // SERVER_1 :: W_Write


/*******************************************************************

    NAME:       SERVER_1 :: QueryMajorVer

    SYNOPSIS:   Returns the major version of the target server.

    RETURNS:    UINT                    - The major version number.

    NOTES:      This method will return zero if the SERVER_1 object
                was not constructed properly.

    HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        TerryK      19-Sep-1991 use CHECK_OK macro

********************************************************************/
UINT SERVER_1 :: QueryMajorVer( VOID ) const
{
    CHECK_OK( 0 );

    return _nMajorVer;

}   // SERVER_1 :: QueryMajorVer


/*******************************************************************

    NAME:       SERVER_1 :: QueryMinorVer

    SYNOPSIS:   Returns the minor version of the target server.

    RETURNS:    UINT                    - The minor version number.

    NOTES:      This method will return zero if the SERVER_1 object
                was not constructed properly.

    HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        TerryK      19-Sep-1991 use CHECK_OK macro

********************************************************************/
UINT SERVER_1 :: QueryMinorVer( VOID ) const
{
    CHECK_OK( 0 );

    return _nMinorVer;

}   // SERVER_1 :: QueryMinorVer


/*******************************************************************

    NAME:       SERVER_1 :: QueryComment

    SYNOPSIS:   Returns the target server's comment.

    RETURNS:    const TCHAR *           - The target server's comment.

    NOTES:      This method will return NULL if the SERVER_1 object
                was not constructed properly.

    HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        TerryK      19-Sep-1991 use CHECK_OK macro

********************************************************************/
const TCHAR * SERVER_1 :: QueryComment( VOID ) const
{
    CHECK_OK( NULL );

    return _nlsComment.QueryPch();

}   // SERVER_1 :: QueryMinorVer


/*******************************************************************

    NAME:       SERVER_1 :: QueryServerType

    SYNOPSIS:   Returns the target server's type vector.

    RETURNS:    ULONG                   - The target server's type vector.

    NOTES:      This method will return zero if the SERVER_1 object
                was not constructed properly.

    HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        TerryK      19-Sep-1991 use CHECK_OK macro

********************************************************************/
ULONG SERVER_1 :: QueryServerType( VOID ) const
{
    CHECK_OK( 0 );

    return _lServerType;

}   // SERVER_1 :: QueryServerType


/*******************************************************************

    NAME:       SERVER_1::SetComment

    SYNOPSIS:   Sets the target server's comment.

    ENTRY:      pszComment              - The new comment.

    RETURNS:    APIERR                  - Error for setting the comment.

    HISTORY:
        TerryK      30-Sep-1991 Created

********************************************************************/
APIERR SERVER_1 :: SetComment( const TCHAR * pszComment )
{
    CHECK_OK( ERROR_GEN_FAILURE );

    return _nlsComment.CopyFrom( pszComment );

}   // SERVER_1 :: SetComment


/*******************************************************************

    NAME:       SERVER_1 :: SetMajorMinorVer

    SYNOPSIS:   This protected method will set the _nMajorVer and
                _nMinorVer members to the specified values.

    ENTRY:      uMajorVer               - The new major version number.

                uMinorVer               - The new minor version number.

    NOTES:      This method may only be called by derived subclases.

    HISTORY:
        KeithMo     25-Nov-1991 Created.
        KeithMo     04-Dec-1992 Nuked IBM LanServer & downlevel hacks.

********************************************************************/
VOID SERVER_1 :: SetMajorMinorVer( UINT nMajorVer, UINT nMinorVer )
{
    _nMajorVer = nMajorVer;
    _nMinorVer = nMinorVer;

#if 0
    //
    //  Do we really care about IBM LanServers and LM 1.0 machines??
    //  This logic screws up Window for Workgroup servers, which
    //  return version 1.5.
    //

    if( _nMajorVer < CURRENT_MAJOR_VER )
    {
        if( ( _nMajorVer >= IBMLS_MAJ ) && ( _nMinorVer >= IBMLS_MIN ) )
        {
            _nMajorVer = 2;
            _nMinorVer = 0;
        }
        else
        {
            _nMajorVer = 1;
            _nMinorVer = 0;
        }
    }
#endif

}   // SERVER_1 :: SetMajorVer


/*******************************************************************

    NAME:       SERVER_1 :: SetServerType

    SYNOPSIS:   This protected method will set the _lServerType data
                member to the specified value.

    ENTRY:      ulServerType            - The new server type vector.

    NOTES:      This method may only be called by derived subclases.

    HISTORY:
        KeithMo     25-Nov-1991 Created.

********************************************************************/
VOID SERVER_1 :: SetServerType( ULONG lServerType )
{
    _lServerType = lServerType;

}   // SERVER_1 :: SetServerType



//
//  SERVER_2 methods
//

/*******************************************************************

    NAME:       SERVER_2 :: SERVER_2

    SYNOPSIS:   SERVER_2 class constructor.

    ENTRY:      pszServerName           - Name of the target server.

    EXIT:       The object is constructed.

    HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        TerryK      19-Sep-1991 Remove MakeConstructed
        KeithMo     25-Nov-1991 Recreated in the new class structure.

********************************************************************/
SERVER_2 :: SERVER_2( const TCHAR * pszServerName )
  : SERVER_1( pszServerName ),
    _nSecurity( 0 )
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

}   // SERVER_2 :: SERVER_2


/*******************************************************************

    NAME:       SERVER_2 :: ~SERVER_2

    SYNOPSIS:   SERVER_2 class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        KeithMo     25-Nov-1991 Recreated in the new class structure.

********************************************************************/
SERVER_2 :: ~SERVER_2( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // SERVER_2 :: ~SERVER_2


/*******************************************************************

    NAME:       SERVER_2 :: I_GetInfo

    SYNOPSIS:   Virtual callout used by NEW_LM_OBJ to invoke the
                NetXxxGetInfo API (info-level 2).

    EXIT:       The API has been invoked, and any "persistant" data
                has been cached.  For SERVER_2, this includes the
                major/minor versions, server type, server comment,
                and security type.

    RETURNS:    APIERR                  - The result of the API.

    HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        KeithMo     01-May-1991 Added code to determine domain role.
        TerryK      19-Sep-1991 Change GetInfo to I_GetInfo
        KeithMo     02-Oct-1991 Removed QueryDomainRole method.
        jonn        13-Oct-1991 Removed SetBufferSize
        KeithMo     25-Nov-1991 Recreated in the new class structure.

********************************************************************/
APIERR SERVER_2 :: I_GetInfo( VOID )
{
    BYTE * pbBuffer = NULL;

    //
    //  Invoke the API.
    //

    APIERR err = ::MNetServerGetInfo( QueryName(),
                                      SERVER_INFO_LEVEL( 2 ),
                                      &pbBuffer );

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  Tell NEW_LM_OBJ where the buffer is.
    //

    SetBufferPtr( pbBuffer );

    struct server_info_2 * psi2 = (struct server_info_2 *)pbBuffer;

    //
    //  Extract the major/minor version numbers.
    //

    SetMajorMinorVer( (UINT)( psi2->sv2_version_major & MAJOR_VERSION_MASK ),
                      (UINT)( psi2->sv2_version_minor ) );

    //
    //  Extract the server type.
    //

    SetServerType( psi2->sv2_type );

    //
    //  Save away the server comment.  Note that this may fail.
    //

    err = SetComment( psi2->sv2_comment );

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  Extract the security type.
    //

#if defined( WIN32 )

    //
    //  In their on-going efforts to add needless complexity to our
    //  lives, the designers of the Win32 network API have decided
    //  to split the old server_info_x structures into a number of
    //  separate SERVER_INFO_xxx structures.  Unfortunately (for us)
    //  the "security" field is in a separate structure whose info-
    //  level depends on the target machines platform ID.  Ergo, we
    //  must decipher the platform ID, issue an appropriate API
    //  info-level, and interpret the results.  Ack!  Pfft!!!
    //

    switch( psi2->sv102_platform_id )
    {
    case SV_PLATFORM_ID_OS2 :
        //
        //  OS/2 servers can be either user or share security.
        //

        //
        //  The following MNetServerGetInfo will perform an infolevel 402
        //  getinfo.  The number 402 can be derived by SV_PLADFORM_ID + 2.
        //  The SERVER_INFO_402 structure contains platform-specific info
        //  for OS/2 servers.  The security field is held in this structure.
        //

        err = ::MNetServerGetInfo( QueryName(),
                                   402,
                                   &pbBuffer );

        if( err != NERR_Success )
        {
            return err;
        }

        SetSecurity( (UINT)(((SERVER_INFO_402 *)pbBuffer)->sv402_security) );

        ::MNetApiBufferFree( &pbBuffer );
        break;

    case SV_PLATFORM_ID_NT :
        //
        //  NT servers are always (for the moment...) user security.
        //

        SetSecurity( SV_USERSECURITY );
        break;

    default :
        //
        //  Hmm...  This should probably never happen, but we should
        //  set the security field to something reasonable.
        //

#ifdef TRACE
        UITRACE( SZ("Got invalid platform ID : ") );
        UITRACENUM( (LONG)psi2->sv102_platform_id );
        UITRACE( SZ(", assuming security = SHARE\n\r") );
#endif

        SetSecurity( (UINT)SV_SHARESECURITY );
        break;
    }

#else   // !WIN32

    //
    //  Since we not running Win32, we can just extract
    //  the security field from the server_info_2 structure.
    //

    SetSecurity( psi2->sv2_security );

#endif  // WIN32

    SetMaxUsers( psi2->sv2_users );

    return NERR_Success;

}   // SERVER_2 :: I_GetInfo


/*******************************************************************

    NAME:       SERVER_2 :: I_WriteInfo

    SYNOPSIS:   Virtual callout used by NEW_LM_OBJ to invoke the
                NetXxxSetInfo API (info-level 2).

    EXIT:       If successful, the target server has been updated.

    RETURNS:    APIERR                  - The result of the API.

    HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        TerryK      19-Sep-1991 Change WriteInfo to I_WriteInfo
        KeithMo     25-Nov-1991 Recreated in the new class structure.

********************************************************************/
APIERR SERVER_2 :: I_WriteInfo( VOID )
{
    //
    //  Update the server_info_2 structure.
    //

    APIERR err = W_Write();

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  Invoke the API to do the actual server update.
    //

    return ::MNetServerSetInfo ( QueryServer(),
                                 SERVER_INFO_LEVEL( 2 ),
                                 QueryBufferPtr(),
                                 sizeof( struct server_info_2 ),
                                 PARMNUM_ALL );

}   // SERVER_2 :: I_WriteInfo


/*******************************************************************

    NAME:       SERVER_2 :: W_Write

    SYNOPSIS:   Helper function for WriteNew and WriteInfo -- loads
                current values into the API buffer.

    EXIT:       The API buffer has been filled.

    RETURNS:    APIERR                  - The result of the API.

    NOTES:      As currently written, this method will *NOT* update
                the target server's security field if this code is
                running under Win32.

    HISTORY:
        TerryK      19-Sep-1991 Created.
        DavidHov    28-May-1992 Changed to allow for NULL server name

********************************************************************/
APIERR SERVER_2 :: W_Write( VOID )
{
    const TCHAR * pszServer = QueryName() ;
    struct server_info_2 * psi2 = (struct server_info_2 *)QueryBufferPtr();

    ASSERT( psi2 != NULL );

    if ( pszServer )
    {
        ASSERT( ::strlenf(pszServer) <= MAX_PATH );

        COPYTOARRAY( psi2->sv2_name, (TCHAR *) pszServer );
    }

    psi2->sv2_version_major = QueryMajorVer();
    psi2->sv2_version_minor = QueryMinorVer();
    psi2->sv2_type          = QueryServerType();
    psi2->sv2_comment       = (TCHAR *)QueryComment();

#if !defined( WIN32 )
    psi2->sv2_security      = QuerySecurity();
#endif  // WIN32

    psi2->sv2_users         = QueryMaxUsers();

    return NERR_Success;

}   // SERVER_2 :: W_Write


/*******************************************************************

    NAME:       SERVER_2 :: QuerySecurity

    SYNOPSIS:   Returns the target server's security type (either
                SV_SHARESECURITY or SV_USERSECURITY).

    RETURNS:    UINT                    - The target server's security
                                          type.

    NOTES:      This method will return SV_SHARESECURITY if the
                SERVER_2 object was not properly constructed.

    HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        TerryK      19-Sep-1991 Use CHECK_OK macro

********************************************************************/
UINT SERVER_2 :: QuerySecurity( VOID ) const
{
    CHECK_OK ( SV_SHARESECURITY );

    return _nSecurity;

}   // SERVER_2 :: QuerySecurity


/*******************************************************************

    NAME:       SERVER_2 :: SetSecurity

    SYNOPSIS:   This protected method will set the target server's
                security type (either SV_SHARESECURITY or
                SV_USERSECURITY).

    ENTRY:      uSecurity               - The target server's new
                                          security type.

    NOTES:      This method may only be called by derived subclases.

    HISTORY:
        KeithMo     25-Nov-1991 Created.

********************************************************************/
VOID SERVER_2 :: SetSecurity( UINT uSecurity )
{
    _nSecurity = uSecurity;

}   // SERVER_2 :: SetSecurity


/*******************************************************************

    NAME:       SERVER_2 :: QueryMaxUsers

    SYNOPSIS:   Queries the maximum number of users allowed by the server

    RETURNS:    UINT                    - The target server's max # of users

    HISTORY:
        BruceFo     26-Sep-1995 Created

********************************************************************/
UINT SERVER_2 :: QueryMaxUsers( VOID ) const
{
    return _nMaxUsers;

}   // SERVER_2 :: QueryMaxUsers


/*******************************************************************

    NAME:       SERVER_2 :: SetMaxUsers

    SYNOPSIS:   Sets the maximum number of users allowed by the server. Note
                that the server allows you to set it to anything, but on
                reboot, the server will reset the number to be <= its maximum
                session count.

    ENTRY:      uMaxUsers       - The target server's new max number of users

    NOTES:      This method may only be called by derived subclases.

    HISTORY:
        BruceFo     26-Sep-1995 Created

********************************************************************/
VOID SERVER_2 :: SetMaxUsers( UINT uMaxUsers )
{
    _nMaxUsers = uMaxUsers;

}   // SERVER_2 :: SetMaxUsers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\lmouser.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**                Copyright(c) Microsoft Corp., 1990                **/
/**********************************************************************/

/*  HISTORY:
 *      gregj   4/16/91         Created.
 *      gregj   4/22/91         Added USER, USER_11.
 *      gregj   4/29/91         Results of 4/29/91 code review
 *                              with chuckc, jimh, terryk, ericch
 *      gregj   5/21/91         Use new LOCATION class
 *      gregj   5/22/91         Support LOCATION's LOCATION_TYPE constructor
 *      jonn    7/22/91         USER_11 now writable
 *      rustanl 8/21/91         Renamed NEW_LM_OBJ buffer methods
 *      rustanl 8/26/91         Changed [W_]CloneFrom parameter from * to &
 *      jonn    8/29/91         Added ChangeToNew(), Query/SetAccountDisabled
 *      jonn    9/03/91         Added Query/SetUserComment()
 *      jonn    9/03/91         Added Query/SetParms()
 *      terryk  9/11/91         Added LOGON_USER here
 *      terryk  9/19/91         Added CHECK_OK to LOGON_USER
 *      terryk  9/20/91         Move LOGON_USER to Lmomisc.cxx
 *      terryk  10/7/91         types change for NT
 *      KeithMo 10/8/91         Now includes LMOBJP.HXX.
 *      terryk  10/17/91        WIN 32 conversion
 *      jonn    10/17/91        Fixed up password plus cleared bug-bugs.
 *      terryk  10/21/91        WIN 32 conversion ( part 2 )
 *      jonn    10/31/91        Removed SetBufferSize
 *      jonn    11/01/91        Added parms filter
 *      jonn    12/11/91        Added LogonHours accessors
 *      thoamspa 1/21/92        Added Rename()
 *      jonn     2/26/92        Fixups for 32-bit
 *      beng    05/07/92        Removed LOGON_HOURS_SETTING to collections
 *
 */

#include "pchlmobj.hxx"  // Precompiled header


// string constant for "any logon server"
#define SERVER_ANY SZ("\\\\*")



/*******************************************************************

    NAME:       USER::USER

    SYNOPSIS:   constructor for the USER object

    ENTRY:      pszAccount -    account name
                pszLocation -   server or domain name to execute on;
                                default (NULL) means the local computer
                OR:
                loctype -       type of location, local computer or
                                logon domain

    EXIT:       Object is constructed

    NOTES:      Validation is not done until GetInfo() time.

    HISTORY:
        gregj       4/22/91     Created
        gregj       5/22/91     Added LOCATION_TYPE constructor
        beng        22-Nov-1991 Corrected owner-alloc members

********************************************************************/

VOID USER::CtAux( const TCHAR * pszAccount )
{
    if ( QueryError() )
        return;

    APIERR err = SetName( pszAccount );
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
}

USER::USER(const TCHAR *pszAccount, const TCHAR *pszLocation)
        : LOC_LM_OBJ( pszLocation ),
          CT_NLS_STR(_nlsAccount)
{
    CtAux( pszAccount );
}

USER::USER(const TCHAR *pszAccount, enum LOCATION_TYPE loctype)
        : LOC_LM_OBJ( loctype ),
          CT_NLS_STR(_nlsAccount)
{
    CtAux( pszAccount );
}

USER::USER(const TCHAR *pszAccount, const LOCATION & loc)
        : LOC_LM_OBJ( loc ),
          CT_NLS_STR(_nlsAccount)
{
    CtAux( pszAccount );
}


/*******************************************************************

    NAME:       USER::~USER

    SYNOPSIS:   Destructor for USER class

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        gregj   4/22/91         Created

********************************************************************/

USER::~USER()
{
}


/*******************************************************************

    NAME:       USER::HandleNullAccount

    SYNOPSIS:   Validates the account name

    ENTRY:

    EXIT:       Returns a standard LANMAN error code

    NOTES:      Modifies _nlsAccount if it was empty

    HISTORY:
        gregj   4/29/91         Created
        jonn    8/12/91         Renamed from ValidateAccount()

********************************************************************/

APIERR USER::HandleNullAccount()
{
    if ( _nlsAccount.strlen() == 0 ) {
        WKSTA_10 wksta(NULL);

        APIERR err = wksta.GetInfo();
        if (err != NERR_Success)
            return err;

        TCHAR *pszLogonUser = (TCHAR *)wksta.QueryLogonUser();
        if ( pszLogonUser != NULL )
        {
            UIASSERT( strlenf(pszLogonUser) <= UNLEN );
            err =_nlsAccount.CopyFrom(pszLogonUser);
            if ( err != NERR_Success )
                return err;
        }
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:       USER::QueryName

    SYNOPSIS:   Returns the account name of a user

    EXIT:       Returns a pointer to the account name

    NOTES:      Will be the same as the account name supplied at
                construction, except it will probably be uppercased
                by the API.

                Valid for objects in CONSTRUCTED state, thus no CHECK_OK

    HISTORY:
        gregj   4/22/91         Created

********************************************************************/

const TCHAR *USER::QueryName() const
{
    return _nlsAccount.QueryPch();
}


/*******************************************************************

    NAME:       USER::Rename

    SYNOPSIS:   renames the given username

    ENTRY:      TCHAR * pszAccount, new account name

    EXIT:       error code

    NOTES:      CODEWORK This is no longer used by User Manager and is
                probably not needed anymore.

    HISTORY:
        thomaspa        1/23/92         Created

********************************************************************/

APIERR USER::Rename( const TCHAR * pszAccount )
{

    ASSERT( strlenf(pszAccount) <= UNLEN );

    APIERR err = ::MNetUserSetInfo( QueryServer(),
                                  (TCHAR *) QueryName(),
                                  0,
                                  (PBYTE) &pszAccount,
                                  sizeof( user_info_0 ),
                                  PARMNUM_ALL );

    if ( err == NERR_Success )
    {
        // NOTE: we are not validating the new name.  It is assumed
        // that the user will do this.

        REQUIRE( _nlsAccount.CopyFrom(pszAccount) == NERR_Success );
    }

    return err;
}


/*******************************************************************

    NAME:       USER::SetName

    SYNOPSIS:   Changes the account name of a user

    ENTRY:      new account name

    EXIT:       Returns an API error code

    HISTORY:
        jonn    7/24/91         Created

********************************************************************/

APIERR USER::SetName( const TCHAR * pszAccount )
{
    if ( (pszAccount != NULL) && (strlenf(pszAccount) > UNLEN) )
        return ERROR_INVALID_PARAMETER;
    else
    {
        if ( (pszAccount != NULL) && ( strlenf(pszAccount) > 0 ) )
        {
            APIERR err = ::I_MNetNameValidate( NULL, pszAccount, NAMETYPE_USER, 0L );
            if ( err != NERR_Success )
                return NERR_BadUsername;
        }

        return _nlsAccount.CopyFrom(pszAccount);
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:       USER::W_CloneFrom

    SYNOPSIS:   Copies information on the user

    EXIT:       Returns an API error code

    HISTORY:
        jonn    7/24/91         Created
        rustanl 8/26/91         Changed parameter from * to &

********************************************************************/

APIERR USER::W_CloneFrom( const USER & user )
{
    APIERR err = LOC_LM_OBJ::W_CloneFrom( user );
    if ( err != NERR_Success )
        return err;

    _nlsAccount = user.QueryName();
    ASSERT( _nlsAccount.QueryError() == NERR_Success );

    return NERR_Success;
}

/*******************************************************************

    NAME:       USER::I_Delete

    SYNOPSIS:   Deletes the user (calls NET API)

    RETURNS:    Returns an API error code

    HISTORY:
        o-SimoP         12-Aug-91       Created
********************************************************************/

APIERR USER::I_Delete( UINT uiForce )
{
    UNREFERENCED( uiForce );
    return ::MNetUserDel( QueryServer(), (TCHAR *)QueryName() );
}


/*******************************************************************

    NAME:       USER_11::USER_11

    SYNOPSIS:   Constructor for USER_11 class

    ENTRY:      pszAccount -    account name
                pszLocation -   server or domain name to execute on;
                                default (NULL) means the logon domain

    EXIT:       Object is constructed

    NOTES:      Validation is not done until GetInfo() time.

    CAVEATS:    Should we create a ctor-helper to perform the common
                work?
    HISTORY:
        gregj   4/22/91         Created
        gregj   5/22/91         Added LOCATION_TYPE constructor

********************************************************************/

VOID USER_11::CtAux()
{

    if ( QueryError() )
        return;

    APIERR err = NERR_Success;
    if (   ( (err = _nlsComment.QueryError()) != NERR_Success )
        || ( (err = _nlsUserComment.QueryError()) != NERR_Success )
        || ( (err = _nlsFullName.QueryError()) != NERR_Success )
        || ( (err = _nlsHomeDir.QueryError()) != NERR_Success )
        || ( (err = _nlsParms.QueryError()) != NERR_Success )
        || ( (err = _nlsWorkstations.QueryError()) != NERR_Success )
        || ( (err = _logonhrs.QueryError()) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

}

USER_11::USER_11( const TCHAR *pszAccount, const TCHAR *pszLocation )
        : USER( pszAccount, pszLocation ),
          _uPriv( USER_PRIV_USER ),
          _flAuth( 0L ),
          _nlsComment(),
          _nlsUserComment(),
          _nlsFullName(),
          _nlsHomeDir(),
          _nlsParms(),
          _nlsWorkstations(),
          _logonhrs()
{
    CtAux();
}

USER_11::USER_11( const TCHAR *pszAccount, enum LOCATION_TYPE loctype )
        : USER( pszAccount, loctype ),
          _uPriv( USER_PRIV_USER ),
          _flAuth( 0L ),
          _nlsComment(),
          _nlsUserComment(),
          _nlsFullName(),
          _nlsHomeDir(),
          _nlsParms(),
          _nlsWorkstations(),
          _logonhrs()
{
    CtAux();
}

USER_11::USER_11( const TCHAR *pszAccount, const LOCATION & loc )
        : USER( pszAccount, loc ),
          _uPriv( USER_PRIV_USER ),
          _flAuth( 0L ),
          _nlsComment(),
          _nlsUserComment(),
          _nlsFullName(),
          _nlsHomeDir(),
          _nlsParms(),
          _nlsWorkstations(),
          _logonhrs()
{
    CtAux();
}


/*******************************************************************

    NAME:       USER_11::~USER_11

    SYNOPSIS:   Destructor for USER_11 class

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        gregj   4/22/91         Created

********************************************************************/

USER_11::~USER_11()
{
}


/*******************************************************************

    NAME:       USER_11::I_GetInfo

    SYNOPSIS:   Gets information about the local user

    ENTRY:

    EXIT:       Returns a standard LANMAN error code

    NOTES:      Name validation and memory allocation are done
                at this point, not at construction.

    HISTORY:
        gregj       4/16/91         Created
        beng        15-Jul-1991     BUFFER::Resize changed return type
        jonn        13-Oct-1991     Removed SetBufferSize

********************************************************************/

APIERR USER_11::I_GetInfo()
{
    // Validate the account name

    APIERR err = HandleNullAccount();
    if (err != NERR_Success)
        return err;

    // Location is validated in LOC_LM_OBJ ctor
    BYTE *pBuffer = NULL;
    err = ::MNetUserGetInfo ( QueryServer(), (TCHAR *)_nlsAccount.QueryPch(), 11,
        &pBuffer );
    SetBufferPtr( pBuffer );

    if ( err != NERR_Success )
        return err;

    struct user_info_11 *lpui11 = (struct user_info_11 *)QueryBufferPtr();
    UIASSERT( lpui11 != NULL );

    _uPriv  = (UINT)lpui11->usri11_priv;
    _flAuth = lpui11->usri11_auth_flags;

    if (   ((err = SetName( lpui11->usri11_name )) != NERR_Success )
        || ((err = SetComment( lpui11->usri11_comment )) != NERR_Success)
        || ((err = SetUserComment( lpui11->usri11_usr_comment )) != NERR_Success)
        || ((err = SetFullName( lpui11->usri11_full_name )) != NERR_Success )
        || ((err = SetHomeDir( lpui11->usri11_home_dir )) != NERR_Success )
        || ((err = SetParms( lpui11->usri11_parms )) != NERR_Success )
        || ((err = SetWorkstations( lpui11->usri11_workstations )) != NERR_Success )
        || ((err = SetLogonHours( (BYTE *)lpui11->usri11_logon_hours,
                                  (UINT)lpui11->usri11_units_per_week)) != NERR_Success )
       )
    {
        return err;
    }

    return NERR_Success;

}


/*******************************************************************

    NAME:       USER_11::W_CloneFrom

    SYNOPSIS:   Copies information on the user

    EXIT:       Returns an API error code

    HISTORY:
        jonn    7/24/91         Created
        rustanl 8/26/91         Changed parameter from * to &

********************************************************************/

APIERR USER_11::W_CloneFrom( const USER_11 & user11 )
{
    APIERR err = NERR_Success;
    if (   ((err = USER::W_CloneFrom( user11 )) != NERR_Success )
        || ((err = SetPriv( user11.QueryPriv())) != NERR_Success )
        || ((err = SetAuthFlags( user11.QueryAuthFlags())) != NERR_Success )
        || ((err = SetComment( user11.QueryComment())) != NERR_Success)
        || ((err = SetUserComment( user11.QueryUserComment())) != NERR_Success)
        || ((err = SetFullName( user11.QueryFullName())) != NERR_Success)
        || ((err = SetHomeDir( user11.QueryHomeDir())) != NERR_Success )
        || ((err = SetParms( user11.QueryParms())) != NERR_Success )
        || ((err = SetWorkstations( user11.QueryWorkstations() )) != NERR_Success )
        || ((err = SetLogonHours( user11.QueryLogonHours() )) != NERR_Success )
       )
    {
        UIDEBUG( SZ("USER_11::W_CloneFrom failed\r\n") );
        return err;
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:       USER_11::W_CreateNew

    SYNOPSIS:   initializes private data members for new object

    EXIT:       Returns an API error code

    HISTORY:
        jonn    8/13/91         Created

********************************************************************/

APIERR USER_11::W_CreateNew()
{
    APIERR err = NERR_Success;
    if (   ((err = USER::W_CreateNew()) != NERR_Success )
        || ((err = SetComment( NULL )) != NERR_Success )
        || ((err = SetUserComment( NULL )) != NERR_Success )
        || ((err = SetFullName( NULL )) != NERR_Success )
        || ((err = SetPriv( USER_PRIV_USER )) != NERR_Success )
        || ((err = SetAuthFlags( 0L )) != NERR_Success )
        || ((err = SetHomeDir( NULL )) != NERR_Success )
        || ((err = SetParms( NULL )) != NERR_Success )
        || ((err = SetWorkstations( NULL )) != NERR_Success )
        || ((err = SetLogonHours( NULL )) != NERR_Success )
       )
    {
        UIDEBUG( SZ("USER_11::W_CreateNew failed\r\n") );
        return err;
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:       USER_11::QueryPriv

    SYNOPSIS:   Returns the privilege level of a user

    ENTRY:

    EXIT:       USER_PRIV_GUEST, USER_PRIV_USER, or USER_PRIV_ADMIN

    NOTES:

    HISTORY:
        gregj   4/22/91         Created

********************************************************************/

UINT USER_11::QueryPriv() const
{
    CHECK_OK(USER_PRIV_USER);
    return( _uPriv ) ;
}


/*******************************************************************

    NAME:       USER_11::QueryAuthFlags

    SYNOPSIS:   Returns the authorization flags (operator rights)
                of a user

    EXIT:       Mask containing any of the following:

                AF_OP_PRINT     Print operator
                AF_OP_COMM      Comm queue operator
                AF_OP_SERVER    Server operator
                AF_OP_ACCOUNTS  Accounts operator

    HISTORY:
        gregj   4/22/91         Created

********************************************************************/

ULONG USER_11::QueryAuthFlags() const
{
    CHECK_OK(0L);
    return( _flAuth ) ;
}


/*******************************************************************

    NAME:       USER_11::IsXXXOperator

    SYNOPSIS:   Returns whether the user has XXX operator rights

    EXIT:       TRUE if the user is a XXX operator

    NOTES:      Will return FALSE if the user is an administrator

                Why "!!"?  If the flag is in the top word, we will lose
                it in translation to BOOL (SHORT) without this.

    HISTORY:
        gregj   4/29/91         Created

********************************************************************/

BOOL USER_11::IsPrintOperator() const
{
    return !!(QueryAuthFlags() & AF_OP_PRINT);
}

BOOL USER_11::IsCommOperator() const
{
    return !!(QueryAuthFlags() & AF_OP_COMM);
}

BOOL USER_11::IsServerOperator() const
{
    return !!(QueryAuthFlags() & AF_OP_SERVER);
}

BOOL USER_11::IsAccountsOperator() const
{
    return !!(QueryAuthFlags() & AF_OP_ACCOUNTS);
}


/*******************************************************************

    NAME:       USER_11::SetComment

    SYNOPSIS:   Changes the comment set by administrator

    EXIT:       error code.  If not NERR_Success the object is still valid.

    HISTORY:
        jonn    7/23/91         Created

********************************************************************/

APIERR USER_11::SetComment( const TCHAR * pszComment )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    return _nlsComment.CopyFrom( pszComment );

}


/*******************************************************************

    NAME:       USER_11::SetUserComment

    SYNOPSIS:   Changes the comment set by user

    EXIT:       error code.  If not NERR_Success the object is still valid.

    HISTORY:
        jonn    7/23/91         Created

********************************************************************/

APIERR USER_11::SetUserComment( const TCHAR * pszUserComment )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    return _nlsUserComment.CopyFrom( pszUserComment );

}


/*******************************************************************

    NAME:       USER_11::SetFullName

    SYNOPSIS:   Changes the user's fullname

    EXIT:       error code.  If not NERR_Success the object is still valid.

    HISTORY:
        jonn    7/23/91         Created

********************************************************************/

APIERR USER_11::SetFullName( const TCHAR * pszFullName )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    return _nlsFullName.CopyFrom( pszFullName );
}


/*******************************************************************

    NAME:       USER_11::SetPriv

    SYNOPSIS:   Changes the user's privilege level

    EXIT:       error code.

    HISTORY:
        jonn    7/30/91         Created

********************************************************************/

APIERR USER_11::SetPriv( UINT uPriv )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    _uPriv = uPriv;
    return NERR_Success;
}


/*******************************************************************

    NAME:       USER_11::SetAuthFlags

    SYNOPSIS:   Changes the user's authorization flags (operator rights)

    EXIT:       error code.

    HISTORY:
        jonn    8/07/91         Created

********************************************************************/

APIERR USER_11::SetAuthFlags( ULONG flAuth )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    _flAuth = flAuth;
    return NERR_Success;
}


/*******************************************************************

    NAME:       USER_11::SetHomeDir

    SYNOPSIS:   Changes the user's home directory

    EXIT:       error code.  If not NERR_Success the object is still valid.

    HISTORY:
        o-SimoP 08/27/91        Created

********************************************************************/

APIERR USER_11::SetHomeDir( const TCHAR * pszHomeDir )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    return _nlsHomeDir.CopyFrom( pszHomeDir );
}


/*******************************************************************

    NAME:       USER_11::SetParms

    SYNOPSIS:   Changes the user's application-defined parameters

    EXIT:       error code.  If not NERR_Success the object is still valid.

    HISTORY:
        o-SimoP 08/27/91        Created

********************************************************************/

APIERR USER_11::SetParms( const TCHAR * pszParms )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    return _nlsParms.CopyFrom( pszParms );
}


/*******************************************************************

    NAME:       USER_11::SetWorkstations

    SYNOPSIS:   Sets the user's valid logon workstations

    EXIT:       error code.  If not NERR_Success the object is still valid.

    HISTORY:
        o-SimoP 10/02/91        Created

********************************************************************/

APIERR USER_11::SetWorkstations( const TCHAR * pszWstations )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    return _nlsWorkstations.CopyFrom( pszWstations );
}


/*******************************************************************

    NAME:       USER_11::SetLogonHours

    SYNOPSIS:   Changes the user's logon hours

    EXIT:       error code.  If not NERR_Success the object is still valid.

    HISTORY:
        jonn    12/11/91        Created

********************************************************************/

APIERR USER_11::SetLogonHours( const UCHAR * pLogonHours,
                               UINT unitsperweek )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    if ( pLogonHours == NULL )
        return _logonhrs.MakeDefault();
    else
        return _logonhrs.SetFromBits( pLogonHours, unitsperweek );
}


/*******************************************************************

    NAME:       USER_11::TrimParams

    SYNOPSIS:   Like LM21 NIF, User Manager trims certain Dialin
                information out of the parms field when a user is
                cloned.  This does not happen automatically on
                CloneFrom, instead the caller must call TrimParms
                explicitly.

    EXIT:       error code.  If not NERR_Success the object is still valid.

    NOTES:      As per agreement with LM21, program management and other
                concerned parties, this method trims the Dialin
                information from the parms string but not the Macintosh
                Access information.  This is because the Dialin
                information may carry significant security privileges,
                but the Macintosh primary group is not as significant a
                security risk.

    HISTORY:
        JonN    11/01/91        Copied from
                        \\deficit\lm!ui\nif\nif\utils2.c:CloneUsrParams
        jonN    12/10/92        UNICODE cleanup

********************************************************************/

// JonN: from utils.h
// usr_parms munging stuff
#define UP_CLIENT_MAC   TCH('m')
#define UP_CLIENT_DIAL  TCH('d')

// JonN: from utils2.c
// definitions et al for usr_parms functions
#define UP_LEN_MAC              LM20_GNLEN
#define UP_LEN_DIAL             (48 - 3 - UP_LEN_MAC)

typedef struct {
        TCHAR   up_MACid;
        TCHAR   up_PriGrp[UP_LEN_MAC];
        TCHAR   up_MAC_Terminater;
        TCHAR   up_DIALid;
        TCHAR   up_CBNum[UP_LEN_DIAL];
        TCHAR   up_Null;
} USER_PARMS;
typedef USER_PARMS FAR * PUP;

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

APIERR USER_11::TrimParams()
{
    const TCHAR * pchParms = QueryParms();
    if ( pchParms == NULL )
        return NERR_Success;

    // check if the buffer is large enough to hold RAS info.
    // UP_LEN_MAC + 4  will do it

    if ( strlenf(pchParms) < UP_LEN_MAC + 4 )
        return NERR_Success;

    USER_PARMS * pupBuf = (USER_PARMS *)pchParms;

    // Check signature bytes.
    if ((pupBuf->up_MACid != UP_CLIENT_MAC)
        || (pupBuf->up_DIALid != UP_CLIENT_DIAL))
    {
        return NERR_Success;
    }

    size_t cbParmLen = (::strlenf(pchParms)+1) * sizeof(TCHAR);
    cbParmLen = max(sizeof(USER_PARMS), cbParmLen );
    BUFFER bufNewParms( cbParmLen );
    APIERR err = bufNewParms.QueryError();
    if (err != NERR_Success)
    {
        return err;
    }

    TCHAR * pchParmsNew = (TCHAR *) bufNewParms.QueryPtr();
    ::strcpyf( pchParmsNew, pchParms );

    // Ok, it's valid. Do our thing.
    USER_PARMS * pupBufNew = (USER_PARMS *)pchParmsNew;
    pupBufNew->up_CBNum[0] = 1;     // no RAS perms
    for ( int i = 1; i < UP_LEN_DIAL; i++ )
        pupBufNew->up_CBNum[i] = TCH(' ');

    // Make sure the buffer is null terminated.
    pchParmsNew[ cbParmLen/sizeof(TCHAR) - 1 ] = TCH('\0');

    err = SetParms( pchParmsNew );

    return err;
}


/*******************************************************************

    NAME:       USER_2::CtAux

    SYNOPSIS:   Constructor helper for USER_2 class

    EXIT:       ReportError is called if nesessary

    HISTORY:
        o-SimoP 08/27/91        Created

********************************************************************/

VOID USER_2::CtAux()
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (   ((err = _nlsScriptPath.QueryError()) != NERR_Success)
        || ((err = _nlsPassword.QueryError()) != NERR_Success) )
    {
        ReportError( err );
        return;
    }
}

/*******************************************************************

    NAME:       USER_2::USER_2

    SYNOPSIS:   Constructor for USER_2 class

    ENTRY:      pszAccount -    account name
                pszLocation -   server or domain name to execute on;
                                default (NULL) means the logon domain

    EXIT:       Object is constructed

    NOTES:      Validation is not done until GetInfo() time.

                These constructors/destructors are not strictly
                necessary, but may be needed later if we add accessors
                to USER_2-specific fields.

    HISTORY:
        jonn    7/24/91         Created

********************************************************************/


USER_2::USER_2( const TCHAR *pszAccount, const TCHAR *pszLocation )
        : USER_11( pszAccount, pszLocation ),
          _afUserFlags( UF_SCRIPT ),
          _lAcctExpires( TIMEQ_FOREVER ),
          _nlsPassword(),
          _nlsScriptPath()
{
    CtAux();
}

USER_2::USER_2( const TCHAR *pszAccount, enum LOCATION_TYPE loctype )
        : USER_11( pszAccount, loctype ),
          _afUserFlags( UF_SCRIPT ),
          _lAcctExpires( TIMEQ_FOREVER ),
          _nlsPassword(),
          _nlsScriptPath()
{
    CtAux();
}

USER_2::USER_2( const TCHAR *pszAccount, const LOCATION & loc )
        : USER_11( pszAccount, loc ),
          _afUserFlags( UF_SCRIPT ),
          _lAcctExpires( TIMEQ_FOREVER ),
          _nlsPassword(),
          _nlsScriptPath()
{
    CtAux();
}



/*******************************************************************

    NAME:       USER_2::~USER_2

    SYNOPSIS:   Destructor for USER_2 class

    HISTORY:
        jonn    7/24/91         Created

********************************************************************/

USER_2::~USER_2()
{
    // clear password from pagefile
    ::memsetf( (void *)(_nlsPassword.QueryPch()),
               0x20,
               _nlsPassword.strlen() );
}


/*******************************************************************

    NAME:       USER_2::I_GetInfo

    SYNOPSIS:   Gets information about the local user

    EXIT:       Returns API error code

    NOTES:      In I_GetInfo, we set the password to NULL_USERSETINFO_PASSWD.
                NetUserGetInfo[2] will never give us a real password, but
                only this value.  If this value is passed though to
                SetInfo, the user's password will not be changed.

    HISTORY:
        jonn        7/24/91         Created
        jonn        13-Oct-1991     Removed SetBufferSize
        beng        29-Mar-1992     Removed verboten PCH type

********************************************************************/

APIERR USER_2::I_GetInfo()
{
    // Validate the account name

    APIERR err = HandleNullAccount();
    if (err != NERR_Success)
        return err;

    BYTE *pBuffer = NULL;
    err = ::MNetUserGetInfo ( QueryServer(), (TCHAR*)_nlsAccount.QueryPch(), 2,
                              &pBuffer );
    SetBufferPtr( pBuffer );
    if ( err != NERR_Success )
        return err;

    struct user_info_2 *lpui2 = (struct user_info_2 *)QueryBufferPtr();
    UIASSERT( lpui2 != NULL );

    if (   ((err = SetName( lpui2->usri2_name )) != NERR_Success )
        || ((err = SetPriv( (UINT)lpui2->usri2_priv )) != NERR_Success )
        || ((err = SetAuthFlags( (UINT)lpui2->usri2_auth_flags )) != NERR_Success )
        || ((err = SetComment( lpui2->usri2_comment )) != NERR_Success)
        || ((err = SetUserComment( lpui2->usri2_usr_comment )) != NERR_Success)
        || ((err = SetFullName( lpui2->usri2_full_name )) != NERR_Success )
        || ((err = SetHomeDir( lpui2->usri2_home_dir )) != NERR_Success )
        || ((err = SetParms( lpui2->usri2_parms )) != NERR_Success )
        || ((err = SetScriptPath( lpui2->usri2_script_path )) != NERR_Success )
        || ((err = SetAccountExpires( lpui2->usri2_acct_expires )) != NERR_Success )
        || ((err = SetUserFlags( (UINT)lpui2->usri2_flags )) != NERR_Success )
        || ((err = SetPassword( UI_NULL_USERSETINFO_PASSWD )) != NERR_Success )
        || ((err = SetWorkstations( lpui2->usri2_workstations )) != NERR_Success )
        || ((err = SetLogonHours( (BYTE *)lpui2->usri2_logon_hours,
                                  (UINT)lpui2->usri2_units_per_week )) != NERR_Success )
       )
    {
        return err;
    }

    return NERR_Success;

}


/*******************************************************************

    NAME:       USER_2::W_CreateNew

    SYNOPSIS:   initializes private data members for new object

    EXIT:       Returns an API error code

    NOTES:      Unlike I_GetInfo, we set the password to NULL.  This is
                an appropriate initial value for a new user.

    HISTORY:
        o-SimoP         08/28/91        Created
        JonN            10/17/91        Sets password to NULL

********************************************************************/

APIERR USER_2::W_CreateNew()
{
    APIERR err = NERR_Success;
    if (   ((err = USER_11::W_CreateNew()) != NERR_Success )
        || ((err = SetScriptPath( NULL )) != NERR_Success )
        || ((err = SetPassword( NULL )) != NERR_Success )
        || ((err = SetAccountExpires( TIMEQ_FOREVER )) != NERR_Success )
        || ((err = SetUserFlags( UF_SCRIPT )) != NERR_Success )
       )
    {
        UIDEBUG( SZ("USER_2::W_CreateNew failed\r\n") );
        return err;
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:       USER_2::I_CreateNew

    SYNOPSIS:   Sets up object for subsequent WriteNew

    EXIT:       Returns a standard LANMAN error code

    NOTES:      Name validation and memory allocation are done
                at this point, not at construction.  The string-valued
                fields are only valid in the NLS_STR members and are not
                valid in the buffer until WriteNew.

                EXCEPTION: We don't validate the account name until
                WriteNew.

                Default values taken from NetCmd::user_add().

    HISTORY:
        jonn        7/22/91         Created
        JonN        05/08/92        Calls ClearBuffer()

********************************************************************/

APIERR USER_2::I_CreateNew()
{

    APIERR err = NERR_Success;
    if (   ((err = W_CreateNew()) != NERR_Success )
        || ((err = ResizeBuffer( sizeof(user_info_2) )) != NERR_Success )
        || ((err = ClearBuffer()) != NERR_Success )
       )
    {
        return err;
    }

    struct user_info_2 *lpui2 = (struct user_info_2 *)QueryBufferPtr();
    UIASSERT( lpui2 != NULL );

    /*
        All fields of user_info_2 are listed here.  Some are commented
        out because:
        (1) They are adequately initialized by BufferClear()
        (2) The effective value is stored in an NLS_SLR or other data member
    */
    // lpui2->usri2_name =
    // strcpyf( lpui2->usri2_password, QueryPassword() );
    // lpui2->usri2_password_age =
    // lpui2->usri2_priv = _usPriv = USER_PRIV_USER;
    // lpui2->usri2_home_dir =
    // lpui2->usri2_comment = (PSZ)_nlsComment.QueryPch();
    // lpui2->usri2_flags = UF_SCRIPT;
    // lpui2->usri2_script_path =
    // lpui2->usri2_auth_flags = _flAuth = 0L;
    // lpui2->usri2_full_name = (PSZ)_nlsFullName.QueryPch();
    // lpui2->usri2_usr_comment = (PSZ)_nlsUserComment.QueryPch();
    // lpui2->usri2_parms =
    // lpui2->usri2_workstations =
    // lpui2->usri2_last_logon =
    // lpui2->usri2_last_logoff =
    lpui2->usri2_acct_expires = TIMEQ_FOREVER;
    lpui2->usri2_max_storage = USER_MAXSTORAGE_UNLIMITED;
    // lpui2->usri2_units_per_week =
    // lpui2->usri2_logon_hours =
    // lpui2->usri2_bad_pw_count =
    // lpui2->usri2_num_logons =
    lpui2->usri2_logon_server = SERVER_ANY;
    // lpui2->usri2_country_code =
    // lpui2->usri2_code_page =

    return NERR_Success;

}


/*******************************************************************

    NAME:       USER_2::W_CloneFrom

    SYNOPSIS:   Copies information on the user

    EXIT:       Returns an API error code

    HISTORY:
        jonn    7/24/91         Created
        rustanl 8/26/91         Changed parameter from * to &
        o-SimoP 08/28/91        Cloned from USER_11::W_CloneFrom

********************************************************************/

APIERR USER_2::W_CloneFrom( const USER_2 & user2 )
{
    APIERR err = NERR_Success;
    if (   ((err = USER_11::W_CloneFrom( user2 )) != NERR_Success )
        || ((err = SetScriptPath( user2.QueryScriptPath() )) != NERR_Success )
        || ((err = SetPassword( user2.QueryPassword() )) != NERR_Success )
        || ((err = SetAccountExpires( user2.QueryAccountExpires() )) != NERR_Success )
        || ((err = SetUserFlags( user2.QueryUserFlags() )) != NERR_Success)
       )
    {
        UIDEBUG( SZ("USER_2::W_CloneFrom failed\r\n") );
        return err;
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:       USER_2::CloneFrom

    SYNOPSIS:   Copies information on the user

    EXIT:       Returns an API error code

    NOTES:      W_CloneFrom copies all member objects, but it does not
                update the otherwise unused pointers in the API buffer.
                This is left for the outermost routine, CloneFrom().
                Only the otherwise unused pointers need to be fixed
                here, the rest will be fixed in WriteInfo/WriteNew.

                usri2_logon_server is an "obscure" pointer which may
                have one of two origins:
                (1) It may have been pulled in by GetInfo, in which case
                    it is in the buffer;
                (2) It may have been created by CreateNew, in which case
                    it points to a static string outside the buffer.
                To handle these cases, FixupPointer must try to fixup
                logon_server except where it points outside the buffer.

    HISTORY:
        jonn    7/24/91         Created
        rustanl 8/26/91         Changed parameter from * to &

********************************************************************/

APIERR USER_2::CloneFrom( const USER_2 & user2 )
{
    APIERR err = W_CloneFrom( user2 );
    if ( err != NERR_Success )
    {
        UIDEBUG( SZ("USER_2::W_CloneFrom failed with error code ") );
        UIDEBUGNUM( (LONG)err );
        UIDEBUG( SZ("\r\n") );

        ReportError( err ); // make unconstructed here
        return err;
    }

    /*
        This is where I fix up the otherwise unused pointers.
    */
    user_info_2 *pAPIuser2 = (user_info_2 *)QueryBufferPtr();


    /*
        Do not attempt to merge these into a macro, the compiler will not
        interpret the "&(p->field)" correctly if you do.
    */
    FixupPointer32(((TCHAR**)&(pAPIuser2->usri2_name)), (& user2));
    FixupPointer( (TCHAR **)&(pAPIuser2->usri2_script_path), &user2 );
    FixupPointer( (TCHAR **)&(pAPIuser2->usri2_logon_server), &user2 );

    FixupPointer( (TCHAR **)&(pAPIuser2->usri2_full_name), &user2 );

    return NERR_Success;
}


/*******************************************************************

    NAME:       USER_2::W_Write

    SYNOPSIS:   Helper function for WriteNew and WriteInfo -- loads
                current values into the API buffer

    EXIT:       Returns API error code

    HISTORY:
        jonn        8/12/91         Created

********************************************************************/

APIERR USER_2::W_Write()
{
    struct user_info_2 *lpui2 = (struct user_info_2 *)QueryBufferPtr();
    ASSERT( lpui2 != NULL );
    ASSERT( _nlsAccount.QueryError() == NERR_Success );
    ASSERT( _nlsAccount.strlen() <= UNLEN );
    // usri2_name is a buffer rather than a pointer
    COPYTOARRAY( lpui2->usri2_name, (TCHAR *)_nlsAccount.QueryPch() );
    lpui2->usri2_comment = (TCHAR *)QueryComment();
    lpui2->usri2_usr_comment = (TCHAR *)QueryUserComment();
    lpui2->usri2_full_name = (TCHAR *)QueryFullName();
    lpui2->usri2_priv = QueryPriv();
    lpui2->usri2_auth_flags = QueryAuthFlags();
    lpui2->usri2_flags = QueryUserFlags();
    lpui2->usri2_home_dir = (TCHAR *)QueryHomeDir();
    lpui2->usri2_parms = (TCHAR *)QueryParms();
    lpui2->usri2_script_path = (TCHAR *)QueryScriptPath();
    lpui2->usri2_acct_expires = QueryAccountExpires();
    lpui2->usri2_workstations = (TCHAR *)QueryWorkstations();
    lpui2->usri2_units_per_week = QueryLogonHours().QueryUnitsPerWeek();
    lpui2->usri2_logon_hours = (UCHAR *)(QueryLogonHours().QueryHoursBlock());

#ifndef WIN32
    memsetf( lpui2->usri2_password, 0, ENCRYPTED_PWLEN );
#endif // WIN32
    COPYTOARRAY( lpui2->usri2_password, (TCHAR*)QueryPassword() );

    return NERR_Success;
}


/*******************************************************************

    NAME:       USER_2::I_WriteInfo

    SYNOPSIS:   Writes information about the local user

    EXIT:       Returns API error code

    HISTORY:
        jonn        7/24/91         Created

********************************************************************/

APIERR USER_2::I_WriteInfo()
{
    APIERR err = W_Write();
    if ( err != NERR_Success )
        return err;

    return ::MNetUserSetInfo ( QueryServer(), (TCHAR *)_nlsAccount.QueryPch(), 2,
                        QueryBufferPtr(),
                        sizeof( struct user_info_2 ), PARMNUM_ALL );

}


/*******************************************************************

    NAME:       USER_2::I_WriteNew

    SYNOPSIS:   Creates a new user

    ENTRY:

    EXIT:       Returns an API error code

    NOTES:

    HISTORY:
        jonn        7/22/91         Created

********************************************************************/

APIERR USER_2::I_WriteNew()
{
    // Validate the account name

    APIERR err = HandleNullAccount();
    if (err != NERR_Success)
        return err;

    err = W_Write();
    if ( err != NERR_Success )
        return err;

/*
    We pass size sizeof(struct user_info_2) instead of QueryBufferSize()
    to force all pointers to point outside of the buffer.
*/

    return ::MNetUserAdd( QueryServer(), 2,
                          QueryBufferPtr(),
                          sizeof( struct user_info_2 ) );
}


/**********************************************************\

    NAME:       USER_2::I_ChangeToNew

    SYNOPSIS:   NEW_LM_OBJ::ChangeToNew() transforms a NEW_LM_OBJ from VALID
                to NEW status only when a corresponding I_ChangeToNew()
                exists.  The user_info_2 API buffer is the same for new
                and valid objects, so this nethod doesn't have to do
                much.

    HISTORY:
        JonN        29-Aug-1991     Created

\**********************************************************/

APIERR USER_2::I_ChangeToNew()
{
    return W_ChangeToNew();
}


/*******************************************************************

    NAME:       USER_2::SetAccountExpires

    SYNOPSIS:   Changes the user's account expires time

    EXIT:       error code.  If not NERR_Success the object is still valid.

    HISTORY:
        o-SimoP         08/28/91        Created

********************************************************************/

APIERR USER_2::SetAccountExpires( LONG lExpires )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    _lAcctExpires = lExpires;
    return NERR_Success;
}


/*******************************************************************

    NAME:       USER_2::SetUserFlags

    SYNOPSIS:   Changes the user's user flags

    EXIT:       error code.  If not NERR_Success the object is still valid.

    HISTORY:
        o-SimoP         08/28/91        Created

********************************************************************/

APIERR USER_2::SetUserFlags( UINT afFlags )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    _afUserFlags = afFlags;
    return NERR_Success;
}


/*******************************************************************

    NAME:       USER_2::SetScriptPath

    SYNOPSIS:   Changes the user's script path

    EXIT:       error code.  If not NERR_Success the object is still valid.

    HISTORY:
        o-SimoP         08/28/91        Created

********************************************************************/

APIERR USER_2::SetScriptPath( const TCHAR * pszScriptPath )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    return _nlsScriptPath.CopyFrom( pszScriptPath );
}


/*******************************************************************

    NAME:       USER_2::SetPassword

    SYNOPSIS:   Changes the user password

    ENTRY:      Expects a pointer to a valid password

    EXIT:       error code.

    NOTES:      This must be a null-terminated string of length at most
                PWLEN TCHAR.

    HISTORY:
        jonn    8/27/91         Created
        jonn    6/13/93         Clear password from pagefile

********************************************************************/

APIERR USER_2::SetPassword( const TCHAR * pszPassword )
{
    CHECK_OK( ERROR_GEN_FAILURE );

    //  NULL and NULL_USERSETINFO_PASSWD must also validate
    APIERR err = NERR_Success;
    if (   pszPassword != NULL
        && (::strcmpf(pszPassword, UI_NULL_USERSETINFO_PASSWD) != 0)
        && (err = ::I_MNetNameValidate( NULL, pszPassword, NAMETYPE_PASSWORD, 0L ))
                != NERR_Success
       )
    {
        return NERR_BadPassword;
    }

    // clear password from pagefile
    ::memsetf( (void *)(_nlsPassword.QueryPch()),
               0x20,
               _nlsPassword.strlen() );
    return _nlsPassword.CopyFrom( pszPassword );
}


/*******************************************************************

    NAME:       USER_2::QueryUserFlag

    SYNOPSIS:   Queries a specific flag (usriX_flags)

    EXIT:       BOOL whether flag is set

    NOTES:      "!!" ensures that result is in first 16 bits -- not
                strictly necessary at present, but a precaution in case
                this moves to ULONG

    HISTORY:
        jonn    8/28/91         Created

********************************************************************/

BOOL USER_2::QueryUserFlag( UINT afMask ) const
{
    return !!( QueryUserFlags() & afMask );
}


/*******************************************************************

    NAME:       USER_2::SetUserFlag

    SYNOPSIS:   Sets a specific flag (usriX_flags)

    ENTRY:      BOOL whether flag should be set

    EXIT:       error code

    HISTORY:
        jonn    8/28/91         Created

********************************************************************/

APIERR USER_2::SetUserFlag( BOOL fSetTo, UINT afMask )
{
    if ( fSetTo )
        return SetUserFlags( QueryUserFlags() | afMask );
    else
        return SetUserFlags( QueryUserFlags() & ~afMask );
}


/*******************************************************************

    NAME:       USER_2::QueryAccountDisabled

    SYNOPSIS:   Queries the account disabled flag (usriX_flags)

    EXIT:       BOOL whether account is disabled

    NOTES:      "!!" ensures that the data is not lost in the conversion
                to BOOL

    HISTORY:
        jonn    8/28/91         Created

********************************************************************/

BOOL USER_2::QueryAccountDisabled() const
{
    return QueryUserFlag( UF_ACCOUNTDISABLE );
}


/*******************************************************************

    NAME:       USER_2::SetAccountDisabled

    SYNOPSIS:   Sets the account disabled flag (usriX_flags)

    ENTRY:      BOOL whether account is disabled

    EXIT:       error code

    HISTORY:
        jonn    8/28/91         Created

********************************************************************/

APIERR USER_2::SetAccountDisabled( BOOL fAccountDisabled )
{
    return SetUserFlag( fAccountDisabled, UF_ACCOUNTDISABLE );
}


/*******************************************************************

    NAME:       USER_2::QueryUserCantChangePass

    SYNOPSIS:   Queries the user-cannot-change-password flag (usriX_flags)

    EXIT:       BOOL whether user cannot change password

    HISTORY:
        jonn    8/28/91         Created

********************************************************************/

BOOL USER_2::QueryUserCantChangePass() const
{
    return QueryUserFlag( UF_PASSWD_CANT_CHANGE );
}


/*******************************************************************

    NAME:       USER_2::SetUserCantChangePass

    SYNOPSIS:   Sets the user-cannot-change-password flag (usriX_flags)

    ENTRY:      BOOL whether user cannot change password

    EXIT:       error code

    HISTORY:
        jonn    8/28/91         Created

********************************************************************/

APIERR USER_2::SetUserCantChangePass( BOOL fUserCantChangePass )
{
    return SetUserFlag( fUserCantChangePass, UF_PASSWD_CANT_CHANGE );
}


/*******************************************************************

    NAME:       USER_2::QueryNoPasswordExpire

    SYNOPSIS:   Queries the password-does-not-expire flag (usriX_flags)

    EXIT:       BOOL whether the password does not expire

    HISTORY:
        thomaspa    8/5/92         Created

********************************************************************/

BOOL USER_2::QueryNoPasswordExpire() const
{
    return QueryUserFlag( UF_DONT_EXPIRE_PASSWD );
}


/*******************************************************************

    NAME:       USER_2::SetNoPasswordExpire

    SYNOPSIS:   Sets the password-does-not-expire flag (usriX_flags)

    ENTRY:      BOOL whether the password does not expire

    EXIT:       error code

    HISTORY:
        thomaspa    8/05/92         Created

********************************************************************/

APIERR USER_2::SetNoPasswordExpire( BOOL fNoPasswordExpire )
{
    return SetUserFlag( fNoPasswordExpire, UF_DONT_EXPIRE_PASSWD );
}


/*******************************************************************

    NAME:       USER_2::QueryUserPassRequired

    SYNOPSIS:   Queries the password-required flag (usriX_flags)

    EXIT:       BOOL whether a password is required for this account

    HISTORY:
        jonn    8/29/91         Created

********************************************************************/

BOOL USER_2::QueryUserPassRequired() const
{
    return !( QueryUserFlag( UF_PASSWD_NOTREQD ) );
}


/*******************************************************************

    NAME:       USER_2::SetUserPassRequired

    SYNOPSIS:   Sets the password-required flag (usriX_flags)

    ENTRY:      BOOL whether a password is required for this account

    EXIT:       error code

    HISTORY:
        jonn    8/29/91         Created

********************************************************************/

APIERR USER_2::SetUserPassRequired( BOOL fUserPassRequired )
{
    return SetUserFlag( !fUserPassRequired, UF_PASSWD_NOTREQD );
}


/*******************************************************************

    NAME:       USER_2::QueryLockout

    SYNOPSIS:   Queries the locked-out flag (usriX_flags)

    EXIT:       BOOL whether the account is locked out

    HISTORY:
        jonn    12/28/93        Created

********************************************************************/

BOOL USER_2::QueryLockout() const
{
    return QueryUserFlag( UF_LOCKOUT );
}


/*******************************************************************

    NAME:       USER_2::SetLockout

    SYNOPSIS:   Sets the locked-out flag (usriX_flags)

    ENTRY:      BOOL whether the account is locked out

    EXIT:       error code

    HISTORY:
        jonn    12/28/93        Created

********************************************************************/

APIERR USER_2::SetLockout( BOOL fLockout )
{
    return SetUserFlag( fLockout, UF_LOCKOUT );
}




/*******************************************************************

    NAME:       LOCAL_USER::LOCAL_USER

    SYNOPSIS:   Constructor for LOCAL_USER class

    ENTRY:      pszLocation -   server or domain to execute on;
                                default (NULL) means logon domain

                pszPassword -   password for down-level ADMIN$ share

    EXIT:       object is constructed

    HISTORY:
        gregj   4/22/91         Created
        gregj   5/22/91         Added LOCATION_TYPE constructor

********************************************************************/

LOCAL_USER::LOCAL_USER (const TCHAR *pszLocation, const TCHAR *pszPassword)
        : USER_11(NULL, pszLocation)
{
    _fAdminConnect = FALSE;

    memsetf( _szPassword, 0, sizeof(_szPassword) );
    if (pszPassword)
        strncpyf( _szPassword, pszPassword,
                  sizeof _szPassword / sizeof (TCHAR) - 1 ) ;
}


LOCAL_USER::LOCAL_USER ( enum LOCATION_TYPE loctype )
        : USER_11(NULL, loctype)
{
    _fAdminConnect = FALSE;

    memsetf( _szPassword, 0, sizeof(_szPassword) );
}


/*******************************************************************

    NAME:       LOCAL_USER::~LOCAL_USER

    SYNOPSIS:   Destructor for LOCAL_USER class

    EXIT:       Automatically disconnects the ADMIN$ share if one
                was created in I_GetInfo()

    HISTORY:
        gregj   4/22/91         Created

********************************************************************/

LOCAL_USER::~LOCAL_USER()
{
    //  Disconnect from ADMIN$ if necessary

    if (_fAdminConnect) {
        TCHAR remote_buf [MAX_PATH+1];
        APIERR err;

        strcpyf ( remote_buf, QueryServer() );
        strcatf ( remote_buf, SZ("\\ADMIN$") );
        err = ::MNetUseDel ( NULL, remote_buf, USE_LOTS_OF_FORCE );
        if ( err != NERR_Success ) {
            UIDEBUG(SZ("Error disconnecting ADMIN$ in ~USER_11.\r\n"));
        }
    }
}


/*******************************************************************

    NAME:       LOCAL_USER::I_GetInfo

    SYNOPSIS:   Gets information about the local user

    EXIT:       Automatically creates an ADMIN$ share to share-level
                servers

    RETURNS:    Returns a standard LANMAN error code

    NOTES:      The difference between this and USER_11::I_GetInfo
                is some extra fiddling around to handle share-level
                servers.

    HISTORY:
        gregj   4/23/91         Created

********************************************************************/

APIERR LOCAL_USER::I_GetInfo()
{
    APIERR err = USER_11::I_GetInfo();

    if (err == ERROR_NOT_SUPPORTED) {
        //  Try connecting to ADMIN$, maybe this is share-level

        //  CODEWORK: Move the following NetUseAdd call, and the
        //  corresponding NetUseDel in the destructor, into a
        //  separate CONNECTION class.

        use_info_1 ui1;
        TCHAR remote_buf [MAX_PATH+1];
        TCHAR local_buf [MAX_PATH+1];

        ui1.ui1_local = local_buf;
        ui1.ui1_local [0] = TCH('\0');  // no local device name
        strcpyf ( remote_buf, QueryServer() );
        strcatf ( remote_buf, SZ("\\ADMIN$") );
        ui1.ui1_remote = remote_buf;
        ui1.ui1_password = _szPassword;
        ui1.ui1_asg_type = USE_WILDCARD;

        err = ::MNetUseAdd (NULL, 1, (BYTE *)&ui1, sizeof (ui1));
        if (err == NERR_Success) {
            //  Connected successfully.  Fake up account info.

            _fAdminConnect = TRUE;      // so destructor will disconnect
        }
    }

    return err;
}


/*******************************************************************

    NAME:       LOCAL_USER::QueryPriv

    SYNOPSIS:   Returns the privilege level of a user

    RETURNS:    USER_PRIV_GUEST, USER_PRIV_USER, or USER_PRIV_ADMIN

    HISTORY:
        gregj   4/23/91         Created

********************************************************************/

UINT LOCAL_USER::QueryPriv() const
{
    return((!QueryError()) ?
           (_fAdminConnect ? USER_PRIV_ADMIN : USER_11::QueryPriv()) : 0) ;
}


/*******************************************************************

    NAME:       LOCAL_USER::QueryAuthFlags

    SYNOPSIS:   Returns the authorization flags (operator rights)
                of a user

    RETURNS:    Mask containing any of the following:

                AF_OP_PRINT     Print operator
                AF_OP_COMM      Comm queue operator
                AF_OP_SERVER    Server operator
                AF_OP_ACCOUNTS  Accounts operator

    HISTORY:
        gregj   4/23/91         Created

********************************************************************/

ULONG LOCAL_USER::QueryAuthFlags() const
{
    return((!QueryError() && !_fAdminConnect) ? USER_11::QueryAuthFlags() : 0L) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\lmow32.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		   Copyright(c) Microsoft Corp., 1990		     **/
/**********************************************************************/

/*
 * History
 *	jonn        9/16/92       Created
 */

#include "pchlmobj.hxx"  // Precompiled header

#include "lmow32.hxx"


/**********************************************************\

    NAME:       ::GetW32ComputerName

    SYNOPSIS:   loads ::GetComputerName into an NLS_STR

    RETURNS:    APIERR

    HISTORY:
        jonn        9/16/92       Created

\**********************************************************/

APIERR GetW32ComputerName( NLS_STR & nls )
{
    DWORD cbBufLen = (MAX_COMPUTERNAME_LENGTH+1) * sizeof(TCHAR);
    BUFFER buf( (UINT)cbBufLen );
    APIERR err = buf.QueryError();
    if ( err == NERR_Success )
    {
        if ( !::GetComputerName( (TCHAR *)buf.QueryPtr(), &cbBufLen ) )
        {
            err = ::GetLastError();
            DBGEOL( "::GetW32ComputerName: error " << err );
        }
        else
        {
            err = nls.CopyFrom( (const TCHAR *)buf.QueryPtr() );
            DBGEOL( "::GetW32ComputerName: string error " << err );
        }
    }

    return err;
}


/**********************************************************\

    NAME:       ::GetW32UserName

    SYNOPSIS:   loads ::GetUserName into an NLS_STR

    RETURNS:    APIERR

    NOTES:      Note that, contrary to the documentation, this will
                always get the username and never the fullname.

    HISTORY:
        jonn        9/16/92       Created

\**********************************************************/

APIERR GetW32UserName( NLS_STR & nls )
{
    DWORD cbBufLen = (UNLEN+1) * sizeof(TCHAR);
    BUFFER buf( (UINT)cbBufLen );
    APIERR err = buf.QueryError();
    if ( err == NERR_Success )
    {
        if ( !::GetUserName( (TCHAR *)buf.QueryPtr(), &cbBufLen ) )
        {
            err = ::GetLastError();
            DBGEOL( "::GetW32UserName: error " << err );
        }
        else
        {
            err = nls.CopyFrom( (const TCHAR *)buf.QueryPtr() );
            DBGEOL( "::GetW32UserName: string error " << err );
        }
    }

    return err;
}


/**********************************************************\

    NAME:       ::GetW32UserAndDomainName

    SYNOPSIS:   loads username and domain name into two NLS_STRs

    RETURNS:    APIERR

    NOTES:      Note that, contrary to the documentation, this will
                always get the username and never the fullname.

                Unlike ::GetUserName, this information is always for
                the calling process, and does not take impersonation
                into account.

                This code was stolen from ADVAPI32.DLL and slightly
                modified, thus the mixed metaphor between RTL calls
                and NETUI primitives.

    HISTORY:
        jonn        9/17/92       Templated from windows\base\advapi\username.c

\**********************************************************/

APIERR GetW32UserAndDomainName( NLS_STR & nlsUserName,
                                NLS_STR & nlsDomainName )
{
    APIERR err = NERR_Success;

    // Never mind about impersonating anybody.
    // Instead, lets get the token out of the process.

    HANDLE hToken = NULL;
    if (!::OpenProcessToken( ::GetCurrentProcess(), TOKEN_QUERY, &hToken ))
    {
        REQUIRE( (err = ::GetLastError()) != NERR_Success );
        DBGEOL(   "ADMIN: GetW32UserAndDomainName: ::OpenProcessToken() error "
               << err );
    }

    // determine how much space will be needed for token information
    // we expect ERROR_INSUFFICIENT_BUFFER

    DWORD cbTokenBuffer = 0;
    TOKEN_USER *pUserToken = NULL;
    if (   (err == NERR_Success)
        && !::GetTokenInformation( hToken, TokenUser, pUserToken,
                                   cbTokenBuffer, &cbTokenBuffer )
       )
    {
        REQUIRE( (err = ::GetLastError()) != NERR_Success );
        if (err == ERROR_INSUFFICIENT_BUFFER)
        {
            err = NERR_Success;
        }
        else if (err != NERR_Success)
        {
            DBGEOL(   "ADMIN: GetW32UserAndDomainName: first call to ::GetTokenInformation() error"
                   << err);
        }
    }
    TRACEEOL( "ADMIN: GetW32UserAndDomainName: token buffer " << cbTokenBuffer );

    // now get token information

    BUFFER bufTokenInformation( (UINT)cbTokenBuffer );
    if (   err == NERR_Success
        && (err = bufTokenInformation.QueryError()) == NERR_Success
        && (pUserToken = (TOKEN_USER *)bufTokenInformation.QueryPtr(), TRUE)
        && (!::GetTokenInformation( hToken, TokenUser,  pUserToken,
                                    cbTokenBuffer, &cbTokenBuffer))
       )
    {
        REQUIRE( (err = ::GetLastError()) != NERR_Success );
        DBGEOL(   "ADMIN: GetW32UserAndDomainName: second call to ::GetTokenInformation() error "
               << err);
    }

    if (hToken != NULL)
    {
        ::CloseHandle( hToken );
    }

    // determine how much space is needed for username and domainname

    TCHAR * pchUserNameBuffer = NULL;
    DWORD cchUserNameBuffer = 0;
    TCHAR * pchDomainNameBuffer = NULL;
    DWORD cchDomainNameBuffer = 0;
    SID_NAME_USE SidNameUse;
    if (   err == NERR_Success
        && (!::LookupAccountSid( NULL, pUserToken->User.Sid,
                                 pchUserNameBuffer, &cchUserNameBuffer,
                                 pchDomainNameBuffer, &cchDomainNameBuffer,
                                 &SidNameUse))
       )
    {
        REQUIRE( (err = ::GetLastError()) != NERR_Success );
        if (err == ERROR_INSUFFICIENT_BUFFER)
        {
            err = NERR_Success;
        }
        else if (err != NERR_Success)
        {
            DBGEOL( "ADMIN: GetW32UserAndDomainName: first call to ::LookupAccountSid() error "
                   << err );
        }
    }
    TRACEEOL( "ADMIN: GetW32UserAndDomainName: user buffer " << cchUserNameBuffer );
    TRACEEOL( "ADMIN: GetW32UserAndDomainName: domain buffer " << cchDomainNameBuffer );

    // now get username and domainname

    BUFFER  bufUserName( (UINT)cchUserNameBuffer*sizeof(TCHAR) );
    BUFFER  bufDomainName( (UINT)cchDomainNameBuffer*sizeof(TCHAR) );
    if (   err == NERR_Success
        && (err = bufUserName.QueryError()) == NERR_Success
        && (err = bufDomainName.QueryError()) == NERR_Success
        && (pchUserNameBuffer = (TCHAR *)bufUserName.QueryPtr(), TRUE)
        && (pchDomainNameBuffer = (TCHAR *)bufDomainName.QueryPtr(), TRUE)
        && (!::LookupAccountSid( NULL, pUserToken->User.Sid,
                                 pchUserNameBuffer, &cchUserNameBuffer,
                                 pchDomainNameBuffer, &cchDomainNameBuffer,
                                 &SidNameUse))
       )
    {
        REQUIRE( (err = ::GetLastError()) != NERR_Success );
        DBGEOL( "ADMIN: GetW32UserAndDomainName: second call to ::LookupAccountSid() error "
               << err );
    }

    // now copy the username and domainname

    if (err == NERR_Success)
    {
        if (   (err = nlsUserName.CopyFrom( pchUserNameBuffer )) != NERR_Success
            || (err = nlsDomainName.CopyFrom( pchDomainNameBuffer )) != NERR_Success
           )
        {
            DBGEOL(   "ADMIN: GetW32UserAndDomainName: final copy error "
                   << err );
        }
    }

#ifdef DEBUG
    if (err != NERR_Success)
    {
        DBGEOL( "ADMIN: GetW32UserAndDomainName: returns " << err );
    }
    else
    {
        TRACEEOL(   "ADMIN: GetW32UserAndDomainName: username    \""
                 << nlsUserName
                 << "\"" );
        TRACEEOL(   "ADMIN: GetW32UserAndDomainName: domain name \""
                 << nlsDomainName
                 << "\"" );
    }
#endif DEBUG

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\lmowks.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		   Copyright(c) Microsoft Corp., 1990		     **/
/**********************************************************************/

/*  HISTORY:
 *	ChuckC	    07-Dec-1990     Created
 *	beng	    11-Feb-1991     Uses lmui.hxx
 *	ChuckC	    3/6/91	    Code Review changes from 2/28/91
 *				    (chuckc,johnl,rustanl,annmc,jonshu)
 *	terryk	    9/17/91	    Change the parent class from LM_OBJ
 *				    to LOC_LM_BOJ
 *	terryk	    10/7/91	    types changes for NT
 *	KeithMo	    10/8/91	    Now includes LMOBJP.HXX.
 *	terryk	    10/17/91	    WIN 32 conversion
 *	terryk	    10/21/91	    WIN 32 conversion
 *	KeithMo	    10/22/91	    Would you believe more WIN 32 conversion?
 *	jonn        10/31/91	    Removed SetBufferSize
 *
 */

#include "pchlmobj.hxx"  // Precompiled header


/************************* workstation, Level 10 ************************/

/**********************************************************\

    NAME:       WKSTA_10::WKSTA_10

    SYNOPSIS:   workstation 10 constructor

    ENTRY:      const TCHAR * pszName - computer name

    HISTORY:
	ChuckC	    07-Dec-1990     Created
	terryk	    17-Sep-1991	    Add QueryError()

\**********************************************************/

WKSTA_10::WKSTA_10(const TCHAR * pszName)
    : COMPUTER (pszName),
    uMinorVer( 0 ),
    uMajorVer( 0 ),
    pszLogonUser( NULL ),
    pszWkstaDomain( NULL ),
    pszLogonDomain( NULL ),
    pslOtherDomains( NULL )
#ifdef WIN32
    , _pwkui1( NULL )
#endif	// WIN32
{
}

/**********************************************************\

    NAME:       WKSTA_10::~WKSTA_10

    SYNOPSIS:   destructor for workstation 10 object

    HISTORY:
	ChuckC	    07-Dec-1990     Created

\**********************************************************/

WKSTA_10::~WKSTA_10()
{
    // destroy what we had allocated
    delete pslOtherDomains ;
    pslOtherDomains = NULL ;

#ifdef WIN32
    ::MNetApiBufferFree( (BYTE **)&_pwkui1 );
#endif	// WIN32
}


/**********************************************************\

    NAME:       WKSTA_10::I_GetInfo

    SYNOPSIS:   Get information for the workstation object

    RETURN:     APIERR err - NERR_Success for succeed. otherwise,
			    failure.

    HISTORY:
	ChuckC	    07-Dec-1990     Created
	terryk	    17-Sep-1991	    use internal buffer object
	jonn	    13-Oct-1991     Removed SetBufferSize
        jonn        25-Jun-1992     Changed from NetWkstaUserEnum
                                            to   NetWkstaUserGetInfo

\**********************************************************/

APIERR WKSTA_10::I_GetInfo()
{
#ifdef WIN32

    PWKSTA_INFO_100	pwki100	 = NULL;

    APIERR err = ::MNetWkstaGetInfo( QueryName(), 100, (BYTE **)&pwki100 );
    SetBufferPtr( (BYTE *)pwki100 );

    if( err != NERR_Success )
    {
    	return err;
    }

    // BUGBUG should be an assert
    if ( (QueryName() != NULL) && (QueryName()[0] != TCH('\0')) )
    {
        // BUGBUG what???
        // UIDEBUG( SZ("WKSTA_10::I_GetInfo(): WARNING: non-NULL server") );
    }

    err = ::MNetWkstaUserGetInfo( NULL, 1, (BYTE **)&_pwkui1 );

    // This may have been called during setup when no one is logged on.
    if( err == ERROR_NO_SUCH_LOGON_SESSION )
    {
        _pwkui1 = NULL;
        err = NERR_Success;
    }

    if( err != NERR_Success )
    {
	return err;
    }

    err = SetName( pwki100->wki100_computername );

    if( err != NERR_Success )
    {
	return err;
    }

    //
    //	WIN32BUGBUG!
    //
    //	If NetWkstaUserEnum() is invoked against a down-level
    //	server, it returns NERR_Success but a NULL _pwkui1 pointer.
    //

    if( _pwkui1 == NULL )
    {
    	pszLogonUser   = NULL;
	pszLogonDomain = NULL;
    }
    else
    {
	pszLogonUser = (TCHAR *)_pwkui1->wkui1_username;
	if( ( pszLogonUser != NULL ) && ( *pszLogonUser == TCH('\0') ) )
	{
	    pszLogonUser = NULL;
	}

	pszLogonDomain = (TCHAR *)_pwkui1->wkui1_logon_domain;
	if( ( pszLogonDomain != NULL ) && ( *pszLogonDomain == TCH('\0') ) )
	{
	    pszLogonDomain = NULL;
	}
    }

    pszWkstaDomain = (TCHAR *)pwki100->wki100_langroup ;
    uMajorVer = (UINT)pwki100->wki100_ver_major ;
    uMinorVer = (UINT)pwki100->wki100_ver_minor ;

    if( pslOtherDomains != NULL )
    {
	delete pslOtherDomains; // delete old
	pslOtherDomains = NULL;
    }

    //
    //	WIN32BUGBUG!
    //
    //	oth_domains is not currently available via any
    //	non-priveledged API.
    //

    pslOtherDomains = new STRLIST( SZ(""), SZ(" ") );
    if( pslOtherDomains == NULL )
    {
	return ERROR_NOT_ENOUGH_MEMORY;
    }

    return NERR_Success;

#else	// !WIN32

    struct  wksta_info_10 * lpwki10Buffer ;

    /*
     * We get the info by doing a NetWkstaGetInfo. No need to
     * realloc, since MAX_WKSTA_INFO_SIZE guarantees correct size.
     */

    BYTE *pBuffer = NULL;
    APIERR err = ::MNetWkstaGetInfo (QueryName(), 10, &pBuffer );

    if ( ! err )
    {
	SetBufferPtr( pBuffer );
	lpwki10Buffer = (struct wksta_info_10 *) QueryBufferPtr() ;
        err = SetName( lpwki10Buffer->wki10_computername) ;
	if ( err != NERR_Success )
	{
	    return err;
	}
	pszLogonUser = (TCHAR *) lpwki10Buffer->wki10_username ;
	if (pszLogonUser && *pszLogonUser == TCH('\0'))
	    pszLogonUser = NULL ;
	pszLogonDomain = (TCHAR *) lpwki10Buffer->wki10_logon_domain ;
	if (pszLogonDomain && *pszLogonDomain == TCH('\0'))
	    pszLogonDomain = NULL ;
	pszWkstaDomain = (TCHAR *) lpwki10Buffer->wki10_langroup ;
	uMajorVer = lpwki10Buffer->wki10_ver_major ;
	uMinorVer = lpwki10Buffer->wki10_ver_minor ;
	if (pslOtherDomains)
	    delete pslOtherDomains ; // delete old
	if (!(pslOtherDomains =
	    new STRLIST(lpwki10Buffer->wki10_oth_domains,SZ(" "))))
	{
	    return ERROR_NOT_ENOUGH_MEMORY;
	}
    }

    return err;

#endif	// WIN32
}

/**********************************************************\

    NAME:       WKSTA_10::QueryMajorVer

    SYNOPSIS:   query major version of the workstation object

    RETURN:     UINT - 0 if the object is in invalid state
		return usMajorVer otherwise

    HISTORY:
	ChuckC	    07-Dec-1990     Created
	terryk	    18-Sep-1991	    Use CHECK_OK macro

\**********************************************************/

UINT WKSTA_10::QueryMajorVer() const
{
    CHECK_OK( 0 );
    return uMajorVer;
}

/**********************************************************\

    NAME:       WKSTA_10::QueryMinorVer

    SYNOPSIS:   query minor version of object

    RETURN:     UINT - 0 if the object is in invalid state
		return usMinorVer otherwise

    HISTORY:
	ChuckC	    07-Dec-1990     Created
	terryk	    18-Sep-1991	    Use CHECK_OK macro

\**********************************************************/

UINT WKSTA_10::QueryMinorVer() const
{
    CHECK_OK( 0 );
    return uMinorVer;
}


/**********************************************************\

    NAME:       WKSTA_10::QueryLogonUser

    SYNOPSIS:   query the current logon user on the workstation object

    RETURN:	PSZ - NULL if the object is invalid
		otherwise it will return the logon user name

    HISTORY:
	ChuckC	    07-Dec-1990     Created
	terryk	    18-Sep-1991	    Use CHECK_OK macro

\**********************************************************/

const TCHAR * WKSTA_10::QueryLogonUser() const
{
    CHECK_OK( NULL );
    return pszLogonUser;
}

/**********************************************************\

    NAME:       WKSTA_10::QueryWkstaDomain

    SYNOPSIS:   query the current workstation domain

    RETURN:     PSZ - NULL if the object is invalid
		otherwise it will return the wkstation domain name

    HISTORY:
   	ChuckC	    07-Dec-1990     Created
	terryk	    18-Sep-1991	    Use CHECK_OK macro

\**********************************************************/

const TCHAR * WKSTA_10::QueryWkstaDomain() const
{
    CHECK_OK( NULL );
    return pszWkstaDomain;
}

/**********************************************************\

    NAME:       WKSTA_10::QueryLogonDomain

    SYNOPSIS:   query the current logon user domain

    RETURN:     PSZ - NULL if the object is invalid
		otherwise it will return the logon domain name

    HISTORY:
   	ChuckC	    07-Dec-1990     Created
	terryk	    18-Sep-1991	    Use CHECK_OK macro

\**********************************************************/

const TCHAR * WKSTA_10::QueryLogonDomain() const
{
    CHECK_OK( NULL );
    return pszLogonDomain;
}

/**********************************************************\

    NAME:       WKSTA_10::QueryOtherDomains

    SYNOPSIS:   query other domains

    RETURN:     PSZ - NULL if the object is invalid
		otherwise it will return the logon domain name

    HISTORY:
   	ChuckC	    07-Dec-1990     Created
	terryk	    18-Sep-1991	    Use CHECK_OK macro

\**********************************************************/

STRLIST * WKSTA_10::QueryOtherDomains() const
{
    CHECK_OK( NULL );
    return pslOtherDomains;
}

/************************* workstation, Level 1 *************************/

/**********************************************************\

    NAME:       WKSTA_1::WKSTA_1

    SYNOPSIS:   workstation 1 constructor

    ENTRY:      const TCHAR * pszName - workstation name

    HISTORY:
	ChuckC	    07-Dec-1990     Created
	terryk	    18-Sep-1991	    use LOC_LM_OBJ as parent's parent class

\**********************************************************/

WKSTA_1::WKSTA_1(const TCHAR * pszName)
    : WKSTA_10(pszName),
    pszLogonServer( NULL ),
    pszLMRoot( NULL )
#ifdef WIN32
    , _pwkui1( NULL )
#endif	// WIN32
{
}

/**********************************************************\

    NAME:       WKSTA_1::~WKSTA_1

    SYNOPSIS:   destructor for thw workstation 1

    HISTORY:
	ChuckC	    07-Dec-1990     Created

\**********************************************************/

WKSTA_1::~WKSTA_1()
{
#ifdef WIN32
    ::MNetApiBufferFree( (BYTE **)&_pwkui1 );
#endif	// WIN32
}

/**********************************************************\

    NAME:       WKSTA_1::I_GetInfo

    SYNOPSIS:   Get information for the workstation

    RETURN:	APIERR err - NERR_Successs for succeed.
		Failure otherwise.

    HISTORY:
	ChuckC	    07-Dec-1990     Created
	jonn	    13-Oct-1991     Removed SetBufferSize
        jonn        25-Jun-1992     Changed from NetWkstaUserEnum
                                            to   NetWkstaUserGetInfo

\**********************************************************/

APIERR WKSTA_1::I_GetInfo()
{
#ifdef WIN32

    PWKSTA_INFO_101	pwki101	 = NULL;

    APIERR err = ::MNetWkstaGetInfo( QueryName(), 101, (BYTE **)&pwki101 );
    SetBufferPtr( (BYTE *)pwki101 );

    if( err != NERR_Success )
    {
    	return err;
    }

    // BUGBUG should be an assert
    if ( (QueryName() != NULL) && (QueryName()[0] != TCH('\0')) )
    {
        // BUGBUG what???
        // UIDEBUG( SZ("WKSTA_1::I_GetInfo(): WARNING: non-NULL server") );
    }

    err = ::MNetWkstaUserGetInfo( NULL, 1, (BYTE **)&_pwkui1 );

    if( err != NERR_Success )
    {
	return err;
    }

    err = SetName( pwki101->wki101_computername );

    if( err != NERR_Success )
    {
	return err;
    }

    pszLogonUser = (TCHAR *)_pwkui1->wkui1_username;
    if( ( pszLogonUser != NULL ) && ( *pszLogonUser == TCH('\0') ) )
    {
	pszLogonUser = NULL;
    }

    pszLogonDomain = (TCHAR *)_pwkui1->wkui1_logon_domain;
    if( ( pszLogonDomain != NULL ) && ( *pszLogonDomain == TCH('\0') ) )
    {
	pszLogonDomain = NULL;
    }

    pszWkstaDomain = (TCHAR *)pwki101->wki101_langroup ;
    pszLMRoot = (TCHAR *)pwki101->wki101_lanroot;
    pszLogonServer = (TCHAR *)_pwkui1->wkui1_logon_server;
    uMajorVer = (UINT)pwki101->wki101_ver_major ;
    uMinorVer = (UINT)pwki101->wki101_ver_minor ;

    if( pslOtherDomains != NULL )
    {
	delete pslOtherDomains; // delete old
	pslOtherDomains = NULL;
    }

    //
    //	WIN32BUGBUG!
    //
    //	oth_domains is not currently available via any
    //	non-priveledged API.
    //

    pslOtherDomains = new STRLIST( SZ(""), SZ(" ") );
    if( pslOtherDomains == NULL )
    {
	return ERROR_NOT_ENOUGH_MEMORY;
    }

    return NERR_Success;

#else	// !WIN32

    struct  wksta_info_1 * lpwki1Buffer ;
    BYTE *pBuffer = NULL;
    APIERR err = ::MNetWkstaGetInfo (QueryName(), 1, &pBuffer );
    /*
     * We get the info by doing a NetWkstaGetInfo. No need to
     * realloc, since MAX_WKSTA_INFO_SIZE guarantees correct size.
     */
    if ( ! err )
    {
        SetBufferPtr( pBuffer );

	lpwki1Buffer = (struct wksta_info_1 *) QueryBufferPtr() ;
	err =  SetName( lpwki1Buffer->wki1_computername) ;
	if ( err != NERR_Success )
	{
	    return err;
	}
	pszLogonUser = (TCHAR *) lpwki1Buffer->wki1_username ;
	if (pszLogonUser && *pszLogonUser == TCH('\0'))
	    pszLogonUser = NULL ;
	pszLogonDomain = (TCHAR *) lpwki1Buffer->wki1_logon_domain ;
	if (pszLogonDomain && *pszLogonDomain == TCH('\0'))
	    pszLogonDomain = NULL ;
	pszWkstaDomain = (TCHAR *) lpwki1Buffer->wki1_langroup ;
	pszLMRoot = (TCHAR *) lpwki1Buffer->wki1_root ;
	pszLogonServer = (TCHAR *) lpwki1Buffer->wki1_logon_server ;
	uMajorVer = lpwki1Buffer->wki1_ver_major ;
	uMinorVer = lpwki1Buffer->wki1_ver_minor ;
	if (pslOtherDomains)
	    delete pslOtherDomains ; // delete old
	if (!(pslOtherDomains =
		new STRLIST(lpwki1Buffer->wki1_oth_domains,SZ(" "))))
	{
	    return(ERROR_NOT_ENOUGH_MEMORY) ;
	}
    }

    return( err ) ;

#endif	// WIN32
}

/**********************************************************\

    NAME:       WKSTA_1::QueryLMRoot

    SYNOPSIS:   query the lan manager root for the workstation object

    RETURN:     PSZ - NULL if the object is invalid
		return pszLMRoot if the object is valid

    HISTORY:
	ChuckC	    07-Dec-1990     Created
	terryk	    18-Sep-1991	    Use CHECK_OK macro

\**********************************************************/

const TCHAR * WKSTA_1::QueryLMRoot() const
{
    CHECK_OK( NULL );
    return pszLMRoot;
}

/**********************************************************\

    NAME:       WKSTA_1::QueryLogonServer

    SYNOPSIS:   query logon server

    RETURN:	PSZ - NULL if the object is invalid
		otherwise, it will return the logon server name

    HISTORY:
   	ChuckC	    07-Dec-1990     Created
	terryk	    18-Sep-1991	    Use CHECK_OK macro

\**********************************************************/

const TCHAR * WKSTA_1::QueryLogonServer() const
{
    CHECK_OK( NULL );
    return pszLogonServer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\lmowksu.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    lmowksu.hxx
    Class definitions for the WKSTA_USER_1 class.

    The WKSTA_USER_1 class represents the local logged-on user.


    FILE HISTORY:
        KeithMo     14-Apr-1992 Created.

*/

#include "pchlmobj.hxx"  // Precompiled header


//
//  WKSTA_USER_1 methods.
//

/*******************************************************************

    NAME:       WKSTA_USER_1 :: WKSTA_USER_1

    SYNOPSIS:   WKSTA_USER_1 class constructor.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     14-Apr-1992 Created.

********************************************************************/
WKSTA_USER_1 :: WKSTA_USER_1( VOID )
  : NEW_LM_OBJ(),
    _nlsUserName(),
    _nlsLogonDomain(),
    _nlsOtherDomains(),
    _nlsLogonServer()
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;

    if( ( ( err = _nlsUserName.QueryError()     ) != NERR_Success ) ||
        ( ( err = _nlsLogonDomain.QueryError()  ) != NERR_Success ) ||
        ( ( err = _nlsOtherDomains.QueryError() ) != NERR_Success ) ||
        ( ( err = _nlsLogonServer.QueryError()  ) != NERR_Success ) )
    {
        ReportError( err );
        return;
    }

}   // WKSTA_USER_1 :: WKSTA_USER_1


/*******************************************************************

    NAME:       WKSTA_USER_1 :: ~WKSTA_USER_1

    SYNOPSIS:   WKSTA_USER_1 class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     14-Apr-1992 Created.

********************************************************************/
WKSTA_USER_1 :: ~WKSTA_USER_1( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // WKSTA_USER_1 :: ~WKSTA_USER_1


/*******************************************************************

    NAME:       WKSTA_USER_1 :: I_GetInfo

    SYNOPSIS:   Virtual callout used by NEW_LM_OBJ to invoke the
                NetXxxGetInfo API (info-level 1).

    EXIT:       The API has been invoked, and any "persistant" data
                has been cached.  For WKSTA_USER_1, this includes the
                user name, logon domain, other domains, and logon
                server.

    RETURNS:    APIERR                  - The result of the API.

    HISTORY:
        KeithMo     14-Apr-1992 Created.

********************************************************************/
APIERR WKSTA_USER_1 :: I_GetInfo( VOID )
{
    BYTE * pbBuffer = NULL;

    //
    //  Invoke the API.
    //
    //          BUGBUG!!!  WE NEED MNET SUPPORT FOR THIS API!!!
    //

    APIERR err = ::NetWkstaUserGetInfo( NULL,
                                        1,
                                        (LPBYTE *)&pbBuffer );

    //
    //  Tell NEW_LM_OBJ where the buffer is.
    //

    SetBufferPtr( pbBuffer );

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  Extract the relevant structure fields.
    //

    WKSTA_USER_INFO_1 * pwkui1 = (WKSTA_USER_INFO_1 *)pbBuffer;

    err = SetUserName( pwkui1->wkui1_username );

    if( err == NERR_Success )
    {
        err = SetLogonDomain( pwkui1->wkui1_logon_domain );
    }

    if( err == NERR_Success )
    {
        err = SetOtherDomains( pwkui1->wkui1_oth_domains );
    }

    if( err == NERR_Success )
    {
        err = SetLogonServer( pwkui1->wkui1_logon_server );
    }

    return err;

}   // WKSTA_USER_1 :: I_GetInfo


/*******************************************************************

    NAME:       WKSTA_USER_1 :: I_WriteInfo

    SYNOPSIS:   Virtual callout used by NEW_LM_OBJ to invoke the
                NetXxxSetInfo API (info-level 1).

    EXIT:       If successful, the local workstation has been updated.

    RETURNS:    APIERR                  - The result of the API.

    HISTORY:
        KeithMo     14-Apr-1992 Created.

********************************************************************/
APIERR WKSTA_USER_1 :: I_WriteInfo( VOID )
{
    //
    //  Update the WKSTA_USER_INFO_1 structure.
    //

    APIERR err = W_Write();

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  Invoke the API to do the actual workstation update.
    //
    //          BUGBUG!!!  WE NEED MNET SUPPORT FOR THIS API!!!
    //

#if 0   // BUGBUG! not in NETAPI.LIB???

    return ::NetWkstaUserSetInfo( NULL,
                                  1,
                                  (LPBYTE)QueryBufferPtr(),
                                  NULL );

#else

    return ERROR_NOT_SUPPORTED;

#endif

}   // WKSTA_USER_1 :: I_WriteInfo


/*******************************************************************

    NAME:       WKSTA_USER_1 :: W_Write

    SYNOPSIS:   Helper function for WriteNew and WriteInfo -- loads
                current values into the API buffer.

    EXIT:       The API buffer has been filled.

    RETURNS:    APIERR                  - The result of the API.

    HISTORY:
        KeithMo     14-Apr-1992 Created.

********************************************************************/
APIERR WKSTA_USER_1 :: W_Write( VOID )
{
    WKSTA_USER_INFO_1 * pwkui1 = (WKSTA_USER_INFO_1 *)QueryBufferPtr();
    ASSERT( pwkui1 != NULL );

    pwkui1->wkui1_username     = (LPTSTR)QueryUserName();
    pwkui1->wkui1_logon_domain = (LPTSTR)QueryLogonDomain();
    pwkui1->wkui1_oth_domains  = (LPTSTR)QueryOtherDomains();
    pwkui1->wkui1_logon_server = (LPTSTR)QueryLogonServer();

    return NERR_Success;

}   // WKSTA_USER_1 :: W_Write
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\lmsvc.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*  HISTORY:
 *      ChuckC      17-Aug-1991     Created
 *      terryk      19-Sep-1991     Change comment header
 *      ChuckC      23-Sep-1991     Code review changes.
 *                                  Attended by JimH, KeithMo, EricCh, O-SimoP
 *      KeithMo     30-Sep-1991     Moved polling logic from UI_SERVICE
 *                                  to LM_SERVICE.
 *      terryk      07-Oct-1991     types change for NT
 *      KeithMo     10/8/91         Now includes LMOBJP.HXX.
 *      terryk      10/17/91        WIN 32 conversion
 *      terryk      10/21/91        cast buffer to TCHAR * for
 *                                  MNetApiBufferFree
 *
 */

#include "pchlmobj.hxx"  // Precompiled header


#ifdef UNICODE
#define ADVANCE_CHAR(p)     p++
#define COPY_CHAR(p,q)     *p = *q
#else
#error BARF - the macros below need to be tested in non Unicode case
#define ADVANCE_CHAR(p)     if(isleadbyte(*p)) p+=2; else p++
#define COPY_CHAR(p,q)      if(isleadbyte(*p)) {*p = *q; *(p+1) = *(q+1);} \
                            else *p = *q
#endif

//
// forward declare
//
DWORD MakeNullNull(const TCHAR *pszOld, TCHAR **ppszNew)  ;
VOID  SkipWhiteSpace(TCHAR **ppsz) ;
BOOL  IsWhiteSpace(TCHAR c) ;

//
//  This is the maximum allowed polling time we'll
//  wait for a service that does not support checkpoints
//  and wait hints.
//

#define NOHINT_WAIT_TIME        ( 10 * 1000 )   // milliseconds


/*******************************************************************

    NAME:       LM_SERVICE::LM_SERVICE

    SYNOPSIS:   constructor just records service & server names,
                with validation.

    HISTORY:
        ChuckC      21-Aug-1991     Created
        KeithMo     30-Sep-1991     Added polling logic from UI_SERVICE.

********************************************************************/

#define LM_SVC_BUFFER_SIZE      512     // reasonable initial estimate

LM_SERVICE::LM_SERVICE(const TCHAR *pszServer, const TCHAR *pszServiceName)
  : BASE(),
    CT_NLS_STR( _nlsService ),
    CT_NLS_STR( _nlsServer ),
    _pBuffer( NULL ),
    _ulServiceStatus( 0 ),
    _ulServiceCode( 0 ),
    _svcStat( LM_SVC_STATUS_UNKNOWN ),
    _uiMaxTries( DEFAULT_MAX_TRIES ),
    _uiCurrentTry( 0 ),
    _uiSleepTime( DEFAULT_SLEEP_TIME ),
    _ulOldCheckPoint( 0L ),
    _lmsvcDesiredStat( LM_SVC_STATUS_UNKNOWN ),
    _lmsvcPollStat( LM_SVC_STATUS_UNKNOWN ),
    _errExit( NERR_Success ),
    _errSpecific( NERR_Success ),
    _fIsWellKnownService( FALSE )
{
    UIASSERT(pszServiceName != NULL) ;

    if (QueryError() != NERR_Success)
        return ;

    APIERR err = SetName(pszServiceName) ;
    if (err == NERR_Success)
        err = SetServerName(pszServer) ;

    if (err != NERR_Success)
        ReportError(err) ;

    _fIsWellKnownService = W_IsWellKnownService();
}

/*******************************************************************

    NAME:       LM_SERVICE::~LM_SERVICE

    SYNOPSIS:   destructor and free up the memory

    HISTORY:
                terryk  16-Oct-91       Created

********************************************************************/

LM_SERVICE::~LM_SERVICE()
{
    ::MNetApiBufferFree( &_pBuffer );
}


/*******************************************************************

    NAME:       LM_SERVICE::Start

    SYNOPSIS:   Starts a service.

    EXIT:       Service either started or starting

    RETURNS:    API error from Service Control Operation

    NOTES:      This operation returns immediately, the service
                may not be in the desired state yet.

    HISTORY:
        ChuckC      21-Aug-1991     Created
        KeithMo     30-Sep-1991     Added polling logic from UI_SERVICE.

********************************************************************/

APIERR LM_SERVICE::Start( const TCHAR * pszArgs,
                          UINT         uiSleepTime,
                          UINT         uiMaxTries )
{
    _uiMaxTries   = uiMaxTries;
    _uiCurrentTry = 0;
    _uiSleepTime  = uiSleepTime;
    _ulOldCheckPoint = 0L;

    _lmsvcDesiredStat = LM_SVC_STARTED;
    _lmsvcPollStat    = LM_SVC_STARTING;

    _errExit = _errSpecific = NERR_Success;

    return( W_ServiceStart(pszArgs) ) ;
}

/*******************************************************************

    NAME:       LM_SERVICE::Pause

    SYNOPSIS:   Pause a service

    EXIT:       Service paused or pausing.

    RETURNS:    API error from Service Control Operation

    NOTES:      This operation returns immediately, the service
                may not be in the desired state yet.

    HISTORY:
        ChuckC      21-Aug-1991     Created
        KeithMo     30-Sep-1991     Added polling logic from UI_SERVICE.

********************************************************************/

APIERR LM_SERVICE::Pause( UINT uiSleepTime, UINT uiMaxTries )
{
    _uiMaxTries   = uiMaxTries;
    _uiCurrentTry = 0;
    _uiSleepTime  = uiSleepTime;
    _ulOldCheckPoint = 0L;

    _lmsvcDesiredStat = LM_SVC_PAUSED;
    _lmsvcPollStat    = LM_SVC_PAUSING;

    _errExit = _errSpecific = NERR_Success;

    return( W_ServiceControl(SERVICE_CTRL_PAUSE) ) ;
}

/*******************************************************************

    NAME:       LM_SERVICE::Continue

    SYNOPSIS:   Continue a service.

    EXIT:       Service continued or continuing.

    RETURNS:    API error from Service Control Operation

    NOTES:      This operation returns immediately, the service
                may not be in the desired state yet.

    HISTORY:
        ChuckC      21-Aug-1991     Created
        KeithMo     30-Sep-1991     Added polling logic from UI_SERVICE.

********************************************************************/

APIERR LM_SERVICE::Continue( UINT uiSleepTime, UINT uiMaxTries )
{
    _uiMaxTries   = uiMaxTries;
    _uiCurrentTry = 0;
    _uiSleepTime  = uiSleepTime;
    _ulOldCheckPoint = 0L;

    _lmsvcDesiredStat = LM_SVC_STARTED;
    _lmsvcPollStat    = LM_SVC_CONTINUING;

    _errExit = _errSpecific = NERR_Success;

    return( W_ServiceControl(SERVICE_CTRL_CONTINUE) ) ;
}

/*******************************************************************

    NAME:       LM_SERVICE::Stop

    SYNOPSIS:   Stop a service.

    EXIT:       Service stopped or stopping.

    RETURNS:    API error from Service Control Operation

    NOTES:      This operation returns immediately, the service
                may not be in the desired state yet.

    HISTORY:
        ChuckC      21-Aug-1991     Created
        KeithMo     30-Sep-1991     Added polling logic from UI_SERVICE.

********************************************************************/

APIERR LM_SERVICE::Stop( UINT uiSleepTime, UINT uiMaxTries )
{
    _uiMaxTries   = uiMaxTries;
    _uiCurrentTry = 0;
    _uiSleepTime  = uiSleepTime;
    _ulOldCheckPoint = 0L;

    _lmsvcDesiredStat = LM_SVC_STOPPED;
    _lmsvcPollStat    = LM_SVC_STOPPING;

    _errExit = _errSpecific = NERR_Success;

    return( W_ServiceControl(SERVICE_CTRL_UNINSTALL) ) ;
}


/*******************************************************************

    NAME:       LM_SERVICE::IsStarted

    SYNOPSIS:   Check whether the service is started or not

    RETURNS:    TRUE if service is started.

    HISTORY:
        ChuckC      21-Aug-1991     Created

********************************************************************/

BOOL LM_SERVICE::IsStarted(APIERR *pErr)
{
    return (QueryStatus(pErr) == LM_SVC_STARTED) ;
}

/*******************************************************************

    NAME:       LM_SERVICE::IsPaused

    SYNOPSIS:   Check whether the service is paused or not

    RETURNS:    TRUE if service is paused

    HISTORY:
        ChuckC      21-Aug-1991     Created

********************************************************************/

BOOL LM_SERVICE::IsPaused(APIERR *pErr)
{
    return (QueryStatus(pErr) == LM_SVC_PAUSED) ;
}

/*******************************************************************

    NAME:       LM_SERVICE::IsStopped

    SYNOPSIS:   Check whether the service is stopped or not

    RETURNS:    TRUE if service is stopped

    HISTORY:
        ChuckC      21-Aug-1991     Created

********************************************************************/

BOOL LM_SERVICE::IsStopped(APIERR *pErr)
{
    return (QueryStatus(pErr) == LM_SVC_STOPPED) ;
}


/*******************************************************************

    NAME:       LM_SERVICE::IsStarting

    SYNOPSIS:   Check whether the service is starting or not

    RETURNS:    TRUE if service is starting

    HISTORY:
        ChuckC      21-Aug-1991     Created

********************************************************************/

BOOL LM_SERVICE::IsStarting(APIERR *pErr)
{
    return (QueryStatus(pErr) == LM_SVC_STARTING) ;
}

/*******************************************************************

    NAME:       LM_SERVICE::IsPausing

    SYNOPSIS:   Check whether the service is pausing or not

    RETURNS:    TRUE if service is pausing

    HISTORY:
        ChuckC      21-Aug-1991     Created

********************************************************************/

BOOL LM_SERVICE::IsPausing(APIERR *pErr)
{
    return (QueryStatus(pErr) == LM_SVC_PAUSING) ;
}

/*******************************************************************

    NAME:       LM_SERVICE::IsStopping

    SYNOPSIS:   Check whether the service is stopping or not

    RETURNS:    TRUE if service is stopping

    HISTORY:
        ChuckC      21-Aug-1991     Created

********************************************************************/

BOOL LM_SERVICE::IsStopping(APIERR *pErr)
{
    return (QueryStatus(pErr) == LM_SVC_STOPPING) ;
}

/*******************************************************************

    NAME:       LM_SERVICE::IsContinuing

    SYNOPSIS:   Check whether the service is continuing or not

    RETURNS:    TRUE if service is continuing

    HISTORY:
        ChuckC      21-Aug-1991     Created

********************************************************************/

BOOL LM_SERVICE::IsContinuing(APIERR *pErr)
{
    return (QueryStatus(pErr) == LM_SVC_CONTINUING) ;
}


/*******************************************************************

    NAME:       LM_SERVICE::QueryStatus

    SYNOPSIS:   Query status of service. Error returned in pErr.

    RETURNS:    LM_SERVICE_STATUS indicating current status of service.

    HISTORY:
        ChuckC      21-Aug-1991     Created

********************************************************************/

LM_SERVICE_STATUS LM_SERVICE::QueryStatus(APIERR *pErr)
{

    LM_SERVICE_STATUS svcstat ;
    APIERR err = W_QueryStatus(&svcstat) ;
    if (pErr != NULL)
        *pErr = err ;

    return(svcstat) ;
}

/*******************************************************************

    NAME:       LM_SERVICE::QueryFullStatus

    SYNOPSIS:   Query full status of service, including extended
                info like hints, check points, etc.

    RETURNS:    API return code from Service interrogate.

    HISTORY:
        ChuckC      21-Aug-1991     Created

********************************************************************/

APIERR LM_SERVICE::QueryFullStatus(LM_SERVICE_STATUS *pSvcStat,
                                   LM_SERVICE_OTHER_STATUS *pSvcOtherStat)
{
    return W_QueryStatus(pSvcStat, pSvcOtherStat);
}

/*******************************************************************

    NAME:       LM_SERVICE::SetName

    SYNOPSIS:   Validates the name as valid service name, then record it.

    RETURNS:    NERR_Success if ok, ERROR_INVALID_PARAMETER other wise.

    HISTORY:
        ChuckC      21-Aug-1991     Created

********************************************************************/

APIERR LM_SERVICE::SetName(const TCHAR *pszServiceName)
{
    APIERR err = ::I_MNetNameValidate(NULL,pszServiceName,NAMETYPE_SERVICE,0) ;
    if (err != NERR_Success)
        return(ERROR_INVALID_PARAMETER) ;

    _nlsService = pszServiceName ;
    UIASSERT(_nlsService.QueryError() == NERR_Success) ; // since CLASS_NLS_STR
    return(NERR_Success) ;
}

/*******************************************************************

    NAME:       LM_SERVICE::SetServerName

    SYNOPSIS:   Validates the name as valid server name, then record it.

    RETURNS:    NERR_Success if ok, ERROR_INVALID_PARAMETER other wise.

    HISTORY:
        ChuckC      21-Aug-1991     Created
        KeithMo     17-Jul-1992     Rewrote to take a server name *with*
                                    the leading backslashes.

********************************************************************/

APIERR LM_SERVICE::SetServerName(const TCHAR *pszServerName)
{
    //
    //  NULL/empty name always allowed.
    //

    if( ( pszServerName == NULL ) || ( *pszServerName == TCH('\0') ) )
    {
        _nlsServer = SZ("");
        return NERR_Success;
    }

    //
    //  Save away the server name.
    //

    _nlsServer = pszServerName;
    UIASSERT( _nlsServer.QueryError() == NERR_Success ); // CLASS_NLS_STR!

    //
    //  Validate the server name.
    //

    ISTR istr( _nlsServer );
    istr += 2;

#ifdef DEBUG
    {
        ISTR istrDbg( _nlsServer );
        UIASSERT( _nlsServer.QueryChar( istrDbg ) == L'\\' );
        ++istrDbg ;
        UIASSERT( _nlsServer.QueryChar( istrDbg ) == L'\\' );
    }
#endif

    APIERR err = ::I_MNetNameValidate( NULL,
                                       _nlsServer[istr],
                                       NAMETYPE_COMPUTER,
                                       0 );

    if( err != NERR_Success )
    {
        err = ERROR_INVALID_PARAMETER;
    }

    return err;

}   // LM_SERVICE::SetServerName

/*******************************************************************

    NAME:       LM_SERVICE::W_ServiceControl

    SYNOPSIS:   worker function that calls out to NetApi service control.

    ENTRY:      opcode defines the operation, fbArgs defines service
                specific information if any.

    RETURNS:    API return code.

    HISTORY:    ChuckC      21-Aug-1991     Created

********************************************************************/

APIERR LM_SERVICE::W_ServiceControl( UINT opcode, UINT fbArg)
{
    ::MNetApiBufferFree( &_pBuffer );

    APIERR err = ::MNetServiceControl( QueryServerName(),
                                       QueryName(),
                                       opcode,
                                       fbArg,
                                       &_pBuffer );

    return err;
}

/*******************************************************************

    NAME:       LM_SERVICE::W_ServiceStart

    SYNOPSIS:   worker function that actually calls ther service start
                APIs.

    RETURNS:    API return code.

    HISTORY:
        ChuckC      21-Aug-1991     Created

********************************************************************/

APIERR LM_SERVICE::W_ServiceStart( const TCHAR * pszArgs )
{

    TCHAR *pszNewArgs ;
    APIERR err ;

    //
    // convert pszArgs we get from UI, which is in the 'standard'
    // cmd.exe form (white space separated) to a NULL-NULL string
    // for the NetServiceInstall API.
    //
    err = MakeNullNull(pszArgs, &pszNewArgs) ;
    if( err != NERR_Success )
        return err ;

    ::MNetApiBufferFree( &_pBuffer );
    err = ::MNetServiceInstall( QueryServerName(),
                                QueryName(),
                                pszNewArgs,
                                &_pBuffer );
    delete pszNewArgs ;

    if( err == NERR_Success )
    {
        LM_SERVICE_STATUS SvcStat;

        W_InterpretStatus( (struct service_info_2 *)_pBuffer,
                           &SvcStat,
                           NULL );
    }

    return err;
}

/*******************************************************************

    NAME:       LM_SERVICE::W_QueryStatus

    SYNOPSIS:   worker method that calls NETAPI for service status info.

    RETURNS:    API return code

    HISTORY:
        ChuckC      21-Aug-1991     Created

********************************************************************/

APIERR LM_SERVICE::W_QueryStatus(LM_SERVICE_STATUS *pSvcStat,
                                 LM_SERVICE_OTHER_STATUS *pSvcOtherStat)
{
    ::MNetApiBufferFree( &_pBuffer );

    /*
     * call out to NET to to get info
     */
    APIERR err = ::MNetServiceGetInfo( QueryServerName(),
                                       QueryName(),
                                       2,
                                       &_pBuffer );

    if( err == NERR_ServiceNotInstalled )
    {
        //
        //  Map to success.
        //

        *pSvcStat = LM_SVC_STOPPED;
        err = NERR_Success;
    }
    else
    if( err == NERR_Success )
    {
        W_InterpretStatus( (struct service_info_2 *)_pBuffer,
                           pSvcStat,
                           pSvcOtherStat );
    }

    return err;
}


/*******************************************************************

    NAME:       LM_SERVICE::W_InterpretStatus

    SYNOPSIS:   Worker method that interprets service status info.

    HISTORY:
        KeithMo     18-Nov-1992     Created from ChuckC's W_QueryStatus.

********************************************************************/
VOID LM_SERVICE :: W_InterpretStatus( const service_info_2    * psvi2,
                                      LM_SERVICE_STATUS       * pSvcStat,
                                      LM_SERVICE_OTHER_STATUS * pSvcOtherStat )
{
    UIASSERT( psvi2 != NULL );
    UIASSERT( pSvcStat != NULL );

    *pSvcStat = LM_SVC_STATUS_UNKNOWN ;

    if (pSvcOtherStat)
    {
        pSvcOtherStat->fUnInstallable =
            pSvcOtherStat->fPauseable =
            pSvcOtherStat->fRdrDiskPaused =
            pSvcOtherStat->fRdrPrintPaused =
            pSvcOtherStat->fRdrCommPaused =
            pSvcOtherStat->fHint = FALSE ;
        pSvcOtherStat->ulSecCode =
            pSvcOtherStat->ulCheckPointNum =
            pSvcOtherStat->ulWaitTime = 0 ;
        pSvcOtherStat->errExit =
            pSvcOtherStat->errSpecific = NERR_Success;
    }

    _ulServiceStatus = psvi2->svci2_status ;
    _ulServiceCode   = psvi2->svci2_code ;

    ULONG ulInstallState = _ulServiceStatus & (ULONG)SERVICE_INSTALL_STATE ;

    switch (ulInstallState)
    {
        case SERVICE_INSTALLED:
        {
            ULONG ulPauseState = _ulServiceStatus &
                                 (ULONG)SERVICE_PAUSE_STATE ;
            switch(ulPauseState)
            {
                case LM20_SERVICE_ACTIVE:
                    _svcStat = LM_SVC_STARTED ;
                    if( HIWORD(_ulServiceCode) == SERVICE_UIC_SYSTEM )
                        _errExit = (APIERR)LOWORD(_ulServiceCode);
                    _errSpecific = (APIERR)psvi2->svci2_specific_error;
                    break ;

                case LM20_SERVICE_CONTINUE_PENDING:
                    _svcStat = LM_SVC_CONTINUING ;
                    break ;

                case LM20_SERVICE_PAUSE_PENDING:
                    _svcStat = LM_SVC_PAUSING ;
                    break ;

                case LM20_SERVICE_PAUSED:
                    _svcStat = LM_SVC_PAUSED ;
                    break ;

                default:
                    UIASSERT(0) ;
                    break ;
            }
            break ;
        }

        case SERVICE_UNINSTALLED:
            _svcStat = LM_SVC_STOPPED ;
            if( HIWORD(_ulServiceCode) == SERVICE_UIC_SYSTEM )
                _errExit = (APIERR)LOWORD(_ulServiceCode);
            _errSpecific = (APIERR)psvi2->svci2_specific_error;
            break ;

        case SERVICE_INSTALL_PENDING:
            _svcStat = LM_SVC_STARTING ;
            break ;

        case SERVICE_UNINSTALL_PENDING:
            _svcStat = LM_SVC_STOPPING ;
            break ;

        default:
            UIASSERT(0) ;
            break ;
    }

    /*
     * calculate the other status info
     */
    W_ComputeOtherStatus(pSvcOtherStat) ;

    /*
     * set the stat, and we're outta here
     */
    *pSvcStat = _svcStat ;
}


/*******************************************************************

    NAME:       LM_SERVICE::W_ComputeOtherStatus

    SYNOPSIS:   helper function for W_QueryStatus

    ENTRY:      pSvcOtherStat initialized to all FALSE & zeros

    EXIT:       appropriate fields of pSvcOtherStat now set

    HISTORY:
        ChuckC      21-Aug-1991     Created

********************************************************************/

VOID LM_SERVICE::W_ComputeOtherStatus(LM_SERVICE_OTHER_STATUS *pSvcOtherStat)
{
    if (pSvcOtherStat == NULL)
        return ;

    pSvcOtherStat->fUnInstallable =
        (_ulServiceStatus & (ULONG)SERVICE_UNINSTALLABLE) != 0 ;

    pSvcOtherStat->fPauseable =
        (_ulServiceStatus & (ULONG)SERVICE_PAUSABLE) != 0 ;

    /*
     * following info only given with stopped services.
     * Sorry, no manifest for the shift. RTFM.
     */
    if (_ulServiceStatus & (ULONG)SERVICE_UNINSTALLED)
        pSvcOtherStat->ulSecCode = (_ulServiceCode >> 16) ;
    else
        pSvcOtherStat->ulSecCode = SERVICE_UIC_NORMAL ;

    /*
     * following info only given with starting/stopping services
     */
    if (_svcStat == LM_SVC_STARTING || _svcStat == LM_SVC_STOPPING)
    {
        pSvcOtherStat->fHint =
            ((_ulServiceCode & (ULONG)SERVICE_CCP_QUERY_HINT) != 0) ;
        if (pSvcOtherStat->fHint)
        {
            /*
             * below only valid if hint is given. Time is in 1/10
             * seconds, hence the 100 * to make it millisecs.
             */
            pSvcOtherStat->ulWaitTime =
                100L * (ULONG)SERVICE_NT_WAIT_GET(_ulServiceCode);

            pSvcOtherStat->ulCheckPointNum =
                (_ulServiceCode & SERVICE_IP_CHKPT_NUM) ;
        }
    }

    pSvcOtherStat->errExit     = _errExit;
    pSvcOtherStat->errSpecific = _errSpecific;

}


/*******************************************************************

    NAME:       LM_SERVICE :: Poll

    SYNOPSIS:   Polls the service after a Start(), Stop(), Pause(),
                or Continue() operation to see if the operation has
                completed.

    ENTRY:      pfDone                  - Will receive TRUE if the
                                          operation has completed (either
                                          successfully or with failure).
                                          Will receive FALSE otherwise.

    RETURNS:    APIERR                  - Any errors encountered.

    NOTES:

    HISTORY:
        KeithMo     30-Sep-1991     Created.

********************************************************************/
APIERR LM_SERVICE :: Poll( BOOL * pfDone )
{
    UIASSERT( pfDone != NULL );

    LM_SERVICE_STATUS       lmsvcStat;
    LM_SERVICE_OTHER_STATUS lmsvcOtherStat;

    //
    //  Assume we'll finish the operation.  In this context, "finish"
    //  means either the operation (i.e. Pause) is complete OR a
    //  fatal error occurred.
    //

    *pfDone = TRUE;

    //
    //  Retrieve the service status.
    //

    APIERR err = QueryFullStatus( &lmsvcStat, &lmsvcOtherStat );

    if( err != NERR_Success )
    {
        //
        //  Error retrieving service status.  We're done.
        //

        return err;
    }

    if( lmsvcStat == _lmsvcDesiredStat )
    {
        //
        //  The service has reached its desired state.  We're done.
        //

        return NERR_Success;
    }

    if( lmsvcStat != _lmsvcPollStat )
    {
        //
        //  The service is returning a bogus status.  Bail out.
        //

        err = QueryExitCode();

        if( err == NERR_Success )
        {
            err = NERR_InternalError;
        }

        return err;
    }

    //
    //  At this point, we can assume the operation is not yet complete.
    //

    *pfDone = FALSE;

    if( !lmsvcOtherStat.fHint )
    {
        //
        //  This service does not support checkpoints & wait hints.
        //  We'll cobble up some fake ones.
        //

        UINT uiTmp = ( NOHINT_WAIT_TIME / _uiSleepTime ) + 1;

        if( _uiMaxTries < uiTmp )
        {
            _uiMaxTries = uiTmp;
        }
    }
    else
    {
        //
        //  We have checkpoints & wait hints.  Use 'em.
        //

        if( ( _uiMaxTries * _uiSleepTime ) < lmsvcOtherStat.ulWaitTime )
        {
            //
            //  Time to recalculate the max tries counter.
            //

            _uiMaxTries = (UINT)( lmsvcOtherStat.ulWaitTime /
                                      _uiSleepTime ) + 1;

            _uiMaxTries *= 4;   // Be generous, some machines are slow...

            _uiCurrentTry = 0;
        }

        if( _ulOldCheckPoint != lmsvcOtherStat.ulCheckPointNum )
        {
            //
            //  Check point updated, reset counter.
            //

            _uiCurrentTry    = 0;
            _ulOldCheckPoint = lmsvcOtherStat.ulCheckPointNum;
        }
    }

    if( ++_uiCurrentTry > _uiMaxTries )
    {
        //
        //  Service timed out.
        //

        *pfDone = TRUE;
        return NERR_ServiceCtlTimeout;
    }

    //
    //  If we made it this far, then the operation is
    //  proceeding as expected.  Return success so that
    //  the client will sleep and try again later.
    //

    return NERR_Success;

}   // LM_SERVICE :: Poll


/*******************************************************************

    NAME:       LM_SERVICE :: QueryExitCode

    SYNOPSIS:   Returns the exit code for this service.  If this is
                a well known service and the exit code is
                ERROR_SERVICE_SPECIFIC_ERROR, then return the service
                specific error instead.

    RETURNS:    APIERR                  - The exit code.

    HISTORY:
        KeithMo     19-Nov-1991     Created.

********************************************************************/
APIERR LM_SERVICE :: QueryExitCode( VOID ) const
{
    APIERR err = _errExit;

    if( _fIsWellKnownService && ( err == ERROR_SERVICE_SPECIFIC_ERROR ) )
    {
        err = _errSpecific;
    }

    return err;

}   // LM_SERVICE :: QueryExitCode


/*******************************************************************

    NAME:       LM_SERVICE :: W_IsWellKnownService

    SYNOPSIS:   Determine if this is a "well known" service that
                returns NERR_* codes as service specific errors.

    RETURNS:    BOOL                    - TRUE if this is a well-known
                                          service, FALSE otherwise.

    HISTORY:
        KeithMo     18-Nov-1992     Created.

********************************************************************/
BOOL LM_SERVICE :: W_IsWellKnownService( VOID ) const
{
    const TCHAR * apszServices[] = { (TCHAR *)SERVICE_WORKSTATION,
                                     (TCHAR *)SERVICE_SERVER,
                                     (TCHAR *)SERVICE_BROWSER,
                                     (TCHAR *)SERVICE_MESSENGER,
                                     (TCHAR *)SERVICE_NETRUN,
                                     (TCHAR *)SERVICE_ALERTER,
                                     (TCHAR *)SERVICE_NETLOGON,
                                     (TCHAR *)SERVICE_REPL,
                                     (TCHAR *)SERVICE_UPS,
                                     (TCHAR *)SERVICE_TCPIP,
                                     (TCHAR *)SERVICE_NBT,
                                     (TCHAR *)SERVICE_TELNET,

//                                   (TCHAR *)SERVICE_SPOOLER,
//                                   (TCHAR *)SERVICE_NETPOPUP,
//                                   (TCHAR *)SERVICE_SQLSERVER,
//                                   (TCHAR *)SERVICE_RIPL,
//                                   (TCHAR *)SERVICE_TIMESOURCE,
//                                   (TCHAR *)SERVICE_AFP,
//                                   (TCHAR *)SERVICE_XACTSRV,
//                                   (TCHAR *)SERVICE_SCHEDULE,

                                     NULL
                                   };

    BOOL fResult = FALSE;

    const TCHAR * pszKeyName = QueryName();

    for( const TCHAR ** ppsz = apszServices ; *ppsz ; ppsz++ )
    {
        if( ::stricmpf( pszKeyName, *ppsz ) == 0 )
        {
            fResult = TRUE;
            break;
        }
    }

    return fResult;

}   // LM_SERVICE :: W_IsWellKnownService

/*******************************************************************

    NAME:       :: MakeNullNull

    SYNOPSIS:   Creates a NULL-NULL string from a normal PSZ.
                Space & tab are the accepted separators, quotes
                may be used to enclose a separator, and \ may be
                used to escape the quote.

                hello "bar \"&\" foo" world

                will generate:
                    hello\0bar "&" foo\0world\0\0

                the new string is alloced by this functions and should
                be deleted by caller with 'delete'.


    ENTRY:      pszOld -  input string to be parsed
                ppszNew - used to return new string that is allocated

    RETURNS:    APIERR                  - The exit code.

    HISTORY:
        ChuckC     18-Mar-1993     Created.

********************************************************************/
DWORD MakeNullNull(const TCHAR *pszOld, TCHAR **ppszNew)
{
    BOOL fInQuote = FALSE ;
    TCHAR *pszNew, *pszNewTmp, *pszOldTmp ;

    //
    // check against null return buffer
    //
    if (ppszNew == NULL)
        return ERROR_INVALID_PARAMETER ;

    //
    // the trivial case
    //
    if (pszOld == NULL || *pszOld == 0)
    {
        *ppszNew = NULL ;
        return NERR_Success ;
    }

    //
    // allocate memory. the new string is never bigger than the old by
    // more than 1 char (ie. the last null).
    //
    pszNew = (TCHAR *) new CHAR[(strlenf(pszOld)+2) * sizeof(TCHAR)] ;
    if (pszNew == NULL)
        return ERROR_NOT_ENOUGH_MEMORY ;
    *ppszNew = pszNew ;

    //
    // setup pointers, skip initial white space
    //
    pszOldTmp = (TCHAR *) pszOld ;
    pszNewTmp = pszNew ;
    SkipWhiteSpace(&pszOldTmp) ;

    while (*pszOldTmp)
    {
        if (IsWhiteSpace(*pszOldTmp) && !fInQuote)
        {
            //
            // found end of one token, null terminate it
            //
            *pszNewTmp++ = 0 ;
            SkipWhiteSpace(&pszOldTmp) ;

            //
            // if this was last, back step one since we
            // will add 'null null' as result of exiting loop.
            // note: backing up from \0 has no DBCS problems.
            //
            if (! *pszOldTmp)
                pszNewTmp-- ;
        }
        else if (*pszOldTmp == '"')
        {
            //
            // found a quote. just eat it.
            //
            fInQuote = !fInQuote ;
            ADVANCE_CHAR(pszOldTmp) ;
        }
        else if (*pszOldTmp == '\\')
        {
            //
            // found a back slash. skip it & take whatever is next
            // this advance is always safe, since it is not a leadbyte.
            //
            pszOldTmp++ ;
            if (*pszOldTmp)
            {
                COPY_CHAR(pszNewTmp, pszOldTmp) ;
                ADVANCE_CHAR(pszNewTmp) ;
                ADVANCE_CHAR(pszOldTmp) ;
            }
        }
        else
        {
            COPY_CHAR(pszNewTmp, pszOldTmp) ;
            ADVANCE_CHAR(pszOldTmp) ;
            ADVANCE_CHAR(pszNewTmp) ;
        }
    }

    //
    // do the NULL NULL termination
    //
    *pszNewTmp++ = 0 ;
    *pszNewTmp++ = 0 ;
    return NERR_Success ;
}


/*******************************************************************

    NAME:       :: SkipWhiteSpace

    SYNOPSIS:   takes a pointer to a PSZ and advances
                the pointer past any white spaces

    ENTRY:

    RETURNS:    no return

    HISTORY:
        ChuckC     18-Mar-1993     Created.

********************************************************************/
VOID  SkipWhiteSpace(TCHAR **ppsz)
{
    TCHAR *psz = *ppsz;

    if (!psz)
        return ;

    while (IsWhiteSpace(*psz))
        ADVANCE_CHAR(psz) ;

    *ppsz = psz ;
}

/*******************************************************************

    NAME:       :: IsWhiteSpace

    SYNOPSIS:   return TRUE if space or tab, FALSE otherwise

    ENTRY:

    RETURNS:    TRUE if space or tab, FALSE otherwise

    HISTORY:
        ChuckC     18-Mar-1993     Created.

********************************************************************/
BOOL  IsWhiteSpace(TCHAR c)
{
    return ( c == ' ' || c == '\t' ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\lsaaccnt.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1992                   **/
/**********************************************************************/

/*
    lsaaccnt.hxx

    This file contains the LSA account object.

    FILE HISTORY:
        Yi-HsinS         3-Mar-1992     Created
*/

#include "pchlmobj.hxx"  // Precompiled header


// The size of STANDARD_PRIVILEGE_SET_SIZE can contain 3 privileges.
#define DEFAULT_NUM_PRIVILEGE        3
#define STANDARD_PRIVILEGE_SET_SIZE  ( sizeof( PRIVILEGE_SET ) +  \
                                       (DEFAULT_NUM_PRIVILEGE - 1 ) * \
                                       sizeof( LUID_AND_ATTRIBUTES ) )

BOOL OS_LUID :: operator==( const OS_LUID & osluid ) const
{
#if defined(_CFRONT_PASS_)
    return _luid.u.LowPart  == (osluid.QueryLuid()).u.LowPart &&
              _luid.u.HighPart == (osluid.QueryLuid()).u.HighPart;
#else
    return _luid.LowPart  == (osluid.QueryLuid()).LowPart &&
           _luid.HighPart == (osluid.QueryLuid()).HighPart;
#endif
}


/*************************************************************************

    NAME:       OS_PRIVILEGE_SET::OS_PRIVILEGE_SET

    SYPNOSIS:   Constructor

    ENTRY:      pPrivSet - pointer to a PRIVILEGE_SET or NULL. If it is
                           NULL, then we allocate memory locally.

    EXITS:

    RETURNS:

    NOTES:      If pPrivSet is NULL, the buffer allcated can contain at
                most DEFAULT_NUM_PRIVILEGE. The buffer will be resized
                if necessary.

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

OS_PRIVILEGE_SET::OS_PRIVILEGE_SET( PPRIVILEGE_SET pPrivSet )
    : OS_OBJECT_WITH_DATA( (UINT)(pPrivSet == NULL? STANDARD_PRIVILEGE_SET_SIZE: 0 )),
      _pPrivSet( pPrivSet == NULL? (PPRIVILEGE_SET) QueryPtr() : pPrivSet ),
      _osluidAndAttrib(),
      _ulMaxNumPrivInBuf( pPrivSet == NULL? DEFAULT_NUM_PRIVILEGE
                                           : pPrivSet->PrivilegeCount )
{
    if ( QueryError() != NERR_Success )
        return;

    if ( pPrivSet == NULL )
    {
        InitializeMemory();
    }

}

/*************************************************************************

    NAME:       OS_PRIVILEGE_SET::~OS_PRIVILEGE_SET

    SYPNOSIS:   Destructor

    ENTRY:

    EXITS:

    RETURNS:

    NOTES:      Free the memory only if it's allocated by some API.
                Otherwise, the BUFFER object in OS_OBJECT_WITH_DATA
                will free the memory that we allocated ourselves.

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

OS_PRIVILEGE_SET::~OS_PRIVILEGE_SET()
{
    if ( IsOwnerAlloc() )
        ::LsaFreeMemory( _pPrivSet );

    _pPrivSet = NULL;
}

/*************************************************************************

    NAME:       OS_PRIVILEGE_SET::InitializeMemory

    SYPNOSIS:   Initialize local memory

    ENTRY:

    EXITS:

    RETURNS:

    NOTES:      This is only valid when the set is allocated by
                ourselves and not returned to us by some API.

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

VOID OS_PRIVILEGE_SET::InitializeMemory( VOID )
{
    UIASSERT( !IsOwnerAlloc() );

    _pPrivSet->PrivilegeCount = 0;
    _pPrivSet->Control = 0;
}

/*************************************************************************

    NAME:       OS_PRIVILEGE_SET::QueryPrivilege

    SYPNOSIS:   Query the ith privilege contained in the OS_PRIVILEGE_SET

    ENTRY:

    EXITS:

    RETURNS:    Returns the ith OS_LUID_AND_ATTRIBUTES contained in the
                privilege set.

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

const OS_LUID_AND_ATTRIBUTES *OS_PRIVILEGE_SET::QueryPrivilege( LONG i )
{
    UIASSERT( ( i >= 0) && ( i < (LONG) _pPrivSet->PrivilegeCount) );

    _osluidAndAttrib.SetLuidAndAttrib( _pPrivSet->Privilege[i] );

    return &_osluidAndAttrib;
}

/*************************************************************************

    NAME:       OS_PRIVILEGE_SET::FindPrivilege

    SYPNOSIS:   Find a privilege in the set

    ENTRY:      luid - id of the privilege to search for

    EXITS:

    RETURNS:    Returns the index to the privilege set that contains
                the luid passed in

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

LONG OS_PRIVILEGE_SET::FindPrivilege( LUID luid ) const
{
    for ( LONG i = 0; i < (LONG) _pPrivSet->PrivilegeCount; i++ )
    {
         if (
#if defined(_CFRONT_PASS_)
               ( _pPrivSet->Privilege[i].Luid.u.LowPart == luid.u.LowPart )
            && ( _pPrivSet->Privilege[i].Luid.u.HighPart == luid.u.HighPart )

#else
               ( _pPrivSet->Privilege[i].Luid.LowPart == luid.LowPart )
            && ( _pPrivSet->Privilege[i].Luid.HighPart == luid.HighPart )
#endif
            )
         {
             return i;
         }
    }

    return -1;  // No match!
}

/*************************************************************************

    NAME:       OS_PRIVILEGE_SET::AddPrivilege

    SYPNOSIS:   Add a privilege to the privilege set

    ENTRY:      luid - the id of the privilege to add
                ulAttribs - the attributes to be assigned to the privilege

    EXITS:

    RETURNS:

    NOTES:      This is only valid when the set is allocated by
                ourselves and not returned to us by some API.

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

APIERR OS_PRIVILEGE_SET::AddPrivilege( LUID luid, ULONG ulAttribs )
{
    UIASSERT( !IsOwnerAlloc() );

    APIERR err = NERR_Success;
    LONG iAdd = FindPrivilege( luid );

    //
    //  If the luid is already in the privilege set, just return.
    //

    if ( iAdd >= 0 )
    {
        _pPrivSet->Privilege[ iAdd ].Attributes = ulAttribs;
        return err;
    }

    //
    //  If the buffer is full, resize it to accommodate more privileges
    //

    if ( _pPrivSet->PrivilegeCount == _ulMaxNumPrivInBuf )
    {

        err = Resize( QueryAllocSize() + sizeof( LUID_AND_ATTRIBUTES ) *
                                         DEFAULT_NUM_PRIVILEGE );

        _pPrivSet = (PPRIVILEGE_SET) QueryPtr();

        if ( err != NERR_Success )
            return err;

        _ulMaxNumPrivInBuf += DEFAULT_NUM_PRIVILEGE;
    }

    //
    //  Add the privilege to the set
    //

    iAdd = _pPrivSet->PrivilegeCount++;

    _pPrivSet->Privilege[ iAdd ].Luid = luid;
    _pPrivSet->Privilege[ iAdd ].Attributes = ulAttribs;

    return err;
}

/*************************************************************************

    NAME:       OS_PRIVILEGE_SET::RemovePrivilege

    SYPNOSIS:   Remove the privilege from the set

    ENTRY:      luid - the privilege to be removed

    EXITS:

    RETURNS:

    NOTES:      This is only valid when the set is allocated by
                ourselves and not returned to us by some API.

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

APIERR OS_PRIVILEGE_SET::RemovePrivilege( LUID luid )
{

    UIASSERT( !IsOwnerAlloc() );

    LONG iDelete = FindPrivilege( luid );

    //
    // If we can't find luid, just return success.
    // Else delete it from the set.
    //

    if (( iDelete >= 0 )  && ( iDelete < (LONG) _pPrivSet->PrivilegeCount ))
    {
         _pPrivSet->Privilege[ iDelete ] =
                 _pPrivSet->Privilege[ _pPrivSet->PrivilegeCount - 1];

        _pPrivSet->PrivilegeCount--;
    }

    return NERR_Success;

}

/*************************************************************************

    NAME:       OS_PRIVILEGE_SET::RemovePrivilege

    SYPNOSIS:   Remove the ith privilege from the privilege set.

    ENTRY:      i - the index of the privilege to remove.

    EXITS:

    RETURNS:

    NOTES:      This is only valid when the set is allocated by
                ourselves and not returned to us by some API.

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

APIERR OS_PRIVILEGE_SET::RemovePrivilege( LONG i )
{

    UIASSERT( !IsOwnerAlloc() );

    UIASSERT( ( i >= 0) && ( i < (LONG) _pPrivSet->PrivilegeCount));

    _pPrivSet->Privilege[ i ] =
            _pPrivSet->Privilege[ _pPrivSet->PrivilegeCount - 1];

    _pPrivSet->PrivilegeCount--;

    return NERR_Success;

}

/*************************************************************************

    NAME:       OS_PRIVILEGE_SET::Clear

    SYPNOSIS:   Clear the privilege set, i.e., set the privilege count to zero.

    ENTRY:

    EXITS:

    RETURNS:

    NOTES:      This is only valid when the set is allocated by
                ourselves and not returned to us by some API.

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

VOID OS_PRIVILEGE_SET::Clear( VOID )
{
    UIASSERT( !IsOwnerAlloc() );

    _pPrivSet->PrivilegeCount = 0;
}

/*************************************************************************

    NAME:       LSA_ACCOUNT_PRIVILEGE_ENUM_ITER::LSA_ACCOUNT_PRIVILEGE_ENUM_ITER

    SYNOPSIS:   Constructor

    ENTRY:      pOsPrivSet - the privilege set to iterate over

    EXITS:

    RETURNS:

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

LSA_ACCOUNT_PRIVILEGE_ENUM_ITER::LSA_ACCOUNT_PRIVILEGE_ENUM_ITER(
                                 OS_PRIVILEGE_SET * pOsPrivSet )
    :  _pOsPrivSet( pOsPrivSet ),
       _iNext( 0 )
{
    if ( QueryError() != NERR_Success )
        return;
}

/*************************************************************************

    NAME:      LSA_ACCOUNT_PRIVILEGE_ENUM_ITER::~LSA_ACCOUNT_PRIVILEGE_ENUM_ITER

    SYNOPSIS:  Destructor

    ENTRY:

    EXITS:

    RETURNS:

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

LSA_ACCOUNT_PRIVILEGE_ENUM_ITER::~LSA_ACCOUNT_PRIVILEGE_ENUM_ITER()
{
    _pOsPrivSet = NULL;
}

/*************************************************************************

    NAME:      LSA_ACCOUNT_PRIVILEGE_ENUM_ITER::operator()

    SYNOPSIS:  Iterator to return the next privilege in the privilege set

    ENTRY:

    EXITS:

    RETURNS:   Returns the next privilege OS_LUID_AND_ATTRIBUTES in the set.

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

const OS_LUID_AND_ATTRIBUTES *LSA_ACCOUNT_PRIVILEGE_ENUM_ITER::operator()( VOID)
{
    if ( _iNext < (LONG) _pOsPrivSet->QueryNumberOfPrivileges() )
    {
        return _pOsPrivSet->QueryPrivilege( _iNext++ );
    }

    return NULL;  // Reach the end
}

/*************************************************************************

    NAME:       LSA_ACCOUNT::LSA_ACCOUNT

    SYNOPSIS:   Constructor

    ENTRY:      plsaPolicy - pointer to the LSA_POLICY object
                psid - the sid of the account
                accessDesired - access desired to handle the account

    EXITS:

    RETURNS:

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

LSA_ACCOUNT::LSA_ACCOUNT( LSA_POLICY *plsaPolicy,
                          PSID psid,
                          ACCESS_MASK accessDesired,
                          const TCHAR * pszFocus,
                          PSID psidFocus )
    : NEW_LM_OBJ(),
      _plsaPolicy( plsaPolicy ),
      _handleAccount( 0 ),
      _ossid( psid, TRUE ),
      _accessDesired( accessDesired ),
      _osPrivSetCurrent(),
      _osPrivSetAdd(),
      _osPrivSetDelete(),
      _ulSystemAccessCurrent( 0 ),
      _ulSystemAccessNew( 0 )
{

    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (  ((err = _ossid.QueryError()) != NERR_Success )
       || ((err = _ossid.QueryName( &_nlsName, pszFocus, psidFocus )) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

}

/*************************************************************************

    NAME:       LSA_ACCOUNT::PrintInfo

    SYNOPSIS:   Dump the information in the LSA_ACCOUNT

    ENTRY:      pszString - the title to print out for the dump

    EXITS:

    RETURNS:

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

VOID LSA_ACCOUNT::PrintInfo( const TCHAR *pszString )
{
#ifndef TRACE
    UNREFERENCED( pszString );
#endif
    TRACEEOL( pszString << SZ(":") );
    TRACEEOL( SZ("Name:") << _nlsName );
    TRACEEOL( SZ("New:") << _osPrivSetAdd.QueryNumberOfPrivileges() );
    TRACEEOL( SZ("Current:") << _osPrivSetCurrent.QueryNumberOfPrivileges() );
    TRACEEOL( SZ("Delete:") << _osPrivSetDelete.QueryNumberOfPrivileges() );
    TRACEEOL( SZ("Current SystemAccess:") << _ulSystemAccessCurrent );
    TRACEEOL( SZ("New SystemAccess:") << _ulSystemAccessNew );
    TRACEEOL( SZ("") );
}

/*************************************************************************

    NAME:       LSA_ACCOUNT::~LSA_ACCOUNT

    SYNOPSIS:   Destructor

    ENTRY:

    EXITS:

    RETURNS:

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

LSA_ACCOUNT::~LSA_ACCOUNT()
{
    //
    // Close the handle if it has been opened
    //
    if ( _handleAccount != 0 )
        ::LsaClose( _handleAccount );

    _plsaPolicy = NULL;
}

/*************************************************************************

    NAME:       LSA_ACCOUNT::QueryPrivilegeEnumIter

    SYNOPSIS:   Return an iterator that can be iterated to get the
                privileges the account has.

    ENTRY:

    EXITS:      *ppIter - contains a pointer to the iterator

    RETURNS:

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

APIERR LSA_ACCOUNT::QueryPrivilegeEnumIter( LSA_ACCOUNT_PRIVILEGE_ENUM_ITER
                                            **ppIter )
{
    *ppIter = new LSA_ACCOUNT_PRIVILEGE_ENUM_ITER( &_osPrivSetCurrent );

    APIERR err = (*ppIter == NULL)? ERROR_NOT_ENOUGH_MEMORY
                                  : (*ppIter)->QueryError();

    if ( err != NERR_Success )
    {
        delete *ppIter;
        *ppIter = NULL;
    }

    return err;
}

/*************************************************************************

    NAME:       LSA_ACCOUNT::InsertPrivilege

    SYNOPSIS:   Add a privilege to the account

    ENTRY:      luid - the privilege to be added
                ulAttribs - the attribute to be assigned to the privilege

    EXITS:

    RETURNS:

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

APIERR LSA_ACCOUNT::InsertPrivilege( LUID luid, ULONG ulAttribs )
{
    APIERR err = NERR_Success;

    // Remove the privilege from the "deleted" privilege set if it's there
    err = _osPrivSetDelete.RemovePrivilege( luid );

    //
    // See if the privilege is in the current privilege set
    // If so, do nothing.
    // Else, add the privilege to the "add" privilege set.
    //
    if (  (err == NERR_Success)
       && ( _osPrivSetCurrent.FindPrivilege( luid ) < 0)
       )
    {
        err = _osPrivSetAdd.AddPrivilege( luid, ulAttribs );
    }

    return err;
}

/*************************************************************************

    NAME:       LSA_ACCOUNT::DeletePrivilege

    SYNOPSIS:   Remove the privilege from the account

    ENTRY:      luid - the privilege to be removed

    EXITS:

    RETURNS:

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

APIERR LSA_ACCOUNT::DeletePrivilege( LUID luid )
{
    APIERR err = NERR_Success;
    LONG i;

    //
    // See if the privilege is in the current privilege set.
    // If so, add the privilege to the "deleted" privilege set.
    // Else if the privilege is in the "add" privilege set,
    //        remove it from the "add" privilege set.
    // Else, do nothing.
    //
    if ( _osPrivSetCurrent.FindPrivilege( luid ) >= 0 )
    {
        err = _osPrivSetDelete.AddPrivilege( luid );
    }
    else if ( (i = _osPrivSetAdd.FindPrivilege( luid )) >= 0 )
    {
        err = _osPrivSetAdd.RemovePrivilege( i );
    }

    return err;
}

/*************************************************************************

    NAME:       LSA_ACCOUNT::I_GetInfo

    SYNOPSIS:   Get all information about the account, including the
                privileges and system access modes.

    ENTRY:

    EXITS:

    RETURNS:

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

APIERR LSA_ACCOUNT::I_GetInfo( VOID )
{
    APIERR err = ERRMAP::MapNTStatus( ::LsaOpenAccount(
                                          _plsaPolicy->QueryHandle(),
                                          _ossid.QuerySid(),
                                          _accessDesired,
                                         &_handleAccount  ));


    if ( err == NERR_Success )
    {
        PPRIVILEGE_SET pPrivSet;
        err = ERRMAP::MapNTStatus(
                  ::LsaEnumeratePrivilegesOfAccount(  _handleAccount,
                                                     &pPrivSet ) );

        if ( err == NERR_Success )
        {
            _osPrivSetCurrent.SetPtr( pPrivSet );

            err = ERRMAP::MapNTStatus(
                      ::LsaGetSystemAccessAccount(  _handleAccount,
                                                   &_ulSystemAccessCurrent ) );

            if ( err == NERR_Success )
            {
                _ulSystemAccessNew = _ulSystemAccessCurrent;
            }
        }
    }

    return err;

}

/*************************************************************************

    NAME:       LSA_ACCOUNT::I_WriteInfo

    SYNOPSIS:   Write all information about the account back to the LSA
                including the privileges and system access modes.

    ENTRY:

    EXITS:

    RETURNS:

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

APIERR LSA_ACCOUNT::I_WriteInfo( VOID )
{
    APIERR err = NERR_Success;

    //
    // If there are new privileges to be added, add them.
    //
    if ( _osPrivSetAdd.QueryNumberOfPrivileges() > 0 )
    {
        err = ERRMAP::MapNTStatus( ::LsaAddPrivilegesToAccount(
                                              _handleAccount,
                                              _osPrivSetAdd.QueryPrivSet()));
    }

    //
    // If there are privileges to be deleted from the account, delete them.
    //
    if (  ( err == NERR_Success )
       && ( _osPrivSetDelete.QueryNumberOfPrivileges() > 0 )
       )
    {
        err = ERRMAP::MapNTStatus( ::LsaRemovePrivilegesFromAccount(
                                              _handleAccount,
                                              FALSE,
                                              _osPrivSetDelete.QueryPrivSet()));
    }

    //
    // If we have modified the system access mode, write them out.
    //
    if (  ( err == NERR_Success )
       && ( _ulSystemAccessNew != _ulSystemAccessCurrent )
       )
    {
        err = ERRMAP::MapNTStatus( ::LsaSetSystemAccessAccount(
                                              _handleAccount,
                                              _ulSystemAccessNew ));
    }

    return err;
}

/*************************************************************************

    NAME:       LSA_ACCOUNT::W_CreateNew

    SYNOPSIS:   Initialize internal variables for a new account

    ENTRY:

    EXITS:

    RETURNS:

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

APIERR LSA_ACCOUNT::W_CreateNew( VOID )
{
    APIERR err;

    if ( (err =  NEW_LM_OBJ::W_CreateNew()) != NERR_Success )
        return err;

    _handleAccount = 0;

    _osPrivSetCurrent.Clear();
    _osPrivSetAdd.Clear();
    _osPrivSetDelete.Clear();

    _ulSystemAccessCurrent = 0;
    _ulSystemAccessNew = 0;

    return NERR_Success;
}

/*************************************************************************

    NAME:       LSA_ACCOUNT::I_CreateNew

    SYNOPSIS:   Create a new account.

    ENTRY:

    EXITS:

    RETURNS:

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

APIERR LSA_ACCOUNT::I_CreateNew( VOID )
{
    return W_CreateNew();
}

/*************************************************************************

    NAME:       LSA_ACCOUNT::I_WriteNew

    SYNOPSIS:   Write out the new lsa account.

    ENTRY:

    EXITS:

    RETURNS:

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

APIERR LSA_ACCOUNT::I_WriteNew( VOID )
{
    APIERR err = NERR_Success;

    //
    // If we have not modified the privileges of the account nor
    // add system access mode to the account, then we don't need
    // to create the account in the LSA.
    //
    if (  ( _osPrivSetAdd.QueryNumberOfPrivileges() == 0 )
       && ( _ulSystemAccessNew == 0 )
       )
    {
        // No privilege is added, so we don't need to create the account.
        return err;   // Return NERR_Success
    }

    //
    // Create the LSA account
    //
    err = ERRMAP::MapNTStatus( ::LsaCreateAccount( _plsaPolicy->QueryHandle(),
                                                   _ossid.QuerySid(),
                                                   _accessDesired,
                                                  &_handleAccount ));

    if ( err == NERR_Success )
    {
        //
        // Add the privileges to the account if modified
        //
        if ( _osPrivSetAdd.QueryNumberOfPrivileges() != 0 )
        {
            err = ERRMAP::MapNTStatus( ::LsaAddPrivilegesToAccount(
                                               _handleAccount,
                                               _osPrivSetAdd.QueryPrivSet()));
        }

        //
        // Set the system access modes if modified
        //
        if ( ( err == NERR_Success ) && ( _ulSystemAccessNew != 0 ) )
        {
            err = ERRMAP::MapNTStatus( ::LsaSetSystemAccessAccount(
                                               _handleAccount,
                                               _ulSystemAccessNew ));
        }
    }

    return err;

}

/*************************************************************************

    NAME:       LSA_ACCOUNT::I_Delete

    SYNOPSIS:   Delete the lsa account.

    ENTRY:

    EXITS:

    RETURNS:

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

APIERR LSA_ACCOUNT::I_Delete( UINT uiForce )
{
    UNREFERENCED( uiForce );

    APIERR err = NERR_Success;
    if ( _handleAccount != 0 )
    {
        err =  ERRMAP::MapNTStatus( ::LsaDelete( _handleAccount ));
        _handleAccount = 0;
    }

    return err;

}

/*************************************************************************

    NAME:       LSA_ACCOUNT::IsDefaultSettings

    SYNOPSIS:   Check if the account has default settings, i.e., no
                privileges, no system access modes ...

    ENTRY:

    EXITS:

    RETURNS:    TRUE if the account has default settings, FALSE otherwise.

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

BOOL LSA_ACCOUNT::IsDefaultSettings( VOID )
{
    //CODEWORK : Need to check whether quota is default settings
    return (  ( _osPrivSetAdd.QueryNumberOfPrivileges() == 0 )
           && ( _osPrivSetCurrent.QueryNumberOfPrivileges() ==
                   _osPrivSetDelete.QueryNumberOfPrivileges() )
           && ( _ulSystemAccessNew == 0 )
           );
}

// End of LSAACCNT.CXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\lmsrvres.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    lmsrvres.hxx
    Implementation of the LM_SRVRES class.

    The LM_SRVRES class is a container for a number of utility
    functions pertaining to resources.  These functions mainly
    deal with collecting various run-time server statistics,
    such as counts of open files and print jobs.

    FILE HISTORY:
        KeithMo     27-Aug-1991 Created.
        KeithMo     06-Oct-1991 Win32 Conversion.
        ChuckC      01-Dec-1991 Split from SERVER/H, cleanup to remove
                                stuff that dont belong, no pixel drawing
                                in this baby.
        ChuckC      17-Feb-1992 Code review changes
*/

#include "pchlmobj.hxx"  // Precompiled header

extern "C"
{
    #include <mnet.h>

}   // extern "C"


//
//  LM_SRVRES methods.
//

/*******************************************************************

    NAME:       LM_SRVRES :: LM_SRVRES

    SYNOPSIS:   LM_SRVRES class constructor.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     27-Aug-1991 Created.

********************************************************************/
LM_SRVRES :: LM_SRVRES()
{
    //
    //  This space intentionally left blank.
    //

}   // LM_SRVRES :: LM_SRVRES


/*******************************************************************

    NAME:       LM_SRVRES :: ~LM_SRVRES

    SYNOPSIS:   LM_SRVRES class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     27-Aug-1991 Created.

********************************************************************/
LM_SRVRES :: ~LM_SRVRES()
{
    //
    //  This space intentionally left blank.
    //

}   // LM_SRVRES :: ~LM_SRVRES


/*******************************************************************

    NAME:       LM_SRVRES :: GetResourceCount

    SYNOPSIS:   This method retrieves the number of open named
                pipes, open files, and file locks on the target
                server.

    ENTRY:      pszServerName           - The name of the target server.

                pcOpenFiles             - Will receive a count of the
                                          remotely opened files.

                pcFileLocks             - Will receive a count of the
                                          remotely locked files.

                pcOpenNamedPipes        - Will receive a count of the
                                          remotely opened named pipes.

                pcOpenCommQueues        - Will receive a count of the
                                          remotely opened comm queues.

                pcOpenPrintQueues       - Will receive a count of the
                                          remotely opened print queues.

                pcOtherResources        - Will receive a count of the
                                          remotely opened "other"
                                          (unknown) resources.

    RETURNS:    APIERR                  - Any errors encountered.  If
                                          not NERR_Success, then the
                                          returned counts are invalid.

    HISTORY:
        KeithMo     27-Aug-1991 Created.

********************************************************************/
APIERR LM_SRVRES :: GetResourceCount( const TCHAR * pszServerName,
                                      ULONG *      pcOpenFiles,
                                      ULONG *      pcFileLocks,
                                      ULONG *      pcOpenNamedPipes,
                                      ULONG *      pcOpenCommQueues,
                                      ULONG *      pcOpenPrintQueues,
                                      ULONG *      pcOtherResources )
{
    UIASSERT(pcOpenFiles != NULL) ;
    UIASSERT(pcFileLocks != NULL) ;
    UIASSERT(pcOpenNamedPipes != NULL) ;
    UIASSERT(pcOpenCommQueues != NULL) ;
    UIASSERT(pcOpenPrintQueues != NULL) ;
    UIASSERT(pcOtherResources != NULL) ;

    FILE3_ENUM  enumFile3( pszServerName, NULL, NULL );

    APIERR err = enumFile3.GetInfo();

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  We've got our enumeration, now tally up the
    //  open named pipes, open files and file locks.
    //

    ULONG cOpenNamedPipes  = 0L;
    ULONG cOpenFiles       = 0L;
    ULONG cFileLocks       = 0L;
    ULONG cOpenCommQueues  = 0L;
    ULONG cOpenPrintQueues = 0L;
    ULONG cOtherResources  = 0L;

    FILE3_ENUM_ITER iterFile3( enumFile3 );
    const FILE3_ENUM_OBJ * pfi3;

    while( ( pfi3 = iterFile3( &err ) ) != NULL )
    {
        if( IS_FILE( pfi3->QueryPathName() ) )
        {
            //
            //  It's a "normal" file.
            //

            cOpenFiles++;
        }
        else
        if( IS_PIPE( pfi3->QueryPathName() ) )
        {
            //
            //  It's a pipe.
            //

            cOpenNamedPipes++;
        }
        else
        if( IS_COMM( pfi3->QueryPathName() ) )
        {
            //
            //  It's a comm queue.
            //

            cOpenCommQueues++;
        }
        else
        if( IS_PRINT( pfi3->QueryPathName() ) )
        {
            //
            //  It's a print queue.
            //

            cOpenPrintQueues++;
        }
        else
        {
            //
            //  It's some other resource.
            //

            cOtherResources++;
        }

        cFileLocks += (ULONG)pfi3->QueryNumLocks();
    }

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  Update the counters.
    //

    *pcOpenFiles       = cOpenFiles;
    *pcFileLocks       = cFileLocks;
    *pcOpenNamedPipes  = cOpenNamedPipes;
    *pcOpenCommQueues  = cOpenCommQueues;
    *pcOpenPrintQueues = cOpenPrintQueues;
    *pcOtherResources  = cOtherResources;

    return NERR_Success;

}   // LM_SRVRES :: GetResourceCount


/*******************************************************************

    NAME:       LM_SRVRES :: GetSessionCount

    SYNOPSIS:   This method retrieves the number of sessions
                active on the target server.

    ENTRY:      pszServerName           - The name of the target server.

                pcSessions              - Will receive a count of the
                                          active sessions.

    RETURNS:    APIERR                  - Any errors encountered.  If
                                          not NERR_Success, then the
                                          returned counts are invalid.

    HISTORY:
        KeithMo     27-Aug-1991 Created.

********************************************************************/
APIERR LM_SRVRES :: GetSessionsCount( const TCHAR * pszServerName,
                                      ULONG *      pcSessions )
{
    //
    // CODEWORK - this can be faster, info is avail from single API
    // call, but there is no LMOBJ for it
    //

    SESSION0_ENUM enumSession0( pszServerName );

    APIERR err = enumSession0.GetInfo();

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  We've got our enumeration, now tally up the
    //  active sessions.
    //

    ULONG cSessions = 0L;

    SESSION0_ENUM_ITER iterSession0( enumSession0 );
    const SESSION0_ENUM_OBJ * psi0;

    while( ( psi0 = iterSession0() ) != NULL )
    {
        cSessions++;
    }

    //
    //  Update the counter.
    //

    *pcSessions = cSessions;

    return NERR_Success;

}   // LM_SRVRES :: GetSessionsCount


#if 0   // not supported in NT product 1


/*******************************************************************

    NAME:       LM_SRVRES :: GetPrintJobCount

    SYNOPSIS:   This method retrieves the number of print jobs
                active on the target server.

    ENTRY:      pszServerName           - The name of the target server.

                pcPrintJobs             - Will receive a count of the
                                          active print jobs.

    RETURNS:    APIERR                  - Any errors encountered.  If
                                          not NERR_Success, then the
                                          returned counts are invalid.

    HISTORY:
        KeithMo     27-Aug-1991 Created.

********************************************************************/
APIERR LM_SRVRES :: GetPrintJobCount( const TCHAR * pszServerName,
                                      ULONG *      pcPrintJobs )
{
    PRINTQ1_ENUM enumPrintQ1( (TCHAR *)pszServerName );

    APIERR err = enumPrintQ1.GetInfo();

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  We've got our enumeration, now tally up the
    //  active print jobs.
    //

    ULONG cPrintJobs = 0L;

    PRINTQ1_ENUM_ITER iterPrintQ1( enumPrintQ1 );
    const PRINTQ1_ENUM_OBJ * ppqi1;

    while( ( ppqi1 = iterPrintQ1() ) != NULL )
    {
        cPrintJobs += (ULONG)ppqi1->QueryJobCount();
    }

    //
    //  Update the counter.
    //

    *pcPrintJobs = cPrintJobs;

    return NERR_Success;

}   // LM_SRVRES :: GetPrintJobCount


/*******************************************************************

    NAME:       LM_SRVRES :: GetOpenCommCount

    SYNOPSIS:   This method retrieves the number of comm ports
                remotedly opened on the target server.

    ENTRY:      pszServerName           - The name of the target server.

                pcOpenCommPorts         - Will receive a count of the
                                          remotely opened comm ports.

    RETURNS:    APIERR                  - Any errors encountered.  If
                                          not NERR_Success, then the
                                          returned counts are invalid.

    HISTORY:
        KeithMo     27-Aug-1991 Created.

********************************************************************/
APIERR LM_SRVRES :: GetOpenCommCount( const TCHAR * pszServerName,
                                      ULONG *      pcOpenCommPorts )
{
    CHARDEVQ1_ENUM enumCharDevQ1( pszServerName, NULL );

    APIERR err = enumCharDevQ1.GetInfo();

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  We've got our enumeration, now tally up the
    //  open comm ports.
    //

    ULONG cOpenCommPorts = 0L;

    CHARDEVQ1_ENUM_ITER iterCharDevQ1( enumCharDevQ1 );
    const CHARDEVQ1_ENUM_OBJ * pcqi1;

    while( ( pcqi1 = iterCharDevQ1() ) != NULL )
    {
        cOpenCommPorts += (ULONG)pcqi1->QueryNumUsers();
    }

    //
    //  Update the counter.
    //

    *pcOpenCommPorts = cOpenCommPorts;

    return NERR_Success;

}   // LM_SRVRES :: GetOpenCommCount


#endif  // 0


/*******************************************************************

    NAME:       LM_SRVRES :: NukeUsersSession

    SYNOPSIS:   Blow off the user's session to the target server.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     26-Aug-1991 Created.
        KeithMo     03-Sep-1991 Use ALIAS_STR for nlsWithoutPrefix.
        KevinL      15-Sep-1991 Moved from resbase.cxx
        KeithMo     17-Jul-1992 Removed an overactive assert.
        KeithMo     11-Apr-1993 Map NERR_ClientNameNotFound to success.
        KeithMo     01-Oct-1993 Add pszUserName, call MNetSessionDel directly.

********************************************************************/
APIERR LM_SRVRES :: NukeUsersSession( const TCHAR * pszServerName,
                                      const TCHAR * pszComputerName,
                                      const TCHAR * pszUserName )
{
    //
    //  Since the computer name (as stored in the LBI) does not
    //  contain the leading backslashes ('\\'), we must add them
    //  before we can delete the session.
    //

    NLS_STR nlsWithPrefix( SZ("\\\\") );

    if( pszComputerName != NULL )
    {
        const ALIAS_STR nlsWithoutPrefix( pszComputerName );
        nlsWithPrefix.strcat( nlsWithoutPrefix );
    }

    APIERR err = nlsWithPrefix.QueryError();

    if( err != NERR_Success )
    {
        return err;
    }

    err = ::MNetSessionDel( pszServerName,
                            pszComputerName ? nlsWithPrefix.QueryPch() : NULL,
                            pszUserName );

    if( err == NERR_ClientNameNotFound )
    {
        err = NERR_Success;
    }

    return err;

}   // LM_SRVRES :: NukeUsersSession
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\netname.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1991                   **/
/**********************************************************************/

/*
 *  netname.cxx
 *      This file contain the NET_NAME class for manipulating path names.
 *
 *
 *  History:
 *      Yi-HsinS        12/8/91         Created, separated from sharebas.cxx
 *                                      and combine the 3 classes -
 *                                      FULL_SHARE_NAME, UNC_NAME and
 *                                      RELATIVE_PATH_NAME  into a NET_NAME
 *                                      class.
 *
 *      Yi-HsinS        12/15/91        Clean up for general use, added
 *                                      QueryLocalDrive
 *
 *      Yi-HsinS        12/31/91        Move string and character constants
 *                                      from netname.hxx to here plus
 *                                      Unicode work
 */

#include "pchlmobj.hxx"  // Precompiled header



#define PATH_SEPARATOR          TCH('\\')
#define STRING_TERMINATOR       TCH('\0')
#define COLON                   TCH(':')

#define SERVER_INIT_STRING      SZ("\\\\")

/*******************************************************************

    NAME:       NET_NAME::NET_NAME

    SYNOPSIS:   Manipulate info. of the form \\Server\Share\..\..
                or x:\..\..\..  where x: may be local or redirected

    ENTRY:      pszNetName - full name of the path

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        11/15/91                Created

********************************************************************/

NET_NAME::NET_NAME( const TCHAR *pszNetName, NETNAME_TYPE netNameType )
    : _nlsComputer(),
      _nlsShare(),
      _nlsRelativePath(),
      _nlsDrive(),
      _nlsLocalPath(),
      _fLocal( BOOL_UNINITIALIZED ),
      _fSharable( BOOL_UNINITIALIZED ),
      _netNameType( netNameType )
{

    if ( QueryError() != NERR_Success )
        return;

    UIASSERT( pszNetName != NULL );

    APIERR err = NERR_Success;
    NLS_STR nlsNetName = pszNetName;

    if ( (err = nlsNetName.QueryError() ) != NERR_Success )
    {
        ReportError( err );
        return;
    }

    ULONG ulType;
    if ( (err = I_MNetPathType( NULL, pszNetName, &ulType, 0)) == NERR_Success)
    {

        switch ( ulType )
        {
            case ITYPE_UNC:
            {
                if ( netNameType == TYPE_UNKNOWN  || netNameType == TYPE_PATH_UNC )
                    err = SetUNCPath( nlsNetName );
                else
                    err = ERROR_INVALID_NAME;
                break;
            }

            case ITYPE_DEVICE_DISK:
                // To be consistent with what netcmd does
                nlsNetName.AppendChar( PATH_SEPARATOR );
                // Falls through!

            case ITYPE_PATH_ABSD:
            {
                if ( netNameType == TYPE_UNKNOWN  || netNameType == TYPE_PATH_ABS )
                    err = SetABSPath( nlsNetName );
                else
                    err = ERROR_INVALID_NAME;
                break;
            }

            default:
            {
                err = ERROR_INVALID_NAME;
                break;
            }

        }
    }

    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}

/*******************************************************************

    NAME:       NET_NAME::~NET_NAME

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        12/15/91                Created

********************************************************************/
NET_NAME::~NET_NAME()
{
}

/*******************************************************************

    NAME:       NET_NAME::SetUNCPath

    SYNOPSIS:   The name passed in is a UNC path, so set members accordingly.
                \\server\share\relativepath

    ENTRY:      pszNetName - the UNC path name

    EXIT:

    RETURNS:

    NOTES:      _fLocal, and _nlsLocalPath are not set initially. They
                will be set only when queried because getting these
                information will involved some net API calls.

    HISTORY:
        Yi-HsinS        8/15/91         Created

********************************************************************/

APIERR NET_NAME::SetUNCPath( const TCHAR *pszNetName )
{
    APIERR err = NERR_Success;


    /*
     * Get server name
     */

    _nlsComputer = pszNetName;
    ISTR istrSvrStart( _nlsComputer), istrSvrEnd( _nlsComputer);

    istrSvrStart += 2;  // to skip past "\\"
    _nlsComputer.strchr( &istrSvrEnd, PATH_SEPARATOR, istrSvrStart);

    _nlsComputer.DelSubStr( istrSvrEnd );

    /*
     * Get share name
     */

    _nlsShare = pszNetName;

    ISTR istrShare( _nlsShare ), istrShStart( _nlsShare ), istrShEnd( _nlsShare );
    istrShStart += 2;  // skip past "\\"
    _nlsShare.strchr( &istrShEnd, PATH_SEPARATOR, istrShStart);

    // delete "\\server\"
    _nlsShare.DelSubStr( istrShare, ++istrShEnd );

    ISTR istrShStart2( _nlsShare ), istrShEnd2( _nlsShare );

    if ( _nlsShare.strchr( &istrShEnd2, PATH_SEPARATOR, istrShStart2) )
    {
        _nlsRelativePath = _nlsShare;
        _nlsShare.DelSubStr( istrShEnd2 );

       /*
        * Get relative path only if another PATH_SEPARATOR exists
        */

        // _nlsRelativePath initially equals "share\restpath"

        ISTR istrRelStart( _nlsRelativePath );
        ISTR istrRelEnd( _nlsRelativePath );

        _nlsRelativePath.strchr( &istrRelEnd, PATH_SEPARATOR, istrRelStart);
        _nlsRelativePath.DelSubStr( istrRelStart, ++istrRelEnd );
    }

    if (  (( err = _nlsComputer.QueryError() ) != NERR_Success )
       || (( err = _nlsShare.QueryError() ) != NERR_Success )
       || (( err = _nlsRelativePath.QueryError()) != NERR_Success )
       )
    {
        return err;
    }

    _fSharable = BOOL_TRUE;
    _netNameType = TYPE_PATH_UNC;
    return NERR_Success;
}

/*******************************************************************

    NAME:       NET_NAME::SetABSPath

    SYNOPSIS:   The name is an absolute path, so set members accordingly
                x:\relativepath

    ENTRY:      pszNetName - the absolute path name

    EXIT:

    RETURNS:

    NOTES:      Only _nlsDrive, _nlsRelativePath
                and _netNameType are set. All other members are
                set only when needed.

    HISTORY:
        Yi-HsinS        8/15/91         Created

********************************************************************/

APIERR NET_NAME::SetABSPath( const TCHAR *pszNetName )
{

    TCHAR szDev[3];
    ::strncpyf( szDev, pszNetName, 2);
    szDev[2] = STRING_TERMINATOR;

    _netNameType = TYPE_PATH_ABS;
    _nlsDrive = szDev;

    if ( _nlsDrive.QueryError() != NERR_Success )
        return _nlsDrive.QueryError();

    // Get the relative path name minus device "x:\"
    _nlsRelativePath = pszNetName;
    ISTR istrStart( _nlsRelativePath ), istrEnd( _nlsRelativePath );
    istrEnd += 3;    // Skip past "x:\"
    _nlsRelativePath.DelSubStr( istrStart, istrEnd );

    return _nlsRelativePath.QueryError();
}


/*******************************************************************

    NAME:       NET_NAME::GetDeviceInfo

    SYNOPSIS:   Set the members if the class is constructed with absolute path
                x:\relativepath

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:
        If device x: is redirected,
           then find \\server\share associated with it and
                set _nlsComputer, _nlsShare and  _fSharable.
        else if device x: is local,
           then set _fLocal and _nlsLocalPath.


    HISTORY:
        Yi-HsinS        8/15/91         Created

********************************************************************/
APIERR NET_NAME::GetDeviceInfo( void )
{

    APIERR err = NERR_Success;

    DEVICE dev( _nlsDrive );
    if ( ( err = dev.GetInfo() ) != NERR_Success )
    {
        return err;
    }

    switch ( dev.QueryState() )
    {
        case LMO_DEV_LOCAL:
            {
                // Set the flag to TRUE indicating it's a local device
                _fLocal = BOOL_TRUE;
                _nlsLocalPath = _nlsDrive;
                _nlsLocalPath.AppendChar( PATH_SEPARATOR );
                _nlsLocalPath += _nlsRelativePath;

                err = _nlsLocalPath.QueryError();
            }
            break;

        case LMO_DEV_REMOTE:
            {
                _fSharable = BOOL_TRUE;
                if ( dev.QueryStatus() == USE_SESSLOST )
                {
                    return NERR_UseNotFound;
                }

                NLS_STR nlsRemoteName( dev.QueryRemoteName() );

                if ( (err = nlsRemoteName.QueryError()) == NERR_Success )
                {
                   err = SetUNCPath( nlsRemoteName );
                   // Set the type back 'cause SetUNCPath will
                   // change the type to TYPE_PATH_UNC
                   _netNameType = TYPE_PATH_ABS;
                }

            }
            break;

       default:
            err = (APIERR) NERR_InvalidDevice;
            break;
    }

    return err;

}



/*******************************************************************

    NAME:       NET_NAME::QueryComputerName

    SYNOPSIS:   Get the computer name

    ENTRY:

    EXIT:       pnlsComp - the computer name

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/15/91         Created

********************************************************************/
APIERR NET_NAME::QueryComputerName( NLS_STR *pnlsComp )
{
    APIERR err = QueryError();

    if ( err != NERR_Success )
        return err;

    // If _nlsComputer is not initialized ( empty string),
    // then it is constructed with x:\..\..
    if ( _nlsComputer.QueryTextLength() == 0)
    {
        // Get information about x:
        err = GetDeviceInfo();

        // If _nlsComputer is still empty string, then  the class must be
        // constructed with x:\..\.. where x: is local device
        if (  ( err == NERR_Success)
           && ( _nlsComputer.QueryTextLength() == 0 )
           )
        {
            // Get local computer name!
            LOCATION loc;
            if (  ((err = loc.QueryError()) == NERR_Success )
               && ((err = loc.QueryDisplayName( &_nlsComputer)) == NERR_Success)
               )
            {
                // nothing to do
            }
        }
    }

    if ( err == NERR_Success )
    {
        *pnlsComp = _nlsComputer;
        err = pnlsComp->QueryError();
    }

#ifdef netname_debug
UIDEBUG(SZ("Computer:#"));
UIDEBUG(*pnlsComp);
UIDEBUG(SZ("#\n\r"));
#endif

    return err;
}

/*******************************************************************

    NAME:       NET_NAME::QueryShare

    SYNOPSIS:   Get the share name

    ENTRY:

    EXIT:       pnlsShare - the share name

    RETURNS:    Returns NERR_RemoteOnly if constructed with
                x:\..\.. where x: is a local device.

    NOTES:

    HISTORY:
        Yi-HsinS        8/15/91         Created

********************************************************************/
APIERR NET_NAME::QueryShare( NLS_STR *pnlsShare )
{
    APIERR err = QueryError();
    if ( err != NERR_Success )
        return err;

    // If _nlsComputer is not initialized, then it is constructed with x:\..\..
    if ( _nlsComputer.QueryTextLength() == 0)
        err = GetDeviceInfo();

    // After GetDeviceInfo() is called, if _nlsShare is still empty,
    // then it is constructed with x:\..\.. where x: is local. Hence,
    // it's an error to query the share name.
    if ( (err == NERR_Success) && ( _nlsShare.QueryTextLength() == 0 ))
    {
        UIASSERT( FALSE );
        return NERR_RemoteOnly;
    }

    *pnlsShare = _nlsShare;

#ifdef netname_debug
UIDEBUG(SZ("Share:#"));
UIDEBUG( *pnlsShare);
UIDEBUG(SZ("#\n\r"));
#endif

    return pnlsShare->QueryError();
}

/*******************************************************************

    NAME:       NET_NAME::QueryDrive

    SYNOPSIS:   Get the drive letter

    ENTRY:

    EXIT:       pnlsDrive - the drive letter
                    will point to empty string if constructed with UNC path

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/15/91         Created

********************************************************************/
APIERR NET_NAME::QueryDrive( NLS_STR *pnlsDrive )
{
    if ( QueryError() != NERR_Success )
        return QueryError();

    *pnlsDrive = _nlsDrive;

#ifdef netname_debug
UIDEBUG(SZ("Drive:#"));
UIDEBUG( *pnlsDrive );
UIDEBUG(SZ("#\n\r"));
#endif

    return pnlsDrive->QueryError();
}

/*******************************************************************

    NAME:       NET_NAME::QueryLocalDrive

    SYNOPSIS:   Get the drive letter of the local path on the computer

    ENTRY:

    EXIT:       pnlsLocalDrive - the drive letter

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/15/91         Created

********************************************************************/
APIERR NET_NAME::QueryLocalDrive( NLS_STR *pnlsLocalDrive )
{
    APIERR err = QueryError();
    if ( err != NERR_Success )
        return err;

    if ( (err = QueryLocalPath( pnlsLocalDrive )) != NERR_Success )
        return err;

    ISTR istr( *pnlsLocalDrive );
    istr += 2;   // jump past "x:"

    pnlsLocalDrive->DelSubStr( istr );

#ifdef netname_debug
UIDEBUG(SZ("Local Drive:#"));
UIDEBUG( *pnlsLocalDrive );
UIDEBUG(SZ("#\n\r"));
#endif

    return pnlsLocalDrive->QueryError();
}

/*******************************************************************

    NAME:       NET_NAME::QueryRelativePath

    SYNOPSIS:   Get the Relative Path

    ENTRY:

    EXIT:       pnlsRelativePath - the relative path

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/15/91         Created

********************************************************************/
APIERR NET_NAME::QueryRelativePath( NLS_STR *pnlsRelativePath )
{
    if ( QueryError() != NERR_Success )
        return QueryError();

    *pnlsRelativePath = _nlsRelativePath;

#ifdef netname_debug
UIDEBUG(SZ("Relative Path:#"));
UIDEBUG( *pnlsRelativePath );
UIDEBUG(SZ("#\n\r"));
#endif

    return pnlsRelativePath->QueryError();
}

/*******************************************************************

    NAME:       NET_NAME::QueryLastComponent

    SYNOPSIS:   Get the last directory in the path
                e.g. if path is x:\....\foo or \\server\share\..\foo
                     then return foo

    ENTRY:

    EXIT:       pnlsLastComp  - the last directory

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/15/91         Created

********************************************************************/

APIERR NET_NAME::QueryLastComponent( NLS_STR *pnlsLastComp )
{

    if ( QueryError() != NERR_Success )
        return QueryError();

    *pnlsLastComp = _nlsRelativePath;
    ISTR istrStart( *pnlsLastComp ), istrEnd( *pnlsLastComp );

    if ( pnlsLastComp->strrchr( &istrEnd, PATH_SEPARATOR ))
        pnlsLastComp->DelSubStr( istrStart, ++istrEnd);

#ifdef netname_debug
UIDEBUG(SZ("Last Comp:#"));
UIDEBUG(*pnlsLastComp );
UIDEBUG(SZ("#\n\r"));
#endif

    return pnlsLastComp->QueryError();
}

/*******************************************************************

    NAME:       NET_NAME::QueryServerShare

    SYNOPSIS:   Get the \\server\share

    ENTRY:

    EXIT:       pnlsServerShare - \\server\share

    RETURNS:    Returns NERR_RemoteOnly if constructed with
                x:\..\.. where x: is a local device.

    NOTES:

    HISTORY:
        Yi-HsinS        8/15/91         Created

********************************************************************/
APIERR NET_NAME::QueryServerShare( NLS_STR *pnlsServerShare )
{

    APIERR err = QueryError();
    NLS_STR nlsShare;

    if (  (err != NERR_Success )
       || ((err = QueryComputerName( pnlsServerShare )) != NERR_Success )
       || ((err = QueryShare( &nlsShare ) ) != NERR_Success )
       )
    {
        return err;
    }

    pnlsServerShare->AppendChar( PATH_SEPARATOR );
    *pnlsServerShare += nlsShare;

#ifdef netname_debug
UIDEBUG(SZ("ServerShare:#"));
UIDEBUG(*pnlsServerShare);
UIDEBUG(SZ("#\n\r"));
#endif

    return pnlsServerShare->QueryError();
}

/*******************************************************************

    NAME:       NET_NAME::QueryUNCPath

    SYNOPSIS:   Get the \\server\share\relativepath

    ENTRY:

    EXIT:       pnlsUNCPath  - the UNC path

    RETURNS:    Returns NERR_RemoteOnly if constructed with
                x:\..\.. where x: is a local device.
    NOTES:

    HISTORY:
        Yi-HsinS        8/15/91         Created

********************************************************************/
APIERR NET_NAME::QueryUNCPath( NLS_STR *pnlsUNCPath )
{

    APIERR err = QueryError();

    if (   (err != NERR_Success )
       || ((err = QueryServerShare( pnlsUNCPath ))  != NERR_Success )
       )
    {
        return err;
    }

    if ( _nlsRelativePath.QueryTextLength() != 0 )
    {
        pnlsUNCPath->AppendChar( PATH_SEPARATOR );
        *pnlsUNCPath += _nlsRelativePath;
    }

#ifdef netname_debug
UIDEBUG(SZ("UNCPath:#"));
UIDEBUG(*pnlsUNCPath);
UIDEBUG(SZ("#\n\r"));
#endif

    return pnlsUNCPath->QueryError();
}

/*******************************************************************

    NAME:       NET_NAME::QueryLocalPath

    SYNOPSIS:   Get the local path on the computer
                x:\..\..    where x: is a local drive on the computer

    ENTRY:

    EXIT:       pnlsLocalPath - pointer to the local path on the computer

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/15/91         Created

********************************************************************/

APIERR NET_NAME::QueryLocalPath( NLS_STR *pnlsLocalPath )
{
    APIERR err = QueryError();
    if ( err != NERR_Success )
        return err;

    // Check if _nlsLocalPath is initialized already
    if ( _nlsLocalPath.QueryTextLength() == 0 )
    {
        // If not initialized, initialize it!
        NLS_STR nlsComp; // Initialize to empty string for local computer
        NLS_STR nlsShare;

        if ( (err = nlsComp.QueryError()) == NERR_Success )
        {
            if ( !IsLocal( &err ) && (err == NERR_Success))
                err = QueryComputerName( &nlsComp );
        }

        if (  (err != NERR_Success )
           || ((err = nlsShare.QueryError()) != NERR_Success )
           || ((err = QueryShare( &nlsShare )) != NERR_Success )
           )
        {
            return err;
        }

        SHARE_2 sh2( nlsShare, nlsComp );

        if (  ((err = sh2.QueryError() ) != NERR_Success )
           || ((err = sh2.GetInfo()) != NERR_Success )
           )
        {
            return err;
        }

        _nlsLocalPath = sh2.QueryPath() ;

        // Add an extra '\' after if the path is not of the form "x:\"
        // i.e. does not end with "\"
        ISTR istrLocalPath( _nlsLocalPath );
        if (  ( _nlsLocalPath.strrchr( &istrLocalPath, PATH_SEPARATOR) )
           && ( !istrLocalPath.IsLastPos() )
           && ( _nlsRelativePath.QueryTextLength() != 0 )
           )
        {
            _nlsLocalPath.AppendChar( PATH_SEPARATOR );
        }

        _nlsLocalPath.strcat( _nlsRelativePath );

        if ( (err = _nlsLocalPath.QueryError()) != NERR_Success )
            return err;

    }

    *pnlsLocalPath = _nlsLocalPath;

#ifdef netname_debug
UIDEBUG(SZ("Local Path:#"));
UIDEBUG( *pnlsLocalPath );
UIDEBUG(SZ("#\n\r"));
#endif

    return pnlsLocalPath->QueryError();

}

/*******************************************************************

    NAME:       NET_NAME::IsLocal

    SYNOPSIS:   Check if the path is on a local machine,

    ENTRY:

    EXIT:       perr - pointer to the error

    RETURNS:    Returns TRUE if the  path is on a local machine,
                        FALSE otherwise.

    NOTES:

    HISTORY:
        Yi-HsinS        12/15/91                Created

********************************************************************/

BOOL NET_NAME::IsLocal( APIERR *perr )
{

    APIERR err = QueryError();

    if (  ( err == NERR_Success )
       && ( _fLocal == BOOL_UNINITIALIZED )
       )
    {
        /*
         * _fLocal is not initialized
         */

        // If the class is constructed with an absolute path
        // and neither _nlsComputer nor _nlsLocalPath is initialized,
        // call GetDeviceInfo.
        if (  ( _netNameType == TYPE_PATH_ABS )
           && ( _nlsComputer.QueryTextLength() == 0 )
           && ( _nlsLocalPath.QueryTextLength() == 0)
           )
        {
            err = GetDeviceInfo();
        }

        // If the class is constructed with an UNC name or if
        // the class is constructed with x:\..\.. where x: is redirected
        if (( err == NERR_Success ) && ( _fLocal == BOOL_UNINITIALIZED ))
        {
            // Get Local Computer Name to set the _fLocal flag
            LOCATION loc;
            NLS_STR  nlsLocalComp;
            if (  ((err = loc.QueryError()) == NERR_Success )
               && ((err = nlsLocalComp.QueryError()) == NERR_Success )
               && ((err = loc.QueryDisplayName( &nlsLocalComp)) == NERR_Success)
               )
            {
                if( !::I_MNetComputerNameCompare( _nlsComputer, nlsLocalComp ) )
                    _fLocal = BOOL_TRUE;
                else
                    _fLocal = BOOL_FALSE;
            }
        }
    }

    if ( perr != NULL )
        *perr = err;

#ifdef netname_debug
UIDEBUG(SZ("Local:#"));
UIDEBUGNUM( _fLocal );
UIDEBUG(SZ("#\n\r"));
#endif

    return ( (_fLocal == BOOL_TRUE) ? TRUE : FALSE);

}

/*******************************************************************

    NAME:       NET_NAME::IsSharable

    SYNOPSIS:   Check if the path is on a computer that can share directories

    ENTRY:

    EXIT:       perr - pointer to the error

    RETURNS:    Returns TRUE if the computer can share directories
                        FALSE otherwise.

    NOTES:

    HISTORY:
        Yi-HsinS        12/15/91                Created

********************************************************************/

BOOL NET_NAME::IsSharable( APIERR *perr )
{
    APIERR err = QueryError();
    if (  ( err == NERR_Success )
       && ( _fSharable == BOOL_UNINITIALIZED )
       )
    {

        // If the class is constructed with an absolute path
        // and neither _nlsComputer nor _nlsLocalPath is initialized,
        // call GetDeviceInfo.
        if (  ( _netNameType == TYPE_PATH_ABS )
           && ( _nlsComputer.QueryTextLength() == 0 )
           && ( _nlsLocalPath.QueryTextLength() == 0 )
           )
        {
                err = GetDeviceInfo();
        }

        if (( err == NERR_Success ) && (_fSharable == BOOL_UNINITIALIZED))
        {
            LOCATION loc;   // local machine

            //  Check whether local machine is a NT server
            BOOL fNT;
            if (  ((err = loc.QueryError()) == NERR_Success )
               && ((err = loc.CheckIfNT( &fNT )) == NERR_Success )
               )
            {

                if ( !fNT )
                {
                    // NOTE: What happens if we admin NT from Winball machine?
                    _fSharable = BOOL_FALSE;
                }
                else
                {
                    // The local computer is NT
                    // Check whether the server service has started.

                    LM_SERVICE lmsvc( NULL, (const TCHAR *)SERVICE_SERVER );
                    if ( (err = lmsvc.QueryError()) == NERR_Success )
                    {

                        // If not started, return err
                        if ( !lmsvc.IsStarted() )
                            _fSharable = BOOL_FALSE;
                        else
                            _fSharable = BOOL_TRUE;
                    }
                }
            }
        }
    }

    if ( perr != NULL )
        *perr = err;

#ifdef netname_debug
UIDEBUG(SZ("Sharable:#"));
UIDEBUGNUM( _fSharable );
UIDEBUG(SZ("#\n\r"));
#endif

    return ( (_fSharable == BOOL_TRUE) ? TRUE : FALSE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\ntuser.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		   Copyright(c) Microsoft Corp., 1990		     **/
/**********************************************************************/

/*
 * This module contains the wrappers to NT-specific infolevels of the
 * USER object.  These infolevels are only supported on an NT server; at
 * present, they may only be called from an NT client.
 *
 *
 * HISTORY:
 *	jonn	01/21/92	Created.
 *	jonn     2/26/92	Fixups for 32-bit
 *      jonn    04/27/92        Implemented add'l accessors
 *	thomaspa 04/29/92	Set PrimaryGroup in W_CreateNew
 *      jonn    05/02/92        Set AccountType in W_CreateNew
 *
 */
#include "pchlmobj.hxx"  // Precompiled header


// string constant for "any logon server"
// BUGBUG only define once
#define SERVER_ANY SZ("\\\\*")


/*******************************************************************

    NAME:	USER_3::CtAux

    SYNOPSIS:	Constructor helper for USER_3 class

    EXIT:	ReportError is called if nesessary

    HISTORY:
	JonN	01/21/92	Created

********************************************************************/

VOID USER_3::CtAux()
{
    if ( QueryError() != NERR_Success )
	return;

    APIERR err;
    if (   ((err = _nlsProfile.QueryError()) != NERR_Success)
        || ((err = _nlsHomedirDrive.QueryError()) != NERR_Success) )
    {
    	ReportError( err );
	return;
    }
}

/*******************************************************************

    NAME:	USER_3::USER_3

    SYNOPSIS:	Constructor for USER_3 class

    ENTRY:	pszAccount -	account name
		pszLocation -	server or domain name to execute on;
				default (NULL) means the logon domain

    EXIT:	Object is constructed

    NOTES:	Validation is not done until GetInfo() time.

    HISTORY:
	JonN	01/21/92	Created

********************************************************************/


USER_3::USER_3( const TCHAR *pszAccount, const TCHAR *pszLocation )
	: USER_2( pszAccount, pszLocation ),	
	  _dwUserId( 0L ),
	  _dwPrimaryGroupId( 0L ),
	  _nlsProfile(),
          _nlsHomedirDrive(),
          _dwPasswordExpired( 0L )
{
    CtAux();
}

USER_3::USER_3( const TCHAR *pszAccount, enum LOCATION_TYPE loctype )
	: USER_2( pszAccount, loctype ),
	  _dwUserId( 0L ),
	  _dwPrimaryGroupId( 0L ),
	  _nlsProfile(),
          _nlsHomedirDrive(),
          _dwPasswordExpired( 0L )
{
    CtAux();
}

USER_3::USER_3( const TCHAR *pszAccount, const LOCATION & loc )
	: USER_2( pszAccount, loc ),
	  _dwUserId( 0L ),
	  _dwPrimaryGroupId( 0L ),
	  _nlsProfile(),
          _nlsHomedirDrive(),
          _dwPasswordExpired( 0L )
{
    CtAux();
}



/*******************************************************************

    NAME:	USER_3::~USER_3

    SYNOPSIS:	Destructor for USER_3 class

    HISTORY:
	JonN	01/21/92	Created

********************************************************************/

USER_3::~USER_3()
{
}


/*******************************************************************

    NAME:	USER_3::I_GetInfo

    SYNOPSIS:	Gets information about the local user

    EXIT:	Returns API error code

    NOTES:	In I_GetInfo, we set the password to NULL_USERSETINFO_PASSWD.
   		NetUserGetInfo[3] will never give us a real password, but
		only this value.  If this value is passed though to
		SetInfo, the user's password will not be changed.

    HISTORY:
	JonN	01/21/92	Created

********************************************************************/

APIERR USER_3::I_GetInfo()
{


    // Validate the account name

    APIERR err = HandleNullAccount();
    if (err != NERR_Success)
	return err;

    BYTE *pBuffer = NULL;
    err = ::MNetUserGetInfo ( QueryServer(), (TCHAR *)_nlsAccount.QueryPch(), 3,
	&pBuffer );
    SetBufferPtr( pBuffer );
    if ( err != NERR_Success )
	return err;

    USER_INFO_3 *lpui3 = (USER_INFO_3 *)QueryBufferPtr();
    UIASSERT( lpui3 != NULL );

    if (   ((err = SetName( lpui3->usri3_name )) != NERR_Success )
	|| ((err = SetPriv( (UINT)lpui3->usri3_priv )) != NERR_Success )
	|| ((err = SetAuthFlags( (UINT)lpui3->usri3_auth_flags )) != NERR_Success )
	|| ((err = SetComment( lpui3->usri3_comment )) != NERR_Success)
	|| ((err = SetUserComment( lpui3->usri3_usr_comment )) != NERR_Success)
	|| ((err = SetFullName( lpui3->usri3_full_name )) != NERR_Success )
    	|| ((err = SetHomeDir( lpui3->usri3_home_dir )) != NERR_Success )
    	|| ((err = SetParms( lpui3->usri3_parms )) != NERR_Success )
	|| ((err = SetScriptPath( lpui3->usri3_script_path )) != NERR_Success )
	|| ((err = SetAccountExpires( lpui3->usri3_acct_expires )) != NERR_Success )
	|| ((err = SetUserFlags( (UINT)lpui3->usri3_flags )) != NERR_Success )
	|| ((err = SetPassword( UI_NULL_USERSETINFO_PASSWD )) != NERR_Success )
	|| ((err = SetWorkstations( lpui3->usri3_workstations )) != NERR_Success )
	|| ((err = SetLogonHours( (BYTE *)lpui3->usri3_logon_hours,
				  (UINT)lpui3->usri3_units_per_week )) != NERR_Success )
	|| ((err = SetUserId( lpui3->usri3_user_id )) != NERR_Success )
	|| ((err = SetPrimaryGroupId( lpui3->usri3_primary_group_id )) != NERR_Success )
	|| ((err = SetProfile( lpui3->usri3_profile )) != NERR_Success )
	|| ((err = SetHomedirDrive( lpui3->usri3_home_dir_drive )) != NERR_Success )
	|| ((err = SetPasswordExpired( lpui3->usri3_password_expired )) != NERR_Success )
       )
    {
	return err;
    }

    return NERR_Success;


}


/*******************************************************************

    NAME:	USER_3::W_CreateNew

    SYNOPSIS:	initializes private data members for new object

    EXIT:	Returns an API error code

    NOTES:	Unlike I_GetInfo, we set the password to NULL.  This is
		an appropriate initial value for a new user.

    HISTORY:
	JonN	01/21/92	Created
        jonn    05/02/92        Set AccountType in W_CreateNew

********************************************************************/

APIERR USER_3::W_CreateNew()
{
    APIERR err = NERR_Success;
    if (   ((err = USER_2::W_CreateNew()) != NERR_Success )
	|| ((err = SetUserId( 0L )) != NERR_Success )
	|| ((err = SetPrimaryGroupId(DOMAIN_GROUP_RID_USERS)) != NERR_Success )
	|| ((err = SetProfile( NULL )) != NERR_Success )
	|| ((err = SetHomedirDrive( NULL )) != NERR_Success )
	|| ((err = SetAccountType( AccountType_Normal )) != NERR_Success )
       )
    {
	UIDEBUG( SZ("USER_3::W_CreateNew failed\r\n") );
	return err;
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:	USER_3::I_CreateNew

    SYNOPSIS:	Sets up object for subsequent WriteNew

    EXIT:	Returns a standard LANMAN error code

    NOTES:	Name validation and memory allocation are done
		at this point, not at construction.  The string-valued
		fields are only valid in the NLS_STR members and are not
		valid in the buffer until WriteNew.

		EXCEPTION: We don't validate the account name until
		WriteNew.

		Default values taken from NetCmd::user_add().

    HISTORY:
	JonN	01/21/92	Created
        JonN    05/08/92        Calls ClearBuffer()

********************************************************************/

APIERR USER_3::I_CreateNew()
{


    APIERR err = NERR_Success;
    if (   ((err = W_CreateNew()) != NERR_Success )
	|| ((err = ResizeBuffer( sizeof(USER_INFO_3) )) != NERR_Success )
	|| ((err = ClearBuffer()) != NERR_Success )
       )
    {
	return err;
    }

    USER_INFO_3 *lpui3 = (USER_INFO_3 *)QueryBufferPtr();
    UIASSERT( lpui3 != NULL );

    /*
	All fields of USER_INFO_3 are listed here.  Some are commented
	out because:
	(1) They are adequately initialized by ClearBuffer()
	(2) The effective value is stored in an NLS_SLR or other data member
    */
    // lpui3->usri3_name =
    // strcpyf( lpui3->usri3_password, QueryPassword() );
    // lpui3->usri3_password_age =
    // lpui3->usri3_priv = _usPriv = USER_PRIV_USER;
    // lpui3->usri3_home_dir =
    // lpui3->usri3_comment = (PSZ)_nlsComment.QueryPch();
    // lpui3->usri3_flags = UF_SCRIPT;
    // lpui3->usri3_script_path =
    // lpui3->usri3_auth_flags = _flAuth = 0L;
    // lpui3->usri3_full_name = (PSZ)_nlsFullName.QueryPch();
    // lpui3->usri3_usr_comment = (PSZ)_nlsUserComment.QueryPch();
    // lpui3->usri3_parms =
    // lpui3->usri3_workstations =
    // lpui3->usri3_last_logon =
    // lpui3->usri3_last_logoff =
    lpui3->usri3_acct_expires = TIMEQ_FOREVER;
    lpui3->usri3_max_storage = USER_MAXSTORAGE_UNLIMITED;
    // lpui3->usri3_units_per_week =
    // lpui3->usri3_logon_hours =
    // lpui3->usri3_bad_pw_count =
    // lpui3->usri3_num_logons =
    lpui3->usri3_logon_server = SERVER_ANY;
    // lpui3->usri3_country_code =
    // lpui3->usri3_code_page =
    // lpui3->usri3_user_id =
    // lpui3->usri3_primary_group_id =
    // lpui3->usri3_profile =
    // lpui3->usri3_home_dir_drive =
    // lpui3->usri3_password_expired =

    return NERR_Success;


}


/*******************************************************************

    NAME:	USER_3::W_CloneFrom

    SYNOPSIS:	Copies information on the user

    EXIT:	Returns an API error code

    HISTORY:
	JonN	01/21/92	Created

********************************************************************/

APIERR USER_3::W_CloneFrom( const USER_3 & user3 )
{
    APIERR err = NERR_Success;
    if (   ((err = USER_2::W_CloneFrom( user3 )) != NERR_Success )
	|| ((err = SetUserId( user3.QueryUserId() )) != NERR_Success )
	|| ((err = SetPrimaryGroupId( user3.QueryPrimaryGroupId() )))
	|| ((err = SetProfile( user3.QueryProfile() )) != NERR_Success )
	|| ((err = SetHomedirDrive( user3.QueryHomedirDrive() )) != NERR_Success )
       )
    {
	UIDEBUG( SZ("USER_3::W_CloneFrom failed\r\n") );
	return err;
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:	USER_3::CloneFrom

    SYNOPSIS:	Copies information on the user

    EXIT:	Returns an API error code

    NOTES:	W_CloneFrom copies all member objects, but it does not
    		update the otherwise unused pointers in the API buffer.
		This is left for the outermost routine, CloneFrom().
		Only the otherwise unused pointers need to be fixed
		here, the rest will be fixed in WriteInfo/WriteNew.

		usri3_logon_server is an "obscure" pointer which may
		have one of two origins:
		(1) It may have been pulled in by GetInfo, in which case
		    it is in the buffer;
		(2) It may have been created by CreateNew, in which case
		    it points to a static string outside the buffer.
		To handle these cases, FixupPointer must try to fixup
		logon_server except where it points outside the buffer.

    HISTORY:
	JonN	01/21/92	Created

********************************************************************/

APIERR USER_3::CloneFrom( const USER_3 & user3 )
{
    APIERR err = W_CloneFrom( user3 );
    if ( err != NERR_Success )
    {
	UIDEBUG( SZ("USER_3::W_CloneFrom failed with error code ") );
	UIDEBUGNUM( (LONG)err );
	UIDEBUG( SZ("\r\n") );

	ReportError( err ); // BUGBUG make unconstructed here??
	return err;
    }


    /*
	This is where I fix up the otherwise unused pointers.
    */
    USER_INFO_3 *pAPIuser3 = (USER_INFO_3 *)QueryBufferPtr();
	

    /*
	Do not attempt to merge these into a macro, the compiler will not
	interpret the "&(p->field)" correctly if you do.
    */
    FixupPointer32(((TCHAR**)&(pAPIuser3->usri3_name)), (& user3));
    FixupPointer( (TCHAR **)&(pAPIuser3->usri3_script_path), &user3 );
    FixupPointer( (TCHAR **)&(pAPIuser3->usri3_logon_server), &user3 );

    FixupPointer( (TCHAR **)&(pAPIuser3->usri3_full_name), &user3 );


    return NERR_Success;
}


/*******************************************************************

    NAME:	USER_3::W_Write

    SYNOPSIS:	Helper function for WriteNew and WriteInfo -- loads
		current values into the API buffer

    EXIT:	Returns API error code

    HISTORY:
	JonN	01/21/92	Created
        JonN    04/27/92        Enabled
	thomaspa 04/28/92	Fixed up password handling/remove redundancy

********************************************************************/

APIERR USER_3::W_Write()
{

    USER_INFO_3 *lpui3 = (USER_INFO_3 *)QueryBufferPtr();
    ASSERT( lpui3 != NULL );
    ASSERT( _nlsAccount.QueryError() == NERR_Success );
    ASSERT( _nlsAccount.strlen() <= UNLEN );
    // usri3_name is a buffer rather than a pointer
    COPYTOARRAY( lpui3->usri3_name, (TCHAR *)_nlsAccount.QueryPch() );
    lpui3->usri3_comment = (TCHAR *)QueryComment();
    lpui3->usri3_usr_comment = (TCHAR *)QueryUserComment();
    lpui3->usri3_full_name = (TCHAR *)QueryFullName();
    lpui3->usri3_priv = QueryPriv();
    lpui3->usri3_auth_flags = QueryAuthFlags();
    lpui3->usri3_flags = QueryUserFlags();
    lpui3->usri3_home_dir = (TCHAR *)QueryHomeDir();
    lpui3->usri3_parms = (TCHAR *)QueryParms();
    lpui3->usri3_script_path = (TCHAR *)QueryScriptPath();
    lpui3->usri3_acct_expires = QueryAccountExpires();
    lpui3->usri3_workstations = (TCHAR *)QueryWorkstations();
    lpui3->usri3_units_per_week = QueryLogonHours().QueryUnitsPerWeek();
    lpui3->usri3_logon_hours = (UCHAR *)(QueryLogonHours().QueryHoursBlock());
    lpui3->usri3_user_id = QueryUserId();
    lpui3->usri3_primary_group_id = QueryPrimaryGroupId();
    lpui3->usri3_profile = (TCHAR *)QueryProfile();
    lpui3->usri3_home_dir_drive = (TCHAR *)QueryHomedirDrive();
    lpui3->usri3_password_expired = QueryPasswordExpired();


    // This makes the assumption that the USER_INFO_3 struct has
    // the same format (up until the last 4 members) as the USER_INFO_2
    // struct.
    APIERR err =  USER_2::W_Write();

    // This must be done AFTER the USER_2::W_Write()
    if ( !::strcmpf( (TCHAR*)QueryPassword(), UI_NULL_USERSETINFO_PASSWD ) )
    {
	lpui3->usri3_password = NULL;
    }

    return err;

}


/*******************************************************************

    NAME:	USER_3::I_WriteInfo

    SYNOPSIS:	Writes information about the local user

    EXIT:	Returns API error code

    HISTORY:
	JonN	01/21/92	Created

********************************************************************/

APIERR USER_3::I_WriteInfo()
{


    APIERR err = W_Write();
    if ( err != NERR_Success )
	return err;

    return ::MNetUserSetInfo ( QueryServer(), (TCHAR *)_nlsAccount.QueryPch(), 3,
			QueryBufferPtr(),
			sizeof( USER_INFO_3 ), PARMNUM_ALL );


}


/*******************************************************************

    NAME:	USER_3::I_WriteNew

    SYNOPSIS:	Creates a new user

    ENTRY:

    EXIT:	Returns an API error code

    NOTES:	

    HISTORY:
	JonN	01/21/92	Created

********************************************************************/

APIERR USER_3::I_WriteNew()
{


    // Validate the account name

    APIERR err = HandleNullAccount();
    if (err != NERR_Success)
	return err;

    err = W_Write();
    if ( err != NERR_Success )
	return err;

/*
    We pass size sizeof(struct USER_INFO_3) instead of QueryBufferSize()
    to force all pointers to point outside of the buffer.
*/

    return ::MNetUserAdd( QueryServer(), 3,
			  QueryBufferPtr(),
			  sizeof( USER_INFO_3 ) );


}


/**********************************************************\

    NAME:	USER_3::I_ChangeToNew

    SYNOPSIS:	NEW_LM_OBJ::ChangeToNew() transforms a NEW_LM_OBJ from VALID
		to NEW status only when a corresponding I_ChangeToNew()
		exists.  The USER_INFO_3 API buffer is the same for new
		and valid objects, so this nethod doesn't have to do
		much.

    HISTORY:
	JonN	01/21/92	Created

\**********************************************************/

APIERR USER_3::I_ChangeToNew()
{
    return W_ChangeToNew();
}


/*******************************************************************

    NAME:	USER_3::SetUserId

    SYNOPSIS:	Changes the user's RID

    EXIT:	error code.  If not NERR_Success the object is still valid.

    HISTORY:
	JonN	01/21/92	Created

********************************************************************/

APIERR USER_3::SetUserId( DWORD dwUserId )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    _dwUserId = dwUserId;
    return NERR_Success;
}


/*******************************************************************

    NAME:	USER_3::SetPrimaryGroupId

    SYNOPSIS:	Changes the user's primary group RID

    EXIT:	error code.  If not NERR_Success the object is still valid.

    HISTORY:
	JonN	01/21/92	Created

********************************************************************/

APIERR USER_3::SetPrimaryGroupId( DWORD dwPrimaryGroupId )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    _dwPrimaryGroupId = dwPrimaryGroupId;
    return NERR_Success;
}


/*******************************************************************

    NAME:	USER_3::SetPasswordExpired

    SYNOPSIS:	Changes whether the user's password has expired

    EXIT:	error code.  If not NERR_Success the object is still valid.

    HISTORY:
	JonN	05/28/92	Created

********************************************************************/

APIERR USER_3::SetPasswordExpired( DWORD dwPasswordExpired )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    _dwPasswordExpired = dwPasswordExpired;
    return NERR_Success;
}


/*******************************************************************

    NAME:	USER_3::SetProfile

    SYNOPSIS:	Changes the user's profile path

    EXIT:	error code.  If not NERR_Success the object is still valid.

    HISTORY:
	JonN	01/21/92	Created

********************************************************************/

APIERR USER_3::SetProfile( const TCHAR * pszProfile )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    return _nlsProfile.CopyFrom( pszProfile );
}


/*******************************************************************

    NAME:	USER_3::QueryAccountType

    SYNOPSIS:	Queries the NT account type

    EXIT:	ACCOUNT_TYPE

    HISTORY:
	jonn	01/22/92	Created
	jonn	04/27/92	Enabled

********************************************************************/

ACCOUNT_TYPE USER_3::QueryAccountType() const
{


    ACCOUNT_TYPE accountType =
		(ACCOUNT_TYPE)(QueryUserFlags() & UF_ACCOUNT_TYPE_MASK);

// #ifdef DEBUG
    switch (accountType)
    {
    case AccountType_Normal:
    case AccountType_Remote:
    case AccountType_DomainTrust:
    case AccountType_WkstaTrust:
    case AccountType_ServerTrust:
	break;
    default:
	ASSERT( FALSE ); // invalid account type
        UIDEBUG( SZ("User Manager: USER_3::QueryAccountType(): Invalid account type ") );
        UIDEBUGNUM( (ULONG)accountType );
        UIDEBUG( SZ("\n\r") );
        accountType = AccountType_Normal;
	break;
    }
// #endif // DEBUG
    return accountType;


}


/*******************************************************************

    NAME:	USER_3::SetAccountType

    SYNOPSIS:	Sets a specific flag (usriX_flags)

    ENTRY:	BOOL whether flag should be set

    EXIT:	error code

    HISTORY:
	jonn	8/28/91		Created
	jonn	04/27/92	Enabled

********************************************************************/

APIERR USER_3::SetAccountType( ACCOUNT_TYPE accountType )
{
// #if 0
    switch (accountType)
    {
    case AccountType_Normal:
    case AccountType_Remote:
    case AccountType_DomainTrust:
    case AccountType_WkstaTrust:
    case AccountType_ServerTrust:
	break;
    default:
	ASSERT( FALSE ); // invalid account type
        UIDEBUG( SZ("User Manager: USER_3::QueryAccountType(): Invalid account type ") );
        UIDEBUGNUM( (ULONG)accountType );
        UIDEBUG( SZ("\n\r") );
        accountType = AccountType_Normal;
	break;
    }
// #endif // DEBUG


    return SetUserFlags( (QueryUserFlags() & (~UF_ACCOUNT_TYPE_MASK))
			 | ((UINT)accountType) );

}


/*******************************************************************

    NAME:	USER_3::SetHomedirDrive

    SYNOPSIS:	Changes the user's home directory drive

    EXIT:	error code.  If not NERR_Success the object is still valid.

    HISTORY:
	JonN	04/27/92	Created

********************************************************************/

APIERR USER_3::SetHomedirDrive( const TCHAR * pszHomedirDrive )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    return _nlsHomedirDrive.CopyFrom( pszHomedirDrive );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\ntacutil.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    NTAcUtil.cxx

    This file contains the implemenation for the NT Account utilities



    FILE HISTORY:
        JohnL   13-Mar-1992     Created
        thomaspa 14-May-1992    Added GetQualifiedAccountNames
        KeithMo  20-Jul-1992    Added ValidateQualifiedAccountName.
        JonN    16-Nov-1992     Fix DC-focus problem, get group comments

*/

#include "pchlmobj.hxx"  // Precompiled header



// used in GetQualifiedAccountNames
DECLARE_SLIST_OF( API_SESSION );
DEFINE_SLIST_OF( API_SESSION );

DECLARE_SLIST_OF( ADMIN_AUTHORITY );
DEFINE_SLIST_OF( ADMIN_AUTHORITY );


//
// locally-defined worker routines for GetQualifiedAccountNames
//

APIERR I_FetchDCList(       const LSA_TRANSLATED_NAME_MEM & lsatnm,
                            const LSA_REF_DOMAIN_MEM &  lsardm,
                            PSID                        psidLSAAcctDom,
                            PSID                        psidBuiltIn,
                            NLS_STR **                  apnlsPDCs,
                            STRLIST *                   pstrlistPDCs,
                            BOOL *                      afDCFound,
                            APIERR *                    perrNonFatal = FALSE,
                            const TCHAR *               pszServer = NULL,
                            BOOL                        fFetchUserFlags = FALSE,
                            BOOL                        fFetchFullNames = FALSE,
                            BOOL                        fFetchComments = FALSE );

APIERR I_FetchGroupFields(  NLS_STR *       pnlsComment,
                            const NLS_STR & nlsAccountName,
                            const NLS_STR * pnlsPDC,
                            APIERR *        perrNonFatal = NULL );

APIERR I_FetchAliasFields(  NLS_STR *       pnlsComment,
                            ADMIN_AUTHORITY ** ppadminauth,
                            SLIST_OF(ADMIN_AUTHORITY) * pslistADMIN_AUTH,
                            ULONG           ulRID,
                            BOOL            fDomainIsBuiltIn,
                            const NLS_STR & nlsAccountName,
                            const NLS_STR * pnlsPDC,
                            APIERR *        perrNonFatal = NULL );

APIERR I_FetchUserFields(   NLS_STR *       pnlsComment,
                            NLS_STR *       pnlsFullName,
                            ULONG *         pulUserFlags,
                            const NLS_STR & nlsAccountName,
                            const NLS_STR * pnlsPDC,
                            APIERR *        perrNonFatal = NULL );

APIERR I_AppendToSTRLIST(   STRLIST *       pstrlist,
                            NLS_STR &       nlsToCopy );


/*******************************************************************

    NAME:       NT_ACCOUNTS_UTILITY::BuildQualifiedAccountName

    SYNOPSIS:   Builds a fully qualified Account name of the form
                "NtProject\JohnL".

    ENTRY:
        pnlsQualifiedAccountName - Pointer to NLS_STR to receive the qualified
             Account name.
        nlsAccountName - contains the Account name (such as "JohnL")
        nlsDomainName - Contains the domain the Account lives in (such as
             "NtProject")
        pnlsCurrentDomain - Optional name of the domain the current logged on
             Account lives in.
             If this domain name matches nlsDomainName, then
             nlsDomainName is omitted as the prefix for the qualified name.
             If this parameter is NULL, then nlsDomainName is always prefixed
             to the qualified name.

    EXIT:       *pnlsQualifiedAccountName will contain either "JohnL" or
                "NtProject\JohnL" depending on where "JohnL" lives.

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   13-Mar-1992     Created

********************************************************************/

APIERR NT_ACCOUNTS_UTILITY::BuildQualifiedAccountName(
                             NLS_STR *       pnlsQualifiedAccountName,
                             const NLS_STR & nlsAccountName,
                             const NLS_STR & nlsDomainName,
                             const NLS_STR * pnlsFullName,
                             const NLS_STR * pnlsCurrentDomain,
                             SID_NAME_USE    sidType )
{
    UIASSERT( pnlsQualifiedAccountName != NULL ) ;

    *pnlsQualifiedAccountName = SZ("") ;

    if (  (pnlsCurrentDomain == NULL) ||
          ::I_MNetComputerNameCompare( pnlsCurrentDomain->QueryPch(),
                                       nlsDomainName ) )
    {
        /* Only put on the domain name if it is not the empty string
         */
        if ( nlsDomainName.strlen() > 0)
        {
            *pnlsQualifiedAccountName += nlsDomainName ;
            pnlsQualifiedAccountName->AppendChar( QUALIFIED_ACCOUNT_SEPARATOR ) ;
        }
    }

    return W_BuildQualifiedAccountName( pnlsQualifiedAccountName,
                                        nlsAccountName,
                                        pnlsFullName,
                                        sidType );

}




/*******************************************************************

    NAME:       BuildQualifiedAccountName

    SYNOPSIS:   Same as above only SIDs are used for determining
                whether or not to include the domain name

        pnlsQualifiedAccountName - Pointer to NLS_STR to receive the qualified
             Account name.
        nlsAccountName - contains the Account name (such as "JohnL")
        nlsDomainName - Contains the domain the Account lives in (such as
             "NtProject")
        psidDomain - PSID for the domain the Account lives in
        psidCurrentDomain - Optional PSID of the domain the current logged on
             Account lives in.
             If this domain PSID matches psidDomain, then
             nlsDomainName is omitted as the prefix for the qualified name.
             If this parameter is NULL, then nlsDomainName is always prefixed
             to the qualified name.

    EXIT:       Same as above.

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   13-Mar-1992     Created

********************************************************************/
APIERR NT_ACCOUNTS_UTILITY::BuildQualifiedAccountName(
                             NLS_STR *       pnlsQualifiedAccountName,
                             const NLS_STR & nlsAccountName,
                             PSID psidDomain,
                             const NLS_STR & nlsDomainName,
                             const NLS_STR * pnlsFullName,
                             PSID psidCurrentDomain,
                             SID_NAME_USE    sidType )
{
    UIASSERT( pnlsQualifiedAccountName != NULL ) ;

    *pnlsQualifiedAccountName = SZ("") ;

    if (  (psidCurrentDomain == NULL) ||
          (psidDomain        == NULL) ||
        !(::EqualSid( psidDomain, psidCurrentDomain )) )
    {
#ifdef TRACE
        if ( psidDomain == NULL )
            TRACEEOL("NT_ACCOUNTS_UTILITY::BuildQualifiedAccountName - " <<
                     "Warning - psidDomain is NULL!") ;
#endif //TRACE

        /* Only put on the domain name if it is not the empty string
         */
        if ( nlsDomainName.strlen() > 0)
        {
            *pnlsQualifiedAccountName += nlsDomainName ;
            pnlsQualifiedAccountName->AppendChar( QUALIFIED_ACCOUNT_SEPARATOR ) ;
        }
    }

    return W_BuildQualifiedAccountName( pnlsQualifiedAccountName,
                                        nlsAccountName,
                                        pnlsFullName,
                                        sidType );
}






/*******************************************************************

    NAME:       W_BuildQualifiedAccountName

    SYNOPSIS:   Worker function for BuildQualifiedAccountName

    ENTRY:

    EXIT:       Same as above.

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Thomaspa        09-Jul-1992     Created

********************************************************************/

APIERR NT_ACCOUNTS_UTILITY::W_BuildQualifiedAccountName(
                             NLS_STR * pnlsQualifiedAccountName,
                             const NLS_STR & nlsAccountName,
                             const NLS_STR * pnlsFullName,
                             SID_NAME_USE    sidType )
{
    NLS_STR nls;
    APIERR err;
    switch ( sidType )
    {
    case SidTypeUnknown:
    case SidTypeInvalid:
        err = nls.Load( IDS_LMOBJ_SIDUNKNOWN, NLS_BASE_DLL_HMOD );
        if ( err == NERR_Success )
        {
            *pnlsQualifiedAccountName += nls;
        }
        else
        {
            DBGEOL( SZ("Can't load IDS_LMOBJ_SIDUNKNOWN.") );
            // If we can't load the string, just display what is passed in
            *pnlsQualifiedAccountName += nlsAccountName ;
        }
        break;
    case SidTypeDeletedAccount:
        err = nls.Load( IDS_LMOBJ_SIDDELETED, NLS_BASE_DLL_HMOD );
        if ( err == NERR_Success )
        {
            *pnlsQualifiedAccountName += nls;
        }
        else
        {
            DBGEOL( SZ("Can't load IDS_LMOBJ_SIDDELETED.") );
            // If we can't load the string, just display what is passed in
            *pnlsQualifiedAccountName += nlsAccountName ;
        }
        break;
    default:
        *pnlsQualifiedAccountName += nlsAccountName ;
        break;
    }

    /* Append the fullname if it was specified
     */
    if ( (pnlsFullName != NULL) &&
         (pnlsFullName->strlen() > 0) )
    {
        // CODEWORK: the text constants should come from a common place.
        *pnlsQualifiedAccountName += SZ(" (") ;
        *pnlsQualifiedAccountName += *pnlsFullName ;
        *pnlsQualifiedAccountName += SZ(")") ;
    }

    return pnlsQualifiedAccountName->QueryError() ;
}

/*******************************************************************

    NAME:       NT_ACCOUNTS_UTILITY::CrackQualifiedAccountName

    SYNOPSIS:   Breaks a qualified account name into its components.

    ENTRY:      nlsQualifiedAccountName - An account name of the form
                    "JohnL" or "NtProject\JohnL (Ludeman, John)".  If the
                    domain name is requested but isn't contained in the
                    account name, then the empty string will be returned
                    in the domain name.
                pnlsAccountName - Pointer to NLS_STR that will receive the
                    account name (or NULL if you don't want the account name).
                pnlsDomainName - Same as pnlsAccountName only for the domain.

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      The domain name will be set to the empty string if one wasn't
                found (same for user name).

    HISTORY:
        Johnl   13-Mar-1992     Created
        KeithMo 20-Jul-1992     Added support for ".\user" syntax.

********************************************************************/

APIERR NT_ACCOUNTS_UTILITY::CrackQualifiedAccountName(
                             const NLS_STR & nlsQualifiedAccountName,
                                   NLS_STR * pnlsAccountName,
                                   NLS_STR * pnlsDomainName )
{
    APIERR err = NERR_Success ;

    /* We write to the string so make a copy and use it.
     */
    NLS_STR nlsScratch( nlsQualifiedAccountName ) ;
    if ( err = nlsScratch.QueryError())
        return err ;

    ISTR istrSep( nlsScratch ) ;
    BOOL fContainsDomain = nlsScratch.strchr( &istrSep,
                                              QUALIFIED_ACCOUNT_SEPARATOR );
    if ( fContainsDomain )
    {
        if ( pnlsDomainName != NULL )
        {
            ISTR istrStart( nlsScratch ) ;
            NLS_STR *pnlsTemp = nlsScratch.QuerySubStr( istrStart,
                                                       istrSep );
            if ( pnlsTemp == NULL )
            {
                return ERROR_NOT_ENOUGH_MEMORY ;
            }

            if( ( pnlsTemp->QueryTextLength() == 1 ) &&
                ( nlsScratch.QueryChar( istrStart ) == TCH('.') ) )
            {
                *pnlsDomainName = SZ("");
            }
            else
            {
                *pnlsDomainName = *pnlsTemp ;
            }

            delete pnlsTemp ;

            err = pnlsDomainName->QueryError() ;
        }

        /* Move the ISTR to the first character of the Account Name in case
         * the user requested it also.
         */
        ++istrSep ;
    }
    else
    {
        /* No domain to be found
         */
        if ( pnlsDomainName != NULL )
        {
            *pnlsDomainName = SZ("") ;
            err = pnlsDomainName->QueryError() ;
        }

        /* The ISTR was set to the end of the string since we didn't find
         * a '\\' marking a domain name.  Get it ready for any User name
         * munging.
         */
        istrSep.Reset() ;
    }

    if ( !err && pnlsAccountName != NULL )
    {
        /* Truncate the string if it has a " (name, full)" on the end
         *
         * We specifically look for a space followed by a '(' followed by
         * a ')'
         */
        ISTR istrEnd( istrSep ) ;

        if ( nlsScratch.strchr( &istrEnd, TCH(' ')))
        {
            ISTR istrOpenParen( istrEnd ) ;
            ISTR istrCloseParen( istrEnd ) ;
            if ( nlsScratch.strchr( &istrOpenParen,
                                                 TCH('('),
                                                 istrEnd )       &&
                 nlsScratch.strchr( &istrCloseParen,
                                                 TCH(')'),
                                                 istrOpenParen)    )
            {
                nlsScratch.DelSubStr( istrEnd ) ;
            }
        }

        /* Since we modified the string, we have to find the account name/
         * domain name separator again
         */
        if ( nlsScratch.strchr( &istrSep, QUALIFIED_ACCOUNT_SEPARATOR))
        {
            /* Move beyond the '\\' if found
             */
            ++istrSep ;
        }
        else
        {
            istrSep.Reset() ;
        }

        *pnlsAccountName = nlsScratch.QueryPch( istrSep ) ;
        err = pnlsAccountName->QueryError() ;
    }

    return err ;
}

/*******************************************************************

    NAME:       NT_ACCOUNTS_UTILITY::ValidateQualifiedAccountName

    SYNOPSIS:   Validates the (optional) domain name and the user name
                of a qualified account.

    ENTRY:      nlsQualifiedAccountName - An account name of the form
                    "KeithMo" or "NtProject\KeithMo (Moore, Keith)".

                pfInvalidDomain - Optional parameter will receive TRUE
                    if the qualified account name contained an invalid
                    domain name, FALSE otherwise.

    RETURNS:    (APIERR)  NERR_Success if the domain & account names
                          are both valid.  ERROR_INVALID_PARAMETER if
                          either is malformed.  Other errors as appropriate
                          (most probably ERROR_NOT_ENOUGH_MEMORY).

    HISTORY:
        KeithMo 20-Jul-1992     Created.

********************************************************************/

APIERR NT_ACCOUNTS_UTILITY::ValidateQualifiedAccountName(
                             const NLS_STR & nlsQualifiedAccountName,
                             BOOL          * pfInvalidDomain )
{
    //
    //  These strings will receive the account name & domain name
    //  portions of the qualified account name.
    //

    NLS_STR nlsAccountName;
    NLS_STR nlsDomainName;
    BOOL    fInvalidDomain = FALSE;     // until proven otherwise

    APIERR err = nlsAccountName.QueryError();

    if( err == NERR_Success )
    {
        err = nlsDomainName.QueryError();
    }

    if( err == NERR_Success )
    {
        //
        //  Crack the qualified name into an account and a domain.
        //

        err = NT_ACCOUNTS_UTILITY::CrackQualifiedAccountName(
                                            nlsQualifiedAccountName,
                                            &nlsAccountName,
                                            &nlsDomainName );
    }

    if( err == NERR_Success )
    {
        //
        //  If the domain was specified, validate it.
        //

        if( nlsDomainName.QueryTextLength() > 0 )
        {
            if( I_MNetNameValidate( NULL,
                                    nlsDomainName,
                                    NAMETYPE_DOMAIN,
                                    0 ) != NERR_Success )
            {
                err = ERROR_INVALID_PARAMETER;
                fInvalidDomain = TRUE;
            }
        }
    }

    if( err == NERR_Success )
    {
        //
        //  Validate the user name.
        //

        if( I_MNetNameValidate( NULL,
                                nlsAccountName,
                                NAMETYPE_USER,
                                0 ) != NERR_Success )
        {
            err = ERROR_INVALID_PARAMETER;
        }
    }

    if( pfInvalidDomain != NULL )
    {
        *pfInvalidDomain = fInvalidDomain;
    }

    return err;

}   // NT_ACCOUNTS_UTILITY :: ValidateQualifiedAccountName


/*******************************************************************

    NAME:       NT_ACCOUNTS_UTILITY::QuerySystemSid

    SYNOPSIS:   Retrieves the requested SID

    ENTRY:      UI_SystemSid - Which SID to retrieve
                possidSystemSid - Pointer to OS_SID that will recieve the
                    system sid.

    EXIT:

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      pszServer is not currently used

    HISTORY:
        Johnl    13-Mar-1992    Created
        DavidHov 18-Aug-1992    Added UI_SID_Replicator

********************************************************************/

SID_IDENTIFIER_AUTHORITY IDAuthorityWorld   = SECURITY_WORLD_SID_AUTHORITY ;
SID_IDENTIFIER_AUTHORITY IDAuthorityLocal   = SECURITY_LOCAL_SID_AUTHORITY ;
SID_IDENTIFIER_AUTHORITY IDAuthorityNT      = SECURITY_NT_AUTHORITY ;
SID_IDENTIFIER_AUTHORITY IDAuthorityCreator = SECURITY_CREATOR_SID_AUTHORITY ;
SID_IDENTIFIER_AUTHORITY IDAuthorityNull    = SECURITY_NULL_SID_AUTHORITY ;


APIERR NT_ACCOUNTS_UTILITY::QuerySystemSid(
                              enum UI_SystemSid   SystemSid,
                                   OS_SID       * possidSystemSid,
                                   const TCHAR  * pszServer )
{
    UNREFERENCED( pszServer ) ;

    if ( possidSystemSid == NULL )
    {
        ASSERT( FALSE ) ;
        return ERROR_INVALID_PARAMETER ;
    }

    APIERR err = NERR_Success ;
    switch ( SystemSid )
    {
    case UI_SID_Null:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityNull,
                              1,
                              SECURITY_NULL_RID ) ;
        break ;

    case UI_SID_Local:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityLocal,
                              1,
                              SECURITY_LOCAL_RID ) ;
        break ;




    case UI_SID_CreatorOwner:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityCreator,
                              1,
                              SECURITY_CREATOR_OWNER_RID ) ;
        break ;

    case UI_SID_CreatorGroup:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityCreator,
                              1,
                              SECURITY_CREATOR_GROUP_RID ) ;
        break ;

    case UI_SID_NTAuthority:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityNT,
                              0 ) ;

        break ;
    case UI_SID_Dialup:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityNT,
                              1,
                              SECURITY_DIALUP_RID ) ;
        break ;

    case UI_SID_Network:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityNT,
                              1,
                              SECURITY_NETWORK_RID ) ;
        break ;

    case UI_SID_Batch:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityNT,
                              1,
                              SECURITY_BATCH_RID ) ;
        break ;

    case UI_SID_Interactive:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityNT,
                              1,
                              SECURITY_INTERACTIVE_RID ) ;
        break ;

    case UI_SID_Service:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityNT,
                              1,
                              SECURITY_SERVICE_RID ) ;
        break ;

    case UI_SID_BuiltIn:
            err = BuildAndCopySysSid( possidSystemSid,
                                  &IDAuthorityNT,
                                  1,
                                  SECURITY_BUILTIN_DOMAIN_RID ) ;
        break ;

    case UI_SID_System:
            err = BuildAndCopySysSid( possidSystemSid,
                                  &IDAuthorityNT,
                                  1,
                                  SECURITY_LOCAL_SYSTEM_RID ) ;
        break ;

    case UI_SID_Restricted:
            err = BuildAndCopySysSid( possidSystemSid,
                                  &IDAuthorityNT,
                                  1,
                                  SECURITY_RESTRICTED_CODE_RID ) ;
        break ;

    case UI_SID_World:
        err = BuildAndCopySysSid( possidSystemSid,
                                  &IDAuthorityWorld,
                                  1,
                                  SECURITY_WORLD_RID ) ;
        break ;

    case UI_SID_Admins:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityNT,
                              2,
                              SECURITY_BUILTIN_DOMAIN_RID,
                              DOMAIN_ALIAS_RID_ADMINS ) ;
        break ;

    case UI_SID_Users:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityNT,
                              2,
                              SECURITY_BUILTIN_DOMAIN_RID,
                              DOMAIN_ALIAS_RID_USERS ) ;
        break ;

    case UI_SID_Guests:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityNT,
                              2,
                              SECURITY_BUILTIN_DOMAIN_RID,
                              DOMAIN_ALIAS_RID_GUESTS ) ;
        break ;


    case UI_SID_PowerUsers:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityNT,
                              2,
                              SECURITY_BUILTIN_DOMAIN_RID,
                              DOMAIN_ALIAS_RID_POWER_USERS ) ;
        break ;

    case UI_SID_AccountOperators:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityNT,
                              2,
                              SECURITY_BUILTIN_DOMAIN_RID,
                              DOMAIN_ALIAS_RID_ACCOUNT_OPS ) ;
        break ;


    case UI_SID_SystemOperators:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityNT,
                              2,
                              SECURITY_BUILTIN_DOMAIN_RID,
                              DOMAIN_ALIAS_RID_SYSTEM_OPS ) ;
        break ;

    case UI_SID_BackupOperators:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityNT,
                              2,
                              SECURITY_BUILTIN_DOMAIN_RID,
                              DOMAIN_ALIAS_RID_BACKUP_OPS ) ;
        break ;

    case UI_SID_PrintOperators:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityNT,
                              2,
                              SECURITY_BUILTIN_DOMAIN_RID,
                              DOMAIN_ALIAS_RID_PRINT_OPS ) ;
        break ;

    case UI_SID_Replicator:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityNT,
                              2,
                              SECURITY_BUILTIN_DOMAIN_RID,
                              DOMAIN_ALIAS_RID_REPLICATOR ) ;
        break ;

    case UI_SID_CurrentProcessUser:
        do
        {
            BUFFER buffUser(   sizeof (SID_AND_ATTRIBUTES)
                              + sizeof (ULONG) * SID_MAX_SUB_AUTHORITIES ) ;
            ULONG  cbBuffRequired ;
            HANDLE hProcess = ::GetCurrentProcess() ;

            if ( (err = buffUser.QueryError() ) )
            {
                break ;
            }

            /* Get the current process's user's SID
             */
            HANDLE hProcessToken = NULL ;
            if (   !::OpenProcessToken( hProcess, TOKEN_QUERY, &hProcessToken )
                || !::GetTokenInformation( hProcessToken,
                                         TokenUser,
                                         buffUser.QueryPtr(),
                                         buffUser.QuerySize(),
                                         &cbBuffRequired ) )
            {
                err = ::GetLastError() ;
                if (hProcessToken)
                {
                    ::CloseHandle( hProcessToken );
                }

                DBGEOL( SZ("OpenProcess or GetTokenInfo failed with error ") << (ULONG) err ) ;
                break ;
            }
            ::CloseHandle( hProcessToken );

            TOKEN_USER * ptokenUser = (TOKEN_USER *) buffUser.QueryPtr() ;
            OS_SID ossidNewUser( ptokenUser->User.Sid ) ;
            if ( (err = ossidNewUser.QueryError()) ||
                 (err = possidSystemSid->Copy( ossidNewUser )))
            {
                break ;
            }
        }
        while (FALSE) ;
        break ;

    case UI_SID_CurrentProcessOwner:
        do
        {
            BUFFER buffOwner(   sizeof (SID_AND_ATTRIBUTES)
                              + sizeof (ULONG) * SID_MAX_SUB_AUTHORITIES ) ;
            ULONG  cbBuffRequired ;
            HANDLE hProcess = ::GetCurrentProcess() ;

            if ( (err = buffOwner.QueryError() ) )
            {
                break ;
            }

            /* Get the current process Owner's SID
             */
            HANDLE hProcessToken = NULL ;
            if (   !::OpenProcessToken( hProcess, TOKEN_QUERY, &hProcessToken )
                || !::GetTokenInformation( hProcessToken,
                                         TokenOwner,
                                         buffOwner.QueryPtr(),
                                         buffOwner.QuerySize(),
                                         &cbBuffRequired ) )
            {
                err = ::GetLastError() ;
                if (hProcessToken)
                {
                    ::CloseHandle( hProcessToken );
                }

                DBGEOL( SZ("OpenProcess or GetTokenInfo failed with error ") << (ULONG) err ) ;
                break ;
            }
            ::CloseHandle( hProcessToken );

            TOKEN_OWNER * ptokenOwner = (TOKEN_OWNER *) buffOwner.QueryPtr() ;
            OS_SID ossidNewOwner( ptokenOwner->Owner ) ;
            if ( (err = ossidNewOwner.QueryError()) ||
                 (err = possidSystemSid->Copy( ossidNewOwner )))
            {
                break ;
            }
        }
        while (FALSE) ;
        break ;

    case UI_SID_CurrentProcessPrimaryGroup:
        do {
            BUFFER buffGroup( sizeof(SID) + sizeof(ULONG)*SID_MAX_SUB_AUTHORITIES) ;
            ULONG  cbBuffRequired ;
            HANDLE hProcess = ::GetCurrentProcess() ;

            if ( (err = buffGroup.QueryError() ) )
            {
                break ;
            }

            /* Get the current process's primary group SID
             */
            HANDLE hProcessToken = NULL ;
            if ( !::OpenProcessToken( hProcess, TOKEN_QUERY, &hProcessToken ) ||
                 !::GetTokenInformation( hProcessToken,
                                         TokenPrimaryGroup,
                                         buffGroup.QueryPtr(),
                                         buffGroup.QuerySize(),
                                         &cbBuffRequired ) )
            {
                err = ::GetLastError() ;
                if (hProcessToken)
                {
                    ::CloseHandle( hProcessToken );
                }
                DBGEOL( SZ("OpenProcess or GetTokenInfo failed with error ") << (ULONG) err ) ;
                break ;
            }
            ::CloseHandle( hProcessToken );

            TOKEN_PRIMARY_GROUP * ptokengroup = (TOKEN_PRIMARY_GROUP*) buffGroup.QueryPtr() ;
            OS_SID ossidNewGroup( ptokengroup->PrimaryGroup ) ;
            if ( (err = ossidNewGroup.QueryError()) ||
                 (err = possidSystemSid->Copy( ossidNewGroup )))
            {
                break ;
            }
        } while (FALSE) ;
        break ;

    case UI_SID_Invalid:
    default:
        DBGEOL(SZ("NT_ACCOUNTS_UTILITY::QuerySystemSid Unrecognized SystemSid request")) ;
        UIASSERT( FALSE ) ;
        err = ERROR_INVALID_PARAMETER ;
        break ;
    }

    return err ;

}


#if 0 // uncomment if needed

/*******************************************************************

    NAME:       NT_ACCOUNTS_UTILITY::IsEqualToSystemSid

    SYNOPSIS:   Compares the SID to the requested system SID

    ENTRY:      UI_SystemSid - Which SID to compare
                possidSystemSid - Pointer to OS_SID that will compare

    EXIT:

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      pszServer is not currently used

    HISTORY:
        JonN     17-Nov-1992    Created

********************************************************************/

APIERR NT_ACCOUNTS_UTILITY::IsEqualToSystemSid(
                                   BOOL *         pfEqual,
                              enum UI_SystemSid   SystemSid,
                                   const OS_SID & ossidCompare,
                                   const TCHAR  * pszServer )
{
    UIASSERT( pfEqual != NULL && ossidCompare.QueryError() == NERR_Success );

    APIERR err = NERR_Success;
    OS_SID ossidSystem;
    // CODEWORK cache the builtin sid
    if (   (err = ossidSystem.QueryError()) != NERR_Success
        || (err = QuerySystemSid( SystemSid,
                                  &ossidSystem,
                                  pszServer )) != NERR_Success
       )
    {
        DBGEOL( "NT_ACCOUNTS_UTILITY:: error loading SystemSid " << (INT)SystemSid );
    }
    else
    {
        *pfEqual = (ossidCompare == ossidSystem);
    }

    return err;

}

#endif


/*******************************************************************

    NAME:       NT_ACCOUNTS_UTILITY::BuildAndCopySysSid

    SYNOPSIS:   Builds a SID from scratch given the identifier authority
                and subauthorities.  It then copies the resulting
                SID to possid

    ENTRY:      possid - Pointer to OS_SID that will receive the
                    newly built SID
                pIDAuthority - Pointer to an Identifier Authority
                cSubAuthorities - Count of sub-authorities
                ulSubAuthority0 -> ulSubAuthority7 - Subauthorities

    EXIT:       possid will contain the newly built SID

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   25-Apr-1992     Created

********************************************************************/

APIERR NT_ACCOUNTS_UTILITY::BuildAndCopySysSid(
                    OS_SID                   *possid,
                    PSID_IDENTIFIER_AUTHORITY pIDAuthority,
                    UCHAR                     cSubAuthorities,
                    ULONG                     ulSubAuthority0,
                    ULONG                     ulSubAuthority1,
                    ULONG                     ulSubAuthority2,
                    ULONG                     ulSubAuthority3,
                    ULONG                     ulSubAuthority4,
                    ULONG                     ulSubAuthority5,
                    ULONG                     ulSubAuthority6,
                    ULONG                     ulSubAuthority7 )
{
    PSID psid ;
    APIERR err = ERRMAP::MapNTStatus(RtlAllocateAndInitializeSid(
                                                     pIDAuthority,
                                                     cSubAuthorities,
                                                     ulSubAuthority0,
                                                     ulSubAuthority1,
                                                     ulSubAuthority2,
                                                     ulSubAuthority3,
                                                     ulSubAuthority4,
                                                     ulSubAuthority5,
                                                     ulSubAuthority6,
                                                     ulSubAuthority7,
                                                     &psid )) ;
    if ( err )
    {
        return err ;
    }

    OS_SID ossidTemp( psid ) ;
    if ( (err = ossidTemp.QueryError()) ||
         (err = possid->Copy( ossidTemp )) )
    {
        /* Fall Through
         */
    }

    RtlFreeSid( psid ) ;
    return err ;
}



/*******************************************************************

    NAME:       NT_ACCOUNTS_UTILITY::I_FetchDCList

    SYNOPSIS:   Worker function for GetQualifiedAccountNames
                Fetches DC names for each referenced domain where
                needed

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      afDCFound is passed in, an array of BOOL which indocates
                whether a DC could be found for each domain.

    HISTORY:
        JonN           16-Nov-1992      Split from GetQualifiedAccountNames

********************************************************************/

APIERR I_FetchDCList(   const LSA_TRANSLATED_NAME_MEM & lsatnm,
                        const LSA_REF_DOMAIN_MEM &  lsardm,
                        PSID                        psidLSAAcctDom,
                        PSID                        psidBuiltIn,
                        NLS_STR **                  apnlsPDCs,
                        STRLIST *                   pstrlistPDCs,
                        BOOL *                      afDCFound,
                        APIERR *                    perrNonFatal,
                        const TCHAR *               pszServer,
                        BOOL                        fFetchUserFlags,
                        BOOL                        fFetchFullNames,
                        BOOL                        fFetchComments )
{
    ASSERT( pstrlistPDCs != NULL );

    APIERR err = NERR_Success;
    NLS_STR nlsDC;
    if ((err = nlsDC.QueryError()) != NERR_Success)
        return err;

    for ( INT i = 0; i < (INT)lsardm.QueryCount(); i++ )
    {
        /* Get the DC for any referenced domains that contain user accounts.
         * Skip any domains that do not have any user accounts.
         */
        BOOL fFetchDCForDomain = FALSE ;
        for (   ULONG iNameMem = 0 ;
                (!fFetchDCForDomain) && (iNameMem < lsatnm.QueryCount()) ;
                iNameMem++)
        {
            //
            //  If this account's referenced domain doesn't match the domain
            //  we are currently considering, then skip this account
            //
            if ( lsatnm.QueryDomainIndex( iNameMem ) != i )
            {
                continue ;
            }

            switch ( lsatnm.QueryUse( iNameMem ) )
            {
            case SidTypeUser:
                if (fFetchUserFlags || fFetchFullNames || fFetchComments)
                {
                    fFetchDCForDomain = TRUE;
                }
                break;
            case SidTypeGroup:
            case SidTypeAlias:
                if (fFetchComments)
                {
                    fFetchDCForDomain = TRUE;
                }
                break;
            default:
                break;
            }
        }

        if ( !fFetchDCForDomain )
        {
            afDCFound[i] = FALSE ;
            continue ;
        }

        NLS_STR nlsDomainName;
        const TCHAR * pszDCName;

        if (   (err = nlsDomainName.QueryError()) != NERR_Success
            || (err = lsardm.QueryName( i, &nlsDomainName )) != NERR_Success
           )
        {
            return err;
        }

        //
        //  Skip the "BuiltIn" and "Accounts" domains
        //
        if (   ::EqualSid( psidLSAAcctDom, lsardm.QueryPSID( i ) )
            || ::EqualSid( psidBuiltIn,    lsardm.QueryPSID( i ) )
           )
        {
            // "Accounts" or "BuiltIn" domain

            afDCFound[i] = TRUE ;
            pszDCName = NULL ;
            nlsDomainName = SZ("") ;  // Empty so pszServer is used
        }
        else
        {
            // not "Accounts" or "BuiltIn" domain

            /* If the domain name is zero length (i.e., NULL) then the DC name
             * should be the focused machine (pszServer).
             */
            if ( (err = DOMAIN_WITH_DC_CACHE::GetAnyDC( NULL,
                                                   nlsDomainName.QueryPch(),
                                                   &nlsDC)) != NERR_Success )
            {
                ASSERT( nlsDomainName.strlen() > 0 );

                /* Any error as result DC not found is NOT fatal
                 *
                 */
                afDCFound[i] = FALSE ;
                pszDCName = NULL ;
                if ( perrNonFatal != NULL && !*perrNonFatal )
                {
                    *perrNonFatal = NERR_DCNotFound ;
                }

                DBGEOL(   "NT_ACCOUNTS_UTILITY::I_FetchDCList"
                       << " - Warning - Unable to get DC for domain \""
                       << nlsDomainName << "\", error " << err );

                err = NERR_Success;
            }
            else
            {
                pszDCName = nlsDC.QueryPch();
                afDCFound[i] = TRUE ;
            }

        }

        apnlsPDCs[i] = new NLS_STR( nlsDomainName.strlen() == 0 ? pszServer :
                                                                  pszDCName);
        err = ERROR_NOT_ENOUGH_MEMORY ;
        if ( (apnlsPDCs[i] == NULL) ||
             (err = apnlsPDCs[i]->QueryError()) ||
             (err = pstrlistPDCs->Append( apnlsPDCs[i] )) )
        {
            delete apnlsPDCs[i];
            apnlsPDCs[i] = NULL;
            return err ;
        }
    }

    return NERR_Success;

} // I_FetchDCList


/*******************************************************************

    NAME:       NT_ACCOUNTS_UTILITY::I_FetchAliasFields

    SYNOPSIS:   Worker function for GetQualifiedAccountNames

                Loads the comment for this alias

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      This call will allocate a new ADMIN_AUTHORITY for the
                domain (in *ppadminauth) if none has yet been allocated.
                This way, they are loaded on demand, and not at all if
                not needed.

    HISTORY:
        JonN           18-Nov-1992      Split from GetQualifiedAccountNames

********************************************************************/

APIERR I_FetchAliasFields(  NLS_STR *       pnlsComment,
                            ADMIN_AUTHORITY ** ppadminauth,
                            SLIST_OF(ADMIN_AUTHORITY) * pslistADMIN_AUTH,
                            ULONG           ulRID,
                            BOOL            fDomainIsBuiltIn,
                            const NLS_STR & nlsAccountName,
                            const NLS_STR * pnlsPDC,
                            APIERR *        perrNonFatal )
{
    ASSERT( pnlsComment != NULL );
    ASSERT( ppadminauth != NULL );
    ASSERT( pslistADMIN_AUTH != NULL );

    APIERR err = NERR_Success;

    // Load alias comment

    if (*ppadminauth == NULL)
    {
        *ppadminauth = new ADMIN_AUTHORITY(
                        (pnlsPDC != NULL)
                            ? pnlsPDC->QueryPch()
                            : NULL );
                        // default access
        err = ERROR_NOT_ENOUGH_MEMORY;
        if (    *ppadminauth == NULL
            || (err = pslistADMIN_AUTH->Append( *ppadminauth )) != NERR_Success
           )
        {
            /* Note that this will cause repeated failures and long delays
             * in the unusual case where the ADMIN_AUTHORITY is successfully
             * created but the Append() fails.
             */
            delete *ppadminauth;
            *ppadminauth = NULL;
            return err;
        }
    }
    if ( (*ppadminauth)->QueryError() != NERR_Success )
    {
        return NERR_Success;
    }

    // At this point the ADMIN_AUTHORITY is ready

    SAM_ALIAS samalias( (fDomainIsBuiltIn)
                            ? *((*ppadminauth)->QueryBuiltinDomain())
                            : *((*ppadminauth)->QueryAccountDomain()),
                        ulRID,
                        ALIAS_READ_INFORMATION );

    if (   (err = samalias.QueryError()) != NERR_Success
        || (err = samalias.GetComment( pnlsComment )) != NERR_Success
       )
    {
        /* Treat this as a non-fatal error
         */
        DBGEOL("NT_ACCOUNTS_UTILITY::I_FetchAliasFields"
               << ", error " << err
               << " getting comment for alias \""
               << nlsAccountName << "\" from server \""
               << (*ppadminauth)->QuerySamServer()->QueryServerName()
               << "\"" );

        if ( perrNonFatal && !*perrNonFatal )
        {
            *perrNonFatal = err ;
        }
        err = NERR_Success;
    }

    return err;
}


/*******************************************************************

    NAME:       NT_ACCOUNTS_UTILITY::I_FetchGroupFields

    SYNOPSIS:   Worker function for GetQualifiedAccountNames

                Loads the comment for this group

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      CODEWORK -- would a SAM_GROUP be faster?  Maybe, maybe not,
                since we would then need an ADMIN_AUTHORITY.

    HISTORY:
        JonN           16-Nov-1992      Split from GetQualifiedAccountNames

********************************************************************/

APIERR I_FetchGroupFields(  NLS_STR *       pnlsComment,
                            const NLS_STR & nlsAccountName,
                            const NLS_STR * pnlsPDC,
                            APIERR *        perrNonFatal )
{
    ASSERT( pnlsComment != NULL );

    APIERR err = NERR_Success;
    GROUP_1 group1( nlsAccountName.QueryPch(),
                    (pnlsPDC != NULL) ? pnlsPDC->QueryPch() : NULL );
    if (   (err = group1.QueryError()) != NERR_Success
        || (err = group1.GetInfo()) != NERR_Success
        || (err = pnlsComment->CopyFrom( group1.QueryComment())) != NERR_Success
       )
    {
        /* Treat this as a non-fatal error
         */
#if defined(DEBUG)
        DBGOUT("NT_ACCOUNTS_UTILITY::I_FetchGroupFields"
               << ", error " << err
               << " getting comment for group \""
               << nlsAccountName << "\" from server " );
        if ( pnlsPDC == NULL )
        {
            DBGEOL( "<NULL>" );
        }
        else
        {
            DBGEOL( "\"" << *pnlsPDC << "\"" );
        }
#endif

        if ( perrNonFatal && !*perrNonFatal )
        {
            *perrNonFatal = err ;
        }
        err = NERR_Success;
    }

    return err;

} // I_FetchGroupFields


/*******************************************************************

    NAME:       NT_ACCOUNTS_UTILITY::I_FetchUserFields

    SYNOPSIS:   Worker function for GetQualifiedAccountNames

                Loads the comment, fullname and/or user flags for this user

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        JonN           18-Nov-1992      Split from GetQualifiedAccountNames

********************************************************************/
APIERR I_FetchUserFields(   NLS_STR *       pnlsComment,
                            NLS_STR *       pnlsFullName,
                            ULONG *         pulUserFlags,
                            const NLS_STR & nlsAccountName,
                            const NLS_STR * pnlsPDC,
                            APIERR *        perrNonFatal )
{
    APIERR err = NERR_Success;

    do { // false loop

        USER_2 * puser2;
        if ( pnlsPDC == NULL )
        {
            puser2 = new USER_2( nlsAccountName.QueryPch() );
        }
        else
        {
            puser2 = new USER_2( nlsAccountName.QueryPch(),
                            pnlsPDC->QueryPch() );
        }

        err = ERROR_NOT_ENOUGH_MEMORY;

        if ( puser2 == NULL
            || (err = puser2->QueryError()) != NERR_Success
            || (err = puser2->GetInfo()) != NERR_Success )
        {
            /* Treat this as a non-fatal error
             */
#if defined(DEBUG)
            DBGOUT("NT_ACCOUNTS_UTILITY::I_FetchUserFields"
                   << ", error " << err << " getting fields for user \""
                   << nlsAccountName << "\" from server " ) ;
            if ( pnlsPDC == NULL )
            {
                DBGEOL( "<NULL>" );
            }
            else
            {
                DBGEOL( "\"" << *pnlsPDC << "\"" );
            }
#endif

            delete puser2 ;
            puser2 = NULL ;

            if ( perrNonFatal && !*perrNonFatal )
            {
                *perrNonFatal = err ;
            }

            err = NERR_Success ;

            break;
        }

        if ( pulUserFlags != NULL )
        {
            *pulUserFlags = puser2->QueryUserFlags() ;
        }

        if ( pnlsFullName != NULL )
        {
            err = pnlsFullName->CopyFrom( puser2->QueryFullName() );
        }
        if ( (err == NERR_Success) && (pnlsComment != NULL) )
        {
            err = pnlsComment->CopyFrom( puser2->QueryComment() );
        }

        delete puser2;

    } while (FALSE); // false loop

    return err;

} // I_FetchUserFields


/*******************************************************************

    NAME:       NT_ACCOUNTS_UTILITY::I_AppendToSTRLIST

    SYNOPSIS:   Worker function for GetQualifiedAccountNames

                Creates a copy of an NLS_STR and appends the copy
                to a STRLIST (so that it will be destructed with the
                STRLIST)

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      Does nothing if the STRLIST pointer is NULL

    HISTORY:
        JonN           19-Nov-1992      Split from GetQualifiedAccountNames

********************************************************************/

APIERR I_AppendToSTRLIST(   STRLIST *       pstrlist,
                            NLS_STR &       nlsToCopy )
{
    ASSERT( nlsToCopy.QueryError() == NERR_Success );

    APIERR err = NERR_Success;

    if ( pstrlist != NULL )
    {
        NLS_STR * pnls = new NLS_STR( nlsToCopy ) ;
        err = ERROR_NOT_ENOUGH_MEMORY ;
        if (   pnls == NULL
            || (err = pnls->QueryError()) != NERR_Success
            || (err = pstrlist->Append(pnls)) != NERR_Success
           )
        {
            delete pnls;
        }
    }

    return err;
}


/*******************************************************************

    NAME:       NT_ACCOUNTS_UTILITY::GetQualifiedAccountNames

    SYNOPSIS:   Builds a fully qualified Account name of the form
                "NtProject\JohnL".

    ENTRY:
                lsapol          - LSA_POLICY object to perform the lookup
                                  on
                samdomFocus    -  SAM_DOMAIN object that points to the
                                  domain that has the current "focus"
                ppsids          - array of PSIDs for which qualified names
                                  are desired.
                cSids           - count of PSIDs to lookup
                fFullNames      - TRUE if FullNames are to be returned for Users
                pstrlistQualifiedNames - STRLIST that will receive the qualified
                                  names
                afUserFlags     - Optional array that will receive user account
                                  flags (such as remote users etc.)
                aSidType        - Optional array that will indicate the sid
                                  type
                perrNonFatal    - Non-fatal error indicator (such as DC not
                                  found)
                pszServer       - Optional (defaults to local machine) Server
                                  name to use for remote lookups of user
                                  full names (in form of "\\server").  Also
                                  used as a domain qualifier.
                pstrlistAccountNames - Optional stand alone account name
                pstrlistFullNames    - Optional stand alone Full Name
                pstrlistComments     - Optional stand alone Comment
                pstrlistDomainNames  - Optional stand alone Domain Name

    EXIT:       *strlistQualifiedNames will contain a strlist of
                qualified names in one of the following formats:


                "DOMAIN\NAME"   Resouce in domain other than current domain

                "NAME"          Resource in current domain

                Additionally, for Usernames, if fFullNames is TRUE:

                "DOMAIN\NAME (FULL NAME)"

                "NAME (FULL NAME)"

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        thomaspa        7-May-1992      Created
        Johnl          14-May-1992      Added optional aSidType parameter
        Johnl          08-Jul-1992      Added optional pszServer
        Johnl          15-Oct-1992      Added domain prefixing for Local groups
        Johnl          18-Nov-1992      Added PSID version for focused domain

********************************************************************/

APIERR NT_ACCOUNTS_UTILITY::GetQualifiedAccountNames(
                                      LSA_POLICY      & lsapol,
                                const SAM_DOMAIN      & samdomFocus,
                                const PSID            * ppsids,
                                ULONG                   cSids,
                                BOOL                    fFullNames,
                                STRLIST               * pstrlistQualifiedNames,
                                ULONG                 * afUserFlags,
                                SID_NAME_USE          * aSidType,
                                APIERR                * perrNonFatal,
                                const TCHAR           * pszServer,
                                STRLIST               * pstrlistAccountNames,
                                STRLIST               * pstrlistFullNames,
                                STRLIST               * pstrlistComments,
                                STRLIST               * pstrlistDomainNames  )
{
    return NT_ACCOUNTS_UTILITY::GetQualifiedAccountNames(
                         lsapol,
                         samdomFocus.QueryPSID(),
                         ppsids,
                         cSids,
                         fFullNames,
                         pstrlistQualifiedNames,
                         afUserFlags,
                         aSidType,
                         perrNonFatal,
                         pszServer,
                         pstrlistAccountNames,
                         pstrlistFullNames,
                         pstrlistComments,
                         pstrlistDomainNames ) ;
}


/*******************************************************************

    NAME:       NT_ACCOUNTS_UTILITY::GetQualifiedAccountNames

    SYNOPSIS:   Builds a fully qualified Account name of the form
                "NtProject\JohnL".

    ENTRY:
                lsapol          - LSA_POLICY object to perform the lookup
                                  on
                psidSamDomainFocus - SID of the domain that has the current
                                  "focus", or NULL if all names should
                                  be qualified
                ppsids          - array of PSIDs for which qualified names
                                  are desired.
                cSids           - count of PSIDs to lookup
                fFullNames      - TRUE if FullNames are to be returned for Users
                pstrlistQualifiedNames - STRLIST that will receive the qualified
                                  names
                afUserFlags     - Optional array that will receive user account
                                  flags (such as remote users etc.)
                aSidType        - Optional array that will indicate the sid
                                  type
                perrNonFatal    - Non-fatal error indicator (such as DC not
                                  found)
                pszServer       - Optional (defaults to local machine) Server
                                  name to use for remote lookups of user
                                  full names (in form of "\\server").  Also
                                  used as a domain qualifier.
                pstrlistAccountNames - Optional stand alone account name
                pstrlistFullNames    - Optional stand alone Full Name
                pstrlistComments     - Optional stand alone Comment
                pstrlistDomainNames  - Optional stand alone Domain Name

    EXIT:       *strlistQualifiedNames will contain a strlist of
                qualified names in one of the following formats:


                "DOMAIN\NAME"   Resouce in domain other than current domain

                "NAME"          Resource in current domain

                Additionally, for Usernames, if fFullNames is TRUE:

                "DOMAIN\NAME (FULL NAME)"

                "NAME (FULL NAME)"

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        thomaspa        7-May-1992      Created
        Johnl          14-May-1992      Added optional aSidType parameter
        Johnl          08-Jul-1992      Added optional pszServer
        Johnl          15-Oct-1992      Added domain prefixing for Local groups

********************************************************************/

APIERR NT_ACCOUNTS_UTILITY::GetQualifiedAccountNames(
                LSA_POLICY &            lsapol,
                const PSID              psidSamDomainFocus,
                const PSID            * ppsids,
                ULONG                   cSids,
                BOOL                    fFullNames,
                STRLIST               * pstrlistQualifiedNames,
                ULONG                 * afUserFlags,
                SID_NAME_USE          * aSidType,
                APIERR                * perrNonFatal,
                const TCHAR           * pszServer,
                STRLIST               * pstrlistAccountNames,
                STRLIST               * pstrlistFullNames,
                STRLIST               * pstrlistComments,
                STRLIST               * pstrlistDomainNames )
{
    ASSERT( ppsids != NULL || cSids == 0 );
    ASSERT( pstrlistQualifiedNames != NULL );
    ASSERT( (psidSamDomainFocus == NULL) || ::IsValidSid( psidSamDomainFocus ) );

    LSA_TRANSLATED_NAME_MEM lsatnm;
    LSA_REF_DOMAIN_MEM    lsardm;
    LSA_ACCT_DOM_INFO_MEM LSAAcctDomMem ;

    APIERR err;
    if ( perrNonFatal != NULL )
    {
        *perrNonFatal = NERR_Success ;
    }

    if ( (err = lsapol.TranslateSidsToNames( ppsids,
                                              cSids,
                                              &lsatnm,
                                              &lsardm )) ||
         (err = lsapol.GetAccountDomain( &LSAAcctDomMem )))
    {
        return err;
    }

    ASSERT( cSids == lsatnm.QueryCount() );

    PSID psidLSAAcctDom = LSAAcctDomMem.QueryPSID() ;

    //
    // Create an array of PDC names, one for each referenced domain
    //
    BUFFER bufPDCs( sizeof(NLS_STR *) * lsardm.QueryCount() );
    if ( (err = bufPDCs.QueryError()) != NERR_Success )
    {
        return err;
    }
    NLS_STR ** apnlsPDCs = (NLS_STR **) bufPDCs.QueryPtr();

    //
    // This STRLIST ensures that all of the strings in the array will be freed.
    //
    STRLIST strlistPDCs ;

    //
    // This array remembers which DCs we have found
    //
    BUFFER buffDomainFoundArray( (UINT) (sizeof(BOOL) * lsardm.QueryCount())) ;
    if ( err = buffDomainFoundArray.QueryError() )
    {
        return err ;
    }
    BOOL *afDCFound = (BOOL *) buffDomainFoundArray.QueryPtr() ;

    ULONG i;
    for ( i = 0; i < lsardm.QueryCount(); i++ )
    {
        apnlsPDCs[i] = NULL;
        afDCFound[i] = FALSE;
    }

    //
    // Cache builtin SID for future reference
    //
    OS_SID ossidBuiltIn;
    if (   (err = ossidBuiltIn.QueryError()) != NERR_Success
        || (err = QuerySystemSid( UI_SID_BuiltIn, &ossidBuiltIn )) != NERR_Success
       )
    {
        return err;
    }

    //
    // First Get all the PDCs
    //
    if ( (err = I_FetchDCList(  lsatnm,
                                lsardm,
                                psidLSAAcctDom,
                                ossidBuiltIn.QueryPSID(),
                                apnlsPDCs,
                                &strlistPDCs,
                                afDCFound,
                                perrNonFatal,
                                pszServer,
                                (afUserFlags != NULL),
                                (fFullNames || (pstrlistFullNames != NULL)),
                                (pstrlistComments != NULL))) != NERR_Success )
    {
        return err;
    }

    //
    // Create API_SESSIONs to all the known DCs (best effort only)
    //
    // This array will contain API_SESSIONs to DCs for all domains
    // for which we were able to find a PDC, EXCEPT for the "Accounts"
    // and "BuiltIn" domains.  We do not attempt to open an API_SESSION
    // to that DC since we already have an LSA_POLICY to that server,
    // so we should already have a working connection.
    //
    BUFFER bufAPI_SESSION( sizeof(API_SESSION *) * lsardm.QueryCount() );
    if ( (err = bufAPI_SESSION.QueryError()) != NERR_Success )
        return err;
    API_SESSION ** apapisess = (API_SESSION **) bufAPI_SESSION.QueryPtr();
    SLIST_OF(API_SESSION) slistAPI_SESSION;

    //
    // These ADMIN_AUTHORITYs are used to load alias comments
    //
    BUFFER bufADMIN_AUTH( sizeof(ADMIN_AUTHORITY *) * lsardm.QueryCount() );
    if ( (err = bufADMIN_AUTH.QueryError()) != NERR_Success )
        return err;
    ADMIN_AUTHORITY ** apadminauth = (ADMIN_AUTHORITY **) bufADMIN_AUTH.QueryPtr();
    SLIST_OF(ADMIN_AUTHORITY) slistADMIN_AUTH;

    //
    // Get an API_SESSION to each known PDC
    //
    for ( i = 0; i < lsardm.QueryCount(); i++ )
    {
        apapisess[i] = NULL;
        apadminauth[i] = NULL;

        if (   afDCFound[i]
            && !::EqualSid( psidLSAAcctDom,           lsardm.QueryPSID(i) )
            && !::EqualSid( ossidBuiltIn.QueryPSID(), lsardm.QueryPSID(i) )
           )
        {
            const TCHAR * pchPDC = (apnlsPDCs[i] == NULL)
                                        ? NULL
                                        : apnlsPDCs[i]->QueryPch() ;
            apapisess[i] = new API_SESSION( pchPDC, TRUE );
            err = ERROR_NOT_ENOUGH_MEMORY;
            if (   (apapisess[i] == NULL)
                || (err = slistAPI_SESSION.Append( apapisess[i] )) != NERR_Success
               )
            {
                delete apapisess[i];
                apapisess[i] = NULL;
                return err;
            }
#if defined(DEBUG)
            if ( (err = apapisess[i]->QueryError()) != NERR_Success)
            {
                DBGEOL(   "NT_ACCOUNTS_UTILITY error " << err
                       << "adding API_SESSION to \"" << pchPDC << "\"" );
                err = NERR_Success;
            }
#endif

        }

        ASSERT(   !afDCFound[i]
               || apapisess[i] != NULL // may be in error state
               || ::EqualSid( psidLSAAcctDom,           lsardm.QueryPSID(i) )
               || ::EqualSid( ossidBuiltIn.QueryPSID(), lsardm.QueryPSID(i) )
              );
    }

    NLS_STR nlsQualifiedAccountName;
    NLS_STR nlsAccountName;
    NLS_STR nlsFullName;
    NLS_STR nlsComment;
    NLS_STR nlsDomainDisplayName;
    if (   (err = nlsQualifiedAccountName.QueryError()) != NERR_Success
        || (err = nlsAccountName.QueryError()) != NERR_Success
        || (err = nlsFullName.QueryError()) != NERR_Success
        || (err = nlsComment.QueryError()) != NERR_Success
        || (err = nlsDomainDisplayName.QueryError()) != NERR_Success
       )
    {
        return err;
    }

    //
    // Now build the qualified names
    //
    for ( i = 0; i < lsatnm.QueryCount(); i++ )
    {
        nlsQualifiedAccountName = NULL;
        nlsAccountName = NULL;
        nlsFullName = NULL;
        nlsComment = NULL;
        nlsDomainDisplayName = NULL;
        ASSERT(   nlsQualifiedAccountName.QueryError() == NERR_Success
               && nlsAccountName.QueryError() == NERR_Success
               && nlsFullName.QueryError() == NERR_Success
               && nlsComment.QueryError() == NERR_Success
               && nlsDomainDisplayName.QueryError() == NERR_Success
              );

        PSID psidDomainForName = NULL ;

        SID_NAME_USE sidtype = lsatnm.QueryUse( i );

        if ( afUserFlags != NULL )
            afUserFlags[i] = 0;

        if ( aSidType != NULL )
            aSidType[i] = sidtype ;

        OS_SID ossidDomain( ppsids[i], TRUE );
        ULONG ulRID;
        if (   (err = ossidDomain.QueryError()) != NERR_Success
            || (err = ossidDomain.TrimLastSubAuthority( &ulRID )) != NERR_Success
           )
        {
            break;
        }

        LONG nIndex = lsatnm.QueryDomainIndex( i );

        if ( nIndex >= 0 ) // valid domain index
        {

            //
            // If the name is an alias, it might be in the Builtin domain.
            // If so, use the name of the LSA Accounts domain instead.
            //
            if ( (sidtype == SidTypeAlias) && (ossidDomain == ossidBuiltIn) )
            {
                err = LSAAcctDomMem.QueryName( &nlsDomainDisplayName );
            }
            else
            {
                err = lsardm.QueryName( nIndex, &nlsDomainDisplayName );
            }

            if (err != NERR_Success)
            {
                break;
            }

            psidDomainForName = lsardm.QueryPSID( nIndex );
        }

        PSID psidDomainToQualify = psidDomainForName;

        if (sidtype != SidTypeInvalid)
        {
            if ( (err = lsatnm.QueryName( i, &nlsAccountName )) != NERR_Success )
            {
                break;
            }
        }

        //
        // Load special information, such as fullnames, comments and user flags
        //
        switch (sidtype)
        {

        case SidTypeInvalid:
        case SidTypeWellKnownGroup:
        case SidTypeDomain:
        case SidTypeDeletedAccount:
        case SidTypeUnknown:
            break;

        case SidTypeAlias:
            {

                UIASSERT(   ::IsValidSid( psidLSAAcctDom ) );

                psidDomainToQualify = psidLSAAcctDom;

                if (   nIndex >= 0         // valid domain index
                    && afDCFound[nIndex]
                    && (pstrlistComments != NULL) )
                {
                    // Load alias comment

                    // Do not load if we failed to get an API_SESSION
                    if (   apapisess[nIndex] != NULL
                        && (err = apapisess[nIndex]->QueryError()) != NERR_Success )
                    {
                        /* Treat this as a non-fatal error
                         */
#if defined(DEBUG)
                        DBGOUT("NT_ACCOUNTS_UTILITY::GetQualifiedAccountName"
                               << ", cannot load alias fields due to error " << err
                               << " in API_SESSION for server " );
                        if ( apnlsPDCs[nIndex] == NULL )
                        {
                            DBGEOL( "<NULL>" );
                        }
                        else
                        {
                            DBGEOL( "\"" << *(apnlsPDCs[nIndex]) << "\"" );
                        }
#endif // DEBUG

                        err = NERR_Success ;
                    }
                    else
                    {
                        err = I_FetchAliasFields( &nlsComment,
                                                  &(apadminauth[nIndex]),
                                                  &slistADMIN_AUTH,
                                                  ulRID,
                                                  (ossidDomain == ossidBuiltIn),
                                                  nlsAccountName,
                                                  apnlsPDCs[nIndex],
                                                  perrNonFatal );
                    }
                }

            }
            break;

        case SidTypeGroup:
            if (   nIndex >= 0
                && afDCFound[nIndex]
                && (pstrlistComments != NULL)
               )
            {
                err = I_FetchGroupFields( &nlsComment,
                                          nlsAccountName,
                                          apnlsPDCs[nIndex],
                                          perrNonFatal );
            }
            break;

        case SidTypeUser:
            /* If there were no DCs to find or we failed to lookup this
             * DC then don't use the fullname.
             */
            if (   nIndex >= 0
                && afDCFound[nIndex]
                && (    (afUserFlags != NULL)
                     || (fFullNames || (pstrlistFullNames != NULL))
                     || (pstrlistComments != NULL)) )
            {
                // Do not load if we failed to get an API_SESSION
                if (   apapisess[nIndex] != NULL
                    && (err = apapisess[nIndex]->QueryError()) != NERR_Success )
                {
                    /* Treat this as a non-fatal error
                     */
#if defined(DEBUG)
                    DBGOUT("NT_ACCOUNTS_UTILITY::GetQualifiedAccountName"
                           << ", cannot load user fields due to error " << err
                           << " in API_SESSION for server " );
                    if ( apnlsPDCs[nIndex] == NULL )
                    {
                        DBGEOL( "<NULL>" );
                    }
                    else
                    {
                        DBGEOL( "\"" << *(apnlsPDCs[nIndex]) << "\"" );
                    }
#endif // DEBUG

                    err = NERR_Success ;
                }
                else
                {
                    err = I_FetchUserFields( &nlsComment,
                                             &nlsFullName,
                                             (afUserFlags == NULL)
                                               ? NULL
                                               : &(afUserFlags[i]),
                                             nlsAccountName,
                                             apnlsPDCs[nIndex],
                                             perrNonFatal );
                }

            }
            break;

        default:
            DBGEOL( "NTACUTIL: bad sid type " << (INT)sidtype );
            break;

        } // switch (sidtype)

        if ( err != NERR_Success )
            break;

        //
        // Load qualified name
        //
        switch (sidtype)
        {

        case SidTypeUser:
        case SidTypeGroup:
        case SidTypeAlias:
        case SidTypeDomain:
        case SidTypeDeletedAccount:
        case SidTypeUnknown:
        case SidTypeInvalid:
            //
            //  If the domain SIDs are pointing at the same domain, then
            //  don't prefix the alias, otherwise prefix it.
            //
            err = NT_ACCOUNTS_UTILITY::BuildQualifiedAccountName(
                                        &nlsQualifiedAccountName,
                                        nlsAccountName,
                                        psidDomainToQualify,
                                        nlsDomainDisplayName,
                                        &nlsFullName,
                                        psidSamDomainFocus,
                                        sidtype ) ;

            break;

        case SidTypeWellKnownGroup:
            /* Well known SIDs should never be prefixed by domains
             */
            err = nlsQualifiedAccountName.CopyFrom( nlsAccountName ) ;
            break;

        default:
            break;
        }

        if ( err )
        {
            break ;
        }

        //
        // Note that I_AppendToSTRLIST does nothing if the
        // strlist pointer is NULL
        //

        if (   (err = I_AppendToSTRLIST( pstrlistQualifiedNames,
                                         nlsQualifiedAccountName )) != NERR_Success
            || (err = I_AppendToSTRLIST( pstrlistAccountNames,
                                         nlsAccountName )) != NERR_Success
            || (err = I_AppendToSTRLIST( pstrlistFullNames,
                                         nlsFullName )) != NERR_Success
            || (err = I_AppendToSTRLIST( pstrlistComments,
                                         nlsComment )) != NERR_Success
            || (err = I_AppendToSTRLIST( pstrlistDomainNames,
                                         nlsDomainDisplayName )) != NERR_Success
           )
        {
            DBGEOL("NT_ACCOUNTS_UTILITY::GetQualifiedAccountName"
                   << ", error " << err
                   << " copying strings to STRLISTs" );
            break;
        }

    } // loop i=0 to lsatnm.QueryCount()-1

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\ossid.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    Ossid.cxx

    This file contains wrapper classes for the Win32 SID structure.

    FILE HISTORY:
        Johnl   04-May-1992     Broke off from security.cxx

*/

#include "pchlmobj.hxx"  // Precompiled header


#ifndef max
#define max(a,b)   ((a)>(b)?(a):(b))
#endif

/* The initial allocation size for an NT SID.  The basic structure plus
 * seven sub-authorities (what most users will have).
 */
#define STANDARD_SID_SIZE  (sizeof(SID) + 7*sizeof(ULONG))

/*******************************************************************

    NAME:       OS_OBJECT_WITH_DATA::OS_OBJECT_WITH_DATA

    SYNOPSIS:   Constructor/Destructor for this class

    ENTRY:      cbInitSize - Initial size of the class buffer

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   11-Dec-1991     Created

********************************************************************/

OS_OBJECT_WITH_DATA::OS_OBJECT_WITH_DATA( UINT cbInitSize )
    : BASE(),
      _buffOSData( cbInitSize )
{
    if ( QueryError() )
        return ;

    if ( _buffOSData.QueryError() )
        ReportError( _buffOSData.QueryError() ) ;
}

OS_OBJECT_WITH_DATA::~OS_OBJECT_WITH_DATA()
{
    Resize( 0 ) ;
}

/*******************************************************************

    NAME:       OS_SID::OS_SID

    SYNOPSIS:   Constructor/Destructor for the OS_SID class

    ENTRY:      psid - Pointer to valid SID this OS_SID will operate on
                       (optionally copies the SID) or NULL if we are
                       creating a SID from scratch.
                fCopy - Set to FALSE if *psid should not be copied, TRUE
                       if *psid should be copied.

    EXIT:       The SID will be initialized (if appropriate) and validated.
                A construction error of ERROR_INVALID_PARAMETER will be
                set if an invalid SID is passed in.

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   12-Dec-1991     Created

********************************************************************/

OS_SID::OS_SID( PSID psid,
                BOOL fCopy,
                OS_SECURITY_DESCRIPTOR * pOwner )
    : OS_OBJECT_WITH_DATA( (UINT)((psid == NULL) || fCopy ? STANDARD_SID_SIZE : 0 )),
      _psid( NULL ),
      _pOwner( pOwner )
{
    if ( QueryError() )
        return ;

    _psid = (psid == NULL ? (PSID) QueryPtr() : psid ) ;

    if ( psid == NULL )
    {
        /* We are using our internal memory for the SID, so initialize
         * it appropriately.
         */
        UIASSERT( !fCopy ) ;
        OS_SID::InitializeMemory( (void *) _psid ) ;
        UIASSERT( IsValid() ) ;
    }
    else
    {
        /* The user passed us a SID, check to see if it is valid.
         */
        if ( !IsValid() )
        {
            UIASSERT(!SZ("Invalid SID!")) ;
            ReportError( ERROR_INVALID_PARAMETER ) ;
            return ;
        }

        if ( fCopy )
        {
            APIERR err = Resize( (UINT) ::GetLengthSid( psid ) ) ;
            if ( err )
            {
                _psid = NULL ;
                ReportError( err ) ;
                return ;
            }

            _psid = (PSID) QueryPtr() ;
            UIASSERT( !IsOwnerAlloc() ) ;

            /* QueryAllocSize contains the size of our memory chunk because
             * we know we aren't OwnerAlloced at this point.
             */
            if (!::CopySid( QueryAllocSize(), (PSID) *this, psid ) )
            {
                ReportError( ::GetLastError() ) ;
                return ;
            }
        }
    }

    UIASSERT( IsValid() ) ;
}

OS_SID::OS_SID( PSID  psidDomain,
                ULONG ridAccount,
                OS_SECURITY_DESCRIPTOR * pOwner )
    : OS_OBJECT_WITH_DATA( ::GetLengthSid( psidDomain ) + sizeof(ridAccount)),
      _psid( NULL ),
      _pOwner( pOwner )
{
    if ( QueryError() )
        return ;

    APIERR err = NERR_Success ;

    do { // Error breakout

        if ( !::IsValidSid( psidDomain ) )
        {
            DBGEOL(SZ("OS_SID::OS_SID - Invalid domain SID")) ;
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        _psid = (PSID) QueryPtr() ;
        if ( !::CopySid( QueryAllocSize(), _psid, psidDomain ))
        {
            err = ::GetLastError() ;
            break ;
        }

        /* Get the sub-authority count field and increment it by one, then
         * set the last sub-authority to be the user's RID.
         */
        UCHAR * pcSubAuthorities ;
        if ( err = QuerySubAuthorityCount( &pcSubAuthorities ))
        {
            DBGEOL(SZ("OS_SID::OS_SID - Error getting sub-authority count")) ;
            break ;
        }
        (*pcSubAuthorities)++ ;

        ULONG * pulSubAuthority ;
        if ( err = QuerySubAuthority( *pcSubAuthorities-1, &pulSubAuthority ))
        {
            DBGEOL(SZ("OS_SID::OS_SID - Error getting sub-authority count")) ;
            break ;
        }

        *pulSubAuthority = ridAccount ;
    } while (FALSE) ;

    if ( err )
    {
        ReportError( err ) ;
    }
    else
    {
        UIASSERT( IsValid() ) ;
    }
}



OS_SID::~OS_SID()
{
    _psid = NULL ;
}

/*******************************************************************

    NAME:       OS_SID::InitializeMemory

    SYNOPSIS:   The static method initializes a chunk of memory as a
                static valid SID.

    ENTRY:      pMemToInitAsSID - Pointer to memory that will contain
                    the SID.  It should be at lease STANDARD_SID_SIZE bytes.

    EXIT:       The memory can be used as a blank SID.

    NOTES:

    HISTORY:
        Johnl   12-Dec-1991     Created

********************************************************************/

void OS_SID::InitializeMemory( void * pMemToInitAsSID )
{
    UIASSERT( pMemToInitAsSID != NULL ) ;

    /* BUGBUG - probably isn't safe, make it static or something
     */
    SID_IDENTIFIER_AUTHORITY sidIDAuthority ;
    UCHAR achIDAuthority[] = SECURITY_NULL_SID_AUTHORITY ;
    for ( int i = 0 ; i < 6 ; i++ )
    {
        sidIDAuthority.Value[i] = achIDAuthority[i] ;
    }

    /* Initialize SID
     */
    ::InitializeSid( (PSID) pMemToInitAsSID,
                     &sidIDAuthority,
                     0 ) ;
}

/*******************************************************************

    NAME:       OS_SID::IsValid

    SYNOPSIS:   Checks the validity of this SID

    RETURNS:    Returns TRUE if the OS thinks we contain a valid SID,
                FALSE otherwise.

    NOTES:

    HISTORY:
        Johnl   12-Dec-1991     Created

********************************************************************/

BOOL OS_SID::IsValid( void ) const
{
    return !QueryError() && ::IsValidSid( _psid ) ;
}

/*******************************************************************

    NAME:       OS_SID::QueryLength

    SYNOPSIS:   Gets the amount of memory this SID occupies

    RETURNS:    Returns the count of bytes this SID uses or 0 if the
                SID is not valid.

    NOTES:

    HISTORY:
        Johnl   10-Feb-1992     Created

********************************************************************/

ULONG OS_SID::QueryLength( void ) const
{
    if ( !IsValid() )
        return 0 ;

    return ::GetLengthSid( (PSID) *this) ;
}


/*******************************************************************

    NAME:       OS_SID::QueryRawID

    SYNOPSIS:   Places the text string of the Identifier Authority into
                *pnlsRawID. The text string will look something like "1-5-17"

    ENTRY:      pnlsRawID - Pointer to NLS_STR that will receive the string

    EXIT:

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:      CODEWORK - Change to use new Rtl routine

    HISTORY:
        Johnl   12-Dec-1991     Created
        beng    05-Mar-1992     Replaced wsprintf

********************************************************************/

APIERR OS_SID::QueryRawID( NLS_STR * pnlsRawID ) const
{
    UIASSERT( IsValid() ) ;
    APIERR err ;
    UNICODE_STRING UniStr ;

    if ( (err = ERRMAP::MapNTStatus( ::RtlConvertSidToUnicodeString(
                                                         &UniStr,
                                                         QueryPSID(),
                                                         TRUE ))) ||
         (err = pnlsRawID->MapCopyFrom( UniStr.Buffer,
                                        UniStr.Length)) )
    {
        /* Fall through
         */
    }

    if ( !err )
    {
        ::RtlFreeUnicodeString( &UniStr ) ;
    }

    return err ;
}

/*******************************************************************

    NAME:       OS_SID::QueryName

    SYNOPSIS:   Retrieves the User/Group name from user accounts database
                that is associated with this SID.

                The name *may* come back with a domain qualifier also (TBD).

    ENTRY:      pnlsName - NLS_STR that will receive the text string,
                pszServer - Machine to lookup account on
                pszFocus  - What machine is considered to have the "focus"
                    If NULL, then the focus is assumed to be pszServer.

    EXIT:

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      pszFocus is used to determine the correct domain name
                qualification.  It should contain a server name (in the
                form of "\\server") that has the focus.  If the focus is
                on a domain, then it should contain a BDC or PDC for that
                domain.

                What the above means is that if pszServer is different from
                pszFocus, then the returned name will probably be qualified
                by a domain name (i.e., "NtLan\Johnl").

    HISTORY:
        Johnl   12-Dec-1991     Created
        Johnl   17-Jul-1992     Added server parameter and real lookup

********************************************************************/

APIERR OS_SID::QueryName( NLS_STR * pnlsName,
                          const TCHAR * pszServer,
                          PSID psidFocusedDomain ) const
{
    APIERR err ;
    PSID apsid[1] ;
    STRLIST strlistNames ;

    API_SESSION APISessionTarget( pszServer ) ;
    LSA_POLICY  LSAPolicyTarget( pszServer ) ;
    OS_SID      ossidFocusedDomain( psidFocusedDomain ) ;
    apsid[0] = (PSID) *this ;

    if ((err = APISessionTarget.QueryError())  ||
        (err = LSAPolicyTarget.QueryError())   ||
        (err = ossidFocusedDomain.QueryError())  )
    {
        DBGEOL("OS_SID::QueryName - Error " << (ULONG) err
                << " returned from LSAPolicy") ;
        return err ;
    }

    //
    //  If we weren't given a focused domain SID to qualify the name with,
    //  then use the current user's domain SID.
    //

    if ( psidFocusedDomain == NULL )
    {
        if ( (err = NT_ACCOUNTS_UTILITY::QuerySystemSid(
                                                  UI_SID_CurrentProcessUser,
                                                  &ossidFocusedDomain )) ||
             (err = ossidFocusedDomain.TrimLastSubAuthority()) )
        {
            return err ;
        }
    }


    if ((err = NT_ACCOUNTS_UTILITY::GetQualifiedAccountNames(
                                      LSAPolicyTarget,
                                      ossidFocusedDomain.QueryPSID(),
                                      apsid,
                                      1,
                                      TRUE,
                                      &strlistNames,
                                      NULL,
                                      NULL,
                                      NULL,
                                      pszServer )))
    {
        DBGEOL("OS_SID::QueryName - Error " << (ULONG) err
                << " returned from GetQualifiedAccountNames") ;
        return err ;
    }

    /* Set each of the account names to the looked up name
     */
    ITER_STRLIST iterNames( strlistNames ) ;
    NLS_STR * pnlsNameTmp ;
    if ( (pnlsNameTmp = iterNames.Next()) == NULL )
    {
        /* If everything succeeded, then there should always be at least
         * one name in the strlist.
         */
        UIASSERT( FALSE ) ;
        return ERROR_INVALID_PARAMETER ;
    }

    return pnlsName->CopyFrom( *pnlsNameTmp ) ;
}

#if 0
/*******************************************************************

    NAME:       OS_SID::QueryName

    SYNOPSIS:   Retrieves the User/Group name from user accounts database
                that is associated with this SID.

    ENTRY:      pnlsName - NLS_STR that will receive the text string,
                pszServer - Machine to lookup account on
                pszFocus  - What machine is considered to have the "focus"
                    If NULL, then the focus is assumed to be pszServer.

    EXIT:

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      pszFocus is used to determine the correct domain name
                qualification.  It should contain a server name (in the
                form of "\\server") that has the focus.  If the focus is
                on a domain, then it should contain a BDC or PDC for that
                domain.

                What the above means is that if pszServer is different from
                pszFocus, then the returned name will probably be qualified
                by a domain name (i.e., "NtLan\Johnl").

    CAVEAT:     This method creates an LSA_POLICY and SAM_DOMAIN to get the
                domain SID.  It is very preferable to use the other version
                of QueryName that accepts a PSID for the focus.

    HISTORY:
        Johnl   12-Dec-1991     Created
        Johnl   17-Jul-1992     Added server parameter and real lookup

********************************************************************/

APIERR OS_SID::QueryName( NLS_STR * pnlsName,
                          const TCHAR * pszServer,
                          const TCHAR * pszFocus ) const
{
    APIERR err ;
    if ( pszFocus == NULL )
        pszFocus = pszServer ;

    API_SESSION APISessionFocus ( pszFocus  ) ;
    LSA_ACCT_DOM_INFO_MEM LSAAcctDomInfoMem ;
    LSA_POLICY LSAPolicyFocus( pszFocus ) ;
    SAM_SERVER SAMServer( pszFocus ) ;

    if ((err = APISessionFocus.QueryError())   ||
        (err = LSAAcctDomInfoMem.QueryError()) ||
        (err = LSAPolicyFocus.QueryError())    ||
        (err = LSAPolicyFocus.GetAccountDomain( &LSAAcctDomInfoMem )) ||
        (err = SAMServer.QueryError()) )
    {
        DBGEOL("OS_SID::QueryName - Error " << (ULONG) err
                << " returned from SAMServer or LSAPolicy") ;
        return err ;
    }

    SAM_DOMAIN SAMDomain( SAMServer, LSAAcctDomInfoMem.QueryPSID() ) ;
    if ((err = SAMDomain.QueryError()) ||
        (err = QueryName( pnlsName, pszServer, SAMDomain.QueryPSID() )) )
    {
        /* Fall through
         */
    }

    return err ;
}

#endif

/*******************************************************************

    NAME:       OS_SID::QuerySubAuthority

    SYNOPSIS:   Retrieves a pointer to the requested sub-authority

    ENTRY:      iSubAuthority - Sub-authority index to retrieve
                ppulSubAuthority - Pointer to a pointer of the sub-authority
                    requested

    EXIT:       ppulSubAuthority will point to the request subauthority

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:      The API GetSidSubAuthority does not return an error code,
                thus this method could fail and still return success.

    HISTORY:
        Johnl   16-Mar-1992     Created

********************************************************************/

APIERR OS_SID::QuerySubAuthority( UCHAR iSubAuthority,
                                  PULONG * ppulSubAuthority ) const
{
    *ppulSubAuthority = ::GetSidSubAuthority( _psid, iSubAuthority ) ;
    return NERR_Success ;
}

/*******************************************************************

    NAME:       QuerySubAuthorityCount

    SYNOPSIS:   Retrieves a pointer to the sub-authority count field

    ENTRY:      ppucSubAuthority - Pointer to a pointer of the sub-authority
                    count field

    EXIT:       ppcSubAuthority will point to the sub-authority count field

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:      The API GetSidSubAuthorityCount does not return an error code,
                thus this method could fail and still return success.

    HISTORY:
        Johnl   16-Mar-1992     Created

********************************************************************/

APIERR OS_SID::QuerySubAuthorityCount( UCHAR * * ppcSubAuthority ) const
{
    *ppcSubAuthority = ::GetSidSubAuthorityCount( _psid ) ;
    return NERR_Success ;
}

/*******************************************************************

    NAME:       QueryLastSubAuthority

    SYNOPSIS:   Retrieves a pointer to the last sub-authority, which is
                the RID for SIDS which have RIDs.

    EXIT:       *ppulrid will point to the last sub-authority

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:      The API GetSidSubAuthorityCount does not return an error code,
                thus this method could fail and still return success.

    HISTORY:
        JonN    30-Oct-1992     Created

********************************************************************/

APIERR OS_SID::QueryLastSubAuthority( PULONG * ppulSubAuthority ) const
{
    ASSERT( ppulSubAuthority != NULL );
    UCHAR * pcSubAuthorityCount = NULL;
    APIERR err = QuerySubAuthorityCount( &pcSubAuthorityCount );
    if ( err == NERR_Success )
    {
        ASSERT( pcSubAuthorityCount != NULL );
        err = QuerySubAuthority( (*pcSubAuthorityCount)-1, ppulSubAuthority );
    }
    return err ;
}

/*******************************************************************

    NAME:       TrimLastSubAuthority

    SYNOPSIS:   Removes the last SubAuthority.  This will change user,
                group and alias SIDs into the SID for their domain.

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:      The API GetSidSubAuthorityCount does not return an error code,
                thus this method could fail and still return success.

    HISTORY:
        JonN    04-Nov-1992     Created
        JonN    17-Nov-1992     Added pulLastSubAuthority param

********************************************************************/

APIERR OS_SID::TrimLastSubAuthority( ULONG * pulLastSubAuthority )
{
    UCHAR * pcSubAuthorityCount = NULL;
    APIERR err = QuerySubAuthorityCount( &pcSubAuthorityCount );
    if ( err == NERR_Success )
    {
        ASSERT( pcSubAuthorityCount != NULL );
        ASSERT( *pcSubAuthorityCount > 0 );
        if ( *pcSubAuthorityCount > 0 )
        {
            if (pulLastSubAuthority != NULL)
            {
                PULONG pulTempLastSubAuthority;
                err = QuerySubAuthority( (*pcSubAuthorityCount)-1,
                                         &pulTempLastSubAuthority );
                if (err == NERR_Success)
                {
                    *pulLastSubAuthority = *pulTempLastSubAuthority;
                }
            }

            (*pcSubAuthorityCount)--;
        }
    }
    return err ;
}

/*******************************************************************

    NAME:       OS_SID::operator==

    SYNOPSIS:   Checks for equality between two SIDs

    ENTRY:      ossid - SID to compare *this to

    EXIT:

    RETURNS:    Returns TRUE if the SIDs are equal, FALSE if they are unequal
                or invalid.

    NOTES:

    HISTORY:
        Johnl   12-Dec-1991     Created

********************************************************************/

BOOL OS_SID::operator==( const OS_SID & ossid ) const
{
    if ( !IsValid() || !ossid.IsValid() )
    {
        UIASSERT(!SZ("Attempted to compare an invalid SID")) ;
        return FALSE ;
    }

    return ::EqualSid( QuerySid(), ossid.QuerySid() ) ;
}

/*******************************************************************

    NAME:       OS_SID::Copy

    SYNOPSIS:   Copies the source SID to *this if there is enough size

    ENTRY:      ossid - SID to copy into *this

    EXIT:

    RETURNS:    NERR_Success if successful, error code otherwise
                ERROR_INSUFFICIENT_BUFFER is returned if this is an
                owner alloced SID and the source SID will not fit.

    NOTES:

    HISTORY:
        Johnl   26-Dec-1991     Created

********************************************************************/

APIERR OS_SID::Copy( const OS_SID & ossid )
{
    ULONG cbSrcSidSize = ::GetLengthSid( (PSID)ossid ) ;
    ULONG cbDestBuffSize = 0 ;

    if ( QueryError() )
        return QueryError() ;

    if ( IsOwnerAlloc() )
    {
        /* If there isn't enough space in a SID that we don't own the
         * memory for, then we return an error.
         */
        cbDestBuffSize = ::GetLengthSid( (PSID)*this ) ;
        if ( cbSrcSidSize > cbDestBuffSize )
            return ERROR_INSUFFICIENT_BUFFER ;
    }
    else
    {
        /* Check if we have to realloc our memory to fit the new SID size.
         */
        cbDestBuffSize = QueryAllocSize() ;
        if ( cbSrcSidSize > cbDestBuffSize )
        {
            /* SIDs shouldn't get larger then 256 bytes
             */
            APIERR err ;
            if ( err = Resize( (UINT) cbSrcSidSize ))
                return err ;

            _psid = (PSID) QueryPtr() ;

            /* If this SID is part of a security descriptor, update our
             * security descriptor with our new memory location.
             */
            if ( _pOwner != NULL )
            {
                if ( err = _pOwner->UpdateReferencedSecurityObject( this ))
                {
                    return err ;
                }
            }

            /* We have a new destination buffer size now.
             */
            cbDestBuffSize = QueryAllocSize() ;
        }
    }

    if ( !::CopySid( cbDestBuffSize, (PSID) *this, (PSID) ossid ) )
        return ::GetLastError() ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_SID::SetPtr

    SYNOPSIS:   Points this OS_SID at a new SID

    ENTRY:      psid - Memory to use as new SID

    EXIT:       *this will now operate on the sid pointed at by psid

    RETURNS:    NERR_Success if everything is valid, error code otherwise

    NOTES:

    HISTORY:
        Johnl   17-Dec-1991     Created

********************************************************************/

APIERR OS_SID::SetPtr( PSID psid )
{
    if ( !::IsValidSid( psid ) )
        return ERROR_INVALID_PARAMETER ;

    _psid = psid ;

    UIASSERT( IsValid() ) ;
    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_SID::_DbgPrint

    SYNOPSIS:   Takes apart this SID and outputs it to cdebug

    ENTRY:

    NOTES:      Doesn't print sub-authorities, can be modified to do so

    HISTORY:
        Johnl   30-Dec-1991     Created

********************************************************************/

void OS_SID::_DbgPrint( void ) const
{
#if defined(DEBUG)
    APIERR err ;
    cdebug << SZ("\tIsOwnerAlloc      = ") << (IsOwnerAlloc() ? SZ("TRUE") : SZ("FALSE")) << dbgEOL ;
    if ( !IsOwnerAlloc() )
        cdebug << SZ("\tQueryAllocSize    = ") << QueryAllocSize() << dbgEOL ;
    cdebug << SZ("\tLength of SID     = ") << ::GetLengthSid( (PSID)*this ) << dbgEOL ;
    cdebug << SZ("\tIsValid           = ") << (IsValid() ? SZ("TRUE") : SZ("FALSE")) << dbgEOL ;

    NLS_STR nlsRawID(10) ;
    if ( err = QueryRawID( &nlsRawID ) )
        cdebug << SZ("\tQueryRawID returned error ") << err << dbgEOL ;
    else
        cdebug << SZ("\tQueryRawID        = ") << (const TCHAR *) nlsRawID << dbgEOL ;

#if 0
    NLS_STR nlsName(50) ;
    if ( err = QueryName( &nlsName ) )
        cdebug << SZ("\tQueryName returned error ") << err << dbgEOL ;
    else
        cdebug << SZ("\tQueryName         = ") << (const TCHAR *) nlsName << dbgEOL ;
#endif

    UCHAR * pcSubAuthorities ;
    if ( err = QuerySubAuthorityCount( &pcSubAuthorities ) )
        cdebug << SZ("\tQuerySubAuthorityCount returned error ") << err << dbgEOL ;
    else
        cdebug << SZ("\tQuerySubAuthorityCount = ") << (UINT) *pcSubAuthorities << dbgEOL ;
#endif  // DEBUG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\security.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    Security.cxx

    This file contains wrapper classes for the Win32 security structures.
    Specifically: ACE, ACL, SECURITY_DESCRIPTOR,
    and SECURITY_DESCRIPTOR_CONTROL.

    The wrapper classes follow the same name except the class
    names will begin with an "OS_".

    FILE HISTORY:
        Johnl   11-Dec-1991     Created
        JohnL   09-Mar-1992     Code review changes
        JohnL   04-May-1992     Moved OS_SID out to its own file

*/

#include "pchlmobj.hxx"  // Precompiled header


#ifndef max
#define max(a,b)   ((a)>(b)?(a):(b))
#endif

/* The initial allocation size for an NT SID
 */
#define STANDARD_SID_SIZE  (sizeof(SID))

/* Initial allocation size of a basic *known* ACE.
 * Note that the SID is variable length, thus this number
 * is only a starting point.
 */
#define STANDARD_ACE_SIZE  (max(sizeof(ACCESS_ALLOWED_ACE),     \
                            max(sizeof(ACCESS_DENIED_ACE),      \
                            max(sizeof(SYSTEM_AUDIT_ACE),       \
                                sizeof(SYSTEM_ALARM_ACE)) ))    \
                            - sizeof(ULONG) + STANDARD_SID_SIZE)

/* Initial allocation size of an NT ACL (room for 1 ACE)
 */
#define STANDARD_ACL_SIZE  (sizeof(ACL) + STANDARD_ACE_SIZE)

/*******************************************************************

    NAME:       OS_ACE::OS_ACE

    SYNOPSIS:   Standard constructor and destructor

    ENTRY:      pACE - Pointer to valid ACE or NULL.  If pACE is non-NULL,
                it should point to a valid ACE we can operate on (all
                operations except anything that causes expansion).  If
                pACE is NULL, then we allocate the memory locally.

    EXIT:

    RETURNS:

    NOTES:      This ACE defaults to an ACCESS_DENIED_ACE_TYPE if pACE
                is NULL.  Note that QuerySIDMemory may break if the
                different ACE sizes ever differ (we key off the type so
                we use the correct cast, however if the ace type is
                different and has a different SID offset, then the
                wrong portion of memory will be initialized by QuerySIDMemory.

                Note that there is no ::IsValidAce API, thus we can only
                check the SID for validity.

    HISTORY:
        Johnl   13-Dec-1991     Created

********************************************************************/

OS_ACE::OS_ACE( void * pACE )
    : OS_OBJECT_WITH_DATA( (UINT)(pACE == NULL ? STANDARD_ACE_SIZE : 0 )),
      _pACEHeader( NULL ),
      _possid( NULL )
{
    if ( QueryError() )
        return ;

    _pACEHeader = (PACE_HEADER) (pACE == NULL ? QueryPtr() : pACE ) ;

    APIERR err ;

    if ( pACE == NULL )
    {
        /* Initialize the whole chunk of memory to zeros
         */
        ::memsetf( QueryPtr(), 0, QueryAllocSize() ) ;

        _pACEHeader->AceSize = (USHORT)QueryAllocSize() ;
        _pACEHeader->AceType = ACCESS_DENIED_ACE_TYPE ;

        /* Rather then do a switch on each ACE type when we know they all look
         * the same, we will make sure all of the fields resolve to the same
         * address and just query off of one ACE type.
         */
        UIASSERT(  (((void*)&((ACCESS_ALLOWED_ACE*)QueryACE())->SidStart) ==
                    ((void*)&((ACCESS_DENIED_ACE*)QueryACE())->SidStart)    ) &&
                    (((void*)&((ACCESS_ALLOWED_ACE*)QueryACE())->SidStart) ==
                    ((void*)&((SYSTEM_AUDIT_ACE*)QueryACE())->SidStart)    )  &&
                    (((void*)&((ACCESS_ALLOWED_ACE*)QueryACE())->SidStart) ==
                    ((void*)&((SYSTEM_ALARM_ACE*)QueryACE())->SidStart)      )) ;

        /* Initialize SID portion of this ACE
         */
        OS_SID::InitializeMemory( (void *) QuerySIDMemory() ) ;
    }

    if ( !IsKnownACE() )
    {
        DBGEOL(SZ("OS_ACE::ct - Attempted to add an unkown ACE type")) ;
        ReportError( ERROR_INVALID_PARAMETER ) ;
        return ;
    }

    _possid = new OS_SID( (PSID) QuerySIDMemory() ) ;
    if ( err = ( _possid==NULL ? ERROR_NOT_ENOUGH_MEMORY : _possid->QueryError()))
    {
        ReportError( err ) ;
        return ;
    }

    /* Rather then do a switch on each ACE type when we know they all look
     * the same, we will make sure all of the fields resolve to the same
     * address and just query off of one ACE type.
     */
     UIASSERT(  (((void*)&((ACCESS_ALLOWED_ACE*)QueryACE())->Mask) ==
                 ((void*)&((ACCESS_DENIED_ACE*)QueryACE())->Mask)     ) &&
                (((void*)&((ACCESS_ALLOWED_ACE*)QueryACE())->Mask) ==
                 ((void*)&((SYSTEM_AUDIT_ACE*)QueryACE())->Mask)      )  &&
                (((void*)&((ACCESS_ALLOWED_ACE*)QueryACE())->Mask) ==
                 ((void*)&((SYSTEM_ALARM_ACE*)QueryACE())->Mask)      )) ;

    UIASSERT( _possid->IsValid() ) ;
}

OS_ACE::~OS_ACE()
{
    delete _possid ;
    _possid = NULL ;
    _pACEHeader = NULL ;
}

/*******************************************************************

    NAME:       OS_ACE::QueryAccessMask

    SYNOPSIS:   Gets the access mask of this ACE

    ENTRY:

    EXIT:

    RETURNS:    Returns the ACCESS_MASK bitfield of this ACE

    NOTES:

    HISTORY:
        Johnl   14-Dec-1991     Created

********************************************************************/

ACCESS_MASK OS_ACE::QueryAccessMask( void ) const
{
    UIASSERT( IsKnownACE() ) ;

    return ((ACCESS_ALLOWED_ACE*)QueryACE())->Mask ;
}


/*******************************************************************

    NAME:       OS_ACE::QuerySID

    SYNOPSIS:   Retrieves a pointer to the OS_SID of this ACE

    ENTRY:      ppossid - Pointer that will receive the pointer to the
                OS_SID

    EXIT:       ppossid will contain the pointer to this ACE's OS_SID

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   16-Dec-1991     Created

********************************************************************/

APIERR OS_ACE::QuerySID( OS_SID * * ppossid ) const
{
    if ( !IsKnownACE() )
    {
        UIASSERT(!SZ("QuerySID on unknown ACE")) ;
        return ERROR_INVALID_PARAMETER ;
    }

    *ppossid = _possid ;
    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_ACE::QuerySIDMemory

    SYNOPSIS:


    EXIT:

    RETURNS:    Returns a pointer to the memory in this ACE that the
                SID resides

    NOTES:

    HISTORY:
        Johnl   13-Dec-1991     Created

********************************************************************/

void * OS_ACE::QuerySIDMemory( void ) const
{
    UIASSERT( IsKnownACE() ) ;

    return &((ACCESS_ALLOWED_ACE*)QueryACE())->SidStart ;
}

/*******************************************************************

    NAME:       OS_ACE::QueryRevision

    SYNOPSIS:   Returns the revision level of the ACEs supported by this
                class

    EXIT:

    RETURNS:    The current revision list

    NOTES:

    HISTORY:
        Johnl   17-Dec-1991     Created

********************************************************************/

ULONG OS_ACE::QueryRevision()
{
    return ACL_REVISION2 ;
}

/*******************************************************************

    NAME:       OS_ACE::SetAccessMask

    SYNOPSIS:   Sets the access permission mask for this ACE

    ENTRY:      accmask - New value of the permission mask for this ACE

    RETURNS:

    NOTES:      This method can only be used on known ace types

    HISTORY:
        Johnl   16-Dec-1991     Created

********************************************************************/

void OS_ACE::SetAccessMask( ACCESS_MASK accmask )
{
    if ( !IsKnownACE() )
    {
        UIASSERT( FALSE ) ;
        return ;
    }

    ((ACCESS_ALLOWED_ACE*)QueryACE())->Mask = accmask ;
}

/*******************************************************************

    NAME:       OS_ACE::SetSize

    SYNOPSIS:   Sets the size field on this ACE and resizes the memory
                block if necessary.

    ENTRY:      cbSize - New size of this ACE to set

    EXIT:

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   16-Dec-1991     Created

********************************************************************/

APIERR OS_ACE::SetSize( UINT cbSize )
{
    UIASSERT( IsKnownACE() ) ;
    UIASSERT( IsOwnerAlloc() ||
              (!IsOwnerAlloc() && QuerySize() <= QueryAllocSize())) ;

    if ( IsOwnerAlloc() )
    {
        if ( cbSize > QuerySize() )
        {
            DBGEOL(SZ("OS_ACE::SetSize - not enough room in buffer for requested size")) ;
            return ERROR_INSUFFICIENT_BUFFER ;
        }
    }
    else if ( QueryAllocSize() < cbSize )
    {
        APIERR err = Resize( cbSize ) ;
        if ( err != NERR_Success )
            return err ;

        /* The memory block's contents will be preserved across the Resize
         * call, so just watch out for a new pointer.
         */
        if ( err = SetPtr( (PACE_HEADER) QueryPtr() ))
        {
            return err ;
        }
    }

    _pACEHeader->AceSize = (USHORT)cbSize ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_ACE::SetSID

    SYNOPSIS:   Sets the SID of this ACE

    ENTRY:      ossid - SID to copy to this ACE

    EXIT:       NERR_Success if successful, error code otherwise

    RETURNS:

    NOTES:      If there isn't enough room to fit the SID in this ACE and
                the ACE is owner alloced, then ERROR_INSUFFICIENT_BUFFER
                will be returned.

    HISTORY:
        Johnl   10-Jan-1992     Created

********************************************************************/

APIERR OS_ACE::SetSID( const OS_SID & ossid )
{
    UIASSERT( IsKnownACE() ) ;
    UIASSERT( IsOwnerAlloc() ||
              (!IsOwnerAlloc() && QuerySize() <= QueryAllocSize())) ;

    /* Figure the total memory we have to work with to see if we can shoehorn
     * the SID into the ACE.
     */
    ULONG cbSizeOfConstantPortion = (ULONG)((BYTE *)QuerySIDMemory() - (BYTE *)QueryPtr()) ;
    ULONG cbMemoryFreeForSID = (ULONG) QuerySize() - cbSizeOfConstantPortion ;


    if ( ossid.QueryLength() > cbMemoryFreeForSID )
    {
        if ( IsOwnerAlloc() )
        {
            return ERROR_INSUFFICIENT_BUFFER ;
        }
        else
        {
            APIERR err = SetSize( (UINT) (cbSizeOfConstantPortion + ossid.QueryLength()) ) ;
            if ( err != NERR_Success )
                return err ;
        }
    }

    ::memcpyf( QuerySIDMemory(), (PSID) ossid, (UINT) ossid.QueryLength() ) ;
    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_ACE::SetPtr

    SYNOPSIS:   Points this OS_ACE at a new ACE

    ENTRY:      pace - Memory to use as new ACE

    EXIT:       *this will now operate on the ace pointed at by pace

    RETURNS:    NERR_Success if everything is valid, error code otherwise

    NOTES:

    HISTORY:
        Johnl   17-Dec-1991     Created

********************************************************************/
APIERR OS_ACE::SetPtr( void * pace )
{
    _pACEHeader = (PACE_HEADER) pace ;

    APIERR err = _possid->SetPtr( QuerySIDMemory() ) ;

    return err ;
}

/*******************************************************************

    NAME:       OS_ACE::_DbgPrint

    SYNOPSIS:   Takes apart this ACE and outputs it to cdebug

    ENTRY:

    NOTES:

    HISTORY:
        Johnl   30-Dec-1991     Created

********************************************************************/

void OS_ACE::_DbgPrint( void ) const
{
#if defined(DEBUG)

    APIERR err ;
    cdebug << SZ("\tIsOwnerAlloc      = ") << (IsOwnerAlloc() ? SZ("TRUE") : SZ("FALSE")) << dbgEOL ;
    cdebug << SZ("\tQuerySize         = ") << QuerySize() << dbgEOL ;
    cdebug << SZ("\tIsKnownACE        = ") << (IsKnownACE()  ? SZ("TRUE") : SZ("FALSE")) << dbgEOL ;
    cdebug << SZ("\tQueryAceFlags     = ") << (HEX_STR)((ULONG) QueryAceFlags()) << dbgEOL ;
    cdebug << SZ("\t\tIsInherittedByNewObjects    = ") << (IsInherittedByNewObjects() ? SZ("TRUE") : SZ("FALSE")) << dbgEOL ;
    cdebug << SZ("\t\tIsInherittedByNewContainers = ") << (IsInherittedByNewContainers() ? SZ("TRUE") : SZ("FALSE")) << dbgEOL ;
    cdebug << SZ("\t\tIsInheritancePropagated     = ") << (IsInheritancePropagated() ? SZ("TRUE") : SZ("FALSE")) << dbgEOL ;
    cdebug << SZ("\t\tIsInheritOnly               = ") << (IsInheritOnly() ? SZ("TRUE") : SZ("FALSE")) << dbgEOL ;

    cdebug << SZ("\tAceType           = ") << (UINT) QueryType() << SZ("  ");
    switch ( QueryType() )
    {
    case ACCESS_ALLOWED_ACE_TYPE:
        cdebug << SZ("(ACCESS_ALLOWED_ACE_TYPE)") ;
        break ;

    case ACCESS_DENIED_ACE_TYPE:
        cdebug << SZ("(ACCESS_DENIED_ACE_TYPE)") ;
        break ;

    case SYSTEM_AUDIT_ACE_TYPE:
        cdebug << SZ("(SYSTEM_AUDIT_ACE_TYPE)") ;
        break ;

    case SYSTEM_ALARM_ACE_TYPE:
        cdebug << SZ("(SYSTEM_ALARM_ACE_TYPE)") ;
        break ;

    default:
        cdebug << SZ("(Unknown Ace Type)") ;
        return ;
    }
    cdebug << dbgEOL ;

    cdebug << SZ("\tQueryAccessMask   = ") << (HEX_STR)((ULONG)QueryAccessMask()) << dbgEOL ;

    OS_SID * possid ;
    err = QuerySID( &possid ) ;
    if ( err )
        cdebug << SZ("\tError retrieving SID, error code ") << err << dbgEOL ;
    else
    {
        cdebug << SZ("\tSID for this ACE:") << dbgEOL ;
        possid->_DbgPrint() ;
    }
#endif  // DEBUG
}

/*******************************************************************

    NAME:       OS_ACL::OS_ACL

    SYNOPSIS:   Standard constructor/destructor for the OS_ACL class

    ENTRY:      pACL - Pointer to valid ACL or NULL.  If NULL, then we
                allocate memory locally, else we assume the pointer
                points to a valid ACL.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   17-Dec-1991     Created

********************************************************************/

OS_ACL::OS_ACL( PACL pACL,
                BOOL fCopy,
                OS_SECURITY_DESCRIPTOR * pOwner )
    : OS_OBJECT_WITH_DATA( (UINT)(pACL == NULL ? STANDARD_ACL_SIZE : 0 )),
      _pACL( NULL ),
      _pOwner( pOwner )
{
    if ( QueryError() )
        return ;

    APIERR err ;
    if ( fCopy && pACL != NULL )
    {
        ACL_SIZE_INFORMATION aclsizeinfo ;
        if ( !::GetAclInformation( pACL,
                                   &aclsizeinfo,
                                   sizeof( ACL_SIZE_INFORMATION ),
                                   AclSizeInformation ))
        {
            ReportError( ::GetLastError() ) ;
            return ;
        }

        if ( err = Resize( aclsizeinfo.AclBytesInUse ) )
        {
            ReportError( err ) ;
            return ;
        }
        ::memcpy( QueryPtr(), pACL, aclsizeinfo.AclBytesInUse ) ;
    }

    _pACL = (PACL) (pACL == NULL || fCopy ? QueryPtr() : pACL )  ;
    UIASSERT( (pACL == NULL ) || ::IsValidAcl( _pACL ) ) ;

    if ( pACL == NULL )
    {
        /* Initialize the whole chunk of memory to zeros
         */
        if ( !::InitializeAcl( _pACL, QueryAllocSize(), ACL_REVISION2 ) )
        {
            ReportError( ::GetLastError() ) ;
            return ;
        }
        UIASSERT( IsValid() ) ;
    }
}

OS_ACL::~OS_ACL()
{
    _pACL = NULL ;
}

/*******************************************************************

    NAME:       OS_ACL::IsValid

    SYNOPSIS:   Checks the validity of the ACL contained in this OS_ACL

    RETURNS:    TRUE if the ACL is valid, FALSE otherwise.

    NOTES:      If FALSE is returned, GetLastError can be used to get a
                more specific error code, however I do not know how
                useful this would be.

    HISTORY:
        Johnl   17-Dec-1991     Created

********************************************************************/

BOOL OS_ACL::IsValid( void ) const
{
    return (QueryError() == NERR_Success) || ::IsValidAcl( _pACL ) ;
}

/*******************************************************************

    NAME:       OS_ACL::QuerySizeInformation

    SYNOPSIS:   Retrieves the ACL_SIZE_INFORMATION structure about this ACL

    ENTRY:      paclsizeinfo - pointer to ACL_SIZE_INFORMATION that will
                    receive the data.

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   17-Dec-1991     Created

********************************************************************/

APIERR OS_ACL::QuerySizeInformation( ACL_SIZE_INFORMATION * paclsizeinfo ) const
{
    if ( !::GetAclInformation( _pACL, paclsizeinfo,
                       sizeof( ACL_SIZE_INFORMATION ), AclSizeInformation ) )
    {
        return ::GetLastError() ;
    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_ACL::QueryBytesInUse

    SYNOPSIS:   Determines how much storage (in bytes) this ACL needs
                based on its current size.  This is different from
                the Allocated memory size (QueryAllocSize).

    ENTRY:      pcbBytesInUse - Pointer to item that will receive the
                    number of bytes used by this ACL

    EXIT:

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   17-Dec-1991     Created

********************************************************************/

APIERR OS_ACL::QueryBytesInUse( PULONG pcbBytesInUse ) const
{
    ACL_SIZE_INFORMATION aclsizeinfo ;

    APIERR err ;
    if ( err = QuerySizeInformation( &aclsizeinfo ) )
        return err ;

    *pcbBytesInUse = aclsizeinfo.AclBytesInUse ;
    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_ACL::QueryACECount

    SYNOPSIS:   Retrieves the count of ACEs in this ACL

    ENTRY:      pcAces - Pointer to variable that will receive the count of ACEs

    EXIT:

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:

    HISTORY:
        Johnl   17-Dec-1991     Created
********************************************************************/

APIERR OS_ACL::QueryACECount( PULONG pcAces ) const
{
    ACL_SIZE_INFORMATION aclsizeinfo ;

    APIERR err ;
    if ( err = QuerySizeInformation( &aclsizeinfo ) )
        return err ;

    *pcAces = aclsizeinfo.AceCount ;
    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_ACL::AddACE

    SYNOPSIS:   Adds an ACE to this ACL

    ENTRY:      iAce - Index of ACE to add, MAXULONG to append the ace
                osace - ACE to add to this ACL

    EXIT:       The ACE will be inserted at position iAce into this ACL

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      The ACE is *copied* into this ACL.  Note that you should avoid
                doing a QueryACE (which references the real ACL) then an AddACE,
                as you will have duplicate ACEs in this ACL.

    HISTORY:
        Johnl   17-Dec-1991     Created

********************************************************************/

APIERR OS_ACL::AddACE( ULONG iAce, const OS_ACE & osace )
{
    APIERR err ;

    /* Check if enough size to fit ACE, resize if necessary
     */
    ACL_SIZE_INFORMATION aclsizeinfo ;
    if ( err = QuerySizeInformation( &aclsizeinfo ) )
        return err ;

    if ( err = SetSize( (UINT) (aclsizeinfo.AclBytesInUse + osace.QuerySize())) )
        return err ;

    if ( !::AddAce( _pACL, OS_ACE::QueryRevision(),
                  iAce, osace.QueryACE(), osace.QuerySize() ))
    {
        return ::GetLastError() ;
    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_ACL::QueryACE

    SYNOPSIS:   Retrieves the ace at index iAce

    ENTRY:      iAce - Index of ACE to retrieve
                posace - Pointer to OS_ACE that will receive the reference
                    to the requested ACE.

    EXIT:       *posace will *reference* the requested ACE.

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      The ACE is not copied, it directly references the ACE that
                is in the ACL.  Thus resizing it is problematical.

                It is not recommended you keep OS_ACEs around for any
                length of time when they directly reference an ACL
                (as is the case after using QueryAce).

    HISTORY:
        Johnl   17-Dec-1991     Created

********************************************************************/

APIERR OS_ACL::QueryACE( ULONG iAce, OS_ACE * posace ) const
{
    void * pAce ;
    if ( !::GetAce( _pACL, iAce, &pAce ) )
        return ::GetLastError() ;

    return posace->SetPtr( pAce ) ;
}

/*******************************************************************

    NAME:       OS_ACL::DeleteACE

    SYNOPSIS:   Deletes an ACE from this ACL

    ENTRY:      iAce - Index of ACE to delete

    EXIT:       The ace at iAce will have been deleted and the rest of
                ACEs will have been moved to replace it

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   17-Dec-1991     Created

********************************************************************/

APIERR OS_ACL::DeleteACE( ULONG iAce )
{
    if ( !::DeleteAce( _pACL, iAce ))
        return ::GetLastError() ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_ACL::FindACE

    SYNOPSIS:   Searchs this ACL for an ACE whose SID is equal to ossidKey

    ENTRY:      ossidKey - OS_SID to search this ACL for
                pfFound - Set to TRUE if we found an ACE that contains
                    the key value, FALSE otherwise.  If the ACE is not
                    found, then the rest of the parameters should be ignored.
                posace - pointer to an OS_ACE that will receive the OS_ACE
                    if one is found.
                piAce - The index of where the ACE was found in this ACL
                iStart - Optional start searching position.  Defaults to
                    starting at the beginning of the ACL.

    EXIT:

    RETURNS:    NERR_Success if successful, error code otherwise.  If an
                error code is returned, then the parameters will not
                contain valid values.

    NOTES:

    HISTORY:
        Johnl   27-Dec-1991     Created

********************************************************************/

APIERR OS_ACL::FindACE( const OS_SID & ossidKey,
                        BOOL         * pfFound,
                        OS_ACE       * posace,
                        PULONG         piAce,
                        ULONG          iStart ) const
{
    UIASSERT( ossidKey.IsValid() ) ;
    *pfFound = FALSE ;

    APIERR err ;
    ULONG cTotalAces ;
    if ( err = QueryACECount( &cTotalAces ) )
        return err ;

    if ( iStart >= cTotalAces )
    {
        UIASSERT(!SZ("Search start index greater then total number of ACEs!!")) ;
        return ERROR_INVALID_PARAMETER ;
    }

    for ( ; iStart < cTotalAces ; iStart++ )
    {
        OS_SID * possidTarget ;

        if ( (err = QueryACE( iStart, posace )) ||
             (err = posace->QuerySID( &possidTarget )) )
        {
            return err ;
        }

        if ( *possidTarget == ossidKey )
        {
            *pfFound = TRUE ;
            *piAce   = iStart ;
            return NERR_Success ;
        }
    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_ACL::SetSize

    SYNOPSIS:   Resizes this ACL and sets the ACL's header information to
                reflect the change.

    ENTRY:      cbNewACLSize - New desired size of this ACL

    EXIT:       The ACL will be resized as requested

    RETURNS:    NERR_Success if successful, error code otherwise.
                ERROR_INSUFFICIENT_BUFFER will be returned if this is an
                owner alloced ACL and we've ran out of room OR the ACL has
                run out of space all together.

    NOTES:      We directly access the ACL header which may not be the
                safest way to do things, but it is the only way currently.

                The size info in the ACL header is the total allocated size,
                thus we don't change this information unless we actually
                resize the buffer.
    HISTORY:
        Johnl   26-Dec-1991     Created
        Johnl   22-Apr-1993     Check for exceeding an ACL's max size

********************************************************************/

APIERR OS_ACL::SetSize( UINT cbNewACLSize, BOOL fForceToNonOwnerAlloced  )
{
    ACL_SIZE_INFORMATION aclsizeinfo ;
    APIERR err = QuerySizeInformation( &aclsizeinfo ) ;
    UIASSERT( sizeof( _pACL->AclSize ) == sizeof( USHORT ) ) ;

    if ( err )
        return err ;

    if ( cbNewACLSize > QueryAllocSize() )
    {
        //
        //  An ACL's maximum size is 65k bytes, make sure we haven't exceeded
        //  that limit
        //
        if ( (!fForceToNonOwnerAlloced && IsOwnerAlloc()) ||
             ( cbNewACLSize >= 0xffff ) )
        {
            return ERROR_INSUFFICIENT_BUFFER ;
        }

        if ( err = Resize( cbNewACLSize ) )
            return err ;

        /* The memory block contents are preserved across the Resize
         * call, watch for pointer shift though.
         */
        _pACL = (PACL) QueryPtr() ;
        _pACL->AclSize = (USHORT) cbNewACLSize ;

        /* If this ACL is part of a security descriptor, update our
         * security descriptor with our new memory location.
         */
        if ( _pOwner != NULL )
        {
            if ( err = _pOwner->UpdateReferencedSecurityObject( this ))
            {
                return err ;
            }
        }

    }

    UIASSERT( IsValid() ) ;
    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_ACL::Copy

    SYNOPSIS:   Copies osaclSrc to *this

    ENTRY:      osaclSrc - ACL to copy
                fForceToNonOwnerAlloced - Set to TRUE if you want this object
                    to own (and thus be able to reallocate as needed) the
                    memory for the copy of the passed ACL.  Set to FALSE
                    if using the original buffer (whether owner alloced
                    or not) is preferred.

    EXIT:

    RETURNS:    NERR_Success if successful, error code otherwise.  If this
                is an owner alloced ACL and fForceToNonOwnerAlloced is FALSE
                and there isn't enough room, then
                ERROR_INSUFFICIENT_BUFFER will be returned.

    NOTES:      An ACL is self contained, thus it doesn't contain pointers
                which would cause problems in the memcpyf we use to
                do the copy.

    HISTORY:
        Johnl   26-Dec-1991     Created

********************************************************************/

APIERR OS_ACL::Copy( const OS_ACL & osaclSrc, BOOL fForceToNonOwnerAlloced )
{
    UIASSERT( osaclSrc.IsValid() ) ;

    ULONG cbAclSrcSize ;
    ULONG cbDestBuffSize = 0 ;
    APIERR err ;

    if ( (err = osaclSrc.QueryBytesInUse( &cbAclSrcSize )) ||
         (err = SetSize( (UINT) cbAclSrcSize, fForceToNonOwnerAlloced ))       )
    {
        return err ;
    }

    ::memcpyf( (PACL) *this, (PACL) osaclSrc, (UINT) cbAclSrcSize ) ;

    if ( !IsOwnerAlloc() )
        _pACL->AclSize = (USHORT)QueryAllocSize() ;

    UIASSERT( IsValid() ) ;
    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_ACL::_DbgPrint

    SYNOPSIS:   Takes apart this ACL and outputs it to cdebug

    ENTRY:

    NOTES:

    HISTORY:
        Johnl   30-Dec-1991     Created

********************************************************************/

void OS_ACL::_DbgPrint( void ) const
{
#if defined(DEBUG)
    APIERR err ;
    ACL_SIZE_INFORMATION aclsizeinfo ;

    cdebug << SZ("\tIsOwnerAlloc      = ") << (IsOwnerAlloc() ? SZ("TRUE") : SZ("FALSE")) << dbgEOL ;
    cdebug << SZ("\tIsValid           = ") << (IsValid() ? SZ("TRUE") : SZ("FALSE")) << dbgEOL ;
    cdebug << SZ("\tAddress of _pACL  = ") << (HEX_STR)(PtrToUlong(_pACL)) ;

    if ( err = QuerySizeInformation( &aclsizeinfo ))
    {
        cdebug << SZ("\tQuerySizeInformation returned error code ") << err << dbgEOL ;
        return ;
    }
    else
    {
        cdebug << SZ("\tAceCount          = ") << aclsizeinfo.AceCount << dbgEOL ;
        cdebug << SZ("\tAclBytesInUse     = ") << aclsizeinfo.AclBytesInUse << dbgEOL ;
        cdebug << SZ("\tAclBytesFree      = ") << aclsizeinfo.AclBytesFree << dbgEOL ;
    }

    OS_ACE osace ;
    if ( osace.QueryError() )
    {
        cdebug << SZ("OS_ACE Failed to construct, error code ") << osace.QueryError() << dbgEOL ;
        return ;
    }

    for ( ULONG iAce = 0 ; iAce < aclsizeinfo.AceCount ; iAce++ )
    {
        if ( err = QueryACE( iAce, &osace ))
        {
            cdebug << SZ("QueryACE failed with error code ") << (ULONG) err << dbgEOL ;
            return ;
        }

        cdebug << SZ("\t==================================================") << dbgEOL ;
        cdebug << SZ("\tAce # ") << iAce << dbgEOL ;
        osace._DbgPrint() ;
    }
#endif  // DEBUG
}

/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::OS_SECURITY_DESCRIPTOR

    SYNOPSIS:   Standard constructor/destructor for this class

    ENTRY:      psecuritydesc - Pointer to valid security descriptor else
                    NULL if we are creating a new one.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   18-Dec-1991     Created

********************************************************************/

OS_SECURITY_DESCRIPTOR::OS_SECURITY_DESCRIPTOR( PSECURITY_DESCRIPTOR psecuritydesc,
                                                BOOL fCopy )
    : OS_OBJECT_WITH_DATA( psecuritydesc==NULL || fCopy ?
                                                 sizeof(SECURITY_DESCRIPTOR)
                                                 : 0 ),
      _psecuritydesc   ( NULL ),

      _secdesccont     ( 0 ),
      _osSecDescControl( &_secdesccont ),
      _posaclDACL      ( NULL ),
      _posaclSACL      ( NULL ),
      _possidOwner     ( NULL ),
      _possidGroup     ( NULL )
{
    if ( QueryError() )
        return ;

    //
    //  If fCopy is TRUE, then we will set _psecuritydesc to our memory and
    //  use the flags from the psecdesc parameter, copying each of the
    //  items from psecdesc to _psecuritydesc.  If psecdesc is NULL then
    //  _psecuritydesc == psecuritydesc (i.e., empty security descriptor).
    //
    //  If fCopy is FALSE, then _psecuritydesc == psecuritydesc
    //
    _psecuritydesc = fCopy || psecuritydesc == NULL ?
                           (PSECURITY_DESCRIPTOR) QueryPtr() : psecuritydesc ;

    if ( fCopy || psecuritydesc == NULL )
    {
        if ( psecuritydesc == NULL )
            psecuritydesc = (PSECURITY_DESCRIPTOR) QueryPtr() ;

        if ( !::InitializeSecurityDescriptor( _psecuritydesc,
                                              SECURITY_DESCRIPTOR_REVISION1 ) )
        {
            ReportError( ::GetLastError() ) ;
            return ;
        }
    }
    else
    {
        psecuritydesc = _psecuritydesc ;
    }

    ULONG ulRevision ;
    SECURITY_DESCRIPTOR_CONTROL secdesccont ;
    if ( !::GetSecurityDescriptorControl( psecuritydesc,
                                          &secdesccont,
                                          &ulRevision     ))
    {
        ReportError( ::GetLastError() ) ;
        return ;
    }

    APIERR err ;
    /* Now we need to create each of the OS_* members iff the corresponding
     * item exists in this security descriptor.
     */

    if ( secdesccont & SE_DACL_PRESENT )
    {
        BOOL fDACLPresent, fDACLDefaulted ;
        PACL pDACL ;
        if ( !::GetSecurityDescriptorDacl( psecuritydesc,
                                           &fDACLPresent,
                                           &pDACL,
                                           &fDACLDefaulted))
        {
            ReportError( ::GetLastError() ) ;
            return ;
        }
        UIASSERT( fDACLPresent ) ;

        /* A NULL DACL means World gets Full access
         */
        if ( pDACL != NULL )
        {
            _posaclDACL = new OS_ACL( pDACL, fCopy, this ) ;
            if ( _posaclDACL == NULL )
            {
                ReportError( ERROR_NOT_ENOUGH_MEMORY ) ;
                return ;
            }
            else if ( _posaclDACL->QueryError() )
            {
                ReportError( _posaclDACL->QueryError() ) ;
                return ;
            }
            UIASSERT( _posaclDACL->IsValid()) ;
        }

        if ( fCopy )
        {
            if ( !::SetSecurityDescriptorDacl( _psecuritydesc,
                                               fDACLPresent,
                                               _posaclDACL == NULL ? NULL :
                                                         (PACL)*_posaclDACL,
                                               fDACLDefaulted ) )
            {
                ReportError( ::GetLastError() ) ;
                return ;
            }
        }

    }

    if ( secdesccont & SE_SACL_PRESENT  )
    {
        BOOL fSACLPresent, fSACLDefaulted ;
        PACL pSACL ;
        if ( !::GetSecurityDescriptorSacl( psecuritydesc,
                                           &fSACLPresent,
                                           &pSACL,
                                           &fSACLDefaulted))
        {
            ReportError( ::GetLastError() ) ;
            return ;
        }
        UIASSERT( fSACLPresent ) ;

        /* Note that pSACL maybe NULL
         */
        _posaclSACL = new OS_ACL( pSACL, fCopy, this ) ;
        if ( _posaclSACL == NULL )
        {
            ReportError( ERROR_NOT_ENOUGH_MEMORY ) ;
            return ;
        }
        else if ( _posaclSACL->QueryError() )
        {
            ReportError( _posaclSACL->QueryError() ) ;
            return ;
        }
        UIASSERT( _posaclSACL->IsValid()) ;

        if ( fCopy )
        {
            if ( !::SetSecurityDescriptorSacl( _psecuritydesc,
                                               fSACLPresent,
                                               _posaclSACL == NULL ? NULL :
                                                         (PACL)*_posaclSACL,
                                               fSACLDefaulted ) )
            {
                ReportError( ::GetLastError() ) ;
                return ;
            }
        }

    }

    /* Get the Owner.  Note that if the Owner isn't present *yet*, then
     * psidOwner can come back NULL.
     */
    {
        BOOL fOwnerDefaulted ;
        PSID psidOwner ;
        if ( !::GetSecurityDescriptorOwner( psecuritydesc,
                                            &psidOwner,
                                            &fOwnerDefaulted))
        {
            ReportError( ::GetLastError() ) ;
            return ;
        }

        if ( psidOwner != NULL )
        {
            _possidOwner = new OS_SID( psidOwner, fCopy, this ) ;
            if ( _possidOwner == NULL )
            {
                ReportError( ERROR_NOT_ENOUGH_MEMORY ) ;
                return ;
            }
            else if ( _possidOwner->QueryError() )
            {
                ReportError( _possidOwner->QueryError() ) ;
                return ;
            }
        }

        if ( fCopy )
        {
            if ( !::SetSecurityDescriptorOwner(  _psecuritydesc,
                                                 psidOwner ?
                                                      _possidOwner->QueryPSID() :
                                                      NULL,
                                                 fOwnerDefaulted ) )
            {
                ReportError( ::GetLastError() ) ;
                return ;
            }
        }
    }

    /* Get the group.  Note that if the group isn't present *yet*, then
     * psidGroup can come back NULL.
     */
    {
        BOOL fGroupDefaulted ;
        PSID psidGroup ;
        if ( !::GetSecurityDescriptorGroup( psecuritydesc,
                                            &psidGroup,
                                            &fGroupDefaulted))
        {
            ReportError( ::GetLastError() ) ;
            return ;
        }

        if ( psidGroup != NULL )
        {
            _possidGroup = new OS_SID( psidGroup, fCopy, this ) ;
            if ( _possidGroup == NULL )
            {
                ReportError( ERROR_NOT_ENOUGH_MEMORY ) ;
                return ;
            }
            else if ( _possidGroup->QueryError() )
            {
                ReportError( _possidGroup->QueryError() ) ;
                return ;
            }
        }

        if ( fCopy )
        {
            if ( !::SetSecurityDescriptorGroup(  _psecuritydesc,
                                                 psidGroup ?
                                                      _possidGroup->QueryPSID() :
                                                      NULL,
                                                 fGroupDefaulted ) )
            {
                ReportError( ::GetLastError() ) ;
                return ;
            }
        }
    }

    //
    //  Finally, update the control field to reflect the items we have
    //  set in the security descriptor
    //
    if ( err = UpdateControl() )
    {
        ReportError( err ) ;
        return ;
    }

    UIASSERT( IsValid() ) ;
}

OS_SECURITY_DESCRIPTOR::~OS_SECURITY_DESCRIPTOR()
{
    delete _posaclDACL ;
    delete _posaclSACL ;
    delete _possidOwner ;
    delete _possidGroup ;
    _posaclDACL  = NULL ;
    _posaclSACL  = NULL ;
    _possidOwner = NULL ;
    _possidGroup = NULL ;

    _secdesccont = 0 ;
    _psecuritydesc = NULL ;
}

/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::UpdateControl

    SYNOPSIS:   Forces an update of our private SECURITY_DESCRIPTOR_CONTROL.
                Call after changes to the security descriptor.

    ENTRY:

    EXIT:       _secdesccont will be updated to reflect the current state
                of the security descriptor.

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:

    HISTORY:
        Johnl   18-Dec-1991     Created

********************************************************************/

APIERR OS_SECURITY_DESCRIPTOR::UpdateControl( void )
{
    ULONG ulRevision ;
    if ( !::GetSecurityDescriptorControl( _psecuritydesc,
                                          &_secdesccont,
                                          &ulRevision     ))
    {
        return ::GetLastError() ;
    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::QueryDACL

    SYNOPSIS:   Retrieves the DACL for this security descriptor

    ENTRY:      pfDACLPresent - If set to FALSE, then the DACL isn't present
                    and the rest of the parameters should be ignored.
                ppOSACL - Pointer to pointer to receive the OS_ACL that
                    represents the DACL.  THIS MAYBE NULL!
                pfDACLDefaulted - Set to TRUE if the ACL was assigned using
                    some default ACL (OPTIONAL)

    EXIT:       The parameters will be set as above

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   18-Dec-1991     Created

********************************************************************/

APIERR OS_SECURITY_DESCRIPTOR::QueryDACL( PBOOL      pfDACLPresent,
                                          OS_ACL * * ppOSACL,
                                          PBOOL      pfDACLDefaulted
                                        ) const
{
    *pfDACLPresent = _osSecDescControl.IsDACLPresent() ;
    if ( pfDACLDefaulted != NULL )
        *pfDACLDefaulted = _osSecDescControl.IsDACLDefaulted() ;

    *ppOSACL = _posaclDACL ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::QuerySACL

    SYNOPSIS:   Retrieves the SACL for this security descriptor

    ENTRY:      pfSACLPresent - If set to FALSE, then the SACL isn't present
                    and the rest of the parameters should be ignored.
                ppOSACL - Pointer to pointer to receive the OS_ACL that
                    represents the SACL
                pfSACLDefaulted - Set to TRUE if the ACL was assigned using
                    some default ACL (OPTIONAL)

    EXIT:       The parameters will be set as above

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   18-Dec-1991     Created

********************************************************************/

APIERR OS_SECURITY_DESCRIPTOR::QuerySACL( PBOOL      pfSACLPresent,
                                          OS_ACL * * ppOSACL,
                                          PBOOL      pfSACLDefaulted
                                        ) const
{
    *pfSACLPresent = _osSecDescControl.IsSACLPresent() ;
    if ( pfSACLDefaulted != NULL )
        *pfSACLDefaulted = _osSecDescControl.IsSACLDefaulted() ;

    *ppOSACL = _posaclSACL ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::QueryGroup

    SYNOPSIS:   Retrieves the Group SID for this security descriptor

    ENTRY:      pfGroupPresent - If set to FALSE, then the Group isn't present
                    and the rest of the parameters should be ignored.
                ppOSACL - Pointer to pointer to receive the OS_SID that
                    represents the Group
                pfGroupDefaulted - Set to TRUE if the group was assigned using
                    some default group (OPTIONAL)

    EXIT:       The parameters will be set as above

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   18-Dec-1991     Created

********************************************************************/

APIERR OS_SECURITY_DESCRIPTOR::QueryGroup( PBOOL      pfContainsGroup,
                                           OS_SID * * ppOSSID,
                                           PBOOL      pfGroupDefaulted
                                         ) const
{
    if ( pfGroupDefaulted != NULL )
        *pfGroupDefaulted = _osSecDescControl.IsGroupDefaulted() ;
    *ppOSSID = _possidGroup ;
    *pfContainsGroup = (_possidGroup != NULL) ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::QueryOwner

    SYNOPSIS:   Retrieves the Owner SID for this security descriptor

    ENTRY:      pfOwnerPresent - If set to FALSE, then the Owner isn't present
                    and the rest of the parameters should be ignored.
                ppOSACL - Pointer to pointer to receive the OS_SID that
                    represents the Owner
                pfOwnerDefaulted - Set to TRUE if the Owner was assigned using
                    some default Owner (OPTIONAL)

    EXIT:       The parameters will be set as above

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   18-Dec-1991     Created

********************************************************************/
APIERR OS_SECURITY_DESCRIPTOR::QueryOwner( PBOOL      pfContainsOwner,
                                           OS_SID * * ppOSSID,
                                           PBOOL      pfOwnerDefaulted
                                         ) const
{
    if ( pfOwnerDefaulted != NULL )
        *pfOwnerDefaulted = _osSecDescControl.IsOwnerDefaulted() ;
    *ppOSSID = _possidOwner ;
    *pfContainsOwner = (_possidOwner != NULL) ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::UpdateReferencedSecurityObject

    SYNOPSIS:   This method finds which security object is requesting to
                be updated and updates this security descriptor's pointer
                to match the new security object.

    ENTRY:      posobj - Pointer to the os object (must be equal to _posaclDACL,
                    _posaclSACL, _possidOwner, _possidGroup).  Can't be NULL.

    EXIT:       This security descriptor's reference to the object will
                updated.

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:      Validation should not be performed on the passed security
                object because only the memory location has changed,
                the contents of the memory may not yet be valid.


    HISTORY:
        JohnL   26-Feb-1992     Created

********************************************************************/

APIERR OS_SECURITY_DESCRIPTOR::UpdateReferencedSecurityObject(
                                            OS_OBJECT_WITH_DATA * posobj )
{
    APIERR err = NERR_Success ;
    UIASSERT( posobj != NULL ) ;

    if ( posobj == _posaclDACL )
    {
        if ( !::SetSecurityDescriptorDacl( _psecuritydesc,
                                           TRUE,
                                           (PACL)*_posaclDACL,
                                           FALSE ) )
        {
            err = ::GetLastError() ;
        }
    }
    else if ( posobj == _posaclSACL )
    {
        if ( !::SetSecurityDescriptorSacl( _psecuritydesc,
                                           TRUE,
                                           (PACL)*_posaclSACL,
                                           FALSE ) )
        {
            err = ::GetLastError() ;
        }
    }
    else if ( posobj == _possidOwner )
    {
        if ( !::SetSecurityDescriptorOwner( _psecuritydesc,
                                                     *_possidOwner,
                                                     FALSE ) )
        {
            err = ::GetLastError() ;
        }
    }
    else if ( posobj == _possidGroup )
    {
        if ( !::SetSecurityDescriptorGroup( _psecuritydesc,
                                                     *_possidGroup,
                                                     FALSE ) )
        {
            err = ::GetLastError() ;
        }

    }
    else
    {
        DBGEOL( SZ("OS_SECURITY_DESCRIPTOR::UpdateReferencedSecurityObject passed object that isn't in this security descriptor")) ;
        UIASSERT(FALSE) ;
        err = ERROR_INVALID_PARAMETER ;
    }

    return err ;
}

/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::SetDACL

    SYNOPSIS:   Sets the DACL on this security descriptor

    ENTRY:      fDACLPresent - Set to FALSE if you are removing the DACL
                    from this SECURITY_DESCRIPTOR.  The rest of the
                    parameters will be ignored.
                posacl - OS_ACL that we are setting.  This may be NULL.
                fDACLDefaulted - Set to TRUE to indicate the ACL was selected
                    throug some default mechanism

    EXIT:       The security descriptor will either use the new ACL or
                the current ACL will become unreferenced.

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      If setting the DACL, then the ACL contained in osacl is
                copied.

    HISTORY:
        Johnl   18-Dec-1991     Created

********************************************************************/

APIERR OS_SECURITY_DESCRIPTOR::SetDACL( BOOL           fDACLPresent,
                                        const OS_ACL * posacl,
                                        BOOL           fDACLDefaulted
                                      )
{
    APIERR err = NERR_Success ;
    if ( fDACLPresent )
    {
        /* If the Security Descriptor didn't contain a DACL previously, then
         * we need to create a new one, otherwise just copy it.
         */
        if ( _posaclDACL == NULL && posacl != NULL )
        {
            if ( (_posaclDACL = new OS_ACL( posacl ? posacl->QueryAcl() : NULL,
                                            TRUE,
                                            this )) == NULL )
                return ERROR_NOT_ENOUGH_MEMORY ;
            else if ( _posaclDACL->QueryError() )
                return _posaclDACL->QueryError() ;

            UIASSERT( _posaclDACL->IsValid() ) ;
        }
        else if ( posacl == NULL )
        {
            //
            //  If we are setting a NULL DACL, then delete the OS_ACL wrapper
            //
            delete _posaclDACL ;
            _posaclDACL = NULL ;
        }
        else
        {
            if ( err = _posaclDACL->Copy( *posacl ) )
                return err ;

            UIASSERT( _posaclDACL->IsValid() ) ;
        }
    }

    /* The reason for the ternary operator is because _posaclDACL may or
     * may not be NULL, and we obviously do not want to dereference a
     * NULL pointer.  When _posaclDACL is not NULL, then the *_posaclDACL
     * will resolve to a PACL using the conversion operator.
     */
    if ( !::SetSecurityDescriptorDacl( _psecuritydesc,
                                       fDACLPresent,
                                       _posaclDACL == NULL ? NULL :
                                                 (PACL)*_posaclDACL,
                                       fDACLDefaulted ) )
    {
        return ::GetLastError() ;
    }

    if ( !fDACLPresent )
    {
        /* The DACL is being removed from this security descriptor, so free
         * up the potentially large chunk of memory in this OS_ACL.
         */
        delete _posaclDACL ;
        _posaclDACL = NULL ;
    }

    UIASSERT( IsValid() ) ;
    UIASSERT( (_posaclDACL == NULL) || (_posaclDACL->IsValid())) ;
    return UpdateControl() ;
}


/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::SetSACL

    SYNOPSIS:   Sets the SACL on this security descriptor

    ENTRY:      fSACLPresent - Set to FALSE if you are removing the SACL
                    from this SECURITY_DESCRIPTOR.  The rest of the
                    parameters will be ignored.
                posacl - OS_ACL that we are setting.
                fSACLDefaulted - Set to TRUE to indicate the ACL was selected
                    throug some default mechanism

    EXIT:       The security descriptor will either use the new ACL or
                the current ACL will become unreferenced.

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      If setting the SACL, then the ACL contained in osacl is
                copied.

    HISTORY:
        Johnl   18-Dec-1991     Created

********************************************************************/

APIERR OS_SECURITY_DESCRIPTOR::SetSACL( BOOL           fSACLPresent,
                                        const OS_ACL * posacl,
                                        BOOL           fSACLDefaulted
                                      )
{
    APIERR err = NERR_Success ;
    if ( fSACLPresent )
    {
        /* If the Security Descriptor didn't contain a SACL previously, then
         * we need to create a new one, otherwise just copy it.
         */
        if ( _posaclSACL == NULL && posacl != NULL )
        {
            if ( (_posaclSACL = new OS_ACL( posacl ? posacl->QueryAcl() : NULL,
                                            TRUE,
                                            this )) == NULL )
                return ERROR_NOT_ENOUGH_MEMORY ;
            else if ( _posaclSACL->QueryError() )
                return _posaclSACL->QueryError() ;

            UIASSERT( _posaclSACL->IsValid() ) ;
        }
        else if ( posacl == NULL )
        {
            //
            //  If we are setting a NULL SACL, then delete the OS_ACL wrapper
            //
            delete _posaclSACL ;
            _posaclSACL = NULL ;
        }
        else
        {
            if ( err = _posaclSACL->Copy( *posacl ) )
                return err ;

            UIASSERT( _posaclSACL->IsValid() ) ;
        }
    }

    /* The reason for the ternary operator is because _posaclSACL may or
     * may not be NULL, and we obviously do not want to dereference a
     * NULL pointer.  When _posaclSACL is not NULL, then the *_posaclSACL
     * will resolve to a PACL using the conversion operator.
     */
    if ( !::SetSecurityDescriptorSacl( _psecuritydesc,
                                       fSACLPresent,
                                       _posaclSACL == NULL ? NULL :
                                                   (PACL)*_posaclSACL,
                                       fSACLDefaulted ) )
    {
        return ::GetLastError() ;
    }

    if ( !fSACLPresent )
    {
        /* The SACL is being removed from this security descriptor, so free
         * up the potentially large chunk of memory in this OS_ACL.
         */
        delete _posaclSACL ;
        _posaclSACL = NULL ;
    }

    UIASSERT( IsValid() ) ;
    return  UpdateControl() ;
}

/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::SetOwner

    SYNOPSIS:   Sets the Owner SID on this security descriptor

    ENTRY:      fOwnerPresent - If FALSE, then the SID is marked as not
                                present and the rest of the params are ignored
                possid - Owner SID we are setting for this security descriptor
                fOwnerDefaulted - Set to TRUE to indicate the SID was selected
                    throug some default mechanism

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      The Owner SID is copied


    HISTORY:
        Johnl   13-Oct-1992     Created

********************************************************************/

APIERR OS_SECURITY_DESCRIPTOR::SetOwner( BOOL           fOwnerPresent,
                                         const OS_SID * possid,
                                         BOOL           fOwnerDefaulted
                                       )
{
    UIASSERT( !fOwnerPresent || (possid != NULL && possid->IsValid()) ) ;

    //
    //  SetSecurityDescriptorOwner will fail with invalid security descriptor
    //  if this is a self relative security descriptor.
    //
    UIASSERT( !QueryControl()->IsSelfRelative() ) ;

    APIERR err = NERR_Success ;
    if ( fOwnerPresent )
    {
        /* If the Owner SID didn't contain a SID previously, then
         * we need to create a new one, otherwise just copy it.
         */
        if ( _possidOwner == NULL )
        {
            if ( (_possidOwner = new OS_SID( NULL, FALSE, this )) == NULL )
                return ERROR_NOT_ENOUGH_MEMORY ;
            else if ( _possidOwner->QueryError() )
                return _possidOwner->QueryError() ;
        }

        err = _possidOwner->Copy( *possid ) ;
        if ( err )
            return err ;
    }
    else
    {
        delete _possidOwner ;
        _possidOwner = NULL ;
        possid = NULL ;
    }

    if ( !::SetSecurityDescriptorOwner(  _psecuritydesc,
                                         fOwnerPresent ?
                                              _possidOwner->QueryPSID() :
                                              NULL,
                                         fOwnerDefaulted ) )
    {
        return ::GetLastError() ;
    }

    UIASSERT( IsValid() ) ;
    err = UpdateControl() ;
    return err ;
}

/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::SetGroup

    SYNOPSIS:   Sets the Group SID on this security descriptor

    ENTRY:      fGroupPresent - If FALSE, then the SID is marked as not
                                present and the rest of the params are ignored
                possid - Group SID we are setting for this security descriptor
                fGroupDefaulted - Set to TRUE to indicate the SID was selected
                    throug some default mechanism

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      The Group SID is copied


    HISTORY:
        Johnl   13-Oct-1992     Created

********************************************************************/

APIERR OS_SECURITY_DESCRIPTOR::SetGroup( BOOL           fGroupPresent,
                                         const OS_SID * possid,
                                         BOOL           fGroupDefaulted
                                       )
{
    UIASSERT( !fGroupPresent || (possid != NULL && possid->IsValid()) ) ;

    //
    //  SetSecurityDescriptorGroup will fail with invalid security descriptor
    //  if this is a self relative security descriptor.
    //
    UIASSERT( !QueryControl()->IsSelfRelative() ) ;

    APIERR err = NERR_Success ;
    if ( fGroupPresent )
    {
        /* If the Group SID didn't contain a SID previously, then
         * we need to create a new one, otherwise just copy it.
         */
        if ( _possidGroup == NULL )
        {
            if ( (_possidGroup = new OS_SID( NULL, FALSE, this )) == NULL )
                return ERROR_NOT_ENOUGH_MEMORY ;
            else if ( _possidGroup->QueryError() )
                return _possidGroup->QueryError() ;
        }

        err = _possidGroup->Copy( *possid ) ;
        if ( err )
            return err ;
    }
    else
    {
        delete _possidGroup ;
        _possidGroup = NULL ;
        possid = NULL ;
    }

    if ( !::SetSecurityDescriptorGroup(  _psecuritydesc,
                                         fGroupPresent ?
                                              _possidGroup->QueryPSID() :
                                              NULL,
                                         fGroupDefaulted ) )
    {
        return ::GetLastError() ;
    }

    UIASSERT( IsValid() ) ;
    err = UpdateControl() ;
    return err ;
}

/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::SetGroup

    SYNOPSIS:   Sets the Group SID on this security descriptor

    ENTRY:      ossid - Group SID we are setting for this security descriptor
                fGroupDefaulted - Set to TRUE to indicate the ACL was selected
                    throug some default mechanism

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      The group SID is copied


    HISTORY:
        Johnl   18-Dec-1991     Created

********************************************************************/

APIERR OS_SECURITY_DESCRIPTOR::SetGroup( const OS_SID & ossid,
                                         BOOL  fGroupDefaulted
                                       )
{
    UIASSERT( ossid.IsValid() ) ;

    /* If the Group SID didn't contain a SID previously, then
     * we need to create a new one, otherwise just copy it.
     */
    if ( _possidGroup == NULL )
    {
        if ( (_possidGroup = new OS_SID( NULL, FALSE, this )) == NULL )
            return ERROR_NOT_ENOUGH_MEMORY ;
        else if ( _possidGroup->QueryError() )
            return _possidGroup->QueryError() ;
    }

    APIERR err = _possidGroup->Copy( ossid ) ;
    if ( err )
        return err ;

    if ( !::SetSecurityDescriptorGroup( _psecuritydesc,
                                        *_possidGroup,
                                       fGroupDefaulted ) )
    {
        return ::GetLastError() ;
    }

    UIASSERT( IsValid() ) ;

    return UpdateControl() ;
}

/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::SetOwner

    SYNOPSIS:   Sets the Owner SID on this security descriptor

    ENTRY:      ossid - OS_SID we are setting for the owner of this sec. desc.
                fOwnerDefaulted - Set to TRUE to indicate the ACL was selected
                    throug some default mechanism

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      The Owner SID is copied


    HISTORY:
        Johnl   18-Dec-1991     Created

********************************************************************/

APIERR OS_SECURITY_DESCRIPTOR::SetOwner( const OS_SID & ossid,
                                         BOOL  fOwnerDefaulted
                                       )
{
    UIASSERT( ossid.IsValid() ) ;

    /* If the Owner SID didn't contain a SID previously, then
     * we need to create a new one, otherwise just copy it.
     */
    if ( _possidOwner == NULL )
    {
        if ( (_possidOwner = new OS_SID( NULL, FALSE, this )) == NULL )
            return ERROR_NOT_ENOUGH_MEMORY ;
        else if ( _possidOwner->QueryError() )
            return _possidOwner->QueryError() ;
    }

    APIERR err = _possidOwner->Copy( ossid ) ;
    if ( err )
        return err ;

    if ( !::SetSecurityDescriptorOwner( _psecuritydesc,
                                        *_possidOwner,
                                       fOwnerDefaulted ) )
    {
        return ::GetLastError() ;
    }

    UIASSERT( IsValid() ) ;
    err = UpdateControl() ;
    return err ;
}

/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::Copy

    SYNOPSIS:   Copies the given security descriptor to this

    ENTRY:      ossecdescSrc - Security descriptor to copy

    EXIT:       This will be a replica of ossecdescSrc (with its own
                memory).

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   28-Aug-1992     Created

********************************************************************/

APIERR OS_SECURITY_DESCRIPTOR::Copy( const OS_SECURITY_DESCRIPTOR & ossecdescSrc )
{
    APIERR err = NERR_Success ;
    UIASSERT( ossecdescSrc.IsValid() ) ;

    do { // error break out

        /*
         *  Copy the SACL and DACL
         */
        BOOL fSIDPresent, fACLPresent ;
        OS_ACL * pOsAcl ;
        OS_SID * pOsSid ;

        if ( (err = ossecdescSrc.QueryDACL(&fACLPresent, &pOsAcl)) ||
             (err = SetDACL(fACLPresent, pOsAcl) ))
        {
            break ;
        }

        if ( (err = ossecdescSrc.QuerySACL(&fACLPresent, &pOsAcl)) ||
             (err = SetSACL(fACLPresent, pOsAcl)))
        {
            break ;
        }

        /* Copy the Owner and Group
         */
        if ( (err = ossecdescSrc.QueryOwner(&fSIDPresent, &pOsSid)) ||
             (err = SetOwner(fSIDPresent, pOsSid)) )
        {
            break ;
        }
        
        if ( (err = ossecdescSrc.QueryGroup(&fSIDPresent, &pOsSid)) ||
             (err = SetGroup(fSIDPresent, pOsSid)))
        {
            break ;
        }
    } while (FALSE) ;

    return err ;
}

/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::AccessCheck

    SYNOPSIS:   Determines if the current process can access the object this
                security descriptor is attached to with the passed access
                mask.

    ENTRY:      DesiredAccess - The desired access (should not have any
                    generic bits set)
                pGenericMapping - Generic mapping appropriate for the object
                pfAccessGranted - Will be set to TRUE if access is granted,
                    FALSE otherwise
                pGrantedAccess - Indicates which accesses were actually
                    granted (optional, can be NULL).

    EXIT:

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      This method has to impersonate itself to call the AccessCheck
                API that was designed to be called only from Server
                Applications.

    HISTORY:
        Johnl   04-May-1992     Created

********************************************************************/

#if 0

//
//  Not used for anything.  Note that AccessChecks can only be done
//  with security descriptors from the local machine thus seriously limiting
//  the usefulness of this method.
//

APIERR OS_SECURITY_DESCRIPTOR::AccessCheck(
                    ACCESS_MASK       DesiredAccess,
                    PGENERIC_MAPPING  pGenericMapping,
                    BOOL            * pfAccessGranted,
                    PACCESS_MASK      pGrantedAccess )
{
    APIERR err = NERR_Success ;
    BOOL fImpersonated = FALSE ;    // Set if we have to revert to self
    HANDLE hToken1, hToken2;


    do { // Error breakout

        DWORD dwTmpGrantedAccess ;
        BUFFER buffPrivilegeSet( 254 ) ;
        if ( err = buffPrivilegeSet.QueryError())
        {
            break ;
        }

        /* Get the thread token required by the AccessCheck API
         */
        OBJECT_ATTRIBUTES ObjectAttributes;
        SECURITY_QUALITY_OF_SERVICE Qos;
        InitializeObjectAttributes(&ObjectAttributes, NULL, 0, 0, NULL);

        Qos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
        Qos.ImpersonationLevel = SecurityImpersonation ;
        Qos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        Qos.EffectiveOnly = FALSE;
        ObjectAttributes.SecurityQualityOfService = &Qos;

        /* Try impersonating our current thread token, if that fails, then
         * do it with our process token.
         */
        if ( (err = ERRMAP::MapNTStatus(::NtOpenThreadToken( NtCurrentThread(),
                                                              TOKEN_DUPLICATE,
                                                              FALSE,
                                                              &hToken1 ))))
        {
            if ( (err == ERROR_NO_TOKEN) &&
                !(err = ERRMAP::MapNTStatus(
                                 ::NtOpenProcessToken( NtCurrentProcess(),
                                                       TOKEN_DUPLICATE,
                                                       &hToken1 ))))
            {
                /* Openning the process token worked, so proceed
                 */
            }
            else
            {
                DBGEOL("OS_SECURITY_DESCRIPTOR::AccessCheck - Token  Open failed -  error "
                    << (ULONG) err ) ;
                break ;
            }
        }

        if ((err = ERRMAP::MapNTStatus(::NtDuplicateToken(
                                            hToken1,
                                            TOKEN_IMPERSONATE |
                                            TOKEN_QUERY |
                                            TOKEN_ADJUST_PRIVILEGES,
                                            &ObjectAttributes,
                                            FALSE,                 //EffectiveOnly
                                            TokenImpersonation,
                                            &hToken2
                                            ))))
        {
            DBGEOL("OS_SECURITY_DESCRIPTOR::AccessCheck - Token impersonation failed -  error "
                    << (ULONG) err ) ;
            break ;
        }
        fImpersonated = TRUE ;

        /* Loop until we get the buffer size right (should go through at
         * most twice because cbPrivilegeSetLength will be set to the
         * required buffer size).
         */
        BOOL fAccessStatus ;
        do {
            DWORD cbPrivilegeSetLength = buffPrivilegeSet.QuerySize() ;
            if ( !::AccessCheck( QueryDescriptor(),
                                 hToken2,
                                 (DWORD) DesiredAccess,
                                 pGenericMapping,
                                 (PPRIVILEGE_SET) buffPrivilegeSet.QueryPtr(),
                                 &cbPrivilegeSetLength,
                                 &dwTmpGrantedAccess,
                                 &fAccessStatus ))
            {
                if ( (err = ::GetLastError()) == ERROR_INSUFFICIENT_BUFFER)
                {
                    err = buffPrivilegeSet.Resize( (UINT) cbPrivilegeSetLength) ;
                }
            }
        } while ( err == ERROR_INSUFFICIENT_BUFFER ) ;

        /* If an error occurred on the API or something else happenned
         * trying to do the access check, then bail out (in which case
         * fAccessStatus will be FALSE).
         */
        if ( err ||
            ( !fAccessStatus && (err = ::GetLastError()) &&
              err != ERROR_ACCESS_DENIED ))
        {
            DBGEOL("OS_SECURITY_DESCRIPTOR::AccessCheck - Returning error "
                    << (ULONG) err ) ;
            break ;
        }

        /* If the secondary status failed with an Access check, then the user
         * doesn't have the requested privilege on this security descriptor.
         */
        if ( err == ERROR_ACCESS_DENIED )
        {
            err = NERR_Success ;
            dwTmpGrantedAccess = 0 ;
        }

        *pfAccessGranted = (DesiredAccess ==
                                      (DesiredAccess & dwTmpGrantedAccess)) ;
        if ( pGrantedAccess != NULL )
        {
            *pGrantedAccess  = (ACCESS_MASK) dwTmpGrantedAccess ;
        }
    } while (FALSE) ;

    if ( fImpersonated )
    {
        /* We ignore any errors that occurr here
         */
        ::NtClose( hToken1 ) ;
        ::NtClose( hToken2 ) ;
        if ( !::RevertToSelf() )
        {
            DBGEOL("OS_SECURITY_DESCRIPTOR::AccessCheck - RevertToSelf failed with error code "
                    << (ULONG) ::GetLastError() ) ;
        }
    }

    return err ;
}
#endif // 0

/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::Compare

    SYNOPSIS:   Compares two security descriptors

    ENTRY:      possecdesc - Pointer to other security descriptor to compare
                pfOwnerEqual - Will be set to TRUE if the item is equal,
                                if NULL, then this component won't be checked
                pfGroupEqual -  "
                pfDACLEqual  -  "
                pfSACLEqual  -  "
                pGenericMapping - Generic mapping for this object, used
                                    for SACL/DACL comparison
                pGenericMappingNewObjects - Generic mapping for new objects
                                    if this is a container
                fMapGenAllOnly - Map generic all only, don't map other generics
                fIsContainer   - TRUE if this security descriptor is on a
                                    container

    EXIT:       The pf*Equal flags will be set

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      For SACL/DACL comparisons, the ACLs are compacted and compared
                once for each unique SID.  Thus the ACLs must conform to the
                security editor's canonical form.

    HISTORY:
        Johnl   09-Nov-1992     Created

********************************************************************/

APIERR OS_SECURITY_DESCRIPTOR::Compare(
                OS_SECURITY_DESCRIPTOR * possecdesc,
                BOOL *           pfOwnerEqual,
                BOOL *           pfGroupEqual,
                BOOL *           pfDACLEqual,
                BOOL *           pfSACLEqual,
                PGENERIC_MAPPING pGenericMapping,
                PGENERIC_MAPPING pGenericMappingNewObjects,
                BOOL             fMapGenAllOnly,
                BOOL             fIsContainer )
{
    OS_SID * possid1 ;
    OS_SID * possid2 ;
    BOOL   fPresent1, fPresent2 ;
    APIERR err = NERR_Success ;

    if ( pfOwnerEqual != NULL )
    {
        if ( !(err = QueryOwner( &fPresent1, &possid1 )) &&
             !(err = possecdesc->QueryOwner( &fPresent2, &possid2 )) )
        {
            *pfOwnerEqual = ( fPresent1 == fPresent2 ) &&
                            fPresent1 && (*possid1 == *possid2) ;
        }
    }

    if ( !err && pfGroupEqual != NULL )
    {
        if ( !(err = QueryGroup( &fPresent1, &possid1 )) &&
             !(err = possecdesc->QueryGroup( &fPresent2, &possid2 )) )
        {
            *pfGroupEqual = ( fPresent1 == fPresent2 ) &&
                            fPresent2 && (*possid1 == *possid2) ;
        }
    }

    if ( !err && pfDACLEqual != NULL )
    {
        *pfDACLEqual = TRUE ;
        BOOL fDACL1Present, fDACL2Present ;
        OS_ACL * pacl1, * pacl2 ;

        if ( (err = QueryDACL( &fDACL1Present, &pacl1 )) ||
             (err = possecdesc->QueryDACL( &fDACL2Present, &pacl2 )) ||
             (fDACL1Present != fDACL2Present))
        {
            *pfDACLEqual = FALSE ;
        }
        else if ( IsDACLPresent() )
        {
            if ( pacl1 != NULL && pacl2 != NULL )
            {
                OS_DACL_SUBJECT_ITER subjiter1( pacl1,
                                                pGenericMapping,
                                                pGenericMappingNewObjects,
                                                fMapGenAllOnly,
                                                fIsContainer ) ;
                OS_DACL_SUBJECT_ITER subjiter2( pacl2,
                                                pGenericMapping,
                                                pGenericMappingNewObjects,
                                                fMapGenAllOnly,
                                                fIsContainer ) ;

                if ( (err = subjiter1.QueryError()) ||
                     (err = subjiter2.QueryError()) ||
                     (err = subjiter1.Compare( pfDACLEqual, &subjiter2)) )
                {
                    return err ;
                }
            }
            else
            {
                *pfDACLEqual = (pacl1 == NULL && pacl2 == NULL);
            }
        }
    }

    if ( !err && pfSACLEqual != NULL )
    {
        *pfSACLEqual = TRUE ;
        BOOL fSACL1Present, fSACL2Present ;
        OS_ACL * pacl1, * pacl2 ;

        if ( (err = QuerySACL( &fSACL1Present, &pacl1 )) ||
             (err = possecdesc->QuerySACL( &fSACL2Present, &pacl2 )) ||
             (fSACL1Present != fSACL2Present))
        {
            *pfSACLEqual = FALSE ;
        }
        else if ( IsSACLPresent() )
        {
            OS_SACL_SUBJECT_ITER subjiter1( pacl1,
                                            pGenericMapping,
                                            pGenericMappingNewObjects,
                                            fMapGenAllOnly,
                                            fIsContainer ) ;
            OS_SACL_SUBJECT_ITER subjiter2( pacl2,
                                            pGenericMapping,
                                            pGenericMappingNewObjects,
                                            fMapGenAllOnly,
                                            fIsContainer ) ;

            if ( (err = subjiter1.QueryError()) ||
                 (err = subjiter2.QueryError()) ||
                 (err = subjiter1.Compare( pfSACLEqual, &subjiter2)) )
            {
                return err ;
            }
        }
    }

    return NERR_Success ;
}


/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::IsValid

    SYNOPSIS:   Returns TRUE if the components of this security descriptor
                are valid.

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   20-Feb-1992     Created

********************************************************************/

BOOL OS_SECURITY_DESCRIPTOR::IsValid( void ) const
{
    BOOL fIsValid1 = TRUE ;
    BOOL fIsValid2 = TRUE ;
    BOOL fIsValid3 = TRUE ;
    BOOL fIsValid4 = TRUE ;


    if ( QueryControl()->IsDACLPresent() )
        if (_posaclDACL != NULL && !(fIsValid1 = _posaclDACL->IsValid()))
            DBGEOL(SZ("OS_SECURITY_DESCRIPTOR::IsValid - DACL is not valid")) ;

    if ( QueryControl()->IsSACLPresent() )
        if ( !(fIsValid2 = _posaclSACL->IsValid()) )
            DBGEOL(SZ("OS_SECURITY_DESCRIPTOR::IsValid - SACL is not valid")) ;

    if ( _possidOwner != NULL )
        if ( !(fIsValid3 = _possidOwner->IsValid()))
            DBGEOL(SZ("OS_SECURITY_DESCRIPTOR::IsValid - Owner SID is not valid")) ;

    if ( _possidGroup != NULL )
        if ( !(fIsValid4 = _possidGroup->IsValid()))
            DBGEOL(SZ("OS_SECURITY_DESCRIPTOR::IsValid - Group SID is not valid")) ;

    return fIsValid1 && fIsValid2 && fIsValid3 && fIsValid4 ;
}

void OS_SECURITY_DESCRIPTOR::_DbgPrint( void ) const
{
#if defined(DEBUG)
    APIERR err ;
    cdebug << SZ("OS_SECURITY_DESCRIPTOR::DbgPrint - ") << dbgEOL ;
    cdebug << SZ("\tIsOwnerAlloc = ") << (IsOwnerAlloc() ? SZ("TRUE") : SZ("FALSE")) << dbgEOL ;
    cdebug << SZ("\tControl flag = ") << (HEX_STR)((ULONG)((SECURITY_DESCRIPTOR_CONTROL)(*QueryControl()))) << dbgEOL ;
    cdebug << SZ("\tIsValid      = ") << (IsValid() ? SZ("TRUE") : SZ("FALSE")) << dbgEOL ;
    cdebug << SZ("\tDACL Present = ") << (QueryControl()->IsDACLPresent() ? SZ("TRUE") : SZ("FALSE")) << dbgEOL ;
    cdebug << SZ("\tSACL Present = ") << (QueryControl()->IsSACLPresent() ? SZ("TRUE") : SZ("FALSE")) << dbgEOL ;
    cdebug << SZ("\tAddress of this = ") << (HEX_STR)(PtrToUlong(this)) << SZ("  Address of _psecuritydesc = ") << (HEX_STR)(PtrToUlong(_psecuritydesc)) << dbgEOL ;

    BOOL fDACLPresent, fDACLDefaulted ;
    PACL pDACL ;
    GetSecurityDescriptorDacl( _psecuritydesc, &fDACLPresent,
                               &pDACL, &fDACLDefaulted ) ;
    cdebug << SZ("\tAddress of DACL referenced by _psecuritydesc = ") << (HEX_STR)(PtrToUlong(pDACL)) << dbgEOL ;
    cdebug << dbgEOL ;

    OS_SID * possidOwner ;
    BOOL     fContainsOwner ;
    err = QueryOwner( &fContainsOwner, &possidOwner ) ;
    if ( err )
        cdebug << SZ("Error retrieving Owner SID, error code: ") << err << dbgEOL ;
    else if ( !fContainsOwner )
        cdebug << SZ("Security Descriptor doesn't contain an Owner SID") << dbgEOL ;
    else
    {
        cdebug << SZ("Owner SID:") << dbgEOL ;
        possidOwner->_DbgPrint() ;
    }

    OS_SID * possidGroup ;
    BOOL     fContainsGroup ;
    err = QueryGroup( &fContainsGroup, &possidGroup ) ;
    if ( err )
        cdebug << SZ("Error retrieving Group SID, error code: ") << err << dbgEOL ;
    else if ( !fContainsGroup )
        cdebug << SZ("Security Descriptor doesn't contain a Group SID") << dbgEOL ;
    else
    {
        cdebug << SZ("Group SID:") << dbgEOL ;
        possidGroup->_DbgPrint() ;
    }

    if ( QueryControl()->IsSACLPresent() )
    {
        OS_ACL * pSACL ;
        BOOL     fSACLPresent ;
		// NTRAID#NTBUG9-574280-2002/03/08-artm  Prefast: redeclaration of err.
		// Hides err declared at function level.  This is very low pri since
		// in debug code.
        APIERR err = QuerySACL( &fSACLPresent, &pSACL ) ;
        if ( err )
            cdebug << SZ("Error retrieving SACL, error code: ") << err << dbgEOL ;
        else
        {
            UIASSERT( fSACLPresent ) ;
            cdebug << SZ("SACL:") << dbgEOL ;
            pSACL->_DbgPrint() ;
        }
    }

    if ( QueryControl()->IsDACLPresent() )
    {
		// NTRAID#NTBUG9-574280-2002/03/08-artm  Prefast: redeclaration of pDACL and fDACLPresent and err.
		// Hides pDACL declared at function level.  This is very low pri since
		// in debug code.
        OS_ACL * pDACL ;
        BOOL     fDACLPresent ;
        APIERR err = QueryDACL( &fDACLPresent, &pDACL ) ;
        if ( err )
            cdebug << SZ("Error retrieving DACL, error code: ") << err << dbgEOL ;
        else
        {
            UIASSERT( fDACLPresent ) ;
            cdebug << SZ("DACL:") << dbgEOL ;
            if ( pDACL == NULL )
            {
                cdebug << SZ("\tNULL") << dbgEOL ;
            }
            else
                pDACL->_DbgPrint() ;
        }
    }
#endif  // DEBUG
}

/*******************************************************************

    NAME:       OS_ACL_SUBJECT_ITER::OS_ACL_SUBJECT_ITER

    SYNOPSIS:   Standard Constructor/destructor

    ENTRY:      posacl - Pointer to valid ACL to iterate over
                pGenericMapping - Pointer to GENERIC_MAPPING structure that
                    is used for specific->Generic conversion and recognition
                    of Deny All aces.
                fMapGenAllOnly - TRUE means only convert specific permissions
                    that correspond to generic all and ignore possible
                    mappings to Generic Read, Write and Execute.

    EXIT:

    RETURNS:

    NOTES:


    HISTORY:
        Johnl   31-Dec-1991     Created

********************************************************************/

OS_ACL_SUBJECT_ITER::OS_ACL_SUBJECT_ITER( const OS_ACL *   posacl,
                                          PGENERIC_MAPPING pGenericMapping,
                                          PGENERIC_MAPPING pGenericMappingNewObjects,
                                          BOOL             fMapGenAllOnly,
                                          BOOL             fIsContainer )
    : BASE(),
      _posacl                   ( posacl ),
      _pGenericMapping          ( pGenericMapping ),
      _pGenericMappingNewObjects( pGenericMappingNewObjects ),
      _fMapGenAllOnly           ( fMapGenAllOnly ),
      _ossidCurrentSubject      ( NULL   ),
      _cTotalAces               ( 0      ),
      _iCurrentAce              ( 0      ),
      _fIsContainer             ( fIsContainer ),
      _ossidCreator             (),
      _ossidCreatorGroup        ()
{
    UIASSERT( posacl != NULL ) ;
    UIASSERT( pGenericMapping != NULL ) ;

    if ( !posacl->IsValid() )
    {
        ReportError( ERROR_INVALID_PARAMETER ) ;
        return ;
    }

    APIERR err ;
    if ( (err = _ossidCurrentSubject.QueryError()) ||
         (err = _posacl->QueryACECount( &_cTotalAces )) ||
         (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_CreatorOwner,
                                                     &_ossidCreator )) ||
         (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_CreatorGroup,
                                                     &_ossidCreatorGroup )) )

    {
        ReportError( err ) ;
        return ;
    }

}

OS_ACL_SUBJECT_ITER::~OS_ACL_SUBJECT_ITER()
{
    _posacl = NULL ;
}

/*******************************************************************

    NAME:       OS_ACL_SUBJECT_ITER::FindNextSubject

    SYNOPSIS:   Finds the next unique SID in this ACL starting from our
                current position.

    ENTRY:      pfFoundNewSubject - Set to TRUE if a new subject was found, FALSE
                    otherwise.
                possidNewSubj - Pointer to OS_SID that will receive the new subject
                posaceFirstAceWithSubj - pointer to ACE that will receive the first
                    ACE in this ACL that contains the new subject.  The current
                    ACE index will be set to this ACE position also.

    EXIT:       if *pfFoundNewSubject is TRUE, then
                    *possidNewSubj will contain the new SID
                    *posaceFirstAceWithSubj will point to the first ACE in
                            the ACL with this SID

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   31-Dec-1991     Broke out from child classes

********************************************************************/

APIERR OS_ACL_SUBJECT_ITER::FindNextSubject( BOOL   * pfFoundNewSubject,
                                             OS_SID * possidNewSubj,
                                             OS_ACE * posaceFirstAceWithSubj )
{
    APIERR err ;
    UIASSERT( possidNewSubj != NULL ) ;
    UIASSERT( !possidNewSubj->QueryError() &&
              !posaceFirstAceWithSubj->QueryError() ) ;

    /* Assume we won't find a new subject
     */
    *pfFoundNewSubject = FALSE ;

    /* Confirm there are ACEs left to examine in this ACL.
     */
    if ( _iCurrentAce >= QueryTotalAceCount() )
        return NERR_Success ;

    /* Find the next subject that we haven't encountered before.  We do this
     * by looking at the SID in the current ACE, then scanning from the
     * start of the ACL looking for the same SID, if we don't find it before
     * our current location, then this is a new subject, otherwise we go
     * on to the next ACE.
     */
    BOOL fOldSid = TRUE ;
    while ( fOldSid )
    {
        /* Get the candidate SID from the current ACE
         */
        OS_SID * possid ;
        if ( (err =_posacl->QueryACE( _iCurrentAce, posaceFirstAceWithSubj ))||
             (err =posaceFirstAceWithSubj->QuerySID( &possid ))              ||
             (err =possidNewSubj->Copy( *possid )))
        {
            return err ;
        }

        /* Determine if the candidate SID is one we have already encountered
         */
        BOOL fFoundAce ;
        ULONG iFoundAce ;
        if ( (err = _posacl->FindACE( *possidNewSubj, &fFoundAce,
                                       posaceFirstAceWithSubj,
                                       &iFoundAce ))             )
        {
            UIDEBUG(SZ("OS_DACL_SUBJECT_ITER::Next - Unable to find ACE\n\r")) ;
            return err ;
        }
        UIASSERT( fFoundAce ) ;

        /* If we didn't find the same SID before our current position, then
         * this is indeed a new SID.
         */
        if ( iFoundAce == _iCurrentAce )
        {
            fOldSid = FALSE ;
        }
        else
        {
            _iCurrentAce++ ;
            if ( _iCurrentAce >= _cTotalAces )
            {
                /* We have already set pfFoundNewSubject to FALSE
                 */
                return NERR_Success ;
            }
        }
    }

    //
    //  Special case the Creator Owner SID.  The system makes ACEs with the
    //  Creator Owner SID inherit only.  We compensate for that here by
    //  undoing what the system did.  This is a benign change
    //  since the Creator Owner SID never grants anything directly.  We do
    //  this because this class (and the security editor) expect SIDs to
    //  be on the object (in addition to child containers/objects).
    //
    if ( posaceFirstAceWithSubj->IsInheritOnly() &&
         (
            !IsContainer() ||
            (IsContainer() &&
             posaceFirstAceWithSubj->IsInherittedByNewContainers())
         ) &&
         (*possidNewSubj == _ossidCreator  ||
          *possidNewSubj == _ossidCreatorGroup ))
    {
        TRACEEOL("OS_ACL_SUBJECT_ITER::FindNextSubject - Adjusting Creator Owner ACE inheritance") ;
        posaceFirstAceWithSubj->SetInheritOnly( FALSE ) ;
    }

    *pfFoundNewSubject = TRUE ;
    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_ACL_SUBJECT_ITER::MapSpecificToGeneric

    SYNOPSIS:   This method takes an access mask and maps the specific
                (and sometimes standard) permissions to their Generic
                equivalent, clearing any bits that were mapped.

    ENTRY:      *pAccessMask - Pointer to access mask to map
                fIsInherittedByNewObjects - If TRUE, then the new object
                generic mapping is used.

    EXIT:       The access mask will have some set of generic bits set and
                the corresponding specific/standard bits cleared according
                to the generic mapping passed in at construction.

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:

    HISTORY:
        Johnl   26-Feb-1992     Created

********************************************************************/

APIERR OS_ACL_SUBJECT_ITER::MapSpecificToGeneric( ACCESS_MASK * pAccessMask,
                                                  BOOL fIsInherittedByNewObjects )
{
    APIERR err = NERR_Success ;
    PGENERIC_MAPPING pGenMapping = fIsInherittedByNewObjects ?
                                    _pGenericMappingNewObjects :
                                    _pGenericMapping ;
    UIASSERT( pGenMapping != NULL ) ;

    /* First check if the access mask is a "Generic All" access mask
     */
    if ( (pGenMapping->GenericAll & *pAccessMask) == pGenMapping->GenericAll )
    {
        *pAccessMask &= ~pGenMapping->GenericAll ;
        *pAccessMask |= GENERIC_ALL ;

        /* If, after taking out all of the bits mapped by Generic all, there
         * are some bits left over, then something went wrong (generic all
         * mapping didn't cover all possible access bits).
         */
        if ( *pAccessMask & ~GENERIC_ALL )
        {
            DBGEOL(SZ("OS_ACL_SUBJECT_ITER::MapSpecificToGeneric - Generic All map didn't cover all possible bits!!")) ;
            err = ERROR_INVALID_PARAMETER ;
        }
    }
    else if ( !MapGenericAllOnly() )
    {
        /* Look at whether the bits match any of the other generic cases.
         */
        ACCESS_MASK TempGenRead  = *pAccessMask ;
        ACCESS_MASK TempGenWrite = *pAccessMask ;
        ACCESS_MASK TempGenExec  = *pAccessMask ;
        ACCESS_MASK Generics = 0 ;

        if ( (pGenMapping->GenericRead & *pAccessMask) ==
                                                pGenMapping->GenericRead )
        {
            TempGenRead &= ~pGenMapping->GenericRead ;
            Generics |= GENERIC_READ ;
        }

        if ( (pGenMapping->GenericWrite & *pAccessMask) ==
                                                pGenMapping->GenericWrite )
        {
            TempGenWrite &= ~pGenMapping->GenericWrite ;
            Generics |= GENERIC_WRITE ;
        }

        if ( (pGenMapping->GenericExecute & *pAccessMask) ==
                                                pGenMapping->GenericExecute )
        {
            TempGenExec &= ~pGenMapping->GenericExecute ;
            Generics |= GENERIC_EXECUTE ;
        }

        /* At this point, Generics contains all of the generic bits set and
         * anding all of the TempGen* access masks will give all of the bits
         * that weren't masked out by a mapping (such as the standard bits).
         */

        *pAccessMask = Generics | ( TempGenRead & TempGenWrite & TempGenExec ) ;
    }

    return err ;
}

/*******************************************************************

    NAME:       OS_ACL_SUBJECT_ITER::Compare

    SYNOPSIS:   Compares this subject iter with psubjiter

    ENTRY:      pfACLEqual - Will be set to TRUE if the ACLs are equal
                psubjiter - Subj iter to compare

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   09-Nov-1992     Created

********************************************************************/

APIERR OS_ACL_SUBJECT_ITER::Compare( BOOL * pfACLEqual,
                                     OS_ACL_SUBJECT_ITER * psubjiter )
{
    APIERR err = NERR_Success ;
    INT  cSubjIter1Subjects = 0,
         cSubjIter2Subjects = 0 ;
    *pfACLEqual = TRUE ;
    BOOL fQuitCauseACLAintEqual = FALSE ;

    //
    //  First compare the number of unique SIDs in each ACL.  If they are
    //  different, then we get out right away.
    //

    while ( psubjiter->Next( &err ) && !err )
        cSubjIter1Subjects++ ;

    if ( err )
        return err ;

    while ( Next( &err ) && !err )
        cSubjIter2Subjects++ ;

    if ( err )
        return err ;

    if ( cSubjIter1Subjects != cSubjIter2Subjects )
    {
        *pfACLEqual = FALSE ;
        return err ;
    }

    Reset() ;
    psubjiter->Reset() ;

    //
    //  Now go through each subject and compare the masks and inheritance
    //  bits
    //
    //  CODEWORK - This is the expensive way of doing things, would be
    //  prefereable to not have an n^2 algorithm
    //

    while ( psubjiter->Next( &err ) && !err )
    {
        BOOL fFoundMatchingSID = FALSE ;
        while ( Next( &err ) &&
                !err )
        {
            if ( *psubjiter->QuerySID() == *QuerySID() )
            {
                if ( !CompareCurrentSubject( psubjiter ) )
                {
                    fQuitCauseACLAintEqual = TRUE ;
                    break ;
                }
                //
                //  There will be only one unique SID per "Next"
                //
                fFoundMatchingSID = TRUE ;
                break ;
            }
        } // while subjiter2

        //
        //  If no match was found, then these aren't equal
        //
        if ( err || fQuitCauseACLAintEqual || !fFoundMatchingSID )
        {
            fQuitCauseACLAintEqual = TRUE ;
            break ;
        }

        Reset() ;
    } // while psubjiter

    if ( fQuitCauseACLAintEqual )
        *pfACLEqual = FALSE ;

    return err ;
}

/*******************************************************************

    NAME:       OS_DACL_SUBJECT_ITER::OS_DACL_SUBJECT_ITER

    SYNOPSIS:   Standard Constructor/destructor

    ENTRY:      posacl - Pointer to valid ACL to iterate over

    EXIT:

    RETURNS:

    NOTES:      The ACL must conform to the Deny All followed by grants
                form.

                The private data members are initialized when used in Next.

    HISTORY:
        Johnl   23-Dec-1991     Created

********************************************************************/

OS_DACL_SUBJECT_ITER::OS_DACL_SUBJECT_ITER( OS_ACL * posacl,
                                            PGENERIC_MAPPING pGenericMapping,
                                            PGENERIC_MAPPING pGenericMappingNewObjects,
                                            BOOL             fMapGenAllOnly,
                                            BOOL             fIsContainer )
    : OS_ACL_SUBJECT_ITER( posacl,
                           pGenericMapping,
                           pGenericMappingNewObjects,
                           fMapGenAllOnly,
                           fIsContainer  )
{
    if ( QueryError() )
        return ;

    //
    //  Check for a bad mix of grants or denies or unrecognized ACEs
    //
    APIERR err = NERR_Success ;
    ULONG  cAces ;
    OS_ACE osace ;
    if ( (err = posacl->QueryACECount( &cAces )) ||
         (err = osace.QueryError()) )
    {
        ReportError( err ) ;
        return ;
    }

    BOOL fFoundGrant = FALSE ;
    for ( ULONG i = 0 ; !err && i < cAces ; i++ )
    {
        if ( err = posacl->QueryACE( i, &osace ) )
        {
            break ;
        }

        switch ( osace.QueryType() )
        {
        case ACCESS_ALLOWED_ACE_TYPE:
            fFoundGrant = TRUE ;
            break ;

        case ACCESS_DENIED_ACE_TYPE:
            if ( fFoundGrant )
            {
                DBGEOL("OS_DACL_SUBJECT_ITER::ct - Found Deny ACE after grant ACE") ;
                err = IERR_UNRECOGNIZED_ACL ;
            }
            break ;

        default:
            err = IERR_UNRECOGNIZED_ACL ;
        }
    }

    if ( err )
        ReportError( err ) ;
}

OS_DACL_SUBJECT_ITER::~OS_DACL_SUBJECT_ITER()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:       OS_DACL_SUBJECT_ITER::Next

    SYNOPSIS:   Moves to the next subject in this ACL

    ENTRY:      perr - Pointer to receive error code if one occurs

    EXIT:       The Data members will be updated to contain the data
                as specified by the ACEs in this ACL

    RETURNS:    TRUE if a new subject was found in this ACL and the Query
                methods will return valid data.  FALSE if there are no
                more SIDs or an error occurred.

    NOTES:      IERR_UNRECOGNIZED_ACL may be returned if a particular
                series of ACEs occur that cannot be expressed by this
                iterator.

    HISTORY:
        Johnl   23-Dec-1991     Created

********************************************************************/

BOOL OS_DACL_SUBJECT_ITER::Next( APIERR * perr )
{
    /* Assume the operation will succeed
     */
    *perr = NERR_Success ;

    OS_ACE osaceCurrent ;
    OS_SID ossidKey ;
    BOOL   fFoundNewSubj ;
    if ( (*perr = ossidKey.QueryError()) ||
         (*perr = osaceCurrent.QueryError()) ||
         (*perr = FindNextSubject( &fFoundNewSubj, &ossidKey, &osaceCurrent ))||
         ( !fFoundNewSubj ) )
    {
        if ( *perr )
            DBGEOL(SZ("OS_DACL_SUBJECT_ITER::Next - error ") << (ULONG) *perr <<
                    SZ(" occurred on FindNextSubject")) ;

        return FALSE ;
    }

    /* We have found a new SID, so find the rest of the permissions in this
     * ACL and accumulate the permissions as appropriate.
     */
    _accessmask           = 0      ;
    _fDenyAll             = FALSE  ;
    _fHasAce              = FALSE  ;
    _accessmaskNewObj     = 0      ;
    _fDenyAllNewObj       = FALSE  ;
    _fHasAceNewObj        = FALSE  ;
    _accessmaskNewCont    = 0      ;
    _fDenyAllNewCont      = FALSE  ;
    _fHasAceNewCont       = FALSE  ;
    _accessmaskInheritOnly= 0      ;
    _fDenyAllInheritOnly  = FALSE  ;
    _fHasAceInheritOnly   = FALSE  ;

    BOOL fMoreAces = TRUE ;
    ULONG iAce = QueryCurrentACE() ;
    while ( fMoreAces )
    {
        /* If inherittance is "On", then inherittance must also be propagated.
         */
        if ( IsContainer() &&
             (osaceCurrent.IsInherittedByNewObjects() ||
              osaceCurrent.IsInherittedByNewContainers()) &&
             !osaceCurrent.IsInheritancePropagated() )
        {
            UIDEBUG(SZ("OS_DACL_SUBJECT_ITER::Next - Inheritance not propagated in ACE\n\r")) ;
            *perr = IERR_UNRECOGNIZED_ACL ;
            return FALSE ;
        }

        /* The following may not be safe for sub-items that have specific
         * permissions set (that correspond to this container's generic
         * mapping.  This is really the responsibility of the client of the
         * Acl Editor API.
         */
        ACCESS_MASK MappedAccessMask = osaceCurrent.QueryAccessMask() ;
        if ( *perr = MapSpecificToGeneric( &MappedAccessMask,
                                           osaceCurrent.IsInherittedByNewObjects() ))
        {
            return FALSE ;
        }

        switch ( osaceCurrent.QueryType() )
        {
        case ACCESS_DENIED_ACE_TYPE:
            /* If we found a Deny ACE after finding a Grant ACE or
             *    The deny ACE is not Deny ALL
             * then we can't process this DACL.
             */
            if ( !(MappedAccessMask & GENERIC_ALL) )
            {
                DBGEOL("OS_DACL_SUBJECT_ITER::Next - Partial deny ACE found") ;
                *perr = IERR_UNRECOGNIZED_ACL ;
                return FALSE ;
            }

            if ( !osaceCurrent.IsInheritOnly() )
            {
                /* Have we hit a grant already for this type of ACE?  If so
                 * then it is an unrecognized DACL.  Note that the deny
                 * will take precedence over other masks for this ACE.
                 */
                if ( _fHasAce && _accessmask != 0 )
                {
                    *perr = IERR_UNRECOGNIZED_ACL ;
                    break ;
                }

                _accessmask = 0 ;
                _fDenyAll = TRUE ;
                _fHasAce  = TRUE ;
            }
            else
            {
#if 0
//
//  We shouldn't need to check the inherit only flags since we will catch
//  them in either oi or ci case.  We should be able to safely comment
//  the inherit only sections out since they will always be initialized to
//  zero.
//
                if ( _fHasAceInheritOnly && _accessmaskInheritOnly != 0 )
                {
                    *perr = IERR_UNRECOGNIZED_ACL ;
                    break ;
                }

                _accessmaskInheritOnly = 0 ;
                _fDenyAllInheritOnly   = TRUE ;
                _fHasAceInheritOnly    = TRUE ;
#endif //0
            }

            if ( osaceCurrent.IsInherittedByNewObjects() )
            {
                if ( _fHasAceNewObj && _accessmaskNewObj != 0 )
                {
                    *perr = IERR_UNRECOGNIZED_ACL ;
                    break ;
                }

                _accessmaskNewObj = 0 ;
                _fDenyAllNewObj = TRUE ;
                _fHasAceNewObj  = TRUE ;
            }

            if ( osaceCurrent.IsInherittedByNewContainers() )
            {
                if ( _fHasAceNewCont && _accessmaskNewCont != 0 )
                {
                    *perr = IERR_UNRECOGNIZED_ACL ;
                    break ;
                }

                _accessmaskNewCont = 0 ;
                _fDenyAllNewCont = TRUE ;
                _fHasAceNewCont  = TRUE ;
            }
            break ;

        case ACCESS_ALLOWED_ACE_TYPE:
            if ( !osaceCurrent.IsInheritOnly() &&
                 !_fDenyAll )
            {
                _accessmask |= MappedAccessMask ;
                _fHasAce  = TRUE ;
            }
            else if ( !_fDenyAllInheritOnly )
            {
#if 0
                _accessmaskInheritOnly |= MappedAccessMask ;
                _fHasAceInheritOnly  = TRUE ;
#endif
            }


            if ( osaceCurrent.IsInherittedByNewObjects() &&
                 !_fDenyAllNewObj )
            {
                _accessmaskNewObj |= MappedAccessMask ;
                _fHasAceNewObj  = TRUE ;
            }

            if ( osaceCurrent.IsInherittedByNewContainers() &&
                 !_fDenyAllNewCont )
            {
                _accessmaskNewCont |= MappedAccessMask ;
                _fHasAceNewCont  = TRUE ;
            }

            break ;

        default:
            UIDEBUG(SZ("OS_DACL_SUBJECT_ITER::Next - ACE not Access Allowed or Access Denied\n\r")) ;
            *perr = IERR_UNRECOGNIZED_ACL ;
            return FALSE ;
        }

        if ( *perr )
        {
            DBGEOL("OS_DACL_SUBJECT_ITER::Next - Returning error " << (ULONG) *perr ) ;
            return FALSE ;
        }

        /* Find the next ACE for this SID
         *
         * Start searching for the next ACE one after the ACE we just
         * looked at
         */
        iAce++ ;
        if ( iAce >= QueryTotalAceCount() )
        {
            fMoreAces = FALSE ;
        }
        else if ( (*perr = QueryACL()->FindACE( ossidKey,
                                                &fMoreAces,
                                                &osaceCurrent,
                                                &iAce,
                                                iAce )) )
        {
            DBGEOL(SZ("OS_DACL_SUBJECT_ITER::Next - FindACE failed")) ;
            return FALSE ;
        }

        //
        //  Adjust the inherit flags on this ACE if it contains the creator
        //  owner SID
        //
        if ( osaceCurrent.IsInheritOnly() &&
             (
                !IsContainer() ||
                (IsContainer() &&
                 osaceCurrent.IsInherittedByNewContainers())
             ) &&
             ( ossidKey == _ossidCreator  ||
               ossidKey == _ossidCreatorGroup ))
        {
            TRACEEOL("OS_DACL_SUBJECT_ITER::Next - Adjusting Creator Owner ACE inheritance") ;
            osaceCurrent.SetInheritOnly( FALSE ) ;
        }
    }

    if ( *perr = ((OS_SID *)QuerySID())->Copy( ossidKey ))
    {
        DBGEOL(SZ("OS_DACL_SUBJECT_ITER::Next - Copy SID failed")) ;
        return FALSE ;
    }

    SetCurrentACE( QueryCurrentACE() + 1 ) ;
    return TRUE ;
}

/*******************************************************************

    NAME:       OS_DACL_SUBJECT_ITER::CompareCurrentSubject

    SYNOPSIS:   Returns TRUE if the current subject if the passed psubjiter
                equals the current subject of this.  FALSE if they are not
                equal

    ENTRY:      psubjiter - Pointer to subject iter to compare against

    RETURNS:    TRUE if they are equal, FALSE if they are not equal

    NOTES:      psubjiter must be a pointer to a OS_DACL_SUBJECT_ITER.

    HISTORY:
        Johnl   09-Nov-1992     Created

********************************************************************/

BOOL OS_DACL_SUBJECT_ITER::CompareCurrentSubject( OS_ACL_SUBJECT_ITER * psubjiter )
{
    UIASSERT( IsContainer() == psubjiter->IsContainer() ) ;
    OS_DACL_SUBJECT_ITER * pdaclsubjiter = (OS_DACL_SUBJECT_ITER *) psubjiter ;

    if ( pdaclsubjiter->IsDenyAll()  != IsDenyAll()  ||
         pdaclsubjiter->HasThisAce() != HasThisAce() ||
         pdaclsubjiter->QueryAccessMask() != QueryAccessMask())
    {
        return FALSE ;
    }

    if ( IsContainer() &&
        (pdaclsubjiter->IsNewObjectDenyAll()         != IsNewObjectDenyAll() ||
         pdaclsubjiter->IsNewContainerDenyAll()      != IsNewContainerDenyAll() ||
         pdaclsubjiter->IsInheritOnlyDenyAll()       != IsInheritOnlyDenyAll() ||
         pdaclsubjiter->HasNewObjectAce()            != HasNewObjectAce() ||
         pdaclsubjiter->HasNewContainerAce()         != HasNewContainerAce() ||
         pdaclsubjiter->HasInheritOnlyAce()          != HasInheritOnlyAce() ||
         pdaclsubjiter->QueryNewObjectAccessMask()   != QueryNewObjectAccessMask() ||
         pdaclsubjiter->QueryNewContainerAccessMask()!= QueryNewContainerAccessMask() ||
         pdaclsubjiter->QueryInheritOnlyAccessMask() != QueryInheritOnlyAccessMask()))
    {
        return FALSE ;
    }

    return TRUE ;
}

/*******************************************************************

    NAME:       OS_SACL_SUBJECT_ITER::OS_SACL_SUBJECT_ITER

    SYNOPSIS:   Standard Constructor/destructor

    ENTRY:      posacl - Pointer to valid ACL to iterate over

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   23-Dec-1991     Created

********************************************************************/

OS_SACL_SUBJECT_ITER::OS_SACL_SUBJECT_ITER( OS_ACL * posacl,
                                            PGENERIC_MAPPING pGenericMapping,
                                            PGENERIC_MAPPING pGenericMappingNewObjects,
                                            BOOL             fMapGenAllOnly,
                                            BOOL             fIsContainer )
    : OS_ACL_SUBJECT_ITER( posacl,
                           pGenericMapping,
                           pGenericMappingNewObjects,
                           fMapGenAllOnly,
                           fIsContainer )
{
    if ( QueryError() )
        return ;

    InitToZero() ;
}

OS_SACL_SUBJECT_ITER::~OS_SACL_SUBJECT_ITER()
{
    /* Nothing to do */
}

void OS_SACL_SUBJECT_ITER::InitToZero( void )
{
    for ( int i = 0 ; i < OS_SACL_DESC_LAST ; i++ )
        _asaclDesc[i].InitToZero() ;
}

/*******************************************************************

    NAME:       OS_SACL_SUBJECT_ITER::Next

    SYNOPSIS:   Moves to the next subject in this ACL

    ENTRY:      perr - Pointer to receive error code if one occurs

    EXIT:       The Data members will be updated to contain the data
                as specified by the ACEs in this ACL

    RETURNS:    TRUE if a new subject was found in this ACL and the Query
                methods will return valid data.  FALSE if there are no
                more SIDs ore an error occurred.

    NOTES:      IERR_UNRECOGNIZED_ACL may be returned if a particular
                series of ACEs occur that cannot be expressed by this
                iterator.

    HISTORY:
        Johnl   23-Dec-1991     Created

********************************************************************/

BOOL OS_SACL_SUBJECT_ITER::Next( APIERR * perr )
{
    /* Assume the operation will succeed
     */
    *perr = NERR_Success ;

    OS_ACE osaceCurrent ;
    OS_SID ossidKey ;
    BOOL   fFoundNewSubj ;
    if ( (*perr = ossidKey.QueryError()) ||
         (*perr = osaceCurrent.QueryError()) ||
         (*perr = FindNextSubject( &fFoundNewSubj, &ossidKey, &osaceCurrent )) ||
         ( !fFoundNewSubj ) )
    {
        return FALSE ;
    }

    /* We have found a new SID, so find the rest of the permissions in this
     * ACL and accumulate the permissions as appropriate.
     */
    InitToZero() ;

    BOOL fMoreAces = TRUE ;
    ULONG iAce = QueryCurrentACE() ;
    while ( fMoreAces )
    {
        /* If inherittance is "On", then inherittance must also be propagated.
         */
        if ( IsContainer() &&
             (osaceCurrent.IsInherittedByNewObjects() ||
              osaceCurrent.IsInherittedByNewContainers()) &&
             !osaceCurrent.IsInheritancePropagated() )
        {
            UIDEBUG(SZ("OS_DACL_SUBJECT_ITER::Next - Inheritance not propagated in ACE\n\r")) ;
            *perr = IERR_UNRECOGNIZED_ACL ;
            return FALSE ;
        }

        ACCESS_MASK MappedAccessMask = osaceCurrent.QueryAccessMask() ;
        if ( *perr = MapSpecificToGeneric( &MappedAccessMask,
                                           osaceCurrent.IsInherittedByNewObjects() ))
        {
            *perr = IERR_UNRECOGNIZED_ACL ;
            return FALSE ;
        }

        /* Since an ACE can only be a system audit or system alarm ace,
         * we can use an offset into the description array to choose
         * the correct item.  All the other attributes are bitfields so
         * we have to check each individually.
         */
        UINT uiTypeOffset = osaceCurrent.QueryType() & SYSTEM_AUDIT_ACE_TYPE ?
                                          0 :
                                          OS_SACL_DESC_THIS_OBJECT_S_ALARM ;
        UIASSERT( (osaceCurrent.QueryType() & SYSTEM_AUDIT_ACE_TYPE) ||
                  (osaceCurrent.QueryType() & SYSTEM_ALARM_ACE_TYPE)    ) ;

        if ( !((osaceCurrent.QueryAceFlags() & SUCCESSFUL_ACCESS_ACE_FLAG) ||
               (osaceCurrent.QueryAceFlags() & FAILED_ACCESS_ACE_FLAG)))
        {
            UIDEBUG(SZ("OS_DACL_SUBJECT_ITER::Next - Unrecognized ACE Flags\n\r")) ;
            *perr = IERR_UNRECOGNIZED_ACL ;
            return FALSE ;
        }

        if ( !osaceCurrent.IsInheritOnly() )
        {
            if ( osaceCurrent.QueryAceFlags() & SUCCESSFUL_ACCESS_ACE_FLAG )
            {
                _asaclDesc[OS_SACL_DESC_THIS_OBJECT_S_AUDIT+uiTypeOffset]._accessmask |=
                        MappedAccessMask ;
                _asaclDesc[OS_SACL_DESC_THIS_OBJECT_S_AUDIT+uiTypeOffset]._fHasAce = TRUE ;
            }

            if ( osaceCurrent.QueryAceFlags() & FAILED_ACCESS_ACE_FLAG )
            {
                _asaclDesc[OS_SACL_DESC_THIS_OBJECT_F_AUDIT+uiTypeOffset]._accessmask |=
                        MappedAccessMask ;
                _asaclDesc[OS_SACL_DESC_THIS_OBJECT_F_AUDIT+uiTypeOffset]._fHasAce = TRUE ;
            }

        }
        else
        {
#if 0
            if ( osaceCurrent.QueryAceFlags() & SUCCESSFUL_ACCESS_ACE_FLAG )
            {
                _asaclDesc[OS_SACL_DESC_INHERIT_ONLY_S_AUDIT+uiTypeOffset]._accessmask |=
                        MappedAccessMask ;
                _asaclDesc[OS_SACL_DESC_INHERIT_ONLY_S_AUDIT+uiTypeOffset]._fHasAce = TRUE ;
            }

            if ( osaceCurrent.QueryAceFlags() & FAILED_ACCESS_ACE_FLAG )
            {
                _asaclDesc[OS_SACL_DESC_INHERIT_ONLY_F_AUDIT+uiTypeOffset]._accessmask |=
                        MappedAccessMask ;
                _asaclDesc[OS_SACL_DESC_INHERIT_ONLY_F_AUDIT+uiTypeOffset]._fHasAce = TRUE ;
            }
#endif
        }

        if ( osaceCurrent.IsInherittedByNewObjects() )
        {
            if ( osaceCurrent.QueryAceFlags() & SUCCESSFUL_ACCESS_ACE_FLAG )
            {
                _asaclDesc[OS_SACL_DESC_NEW_OBJECT_S_AUDIT+uiTypeOffset]._accessmask |=
                        MappedAccessMask ;
                _asaclDesc[OS_SACL_DESC_NEW_OBJECT_S_AUDIT+uiTypeOffset]._fHasAce = TRUE ;
            }

            if ( osaceCurrent.QueryAceFlags() & FAILED_ACCESS_ACE_FLAG )
            {
                _asaclDesc[OS_SACL_DESC_NEW_OBJECT_F_AUDIT+uiTypeOffset]._accessmask |=
                        MappedAccessMask ;
                _asaclDesc[OS_SACL_DESC_NEW_OBJECT_F_AUDIT+uiTypeOffset]._fHasAce = TRUE ;
            }
        }

        if ( osaceCurrent.IsInherittedByNewContainers() )
        {
            if ( osaceCurrent.QueryAceFlags() & SUCCESSFUL_ACCESS_ACE_FLAG )
            {
                _asaclDesc[OS_SACL_DESC_NEW_CONT_S_AUDIT+uiTypeOffset]._accessmask |=
                        MappedAccessMask ;
                _asaclDesc[OS_SACL_DESC_NEW_CONT_S_AUDIT+uiTypeOffset]._fHasAce = TRUE ;
            }

            if ( osaceCurrent.QueryAceFlags() & FAILED_ACCESS_ACE_FLAG )
            {
                _asaclDesc[OS_SACL_DESC_NEW_CONT_F_AUDIT+uiTypeOffset]._accessmask |=
                        MappedAccessMask ;
                _asaclDesc[OS_SACL_DESC_NEW_CONT_F_AUDIT+uiTypeOffset]._fHasAce = TRUE ;
            }
        }

        /* Start searching for the next ACE with this SID one after
         * the ACE we just looked at
         */
        iAce++ ;
        if ( iAce >= QueryTotalAceCount() )
        {
            fMoreAces = FALSE ;
        }
        else if ( (*perr = QueryACL()->FindACE( ossidKey, &fMoreAces, &osaceCurrent,
                                        &iAce, iAce ))              )
        {
            DBGEOL(SZ("OS_SACL_SUBJECT_ITER::Next - FindACE failed")) ;
            return FALSE ;
        }

        //
        //  Adjust the inherit flags on this ACE if it contains the creator
        //  owner SID
        //
        if ( osaceCurrent.IsInheritOnly() &&
             (
                !IsContainer() ||
                (IsContainer() &&
                 osaceCurrent.IsInherittedByNewContainers())
             ) &&
             ( ossidKey == _ossidCreator  ||
               ossidKey == _ossidCreatorGroup ))
        {
            TRACEEOL("OS_DACL_SUBJECT_ITER::Next - Adjusting Creator Owner ACE inheritance") ;
            osaceCurrent.SetInheritOnly( FALSE ) ;
        }
    }

    if ( *perr = ((OS_SID *) QuerySID())->Copy( ossidKey ))
    {
        DBGEOL(SZ("OS_SACL_SUBJECT_ITER::Next - Copy SID failed")) ;
        return FALSE ;
    }

    SetCurrentACE( QueryCurrentACE() + 1 ) ;
    return TRUE ;
}

/*******************************************************************

    NAME:       OS_SACL_SUBJECT_ITER::CompareCurrentSubject

    SYNOPSIS:   Returns TRUE if the current subject if the passed psubjiter
                equals the current subject of this.  FALSE if they are not
                equal

    ENTRY:      psubjiter - Pointer to subject iter to compare against

    RETURNS:    TRUE if they are equal, FALSE if they are not equal

    NOTES:      psubjiter must be a pointer to a OS_SACL_SUBJECT_ITER.

    HISTORY:
        Johnl   09-Nov-1992     Created

********************************************************************/

BOOL OS_SACL_SUBJECT_ITER::CompareCurrentSubject( OS_ACL_SUBJECT_ITER * psubjiter )
{
    OS_SACL_SUBJECT_ITER * psaclsubjiter = (OS_SACL_SUBJECT_ITER *) psubjiter ;

    if ( psaclsubjiter->HasThisAuditAce_S()      != HasThisAuditAce_S() ||
         psaclsubjiter->QueryAuditAccessMask_S() != QueryAuditAccessMask_S() ||
         psaclsubjiter->HasThisAuditAce_F()      != HasThisAuditAce_F() ||
         psaclsubjiter->QueryAuditAccessMask_F() != QueryAuditAccessMask_F()
       )
    {
        return FALSE ;
    }

    if ( IsContainer() &&
        (psaclsubjiter->HasNewObjectAuditAce_S()      != HasNewObjectAuditAce_S() ||
         psaclsubjiter->QueryNewObjectAuditAccessMask_S() != QueryNewObjectAuditAccessMask_S() ||
         psaclsubjiter->HasNewObjectAuditAce_F()      != HasNewObjectAuditAce_F() ||
         psaclsubjiter->QueryNewObjectAuditAccessMask_F() != QueryNewObjectAuditAccessMask_F() ||

         psaclsubjiter->HasNewContainerAuditAce_S()      != HasNewContainerAuditAce_S() ||
         psaclsubjiter->QueryNewContainerAuditAccessMask_S() != QueryNewContainerAuditAccessMask_S() ||
         psaclsubjiter->HasNewContainerAuditAce_F()      != HasNewContainerAuditAce_F() ||
         psaclsubjiter->QueryNewContainerAuditAccessMask_F() != QueryNewContainerAuditAccessMask_F() ||

         psaclsubjiter->HasInheritOnlyAuditAce_S()      != HasInheritOnlyAuditAce_S() ||
         psaclsubjiter->QueryInheritOnlyAuditAccessMask_S() != QueryInheritOnlyAuditAccessMask_S() ||
         psaclsubjiter->HasInheritOnlyAuditAce_F()      != HasInheritOnlyAuditAce_F() ||
         psaclsubjiter->QueryInheritOnlyAuditAccessMask_F() != QueryInheritOnlyAuditAccessMask_F()
        )
         /* Alert ACEs will go here */
       )
    {
        return FALSE ;
    }

    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\uintlsa.cxx ===
/**********************************************************************/
/**			  Microsoft Windows NT	 		     **/
/**		   Copyright(c) Microsoft Corp., 1992		     **/
/**********************************************************************/

/*
 * This module contains the wrappers for LSA-based objects.
 *
 *
 * History
 *	thomaspa	01/17/92	Created from ntsam.cxx
 */

#include "pchlmobj.hxx"  // Precompiled header



/*******************************************************************

    NAME: LSA_MEMORY::LSA_MEMORY

    SYNOPSIS: Constructor

    ENTRY: pvBuffer - pointer to the LSA allocated buffer
	   cItems - count of items in buffer

    EXIT: none

    NOTES:

    HISTORY:
	thomaspa	03/03/92	Created

********************************************************************/
LSA_MEMORY::LSA_MEMORY( BOOL fOwnerAlloc )
	: NT_MEMORY( ),
	_fOwnerAlloc( fOwnerAlloc )
{
    if ( QueryError() != NERR_Success )
	return;
}

/*******************************************************************

    NAME: LSA_MEMORY::~LSA_MEMORY()

    SYNOPSIS: Destructor.  Deallocates the LSA allocated buffer

    ENTRY: none

    EXIT: none

    NOTES:

    HISTORY:
	thomaspa	03/03/92	Created

********************************************************************/
LSA_MEMORY::~LSA_MEMORY()
{
    Set( NULL, 0 );
}



/*******************************************************************

    NAME: LSA_TRANSLATED_NAME_MEM::LSA_TRANSLATED_NAME_MEM

    SYNOPSIS: Constructor

    ENTRY: pvBuffer - pointer to the LSA allocated buffer
	   cItems - count of items in buffer

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/22/92	Created

********************************************************************/
LSA_TRANSLATED_NAME_MEM::LSA_TRANSLATED_NAME_MEM( BOOL fOwnerAlloc )
    : LSA_MEMORY( fOwnerAlloc )
{
}


/*******************************************************************

    NAME: LSA_TRANSLATED_NAME_MEM::~LSA_TRANSLATED_NAME_MEM

    SYNOPSIS: Destructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/22/92	Created

********************************************************************/
LSA_TRANSLATED_NAME_MEM::~LSA_TRANSLATED_NAME_MEM()
{
}


/*******************************************************************

    NAME: LSA_TRANSLATED_SID_MEM::LSA_TRANSLATED_SID_MEM

    SYNOPSIS: Constuctor

    ENTRY:

    EXIT: none

    NOTES:

    HISTORY:
	thomaspa	02/22/92	Created

********************************************************************/
LSA_TRANSLATED_SID_MEM::LSA_TRANSLATED_SID_MEM( BOOL fOwnerAlloc )
    : LSA_MEMORY( fOwnerAlloc )
{
}


/*******************************************************************

    NAME: LSA_TRANSLATED_SID_MEM::~LSA_TRANSLATED_SID_MEM

    SYNOPSIS: Destructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/22/92	Created

********************************************************************/
LSA_TRANSLATED_SID_MEM::~LSA_TRANSLATED_SID_MEM()
{
}

/*******************************************************************

    NAME:	LSA_TRANSLATED_SID_MEM::QueryFailingNameIndex

    SYNOPSIS:	Finds the first name that failed from the lookup

    ENTRY:	pi - Receives the index

    RETURNS:	TRUE if a failing index was found, FALSE otherwise

    NOTES:

    HISTORY:
	Johnl	10-Dec-1992	Created

********************************************************************/

BOOL LSA_TRANSLATED_SID_MEM::QueryFailingNameIndex( ULONG * pi )
{
    UIASSERT( pi != NULL ) ;

    if ( QueryPtr() == NULL )
    {
	*pi = 0 ;
	return TRUE ;
    }

    ULONG cItems = QueryCount() ;
    for ( ULONG i = 0 ; i < cItems ; i++ )
    {
	//
	//  Look at the SID_NAME_USE.  The RID is zero for Everyone and
	//  Creator Owner
	//
	if ( (QueryPtr()[i].Use == SidTypeUnknown) ||
	     (QueryPtr()[i].Use == SidTypeInvalid) )
	{
	    *pi = i ;
	    return TRUE ;
	}
    }

    return FALSE ;
}

/*******************************************************************

    NAME: LSA_TRUST_INFO_MEM::LSA_TRUST_INFO_MEM

    SYNOPSIS: Constructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	03/03/92	Created

********************************************************************/
LSA_TRUST_INFO_MEM::LSA_TRUST_INFO_MEM( BOOL fOwnerAlloc )
	: LSA_MEMORY( fOwnerAlloc )
{
}




/*******************************************************************

    NAME: LSA_TRUST_INFO_MEM::~LSA_TRUST_INFO_MEM

    SYNOPSIS: Destructor

    ENTRY: none

    EXIT: none

    NOTES:

    HISTORY:
	thomaspa	03/03/92	Created

********************************************************************/
LSA_TRUST_INFO_MEM::~LSA_TRUST_INFO_MEM()
{
}





/*******************************************************************

    NAME: LSA_REF_DOMAIN_MEM::LSA_REF_DOMAIN_MEM

    SYNOPSIS: Constructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/22/92	Created

********************************************************************/
LSA_REF_DOMAIN_MEM::LSA_REF_DOMAIN_MEM( BOOL fOwnerAlloc )
    : LSA_MEMORY( fOwnerAlloc )
{
}



/*******************************************************************

    NAME: LSA_REF_DOMAIN_MEM::~LSA_REF_DOMAIN_MEM

    SYNOPSIS: Destructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/22/92	Created

********************************************************************/
LSA_REF_DOMAIN_MEM::~LSA_REF_DOMAIN_MEM()
{
}




/*******************************************************************

    NAME: LSA_ACCT_DOM_INFO_MEM::LSA_ACCT_DOM_INFO

    SYNOPSIS: Constructor

    ENTRY:


    NOTES: This NT_MEMORY-based object is slightly different from the
	others in that it only ever contains a single item.

    HISTORY:
	thomaspa	03/03/92	Created

********************************************************************/
LSA_ACCT_DOM_INFO_MEM::LSA_ACCT_DOM_INFO_MEM( BOOL fOwnerAlloc )
	: LSA_MEMORY( fOwnerAlloc )
{
}



/*******************************************************************

    NAME: LSA_ACCT_DOM_INFO_MEM::~LSA_ACCT_DOM_INFO

    SYNOPSIS: Destructor

    ENTRY:


    NOTES:

    HISTORY:
	thomaspa	03/03/92	Created

********************************************************************/
LSA_ACCT_DOM_INFO_MEM::~LSA_ACCT_DOM_INFO_MEM()
{
}

/*******************************************************************

    NAME: LSA_PRIMARY_DOM_INFO_MEM::LSA_PRIMARY_DOM_INFO_MEM

    SYNOPSIS: Constructor

    ENTRY:


    NOTES: This NT_MEMORY-based object is slightly different from the
	others in that it only ever contains a single item.

    HISTORY:
	DavidHov  04/9/92	Created

********************************************************************/
LSA_PRIMARY_DOM_INFO_MEM::LSA_PRIMARY_DOM_INFO_MEM( BOOL fOwnerAlloc )
	: LSA_MEMORY( fOwnerAlloc )
{
}

/*******************************************************************

    NAME: LSA_PRIMARY_DOM_INFO_MEM::~LSA_PRIMARY_DOM_INFO

    SYNOPSIS: Destructor

    ENTRY:

    NOTES:

    HISTORY:
	thomaspa	03/03/92	Created

********************************************************************/
LSA_PRIMARY_DOM_INFO_MEM::~LSA_PRIMARY_DOM_INFO_MEM()
{
}

/*******************************************************************

    NAME: LSA_AUDIT_EVENT_INFO_MEM::LSA_AUDIT_EVENT_INFO_MEM

    SYNOPSIS: Constructor

    ENTRY:

    NOTES: This MEM object is slightly different from the others in
	that it only ever contains a single item.

    HISTORY:
	Yi-HsinS	04/01/92	Created

********************************************************************/

LSA_AUDIT_EVENT_INFO_MEM::LSA_AUDIT_EVENT_INFO_MEM( BOOL fOwnerAlloc )
	: LSA_MEMORY( fOwnerAlloc )
{
}

/*******************************************************************

    NAME: LSA_AUDIT_EVENT_INFO_MEM::~LSA_AUDIT_EVENT_INFO_MEM

    SYNOPSIS: Destructor

    ENTRY:


    NOTES:

    HISTORY:
	Yi-HsinS	04/01/92	Created

********************************************************************/

LSA_AUDIT_EVENT_INFO_MEM::~LSA_AUDIT_EVENT_INFO_MEM()
{
}

/*******************************************************************

    NAME: LSA_OBJECT::LSA_OBJECT

    SYNOPSIS: Constructor

    ENTRY: none

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/22/92	Created from ntsam.hxx

********************************************************************/
LSA_OBJECT::LSA_OBJECT()
    : BASE(),
    _hlsa( NULL ),
    _fHandleValid( FALSE )
{
    if ( QueryError() != NERR_Success )
	return;
}



/*******************************************************************

    NAME: LSA_OBJECT::~LSA_OBJECT

    SYNOPSIS: Destructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/22/92	Created from ntsam.hxx

********************************************************************/
LSA_OBJECT::~LSA_OBJECT()
{
    CloseHandle() ;
}


/*******************************************************************

    NAME:       LSA_OBJECT::CloseHandle

    SYNOPSIS:   Explict close of handle

    ENTRY:

    EXIT:

    NOTES:      No error is reported if the handle
                has already been closed (invalidated).

    HISTORY:    DavidHov   4/12/92
	 	ChuckC     7/6/92	removed needless assert

********************************************************************/
APIERR LSA_OBJECT :: CloseHandle ( BOOL fDelete )
{
    APIERR err = NERR_Success ;

    if ( _fHandleValid )
    {
        if ( _hlsa != NULL )
        {
            NTSTATUS ntStatus = fDelete
                                ? ::LsaDelete( QueryHandle() )
                                : ::LsaClose( QueryHandle() ) ;

            err = ERRMAP::MapNTStatus( ntStatus ) ;
        }
        ResetHandle() ;
    }
    return err ;
}


/*******************************************************************

    NAME: LSA_POLICY::LSA_POLICY

    SYNOPSIS: Constructor

    ENTRY: pszServerName.  Name of computer on which LSA information
	is desired.  On a LAN Manager for NT cluster, this should
	always be the name of the PDC.

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/22/92	Created from ntsam.hxx

********************************************************************/
LSA_POLICY::LSA_POLICY( const TCHAR * pszServerName,
		       ACCESS_MASK accessDesired )
    : LSA_OBJECT(),
    _lsplType( LSPL_PROD_NONE )
{

    if ( QueryError() != NERR_Success )
	return;

    APIERR err = Open( pszServerName, accessDesired ) ;

    if ( err )
        ReportError( err ) ;
}




/*******************************************************************

    NAME: LSA_POLICY::~LSA_POLICY

    SYNOPSIS: Destructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/22/92	Created from ntsam.hxx

********************************************************************/
LSA_POLICY::~LSA_POLICY()
{
}

/*******************************************************************

    NAME:       LSA_POLICY::Open

    SYNOPSIS:   Obtain an LSA Policy Handle.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:    DavidHov 4/12/92   Separated from constructor
	
********************************************************************/
APIERR LSA_POLICY :: Open (
    const TCHAR * pszServerName,
    ACCESS_MASK accessDesired )
{
    UNICODE_STRING unistrServerName;
    PUNICODE_STRING punistrServerName = NULL ;
    LSA_HANDLE hlsa;
    OBJECT_ATTRIBUTES oa;
    SECURITY_QUALITY_OF_SERVICE sqos;
    APIERR err = 0 ;

    CloseHandle() ;

    if ( pszServerName != NULL && ::strlenf(pszServerName) != 0 )
    {
	NLS_STR nlsServerName = pszServerName;

	if ( err = ::FillUnicodeString( &unistrServerName, nlsServerName ) )
	{
	    return err ;
	}
	punistrServerName = &unistrServerName;
    }
    else
    {
	punistrServerName = NULL;
    }

    InitObjectAttributes( &oa, &sqos );

    err = ERRMAP::MapNTStatus( ::LsaOpenPolicy( punistrServerName,
					 &oa,
					 accessDesired,
					 &hlsa ) );

    if ( err == NERR_Success )
    {
	SetHandle( hlsa );
    }

    if ( punistrServerName != NULL )
    {
	::FreeUnicodeString( punistrServerName );
    }

    return err ;
}


/*******************************************************************

    NAME: LSA_POLICY::TranslateSidsToNames

    SYNOPSIS: Wrapper for LsaLookupSids()

    ENTRY: ppsids - array of PSIDS to look up
	   cSids - Count of PSIDS to look up
	   plsatnm - NT_MEMORY object to receive the data
	   plsardm - NT_MEMORY object to receive referenced domain info

    EXIT: NERR_Success or error code.

    NOTES:

    HISTORY:
	thomaspa	02/22/92	Created from ntsam.hxx

********************************************************************/
APIERR LSA_POLICY::TranslateSidsToNames( const PSID *ppsids,
					ULONG cSids,
                                	LSA_TRANSLATED_NAME_MEM *plsatnm,
					LSA_REF_DOMAIN_MEM *plsardm)
{
    NTSTATUS ntStatus ;
    APIERR err ;

    ASSERT( ppsids != NULL );
    ASSERT( *ppsids != NULL );
    ASSERT( plsatnm != NULL );
    ASSERT( plsardm != NULL );

    if ( cSids == 0 )
	return ERRMAP::MapNTStatus( STATUS_NONE_MAPPED );

    PLSA_REFERENCED_DOMAIN_LIST plsardl = NULL;
    PLSA_TRANSLATED_NAME plsatn = NULL;

    ntStatus =	::LsaLookupSids( QueryHandle(),
	                         cSids,
	                         (PSID *)ppsids,
	                         & plsardl,
	                         & plsatn );

    if ( ntStatus == STATUS_NONE_MAPPED )
    {
        ntStatus = STATUS_SOME_NOT_MAPPED;
    }
    // BUGBUG:  ERRMAP should do the following mapping correctly.
    //          the mapping above is temporary till that status is
    //          correctly NOT an error.

    err = ntStatus == STATUS_NO_MORE_ENTRIES
        ? ERROR_NO_MORE_ITEMS
        : ERRMAP::MapNTStatus( ntStatus ) ;

    if ( err == NERR_Success )
    {
        ASSERT( plsatn != NULL && plsardl != NULL );
	plsatnm->Set( plsatn, plsatn ? cSids : 0 ) ;
        plsardm->Set( plsardl, plsardl ? plsardl->Entries : 0 );
    }
    else
    {
        if ( plsardl )
           ::LsaFreeMemory( plsardl ) ;
        if ( plsatn )
           ::LsaFreeMemory( plsatn ) ;
    }

    return err;
}

/*******************************************************************

    NAME: LSA_POLICY::TranslateNamesToSids

    SYNOPSIS: Wrapper for LsaLookupNames()

    ENTRY: apszAccountNames - An array of '\0' terminated ANSI strings
	   cAccountNames - Count of items in apszAccountNames
	   plsatsidmem - NT_MEMORY object to receive the data
	   plsardm - NT_MEMORY object to receive referenced domain info

    EXIT: NERR_Success or error code.

    NOTES:

    HISTORY:
	JohnL	    08-Apr-1992     Copied from TranslateSidsToNames

********************************************************************/

APIERR LSA_POLICY::TranslateNamesToSids(
			     const TCHAR * const    * apszAccountNames,
			     ULONG		      cAccountNames,
			     LSA_TRANSLATED_SID_MEM * plsatsidmem,
			     LSA_REF_DOMAIN_MEM     * plsardm )
{
    ASSERT( cAccountNames == 0 || apszAccountNames != NULL );
    ASSERT( cAccountNames == 0 || *apszAccountNames != NULL );
    ASSERT( plsatsidmem != NULL );
    ASSERT( plsardm != NULL );

    if ( cAccountNames == 0 )
	return ERRMAP::MapNTStatus( STATUS_NONE_MAPPED );

    APIERR err = NERR_Success ;

    /* Build an array of UNICODE_STRINGs out of the array of cAccountNames
     */
    PUNICODE_STRING aUniStr = (PUNICODE_STRING) new UNICODE_STRING[cAccountNames] ;
    if ( aUniStr == NULL )
    {
	return ERROR_NOT_ENOUGH_MEMORY ;
    } else if ( err = TcharArrayToUnistrArray( apszAccountNames,
					       aUniStr,
					       cAccountNames ))
    {
	return err ;
    }

    PLSA_REFERENCED_DOMAIN_LIST plsardl;
    PLSA_TRANSLATED_SID plsasid;

    err = ERRMAP::MapNTStatus( ::LsaLookupNames( QueryHandle(),
						 cAccountNames,
						 aUniStr,
						 &plsardl,
						 &plsasid ) );

    if ( err == NERR_Success )
    {
	plsatsidmem->Set( plsasid, cAccountNames );
        plsardm->Set( plsardl, plsardl ? plsardl->Entries : 0 );
    }

    CleanupUnistrArray( aUniStr, cAccountNames ) ;
	// NRAID#NTBUG9-577099-2002/03/08-artm  Prefast: need to call delete []
	// aUniStr allocated with new [], need to use delete [] to avoid mem. leak
    delete aUniStr ;

    return err;
}


/*******************************************************************

    NAME: LSA_POLICY::EnumerateTrustedDomains

    SYNOPSIS: returns a list of trusted domains

    ENTRY: plsatim -	pointer to a LSA_TRUST_INFO_MEMORY object to
			receive the data.

	   plsaenumh -	pointer to enumeration handle
			This should initially point to a variable initialized
			to 0.  If the call returns ERROR_MORE_DATA, then
			another call should be made using the returned
			plsaenumh to get the next block of data.

	   cbRequested - recommended maximum amount of info to return

    EXIT:  NERR_Success or ERROR_MORE_DATA on success.

    NOTES:

    HISTORY:
	thomaspa	03/05/92	Created from ntsam.hxx

********************************************************************/
APIERR LSA_POLICY::EnumerateTrustedDomains (
    LSA_TRUST_INFO_MEM * plsatim,
    PLSA_ENUMERATION_HANDLE plsaenumh,
    ULONG cbRequested )
{
    ASSERT( plsatim != NULL );

    PVOID pvBuffer;
    ULONG cItems;

    APIERR err = ERRMAP::MapNTStatus(
			::LsaEnumerateTrustedDomains( QueryHandle(),
						      plsaenumh,
						      &pvBuffer,
						      cbRequested,
						      &cItems ) );

    if ( err == NERR_Success || err == ERROR_MORE_DATA )
    {
	plsatim->Set( pvBuffer, cItems );
    }

    return err;


}



/*******************************************************************

    NAME: LSA_POLICY::GetAccountDomain

    SYNOPSIS: returns name and sid of Account domain.

    ENTRY: plsaadim - pointer to a LSA_ACCT_DOM_INFO_MEM object to
	receive the data.

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	03/05/92	Created from ntsam.hxx

********************************************************************/
APIERR LSA_POLICY::GetAccountDomain(
    LSA_ACCT_DOM_INFO_MEM *plsaadim )  const
{

    PVOID pvBuffer;

    ASSERT( plsaadim != NULL );

    APIERR err = ERRMAP::MapNTStatus(
		::LsaQueryInformationPolicy( QueryHandle(),
					     PolicyAccountDomainInformation,
					     &pvBuffer ) );
    if ( err == NERR_Success )
    {
	plsaadim->Set( pvBuffer, 1 );
    }

    return err;
}

/*******************************************************************

    NAME:     LSA_POLICY::GetAuditEventInfo

    SYNOPSIS: Get the audit events info from LSA

    ENTRY:    plsaaeim - pointer to a LSA_AUDIT_EVENT_INFO_MEM
                         object to receive the data.

    EXIT:

    NOTES:

    HISTORY:
	Yi-HsinS	04/01/92	Created

********************************************************************/

APIERR LSA_POLICY::GetAuditEventInfo( LSA_AUDIT_EVENT_INFO_MEM *plsaaeim )
{

    PVOID pvBuffer = NULL;

    ASSERT( plsaaeim != NULL );

    APIERR err = ERRMAP::MapNTStatus(
		::LsaQueryInformationPolicy( QueryHandle(),
					     PolicyAuditEventsInformation,
					     &pvBuffer ) );
    if ( err == NERR_Success )
    {
	plsaaeim->Set( pvBuffer, 1 );
    }

    return err;
}

/*******************************************************************

    NAME:     LSA_POLICY::SetAuditEventInfo

    SYNOPSIS: Set the audit events info back to the LSA

    ENTRY:    plsaaeim - pointer to a LSA_AUDIT_EVENT_INFO_MEM
                         object for the data to set.

    EXIT:

    NOTES:

    HISTORY:
	Yi-HsinS	04/01/92	Created

********************************************************************/
APIERR LSA_POLICY::SetAuditEventInfo( LSA_AUDIT_EVENT_INFO_MEM *plsaaeim )
{

    ASSERT( plsaaeim != NULL );

    APIERR err = ERRMAP::MapNTStatus(
		::LsaSetInformationPolicy(  QueryHandle(),
					    PolicyAuditEventsInformation,
					    (PVOID) plsaaeim->QueryPtr() ));
    return err;
}

/*******************************************************************

    NAME:     LSA_POLICY::CheckIfShutDownOnFull

    SYNOPSIS: Query if we shut down the system when the security log is full

    ENTRY:

    EXIT:     fShutDownOnFull - TRUE if the system will be shut down
                                when security log is full, FALSE otherwise.

    RETURNS:

    NOTES:

    HISTORY:
	Yi-HsinS	04/13/92	Created

********************************************************************/

APIERR LSA_POLICY::CheckIfShutDownOnFull( BOOL *pfShutDownOnFull )
{

    UIASSERT( pfShutDownOnFull != NULL );

    PVOID pvBuffer = NULL;

    APIERR err = ERRMAP::MapNTStatus(
	      ::LsaQueryInformationPolicy( QueryHandle(),
		        		   PolicyAuditFullQueryInformation,
					   &pvBuffer ) );
    if ( err == NERR_Success )
    {
        UIASSERT( pvBuffer != NULL );

        *pfShutDownOnFull =
             (( PPOLICY_AUDIT_FULL_QUERY_INFO ) pvBuffer)->ShutDownOnFull;

        ::LsaFreeMemory( pvBuffer );
    }

    return err;
}


/*******************************************************************

    NAME:     LSA_POLICY::SetShutDownOnFull

    SYNOPSIS: Set the info to shut down the system when security log is full
              back to the LSA

    ENTRY:    fShutDownOnFull - TRUE if we want to shut down when
                                security log is full, FALSE otherwise.

    EXIT:

    NOTES:

    HISTORY:
	Yi-HsinS	04/13/92	Created

********************************************************************/

APIERR LSA_POLICY::SetShutDownOnFull( BOOL fShutDownOnFull )
{

    POLICY_AUDIT_FULL_SET_INFO AuditFullInfo;

    AuditFullInfo.ShutDownOnFull = (fShutDownOnFull != FALSE);


    APIERR err = ERRMAP::MapNTStatus(
		::LsaSetInformationPolicy(  QueryHandle(),
					    PolicyAuditFullSetInformation,
					    (PVOID) &AuditFullInfo ));

    return err;
}


/********************************************************************

    NAME:      LSA_POLICY::GetPrimaryDomain

    SYNOPSIS:  returns name and sid of Primary domain.

    ENTRY:     plsapdim - pointer to a LSA_PRIMARY_DOM_INFO_MEM object to
               receive the data.

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	03/05/92	Created from ntsam.hxx

********************************************************************/
APIERR LSA_POLICY::GetPrimaryDomain (
    LSA_PRIMARY_DOM_INFO_MEM * plsapdim ) const
{

    PVOID pvBuffer;

    ASSERT( plsapdim != NULL );

    APIERR err = ERRMAP::MapNTStatus(
		::LsaQueryInformationPolicy( QueryHandle(),
					     PolicyPrimaryDomainInformation,
					     &pvBuffer ) );
    if ( err == NERR_Success )
    {
	plsapdim->Set( pvBuffer, 1 );
    }

    return err;
}




/*******************************************************************

    NAME: LSA_POLICY::InitObjectAttributes

    SYNOPSIS:

    This function initializes the given Object Attributes structure, including
    Security Quality Of Service.  Memory must be allcated for both
    ObjectAttributes and Security QOS by the caller.

    ENTRY:

    poa - Pointer to Object Attributes to be initialized.

    psqos - Pointer to Security QOS to be initialized.

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	03/05/92	Created from ntsam.hxx

********************************************************************/
VOID LSA_POLICY::InitObjectAttributes( POBJECT_ATTRIBUTES poa,
				       PSECURITY_QUALITY_OF_SERVICE psqos )

{
    ASSERT( poa != NULL );
    ASSERT( psqos != NULL );

    psqos->Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    psqos->ImpersonationLevel = SecurityImpersonation;
    psqos->ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    psqos->EffectiveOnly = FALSE;

    //
    // Set up the object attributes prior to opening the LSA.
    //

    InitializeObjectAttributes( poa,
				NULL,
				0L,
				NULL,
				NULL );

    //
    // The InitializeObjectAttributes macro presently stores NULL for
    // the psqos field, so we must manually copy that
    // structure for now.
    //

    poa->SecurityQualityOfService = psqos;
}

//  End of UINTLSA.CXX

/*******************************************************************

    NAME:	LSA_POLICY::TcharArrayToUnistrArray

    SYNOPSIS:	Initializes each element in the unicode array with
		the appropriate data from the corresponding element
		in the TCHAR array.

    ENTRY:	apsz - Array of TCHAR * strings used to initialize
		    the unicode array
		aUniStr - Array of UNICODE_STRINGs to be initialized
		cElements - Count of elements in apsz

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:	The method allocates memory for each element of the
		array.	Call CleanupUnistrArray to deallocate this
		memory.

		There must be at least cElements in aUniStr.  No
		checking is performed to confirm this.

		If an error is returned, this method will have cleaned
		up after itself before returning.

    HISTORY:
	Johnl	08-Apr-1992	Created

********************************************************************/

APIERR LSA_POLICY::TcharArrayToUnistrArray( const TCHAR * const *   apsz,
					    PUNICODE_STRING aUniStr,
					    ULONG	    cElements )
{
    APIERR err = NERR_Success ;

    for ( ULONG i = 0 ; i < cElements ; i++ )
    {
	ALIAS_STR nlsString( apsz[i] ) ;
	UINT cb = (nlsString.QueryTextLength() + 1) * sizeof(WCHAR) ;
	aUniStr[i].Buffer = (PWSTR) new BYTE[ cb ] ;
	if ( aUniStr[i].Buffer == NULL )
	{
	    err = ERROR_NOT_ENOUGH_MEMORY ;
	    break ;
	}

	if ( err = nlsString.MapCopyTo( (WCHAR *) aUniStr[i].Buffer, cb ))
	{
	    break ;
	}

	aUniStr[i].Length = (USHORT) nlsString.QueryTextLength()*sizeof(WCHAR);
	aUniStr[i].MaximumLength = (USHORT) cb ;
    }

    if ( err )
    {
	CleanupUnistrArray( aUniStr, i + 1 ) ;
    }

    return err ;
}

/*******************************************************************

    NAME:	LSA_POLICY::CleanupUnistrArray

    SYNOPSIS:	Deletes the Buffer member of each element in the
		UNICODE_STRING array

    ENTRY:	aUniStr - Array of UNICODE_STRINGs
		cElementsConstructed - The number of elements in the
		    array that contain allocated data

    EXIT:

    NOTES:

    HISTORY:
	Johnl	08-Apr-1992	Created

********************************************************************/

void LSA_POLICY::CleanupUnistrArray( PUNICODE_STRING aUniStr,
				     ULONG	     cElementsAllocated )
{
    for ( ULONG i = 0 ; i < cElementsAllocated ; i++ )
    {
	delete aUniStr[i].Buffer ;
	aUniStr[i].Buffer = NULL ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\uintlsax.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    UINTLSAX.CXX


    LSA Extensions:  other LSA_POLICY members and LSA_SECRET
        class.



    FILE HISTORY:
        DavidHov    3/10/92   Created

*/

#include "pchlmobj.hxx"  // Precompiled header


/*******************************************************************

    NAME:       LsaxGetComputerName

    SYNOPSIS:   Get the computer name in a NETUI manner.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
APIERR LsaxGetComputerName ( NLS_STR * pnlsComputerName )
{
    TCHAR szComputerName [MAX_PATH] ;
    DWORD dwCch = sizeof szComputerName / sizeof(szComputerName[0]) - 1 ;
    APIERR err ;

    BOOL fOk = ::GetComputerName( szComputerName, & dwCch ) ;

    if ( fOk )
    {
        szComputerName[dwCch] = 0 ;
        *pnlsComputerName = szComputerName ;
        err = pnlsComputerName->QueryError() ;
    }
    else
    {
        err = ::GetLastError() ;
    }
    return  err ;
}

/*******************************************************************

    NAME:     LSA_SERVER_ROLE_INFO_MEM::LSA_SERVER_ROLE_INFO_MEM

    SYNOPSIS: Constructor

    ENTRY:


    NOTES:

    HISTORY:  DavidHov   5/15/92

********************************************************************/
LSA_SERVER_ROLE_INFO_MEM :: LSA_SERVER_ROLE_INFO_MEM (
    BOOL fOwnerAlloc,
    BOOL fPrimary )
    : LSA_MEMORY( fOwnerAlloc )
{
}

/*******************************************************************

    NAME:     LSA_SERVER_ROLE_INFO_MEM::~LSA_SERVER_ROLE_INFO_MEM

    SYNOPSIS: Destructor

    ENTRY:


    NOTES:

    HISTORY:

********************************************************************/
LSA_SERVER_ROLE_INFO_MEM :: ~ LSA_SERVER_ROLE_INFO_MEM ()
{
}

/*******************************************************************

    NAME:     LSA_POLICY::SetPrimaryDomain

    SYNOPSIS: Update the primary domain info.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:  DavidHov   5/16/92

********************************************************************/
APIERR LSA_POLICY::SetPrimaryDomain ( const LSA_PRIMARY_DOM_INFO_MEM * plsapdim )
{
    ASSERT( plsapdim != NULL );

#if defined(DEBUG)
    if ( plsapdim->QueryPtr()->Sid == NULL )
    {
        TRACEEOL("UINTLSA: WARNING Setting primary domain SID to NULL") ;
    }
#endif

    APIERR err = ERRMAP::MapNTStatus(
                ::LsaSetInformationPolicy(  QueryHandle(),
                                            PolicyPrimaryDomainInformation,
                                            (PVOID) plsapdim->QueryPtr() ));
    return err;
}

/*******************************************************************

    NAME:     LSA_POLICY::SetAccountDomain

    SYNOPSIS: Update the Account domain info.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:  DavidHov   5/16/92

********************************************************************/
APIERR LSA_POLICY::SetAccountDomain ( const LSA_ACCT_DOM_INFO_MEM * plsaadim )
{
    ASSERT( plsaadim != NULL );

#if defined(DEBUG)
    if ( plsaadim->QueryPtr()->DomainSid == NULL )
    {
        TRACEEOL("UINTLSA: WARNING Setting account domain SID to NULL") ;
    }
#endif

    APIERR err = ERRMAP::MapNTStatus(
                ::LsaSetInformationPolicy(  QueryHandle(),
                                            PolicyAccountDomainInformation,
                                            (PVOID) plsaadim->QueryPtr() ));
    return err;
}

/*******************************************************************

    NAME:     LSA_POLICY::SetAccountDomainName

    SYNOPSIS: Update the Account domain name.

    ENTRY:

    EXIT:

    NOTES:    A bit of a hack.  Creates and fills an
              LSA_ACCT_DOM_INFO_MEM, then alters its UNICODE_STRING
              to match the input parameters.  The original
              data is then restored.

    HISTORY:  DavidHov   5/16/92
              DavidHov   9/20/92   Extended similarly to
                                   SetPrimaryDomainName

********************************************************************/
APIERR LSA_POLICY :: SetAccountDomainName (
    const NLS_STR * pnlsDomainName,
    const PSID * ppsidDomain )
{
    LSA_ACCT_DOM_INFO_MEM lsaadim ;
    UNICODE_STRING usDomainName,
                   usNameSave ;
    POLICY_ACCOUNT_DOMAIN_INFO * pPolAcctDomInfo ;
    PSID psidCurrent = NULL ;

    APIERR err = GetAccountDomain( & lsaadim ) ;

    if ( err == 0 )
    {
        pPolAcctDomInfo = (POLICY_ACCOUNT_DOMAIN_INFO *) lsaadim.QueryPtr() ;

        //  If we're changing the domain name, make a UNICODE_STRING

        if ( pnlsDomainName )
        {
            usNameSave = pPolAcctDomInfo->DomainName ;
            err = ::FillUnicodeString( & usDomainName, *pnlsDomainName ) ;
        }

        //  If we're changing the SID, save the older one

        if ( ppsidDomain )
        {
            psidCurrent = pPolAcctDomInfo->DomainSid ;
            pPolAcctDomInfo->DomainSid = *ppsidDomain ;
        }

        if ( err == 0 )
        {
            if ( pnlsDomainName )
            {
                pPolAcctDomInfo->DomainName = usDomainName ;
            }

            err = SetAccountDomain( & lsaadim ) ;

            if ( pnlsDomainName )
            {
                pPolAcctDomInfo->DomainName = usNameSave ;
                ::FreeUnicodeString( & usDomainName ) ;
            }
        }

        //  Restore the original SID, if any

        if ( psidCurrent )
        {
            pPolAcctDomInfo->DomainSid = psidCurrent ;
        }
    }

    return err ;
}


/*******************************************************************

    NAME:     LSA_POLICY::SetPrimaryDomainName

    SYNOPSIS: Update the Primary domain name.

    ENTRY:    const NLS_STR * pnlsDomainName    new primary domain name
                                                or NULL if not changing
              const PSID * ppsidDomain          new primary domain SID
                                                or NULL if not changing

    EXIT:

    NOTES:    See SetAccountDomainName() above.

    HISTORY:  DavidHov   5/16/92
              DavidHov   6/5/92    added optional PSID *
              DavidHov   8/4/92    allowed pnlsDomainName to be NULL

********************************************************************/
APIERR LSA_POLICY :: SetPrimaryDomainName (
     const NLS_STR * pnlsDomainName,
     const PSID * ppsidDomain )
{
    LSA_PRIMARY_DOM_INFO_MEM lsapdim ;
    UNICODE_STRING usDomainName,
                   usNameSave ;
    POLICY_PRIMARY_DOMAIN_INFO * pPolPrimDomInfo ;
    PSID psidCurrent = NULL ;

    APIERR err = GetPrimaryDomain( & lsapdim ) ;

    if ( err == 0 )
    {
        //  Access the underlying stucture and prepare to modify the
        //  Unicode name.

        pPolPrimDomInfo = (POLICY_PRIMARY_DOMAIN_INFO *) lsapdim.QueryPtr() ;

        //  If we're changing the domain name, make a UNICODE_STRING

        if ( pnlsDomainName )
        {
            usNameSave = pPolPrimDomInfo->Name ;
            err = ::FillUnicodeString( & usDomainName, *pnlsDomainName ) ;
        }

        //  If we're changing the SID, save the older one

        if ( ppsidDomain )
        {
            psidCurrent = pPolPrimDomInfo->Sid ;
            pPolPrimDomInfo->Sid = *ppsidDomain ;
        }

        if ( err == 0 )
        {
            if ( pnlsDomainName )
            {
               pPolPrimDomInfo->Name = usDomainName ;
            }

            err = SetPrimaryDomain( & lsapdim ) ;

            if ( pnlsDomainName )
            {
               pPolPrimDomInfo->Name = usNameSave ;
               ::FreeUnicodeString( & usDomainName ) ;
            }
        }

        //  Restore the original SID, if any

        if ( psidCurrent )
        {
            pPolPrimDomInfo->Sid = psidCurrent ;
        }
    }

    return err ;
}

/*******************************************************************

    NAME:     LSA_POLICY::GetServerRole

    SYNOPSIS:

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:  DavidHov   5/16/92

********************************************************************/
APIERR LSA_POLICY :: GetServerRole
   ( LSA_SERVER_ROLE_INFO_MEM * plsasrim ) const
{
    PVOID pvBuffer;

    ASSERT( plsasrim != NULL );

    APIERR err = ERRMAP::MapNTStatus(
                ::LsaQueryInformationPolicy( QueryHandle(),
                                             PolicyLsaServerRoleInformation,
                                             &pvBuffer ) );
    if ( err == NERR_Success )
    {
        plsasrim->Set( pvBuffer, 1 );
    }

    return err;
}

/*******************************************************************

    NAME:     LSA_POLICY::SetServerRole

    SYNOPSIS:

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:  DavidHov   5/16/92

********************************************************************/
APIERR LSA_POLICY :: SetServerRole
   ( const LSA_SERVER_ROLE_INFO_MEM * plsasrim )
{
    ASSERT( plsasrim != NULL );

    APIERR err = ERRMAP::MapNTStatus(
                ::LsaSetInformationPolicy(  QueryHandle(),
                                            PolicyLsaServerRoleInformation,
                                            (PVOID) plsasrim->QueryPtr() ));
    return err;
}

/*******************************************************************

    NAME:       LSA_POLICY::MakeSecretName

    SYNOPSIS:   Create the name of the shared secret
                depending upon its type

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        JonN     12/11/92       Change in global secret naming convention

********************************************************************/

APIERR LSA_POLICY :: MakeSecretName (
    const NLS_STR & nlsDomainName,
    BOOL fPrimary,
    NLS_STR * pnlsSecretName )
{
    APIERR err = 0 ;

    if( fPrimary )
    {
        //  The name is "$MACHINE.ACC"

        err = pnlsSecretName->MapCopyFrom( (WCHAR *)SSI_SECRET_NAME ) ;
    }
    else
    {
        //  The name is of the form  "$DOMAIN"

        err = pnlsSecretName->MapCopyFrom( (WCHAR *)LSA_GLOBAL_SECRET_PREFIX );

        if( err == NERR_Success )
        {
            err = pnlsSecretName->Append( (WCHAR *)SSI_SECRET_PREFIX );
        }

        if( err == NERR_Success )
        {
            err = pnlsSecretName->Append( nlsDomainName );
        }
    }

    return err ? err : pnlsSecretName->QueryError() ;
}

/*******************************************************************

    NAME:       LSA_POLICY::VerifyLsa

    SYNOPSIS:   Return the packaging type of this installation

    ENTRY:      LSA_PRIMARY_DOM_INFO_MEM * plsaprm
                        optional pointer to memory wrapper for
                        primary domain information structure

                const NLS_STR * pnlsDomainName
                        optional domain name to be verified
                        against actual.  If mismatch.
                        NERR_NotPrimary is returned.

    EXIT:      *plsaprm  updated

    RETURNS:   APIERR if failure

    NOTES:

    HISTORY:
               DavidHov  4/10/92   Created
********************************************************************/
APIERR LSA_POLICY :: VerifyLsa (
    LSA_PRIMARY_DOM_INFO_MEM * plsapdim,
    const NLS_STR * pnlsDomainName  ) const
{
    APIERR err ;
    BOOL fAllocated = FALSE ;
    NLS_STR nlsRealDomainName ;

    do
    {
        if ( plsapdim == NULL )
        {
            plsapdim = new LSA_PRIMARY_DOM_INFO_MEM ;
            if ( plsapdim == NULL )
            {
                err = ERROR_NOT_ENOUGH_MEMORY ;
                break ;
            }
            fAllocated = TRUE ;
        }

        //  Get primary domain information.

        err = GetPrimaryDomain( plsapdim ) ;
        if ( err )
            break ;

        //  See if the domain name is to be verified
        if ( pnlsDomainName == NULL )
            break ;

        err = plsapdim->QueryName( & nlsRealDomainName ) ;
        if ( err )
           break ;
        if ( *pnlsDomainName != nlsRealDomainName )
           err = NERR_NotPrimary ;
    }
    while ( FALSE ) ;

    if ( fAllocated )
        delete plsapdim ;

    return err ;
}


/*******************************************************************

    NAME:       LSA_POLICY::QueryProductType

    SYNOPSIS:   Return the packaging type of this installation

    ENTRY:      LSPL_PROD_TYPE * lsplProd       receiving variable

    EXIT:       lsplProd updated if no error

    RETURNS:    APIERR if failure

    NOTES:      This function will be replaced when this data lives
                in the Registry.
                Treat (Dedicated) Server as WinNt

    HISTORY:
                DavidHov   4/10/92    Created

********************************************************************/
APIERR LSA_POLICY :: QueryProductType
    ( LSPL_PROD_TYPE * lsplProd )
{
    NT_PRODUCT_TYPE ntpType ;
    APIERR err = 0 ;

    if ( ::RtlGetNtProductType( & ntpType ) )
    {
        switch ( ntpType )
        {
        case NtProductWinNt:
        case NtProductServer:
            *lsplProd = LSPL_PROD_WIN_NT ;
            break ;
        case NtProductLanManNt:
            *lsplProd = LSPL_PROD_LANMAN_NT ;
            break ;
        default:
            err = ERROR_GEN_FAILURE ;
            break ;
        }
    }
    else
    {
       err = ERROR_GEN_FAILURE ;
    }
    return err ;
}


/*******************************************************************

    NAME:       LSA_POLICY::QueryCurrentUser

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/
APIERR LSA_POLICY ::QueryCurrentUser
    ( NLS_STR * pnlsUserName ) const
{
    OS_SID osSid ;
    APIERR err ;

    do
    {
        err = osSid.QueryError() ;
        if ( err )
           break ;

        err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_CurrentProcessUser, & osSid  ) ;
        if ( err )
           break ;
        err = osSid.QueryName( pnlsUserName ) ;
    }
    while ( FALSE ) ;

    return err ;
}

/*******************************************************************

    NAME:       LSA_POLICY::QueryPrimaryDomainName

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      Algorithm is:

                        If LANMan/NT, it's the name of the Accounts domain;

                        If Windows/NT and the Primary Domain SID is NULL,
                            use the machine name,
                        else
                            use the primary domain name.

    HISTORY:

********************************************************************/
APIERR LSA_POLICY :: QueryPrimaryDomainName (
    NLS_STR * pnlsDomainName ) const
{
    LSPL_PROD_TYPE lsplProd ;
    APIERR err ;

    *pnlsDomainName = SZ("");

    do
    {
        err = QueryProductType( & lsplProd ) ;
        if ( err )
            break ;
        if ( lsplProd == LSPL_PROD_LANMAN_NT )
        {
            LSA_ACCT_DOM_INFO_MEM lsaadim ;

            err = lsaadim.QueryError() ;
            if ( err )
               break ;
            if ( err = GetAccountDomain( & lsaadim ) )
               break ;

            err = lsaadim.QueryName( pnlsDomainName ) ;
        }
        else
        {
            LSA_PRIMARY_DOM_INFO_MEM lspdim ;

            err = lspdim.QueryError() ;
            if ( err )
                break ;
            err = GetPrimaryDomain( & lspdim ) ;
            if ( err )
                break ;

            if ( lspdim.QueryPSID() == NULL )
            {
                err = LsaxGetComputerName( pnlsDomainName ) ;
            }
            else
            {
                err = lspdim.QueryName( pnlsDomainName ) ;
            }
        }
    }
    while ( FALSE ) ;

    return err ;
}

/*******************************************************************

    NAME:       LSA_POLICY::QueryPrimaryBrowserGroup

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/
APIERR LSA_POLICY ::QueryPrimaryBrowserGroup
    ( NLS_STR * pnlsBrowserGroup ) const
{
    APIERR err ;
    LSA_PRIMARY_DOM_INFO_MEM lspdim ;

    do  // Pseudo-loop for breakout
    {
         if ( err = lspdim.QueryError() )
            break ;
         if ( err = GetPrimaryDomain( & lspdim ) )
            break ;

         err = lspdim.QueryName( pnlsBrowserGroup ) ;
    }
    while ( FALSE ) ;

    return err ;
}

/*******************************************************************

    NAME:       LSA_POLICY::SetPrimaryBrowserGroup

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      This function is only applicable to Windows NT
                systems which are NOT currently members of a domain.
                Great pains are taken herein to verify this state;
                ERROR_INVALID_FUNCTION is returned if improper request.

    HISTORY:

********************************************************************/
APIERR LSA_POLICY :: SetPrimaryBrowserGroup
    ( const NLS_STR & nlsBrowserGroup )
{
    APIERR err ;
    LSPL_PROD_TYPE lsplProd ;
    LSA_PRIMARY_DOM_INFO_MEM lspdim ;

    do  // Pseudo-loop for breakout
    {
        if ( err = QueryProductType( & lsplProd ) )
            break ;

        if ( lsplProd == LSPL_PROD_LANMAN_NT )
        {
            //  It's not Windows NT!

            err = ERROR_INVALID_FUNCTION ;
            break ;
        }

        if ( err = lspdim.QueryError() )
            break ;

        if ( lspdim.QueryPSID() != NULL )
        {
            //  It's a domain member!

            err = ERROR_INVALID_FUNCTION ;
            break ;
        }

        err = SetPrimaryDomainName( & nlsBrowserGroup ) ;
    }
    while ( FALSE );

    return err ;
}


/*******************************************************************

    NAME:       LSA_POLICY::DeleteAllTrustedDomains

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/
APIERR LSA_POLICY :: DeleteAllTrustedDomains ()
{
    APIERR err ;
    LSA_TRUST_INFO_MEM lsatim ;
    LSA_ENUMERATION_HANDLE lenumHand = NULL ;
    NLS_STR nlsDomain;

    do
    {
        err = nlsDomain.QueryError();
        if( err != NERR_Success )
            break;

        err = lsatim.QueryError() ;
        if ( err )
            break ;

        err = EnumerateTrustedDomains( & lsatim, & lenumHand ) ;
        if ( err )
            break ;

        for ( ULONG i = 0 ; err == 0 && i < lsatim.QueryCount() ; i++ )
        {
            err = lsatim.QueryName( i, &nlsDomain );

            if( err == NERR_Success )
            {
                err = DistrustDomain( lsatim.QueryPSID( i ),
                                      nlsDomain,
                                      TRUE );
            }
        }
    }
    while ( FALSE ) ;

    //  See if there were no trusted domains
    if ( err == ERROR_NO_MORE_ITEMS )
        err = 0 ;

    return err ;
}

/*******************************************************************

    NAME:       LSA_POLICY::TrustDomain

    SYNOPSIS:   Variant 1:  Given a domain name and a SID,
                establish the LSA_TRUSTED_DOMAIN object
                and associated LSA_SECRET necessary to
                forge the trusted relationship.

    ENTRY:      const NLS_STR & nlsDomainName
                                     name of domain

                const PSID psid      opaque reference to SID

                const NLS_STR nlsPassword
                                     password for the secret object

                BOOL fAsPrimary      create the primary domain
                                     relationship.

                const TCHAR * pszTrustedDcHint   name of DC to use
                                     for operations; used for WAN
                                     configurations to avoid broadcasts
                                     which generally don't work

                BOOL fAsDc           TRUE if this is a Backup Domain
                                     Controller
    EXIT:

    RETURNS:

    NOTES:      This routine is used both for joining domains
                (workstations and BDCs) and for establishing trust
                relationships.

                The "as primary" flag determines how the secret object
                is named.  It also causes any other trusted domains to
                be enumerated and deleted.

    HISTORY:
        DavidHov    01-Apr-1992 Created.
        KeithMo     13-Jul-1992 Reordered operations as requested by CliffV.
        DavidHov    20-Aug-1992 Added 'fAsDc', since BDC's are
                                not supposed to have Trusted Domain
                                objects.
        KeithMo     08-Jan-1993 Don't setup trusted controller list.

                                CODEWORK: THIS ROUTINE NEEDS A REWRITE/REORG!

********************************************************************/
APIERR LSA_POLICY :: TrustDomain ( const NLS_STR & nlsDomainName,
                                   const PSID      psid,
                                   const NLS_STR & nlsPassword,
                                   BOOL            fAsPrimary,
                                   const TCHAR   * pszTrustedDcHint,
                                   BOOL            fAsDc )
{
    //
    //  We'll set this flag to TRUE if we managed to
    //  create the LSA Secret object.  This way, if we
    //  have to bag out, we'll know to first delete the
    //  object.
    //

    BOOL fCreatedSecret = FALSE;

    //
    //  Our secret name.
    //

    NLS_STR nlsSecretName;

    //
    //  Create our secret name.
    //

    APIERR err = nlsSecretName.QueryError();

    if( err == NERR_Success )
    {
        err = MakeSecretName( nlsDomainName,
                              fAsPrimary,
                              &nlsSecretName );
    }

    //
    //  If this domain is to act as a Primary, then delete
    //  all other trusted domains (the First Commandment).
    //

    if( fAsPrimary && ( err == NERR_Success ) )
    {
        err = DeleteAllTrustedDomains();
    }

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  Create the actual secret object.
    //

    LSA_SECRET lsaSecret( nlsSecretName );

    err = lsaSecret.QueryError();

    if( err == NERR_Success )
    {
        err = lsaSecret.Create( *this );
        TRACEEOL( "LSA_POLICY::TrustDomain: LSA_SECRET::Create returns " << err );
    }

    if( err == ERROR_ALREADY_EXISTS )
    {
        //
        //  The secret already exists, just open and reuse it.
        //
        err = lsaSecret.Open( *this, SECRET_ALL_ACCESS ) ;
    }
    else
    if( err == NERR_Success )
    {
        fCreatedSecret = TRUE ;
    }

    if( err == NERR_Success )
    {
        err = lsaSecret.SetInfo( &nlsPassword, &nlsPassword );
    }

    if( err != NERR_Success )
    {
        lsaSecret.CloseHandle( fCreatedSecret );
        return err;
    }

    TRACEEOL( "UILMOBJ: LSA_POLICY::TrustDomain() Secret Object created; name: "
              << nlsSecretName.QueryPch()
              << " password: "
              << nlsPassword.QueryPch() ) ;

    //
    //  Create the actual Trusted Domain object.  This occurs for workstations
    //  and for inter-domain trust relationships.
    //

    if ( ! fAsDc )
    {
        //
        // JonN 5/14/99: Bug 339487
        // We previously asked for TRUSTED_ALL_ACCESS (on NT5, 0xF007F).
        // This broke NT5/NT4 compatibility since NT5 defined additional bits in
        // TRUSTED_ALL_ACCESS which NT4 doesn't understand.
        //
        LSA_TRUSTED_DOMAIN ltdomTrusted( *this, nlsDomainName, psid, 0L );

#if defined( DEBUG )

        {
            OS_SID ossidDomain( (PSID)psid );
            NLS_STR nlsRawSid;

            if( ( ossidDomain.QueryError() == NERR_Success ) &&
                ( nlsRawSid.QueryError() == NERR_Success ) &&
                ( ossidDomain.QueryRawID( &nlsRawSid ) == NERR_Success ) )
            {
                TRACEEOL( "UILMOBJ:LSA_POLICY::TrustDomain(); trust domain" <<
                          nlsDomainName.QueryPch() <<
                          " SID " <<
                          nlsRawSid.QueryPch() );
            }
            else
            {
                TRACEEOL( "UILMOBJ:LSA_POLICY::TrustDomain(); can't print raw SID" );
            }
        }

#endif  // DEBUG

        //
        //  Verify that the LSA objects constructed properly.
        //

        err = ltdomTrusted.QueryError();
#ifdef DEBUG
        if (err != NERR_Success)
        {
            DBGEOL( "UILMOBJ:LSA_POLICY::TrustDomain(); LSA_TRUSTED_DOMAIN::ctor error" << err );
        }
#endif  // DEBUG

    }

    //
    //  If we're setting up the primary domain, then set its name and SID
    //  If this is a LanmanNT BDC, set the name and SID of the Accounts
    //    domain.
    //

    if ( fAsPrimary && ( err == NERR_Success ) )
    {
        TRACEEOL( "UILMOBJ:LSA_POLICY: Setting new domain name & SID to: "
                  << nlsDomainName.QueryPch() );

        err = SetPrimaryDomainName( & nlsDomainName, & psid );

        if ( fAsDc && err == NERR_Success )
        {
           err = SetAccountDomainName( & nlsDomainName, & psid );
        }
    }

    //
    //  Let's see if we need to undo anything.
    //

    if ( err != NERR_Success )
    {
        lsaSecret.CloseHandle( fCreatedSecret );
    }

    return err;

}   // TrustDomain


/*******************************************************************

    NAME:       LSA_POLICY::TrustDomain

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/
APIERR LSA_POLICY :: TrustDomain (
    LSA_POLICY & lsapolDC,
    const NLS_STR & nlsPassword,
    BOOL fAsPrimary,
    const TCHAR * pszTrustedDcHint )
{
    return ERROR_INVALID_FUNCTION ;
}

/*******************************************************************

    NAME:       LSA_POLICY::DistrustDomain

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      BUGBUG:  this routine needs to check
                if this is the primary domain and create
                the Secret Name accordingly.  For now,
                it just assumes primary...

    HISTORY:

********************************************************************/
APIERR LSA_POLICY :: DistrustDomain ( const PSID psid,
                                      const NLS_STR & nlsDomain,
                                      BOOL fAsPrimary )
{
    UIASSERT( nlsDomain.QueryError() == NERR_Success );

    APIERR err = 0 ;
    NLS_STR nlsSecretName;
    BOOL fDeleteDomain = TRUE ;

    //
    // JonN 5/14/99: Bug 339487
    // We previously asked for TRUSTED_ALL_ACCESS (on NT5, 0xF007F).
    // This broke NT5/NT4 compatibility since NT5 defined additional bits in
    // TRUSTED_ALL_ACCESS which NT4 doesn't understand.
    //
    LSA_TRUSTED_DOMAIN ltdomToDelete( *this, psid, DELETE ) ;

    do
    {
        err = ltdomToDelete.QueryError() ;

        //  If we failed to get access, quit; if it's not there,
        //  continue to try to delete the secret object.

        if ( err == ERROR_FILE_NOT_FOUND )
        {
             fDeleteDomain = FALSE ;
        }
        else
        if ( err )
             break ;

        err = MakeSecretName( nlsDomain, fAsPrimary, & nlsSecretName ) ;
        if ( err )
            break ;

        do
        {   //  Destroy the corresponding Secret Object

            LSA_SECRET lsaSecret( nlsSecretName ) ;
            if ( err = lsaSecret.QueryError() )
                break ;

            err = lsaSecret.Open( *this, SECRET_ALL_ACCESS ) ;

            if( err == ERROR_FILE_NOT_FOUND )
            {
                //
                //  ERROR_FILE_NOT_FOUND is returned if the LSA_SECRET
                //  object does not exist.  Since this is what we want
                //  anyway, we'll just pretend it never happened.
                //

                err = NO_ERROR;
            }

            if ( err )
                break ;

            err = lsaSecret.CloseHandle( TRUE ) ;
        }
        while ( FALSE ) ;

        if ( err )
            break ;

        if ( fDeleteDomain )
            err = ltdomToDelete.Delete() ;
    }
    while ( FALSE ) ;

    return err ;
}

/*******************************************************************

    NAME:       LSA_POLICY::JoinDomain

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      An LSA_DOMAIN_INFO is constructed, which represents
                the Primary Domain information from the PDC.  If it
                constructs successfully, create a primary trust
                relationship.

    HISTORY:

********************************************************************/
APIERR LSA_POLICY :: JoinDomain (
    const NLS_STR & nlsDomainName,
    const NLS_STR & nlsPassword,
    BOOL fAsDc,
    const NLS_STR * pnlsDcName,
    const TCHAR   * pszTrustedDcHint )
{
    APIERR err ;

    LSA_DOMAIN_INFO lsadci( nlsDomainName, NULL, pnlsDcName ) ;

    do
    {
        if ( err = lsadci.QueryError() )
            break ;

        err = TrustDomain( nlsDomainName,
                           lsadci.QueryPSID(),
                           nlsPassword,
                           TRUE,
                           pszTrustedDcHint,
                           fAsDc ) ;
        if ( err )
           break ;
    }
    while ( FALSE ) ;

    return err ;
}

/*******************************************************************

    NAME:       LSA_POLICY::LeaveDomain

    SYNOPSIS:   Delete the primary domain information from
                the LSA.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      This routine now leaves the primary domain name as it
                is; otherwise, the Redirector would fail since it
                can tolerate neither a null name nor the same value
                as the machine name.

    HISTORY:    DavidHov    4/1/92   Created
                DavidHov    8/4/92   Changed to preserve primary
                                     domain name.

********************************************************************/
APIERR LSA_POLICY :: LeaveDomain ()
{
    APIERR err ;
    LSA_PRIMARY_DOM_INFO_MEM lsapdim ;
    NLS_STR nlsDomainName ;
    PSID psidNew = NULL ;

    do
    {
        err = nlsDomainName.QueryError();
        if( err != NERR_Success )
            break;

        err = GetPrimaryDomain( & lsapdim ) ;
        if ( err )
            break ;

        err = lsapdim.QueryName( & nlsDomainName );
        if( err != NERR_Success )
            break;

        TRACEEOL( "UILMOBJ:LSA_POLICY: leaving domain "
                  << nlsDomainName.QueryPch() ) ;

        err = DistrustDomain( lsapdim.QueryPSID(), nlsDomainName ) ;
        if ( err )
           break ;

        //  SUCCESS!  Set the primary domain SID to NULL; leave the
        //   name unchanged.

        err = SetPrimaryDomainName( NULL, & psidNew ) ;
    }
    while ( FALSE ) ;

    return err ;
}


/*******************************************************************

    NAME:       LSA_SECRET::LSA_SECRET

    SYNOPSIS:   Constructror of Lsa "Secret Object"

                Allows open, creation, query and set.

                Open/Create require previously successfully
                constructed LSA_POLICY object.

                Machine referenced is the machine specified when the
                LSA_POLICY object was constructed.

    ENTRY:      const NLS_STR & nlsSecretName
                                name of secret object

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/
LSA_SECRET :: LSA_SECRET (
    const NLS_STR & nlsSecretName )
    : _nlsSecretName( nlsSecretName )
{
    if ( QueryError() )
        return ;

    if ( _nlsSecretName.QueryError() )
    {
        ReportError( _nlsSecretName.QueryError() ) ;
        return ;
    }
}

/*******************************************************************

    NAME:       LSA_SECRET::~LSA_SECRET

    SYNOPSIS:   Desctructor of Secret Object wrapper

    ENTRY:      nothing

    EXIT:       nothing

    RETURNS:    nothing

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
LSA_SECRET :: ~ LSA_SECRET ()
{
}

/*******************************************************************

    NAME:       LSA_SECRET::Create

    SYNOPSIS:   Create a new Secret Object

    ENTRY:      const LSA_POLICY & lsapol     of open LSA_POLICY
                ACCESS_MASK accessDesired

    EXIT:       Private handle to secret object open and
                available for QueryInfo(), SetInfo().

    RETURNS:    APIERR if failure

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
APIERR LSA_SECRET :: Create (
    const LSA_POLICY & lsapol,
    ACCESS_MASK accessDesired )
{
    APIERR err ;
    UNICODE_STRING unsName ;
    LSA_HANDLE hlsa ;

    ASSERT( ! IsHandleValid() ) ;

    if ( IsHandleValid() )
    {
        CloseHandle() ;
    }

    err = ::FillUnicodeString( & unsName, _nlsSecretName ) ;

    if ( err == 0 )
    {
        err = ERRMAP::MapNTStatus(
                     ::LsaCreateSecret( lsapol.QueryHandle(),
                                        & unsName,
                                        accessDesired,
                                        & hlsa )  ) ;
        if ( err == 0 )
            SetHandle( hlsa ) ;
    }

    ::FreeUnicodeString( & unsName ) ;

    return err ;
}

/*******************************************************************

    NAME:       LSA_SECRET::Open

    SYNOPSIS:   Open an existing Secret Object

    ENTRY:      const LSA_POLICY & lsaPol
                                policy to open agains
                ACCESS_MASK accessDesired

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
APIERR LSA_SECRET :: Open   (
    const LSA_POLICY & lsapol,
    ACCESS_MASK accessDesired )
{
    APIERR err ;
    UNICODE_STRING unsName ;
    LSA_HANDLE hlsa ;

    ASSERT( ! IsHandleValid() ) ;

    if ( IsHandleValid() )
    {
        CloseHandle() ;
    }

    err = ::FillUnicodeString( & unsName, _nlsSecretName ) ;

    if ( err == 0 )
    {
        err = ERRMAP::MapNTStatus(
                     ::LsaOpenSecret( lsapol.QueryHandle(),
                                      & unsName,
                                      accessDesired,
                                      & hlsa )  ) ;
        if ( err == 0 )
            SetHandle( hlsa ) ;
    }

    ::FreeUnicodeString( & unsName ) ;

    return err ;
}

/*******************************************************************

    NAME:       LSA_SECRET::QueryInfo

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
APIERR LSA_SECRET :: QueryInfo (
    NLS_STR * pnlsCurrentValue,
    NLS_STR * pnlsOldValue,
    LARGE_INTEGER * plintCurrentValueSetTime,
    LARGE_INTEGER * plintOldValueSetTime ) const
{
    APIERR err ;
    UNICODE_STRING * punsCurrent = NULL,
                   * punsOld     = NULL ;

    ASSERT( IsHandleValid() ) ;

    if ( ! IsHandleValid() )
    {
        return ERROR_INVALID_HANDLE ;
    }

    err = ERRMAP::MapNTStatus(
                ::LsaQuerySecret( QueryHandle(),
                                  pnlsCurrentValue ?
                                        & punsCurrent
                                        : NULL,
                                  plintCurrentValueSetTime,
                                  pnlsOldValue ?
                                        & punsOld
                                        : NULL,
                                  plintOldValueSetTime ) ) ;

     if ( err == 0 && pnlsCurrentValue )
     {
         err = pnlsCurrentValue->MapCopyFrom( punsCurrent->Buffer,
                                              punsCurrent->Length );
     }
     if ( err == 0 &&  pnlsOldValue )
     {
         err = pnlsOldValue->MapCopyFrom( punsOld->Buffer,
                                          punsOld->Length );
     }

     if ( punsCurrent )
        ::LsaFreeMemory( punsCurrent ) ;

     if ( punsOld )
        ::LsaFreeMemory( punsOld ) ;

     return err ;
}

/*******************************************************************

    NAME:       LSA_SECRET::SetInfo

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
APIERR LSA_SECRET :: SetInfo (
    const NLS_STR * pnlsCurrentValue,
    const NLS_STR * pnlsOldValue )
{
    APIERR err = 0 ;
    UNICODE_STRING unsCurrent,
                   * punsCurrent = NULL,
                   unsOld,
                   * punsOld = NULL ;

    ASSERT( IsHandleValid() ) ;

    if ( ! IsHandleValid() )
    {
        return ERROR_INVALID_HANDLE ;
    }

    if ( err == 0 && pnlsCurrentValue )
    {
        err = ::FillUnicodeString( punsCurrent = & unsCurrent,
                                   *pnlsCurrentValue ) ;
    }

    if ( err == 0 && pnlsOldValue )
    {
        err = ::FillUnicodeString( punsOld = & unsOld,
                                   *pnlsOldValue ) ;
    }

    if ( err == 0 )
    {
        err = ERRMAP::MapNTStatus(
                ::LsaSetSecret( QueryHandle(),
                                punsCurrent,
                                punsOld ) ) ;
    }
    if ( punsCurrent )
    {
        ::FreeUnicodeString( punsCurrent ) ;
    }
    if ( punsOld )
    {
        ::FreeUnicodeString( punsOld ) ;
    }
    return err ;
}


/*******************************************************************

    NAME:       LSA_TRUSTED_DC_LIST::LSA_TRUSTED_DC_LIST

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
LSA_TRUSTED_DC_LIST :: LSA_TRUSTED_DC_LIST (
    const NLS_STR & nlsDomain,
    const TCHAR   * pszTrustedDcHint )
    : _lcDc( 0 ),
    _punsNames( NULL )
{
    if ( QueryError() )
        return ;

    APIERR err = QueryInfo( nlsDomain, pszTrustedDcHint ) ;
    if ( err )
    {
        ReportError( err ) ;
        return ;
    }
}

/*******************************************************************

    NAME:       LSA_TRUSTED_DC_LIST::~LSA_TRUSTED_DC_LIST

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
LSA_TRUSTED_DC_LIST :: ~ LSA_TRUSTED_DC_LIST ()
{
    FreeBuffer() ;
}

/*******************************************************************

    NAME:       LSA_TRUSTED_DC_LIST::FreeBuffer

    SYNOPSIS:   Delete the Net API-provided buffer

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
VOID LSA_TRUSTED_DC_LIST :: FreeBuffer ()
{
    if ( _punsNames )
    {
        ::NetApiBufferFree( _punsNames ) ;
    }
    _punsNames = NULL ;
    _lcDc = 0 ;
}

/*******************************************************************

    NAME:       LSA_TRUSTED_DC_LIST::QueryInfo

    SYNOPSIS:   Perform the API call to obtain the
                complete DC list of the domain in question.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
APIERR LSA_TRUSTED_DC_LIST :: QueryInfo (
    const NLS_STR & nlsDomain,
    const TCHAR   * pszTrustedDcHint )
{
    APIERR err ;

    FreeBuffer() ;

    _tciInfo.Names = NULL ;
    _tciInfo.Entries = 0 ;

    err = ::I_NetGetDCList( (LPTSTR)pszTrustedDcHint,
                            (TCHAR *) nlsDomain.QueryPch(),
                            & _lcDc,
                            & _punsNames ) ;
    if ( err == 0 )
    {
        _tciInfo.Entries = _lcDc ;
        _tciInfo.Names = _punsNames ;
    }
    return err ;
}

/*******************************************************************

    NAME:       LSA_TRUSTED_DC_LIST::QueryControllerList

    SYNOPSIS:   Return a reference to a constructed LSA
                structure in memory based upon the
                DC list obtained through the API.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
const TRUSTED_CONTROLLERS_INFO & LSA_TRUSTED_DC_LIST :: QueryControllerList () const
{
    ASSERT( QueryError() == 0 ) ;

    return _tciInfo ;
}

/*******************************************************************

    NAME:       LSA_TRUSTED_DC_LIST::operator []

    SYNOPSIS:   Index into the DC list, return a reference
                to the UNICODE name of the DC.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
const UNICODE_STRING & LSA_TRUSTED_DC_LIST :: operator [] ( INT iIndex ) const
{
    ASSERT(    QueryError() == 0
           && _punsNames != NULL
           &&  (UINT)iIndex < _lcDc ) ;

    return _punsNames[ iIndex ] ;
}

/*******************************************************************

    NAME:       LSA_TRUSTED_DC_LIST::QueryCount

    SYNOPSIS:   Return the number of DCs in the list.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
INT LSA_TRUSTED_DC_LIST ::  QueryCount ()
{
    return _lcDc ;
}



/*******************************************************************

    NAME:       LSA_DOMAIN_INFO::LSA_DOMAIN_INFO

    SYNOPSIS:   Constructor of wrapper class for domain info

    ENTRY:      const NLS_STR & nlsDomainName

                                Name of the domain to join; required

                const NLS_STR * pnlsServer

                                Name of server to ask for DC name, if
                                not provided.

                const NLS_STR * pnlsDcName

                                DC name of target domain, if known

    EXIT:       Nothing

    RETURNS:    APIERR if err;

                If successful, underlying primary domain information
                is available for querying.

    NOTES:      This object is a wrapper for the primary domain
                information obtained from the Domain Controller.
                An LSA_POLICY is constructed temporarily, and
                GetPrimaryDomain() called against it.  The handle
                to the information returned is preserved; the
                wrapper is discarded.

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
LSA_DOMAIN_INFO :: LSA_DOMAIN_INFO (
     const NLS_STR & nlsDomainName,
     const NLS_STR * pnlsServer,
     const NLS_STR * pnlsDcName )
   : _nlsDomainName( nlsDomainName )
{
    APIERR err = 0 ;
    const TCHAR * pszDomain = NULL ;
    const TCHAR * pszServer = NULL ;
    const TCHAR * pszDcName = NULL ;

    if ( QueryError() )
        return ;

    if ( pnlsServer )
    {
        pszServer = pnlsServer->QueryPch() ;
    }
    if ( pnlsDcName )
    {
        pszDcName = pnlsDcName->QueryPch() ;
    }

    do  // PSEUDO-LOOP
    {
        pszDomain = _nlsDomainName.QueryPch() ;
        if ( err = _nlsDomainName.QueryError() )
            break ;

        //  If we don't have the DC name already, ask for it.

        if ( pszDcName == NULL )
        {
            err = ::MNetGetDCName( pszServer,
                                   pszDomain,
                                   (BYTE * *) & pszDcName ) ;
            if ( err )
                break ;

            _nlsDcName = pszDcName ;
            ::MNetApiBufferFree( (BYTE * *) & pszDcName ) ;
        }
        else
        {
            _nlsDcName = pszDcName ;
        }

        if ( err = _nlsDcName.QueryError() )
            break ;

        TRACEEOL( "UINTLSA:Ct LSA_DOMAIN_INFO: open policy on "
                  << _nlsDcName.QueryPch() ) ;

        LSA_POLICY lsapol( _nlsDcName.QueryPch() ) ;

        err = lsapol.QueryError() ;
        if ( err )
            break ;

        err = lsapol.GetPrimaryDomain( & _lsapdim ) ;
        if ( err )
             break ;
    }
    while ( FALSE ) ;

    if ( err )
    {
        ReportError( err ) ;
    }
}

/*******************************************************************

    NAME:       LSA_DOMAIN_INFO::~LSA_DOMAIN_INFO

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      The purpose of this class is to properly
                dispose of the LSA_PRIMARY_DOM_INFO_MEM
                item.

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
LSA_DOMAIN_INFO :: ~ LSA_DOMAIN_INFO ()
{
}

/*******************************************************************

    NAME:       LSA_DOMAIN_INFO::QueryPSID

    SYNOPSIS:   Return the PSID of the given domain

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      Read the BUGBUG comment below.

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
const PSID LSA_DOMAIN_INFO :: QueryPSID () const
{
    APIERR err ;
    PSID pSid = NULL ;

    return _lsapdim.QueryPSID() ;
}

/*******************************************************************

    NAME:       LSA_DOMAIN_INFO::QueryDcName

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
APIERR LSA_DOMAIN_INFO :: QueryDcName (
    NLS_STR * pnlsDcName )
{
    return ERROR_INVALID_FUNCTION ;
}


//  End of UINTLSAX.CXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\uintmem.cxx ===
/**********************************************************************/
/**			  Microsoft Windows NT	 		     **/
/**		   Copyright(c) Microsoft Corp., 1992		     **/
/**********************************************************************/

/*
 * NET_MEMORY class implementation
 *
 * History
 *	thomaspa	01/17/92	Created from ntsam.hxx
 */

#include "pchlmobj.hxx"  // Precompiled header



/*******************************************************************

    NAME: ::FillUnicodeString

    SYNOPSIS: Standalone method for filling in a UNICODE_STRING

    ENTRY:	punistr - Unicode string to be filled in.
		nls - Source for filling the unistr

    EXIT:

    NOTES: punistr->Buffer is allocated here and must be deallocated
	by the caller using FreeUnicodeString.

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
APIERR FillUnicodeString( UNICODE_STRING * punistr, const NLS_STR & nls )
{


	USHORT cTchar = (USHORT)nls.QueryTextLength();

	// Length and MaximumLength are counts of bytes.
	punistr->Length = cTchar * sizeof(WCHAR);
	punistr->MaximumLength = punistr->Length + sizeof(WCHAR);
	punistr->Buffer = new WCHAR[cTchar + 1];
        APIERR err = ERROR_NOT_ENOUGH_MEMORY;
        if (punistr->Buffer != NULL)
            err = nls.MapCopyTo( punistr->Buffer, punistr->MaximumLength );
        return err;
}




/*******************************************************************

    NAME: ::FreeUnicodeString

    SYNOPSIS: Standalone method for freeing in a UNICODE_STRING

    ENTRY:	unistr - Unicode string whose Buffer is to be freed.

    EXIT:


    HISTORY:
	thomaspa	03/30/92	Created

********************************************************************/
VOID FreeUnicodeString( UNICODE_STRING * punistr )
{
    ASSERT( punistr != NULL );
    delete punistr->Buffer;
}


/*******************************************************************

    NAME: NT_MEMORY::NT_MEMORY

    SYNOPSIS: constructor

    ENTRY:	pvBuffer - pointer to allocated buffer
		cItems - count of items contained in buffer

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/

NT_MEMORY::NT_MEMORY()
	: _pvBuffer( NULL ),
	  _cItems ( 0L )
{
}


/*******************************************************************

    NAME: NT_MEMORY::~NT_MEMORY

    SYNOPSIS: destructor,

    ENTRY:

    EXIT:

    NOTES: subclasses for NT_MEMORY should use the appropriate method
	to free the memory in the destructor.

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
NT_MEMORY::~NT_MEMORY()
{
    ASSERT( _pvBuffer == NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\svcman.cxx ===
/**********************************************************************/
/**                       Microsoftscman. Windows NT                 **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    SCMAN.cxx
        SC Manager and Service object class. It is used to create, control,
        and query the services and sc manager objects in the NT registry.

    FILE HISTORY:
        terryk  05-May-1992     Created
        KeithMo 11-Nov-1992     Added DisplayName goodies.

*/

#include "pchlmobj.hxx"  // Precompiled header

extern "C"
{
    #include <winsvcp.h>     // EnumServiceGroupW
}



//
// string constants defined
//

#if defined(UNICODE)
  #define SZ_SERVICES_ACTIVE    ((WCHAR *) (SERVICES_ACTIVE_DATABASEW))
  #define SZ_SERVICES_FAILED    ((WCHAR *) (SERVICES_FAILED_DATABASEW))
#else
  #define SZ_SERVICES_ACTIVE    SERVICES_ACTIVE_DATABASEA
  #define SZ_SERVICES_FAILED    SERVICES_FAILED_DATABASEA
#endif

//
//  Slop space for enumeration buffer.
//

#define SERVICE_ENUM_SLOP       ((DWORD)1024)


/*******************************************************************

    NAME:       SERVICE_CONTROL::SERVICE_CONTROL

    SYNOPSIS:   constructor

    HISTORY:
                terryk  20-May-1992     Created

********************************************************************/

SERVICE_CONTROL::SERVICE_CONTROL()
        : _hHandle( NULL ),
        _buffer( 1024 )
{
    APIERR err;

    if (( err =  _buffer.QueryError()) != NERR_Success )
    {
        ReportError( err );
    }
}

/*******************************************************************

    NAME:       SERVICE_CONTROL::Close

    SYNOPSIS:   Close the object handle

    RETURN:     APIERR - NERR_Success if OK. Otherwise, it will return
                the error code. Possible errors:
                        ERROR_INVALID_HANDLE - The specified handle is invalid.

    HISTORY:
        terryk  04-May-1992     Created
        davidhov 5/26/92   Changed to ignore close on NULL handle

********************************************************************/

APIERR SERVICE_CONTROL::Close()
{
    APIERR err = NERR_Success;

    if ( _hHandle )
    {
        if ( !::CloseServiceHandle( _hHandle ) )
        {
            // get the err code
            err = ::GetLastError( );
        }
    }

    _hHandle = NULL ;

    return err;
}

/*******************************************************************

    NAME:       SC_MANAGER::SC_MANAGER

    SYNOPSIS:   Constructor. It will open the registry database for later
                reference.

    ENTRY:      const TCHAR * pszMachine - Name of the target machine; NULL
                        or empty string connects to the local service control
                        manager
                UINT dwAccess - access code. See winsvc.h for detail.
                SERVICE_DATA - either "ACTIVE" or "FAILED". The default
                        is "ACTIVE".

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

SC_MANAGER::SC_MANAGER(
        const TCHAR * pszMachineName,
        UINT dwAccess,
        SERVICE_DATABASE database )
    : _fOwnerAlloc( FALSE )
{
    // BUGBUG:  database name strings don't work, so use NULL (1.256)

    const TCHAR * szDatabase = NULL ;

    if (database == FAILED )
    {
        szDatabase = SZ_SERVICES_FAILED ;
    }

    SC_HANDLE hSCManager = ::OpenSCManager(
                                 (TCHAR *) pszMachineName,
                                 (TCHAR *) szDatabase,
                                 dwAccess );

    SetHandle( hSCManager );

    if ( hSCManager == NULL )
    {
        ReportError( ::GetLastError() );
    }
}


  //  Secondary constructor to wrapper a pre-existing handle

SC_MANAGER::SC_MANAGER ( SC_HANDLE hSvcCtrl )
    : _fOwnerAlloc( TRUE )
{
    SetHandle( hSvcCtrl );
}


/*******************************************************************

    NAME:       SC_MANAGER::~SC_MANAGER

    SYNOPSIS:   Close the sc manager's handle

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

SC_MANAGER::~SC_MANAGER()
{
    if ( ! _fOwnerAlloc )
    {
        if ( Close() != NERR_Success )
        {
            DBGEOL( SZ("Error: Cannot close service") );
        }
    }
}

/*******************************************************************

    NAME:       SC_MANAGER::EnumServiceStatus

    SYNOPSIS:   Enumerate services in the service control manager database
                along with the status of each service.

    ENTRY:      UINT dwServiceType - Value to select the type of
                        services of enumerate. It must be one of the bitwise
                        OR of the following values:
                        SERVICE_WIN32 - enumerate Win32 services only
                        SERVICE_DRIVER - enumerate Driver services only
                UINT dwServiceState - Value to select the services to
                        enumerate based on the running state. It must be one
                        or the bitwise OR of the following values:
                        SERVICE_ACTIVE - enumerate services that have started
                            which includes services that are running, paused,
                            and inpending states.
                        SERVICE_INACTIVE - enumerate services that are stopped.
                LPENUM_SERVICE_STATUS *ppServices - A pointer to a buffer to
                        receive an array of service entries; each entry is
                        the ENUM_SERVICE_STATUS information structure.
                UINT * lpServicesReturned - A pointer to a variable to receive
                        the number of service entries returned.
                const TCHAR * pszGroupName - optional - limits enumeration to 
                        those services who are in the pszGroupName service 
                        order group.

    EXIT:       lpService - an array of service entries.
                lpServicesReturned - the number of service entries returned.

    RETURNS:    Possible errors:
                ERROR_ACCESS_DENIED - The specified handle was not opened with
                        SC_MANAGER_ENUMERATE_SERVICES access.
                ERROR_INVALID_HANDLE - The specified handle is invalid.
                ERROR_INSUFFICIENT_BUFFER - There are more service entries that would fit
                        into the supplied output buffer.
                ERROR_INVALID_PARAMETER - A parameter specified in invalid.

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

APIERR SC_MANAGER::EnumServiceStatus(
        UINT dwServiceType,
        UINT dwServiceState,
        LPENUM_SERVICE_STATUS *ppServices,
        DWORD * lpServicesReturned,
        const TCHAR * pszGroupName )
{
    APIERR err = NERR_Success;
    DWORD cbBytesNeeded = 0;

    if (pszGroupName && *pszGroupName == TCH('\0'))
    {
        pszGroupName = NULL;
    }

    if ( !::EnumServiceGroupW( QueryHandle(), dwServiceType, dwServiceState,
        (LPENUM_SERVICE_STATUS)_buffer.QueryPtr(), _buffer.QuerySize(),
        &cbBytesNeeded, lpServicesReturned, 0, pszGroupName ))
    {
        if (( err = ::GetLastError()) == ERROR_MORE_DATA )
        {
            //
            //  We need to enlarge our buffer to get all
            //  of the enumeration data.  We'll also throw
            //  in some slop space, just in case someone
            //  creates a new service between these two
            //  API calls.
            //

            cbBytesNeeded += (DWORD)_buffer.QuerySize() + SERVICE_ENUM_SLOP;

            if (( err = _buffer.Resize( (UINT)cbBytesNeeded )) == NERR_Success )
            {
                if ( !::EnumServiceGroupW( QueryHandle(), dwServiceType,
                    dwServiceState, (LPENUM_SERVICE_STATUS)_buffer.QueryPtr(),
                    _buffer.QuerySize(), &cbBytesNeeded, lpServicesReturned, 0, pszGroupName ))
                {
                    err = ::GetLastError();
                }
            }
        }
        if (err != NERR_Success)
        {
            DBGEOL( "NETUI: SC_MANAGER::EnumServiceStatus returns "
                 << err
                 << ", bufsize " << _buffer.QuerySize()
                 << ", cbBytesNeeded " << cbBytesNeeded );
        }
    }

    *ppServices = err
                ? NULL
                : (LPENUM_SERVICE_STATUS) _buffer.QueryPtr();
    return err;
}

/*******************************************************************

    NAME:       SC_MANAGER::Lock

    SYNOPSIS:   Lock a specified database

    RETURNS:    Possible errors:
                ERROR_ACCESS_DENIED - The specified handle was not opened with
                        SC_MANAGER_LOCK access.
                ERROR_INVALID_HANDLE - the specified handle is invalid.
                ERROR_SERVICE_DATABASE_LOCKED - The database is locked.

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

APIERR SC_MANAGER::Lock()
{
    APIERR err = NERR_Success;

    _scLock = ::LockServiceDatabase( QueryHandle() );
    if ( _scLock == NULL )
    {
        err = ::GetLastError();
    }
    return err;
}

/*******************************************************************

    NAME:       SC_MANAGER::Unlock

    SYNOPSIS:   Unlock a specified database

    RETURNS:    NERR_Success - OK
                ERROR_INVALID_SERVICE_LOCK - The specified lock is invalid.

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

APIERR SC_MANAGER::Unlock()
{
    APIERR err = NERR_Success;

    if ( ! ::UnlockServiceDatabase( _scLock ))
    {
        err = ::GetLastError();
    }
    return err;
}

/*******************************************************************

    NAME:       SC_MANAGER::QueryLockStatus

    SYNOPSIS:   examine the lock status on a specified database

    ENTRY:      LPQUERY_SERVICE_LOCK_STATUS *ppLockStatus - A pointer to a
                        buffer to receive a QUERY_SERVICE_LOCK_STATUS
                        information structure.

    EXIT:       lpLockStatus - status information

    RETURNS:    NERR_Success - ok
                ERROR_ACCESS_DENIED - The specified handle was not opened with
                        SC_MANAGER_QUERY_LOCK_STATUS access.
                ERROR_INVALID_HANDLE - the specified handle is invalid.
                ERROR_INSUFFICIENT_BUFFER - the supplied output buffer is too
                        small for the QUERY_SERVICE_LOCK_STATUS information
                        structure. Nothing is written to the supplied output
                        buffer.

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

APIERR SC_MANAGER::QueryLockStatus(
        LPQUERY_SERVICE_LOCK_STATUS *ppLockStatus )
{
    DWORD cbBytesNeeded = 0;
    APIERR err = NERR_Success;

    if ( ! ::QueryServiceLockStatus( QueryHandle(),
        (LPQUERY_SERVICE_LOCK_STATUS)_buffer.QueryPtr(), _buffer.QuerySize(),
        &cbBytesNeeded ))
    {
        if (( err = ::GetLastError()) == ERROR_INSUFFICIENT_BUFFER )
        {
            cbBytesNeeded *= 2 ;  // BUGBUG

            if (( err = _buffer.Resize( (UINT)cbBytesNeeded )) == NERR_Success )
            {

                if ( ! ::QueryServiceLockStatus( QueryHandle(),
                    (LPQUERY_SERVICE_LOCK_STATUS)_buffer.QueryPtr(),
                    _buffer.QuerySize(), &cbBytesNeeded ))
                {
                    err = ::GetLastError();
                }
                else
                {
                    *ppLockStatus = (LPQUERY_SERVICE_LOCK_STATUS)_buffer.QueryPtr();
                }
            }
        }
        if (err != NERR_Success)
        {
            DBGEOL( "NETUI: SC_MANAGER::QueryLockStatus returns "
                 << err
                 << ", bufsize " << _buffer.QuerySize()
                 << ", cbBytesNeeded " << cbBytesNeeded );
        }
    }
    else
    {
        *ppLockStatus = (LPQUERY_SERVICE_LOCK_STATUS)_buffer.QueryPtr();
    }
    return err;
}

/*******************************************************************

    NAME:       SC_MANAGER :: QueryServiceDisplayName

    SYNOPSIS:   Returns the display name of a service given its key name.

    ENTRY:      pszKeyName              - The key name of a service.

                pnlsDisplayName         - Will receive the display name.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo 17-Nov-1992     Created.

********************************************************************/
APIERR SC_MANAGER :: QueryServiceDisplayName( const TCHAR * pszKeyName,
                                              NLS_STR     * pnlsDisplayName )
{
    UIASSERT( pszKeyName != NULL );
    UIASSERT( pnlsDisplayName != NULL )
    UIASSERT( pnlsDisplayName->QueryError() == NERR_Success );

    //
    //  Determine the appropriate buffer size.
    //

    BUFFER buffer( SNLEN * sizeof(TCHAR) );

    APIERR err = buffer.QueryError();

    if( err == NERR_Success )
    {
        DWORD cchNeeded = (DWORD)buffer.QuerySize() / sizeof(TCHAR);

        if( !::GetServiceDisplayName( QueryHandle(),
                                      pszKeyName,
                                      (TCHAR *)buffer.QueryPtr(),
                                      &cchNeeded ) )
        {
            err = (APIERR)::GetLastError();
        }

        if( err == ERROR_INSUFFICIENT_BUFFER )
        {
            //
            //  Resize the buffer & try again.
            //

            err = buffer.Resize( (UINT)cchNeeded * sizeof(TCHAR) );

            if( err == NERR_Success )
            {
                cchNeeded = (DWORD)buffer.QuerySize();

                if( !::GetServiceDisplayName( QueryHandle(),
                                              pszKeyName,
                                              (TCHAR *)buffer.QueryPtr(),
                                              &cchNeeded ) )
                {
                    err = (APIERR)::GetLastError();
                }
            }
        }
        if (err != NERR_Success)
        {
            DBGEOL( "NETUI: SC_MANAGER::QueryServiceDisplayName returns "
                 << err
                 << ", bufsize " << _buffer.QuerySize()
                 << ", cchNeeded " << cchNeeded );
        }
    }

    if( err == NERR_Success )
    {
        //
        //  Return the name back to the caller.
        //

        err = pnlsDisplayName->CopyFrom( (TCHAR *)buffer.QueryPtr() );
    }
    else
    {
        DBGEOL( "GetServiceDisplayName returned " << err );

        //
        //  Return the key name.
        //

        err = pnlsDisplayName->CopyFrom( pszKeyName );
    }

    return err;

}   // SC_MANAGER :: QueryServiceDisplayName

/*******************************************************************

    NAME:       SC_MANAGER :: QueryServiceKeyName

    SYNOPSIS:   Returns the key name of a service given its display name.

    ENTRY:      pszDisplayName          - The key name of a service.

                pnlsKeyName             - Will receive the display name.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo 17-Nov-1992     Created.

********************************************************************/
APIERR SC_MANAGER :: QueryServiceKeyName( const TCHAR * pszDisplayName,
                                          NLS_STR     * pnlsKeyName )
{
    UIASSERT( pszDisplayName != NULL );
    UIASSERT( pnlsKeyName != NULL )
    UIASSERT( pnlsKeyName->QueryError() == NERR_Success );

    //
    //  Determine the appropriate buffer size.
    //

    BUFFER buffer( SNLEN * sizeof(TCHAR) );

    APIERR err = buffer.QueryError();

    if( err == NERR_Success )
    {
        DWORD cchNeeded = (DWORD)buffer.QuerySize() / sizeof(TCHAR);

        if( !::GetServiceKeyName( QueryHandle(),
                                  pszDisplayName,
                                  (TCHAR *)buffer.QueryPtr(),
                                  &cchNeeded ) )
        {
            err = (APIERR)::GetLastError();
        }

        if( err == ERROR_INSUFFICIENT_BUFFER )
        {
            //
            //  Resize the buffer & try again.
            //

            err = buffer.Resize( (UINT)cchNeeded * sizeof(TCHAR) );

            if( err == NERR_Success )
            {
                cchNeeded = (DWORD)buffer.QuerySize();

                if( !::GetServiceKeyName( QueryHandle(),
                                          pszDisplayName,
                                          (TCHAR *)buffer.QueryPtr(),
                                          &cchNeeded ) )
                {
                    err = (APIERR)::GetLastError();
                }
            }
        }
        if (err != NERR_Success)
        {
            DBGEOL( "NETUI: SC_MANAGER::QueryServiceKeyName returns "
                 << err
                 << ", bufsize " << _buffer.QuerySize()
                 << ", cchNeeded " << cchNeeded );
        }
    }

    if( err == NERR_Success )
    {
        //
        //  Return the name back to the caller.
        //

        err = pnlsKeyName->CopyFrom( (TCHAR *)buffer.QueryPtr() );
    }

    return err;

}   // SC_MANAGER :: QueryServiceKeyName


#ifdef _BUILD_263_

/*******************************************************************

    NAME:       SC_MANAGER::UpdateLastKnownGood

    SYNOPSIS:   Update the last-know-good configuration with the configuration
                which the system was booted from.

    RETURNS:    NERR_Success - ok
                ERROR_INVALID_HANDLE - The specified handle is invalid
                ERROR_ACCESS_DENIED - The specified handle was not opened with
                        SC_MANAGER_UPDATE_LASTKNOWGOOD access.

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

APIERR SC_MANAGER::UpdateLastKnownGood()
{
    APIERR err = NERR_Success;

    if ( ! ::UpdateServiceLastKnownGood( QueryHandle() ))
    {
        err = ::GetLastError();
    }
    return err;
}

#endif // _BUILD_263_

/*******************************************************************

    NAME:       SC_SERVICE::SC_SERVICE

    SYNOPSIS:   constructor - create a new service object

    ENTRY:      const SC_MANAGER & scManager - sc manager database
                const TCHAR * pszServiceName - service name
                const TCHAR * pszDisplayName - display name
                UINT dwAccess - access code. See winsvc.h for detail.
                UINT dwServiceType - Value to indicate the type of
                    service this is.
                        SERVICE_WIN32_OWN_PROCESS - a service which runs in its
                            own Win32 process.
                        SERVICE_WIN32_SHARE_PROCESS - a service which shares a
                            Win32 process with other services.
                        SERVICE_DRIVER - an NT device driver.
                UINT dwStartType - value to specify when to start the
                    service.
                        SERVICE_BOOT_START - Only valid if service type is
                            SERVICE_DRIVER. This device driver is to be started
                            by the OS loader.
                        SERVICE_SYSTEM_START - Only valid if service type is
                            SERVICE_DRIVER. This device driver is to be
                            started by IoInitSystem.
                        SERVICE_AUTO_START - valid for both SERVICE_DRIVER and
                            SERVICE_WIN32 service types. This service is
                            started by the service control manager when a start
                            request is issued via the StartService API.
                        SERVICE_DISABLE - This service can no longer be started.
                UINT dwErrorControl - value to specify the severity of
                    the error if this service fails to start during boot so
                    that the appropriate action can be taken.
                        SERVICE_ERROR_NORMAL - log error but system continues
                            to boot.
                        SERVICE_ERROR_SEVERE - log error, and the system is
                            rebooted with the last-known-good configuration.
                            If the current configuration is last-known-good,
                            press on with boot.
                        SERVICE_ERROR_CRITICAL - log error if possible, and
                            system is rebooted with last-known-good
                            configuration. If the current is last-know-good,
                            boot fails.
                const TCHAR * lpBinaryPathName - fully-qualified path name to the
                    the service binary file.
                const TCHAR * lpLoadOrderGroup - optional group name parameter
                const TCHAR * lpDependencies - space-separate names of services
                    whuch must be running before this service can run. An
                    empty string means that this service has no depencies.
                const TCHAR * lpServiceStartName - if service type is
                    SERVICE_WIN32, this name is the account name on the form
                    of "DomainName\Username" which the service process will
                    be logged on as when it runs. If the account belongs to
                    the built-in domain, ".\Username" can be specified. If
                    service type is SERVICE_DRIVER, this name must be the NT
                    driver object name (eg \FileSystem\LanManRedirector or
                    \Driver\Xns ) which the I/O system uses to load the device
                    driver.
                const TCHAR * lpPassword - Password to the account name specified
                    by lpServiceStartName if service type if SERVICE_WIN32.
                    This password will be changed periodically by the service
                    control manager so that it will not expire. If service
                    type is SERVICE_DRIVER, this parameter is ignored.

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

SC_SERVICE::SC_SERVICE(
        const SC_MANAGER & scManager,
        const TCHAR *pszServiceName,
        const TCHAR *pszDisplayName,
        UINT dwServiceType,
        UINT dwStartType,
        UINT dwErrorControl,
        const TCHAR * pszBinaryPathName,
        const TCHAR * pszLoadOrderGroup,
        const TCHAR * pszDependencies,
        const TCHAR * pszServiceStartName,
        const TCHAR * pszPassword,
        UINT dwAccess )
{
    APIERR err = NERR_Success;

    SC_HANDLE hService = ::CreateService( scManager.QueryHandle(),
                                         (TCHAR *) pszServiceName,
                                         (TCHAR *) pszDisplayName,
                                         dwAccess,
                                         dwServiceType,
                                         dwStartType,
                                         dwErrorControl,
                                         pszBinaryPathName,
                                         pszLoadOrderGroup,
                                         NULL,
                                         pszDependencies,
                                         pszServiceStartName,
                                         pszPassword );

    SetHandle( hService );

    if ( hService == NULL )
    {
        ReportError( ::GetLastError());
    }
}

/*******************************************************************

    NAME:       SC_SERVICE::SC_SERVICE

    SYNOPSIS:   constructure - Open an existed service object

    ENTRY:      const SC_MANAGER & scManager - the sc manager database
                const TCHAR * pszServiceName - service name
                UINT dwAccess - access code. See winsvc.h for more
                        detail.

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

SC_SERVICE::SC_SERVICE(
        const SC_MANAGER & scManager,
        const TCHAR * pszServiceName,
        UINT dwAccess )
{
    SC_HANDLE hService = ::OpenService( scManager.QueryHandle(),
                                        (TCHAR *)pszServiceName,
                                        dwAccess );
    SetHandle( hService );

    if ( hService == NULL )
    {
        ReportError( ::GetLastError() );
    }
}

/*******************************************************************

    NAME:       SC_SERVICE::~SC_SERVICE

    SYNOPSIS:   destructor - close the handle


    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

SC_SERVICE::~SC_SERVICE()
{
    if ( Close() != NERR_Success )
    {
        DBGEOL( SZ("Error: Cannot close service") );
    }
}

/*******************************************************************

    NAME:       SC_SERVICE::QueryConfig

    SYNOPSIS:   examine the service configuration parameters

    ENTRY:      LPQUERY_SERVICE_CONFIG lpServiceConfig - a pointer to a
                    buffer to receive a QUERY_SERVICE_CONFIG information
                    structure.

    EXIT:       lpServiceConfig - QUERY_SERVUCE_CONFIG information

    RETURNS:    NERR_Success - ok
                ERROR_ACCESS_DENIED - the specifide handle was not opened with
                    SERVICE_QUERY_CONFIG access.
                ERROR_INVALID_HANDLE - the specified handle is invalid.
                ERROR_INSUFFICIENT_BUFFER - there is more service configuration
                    information than would fit into the supplied output buffer.

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

APIERR SC_SERVICE::QueryConfig(
        LPQUERY_SERVICE_CONFIG *ppServiceConfig )
{
    APIERR err = NERR_Success;
    DWORD cbBytesNeeded = 0;

    if ( !::QueryServiceConfig( QueryHandle(),
        (LPQUERY_SERVICE_CONFIG)_buffer.QueryPtr(),
        _buffer.QuerySize(), & cbBytesNeeded ))
    {
        if (( err = ::GetLastError()) == ERROR_INSUFFICIENT_BUFFER )
        {
            cbBytesNeeded *= 2 ;  // BUGBUG

            if (( err = _buffer.Resize( (UINT)cbBytesNeeded )) == NERR_Success )
            {
                if ( !::QueryServiceConfig( QueryHandle(),
                    (LPQUERY_SERVICE_CONFIG)_buffer.QueryPtr(),
                    _buffer.QuerySize(), & cbBytesNeeded ))
                {
                    err = ::GetLastError();
                }
                else
                {
                    *ppServiceConfig = (LPQUERY_SERVICE_CONFIG)_buffer.QueryPtr();
                }
            }
        }
        if (err != NERR_Success)
        {
            DBGEOL( "NETUI: SC_SERVICE::QueryConfig returns "
                 << err
                 << ", bufsize " << _buffer.QuerySize()
                 << ", cbBytesNeeded " << cbBytesNeeded );
        }
    }
    else
    {
        *ppServiceConfig = (LPQUERY_SERVICE_CONFIG)_buffer.QueryPtr();
    }
    return err;

}

/*******************************************************************

    NAME:       SC_SERVICE::QueryStatus

    SYNOPSIS:   examine the service status

    ENTRY:      LPSERVICE_STATUS lpServiceStatus - a pointer to a buffer to
                    receive a SERVICE_STATUS information structure.

    EXIT:       lpServiceStatus - contains SERVICE_STATUS information structure.

    RETURNS:    NERR_Success - ok
                ERROR_ACCESS_DENIED - the specified handle was not opened with
                    SERVICE_QUERY_STATUS access.
                ERROR_INVALID_HANDLE - the specified handle is invalid.

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

APIERR SC_SERVICE::QueryStatus( LPSERVICE_STATUS lpServiceStatus )
{
    APIERR err = NERR_Success;

    if ( !::QueryServiceStatus( QueryHandle(), lpServiceStatus ))
    {
        err = ::GetLastError();
    }
    return err;
}

/*******************************************************************

    NAME:       SC_SERVICE::Control

    SYNOPSIS:   sends a control to a service

    ENTRY:      UINT dwControl - value which indicates the requested
                    control.
                    SERVICE_CONTROL_STOP - requests the service to stop.
                    SERVICE_CONTROL_PAUSE - requests the service to pause.
                    SERVICE_CONTROL_CONTINUE - requests the paused service to
                        resume.
                    SERVICE_CONTROL_INTERROGATE - requests that the service
                        updates the service control manager of its status
                        information immediately.
                LPSERVICE_STATUS lpServiceStatus - a pointer to a buffer to
                    receive a SERVICE_STATUS information structure.

    EXIT:       lpServiceStatus - receive a SERVICE_STATUS information
                    structure.

    RETURNS:    NERR_Success - ok
                ERROR_ACCESS_DENIED - the specified handle was not opened
                    with control access requested.
                ERROR_DEPENDENT_SERVICES_RUNNING - a stop control has been
                    sent to the service which other running services are
                    dependent on.
                ERROR_SERVICE_REQUEST_TIMEOUT - the service did not respond
                    to the start request in a timely fashion.
                ERROR_INVALID_SERVICE_CONTROL - the requested control is not
                    valid, or is unacceptable to the service.
                ERROR_SERVICE_CANNOT_ACCEPT_CTRL - The requested control cannot
                    be sent to the service becayse the state of the service is
                    stopped, stop-pending, or start-pending.

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

APIERR SC_SERVICE::Control(
        UINT dwControl,
        LPSERVICE_STATUS lpServiceStatus )
{
    APIERR err = NERR_Success;

    if ( !::ControlService( QueryHandle(), dwControl, lpServiceStatus ))
    {
        err = ::GetLastError();
    }
    return err;
}

/*******************************************************************

    NAME:       SC_SERVICE::ChangeConfig

    SYNOPSIS:   change the service configuration parameters

    ENTRY:      UINT dwServiceType - value to indicate the type of
                    service this is.
                        SERVICE_WIN32_OWN_PROCESS - a service which runs its
                            own Win32 process.
                        SERVICE_WIN32_SHARE_PROCESS - a service which shares a
                            Win32 process with other services.
                        SERVICE_DRIVER - an NT Device driver
                        SERVICE_NO_CHANGE - do not modify existing ServiceType
                            value.
                UINT dwStartType - value to specify when to start the
                    service.
                        SERVICE_BOOT_START - only valid if service type is
                            SERVICE_DRIVER. This device driver is to be started
                            by the OS loader.
                        SERVICE_SYSTEM_START - Only valid if service type is
                            SERVICE_DRIVER. This device driver is to be started
                            by IoInitSystem.
                        SERVICE_AUTO_START - valid for both SERVICE_DRIVER and
                            SERVICE_WIN32 service types. This service is
                            started by the service control manager when a start
                            request is issued via the StartService API.
                        SERVICE_DISABLE - This service can no longer be started.
                        SERVICE_NO_CHANGE - do not modify existing StartType
                            value.
                UINT dwErrorControl - value to specify the severity of
                    the error if this service fails to start during boot so
                    that the appropriate action can be taken.
                        SERVICE_ERROR_NORMAL - log error but system continues
                            to boot.
                        SERVICE_ERROR_SEVERE - log error, and the system is
                            rebooted with the last-known-good configuration.
                            If the current configuration is last-known-good,
                            press on with boot.
                        SERVICE_ERROR_CRITICAL - log error if possible, and
                            system is rebooted with last-known-good
                            configuration. If the current is last-know-good,
                            boot fails.
                        SERVICE_NO_CHANGE - do not modify existing StartType
                            value.
                const TCHAR * lpBinaryPathName - fully-qualified path name to the
                    the service binary file.
                const TCHAR * lpDependencies - space-separate names of services
                    whuch must be running before this service can run. An
                    empty string means that this service has no depencies.
                const TCHAR * lpServiceStartName - if service type is
                    SERVICE_WIN32, this name is the account name on the form
                    of "DomainName\Username" which the service process will
                    be logged on as when it runs. If the account belongs to
                    the built-in domain, ".\Username" can be specified. If
                    service type is SERVICE_DRIVER, this name must be the NT
                    driver object name (eg \FileSystem\LanManRedirector or
                    \Driver\Xns ) which the I/O system uses to load the device
                    driver.
                const TCHAR * lpPassword - Password to the account name specified
                    by lpServiceStartName if service type if SERVICE_WIN32.
                    This password will be changed periodically by the service
                    control manager so that it will not expire. If service
                    type is SERVICE_DRIVER, this parameter is ignored.
                const TCHAR * pszDisplayName - Display name for the service.

    RETURNS:    NERR_Success - no problem
                ERROR_ACCESS_DENIED - the specified handle was not opened with
                    SERVICE_CHANGE_CONFIG access.
                ERROR_INVALID_SERVICE_ACCOUNT - the account name does not exist,
                    or the service is specified to share the same binary file
                    as an already installed service but has an account name that
                    is not the same as installed service.
                ERROR_INVALID_PARAMETER - A parameter specified is invalid.

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

APIERR SC_SERVICE::ChangeConfig(
        UINT dwServiceType,
        UINT dwStartType,
        UINT dwErrorControl,
        const TCHAR * pszBinaryPathName,
        const TCHAR * pszLoadOrderGroup,
        const TCHAR * pszDependencies,
        const TCHAR * pszServiceStartName,
        const TCHAR * pszPassword,
        const TCHAR * pszDisplayName )
{
    APIERR err = NERR_Success;

    if ( !::ChangeServiceConfig( QueryHandle(),
                                 dwServiceType,
                                 dwStartType,
                                 dwErrorControl,
                                 pszBinaryPathName,
                                 pszLoadOrderGroup,
                                 NULL,
                                 pszDependencies,
                                 pszServiceStartName,
                                 pszPassword,
                                 pszDisplayName ) )
    {
        err = ::GetLastError();
    }

    return err;
}

/*******************************************************************

    NAME:       SC_SERVICE::Start

    SYNOPSIS:   begin the execution of a service

    ENTRY:      UINT dwNumServiceArgs - number of arguments in the
                    lpServiceArgs string. This value is passed on to the
                    service begin started.
                const TCHAR **ppszServiceArgs - An array of argument strings
                    passed on to a service for its use of receiving startup
                    parameters.

    RETURNS:    NERR_Success - ok
                ERROR_ACCESS_DENIED - the specified handle was not opened
                    with SERVICE_START access.
                ERROR_INVALID_HANDLE - the handle is invalid.
                ERROR_PATH_NOT_FOUND - The service binary file could not be
                    found.
                ERROR_SERVICE_ALREADY_RUNNING - An instance of the service is
                    already running.
                ERROR_SERVICE_REQUEST_TIMEOUT - the service did not respond to
                    the start request in a timely fashion.
                ERROR_SERVICE_NO_THREAD - A thread could not be created for the
                    Win32 service.
                ERROR_SERVICE_DATABASE_LOCKED - the database is locked.
                ERROR_SERVICE_DISABLED - the service has been disabled.
                ERROR_SERVICE_DEPENDENCY_FAIL - the service depends on
                    another service which has failed to start.
                ERROR_SERVICE_LOGON_FAILED - The service could not be logged on.

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

APIERR SC_SERVICE::Start(
        UINT dwNumServiceArgs,
        const TCHAR **ppszServiceArgs )
{
    APIERR err = NERR_Success;

    if ( !::StartService( QueryHandle(),
                          dwNumServiceArgs,
                          ppszServiceArgs ) )
    {
        err = ::GetLastError();
    }
    return err;
}


/*******************************************************************

    NAME:       SC_SERVICE::Delete

    SYNOPSIS:   remove the service from the Service Control Manager database

    RETURNS:    NERR_Success - OK
                ERROR_ACCESS_DENIED - the specified handle was not opened with
                    DELETE access.
                ERROR_INVALID_HANDLE - the handle is invalid
                ERROR_INVALID_SERVICE_STATE - attempted to delete a service
                    that has not stopped. The service must be stopped first.

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

APIERR SC_SERVICE::Delete()
{
    APIERR err = NERR_Success;

    if ( !::DeleteService( QueryHandle() ))
    {
        err = ::GetLastError();
    }
    return err;
}

/*******************************************************************

    NAME:       SC_SERVICE::EnumDependent

    SYNOPSIS:   enumerate services that depend on the specified service

    ENTRY:      UINT deServiceState - Value of select the services to
                    enumerate based on the running state. It must be one or the
                    bitwise OR of the following values:
                        SERVICE_ACTIVE - enumerate services that have started
                            which includes services that are running, paused,
                            and in pendinf states.
                        SERVICE_INACTIVE - enumerate services that are stopped.
                LPENUM_SERVICE_STATUS *ppServices - A pointer to a buffer to
                    receive an array of service entries; each entry is the
                    ENUM_SERVICE_STATUS information status.
                UINT * lpServicesReturned - A pointer to a variable to
                    receive the number of service entries returned.

    EXIT:       lpService - receive an array of service entries.
                lpServicesReturned - number of service entries returned.

    RETURNS:    NERR_Success - ok
                ERROR_ACCESS_DENIED - the specified handle was not opened with
                    SERVICE_ENUMERATE_DEPENDENTS access.
                ERROR_INVALID_HANDLE - the specified handle is invalid.
                ERROR_INSUFFICIENT_BUFFER - there are more service entries than would fit
                    into the supplied output buffer.
                ERROR_INVALID_PARAMETER - a parameter specified in invalid.

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

APIERR SC_SERVICE::EnumDependent(
        UINT dwServiceState,
        LPENUM_SERVICE_STATUS *ppServices,
        DWORD * lpServicesReturned )
{
    APIERR err = NERR_Success;
    DWORD cbBytesNeeded = 0;

    *ppServices = NULL ; // init to NULL
    *lpServicesReturned = 0 ;

    if ( !::EnumDependentServices( QueryHandle(), dwServiceState,
        (LPENUM_SERVICE_STATUS)_buffer.QueryPtr(), _buffer.QuerySize(),
        &cbBytesNeeded, lpServicesReturned ))
    {
        // JonN 3/20/95: Check for both MORE_DATA and INSUFFICIENT_BUFFER;
        //  not sure if downlevel can return INSUFFICIENT_BUFFER or not
        if (( err = ::GetLastError()) == ERROR_MORE_DATA
                              || (err == ERROR_INSUFFICIENT_BUFFER) )
        {
            //
            //  We need to enlarge our buffer to get all
            //  of the enumeration data.  We'll also throw
            //  in some slop space, just in case someone
            //  creates a new service between these two
            //  API calls.
            //

            cbBytesNeeded += (DWORD)_buffer.QuerySize() + SERVICE_ENUM_SLOP;

            if (( err = _buffer.Resize( (UINT)cbBytesNeeded )) == NERR_Success )
            {
                if ( !::EnumDependentServices( QueryHandle(), dwServiceState,
                    (LPENUM_SERVICE_STATUS)_buffer.QueryPtr(),
                    _buffer.QuerySize(), &cbBytesNeeded, lpServicesReturned ))
                {
                    err = ::GetLastError();
                }
                else
                {
                    *ppServices = (LPENUM_SERVICE_STATUS)_buffer.QueryPtr();
                }
            }
        }
        if (err != NERR_Success)
        {
            DBGEOL( "NETUI: SC_SERVICE::EnumDependent returns "
                 << err
                 << ", bufsize " << _buffer.QuerySize()
                 << ", cbBytesNeeded " << cbBytesNeeded );
        }
    }
    else
    {
        *ppServices = (LPENUM_SERVICE_STATUS)_buffer.QueryPtr();
    }
    return err;
}

/*******************************************************************

    NAME:       SC_SERVICE::QuerySecurity

    SYNOPSIS:   examine the security descriptor of a service object

    ENTRY:      SECURITY_INFORMATION dwSecurityInformation - Indicates
                    which security information is to be applied to the object.
                    The values to be returned are passed in the
                    lpSecurityDescriptor parameter/
                    THe security information is specified using the following
                    bit flags:
                        OWNER_SECURITY_INFORMATION (object's owner SID is being
                            referenced)
                        GROUP_SECURITY_INFORMATION (object's group SID is being
                            referenced)
                        DACL_SECURITY_INFORMATION (object's discretionary ACL is
                            being referenced)
                        SACL_SECURITY_INFORMATION (object's system ACL is being
                            reference)
                PSECURITY_DESCRIPTOR lpSecurityDescriptor - a pointer to a
                    buffer to receive a copy of the security descriptor of the
                    service object.

    EXIT:       lpSecurityDescriptor - receive the security descriptor of the
                    service object.

    RETURNS:    NERR_Success - ok
                ERROR_ACCESS_DENIED - the specified handle was not opened with
                    READ_CONTROL access, or the caller is not the owner of the
                    object.
                ERROR_INVALID_HANDLE - the specified handle is invalid.
                ERROR_INSUFFICIENT_BUFFER - the specified output buffer is
                    smaller than the required size returned in pcbBytesNeeded.
                ERROR_INVALID_PARAMETER - the specified security information
                    is invalid.

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

APIERR SC_SERVICE::QuerySecurity(
        SECURITY_INFORMATION dwSecurityInformation,
        PSECURITY_DESCRIPTOR *ppSecurityDescriptor )
{
    APIERR err = NERR_Success;
    DWORD cbBytesNeeded = 0;

    if ( !::QueryServiceObjectSecurity( QueryHandle(), dwSecurityInformation,
        (PSECURITY_DESCRIPTOR)_buffer.QueryPtr(), _buffer.QuerySize(),
        &cbBytesNeeded ))
    {
        if (( err = ::GetLastError()) == ERROR_INSUFFICIENT_BUFFER )
        {
            cbBytesNeeded *= 2 ;  // BUGBUG

            if (( err = _buffer.Resize( (UINT)cbBytesNeeded )) == NERR_Success )
            {
                if ( !::QueryServiceObjectSecurity( QueryHandle(),
                    dwSecurityInformation, (PSECURITY_DESCRIPTOR)_buffer.QueryPtr(),
                     _buffer.QuerySize(), &cbBytesNeeded ))
                {
                    err = ::GetLastError();
                }
                else
                {
                    *ppSecurityDescriptor=(PSECURITY_DESCRIPTOR)_buffer.QueryPtr();
                }
            }
        }
        if (err != NERR_Success)
        {
            DBGEOL( "NETUI: SC_SERVICE::QuerySecurity returns "
                 << err
                 << ", bufsize " << _buffer.QuerySize()
                 << ", cbBytesNeeded " << cbBytesNeeded );
        }
    }
    else
    {
        *ppSecurityDescriptor = (PSECURITY_DESCRIPTOR)_buffer.QueryPtr();
    }
    return err;
}


/*******************************************************************

    NAME:       SC_SERVICE::SetSecurity

    SYNOPSIS:   modify the security descriptor of a service object

    ENTRY:      SECURITY_INFORMATION dwSecurityInformation - Indicates
                    which security information is to be applied to the object.
                    The value(s) to be assigned are passed in the
                    lpSecurityDescriptor parameter.
                    The security information is specified using the following
                    bit flags:
                        OWNER_SECURITY_INFORMATION( Object's owner SID is
                            being referenced)
                        GROUP_SECURITY_INFORMATION( Object's group SID is
                            begin referenced)
                        DCAL_SECURITY_INFORMATION( object's discretionary ACL
                            is being referenced)
                        SACL)SECURITY_INFORMATION( object's system ACL is being
                            referenced)
                const PSECURITY_DESCRIPTOR lpSecurityDescriptor - A pointer
                    to a well-formed security descriptor.

    RETURNS:    NERR_Success - ok
                ERROR_ACCESS_DENIED - the specified handle was not opened with
                    the required access, or the caller is not the owner of the
                    object.
                ERROR_INVALID_HANDLE - the specified handle is invalid.
                ERROR_INVALID_PARAMETER - the specified security information or
                    security descriptor is invalid.

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

APIERR SC_SERVICE::SetSecurity(
        SECURITY_INFORMATION dwSecurityInformation,
        const PSECURITY_DESCRIPTOR lpSecurityDescriptor )
{
    APIERR err = NERR_Success;
    if ( !::SetServiceObjectSecurity( QueryHandle(), dwSecurityInformation,
        lpSecurityDescriptor ))
    {
        err = ::GetLastError();
    }
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\uintsam.cxx ===
/**********************************************************************/
/**			  Microsoft Windows NT	 		     **/
/**		   Copyright(c) Microsoft Corp., 1992		     **/
/**********************************************************************/

/*
 * This module contains the wrappers for SAM handle-based objects.
 *
 *
 * History
 *	thomaspa	01/17/92	Created from ntsam.hxx
        jonn            07/06/92        Added ADMIN_AUTHORITY::ReplaceAccountDomain
 */

#include "pchlmobj.hxx"  // Precompiled header



/*******************************************************************

    NAME: SAM_MEMORY::SAM_MEMORY

    SYNOPSIS: Constructor

    ENTRY: none

    EXIT: none

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
SAM_MEMORY::SAM_MEMORY( BOOL fOwnerAlloc )
	: NT_MEMORY(),
	_fOwnerAlloc( fOwnerAlloc )
{
    if ( QueryError() != NERR_Success )
	return;
}



/*******************************************************************

    NAME: SAM_MEMORY::~SAM_MEMORY

    SYNOPSIS: Destructor

    ENTRY: none

    EXIT: none

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
SAM_MEMORY::~SAM_MEMORY()
{
    Set( NULL, 0 );
}





/*******************************************************************

    NAME: SAM_SID_MEM::SAM_SID_MEM

    SYNOPSIS: Constructor

    ENTRY:
	

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
SAM_SID_MEM::SAM_SID_MEM( BOOL fOwnerAlloc )
	: SAM_MEMORY( fOwnerAlloc )
{
}



/*******************************************************************

    NAME: SAM_SID_MEM::~SAM_SID_MEM

    SYNOPSIS: Destructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
SAM_SID_MEM::~SAM_SID_MEM()
{
}




/*******************************************************************

    NAME: SAM_RID_MEM::SAM_RID_MEM

    SYNOPSIS: Constructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
SAM_RID_MEM::SAM_RID_MEM( BOOL fOwnerAlloc )
	: SAM_MEMORY( fOwnerAlloc )
{
}



/*******************************************************************

    NAME: SAM_RID_MEM::~SAM_RID_MEM

    SYNOPSIS: Destructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
SAM_RID_MEM::~SAM_RID_MEM()
{
}




/*******************************************************************

    NAME: SAM_RID_ENUMERATION_MEM::SAM_RID_ENUMERATION_MEM

    SYNOPSIS: Constructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
SAM_RID_ENUMERATION_MEM::SAM_RID_ENUMERATION_MEM( BOOL fOwnerAlloc )
	: SAM_MEMORY( fOwnerAlloc )
{
}


/*******************************************************************

    NAME: SAM_RID_ENUMERATION_MEM::~SAM_RID_ENUMERATION_MEM

    SYNOPSIS: Destructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
SAM_RID_ENUMERATION_MEM::~SAM_RID_ENUMERATION_MEM()
{
}


/*******************************************************************

    NAME: SAM_SID_NAME_USE_MEM::SAM_SID_NAME_USE_MEM

    SYNOPSIS: Constructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	03/11/92	Created from ntsam.hxx

********************************************************************/
SAM_SID_NAME_USE_MEM::SAM_SID_NAME_USE_MEM( BOOL fOwnerAlloc )
	: SAM_MEMORY( fOwnerAlloc )
{
}


/*******************************************************************

    NAME: SAM_SID_NAME_USE_MEM::~SAM_SID_NAME_USE_MEM

    SYNOPSIS: Destructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	03/11/92	Created from ntsam.hxx

********************************************************************/
SAM_SID_NAME_USE_MEM::~SAM_SID_NAME_USE_MEM()
{
}


/*******************************************************************

    NAME: SAM_PSWD_DOM_INFO_MEM::SAM_PSWD_DOM_INFO_MEM

    SYNOPSIS: Constructor

    ENTRY:

    HISTORY:
        JonN       12/23/93     Created

********************************************************************/
SAM_PSWD_DOM_INFO_MEM::SAM_PSWD_DOM_INFO_MEM( BOOL fOwnerAlloc )
	: SAM_MEMORY( fOwnerAlloc )
{
}

/*******************************************************************

    NAME: SAM_PSWD_DOM_INFO_MEM::~SAM_PSWD_DOM_INFO_MEM

    SYNOPSIS: Destructor

    ENTRY:

    NOTES:

    HISTORY:
        JonN       12/23/93     Created

********************************************************************/
SAM_PSWD_DOM_INFO_MEM::~SAM_PSWD_DOM_INFO_MEM()
{
}


/*******************************************************************

    NAME: SAM_PSWD_DOM_INFO_MEM::QueryNoAnonChange

    HISTORY:
        JonN       12/23/93     Created

********************************************************************/
BOOL SAM_PSWD_DOM_INFO_MEM::QueryNoAnonChange()
{
    return ( QueryPtr()->PasswordProperties
                        & DOMAIN_PASSWORD_NO_ANON_CHANGE );
}


/*******************************************************************

    NAME: SAM_PSWD_DOM_INFO_MEM::SetNoAnonChange

    HISTORY:
        JonN       12/23/93     Created

********************************************************************/
void SAM_PSWD_DOM_INFO_MEM::SetNoAnonChange( BOOL fNoAnonChange )
{
    if (fNoAnonChange)
    {
        QueryUpdatePtr()->PasswordProperties |= DOMAIN_PASSWORD_NO_ANON_CHANGE;
    }
    else
    {
        QueryUpdatePtr()->PasswordProperties &= ~DOMAIN_PASSWORD_NO_ANON_CHANGE;
    }
}





/*******************************************************************

    NAME: SAM_OBJECT::SAM_OBJECT

    SYNOPSIS: Constructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
SAM_OBJECT::SAM_OBJECT()
	: _hsam( NULL ),
	  _fHandleValid( FALSE )
{
    if ( QueryError() != NERR_Success )
	return;
}


/*******************************************************************

    NAME:       SAM_OBJECT::CloseHandle

    SYNOPSIS:   Explict close of handle

    ENTRY:

    EXIT:

    NOTES:      No error is reported if the handle
                has already been closed (invalidated).

    HISTORY:    Thomaspa   4/17/92	Templated from LSA_OBJECT

********************************************************************/
APIERR SAM_OBJECT::CloseHandle ( )
{
    APIERR err = NERR_Success ;

    if ( _fHandleValid )
    {
        if ( _hsam != NULL )
        {
            NTSTATUS ntStatus = ::SamCloseHandle( QueryHandle() ) ;

            err = ERRMAP::MapNTStatus( ntStatus ) ;
        }
        ResetHandle() ;
    }
    return err ;
}




/*******************************************************************

    NAME: SAM_OBJECT::~SAM_OBJECT

    SYNOPSIS: Destructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
SAM_OBJECT::~SAM_OBJECT()
{
    CloseHandle();
}




/*******************************************************************

    NAME: SAM_SERVER::SAM_SERVER

    SYNOPSIS: Constructor

    ENTRY: pszServerName - name of server to connect to
	accessDesired - Security access requested

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
SAM_SERVER::SAM_SERVER( const TCHAR * pszServerName,
		        ACCESS_MASK   accessDesired )
	: SAM_OBJECT(),
          _nlsServerName( pszServerName )
{
    if ( QueryError() != NERR_Success )
	return;

    APIERR err = _nlsServerName.QueryError();
    if (err != NERR_Success)
    {
        ReportError( err );
        return;
    }

    SAM_HANDLE hsamServer;
    UNICODE_STRING unistrServerName;
    PUNICODE_STRING punistrServerName;

    if ( pszServerName != NULL )
    {
	ALIAS_STR nlsServerName = pszServerName;

	err = ::FillUnicodeString( &unistrServerName, nlsServerName );
	if ( err != NERR_Success )
	{
	    ReportError( err );
	    return;
	}
	punistrServerName = &unistrServerName;
    }
    else
    {
	punistrServerName = NULL;
    }

    err = ERRMAP::MapNTStatus(
	    ::SamConnect( punistrServerName,
		          &hsamServer,
		          accessDesired,
		          NULL ) );

    if ( err == NERR_Success )
    {
	SetHandle( hsamServer );
    }
    else
    {
	ReportError( err );
    }

    if ( punistrServerName != NULL )
    {
	::FreeUnicodeString( punistrServerName );
    }
}




/*******************************************************************

    NAME: SAM_SERVER::~SAM_SERVER

    SYNOPSIS: Destructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
SAM_SERVER::~SAM_SERVER()
{
}



/*******************************************************************

    NAME: SAM_DOMAIN::SAM_DOMAIN

    SYNOPSIS: Constructor

    ENTRY: server - reference to SAM_SERVER on which the domain resides
	psidDomain - SID for domain
	accessDesired - Security access requested

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
SAM_DOMAIN::SAM_DOMAIN( const SAM_SERVER & server,
		       PSID psidDomain,
		       ACCESS_MASK accessDesired )
	: SAM_OBJECT(),
	  _ossidDomain( psidDomain, TRUE )
{

    if ( QueryError() != NERR_Success )
	return;

    APIERR err;

    if ( (err = _ossidDomain.QueryError()) != NERR_Success )
    {
	ReportError( err );
	return;
    }

    if ( (err = OpenDomain( server,
			    psidDomain,
			    accessDesired )) != NERR_Success )
    {
	ReportError(err);
	return;
    }
}




/*******************************************************************

    NAME: SAM_DOMAIN::~SAM_DOMAIN

    SYNOPSIS: Destructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
SAM_DOMAIN::~SAM_DOMAIN()
{
}





/*******************************************************************

    NAME: SAM_DOMAIN::OpenDomain

    SYNOPSIS: wrapper for SamOpenDomain()

    ENTRY: same as constructor

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
APIERR SAM_DOMAIN::OpenDomain( const SAM_SERVER & server,
		       	      PSID psidDomain,
		       	      ACCESS_MASK accessDesired )
{
    SAM_HANDLE hsamDomain;

    APIERR err = ERRMAP::MapNTStatus(
	    ::SamOpenDomain( server.QueryHandle(),
			     accessDesired,
			     psidDomain,
			     &hsamDomain ) );

    if ( err == NERR_Success )
    {
	SetHandle( hsamDomain );
    }
    return err;

}


/*******************************************************************

    NAME:     SAM_DOMAIN::GetPasswordInfo

    SYNOPSIS: Get the password info from SAM

    ENTRY:    psampswdinfo - pointer to a SAM_PSWD_DOM_INFO_MEM
                         object to receive the data.

    EXIT:

    NOTES:

    HISTORY:
        JonN       12/23/93     Created

********************************************************************/

APIERR SAM_DOMAIN::GetPasswordInfo( SAM_PSWD_DOM_INFO_MEM *psampswdinfo ) const
{

    PVOID pvBuffer = NULL;

    ASSERT( psampswdinfo != NULL );

    APIERR err = ERRMAP::MapNTStatus(
		::SamQueryInformationDomain( QueryHandle(),
					     DomainPasswordInformation,
					     &pvBuffer ) );
    if ( err == NERR_Success )
    {
	psampswdinfo->Set( pvBuffer, 1 );
    }

    return err;
}

/*******************************************************************

    NAME:     SAM_DOMAIN::SetPasswordInfo

    SYNOPSIS: Set the password info back to SAM

    ENTRY:    psampswdinfo - pointer to a SAM_PSWD_DOM_INFO_MEM
                         object for the data to set.

    EXIT:

    NOTES:

    HISTORY:
        JonN       12/23/93     Created

********************************************************************/
APIERR SAM_DOMAIN::SetPasswordInfo( const SAM_PSWD_DOM_INFO_MEM *psampswdinfo )
{

    ASSERT( psampswdinfo != NULL );

    APIERR err = ERRMAP::MapNTStatus(
		::SamSetInformationDomain(  QueryHandle(),
					    DomainPasswordInformation,
					    (PVOID) psampswdinfo->QueryPtr() ));
    return err;
}

/*******************************************************************

    NAME: SAM_DOMAIN::TranslateNamesToRids

    SYNOPSIS: Wrapper for SamLookupNames()

    ENTRY: ppszNames - array of names to lookup
	cNames - count of names to lookup
	psamrm - NT_MEMORY object to receive data
	psamsnum - NE_MEMORY object to receive Name Use data

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	03/06/92	Created from ntsam.hxx

********************************************************************/
APIERR SAM_DOMAIN::TranslateNamesToRids( const TCHAR * const * ppszNames,
				 ULONG cNames,
                                 SAM_RID_MEM *psamrm,
				 SAM_SID_NAME_USE_MEM *psamsnum) const
{
    ASSERT( ppszNames != NULL );
    ASSERT( *ppszNames != NULL );
    ASSERT( psamrm != NULL );
    ASSERT( psamsnum != NULL );

    if ( cNames == 0 )
    {
	psamrm->Set( NULL, 0 );
	psamsnum->Set( NULL, 0 );
	return ERRMAP::MapNTStatus( STATUS_NONE_MAPPED );
    }

    ULONG *		pulRids;
    SID_NAME_USE *	psidnu;
    APIERR		err;
    UINT		i;

    // First create and fill in the array of UNICODE_STRINGs
    UNICODE_STRING *aunicodeNames = new UNICODE_STRING[ cNames ];

    if (aunicodeNames == NULL)
    {
	return ERROR_NOT_ENOUGH_MEMORY;
    }


    UINT cAllocd = 0;

    for ( i = 0; i < cNames; i++ )
    {
	ALIAS_STR nlsTemp = *ppszNames++;

	if ( (err = ::FillUnicodeString( &aunicodeNames[i], nlsTemp ) )
		!= NERR_Success )
	{
	    break;
	}
	cAllocd++;
    }


    if ( err == NERR_Success )
    {
	err = ERRMAP::MapNTStatus(
			::SamLookupNamesInDomain( QueryHandle(),
						  cNames,
						  aunicodeNames,
						  &pulRids,
						  &psidnu ) );
    }



    if ( err == NERR_Success )
    {
	psamrm->Set( pulRids, cNames );
	psamsnum->Set( psidnu, cNames );
    }

    // Free the array of UNICODE_STRINGS
    for ( i = 0; i < cAllocd; i++ )
    {
	::FreeUnicodeString( &aunicodeNames[i] );
    }
    delete [] aunicodeNames;

    return err;
}


/*******************************************************************

    NAME: SAM_DOMAIN::EnumerateAliases

    SYNOPSIS: Wrapper for SamEnumerateAliasesInDomain()

    ENTRY:
	   psamrem - pointer to MEM object to receive the data.

	   psamenumh -	pointer to enumeration handle
			This should initially point to a variable initialized
			to 0.  If the call returns ERROR_MORE_DATA, then
			another call should be made using the returned
			plsaenumh to get the next block of data.
	   cbRequested - recommended maximum amount of data to return.

    EXIT:  NERR_Success or ERROR_MORE_DATA on success.

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
APIERR SAM_DOMAIN::EnumerateAliases( SAM_RID_ENUMERATION_MEM * psamrem,
				     PSAM_ENUMERATE_HANDLE psamenumh,
				     ULONG cbRequested ) const
{
    ASSERT( psamrem != NULL );

    ULONG cEntriesRead;
    PVOID pvBuffer;


    APIERR err = ERRMAP::MapNTStatus(
	::SamEnumerateAliasesInDomain( QueryHandle(),
				       psamenumh,
				       &pvBuffer,
				       cbRequested,
				       &cEntriesRead ));
    if ( err == NERR_Success || err == ERROR_MORE_DATA )
    {
	psamrem->Set( pvBuffer, cEntriesRead );
    }

    return err;
}


/*******************************************************************

    NAME: SAM_DOMAIN::EnumerateUsers

    SYNOPSIS: Wrapper for SamEnumerateUsersInDomain()

    ENTRY:
	   psamrem - pointer to MEM object to receive the data.

	   psamenumh -	pointer to enumeration handle
			This should initially point to a variable initialized
			to 0.  If the call returns ERROR_MORE_DATA, then
			another call should be made using the returned
			plsaenumh to get the next block of data.
	   cbRequested - recommended maximum amount of data to return.

    EXIT:  NERR_Success or ERROR_MORE_DATA on success.

    NOTES:

    HISTORY:
	thomaspa	04/13/92	Created

********************************************************************/
APIERR SAM_DOMAIN::EnumerateUsers( SAM_RID_ENUMERATION_MEM * psamrem,
				     PSAM_ENUMERATE_HANDLE psamenumh,
				     ULONG fAccountControl,
				     ULONG cbRequested ) const
{
    ASSERT( psamrem != NULL );

    ULONG cEntriesRead;
    PVOID pvBuffer;


    APIERR err = ERRMAP::MapNTStatus(
	::SamEnumerateUsersInDomain( QueryHandle(),
				     psamenumh,
				     fAccountControl,
				     &pvBuffer,
				     cbRequested,
				     &cEntriesRead ));
    if ( err == NERR_Success || err == ERROR_MORE_DATA )
    {
	psamrem->Set( pvBuffer, cEntriesRead );
    }

    return err;
}

/*******************************************************************

    NAME: SAM_DOMAIN::EnumerateGroups

    SYNOPSIS: Wrapper for SamEnumerateGroupsInDomain()

    ENTRY:
	   psamrem - pointer to MEM object to receive the data.

	   psamenumh -	pointer to enumeration handle
			This should initially point to a variable initialized
			to 0.  If the call returns ERROR_MORE_DATA, then
			another call should be made using the returned
			plsaenumh to get the next block of data.
	   cbRequested - recommended maximum amount of data to return.

    EXIT:  NERR_Success or ERROR_MORE_DATA on success.

    NOTES:

    HISTORY:
	Johnl	    20-Oct-1992     Copied from EnumerateAliases

********************************************************************/

APIERR SAM_DOMAIN::EnumerateGroups( SAM_RID_ENUMERATION_MEM * psamrem,
				     PSAM_ENUMERATE_HANDLE psamenumh,
				     ULONG cbRequested ) const
{
    ASSERT( psamrem != NULL );

    ULONG cEntriesRead;
    PVOID pvBuffer;


    APIERR err = ERRMAP::MapNTStatus(
	::SamEnumerateGroupsInDomain( QueryHandle(),
				       psamenumh,
				       &pvBuffer,
				       cbRequested,
				       &cEntriesRead ));
    if ( err == NERR_Success || err == ERROR_MORE_DATA )
    {
	psamrem->Set( pvBuffer, cEntriesRead );
    }

    return err;
}



/*******************************************************************

    NAME: SAM_DOMAIN::EnumerateAliasesForUser

    SYNOPSIS: Wrapper for SamEnumerateAliasesForUser

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
APIERR SAM_DOMAIN::EnumerateAliasesForUser( PSID psidUser,
				    SAM_RID_MEM * psamrm ) const
{
    ASSERT( psamrm != NULL );

    ULONG cAliases;
    ULONG *pulRids;

    APIERR err = ERRMAP::MapNTStatus(
			::SamGetAliasMembership( QueryHandle(),
						 1,
						 &psidUser,
						 &cAliases,
						 &pulRids ) );

    if ( err == NERR_Success )
    {
	psamrm->Set( pulRids, cAliases );
    }

    return err;
}



/*******************************************************************

    NAME: SAM_DOMAIN::RemoveMemberFromAliases

    SYNOPSIS: Wrapper for SamRemoveMemberFromForeignDomain

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	jonn    	02/06/92	Created

********************************************************************/
APIERR SAM_DOMAIN::RemoveMemberFromAliases( PSID psidMember )
{
    return ERRMAP::MapNTStatus(
			::SamRemoveMemberFromForeignDomain( QueryHandle(),
                                                            psidMember )
                              );
}



/*******************************************************************

    NAME: SAM_ALIAS::SAM_ALIAS

    SYNOPSIS: Opens an existing alias or Creates a New Alias

    ENTRY: samdom - SAM_DOMAIN for domain in which to open/create alias
	   accessDesired - security access requested
	   ( open form ) ulAliasRid - Rid for alias to open
	   ( create form ) pszName - name of alias to create

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	03/03/92	Created

********************************************************************/
/* Open an existing alias */
SAM_ALIAS::SAM_ALIAS(	const SAM_DOMAIN & samdom,
			ULONG ulAliasRid,
			ACCESS_MASK accessDesired )
	: _ulRid( MAXULONG )
{
    SAM_HANDLE hsamAlias;

    APIERR err = ERRMAP::MapNTStatus(
			:: SamOpenAlias( samdom.QueryHandle(),
					 accessDesired,
					 ulAliasRid,
					 &hsamAlias ) );
    if ( err != NERR_Success )
    {
	ReportError( err );
	return;
    }

    SetHandle( hsamAlias );
    _ulRid = ulAliasRid;
}


/* Create a new alias */
SAM_ALIAS::SAM_ALIAS( const SAM_DOMAIN & samdom,
			const TCHAR *pszName,
			ACCESS_MASK accessDesired )
	: _ulRid( MAXULONG )
{
    ASSERT( pszName != NULL );

    if ( QueryError() )
	return;

    SAM_HANDLE hsamAlias;
    ULONG ulRid;
    UNICODE_STRING unistr;
    ALIAS_STR nlsTemp = pszName;
    APIERR err;

    if ( (err = ::FillUnicodeString( &unistr, nlsTemp )) != NERR_Success )
    {
	ReportError( err );
	return;
    }

    err = ERRMAP::MapNTStatus(
	::SamCreateAliasInDomain( samdom.QueryHandle(),
			  &unistr,
			  accessDesired,
			  &hsamAlias,
			  &ulRid ) );

    FreeUnicodeString( &unistr );

    if ( err != NERR_Success )
    {
	ReportError( err );
	return;
    }

    SetHandle( hsamAlias );
    _ulRid = ulRid;
}




/*******************************************************************

    NAME: SAM_ALIAS::~SAM_ALIAS

    SYNOPSIS: Destructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
SAM_ALIAS::~SAM_ALIAS()
{
    _ulRid = MAXULONG;
}




/*******************************************************************

    NAME: SAM_ALIAS::Delete

    SYNOPSIS: Destructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
APIERR SAM_ALIAS::Delete()
{
    ASSERT( QueryHandle() != NULL );

    APIERR err = ERRMAP::MapNTStatus(
	::SamDeleteAlias( QueryHandle() ) );

    ResetHandle();

    return err;
}




/*******************************************************************

    NAME: SAM_ALIAS::GetMembers

    SYNOPSIS: Get the members of an alias

    ENTRY: psamsm - pointer to NT_MEMORY object to receive the members

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
APIERR SAM_ALIAS::GetMembers( SAM_SID_MEM * psamsm )
{
    ASSERT( psamsm != NULL );

    PSID * ppsidMembers;
    ULONG cMembers;
    APIERR err = ERRMAP::MapNTStatus(
	::SamGetMembersInAlias( QueryHandle(),
				&ppsidMembers,
				&cMembers ) );
    if ( err == NERR_Success )
	psamsm->Set( (PVOID)ppsidMembers, cMembers );
    return err;
}




/*******************************************************************

    NAME: SAM_ALIAS::AddMember

    SYNOPSIS: Add a member to an alias

    ENTRY: psidMemberSid - sid of member to add

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
APIERR SAM_ALIAS::AddMember( PSID psidMemberSid )
{
    return ERRMAP::MapNTStatus(
	::SamAddMemberToAlias( QueryHandle(),
			       psidMemberSid ) );

}




/*******************************************************************

    NAME: SAM_ALIAS::RemoveMember

    SYNOPSIS: Removes a member from an alias

    ENTRY: psidMemberSid - Member to remove

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
APIERR SAM_ALIAS::RemoveMember( PSID psidMemberSid )
{
    return ERRMAP::MapNTStatus(
	::SamRemoveMemberFromAlias( QueryHandle(),
				    psidMemberSid ) );
}




/*******************************************************************

    NAME: SAM_ALIAS::AddMembers

    SYNOPSIS: Add several members to an alias

    ENTRY: apsidMemberSids - sids of members to add
           cSidCount - number of members to add

    EXIT:

    NOTES:

    HISTORY:
        jonn            09/28/94        Created
        jonn            10/08/94        new API now available

********************************************************************/
APIERR SAM_ALIAS::AddMembers( PSID * apsidMemberSids, UINT cSidCount )
{
    APIERR err = NERR_Success;
    if (cSidCount == 0)
    {
        TRACEEOL( "SAM_ALIAS::AddMembers(); cSidCount==0" );
        return NERR_Success;
#ifdef NO_SUCH_API
    } else if (cSidCount > 1) {
        err = ERRMAP::MapNTStatus(
            ::SamAddMultipleMembersToAlias( QueryHandle(),
    			                    apsidMemberSids,
                                            cSidCount ) );
        //
        // Since any number of different error codes could come back if the
        // target server does not support this API, we fall through to
        // AddMember on any error.
        //
        if (err == NERR_Success)
           return NERR_Success;

        DBGEOL( "SAM_ALIAS::AddMembers(): error in new API " << err );
        err = NERR_Success;
#endif
    }

    for (UINT i = 0; i < cSidCount; i++)
    {
        err = AddMember( apsidMemberSids[i] );
        if (   err != NERR_Success
            && err != STATUS_MEMBER_IN_ALIAS
            && err != ERROR_MEMBER_IN_ALIAS )
        {
            DBGEOL(   "SAM_ALIAS::AddMembers(); error " << err
                   << "adding member " << i );
            return err;
        }
    }
    return NERR_Success;
}




/*******************************************************************

    NAME: SAM_ALIAS::RemoveMembers

    SYNOPSIS: Remove several members from an alias

    ENTRY: apsidMemberSids - sids of members to remove
           cSidCount - number of members to remove

    EXIT:

    NOTES:

    HISTORY:
        jonn            09/28/94        Created
        jonn            10/08/94        new API now available

********************************************************************/
APIERR SAM_ALIAS::RemoveMembers( PSID * apsidMemberSids, UINT cSidCount )
{
    APIERR err = NERR_Success;
    if (cSidCount == 0)
    {
        TRACEEOL( "SAM_ALIAS::RemoveMembers(); cSidCount==0" );
        return NERR_Success;
#ifdef NO_SUCH_API
    } else if (cSidCount > 1) {
        err = ERRMAP::MapNTStatus(
                ::SamRemoveMultipleMembersFromAlias( QueryHandle(),
                                                     apsidMemberSids,
                                                     cSidCount ) );
        //
        // Since any number of different error codes could come back if the
        // target server does not support this API, we fall through to
        // RemoveMember on any error.
        //
        if (err == NERR_Success)
           return NERR_Success;

        DBGEOL( "SAM_ALIAS::RemoveMembers(): error in new API " << err );
        err = NERR_Success;
#endif
    }

    for (UINT i = 0; i < cSidCount; i++)
    {
        err = RemoveMember( apsidMemberSids[i] );
        if (   err != NERR_Success
            && err != STATUS_MEMBER_NOT_IN_ALIAS
            && err != ERROR_MEMBER_NOT_IN_ALIAS )
        {
            DBGEOL(   "SAM_ALIAS::RemoveMembers(); error " << err
                   << "removing member " << i );
            return err;
        }
    }
    return NERR_Success;
}




/*******************************************************************

    NAME: SAM_ALIAS::GetComment

    SYNOPSIS: Gets the Comment for an alias using SamGetInformationAlias()

    ENTRY: pnlsComment - pointer an NLS_STR to receive the comment

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
APIERR SAM_ALIAS::GetComment( NLS_STR * pnlsComment )
{

    ASSERT( pnlsComment != NULL );

    PALIAS_ADM_COMMENT_INFORMATION paaci;

    APIERR err = ERRMAP::MapNTStatus(
		::SamQueryInformationAlias( QueryHandle(),
					    AliasAdminCommentInformation,
					    (PVOID *)&paaci ) );
    if ( err == NERR_Success )
    {
	err = pnlsComment->MapCopyFrom( paaci->AdminComment.Buffer,
					    paaci->AdminComment.Length );
	::SamFreeMemory( (PVOID)paaci );
    }


    return err;
}


/*******************************************************************

    NAME: SAM_ALIAS::SetComment

    SYNOPSIS: Sets the Comment for an alias using SamSetInformationAlias()

    ENTRY: pnlsComment - comment text

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
APIERR SAM_ALIAS::SetComment( const NLS_STR * pnlsComment )
{
    ALIAS_ADM_COMMENT_INFORMATION aaci;

    APIERR err = ::FillUnicodeString( &aaci.AdminComment, *pnlsComment );
    if ( err == NERR_Success )
    {
	err = ERRMAP::MapNTStatus(
		::SamSetInformationAlias( QueryHandle(),
					  AliasAdminCommentInformation,
					  (PVOID)&aaci ) );
    }

    FreeUnicodeString( &aaci.AdminComment );
    return err;
}


/*******************************************************************

    NAME: SAM_ALIAS::QueryRID

    SYNOPSIS: Returns the RID for this alias.  Works if alias was
              constructed successfully, regardless of whether it existed
              already or was just created.

    EXIT:       RID for alias

    NOTES:

    HISTORY:
        jonn            05/04/94        Created by JonN (was already defined)

********************************************************************/
ULONG SAM_ALIAS::QueryRID()
{
    ASSERT( QueryError() == NERR_Success );
    return _ulRid;
}



/*******************************************************************

    NAME: SAM_USER::SAM_USER

    SYNOPSIS: Opens an existing user

    ENTRY: samdom - SAM_DOMAIN for domain in which to open user
	   accessDesired - security access requested
	   ulUserRid - Rid for user to open

    EXIT:

    NOTES:

    HISTORY:
        jonn            07/07/92        Created

********************************************************************/
/* Open an existing user */
SAM_USER::SAM_USER(	const SAM_DOMAIN & samdom,
			ULONG ulUserRid,
			ACCESS_MASK accessDesired )
	: _ulRid( MAXULONG )
{
    SAM_HANDLE hsamUser;

    APIERR err = ERRMAP::MapNTStatus(
			:: SamOpenUser(  samdom.QueryHandle(),
					 accessDesired,
					 ulUserRid,
					 &hsamUser ) );
    if ( err != NERR_Success )
    {
	ReportError( err );
	return;
    }

    SetHandle( hsamUser );
    _ulRid = ulUserRid;
}




/*******************************************************************

    NAME: SAM_USER::~SAM_USER

    SYNOPSIS: Destructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        jonn            07/07/92        Created

********************************************************************/
SAM_USER::~SAM_USER()
{
    _ulRid = MAXULONG;
}



/*******************************************************************

    NAME: SAM_USER::SetUsername

    SYNOPSIS: Sets the Username for an user using SamSetInformationUser()

    ENTRY: pnlsUsername - username

    EXIT:

    NOTES:

    HISTORY:
        jonn            07/07/92        Created

********************************************************************/
APIERR SAM_USER::SetUsername( const NLS_STR * pnlsUsername )
{
    USER_ACCOUNT_NAME_INFORMATION uani;

    APIERR err = ::FillUnicodeString( &uani.UserName, *pnlsUsername );
    if ( err == NERR_Success )
    {
	err = ERRMAP::MapNTStatus(
		::SamSetInformationUser(  QueryHandle(),
					  UserAccountNameInformation,
					  (PVOID)&uani ) );
    }

    FreeUnicodeString( &uani.UserName );
    return err;
}

/*******************************************************************

    NAME:      SAM_USER::SetPassword

    SYNOPSIS:  Changes the password for a user using the old password

    ENTRY:     const NLS_STR * pnlsOldPassword   -- old password for user
               const NLS_STR * pnlsNewPassword   -- new password for user

    EXIT:

    NOTES:

    HISTORY:
        DavidHov       08/06/92        Created

********************************************************************/
APIERR SAM_USER :: SetPassword (
    const NLS_STR & nlsOldPassword,
    const NLS_STR & nlsNewPassword )
{
    UNICODE_STRING unsOldPw,
                   unsNewPw ;
    APIERR err = 0 ;

    unsOldPw.Buffer = unsNewPw.Buffer = NULL ;

    do
    {
        if ( err = ::FillUnicodeString( & unsOldPw, nlsOldPassword ) )
            break ;

        if ( err = ::FillUnicodeString( & unsNewPw, nlsNewPassword ) )
            break ;

	err = ERRMAP::MapNTStatus(
		::SamChangePasswordUser(  QueryHandle(),
                                          & unsOldPw,
                                          & unsNewPw ) ) ;
    }
    while ( FALSE ) ;

    if ( unsOldPw.Buffer )
    {
       ::FreeUnicodeString( & unsOldPw );
    }

    if ( unsNewPw.Buffer )
    {
       ::FreeUnicodeString( & unsNewPw );
    }

    return err ;
}


/*******************************************************************

    NAME:      SAM_USER::SetPassword

    SYNOPSIS:  Changes the password to a new value

    ENTRY:     const NLS_STR * pnlsPassword   -- password for user
               BOOL fPasswordExpired          -- expiration flag

    EXIT:

    NOTES:

    HISTORY:
        DavidHov       09/03/92        Created

********************************************************************/
APIERR SAM_USER :: SetPassword (
    const NLS_STR & nlsPassword,
    BOOL fPasswordExpired )
{
    APIERR err = 0 ;
    USER_SET_PASSWORD_INFORMATION uspi ;

    uspi.Password.Buffer = NULL ;
    uspi.PasswordExpired = (fPasswordExpired != FALSE);

    do
    {
        if ( err = ::FillUnicodeString( & uspi.Password, nlsPassword ) )
            break ;

        TRACEEOL( SZ("NETUI: SAM_USER::SetPassword to [")
                  << uspi.Password.Buffer
                  << SZ("] length ")
                  << (INT) uspi.Password.Length
                  << SZ(" max lgt ")
                  << (INT) uspi.Password.MaximumLength
                  << SZ(" p/w expired = ")
                  << fPasswordExpired );

	err = ERRMAP::MapNTStatus(
                ::SamSetInformationUser( QueryHandle(),
                                         UserSetPasswordInformation,
                                         & uspi ) ) ;
    }
    while ( FALSE ) ;

    if ( uspi.Password.Buffer )
    {
       ::FreeUnicodeString( & uspi.Password );
    }

    return err ;
}



/*******************************************************************

    NAME: SAM_GROUP::SAM_GROUP

    SYNOPSIS: Opens an existing group

    ENTRY: samdom - SAM_DOMAIN for domain in which to open group
	   accessDesired - security access requested
	   ulGroupRid - Rid for group to open

    EXIT:

    NOTES:

    HISTORY:
        jonn            07/07/92        Created

********************************************************************/
/* Open an existing group */
SAM_GROUP::SAM_GROUP(	const SAM_DOMAIN & samdom,
			ULONG ulGroupRid,
			ACCESS_MASK accessDesired )
	: _ulRid( MAXULONG )
{
    SAM_HANDLE hsamGroup;

    APIERR err = ERRMAP::MapNTStatus(
			:: SamOpenGroup( samdom.QueryHandle(),
					 accessDesired,
					 ulGroupRid,
					 &hsamGroup ) );
    if ( err != NERR_Success )
    {
	ReportError( err );
	return;
    }

    SetHandle( hsamGroup );
    _ulRid = ulGroupRid;
}




/*******************************************************************

    NAME: SAM_GROUP::~SAM_GROUP

    SYNOPSIS: Destructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        jonn            07/07/92        Created

********************************************************************/
SAM_GROUP::~SAM_GROUP()
{
    _ulRid = MAXULONG;
}

/*******************************************************************

    NAME: SAM_GROUP::SetGroupname

    SYNOPSIS: Sets the Groupname for a global group using
              SamSetInformationGroup()

    ENTRY: pnlsGroupname - groupname

    EXIT:

    NOTES:

    HISTORY:
        jonn            05/31/94        Templated from SetUsername

********************************************************************/
APIERR SAM_GROUP::SetGroupname( const NLS_STR * pnlsGroupname )
{
    GROUP_NAME_INFORMATION gni;

    APIERR err = ::FillUnicodeString( &gni.Name, *pnlsGroupname );
    if ( err == NERR_Success )
    {
	err = ERRMAP::MapNTStatus(
		::SamSetInformationGroup(  QueryHandle(),
					   GroupNameInformation,
					   (PVOID)&gni ) );
    }

    FreeUnicodeString( &gni.Name );
    return err;
}

/*******************************************************************

    NAME: SAM_GROUP::GetComment

    SYNOPSIS: Gets the Comment for an Group using SamGetInformationGroup()

    ENTRY: pnlsComment - pointer an NLS_STR to receive the comment

    EXIT:

    NOTES:

    HISTORY:
	Johnl	    20-Oct-1992     Copied from SAM_ALIAS

********************************************************************/

APIERR SAM_GROUP::GetComment( NLS_STR * pnlsComment )
{
    ASSERT( pnlsComment != NULL );

    PGROUP_ADM_COMMENT_INFORMATION paaci;

    APIERR err = ERRMAP::MapNTStatus(
		::SamQueryInformationGroup( QueryHandle(),
					    GroupAdminCommentInformation,
					    (PVOID *)&paaci ) );
    if ( err == NERR_Success )
    {
	err = pnlsComment->MapCopyFrom( paaci->AdminComment.Buffer,
					paaci->AdminComment.Length );
	::SamFreeMemory( (PVOID)paaci );
    }

    return err;
}




/*******************************************************************

    NAME: SAM_GROUP::GetMembers

    SYNOPSIS: Wrapper for SamGetMembersInGroup

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        jonn            10/29/92        Created

********************************************************************/
APIERR SAM_GROUP::GetMembers( SAM_RID_MEM * psamrm )
{
    ASSERT( psamrm != NULL );

    ULONG   cMembers;
    ULONG * pulRids;
    ULONG * pulAttributes;

    APIERR err = ERRMAP::MapNTStatus(
			::SamGetMembersInGroup( QueryHandle(),
					        &pulRids,
					        &pulAttributes,
					        &cMembers ) );

    if ( err == NERR_Success )
    {
	psamrm->Set( pulRids, cMembers );

        // We don't care about attributes, delete them
        REQUIRE( ::SamFreeMemory( pulAttributes ) == STATUS_SUCCESS );
    }

    return err;
}


/*******************************************************************

    NAME: SAM_GROUP::AddMember

    SYNOPSIS: Add a member to a group

    ENTRY: ulMemberRid - rid of member to add

    EXIT:

    NOTES:

    HISTORY:
        jonn            10/12/94        Created

********************************************************************/
APIERR SAM_GROUP::AddMember( ULONG ulMemberRid )
{
    return ERRMAP::MapNTStatus(
	::SamAddMemberToGroup( QueryHandle(),
			       ulMemberRid,
                               SE_GROUP_MANDATORY | SE_GROUP_ENABLED) );

}




/*******************************************************************

    NAME: SAM_GROUP::RemoveMember

    SYNOPSIS: Removes a member from a group

    ENTRY: ulMemberRid - Member to remove

    EXIT:

    NOTES:

    HISTORY:
        jonn            10/12/94        Created

********************************************************************/
APIERR SAM_GROUP::RemoveMember( ULONG ulMemberRid )
{
    return ERRMAP::MapNTStatus(
	::SamRemoveMemberFromGroup( QueryHandle(),
				    ulMemberRid ) );
}




/*******************************************************************

    NAME: SAM_GROUP::AddMembers

    SYNOPSIS: Add several members to a group

    ENTRY: aridMemberRids - rids of members to add
           cRidCount - number of members to add

    EXIT:

    NOTES:

    HISTORY:
        jonn            10/12/94        Created (new API now available)

********************************************************************/
APIERR SAM_GROUP::AddMembers( ULONG * aridMemberRids, UINT cRidCount )
{
    APIERR err = NERR_Success;
    if (cRidCount == 0)
    {
        TRACEEOL( "SAM_GROUP::AddMembers(); cRidCount==0" );
        return NERR_Success;
#ifdef NO_SUCH_API
    } else if (cRidCount > 1) {
        err = ERRMAP::MapNTStatus(
    	    ::SamAddMultipleMembersToGroup( QueryHandle(),
                                            aridMemberRids,
                                            cRidCount ) );
        //
        // Since any number of different error codes could come back if the
        // target server does not support this API, we fall through to
        // AddMember on any error.
        //
        if (err == NERR_Success)
           return NERR_Success;

        DBGEOL( "SAM_GROUP::AddMembers(): error in new API " << err );
        err = NERR_Success;
#endif
    }

    for (UINT i = 0; i < cRidCount; i++)
    {
        err = AddMember( aridMemberRids[i] );
        if (   err != NERR_Success
            && err != STATUS_MEMBER_IN_GROUP
            && err != ERROR_MEMBER_IN_GROUP )
        {
            DBGEOL(   "SAM_GROUP::AddMembers(); error " << err
                   << "adding member " << i );
            return err;
        }
    }
    return NERR_Success;
}




/*******************************************************************

    NAME: SAM_GROUP::RemoveMembers

    SYNOPSIS: Remove several members from a group

    ENTRY: aridMemberRids - rids of members to remove
           cRidCount - number of members to remove

    EXIT:

    NOTES:

    HISTORY:
        jonn            10/12/94        Created (new API now available)

********************************************************************/
APIERR SAM_GROUP::RemoveMembers( ULONG * aridMemberRids, UINT cRidCount )
{
    APIERR err = NERR_Success;
    if (cRidCount == 0)
    {
        TRACEEOL( "SAM_GROUP::RemoveMembers(); cRidCount==0" );
        return NERR_Success;
#ifdef NO_SUCH_API
    } else if (cRidCount > 1) {
        err = ERRMAP::MapNTStatus(
    	       ::SamRemoveMultipleMembersFromGroup( QueryHandle(),
                                                    aridMemberRids,
                                                    cRidCount ) );
        //
        // Since any number of different error codes could come back if the
        // target server does not support this API, we fall through to
        // RemoveMember on any error.
        //
        if (err == NERR_Success)
           return NERR_Success;

        DBGEOL( "SAM_GROUP::RemoveMembers(): error in new API " << err );
        err = NERR_Success;
#endif
    }

    for (UINT i = 0; i < cRidCount; i++)
    {
        err = RemoveMember( aridMemberRids[i] );
        if (   err != NERR_Success
            && err != STATUS_MEMBER_NOT_IN_GROUP
            && err != ERROR_MEMBER_NOT_IN_GROUP )
        {
            DBGEOL(   "SAM_GROUP::RemoveMembers(); error " << err
                   << "removing member " << i );
            return err;
        }
    }
    return NERR_Success;
}


/*******************************************************************

    NAME: ADMIN_AUTHORITY::ADMIN_AUTHORITY

    SYNOPSIS: Constructor

    ENTRY: pszServerName - target machine name
	   accessAccountDomain - access desired for Account domain
	   accessBuiltinDomain - access desired for Builtin domain
	   accessLSA - access desired for LSA_POLICY object
	   accessServer - access desired for Sam Server object

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	03/06/92	Created
        jonn            07/06/92        Added ReplaceAccountDomain

********************************************************************/
ADMIN_AUTHORITY::ADMIN_AUTHORITY( const TCHAR * pszServerName,
                  ACCESS_MASK accessAccountDomain,
		  ACCESS_MASK accessBuiltinDomain,
                  ACCESS_MASK accessLSA,
		  ACCESS_MASK accessServer,
		  BOOL	      fNullSessionOk )
    : _nlsServerName( pszServerName ),
      _psamsrv( NULL ),
      _psamdomAccount( NULL ),
      _psamdomBuiltin( NULL ),
      _plsapol( NULL ),
      _papisess( NULL )
{
    if ( QueryError() )
    {
	return;
    }

    APIERR err;

    // if a non-NULL servername was specified, create an API_SESSION to
    // the server before trying to make any other API calls.
    if ( pszServerName != NULL )
    {
	_papisess = new API_SESSION( pszServerName, fNullSessionOk );

	err = ERROR_NOT_ENOUGH_MEMORY;
	if ( _papisess == NULL
	    || (err = _papisess->QueryError()) != NERR_Success )
	{
	    delete _papisess;
	    _papisess = NULL;
	    ReportError( err );
	}
    }

    if (   (err = _nlsServerName.QueryError()) != NERR_Success
        || (err = ReplaceSamServer( accessServer )) != NERR_Success
        || (err = ReplaceLSAPolicy( accessLSA )) != NERR_Success
        || (err = ReplaceBuiltinDomain( accessBuiltinDomain )) != NERR_Success
        || (err = ReplaceAccountDomain( accessAccountDomain )) != NERR_Success
       )
    {
	ReportError( err );
    }

    return;


}


/*******************************************************************

    NAME: ADMIN_AUTHORITY::~ADMIN_AUTHORITY

    SYNOPSIS:

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	03/06/92	Created

********************************************************************/
ADMIN_AUTHORITY::~ADMIN_AUTHORITY()
{
    delete _psamsrv;
    delete _psamdomAccount;
    delete _psamdomBuiltin;
    delete _plsapol;
    delete _papisess;

    _psamsrv = NULL;
    _psamdomAccount = NULL;
    _psamdomBuiltin = NULL;
    _plsapol = NULL;
    _papisess = NULL;
}


/*******************************************************************

    NAME: ADMIN_AUTHORITY::ReplaceSamServer

    SYNOPSIS:   Replaces the current SamServer handle with another
                one, presumably one with different access.  If the
                attempt to obtain the new handle fails, the old one
                is left in place.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        jonn            07/07/92        Created

********************************************************************/
APIERR ADMIN_AUTHORITY::ReplaceSamServer(
            ACCESS_MASK accessServer )
{
    APIERR err = NERR_Success;

    /*
     * Construct SAM_SERVER
     */
    SAM_SERVER * psamsrvNew = new SAM_SERVER( _nlsServerName, accessServer );

    if ( psamsrvNew == NULL )
        err = ERROR_NOT_ENOUGH_MEMORY;
    else if ( (err = psamsrvNew->QueryError()) != NERR_Success )
    {
        delete psamsrvNew;
    }
    else
    {
        delete _psamsrv;
        _psamsrv = psamsrvNew;
        _accessSamServer = accessServer;
    }

    return err;
}


/*******************************************************************

    NAME: ADMIN_AUTHORITY::ReplaceLSAPolicy

    SYNOPSIS:   Replaces the current LSA Policy handle with another
                one, presumably one with different access.  If the
                attempt to obtain the new handle fails, the old one
                is left in place.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        jonn            07/07/92        Created

********************************************************************/
APIERR ADMIN_AUTHORITY::ReplaceLSAPolicy(
            ACCESS_MASK accessLSA )
{
    APIERR err = NERR_Success;

    /*
     * Construct LSA_POLICY
     */
    LSA_POLICY * plsapolNew = new LSA_POLICY( _nlsServerName, accessLSA );

    if ( plsapolNew == NULL )
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }
    else if ( (err = plsapolNew->QueryError()) != NERR_Success )
    {
        delete plsapolNew;
    }
    else
    {
        delete _plsapol;
        _plsapol = plsapolNew;
        _accessLSAPolicy = accessLSA;
    }

    return err;
}


/*******************************************************************

    NAME: ADMIN_AUTHORITY::ReplaceBuiltinDomain

    SYNOPSIS:   Replaces the current Builtin Domain handle with another
                one, presumably one with different access.  If the
                attempt to obtain the new handle fails, the old one
                is left in place.

    ENTRY:      SAM Server handle must be ready, any access.

    EXIT:

    NOTES:

    HISTORY:
        jonn            07/07/92        Created

********************************************************************/
APIERR ADMIN_AUTHORITY::ReplaceBuiltinDomain(
            ACCESS_MASK accessBuiltinDomain )
{
    ASSERT( (_psamsrv != NULL) && (_psamsrv->QueryError() == NERR_Success) );

    APIERR err = NERR_Success;

    /*
     * Construct SAM_DOMAIN for Builtin domain
     */

    OS_SID ossidBuiltIn;

    do		// FAKE LOOP FOR ERROR HANDLING
    {
        if (   (err = ossidBuiltIn.QueryError()) != NERR_Success
            || (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_BuiltIn,
                                                           &ossidBuiltIn ))
                                                  != NERR_Success
           )
        {
            break;
        }

	PSID psidBuiltin = ossidBuiltIn.QuerySid();

	SAM_DOMAIN * psamdomBuiltinNew = new SAM_DOMAIN(
                                          *_psamsrv,
                                          psidBuiltin,
                                          accessBuiltinDomain );

	if ( psamdomBuiltinNew == NULL )
        {
	    err = ERROR_NOT_ENOUGH_MEMORY;
        }
        else if ( (err = psamdomBuiltinNew->QueryError()) != NERR_Success )
	{
            delete psamdomBuiltinNew;
	}
        else
        {
            delete _psamdomBuiltin;
            _psamdomBuiltin = psamdomBuiltinNew;
            _accessBuiltinDomain = accessBuiltinDomain;
        }

    } while ( FALSE );	// FAKE LOOP FOR ERROR HANDLING

    return err;
}


/*******************************************************************

    NAME: ADMIN_AUTHORITY::ReplaceAccountDomain

    SYNOPSIS:   Replaces the current Account Domain handle with another
                one, presumably one with different access.  If the
                attempt to obtain the new handle fails, the old one
                is left in place.

    ENTRY:      LSA Policy handle must already be allocated, and must
                have at least POLICY_VIEW_LOCAL_INFORMATION access.
                SAM Server handle must also be ready, any access.

    EXIT:

    NOTES:

    HISTORY:
        jonn            07/06/92        Created

********************************************************************/
APIERR ADMIN_AUTHORITY::ReplaceAccountDomain(
            ACCESS_MASK accessAccountDomain )
{
    ASSERT( (_plsapol != NULL) && (_plsapol->QueryError() == NERR_Success) );
    ASSERT( (_psamsrv != NULL) && (_psamsrv->QueryError() == NERR_Success) );

    APIERR err = NERR_Success;

    /*
     * Construct SAM_DOMAIN for Account domain
     */
    LSA_ACCT_DOM_INFO_MEM lsaadim;

    do		// FAKE LOOP FOR ERROR HANDLING
    {

        if ( (err = lsaadim.QueryError()) != NERR_Success )
        {
            break;
        }

        if ( (err = _plsapol->GetAccountDomain( &lsaadim )) != NERR_Success)
        {
            break;
        }

        PSID psidAccount = lsaadim.QueryPSID( );

        SAM_DOMAIN * psamdomAccountNew = new SAM_DOMAIN(
                              *_psamsrv,
        		      psidAccount,
        		      accessAccountDomain );

        if ( psamdomAccountNew == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
        else if ( (err = psamdomAccountNew->QueryError()) != NERR_Success )
        {
            delete psamdomAccountNew;
        }
        else
        {
            delete _psamdomAccount;
            _psamdomAccount = psamdomAccountNew;
            _accessAccountDomain = accessAccountDomain;
        }

    } while ( FALSE );	// FAKE LOOP FOR ERROR HANDLING

    return err;
}



/*******************************************************************

    NAME: ADMIN_AUTHORITY::QuerySamServer

    SYNOPSIS:

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	03/06/92	Created

********************************************************************/
SAM_SERVER * ADMIN_AUTHORITY::QuerySamServer() const
{
    return _psamsrv;
}



/*******************************************************************

    NAME: ADMIN_AUTHORITY::QueryAccountDomain

    SYNOPSIS: returns pointer to SAM_DOMAIN object for Account domain

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	03/06/92	Created

********************************************************************/
SAM_DOMAIN * ADMIN_AUTHORITY::QueryAccountDomain() const
{
    return _psamdomAccount;
}



/*******************************************************************

    NAME: ADMIN_AUTHORITY::QueryBuiltinDomain

    SYNOPSIS: returns pointer to SAM_DOMAIN object for Builtin domain

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	03/06/92	Created

********************************************************************/
SAM_DOMAIN * ADMIN_AUTHORITY::QueryBuiltinDomain() const
{
    return _psamdomBuiltin;
}



/*******************************************************************

    NAME: ADMIN_AUTHORITY::QueryLSAPolicy

    SYNOPSIS: returns pointer to LSA_POLICY object

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	03/06/92	Created

********************************************************************/
LSA_POLICY * ADMIN_AUTHORITY::QueryLSAPolicy() const
{
    return _plsapol;
}


/*******************************************************************

    NAME: ADMIN_AUTHORITY::QueryAccessSamServer

    SYNOPSIS:

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	jonn    	07/20/92	Created

********************************************************************/
ACCESS_MASK ADMIN_AUTHORITY::QueryAccessSamServer() const
{
    return _accessSamServer;
}



/*******************************************************************

    NAME: ADMIN_AUTHORITY::QueryAccessLSAPolicy

    SYNOPSIS:

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	jonn    	07/20/92	Created

********************************************************************/
ACCESS_MASK ADMIN_AUTHORITY::QueryAccessLSAPolicy() const
{
    return _accessLSAPolicy;
}



/*******************************************************************

    NAME: ADMIN_AUTHORITY::QueryAccessBuiltinDomain

    SYNOPSIS:

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	jonn    	07/20/92	Created

********************************************************************/
ACCESS_MASK ADMIN_AUTHORITY::QueryAccessBuiltinDomain() const
{
    return _accessBuiltinDomain;
}


/*******************************************************************

    NAME: ADMIN_AUTHORITY::QueryAccessAccountDomain

    SYNOPSIS:

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	jonn    	07/20/92	Created

********************************************************************/
ACCESS_MASK ADMIN_AUTHORITY::QueryAccessAccountDomain() const
{
    return _accessAccountDomain;
}


/*******************************************************************

    NAME: ADMIN_AUTHORITY::UpgradeSamServer

    SYNOPSIS:   Upgrades the current SamServer handle if it does not
                have at least the requested access.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        jonn            07/20/92        Created

********************************************************************/
APIERR ADMIN_AUTHORITY::UpgradeSamServer(
            ACCESS_MASK accessServer )
{
    ACCESS_MASK accessNew = accessServer | QueryAccessSamServer();

    return (accessNew == QueryAccessSamServer())
                 ? NERR_Success
                 : ReplaceSamServer( accessNew );
}


/*******************************************************************

    NAME: ADMIN_AUTHORITY::UpgradeLSAPolicy

    SYNOPSIS:   Upgrades the current LSAPolicy handle if it does not
                have at least the requested access.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        jonn            07/20/92        Created

********************************************************************/
APIERR ADMIN_AUTHORITY::UpgradeLSAPolicy(
            ACCESS_MASK accessLSA )
{
    ACCESS_MASK accessNew = accessLSA | QueryAccessLSAPolicy();

    return (accessNew == QueryAccessLSAPolicy())
                 ? NERR_Success
                 : ReplaceLSAPolicy( accessNew );
}


/*******************************************************************

    NAME: ADMIN_AUTHORITY::UpgradeBuiltinDomain

    SYNOPSIS:   Upgrades the current BuiltinDomain handle if it does not
                have at least the requested access.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        jonn            07/20/92        Created

********************************************************************/
APIERR ADMIN_AUTHORITY::UpgradeBuiltinDomain(
            ACCESS_MASK accessBuiltinDomain )
{
    ACCESS_MASK accessNew = accessBuiltinDomain | QueryAccessBuiltinDomain();

    return (accessNew == QueryAccessBuiltinDomain())
                 ? NERR_Success
                 : ReplaceBuiltinDomain( accessNew );
}


/*******************************************************************

    NAME: ADMIN_AUTHORITY::UpgradeAccountDomain

    SYNOPSIS:   Upgrades the current AccountDomain handle if it does not
                have at least the requested access.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        jonn            07/20/92        Created

********************************************************************/
APIERR ADMIN_AUTHORITY::UpgradeAccountDomain(
            ACCESS_MASK accessAccountDomain )
{
    ACCESS_MASK accessNew = accessAccountDomain | QueryAccessAccountDomain();

    return (accessNew == QueryAccessAccountDomain())
                 ? NERR_Success
                 : ReplaceAccountDomain( accessNew );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmobj\uintlstd.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    UINTLSTD.CXX


    LSA Trusted Domain handling



    FILE HISTORY:
        DavidHov    3/10/92   Created

*/


#include "pchlmobj.hxx"  // Precompiled header


/*******************************************************************

    NAME:       LSA_TRUSTED_DOMAIN::LSA_TRUSTED_DOMAIN

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
LSA_TRUSTED_DOMAIN :: LSA_TRUSTED_DOMAIN (
    const LSA_POLICY & lsapol,
    const PSID psid,
    ACCESS_MASK desiredAccess )
{
    LSA_HANDLE hlsa = NULL ;

    if ( QueryError() )
        return ;

    NTSTATUS ntstatus = ::LsaOpenTrustedDomain(
                            lsapol.QueryHandle(),
                            psid,
                            desiredAccess,
                            & hlsa ) ;
    APIERR err = ERRMAP::MapNTStatus( ntstatus );
    if ( err == 0 )
    {
        SetHandle( hlsa ) ;
    }
    else
    {
        DBGEOL( "NETUI: LSA_TRUSTED_DOMAIN::ctor: LsaOpenTrustedDomain returns NTSTATUS " << err );
        ReportError( err ) ;
    }
}

/*******************************************************************

    NAME:       LSA_TRUSTED_DOMAIN::LSA_TRUSTED_DOMAIN

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
LSA_TRUSTED_DOMAIN :: LSA_TRUSTED_DOMAIN (
    const LSA_POLICY & lsapol,
    const LSA_TRUST_INFORMATION & lstInfo,
    ACCESS_MASK desiredAccess )
{
    LSA_HANDLE hlsa = NULL ;

    if ( QueryError() )
        return ;

    NTSTATUS ntstatus = ::LsaOpenTrustedDomain(
                            lsapol.QueryHandle(),
                            lstInfo.Sid,
                            desiredAccess,
                            & hlsa );
    APIERR err = ERRMAP::MapNTStatus( ntstatus );
    if ( err == 0 )
    {
        SetHandle( hlsa ) ;
    }
    else
    {
        DBGEOL( "NETUI: LSA_TRUSTED_DOMAIN::ctor: LsaOpenTrustedDomain returns NTSTATUS " << err );
        ReportError( err ) ;
    }
}

/*******************************************************************

    NAME:       LSA_TRUSTED_DOMAIN::LSA_TRUSTED_DOMAIN

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
LSA_TRUSTED_DOMAIN :: LSA_TRUSTED_DOMAIN (
    const LSA_POLICY & lsapol,
    const NLS_STR & nlsDomainName,
    const PSID psid,
    ACCESS_MASK desiredAccess )
{
    LSA_HANDLE hlsa = NULL ;
    LSA_TRUST_INFORMATION lstInfo ;
    APIERR err ;

    if ( QueryError() )
        return ;

    lstInfo.Sid = psid ;
    err = ::FillUnicodeString( & lstInfo.Name, nlsDomainName ) ;
    if ( err )
    {
        DBGEOL( "NETUI: LSA_TRUSTED_DOMAIN::ctor: FillUnicodeString returns " << err );
        ReportError( err ) ;
        return ;
    }

    NTSTATUS ntstatus = ::LsaCreateTrustedDomain(
                            lsapol.QueryHandle(),
                            & lstInfo,
                            desiredAccess,
                            & hlsa );
    err = ERRMAP::MapNTStatus( ntstatus );

    ::FreeUnicodeString( & lstInfo.Name ) ;

    if ( err == 0 )
    {
        SetHandle( hlsa ) ;
    }
    else
    {
        DBGEOL( "NETUI: LSA_TRUSTED_DOMAIN::ctor: LsaOpenTrustedDomain returns NTSTATUS " << err );
        ReportError( err ) ;
    }
}

/*******************************************************************

    NAME:       LSA_TRUSTED_DOMAIN::~LSA_TRUSTED_DOMAIN

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
LSA_TRUSTED_DOMAIN :: ~ LSA_TRUSTED_DOMAIN ()
{
}

/*******************************************************************

    NAME:       LSA_TRUSTED_DOMAIN::QueryPosixOffset

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
APIERR LSA_TRUSTED_DOMAIN :: QueryPosixOffset (
    ULONG * plPosixOffset ) const
{
    APIERR err = 0 ;
    TRUSTED_POSIX_OFFSET_INFO * pTrustPosix = NULL ;

    if ( QueryHandle() == NULL )
    {
        return ERROR_INVALID_HANDLE ;
    }

    err = ERRMAP::MapNTStatus(
                  ::LsaQueryInfoTrustedDomain(
                        QueryHandle(),
                        TrustedPosixOffsetInformation,
                        (PVOID *) & pTrustPosix ) ) ;

    if ( err == 0 )
    {
        *plPosixOffset = pTrustPosix->Offset ;
    }

    if ( pTrustPosix )
        ::LsaFreeMemory( pTrustPosix ) ;

    return err ;
}

/*******************************************************************

    NAME:       LSA_TRUSTED_DOMAIN::QueryControllerList

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
APIERR LSA_TRUSTED_DOMAIN :: QueryControllerList (
   LSA_REF_DOMAIN_MEM * plsatdm ) const
{
    if ( QueryHandle() == NULL )
    {
        return ERROR_INVALID_HANDLE ;
    }
    return ERROR_INVALID_FUNCTION ;
}

/*******************************************************************

    NAME:       LSA_TRUSTED_DOMAIN::SetPosixOffset

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
APIERR LSA_TRUSTED_DOMAIN :: SetPosixOffset ( ULONG lPosixOffset )
{
    if ( QueryHandle() == NULL )
    {
        return ERROR_INVALID_HANDLE ;
    }
    return ERROR_INVALID_FUNCTION ;
}

/*******************************************************************

    NAME:       LSA_TRUSTED_DOMAIN::SetControllerList

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
APIERR LSA_TRUSTED_DOMAIN :: SetControllerList (
    LSA_REF_DOMAIN_MEM * plsatdm )
{
    if ( QueryHandle() == NULL )
    {
        return ERROR_INVALID_HANDLE ;
    }
    return ERROR_INVALID_FUNCTION ;
}

APIERR LSA_TRUSTED_DOMAIN :: SetControllerList (
    const TRUSTED_CONTROLLERS_INFO & tciInfo )
{
    APIERR err ;

    if ( QueryHandle() == NULL )
    {
        return ERROR_INVALID_HANDLE ;
    }
    err = ERRMAP::MapNTStatus(
                        ::LsaSetInformationTrustedDomain(
                                QueryHandle(),
                                TrustedControllersInformation,
                                (PVOID) & tciInfo ) ) ;
    return err ;
}

APIERR LSA_TRUSTED_DOMAIN :: Delete ()
{
    if ( QueryHandle() == NULL )
    {
        return ERROR_INVALID_HANDLE ;
    }

    APIERR err = ERRMAP::MapNTStatus(
                     ::LsaDelete( QueryHandle() ) ) ;

    ResetHandle() ;

    return err ;
}


// End of UINTLSTD.CXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmoenum\lmoeali.cxx ===
/*****************************************************************/
/**                  Microsoft LAN Manager                      **/
/**            Copyright(c) Microsoft Corp., 1991               **/
/*****************************************************************/

/*
 *  History:
 *      Thomaspa    21-Feb-1992    Created
 *
 */

#include "pchlmobj.hxx"

DEFINE_LM_RESUME_ENUM_ITER_OF( ALIAS, SAM_RID_ENUMERATION )

/**********************************************************\

    NAME:       ALIAS_ENUM::CallAPI

    SYNOPSIS:   Call API to do alias enumeration

    ENTRY:      ppbBuffer       - ptr to ptr to buffer to fill
                pcEntriesRead   - variable to store entry count

    EXIT:       LANMAN error code

    NOTES:

    HISTORY:
        thomaspa         22-Feb-1992    Created

\**********************************************************/
APIERR ALIAS_ENUM::CallAPI( BOOL    fRestartEnum,
                        BYTE ** ppbBuffer,
                        UINT  * pcEntriesRead )
{
    if (fRestartEnum)
        _samenumh = 0;

    APIERR err;

    if ( _psamrem != NULL )
        delete _psamrem;

    _psamrem = new SAM_RID_ENUMERATION_MEM;

    if ( err = _psamrem->QueryError() )
    {
        return err;
    }


    err =  _samdomain.EnumerateAliases( _psamrem, &_samenumh, _cbMaxPreferred );

    *ppbBuffer = ( BYTE * )_psamrem->QueryPtr();
    /* BUGBUG 16bit woes */
    *pcEntriesRead = (UINT)_psamrem->QueryCount();

    return err;

} // ALIAS_ENUM::CallApi



/*******************************************************************

    NAME:           ALIAS_ENUM :: FreeBuffer

    SYNOPSIS:       Frees the API buffer.

    ENTRY:          ppbBuffer           - Points to a pointer to the
                                          enumeration buffer.

    HISTORY:
        KeithMo     31-Mar-1992 Created.

********************************************************************/
VOID ALIAS_ENUM :: FreeBuffer( BYTE ** ppbBuffer )
{
    *ppbBuffer = NULL;

}   // ALIAS_ENUM :: FreeBuffer


/**********************************************************\

    NAME:       ALIAS_ENUM::ALIAS_ENUM

    SYNOPSIS:   Alias enumeration constructor

    ENTRY:      samdomain -     SAM_DOMAIN reference for domain


    HISTORY:
        thomaspa         22-Feb-1992    Created

\**********************************************************/
ALIAS_ENUM::ALIAS_ENUM ( SAM_DOMAIN & samdomain, UINT cbMaxPreferred )
        : LM_RESUME_ENUM( 0 ),
          _samdomain( samdomain ),
          _psamrem( NULL ),
          _cbMaxPreferred( cbMaxPreferred )
{

    if( QueryError() != NERR_Success )
    {
        return;
    }
} // ALIAS_ENUM::ALIAS_ENUM


/**********************************************************\

    NAME:       ALIAS_ENUM::~ALIAS_ENUM

    SYNOPSIS:   Alias enumeration destructor

    ENTRY:


    HISTORY:
        thomaspa         22-Feb-1992    Created

\**********************************************************/
ALIAS_ENUM::~ALIAS_ENUM ( )
{
    NukeBuffers();

    if ( _psamrem != NULL )
        delete _psamrem;

} // ALIAS_ENUM::ALIAS_ENUM



/**********************************************************\

    NAME:       ALIAS_ENUM_OBJ::SetBufferPtr

    SYNOPSIS:   Saves the buffer pointer for this enumeration object.

    ENTRY:      pBuffer                 - Pointer to the new buffer.

    EXIT:       The pointer has been saved.

    NOTES:      Will eventually handle OemToAnsi conversions.

    HISTORY:
        thomaspa         22-Feb-1992    Created

\**********************************************************/
VOID ALIAS_ENUM_OBJ::SetBufferPtr( const SAM_RID_ENUMERATION * pBuffer )
{
    ENUM_OBJ_BASE :: SetBufferPtr( (const BYTE *)pBuffer );

} // ALIAS_ENUM_OBJ::SetBufferPtr




/**********************************************************\

    NAME:       ALIAS_ENUM_OBJ::GetComment

    SYNOPSIS:   Accessor to return the comment

    ENTRY:      hDomain - handle to domain of alias

    EXIT:       LANMAN error code

    NOTES:      Since the ALIAS_ENUM_OBJ doesn't store the comment,
                GetComment must call SAM to get the comment each time
                this method is called.  The caller should therefore call
                QueryError

    HISTORY:
        thomaspa         22-Feb-1992    Created

\**********************************************************/
APIERR ALIAS_ENUM_OBJ::GetComment( const SAM_DOMAIN & samdomain,
                                   NLS_STR *pnlsComment )
{
    APIERR err;

    SAM_ALIAS  samalias( samdomain, QueryRid(), ALIAS_READ_INFORMATION );

    if ( (err = samalias.QueryError()) != NERR_Success )
    {
        return err;
    }

    err = samalias.GetComment( pnlsComment );

    return err;

} // ALIAS_ENUM_OBJ::GetComment
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmoenum\domenum.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    domenum.cxx
    This file contains the class definition for the BROWSE_DOMAIN_ENUM
    enumerator class.  It also contains the class definition for the
    BRWOSE_DOMAIN_INFO class, which is the return "type" of the domain
    enumerator.

    The BROWSE_DOMAIN_ENUM class is used to enumerate domains.  A number
    of bit flags are passed to the object's constructor to control the
    domain enumeration.

    BROWSE_DOMAIN_ENUM is quite different from the LM_ENUM class of
    enumerators.  All of the "grunt" work is performed in the constructor
    (there is no GetInfo method).

    NOTE:  This code is based on an initial design by Yi-HsinS.


    FILE HISTORY:
        KeithMo     22-Jul-1992     Created.
        KeithMo     16-Nov-1992     Performance tuning.

*/
#include "pchlmobj.hxx"

//
//  Some handy macros for manipulating BROWSE_*_DOMAIN[S] masks.
//

#define IS_EMPTY(mask)          ((mask) == 0L)
#define NOT_EMPTY(mask)         ((mask) != 0L)

#define IS_VALID(mask)          (NOT_EMPTY(mask) && \
                                 IS_EMPTY((mask) & BROWSE_RESERVED))

#define DOES_INCLUDE(a,b)       (NOT_EMPTY((a) & (b)))


//
//  This is the separator list for the "other domains" as
//  returned by the WKSTA_USER_1 (i.e. NetWkstaUserGetInfo) object.
//

#define OTHER_DOMAINS_SEP       SZ(" ")



//
//  BROWSE_DOMAIN_INFO methods.
//

/*******************************************************************

    NAME:       BROWSE_DOMAIN_INFO :: BROWSE_DOMAIN_INFO

    SYNOPSIS:   BROWSE_DOMAIN_INFO class constructor.

    ENTRY:      pszDomainName           - The name of the current domain.

                maskDomainSources       - The sources of the domain.  This
                                          will be one or more of the
                                          BROWSE_*_DOMAIN[S] bitflags.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     22-Jul-1992     Created.

********************************************************************/
BROWSE_DOMAIN_INFO :: BROWSE_DOMAIN_INFO( const TCHAR * pszDomainName,
                                          ULONG         maskDomainSources )
  : _nlsDomainName( pszDomainName ),
    _maskDomainSources( maskDomainSources )
{
    UIASSERT( pszDomainName != NULL );
    UIASSERT( IS_VALID( maskDomainSources ) );

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_nlsDomainName )
    {
        ReportError( _nlsDomainName.QueryError() );
        return;
    }

    _pszDomainName = _nlsDomainName.QueryPch();
    UIASSERT( _pszDomainName != NULL );

}   // BROWSE_DOMAIN_INFO :: BROWSE_DOMAIN_INFO


/*******************************************************************

    NAME:       BROWSE_DOMAIN_INFO :: ~BROWSE_DOMAIN_INFO

    SYNOPSIS:   BROWSE_DOMAIN_INFO class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     22-Jul-1992     Created.

********************************************************************/
BROWSE_DOMAIN_INFO :: ~BROWSE_DOMAIN_INFO( VOID )
{
    _pszDomainName  = NULL;

}   // BROWSE_DOMAIN_INFO :: ~BROWSE_DOMAIN_INFO


DEFINE_SLIST_OF( BROWSE_DOMAIN_INFO );



//
//  BROWSE_DOMAIN_ENUM methods.
//

/*******************************************************************

    NAME:       BROWSE_DOMAIN_ENUM :: BROWSE_DOMAIN_ENUM

    SYNOPSIS:   BROWSE_DOMAIN_ENUM class constructor.

    ENTRY:      maskDomainSources       - A set of potential domain
                                          sources.  Must be a bit-OR
                                          combination of one or more
                                          BROWSE_*_DOMAIN[S] flags.

                pmaskSuccessful         - Will receive a bitmask of the
                                          "successful" domain sources.

    EXIT:       The object is constructed.

    NOTES:      Just because a particular bit is set in maskDomainSources
                and returned as successful in *pmaskSuccessful does *NOT*
                necessarily mean that such a domain was returned.

                For example, assume that this object is constructed with
                BROWSE_TRUSTING_DOMAINS set in maskDomainSources.  If the
                trusting domain enumerator is successful, then the
                BROWSE_TRUSTING_DOMAINS bit will get set in *pmaskSuccessful.
                However, the trusting domain enumerator *may* have returned
                an empty list of trusting domains.  In this case, the domain
                source succeeded, but there is no domain of the corresponding
                type in the domain list.

    HISTORY:
        KeithMo     22-Jul-1992     Created.
        Yi-HsinS    12-Nov-1992     Browse trusting domain only if it's
                                    absolutely needed

********************************************************************/
BROWSE_DOMAIN_ENUM :: BROWSE_DOMAIN_ENUM( ULONG   maskDomainSources,
                                          ULONG * pmaskSuccessful )
  : _slDomains(),
    _iterDomains( _slDomains ),
    _nlsComputerName(),
    _maskSourcesUnion( 0 )
{
    UIASSERT( IS_VALID( maskDomainSources ) );

    //
    //  Ensure we constructed properly.
    //

    APIERR err = QueryError();

    if( err == NERR_Success )
    {
        err = _nlsComputerName.QueryError();
    }

    //
    //  Get the local computer name.
    //

    TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD cchBuffer = sizeof(szComputerName) / sizeof(TCHAR);

    if( err == NERR_Success )
    {
        if( !::GetComputerName( szComputerName, &cchBuffer ) )
        {
            err = (APIERR)::GetLastError();
        }
    }

    if( err == NERR_Success )
    {
        err = _nlsComputerName.CopyFrom( szComputerName );
    }

    if( err == NERR_Success )
    {
        _nlsComputerName._strupr();
    }

    //
    //  Bag-out if any of the preceeding steps failed.
    //

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    //
    //  We'll update the "success" mask as we invoke the
    //  requested domain sources.
    //

    ULONG maskSuccessful = 0L;

    //
    //  If the user wants workgroup domains, get 'em.
    //

    if( DOES_INCLUDE( maskDomainSources, BROWSE_WORKGROUP_DOMAINS ) )
    {
        err = GetWorkgroupDomains();

        if( err == NERR_Success )
        {
            maskSuccessful |= BROWSE_WORKGROUP_DOMAINS;
        }
    }

    //
    //  If the user wants the Lanman 2.x domains, add them
    //  to the list.  Note that we retrieve the logon, wksta,
    //  and other domains from a WKSTA_10 object.  Therefore,
    //  we'll get them all from the same worker method.
    //

    if( DOES_INCLUDE( maskDomainSources, BROWSE_LM2X_DOMAINS ) )
    {
        err = GetLanmanDomains( maskDomainSources );

        if( err == NERR_Success )
        {
            maskSuccessful |= ( maskDomainSources & BROWSE_LM2X_DOMAINS );
        }
    }


    //
    //  If the user wants trusting domains, get 'em.
    //  ( We will only get the trusting domain if we don't want the
    //    workgroup or if we can't get anything back from the
    //    workgroup )
    //

    if( DOES_INCLUDE( maskDomainSources, BROWSE_TRUSTING_DOMAINS ) &&
        !DOES_INCLUDE( maskSuccessful, BROWSE_WORKGROUP_DOMAINS ) )
    {
        err = GetTrustingDomains();

        if ( err == NERR_Success )
        {
            maskSuccessful |= BROWSE_TRUSTING_DOMAINS;
        }
    }

    //
    //  Now that everything's been added, reset the iterator
    //  so it's in sync with the new items in the collection.
    //

    Reset();

    //
    //  If the user wants the success mask, give it to 'em.
    //

    if( pmaskSuccessful != NULL )
    {
        *pmaskSuccessful = maskSuccessful;
    }

    //
    //  If *none* of the requested domain sources were
    //  successful, then we'll set our status to the
    //  error code returned by the *last* domain source.
    //
    //  CODEWORK:  There should probably be a better
    //             (i.e. more robust) error reporting
    //             mechanism for multiple domain sources!
    //

    if( IS_EMPTY( maskSuccessful ) )
    {
        ReportError( err );
    }

}   // BROWSE_DOMAIN_ENUM :: BROWSE_DOMAIN_ENUM


/*******************************************************************

    NAME:       BROWSE_DOMAIN_ENUM :: ~BROWSE_DOMAIN_ENUM

    SYNOPSIS:   BROWSE_DOMAIN_ENUM class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     22-Jul-1992     Created.

********************************************************************/
BROWSE_DOMAIN_ENUM :: ~BROWSE_DOMAIN_ENUM( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // BROWSE_DOMAIN_ENUM :: ~BROWSE_DOMAIN_ENUM


/*******************************************************************

    NAME:       BROWSE_DOMAIN_ENUM :: FindFirst

    SYNOPSIS:   Implements a simple (minded) FindFirst/FindNext strategy.

    ENTRY:      maskDomainSources       - A bitmask of domain sources to
                                          search for.  The first domain
                                          that contains *any* of the bits
                                          in this mask will be returned.

    EXIT:       The _iterDomains iterator will have been reset to a new
                position.

    RETURNS:    BROWSE_DOMAIN_INFO *    - A pointer to the found domain,
                                          or NULL if none were found.

    HISTORY:
        KeithMo     22-Jul-1992     Created.

********************************************************************/
const BROWSE_DOMAIN_INFO * BROWSE_DOMAIN_ENUM :: FindFirst(
                                                       ULONG maskDomainSources )
{
    UIASSERT( IS_VALID( maskDomainSources ) );

    //
    //  Reset to the beginning of the domain list.
    //

    Reset();

    //
    //  Let FindNext do the dirty work.
    //

    return FindNext( maskDomainSources );

}   // BROWSE_DOMAIN_ENUM :: FindFirst


/*******************************************************************

    NAME:       BROWSE_DOMAIN_ENUM :: FindNext

    SYNOPSIS:   Implements a simple (minded) FindFirst/FindNext strategy.

    ENTRY:      maskDomainSources       - A bitmask of domain sources to
                                          search for.  The next domain
                                          that contains *any* of the bits
                                          in this mask will be returned.

    EXIT:       The _iterDomains iterator will have been reset to a new
                position.

    RETURNS:    BROWSE_DOMAIN_INFO *    - A pointer to the found domain,
                                          or NULL if none were found.

    HISTORY:
        KeithMo     22-Jul-1992     Created.

********************************************************************/
const BROWSE_DOMAIN_INFO * BROWSE_DOMAIN_ENUM :: FindNext(
                                                       ULONG maskDomainSources )
{
    UIASSERT( IS_VALID( maskDomainSources ) );

    //
    //  Scan the domain list starting at the current iteration point.
    //

    const BROWSE_DOMAIN_INFO * pbdi;

    while( ( pbdi = Next() ) != NULL )
    {
        //
        //  If the intersection of the current domain's sources list and
        //  the search criteria sources list is not empty, then we've
        //  found a winner.
        //

        if( DOES_INCLUDE( pbdi->QueryDomainSources(), maskDomainSources ) )
        {
            break;
        }
    }

    //
    //  At this point, pbdi will either be NULL (if we ran off the
    //  end of the domain list) or non-NULL (if we found a matching
    //  domain).
    //

    return pbdi;

}   // BROWSE_DOMAIN_ENUM :: FindNext


/*******************************************************************

    NAME:       BROWSE_DOMAIN_ENUM :: DetermineIfDomainMember

    SYNOPSIS:   This worker method determines if the current machine
                is a member of a domain or a workgroup.

    ENTRY:      pfIsDomainMember        - Will receive TRUE if the
                                          current machine is a member
                                          of a domain, FALSE otherwise.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     23-Jul-1992     Created.

********************************************************************/
APIERR BROWSE_DOMAIN_ENUM :: DetermineIfDomainMember( BOOL * pfIsDomainMember )
{
    LSA_POLICY lsapol( NULL, GENERIC_EXECUTE );
    LSA_PRIMARY_DOM_INFO_MEM lsapdim;

    APIERR err = lsapol.QueryError();

    if( err == NERR_Success )
    {
        err = lsapdim.QueryError();
    }

    if( err == NERR_Success )
    {
        err = lsapol.GetPrimaryDomain( &lsapdim );
    }

    if( err == NERR_Success )
    {
        *pfIsDomainMember = ( lsapdim.QueryPSID() != NULL );
    }

    return err;

}   // BROWSE_DOMAIN_ENUM :: DetermineIfDomainMember


/*******************************************************************

    NAME:       BROWSE_DOMAIN_ENUM :: AddDomainToList

    SYNOPSIS:   This worker method will add a specified domain to the
                domain list.

    ENTRY:      pszDomainName           - The name of the (new?) domain.

                maskDomainSource        - The source of the domain.

                fBrowserList            - If this is TRUE, then the domain
                                          is assumed to be from the browser.
                                          The browser list is always in
                                          uppercase.

    EXIT:       _slDomains is updated.  If the specified domain is
                already in the domain list, then sources field for
                that domain is updated to include maskDomainSource.

    RETURNS:    APIERR                  - Any errors encountered.

    NOTES:      We make a check here to see if the given domain name
                matches the local machine name.  If so, the domain
                is *not* added to the list.  This is to prevent the
                inclusion of bogus domain names when the user is
                logged onto the local machine.

                Also, this code *MUST* maintain the list in sorted
                order.  OLLB depends on this to optimize listbox
                additions.

    HISTORY:
        KeithMo     22-Jul-1992     Created.

********************************************************************/
APIERR BROWSE_DOMAIN_ENUM :: AddDomainToList( const TCHAR * pszDomainName,
                                              ULONG         maskDomainSource,
                                              BOOL          fBrowserList )
{
    UIASSERT( pszDomainName != NULL );
    UIASSERT( IS_VALID( maskDomainSource ) );

    APIERR err = NERR_Success;

    INT cmpres = 0;

    BROWSE_DOMAIN_INFO * pbdiScan = NULL;
    BDI_ITER iter( _slDomains );

    if( !fBrowserList )
    {
        {
            //
            //  Uppercase the name.
            //

            ALIAS_STR nlsDomainName( pszDomainName );
            UIASSERT( !!nlsDomainName );
            nlsDomainName._strupr();
        }

        //
        //  Check to see if the given domain matches
        //  the local machine name.  If so, ignore it.
        //

        if( !::I_MNetComputerNameCompare( pszDomainName, _nlsComputerName ) )
        {
            return NERR_Success;
        }

        //
        //  Scan the domain list to see if this domain
        //  already exists.
        //

        while( ( pbdiScan = iter.Next() ) != NULL )
        {
            cmpres = ::strcmpf( pszDomainName, pbdiScan->QueryDomainName() );

            if( cmpres <= 0 )
            {
                break;
            }
        }
    }

    if( ( pbdiScan != NULL ) && ( cmpres == 0 ) )
    {
        //
        //  The domain is already in the list.  Update the domain sources.
        //

        pbdiScan->AddDomainSource( maskDomainSource );
        _maskSourcesUnion |= maskDomainSource;
    }
    else
    {
        //
        //  The domain does not exist, so we get to create it.
        //

        BROWSE_DOMAIN_INFO * pbdiNew = new BROWSE_DOMAIN_INFO( pszDomainName,
                                                               maskDomainSource );

        err = ( pbdiNew == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                  : pbdiNew->QueryError();

        if( err == NERR_Success )
        {
            //
            //  Insert/append the node to the domain list.
            //

            err = ( pbdiScan == NULL ) ? _slDomains.Append( pbdiNew )
                                       : _slDomains.Insert( pbdiNew, iter );

            if( err != NERR_Success )
            {
                //
                //  The append failed.  Cleanup by deleting the
                //  BROWSE_DOMAIN_INFO node we created above.
                //

                delete pbdiNew;
                pbdiNew = NULL;
            }
            else
            {
                _maskSourcesUnion |= maskDomainSource;
            }
        }
    }

    return err;

}   // BROWSE_DOMAIN_ENUM :: AddDomainToList


/*******************************************************************

    NAME:       BROWSE_DOMAIN_ENUM :: GetLanmanDomains

    SYNOPSIS:   Retrieve the logon, wksta, and other domains, appending
                them to the domain list.

    ENTRY:      maskDomainSources       - Set of desired domain sources.

    EXIT:       If successful, _slDomains will be updated with
                the retrieved domains.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     22-Jul-1992     Created.

********************************************************************/
APIERR BROWSE_DOMAIN_ENUM :: GetLanmanDomains( ULONG maskDomainSources )
{
    UIASSERT( IS_VALID( maskDomainSources ) );
    UIASSERT( DOES_INCLUDE( maskDomainSources, BROWSE_LM2X_DOMAINS ) );

    //
    //  We'll use a WKSTA_10 object to retrieve the various
    //  Lanman 2.x domains.
    //

    WKSTA_10 wksta;

    APIERR err = wksta.GetInfo();

    //
    //  Add the logon domain, if requested.
    //

    if( ( err == NERR_Success ) &&
        DOES_INCLUDE( maskDomainSources, BROWSE_LOGON_DOMAIN ) )
    {
        const TCHAR * pszLogonDomain = wksta.QueryLogonDomain();

        if( pszLogonDomain != NULL )
        {
            err = AddDomainToList( pszLogonDomain,
                                   BROWSE_LOGON_DOMAIN );
        }
    }

    //
    //  Add the workstation domain, if requested.
    //

    if( ( err == NERR_Success ) &&
        DOES_INCLUDE( maskDomainSources, BROWSE_WKSTA_DOMAIN ) )
    {
        const TCHAR * pszWkstaDomain = wksta.QueryWkstaDomain();

        if( pszWkstaDomain != NULL )
        {
            err = AddDomainToList( pszWkstaDomain,
                                   BROWSE_WKSTA_DOMAIN );
        }
    }

    //
    //  Add the other domains, if requested.
    //

    if( ( err == NERR_Success ) &&
        DOES_INCLUDE( maskDomainSources, BROWSE_OTHER_DOMAINS ) )
    {
        WKSTA_USER_1 wkstaUser1;

        err = wkstaUser1.GetInfo();

        if( err == NERR_Success )
        {
            STRLIST slOtherDomains( wkstaUser1.QueryOtherDomains(),
                                    OTHER_DOMAINS_SEP );

            ITER_STRLIST islOtherDomains( slOtherDomains );
            NLS_STR * pnls;

            while( ( pnls = islOtherDomains.Next() ) != NULL )
            {
                err = AddDomainToList( pnls->QueryPch(),
                                       BROWSE_OTHER_DOMAINS );

                if( err != NERR_Success )
                {
                    break;
                }
            }
        }
    }

    return err;

}   // BROWSE_DOMAIN_ENUM :: GetLanmanDomains


/*******************************************************************

    NAME:       BROWSE_DOMAIN_ENUM :: GetTrustingDomains

    SYNOPSIS:   Retrieve the trusting domains, appending them to the
                domain list.

    EXIT:       If successful, _slDomains will be updated with
                the retrieved domains.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     22-Jul-1992     Created.
        JonN        31-Mar-1993     Logon domain not trusted domain

********************************************************************/
APIERR BROWSE_DOMAIN_ENUM :: GetTrustingDomains( VOID )
{
    //
    //  If we're not a domain member, then bag-out.
    //

    BOOL fIsDomainMember = FALSE;
    APIERR err = DetermineIfDomainMember( &fIsDomainMember );

    if( !fIsDomainMember )
    {
        return err;
    }

    //
    //  Determine the user's logon domain.
    //

    NLS_STR nlsLogonDC;

    err = nlsLogonDC.QueryError();

    if( err == NERR_Success )
    {
        err = GetLogonDomainDC( &nlsLogonDC );
    }

    // just return NERR_Success if user logged on locally
    if ( err == NERR_Success && (nlsLogonDC.strlen() > 0) )
    {
        //
        //  Let an ADMIN_AUTHORITY do all of the dirty work
        //  in connecting to the remote SAM.
        //

        ADMIN_AUTHORITY admin( nlsLogonDC );

        err = admin.QueryError();

        if( err == NERR_Success )
        {
            //
            //  Enumerate the interdomain trust accounts.
            //

            SAM_USER_ENUM enumSam( admin.QueryAccountDomain(),
                                   USER_INTERDOMAIN_TRUST_ACCOUNT );
            NLS_STR nlsDomain;

            err = enumSam.QueryError();

            if( err == NERR_Success )
            {
                err = nlsDomain.QueryError();
            }

            if( err == NERR_Success )
            {
                err = enumSam.GetInfo();
            }

            if( err == NERR_Success )
            {
                SAM_USER_ENUM_ITER iterSam( enumSam );
                const SAM_USER_ENUM_OBJ * pobjSam;

                while( ( pobjSam = iterSam.Next( &err ) ) != NULL )
                {
                    //
                    //  Retrieve the domain name.  This will be
                    //  an interdomain trust account and will
                    //  have a trailing '$'.
                    //

                    err = pobjSam->QueryUserName( &nlsDomain );

                    if( err != NERR_Success )
                    {
                        break;
                    }

                    //
                    //  Strip the trailing '$'.
                    //

                    ISTR istr( nlsDomain );

                    while( ( nlsDomain.QueryChar( istr ) != TCH('\0') ) &&
                           ( nlsDomain.QueryChar( istr ) != TCH('$') ) )
                    {
                        ++istr;
                    }

#ifdef DEBUG
                    {
                        ISTR istrDbg( istr );
                        UIASSERT( nlsDomain.QueryChar( istrDbg ) == TCH('$') );
                        ++istrDbg;
                        UIASSERT( nlsDomain.QueryChar( istrDbg ) == TCH('\0') );
                    }
#endif  // DEBUG

                    nlsDomain.DelSubStr( istr );

                    //
                    //  Add the domain to the list.
                    //

                    err = AddDomainToList( nlsDomain,
                                           BROWSE_TRUSTING_DOMAINS );

                    if( err != NERR_Success )
                    {
                        break;
                    }
                }
            }
        }
    }

    return err;

}   // BROWSE_DOMAIN_ENUM :: GetTrustingDomains


/*******************************************************************

    NAME:       BROWSE_DOMAIN_ENUM :: GetWorkgroupDomains

    SYNOPSIS:   Retrieve the workgroup domains, appending them to the
                domain list.

    EXIT:       *pfEmptyList - Contains FALSE if we can't get any workgroup
                               domains, TRUE otherwise.
                If successful, _slDomains will be updated with
                the retrieved domains.

    RETURNS:    APIERR                  - Any errors encountered.

    NOTES:      I have a solemn oath from LarryO that the domain list
                returned from the browser is *always* in uppercase and
                *always* sorted.

    HISTORY:
        KeithMo     22-Jul-1992     Created.
        Yi-HsinS    12-Nov-1992     Add pfEmptyList
        KeithMo     16-Nov-1992     Removed pfEmptyList.

********************************************************************/
APIERR BROWSE_DOMAIN_ENUM :: GetWorkgroupDomains( VOID )
{
    //
    //  This *MUST* be the first worker called!
    //

    UIASSERT( QueryDomainCount() == 0 );

    //
    //  Our domain enumerator.
    //

    DOMAIN0_ENUM enumDomains;

    APIERR err = enumDomains.GetInfo();

    if( err == NERR_Success )
    {
        //
        //  Sort the domain list.
        //

        enumDomains.Sort();

        //
        //  Scan through the returned list of domains, adding
        //  them to _slDomains.
        //

        DOMAIN0_ENUM_ITER iterDomains( enumDomains );
        const DOMAIN0_ENUM_OBJ * pdom;

        while( ( pdom = iterDomains() ) != NULL )
        {
            err = AddDomainToList( pdom->QueryName(),
                                   BROWSE_WORKGROUP_DOMAINS,
                                   TRUE );

            if( err != NERR_Success )
            {
                break;
            }
        }
    }

    return err;

}   // BROWSE_DOMAIN_ENUM :: GetWorkgroupDomains


/*******************************************************************

    NAME:       BROWSE_DOMAIN_ENUM :: GetLogonDomainDC

    SYNOPSIS:   Retrieve the name of a DC in the user's logon domain.
                Returned name is the empty string if user is logged on locally.

    ENTRY:      pnlsLogonDC             - Will receive the name of a DC
                                          in the logon domain.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     23-Jul-1992     Created.
        JonN        31-Mar-1993     Logon domain not primary

********************************************************************/
APIERR BROWSE_DOMAIN_ENUM :: GetLogonDomainDC( NLS_STR * pnlsLogonDC )
{
    //  Determine the user's logon domain.
    //

    WKSTA_10 wksta;
    APIERR err = wksta.QueryError();

    if( err == NERR_Success )
    {
        err = wksta.GetInfo();
    }

    if( err == NERR_Success )
    {
        // check if logged on locally
        TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH+1];
        DWORD cchBuffer = sizeof(szComputerName) / sizeof(TCHAR);

        if ( (err = ( ::GetComputerName( szComputerName, &cchBuffer )
                          ? NERR_Success
                          : ::GetLastError()) ) != NERR_Success
           )
        {
            DBGEOL( "BROWSE_DOMAIN_ENUM: can't get local computer name " << err );
        }
        else if ( 0 == ::stricmpf( wksta.QueryLogonDomain(), szComputerName ) )
        {
            TRACEEOL( "BROWSE_DOMAIN_ENUM: logged on locally, skip trusting domains" );
            err = pnlsLogonDC->CopyFrom( SZ("") );
        }
        else
        {
            //
            //  Determine the PDC of the logon domain.
            //

            DOMAIN domainLogon( wksta.QueryLogonDomain(), TRUE );

            err = domainLogon.GetInfo();

            if( err == NERR_Success )
            {
                err = pnlsLogonDC->CopyFrom( domainLogon.QueryPDC() );
            }
        }
    }

    return err;

}   // BROWSE_DOMAIN_ENUM :: GetLogonDomainDC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmoenum\lmoeals.cxx ===
/*****************************************************************/
/**		     Microsoft LAN Manager			**/
/**	       Copyright(c) Microsoft Corp., 1991		**/
/*****************************************************************/

/*
 *  HISTORY:
 *	RustanL     11-Jan-1991     Created
 *	RustanL     24-Jan-1991     Added level 90
 *	ChuckC	    23-Mar-1991	    Code Rev Cleanup
 *	KeithMo	    07-Oct-1991	    Win32 Conversion.
 *
 */


#ifdef LATER	// BUGBUG!  Do we really need LanServer interoperability??

#include "pchlmobj.hxx"


/*****************************	SHARE90_ENUM  *****************************/



/**********************************************************\

   NAME:       SHARE90_ENUM::SHARE90_ENUM

   SYNOPSIS:   SHARE enum level 90 constructor

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
   	RustanL     11-Jan-1991     Created

\**********************************************************/

SHARE90_ENUM::SHARE90_ENUM( const TCHAR * pszServer )
  : SHARE_ENUM( pszServer, 90 )
{
    // do nothing else

}  // SHARE90_ENUM::SHARE90_ENUM



/**********************************************************\

   NAME:       SHARE90_ENUM::QueryItemSize

   SYNOPSIS:   query the total number of item in the share

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
   	RustanL     11-Jan-1991     Created

\**********************************************************/

UINT SHARE90_ENUM::QueryItemSize( VOID ) const
{
    UIASSERT( QueryInfoLevel() == 90 );

    // BUGBUG!  NT Structures??

    return sizeof( struct share_info_90 ) + MAXCOMMENTSZ + 1;

}  // SHARE90_ENUM::QueryItemSize


DEFINE_LM_ENUM_ITER_OF( SHARE90, struct share_info_90 );



/*****************************	SHARE91_ENUM  *****************************/



/**********************************************************\

   NAME:       SHARE91_ENUM::SHARE91_ENUM

   SYNOPSIS:   share enum level 91 constructor

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
   	RustanL     11-Jan-1991     Created

\**********************************************************/

SHARE91_ENUM::SHARE91_ENUM( const TCHAR * pszServer )
  : SHARE_ENUM( pszServer, 91 )
{
    // do nothing else

}  // SHARE91_ENUM::SHARE91_ENUM



/**********************************************************\

   NAME:       SHARE91_ENUM::QueryItemSize

   SYNOPSIS:   query total item size of the share

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
   	RustanL     11-Jan-1991     Created

\**********************************************************/

UINT SHARE91_ENUM::QueryItemSize( VOID ) const
{
    UIASSERT( QueryInfoLevel() == 91 );

    // BUGBUG!  NT Structures??

    return sizeof( struct share_info_91 ) + NNLEN + 1 + MAX_PATH + 1 + NNLEN + 1;

}  // SHARE91_ENUM::QueryItemSize


DEFINE_LM_ENUM_ITER_OF( SHARE91, struct share_info_91 );


#endif	// LATER    // BUGBUG!
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmoenum\lmoechar.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    lmoechar.cxx
    This file contains the class definitions for the CHARDEVQ_ENUM and
    CHARDEVQ1_ENUM enumerator class and their associated iterator classes.

    CHARDEVQ_ENUM is a base enumeration class intended to be subclassed for
    the desired info level.  CHARDEVQ1_ENUM is an info level 1 enumerator.


    FILE HISTORY:
	KeithMo	    28-Jul-1991	    Created.
	KeithMo	    12-Aug-1991	    Code review cleanup.
	KeithMo	    07-Oct-1991	    Win32 Conversion.

*/

#include "pchlmobj.hxx"

//
//  CHARDEVQ_ENUM methods
//

/*******************************************************************

    NAME:	    CHARDEVQ_ENUM :: CHARDEVQ_ENUM

    SYNOPSIS:	    CHARDEVQ_ENUM class constructor.

    ENTRY:	    pszServerName	- The name of the server to execute
    				  	  the enumeration on.  NULL =
				  	  execute locally.

		    pszUserName		- The name of a user to enumerate
		    			  character queue's for.

		    usLevel		- The information level.

    EXIT:	    The object is constructed.

    RETURNS:	    No return value.

    NOTES:

    HISTORY:
	KeithMo	    28-Jul-1991	    Created.

********************************************************************/
CHARDEVQ_ENUM :: CHARDEVQ_ENUM( const TCHAR * pszServerName,
				const TCHAR * pszUserName,
			  	UINT	     uLevel )
  : LOC_LM_ENUM( pszServerName, uLevel ),
    _nlsUserName( pszUserName )
{
    if( QueryError() != NERR_Success )
    {
    	return;
    }

    if( !_nlsUserName )
    {
    	ReportError( _nlsUserName.QueryError() );
    }

}   // CHARDEVQ_ENUM :: CHARDEVQ_ENUM


/*******************************************************************

    NAME:	    CHARDEVQ_ENUM :: CallAPI

    SYNOPSIS:	    Invokes the NetCharDevQEnum() enumeration API.

    ENTRY:	    ppbBuffer		- Pointer to a pointer to the
					  enumeration buffer.

		    pcEntriesRead	- Will receive the number of
		    		  	  entries read from the API.

    EXIT:	    The enumeration API is invoked.

    RETURNS:	    APIERR		- Any errors encountered.

    NOTES:

    HISTORY:
	KeithMo	    28-Jul-1991	    Created.
	KeithMo	    12-Aug-1991	    Code review cleanup.

********************************************************************/
APIERR CHARDEVQ_ENUM :: CallAPI( BYTE ** ppbBuffer,
			 	 UINT  * pcEntriesRead )
{
    return ::MNetCharDevQEnum( QueryServer(),
			       _nlsUserName.QueryPch(),
    			       QueryInfoLevel(),
			       ppbBuffer,
			       pcEntriesRead );

}   // CHARDEVQ_ENUM :: CallAPI


//
//  CHARDEVQ1_ENUM methods
//

/*******************************************************************

    NAME:	    CHARDEVQ1_ENUM :: CHARDEVQ1_ENUM

    SYNOPSIS:	    CHARDEVQ1_ENUM class constructor.

    ENTRY:	    pszServerName	- The name of the server to execute
    				  	  the enumeration on.  NULL =
				  	  execute locally.

		    pszUserName		- The name of a user to enumerate
		    			  character queue's for.

    EXIT:	    The object is constructed.

    RETURNS:	    No return value.

    NOTES:

    HISTORY:
	KeithMo	    28-Jul-1991	    Created.
	KeithMo	    12-Aug-1991	    Code review cleanup.

********************************************************************/
CHARDEVQ1_ENUM :: CHARDEVQ1_ENUM( const TCHAR * pszServerName,
				  const TCHAR * pszUserName )
  : CHARDEVQ_ENUM( pszServerName, pszUserName, 1 )
{
    //
    //	This space intentionally left blank.
    //

}   // CHARDEVQ1_ENUM :: CHARDEVQ1_ENUM


/*******************************************************************

    NAME:	CHARDEVQ1_ENUM_OBJ :: SetBufferPtr

    SYNOPSIS:	Saves the buffer pointer for this enumeration object.

    ENTRY:	pBuffer			- Pointer to the new buffer.

    EXIT:	The pointer has been saved.

    NOTES:	Will eventually handle OemToAnsi conversions.

    HISTORY:
	KeithMo	    09-Oct-1991	    Created.

********************************************************************/
VOID CHARDEVQ1_ENUM_OBJ :: SetBufferPtr( const struct chardevQ_info_1 * pBuffer )
{
    ENUM_OBJ_BASE :: SetBufferPtr( (const BYTE *)pBuffer );

}   // CHARDEVQ1_ENUM_OBJ :: SetBufferPtr


DEFINE_LM_ENUM_ITER_OF( CHARDEVQ1, struct chardevQ_info_1 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmoenum\lmoent.cxx ===
/*****************************************************************/
/**                  Microsoft Windows NT                       **/
/**            Copyright(c) Microsoft Corp., 1992               **/
/*****************************************************************/

/*
 *  HISTORY:
 *      JonN    13-Mar-1992     Split from lmoeusr.cxx
 *      keithmo 16-mar-1992     Added UNICODE -> ASCII conversion hack.
 *      JonN    01-Apr-1992     NT enumerator CR changes, attended by
 *                              JimH, JohnL, KeithMo, JonN, ThomasPa
 *	JonN    27-Jan-1994	Added group enumerator
 *
 */

#include "pchlmobj.hxx"

//
//  These defines are used in the default QueryCountPreferences().
//  The manifest TOTAL_BYTES_REQUESTED gives the number of BYTEs we request
//  from the server on each call to the account enumeration API.  The
//  manifest TOTAL_ENTRIES_REQUESTED gives the number of entries we request
//  from the server on each call to the account enumeration API.
//

#define TOTAL_BYTES_REQUESTED   0x0001FFFF
#define TOTAL_ENTRIES_REQUESTED 1000


//
// The following defines are used in the slow mode timing heuristics in
// QueryCountPreferences2.  A timer determines how long it takes
// to read in each batch of accounts.  If this time is less
// that READ_MORE_MSEC, we double the number of bytes requested on the
// next call.  If it is more than READ_LESS_MSEC, we halve it.
//
// We only manipulate the BytesRequested, and we leave CountRequested
// at a fixed (large) value.
//

#define PREF_INITIAL_BYTES  0x07FFF /*  64K */
#define PREF_MIN_BYTES      0x003FF /*   2K */
#define PREF_MAX_BYTES      0x7FFFF /* 512K */

#define PREF_COUNT          2000

#define PREF_READ_MORE_MSEC 3000
#define PREF_READ_LESS_MSEC 8000



#ifndef UNICODE // HACK

//
//  This is a simple hack to map a UNICODE string to an
//  ASCII string _in_place_.  Note that after this function
//  completes, punicode will no longer be a "real" UNICODE_STRING.
//  Its Buffer field will point to a NULL terminated string of
//  chars (*not* TCHARs or WCHARs) and its Length field will be
//  adjusted accordingly.
//
//  Note that this function is only necessary for non UNICODE builds.
//

VOID MapUnicodeToAsciiPoorly( PUNICODE_STRING punicode )
{
    char   * psz = (char *)punicode->Buffer;
    WCHAR  * pwc = punicode->Buffer;
    USHORT   cb  = punicode->Length / sizeof(WCHAR);

    punicode->Length = cb;

    if( cb == 0 )
    {
        return;
    }

    while( ( cb-- > 0 ) && ( *pwc != L'\0' ) )  // No TCH(), ALWAYS UNICODE!
    {
        *psz++ = (char)*pwc++;
    }

    *psz = '\0';                                // No TCH(), ALWAYS ASCII!

}   // MapUnicodeToAsciiPoorly

#endif  // UNICODE hack



/****************************   NT_ACCOUNT_ENUM  **************************/


/*******************************************************************

    NAME:       NT_ACCOUNT_ENUM::NT_ACCOUNT_ENUM

    SYNOPSIS:   Account enumeration constructor.  These accounts may
                be either user accounts (NT_USER_ENUM) or machine
                accounts (NT_MACHINE_ENUM).

    ENTRY:      psamdomain              - A SAM_DOMAIN representing the
                                          target domain.

                dinfo                   - Either DomainDisplayUser,
                                          DomainDisplayMachine or DomainDisplayGroup.

                fKeepBuffers            - If TRUE then LM_RESUME_ENUM
                                          will keep a list of all buffers
                                          created by CallAPI.

    HISTORY:
        jonn    30-Jan-1992     Templated from USER_ENUM

********************************************************************/
NT_ACCOUNT_ENUM::NT_ACCOUNT_ENUM( const SAM_DOMAIN * psamdomain,
                                  enum _DOMAIN_DISPLAY_INFORMATION dinfo,
                                  BOOL fKeepBuffers  )
  : LM_RESUME_ENUM( (UINT)dinfo, fKeepBuffers ),
    _psamdomain( psamdomain ),
    _ulIndex( 0 ),
    _nCalls( 0 ),
    _msTimeLastCall( 0 ),
    _cEntriesRequested( TOTAL_ENTRIES_REQUESTED ),
    _cbBytesRequested( TOTAL_BYTES_REQUESTED )
{
    ASSERT( (psamdomain != NULL) && (psamdomain->QueryError() == NERR_Success) );

    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

}  // NT_ACCOUNT_ENUM::NT_ACCOUNT_ENUM


/*******************************************************************

    NAME:           NT_ACCOUNT_ENUM :: ~NT_ACCOUNT_ENUM

    SYNOPSIS:       Account (user or machine) enumeration destructor.

    HISTORY:
        JonN        29-Mar-1992 Created
        KeithMo     10-Sep-1992 Added NukeBuffers().

********************************************************************/
NT_ACCOUNT_ENUM :: ~NT_ACCOUNT_ENUM()
{
    NukeBuffers();

    _psamdomain = NULL;
    _ulIndex = 0;
    _nCalls = 0;
    _msTimeLastCall = 0;
    _cEntriesRequested = 0;
    _cbBytesRequested = 0;

}   // NT_ACCOUNT_ENUM :: ~NT_ACCOUNT_ENUM()


/*******************************************************************

    NAME:           NT_ACCOUNT_ENUM :: FreeBuffer

    SYNOPSIS:       Frees the buffer _pBuffer.

    RETURNS:        No return value.

    NOTE:           Some code relies on the pointer being reset to NULL.

    HISTORY:
        JonN        31-Jan-1992 Created
        JonN        03-Jun-1996 Must reset pointer to 0

********************************************************************/

VOID NT_ACCOUNT_ENUM :: FreeBuffer( BYTE ** ppbBuffer )
{

    UNREFERENCED( this );

    REQUIRE( ::SamFreeMemory( *ppbBuffer ) == STATUS_SUCCESS );

    *ppbBuffer = NULL;


}   // NT_ACCOUNT_ENUM :: FreeBuffer


/*******************************************************************

    NAME:       NT_ACCOUNT_ENUM::CallAPI

    SYNOPSIS:   Call API to do account enumeration

    ENTRY:      fRestartEnum            - If TRUE, then the enumeration
                                          handle should be reset to its
                                          starting position before invoking
                                          the API.

                ppbBuffer               - ptr to ptr to buffer returned

                pcEntriesRead           - variable to store entry count

    EXIT:       LANMAN error code

    HISTORY:
        jonn    30-Jan-1992     Templated from USER_ENUM

********************************************************************/
APIERR NT_ACCOUNT_ENUM :: CallAPI( BOOL    fRestartEnum,
                                   BYTE ** ppbBuffer,
                                   UINT  * pcEntriesRead )
{
    ASSERT( (ppbBuffer != NULL) && (pcEntriesRead != NULL) );

    ULONG ulTotalAvailable;
    ULONG cbTotalReturned;

    if( fRestartEnum )
    {
        _ulIndex = 0;
    }

    APIERR err = QueryCountPreferences( &_cEntriesRequested,
                                        &_cbBytesRequested,
                                        _nCalls++,
                                        _cEntriesRequested,
                                        _cbBytesRequested,
                                        _msTimeLastCall );
    if (err != NERR_Success)
        return err;

    DWORD start = ::GetTickCount();
    NTSTATUS ntstatus = ::SamQueryDisplayInformation(
                                _psamdomain->QueryHandle(),
                                (_DOMAIN_DISPLAY_INFORMATION)QueryInfoLevel(),
                                _ulIndex,
                                _cEntriesRequested,
                                _cbBytesRequested,
                                &ulTotalAvailable,
                                &cbTotalReturned,
                                (PULONG)pcEntriesRead,
                                (PVOID *)ppbBuffer );
    DWORD finish = ::GetTickCount();
    _msTimeLastCall = finish - start;

    err = ERRMAP::MapNTStatus( ntstatus );

    if( ( err == NERR_Success ) || ( err == ERROR_MORE_DATA ) )
    {
        TRACEEOL( "NT_ACCOUNT_ENUM: " << _cEntriesRequested
                 << " (" << *pcEntriesRead
                 << ") entries and " << _cbBytesRequested
                 << " (" << cbTotalReturned
                 << ") bytes took " << _msTimeLastCall
                 << " msec" );

        //
        //  If the call was successful, we must update
        //  our API index so we can get the next batch
        //  of data.
        //

        // 379697: Incorrect usage of SamQueryDisplayInformation() in User Browser and net\ui\common\src
        // JonN 8/5/99

        // set starting index for next iteration to index of last returned entry
        // _ulIndex += *pcEntriesRead;
        if (0 >= *pcEntriesRead)
        {
            ASSERT( err == NERR_Success ); // infinite loop?
        }
        else
        {
            switch ( (_DOMAIN_DISPLAY_INFORMATION)QueryInfoLevel() )
            {
            case DomainDisplayUser:
                _ulIndex = ((DOMAIN_DISPLAY_USER*)(*ppbBuffer))[(*pcEntriesRead)-1].Index;
                break;
            case DomainDisplayMachine:
                _ulIndex = ((DOMAIN_DISPLAY_MACHINE*)(*ppbBuffer))[(*pcEntriesRead)-1].Index;
                break;
            case DomainDisplayGroup:
                _ulIndex = ((DOMAIN_DISPLAY_GROUP*)(*ppbBuffer))[(*pcEntriesRead)-1].Index;
                break;
            default:
                ASSERT(FALSE);
                err = E_FAIL;
            }
        }

#ifndef UNICODE

        //
        //  We must also map the UNICODE strings to ASCII if
        //  this is NOT a UNICODE build.
        //

        FixupUnicodeStrings( *ppbBuffer, *pcEntriesRead );

#endif  // UNICODE
    } // if( ( err == NERR_Success ) || ( err == ERROR_MORE_DATA ) )

    ASSERT( err != NERR_BufTooSmall );
    ASSERT(   (*ppbBuffer != NULL)                      \
           == (   ( err == NERR_Success )               \
               || ( err == ERROR_MORE_DATA )            \
               || ( err == NERR_BufTooSmall ) ) );

    return err;

}  // NT_ACCOUNT_ENUM::CallAPI


/*******************************************************************

    NAME:       NT_ACCOUNT_ENUM::QueryCountPreferences

    SYNOPSIS:   Determines how many entries/bytes to request

    EXIT:       LANMAN error code

    HISTORY:
        jonn    23-Mar-1993     Created

********************************************************************/

APIERR NT_ACCOUNT_ENUM::QueryCountPreferences(
        ULONG * pcEntriesRequested,  // how many entries to request on this call
        ULONG * pcbBytesRequested,   // how many bytes to request on this call
        UINT nNthCall,               // 0 just before 1st call, 1 before 2nd call, etc.
        ULONG cLastEntriesRequested, // how many entries requested on last call
                                     //    ignore for nNthCall==0
        ULONG cbLastBytesRequested,  // how many bytes requested on last call
                                     //    ignore for nNthCall==0
        ULONG msTimeLastCall )       // how many milliseconds last call took
{
    UNREFERENCED( nNthCall );
    UNREFERENCED( cLastEntriesRequested );
    UNREFERENCED( cbLastBytesRequested );
    UNREFERENCED( msTimeLastCall );

    *pcEntriesRequested = TOTAL_ENTRIES_REQUESTED;
    *pcbBytesRequested  = TOTAL_BYTES_REQUESTED;

    return NERR_Success;
}


APIERR NT_ACCOUNT_ENUM::QueryCountPreferences2(
        ULONG * pcEntriesRequested,  // how many entries to request on this call
        ULONG * pcbBytesRequested,   // how many bytes to request on this call
        UINT nNthCall,               // 0 just before 1st call, 1 before 2nd call, etc.
        ULONG cLastEntriesRequested, // how many entries requested on last call
                                     //    ignore for nNthCall==0
        ULONG cbLastBytesRequested,  // how many bytes requested on last call
                                     //    ignore for nNthCall==0
        ULONG msTimeLastCall )       // how many milliseconds last call took
{
    ASSERT( pcEntriesRequested != NULL && pcbBytesRequested != NULL );

    *pcEntriesRequested = PREF_COUNT;

    if (nNthCall == 0)
    {
        *pcbBytesRequested = PREF_INITIAL_BYTES;
    }
    else if ( msTimeLastCall < PREF_READ_MORE_MSEC )
    {
        *pcbBytesRequested = cbLastBytesRequested * 2;
    }
    else if ( msTimeLastCall > PREF_READ_LESS_MSEC )
    {
        *pcbBytesRequested = cbLastBytesRequested / 2;
    }
    else
    {
        *pcbBytesRequested = cbLastBytesRequested;
    }

    if ( *pcbBytesRequested < PREF_MIN_BYTES )
    {
        *pcbBytesRequested = PREF_MIN_BYTES;
    }
    else if ( *pcbBytesRequested > PREF_MAX_BYTES )
    {
        *pcbBytesRequested = PREF_MAX_BYTES;
    }

    return NERR_Success;
}


/*****************************  NT_USER_ENUM  ******************************/


/*******************************************************************

    NAME:       NT_USER_ENUM::NT_USER_ENUM

    SYNOPSIS:   Constructor for NT user enumeration

    ENTRY:      psamHandle -    domain or server to execute on

    HISTORY:
        jonn    30-Jan-1992     Templated from USER_ENUM
        jonn    13-Mar-1992     Changed parameters

********************************************************************/
NT_USER_ENUM::NT_USER_ENUM( const SAM_DOMAIN * psamdomain )
  : NT_ACCOUNT_ENUM( psamdomain, DomainDisplayUser )
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

}  // NT_USER_ENUM::NT_USER_ENUM


/**********************************************************\

    NAME:       NT_USER_ENUM::~NT_USER_ENUM

    SYNOPSIS:   User enumeration destructor

    HISTORY:
        jonn    29-Mar-1992     Created

\**********************************************************/

NT_USER_ENUM::~NT_USER_ENUM()
{

    //
    //  This space intentionally left blank.
    //

}  // NT_USER_ENUM::~NT_USER_ENUM


#ifndef UNICODE

/*******************************************************************

    NAME:       NT_USER_ENUM :: FixupUnicodeStrings

    SYNOPSIS:   Map all UNICODE strings to ASCII _in_place_.

    ENTRY:      pbBuffer                - Points to the enumeration buffer
                                          returned by CallAPI.

                cEntries                - The number of entries in the
                                          enumeration buffer.

    HISTORY:
        KeithMo 30-Mar-1992     Created.

********************************************************************/
VOID NT_USER_ENUM :: FixupUnicodeStrings( BYTE * pbBuffer,
                                          UINT   cEntries )
{
    return;

}  // NT_USER_ENUM :: FixupUnicodeStrings

#endif  // UNICODE


DEFINE_LM_RESUME_ENUM_ITER_OF( NT_USER, DOMAIN_DISPLAY_USER );



//
//  NT_MACHINE_ENUM methods.
//

/*******************************************************************

    NAME:       NT_MACHINE_ENUM :: NT_MACHINE_ENUM

    SYNOPSIS:   Constructor for NT machine enumeration

    ENTRY:      psamHandle -    domain or server to execute on

    HISTORY:
        KeithMo 16-Mar-1992     Created for the Server Manager.

********************************************************************/
NT_MACHINE_ENUM :: NT_MACHINE_ENUM( const SAM_DOMAIN * psamdomain )
  : NT_ACCOUNT_ENUM( psamdomain, DomainDisplayMachine, TRUE )
{

    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

}  // NT_MACHINE_ENUM :: NT_MACHINE_ENUM


/**********************************************************\

    NAME:       NT_MACHINE_ENUM::~NT_MACHINE_ENUM

    SYNOPSIS:   Machine enumeration destructor

    HISTORY:
        jonn    29-Mar-1992     Created

\**********************************************************/

NT_MACHINE_ENUM::~NT_MACHINE_ENUM()
{

    //
    //  This space intentionally left blank.
    //

}  // NT_MACHINE_ENUM::~NT_MACHINE_ENUM


#ifndef UNICODE

/*******************************************************************

    NAME:       NT_MACHINE_ENUM :: FixupUnicodeStrings

    SYNOPSIS:   Map all UNICODE strings to ASCII _in_place_.

    ENTRY:      pbBuffer                - Points to the enumeration buffer
                                          returned by CallAPI.

                cEntries                - The number of entries in the
                                          enumeration buffer.

    HISTORY:
        KeithMo 30-Mar-1992     Created.

********************************************************************/
VOID NT_MACHINE_ENUM :: FixupUnicodeStrings( BYTE * pbBuffer,
                                             UINT   cEntries )
{
    //
    //  Scan the returned structure, mapping the UNICODE strings
    //  to ASCII.
    //

    DOMAIN_DISPLAY_MACHINE * pMach = (DOMAIN_DISPLAY_MACHINE *)pbBuffer;

    while( cEntries-- )
    {
        MapUnicodeToAsciiPoorly( &(pMach->Machine) );
        MapUnicodeToAsciiPoorly( &(pMach->Comment) );

        pMach++;
    }

}  // NT_MACHINE_ENUM :: FixupUnicodeStrings

#endif  // UNICODE


DEFINE_LM_RESUME_ENUM_ITER_OF( NT_MACHINE, DOMAIN_DISPLAY_MACHINE );



//
//  NT_GROUP_ENUM methods.
//

/*******************************************************************

    NAME:       NT_GROUP_ENUM :: NT_GROUP_ENUM

    SYNOPSIS:   Constructor for NT group enumeration

    ENTRY:      psamHandle -    domain or server to execute on

    HISTORY:
        JonN        27-Jan-1994 Templated from NT_MACHINE_ENUM

********************************************************************/
NT_GROUP_ENUM :: NT_GROUP_ENUM( const SAM_DOMAIN * psamdomain )
  : NT_ACCOUNT_ENUM( psamdomain, DomainDisplayGroup, TRUE )
{

    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

}  // NT_GROUP_ENUM :: NT_GROUP_ENUM


/**********************************************************\

    NAME:       NT_GROUP_ENUM::~NT_GROUP_ENUM

    SYNOPSIS:   Group enumeration destructor

    HISTORY:
        JonN        27-Jan-1994 Templated from NT_MACHINE_ENUM

\**********************************************************/

NT_GROUP_ENUM::~NT_GROUP_ENUM()
{

    //
    //  This space intentionally left blank.
    //

}  // NT_GROUP_ENUM::~NT_GROUP_ENUM


#ifndef UNICODE

/*******************************************************************

    NAME:       NT_GROUP_ENUM :: FixupUnicodeStrings

    SYNOPSIS:   Map all UNICODE strings to ASCII _in_place_.

    ENTRY:      pbBuffer                - Points to the enumeration buffer
                                          returned by CallAPI.

                cEntries                - The number of entries in the
                                          enumeration buffer.

    HISTORY:
        JonN        27-Jan-1994 Templated from NT_MACHINE_ENUM

********************************************************************/
VOID NT_GROUP_ENUM :: FixupUnicodeStrings( BYTE * pbBuffer,
                                           UINT   cEntries )
{
    //
    //  Scan the returned structure, mapping the UNICODE strings
    //  to ASCII.
    //

    DOMAIN_DISPLAY_GROUP * pGrp = (DOMAIN_DISPLAY_GROUP *)pbBuffer;

    while( cEntries-- )
    {
        MapUnicodeToAsciiPoorly( &(pGrp->Group) );
        MapUnicodeToAsciiPoorly( &(pGrp->Comment) );

        pGrp++;
    }

}  // NT_GROUP_ENUM :: FixupUnicodeStrings

#endif  // UNICODE


DEFINE_LM_RESUME_ENUM_ITER_OF( NT_GROUP, DOMAIN_DISPLAY_GROUP );

// End of LMOENT.CXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmoenum\lmoeconn.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    lmoeconn.cxx
    This file contains the class definitions for the CONN_ENUM,
    CONN0_ENUM, CONN1_ENUM enumerator class and their associated
    iterator classes.

    CONN_ENUM is a base enumeration class intended to be subclassed for
    the desired info level.  CONN0_ENUM is an info level 0 enumerator,
    while CONN1_ENUM is an info level 1 enumerator.


    FILE HISTORY:
	KeithMo	    28-Jul-1991	    Created.
	KeithMo	    12-Aug-1991	    Code review cleanup.
	KeithMo	    07-Oct-1991	    Win32 Conversion.

*/

#include "pchlmobj.hxx"

//
//  CONN_ENUM methods
//

/*******************************************************************

    NAME:	    CONN_ENUM :: CONN_ENUM

    SYNOPSIS:	    CONN_ENUM class constructor.

    ENTRY:	    pszServerName	- The name of the server to execute
    				  	  the enumeration on.  NULL =
				  	  execute locally.

		    pszQualifier	- Determines the scope of the
		    		  	  enumeration.  May be either a
				  	  share name or a computer name.

		    usLevel		- The information level.

    EXIT:	    The object is constructed.

    RETURNS:	    No return value.

    NOTES:

    HISTORY:
	KeithMo	    28-Jul-1991	    Created.

********************************************************************/
CONN_ENUM :: CONN_ENUM( const TCHAR * pszServerName,
			const TCHAR * pszQualifier,
			UINT	     uLevel )
  : LOC_LM_ENUM( pszServerName, uLevel ),
    _nlsQualifier( pszQualifier )
{
    if( !_nlsQualifier )
    {
    	ReportError( _nlsQualifier.QueryError() );
    }

}   // CONN_ENUM :: CONN_ENUM


/*******************************************************************

    NAME:	    CONN_ENUM :: CallAPI

    SYNOPSIS:	    Invokes the NetConnectionEnum() enumeration API.

    ENTRY:	    ppbBuffer		- Pointer to a pointer to the
					  enumeration buffer.

		    pcEntriesRead	- Will receive the number of
		    		  	  entries read from the API.

    EXIT:	    The enumeration API is invoked.

    RETURNS:	    APIERR		- Any errors encountered.

    NOTES:

    HISTORY:
	KeithMo	    28-Jul-1991	    Created.
	KeithMo	    12-Aug-1991	    Code review cleanup.

********************************************************************/
APIERR CONN_ENUM :: CallAPI( BYTE ** ppbBuffer,
			     UINT  * pcEntriesRead )
{
    return ::MNetConnectionEnum( QueryServer(),
			         _nlsQualifier.QueryPch(),
    			         QueryInfoLevel(),
			         ppbBuffer,
			         pcEntriesRead );

}   // CONN_ENUM :: CallAPI


//
//  CONN0_ENUM methods
//

/*******************************************************************

    NAME:	    CONN0_ENUM :: CONN0_ENUM

    SYNOPSIS:	    CONN0_ENUM class constructor.

    ENTRY:	    pszServerName	- The name of the server to execute
    				  	  the enumeration on.  NULL =
				  	  execute locally.

		    pszQualifier	- Determines the scope of the
		    		  	  enumeration.  May be either a
				  	  share name or a computer name.

    EXIT:	    The object is constructed.

    RETURNS:	    No return value.

    NOTES:

    HISTORY:
	KeithMo	    28-Jul-1991	    Created.

********************************************************************/
CONN0_ENUM :: CONN0_ENUM( const TCHAR * pszServerName,
			  const TCHAR * pszQualifier )
  : CONN_ENUM( pszServerName, pszQualifier, 0 )
{
    //
    //	This space intentionally left blank.
    //

}   // CONN0_ENUM :: CONN0_ENUM


/*******************************************************************

    NAME:	CONN0_ENUM_OBJ :: SetBufferPtr

    SYNOPSIS:	Saves the buffer pointer for this enumeration object.

    ENTRY:	pBuffer			- Pointer to the new buffer.

    EXIT:	The pointer has been saved.

    NOTES:	Will eventually handle OemToAnsi conversions.

    HISTORY:
	KeithMo	    09-Oct-1991	    Created.

********************************************************************/
VOID CONN0_ENUM_OBJ :: SetBufferPtr( const struct connection_info_0 * pBuffer )
{
    ENUM_OBJ_BASE :: SetBufferPtr( (const BYTE *)pBuffer );

}   // CONN0_ENUM_OBJ :: SetBufferPtr


DEFINE_LM_ENUM_ITER_OF( CONN0, struct connection_info_0 );


//
//  CONN1_ENUM methods
//

/*******************************************************************

    NAME:	    CONN1_ENUM :: CONN1_ENUM

    SYNOPSIS:	    CONN1_ENUM class constructor.

    ENTRY:	    pszServerName	- The name of the server to execute
    				  	  the enumeration on.  NULL =
				  	  execute locally.

		    pszQualifier	- Determines the scope of the
		    		  	  enumeration.  May be either a
				  	  share name or a computer name.

    EXIT:	    The object is constructed.

    RETURNS:	    No return value.

    NOTES:

    HISTORY:
	KeithMo	    28-Jul-1991	    Created.

********************************************************************/
CONN1_ENUM :: CONN1_ENUM( const TCHAR * pszServerName,
			  const TCHAR * pszQualifier )
  : CONN_ENUM( pszServerName, pszQualifier, 1 )
{
    //
    //	This space intentionally left blank.
    //

}   // CONN1_ENUM :: CONN1_ENUM


/*******************************************************************

    NAME:	CONN1_ENUM_OBJ :: SetBufferPtr

    SYNOPSIS:	Saves the buffer pointer for this enumeration object.

    ENTRY:	pBuffer			- Pointer to the new buffer.

    EXIT:	The pointer has been saved.

    NOTES:	Will eventually handle OemToAnsi conversions.

    HISTORY:
	KeithMo	    09-Oct-1991	    Created.

********************************************************************/
VOID CONN1_ENUM_OBJ :: SetBufferPtr( const struct connection_info_1 * pBuffer )
{
    ENUM_OBJ_BASE :: SetBufferPtr( (const BYTE *)pBuffer );

}   // CONN1_ENUM_OBJ :: SetBufferPtr


DEFINE_LM_ENUM_ITER_OF( CONN1, struct connection_info_1 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmoenum\lmoedom.cxx ===
/*****************************************************************/
/**                  Microsoft LAN Manager                      **/
/**            Copyright(c) Microsoft Corp., 1991               **/
/*****************************************************************/

/*
 *  HISTORY:
 *      KeithMo     22-Jul-1992     Created.
 *
 */

#include "pchlmobj.hxx"

//
//  DOMAIN_ENUM methods.
//

/*******************************************************************

    NAME:       DOMAIN_ENUM :: DOMAIN_ENUM

    SYNOPSIS:   DOMAIN_ENUM class constructor.

    ENTRY:      pszServer               - Target server for the API.

                level                   - Info level (should be 100).

    HISTORY:
        KeithMo     22-Jul-1992     Created.

********************************************************************/
DOMAIN_ENUM :: DOMAIN_ENUM( const TCHAR * pszServer,
                            UINT          level )
  : LOC_LM_ENUM( pszServer, level )
{
    UIASSERT( level == 100 );   // currently only support infolevel 100

    //
    //  Ensure we constructed OK.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

}   // DOMAIN_ENUM :: DOMAIN_ENUM


/*******************************************************************

    NAME:       DOMAIN_ENUM :: CallAPI

    SYNOPSIS:   Invokes the enumeration API.

    ENTRY:      ppbBuffer               - Will receive a pointer to
                                          the enumeration buffer.

                pcEntriesRead           - Will receive the number of
                                          entries in the buffer.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     22-Jul-1992     Created.

********************************************************************/
APIERR DOMAIN_ENUM :: CallAPI( BYTE ** ppbBuffer,
                               UINT  * pcEntriesRead )
{
    UIASSERT( QueryInfoLevel() == 100 );    // currently only support level 100

    return ::MNetServerEnum( QueryServer(),
                             QueryInfoLevel(),
                             ppbBuffer,
                             pcEntriesRead,
                             SV_TYPE_DOMAIN_ENUM,
                             NULL );

}   // APIERR DOMAIN_ENUM :: CallAPI



//
//  DOMAIN0_ENUM methods.
//

/*******************************************************************

    NAME:       DOMAIN0_ENUM :: DOMAIN0_ENUM

    SYNOPSIS:   DOMAIN0_ENUM class constructor.

    ENTRY:      pszServer               - Target server for the API.

    HISTORY:
        KeithMo     22-Jul-1992     Created.

********************************************************************/
DOMAIN0_ENUM :: DOMAIN0_ENUM( const TCHAR * pszServer )
  : DOMAIN_ENUM( pszServer, 100 )
{
    //
    //  This space intentionally left blank.
    //

}   // DOMAIN0_ENUM :: DOMAIN0_ENUM


/*******************************************************************

    NAME:       DOMAIN0_ENUM :: Sort

    SYNOPSIS:   Sort the API buffer into ascending order.

    HISTORY:
        KeithMo     10-Feb-1993     Created.

********************************************************************/
VOID DOMAIN0_ENUM :: Sort( VOID )
{
    ::qsort( (void *)QueryPtr(),
             (size_t)QueryCount(),
             sizeof(SERVER_INFO_100),
             &DOMAIN0_ENUM::CompareDomains0 );

}   // DOMAIN0_ENUM :: Sort


/*******************************************************************

    NAME:       DOMAIN0_ENUM :: CompareDomains0

    SYNOPSIS:   This static method is called by the ::qsort() standard
                library function.  This method will compare two
                SERVER_INFO_100 structures.

    ENTRY:      p1                      - The "left" object.

                p2                      - The "right" object.

    RETURNS:    int                     - -1 if p1  < p2
                                           0 if p1 == p2
                                          +1 if p1  > p2

    HISTORY:
        KeithMo     10-Feb-1993     Created.

********************************************************************/
int __cdecl DOMAIN0_ENUM :: CompareDomains0( const void * p1,
                                              const void * p2 )
{
    SERVER_INFO_100 * psvi1 = (SERVER_INFO_100 *)p1;
    SERVER_INFO_100 * psvi2 = (SERVER_INFO_100 *)p2;

    return ::strcmpf( (TCHAR *)psvi1->sv100_name, (TCHAR *)psvi2->sv100_name );

}   // DOMAIN0_ENUM :: CompareDomains0


DEFINE_LM_ENUM_ITER_OF( DOMAIN0, SERVER_INFO_100 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmoenum\lmoefile.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    lmoefile.cxx
    This file contains the class definitions for the FILE3_ENUM and
    FILE3_ENUM_ITER classes.

    FILE3_ENUM is an enumeration class used to enumerate the open
    resources on a particular server.  FILE3_ENUM_ITER is an iterator
    used to iterate the open resources from the FILE3_ENUM class.


    FILE HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.
        KeithMo     13-Aug-1991 Cleanup.
        KeithMo     19-Aug-1991 Code review revisions (code review
                                attended by ChuckC, Hui-LiCh, JimH,
                                JonN, KevinL).
        KeithMo     07-Oct-1991 Win32 Conversion.
        JonN        30-Jan-1992 Split LOC_LM_RESUME_ENUM from LM_RESUME_ENUM

*/

#include "pchlmobj.hxx"

//
//  These are the buffer sizes used when growing the enumeration
//  buffer.  The buffer is initially SMALL_BUFFER_SIZE bytes long.
//  If this is insufficient for the enumeration, the buffer is
//  grown to LARGE_BUFFER_SIZE.
//

#define SMALL_BUFFER_SIZE       (  4 * 1024 )
#define LARGE_BUFFER_SIZE       ( 16 * 1024 )


/*******************************************************************

    NAME:           FILE_ENUM :: FILE_ENUM

    SYNOPSIS:       FILE_ENUM class constructor.

    ENTRY:          pszServerName   - The name of the server to execute
                                      the enumeration on.  NULL =
                                      execute locally.

                    pszBasePath     - The root directory for the
                                      enumeration.  NULL = enumerate all
                                      open files.

                    pszUserName     - The name of the user to enumerate
                                      the files for.  NULL = enumerate
                                      for all users.

                    usLevel         - The information level.

    EXIT:           The object is constructed.

    RETURNS:        No return value.

    NOTES:

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.
        KeithMo     13-Aug-1991 Cleanup.

********************************************************************/
FILE_ENUM :: FILE_ENUM( const TCHAR * pszServerName,
                        const TCHAR * pszBasePath,
                        const TCHAR * pszUserName,
                        UINT         uLevel )
  : LOC_LM_RESUME_ENUM( pszServerName, uLevel ),
    _nlsBasePath( pszBasePath ),
    _nlsUserName( pszUserName ),
    _fBigBuffer( FALSE )
{
    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_nlsBasePath )
    {
        ReportError( _nlsBasePath.QueryError() );
        return;
    }

    if( !_nlsUserName )
    {
        ReportError( _nlsUserName.QueryError() );
        return;
    }

}   // FILE_ENUM :: FILE_ENUM


/*******************************************************************

    NAME:           FILE_ENUM :: ~FILE_ENUM

    SYNOPSIS:       FILE_ENUM class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     11-Sep-1992 Created.

********************************************************************/
FILE_ENUM :: ~FILE_ENUM( VOID )
{
    NukeBuffers();

}   // FILE_ENUM :: ~FILE_ENUM


/*******************************************************************

    NAME:           FILE_ENUM :: CallAPI

    SYNOPSIS:       Invokes the enumeration API (NetFileEnum2()).

    ENTRY:          fRestartEnum        - Indicates whether to start at the
                                          beginning.  The first call to
                                          CallAPI will always pass TRUE.

                    ppbBuffer           - Pointer to a pointer to the
                                          enumeration buffer.

                    pcEntriesRead       - Will receive the number of
                                          entries read from the API.

    EXIT:           The enumeration API has been invoked.

    RETURNS:        APIERR          - Any errors encountered.

    NOTES:

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.
        KeithMo     13-Aug-1991 Cleanup.

********************************************************************/
APIERR FILE_ENUM :: CallAPI( BOOL    fRestartEnum,
                             BYTE ** ppbBuffer,
                             UINT  * pcEntriesRead )
{

    //
    //  Restart the enumeration if fRestartEnum is TRUE
    //

    if ( fRestartEnum )
    {
        FRK_INIT( _frk );
    }

    //
    //  Most LanMan API treat a NULL pointer the same as a
    //  NULL string (pointer to '\0').  Unfortunately,
    //  NetFileEnum2() does not work this way.  If all files
    //  opened by all users are to be enumerated, then
    //  NULLs must be passed for the base path and user name.
    //  However, a NULL passed to the NLS_STR constructor
    //  will result in NLS_STR::QueryPch() returning an
    //  empty string.
    //
    //  To get around this behaviour, we must explicitly
    //  convert empty strings to NULL pointers before
    //  passing them to NetFileEnum2().
    //

    const TCHAR * pszBasePath = _nlsBasePath.QueryPch();
    const TCHAR * pszUserName = _nlsUserName.QueryPch();

    UINT cTotalAvailable;

    APIERR err = ::MNetFileEnum( QueryServer(),
                                 ( *pszBasePath == TCH('\0') ) ? NULL : pszBasePath,
                                 ( *pszUserName == TCH('\0') ) ? NULL : pszUserName,
                                 QueryInfoLevel(),
                                 ppbBuffer,
                                 (_fBigBuffer)  ? LARGE_BUFFER_SIZE
                                                : SMALL_BUFFER_SIZE,
                                 pcEntriesRead,
                                 &cTotalAvailable,
                                 &_frk );

    //
    //  At first, the enumeration API is attempted with
    //  a small buffer.  If the buffer is too small, we
    //  pass this data back to the caller, then use a
    //  larger buffer in future.
    //

    switch (err)
    {
    case NERR_BufTooSmall:
    case ERROR_MORE_DATA:

        _fBigBuffer = TRUE;
        // fall through

    case NERR_Success:
    default:
        break;
    }

    return err;

}   // FILE_ENUM :: CallAPI


/*******************************************************************

    NAME:           FILE_ENUM :: FreeBuffer

    SYNOPSIS:       Frees the API buffer.

    ENTRY:          ppbBuffer           - Points to a pointer to the
                                          enumeration buffer.

    HISTORY:
        KeithMo     31-Mar-1992 Created.

********************************************************************/
VOID FILE_ENUM :: FreeBuffer( BYTE ** ppbBuffer )
{
    UIASSERT( ppbBuffer != NULL );

    ::MNetApiBufferFree( ppbBuffer );

}   // FILE_ENUM :: FreeBuffer


/*******************************************************************

    NAME:           FILE2_ENUM :: FILE2_ENUM

    SYNOPSIS:       FILE2_ENUM class constructor.

    ENTRY:          pszServerName   - The name of the server to execute
                                      the enumeration on.  NULL =
                                      execute locally.

                    pszBasePath     - The root directory for the
                                      enumeration.  NULL = enumerate all
                                      open files.

                    pszUserName     - The name of the user to enumerate
                                      the files for.  NULL = enumerate
                                      for all users.

    EXIT:           The object is constructed.

    RETURNS:        No return value.

    NOTES:

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.
        KeithMo     13-Aug-1991 Cleanup.

********************************************************************/
FILE2_ENUM :: FILE2_ENUM( const TCHAR * pszServerName,
                          const TCHAR * pszBasePath,
                          const TCHAR * pszUserName )
  : FILE_ENUM( pszServerName, pszBasePath, pszUserName, 2 )
{
    //
    //  This space intentionally left blank.
    //

}   // FILE2_ENUM :: FILE2_ENUM


/*******************************************************************

    NAME:       FILE2_ENUM_OBJ :: SetBufferPtr

    SYNOPSIS:   Saves the buffer pointer for this enumeration object.

    ENTRY:      pBuffer                 - Pointer to the new buffer.

    EXIT:       The pointer has been saved.

    NOTES:      Will eventually handle OemToAnsi conversions.

    HISTORY:
        KeithMo     09-Oct-1991     Created.

********************************************************************/
VOID FILE2_ENUM_OBJ :: SetBufferPtr( const struct file_info_2 * pBuffer )
{
    ENUM_OBJ_BASE :: SetBufferPtr( (const BYTE *)pBuffer );

}   // FILE2_ENUM_OBJ :: SetBufferPtr


DEFINE_LM_RESUME_ENUM_ITER_OF( FILE2, struct file_info_2 );


/*******************************************************************

    NAME:           FILE3_ENUM :: FILE3_ENUM

    SYNOPSIS:       FILE3_ENUM class constructor.

    ENTRY:          pszServerName   - The name of the server to execute
                                      the enumeration on.  NULL =
                                      execute locally.

                    pszBasePath     - The root directory for the
                                      enumeration.  NULL = enumerate all
                                      open files.

                    pszUserName     - The name of the user to enumerate
                                      the files for.  NULL = enumerate
                                      for all users.

    EXIT:           The object is constructed.

    RETURNS:        No return value.

    NOTES:

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.
        KeithMo     13-Aug-1991 Cleanup.

********************************************************************/
FILE3_ENUM :: FILE3_ENUM( const TCHAR * pszServerName,
                          const TCHAR * pszBasePath,
                          const TCHAR * pszUserName )
  : FILE_ENUM( pszServerName, pszBasePath, pszUserName, 3 )
{
    //
    //  This space intentionally left blank.
    //

}   // FILE3_ENUM :: FILE3_ENUM


/*******************************************************************

    NAME:       FILE3_ENUM_OBJ :: SetBufferPtr

    SYNOPSIS:   Saves the buffer pointer for this enumeration object.

    ENTRY:      pBuffer                 - Pointer to the new buffer.

    EXIT:       The pointer has been saved.

    NOTES:      Will eventually handle OemToAnsi conversions.

    HISTORY:
        KeithMo     09-Oct-1991     Created.

********************************************************************/
VOID FILE3_ENUM_OBJ :: SetBufferPtr( const struct file_info_3 * pBuffer )
{
    ENUM_OBJ_BASE :: SetBufferPtr( (const BYTE *)pBuffer );

}   // FILE3_ENUM_OBJ :: SetBufferPtr


DEFINE_LM_RESUME_ENUM_ITER_OF( FILE3, struct file_info_3 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmoenum\lmoenum.cxx ===
/*****************************************************************/
/**                  Microsoft LAN Manager                      **/
/**            Copyright(c) Microsoft Corp., 1991               **/
/*****************************************************************/

/*
 *  HISTORY:
 *      RustanL     03-Jan-1991     Wrote initial implementation in shell\util
 *      RustanL     10-Jan-1991     Added iterators, simplified usage and
 *                                  the adding of subclasses.  Moved into
 *                                  LMOBJ.
 *      beng        11-Feb-1991     Uses lmui.hxx
 *      Chuckc      23-Mar-1991     code rev cleanup
 *      gregj       23-May-1991     Added LOCATION support.
 *      rustanl     18-Jul-1991     Added ( const LOCATION & ) constructor
 *      rustanl     19-Jul-1991     Inherit from BASE; Removed ValidateName
 *      rustanl     20-Aug-1991     Changed QuerySize to QueryCount
 *      rustanl     21-Aug-1991     Introduced the ENUM_CALLER class
 *      KeithMo     07-Oct-1991     Win32 Conversion.
 *      Thomaspa    21-Feb-1992     Split LOC_LM_ENUM from LM_ENUM
 *
 */

#include "pchlmobj.hxx"

/******************************** ENUM_CALLER ****************************/


/*******************************************************************

    NAME:       ENUM_CALLER::ENUM_CALLER

    SYNOPSIS:   ENUM_CALLER constructor

    NOTES:      Since this class can't inherit from BASE (since some
                of its subclasses already necessarily do from elsewhere),
                this constructor must guarantee to succeed.

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

ENUM_CALLER::ENUM_CALLER()
  : _cEntriesRead( 0 )
{
    // nothing else to do

}  // ENUM_CALLER::ENUM_CALLER


/*******************************************************************

    NAME:       ENUM_CALLER::W_GetInfo

    SYNOPSIS:   Call the Enum API

    RETURN:     An error code, which is NERR_Success on success.

    HISTORY:
        rustanl     21-Aug-1991     Created from LM_ENUM::GetInfo, which
                                    now calls this method as a worker
                                    function.

********************************************************************/

APIERR ENUM_CALLER::W_GetInfo()
{
    BYTE * pBuffer = NULL;
    APIERR err = CallAPI( &pBuffer,
                          &_cEntriesRead );

    if( pBuffer != NULL )
    {
        EC_SetBufferPtr( pBuffer );
    }

    return err;

}  // ENUM_CALLER::W_GetInfo


/********************************** LM_ENUM ******************************/


/**********************************************************\

   NAME:       LM_ENUM::LM_ENUM

   SYNOPSIS:   lm_enum constructor

   ENTRY:
      pszServer Pointer to server name.  May be NULL.
      uLevel    Information level

   EXIT:

   NOTES:

   HISTORY:
      RustanL     03-Jan-1991     Wrote initial implementation in shell\util
      gregj       23-May-1991     Added LOCATION support
      rustanl     18-Jul-1991     Added ( const LOCATION & ) constructor
      rustanl     19-Jul-1991     Added BASE support
      thomaspa    21-Feb-1992     Moved LOCATION to LOC_LM_ENUM

\**********************************************************/

LM_ENUM::LM_ENUM( UINT uLevel )
  : _pBuffer( NULL ),
    _uLevel( uLevel ),
    _cIterRef( 0 )
{
    if ( QueryError() != NERR_Success )
        return;

}  // LM_ENUM::LM_ENUM


/**********************************************************\

   NAME:       LM_ENUM::~LM_ENUM

   SYNOPSIS:   destructor of lm_enum

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
      RustanL     03-Jan-1991     Wrote initial implementation in shell\util

\**********************************************************/

LM_ENUM::~LM_ENUM()
{
    UIASSERT( _cIterRef == 0 );

    ::MNetApiBufferFree( &_pBuffer );

}  // LM_ENUM::~LM_ENUM


/*******************************************************************

    NAME:       LM_ENUM::EC_QueryBufferPtr

    SYNOPSIS:   Returns the pointer to the buffer used in the API
                calls

    RETURNS:    Pointer to said buffer area

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

BYTE * LM_ENUM::EC_QueryBufferPtr() const
{
    return _pBuffer;

}  // LM_ENUM::EC_QueryBufferPtr


/*******************************************************************

    NAME:       LM_ENUM::EC_SetBufferPtr

    SYNOPSIS:   Sets the current buffer pointer.

    RETURNS:    APIERR (in this implementation, always NERR_Success).

    HISTORY:
        KeithMo     15-Oct-1991     Created

********************************************************************/

APIERR LM_ENUM::EC_SetBufferPtr( BYTE * pBuffer )
{
    ::MNetApiBufferFree( &_pBuffer );
    _pBuffer = pBuffer;

    return NERR_Success;

}  // LM_ENUM::EC_SetBufferPtr



/*********************************************************************

    NAME:       LM_ENUM::GetInfo

    SYNOPSIS:   Call the Enum API.

    ENTRY:      NONE

    RETURN:     An error code, which is NERR_Success on success.

    NOTES:      This method is guaranteed to call QueryError, and return
                any error.

    HISTORY:
        RustanL     03-Jan-1991     Initial implementation in shell\util
        rustanl     14-Jun-1991     Added LOCATION::GetInfo from
                                    LM_ENUM::QueryServer
        beng        15-Jul-1991     BUFFER::Resize changed return type
        rustanl     20-Aug-1991     Fixed cast error
        rustanl     21-Aug-1991     Moved meat to ENUM_CALLER::W_GetInfo

**********************************************************************/

APIERR LM_ENUM::GetInfo( VOID )
{
    UIASSERT( _cIterRef == 0 );

    APIERR err = QueryError();
    if ( err != NERR_Success)
        return err;

    return W_GetInfo();

}  // LM_ENUM::GetInfo


/**********************************************************\

   NAME:       LM_ENUM::_RegisterIter

   SYNOPSIS:   registerIter

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
      RustanL     03-Jan-1991     Wrote initial implementation in shell\util

\**********************************************************/

VOID LM_ENUM::_RegisterIter( VOID )
{
#if defined(DEBUG)

    _cIterRef++;

#endif // DEBUG
}  // LM_ENUM::RegisterIter


/**********************************************************\

   NAME:       LM_ENUM::_DeregisterIter

   SYNOPSIS:   deisgter iter

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
      RustanL     03-Jan-1991     Wrote initial implementation in shell\util

\**********************************************************/

VOID LM_ENUM::_DeregisterIter( VOID )
{
#if defined(DEBUG)

    if ( _cIterRef == 0 )
    {
        UIASSERT( !SZ("Negative reference count") );
    }
    else
    {
        _cIterRef--;
    }

#endif // DEBUG
}  // LM_ENUM::DeregisterIter


/******************************* LOC_LM_ENUM *****************************/

/**********************************************************\

   NAME:       LOC_LM_ENUM::LOC_LM_ENUM

   SYNOPSIS:   lm_enum constructor

   ENTRY:
      pszServer Pointer to server name.  May be NULL.
      uLevel    Information level

   EXIT:

   NOTES:

   HISTORY:
        Thomaspa        21-Feb-1992     Split from LM_ENUM

\**********************************************************/

LOC_LM_ENUM::LOC_LM_ENUM( const TCHAR * pszServer, UINT uLevel )
  : LM_ENUM( uLevel ),
    _loc( pszServer )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err = _loc.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}  // LOC_LM_ENUM::LOC_LM_ENUM


LOC_LM_ENUM::LOC_LM_ENUM( LOCATION_TYPE locType, UINT uLevel )
  : LM_ENUM( uLevel ),
    _loc( locType )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err = _loc.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}  // LOC_LM_ENUM::LOC_LM_ENUM


LOC_LM_ENUM::LOC_LM_ENUM( const LOCATION & loc, UINT uLevel )
  : LM_ENUM( uLevel ),
    _loc( loc )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err = _loc.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}  // LOC_LM_ENUM::LOC_LM_ENUM

/**********************************************************\

   NAME:       LOC_LM_ENUM::~LOC_LM_ENUM

   SYNOPSIS:   destructor of loc_lm_enum

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
      Thomaspa     22-Feb-1992     created

\**********************************************************/

LOC_LM_ENUM::~LOC_LM_ENUM()
{
        // do nothing
}


/**********************************************************\

   NAME:       LOC_LM_ENUM::QueryServer

   SYNOPSIS:   query server

   HISTORY:
      RustanL     03-Jan-1991     Wrote initial implementation in shell\util
      gregj       23-May-1991     Added LOCATION support
      rustanl     14-Jun-1991     Moved LOCATION::GetInfo call to
                                  LM_ENUM::GetInfo
      Thomaspa    21-Feb-1992     Split from LM_ENUM

\**********************************************************/

const TCHAR * LOC_LM_ENUM::QueryServer( VOID ) const
{
    return _loc.QueryServer();

}  // LOC_LM_ENUM::QueryServer



/******************************* LM_ENUM_ITER *****************************/


/**********************************************************\

   NAME:       LM_ENUM_ITER::LM_ENUM_ITER

   SYNOPSIS:   constructor for the lm_enum_iter

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
      RustanL     03-Jan-1991     Wrote initial implementation in shell\util

\**********************************************************/

LM_ENUM_ITER::LM_ENUM_ITER( LM_ENUM & lmenum )
{
    _cItems = lmenum.QueryCount();
    _plmenum = &lmenum;

    _plmenum->RegisterIter();

}  // LM_ENUM_ITER::LM_ENUM_ITER


/**********************************************************\

   NAME:       LM_ENUM_ITER::~LM_ENUM_ITER

   SYNOPSIS:   destructor for the LM_ENUM_ITER

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
      RustanL     03-Jan-1991     Wrote initial implementation in shell\util

\**********************************************************/

LM_ENUM_ITER::~LM_ENUM_ITER()
{
    _plmenum->DeregisterIter();
    _plmenum = NULL ;

}  // LM_ENUM_ITER::~LM_ENUM_ITER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmoenum\lmoeprt.cxx ===
#if 0   // unsupported in NT product 1


/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    lmoeprt.cxx
    This file contains the class definitions for the PRINTQ_ENUM and
    PRINTQ1_ENUM enumerator class and their associated iterator classes.

    PRINTQ_ENUM is a base enumeration class intended to be subclassed for
    the desired info level.  PRINTQ1_ENUM is an info level 1 enumerator.


    FILE HISTORY:
        KeithMo     28-Jul-1991     Created.
        KeithMo     12-Aug-1991     Code review cleanup.
        KeithMo     07-Oct-1991     Win32 Conversion.

*/

#include "pchlmobj.hxx"

//
//  PRINTQ_ENUM methods
//

/*******************************************************************

    NAME:           PRINTQ_ENUM :: PRINTQ_ENUM

    SYNOPSIS:       PRINTQ_ENUM class constructor.

    ENTRY:          pszServerName       - The name of the server to execute
                                          the enumeration on.  NULL =
                                          execute locally.

                    usLevel             - The information level.

    EXIT:           The object is constructed.

    RETURNS:        No return value.

    NOTES:

    HISTORY:
        KeithMo     28-Jul-1991     Created.

********************************************************************/
PRINTQ_ENUM :: PRINTQ_ENUM( const TCHAR * pszServerName,
                            UINT         uLevel )
  : LOC_LM_ENUM( pszServerName, uLevel )
{
    //
    //  This space intentionally left blank.
    //

}   // PRINTQ_ENUM :: PRINTQ_ENUM


/*******************************************************************

    NAME:           PRINTQ_ENUM :: CallAPI

    SYNOPSIS:       Invokes the DosPrintQEnum() enumeration API.

    ENTRY:          ppbBuffer           - Pointer to a pointer to the
                                          enumeration buffer.

                    pcEntriesRead       - Will receive the number of
                                          entries read from the API.

    EXIT:           The enumeration API is invoked.

    RETURNS:        APIERR              - Any errors encountered.

    NOTES:

    HISTORY:
        KeithMo     28-Jul-1991     Created.
        KeithMo     12-Aug-1991     Code review cleanup.

********************************************************************/
APIERR PRINTQ_ENUM :: CallAPI( BYTE ** ppbBuffer,
                               UINT  * pcEntriesRead )
{
    return ::MDosPrintQEnum( QueryServer(),
                             QueryInfoLevel(),
                             ppbBuffer,
                             pcEntriesRead );

}   // PRINTQ_ENUM :: CallAPI


//
//  PRINTQ1_ENUM methods
//

/*******************************************************************

    NAME:           PRINTQ1_ENUM :: PRINTQ1_ENUM

    SYNOPSIS:       PRINTQ1_ENUM class constructor.

    ENTRY:          pszServerName       - The name of the server to execute
                                          the enumeration on.  NULL =
                                          execute locally.

    EXIT:           The object is constructed.

    RETURNS:        No return value.

    NOTES:

    HISTORY:
        KeithMo     28-Jul-1991     Created.

********************************************************************/
PRINTQ1_ENUM :: PRINTQ1_ENUM( const TCHAR * pszServerName )
  : PRINTQ_ENUM( pszServerName, 1 )
{
    //
    //  This space intentionally left blank.
    //

}   // PRINTQ1_ENUM :: PRINTQ1_ENUM


/*******************************************************************

    NAME:       PRINTQ1_ENUM_OBJ :: SetBufferPtr

    SYNOPSIS:   Saves the buffer pointer for this enumeration object.

    ENTRY:      pBuffer                 - Pointer to the new buffer.

    EXIT:       The pointer has been saved.

    NOTES:      Will eventually handle OemToAnsi conversions.

    HISTORY:
        KeithMo     09-Oct-1991     Created.

********************************************************************/
VOID PRINTQ1_ENUM_OBJ :: SetBufferPtr( const struct prq_info * pBuffer )
{
    ENUM_OBJ_BASE :: SetBufferPtr( (const BYTE *)pBuffer );

}   // PRINTQ1_ENUM_OBJ :: SetBufferPtr


DEFINE_LM_ENUM_ITER_OF( PRINTQ1, struct prq_info );


#endif  // 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmoenum\lmoesu.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    lmoesu.cxx

    This file contains the class definitions for the SAM_USER_ENUM
    class and its associated iterator classes.


    FILE HISTORY:
        KeithMo     13-Apr-1992     Created for the Server Manager.

*/

#include "pchlmobj.hxx"


//
//  The manifest TOTAL_BYTES_REQUESTED gives the number of BYTEs we request
//  from the server on each call to the trusted domain enumeration API.
//

#define TOTAL_BYTES_REQUESTED   0x0001FFFF



//
//  SAM_USER_ENUM methods.
//

/*******************************************************************

    NAME:       SAM_USER_ENUM :: SAM_USER_ENUM

    SYNOPSIS:   SAM_USER_ENUM class constructor.

    ENTRY:      psamdomain              - A pointer to a properly constructed
                                          SAM_DOMAIN object representing the
                                          target server (usually a PDC).

                lAccountControl         - A bitmask used to filter the
                                          enumeration.  This mask may be any
                                          combination of USER_* flags from
                                          NTSAM.H.

                fKeepBuffers            - If TRUE then LM_RESUME_ENUM
                                          will keep a list of all buffers
                                          created by CallAPI.

    HISTORY:
        KeithMo     13-Apr-1992     Created for the Server Manager.

********************************************************************/
SAM_USER_ENUM :: SAM_USER_ENUM( const SAM_DOMAIN * psamdomain,
                                ULONG              lAccountControl,
                                BOOL               fKeepBuffers )
  : LM_RESUME_ENUM( 0, fKeepBuffers ),
    _psamdomain( psamdomain ),
    _ResumeKey( (SAM_ENUMERATE_HANDLE)0 ),
    _samrem(),
    _lAccountControl( lAccountControl )
{
    UIASSERT( psamdomain != NULL );
    UIASSERT( psamdomain->QueryError() == NERR_Success );
    UIASSERT( lAccountControl != 0L );

    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_samrem )
    {
        ReportError( _samrem.QueryError() );
        return;
    }

}  // SAM_USER_ENUM :: SAM_USER_ENUM


/*******************************************************************

    NAME:       SAM_USER_ENUM :: ~SAM_USER_ENUM

    SYNOPSIS:   SAM_USER_ENUM class destructor.

    HISTORY:
        KeithMo     13-Apr-1992     Created for the Server Manager.

********************************************************************/
SAM_USER_ENUM :: ~SAM_USER_ENUM()
{
    NukeBuffers();

    _psamdomain = NULL;
    _ResumeKey  = (SAM_ENUMERATE_HANDLE)0;

}   // SAM_USER_ENUM :: ~SAM_USER_ENUM()


/*******************************************************************

    NAME:       SAM_USER_ENUM :: FreeBuffer

    SYNOPSIS:   Frees the enumeration buffer.

    ENTRY:      ppbBuffer               - Points to a pointer to the
                                          enumeration buffer.

    HISTORY:
        KeithMo     13-Apr-1992     Created for the Server Manager.

********************************************************************/
VOID SAM_USER_ENUM :: FreeBuffer( BYTE ** ppbBuffer )
{
    UIASSERT( ppbBuffer != NULL );
    UIASSERT( *ppbBuffer == (BYTE *)_samrem.QueryPtr() );

    _samrem.Set( NULL, 0 );
    *ppbBuffer = NULL;

}   // SAM_USER_ENUM :: FreeBuffer


/*******************************************************************

    NAME:       SAM_USER_ENUM :: CallAPI

    SYNOPSIS:   Invokes the SamEnumerateUsersInDomain() API.

    ENTRY:      fRestartEnum            - If TRUE, then the enumeration
                                          handle should be reset to its
                                          starting position before invoking
                                          the API.

                ppbBuffer               - Points to a pointer to the
                                          buffer returned by the API.

                pcEntriesRead           - Will receive the number of
                                          enumeration entries read.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     13-Apr-1992     Created for the Server Manager.

********************************************************************/
APIERR SAM_USER_ENUM :: CallAPI( BOOL    fRestartEnum,
                                 BYTE ** ppbBuffer,
                                 UINT  * pcEntriesRead )
{
    UIASSERT( ppbBuffer != NULL );
    UIASSERT( pcEntriesRead != NULL );

    if( fRestartEnum )
    {
        _ResumeKey = (SAM_ENUMERATE_HANDLE)0;
    }

    APIERR err = _psamdomain->EnumerateUsers( &_samrem,
                                              &_ResumeKey,
                                              _lAccountControl );

    if( ( err == NO_ERROR ) || ( err == ERROR_MORE_DATA ) )
    {
        *ppbBuffer     = (BYTE *)_samrem.QueryPtr();
        *pcEntriesRead = (UINT)_samrem.QueryCount();
    }

    return err;

}  // SAM_USER_ENUM :: CallAPI


DEFINE_LM_RESUME_ENUM_ITER_OF( SAM_USER, SAM_RID_ENUMERATION );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmoenum\lmoesh.cxx ===
/*****************************************************************/
/**		     Microsoft LAN Manager			**/
/**	       Copyright(c) Microsoft Corp., 1991		**/
/*****************************************************************/

/*
 *  HISTORY:
 *	RustanL     03-Jan-1991     Created
 *	RustanL     10-Jan-1991     Added SHARE1 subclass and iterator
 *	RustanL     24-Jan-1991     Changed UIASSERT's to also support
 *				    the recently added level 90
 *	beng	    11-Feb-1991     Uses lmui.hxx
 *	chuckc	    20-Mar-1991     Share Enum level 91, not 92
 *	chuckc	    23-Mar-1991     code rev cleanup
 *	KeithMo	    28-Jul-1991	    Added SHARE2 subclass and iterator
 *	KeithMo	    12-Aug-1991	    Code review cleanup.
 *	KeithMo	    07-Oct-1991	    Win32 Conversion.
 *      Yi-HsinS    20-Nov-1992     Added support for calling NetShareEnumSticky
 *
 */

#include "pchlmobj.hxx"


/*****************************	SHARE_ENUM  ******************************/


/**********************************************************\

   NAME:       SHARE_ENUM::SHARE_ENUM

   SYNOPSIS:   share enum constructor

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
   	RustanL     03-Jan-1991     Created

\**********************************************************/

SHARE_ENUM::SHARE_ENUM( const TCHAR * pszServer, UINT uLevel, BOOL fSticky )
  : LOC_LM_ENUM( pszServer, uLevel ),
    _fSticky( fSticky )
{
    // only supports levels 1, 2, 90, 91 at this time
    UIASSERT( uLevel == 1 || uLevel == 2 || uLevel == 90 || uLevel == 91 );

}  // SHARE_ENUM::SHARE_ENUM



/**********************************************************\

   NAME:       SHARE_ENUM::CallAPI

   SYNOPSIS:   call share enum api

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
   	RustanL     03-Jan-1991     Created
	KeithMo	    12-Aug-1991	    Code review cleanup.

\**********************************************************/

APIERR SHARE_ENUM::CallAPI( BYTE ** ppbBuffer,
			    UINT  * pcEntriesRead )
{
    // only levels support at the time
    UIASSERT( QueryInfoLevel() == 1 ||
	      QueryInfoLevel() == 2 ||
	      QueryInfoLevel() == 90 ||
	      QueryInfoLevel() == 91 );

    if ( _fSticky )
    {
        return ::MNetShareEnumSticky( QueryServer(),
	 		              QueryInfoLevel(),
			              ppbBuffer,
			              pcEntriesRead );
    }
    else
    {
        return ::MNetShareEnum( QueryServer(),
	      		        QueryInfoLevel(),
			        ppbBuffer,
			        pcEntriesRead );
    }

}  // SHARE_ENUM::CallAPI



/*****************************	SHARE1_ENUM  ******************************/



/**********************************************************\

   NAME:       SHARE1_ENUM::SHARE1_ENUM

   SYNOPSIS:   share enum 1 constructor

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
   	RustanL     03-Jan-1991     Created

\**********************************************************/

SHARE1_ENUM::SHARE1_ENUM( const TCHAR * pszServer, BOOL fSticky )
  : SHARE_ENUM( pszServer, 1, fSticky )
{
    // do nothing else

}  // SHARE1_ENUM::SHARE1_ENUM



/*******************************************************************

    NAME:	SHARE1_ENUM_OBJ :: SetBufferPtr

    SYNOPSIS:	Saves the buffer pointer for this enumeration object.

    ENTRY:	pBuffer			- Pointer to the new buffer.

    EXIT:	The pointer has been saved.

    NOTES:	Will eventually handle OemToAnsi conversions.

    HISTORY:
	KeithMo	    09-Oct-1991	    Created.

********************************************************************/
VOID SHARE1_ENUM_OBJ :: SetBufferPtr( const struct share_info_1 * pBuffer )
{
    ENUM_OBJ_BASE :: SetBufferPtr( (const BYTE *)pBuffer );

}   // SHARE1_ENUM_OBJ :: SetBufferPtr


DEFINE_LM_ENUM_ITER_OF( SHARE1, struct share_info_1 );



/*****************************	SHARE2_ENUM  ******************************/



/*******************************************************************

    NAME:	SHARE2_ENUM :: SHARE2_ENUM

    SYNOPSIS:	Constructor for the level 2 share enumerator.

    ENTRY:	pszServer		- The name of the target server.

    EXIT:

    RETURNS:	No return value.

    NOTES:

    HISTORY:
	KeithMo	    28-Jul-1991	    Created.

********************************************************************/
SHARE2_ENUM :: SHARE2_ENUM( const TCHAR * pszServer, BOOL fSticky )
  : SHARE_ENUM( pszServer, 2, fSticky )
{
    //
    //	This space intentionally left blank.
    //

}   // SHARE2_ENUM :: SHARE2_ENUM


/*******************************************************************

    NAME:	SHARE2_ENUM_OBJ :: SetBufferPtr

    SYNOPSIS:	Saves the buffer pointer for this enumeration object.

    ENTRY:	pBuffer			- Pointer to the new buffer.

    EXIT:	The pointer has been saved.

    NOTES:	Will eventually handle OemToAnsi conversions.

    HISTORY:
	KeithMo	    09-Oct-1991	    Created.

********************************************************************/
VOID SHARE2_ENUM_OBJ :: SetBufferPtr( const struct share_info_2 * pBuffer )
{
    ENUM_OBJ_BASE :: SetBufferPtr( (const BYTE *)pBuffer );

}   // SHARE2_ENUM_OBJ :: SetBufferPtr


DEFINE_LM_ENUM_ITER_OF( SHARE2, struct share_info_2 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmoenum\lmoesess.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    lmoesess.cxx
    This file contains the class definitions for the SESSION_ENUM and
    SESSION0_ENUM enumerator class and their associated iterator classes.

    SESSION_ENUM is a base enumeration class intended to be subclassed for
    the desired info level.  SESSION0_ENUM is an info level 0 enumerator.


    FILE HISTORY:
	KeithMo	    28-Jul-1991	    Created.
	KeithMo	    12-Aug-1991	    Code review cleanup.
	KeithMo	    07-Oct-1991	    Win32 Conversion.

*/

#include "pchlmobj.hxx"

//
//  SESSION_ENUM methods
//

/*******************************************************************

    NAME:	    SESSION_ENUM :: SESSION_ENUM

    SYNOPSIS:	    SESSION_ENUM class constructor.

    ENTRY:	    pszServerName	- The name of the server to execute
    				  	  the enumeration on.  NULL =
				  	  execute locally.

		    usLevel		- The information level.

    EXIT:	    The object is constructed.

    RETURNS:	    No return value.

    NOTES:

    HISTORY:
	KeithMo	    28-Jul-1991	    Created.

********************************************************************/
SESSION_ENUM :: SESSION_ENUM( const TCHAR * pszServerName,
			      UINT	   uLevel )
  : LOC_LM_ENUM( pszServerName, uLevel )
{
    //
    //	This space intentionally left blank.
    //

}   // SESSION_ENUM :: SESSION_ENUM


/*******************************************************************

    NAME:	    SESSION_ENUM :: CallAPI

    SYNOPSIS:	    Invokes the NetSessionEnum() enumeration API.

    ENTRY:	    ppbBuffer		- Pointer to a pointer to the
					  enumeration buffer.

		    pcEntriesRead	- Will receive the number of
		    		  	  entries read from the API.

    EXIT:	    The enumeration API is invoked.

    RETURNS:	    APIERR		- Any errors encountered.

    NOTES:

    HISTORY:
	KeithMo	    28-Jul-1991	    Created.
	KeithMo	    12-Aug-1991	    Code review cleanup.

********************************************************************/
APIERR SESSION_ENUM :: CallAPI( BYTE ** ppbBuffer,
			 	UINT  * pcEntriesRead )
{
    return ::MNetSessionEnum( QueryServer(),
    			      QueryInfoLevel(),
			      ppbBuffer,
			      pcEntriesRead );

}   // SESSION_ENUM :: CallAPI


//
//  SESSION0_ENUM methods
//

/*******************************************************************

    NAME:	    SESSION0_ENUM :: SESSION0_ENUM

    SYNOPSIS:	    SESSION0_ENUM class constructor.

    ENTRY:	    pszServerName	- The name of the server to execute
    				  	  the enumeration on.  NULL =
				  	  execute locally.

    EXIT:	    The object is constructed.

    RETURNS:	    No return value.

    NOTES:

    HISTORY:
	KeithMo	    28-Jul-1991	    Created.

********************************************************************/
SESSION0_ENUM :: SESSION0_ENUM( const TCHAR * pszServerName )
  : SESSION_ENUM( pszServerName, 0 )
{
    //
    //	This space intentionally left blank.
    //

}   // SESSION0_ENUM :: SESSION0_ENUM


/*******************************************************************

    NAME:	SESSION0_ENUM_OBJ :: SetBufferPtr

    SYNOPSIS:	Saves the buffer pointer for this enumeration object.

    ENTRY:	pBuffer			- Pointer to the new buffer.

    EXIT:	The pointer has been saved.

    NOTES:	Will eventually handle OemToAnsi conversions.

    HISTORY:
	KeithMo	    09-Oct-1991	    Created.

********************************************************************/
VOID SESSION0_ENUM_OBJ :: SetBufferPtr( const struct session_info_0 * pBuffer )
{
    ENUM_OBJ_BASE :: SetBufferPtr( (const BYTE *)pBuffer );

}   // SESSION0_ENUM_OBJ :: SetBufferPtr


DEFINE_LM_ENUM_ITER_OF( SESSION0, struct session_info_0 );


//
//  SESSION1_ENUM methods
//

/*******************************************************************

    NAME:	    SESSION1_ENUM :: SESSION1_ENUM

    SYNOPSIS:	    SESSION1_ENUM class constructor.

    ENTRY:	    pszServerName	- The name of the server to execute
    				  	  the enumeration on.  NULL =
				  	  execute locally.

    EXIT:	    The object is constructed.

    RETURNS:	    No return value.

    NOTES:

    HISTORY:
	KevinL	    15-Sep-1991	    Created.

********************************************************************/
SESSION1_ENUM :: SESSION1_ENUM( const TCHAR * pszServerName )
  : SESSION_ENUM( pszServerName, 1 )
{
    //
    //	This space intentionally left blank.
    //

}   // SESSION1_ENUM :: SESSION1_ENUM


/*******************************************************************

    NAME:	SESSION1_ENUM_OBJ :: SetBufferPtr

    SYNOPSIS:	Saves the buffer pointer for this enumeration object.

    ENTRY:	pBuffer			- Pointer to the new buffer.

    EXIT:	The pointer has been saved.

    NOTES:	Will eventually handle OemToAnsi conversions.

    HISTORY:
	KeithMo	    09-Oct-1991	    Created.

********************************************************************/
VOID SESSION1_ENUM_OBJ :: SetBufferPtr( const struct session_info_1 * pBuffer )
{
    ENUM_OBJ_BASE :: SetBufferPtr( (const BYTE *)pBuffer );

}   // SESSION1_ENUM_OBJ :: SetBufferPtr


DEFINE_LM_ENUM_ITER_OF( SESSION1, struct session_info_1 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmoenum\lmoersm.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1992                   **/
/**********************************************************************/

/*
    lmoersm.cxx
    This file contains the class definitions for the LM_RESUME_ENUM
    and LM_RESUME_ENUM_ITER classes.

    LM_RESUME_ENUM is a generic enumeration class for resumeable
    API.  LM_RESUME_ENUM_ITER is an iterator for iterating objects
    created from the LM_RESUME_ENUM class.

    NOTE:  All classes contained in this file were derived from
           RustanL's LM_ENUM/LM_ENUM_ITER classes.


    FILE HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.
        KeithMo     13-Aug-1991 Cleanup, added LOCATION support.
        KeithMo     19-Aug-1991 Code review revisions (code review
                                attended by ChuckC, Hui-LiCh, JimH,
                                JonN, KevinL).
        KeithMo     07-Oct-1991 Win32 Conversion.
        JonN        30-Jan-1992 Split LOC_LM_RESUME_ENUM from LM_RESUME_ENUM
        KeithMo     18-Mar-1992 Added optional constructor parameter to
                                force enumerator to keep all buffers.
                                (single/multi buffer support).
        KeithMo     31-Mar-1992 Code review revisions (code review
                                attended by JimH, JohnL, JonN, and ThomasPa).
*/

#include "pchlmobj.hxx"



//
//  LM_RESUME_BUFFER methods.
//

/*******************************************************************

    NAME:           LM_RESUME_BUFFER :: LM_RESUME_BUFFER

    SYNOPSIS:       LM_RESUME_BUFFER class constructor.

    ENTRY:          penum               - Points to the LM_RESUME_ENUM
                                          enumerator that "owns" this
                                          node.

                    cItems              - The number of enumeration items
                                          in the buffer.

                    pbBuffer            - The enumeration buffer.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     15-Mar-1992 Created for the Server Manager.

********************************************************************/
LM_RESUME_BUFFER :: LM_RESUME_BUFFER( LM_RESUME_ENUM * penum,
                                      UINT             cItems,
                                      BYTE           * pbBuffer )
  : BASE(),
    _penum( penum ),
    _cItems( cItems ),
    _pbBuffer( pbBuffer )
{
    UIASSERT( _penum != NULL );
    UIASSERT( _cItems > 0 );
    UIASSERT( _pbBuffer != NULL );

    //
    //  Ensure that everything constructed propertly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

}   // LM_RESUME_BUFFER :: LM_RESUME_BUFFER


/*******************************************************************

    NAME:           LM_RESUME_BUFFER :: ~LM_RESUME_BUFFER

    SYNOPSIS:       LM_RESUME_BUFFER class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     15-Mar-1992 Created for the Server Manager.

********************************************************************/
LM_RESUME_BUFFER :: ~LM_RESUME_BUFFER( VOID )
{
    _penum->FreeBuffer( &_pbBuffer );

    _pbBuffer = NULL;
    _cItems   = 0;

}   // LM_RESUME_BUFFER :: ~LM_RESUME_BUFFER

DEFINE_SLIST_OF( LM_RESUME_BUFFER );



//
//  LM_RESUME_ENUM methods.
//

/*******************************************************************

    NAME:           LM_RESUME_ENUM :: LM_RESUME_ENUM

    SYNOPSIS:       LM_RESUME_ENUM class constructor.

    ENTRY:          pszServerName       - Pointer to the server name.

                    uLevel              - Information level.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.
        KeithMo     13-Aug-1991 Cleanup.
        KeithMo     19-Aug-1991 Moved constructor validation to CtAux().
        JonN        30-Jan-1992 Recombined constructors

********************************************************************/
LM_RESUME_ENUM :: LM_RESUME_ENUM( UINT uLevel,
                                  BOOL fKeepBuffers )
  : _uLevel( uLevel ),
    _fKeepBuffers( fKeepBuffers ),
    _pbBuffer( NULL ),
    _cEntriesRead( 0 ),
    _fMoreData( FALSE ),
    _cAllItems( 0 )
{

    //
    //  Ensure that everything constructed propertly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    //
    //  Clear the iterator reference counter.
    //

    _cIterRef = 0;

}   // LM_RESUME_ENUM :: LM_RESUME_ENUM



/*******************************************************************

    NAME:           LM_RESUME_ENUM :: ~LM_RESUME_ENUM

    SYNOPSIS:       LM_RESUME_ENUM class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.

********************************************************************/
LM_RESUME_ENUM :: ~LM_RESUME_ENUM()
{
    UIASSERT( _cIterRef == 0 );

}   // LM_RESUME_ENUM :: ~LM_RESUME_ENUM


/*******************************************************************

    NAME:           LM_RESUME_ENUM :: GetInfo

    SYNOPSIS:       Invokes the enumeration API.

    ENTRY:          fRestartEnum        - Should we start at the
                                          beginning?  Note that this
                                          flag is only used if
                                          DoesKeepBuffers() is FALSE.


    EXIT:           If DoesKeepBuffers() is TRUE, then GetInfoMulti()
                    is invoked to collect all of the enumeration
                    buffers.  Otherwise, GetInfoSingle() is invoked
                    to get the first enumeration buffer.

    RETURNS:        APIERR      - Any errors encountered.

    HISTORY:
        KeithMo     18-Mar-1991 Created for the Server Manager.

********************************************************************/
APIERR LM_RESUME_ENUM :: GetInfo( BOOL fRestartEnum )
{
    return DoesKeepBuffers() ? GetInfoMulti()
                             : GetInfoSingle( fRestartEnum );

}   // LM_RESUME_ENUM :: GetInfo


/*******************************************************************

    NAME:           LM_RESUME_ENUM :: GetInfoSingle

    SYNOPSIS:       Invokes the enumeration API.

    ENTRY:          fRestartEnum - Should we start at the beginning?

    EXIT:           The enumeration buffer is allocated, and the
                    enumeration API is invoked.  If the API is
                    successful, then the buffer will contain
                    the first chunk of the enumeration data.
                    Further calls to GetInfo() may be required to
                    complete the enumeration.

    RETURNS:        APIERR      - Any errors encountered.

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.
        rustanl     15-Jul-1991 Changed to use new BUFFER::Resize return
                                type
        KeithMo     13-Aug-1991 Cleanup.
        KeithMo     19-Aug-1991 Improved error handling and buffer
                                management.
        KeithMo     18-Mar-1992 Renamed from GetInfo to GetInfoSingle
                                for single/multi buffer support.

********************************************************************/
APIERR LM_RESUME_ENUM :: GetInfoSingle( BOOL fRestartEnum )
{
    //
    //  We must be careful to free any enumeration buffers
    //  allocated on our behalf by the API.
    //

    FreeBuffer( &_pbBuffer );
    ASSERT( _pbBuffer == NULL );

    //
    //  Invoke the API.
    //

    APIERR err = CallAPI( fRestartEnum,
                          &_pbBuffer,
                          &_cEntriesRead );

    //
    //  Interpret the return code.
    //

    switch ( err )
    {
    case NERR_Success:

        //
        //  Success!
        //
        //  Setting this flag to FALSE will tell the
        //  LM_RESUME_ENUM_ITER class that there's no point
        //  in issuing further calls to GetInfo().
        //

        _fMoreData = FALSE;
        // CODEWORK: We should assert here that
        // ASSERT( _pbBuffer != NULL );
        // , but this is not the case for FILE_ENUM, which sometimes
        // returns a NULL buffer and NERR_Success.  This assertion can be
        // restored when LMOEFILE.CXX is fixed to change the return in
        // that case to ERROR_NO_MORE_ITEMS.  JonN 7/10/96

        break;

    case NERR_BufTooSmall:
    case ERROR_MORE_DATA:

        //
        //  The enumeration API is telling us that our buffer
        //  is too small.  Since we don't want to grow the
        //  buffer any larger than this, we'll just have to
        //  live with it and make multiple calls to GetInfo().
        //
        //  Setting this flag to TRUE tells LM_RESUME_ENUM_ITER
        //  that more enumeration data is available.
        //

        _fMoreData = TRUE;
        // CODEWORK This should probably be present, but strange
        // error-handling in lsaenum.cxx will set it off.  The code
        // will muddle through despite the confusion.  I have filed a
        // bug in this.
        // ASSERT( _pbBuffer != NULL );

        //
        //  Since we're using resumable API, we'll pretend
        //  that the API was successful.  Subsequent calls
        //  to GetInfo() will retrieve the remaining enumeration
        //  data.

        break;

    default:

        //
        //      Unknown error.  Return it to the caller.
        //

        ASSERT( _pbBuffer == NULL );

        return err;
    }

    //
    //  Success!
    //

    return NERR_Success;

}   // LM_RESUME_ENUM :: GetInfoSingle


/*******************************************************************

    NAME:           LM_RESUME_ENUM :: GetInfoMulti

    SYNOPSIS:       Invokes the enumeration API.

    EXIT:           The enumeration buffer(s) are allocated, and the
                    enumeration API is invoked.  If the API is
                    successful, then the buffer(s) will contain
                    the enumeration data.

    RETURNS:        APIERR      - Any errors encountered.

    HISTORY:
        KeithMo     18-Mar-1991 Created for the Server Manager.

********************************************************************/
APIERR LM_RESUME_ENUM :: GetInfoMulti( VOID )
{
    UIASSERT( _BufferList.QueryNumElem() == 0 );

    BYTE * pbBuffer;
    UINT   cEntriesRead;
    APIERR err = NERR_Success;
    BOOL   fRestartEnum = TRUE;

    for( BOOL fMoreData = TRUE ; fMoreData && ( err == NERR_Success ) ; )
    {
        //
        //  Invoke the API.
        //

        err = CallAPI( fRestartEnum,
                       &pbBuffer,
                       &cEntriesRead );

        fRestartEnum = FALSE;

        //
        //  Interpret the return code.
        //

        if( err == NERR_Success )
        {
            //
            //  This is very good.  It means that we've retrieved
            //  all of the enumeration data.  We still need to
            //  save the current buffer away, though.
            //

            fMoreData = FALSE;
        }
        else
        if( ( err == NERR_BufTooSmall ) || ( err == ERROR_MORE_DATA ) )
        {
            UIASSERT( cEntriesRead != 0 );

            //
            //  This is also good, it just means that the API
            //  could not allocate enough buffer space for *all*
            //  of the enumeration data.  We'll save away the
            //  current buffer, then loop around & get some more.
            //

            //
            //  Just to make the looping logic somewhat simpler,
            //  we'll map these return codes to NERR_Success.
            //

            err = NERR_Success;
        }
        else
        {
            //
            //  This is not good at all.  Something tragic must
            //  have happened in the API, so break out of the
            //  loop.
            //

            break;
        }

        if( cEntriesRead == 0 )
        {
            //
            //  I'm not sure if this will ever happen, but
            //  we might as well check for it.
            //

            continue;
        }

        _cAllItems += cEntriesRead;

        //
        //  Allocate a new buffer node for our buffer list.
        //

        LM_RESUME_BUFFER * plmrb = new LM_RESUME_BUFFER( this,
                                                         cEntriesRead,
                                                         pbBuffer );

        err = ( plmrb == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                : plmrb->QueryError();

        if( err == NERR_Success )
        {
            //
            //  Add the node to our buffer list.
            //

            err = _BufferList.Append( plmrb );
        }
    }

    return err;

}   // LM_RESUME_ENUM :: GetInfoMulti


/*******************************************************************

    NAME:           LM_RESUME_ENUM :: NukeBuffers

    SYNOPSIS:       Destroys any buffer(s) allocated by this enumerator.

    EXIT:           The enumeration buffer(s) are history.

    NOTES:          THIS METHOD **MUST** BE CALLED FROM THE DESTRUCTOR
                    OF ANY DERIVED SUBCLASS THAT OVERRIDES THE FreeBuffer()
                    VIRTUAL!!!

    HISTORY:
        KeithMo     11-Sep-1992 Created in a fit of stress & confusion.

********************************************************************/
VOID LM_RESUME_ENUM :: NukeBuffers( VOID )
{
    if( DoesKeepBuffers() )
    {
        _BufferList.Clear();
    }
    else
    {
        FreeBuffer( &_pbBuffer );
        ASSERT( _pbBuffer == NULL );
    }

}   // LM_RESUME_ENUM :: NukeBuffer


/*******************************************************************

    NAME:           LM_RESUME_ENUM :: _RegisterIter

    SYNOPSIS:       Register a new iterator by incrementing a
                    reference counter.

    EXIT:           The iterator reference counter is incremented.

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.
        KeithMo     13-Aug-1991 Cleanup.

********************************************************************/
VOID LM_RESUME_ENUM :: _RegisterIter( VOID )
{
#if defined(DEBUG)
    //
    //  If DoesKeepBuffers() is FALSE, then LM_RESUME_ENUM can only
    //  handle one iterator binding at a time.  To enforce this,
    //  we'll ensure that _cIterRef is 0.
    //

    UIASSERT( DoesKeepBuffers() || ( _cIterRef == 0 ) );

    _cIterRef++;

#endif // DEBUG
}   // LM_RESUME_ENUM :: RegisterIter


/*******************************************************************

    NAME:           LM_RESUME_ENUM :: _DeregisterIter

    SYNOPSIS:       Deregister an existing iterator by decrementing
                    a reference counter.

    EXIT:           The iterator reference counter is decremented.

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.

********************************************************************/
VOID LM_RESUME_ENUM :: _DeregisterIter( VOID )
{
#if defined(DEBUG)
    if ( _cIterRef == 0 )
    {
        UIASSERT( FALSE );
    }
    else
    {
        _cIterRef--;
    }

#endif // DEBUG
}   // LM_RESUME_ENUM :: DeregisterIter


//
//  LOC_LM_RESUME_ENUM methods.
//


/*******************************************************************

    NAME:           LOC_LM_RESUME_ENUM :: LOC_LM_RESUME_ENUM

    SYNOPSIS:       LOC_LM_RESUME_ENUM class constructor.

    ENTRY:          pszServerName       - Pointer to the server name.

                    uLevel              - Information level.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.
        KeithMo     13-Aug-1991 Cleanup.
        KeithMo     19-Aug-1991 Moved constructor validation to CtAux().

********************************************************************/

LOC_LM_RESUME_ENUM :: LOC_LM_RESUME_ENUM( const TCHAR * pszServerName,
                                          UINT          uLevel,
                                          BOOL          fKeepBuffers  )
  : LM_RESUME_ENUM( uLevel, fKeepBuffers ),
    _loc( pszServerName )
{

    if( !_loc )
    {
        ReportError( _loc.QueryError() );
        return;
    }

}   // LOC_LM_RESUME_ENUM :: LOC_LM_RESUME_ENUM


/*******************************************************************

    NAME:           LOC_LM_RESUME_ENUM :: LOC_LM_RESUME_ENUM

    SYNOPSIS:       LOC_LM_RESUME_ENUM class constructor.

    ENTRY:          locType             - Location type (a server).

                    uLevel              - Information level.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     13-Aug-1991 Created this constructor.
        KeithMo     19-Aug-1991 Moved constructor validation to CtAux().

********************************************************************/

LOC_LM_RESUME_ENUM :: LOC_LM_RESUME_ENUM( LOCATION_TYPE locType,
                                          UINT          uLevel,
                                          BOOL          fKeepBuffers  )
  : LM_RESUME_ENUM( uLevel, fKeepBuffers ),
    _loc( locType )
{

    if( !_loc )
    {
        ReportError( _loc.QueryError() );
        return;
    }


}   // LOC_LM_RESUME_ENUM :: LOC_LM_RESUME_ENUM


/*******************************************************************

    NAME:           LOC_LM_RESUME_ENUM :: LOC_LM_RESUME_ENUM

    SYNOPSIS:       LOC_LM_RESUME_ENUM class constructor.

    ENTRY:          loc                 - A LOCATION reference.

                    uLevel              - Information level.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     13-Aug-1991 Created this constructor.
        KeithMo     19-Aug-1991 Moved constructor validation to CtAux().

********************************************************************/
LOC_LM_RESUME_ENUM :: LOC_LM_RESUME_ENUM( const LOCATION & loc,
                                          UINT             uLevel,
                                          BOOL             fKeepBuffers  )
  : LM_RESUME_ENUM( uLevel, fKeepBuffers ),
    _loc( loc )
{

    if( !_loc )
    {
        ReportError( _loc.QueryError() );
        return;
    }

}   // LOC_LM_RESUME_ENUM :: LOC_LM_RESUME_ENUM


/*******************************************************************

    NAME:           LOC_LM_RESUME_ENUM :: ~LOC_LM_RESUME_ENUM

    SYNOPSIS:       LOC_LM_RESUME_ENUM class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.

********************************************************************/
LOC_LM_RESUME_ENUM :: ~LOC_LM_RESUME_ENUM()
{
    NukeBuffers();

}   // LM_RESUME_ENUM :: ~LM_RESUME_ENUM


/*******************************************************************

    NAME:           LOC_LM_RESUME_ENUM :: FreeBuffer

    SYNOPSIS:       Frees the API buffer.

    ENTRY:          ppbBuffer           - Points to a pointer to the
                                          enumeration buffer.

    NOTE:           Some code relies on the pointer being reset to NULL.

    HISTORY:
        KeithMo     31-Mar-1992 Created.

********************************************************************/
VOID LOC_LM_RESUME_ENUM :: FreeBuffer( BYTE ** ppbBuffer )
{
    UIASSERT( ppbBuffer != NULL );

    ::MNetApiBufferFree( ppbBuffer );

    ASSERT( *ppbBuffer == NULL );

}   // LOC_LM_RESUME_ENUM :: FreeBuffer



//
//  LM_RESUME_ENUM_ITER methods.
//

/*******************************************************************

    NAME:           LM_RESUME_ENUM_ITER :: LM_RESUME_ENUM_ITER

    SYNOPSIS:       LM_RESUME_ENUM_ITER class constructor.

    ENTRY:          lmenum      - The enumerator to iterate.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.
        KeithMo     13-Aug-1991 Cleanup.

********************************************************************/
LM_RESUME_ENUM_ITER :: LM_RESUME_ENUM_ITER( LM_RESUME_ENUM & lmenum )
  : BASE(),
    _plmenum( &lmenum ),
    _iterBuffer( lmenum._BufferList )
{
    //
    //  Register this iterator with the enumerator.
    //

    _plmenum->RegisterIter();

    //
    //  The the enumerator we're "bound to" keeps all of its
    //  buffers hanging around, then we must "prime the pump".
    //  This will retrieve the first LM_RESUME_BUFFER from the
    //  enumerator's slist.
    //

    if( _plmenum->DoesKeepBuffers() )
    {
        _plmbuffer = _iterBuffer.Next();
    }

}   // LM_RESUME_ENUM_ITER :: LM_RESUME_ENUM_ITER


/*******************************************************************

    NAME:           LM_RESUME_ENUM_ITER :: ~LM_RESUME_ENUM_ITER

    SYNOPSIS:       LM_RESUME_ENUM_ITER class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.
        KeithMo     13-Aug-1991 Cleanup.

********************************************************************/
LM_RESUME_ENUM_ITER :: ~LM_RESUME_ENUM_ITER()
{
    //
    //  Deregister this iterator from the enumerator.
    //

    _plmenum->DeregisterIter();

    _plmenum = NULL ;

}   // LM_RESUME_ENUM_ITER :: ~LM_RESUME_ENUM_ITER


/*******************************************************************

    NAME:           LM_RESUME_ENUM_ITER :: QueryBasePtr

    SYNOPSIS:       Queries the base pointer of the current enumeration
                    buffer.

    RETURNS:        const BYTE *        - The enumerator's base pointer.

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.
        KeithMo     18-Mar-1992 Added single/multi buffer support.
        KeithMo     14-Apr-1992 Fixed empty enumeration case.

********************************************************************/
const BYTE * LM_RESUME_ENUM_ITER :: QueryBasePtr( VOID ) const
{
    if( _plmenum->DoesKeepBuffers() )
    {
        return ( _plmbuffer == NULL ) ? NULL
                                      : _plmbuffer->QueryBufferPtr();
    }
    else
    {
        return _plmenum->_pbBuffer;
    }

}   // LM_RESUME_ENUM_ITER :: QueryBasePtr


/*******************************************************************

    NAME:           LM_RESUME_ENUM_ITER :: QueryCount

    SYNOPSIS:       Queries the number of objects in the current
                    enumeration buffer.

    RETURNS:        UINT        - The number of objects in the
                                  current enumeration buffer.

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.
        KeithMo     13-Aug-1991 Cleanup.
        KeithMo     19-Aug-1991 Renamed QueryCount() from QuerySize().
        KeithMo     18-Mar-1992 Added single/multi buffer support.
        KeithMo     14-Apr-1992 Fixed empty enumeration case.

********************************************************************/
UINT LM_RESUME_ENUM_ITER :: QueryCount( VOID ) const
{
    if( _plmenum->DoesKeepBuffers() )
    {
        return ( _plmbuffer == NULL ) ? 0
                                      : _plmbuffer->QueryItemCount();
    }
    else
    {
        return _plmenum->_cEntriesRead;
    }

}   // LM_RESUME_ENUM_ITER :: QueryCount


/*******************************************************************

    NAME:           LM_RESUME_ENUM_ITER :: HasMoreData

    SYNOPSIS:       Queries the _fMoreData flag.

    RETURNS:        BOOL        - TRUE  if there is more data available.
                                  FALSE if there is no more data.

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.
        KeithMo     19-Aug-1991 Renamed HasMoreData() from
                                QueryMoreData().
        KeithMo     18-Mar-1992 Added single/multi buffer support.
        KeithMo     14-Apr-1992 Fixed empty enumeration case.

********************************************************************/
BOOL LM_RESUME_ENUM_ITER :: HasMoreData( VOID ) const
{
    if( _plmenum->DoesKeepBuffers() )
    {
        if( _plmbuffer == NULL )
        {
            return FALSE;
        }

        ITER_SL iter( _iterBuffer );

        return iter.Next() != NULL;
    }
    else
    {
        return _plmenum->_fMoreData;
    }

}   // LM_RESUME_ENUM_ITER :: HasMoreData


/*******************************************************************

    NAME:           LM_RESUME_ENUM_ITER :: NextGetInfo

    SYNOPSIS:       Call the enumerator's GetInfo() method to read
                    the next available chuck of enumeration data.

    RETURNS:        APIERR      - Any errors returned from GetInfo().

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.
        KeithMo     13-Aug-1991 Cleanup.
        KeithMo     19-Aug-1991 Renamed NextGetInfo() from EnumNext().
        KeithMo     18-Mar-1992 Added single/multi buffer support.

********************************************************************/
APIERR LM_RESUME_ENUM_ITER :: NextGetInfo( VOID )
{
    UIASSERT( HasMoreData() );

    APIERR err = NERR_Success;

    if( _plmenum->DoesKeepBuffers() )
    {
        _plmbuffer = _iterBuffer.Next();
        UIASSERT( _plmbuffer != NULL );
    }
    else
    {
        err = _plmenum->GetInfo( FALSE );
    }

    return err;

}   // LM_RESUME_ENUM_ITER :: NextGetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmoenum\lmoesrv3.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    lmoesrv3.hxx

    This file contains the class declarations for the TRIPLE_SERVER_ENUM
    class and its associated iterator classes.


    FILE HISTORY:
        KeithMo     17-Mar-1992     Created for the Server Manager.
        JonN        01-Apr-1992     Adjusted to changes in NT_MACHINE_ENUM
        JonN        07-Jul-1995     DeadPrimary appears even when !ALLOW_WKSTAS

*/

#include "pchlmobj.hxx"


//
//  Define some handy macros.
//

#define MY_PRIMARY_MASK    (SV_TYPE_DOMAIN_CTRL)
#define MY_BACKUP_MASK     (SV_TYPE_DOMAIN_BAKCTRL | SV_TYPE_SERVER)
#define MY_SERVER_MASK     (SV_TYPE_SERVER_NT)
#define MY_WKSTA_MASK      (SV_TYPE_DOMAIN_CTRL | SV_TYPE_DOMAIN_BAKCTRL | SV_TYPE_SERVER_NT)

#define IS_WKSTA_TRUST(x)  (((x) & USER_WORKSTATION_TRUST_ACCOUNT) != 0)
#define IS_SERVER_TRUST(x) (((x) & USER_SERVER_TRUST_ACCOUNT) != 0)

#define IS_PRIMARY(x)      (((x) & MY_PRIMARY_MASK) == MY_PRIMARY_MASK)
#define IS_BACKUP(x)       (((x) & MY_BACKUP_MASK) == MY_BACKUP_MASK)
#define IS_SERVER(x)       (((x) & MY_SERVER_MASK) == MY_SERVER_MASK)
#define IS_WKSTA(x)        (((x) & MY_WKSTA_MASK) == 0)

#define IS_NT_SERVER(x)    (((x) & SV_TYPE_NT) != 0)
#define IS_WFW_SERVER(x)   (((x) & SV_TYPE_WFW) != 0)
#define IS_LM_SERVER(x)    (((x) & (SV_TYPE_NT | SV_TYPE_WFW)) == 0)
#define IS_WIN95_SERVER(x) (((x) & SV_TYPE_WINDOWS) != 0)

#define ALLOW_WKSTAS       (_fAllowWkstas == TRUE)
#define ALLOW_SERVERS      (_fAllowServers == TRUE)



//
//  TRIPLE_SERVER_ENUM methods.
//

/*******************************************************************

    NAME:       TRIPLE_SERVER_ENUM :: TRIPLE_SERVER_ENUM

    SYNOPSIS:   TRIPLE_SERVER_ENUM class constructor.

    ENTRY:      pszDomainName           - The name of the target domain.

                pszPrimaryName          - The name of the target domain's
                                          Primary controller.  If this
                                          parameter is NULL, then the
                                          PDC is assumed to be down.

    EXIT:       The object has been constructed.

    HISTORY:
        KeithMo     17-Mar-1992     Created for the Server Manager.

********************************************************************/
TRIPLE_SERVER_ENUM :: TRIPLE_SERVER_ENUM( const TCHAR * pszDomainName,
                                          const TCHAR * pszPrimaryName,
                                          BOOL          fIsNtPrimary,
                                          BOOL          fAllowWkstas,
                                          BOOL          fAllowServers,
                                          BOOL          fAccountsOnly )
  : LM_ENUM( 0 ),
    _pmach( NULL ),
    _puser( NULL ),
    _psrv( NULL ),
    _nlsDomainName( pszDomainName ),
    _nlsPrimaryName( pszPrimaryName ),
    _fIsNtPrimary( fIsNtPrimary ),
    _fAllowWkstas( fAllowWkstas ),
    _fAllowServers( fAllowServers ),
    _fAccountsOnly( fAccountsOnly ),
    _fPDCAvailable( pszPrimaryName != NULL ),
    _pszPrimaryNoWhacks( NULL )
{
    UIASSERT( pszDomainName != NULL );
    UIASSERT( fAllowWkstas | fAllowServers );

    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_nlsDomainName )
    {
        ReportError( _nlsDomainName.QueryError() );
        return;
    }

    if( !_nlsPrimaryName )
    {
        ReportError( _nlsPrimaryName.QueryError() );
        return;
    }

    if( _fPDCAvailable )
    {
        //
        //  Get a pointer to the primary name without the
        //  leading backslashes.
        //

        ISTR istr( _nlsPrimaryName );
        istr += 2;

        _pszPrimaryNoWhacks = _nlsPrimaryName.QueryPch( istr );
    }

}   // TRIPLE_SERVER_ENUM :: TRIPLE_SERVER_ENUM


/*******************************************************************

    NAME:       TRIPLE_SERVER_ENUM :: ~TRIPLE_SERVER_ENUM

    SYNOPSIS:   TRIPLE_SERVER_ENUM class destructor.

    EXIT:       The object has been destroyed.

    HISTORY:
        KeithMo     17-Mar-1992     Created for the Server Manager.

********************************************************************/
TRIPLE_SERVER_ENUM :: ~TRIPLE_SERVER_ENUM( VOID )
{
    delete _psrv;
    _psrv = NULL;

    delete _puser;
    _puser = NULL;

    delete _pmach;
    _pmach = NULL;

}   // TRIPLE_SERVER_ENUM :: ~TRIPLE_SERVER_ENUM


/*******************************************************************

    NAME:       TRIPLE_SERVER_ENUM :: CallAPI

    SYNOPSIS:   Invoke the necessary API(s) for the enumeration.

    ENTRY:      ppbBuffer               - Pointer to a pointer to
                                          the enumeration buffer.

                pcEntriesRead           - Will receive the number
                                          of enumeration entries read.

    RETURNS:    APIERR                  - Any error encountered.

    NOTES:      TRIPLE_SERVER_ENUM is rather unique among the LMOBJ
                enumerators in that it must invoke three separate
                API to retrieve the enumeration data.  Also, during
                the operation of the CallAPI() method, numerous
                buffers will be allocated and freed.  There are
                many places where errors may occur.  Thus, a single
                return status does little more than point the app
                in the general direction of the error.

    HISTORY:
        KeithMo     17-Mar-1992     Created for the Server Manager.

********************************************************************/
APIERR TRIPLE_SERVER_ENUM :: CallAPI( BYTE ** ppbBuffer,
                                      UINT  * pcEntriesRead )
{
    TRACEEOL( "In TRIPLE_SERVER_ENUM::CallAPI()" );

    //
    //  We'll need the following buffers.
    //

    BUFFER bufNtServers;
    BUFFER bufLmServers;
    BUFFER bufKnownServers;
    BUFFER bufBrowserServers;

    APIERR err = NERR_Success;

    if( ( ( err = bufNtServers.QueryError()      ) != NERR_Success ) ||
        ( ( err = bufLmServers.QueryError()      ) != NERR_Success ) ||
        ( ( err = bufKnownServers.QueryError()   ) != NERR_Success ) ||
        ( ( err = bufBrowserServers.QueryError() ) != NERR_Success ) )
    {
        return err;
    }

    //
    //  Various counters we'll need often.
    //

    UINT cNtServers      = 0;
    UINT cLmServers      = 0;
    UINT cKnownServers   = 0;
    UINT cBrowserServers = 0;
    UINT cAllServers     = 0;

    if( _fIsNtPrimary && _fPDCAvailable )
    {
        TRACEEOL( "Building NT Server List" );

#if FORCE_PDC
        //
        //  Setup a "fake" DOMAIN_DISPLAY_MACHINE for the PDC
        //  (in case we need to manually insert it in the list).
        //

        _ddm.Index          = 0L;   // not used
        _ddm.Rid            = 0L;   // not used
        _ddm.AccountControl = USER_SERVER_TRUST_ACCOUNT;
        _ddm.Comment.Buffer = NULL; // not used
        _ddm.Comment.Length = 0;    // not used
        _ddm.Machine.Buffer = (PWSTR)_pszPrimaryNoWhacks;
        _ddm.Machine.Length = _nlsPrimaryName.QueryTextSize() - (2*sizeof(TCHAR));
#endif  // FORCE_PDC

        //
        //  Create an ADMIN_AUTHORITY so we can connect to the
        //  Primary's SAM database.
        //

        ADMIN_AUTHORITY adminauth( _nlsPrimaryName.QueryPch() );

        err = adminauth.QueryError();

        if( err == NERR_Success )
        {
            //
            //  Create our NT enumerator.
            //

            _pmach = new NT_MACHINE_ENUM( adminauth.QueryAccountDomain() );

            err = ( _pmach == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                     : _pmach->GetInfo();
        }

        if( err == NERR_Success )
        {
            cNtServers = _pmach->QueryTotalItemCount();

            err = bufNtServers.Resize( ( cNtServers + 1 ) *
                                       sizeof(NT_MACHINE_ENUM_OBJ *) );
        }

        if( err == NERR_Success )
        {
            const DOMAIN_DISPLAY_MACHINE ** ppddm =
                    (const DOMAIN_DISPLAY_MACHINE **)bufNtServers.QueryPtr();

            const NT_MACHINE_ENUM_OBJ * pobj;
            NT_MACHINE_ENUM_ITER iter( *_pmach );

#if FORCE_PDC
            BOOL fPDCInList = FALSE;
#endif  // FORCE_PDC

            while( ( pobj = iter( &err ) ) != NULL )
            {
                if( ( ALLOW_WKSTAS && IS_WKSTA_TRUST( pobj->QueryAccountCtrl() ) ) ||
                    ( ALLOW_SERVERS && IS_SERVER_TRUST( pobj->QueryAccountCtrl() ) ) )
                {
                    *ppddm++ = pobj->QueryBufferPtr();

                    //
                    //  Strip the trailing '$' from the machine name.
                    //

                    TCHAR * pchName = (TCHAR *)pobj->QueryUnicodeMachine()->Buffer;
                    TCHAR * pchTmp  = pchName
                                      + ( pobj->QueryUnicodeMachine()->Length /
                                          sizeof(TCHAR) )
                                      - 1;

                    UIASSERT( *pchTmp == TCH('$') );
                    *pchTmp = TCH('\0');

#if FORCE_PDC
                    if( IS_SERVER_TRUST( pObj->QueryAccountCtrl() ) &&
                        ALLOW_SERVERS &&
                        !fPDCInList )
                    {
                        //
                        //  We're allowing servers, and the PDC is not
                        //  yet in the list.
                        //
                        //  See if the current enumeration object *is*
                        //  the PDC.
                        //

                        INT cmp = ::strcmpf( _pszPrimaryNoWhacks, pchName );

                        if( cmp == 0 )
                        {
                            //
                            //  This is the PDC, therefore it's already
                            //  in the list.
                            //

                            fPDCInList = TRUE;
                        }
                        else
                        if( cmp < 0 )
                        {
                            //
                            //  The current enum object is > than the PDC,
                            //  so we know it *isn't* in the list.  So
                            //  add it.
                            //

                            *ppddm++ = &_ddm;
                            cNtServers++;
                            fPDCInList = TRUE;
                        }
                    }
#endif  // FORCE_PDC

                }
                else
                {
                    cNtServers--;
                }
            }

#if FORCE_PDC
            if( ALLOW_SERVERS && !fPDCInList )
            {
                //
                //  The PDC was not in the list, so add it.
                //
                //  This is necessary for cases in which the PDC should
                //  be the *last* machine account returned from SAM.
                //

                *ppddm++ = &_ddm;
                cNtServers++;
                fPDCInList = TRUE;
            }
#endif  // FORCE_PDC

        }

        if( err == NERR_Success )
        {
            ::qsort( (void *)bufNtServers.QueryPtr(),
                     (size_t)cNtServers,
                     sizeof(DOMAIN_DISPLAY_MACHINE *),
                     &TRIPLE_SERVER_ENUM::CompareNtServers );
        }
    }

    if( ALLOW_SERVERS && _fPDCAvailable )
    {
        //
        //  Create our LM enumerator.
        //

        TRACEEOL( "Building LM Server List" );

        if( err == NERR_Success )
        {
            _puser = new USER0_ENUM( _nlsPrimaryName.QueryPch(),
                                     SZ("SERVERS"), TRUE );

            err = ( _puser == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                     : _puser->GetInfo();
        }

        if( err == NERR_GroupNotFound )
        {
            //
            //  If the group doesn't exist, then there obviously
            //  aren't any servers in the group.  Just pretend
            //  that it never happened.
            //

            err = NERR_Success;
        }
        else
        {
            if( err == NERR_Success )
            {
                cLmServers = _puser->QueryTotalItemCount();

                err = bufLmServers.Resize( cLmServers * sizeof(USER0_ENUM_OBJ *) );
            }

            if( err == NERR_Success )
            {
                const struct user_info_0 ** ppui0 =
                        (const struct user_info_0 **)bufLmServers.QueryPtr();

                const USER0_ENUM_OBJ * pobj;
                USER0_ENUM_ITER iter( *_puser );

                while( ( pobj = iter( &err ) ) != NULL )
                {
                    if ( err != NERR_Success )
                        break;

                    *ppui0 = pobj->QueryBufferPtr();

                    TCHAR * pszTmp = (TCHAR *)(*ppui0)->usri0_name;

                    REQUIRE( ::I_MNetNameCanonicalize(
                                    NULL,
                                    pszTmp,
                                    pszTmp,
                                    ( ::strlenf( pszTmp ) + 1 ) * sizeof(TCHAR),
                                    NAMETYPE_COMPUTER,
                                    0 ) == NERR_Success );

                    ppui0++;
                }
            }

            if( err == NERR_Success )
            {
                ::qsort( (void *)bufLmServers.QueryPtr(),
                         (size_t)cLmServers,
                         sizeof(struct user_info_0 *),
                         &TRIPLE_SERVER_ENUM::CompareLmServers );
            }
        }
    }

    //
    //  Merge the NT servers and LM servers into the Known Servers list.
    //

    TRACEEOL( "Merging NT and LM Server List into Known Server List" );

    if( err == NERR_Success )
    {
        cKnownServers = cNtServers + cLmServers;

        err = bufKnownServers.Resize( cKnownServers * sizeof(KNOWN_SERVER_INFO) );
    }

    if( err == NERR_Success )
    {
        const DOMAIN_DISPLAY_MACHINE ** ppddm =
                (const DOMAIN_DISPLAY_MACHINE **)bufNtServers.QueryPtr();

        const struct user_info_0 ** ppui0 =
                (const struct user_info_0 **)bufLmServers.QueryPtr();

        KNOWN_SERVER_INFO * pKnown =
                (KNOWN_SERVER_INFO *)bufKnownServers.QueryPtr();

        UINT cNtTmp = cNtServers;
        UINT cLmTmp = cLmServers;

        while( ( cNtTmp > 0 ) || ( cLmTmp > 0 ) )
        {
            if( cNtTmp == 0 )
            {
                MapLmToKnown( *ppui0++, pKnown++ );
                cLmTmp--;
            }
            else
            if( cLmTmp == 0 )
            {
                MapNtToKnown( *ppddm++, pKnown++ );
                cNtTmp--;
            }
            else
            {
                NT_MACHINE_ENUM_OBJ NtObj;
                NtObj.SetBufferPtr( *ppddm );

                USER0_ENUM_OBJ LmObj;
                LmObj.SetBufferPtr( *ppui0 );

                INT result =
                       ::strcmpf( (TCHAR *)NtObj.QueryUnicodeMachine()->Buffer,
                                  LmObj.QueryName() );

                if( result < 0 )
                {
                    MapNtToKnown( *ppddm++, pKnown++ );
                    cNtTmp--;
                }
                else
                if( result > 0 )
                {
                    MapLmToKnown( *ppui0++, pKnown++ );
                    cLmTmp--;
                }
                else
                {
                    //
                    //  The same machine is in the SAM list *and*
                    //  the SERVERS group.  This probably indicates
                    //  the machine dual-boots NT and OS/2.  We'll
                    //  assume it's NT unless the browser indicates
                    //  otherwise.
                    //

                    MapNtToKnown( *ppddm++, pKnown++ );
                    cNtTmp--;
                    ppui0++;
                    cLmTmp--;
                    cKnownServers--;
                }
            }
        }
    }

    //
    //  We've finally got a list of known servers.  Now we
    //  can enumerate from the Browser and sort that list.
    //

    TRACEEOL( "Building BROWSER Server List" );

    if( err == NERR_Success && !_fAccountsOnly )
    {
        ULONG flServerTypes = SV_TYPE_ALL;

#if 0
        //
        //  This was a good idea; unfortunately, it won't
        //  pick up non-DC LM Servers.
        //

        if( ALLOW_SERVERS && !ALLOW_WKSTAS )
        {
            flServerTypes = SV_TYPE_DOMAIN_CTRL | SV_TYPE_DOMAIN_BAKCTRL;
        }
        else
        {
            flServerTypes = SV_TYPE_ALL;
        }
#endif

        _psrv = new SERVER1_ENUM( NULL,
                                  _nlsDomainName.QueryPch(),
                                  flServerTypes );

        err = ( _psrv == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                : _psrv->GetInfo();

        if( err == NERR_Success )
        {
            cBrowserServers = _psrv->QueryCount();
            err = bufBrowserServers.Resize( cBrowserServers *
                                                sizeof(SERVER1_ENUM_OBJ *) );
        }
        else
        {
            //
            //  NetServerEnum failed.
            //

            cBrowserServers = 0;
            err = NERR_Success;
        }
    }

    if( ( err == NERR_Success ) && ( cBrowserServers > 0 ) )
    {
        const struct server_info_1 ** ppsi1 =
                (const struct server_info_1 **)bufBrowserServers.QueryPtr();

        const SERVER1_ENUM_OBJ * pobj;
        SERVER1_ENUM_ITER iter( *_psrv );

        while( ( pobj = iter() ) != NULL )
        {
            ULONG TypeMask = pobj->QueryServerType();

            //
            // JonN 7/6/95:  Note that we allow workstations to slip through
            // into the browser list even if !ALLOW_WKSTAS.  This is because
            // a "DeadPrimary" machine will register as a workstation to the
            // browser and we still want to be able to identify it as a
            // DeadPrimary.
            //
            if( ( IS_WKSTA( TypeMask ) && !IS_LM_SERVER( TypeMask ) ) ||
                ( ALLOW_SERVERS && IS_LM_SERVER( TypeMask ) ) ||
                ( ALLOW_SERVERS && IS_BACKUP( TypeMask ) ) ||
                ( ALLOW_SERVERS && IS_SERVER( TypeMask ) ) ||
                ( ALLOW_SERVERS && IS_PRIMARY( TypeMask ) ) )
            {
                *ppsi1++ = pobj->QueryBufferPtr();
            }
            else
            {
                cBrowserServers--;
            }
        }
    }

    if( ( err == NERR_Success ) && ( cBrowserServers > 0 ) )
    {
        ::qsort( (void *)bufBrowserServers.QueryPtr(),
                 (size_t)cBrowserServers,
                 sizeof(struct server_info_1 *),
                 &TRIPLE_SERVER_ENUM::CompareBrowserServers );
    }

    //
    //  Now (finally...) merge the known servers list with the
    //  browser server list.
    //

    TRACEEOL( "Merging Known Server and BROWSER Lists into ALL Server List" );

    TRIPLE_SERVER_INFO * p3srv;

    if( err == NERR_Success )
    {
        cAllServers = cKnownServers + cBrowserServers;

        if( cAllServers > 0 )
        {
            p3srv = (TRIPLE_SERVER_INFO *)
                        ::MNetApiBufferAlloc( cAllServers *
                                              sizeof(TRIPLE_SERVER_INFO) );

            if( p3srv == NULL )
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        else
        {
            p3srv = NULL;
        }
    }

    if( err == NERR_Success )
    {
        //
        //  Return the buffer pointer to LM_ENUM.
        //

        *ppbBuffer = (BYTE *)p3srv;

        const struct server_info_1 ** ppsi1 =
                (const struct server_info_1 **)bufBrowserServers.QueryPtr();

        KNOWN_SERVER_INFO * pKnown =
                (KNOWN_SERVER_INFO *)bufKnownServers.QueryPtr();

        UINT cKnownTmp   = cKnownServers;
        UINT cBrowserTmp = cBrowserServers;

        while( ( cKnownTmp > 0 ) || ( cBrowserTmp > 0 ) )
        {
            if( cBrowserTmp == 0 )
            {
                MapKnownToTriple( pKnown, p3srv );
                p3srv++;
                pKnown++;
                cKnownTmp--;
            }
            else
            if( cKnownTmp == 0 )
            {
                //
                // JonN 7/6/95:  Note that we allow workstations to slip through
                // into the browser list even if !ALLOW_WKSTAS.  This is because
                // a "DeadPrimary" machine will register as a workstation to the
                // browser and we still want to be able to identify it as a
                // DeadPrimary.
                // We repeat the validity test here since the machine cannot be
                // a DeadMachineCandidate since no known server was found.
                //

                ULONG TypeMask = (*ppsi1)->sv1_type;

                if( ( ALLOW_WKSTAS && IS_WKSTA( TypeMask ) && !IS_LM_SERVER( TypeMask ) ) ||
                    ( ALLOW_SERVERS && IS_LM_SERVER( TypeMask ) ) ||
                    ( ALLOW_SERVERS && IS_BACKUP( TypeMask ) ) ||
                    ( ALLOW_SERVERS && IS_SERVER( TypeMask ) ) ||
                    ( ALLOW_SERVERS && IS_PRIMARY( TypeMask ) ) )
                {
                    MapBrowserToTriple( *ppsi1, p3srv );
                    p3srv++;
                }
                else
                {
                    cAllServers--;
                }
                ppsi1++;
                cBrowserTmp--;
            }
            else
            {
                SERVER1_ENUM_OBJ ServerObj;
                ServerObj.SetBufferPtr( *ppsi1 );

                INT result = ::strcmpf( pKnown->pszName, ServerObj.QueryName() );

                if( result < 0 )
                {
                    MapKnownToTriple( pKnown, p3srv );
                    p3srv++;
                    pKnown++;
                    cKnownTmp--;
                }
                else
                if( result > 0 )
                {
                    //
                    // JonN 7/6/95:  Note that we allow workstations to slip through
                    // into the browser list even if !ALLOW_WKSTAS.  This is because
                    // a "DeadPrimary" machine will register as a workstation to the
                    // browser and we still want to be able to identify it as a
                    // DeadPrimary.
                    // We repeat the validity test here since the machine cannot be
                    // a DeadMachineCandidate since no known server was found.
                    //

                    ULONG TypeMask = (*ppsi1)->sv1_type;

                    if( ( ALLOW_WKSTAS && IS_WKSTA( TypeMask ) && !IS_LM_SERVER( TypeMask ) ) ||
                        ( ALLOW_SERVERS && IS_LM_SERVER( TypeMask ) ) ||
                        ( ALLOW_SERVERS && IS_BACKUP( TypeMask ) ) ||
                        ( ALLOW_SERVERS && IS_SERVER( TypeMask ) ) ||
                        ( ALLOW_SERVERS && IS_PRIMARY( TypeMask ) ) )
                    {
                        MapBrowserToTriple( *ppsi1, p3srv );
                        p3srv++;
                    }
                    else
                    {
                        cAllServers--;
                    }
                    ppsi1++;
                    cBrowserTmp--;
                }
                else
                {
                    //
                    // JonN 7/6/95:  Note that we allow workstations to slip through
                    // into the browser list even if !ALLOW_WKSTAS.  This is because
                    // a "DeadPrimary" machine will register as a workstation to the
                    // browser and we still want to be able to identify it as a
                    // DeadPrimary.
                    // We repeat the validity test here and remove the tripleobj
                    // retroactively if the browser object is invalid and
                    // the tripleobj is not a DeadMachine.
                    //

                    ULONG TypeMask = (*ppsi1)->sv1_type;

                    CombineIntoTriple( *ppsi1++, pKnown, p3srv );
                    cBrowserTmp--;
                    cAllServers--;
                    if( ( ALLOW_WKSTAS && IS_WKSTA( TypeMask ) && !IS_LM_SERVER( TypeMask ) ) ||
                        ( ALLOW_SERVERS && IS_LM_SERVER( TypeMask ) ) ||
                        ( ALLOW_SERVERS && IS_BACKUP( TypeMask ) ) ||
                        ( ALLOW_SERVERS && IS_SERVER( TypeMask ) ) ||
                        ( ALLOW_SERVERS && IS_PRIMARY( TypeMask ) ) ||
                        (      p3srv->ServerRole == DeadPrimaryRole
                            || p3srv->ServerRole == DeadBackupRole  ) )
                    {
                        // Either the browser object was valid, or the
                        // machine is DeadPrimary or DeadBackup.  Leave the
                        // tripleobj alone.
                    }
                    else
                    {
                        // The browser object was invalid and the machine
                        // is neither a DeadPrimary nor DeadBackup.  Remap
                        // the tripleobj using just the KNOWN_SERVER_INFO.

                        MapKnownToTriple( pKnown, p3srv );
                    }
                    pKnown++;
                    cKnownTmp--;
                    p3srv++;
                }
            }
        }
    }

    if( err == NERR_Success )
    {
        *pcEntriesRead = cAllServers;
    }

    return err;

}   // TRIPLE_SERVER_ENUM :: CallAPI


/*******************************************************************

    NAME:       TRIPLE_SERVER_ENUM :: MapNtToKnown

    SYNOPSIS:   Takes a DOMAIN_DISPLAY_MACHINE and maps the appropriate
                fields to KNOWN_SERVER_INFO.

    ENTRY:      pddm                    - Points to a DOMAIN_DISPLAY_MACHINE
                                          representing the source server.

                pKnownObj               - Points to a KNOWN_SERVER_INFO
                                          representing the destination.

    HISTORY:
        KeithMo     17-Mar-1992     Created for the Server Manager.

********************************************************************/
VOID TRIPLE_SERVER_ENUM :: MapNtToKnown(
                                    const DOMAIN_DISPLAY_MACHINE * pddm,
                                    KNOWN_SERVER_INFO            * pKnownObj )
{
    NT_MACHINE_ENUM_OBJ NtObj;
    NtObj.SetBufferPtr( pddm );

    //
    //  Migrate the various fields across.
    //

    pKnownObj->pszName    = (TCHAR *)(NtObj.QueryUnicodeMachine()->Buffer);
    pKnownObj->ServerType = InactiveNtServerType;

    //
    //  To determine if the source server is a primary, we must
    //  compare its name with the name of the primary for this
    //  domain.
    //

    BOOL fIsPrimary = FALSE;

    if( _fPDCAvailable )
    {
        fIsPrimary = ( ::strcmpf( (TCHAR *)NtObj.QueryUnicodeMachine()->Buffer,
                                  _pszPrimaryNoWhacks ) ) == 0;
    }

    if( fIsPrimary )
    {
        pKnownObj->ServerRole = PrimaryRole;
    }
    else
    if( IS_WKSTA_TRUST( NtObj.QueryAccountCtrl() ) )
    {
        pKnownObj->ServerRole = WkstaOrServerRole;
    }
    else
    if( IS_SERVER_TRUST( NtObj.QueryAccountCtrl() ) )
    {
        pKnownObj->ServerRole = BackupRole;
    }
    else
    {
        pKnownObj->ServerRole = UnknownRole;
    }

}   // TRIPLE_SERVER_ENUM :: MapNtToKnown


/*******************************************************************

    NAME:       TRIPLE_SERVER_ENUM :: MapLmToKnown

    SYNOPSIS:   Takes a user_info_0 and maps the appropriate
                fields to KNOWN_SERVER_INFO.

    ENTRY:      pui0                    - Points to a user_info_0 structure
                                          representing the source server.

                pKnownObj               - Points to a KNOWN_SERVER_INFO
                                          representing the destination.

    HISTORY:
        KeithMo     17-Mar-1992     Created for the Server Manager.

********************************************************************/
VOID TRIPLE_SERVER_ENUM :: MapLmToKnown(
                                    const struct user_info_0 * pui0,
                                    KNOWN_SERVER_INFO        * pKnownObj )
{
    USER0_ENUM_OBJ LmObj;
    LmObj.SetBufferPtr( pui0 );

    pKnownObj->pszName    = LmObj.QueryName();
    pKnownObj->ServerType = InactiveLmServerType;
    pKnownObj->ServerRole = BackupRole;

}   // TRIPLE_SERVER_ENUM :: MapLmToKnown


/*******************************************************************

    NAME:       TRIPLE_SERVER_ENUM :: MapKnownToTriple

    SYNOPSIS:   Takes a KNOWN_SERVER_INFO and maps the appropriate
                fields to TRIPLE_SERVER_INFO

    ENTRY:      pKnownObj               - Points to a KNOWN_SERVER_INFO
                                          representing the source server.

                pTripleObj              - Points to a TRIPLE_SERVER_INFO
                                          representing the destination.

    HISTORY:
        KeithMo     17-Mar-1992     Created for the Server Manager.

********************************************************************/
VOID TRIPLE_SERVER_ENUM :: MapKnownToTriple(
                                    const KNOWN_SERVER_INFO * pKnownObj,
                                    TRIPLE_SERVER_INFO      * pTripleObj )
{
    SERVER_ROLE role = pKnownObj->ServerRole;
    SERVER_TYPE type = pKnownObj->ServerType;

    if( _fPDCAvailable &&
        ( role != PrimaryRole ) &&
        ( ::strcmpf( _pszPrimaryNoWhacks, pKnownObj->pszName ) == 0 ) )
    {
        //
        //  The role for this known server was *not* Primary,
        //  but its name matches the name of the domain's PDC.
        //  Therefore, it must be the primary.
        //

        role = PrimaryRole;
    }

    if( ( role == PrimaryRole ) && _fPDCAvailable )
    {
        //
        //  Compensate for one of the NT Browser's
        //  many inadequacies...
        //

        if( type == InactiveNtServerType )
        {
            type = ActiveNtServerType;
        }
        else
        if( type == InactiveLmServerType )
        {
            type = ActiveLmServerType;
        }
    }

    pTripleObj->pszName    = pKnownObj->pszName;
    pTripleObj->pszComment = SZ("");
    pTripleObj->ServerType = type;
    pTripleObj->ServerRole = role;
    pTripleObj->verMajor   = 0;
    pTripleObj->verMinor   = 0;
    pTripleObj->TypeMask   = 0L;

}   // TRIPLE_SERVER_ENUM :: MapKnownToTriple


/*******************************************************************

    NAME:       TRIPLE_SERVER_ENUM :: MapBrowserToTriple

    SYNOPSIS:   Takes a server_info_1 and maps the appropriate
                fields to TRIPLE_SERVER_INFO

    ENTRY:      psi1                    - Points to a server_info_1 structure
                                          representing the source server.

                pTripleObj              - Points to a TRIPLE_SERVER_INFO
                                          representing the destination.

    HISTORY:
        KeithMo     17-Mar-1992     Created for the Server Manager.

********************************************************************/
VOID TRIPLE_SERVER_ENUM :: MapBrowserToTriple(
                                    const struct server_info_1 * psi1,
                                    TRIPLE_SERVER_INFO         * pTripleObj )
{
    SERVER1_ENUM_OBJ ServerObj;
    ServerObj.SetBufferPtr( psi1 );

    ULONG TypeMask = ServerObj.QueryServerType();

    pTripleObj->pszName    = ServerObj.QueryName();
    pTripleObj->pszComment = ServerObj.QueryComment();
    pTripleObj->verMajor   = ServerObj.QueryMajorVer();
    pTripleObj->verMinor   = ServerObj.QueryMinorVer();
    pTripleObj->TypeMask   = TypeMask;

    pTripleObj->ServerType = MapTypeMaskToType( TypeMask );
    pTripleObj->ServerRole = MapTypeMaskToRole( TypeMask );

    if( _fPDCAvailable &&
        ( ::strcmpf( _pszPrimaryNoWhacks, pTripleObj->pszName ) == 0 ) )
    {
        //
        //  This is the PDC.  Ensure the other data is set correctly.
        //

        pTripleObj->ServerRole  = PrimaryRole;
        pTripleObj->TypeMask   &= ~SV_TYPE_DOMAIN_BAKCTRL;
        pTripleObj->TypeMask   |=  SV_TYPE_DOMAIN_CTRL;
    }
    else
    {
        if( pTripleObj->ServerRole == PrimaryRole )
        {
            //
            //  The browser has told us that this machine is
            //  a primary, but we *know* it isn't.  Either the
            //  PDC is not available, or the names don't match.
            //  This generally indicates that the browser is
            //  giving us stale data.  In any case, this machine
            //  is definitely *not* the real PDC.  We'll assume
            //  it's a Server.
            //

            pTripleObj->ServerRole  = BackupRole;
            pTripleObj->TypeMask   &= ~SV_TYPE_DOMAIN_CTRL;
            pTripleObj->TypeMask   |=  SV_TYPE_DOMAIN_BAKCTRL;
        }
    }

}   // TRIPLE_SERVER_ENUM :: MapBrowserToTriple


/*******************************************************************

    NAME:       TRIPLE_SERVER_ENUM :: CombineIntoTriple

    SYNOPSIS:   Takes a server_info_1 and a KNOWN_SERVER_INFO and
                maps the appropriate fields to TRIPLE_SERVER_INFO

    ENTRY:      psi1                    - Points to a server_info_1 structure
                                          representing the source server.

                pKnownObj               - Points to a KNOWN_SERVER_INFO
                                          also representing the source
                                          server.

                pTripleObj              - Points to a TRIPLE_SERVER_INFO
                                          representing the destination.

    HISTORY:
        KeithMo     17-Mar-1992     Created for the Server Manager.

********************************************************************/
VOID TRIPLE_SERVER_ENUM :: CombineIntoTriple(
                                    const struct server_info_1 * psi1,
                                    const KNOWN_SERVER_INFO    * pKnownObj,
                                    TRIPLE_SERVER_INFO         * pTripleObj )
{
    //
    //  We'll let MapBrowserToTriple do most of the grunt work.
    //

    MapBrowserToTriple( psi1, pTripleObj );

    BOOL fDeadMachineCandidate = FALSE; // until proven otherwise

    if( _fIsNtPrimary && _fPDCAvailable &&
        IS_NT_SERVER( pTripleObj->TypeMask ) )
    {
        //
        //  Determine if this is a "dead" primary or server.
        //

        if( ( pKnownObj->ServerRole == BackupRole ) &&
            IS_WKSTA( pTripleObj->TypeMask ) )
        {
            //
            //  The machine had a SAM server trust account, but
            //  is broadcasting like a workstation.  This indicates
            //  that the machine is setup as a primary or server, but
            //  its NETLOGON service is not running.  It might be
            //  a dead primary or server.
            //

            fDeadMachineCandidate = TRUE;
        }
    }

    if( fDeadMachineCandidate )
    {
        //
        //  We've found a system that might be a dead primary or server.
        //  To verify, we'll query the machines domain role.
        //  If the role is primary, then we've found a dead one.
        //

        //
        //  CODEWORK:  We need LMOBJ support for this!
        //

        ISTACK_NLS_STR( nlsUNC, MAX_PATH, SZ("\\\\") );
        UIASSERT( !!nlsUNC );
        ALIAS_STR nlsBare( pTripleObj->pszName );
        UIASSERT( !!nlsBare );
        nlsUNC.strcat( nlsBare );
        UIASSERT( !!nlsUNC );

        struct user_modals_info_1 * pumi1 = NULL;

        //
        //  Setup a (potentially NULL) session to the target
        //  server.  This will be necessary if the NetLogon
        //  service is not running on the target server.
        //

        API_SESSION apisess( nlsUNC );

        APIERR err = apisess.QueryError();

        if( err == NERR_Success )
        {
            err = ::MNetUserModalsGet( nlsUNC, 1, (BYTE **)&pumi1 );
        }

        if( err == NERR_Success )
        {
            if( pumi1->usrmod1_role == UAS_ROLE_PRIMARY )
            {
                //
                //  It's a dead primary.
                //

                pTripleObj->ServerRole = DeadPrimaryRole;
            }
            else
            if( pumi1->usrmod1_role == UAS_ROLE_BACKUP )
            {
                //
                //  It's a dead server.
                //

                pTripleObj->ServerRole = DeadBackupRole;
            }

            //
            //  Free the API buffer.
            //

            ::MNetApiBufferFree( (BYTE **)&pumi1 );
        }
    }

}   // TRIPLE_SERVER_ENUM :: CombineIntoTriple


/*******************************************************************

    NAME:       TRIPLE_SERVER_ENUM :: CompareNtServers

    SYNOPSIS:   This static method is called by the ::qsort() standard
                library function.  This method will compare two
                NT_MACHINE_ENUM_OBJ objects.

    ENTRY:      p1                      - The "left" object.

                p2                      - The "right" object.

    RETURNS:    int                     - -1 if p1  < p2
                                           0 if p1 == p2
                                          +1 if p1  > p2

    HISTORY:
        KeithMo     17-Mar-1992     Created for the Server Manager.

********************************************************************/
int __cdecl TRIPLE_SERVER_ENUM :: CompareNtServers( const void * p1,
                                                     const void * p2 )
{
    NT_MACHINE_ENUM_OBJ Obj1;
    NT_MACHINE_ENUM_OBJ Obj2;

    Obj1.SetBufferPtr( *((const DOMAIN_DISPLAY_MACHINE **)p1) );
    Obj2.SetBufferPtr( *((const DOMAIN_DISPLAY_MACHINE **)p2) );

    //
    //  We can use the UNICODE machine name since it's already
    //  been NULL terminated.
    //

    return ::strcmpf( (TCHAR *)Obj1.QueryUnicodeMachine()->Buffer,
                      (TCHAR *)Obj2.QueryUnicodeMachine()->Buffer );

}   // TRIPLE_SERVER_ENUM :: CompareNtServers


/*******************************************************************

    NAME:       TRIPLE_SERVER_ENUM :: CompareLmServers

    SYNOPSIS:   This static method is called by the ::qsort() standard
                library function.  This method will compare two
                USER0_ENUM_OBJ objects.

    ENTRY:      p1                      - The "left" object.

                p2                      - The "right" object.

    RETURNS:    int                     - -1 if p1  < p2
                                           0 if p1 == p2
                                          +1 if p1  > p2

    HISTORY:
        KeithMo     17-Mar-1992     Created for the Server Manager.

********************************************************************/
int __cdecl TRIPLE_SERVER_ENUM :: CompareLmServers( const void * p1,
                                                     const void * p2 )
{
    USER0_ENUM_OBJ Obj1;
    USER0_ENUM_OBJ Obj2;

    Obj1.SetBufferPtr( *((const struct user_info_0 **)p1) );
    Obj2.SetBufferPtr( *((const struct user_info_0 **)p2) );

    return ::strcmpf( Obj1.QueryName(), Obj2.QueryName() );

}   // TRIPLE_SERVER_ENUM :: CompareLmServers


/*******************************************************************

    NAME:       TRIPLE_SERVER_ENUM :: CompareBrowserServers

    SYNOPSIS:   This static method is called by the ::qsort() standard
                library function.  This method will compare two
                SERVER1_ENUM_OBJ objects.

    ENTRY:      p1                      - The "left" object.

                p2                      - The "right" object.

    RETURNS:    int                     - -1 if p1  < p2
                                           0 if p1 == p2
                                          +1 if p1  > p2

    HISTORY:
        KeithMo     17-Mar-1992     Created for the Server Manager.

********************************************************************/
int __cdecl TRIPLE_SERVER_ENUM :: CompareBrowserServers( const void * p1,
                                                          const void * p2 )
{
    SERVER1_ENUM_OBJ Obj1;
    SERVER1_ENUM_OBJ Obj2;

    Obj1.SetBufferPtr( *((const struct server_info_1 **)p1) );
    Obj2.SetBufferPtr( *((const struct server_info_1 **)p2) );

    return ::strcmpf( Obj1.QueryName(), Obj2.QueryName() );

}   // TRIPLE_SERVER_ENUM :: CompareBrowserServers


/*******************************************************************

    NAME:       TRIPLE_SERVER_ENUM :: MapTypeMaskToRole

    SYNOPSIS:   Maps a server type mask (such as return from the
                browser) to a SERVER_ROLE enum.

    ENTRY:      TypeMask                - The server type mask.

    RETURNS:    SERVER_ROLE             - The role represented by the mask.

    HISTORY:
        KeithMo     05-Oct-1992     Created.

********************************************************************/
SERVER_ROLE TRIPLE_SERVER_ENUM :: MapTypeMaskToRole( ULONG TypeMask ) const
{
    SERVER_ROLE role;

    if( IS_WFW_SERVER( TypeMask ) )
    {
        //
        //  Winball machines are always workstations.
        //

        role = WkstaRole;
    }
    else
    if( IS_PRIMARY( TypeMask ) )
    {
        //
        //  A primary is a primary is a primary.
        //

        role = PrimaryRole;
    }
    else
    if( ( TypeMask & SV_TYPE_DOMAIN_BAKCTRL ) )
    {
        role = BackupRole;
    }
    else
    if ( IS_SERVER( TypeMask ) )
    {
        role = ServerRole;
    }
    else
    if( IS_LM_SERVER( TypeMask ) )
    {
        //
        //  All LanMan machines that isn't a BDC.
        //

        role = LmServerRole;
    }
    else
    {
        //
        //  Everything else is just a workstation.
        //

        role = WkstaRole;
    }

    return role;

}   // TRIPLE_SERVER_ENUM :: MapTypeMaskToRole


/*******************************************************************

    NAME:       TRIPLE_SERVER_ENUM :: MapTypeMaskToType

    SYNOPSIS:   Maps a server type mask (such as return from the
                browser) to a SERVER_TYPE enum.

    ENTRY:      TypeMask                - The server type mask.

    RETURNS:    SERVER_TYPE             - The role represented by the mask.

    HISTORY:
        KeithMo     05-Oct-1992     Created.

********************************************************************/
SERVER_TYPE TRIPLE_SERVER_ENUM :: MapTypeMaskToType( ULONG TypeMask ) const
{
    SERVER_TYPE type;

    if( IS_NT_SERVER( TypeMask ) )
    {
        //
        //  It's an NT server.
        //

        type = ActiveNtServerType;
    }
    else
    if( IS_WIN95_SERVER( TypeMask ) )
    {
        //
        //  It's a Windows95 server.  This takes precedence over WFW.
        //

        type = Windows95ServerType;
    }
    else
    if( IS_WFW_SERVER( TypeMask ) )
    {
        //
        //  It's a Winball server.
        //

        type = WfwServerType;
    }
    else
    {
        //
        //  Otherwise, assume it's LanMan.
        //

        type = ActiveLmServerType;
    }

    return type;

}   // TRIPLE_SERVER_ENUM :: MapTypeMaskToType


DEFINE_LM_ENUM_ITER_OF( TRIPLE_SERVER, TRIPLE_SERVER_INFO );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmoenum\lmoesrv.cxx ===
/*****************************************************************/
/**		     Microsoft LAN Manager			**/
/**	       Copyright(c) Microsoft Corp., 1991		**/
/*****************************************************************/

/*
 *  HISTORY:
 *	RustanL     03-Jan-1991     Created
 *	RustanL     10-Jan-1991     Added SERVER1 subclass and iterator
 *	beng	    11-Feb-1991     Uses lmui.hxx
 *	KeithMo	    21-Oct-1991	    Remove INCL_WINDOWS, enhanced WIN32.
 *
 */

#include "pchlmobj.hxx"

/*****************************	SERVER_ENUM  ******************************/


/**********************************************************\

   NAME:       SERVER_ENUM::SERVER_ENUM

   SYNOPSIS:   server_enum constructor

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
   	RustanL     03-Jan-1991     Created

\**********************************************************/

SERVER_ENUM::SERVER_ENUM( const TCHAR * pszServer,
			  UINT	       uLevel,
			  const TCHAR * pszDomain,
			  ULONG        flServerType )
  : LOC_LM_ENUM( pszServer, uLevel ),
    _nlsDomain( pszDomain ),
    _flServerType( flServerType )
{
    UIASSERT( uLevel == 1 );	// only supports level 1 at this time

    if( QueryError() != NERR_Success )
    {
    	return;
    }

    if( !_nlsDomain )
    {
	ReportError( _nlsDomain.QueryError() );
    	return;
    }

}  // SERVER_ENUM::SERVER_ENUM



/**********************************************************\

   NAME:       SERVER_ENUM::CallAPI

   SYNOPSIS:   server enum call api

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
   	RustanL     03-Jan-1991     Created

\**********************************************************/

APIERR SERVER_ENUM::CallAPI( BYTE ** ppbBuffer,
			     UINT  * pcEntriesRead )
{
    UIASSERT( QueryInfoLevel() == 1 );	    // only level support at the time

    return ::MNetServerEnum( QueryServer(),
			     SERVER_INFO_LEVEL( QueryInfoLevel() ),
			     ppbBuffer,
			     pcEntriesRead,
			     _flServerType,
			     (TCHAR *)_nlsDomain.QueryPch() );

}  // SERVER_ENUM::CallAPI



/*****************************	SERVER1_ENUM  ******************************/


/**********************************************************\

   NAME:       SERVER1_ENUM::SERVER1_ENUM

   SYNOPSIS:   server enum 1 constructor

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
   	RustanL     03-Jan-1991     Created

\**********************************************************/

SERVER1_ENUM::SERVER1_ENUM( const TCHAR * pszServer,
			    const TCHAR * pszDomain,
			    ULONG	 flServerType )
  : SERVER_ENUM( pszServer, 1, pszDomain, flServerType )
{
    // do nothing else

}  // SERVER1_ENUM::SERVER1_ENUM



/*******************************************************************

    NAME:	SERVER1_ENUM_OBJ :: SetBufferPtr

    SYNOPSIS:	Saves the buffer pointer for this enumeration object.

    ENTRY:	pBuffer			- Pointer to the new buffer.

    EXIT:	The pointer has been saved.

    NOTES:	Will eventually handle OemToAnsi conversions.

    HISTORY:
	KeithMo	    09-Oct-1991	    Created.

********************************************************************/
#ifdef WIN32

VOID SERVER1_ENUM_OBJ :: SetBufferPtr( const SERVER_INFO_101 * pBuffer )

#else	// !WIN32

VOID SERVER1_ENUM_OBJ :: SetBufferPtr( const struct server_info_1 * pBuffer )

#endif	// WIN32
{
    ENUM_OBJ_BASE :: SetBufferPtr( (const BYTE *)pBuffer );

}   // SERVER1_ENUM_OBJ :: SetBufferPtr


#ifdef WIN32

DEFINE_LM_ENUM_ITER_OF( SERVER1, SERVER_INFO_101 );

#else	// !WIN32

DEFINE_LM_ENUM_ITER_OF( SERVER1, struct server_info_1 );

#endif	// WIN32


/*****************************	CONTEXT_ENUM  ******************************/
/*
 * BUGBUG   Ideally, this should be derived from SERVER1_ENUM, but that
 *          class must first allow overriding the CallAPI method.
 */

/**********************************************************\

   NAME:       CONTEXT_ENUM::CONTEXT_ENUM

   SYNOPSIS:   CONTEXT_ENUM constructor

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        AnirudhS    22-Mar-1995     Created

\**********************************************************/

CONTEXT_ENUM::CONTEXT_ENUM( ULONG        flServerType )
  : LOC_LM_ENUM( NULL, 1 ),     // server and info level
    _flServerType( flServerType )
{
    if( QueryError() != NERR_Success )
    {
    	return;
    }

}  // CONTEXT_ENUM::CONTEXT_ENUM



/**********************************************************\

   NAME:       CONTEXT_ENUM::CallAPI

   SYNOPSIS:   server enum call api

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        AnirudhS    22-Mar-1995     Created

\**********************************************************/

APIERR CONTEXT_ENUM::CallAPI( BYTE ** ppbBuffer,
			     UINT  * pcEntriesRead )
{
    UIASSERT( QueryInfoLevel() == 1 );	    // only level support at the time

    return ::MNetServerEnum( NULL,
			     SERVER_INFO_LEVEL( QueryInfoLevel() ),
			     ppbBuffer,
			     pcEntriesRead,
			     _flServerType,
			     NULL );

}  // CONTEXT_ENUM::CallAPI



/*******************************************************************

    NAME:	CONTEXT_ENUM_OBJ :: SetBufferPtr

    SYNOPSIS:	Saves the buffer pointer for this enumeration object.

    ENTRY:	pBuffer			- Pointer to the new buffer.

    EXIT:	The pointer has been saved.

    NOTES:	Will eventually handle OemToAnsi conversions.

    HISTORY:
        AnirudhS    22-Mar-1995     Created

********************************************************************/

VOID CONTEXT_ENUM_OBJ :: SetBufferPtr( const SERVER_INFO_101 * pBuffer )
{
    ENUM_OBJ_BASE :: SetBufferPtr( (const BYTE *)pBuffer );

}   // CONTEXT_ENUM_OBJ :: SetBufferPtr


DEFINE_LM_ENUM_ITER_OF( CONTEXT, SERVER_INFO_101 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmoenum\lmoetd.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    lmoetd.cxx

    This file contains the class definitions for the TRUSTED_DOMAIN_ENUM
    class and its associated iterator classes.


    FILE HISTORY:
        KeithMo     09-Apr-1992     Created for the Server Manager.

*/

#include "pchlmobj.hxx"


//
//  The manifest TOTAL_BYTES_REQUESTED gives the number of BYTEs we request
//  from the server on each call to the trusted domain enumeration API.
//

#define TOTAL_BYTES_REQUESTED   0x0001FFFF



//
//  TRUSTED_DOMAIN_ENUM methods.
//

/*******************************************************************

    NAME:       TRUSTED_DOMAIN_ENUM :: TRUSTED_DOMAIN_ENUM

    SYNOPSIS:   TRUSTED_DOMAIN_ENUM class constructor.

    ENTRY:      plsapolicy              - A pointer to a properly constructed
                                          LSA_POLICY object representing the
                                          target server (usually a PDC).

                fKeepBuffers            - If TRUE then LM_RESUME_ENUM
                                          will keep a list of all buffers
                                          created by CallAPI.

    HISTORY:
        KeithMo     09-Apr-1992     Created for the Server Manager.

********************************************************************/
TRUSTED_DOMAIN_ENUM :: TRUSTED_DOMAIN_ENUM( const LSA_POLICY * plsapolicy,
                                            BOOL               fKeepBuffers )
  : LM_RESUME_ENUM( 0, fKeepBuffers ),
    _plsapolicy( plsapolicy ),
    _ResumeKey( (LSA_ENUMERATION_HANDLE)0 ),
    _lsatim()
{
    UIASSERT( plsapolicy != NULL );
    UIASSERT( plsapolicy->QueryError() == NERR_Success );

    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_lsatim )
    {
        ReportError( _lsatim.QueryError() );
        return;
    }

}  // TRUSTED_DOMAIN_ENUM :: TRUSTED_DOMAIN_ENUM


/*******************************************************************

    NAME:       TRUSTED_DOMAIN_ENUM :: ~TRUSTED_DOMAIN_ENUM

    SYNOPSIS:   TRUSTED_DOMAIN_ENUM class destructor.

    HISTORY:
        KeithMo     09-Apr-1992     Created for the Server Manager.

********************************************************************/
TRUSTED_DOMAIN_ENUM :: ~TRUSTED_DOMAIN_ENUM()
{
    NukeBuffers();

    _plsapolicy = NULL;
    _ResumeKey  = (LSA_ENUMERATION_HANDLE)0;

}   // TRUSTED_DOMAIN_ENUM :: ~TRUSTED_DOMAIN_ENUM()


/*******************************************************************

    NAME:       TRUSTED_DOMAIN_ENUM :: FreeBuffer

    SYNOPSIS:   Frees the enumeration buffer.

    ENTRY:      ppbBuffer               - Points to a pointer to the
                                          enumeration buffer.

    HISTORY:
        KeithMo     09-Apr-1992     Created for the Server Manager.

********************************************************************/
VOID TRUSTED_DOMAIN_ENUM :: FreeBuffer( BYTE ** ppbBuffer )
{
    UIASSERT( ppbBuffer != NULL );
    UIASSERT( *ppbBuffer == (BYTE *)_lsatim.QueryPtr() );

    _lsatim.Set( NULL, 0 );
    *ppbBuffer = NULL;

}   // TRUSTED_DOMAIN_ENUM :: FreeBuffer


/*******************************************************************

    NAME:       TRUSTED_DOMAIN_ENUM :: CallAPI

    SYNOPSIS:   Invokes the LsaEnumerateTrustedDomains() API.

    ENTRY:      fRestartEnum            - If TRUE, then the enumeration
                                          handle should be reset to its
                                          starting position before invoking
                                          the API.

                ppbBuffer               - Points to a pointer to the
                                          buffer returned by the API.

                pcEntriesRead           - Will receive the number of
                                          enumeration entries read.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     09-Apr-1992     Created for the Server Manager.

********************************************************************/
APIERR TRUSTED_DOMAIN_ENUM :: CallAPI( BOOL    fRestartEnum,
                                       BYTE ** ppbBuffer,
                                       UINT  * pcEntriesRead )
{
    UIASSERT( ppbBuffer != NULL );
    UIASSERT( pcEntriesRead != NULL );

    if( fRestartEnum )
    {
        _ResumeKey = (LSA_ENUMERATION_HANDLE)0;
    }

    APIERR err = ((LSA_POLICY *) _plsapolicy)->EnumerateTrustedDomains(
                                                       &_lsatim,
                                                       &_ResumeKey,
                                                       TOTAL_BYTES_REQUESTED );

    if( ( err == NO_ERROR ) || ( err == ERROR_MORE_DATA ) )
    {
        *ppbBuffer     = (BYTE *)_lsatim.QueryPtr();
        *pcEntriesRead = (UINT)_lsatim.QueryCount();
    }

    return err;

}  // TRUSTED_DOMAIN_ENUM :: CallAPI


DEFINE_LM_RESUME_ENUM_ITER_OF( TRUSTED_DOMAIN, LSA_TRUST_INFORMATION );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmoenum\lmoesvc.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    lmoesvc.hxx
    This file contains the class declarations for the SERVICE_ENUM
    enumerator class and its associated iterator class.

    The SERVICE_ENUM class is used to enumerate the services installed
    on a target (possibly remote) server.

    NOTE:  This class uses the Win32 Service Control API.


    FILE HISTORY:
        KeithMo     17-Jan-1992     Created.
        KeithMo     31-Jan-1992     Changes from code review on 29-Jan-1992
                                    attended by ChuckC, EricCh, TerryK.
        KeithMo     04-Jun-1992     Handle NT & LM servers differently.
        KeithMo     11-Nov-1992     Added DisplayName goodies.

*/


#include "pchlmobj.hxx"

//
//  SERVICE_ENUM methods
//

/*******************************************************************

    NAME:           SERVICE_ENUM :: SERVICE_ENUM

    SYNOPSIS:       SERVICE_ENUM class constructor.

    ENTRY:          pszServerName       - The name of the server to execute
                                          the enumeration on.  NULL =
                                          execute locally.

                    fIsNtServer         - TRUE  if this is an NT server.
                                          FALSE if this is an LM server.

                    ServiceType         - Either SERVICE_WIN32 (for "normal"
                                          services or SERVICE_DRIVER (for
                                          drivers).

                    pszGroupName        - Service Order Group to limit enumeration
    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     17-Jan-1992     Created.

********************************************************************/
SERVICE_ENUM :: SERVICE_ENUM( const TCHAR * pszServerName,
                              BOOL          fIsNtServer,
                              UINT          ServiceType,
                              const TCHAR * pszGroupName )
  : LOC_LM_ENUM( pszServerName, 0 ),
    _ServiceType( ServiceType ),
    _fIsNtServer( fIsNtServer ),
    _nlsGroupName( pszGroupName )
{
    UIASSERT( sizeof(ENUM_SVC_STATUS) <= sizeof(ENUM_SERVICE_STATUS) );
//    UIASSERT( (ServiceType == SERVICE_WIN32)||(ServiceType == SERVICE_DRIVER) );

    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }
    APIERR err = NERR_Success;
    if ((err = _nlsGroupName.QueryError()) != NERR_Success )
    {
        ReportError( err );
        return;
    }

}   // SERVICE_ENUM :: SERVICE_ENUM


/*******************************************************************

    NAME:           SERVICE_ENUM :: ~SERVICE_ENUM

    SYNOPSIS:       SERVICE_ENUM class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     17-Jan-1992     Created.

********************************************************************/
SERVICE_ENUM :: ~SERVICE_ENUM( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // SERVICE_ENUM :: ~SERVICE_ENUM


/*******************************************************************

    NAME:           SERVICE_ENUM :: CallAPI

    SYNOPSIS:       Invokes the EnumServicesStatus() API.

    ENTRY:          ppbBuffer           - Pointer to a pointer to the
                                          enumeration buffer.

                    pcEntriesRead       - Will receive the number of
                                          entries read from the API.

    EXIT:           The enumeration API is invoked.

    RETURNS:        APIERR              - Any errors encountered.

    HISTORY:
        KeithMo     17-Jan-1992     Created.
        KeithMo     04-Jun-1992     Handle NT & LM servers differently.

********************************************************************/
APIERR SERVICE_ENUM :: CallAPI( BYTE ** ppbBuffer,
                                UINT  * pcEntriesRead )
{
    UIASSERT( ppbBuffer != NULL );
    UIASSERT( pcEntriesRead != NULL );

    return _fIsNtServer ? EnumNtServices( ppbBuffer, pcEntriesRead )
                        : EnumLmServices( ppbBuffer, pcEntriesRead );

}   // SERVICE_ENUM :: CallAPI


/*******************************************************************

    NAME:           SERVICE_ENUM :: EnumNtServices

    SYNOPSIS:       Enumerates the services on an NT server.

    ENTRY:          ppbBuffer           - Pointer to a pointer to the
                                          enumeration buffer.

                    pcEntriesRead       - Will receive the number of
                                          entries read from the API.

    EXIT:           The enumeration API is invoked.

    RETURNS:        APIERR              - Any errors encountered.

    HISTORY:
        KeithMo     04-Jun-1992     Created.

********************************************************************/
APIERR SERVICE_ENUM :: EnumNtServices( BYTE ** ppbBuffer,
                                       UINT  * pcEntriesRead )
{
    //
    //  Connect to the service manager on the target server.
    //

    SC_MANAGER scman( QueryServer(),
                      GENERIC_READ | SC_MANAGER_ENUMERATE_SERVICE,
                      ACTIVE );

    LPENUM_SERVICE_STATUS pSvcStatus;
    APIERR err = scman.QueryError();

    if( err == NERR_Success )
    {
        //
        //  Enumerate the services.
        //

        err = scman.EnumServiceStatus( _ServiceType,
                                       SERVICE_ACTIVE | SERVICE_INACTIVE,
                                       &pSvcStatus,
                                       (DWORD *)pcEntriesRead,
                                       _nlsGroupName );
    }

    if( ( err == NERR_Success ) && ( *pcEntriesRead == 0 ) )
    {
        *ppbBuffer = NULL;
        return NERR_Success;
    }

    BYTE FAR * pbTmpBuffer;
    UINT cbBuffer;

    if( err == NERR_Success )
    {
        //
        //  Allocate a new buffer that the LM_ENUM destructor can
        //  successfully destroy.
        //
        //  CODEWORK:  We must allocate a buffer with MNetApiBufferAlloc
        //  because that's what LM_ENUM expects.  What we really need is
        //  to add a new virtual to LM_ENUM for destroying the API buffer.
        //  With such an addition, we could override the virtual in
        //  this class and destroy the buffer appropriately.
        //

        cbBuffer = scman.QueryBuffer().QuerySize();
        pbTmpBuffer = MNetApiBufferAlloc( cbBuffer );

        if( pbTmpBuffer == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if( err == NERR_Success )
    {
        //
        //  Copy the data into the new buffer.
        //

        ::memcpyf( pbTmpBuffer,
                   pSvcStatus,
                   cbBuffer );

        //
        //  Map the ENUM_SERVICE_STATUS structures to ENUM_SVC_STATUS.
        //

        ENUM_SVC_STATUS     * pNewStatus = (ENUM_SVC_STATUS *)pbTmpBuffer;
        ENUM_SERVICE_STATUS * pOldStatus = (ENUM_SERVICE_STATUS *)pSvcStatus;

        for( UINT i = *pcEntriesRead ; i > 0 ; i-- )
        {
            //
            //  Cache the entries from the old structure in case
            //  it overlaps with the new structure.
            //

            //
            //  NOTE:  Since we copied the data, including strings, from
            //  the original API buffer to our newly allocated buffer,
            //  we must perform "fixups" on the string pointers.  This
            //  is the purpose of this first two somewhat elaborate
            //  assignments.
            //

            const TCHAR * pszServiceName =
                (const TCHAR *)( (const BYTE *)pbTmpBuffer +
                                 ( (const BYTE *)pOldStatus->lpServiceName -
                                   (const BYTE *)pSvcStatus ) );

            const TCHAR * pszDisplayName =
                (const TCHAR *)( (const BYTE *)pbTmpBuffer +
                                 ( (const BYTE *)pOldStatus->lpDisplayName -
                                   (const BYTE *)pSvcStatus ) );

            ULONG nCurrentState =
                (ULONG)pOldStatus->ServiceStatus.dwCurrentState;

            ULONG nControlsAccepted =
                (ULONG)pOldStatus->ServiceStatus.dwControlsAccepted;

            pNewStatus->pszServiceName    = pszServiceName;
            pNewStatus->pszDisplayName    = pszDisplayName;
            pNewStatus->nCurrentState     = nCurrentState;
            pNewStatus->nControlsAccepted = nControlsAccepted;

            SC_SERVICE scsvc( scman,
                              pszServiceName,
                              GENERIC_READ | SERVICE_QUERY_CONFIG );

            // if we cannot get to service, assume its disabled

            if (scsvc.QueryError() != NERR_Success)
                pNewStatus->nStartType = SERVICE_DISABLED;
            else
            {
                LPQUERY_SERVICE_CONFIG lpServiceConfig ;

                if (scsvc.QueryConfig(&lpServiceConfig) != NERR_Success)
                    pNewStatus->nStartType = SERVICE_DISABLED;
                else
                    pNewStatus->nStartType = (ULONG)lpServiceConfig->dwStartType;
            }

            pNewStatus++;
            pOldStatus++;
        }

        //
        //  Return the new buffer to LM_ENUM.
        //

        *ppbBuffer = pbTmpBuffer;
    }

    return err;

}   // SERVICE_ENUM :: EnumNtServices


/*******************************************************************

    NAME:           SERVICE_ENUM :: EnumLmServices

    SYNOPSIS:       Enumerates the services on an LM server.

    ENTRY:          ppbBuffer           - Pointer to a pointer to the
                                          enumeration buffer.

                    pcEntriesRead       - Will receive the number of
                                          entries read from the API.

    EXIT:           The enumeration API is invoked.

    RETURNS:        APIERR              - Any errors encountered.

    HISTORY:
        KeithMo     04-Jun-1992     Created.
        KeithMo     08-Sep-1992     Map "LanmanServer" -> "SERVER" et al.

********************************************************************/
APIERR SERVICE_ENUM :: EnumLmServices( BYTE ** ppbBuffer,
                                       UINT  * pcEntriesRead )
{
    UIASSERT( _ServiceType == SERVICE_WIN32 );

    //
    //  First off, we need to read LANMAN.INI to get the list
    //  of available services.
    //

    BYTE * pbCfgBuffer = NULL;

#if 1
    APIERR err = ::MNetConfigGetAll( QueryServer(),
                                     NULL,
                                     (TCHAR *)SECT_LM20_SERVICES,
                                     &pbCfgBuffer );
#else
    //
    //  BUGBUG!
    //
    //  At the time this code was written (04-Jun-1992) the
    //  NetConfigGetAll API had major UNICODE problems when
    //  remoted to downlevel servers.  As a temporary workaround,
    //  we'll use a hard-coded list of known services for downlevel
    //  servers.
    //

    TRACEEOL( "NetConfigGetAll doesn't work on downlevel servers." );
    TRACEEOL( "Using hard-coded service list." );

    const TCHAR * pchCannedNames =
SZ("WORKSTATION=wksta.exe\0SERVER=netsvini.exe\0MESSENGER=msrvinit.exe\0NETPOPUP=netpopup.exe\0ALERTER=alerter.exe\0NETRUN=runservr.exe\0REPLICATOR=replicat.exe\0UPS=ups.exe\0NETLOGON=netlogon.exe\0REMOTEBOOT=rplservr.exe\0TIMESOURCE=timesrc.exe\0\0");

#define SIZEOF_CANNED_NAME_LIST (332 * sizeof(TCHAR))   // must be accurate!!

    pbCfgBuffer = ::MNetApiBufferAlloc( SIZEOF_CANNED_NAME_LIST );

    APIERR err = ( pbCfgBuffer == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                         : NERR_Success;

    if( err == NERR_Success )
    {
        ::memcpyf( pbCfgBuffer,
                   pchCannedNames,
                   SIZEOF_CANNED_NAME_LIST );
    }
#endif

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  Count the number of services and the total *BYTE*
    //  count for the service names.
    //

    UINT cServices;
    UINT cbServiceNames;

    CountServices( pbCfgBuffer, &cServices, &cbServiceNames );

    //
    //  We now know how large our return buffer must be.  It
    //  should be (cServices*sizeof(ENUM_SVC_STATUS))+cbServiceNames.
    //  Note that this assumes that the services returned by
    //  NetConfigGetAll is always a superset of the services
    //  returned by NetServiceEnum.
    //

    UINT cbSvcStatus = cServices * sizeof(ENUM_SVC_STATUS);
    BYTE * pbSvcBuffer = ::MNetApiBufferAlloc( cbSvcStatus + cbServiceNames );

    if( pbSvcBuffer == NULL )
    {
        ::MNetApiBufferFree( &pbCfgBuffer );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    //  We'll place the service names just past the last
    //  ENUM_SVC_STATUS structure.
    //

    TCHAR * pchServiceNames = (TCHAR *)( pbSvcBuffer + cbSvcStatus );

    ::memcpyf( pchServiceNames,
               pbCfgBuffer,
               cbServiceNames );

    //
    //  Now we can build our ENUM_SVC_STATUS structures.
    //  We'll assume that the services are stopped and only
    //  accept the start command (until proven otherwise).
    //  We'll also assume DisplayName == ServiceName.
    //

    ENUM_SVC_STATUS * pSvcStatus = (ENUM_SVC_STATUS *)pbSvcBuffer;

    for( UINT i = cServices ; i > 0 ; i-- )
    {
        pSvcStatus->pszServiceName    = pchServiceNames;
        pSvcStatus->pszDisplayName    = pchServiceNames;
        pSvcStatus->nCurrentState     = SERVICE_STOPPED;
        pSvcStatus->nControlsAccepted = SERVICE_ACCEPT_STOP;
        pSvcStatus->nStartType        = SERVICE_DEMAND_START;

        pSvcStatus++;
        pchServiceNames += ::strlenf( pchServiceNames ) + 1;
    }

    //
    //  Now that we're done with the configuration buffer
    //  we can kill it.
    //

    ::MNetApiBufferFree( &pbCfgBuffer );

    //
    //  Let's see if we can get the "real" services status.
    //

    struct service_info_1 * psvci1 = NULL;
    UINT   cLmServices;

    err = ::MNetServiceEnum( QueryServer(),
                             1,
                             (BYTE **)&psvci1,
                             &cLmServices );

    if( ( err == NERR_Success ) && ( cLmServices > cServices ) )
    {
        //
        //  BUGBUG!
        //
        //  In theory (yea, right) we should never receive
        //  more services from NetServiceEnum than we receive
        //  from NetConfigGetAll.  But, in the odd chance that
        //  we do, what do we do?  For now, I'll just pretend
        //  that it never happened...
        //

        TRACEEOL( "cLmServices > cServices??") ;
    }

    if( err != NERR_Success )
    {
        ::MNetApiBufferFree( &pbSvcBuffer );
        return err;
    }

    {
        //
        //  BUGBUG!  08-Sep-1992
        //
        //  Recent changes to the NetServiceXxx API cause the service
        //  names (on downlevel servers) to get mapped from the old names
        //  (such as "SERVER") to the new names (such as "LanmanServer").
        //  Unfortunately, the key names retrieved from NetConfigGetAll
        //  do *NOT* get mapped to the new names.  So, until the Net API
        //  group gets things fixed correctly, we'll map the new names
        //  back to the old names.
        //

        struct service_info_1 * psvci1Tmp = psvci1;

        for( UINT i = cLmServices ; i > 0 ; i-- )
        {
            //
            //  NOTE:  This code assumes that
            //         strlen(SERVICE_SERVER) >= strlen(SERVICE_LM20_SERVER).
            //

            if( ::stricmpf( (const TCHAR *)psvci1Tmp->svci1_name,
                            (const TCHAR *)SERVICE_SERVER ) == 0 )
            {
                ::strcpy( (TCHAR *)psvci1Tmp->svci1_name,
                          (TCHAR *)SERVICE_LM20_SERVER );
            }
            else
            if( ::stricmpf( (const TCHAR *)psvci1Tmp->svci1_name,
                            (const TCHAR *)SERVICE_WORKSTATION ) == 0 )
            {
                ::strcpy( (TCHAR *)psvci1Tmp->svci1_name,
                          (TCHAR *)SERVICE_LM20_WORKSTATION );
            }

            psvci1Tmp++;
        }
    }

    //
    //  Now that we have the NetConfig list and the NetService
    //  list, we can update the status of the services in the
    //  intersection of the two sets.
    //

    pSvcStatus = (ENUM_SVC_STATUS *)pbSvcBuffer;

    for( i = cServices ; i > 0 ; i-- )
    {
        struct service_info_1 * psvci1Tmp = psvci1;

        for( UINT j = cLmServices ; j > 0 ; j-- )
        {
            if( ::stricmpf( (const TCHAR *)pSvcStatus->pszServiceName,
                            (const TCHAR *)psvci1Tmp->svci1_name ) == 0 )
            {
                //
                //  We've got a match.  Update the state & control
                //  set to reflect reality.
                //

                MapLmStatusToNtState( psvci1Tmp->svci1_status,
                                      &pSvcStatus->nCurrentState,
                                      &pSvcStatus->nControlsAccepted );
                break;
            }

            psvci1Tmp++;
        }

        pSvcStatus++;
    }

    *ppbBuffer     = pbSvcBuffer;
    *pcEntriesRead = cServices;

    return NERR_Success;

}   // SERVICE_ENUM :: EnumLmServices



/*******************************************************************

    NAME:           SERVICE_ENUM :: CountServices

    SYNOPSIS:       Counts the services & total string counts in
                    a buffer returned from NetConfigGetAll for
                    the LanMan [Services] section.

    ENTRY:          pbBuffer            - Pointer to the NetConfigGetAll
                                          buffer.

                    pcServices          - Will receive the number of
                                          services in the buffer.

                    pcbServiceNames     - Will return the total number
                                          of *BYTES* necessary for all
                                          of the service names in the
                                          buffer.

    EXIT:           Initially, the configuration buffer will be of
                    the form:

                        SERVICE_NAME=PATH_TO_EXE\0SERVICE_NAME=
                        PATH_TO_EXE\0SERVICE_NAME=PATH_TO_EXE\0\0

                    After this routine completes, the buffer has been
                    rearranged slightly to be of the form:

                        SERVICE_NAME\0SERVICE_NAME\0SERVICE_NAME\0...

                    In other words, all of the paths to the service
                    executables have been removed from the buffer.

    HISTORY:
        KeithMo     04-Jun-1992     Created.

********************************************************************/
VOID SERVICE_ENUM :: CountServices( BYTE * pbBuffer,
                                    UINT * pcServices,
                                    UINT * pcbServiceNames )
{
    UIASSERT( pbBuffer != NULL );
    UIASSERT( pcServices != NULL );
    UIASSERT( pcbServiceNames != NULL );

    TCHAR * pchSrc = (TCHAR *)pbBuffer;
    TCHAR * pchDst = pchSrc;

    UINT cServices = 0;

    //
    //  Loop until we're out of strings.
    //

    while( *pchSrc != TCH('\0') )
    {
        //
        //  Scan for either the end of the current string, or
        //  the '=' separator.  We *should* always find the '='
        //  separator, but you never know...
        //

        TCHAR * pszSeparator = ::strchrf( pchSrc, TCH('=') );
        UINT cbSrc = ::strlenf( pchSrc );

        //
        //  If we found a separator, terminate the service
        //  name at the separator.
        //

        if( pszSeparator != NULL )
        {
            *pszSeparator = TCH('\0');
        }

        //
        //  Copy the service name to its new location.  This is
        //  done to "compact" the service names in the buffer.
        //

        ::strcpyf( pchDst, pchSrc );

        pchSrc += cbSrc + 1;
        pchDst += ::strlenf( pchDst ) + 1;

        cServices++;
    }

    *pcServices      = cServices;
    *pcbServiceNames = (UINT)((BYTE *)pchDst - pbBuffer);

}   // SERVICE_ENUM :: CountServices



/*******************************************************************

    NAME:           SERVICE_ENUM :: MapLmStatusToNtState

    SYNOPSIS:       Maps the service status returned by NetServiceEnum
                    to the NT State & ControlsAccepted values.

    ENTRY:          dwLmStatus          - The LM status from NetServiceEnum.

                    pnCurrentState      - Will receive the current state.

                    pnControlsAccepted  - Will receive a bitmask of
                                          valid controls this service
                                          will accept.

    HISTORY:
        KeithMo     04-Jun-1992     Created.
        KeithMo     20-Aug-1992     Fixed handling of paused state.

********************************************************************/
VOID SERVICE_ENUM :: MapLmStatusToNtState( DWORD   dwLmStatus,
                                           ULONG * pnCurrentState,
                                           ULONG * pnControlsAccepted )
{
    UIASSERT( pnCurrentState != NULL );
    UIASSERT( pnControlsAccepted != NULL );

    ULONG nCurrentState     = 0;
    ULONG nControlsAccepted = 0;

    switch( dwLmStatus & SERVICE_INSTALL_STATE )
    {
    case SERVICE_INSTALLED :
        nCurrentState = SERVICE_RUNNING;
        break;

    case SERVICE_UNINSTALLED :
        nCurrentState = SERVICE_STOPPED;
        break;

    case SERVICE_INSTALL_PENDING :
        nCurrentState = SERVICE_START_PENDING;
        break;

    case SERVICE_UNINSTALL_PENDING :
        nCurrentState = SERVICE_STOP_PENDING;
        break;
    }

    switch( dwLmStatus & SERVICE_PAUSE_STATE )
    {
    case LM20_SERVICE_PAUSED :
        nCurrentState = SERVICE_PAUSED;
        break;

    case LM20_SERVICE_CONTINUE_PENDING :
        nCurrentState = SERVICE_CONTINUE_PENDING;
        break;

    case LM20_SERVICE_PAUSE_PENDING :
        nCurrentState = SERVICE_PAUSE_PENDING;
        break;
    }

    if( dwLmStatus & SERVICE_UNINSTALLABLE )
    {
        nControlsAccepted |= SERVICE_CONTROL_STOP;
    }

    if( dwLmStatus & SERVICE_PAUSABLE )
    {
        nControlsAccepted |= SERVICE_CONTROL_PAUSE | SERVICE_CONTROL_CONTINUE;
    }

    *pnCurrentState     = nCurrentState;
    *pnControlsAccepted = nControlsAccepted;

}   // SERVICE_ENUM :: MapLmStatusToNtState



DEFINE_LM_ENUM_ITER_OF( SERVICE, ENUM_SVC_STATUS );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\base\base.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    base.cxx
    Implementation of the BASE class.

    FILE HISTORY:
	chuckc	    27-Feb-1992     created

*/


#include "lmui.hxx"
#include "base.hxx"

static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName

APIERR vlasterr ;

VOID BASE::_ReportError( APIERR errSet )
{
    vlasterr = _err  = errSet ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\bin\makefile.inc ===
COMBINE_SOURCELIBS=..\buffer\$(O)\buffer.lib  \
                   ..\misc\$(O)\misc.lib      \
                   ..\trace\$(O)\trace.lib    \
                   ..\system\$(O)\system.lib  \
                   ..\wintime\$(O)\wintime.lib \
                   ..\fsenum\$(O)\fsenum.lib \
                   ..\base\$(O)\base.lib \
                   ..\heap\$(O)\heap.lib \
                   ..\errmap\$(O)\errmap.lib \
                   ..\fmx\$(O)\fmx.lib

COMBINE_TARGETLIB=$(O)\uimisc.lib

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmoenum\lmoeuse.cxx ===
/*****************************************************************/
/**		     Microsoft Windows NT			**/
/**	       Copyright(c) Microsoft Corp., 1992		**/
/*****************************************************************/

/*
 *  lmoeuse.cxx
 *
 *  HISTORY:
 *	Yi-HsinS     09-Jun-1992     Created
 *
 */

#include "pchlmobj.hxx"


/***************************** USE_ENUM  ******************************/


/**********************************************************\

   NAME:       USE_ENUM::USE_ENUM

   SYNOPSIS:   use enum constructor

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
   	Yi-HsinS     09-Jun-1992     Created

\**********************************************************/

USE_ENUM::USE_ENUM( const TCHAR * pszServer, UINT uLevel )
  : LOC_LM_ENUM( pszServer, uLevel )
{
    // only supports levels 1 at this time
    UIASSERT( uLevel == 1 );

}  // USE_ENUM::USE_ENUM



/**********************************************************\

   NAME:       USE_ENUM::CallAPI

   SYNOPSIS:   call use enum api

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
   	Yi-HsinS     09-Jun-1992     Created

\**********************************************************/

APIERR USE_ENUM::CallAPI( BYTE ** ppbBuffer,
			  UINT  * pcEntriesRead )
{
    // only levels support at the time
    UIASSERT( QueryInfoLevel() == 1 );

    return ::MNetUseEnum( QueryServer(),
			  QueryInfoLevel(),
			  ppbBuffer,
			  pcEntriesRead );

}  // USE_ENUM::CallAPI



/*****************************	USE1_ENUM  ******************************/

/**********************************************************\

   NAME:       USE1_ENUM::USE1_ENUM

   SYNOPSIS:   use enum 1 constructor

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
   	Yi-HsinS     09-Jun-1992     Created

\**********************************************************/

USE1_ENUM::USE1_ENUM( const TCHAR * pszServer )
  : USE_ENUM( pszServer, 1 )
{
    // do nothing else

}  // USE1_ENUM::USE1_ENUM


/*******************************************************************

    NAME:	USE1_ENUM_OBJ :: SetBufferPtr

    SYNOPSIS:	Saves the buffer pointer for this enumeration object.

    ENTRY:	pBuffer			- Pointer to the new buffer.

    EXIT:	The pointer has been saved.

    NOTES:	Will eventually handle OemToAnsi conversions.

    HISTORY:
   	Yi-HsinS     09-Jun-1992     Created

********************************************************************/

VOID USE1_ENUM_OBJ :: SetBufferPtr( const struct use_info_1 * pBuffer )
{
    ENUM_OBJ_BASE :: SetBufferPtr( (const BYTE *)pBuffer );

}   // SHARE1_ENUM_OBJ :: SetBufferPtr


DEFINE_LM_ENUM_ITER_OF( USE1, struct use_info_1 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\pch\lmobjnew.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**                Copyright(c) Microsoft Corp., 1990                **/
/**********************************************************************/

/*  HISTORY:
 *      JonN        24-Jul-1991     Created
 *      rustanl     21-Aug-1991     Renamed NEW_LM_OBJ buffer methods
 *      rustanl     26-Aug-1991     Changed [W_]CloneFrom parameter
 *                                  from * to &
 *      jonn    8/29/91         Added ChangeToNew()
 *      jonn    9/05/91         Changes related to IsOKState()
 *      jonn    9/17/91         Moved CHECK_OK / CHECK_VALID strings to static
 *      terryk  10/7/91         type changes for NT
 *      KeithMo 10/8/91         Now includes LMOBJP.HXX.
 *      terryk  10/17/91        WIN 32 conversion
 *      terryk  10/21/91        change _pBuf from TCHAR * to BYTE *
 *      jonn    11/20/91        Fixed ResizeBuffer( 0 )
 *      jonn    5/08/92         Added ClearBuffer()
 *
 *      This file contains basic methods for the LM_OBJ root classes.
 */

#include "pchlmobj.hxx"  // Precompiled header

#if !defined(_CFRONT_PASS_)
#pragma hdrstop            //  This file creates the PCH
#endif


/**********************************************************\

   NAME:        NEW_LM_OBJ::NEW_LM_OBJ

   SYNOPSIS:    constructor and destructor

   NOTES:       The BUFFER object must construct successfully

   HISTORY:
        JonN        12-Aug-1991     Created

\**********************************************************/

NEW_LM_OBJ::NEW_LM_OBJ( BOOL fValidate )
    : LM_OBJ_BASE( fValidate ),
      _pBuf( NULL )
{
    if ( QueryError() )
        return;
}

/*******************************************************************

    NAME:       NEW_LM_OBJ::~NEW_LM_OBJ

    SYNOPSIS:   destrcutor

    NOTES:      free up the memory

    HISTORY:
                terryk  17-Oct-91       Created

********************************************************************/

NEW_LM_OBJ::~NEW_LM_OBJ()
{
    if (_pBuf != NULL)
        ::MNetApiBufferFree( &_pBuf );
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::GetInfo

    SYNOPSIS:   These methods call their corresponding virtuals
                to perform the stated operations.  They handle the state
                transitions, while the I_ methods perform the real work.

    NOTES:      For Delete(), see the specific subclass for the
                interpretation of the usForce() parameter.

    HISTORY:
        JonN        06-Aug-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::GetInfo()
{
    if ( IsUnconstructed() || IsNew() )
    {
        UIASSERT( FALSE ); // not valid in this state
        return ERROR_GEN_FAILURE;
    }

    MakeValid();

    APIERR err = I_GetInfo();
    if (err != NERR_Success)
    {
        MakeInvalid();
        return err;
    }

    return NERR_Success;
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::WriteInfo

    SYNOPSIS:   These methods call their corresponding virtuals
                to perform the stated operations.  They handle the state
                transitions, while the I_ methods perform the real work.

    NOTES:      For Delete(), see the specific subclass for the
                interpretation of the usForce() parameter.

    HISTORY:
        JonN        06-Aug-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::WriteInfo()
{
    if ( !IsValid() )
    {
        UIASSERT( FALSE ); // not valid in this state
        return ERROR_GEN_FAILURE;
    }

    return I_WriteInfo();
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::CreateNew

    SYNOPSIS:   These methods call their corresponding virtuals
                to perform the stated operations.  They handle the state
                transitions, while the I_ methods perform the real work.

    NOTES:      For Delete(), see the specific subclass for the
                interpretation of the usForce() parameter.

    HISTORY:
        JonN        06-Aug-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::CreateNew()
{
    if ( IsUnconstructed() )
    {
        UIASSERT( FALSE ); // not valid in this state
        return ERROR_GEN_FAILURE;
    }

    MakeNew();

    APIERR err = I_CreateNew();
    if ( err != NERR_Success )
    {
        MakeInvalid();
        return err;
    }

    return NERR_Success;

}

/**********************************************************\

    NAME:       NEW_LM_OBJ::WriteNew

    SYNOPSIS:   These methods call their corresponding virtuals
                to perform the stated operations.  They handle the state
                transitions, while the I_ methods perform the real work.

    NOTES:      For Delete(), see the specific subclass for the
                interpretation of the usForce() parameter.

    HISTORY:
        JonN        06-Aug-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::WriteNew()
{
    if ( !IsNew() )
    {
        UIASSERT( FALSE ); // not valid in this state
        return ERROR_GEN_FAILURE;
    }

    APIERR err = I_WriteNew();
    if (err != NERR_Success)
        return err;

    MakeValid(); // the object is no longer new

    return NERR_Success;
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::Write

    SYNOPSIS:   This method calls either WriteInfo() or WriteNew()
                depending on the state of the object.

    HISTORY:
        JonN        13-Sep-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::Write()
{
    if ( IsNew() )
        return WriteNew();
    else
        return WriteInfo();
}

/*
    See the specific subclass for the interpretation of usForce.
*/
APIERR NEW_LM_OBJ::Delete( UINT uiForce )
{
    if ( IsUnconstructed() )
    {
        UIASSERT( FALSE ); // not valid in this state
        return ERROR_GEN_FAILURE;
    }

    return I_Delete( uiForce );
}


/**********************************************************\

    NAME:       NEW_LM_OBJ::ChangeToNew

    SYNOPSIS:   These methods call their corresponding virtuals
                to perform the stated operations.  They handle the state
                transitions, while the I_ methods perform the real work.

    HISTORY:
        JonN        29-Aug-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::ChangeToNew()
{
    if ( !IsValid() )
    {
        UIASSERT( FALSE ); // not valid in this state
        return ERROR_GEN_FAILURE;
    }

    MakeNew();

    APIERR err = I_ChangeToNew();
    if ( err != NERR_Success )
    {
        MakeInvalid();
        return err;
    }

    return NERR_Success;

}


/**********************************************************\

    NAME:       NEW_LM_OBJ::QueryName

    SYNOPSIS:   These methods are not usable unless redefined by
                subclasses.

    HISTORY:
        JonN        24-Jul-1991     Created

\**********************************************************/

const TCHAR * NEW_LM_OBJ::QueryName() const
{
    UIASSERT( FALSE ); // not valid unless redefined
    return NULL;
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::I_GetInfo

    SYNOPSIS:   These methods are not usable unless redefined by
                subclasses.

    HISTORY:
        JonN        24-Jul-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::I_GetInfo()
{
    UIASSERT( FALSE ); // not valid unless redefined
    return ERROR_GEN_FAILURE;
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::I_WriteInfo

    SYNOPSIS:   These methods are not usable unless redefined by
                subclasses.

    HISTORY:
        JonN        24-Jul-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::I_WriteInfo()
{
    UIASSERT( FALSE ); // not valid unless redefined
    return ERROR_GEN_FAILURE;
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::I_CreateNew

    SYNOPSIS:   These methods are not usable unless redefined by
                subclasses.

    HISTORY:
        JonN        24-Jul-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::I_CreateNew()
{
    UIASSERT( FALSE ); // not valid unless redefined
    return ERROR_GEN_FAILURE;
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::I_WriteNew

    SYNOPSIS:   These methods are not usable unless redefined by
                subclasses.

    HISTORY:
        JonN        24-Jul-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::I_WriteNew()
{
    UIASSERT( FALSE ); // not valid unless redefined
    return ERROR_GEN_FAILURE;
}

/*
    See the specific subclass for the interpretation of usForce.
*/
APIERR NEW_LM_OBJ::I_Delete( UINT uiForce )
{
    UNREFERENCED( uiForce );
    UIASSERT( FALSE ); // not valid unless redefined
    return ERROR_GEN_FAILURE;
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::I_ChangeToNew

    SYNOPSIS:   These methods are not usable unless redefined by
                subclasses.

    HISTORY:
        JonN        29-Aug-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::I_ChangeToNew()
{
    UIASSERT( FALSE ); // not valid unless redefined
    return ERROR_GEN_FAILURE;
}


/**********************************************************\

    NAME:       NEW_LM_OBJ::W_CloneFrom

    SYNOPSIS:   Copies object, including base API buffer

    NOTES:      W_CloneFrom should copy all component objects at each
                level.  Every level which has component objects should
                define W_CloneFrom.  Every W_CloneFrom should start with a call
                to the predecessor W_CloneFrom.

    CAVEATS:    Note that NEW_LM_OBJ::W_CloneFrom copies the API buffer but
                does not update the pointers in the API buffer.  Only
                the CloneFrom method at the outermost layer can do this.

    HISTORY:
        JonN        24-Jul-1991     Created
        rustanl     26-Aug-1991     Changed parameter from * to &
        terryk      14-Oct-1991     Use NT NetApi to allocate a new
                                    buffer. It may not work for some
                                    instance. BUGBUG
        JonN        31-Oct-1991     Enabled

\**********************************************************/

APIERR NEW_LM_OBJ::W_CloneFrom( const NEW_LM_OBJ & lmobj )
{
    UINT uBufSize = lmobj.QueryBufferSize();
    APIERR err = ResizeBuffer( uBufSize );
    if ( err != NERR_Success )
        return err;

    if ( uBufSize > 0 )
    {
        UIASSERT( _pBuf != NULL );
        ::memcpyf( (TCHAR *)_pBuf,
                   (const TCHAR *)lmobj.QueryBufferPtr(),
                   uBufSize );
    }

    _usState = lmobj._usState;

    return NERR_Success;
}


/**********************************************************\

    NAME:       NEW_LM_OBJ::W_CreateNew

    SYNOPSIS:   initializes fields with accessors

    NOTES:      Every level of the NEW_LM_OBJ hierarchy determines the
                default values for its own private data members.  This
                is done in W_CreateNew(), where each level calls up to
                its parent.  Every level which has component objects should
                define W_CreateNew.  Every W_CreateNew should start with a call
                to the predecessor W_CreateNew.

    CAVEATS:    Note that NEW_LM_OBJ::W_CreateNew copies the API buffer but
                does not initialize the fields in the API buffer.  These
                fields need only be initialized if they have no accessors.
                Only the I_CreateNew method at the outermost layer can do this.

    HISTORY:
        JonN        24-Jul-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::W_CreateNew()
{
    return NERR_Success;
}


/**********************************************************\

    NAME:       NEW_LM_OBJ::W_ChangeToNew

    SYNOPSIS:   Transforms object from VALID to NEW

    NOTES:      Every level of the NEW_LM_OBJ hierarchy determines
                whether its shadow members take different forms between
                the NEW and VALID states.  W_ChangeToNew changes the
                shadow members, but not the API buffer, from VALID to NEW.
                Only levels with component objects which are different
                between VALID and NEW must define W_ChangeToNew.  Every
                W_ChangeToNew should start with a call to the predecessor
                W_ChangeToNew.

    HISTORY:
        JonN        29-Aug-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::W_ChangeToNew()
{
    return NERR_Success;
}


/**********************************************************\

    NAME:       NEW_LM_OBJ::FixupPointer

    SYNOPSIS:   Fixes pointer inside a copied API buffer

    NOTES:      This is a utility routine for the use of CloneFrom() variants.
                When an API buffer is CloneFrom'd, some of its internal
                components may be pointers to strings inside the buffer.
                These pointers should be fixed-up to point into the new
                buffer, otherwise the cloned NEW_LM_OBJ points to a
                string in the old NEW_LM_OBJ and may break it the old
                one is freed.  Only pointers pointing within the old
                buffer need be fixed, NULL pointers  and pointers not
                pointing withing the old buffer can be left alone.
                Pointers which have a shadow NLS_STR can be left
                alone, Query() will use the NLS_STR and the API buffer
                will be fixed by the next WriteInfo/WriteNew.

    ENTRY:      *ppchar is the pointer to be fixed up.
                bufOld is the API buffer for the old NEW_LM_OBJ
                bufNew is the API buffer for the new NEW_LM_OBJ

    CAVEATS:    Note that NEW_LM_OBJ::W_CloneFrom copies the API buffer but
                does not update the pointers in the API buffer.  Only
                the CloneFrom method at the outermost layer can do this.

                Also note that you must walk on eggshells to do the
                pointer addition/subtraction without C6 leaving off the
                upper word.

                The pointer is not necessarily either NULL or within the old
                buffer.  In some cases, an obscure pointer may or may
                not point within the buffer, depending on whether the
                object was created with GetInfo or CreateNew.  We must
                handle this case by leaving alone any pointers which are
                non-NULL but point outside the buffer.

                Also note that this will not work for pointers in API
                buffers other than the default API buffer.

    HISTORY:
        JonN        04-Aug-1991     Created

\**********************************************************/

VOID NEW_LM_OBJ::FixupPointer( TCHAR ** ppchar,
                   const NEW_LM_OBJ * plmobjOld
                 )
{
    ULONG_PTR ulCurrPtr = (ULONG_PTR)(*ppchar);

    // return if null pointer
    if ( ulCurrPtr == 0 )
        return;

    ULONG_PTR ulOld = (ULONG_PTR)plmobjOld->QueryBufferPtr();

    // the object size should never be equal to 0

    UIASSERT( plmobjOld->QueryBufferSize() != 0 );

    // return if not pointing in old buffer
    if  (    ( ulCurrPtr < ulOld )
          || ( ulCurrPtr >= ulOld + ((UINT)plmobjOld->QueryBufferSize()) )
        )
    {
        return;
    }

    // do not assume 2's complement math -- avoid overflow
    ULONG_PTR ulNew = (ULONG_PTR)QueryBufferPtr();
    if ( ulOld >= ulNew )
        *ppchar = (TCHAR *)(ulCurrPtr - (ulOld - ulNew));
    else
        *ppchar = (TCHAR *)(ulCurrPtr + (ulNew - ulOld));

}


/*******************************************************************

    NAME:       NEW_LM_OBJ::QueryBufferSize

    SYNOPSIS:   query the buffer size

    HISTORY:
                jonn    31-Oct-91       Created

********************************************************************/

UINT NEW_LM_OBJ::QueryBufferSize() const
{
    UINT uSize = 0;
    APIERR err = NERR_Success;
    if (_pBuf != NULL)
        err = ::MNetApiBufferSize( _pBuf, &uSize );
    if ( err != NERR_Success )
    {
        DBGEOL( "Failure in NEW_LM_OBJ::QueryBufferSize() " << err );
        ASSERT( FALSE );
        return 0;
    }
    return uSize;
}


/*******************************************************************

    NAME:       NEW_LM_OBJ::SetBufferPtr

    SYNOPSIS:   set the buffer pointer

    ENTRY:      TCHAR *pBuffer - new pointer

    NOTES:      remove the old buffer if necessary

    HISTORY:
                terryk  16-Oct-91       Created

********************************************************************/

VOID NEW_LM_OBJ::SetBufferPtr( BYTE * pBuffer )
{
    if (_pBuf != NULL)
        ::MNetApiBufferFree( &_pBuf );

    _pBuf = pBuffer;
}


/*******************************************************************

    NAME:       NEW_LM_OBJ::ResizeBuffer

    SYNOPSIS:   resize the current buffer and copy the old content to
                the new one

    ENTRY:      UINT cbSize - new buffer size

    RETURNS:    APIERR for buffer creation error

    NOTES:      MNetApiBufferAlloc returns NULL when asked to allocate a
                buffer of length 0.  To get around this, we allocate a
                buffer of length 1 where the requested size is 0.

    HISTORY:
                terryk  14-Oct-91       Created
                jonn    31-Oct-91       Enabled
                jonn    31-Oct-91       Allocate 1 where 0 requested

********************************************************************/

APIERR NEW_LM_OBJ::ResizeBuffer( UINT cbNewRequestedSize )
{
    if ( cbNewRequestedSize == 0 )
        cbNewRequestedSize = 1;

    BYTE * pTemp = ::MNetApiBufferAlloc( cbNewRequestedSize );
    if ( pTemp == NULL )
        return ( ERROR_NOT_ENOUGH_MEMORY );

    if ( _pBuf != NULL )
    {
        UINT uMinSize = QueryBufferSize();
        if ( uMinSize > cbNewRequestedSize )
            uMinSize = cbNewRequestedSize;

        ::memcpyf((TCHAR *) pTemp, (TCHAR *) _pBuf, uMinSize );
    }

    SetBufferPtr( pTemp );

    return NERR_Success;
}


/*******************************************************************

    NAME:       NEW_LM_OBJ::ClearBuffer

    SYNOPSIS:   Set all bits in the current buffer to 0

    RETURNS:    APIERR for error

    HISTORY:
                jonn    08-May-92       Created

********************************************************************/

APIERR NEW_LM_OBJ::ClearBuffer()
{
    BYTE * pTemp = QueryBufferPtr();
    if ( pTemp == NULL )
    {
        UIASSERT( FALSE );
    }
    else
    {
        ::memsetf( (TCHAR *) pTemp, 0, QueryBufferSize() );
    }

    return NERR_Success;
}


/**********************************************************\

   NAME:        LOC_LM_OBJ::LOC_LM_OBJ

   SYNOPSIS:    constructors

   NOTES:       The LOCATION object must construct successfully

   HISTORY:
        JonN        07-Aug-1991     Created

\**********************************************************/

VOID LOC_LM_OBJ::CtAux( VOID )
{
    if ( QueryError() )
        return;

    APIERR err = _loc.QueryError();
    if ( err != NERR_Success )
        ReportError( err );
}

LOC_LM_OBJ::LOC_LM_OBJ( const TCHAR * pszLocation, BOOL fValidate )
        : NEW_LM_OBJ( fValidate ),
          _loc(pszLocation)
{
    CtAux();
}

LOC_LM_OBJ::LOC_LM_OBJ( enum LOCATION_TYPE loctype, BOOL fValidate )
        : NEW_LM_OBJ( fValidate ),
          _loc(loctype)
{
    CtAux();
}

LOC_LM_OBJ::LOC_LM_OBJ( const LOCATION & loc, BOOL fValidate )
        : NEW_LM_OBJ( fValidate ),
          _loc(loc)
{
    CtAux();
}


/**********************************************************\

   NAME:        LOC_LM_OBJ::W_CloneFrom

   SYNOPSIS:    Copies object

   NOTES:       see NEW_LM_OBJ::W_CloneFrom

   HISTORY:
        JonN        26-Jul-1991     Created
        rustanl     26-Aug-1991     Changed parameter from * to &

\**********************************************************/

APIERR LOC_LM_OBJ::W_CloneFrom( const LOC_LM_OBJ & lmobj )
{
    APIERR err = NEW_LM_OBJ::W_CloneFrom( lmobj );
    if ( err != NERR_Success )
        return err;

    err = _loc.Set( lmobj._loc );
    if ( err != NERR_Success )
    {
        DBGEOL( "LOC_LM_OBJ::W_CloneFrom failed on LOCATION copy " << err );
        return err;
    }

    return NERR_Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmoenum\lmoeusr.cxx ===
/*****************************************************************/
/**		     Microsoft LAN Manager			**/
/**	       Copyright(c) Microsoft Corp., 1991		**/
/*****************************************************************/

/*
 *  HISTORY:
 *	gregj	20-May-1991	Cloned from SERVER_ENUM
 *	gregj	23-May-1991	Added LOCATION support
 *	rustanl 18-Jul-1991	Added ( const LOCATION & ) constructors
 *	KeithMo	07-Oct-1991	Win32 Conversion.
 *	JonN	30-Jan-1992	Added NT_USER_ENUM
 *	JonN	13-Mar-1992	Split NT_ACCOUNT_ENUM to lmoent.cxx
 *
 */

#include "pchlmobj.hxx"


/*****************************	USER_ENUM  ******************************/


/**********************************************************\

    NAME:	USER_ENUM::USER_ENUM

    SYNOPSIS:	User enumeration constructor

    ENTRY:	pszLocation -	domain or server to execute on
		    -OR-
		locType -	local computer/logon domain code
		    -OR-
		loc -		given location to execute on

		usLevel -	info level
		pszGroupName -	name of group to enumerate users
				from, default is all users in UAS

    HISTORY:
	gregj	20-May-1991	Cloned from SERVER_ENUM
	gregj	23-May-1991	Added LOCATION support
	rustanl 18-Jul-1991	Added ( const LOCATION & ) constructor

\**********************************************************/

USER_ENUM::USER_ENUM( const TCHAR * pszLocation,
		      UINT	    uLevel,
		      const TCHAR * pszGroupName,
                      BOOL          fKeepBuffers )
  : LOC_LM_RESUME_ENUM( pszLocation, uLevel, fKeepBuffers ),
    _nlsGroupName( pszGroupName ),
    _ResumeHandle( 0 )
{
    if( QueryError() != NERR_Success )
    {
    	return;
    }

    APIERR err = _nlsGroupName.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }


}  // USER_ENUM::USER_ENUM


USER_ENUM::USER_ENUM( LOCATION_TYPE  locType,
		      UINT	     uLevel,
		      const TCHAR  * pszGroupName,
                      BOOL           fKeepBuffers )
  : LOC_LM_RESUME_ENUM( locType, uLevel, fKeepBuffers ),
    _nlsGroupName( pszGroupName )
{
    if( QueryError() != NERR_Success )
    {
    	return;
    }

    APIERR err = _nlsGroupName.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}  // USER_ENUM::USER_ENUM


USER_ENUM::USER_ENUM( const LOCATION  & loc,
		      UINT	        uLevel,
		      const TCHAR     * pszGroupName,
                      BOOL              fKeepBuffers )
  : LOC_LM_RESUME_ENUM( loc, uLevel, fKeepBuffers ),
    _nlsGroupName( pszGroupName )
{
    if( QueryError() != NERR_Success )
    {
    	return;
    }

    APIERR err = _nlsGroupName.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}  // USER_ENUM::USER_ENUM


/**********************************************************\

    NAME:	USER_ENUM::CallAPI

    SYNOPSIS:	Call API to do user enumeration

    ENTRY:	ppbBuffer	- ptr to ptr to buffer to fill
		pcEntriesRead	- variable to store entry count

    EXIT:	LANMAN error code

    NOTES:

    HISTORY:
	gregj	20-May-1991	Cloned from SERVER_ENUM

\**********************************************************/

APIERR USER_ENUM :: CallAPI( BOOL    fRestartEnum,
                             BYTE ** ppbBuffer,
			     UINT  * pcEntriesRead )
{
    if ( fRestartEnum )
        _ResumeHandle = 0;

    /* NetGroupGetUsers must be level 0, so: */
    UIASSERT( QueryInfoLevel() == 0 || _nlsGroupName.QueryTextLength() == 0 );

    if ( _nlsGroupName.QueryTextLength() != NULL )
    {
	return ::MNetGroupGetUsers( QueryServer(),
				    _nlsGroupName,
				    QueryInfoLevel(),
				    ppbBuffer,
				    pcEntriesRead );
    }
    else
    {
        UINT cTotalEntries;
	return ::MNetUserEnum( QueryServer(),
			       QueryInfoLevel(),
                               FILTER_TEMP_DUPLICATE_ACCOUNT
                               | FILTER_NORMAL_ACCOUNT,
			       ppbBuffer,
                               MAXPREFERREDLENGTH,
			       pcEntriesRead,
                               &cTotalEntries,
                               &_ResumeHandle );
    }

}  // USER_ENUM::CallAPI



/*****************************	USER0_ENUM  ******************************/


/**********************************************************\

    NAME:	USER0_ENUM::USER0_ENUM

    SYNOPSIS:	Constructor for level 0 user enumeration

    ENTRY:	pszLocation -	domain or server to execute on
		    -OR-
		locType -	local computer/logon domain code
		    -OR-
		loc -		given location to execute on

		pszGroupName -	name of group to enumerate users
				from, default is all users in UAS

    HISTORY:
	gregj	20-May-1991	Cloned from SERVER1_ENUM
	gregj	23-May-1991	Added LOCATION support
	rustanl 18-Jul-1991	Added ( const LOCATION & ) constructor

\**********************************************************/

USER0_ENUM::USER0_ENUM( const TCHAR * pszLocation,
			const TCHAR * pszGroupName,
                        BOOL          fKeepBuffers )
  : USER_ENUM( pszLocation, 0, pszGroupName, fKeepBuffers )
{
    // do nothing else

}  // USER0_ENUM::USER0_ENUM


USER0_ENUM::USER0_ENUM( LOCATION_TYPE locType,
			const TCHAR * pszGroupName,
                        BOOL          fKeepBuffers )
  : USER_ENUM( locType, 0, pszGroupName, fKeepBuffers )
{
    // do nothing else

}  // USER0_ENUM::USER0_ENUM


USER0_ENUM::USER0_ENUM( const LOCATION & loc,
			const TCHAR    * pszGroupName,
                        BOOL             fKeepBuffers )
  : USER_ENUM( loc, 0, pszGroupName, fKeepBuffers )
{
    // do nothing else

}  // USER0_ENUM::USER0_ENUM



DEFINE_LM_RESUME_ENUM_ITER_OF( USER0, struct user_info_0 );



/*****************************	USER1_ENUM  ******************************/


/**********************************************************\

    NAME:	USER1_ENUM::USER1_ENUM

    SYNOPSIS:	Constructor for level 1 user enumeration

    ENTRY:	pszLocation -	domain or server to execute on
		    -OR-
		locType -	local computer/logon domain code
		    -OR-
		loc -		given location to execute on

    HISTORY:
	gregj	20-May-1991	Cloned from SERVER1_ENUM
	gregj	23-May-1991	Added LOCATION support
	rustanl 18-Jul-1991	Added ( const LOCATION & ) constructor

\**********************************************************/

USER1_ENUM::USER1_ENUM( const TCHAR * pszLocation,
                        BOOL          fKeepBuffers )
  : USER_ENUM( pszLocation, 1, NULL, fKeepBuffers )
{
    // do nothing else

}  // USER1_ENUM::USER1_ENUM


USER1_ENUM::USER1_ENUM( LOCATION_TYPE locType,
                        BOOL          fKeepBuffers )
  : USER_ENUM( locType, 1, NULL, fKeepBuffers )
{
    // do nothing else

}  // USER1_ENUM::USER1_ENUM


USER1_ENUM::USER1_ENUM( const LOCATION & loc,
                        BOOL             fKeepBuffers )
  : USER_ENUM( loc, 1, NULL, fKeepBuffers )
{
    // do nothing else

}  // USER1_ENUM::USER1_ENUM


DEFINE_LM_RESUME_ENUM_ITER_OF( USER1, struct user_info_1 );



/*****************************	USER2_ENUM  ******************************/


/**********************************************************\

    NAME:	USER2_ENUM::USER2_ENUM

    SYNOPSIS:	Constructor for level 2 user enumeration

    ENTRY:	pszLocation -	domain or server to execute on
		    -OR-
		locType -	local computer/logon domain code
		    -OR-
		loc -		given location to execute on

    HISTORY:
	gregj	20-May-1991	Cloned from SERVER1_ENUM
	gregj	23-May-1991	Added LOCATION support
	rustanl 18-Jul-1991	Added ( const LOCATION & ) constructor

\**********************************************************/

USER2_ENUM::USER2_ENUM( const TCHAR * pszLocation,
                        BOOL          fKeepBuffers )
  : USER_ENUM( pszLocation, 2, NULL, fKeepBuffers )
{
    // do nothing else

}  // USER2_ENUM::USER2_ENUM


USER2_ENUM::USER2_ENUM( LOCATION_TYPE locType,
                        BOOL          fKeepBuffers )
  : USER_ENUM( locType, 2, NULL, fKeepBuffers )
{
    // do nothing else

}  // USER2_ENUM::USER2_ENUM


USER2_ENUM::USER2_ENUM( const LOCATION & loc,
                        BOOL             fKeepBuffers )
  : USER_ENUM( loc, 2, NULL, fKeepBuffers )
{
    // do nothing else

}  // USER2_ENUM::USER2_ENUM


DEFINE_LM_RESUME_ENUM_ITER_OF( USER2, struct user_info_2 );



/*****************************	USER10_ENUM  ******************************/


/**********************************************************\

    NAME:	USER10_ENUM::USER10_ENUM

    SYNOPSIS:	Constructor for level 10 user enumeration

    ENTRY:	pszLocation -	domain or server to execute on
		    -OR-
		locType -	local computer/logon domain code
		    -OR-
		loc -		given location to execute on

    HISTORY:
	gregj	20-May-1991	Cloned from SERVER1_ENUM
	gregj	23-May-1991	Added LOCATION support
	rustanl 18-Jul-1991	Added ( const LOCATION & ) constructor

\**********************************************************/

USER10_ENUM::USER10_ENUM( const TCHAR * pszLocation,
                          BOOL          fKeepBuffers )
  : USER_ENUM( pszLocation, 10, NULL, fKeepBuffers )
{
    // do nothing else

}  // USER10_ENUM::USER10_ENUM


USER10_ENUM::USER10_ENUM( LOCATION_TYPE locType,
                          BOOL          fKeepBuffers )
  : USER_ENUM( locType, 10, NULL, fKeepBuffers )
{
    // do nothing else

}  // USER10_ENUM::USER10_ENUM


USER10_ENUM::USER10_ENUM( const LOCATION & loc,
                          BOOL             fKeepBuffers )
  : USER_ENUM( loc, 10, NULL, fKeepBuffers )
{
    // do nothing else

}  // USER10_ENUM::USER10_ENUM


DEFINE_LM_RESUME_ENUM_ITER_OF( USER10, struct user_info_10 );


/*****************************	GROUP_ENUM  ******************************/


/**********************************************************\

    NAME:	GROUP_ENUM::GROUP_ENUM

    SYNOPSIS:	Group enumeration constructor

    ENTRY:	pszLocation -	domain or server to execute on
		    -OR-
		locType -	local computer/logon domain code
		    -OR-
		loc -		given location to execute on

		uLevel -	info level
		pszUserName -	name of user to enumerate groups
				from, default is all groups in UAS

    HISTORY:
	gregj	21-May-1991	Cloned from USER_ENUM
	gregj	23-May-1991	Added LOCATION support
	rustanl 18-Jul-1991	Added ( const LOCATION & ) constructor

\**********************************************************/

GROUP_ENUM::GROUP_ENUM( const TCHAR * pszLocation,
			UINT	     uLevel,
			const TCHAR * pszUserName )
  : LOC_LM_ENUM( pszLocation, uLevel ),
    _pszUserName( pszUserName )
{
    // nothing else to do

}  // GROUP_ENUM::GROUP_ENUM


GROUP_ENUM::GROUP_ENUM( LOCATION_TYPE locType,
			UINT	      uLevel,
			const TCHAR  * pszUserName )
  : LOC_LM_ENUM( locType, uLevel ),
    _pszUserName( pszUserName )
{
    // nothing else to do

}  // GROUP_ENUM::GROUP_ENUM


GROUP_ENUM::GROUP_ENUM( const LOCATION & loc,
			UINT		 uLevel,
			const TCHAR     * pszUserName )
  : LOC_LM_ENUM( loc, uLevel ),
    _pszUserName( pszUserName )
{
    // nothing else to do

}  // GROUP_ENUM::GROUP_ENUM


/**********************************************************\

    NAME:	GROUP_ENUM::CallAPI

    SYNOPSIS:	Call API to do group enumeration

    ENTRY:	ppbBuffer	- ptr to ptr to buffer to fill
		pcEntriesRead	- variable to store entry count

    EXIT:	LANMAN error code

    NOTES:

    HISTORY:
	gregj	21-May-1991	Cloned from USER_ENUM

\**********************************************************/

APIERR GROUP_ENUM::CallAPI( BYTE ** ppbBuffer,
			    UINT * pcEntriesRead )
{
    /* NetUserGetGroups must be level 0, so: */
    UIASSERT( QueryInfoLevel() == 0 || _pszUserName == NULL);

    if (_pszUserName != NULL)
	return ::MNetUserGetGroups( QueryServer(),
				    _pszUserName,
				    QueryInfoLevel(),
				    ppbBuffer,
				    pcEntriesRead );
    else
	return ::MNetGroupEnum( QueryServer(),
			        QueryInfoLevel(),
			        ppbBuffer,
			        pcEntriesRead );

}  // GROUP_ENUM::CallAPI



/*****************************	GROUP0_ENUM  ******************************/


/**********************************************************\

    NAME:	GROUP0_ENUM::GROUP0_ENUM

    SYNOPSIS:	Constructor for level 0 group enumeration

    ENTRY:	pszLocation -	domain or server to execute on
		    -OR-
		locType -	local computer/logon domain code
		    -OR-
		loc -		given location to execute on

		pszUserName -	name of user to enumerate groups
				from, default is all groups in UAS

    HISTORY:
	gregj	21-May-1991	Cloned from USER0_ENUM
	gregj	23-May-1991	Added LOCATION support
	rustanl 18-Jul-1991	Added ( const LOCATION & ) constructor

\**********************************************************/

GROUP0_ENUM::GROUP0_ENUM( const TCHAR * pszLocation,
			  const TCHAR * pszUserName )
  : GROUP_ENUM( pszLocation, 0, pszUserName )
{
    // do nothing else

}  // GROUP0_ENUM::GROUP0_ENUM


GROUP0_ENUM::GROUP0_ENUM( LOCATION_TYPE locType,
			  const TCHAR  * pszUserName )
  : GROUP_ENUM( locType, 0, pszUserName )
{
    // do nothing else

}  // GROUP0_ENUM::GROUP0_ENUM


GROUP0_ENUM::GROUP0_ENUM( const LOCATION & loc,
			  const TCHAR     * pszUserName )
  : GROUP_ENUM( loc, 0, pszUserName )
{
    // do nothing else

}  // GROUP0_ENUM::GROUP0_ENUM


/*******************************************************************

    NAME:	GROUP0_ENUM_OBJ :: SetBufferPtr

    SYNOPSIS:	Saves the buffer pointer for this enumeration object.

    ENTRY:	pBuffer			- Pointer to the new buffer.

    EXIT:	The pointer has been saved.

    NOTES:	Will eventually handle OemToAnsi conversions.

    HISTORY:
	KeithMo	    09-Oct-1991	    Created.

********************************************************************/
VOID GROUP0_ENUM_OBJ :: SetBufferPtr( const struct group_info_0 * pBuffer )
{
    ENUM_OBJ_BASE :: SetBufferPtr( (const BYTE *)pBuffer );

}   // GROUP0_ENUM_OBJ :: SetBufferPtr


DEFINE_LM_ENUM_ITER_OF( GROUP0, struct group_info_0 );



/*****************************	GROUP1_ENUM  ******************************/


/**********************************************************\

    NAME:	GROUP1_ENUM::GROUP1_ENUM

    SYNOPSIS:	Constructor for level 1 group enumeration

    ENTRY:	pszLocation -	domain or server to execute on
		    -OR-
		locType -	local computer/logon domain code
		    -OR-
		loc -		given location to execute on

    HISTORY:
	gregj	21-May-1991	Cloned from USER1_ENUM
	gregj	23-May-1991	Added LOCATION support
	rustanl 18-Jul-1991	Added ( const LOCATION & ) constructor

\**********************************************************/

GROUP1_ENUM::GROUP1_ENUM( const TCHAR * pszLocation )
  : GROUP_ENUM( pszLocation, 1 )
{
    // do nothing else

}  // GROUP1_ENUM::GROUP1_ENUM


GROUP1_ENUM::GROUP1_ENUM( LOCATION_TYPE locType )
  : GROUP_ENUM( locType, 1 )
{
    // do nothing else

}  // GROUP1_ENUM::GROUP1_ENUM


GROUP1_ENUM::GROUP1_ENUM( const LOCATION & loc )
  : GROUP_ENUM( loc, 1 )
{
    // do nothing else

}  // GROUP1_ENUM::GROUP1_ENUM



/*******************************************************************

    NAME:	GROUP1_ENUM_OBJ :: SetBufferPtr

    SYNOPSIS:	Saves the buffer pointer for this enumeration object.

    ENTRY:	pBuffer			- Pointer to the new buffer.

    EXIT:	The pointer has been saved.

    NOTES:	Will eventually handle OemToAnsi conversions.

    HISTORY:
	KeithMo	    09-Oct-1991	    Created.

********************************************************************/
VOID GROUP1_ENUM_OBJ :: SetBufferPtr( const struct group_info_1 * pBuffer )
{
    ENUM_OBJ_BASE :: SetBufferPtr( (const BYTE *)pBuffer );

}   // GROUP1_ENUM_OBJ :: SetBufferPtr


DEFINE_LM_ENUM_ITER_OF( GROUP1, struct group_info_1 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\lmobj\lmoenum\lsaenum.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1992                   **/
/**********************************************************************/

/*
    lsaenum.cxx

    This file contains the enumerators for enumerating all the accounts
    and privileges in the LSA.

                          LM_RESUME_ENUM
                               |
                               |
                            LSA_ENUM
                           /   |    \
                          /    |     ...
                         /     |
          LSA_ACCOUNT_ENUM   LSA_PRIVILEGE_ENUM


    FILE HISTORY:
        Yi-HsinS          3-Mar-1992    Created
        Yi-HsinS         15-May-1992    Added QueryDisplayName
*/

#include "pchlmobj.hxx"

#define LSA_MAX_PREFERRED_LENGTH (4*1024)

/*************************************************************************

    NAME:       LSA_ENUM::LSA_ENUM

    SYNOPSIS:   Constructor

    ENTRY:      plsaPolicy - pointer to the LSA_POLICY

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

LSA_ENUM::LSA_ENUM( const LSA_POLICY *plsaPolicy )
    : LM_RESUME_ENUM( 0 ), // 0 is the level - not used here
      _plsaPolicy( plsaPolicy ),
      _lsaEnumHandle( 0 )
{
    if ( QueryError() != NERR_Success )
        return;
}

/*************************************************************************

    NAME:       LSA_ENUM::~LSA_ENUM

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

LSA_ENUM::~LSA_ENUM()
{
    NukeBuffers();

    _plsaPolicy = NULL;
}

/*************************************************************************

    NAME:       LSA_ENUM::FreeBuffer

    SYNOPSIS:   Free the memory allocated by LSA APIs

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

VOID LSA_ENUM::FreeBuffer( BYTE **ppbBuffer )
{
    ::LsaFreeMemory( *ppbBuffer );
    *ppbBuffer = NULL;
}

/*************************************************************************

    NAME:       LSA_ACCOUNTS_ENUM::LSA_ACCOUNTS_ENUM

    SYNOPSIS:   Constructor

    ENTRY:      plsaPolicy - pointer to the LSA_POLICY

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

LSA_ACCOUNTS_ENUM::LSA_ACCOUNTS_ENUM( const LSA_POLICY *plsaPolicy )
    :  LSA_ENUM( plsaPolicy )
{
    if ( QueryError() != NERR_Success )
        return;
}


/*************************************************************************

    NAME:       LSA_ACCOUNTS_ENUM::CallAPI

    SYNOPSIS:   Invokes the LsaEnumerateAccounts API

    ENTRY:      fRestartEnum  - Indicates whether to start at the beginning.
                                The first call to CallAPI will always pass TRUE.

                ppbBuffer     - Pointer to a pointer to a enumeration buffer.

                pcEntriesRead - Will receive the number of entries read from
                                the API.

    EXIT:

    RETURNS:    APIERR

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

APIERR LSA_ACCOUNTS_ENUM::CallAPI( BOOL fRestartEnum,
                                   BYTE **ppbBuffer,
                                   UINT  *pcbEntries )
{
    if ( fRestartEnum )
    {
        _lsaEnumHandle = 0;
    }

    NTSTATUS ntStatus = ::LsaEnumerateAccounts(  _plsaPolicy->QueryHandle(),
                                                &_lsaEnumHandle,
                                                (PVOID *) ppbBuffer,
                                                LSA_MAX_PREFERRED_LENGTH,
                                                (PULONG) pcbEntries );

    APIERR err = ERRMAP::MapNTStatus( ntStatus );

    switch ( err )
    {
        case NERR_Success:
            err = ERROR_MORE_DATA;
            break;

        case ERROR_NO_MORE_ITEMS:
            err = NERR_Success;
            break;

        default:
            break;
    }

    return err;
}


// LSA_ACCOUNTS_ENUM_ITER
DEFINE_LM_RESUME_ENUM_ITER_OF( LSA_ACCOUNTS, PSID );

/*************************************************************************

    NAME:       LSA_PRIVILEGES_ENUM::LSA_PRIVILEGES_ENUM

    SYNOPSIS:   Constructor

    ENTRY:      plsaPolicy - pointer to the LSA_POLICY

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

LSA_PRIVILEGES_ENUM::LSA_PRIVILEGES_ENUM( const LSA_POLICY *plsaPolicy )
    :  LSA_ENUM( plsaPolicy )
{
    if ( QueryError() != NERR_Success )
        return;
}

/*************************************************************************

    NAME:       LSA_PRIVILEGES_ENUM::CallAPI

    SYNOPSIS:   Invokes the LsaEnumeratePrivileges API

    ENTRY:      fRestartEnum  - Indicates whether to start at the beginning.
                                The first call to CallAPI will always pass TRUE.

                ppbBuffer     - Pointer to a pointer to a enumeration buffer.

                pcEntriesRead - Will receive the number of entries read from
                                the API.

    EXIT:

    RETURNS:    APIERR

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

APIERR LSA_PRIVILEGES_ENUM::CallAPI( BOOL fRestartEnum,
                                     BYTE **ppbBuffer,
                                     UINT  *pcbEntries )
{

    if ( fRestartEnum )
    {
        _lsaEnumHandle = 0;
    }


    NTSTATUS ntStatus = ::LsaEnumeratePrivileges(  _plsaPolicy->QueryHandle(),
                                                  &_lsaEnumHandle,
                                                  (PVOID *) ppbBuffer,
                                                  LSA_MAX_PREFERRED_LENGTH,
                                                  (PULONG) pcbEntries );

    APIERR err = ERRMAP::MapNTStatus( ntStatus );

    switch ( err )
    {
        case NERR_Success:
            err = ERROR_MORE_DATA;
            break;

        case ERROR_NO_MORE_ITEMS:
            err = NERR_Success;
            break;

        default:
            break;
    }

    return err;
}

// LSA_PRIVILEGES_ENUM_ITER
DEFINE_LM_RESUME_ENUM_ITER_OF( LSA_PRIVILEGES, POLICY_PRIVILEGE_DEFINITION );

/*************************************************************************

    NAME:       LSA_PRIVILEGES_ENUM_OBJ::QueryDisplayName

    SYNOPSIS:   Query the display name of the privilege

    ENTRY:      plsaPolicy - pointer to the LSA_POLICY

    EXIT:       pnls - place to hold the display name

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        15-May-1992     Created

**************************************************************************/

APIERR LSA_PRIVILEGES_ENUM_OBJ::QueryDisplayName( NLS_STR *pnls,
                                const LSA_POLICY *plsaPolicy ) const
{
    PUNICODE_STRING punsDisplayName;
    SHORT nLanguageReturned;

    APIERR err = ERRMAP::MapNTStatus(
           ::LsaLookupPrivilegeDisplayName( plsaPolicy->QueryHandle(),
                                            (PUNICODE_STRING) & QueryBufferPtr()->Name,
                                            &punsDisplayName,
                                            &nLanguageReturned ));

    if ( err == NERR_Success )
    {
        err = pnls->MapCopyFrom( punsDisplayName->Buffer,
                                 punsDisplayName->Length  );

        ::LsaFreeMemory( punsDisplayName->Buffer );
        ::LsaFreeMemory( punsDisplayName );
    }

    return err;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\errmap\errmap.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    errmap.cxx
    Implementation of the ERRMAP class.

    FILE HISTORY:
        ThomasPa    02-Mar-1992     Created

*/


#include "ntincl.hxx"

#define INCL_NETCONS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#include "lmui.hxx"

extern "C"
{
    #include <ntstatus.h>
    #include "netlibnt.h"       // for NetpNtStatusToApiStatus()
}


#include "errmap.hxx"

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif


typedef struct _MAPENTRY {
        NTSTATUS ntstatus;
        APIERR apierr;
} MAPENTRY;

MAPENTRY amapentryUIMapTable[] =
{
   { STATUS_MORE_ENTRIES,    ERROR_MORE_DATA     },
   { STATUS_NO_MORE_ENTRIES, NO_ERROR }
};




/*******************************************************************

    NAME:       ERRMAP::MapNTStatus

    SYNOPSIS:   Static method for mappint NTSTATUS codes to APIERRs

    ENTRY:      ntstatus - NTSTATUS to be mapped
                pfMapped - pointer to boolean set to TRUE if NTSTATUS
                           is mapped. default is NULL.
                apierrDefReturn - if non-zero, this indicates the APIERR
                           code to return if the input NTSTATUS cannot
                           be mapped.  Default is 0 (return unmapped
                           NTSTATUS).


    EXIT:       mapped APIERR
                pfMapped - TRUE if the NTSTATUS was mapped.

    RETURNS:

    NOTES:

    HISTORY:
        Thomaspa        02-Mar-1992     Created
        Thomaspa        30-Mar-1992     Code review changes

********************************************************************/

APIERR ERRMAP::MapNTStatus( NTSTATUS ntstatus,
                            BOOL * pfMapped,
                            APIERR apierrDefReturn )
{
    INT i;
    APIERR apierr;

    ASSERT( sizeof(NTSTATUS) == sizeof(APIERR) );

    if (pfMapped != NULL)       // Assume it will be mapped.
        *pfMapped = TRUE;

    // First check if this is an ntstatus we explicitly want
    // to map (e.g. STATUS_MORE_ENTRIES)

    for ( i = 0;
          i < sizeof(amapentryUIMapTable)/sizeof(amapentryUIMapTable[0]);
          i++ )
    {
        if (ntstatus == amapentryUIMapTable[i].ntstatus)
        {
            return amapentryUIMapTable[i].apierr;
        }
    }

    // Now flatten any non-error ntstatus to NERR_Success
    if ( NT_SUCCESS( ntstatus ) )
    {
        return NERR_Success;
    }

    // Finally, give NetpNtStatusToApiStatus() a chance
    apierr = (APIERR)NetpNtStatusToApiStatus( ntstatus );

    // These errors may be returned by the above API if it doesn't have
    // a mapping for the ntstatus
    if ( apierr != NERR_InternalError &&
	apierr != ERROR_RING2SEG_MUST_BE_MOVABLE )
    {
        return apierr;
    }

    // No mapping was done,

    if ( apierrDefReturn != 0 )
    {
        return apierrDefReturn;
    }
    else
    {
        if (pfMapped != NULL)
            *pfMapped = FALSE;
        return (APIERR)ntstatus;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\buffer\buffer.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    buffer.cxx
    Implementation of the BUFFER class.

    FILE HISTORY:
        RustanL     03-Aug-1990     Created Windows implementation
        RustanL     02-Jan-1991     Adapted for BLT
        RustanL     08-Jan-1991     Moved into UI misc, and added OS/2
                                    and DOS implementation.
        BenG        30-Apr-1991     Uses lmui.hxx
        beng        19-Jun-1991     Inherits from BASE; uses UINT sizes;
                                    documentation corrected and moved
                                    into headers
        beng        19-Mar-1992     Removed OS/2 support
*/


#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#include "lmui.hxx"

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#include "uiassert.hxx"
#include "uibuffer.hxx"


/*******************************************************************

    NAME:       BUFFER::BUFFER

    SYNOPSIS:   Construct a BUFFER object of the given size.

    ENTRY:
        cbRequested     indicates desired size of buffer object

    CAVEATS:
        Requesting a zero-length buffer returns an object which
        has no allocated storage.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added
        beng        20-Jun-1991     Uses BASE; size UINT

********************************************************************/

BUFFER::BUFFER( UINT cbRequested ) :
    _pb(NULL),
    _cb(0),
    _hMem(0)
{
    if ( cbRequested == 0 )
        return;

    // Ignore return value - this reports error itself
    GetNewStorage(cbRequested);
}


/*******************************************************************

    NAME:       BUFFER::GetNewStorage

    SYNOPSIS:   Given an object with no allocated storage,
                allocate the initial memory.

    ENTRY:      cbRequested - amount of storage requested in bytes

    EXIT:       Either storage alloc'd, or error reported
                Sets _cb, _pb, _hMem

    RETURNS:    NERR_Success on success; APIERR otherwise

    NOTES:
        Private member function.

    CAVEATS:
        This function will ReportError itself.

    HISTORY:
        beng        24-Jun-1991     Created (common code factored)
        beng        15-Jul-1991     Returns APIERR
        beng        19-Mar-1992     Removed OS/2 support

********************************************************************/

APIERR BUFFER::GetNewStorage( UINT cbRequested )
{
    UIASSERT(_hMem == 0);

    _hMem = ::GlobalAlloc( GMEM_MOVEABLE, (ULONG)cbRequested );
    if ( _hMem == 0 )
    {
#if defined(WIN32)
        APIERR err = ::GetLastError();
#else
        APIERR err = ERROR_NOT_ENOUGH_MEMORY;
#endif
        ReportError(err);
        return err;
    }

    _pb = (BYTE *) ::GlobalLock( _hMem );
    UIASSERT( _pb != NULL );

    _cb = cbRequested;
    return NERR_Success;
}


/*******************************************************************

    NAME:       BUFFER::ReallocStorage

    SYNOPSIS:   Do a "hard" reallocation to the new size

    ENTRY:      cbNewRequested - new size, in bytes

    EXIT:       Storage realloc'd.
                _pb, _cb, _hMem changed

    RETURNS:    NERR_Success on success; APIERR otherwise

    NOTES:
        Private member function.

    HISTORY:
        beng        24-Jun-1991     Created (common code factor)
        beng        15-Jul-1991     Returns APIERR
        beng        19-Mar-1992     Removed OS/2 support

********************************************************************/

APIERR BUFFER::ReallocStorage( UINT cbNewRequested )
{
    REQUIRE( ! ::GlobalUnlock( _hMem ));
    HANDLE hNewMem = ::GlobalReAlloc( _hMem, cbNewRequested, GMEM_MOVEABLE );
    if (hNewMem == 0)
    {
# if defined(WIN32)
        APIERR err = ::GetLastError();
# else
        APIERR err = ERROR_NOT_ENOUGH_MEMORY;
# endif
        _pb = (BYTE *) ::GlobalLock( _hMem );
        UIASSERT( _pb != NULL );
        return err;
    }
    _hMem = hNewMem;
    _pb = (BYTE *) ::GlobalLock( _hMem );

    UIASSERT( _pb != NULL );
    _cb = cbNewRequested;

    return NERR_Success;
}


/*******************************************************************

    NAME:       BUFFER::~BUFFER

    SYNOPSIS:   Destroys buffer object, and deallocates any memory
                that it might have allocated.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added
        beng        19-Mar-1992     Removed OS/2 support

********************************************************************/

BUFFER::~BUFFER()
{
#if defined(DEBUG)
    VerifyState();
#endif

    if ( _hMem == 0 )
        return;

    REQUIRE( ! ::GlobalUnlock( _hMem ) );
    REQUIRE(   ::GlobalFree( _hMem ) == 0 );

#if defined(DEBUG)
    _hMem = 0;
    _pb = NULL;
    _cb = 0;
#endif
}


/*******************************************************************

    NAME:       BUFFER::VerifyState

    SYNOPSIS:   Verifies the state of the object.
                Asserts out if the state is invalid, i.e. if an
                internal error took place.

    NOTES:      This function does nothing in the retail version.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added

********************************************************************/

VOID BUFFER::VerifyState() const
{
    UIASSERT(( _pb == NULL && _cb == 0 ) ||
             ( _pb != NULL && _cb != 0 ));
}


/*******************************************************************

    NAME:       BUFFER::QueryActualSize

    SYNOPSIS:   Returns the actual size of the allocated memory block.
                (Private.)

    RETURNS:    Size, in bytes, or 0 on error (OS/2 only),

    NOTES:      Error handling is the client's responsibility.
                Called from Resize, FillOut, and Trim.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added.
        beng        20-Jun-1991     Size made UINT; Win32 work added.
        beng        19-Mar-1992     Removed OS/2 support

********************************************************************/

UINT BUFFER::QueryActualSize()
{
    // It means nothing to call this on a zero-alloc'd buffer.
    //
    UIASSERT( _hMem != 0 );

    ULONG_PTR cbActual = ::GlobalSize( _hMem );

    if (cbActual == 0)
    {
#if defined(WIN32)
        ReportError(::GetLastError());
#else
        // Either discarded segment or else invalid handle.
        // This is just a number, meaning nothing.
        //
        ReportError(ERROR_NOT_ENOUGH_MEMORY);
#endif
    }

    // Under Win16, clients will never request >64K of data
    //
    UIASSERT((sizeof(UINT)>=sizeof(ULONG)) || (cbActual <= 0x10000));

    // Safe under Win16 by assertion above; safe under Win32
    // since there sizeof(UINT) == sizeof(ULONG).
    //

    return (UINT)cbActual;
}


/*******************************************************************

    NAME:       BUFFER::QueryPtr

    SYNOPSIS:   Return a pointer to the beginning of the buffer

    RETURNS:    Returns a pointer to the first byte in the allocated
                buffer, or NULL if the buffer size is 0.

    NOTES:

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added

********************************************************************/

BYTE * BUFFER::QueryPtr() const
{
#if defined(DEBUG)
    VerifyState();
#endif

    return _pb;
}


/*******************************************************************

    NAME:       BUFFER::QuerySize

    SYNOPSIS:   Return the requested size of the buffer

    RETURNS:    The current size of the buffer, in bytes.

    CAVEATS:    The size returned is that requested by the client,
                not the "actual" size of the internal buffer.
                Use FillOut to make these two sizes the same.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added

********************************************************************/

UINT BUFFER::QuerySize() const
{
#if defined(DEBUG)
    VerifyState();
#endif

    return _cb;
}


/*******************************************************************

    NAME:       BUFFER::Resize

    SYNOPSIS:   Resizes the memory object

    ENTRY:
        cbNewRequested   - specifies the new size

    EXIT:
        _cb and _pb changed; possibly _hMem resized

        This function will only ReportError if the resize
        forces the object's first allocation.  Other alloc
        (i.e. realloc) failures just cause a direct error
        return.

    RETURNS:
        NERR_Success if successful.  The next call to QueryPtr will then
            return a pointer to the newly allocated memory.
            The new buffer will contain as much of the contents
            of the old buffer as will fit.
        !0 if unsuccessful.  The old piece of memory, if any,
            still exists.  The next call to QueryPtr will
            return a pointer to this memory.

    NOTES:
        After a call to this method, the caller can *not* rely on any
        pointer that QueryPtr has returned in the past, regardless of
        the success of this method.

        Reallocations to size 0 will always succeed.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added
        beng        24-Jun-1991     Fold common code; fix bug seen in
                                    resize-to-0,resize-to-original sequence
        beng        15-Jul-1991     Returns APIERR
        beng        19-Mar-1992     Remove OS/2 support

********************************************************************/

APIERR BUFFER::Resize( UINT cbNewRequested )
{
#if defined(DEBUG)
    VerifyState();
#endif

    if ( cbNewRequested == 0 )
    {
        /*
         * The requested memory size is 0.  This will always work.
         */
        _pb = NULL;
        _cb = 0;

        // N.B. _hMem is not modified
        //
        return NERR_Success;
    }

    if ( _hMem == 0 )
    {
        /*
         * There is no memory handle.  Previous size of buffer
         * must have been 0.
         *
         * The new memory request is allocated.
         */
        return GetNewStorage( cbNewRequested );
    }
    else if (cbNewRequested <= QueryActualSize())
    {
        /*
         * The requested memory is no more than the currently allocated
         * memory block.
         *
         * Use that already allocated block (changing the size as
         * recorded).
         */
        _cb = cbNewRequested;
        if (_pb == NULL)
        {
            // Was resized to 0 once upon a time.
            // Regenerate pointer member.
            //
            _pb = (BYTE *) ::GlobalLock( _hMem );
            UIASSERT( _pb != NULL );
        }
        return NERR_Success;
    }

    /*
     * The requested memory exceeds the currently allocated memory.
     * A reallocation is in order.
     */
    return ReallocStorage(cbNewRequested);
}


/*******************************************************************

    NAME:       BUFFER::Trim

    SYNOPSIS:   Reallocates the buffer so that the actual space alloc'd
                is minimally more than the size requested.

    EXIT:
        After making this call, the client can not rely on any pointer
        that QueryPtr has returned in the past, regardless of the success
        of this method.

    NOTES:
        The actual size of the buffer may be larger than the requested size.
        This method informs the system that only _cb is desired.

        This method is intended to be used only when optimization is key.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header added
        beng        15-Jul-1991     ReallocStorage changed return type
        beng        19-Mar-1992     Remove OS/2 support

********************************************************************/

VOID BUFFER::Trim()
{
#if defined(DEBUG)
    VerifyState();
#endif

    if ( _hMem == 0 )
    {
        /*
         * No memory is allocated.
         */
        UIASSERT( _pb == NULL && _cb == 0 );
        return;
    }

    if ( _cb == 0 )
    {
        /*
         * The requested size is 0.  Free the allocated memory.
         */
        UIASSERT( _pb == NULL );

        REQUIRE( ! ::GlobalUnlock( _hMem ));
        REQUIRE(   ::GlobalFree( _hMem ) == NULL );

        _hMem = NULL;
        return;
    }

    UIASSERT(QueryActualSize() >= _cb);
    if ( QueryActualSize() - _cb < 16 )
    {
        /*
         * A resize would "save" less than a paragraph of memory.
         * Not worth the effort.
         *
         * BUGBUG - what does "paragraph" mean under MIPS?
         */
        return;
    }

    /*
     * The potential optimization is at least one paragraph.
     * A reallocation is in order.
     *
     * (This should not fail, since we are reallocating to less
     * than current storage.)
     */
    REQUIRE( NERR_Success == ReallocStorage(_cb) );
}


/*******************************************************************

    NAME:       BUFFER::FillOut

    SYNOPSIS:   Changes the requested size to the actual buffer size.

    NOTES:
        This method is not defined when QueryPtr returns NULL.

        This method provides a very inexpensive way of possibly increasing
        the size of the buffer.  It is intended to be used when optimization
        is key.

        Note that Resize will not reallocate the buffer if the requested
        size is no more than the actual size.  Hence, Resize attempts to
        minimize the cost its operation.  That optimization is, under
        normal circumstances, all that is needed.

    HISTORY:
        rustanl     ?               Created
        beng        01-May-1991     Header (standard format) added
        beng        24-Jun-1991     Sizes in UINTS

********************************************************************/

VOID BUFFER::FillOut()
{
#if defined(DEBUG)
    VerifyState();
#endif

    if ( _hMem == 0 )
    {
        // Nothing to do
        //
        UIASSERT( _pb == NULL && _cb == 0 );
        return;
    }

    UINT cbSize = QueryActualSize();
    if ( cbSize == 0L )
    {
        // an error occurred, since we know the actual size cannot be 0
        //
        return;
    }

    UIASSERT( _cb <= cbSize );

    _cb = cbSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\fsenum\fsenmdos.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    FSEnmDOS.cxx

    This file contains the implementation of DOS_FS_ENUM
    These are used for traversing files and directories
    on a volume under OS/2.



    FILE HISTORY:
	Johnl	04-Oct-1991	Created

*/

#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_OS2
#include "lmui.hxx"

#include "uiassert.hxx"

#include "fsenum.hxx"

extern "C"
{
    #include <errno.h>
    #include <io.h>
}

/*************************************************************************

    NAME:	DOS_DIR_BLOCK

    SYNOPSIS:	Dir block that contains the DOS File Find buffer


    INTERFACE:	See parent

    PARENT:	DIR_BLOCK

    USES:	find_t

    CAVEATS:


    NOTES:


    HISTORY:
	Johnl	16-Oct-1991	Created

**************************************************************************/

class DOS_DIR_BLOCK : public DIR_BLOCK
{
friend class DOS_FS_ENUM ;

private:
    struct find_t _ffbuff ;

public:
    DOS_DIR_BLOCK()
    {  /* Nothing else to do */ }

    virtual ~DOS_DIR_BLOCK() ;

    virtual UINT QueryAttr( void ) ;
    virtual const TCHAR * QueryFileName( void ) ;
} ;

DOS_DIR_BLOCK::~DOS_DIR_BLOCK()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	DOS_DIR_BLOCK::QueryAttr

    SYNOPSIS:	Returns the file attributes for the current file

    RETURNS:	Bit mask of the current file attributes

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

UINT DOS_DIR_BLOCK::QueryAttr( void )
{
    return (UINT) _ffbuff.attrib ;
}

/*******************************************************************

    NAME:	DOS_DIR_BLOCK::QueryFileName

    SYNOPSIS:	Returns the file name of the current file in this dir block

    RETURNS:	Pointer to the files name

    NOTES:	The client should be sure that FindFirst has successfully
		been called on this dir block before invoking this method.

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

const TCHAR * DOS_DIR_BLOCK::QueryFileName( void )
{
    return _ffbuff.name ;
}

/*******************************************************************

    NAME:	DOS_FS_ENUM::DOS_FS_ENUM

    SYNOPSIS:	Constructor for an DOS File/directory enumerator

    ENTRY:	pszPath - Base path to start the enumeration
		pszMask - Mask to filter the files/dirs with
		filtypInclude - include files/dirs or both

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

DOS_FS_ENUM::DOS_FS_ENUM ( const TCHAR * pszPath,
			       const TCHAR * pszMask,
			       enum FILE_TYPE filtypeInclude )
    : FS_ENUM( pszPath, pszMask, filtypeInclude )
{
    if ( QueryError() )
	return ;
}

DOS_FS_ENUM::~DOS_FS_ENUM ()
{   /* Nothing to do */  }

/*******************************************************************

    NAME:	DOS_FS_ENUM::FindFirst

    SYNOPSIS:	Regular FindFirst redefinition, calls DosFindFirst2

    ENTRY:	See parent

    EXIT:

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

APIERR DOS_FS_ENUM::FindFirst( DIR_BLOCK * pDirBlock,
				 const NLS_STR & nlsSearchPath,
				 UINT uiSearchAttr )
{
    DOS_DIR_BLOCK * pDOSDirBlock = (DOS_DIR_BLOCK *) pDirBlock ;
    return _dos_findfirst( nlsSearchPath.QueryPch(),
			   (unsigned) uiSearchAttr,
			   &(pDOSDirBlock->_ffbuff) );
}

/*******************************************************************

    NAME:	DOS_FS_ENUM::FindNext

    SYNOPSIS:	Typical FindNext redefinition, calls DosFindNext

    ENTRY:	See parent

    EXIT:

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

APIERR DOS_FS_ENUM::FindNext(  DIR_BLOCK * pDirBlock, UINT uiSearchAttr  )
{
    UNREFERENCED( uiSearchAttr ) ;

    DOS_DIR_BLOCK * pDOSDirBlock = (DOS_DIR_BLOCK *) pDirBlock ;
    return _dos_findnext( &(pDOSDirBlock->_ffbuff) );
}

/*******************************************************************

    NAME:	DOS_FS_ENUM::CreateDirBlock

    SYNOPSIS:	Typical redefinition of CreateDirBlock

    ENTRY:

    EXIT:

    RETURNS:	A pointer to a newly created DOS_DIR_BLOCK

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

DIR_BLOCK * DOS_FS_ENUM::CreateDirBlock( void )
{
    return new DOS_DIR_BLOCK() ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\fmx\fmx.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1991                   **/
/**********************************************************************/

/*
    fmx.cxx
    This file contains wrappers around the calls to File Manager via
    the File Manager Extensions.

    FILE HISTORY:
        rustanl     30-Apr-1991     Created

*/


#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETLIB
#define INCL_NETCONS
#include "lmui.hxx"


extern "C"
{
    #include <wfext.h>
    #include <dos.h>
}

#include "string.hxx"
#include "uiassert.hxx"

#include "fmx.hxx"


/*******************************************************************

    NAME:       FMX::FMX

    SYNOPSIS:   Constructs an FMX object

    ENTRY:      hwnd -  File Man's hwnd

    HISTORY:
        rustanl     30-Apr-1991     Created

********************************************************************/

FMX::FMX( HWND hwnd )
    :   _hwnd( hwnd )
{
    // nothing else to do

}  // FMX::FMX


/*******************************************************************

    NAME:       FMX::Command

    SYNOPSIS:   Sends a message to File Manager

    ENTRY:      uiMsg -     message ID
                wParam -    wParam
                lParam -    lParam

    RETURNS:    ULONG value returned by message usMsg

    HISTORY:
        rustanl     30-Apr-1991     Created
        DavidHov    27-Oct-1993     Change to lazy-load USER32.DLL

********************************************************************/

typedef LRESULT WINAPI FN_SendMessageW ( HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam) ;
#define USER32_DLL_NAME SZ("user32.dll")
#define SEND_MSG_API_NAME "SendMessageW"


ULONG_PTR FMX::Command ( UINT uiMsg, UINT wParam, LPARAM lParam ) const
{
    static HMODULE hUser32 = NULL ;
    static FN_SendMessageW * pfSendMsg = NULL ;

    if ( pfSendMsg == NULL )
    {
        if ( hUser32 = ::LoadLibrary( USER32_DLL_NAME ) )
        {
            pfSendMsg = (FN_SendMessageW *) ::GetProcAddress( hUser32,
                                                             SEND_MSG_API_NAME ) ;
        }
        if ( pfSendMsg == NULL )
            return ERROR_INVALID_FUNCTION ;
    }

    return (ULONG_PTR) (*pfSendMsg) ( _hwnd, uiMsg, wParam, lParam );

}  // FMX::Command


/*******************************************************************

    NAME:       FMX::QueryFocus

    SYNOPSIS:   Returns what in FM has the focus

    RETURNS:    What has focus in FM, namely:
                    FMFOCUS_DIR (1)
                    FMFOCUS_TREE (2)
                    FMFOCUS_DRIVES (3)
                    FMFOCUS_SEARCH (4)

    HISTORY:
        rustanl     30-Apr-1991     Created

********************************************************************/

UINT FMX::QueryFocus( void ) const
{
    return (UINT)Command( FM_GETFOCUS );

}  // FMX::QueryFocus


/*******************************************************************

    NAME:       FMX::QuerySelCount

    SYNOPSIS:   Returns the count of selected items in File Man

    RETURNS:    That count

    NOTES:      This method always uses FM_GETSELCOUNTLFN.  There is
                also another message, FM_GETSELCOUNT, which could be
                used, but it doesn't count LFN files.

    HISTORY:
        rustanl     30-Apr-1991     Created

********************************************************************/

UINT FMX::QuerySelCount( void ) const
{
    return (UINT)( QueryFocus() == FMFOCUS_TREE ? 1 :
						 Command( FM_GETSELCOUNTLFN )) ;

}  // FMX::QuerySelCount


/*******************************************************************

    NAME:       FMX::QuerySelection

    SYNOPSIS:   Retrieves information about a selected file

    ENTRY:      iSel        index into the selected items
                pselinfo    pointer to FMS_GETFILESEL structure that
                            this call will fill in

    EXIT:       pselinfo    buffer pointed to by this pointer will be
                            filled in

    NOTES:	fAnsi is not required under win32 since we will map
		everything from the ANSI/OEM charset to UNICODE which
		doesn't have the problems of ANSI/OEM.

    HISTORY:
        rustanl     03-May-1991     Created
        yi-hsins    04-Oct-1991     Modified to return APIERR
	beng	    06-Apr-1992     Unicode version
	JohnL	    12-May-1992     Ansified for ANSI/Unicode interface

********************************************************************/

APIERR FMX::QuerySelection( INT iSel, FMS_GETFILESEL * pselinfo, BOOL fAnsi )
{

    APIERR err = NERR_Success ;

#ifdef WIN32
    UNREFERENCED( fAnsi ) ;

    Command( FM_GETFILESELLFN, iSel, (ULONG_PTR)pselinfo );

#else // WIN16

    Command( FM_GETFILESELLFN, iSel, (ULONG)pselinfo );
    if ( fAnsi )
    {
	::OemToAnsi( pselinfo->szName, pselinfo->szName);
    }
#endif

    return err ;

}  // FMX::QuerySelection


/*******************************************************************

    NAME:       FMX::QueryDriveInfo

    SYNOPSIS:   Retrieves info about the currently selected drive

    ENTRY:      pdriveinfo      Pointer to FMS_GETDRIVEINFO structure
                                that will be filled on exit

    EXIT:       pdriveinfo      Will contain info on exit

    HISTORY:
        rustanl     03-May-1991     Created
	yi-hsins    04-Oct-1991     Modified to return APIERR
	JohnL	    12-May-1992     Ansified for ANSI/Unicode interface

********************************************************************/

APIERR FMX::QueryDriveInfo( FMS_GETDRIVEINFO * pdriveinfo )
{
    APIERR err = NERR_Success ;

    Command( FM_GETDRIVEINFO, 0, (ULONG_PTR)pdriveinfo );

    return err ;

}  // FMX::QueryDriveInfo


/*******************************************************************

    NAME:       FMX::Refresh

    SYNOPSIS:   Refreshes File Man's window

    HISTORY:
        rustanl     03-May-1991     Created

********************************************************************/

void FMX::Refresh( void )
{
    Command( FM_REFRESH_WINDOWS );

}  // FMX::Refresh


/*******************************************************************

    NAME:       FMX::Reload

    SYNOPSIS:   Causes File Man to reload the File Man extensions

    HISTORY:
        rustanl     03-May-1991     Created

********************************************************************/

void FMX::Reload( void )
{
    Command( FM_RELOAD_EXTENSIONS );

}  // FMX::Reload

/*******************************************************************

    NAME:	FMX::IsHeterogeneousSelection

    SYNOPSIS:	Determines if the selection contains a combination of files
		or dirs.

    ENTRY:	pfIsHomogeneousSelFiles - Will be set to TRUE if FALSE is
		    returned the homogenous selection is all files.  Set to
		    FALSE if FALSE is returned and the selection is all
		    directories.

    RETURNS:	TRUE will be returned if the selection contains a mix of
		files and dirs.

    NOTES:

    HISTORY:
	Johnl	03-Nov-1992	Created

********************************************************************/

BOOL FMX::IsHeterogeneousSelection( BOOL * pfIsHomogeneousSelFiles )
{
    UINT cSelectedItems = QuerySelCount() ;

    if ( QueryFocus() == FMFOCUS_TREE )
    {
	if ( pfIsHomogeneousSelFiles != NULL )
	    *pfIsHomogeneousSelFiles = FALSE ;
	return FALSE ;
    }

    if ( pfIsHomogeneousSelFiles != NULL )
	*pfIsHomogeneousSelFiles = TRUE ;

    BOOL fFoundFile = FALSE ;
    BOOL fFoundDir  = FALSE ;
    for ( UINT i = 0 ; i < cSelectedItems ; i++ )
    {
	FMS_GETFILESEL selinfo ;
	Command( FM_GETFILESELLFN, i, (ULONG_PTR)&selinfo );

	//
	//  If this selection is a directory and we previously found a file,
	//  then we have a hetergeneous selection, or vice versa.
	//
	if ( selinfo.bAttr & _A_SUBDIR )
	{
	    if ( fFoundFile )
		return TRUE ;

	    fFoundDir = TRUE ;
	}
	else
	{
	    if ( fFoundDir )
		return TRUE ;

	    fFoundFile = TRUE ;
	}
    }

    //
    //	At this point we know we have a homogeneous selection, but is it
    //	a file or directory?
    //

    if ( pfIsHomogeneousSelFiles != NULL )
	*pfIsHomogeneousSelFiles = fFoundFile ;

    return FALSE ;
}

/*******************************************************************

    NAME:       GetSelItem

    SYNOPSIS:   Get the selected item name - could be a file or
                directory. If it's a file, get the directory the
                file is in if the fGetDirOnly flag is set.

    ENTRY:      hwnd  - hwnd of the parent window
                fGetDirOnly - TRUE if interested only in a directory
                    (i.e., strip filenames).  Also indicates multiple
                    selections should not be allowed.

    EXIT:       nlsSelItem - the name of the selected item name
                pfIsFile - Set to TRUE if the item is a file, FALSE if
                    the item is a directory

    RETURNS:

    NOTES:      If fGetDirOnly is FALSE and multiple files/directories
                exist, then ERROR_NOT_SUPPORTED will be returned (this
                shouldn't happen).

    HISTORY:
        Yi-HsinS        8/25/91         Created
        JohnL           1/21/92         Enhanced for connection use

********************************************************************/

APIERR GetSelItem( HWND     hwnd,
                   NLS_STR *pnlsSelItem,
                   BOOL     fGetDirOnly,
                   BOOL    *pfIsFile )
{
    APIERR err = NERR_Success;

    if ( pfIsFile != NULL )
        *pfIsFile = FALSE ;

    FMX fmx( hwnd );

    switch ( fmx.QueryFocus() )
    {
        case FMFOCUS_DIR:
        case FMFOCUS_SEARCH:
        {
            UINT uiSelCount = fmx.QuerySelCount() ;
            if (  uiSelCount > 0 )
            {

                if ( (uiSelCount > 1) && !fGetDirOnly )
                {
                    err = ERROR_NOT_SUPPORTED ;
                    break ;
                }

                FMS_GETFILESEL selinfo;

                // If multiple files are selected, get the info.
                // on the first file, i.e. use the first file as the
                // selected file.
                if ( err = fmx.QuerySelection(0, &selinfo ) )
                    break ;

                *pnlsSelItem = selinfo.szName ;
                if ( err = pnlsSelItem->QueryError() )
                    break ;

                /* Set the pfIsFile flag if we can return files and
                 * the selection is a file.
                 */
                if ( !fGetDirOnly && (pfIsFile != NULL) )
                    *pfIsFile = !(selinfo.bAttr & _A_SUBDIR) ;

                //
                // If selected item is a file, use the directory of the file
                // if requested
                //
                if ( fGetDirOnly                      &&
                     !( selinfo.bAttr & _A_SUBDIR ) )
                {
                    ISTR istrSelItem( *pnlsSelItem );
		    REQUIRE( pnlsSelItem->strrchr( &istrSelItem, TCH('\\') ));
                    pnlsSelItem->DelSubStr( istrSelItem );
		    REQUIRE( pnlsSelItem->strchr( &istrSelItem, TCH(':') ));

                    // Put the '\' back if the name is a device x:
                    if ( istrSelItem.IsLastPos() )
                    {
			err = pnlsSelItem->AppendChar( TCH('\\'));
                    }
                }
                break;
            }
            // else no files are selected in the FILE window
            // fall through to FMFOCUS_TREE to get driveinfo
        }

        case FMFOCUS_TREE:
        {
            FMS_GETDRIVEINFO driveinfo;
            if ( err = fmx.QueryDriveInfo( &driveinfo ) )
                break ;

            *pnlsSelItem = driveinfo.szPath;
            err = pnlsSelItem->QueryError() ;
            break;
        }

        case FMFOCUS_DRIVES:
        default:
            ASSERTSZ(FALSE, "Invalid Focus!");
            break;
    }

    return err;
}

/*******************************************************************

    NAME:       GetSelItem

    SYNOPSIS:   Get the nth selected item - could be a file or
                directory.

    ENTRY:      hwnd  - hwnd of the parent window
                iSelection - Retrieves the ith selection

    EXIT:       nlsSelItem - the name of the selected item name
                pfIsFile - Set to TRUE if the item is a file, FALSE if
                    the item is a directory

    RETURNS:

    NOTES:

    HISTORY:
        JohnL   13-Feb-1992     Ripped off from GetSelItem above.

********************************************************************/

APIERR GetSelItem( HWND     hwnd,
                   UINT     iSelection,
                   NLS_STR *pnlsSelItem,
                   BOOL    *pfIsFile )
{
    APIERR err = NERR_Success;

    if ( pfIsFile != NULL )
        *pfIsFile = FALSE ;

    FMX fmx( hwnd );
    switch ( fmx.QueryFocus() )
    {
        case FMFOCUS_DIR:
        case FMFOCUS_SEARCH:
        {
            UINT uiSelCount = fmx.QuerySelCount() ;
            if (  uiSelCount > 0 )
            {
                FMS_GETFILESEL selinfo;

                if ( uiSelCount <= iSelection )
                {
                    err = ERROR_INVALID_PARAMETER ;
                    break ;
                }

                if ( err = fmx.QuerySelection(iSelection, &selinfo ) )
                    break ;

                *pnlsSelItem = selinfo.szName ;
                if ( err = pnlsSelItem->QueryError() )
                    break ;

                /* Set the pfIsFile flag if we can return files and
                 * the selection is a file.
                 */
                if ((pfIsFile != NULL) )
                    *pfIsFile = !(selinfo.bAttr & _A_SUBDIR) ;

                break;
            }
            // else no files are selected in the FILE window
            // fall through to FMFOCUS_TREE to get driveinfo
        }

        case FMFOCUS_TREE:
        {
            /* Only one thing is selected
             */
            if ( iSelection > 0 )
            {
                err = ERROR_INVALID_PARAMETER ;
                break ;
            }

            FMS_GETDRIVEINFO driveinfo;
            if ( err = fmx.QueryDriveInfo( &driveinfo ) )
                break ;

            *pnlsSelItem = driveinfo.szPath;
            err = pnlsSelItem->QueryError() ;
            break;
        }

        case FMFOCUS_DRIVES:
        default:
            ASSERTSZ( FALSE, "Invalid Focus!");
            break;
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\fsenum\fsenmos2.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    FSEnmOS2.cxx

    This file contains the implementation of OS2_FS_ENUM
    These are used for traversing files and directories
    on a volume under OS/2.



    FILE HISTORY:
	Johnl	04-Oct-1991	Created

*/

#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_OS2
#include "lmui.hxx"

#include "fsenum.hxx"

/*************************************************************************

    NAME:	OS2_DIR_BLOCK

    SYNOPSIS:	Dir block that contains the OS2 File Find buffer


    INTERFACE:	See parent

    PARENT:	DIR_BLOCK

    USES:	FILEFINDBUF2, HDIR

    CAVEATS:


    NOTES:


    HISTORY:
	Johnl	16-Oct-1991	Created

**************************************************************************/

class OS2_DIR_BLOCK : public DIR_BLOCK
{
friend class OS2_FS_ENUM ;

private:
    struct FILEFINDBUF2 _ffbuff2 ;
    HDIR  _hdir ;

public:
    OS2_DIR_BLOCK() : _hdir( HDIR_CREATE )
    {  /* Nothing else to do */ }

    virtual ~OS2_DIR_BLOCK() ;

    virtual UINT QueryAttr( void ) ;
    virtual const TCHAR * QueryFileName( void ) ;

} ;

OS2_DIR_BLOCK::~OS2_DIR_BLOCK()
{
    DosFindClose( _hdir ) ;
}

/*******************************************************************

    NAME:	OS2_DIR_BLOCK::QueryAttr

    SYNOPSIS:	Returns the file attributes for the current file

    RETURNS:	Bit mask of the current file attributes

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

UINT OS2_DIR_BLOCK::QueryAttr( void )
{
    return (UINT) _ffbuff2.attrFile ;
}

/*******************************************************************

    NAME:	OS2_DIR_BLOCK::QueryFileName

    SYNOPSIS:	Returns the file name of the current file in this dir block

    RETURNS:	Pointer to the files name

    NOTES:	The client should be sure that FindFirst has successfully
		been called on this dir block before invoking this method.

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

const TCHAR * OS2_DIR_BLOCK::QueryFileName( void )
{
    return _ffbuff2.achName ;
}

/*******************************************************************

    NAME:	OS2_FS_ENUM::OS2_FS_ENUM

    SYNOPSIS:	Constructor for an OS/2 File/directory enumerator

    ENTRY:	pszPath - Base path to start the enumeration
		pszMask - Mask to filter the files/dirs with
		filtypInclude - include files/dirs or both

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

OS2_FS_ENUM::OS2_FS_ENUM ( const TCHAR * pszPath,
			       const TCHAR * pszMask,
			       enum FILE_TYPE filtypeInclude )
    : FS_ENUM( pszPath, pszMask, filtypeInclude )
{
    if ( QueryError() )
	return ;
}

OS2_FS_ENUM::~OS2_FS_ENUM ()
{   /* Nothing to do */  }

/*******************************************************************

    NAME:	OS2_FS_ENUM::FindFirst

    SYNOPSIS:	Regular FindFirst redefinition, calls DosFindFirst2

    ENTRY:	See parent

    EXIT:

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

APIERR OS2_FS_ENUM::FindFirst( DIR_BLOCK * pDirBlock,
				 const NLS_STR & nlsSearchPath,
				 UINT uiSearchAttr )
{
    USHORT usSearchCount = 1 ;
    OS2_DIR_BLOCK * pOS2DirBlock = (OS2_DIR_BLOCK *) pDirBlock ;
    return DosFindFirst2( (PSZ) nlsSearchPath.QueryPch(),
			   &(pOS2DirBlock->_hdir),
			   (USHORT) uiSearchAttr,
			   (PVOID)  &(pOS2DirBlock->_ffbuff2),
			   sizeof( pOS2DirBlock->_ffbuff2 ),
			   &usSearchCount,
			   FIL_QUERYEASIZE,
			   0L ) ;
}

/*******************************************************************

    NAME:	OS2_FS_ENUM::FindNext

    SYNOPSIS:	Typical FindNext redefinition, calls DosFindNext

    ENTRY:	See parent

    EXIT:

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

APIERR OS2_FS_ENUM::FindNext(  DIR_BLOCK * pDirBlock, UINT uiSearchAttr  )
{
    USHORT usSearchCount = 1 ;
    OS2_DIR_BLOCK * pOS2DirBlock = (OS2_DIR_BLOCK *) pDirBlock ;
    return DosFindNext(  pOS2DirBlock->_hdir,
			 (PFILEFINDBUF)  &(pOS2DirBlock->_ffbuff2),
			 sizeof( pOS2DirBlock->_ffbuff2 ),
			 &usSearchCount ) ;
}

/*******************************************************************

    NAME:	OS2_FS_ENUM::CreateDirBlock

    SYNOPSIS:	Typical redefinition of CreateDirBlock

    ENTRY:

    EXIT:

    RETURNS:	A pointer to a newly created OS2_DIR_BLOCK

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

DIR_BLOCK * OS2_FS_ENUM::CreateDirBlock( void )
{
    return new OS2_DIR_BLOCK() ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\fsenum\fsenmw32.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    FSEnmW32.cxx

    This file contains the implementation of W32_FS_ENUM
    These are used for traversing files and directories
    on a volume under 32 bit windows (uses the Win32 APIs).



    FILE HISTORY:
	Johnl	04-Oct-1991	Created
	Johnl	10-Mar-1992	Did implementation

*/

#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#include "lmui.hxx"

#include "fsenum.hxx"

/*************************************************************************

    NAME:	W32_DIR_BLOCK

    SYNOPSIS:	Dir block that contains the OS2 File Find buffer


    INTERFACE:	See parent

    PARENT:	DIR_BLOCK

    USES:	FILEFINDBUF2, HDIR

    CAVEATS:


    NOTES:


    HISTORY:
	Johnl	16-Oct-1991	Created

**************************************************************************/

class W32_DIR_BLOCK : public DIR_BLOCK
{
friend class W32_FS_ENUM ;

private:
    WIN32_FIND_DATA _win32FindData ;
    HANDLE _hDir ;

public:
    W32_DIR_BLOCK()
    {
        //
        //  Initialize the file name to NULL in case a FindNext fails the
        //  user can still call QueryFileName to find out which directory
        //  the enumeration failed on
        //
        _win32FindData.cFileName[0] = '\0' ;
    }

    virtual ~W32_DIR_BLOCK() ;

    virtual UINT QueryAttr( void ) ;
    virtual const TCHAR * QueryFileName( void ) ;

} ;

W32_DIR_BLOCK::~W32_DIR_BLOCK()
{
    ::FindClose( _hDir ) ;
}

/*******************************************************************

    NAME:	W32_DIR_BLOCK::QueryAttr

    SYNOPSIS:	Returns the file attributes for the current file

    RETURNS:	Bit mask of the current file attributes

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

UINT W32_DIR_BLOCK::QueryAttr( void )
{
    return (UINT) _win32FindData.dwFileAttributes ;
}

/*******************************************************************

    NAME:	W32_DIR_BLOCK::QueryFileName

    SYNOPSIS:	Returns the file name of the current file in this dir block

    RETURNS:	Pointer to the files name

    NOTES:	The client should be sure that FindFirst has successfully
		been called on this dir block before invoking this method.

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

const TCHAR * W32_DIR_BLOCK::QueryFileName( void )
{
    return _win32FindData.cFileName ;
}

/*******************************************************************

    NAME:	W32_FS_ENUM::W32_FS_ENUM

    SYNOPSIS:	Constructor for an Win32 File/directory enumerator

    ENTRY:	pszPath - Base path to start the enumeration
		pszMask - Mask to filter the files/dirs with
		filtypInclude - include files/dirs or both

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created
	Johnl	26-Oct-1992	Added nMaxDepth

********************************************************************/

W32_FS_ENUM::W32_FS_ENUM ( const TCHAR * pszPath,
			   const TCHAR * pszMask,
			   enum FILE_TYPE filtypeInclude,
			   BOOL fDepthFirst,
			   UINT nMaxDepth )
    : FS_ENUM( pszPath, pszMask, filtypeInclude, fDepthFirst, nMaxDepth )
{
    if ( QueryError() )
	return ;
}

W32_FS_ENUM::~W32_FS_ENUM ()
{   /* Nothing to do */  }

/*******************************************************************

    NAME:	W32_FS_ENUM::FindFirst

    SYNOPSIS:	Regular FindFirst redefinition, calls FindFirstFile

    ENTRY:	See parent

    EXIT:

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

APIERR W32_FS_ENUM::FindFirst( DIR_BLOCK * pDirBlock,
			       const NLS_STR & nlsSearchPath,
			       UINT uiSearchAttr )
{
    APIERR err = NERR_Success ;

    W32_DIR_BLOCK * pW32DirBlock = (W32_DIR_BLOCK *) pDirBlock ;
    pW32DirBlock->_hDir = ::FindFirstFile( (LPTSTR) nlsSearchPath.QueryPch(),
					     &(pW32DirBlock->_win32FindData) ) ;

    if ( INVALID_HANDLE_VALUE == pW32DirBlock->_hDir )
	err = ::GetLastError() ;

    return err ;
}

/*******************************************************************

    NAME:	W32_FS_ENUM::FindNext

    SYNOPSIS:	Typical FindNext redefinition, calls DosFindNext

    ENTRY:	See parent

    EXIT:

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

APIERR W32_FS_ENUM::FindNext(  DIR_BLOCK * pDirBlock, UINT uiSearchAttr  )
{
    W32_DIR_BLOCK * pW32DirBlock = (W32_DIR_BLOCK *) pDirBlock ;
    if ( !::FindNextFile(  pW32DirBlock->_hDir,
			   &(pW32DirBlock->_win32FindData) ))
    {
	return ::GetLastError() ;
    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:	W32_FS_ENUM::CreateDirBlock

    SYNOPSIS:	Typical redefinition of CreateDirBlock

    ENTRY:

    EXIT:

    RETURNS:	A pointer to a newly created W32_DIR_BLOCK

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

DIR_BLOCK * W32_FS_ENUM::CreateDirBlock( void )
{
    return new W32_DIR_BLOCK() ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\fsenum\fsenum.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    FSEnum.cxx

    This file contains the implementation of FS_ENUM file/directory enumerator.
    These are used for traversing files and directories This exists only under the Win32 uimisc libraries

    FILE HISTORY:
	Johnl	04-Oct-1991	Created

*/

#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETLIB
#include "lmui.hxx"

#include "uiassert.hxx"
#include "uitrace.hxx"
#include "fsenum.hxx"

DEFINE_SLIST_OF( DIR_BLOCK )


/*******************************************************************

    NAME:	DIR_BLOCK::DIR_BLOCK

    SYNOPSIS:	Constructor for the DIR_BLOCK

    ENTRY:

    EXIT:	The count is initialized to -1.

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

DIR_BLOCK::DIR_BLOCK()
    : _fHasFindFirstBeenCalled( FALSE ),
      _fBreadthFirstDoDirs    ( FALSE ),
      _strlistIter( _strlistBreadthFirstDirs )
{
    if ( QueryError() )
	return ;
}

DIR_BLOCK::~DIR_BLOCK()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	FS_ENUM::FS_ENUM

    SYNOPSIS:	Constructor for FS_ENUM class

    ENTRY:	pszOrgPath - Base path to start enumerating from (should be
		    directory name).  A '\\' will be appended if it does
		    not end in one.

		pszMask - Search mask

		filtypInclude - Indicates if we should include files, dirs
		    or both.


    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

const TCHAR * FS_ENUM :: _pszAllFilesMask = SZ("*.*");

FS_ENUM::FS_ENUM( const TCHAR * pszOrgPath,
		      const TCHAR * pszMask,
		      enum FILE_TYPE filtypeInclude,
		      BOOL  fDepthFirst,
		      UINT  nMaxDepth )
    : _cTotalFiles	   ( 0 ),
      _filtypInclude	   ( filtypeInclude ),
      _nlsMask		   ( pszMask ),
      _nlsPath		   ( pszOrgPath ),	// These are ALIAS_STRs
      _nlsDot		   ( SZ(".") ),
      _nlsDotDot	   ( SZ("..") ),
      _errLastError	   ( NERR_Success ),
      _pCurrentDirBlock    ( NULL ),
      _slStackOfDirBlocks  (),
      _fDepthFirst	   ( fDepthFirst ),
      _nMaxDepth	   ( nMaxDepth ),
      _nCurrentDepth	   ( 0 )
{
    if ( QueryError() )
	return ;

    APIERR err ;
    if ( err = _nlsPath.QueryError() )
    {
	ReportError( err ) ;
	return ;
    }

    /* If the path doesn't end in a '\\', then append one.
     */
    ISTR istrLastSlash( _nlsPath ) ;
    if ( _nlsPath.strrchr( &istrLastSlash, TCH('\\') ) )
    {
	if ( !istrLastSlash.IsLastPos() )
	    err = _nlsPath.AppendChar( TCH('\\') ) ;
    }
    else
	err = _nlsPath.AppendChar( TCH('\\') ) ;

    if ( err )
    {
	ReportError( err ) ;
	return ;
    }
}

FS_ENUM::~FS_ENUM()
{
    TRACEEOL("FS_ENUM: Traversed " << _cTotalFiles << " files and dirs") ;
    delete _pCurrentDirBlock ;
    _pCurrentDirBlock = NULL ;
}

/*******************************************************************

    NAME:	FS_ENUM::Next( void )

    SYNOPSIS:	Does a depth first or breadth first enumeration

    NOTES:

    HISTORY:
	Johnl	10-Sep-1992	Created

********************************************************************/

BOOL FS_ENUM::Next( void )
{
    if ( _fDepthFirst )
	return NextDepthFirst() ;
    else
	return NextBreadthFirst() ;
}

/*******************************************************************

    NAME:	FS_ENUM::NextDepthFirst

    SYNOPSIS:	Attempts to retrieve the next file in this enumeration
		in a depth first fashion

    ENTRY:

    RETURNS:	TRUE if successful, FALSE if an error occurred or there are
		no more files to retrieve.

    NOTES:	The "." and ".." entries are filtered out

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

BOOL FS_ENUM::NextDepthFirst( void )
{
    APIERR err = NERR_Success ;

    if ( QueryCurrentDirBlock() == NULL )
    {
	/* Very first Next() since this object was instantiated, so we need
	 * to prime the pump.
	 */
	if ( err = PushDir() )
	    ReportLastError( err ) ;
    }

    BOOL fRepeat = TRUE ;
    while ( err == NERR_Success && fRepeat )
    {
	if ( !QueryCurrentDirBlock()->HasFindFirstBeenCalled() )
	{
	    NLS_STR nlsSearchPath( _nlsPath ) ;
	    nlsSearchPath += _nlsMask ;
	    if ( err = nlsSearchPath.QueryError() )
		break ;

	    err = FindFirst( QueryCurrentDirBlock(),
			     nlsSearchPath,
			     QuerySearchAttr() |
			     _A_RDONLY |_A_ARCH | _A_HIDDEN | _A_SYSTEM ) ;
	    if ( err == NERR_Success )
		QueryCurrentDirBlock()->SetFindFirstFlag( TRUE ) ;

	    /* Map a file not found error to a no more files error (NTFS
	     * may return file not found if the directory is empty).
	     */
	    if ( err == ERROR_FILE_NOT_FOUND )
	    {
		err = ERROR_NO_MORE_FILES ;
            }
            else if ( err )
            {
                //
                //  Try and recover by discarding the failing directory
                //
                (void) PopDir() ;
                break ;
            }
	}
	else
	{
	    err = FindNext(  QueryCurrentDirBlock(),
			     QuerySearchAttr() |
			     _A_RDONLY |_A_ARCH | _A_HIDDEN | _A_SYSTEM ) ;
	}

	if ( !err &&
	     QueryCurrentDirBlock()->IsDir() &&
	     ::strcmpf( _nlsDot, QueryCurrentDirBlock()->QueryFileName()) &&
	     ::strcmpf( _nlsDotDot, QueryCurrentDirBlock()->QueryFileName()) &&
	     QueryCurrentDepth() < QueryMaxDepth() )
	{
	    if ( err = PushDir() )
		break ;

	    /* We have a fresh DIR_BLOCK, so initialize it with a FindFirst
	     */
	    continue ;
	}

	//
	// Restore the containing directory and return that to the user
	//

        if ( err )
	{
	    err = PopDir() ;
        }

	if ( err == NERR_Success )
	{
	    ALIAS_STR nlsDirName( QueryCurrentDirBlock()->QueryFileName() ) ;

	    /* We don't include the "." and ".." entries in the directory
	     * listing.
	     */
	    if (  nlsDirName != _nlsDot &&
		  nlsDirName != _nlsDotDot &&
		  ShouldThisFileBeIncluded( QueryCurrentDirBlock()->QueryAttr()) )
	    {
		/* We have found what we were looking for
		 */
		fRepeat = FALSE ;
		_cTotalFiles++ ;
	    }
	}
    }

    if ( err )
	ReportLastError( err ) ;

    return (err == NERR_Success) ;
}

/*******************************************************************

    NAME:	FS_ENUM::NextBreadthFirst

    SYNOPSIS:	Attempts to retrieve the next file in this enumeration
		in a Breadth first fashion

    ENTRY:

    RETURNS:	TRUE if successful, FALSE if an error occurred or there are
		no more files to retrieve.

    NOTES:	The "." and ".." entries are filtered out

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

BOOL FS_ENUM::NextBreadthFirst( void )
{
    APIERR err = NERR_Success ;

    if ( QueryCurrentDirBlock() == NULL )
    {
	/* Very first Next() since this object was instantiated, so we need
	 * to prime the pump.
	 */
	if ( err = PushDir() )
	    ReportLastError( err ) ;
    }

    BOOL fRepeat = TRUE ;
    while ( err == NERR_Success && fRepeat )
    {
	/* Check to see if we are working on our queued list of directories
	 * in the current directory
	 */
	if ( QueryCurrentDirBlock()->DoBreadthFirstDirs() )
	{
	    NLS_STR * pnlsDirName = QueryCurrentDirBlock()->
						    QueryDirsIter()->Next() ;
	    if ( pnlsDirName != NULL &&
		 QueryCurrentDepth() < QueryMaxDepth())
	    {
		err = PushDir( *pnlsDirName ) ;
	    }
	    else
	    {
		/* This one is all used up, get rid of it and get a new one
		 */
		err = PopDir() ;
		continue ;
	    }

	}

	if ( !QueryCurrentDirBlock()->HasFindFirstBeenCalled() )
	{
	    NLS_STR nlsSearchPath( _nlsPath ) ;
	    nlsSearchPath += _nlsMask ;
	    if ( err = nlsSearchPath.QueryError() )
		break ;

	    err = FindFirst( QueryCurrentDirBlock(),
			     nlsSearchPath,
			     QuerySearchAttr() |
			     _A_RDONLY |_A_ARCH | _A_HIDDEN | _A_SYSTEM ) ;
	    if ( err == NERR_Success )
		QueryCurrentDirBlock()->SetFindFirstFlag( TRUE ) ;

	    /* Map a file not found error to a no more files error (NTFS
	     * may return file not found if the directory is empty).
	     */
	    if ( err == ERROR_FILE_NOT_FOUND )
	    {
		err = ERROR_NO_MORE_FILES ;
	    }
	}
	else
	{
	    err = FindNext(  QueryCurrentDirBlock(),
			     QuerySearchAttr() |
			     _A_RDONLY |_A_ARCH | _A_HIDDEN | _A_SYSTEM ) ;
	}

	/* If the current item is a directory, store it away and we will
	 * get back to it.
	 */
	if ( !err &&
	     QueryCurrentDirBlock()->IsDir() &&
	     ::strcmpf( _nlsDot, QueryCurrentDirBlock()->QueryFileName()) &&
	     ::strcmpf( _nlsDotDot, QueryCurrentDirBlock()->QueryFileName()) )
	{
	    /* Save away this directory name in the dirlist.  We will come
	     * back to it after we go through everything in this directory.
	     */
	    NLS_STR * pnlsDir = new NLS_STR(
				     QueryCurrentDirBlock()->QueryFileName() ) ;
	    err = ERROR_NOT_ENOUGH_MEMORY ;
	    if ( pnlsDir == NULL ||
		 (err = pnlsDir->QueryError()) ||
		 (err = QueryCurrentDirBlock()->QueryDirs()->Add( pnlsDir )) )
	    {
		/* Fall through
		 */
	    }
	}

	if ( err == NERR_Success )
	{
	    ALIAS_STR nlsDirName( QueryCurrentDirBlock()->QueryFileName() ) ;

	    /* We don't include the "." and ".." entries in the directory
	     * listing.
	     */
	    if (  nlsDirName != _nlsDot &&
		  nlsDirName != _nlsDotDot &&
		  ShouldThisFileBeIncluded( QueryCurrentDirBlock()->QueryAttr()) )
	    {
		/* We have found what we were looking for
		 */
		fRepeat = FALSE ;
		_cTotalFiles++ ;
	    }
	}
	else if ( err == ERROR_NO_MORE_FILES )
	{
	    /* Now that we have traversed the directory, traverse the queued
	     * up dirs in this dir block
	     */
	    QueryCurrentDirBlock()->SetDoBreadthFirstDirs( TRUE ) ;
	    QueryCurrentDirBlock()->QueryDirsIter()->Reset() ;
	    err = NERR_Success ;
	}
    }

    if ( err )
	ReportLastError( err ) ;

    return (err == NERR_Success) ;
}


/*******************************************************************

    NAME:	FS_ENUM::PushDir

    SYNOPSIS:	We are about to plunge one level deeper in the directory
		tree, so save the current directory information and
		create a new DIR_BLOCK.

    ENTRY:	pszNewDir - Optional dir to use for new directory.  If NULL,
		  then current directory is used

    EXIT:

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:	If there is no current DIR_BLOCK, then this method will
		allocate one and do nothing else.

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

APIERR FS_ENUM::PushDir( const TCHAR * pszNewDir )
{
    APIERR err = NERR_Success ;

    /* Save the current DIR_BLOCK if one exists
     */
    if ( QueryCurrentDirBlock() != NULL )
    {
	err = _slStackOfDirBlocks.Add( QueryCurrentDirBlock() ) ;
    }

    if ( err == NERR_Success )
    {
	DIR_BLOCK * pDirBlock = CreateDirBlock() ;
	if ( pDirBlock == NULL )
	{
	    err = ERROR_NOT_ENOUGH_MEMORY ;
	}
	else if ( err = pDirBlock->QueryError() )
	{
	    delete pDirBlock ;
	}
	else
	{
	    if ( QueryCurrentDirBlock() != NULL )
	    {
		if ( pszNewDir == NULL )
		{
		    pszNewDir = QueryCurrentDirBlock()->QueryFileName() ;
		}

		ALIAS_STR nlsFileName( pszNewDir ) ;
		if ( (err = _nlsPath.Append( nlsFileName )) ||
		     (err = _nlsPath.AppendChar(TCH('\\')) ) )
		{
		    delete pDirBlock ;
		    return err ;
		}
	    }

	    SetCurrentDirBlock( pDirBlock ) ;
	    _nCurrentDepth++ ;
	}
    }

    return err ;
}

/*******************************************************************

    NAME:	FS_ENUM::PopDir

    SYNOPSIS:	We have enumerated all of the items in the current
		directory, so delete the current DIR_BLOCK and get
		the previous one.

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

APIERR FS_ENUM::PopDir( void )
{
    APIERR err = NERR_Success ;

    /* If there aren't any DIR_BLOCKs to pop, or we already popped the last
     * one, then notify the caller, otherwise, set the current dir block.
     */

    if ( QueryCurrentDirBlock() == NULL || _slStackOfDirBlocks.QueryNumElem() == 0 )
    {
	err = ERROR_NO_MORE_FILES ;
    }
    else
    {
	/* Take off the last directory component of the path
	 *   i.e., X:\A\B\C\ ==> X:\A\B\
	 */
	ISTR istrSep( _nlsPath ) ;
	REQUIRE( _nlsPath.strrchr( &istrSep, TCH('\\') ) ) ;
	UIASSERT( istrSep.IsLastPos() ) ;
	_nlsPath.DelSubStr( istrSep ) ;
	istrSep.Reset() ;
	REQUIRE( _nlsPath.strrchr( &istrSep, TCH('\\') ) ) ;
	++istrSep ;
	_nlsPath.DelSubStr( istrSep ) ;

	DIR_BLOCK * pAboutToBeDeleteDirBlock = QueryCurrentDirBlock() ;
	delete pAboutToBeDeleteDirBlock ;

	ITER_SL_OF( DIR_BLOCK ) itersldirblock( _slStackOfDirBlocks ) ;
	itersldirblock.Next() ;
	SetCurrentDirBlock( _slStackOfDirBlocks.Remove( itersldirblock ) ) ;
	UIASSERT(  QueryCurrentDirBlock() != NULL ) ;
	_nCurrentDepth-- ;
    }

    return err ;
}

/*******************************************************************

    NAME:	FS_ENUM::QueryName

    SYNOPSIS:	Returns the qualified name of the current file.  The name
		will be based on the path that was passed in to
		the FS_ENUM constructor.

    ENTRY:	pnlsQualifiedName - pointer to NLS_STR that will receive
		    the string

    EXIT:

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

APIERR FS_ENUM::QueryName( NLS_STR * pnlsQualifiedName ) const
{
    *pnlsQualifiedName = _nlsPath ;
    ALIAS_STR nlsFileName( QueryCurrentDirBlock()->QueryFileName() ) ;
    *pnlsQualifiedName += nlsFileName ;

    //
    //  If the path ends in a slash, then remove the trailing slash
    //
    ISTR istr1( *pnlsQualifiedName ) ;
    if ( pnlsQualifiedName->strrchr( &istr1, TCH('\\')) )
    {
        ISTR istr2( istr1 ) ;
        ++istr1;
        if ( pnlsQualifiedName->QueryChar( istr1 ) == TCH('\0') )
        {
            pnlsQualifiedName->DelSubStr( istr2 ) ;
        }
    }
    return pnlsQualifiedName->QueryError() ;
}


/*******************************************************************

    NAME:	FS_ENUM::ShouldThisFileBeIncluded

    SYNOPSIS:	Based on the attributes and what the current client
		requested, determine whether this file/dir should be
		returned to the user (i.e., filter unwanted files/dirs).

    ENTRY:	uiAttr - Attribute mask of the file/dir in question

    EXIT:

    RETURNS:	Returns TRUE if this file/dir should be returned to the user,
		FALSE otherwise

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

BOOL FS_ENUM::ShouldThisFileBeIncluded( UINT uiAttr ) const
{
    BOOL fRet = FALSE ;

    if ( _filtypInclude == FILTYP_ALL_FILES )
	fRet = TRUE ;
    else if ( uiAttr & _A_SUBDIR )
    {
	fRet = ( _filtypInclude == FILTYP_DIRS ) ;
    }
    else
    {
	fRet = ( _filtypInclude == FILTYP_FILES ) ;
    }

    return fRet ;
}

/*******************************************************************

    NAME:	FS_ENUM::QuerySearchAttr

    SYNOPSIS:	Returns the attribute mask we pass to the findfirst/next
		methods based on what the client wanted

    RETURNS:	Attribute mask that is to be passed to FindFirst.

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

UINT FS_ENUM::QuerySearchAttr( void ) const
{   return ( _filtypInclude==FILTYP_ALL_FILES ? _A_NORMAL | _A_SUBDIR :
	     _filtypInclude==FILTYP_DIRS ? _A_SUBDIR :
	     _filtypInclude==FILTYP_FILES? _A_NORMAL | _A_SUBDIR : 0 ) ; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\heap\heapbase.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    HEAPBASE.CXX
    Base classes for both Global and ONE_SHOT_HEAPs.

    Abstract classes for heap operations.  The LOCAL_HEAP classes
    create objects whose memory is allocated from LocalAlloc.
    The BASE_HEAP object is a LOCAL_HEAP which contains a handle
    (selector) for a BUFFER object.


    FILE HISTORY:
	DavidHov    2-25-91	    Created
	beng	    01-May-1991     Uses lmui.hxx

*/

#ifdef WINDOWS

#define INCL_WINDOWS
#include "lmui.hxx"

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

extern "C"
{
    #include "locheap2.h"   // Local heap C/ASM routines
}

#include "uiassert.hxx"
#include "heap.hxx"

long LOCAL_HEAP_OBJ::_cLocalFreeErrors = 0 ;


/**********************************************************************

    NAME:	LOCAL_HEAP_OBJ::QueryBlockSize

    SYNOPSIS:	LOCAL_HEAP_OBJ is a base class for things which
		are allocated from the DS-relative local heap.
		LOCAL_HEAP_OBJ::Size returns the size of a block

    ENTRY:	Pointer to block in question

    EXIT:	Size of block or zero if it could not be converted
		to a handle.

    NOTES:

    HISTORY:
	davidhov    ??-???-1991     Created

**********************************************************************/

USHORT LOCAL_HEAP_OBJ::QueryBlockSize( VOID * pbBlock )
{
    HANDLE hMem = LocalHandle( LOWORD( pbBlock ) ) ;
    return hMem ? LocalSize( hMem ) : 0 ;
}


/**********************************************************************

    NAME:	LOCAL_HEAP_OBJ::operator new

    SYNOPSIS:	Allocate memory on the local heap.

    ENTRY:	Requires the size of block to be allocated.

    EXIT:	Returns VOID pointer to block allocated.

    NOTES:

    HISTORY:
	davidhov    ??-???-1991     Created

**********************************************************************/

VOID * LOCAL_HEAP_OBJ::operator new( size_t cb )
{
    HANDLE hMem = LocalAlloc( LMEM_FIXED, (USHORT) cb) ;
    if ( hMem )
    {
       return (VOID *) LocalLock( hMem ) ;
    }
    else
    {
       return NULL ;
    }
}


/**********************************************************************

    NAME:	LOCAL_HEAP_OBJ::operator delete

    SYNOPSIS:	Delete a block allocated on the local heap.

    ENTRY:	Pointer to block

    EXIT:	Nothing

    NOTES:

    HISTORY:
	davidhov    ??-???-1991     Created

**********************************************************************/

VOID LOCAL_HEAP_OBJ::operator delete( VOID * pbBlock )
{
    if ( pbBlock == NULL )
      return ;

    HANDLE hMem = LocalHandle( LOWORD( pbBlock ) ) ;
    if (   hMem == NULL
	 || (LocalUnlock( hMem ) != 0)
	 || (LocalFree( hMem ) != NULL) )
    {
      _cLocalFreeErrors++ ;
    }
}


/**********************************************************************

    NAME:	BASE_HEAP::BASE_HEAP

    SYNOPSIS:	Default constructor for an empty BASE_HEAP.
		Used by MEM_MASTER to represent the DS-relative heap.

    ENTRY:

    EXIT:

    NOTES:
	This constructor is used only for MEM_MASTER,
	and exploits the fact that a BUFFER of zero
	length can be created.	Such a BUFFER has no
	global block associated with it.


    HISTORY:
	davidhov    ??-???-1991     Created

**********************************************************************/

BASE_HEAP::BASE_HEAP ( )
    : BUFFER( 0 )
{
    ;
}


/**********************************************************************

    NAME:	BASE_HEAP::BASE_HEAP

    SYNOPSIS:	This constructor is used to create all
		SUB_HEAPs and GIANT_HEAPs.

    ENTRY:	Requires the size of the initial allocation

    EXIT:	Nothing

    NOTES:

    HISTORY:
	davidhov    ??-???-1991     Created

**********************************************************************/

BASE_HEAP::BASE_HEAP ( USHORT cbInitialAllocSize )
     : BUFFER( cbInitialAllocSize )
{
    ;
}


/**********************************************************************

    NAME:	BASE_HEAP::~BASE_HEAP

    SYNOPSIS:	Standard deconstructor.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	davidhov    ??-???-1991     Created

**********************************************************************/

BASE_HEAP::~BASE_HEAP ()
{
    ;
}


#endif // WINDOWS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\fsenum\fsenmlfn.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    FSEnmLFN.cxx

    This file contains the implementation of WINNET_LFN_FS_ENUM
    These are used for traversing files and directories
    on a volume when under Win16 and the volume supports long filenames.



    FILE HISTORY:
	Johnl	04-Oct-1991	Created

*/

#define INCL_DOSERRORS
#define INCL_NETERRORS
//#define INCL_OS2
#define INCL_WINDOWS
#include "lmui.hxx"

#include "fsenum.hxx"

extern "C"
{
    #define LFN
    #include "winnet.h"
}

/*************************************************************************

    NAME:	WINNET_LFN_DIR_BLOCK

    SYNOPSIS:	Dir block that contains the OS2 File Find buffer


    INTERFACE:	See parent

    PARENT:	DIR_BLOCK

    USES:	FILEFINDBUF2

    CAVEATS:


    NOTES:


    HISTORY:
	Johnl	16-Oct-1991	Created

**************************************************************************/

class WINNET_LFN_DIR_BLOCK : public DIR_BLOCK
{
friend class WINNET_LFN_FS_ENUM ;

private:
    UINT   _hdir ;

    /* Note: the _achFileNamePad must immediately follow the _ffbuff2
     * structure.
     */
    struct FILEFINDBUF2 _ffbuff2 ;
    BYTE		_achFileNamePad[ 260 ] ;    // Can we get the manifiest?

public:
    WINNET_LFN_DIR_BLOCK()
    {  /* Nothing else to do */ }

    virtual ~WINNET_LFN_DIR_BLOCK() ;

    virtual UINT QueryAttr( void ) ;
    virtual const TCHAR * QueryFileName( void ) ;

} ;

WINNET_LFN_DIR_BLOCK::~WINNET_LFN_DIR_BLOCK()
{
    LFNFindClose( _hdir ) ;
}

/*******************************************************************

    NAME:	WINNET_LFN_DIR_BLOCK::QueryAttr

    SYNOPSIS:	Returns the file attributes for the current file

    RETURNS:	Bit mask of the current file attributes

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

UINT WINNET_LFN_DIR_BLOCK::QueryAttr( void )
{
    return (UINT) _ffbuff2.attr ;
}

/*******************************************************************

    NAME:	WINNET_LFN_DIR_BLOCK::QueryFileName

    SYNOPSIS:	Returns the file name of the current file in this dir block

    RETURNS:	Pointer to the files name

    NOTES:	The client should be sure that FindFirst has successfully
		been called on this dir block before invoking this method.

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

const TCHAR * WINNET_LFN_DIR_BLOCK::QueryFileName( void )
{
    return (const TCHAR *) _ffbuff2.achName ;
}

/*******************************************************************

    NAME:	WINNET_LFN_FS_ENUM::WINNET_LFN_FS_ENUM

    SYNOPSIS:	Constructor for a WINNET LFN File/directory enumerator

    ENTRY:	pszPath - Base path to start the enumeration
		pszMask - Mask to filter the files/dirs with
		filtypInclude - include files/dirs or both

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

WINNET_LFN_FS_ENUM::WINNET_LFN_FS_ENUM ( const TCHAR * pszPath,
					     const TCHAR * pszMask,
					     enum FILE_TYPE filtypeInclude )
    : FS_ENUM( pszPath, pszMask, filtypeInclude )
{
    if ( QueryError() )
	return ;
}

WINNET_LFN_FS_ENUM::~WINNET_LFN_FS_ENUM ()
{   /* Nothing to do */  }

/*******************************************************************

    NAME:	WINNET_LFN_FS_ENUM::FindFirst

    SYNOPSIS:	Regular FindFirst redefinition, calls LFNFindFirst

    ENTRY:	See parent

    EXIT:

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

APIERR WINNET_LFN_FS_ENUM::FindFirst( DIR_BLOCK * pDirBlock,
				 const NLS_STR & nlsSearchPath,
				 UINT uiSearchAttr )
{
    UINT uiSearchCount = 1 ;
    WINNET_LFN_DIR_BLOCK * pOS2DirBlock = (WINNET_LFN_DIR_BLOCK *) pDirBlock ;
    return LFNFindFirst( (char *) nlsSearchPath.QueryPch(),
			   (WORD) uiSearchAttr,
			  (int *) &uiSearchCount,
			  (int *) &(pOS2DirBlock->_hdir),
				  sizeof( pOS2DirBlock->_ffbuff2 ) +
				      sizeof( pOS2DirBlock->_achFileNamePad ),
				  &(pOS2DirBlock->_ffbuff2) ) ;
}

/*******************************************************************

    NAME:	WINNET_LFN_FS_ENUM::FindNext

    SYNOPSIS:	Typical FindNext redefinition, calls LFNFindNext

    ENTRY:	See parent

    EXIT:

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

APIERR WINNET_LFN_FS_ENUM::FindNext(  DIR_BLOCK * pDirBlock, UINT uiSearchAttr	)
{
    UINT uiSearchCount = 1 ;
    WINNET_LFN_DIR_BLOCK * pOS2DirBlock = (WINNET_LFN_DIR_BLOCK *) pDirBlock ;
    return LFNFindNext(  pOS2DirBlock->_hdir,
			 (int *) &uiSearchCount,
			 sizeof( pOS2DirBlock->_ffbuff2 ) +
			   sizeof( pOS2DirBlock->_achFileNamePad ),
			 &(pOS2DirBlock->_ffbuff2) ) ;
}

/*******************************************************************

    NAME:	WINNET_LFN_FS_ENUM::CreateDirBlock

    SYNOPSIS:	Typical redefinition of CreateDirBlock

    ENTRY:

    EXIT:

    RETURNS:	A pointer to a newly created WINNET_LFN_DIR_BLOCK

    NOTES:

    HISTORY:
	Johnl	16-Oct-1991	Created

********************************************************************/

DIR_BLOCK * WINNET_LFN_FS_ENUM::CreateDirBlock( void )
{
    return new WINNET_LFN_DIR_BLOCK() ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\heap\heapbig.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    HEAPBIG.CXX
    Main methods for Global Heap

       Notes on HEAP classes:
       ----------------------

	The Global Heap memory manager supports the allocation
	of smaller items from several heaps.  This is done by
	chaining a lists of such heaps together.  The heap objects
	themselves are allocated from local heap memory; the
	objects they create are allocated from global memory.

        This code depends upon the BUFFER routines for allocation
        of global memory.  All objects allocated herein must
        come from the local heap, so there is a virtual base
        class called LOCAL_HEAP_OBJ from which all the other
        classes inherit.

	A SUB_HEAP is a single heap object, limited to a 64K
	segment.  Its size is permanently constrained to that
	of its initial allocation, since all objects allocated
	in it are locked. (This could be changed to use BUFFER::Resize.)
        A SUB_HEAP is a BUFFER and a LOCAL_HEAP_OBJ.  That is,
        its instantiation allocates a small block of memory using
        LocalAlloc, and a large block of memory using GlobalAlloc.

	A GIANT_HEAP is a SUB_HEAP which can be extended to include
	more SUB_HEAPs, each of which is identified as being "owned"
	by the GIANT_HEAP. The GIANT_HEAP is "owned" by itself.

	A MEM_MASTER is a GIANT_HEAP which represents the local
	DS-based heap.	It cannot be extended.	There can only be
	one instance of MEM_MASTER, and it is globally available
	through _pmmInstance.  MEM_MASTER allocates through
        the latest created GIANT_HEAP.  Its static constructor creates
        a single GIANT_HEAP, which is all that most programs should
        ever need.

	The primary purpose of this program is to override the
	global "new" and "delete" operators to allocate from a
	GIANT_HEAP. The GIANT_HEAP in use is called the "focus" of
	MEM_MASTER.

	Only after a GIANT_HEAP has been created does allocation
	move outside the boundaries of the Windows DS.	The "focus"
	is automatically set to the base SUB_HEAP of the new GIANT_HEAP.

	The linked list of SUB_HEAPs might look like this:


	SUB_HEAP ---->SUB_HEAP----->SUB_HEAP----->SUB_HEAP----->SUB_HEAP
	GIANT_HEAP    GIANT_HEAP		  GIANT_HEAP	   ^
	MEM_MASTER	   ^			     ^		   |
	 ^ |		   |			     |		   |
	 | >---------------+-------------------------+-------------^
	 |  pointer to     |                         |
	 |  "focussed"	   |			     >--GIANT_HEAP
	 |  SUB_HEAP	   |				allocated by
	 |		   |				user
	 >--GIANT_HEAP	   >--GIANT_HEAP
	    representing      using Global
	    DS heap	      memory, allocated by MEM_MASTER's
			      static constructor


	Maintenance of the linked list and the focus pointer
	is automatic in class SUB_HEAP.

	When focus is set to a SUB_HEAP of a GIANT_HEAP other than
	MEM_MASTER (the normal case), allocation requests are routed
	to the GIANT_HEAP by ::new. It follows the chain of SUB_HEAPs,
	checking every SUB_HEAP it owns for one which has never
	denied a request for the amount of memory being sought.
	If it doesn't find such a SUB_HEAP, it allocates a new one.
	Maintenance of the "_cbLargestFailed" field in a SUB_HEAP is
	automatic, and is reset upon deallocation of a block larger
	than or equal to "_cbLargestFailed".

	In this same situation (focus is on a normal GIANT_HEAP),
	requests from ::delete are routed first to MEM_MASTER, which
	searches every SUB_HEAP for the SUB_HEAP whose selector matches
	the selector of the block about to be deallocated.  If
	it doesn't find one, it increments "_lcDeallocErrors".  The
	same thing happens if the caller should use GIANT_HEAP::Free(),
	but this is not a common case.

	These data structures have provisions for multiple GIANT_HEAPs;
	this is primarily to support the notion of "one-shot" heaps
	and other, possibly less expensive, allocation techniques.

	Debugging code and memory leak detection can also be done with
	GIANT_HEAPs.  If an outer "shell" program is using the normal
	GIANT_HEAP and is about to call a large separate phase, it can
	allocate a separate GIANT_HEAP.  All allocations in the new
	phase will automatically occur there, and upon return, the
	new GIANT_HEAP should be entirely empty.  If not, there was
	a leak during the phase.  Future enhancments could include
	discarding of entire SUB_HEAPs or even GIANT_HEAPs to protect
	programs from memory leaks or simplify error handling.


    USAGE IN DLLs and EXEs

	Due to the peculiar restrictions placed by Windows on memory
	management, there are two modes of initializing the MEM_MASTER
	object: DLL and non-DLL.  In non-DLL mode, everything is done
	as documented aboved and as one would reasonably expect.

	In DLL mode, the MEM_MASTER::InitForDll() routine is called.
	This routines allocates a parameterizable number of SUB_HEAPs
	of minimum size.  Because SUB_HEAPs are based on LocalAlloc
	behavior, they are automatically grown by Windows to the limits
	of the segment size within the operational mode.

	The reason for the preallocation is that DLLs are called with
	task identity of the calling task.  Therefore, new GlobalAlloc
	calls (done during BUFFER object construction) unfortunately
	belong to the calling task, and will be deallocated when the
	calling task terminates.  This behavior would be catastrophic for
	MEM_MASTER.

	The MEM_MASTER::InitForDll() routine is intended to be called
	during LIBENTRY processing of such DLLs as LANMAN.DRV.	In this
	special case, LANMAN.DRV is called by the Windows shell; memory
	is thus owned by the shell, which persists until Windows is
	terminated.


    REAL MODE WARNING!

	All sophistication is suppressed in real mode. GlobalAlloc
	and GlobalFree are used.  Only ::new and ::delete are supported.

    FILE HISTORY:
	DavidHov 01-Apr-1991	Created

	Johnl	27-Mar-1991	Changed Realmode GlobalAlloc flag from
				GMEM_FIXED to GMEM_MOVEABLE (was failing under
				real mode).
	ChuckC  31-Mar-1991     Added temporary GMEM_NODISCARD to above fix!
	ChuckC  12-Apr-1991     Made GlobalAlloc in real mode as _fmalloc does.
				FIXED and NODISCARD!

	DavidHov 28-Apr-1991	Modifications from code review

	KeithMo	08-Nov-1991	Added WIN32 support.

	DavidHov  1-14-92	Change SUB_HEAP destructor to NOT
				call Unlink() for invalid SUB_HEAPs. When
				system ran entirely out of memory,  attempt
				to unlink caused page fault.

				Added the ability to walk heaps through
				the Walk() members.  If HEAPDEBUG is
				defined, Walk() is functional.	This
				capability requires TOOLHELP.DLL.

   */

#if defined( WINDOWS ) && !defined( WIN32 )

#define INCL_WINDOWS
#include "lmui.hxx"

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif


extern "C"
{
    #include "locheap2.h"	// Local heap C/ASM routines
}

#include "heap.hxx"
//  #define HEAPDEBUG		//  Uncomment to activate Walk() members
#include "heapdbg.hxx"

#ifdef HEAPDEBUG
extern "C"
{
    #include <toolhelp.h>	//   Win 3.1 SDK defs for TOOLHELP.DLL
}
#endif


#define MAXUSHORT ((USHORT) 65535)

#define HEAP_INIT_ALLOC_EXE 16000    /*  Heaps grow automatically   */
#define HEAP_INIT_ALLOC_DLL 500
#define HEAP_RESIZE_ALLOC   1000

MEM_MASTER * SUB_HEAP::_pmmInstance = NULL ;

BOOL fHeapRealMode = FALSE ;


/*******************************************************************

    NAME:	SUB_HEAP::SUB_HEAP

    SYNOPSIS:	SUB_HEAP default constructor

    NOTES:
	Used by MEM_MASTER only to describe data segment.
	Parameterless constructor is only possible for DS.
	BUFFER class supports construction of a zero-length
	buffer.

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

SUB_HEAP::SUB_HEAP()
   : BASE_HEAP(),
   _cBlksOut( 0 ),
   _cbLargestFailed( MAXUSHORT ),
   _pOwner( NULL ),
   _lcDeallocErrors( 0 )
{
    _type = SHt_DS ;
    LockSegment( MAXUSHORT ) ;	// Lock data segment
    Init();
}


/*******************************************************************

    NAME:	SUB_HEAP::SUB_HEAP

    SYNOPSIS:	Normal SUB_HEAP constructor

    ENTRY:	USHORT -- amount of initial allocation for
			  SUB_HEAP BUFFER object.

    EXIT:

    RETURNS:

    NOTES:
	This is the normal SUB_HEAP constructor used
	for every SUB_HEAP except the initial MEM_MASTER.

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

SUB_HEAP::SUB_HEAP( USHORT cbInitialAllocSize )
    : BASE_HEAP( cbInitialAllocSize ),
    _cBlksOut( 0 ),
    _cbLargestFailed( MAXUSHORT ),
    _pOwner( NULL ),
    _lcDeallocErrors( 0 )
{
    if (   QuerySize() >= cbInitialAllocSize
	&& DoLocalInit( QuerySel(), (USHORT) QuerySize() ) )
    {
       _type = SHt_Normal ;
       Init();
    }
    else
    {
       _type = SHt_Invalid ;
    }
}


/*******************************************************************

    NAME:	SUB_HEAP::Init

    SYNOPSIS:	Common initialization for a SUB_HEAP
		Initialize the instance variables.  The owner pointer
		is set to self by default.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

VOID SUB_HEAP::Init()
{
   Link();
}


/*******************************************************************

    NAME:	SUB_HEAP::Link

    SYNOPSIS:	Inserted the SUB_HEAP onto the linked list
		whose anchor is pointed to by _pmmInstance.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:
	If _pmmInstance is NULL, this is the construction
	of MEM_MASTER.

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

VOID SUB_HEAP::Link()
{
    //	Control linkage onto the _pmmInstance list.  Note
    //	that this may be the initialization of MEM_MASTER.

    if ( _pmmInstance != NULL )
    {
       _pBack = _pmmInstance->_pBack ;
       _pFwd = _pmmInstance ;
       _pFwd->_pBack = this ;
       _pBack->_pFwd = this ;
       _pmmInstance->SetFocus( this ) ;
    }
    else
    {  // MEM_MASTER initialization
       _pFwd = _pBack = this ;
    }
}


/*******************************************************************

    NAME:	SUB_HEAP::Unlink

    SYNOPSIS:	Remove the SUB_HEAP from the linked list attached
		to MEM_MASTER.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

VOID SUB_HEAP::Unlink()
{
    SUB_HEAP * pSub ;

    _pFwd->_pBack = _pBack ;
    _pBack->_pFwd = _pFwd ;
    _pBack = _pFwd = this ;

    //	Check to see if this is the focussed SUB_HEAP. If so,
    //	refocus MEM_MASTER to another SUB_HEAP or GIANT_HEAP
    //	(including, possibly, itself).

    if ( _pmmInstance->GetSubFocus() == this )
    {
	if (   _pOwner == NULL	 //  Construction failure
	    || (pSub = _pOwner->QueryLatest()) == NULL )
	{
	   pSub = _pmmInstance->_pBack ;
	}
	_pmmInstance->SetFocus( pSub ) ;
    }
}


/*******************************************************************

    NAME:	SUB_HEAP::~SUB_HEAP

    SYNOPSIS:	SUB_HEAP Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:
	There is a single SHt_DS type SUB_HEAP, namely,
	MEM_MASTER. The others are normal.  Normal
	SUB_HEAPs are deallocated by their BUFFER
	destructors.

    HISTORY:
	davidhov    01-Apr-1991     Created
	DavidHov    01-18-92	    Changed to not call Unlink()
				    unless sucessfully constructed.

********************************************************************/

SUB_HEAP::~SUB_HEAP()
{
    switch ( _type )
    {
    case SHt_DS:
	UnlockSegment( MAXUSHORT ) ; // Unlock DS (see constructor)
    case SHt_Normal:
	Unlink();		     // Delink this SUB_HEAP
    case SHt_Invalid:
	break ; 		     // Didn't construct-- do nothing
    default:
	UIASSERT( ! "Invalid memory heap destroyed" ) ;
	break ;
    }
    _type = SHt_Invalid ;
}


/*******************************************************************

    NAME:	SUB_HEAP::QueryOwner

    SYNOPSIS:	Return a pointer to the owning GIANT_HEAP

    ENTRY:

    EXIT:

    RETURNS:	GIANT_HEAP * --> owner of this SUB_HEAP.

    NOTES:

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

GIANT_HEAP * SUB_HEAP::QueryOwner()
{
    return _pOwner ;
}


/*******************************************************************

    NAME:	SUB_HEAP::Alloc

    SYNOPSIS:	Allocate memory in a SUB_HEAP

    ENTRY:	Amount of memory to allocate and flags.

    EXIT:	NULL if failure

    RETURNS:	BYTE * --> memory allocated

    NOTES:
	Flags are passed to DoLocalAlloc, but they
	are unused anywhere.

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

BYTE * SUB_HEAP::Alloc( USHORT cbBytes, USHORT fsFlags )
{
   BYTE * lpsResult = NULL ;
   HANDLE hand ;

   switch ( _type )
   {
   case SHt_DS:
      lpsResult = (BYTE *) LOCAL_HEAP_OBJ::operator new( cbBytes ) ;
      break ;
   case SHt_Normal:
      hand = DoLocalAlloc( QuerySel(), fsFlags, cbBytes ) ;
      if ( hand )
      {
	  lpsResult = (BYTE *) DoLocalLock( QuerySel(), hand ) ;
      }
      break ;
   default:
   case SHt_Invalid:
      UIASSERT( ! SZ("Attempt to allocate from invalid heap") );
      return NULL ;
      break ;
   }

   if ( lpsResult ) {
       _cBlksOut++ ;
   }
   else
   {
       if ( cbBytes < _cbLargestFailed )
	   _cbLargestFailed = cbBytes ;
   }
   return lpsResult ;
}


/*******************************************************************

    NAME:	SUB_HEAP::QueryBlockSize

    SYNOPSIS:	Returns the size of a previously allocated block

    ENTRY:	BYTE * --> block

    EXIT:	USHORT size of block or zero if block does not
		belong to this SUB_HEAP.

    RETURNS:

    NOTES:

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

USHORT SUB_HEAP::QueryBlockSize( BYTE * pbBlock )
{
    HANDLE hMem ;
    USHORT cbSize ;

    switch ( _type )
    {
    case SHt_DS:
       cbSize = LOCAL_HEAP_OBJ::QueryBlockSize( pbBlock ) ;
       break ;
    case SHt_Normal:
       hMem = DoLocalHandle( QuerySel(), LOWORD( pbBlock ) ) ;
       if ( hMem )
       {
	  cbSize = hMem ? DoLocalSize( QuerySel(), hMem ) : 0 ;
       }
       break ;
    default:
    case SHt_Invalid:
       UIASSERT( ! SZ("Attempt to QuerySize on invalid block") );
       cbSize = 0 ;
       break ;
    }
    return cbSize ;
}


/*******************************************************************

    NAME:	SUB_HEAP::Free

    SYNOPSIS:	Release memory allocated in this SUB_HEAP

    ENTRY:	BYTE * --> memory block

    EXIT:

    RETURNS:	TRUE if block belonged to this heap.

    NOTES:

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

BOOL SUB_HEAP::Free( BYTE * pbBlock )
{
    HANDLE hand ;
    BOOL fResult ;

    switch ( _type )
    {
    case SHt_DS:
	fResult = TRUE ;
	LOCAL_HEAP_OBJ::operator delete( pbBlock ) ;
	break ;
    case SHt_Normal:
	hand = DoLocalHandle( QuerySel(), LOWORD( pbBlock ) ) ;
	if ( fResult = (hand != NULL) )
	{
	   DoLocalUnlock( QuerySel(), hand );
	   hand = DoLocalFree( QuerySel(), hand ) ;
	}
	break ;
    case SHt_Invalid:
    default:
	UIASSERT( ! SZ("Attempt to Free invalid block") );
	return FALSE ;
	break ;
    }

    if ( fResult )
    {
	_cbLargestFailed = MAXUSHORT ;
	_cBlksOut-- ;
    }
    else
    {
	_lcDeallocErrors++ ;
    }
    return fResult ;
}


/*******************************************************************

    NAME:	SUB_HEAP::CalcDeallocErrors

    SYNOPSIS:	Calculate (return) number of deallocation errors

    ENTRY:

    EXIT:

    RETURNS:	ULONG number of deallocation errors against this
		SUB_HEAP

    NOTES:

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

ULONG SUB_HEAP::CalcDeallocErrors()
{
    return _lcDeallocErrors ;
}

/*******************************************************************

    NAME:	SUB_HEAP::Walk

    SYNOPSIS:	DEBUGGING:  Walk the heap using the TOOLHELP routines.

    ENTRY:	Nothing

    EXIT:	Nothing

    RETURNS:	BOOL TRUE if heap is in good condition.

    NOTES:	If HEAPDEBUG is not set, will always return TRUE.

    HISTORY:

********************************************************************/
BOOL SUB_HEAP :: Walk ()
{
    BOOL fResult = TRUE ;

#ifdef HEAPDEBUG

    LOCALENTRY leHeap, lePrior ;
    LOCALINFO  liHeap ;
    union {
	HEAPTAG * phtNext ;
	struct {
	    USHORT offs, seg ;
	} addr ;
    } up ;
    int cItems ;

    //	Initialize the data structures.
    liHeap.dwSize = sizeof liHeap ;
    leHeap.dwSize = sizeof leHeap ;

    //	Get basic information about the heap
    fResult = ::LocalInfo( & liHeap, QuerySel() ) ;

    if ( ! fResult ) return FALSE ;

    //	Walk across every item
    BOOL fNext = ::LocalFirst( & leHeap, QuerySel() ) ;

    for ( cItems = 1 ; fNext ; cItems++ )
    {
	up.addr.offs = leHeap.wAddress ;
	up.addr.seg = QuerySel() ;
	//  HEAPTAG * up.phtNext is now valid.
	lePrior = leHeap ; // Save last descriptor.
	fNext = ::LocalNext( & leHeap ) ;
    }

#endif

    return fResult ;
}

/*******************************************************************

    NAME:	GIANT_HEAP::GIANT_HEAP

    SYNOPSIS:	Implicit constructor for a GIANT_HEAP

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:
	Implicit private constructor : used by
	MEM_MASTER only.

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

GIANT_HEAP::GIANT_HEAP()
    : _cbInitAlloc( 0 ),
    _fsBehave( 0 ),	//  No fancy behavior for DS default GIANT_HEAP
    _cExpandErrors( 0 )
{
    _pOwner = this ;
}


/*******************************************************************

    NAME:	GIANT_HEAP::GIANT_HEAP

    SYNOPSIS:	Normal GIANT_HEAP constructor

    ENTRY:	USHORT size to use for initial allocation of
		SUB_HEAPs

    EXIT:

    RETURNS:

    NOTES:
	Public constructor.  Default behavior is set to
	extend (add new SUB_HEAPs) when necessary and resize
	(downsize) SUB_HEAPs when empty.

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

GIANT_HEAP::GIANT_HEAP( USHORT cbInitialAllocation )
    : SUB_HEAP( cbInitialAllocation )
{
    _pOwner = this ;
    _cbInitAlloc = cbInitialAllocation ;
    _fsBehave = GHbExtend | GHbResize ;
}


/*******************************************************************

    NAME:	GIANT_HEAP::~GIANT_HEAP

    SYNOPSIS:	Destroy a GIANT_HEAP

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:
	Release all the SUB_HEAPs but this one; internal
	BUFFER object will be automatically deconstructed
	at exit (via ~SUB_HEAP).

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

GIANT_HEAP::~GIANT_HEAP()
{
    SUB_HEAP * pSheap ;
    SUB_HEAP * pSnext ;

    //	Deconstruct all of our SUB_HEAPS

    for ( pSnext = _pFwd ;
	  pSnext != _pmmInstance ; )
    {
	pSheap = pSnext ;
	pSnext = pSnext->_pFwd ;
	if ( pSheap->_pOwner == this )
	{
	    delete pSheap ;
	}
    }
}


/*******************************************************************

    NAME:	GIANT_HEAP::GrowAndAlloc

    SYNOPSIS:	Add another SUB_HEAP to the ensemble.

    ENTRY:	USHORT count of bytes to be added;
		USHORT allocation flags (unused)

    EXIT:	NULL if error

    RETURNS:	BYTE * --> memory allocated

    NOTES:
	This routine creates another SUB_HEAP owned
	by this GIANT_HEAP.

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

BYTE * GIANT_HEAP::GrowAndAlloc( USHORT cbBytes, USHORT fsFlags )
{
    // See if the requested size is larger than the previous
    // initial allocation.  If so, change initial allocation.

    if ( _cbInitAlloc > cbBytes )
       cbBytes = _cbInitAlloc ;

    // Create a new SUB_HEAP...

    SUB_HEAP * pSub = new SUB_HEAP( cbBytes ) ;
    if ( pSub == NULL || pSub->_type == SHt_Invalid )
    {
      _cExpandErrors++ ;
      if ( pSub ) {
	 delete pSub ;
      }
      return NULL ;
    }

    pSub->_pOwner = this ;
    return pSub->Alloc( cbBytes, fsFlags ) ;

}


/*******************************************************************

    NAME:	GIANT_HEAP::SetBehavior

    SYNOPSIS:	Control the behavior of a GIANT_HEAP

    ENTRY:	USHORT flag to adjust
		BOOL, set ON if TRUE

    EXIT:

    RETURNS:	BOOL, original value of behavior flag.

    NOTES:
	There are three behavior variables:

	    GHbExtend : allow extensions (new SUB_HEAPs)
	    GHbDelete : delete SUB_HEAPS when empty
	    GHbResize : resize the directory to a small
			value when empty.

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

BOOL GIANT_HEAP::SetBehavior( USHORT fFlag, BOOL fOnOff )
{
    BOOL fResult = (_fsBehave & fFlag) > 0 ;
    _fsBehave &= ~ fFlag ;
    if ( fOnOff ) {
	_fsBehave |= fFlag ;
    }
    return fResult ;
}


/*******************************************************************

    NAME:	GIANT_HEAP::QueryLatest

    SYNOPSIS:	Return a pointer to the latest SUB_HEAP

    ENTRY:

    EXIT:

    RETURNS:	SUB_HEAP * --> newest SUB_HEAP in the ensemble

    NOTES:
	Return a pointer to the newest SUB_HEAP associated with this
	GIANT_HEAP.  Note that when called by SUB_HEAP deconstructor,
	"this" GIANT_HEAP may not be in the linked list any longer.

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

SUB_HEAP * GIANT_HEAP::QueryLatest()
{
   SUB_HEAP * pSnext ;
   for ( pSnext = _pmmInstance->_pBack ;
	 pSnext != _pmmInstance && pSnext->_pOwner != this ;
	 pSnext = pSnext->_pBack )
	;

   return (pSnext != _pmmInstance) ? pSnext : NULL ;
}


/*******************************************************************

    NAME:	GIANT_HEAP::Alloc

    SYNOPSIS:	Allocate memory in a GIANT_HEAP

    ENTRY:

    EXIT:	NULL if no memory

    RETURNS:	BYTE * --> new memory

    NOTES:
	Searches the link list to its end trying
	to locate a SUB_HEAP which has never denied an
	allocation of this size.

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

BYTE * GIANT_HEAP::Alloc( USHORT cbBytes, USHORT fsFlags )
{
    //	Find a likely SUB_HEAP from which to allocate.	If none is found,
    //	add another. Note that we may be MEM_MASTER.

    SUB_HEAP * pSub = this ;
    BYTE * pbBlock = NULL ;

    do
    {
       // The qualification SUB_HEAP:: below is necessary; otherwise
       // Alloc() would be a recursive call back to this routine in
       // the case of the base GIANT_HEAP/SUB_HEAP.

	if ( pSub->_pOwner == this && pSub->_cbLargestFailed >= cbBytes )
	{
	   pbBlock = pSub->SUB_HEAP::Alloc( cbBytes, fsFlags ) ;
	}
	if ( pbBlock )
	{
	  break ;
	}
	pSub = pSub->_pFwd ;
    }
    while ( pSub != _pmmInstance ) ;

    if ( (pbBlock == NULL) && (_fsBehave & GHbExtend) )
    {
	pbBlock = GrowAndAlloc( cbBytes, fsFlags );
    }

    return pbBlock ;
}


/*******************************************************************

    NAME:	GIANT_HEAP::Free

    SYNOPSIS:	Release memory allocated by GIANT_HEAP::Alloc

    ENTRY:	BYTE * --> memory block

    EXIT:

    RETURNS:	TRUE if memory block belonged to a SUB_HEAP of
		this GIANT_HEAP.

    NOTES:
	Search the SUB_HEAPs of this GIANT_HEAP for the
	owner of this block, then give it to the SUB_HEAP
	for disposal.  Accumulate any error totals into
	our SUB_HEAP variables.

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

BOOL GIANT_HEAP::Free( BYTE * pbBlock )
{
    SUB_HEAP * pSnext = this ;
    BOOL fFound = FALSE ;
    USHORT selBlock = HIWORD( pbBlock ) ;

    do {
       if ( pSnext->_pOwner == this
	    && selBlock == pSnext->QuerySel() )
       {
	  fFound = TRUE ;
	  break ;
       }
       pSnext = pSnext->_pFwd ;
    }
    while ( pSnext != _pmmInstance ) ;

    // If found, give it to owning SUB_HEAP to be freed.
    // The qualification SUB_HEAP:: is necessary; otherwise Free()
    // would be a recursive call back to this routine in the case
    // of the base GIANT_HEAP itself.

    if ( fFound )
    {
       pSnext->SUB_HEAP::Free( pbBlock ) ;
       if ( pSnext->_cBlksOut == 0 )
       {
	  if (	(_fsBehave & GHbDelete)
	      && pSnext != this )
	  {
	      _lcDeallocErrors += pSnext->CalcDeallocErrors() ;
	      delete pSnext ;
	  }
	  else if ( _fsBehave & GHbResize )
	  {
	     //  Attempt to resize.  If Resize or LocalInit fails,
	     //  delete the degenerate subheap.

	     if (     pSnext->Resize( HEAP_RESIZE_ALLOC ) != 0
		  ||  (! DoLocalInit( pSnext->QuerySel(),
				 (USHORT) pSnext->QuerySize() ) ) )
		 delete pSnext ;
	  }
       }
       return TRUE ;

    }
    else
	return FALSE ;
}


/*******************************************************************

    NAME:	GIANT_HEAP::CalcDeallocErrors

    SYNOPSIS:	Walk thru the SUB_HEAPs and tally the deallocation
		failures

    ENTRY:

    EXIT:	ULONG count of all deallocation failures

    RETURNS:

    NOTES:
	Iterate through the ensemble and total the errors
	The GIANT_HEAP variable _lcDeallocErrors has accumulated
	all the errors from deleted SUB_HEAPs.

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

ULONG GIANT_HEAP::CalcDeallocErrors()
{
    SUB_HEAP * pSnext = this ;
    ULONG cTotalErrors = 0 ;

    do
    {
	cTotalErrors += pSnext->_lcDeallocErrors ;
	pSnext = pSnext->_pFwd ;
    }
    while ( pSnext != _pmmInstance ) ;

    return cTotalErrors ;
}


/*******************************************************************

    NAME:	GIANT_HEAP::QueryTotalBlocks

    SYNOPSIS:	Walk thru the SUB_HEAPs, tallying outstanding
		blocks.

    ENTRY:

    EXIT:	ULONG count of blocks active

    RETURNS:

    NOTES:

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

ULONG GIANT_HEAP::QueryTotalBlocks()
{
    SUB_HEAP * pSnext = this ;
    ULONG cTotalBlocks = 0 ;

    do
    {
	cTotalBlocks += pSnext->_cBlksOut ;
	pSnext = pSnext->_pFwd ;
    }
    while ( pSnext != _pmmInstance ) ;

    return cTotalBlocks ;

}


/*******************************************************************

    NAME:	MEM_MASTER::MEM_MASTER

    SYNOPSIS:	Create MEM_MASTER

    ENTRY:	USHORT initial allocation size for default
		GIANT_HEAP

    EXIT:

    RETURNS:

    NOTES:
	Initialize MEM_MASTER and create the first (and
	probably only) GIANT_HEAP if the initial allocation
	size is non-zero.  N.B. _pmmInstance is initialized
	here because the allocation of a GIANT_HEAP relies
	on this value being set.

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

MEM_MASTER::MEM_MASTER( USHORT cbInitAlloc )
    : GIANT_HEAP()
{
    GIANT_HEAP * pGheap ;

    UIASSERT( _pmmInstance == NULL ) ;

    _pmmInstance = this ;
    _pFocus = this ;

    if ( cbInitAlloc )
    {
	if ( pGheap = new GIANT_HEAP( cbInitAlloc ) )
	{
	    _pFocus = pGheap ;
	}
    }
}


/*******************************************************************

    NAME:	MEM_MASTER::Init

    SYNOPSIS:	(static) Construct and initialize MEM_MASTER

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:
	Initialization for a normal EXE. If real mode,
	just set the flag and exit.

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

BOOL MEM_MASTER::Init()
{
    ::fHeapRealMode = (GetWinFlags() & WF_PMODE) == 0 ;

    if ( ::fHeapRealMode )
	return TRUE ;

    new MEM_MASTER( (USHORT) HEAP_INIT_ALLOC_EXE ) ;

    // Construction of MEM_MASTER loads _pmmInstance.

    if ( _pmmInstance == NULL )
    {
	UIASSERT( ! SZ("Global heap construction failure") );
    }

    return _pmmInstance != NULL ;

}


/*******************************************************************

    NAME:	MEM_MASTER::InitForDll

    SYNOPSIS:	(static) Construct and initialize MEM_MASTER
		for operation in a DLL.

    ENTRY:

    EXIT:	TRUE if initialization was successful.

    RETURNS:

    NOTES:
	Initialization for a DLL.  Preallocate the
	requested number of SUB_HEAPs.	This is only
	guaranteed to work so long as the original
	app loaded the DLL remains alive!

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

BOOL MEM_MASTER::InitForDll( int cPreallocHeaps )
{
    ::fHeapRealMode = (GetWinFlags() & WF_PMODE) == 0 ;
    if ( ::fHeapRealMode )
      return TRUE ;

    new MEM_MASTER( HEAP_INIT_ALLOC_DLL ) ;

    // Construction of MEM_MASTER loads _pmmInstance.

    if ( _pmmInstance == NULL )
    {
	UIASSERT( ! SZ("Global heap construction failure") );
	return FALSE ;
    }

    GIANT_HEAP * pGheap = _pmmInstance->GetGiantFocus() ;

    pGheap->SetDeleteOnEmpty( FALSE ) ;
    pGheap->SetExtendOnFull( FALSE ) ;
    pGheap->SetResizeOnEmpty( TRUE ) ;

    //	Force the GIANT_HEAP to create the requested number
    //	of preallocated SUB_HEAPs.  Remember that it is also
    //	a SUB_HEAP; that's why the count starts at 1.

    for ( int i = 1 ; i < cPreallocHeaps ; i++ ) {
	 BYTE * lpsTemp = pGheap->GrowAndAlloc( HEAP_INIT_ALLOC_DLL / 4 ) ;
	 if ( lpsTemp == NULL )
	 {
	   break ;
	 }
	 pGheap->Free( lpsTemp ) ;
    }

    return TRUE ;

}


/*******************************************************************

    NAME:	MEM_MASTER::Term

    SYNOPSIS:	Destroy MEM_MASTER, release hostages

    ENTRY:

    EXIT:	TRUE if all blocks/heaps deallocated properly

    RETURNS:

    NOTES:

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

BOOL MEM_MASTER::Term()
{
    ULONG cResidue ;

    if ( ::fHeapRealMode )
    {
	return TRUE ;
    }

    if ( _pmmInstance == NULL )
    {
	return FALSE ;	 /*  Never initialized or init failed  */
    }

    if ( cResidue = _pmmInstance->QueryTotalBlocks() )
	HeapResidueIter() ;

    delete _pmmInstance ;
    _pmmInstance = NULL ;

    return cResidue == 0 ;

}


/*******************************************************************

    NAME:	MEM_MASTER::~MEM_MASTER

    SYNOPSIS:	Desctructor for MEM_MASTER.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:
	Iterates through GIANT_HEAPs wielding death at
	every step.

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

MEM_MASTER::~MEM_MASTER()
{
    //	Deconstruct all of the (other) GIANT/SUB_HEAPS

    while ( this->_pFwd != this )
    {
	UIASSERT( this->_pFwd->_pOwner == this->_pFwd ) ;
        delete (GIANT_HEAP *) this->_pFwd ;
    }
}


/*******************************************************************

    NAME:	MEM_MASTER::Alloc

    SYNOPSIS:	Allocate memory from MEM_MASTER

    ENTRY:	USHORT count of bytes desired;
		USHORT flags (unused)

    EXIT:	BYTE * --> memory allocated

    RETURNS:

    NOTES:

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

BYTE * MEM_MASTER::Alloc ( USHORT cbBytes, USHORT fsFlags )
{
    BYTE * lpsResult = NULL ;

    UIASSERT( !::fHeapRealMode );

    //	Allocate from the GIANT_HEAP which as focus.  Note that a SUB_HEAP
    //	may currently have focus, so dereference through it.
    //	Due to virtualization, the qualification GIANT_HEAP:: is necessary.

    if ( _pFocus )
    {
       lpsResult = _pFocus->_pOwner->GIANT_HEAP::Alloc( cbBytes, fsFlags ) ;
    }
    return lpsResult ;

}


/*******************************************************************

    NAME:	MEM_MASTER::Free

    SYNOPSIS:	Release a block of memory.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:
	Search all the GIANT_HEAPs for the owner of
	this block. If found, pass it on; otherwise,
	return FALSE.

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

BOOL MEM_MASTER::Free( BYTE * pbBlock )
{
    SUB_HEAP * pSnext = this ;
    BOOL fFound = FALSE ;
    USHORT selBlock = HIWORD( pbBlock ) ;

    UIASSERT( !::fHeapRealMode );

    do
    {
       if ( selBlock == pSnext->QuerySel() ) {
	  return pSnext->_pOwner->GIANT_HEAP::Free( pbBlock ) ;
       }
       pSnext = pSnext->_pFwd ;
    }
    while ( pSnext != this ) ;

    return FALSE ;

}


/*******************************************************************

    NAME:	MEM_MASTER::QueryBlockSize

    SYNOPSIS:	Given a pointer to a block, return its size.

    ENTRY:

    EXIT:	zero if block was not allocated by MEM_MASTER.

    RETURNS:	USHORT size of block

    NOTES:

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

USHORT MEM_MASTER::QueryBlockSize( BYTE * pbBlock )
{
    SUB_HEAP * pSnext = this ;
    USHORT selBlock = HIWORD( pbBlock ) ;

    UIASSERT( !::fHeapRealMode );

    do
    {
      if ( selBlock == pSnext->QuerySel() )
	 return pSnext->QueryBlockSize( pbBlock ) ;
    }
    while ( (pSnext = pSnext->_pFwd) != this ) ;

    return 0 ;

}


/*******************************************************************

    NAME:	MEM_MASTER::GrowAndAlloc

    SYNOPSIS:	Null method; MEM_MASTER itself cannot grow.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

BYTE * MEM_MASTER::GrowAndAlloc( USHORT cbBytes, USHORT fsFlags )
{
    UNREFERENCED( cbBytes ) ;
    UNREFERENCED( fsFlags ) ;
    return NULL ;
}


/*******************************************************************

    NAME:	MEM_MASTER::SetFocus

    SYNOPSIS:	Set allocation focus on the SUB_HEAP given.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:
	Creation of a GIANT_HEAP automatically sets the
	focus to it; destruction set the focus to the
	nearest other GIANT_HEAP.  This routine can be
	used to switch from a newly allocated GIANT_HEAP
	to an earlier one; even to MEM_MASTER, in which
	case allocation would be done with LocalAlloc!

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

BOOL MEM_MASTER::SetFocus( SUB_HEAP * pSubHeap )
{
    _pFocus = pSubHeap ;
    return TRUE ;
}


/*******************************************************************

    NAME:	MEM_MASTER::GetGiantFocus

    SYNOPSIS:	Return a pointer to the GIANT_HEAP which has focus

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

GIANT_HEAP * MEM_MASTER::GetGiantFocus()
{
    return _pFocus->_pOwner ;
}


/*******************************************************************

    NAME:	MEM_MASTER::GetSubFocus

    SYNOPSIS:	Return a pointer to the focused SUB_HEAP.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

SUB_HEAP * MEM_MASTER::GetSubFocus()
{
    return _pFocus ;
}


/*******************************************************************

    NAME:	MEM_MASTER::QueryTotalHeaps

    SYNOPSIS:	Return the number of heaps alive.

    ENTRY:

    EXIT:

    RETURNS:	USHORT count of all heaps.

    NOTES:

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

USHORT MEM_MASTER::QueryTotalHeaps()
{
    SUB_HEAP * pSnext = this ;
    int cHeaps = 0 ;

    do
    {
	cHeaps++ ;
	pSnext = pSnext->_pFwd ;
    }
    while ( pSnext != this ) ;
    return cHeaps ;
}


/*******************************************************************

    NAME:	MEM_MASTER::QueryTotalBlocks

    SYNOPSIS:	Return the total number of all blocks outstanding

    ENTRY:

    EXIT:

    RETURNS:	ULONG count of blocks.

    NOTES:

    HISTORY:
	davidhov    01-Apr-1991     Created

********************************************************************/

ULONG MEM_MASTER::QueryTotalBlocks()
{
    SUB_HEAP * pSnext = this ;
    ULONG cBlocks = 0 ;

    do
    {
	cBlocks += pSnext->_cBlksOut ;
	pSnext = pSnext->_pFwd ;
    }
    while ( pSnext != this ) ;

    return cBlocks ;
}



BOOL MEM_MASTER :: Walk ()
{
    BOOL fResult = TRUE ;

#ifdef HEAPDEBUG
    SUB_HEAP * pshNext ;
    for ( pshNext = this->_pFwd ;	//  Skip the DS-based heap
	  fResult && pshNext != this ;
	  pshNext = pshNext->_pFwd )
    {
       fResult = pshNext->Walk() ;
    }

#endif
    return fResult ;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\heap\heapones.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    heapones.cxx
    ONE_SHOT_HEAP and ONE_SHOT_ITEM classes

    These classes support the allocation/deallocation of "quicky" items
    which have a short, scoped lifetime.

    FILE HISTORY:
        DavidHov    2-25-91     Created
        beng        24-Dec-1991 Heaps revisited: made safe for multiple
                                clients; made more lightweight
*/

#define INCL_WINDOWS
#include "lmui.hxx"

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#include "base.hxx"
#include "uibuffer.hxx"
#include "heapones.hxx"


// How many bytes can a buffer hold, max?
//
#define CB_MAX_BUFFER (UINT)(-1)


/**********************************************************************

    NAME:       ONE_SHOT_HEAP::ONE_SHOT_HEAP

    SYNOPSIS:   Ctor for one-shot heap

    ENTRY:      Requires the initial allocation size, plus whether
                the heap supports auto-resizing (dangerous on Win32).

                Note that BUFFER objects of zero bytes are allowed and
                will create sucessfully.

    EXIT:       Object created.

    NOTES:      On failure, reports an error.

    HISTORY:
        davidhov    ??-???-1991 Created
        beng        24-Dec-1991 Simplification
        beng        19-Mar-1992 Optional resizing

**********************************************************************/

ONE_SHOT_HEAP::ONE_SHOT_HEAP ( UINT cbInitialAllocSize, BOOL fAutoResize )
    : BUFFER( cbInitialAllocSize ),
    _cbUsed( 0 ),
    _fAutoResize(fAutoResize)
{
    // nothing doing
}


/**********************************************************************

    NAME:       ONE_SHOT_HEAP::Alloc

    SYNOPSIS:   Allocate memory in a ONE_SHOT_HEAP.  This is done
                by maintaining a "high water mark" and moving it
                upwards, reallocating when necessary.  Reallocation
                attempts try to resize to 1.5 times the current
                size.

    ENTRY:      Number of bytes desired.

    EXIT:       Buffer possibly resized; high-water mark moved.

    RETURNS:    Pointer to the data allocated, or NULL if failed.

    HISTORY:
        davidhov    ??-???-1991 Created
        beng        15-Jul-1991 BUFFER::Resize changed return type
        beng        24-Dec-1991 Grand simplification of one-shot heaps
        beng        19-Mar-1992 Resize only if allowed

**********************************************************************/

BYTE * ONE_SHOT_HEAP::Alloc( UINT cbBytes )
{
    BYTE * pbResult = NULL;
    UINT cbRemaining = QuerySize() - _cbUsed;

    if ( cbRemaining < cbBytes )
    {
        if (_fAutoResize)
        {
            UINT cbSize = QuerySize();

            if (cbSize == CB_MAX_BUFFER)    // check if already maxed
                return NULL;

            UINT cbResize = cbSize + (cbSize / 2);

            if (cbResize < cbSize)          // check for overflow
                cbResize = CB_MAX_BUFFER;

            if ( Resize( cbResize ) != 0 )  // try to grow buffer
                return NULL;
        }
        else
        {
            // Auto-resizing has been forbidden.  Try to stretch
            // the last couple of bytes without growing the buffer.

            FillOut();
        }

        cbRemaining = QuerySize() - _cbUsed;
    }

    if ( cbRemaining >= cbBytes )
    {
        pbResult = (BYTE *) (QueryPtr() + _cbUsed);
        _cbUsed += cbBytes;
    }

    return pbResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\heap\heapres.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    HEAPRES.CXX
    Heap residue output routine.

    The function in this file iterates over the unfree blocks
    from "operator new" and formats them onto the debug output stream.

    FILE HISTORY:
        DavidHov    11/21/91    Created
        beng        25-Mar-1992 Updated for Win32
        KeithMo     21-Apr-1992 Added multi-level stack backtrace.
        jonn        02-May-1992 BUILD FIX: StringPrintf() -> wsprintf()
        KeithMo     12-Aug-1992 Robustified stack backtrace a bit,
                                also enabled HEAPDEBUG for MIPS.
 */

#include <stdio.h>

#define INCL_WINDOWS
#include "lmui.hxx"

#if defined(DEBUG)
#  define HEAPDEBUG
#else
#  undef HEAPDEBUG
#endif

#include "heapdbg.hxx"

struct HEAPTAG * pHeapBase = 0 ;     //  Anchor of linked list of alloc'd blocks


    //  Define macro to avoid bringing in USER32.DLL through ::wsprintfW

#define WSPRINTF ::swprintf


VOID HeapResidueIter( UINT cMaxResidueBlocksToDump,
                      BOOL fBreakIfResidue )
{
#ifdef HEAPDEBUG   //  If heap debugging is desired

    const TCHAR * pszMsg = SZ("NETUI heap residue: Hdr = %p, Blk = %p, Size = %lX\n");
    TCHAR         achBuffer[100];
    HEAPTAG     * pht = pHeapBase;
    UINT          cBlocks = 0;

    if( pht == NULL )
    {
        //
        //  No residual heap blocks.  This is good.
        //

        return;
    }

    //
    //  Dump the residual blocks, with stack traces.
    //

    while( pht != NULL )
    {
        if( cBlocks < cMaxResidueBlocksToDump )
        {
            WSPRINTF( achBuffer,
                        pszMsg,
                        pht,
                        (PCHAR)pht + sizeof(HEAPTAG),
                        pht->_usSize );
            ::OutputDebugString( achBuffer );

            UINT cFrames = pht->_cFrames;
            TCHAR * pszStackMsg = SZ("        Stack =");

            if( cFrames > RESIDUE_STACK_BACKTRACE_DEPTH )
            {
                ::OutputDebugString( SZ("_cFrames exceeds RESIDUE_STACK_BACKTRACE_DEPTH,") );
                ::OutputDebugString( SZ(" possible invalid or corrupt heap block!\n") );
            }
            else
            {
                for( UINT i = 0 ; i < cFrames ; i++ )
                {
                    if( ( i % 5 ) == 0 )
                    {
                        ::OutputDebugString( pszStackMsg );
                        pszStackMsg = SZ("\n               ");
                    }

                    WSPRINTF( achBuffer,
                                SZ(" [%p]"),
                                pht->_pvRetAddr[i] );
                    ::OutputDebugString( achBuffer );
                }
            }

            ::OutputDebugString( SZ("\n") );
        }

        cBlocks++;

        if ( (pht = pht->_phtRight) == pHeapBase )
            pht = NULL;
    }

    if( ( cMaxResidueBlocksToDump > 0 ) &&
        ( cBlocks > cMaxResidueBlocksToDump ) )
    {
        //
        //  Tell the user how many remaining residual blocks exist.
        //

        WSPRINTF( achBuffer,
                    SZ("%u residue blocks remaining\n"),
                    cBlocks - cMaxResidueBlocksToDump );
        ::OutputDebugString( achBuffer );
    }

    if( fBreakIfResidue )
    {
        //
        //  Break into the debugger.  If we didn't dump any residual
        //  blocks, then dump the first one so the user can invoke
        //  !netui.heapres to get stack traces with symbols.
        //

        if( cMaxResidueBlocksToDump == 0 )
        {
            WSPRINTF( achBuffer,
                        pszMsg,
                        pHeapBase,
                        (PCHAR)pHeapBase + sizeof(HEAPTAG),
                        pHeapBase->_usSize );
            ::OutputDebugString( achBuffer );
        }

        WSPRINTF( achBuffer,
                    SZ("Execute '!netui.heapres %p' to get stack symbols\n"),
                    pHeapBase );
        ::OutputDebugString( achBuffer );

        ::DebugBreak();
    }

#endif // HEAPDEBUG

}   // HeapResidueIter
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\heap\heapif.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/
/*
    HEAPIF.CXX:  ALLOC_BASE operators new and delete.

    All NETUI objects virtually inherit from ALLOC_BASE, which
    consists of only an "operator new" and an "operator delete".

    These routines allow debug builds to track memory leaks and
    report them to the debugger via ::OutputDebugString().

    In free or retail builds, the operators directly call
    ::malloc() and ::free().

    FILE HISTORY:
        DavidHov   10/26/93     Created to replace older version
                                of HEAPIF.CXX.

 */

#include "ntincl.hxx"

#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETLIB
#include "lmui.hxx"
#include "base.hxx"

#include "uiassert.hxx"
#include "uitrace.hxx"

extern "C"
{
    #include <stdlib.h>
    #include <malloc.h>
}

  //  Mark each block to trap bogus pointers quickly.

#define HEAPTAG_SIGNATURE   0xFEEDBAAC

struct HEAPTAG ;                //  Forward declaration

#if defined(DEBUG)

#  define HEAPDEBUG             //  Debugging only

#  include "heapdbg.hxx"        //  Include the preamble definition

  extern HEAPTAG * pHeapBase ;  //  Anchor of linked list of alloc'd blocks
                                //  see HEAPRES.CXX

  //  Semaphore used to control access to "pHeapBase" in
  //  multi-threaded applications.

  static HANDLE hHeapTrackSema4 = NULL ;

#  define NETUI_HEAP_NEW    NetuiHeapNew
#  define NETUI_HEAP_DELETE NetuiHeapDelete

#else

#  undef HEAPDEBUG              //  Force heap debugging off if non-debug

#  define NETUI_HEAP_NEW    ::malloc
#  define NETUI_HEAP_DELETE ::free

#endif


#if defined(DEBUG)
//
//    NetuiHeapNew and NetuiHeapDelete:   Special
//      heap monitoring functions used as the basis for BASE
//      and LM_OBJ.  If HEAPDEBUG is defined, items are link-listed
//      together. along with size, signature and stack back-trace
//      information.
//
void * NetuiHeapNew ( size_t cb )
{
    void * pvResult ;

#ifdef HEAPDEBUG
    cb += sizeof (struct HEAPTAG) ;
#endif

    pvResult = (void *) ::malloc( cb );

#ifdef HEAPDEBUG
    if ( pvResult )
    {
	if ( hHeapTrackSema4 == NULL )
	{
	    //
	    //	Initialize if necessary
	    //
	    hHeapTrackSema4 = ::CreateSemaphore( NULL, 1, 1, NULL ) ;
	    if ( hHeapTrackSema4 == NULL )
	    {
		//
		// Hmmm, Something is really wrong if we can't create a simple
		// semaphore
		//
		UIASSERT( FALSE ) ;
	    }
	}

	//
	//  We should never have to wait this long
	//
	switch ( ::WaitForSingleObject( hHeapTrackSema4, 30000 ) )
	{
	case 0:
	    break ;

	default:
	    UIASSERT( FALSE ) ;
	} ;


        HEAPTAG * pht = (HEAPTAG *) pvResult ;
        pht->_uSignature = HEAPTAG_SIGNATURE ;
        pht->_usSize = cb - sizeof (struct HEAPTAG) ;

#if i386 && !FPO
        ULONG hash;

        pht->_cFrames =
                (UINT)::RtlCaptureStackBackTrace( 1,
                                                  RESIDUE_STACK_BACKTRACE_DEPTH,
                                                  pht->_pvRetAddr,
                                                  &hash );
#else
        pht->_cFrames = 0;
#endif
        pht->Init() ;
        if ( pHeapBase )
           pht->Link( pHeapBase ) ;
        else
           pHeapBase = pht ;
	pvResult = (void *) ((char *) pvResult + sizeof (struct HEAPTAG)) ;

	REQUIRE( ::ReleaseSemaphore( hHeapTrackSema4, 1, NULL )) ;
    }
#endif

    return pvResult ;

}   // new


void NetuiHeapDelete ( void * p )
{
    if( p != NULL )
    {
#ifdef HEAPDEBUG

        p = (void *) ((char *) p - sizeof (struct HEAPTAG)) ;
        HEAPTAG * pht = (HEAPTAG *) p ;

        if ( pht->_uSignature != HEAPTAG_SIGNATURE )
        {
           ::OutputDebugString(SZ("Bogus pointer passed to operator delete"));
           ::DebugBreak() ;
        }

        if ( pht == pHeapBase )
        {
            if ( (pHeapBase = pht->_phtLeft) == pht )
                pHeapBase = NULL ;
        }
        pht->Unlink() ;

#endif

        ::free( p );
    }

}   // delete

#endif


void * ALLOC_BASE :: operator new ( size_t cbSize )
{
    return NETUI_HEAP_NEW( cbSize ) ;
}

void * ALLOC_BASE :: operator new ( size_t cbSize, void * p )
{
    (void)cbSize;
    return p ;
}

void ALLOC_BASE :: operator delete ( void * p )
{
    NETUI_HEAP_DELETE( p ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\loclheap\loclheap.cxx ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE HISTORY:
 *  01/24/91  Created
 *  03/22/91  Coderev changes (2/20, JonN, RustanL, ?)
 */

#ifdef CODESPEC
/*START CODESPEC*/

/***********
LOCLHEAP.CXX
***********/

/****************************************************************************

    MODULE: LoclHeap.cxx

    PURPOSE: Local-heap management routines

    FUNCTIONS:

    COMMENTS:

****************************************************************************/


PRELIM CDD FOR LOCAL HEAP MANAGER

Glossary:
SZ("local heap") -- an explicitly created heap containing zero or more
        heap elements.
SZ("heap element") -- a block of memory allocated in a specific local heap.

The local heap manager allows applications to set up local heaps.  These
heaps are created by calling GlobalAlloc() to get the memory for the
entire heap, LocalInit() to set up the new segment as a local heap, 
and Local* calls to _access the heap.  Naturally, DS will have to be
explicitly set to the heap segment for each of the Local* calls;  the
local heap manager will deal with setting DS, as well as
saving/restoring the old DS.

The local heap is never explicitly locked;  instead, it is locked
whenever any of the heap elements is locked.  This is implemented by
GlobalLock-ing the heap every time a heap element is locked, and
GLobalUnlock-ing it when any heap element is unlocked.  The local heap
is locked once for every locked heap element.  This allows unlocked
heap elements to move within a local heap, and allows the local heap
to move when all of its heap elemnts are unlocked.  I rely on Windows
to maintain the lock count on the global heap.

It will be possible to create multiple local heaps, or to create local
heaps as global objects.

A DOS variant of the local heap manager will stub out the local heap calls,
map the heap element allocation/deallocation to new() and free(), and
stub out the heap element lock/unlock calls by storing the far pointer
in the instance variables.


/***************
end LOCLHEAP.CXX
***************/

/*END CODESPEC*/
#endif // CODESPEC



#define NOGDICAPMASKS
#define NOSOUND
#define NOMINMAX
#define INCL_WINDOWS
#include <lmui.hxx>

extern "C" 
{
    #include <stdlib.h>

#ifdef WINDOWS
    #include "locheap2.h"
#endif

}

#include <loclheap.hxx>



/**********************************************************\

   NAME:       HEAP_HANDLE::Init

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      

   HISTORY:
   01/24/91  Created

\**********************************************************/

VOID HEAP_HANDLE::Init()
{

    _handle = 0;

}


/**********************************************************\

   NAME:       HEAP_HANDLE::Init

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      
      zero-length heaps not allowed (cannot pass LocalInit API)
      it is an error to Init a local heap twice.  Local heaps cannot be resized.

   HISTORY:
   01/24/91  Created

\**********************************************************/

BOOL HEAP_HANDLE::Init(WORD wBytes, WORD wFlags)
{

#ifdef WINDOWS

    LPSTR lp;

    if (wBytes == 0)
    {
        _handle = 0;
        return FALSE;
    }

    _handle = GlobalAlloc( wFlags, (DWORD) wBytes );
    if (_handle == 0)
        return FALSE;

    lp = GlobalLock(_handle);

    {
        DoLocalInit(HIWORD(lp), wBytes);
    }

    GlobalUnlock(_handle);

#else

    (void) wFlags;
    (void) wBytes;

    _handle = 0xffff;

#endif // WINDOWS

    return TRUE;

}


/**********************************************************\

   NAME:       HEAP_HANDLE::Free

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      

   HISTORY:
   01/24/91  Created

\**********************************************************/

VOID HEAP_HANDLE::Free()
{

#ifdef WINDOWS

    if (_handle != 0)
    {
	GlobalFree(_handle);
        _handle = 0;
    }

#else

    _handle = 0;

#endif // WINDOWS

}


/**********************************************************\

   NAME:       HEAP_HANDLE::IsNull

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      

   HISTORY:
   01/24/91  Created

\**********************************************************/

BOOL HEAP_HANDLE::IsNull()
{

    return (_handle == 0);
}


/**********************************************************\

   NAME:       HEAP_HANDLE::operator=

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      
      copies handle, not heap

   HISTORY:
   01/24/91  Created

\**********************************************************/

VOID HEAP_HANDLE::operator=( const HEAP_HANDLE& source )
{

    _handle = source._handle;

}




/**********************************************************\

   NAME:       ELEMENT_HANDLE::Init

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      

   HISTORY:
   01/24/91  Created

\**********************************************************/

VOID ELEMENT_HANDLE::Init()
{

#ifdef WINDOWS

    _win._globalHandle = 0;
    _win._localHandle  = 0;

#else

    _os2._lpstr = NULL;

#endif // WINDOWS

}


BOOL ELEMENT_HANDLE::Init(const HEAP_HANDLE &heap, WORD wBytes, WORD wFlags)
{

#ifdef WINDOWS

    _win._globalHandle = heap._handle;

    LPSTR lp = GlobalLock(_win._globalHandle);
    if (lp == NULL)
        return FALSE;

    {
	_win._localHandle = DoLocalAlloc(HIWORD(lp), wFlags, wBytes);
    }

    GlobalUnlock(_win._globalHandle);

    return (_win._localHandle != NULL);

#else

    (void) heap;
    (void) wFlags;

    _os2._lpstr = (LPSTR) malloc((unsigned)wBytes);

    return (_os2._lpstr != NULL);

#endif // WINDOWS

}


/**********************************************************\

   NAME:       ELEMENT_HANDLE::Free

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      

   HISTORY:
   01/24/91  Created

\**********************************************************/

VOID ELEMENT_HANDLE::Free()
{

    if (IsNull())
	return;

#ifdef WINDOWS

    LPSTR lp = GlobalLock(_win._globalHandle);
    if (lp == NULL)
        return;

    {
        _win._localHandle = DoLocalFree(HIWORD(lp), _win._localHandle);
    }

    GlobalUnlock(_win._globalHandle);

    _win._globalHandle = 0;
    _win._localHandle  = 0;

#else

    free((void *)_os2._lpstr);
    _os2._lpstr = NULL;

#endif // WINDOWS

}


/**********************************************************\

   NAME:       ELEMENT_HANDLE::Lock

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      

   HISTORY:
   01/24/91  Created

\**********************************************************/

LPSTR ELEMENT_HANDLE::Lock()
{

#ifdef WINDOWS

    LPSTR lp = GlobalLock(_win._globalHandle);
    if (lp == NULL)
        return NULL;

    {
	return DoLocalLock(HIWORD(lp), _win._localHandle);
    }

    // note: global segment is not unlocked

#else

    return _os2._lpstr;

#endif // WINDOWS

}


/**********************************************************\

   NAME:       ELEMENT_HANDLE::Unlock

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      

   HISTORY:
   01/24/91  Created

\**********************************************************/

VOID ELEMENT_HANDLE::Unlock()
{

#ifdef WINDOWS

    LPSTR lp = GlobalLock(_win._globalHandle);
    if (lp == NULL)
        return;

    {
	DoLocalUnlock(HIWORD(lp), _win._localHandle);
    }

    GlobalUnlock(_win._globalHandle);
    GlobalUnlock(_win._globalHandle);

    // note: global segment is unlocked twice

#endif // WINDOWS

}

/**********************************************************\

   NAME:       ELEMENT_HANDLE::IsNull

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      

   HISTORY:
   01/24/91  Created

\**********************************************************/

BOOL ELEMENT_HANDLE::IsNull()
{

#ifdef WINDOWS

    return (_win._localHandle == 0);

#else

    return (_os2._lpstr == NULL);

#endif // WINDOWS
}


// copies handle, not element
/**********************************************************\

   NAME:       ELEMENT_HANDLE::operator=

   SYNOPSIS:   

   ENTRY:      

   EXIT:       

   NOTES:      

   HISTORY:
   01/24/91  Created

\**********************************************************/

VOID ELEMENT_HANDLE::operator=( const ELEMENT_HANDLE& source )
{

#ifdef WINDOWS

    _win._localHandle =  source._win._localHandle;
    _win._globalHandle = source._win._globalHandle;

#else

    _os2._lpstr = source._os2._lpstr;

#endif // WINDOWS
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\misc\loadres.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    loadres.cxx
    Implementation of the LoadResourceString function.

    The Windows version of this method loads the resource string from
    the strings in the resource file of the calling module.

    The OS/2 version should call DosGetMessage to get the string from some
    message file.  The LoadResourceString function needs to be able to
    determine which message file to load the string from.


    CAVEATS:

        CODEWORK.  The OS/2 version is not implemented.  It should be, if
        anyone needs it.

        BUGBUG.  This method may return ERROR_MR_MID_NOT_FOUND (for
        the curious, MR_MID is not Mr. Mid, but Message Resource Message
        ID).  Doing a Helpmsg from the OS/2 prompt shows that this
        error needs insert strings.  This means that the caller of this
        method needs to know about this before calling, say, MsgPopup
        to report the error to the user, so as to fill in the %1 and %2.
        Normally, OS/2 and LAN Man error codes don't require insert strings.
        If this error value does, it should probably be chagned later on.


    FILE HISTORY:
        RustanL     31-Jan-1991 Created.  Added Windows version.

*/

#ifdef WINDOWS

#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#include "lmui.hxx"

#include "blt.hxx"      // for QueryInst function

#else

#define INCL_DOSERRORS
#include "lmui.hxx"

#endif  // WINDOWS


#include "uiassert.hxx"
#include "uimisc.hxx"


/*******************************************************************

    NAME:       LoadResourceString

    SYNOPSIS:   Loads a resource string (duuuuuuh)

    ENTRY:
        msgid       - number identifying the string to be loaded
        pszBuffer   - Pointer to buffer which receives the loaded string
        cbBufSize   - size of the given buffer

    EXIT:
        Buffer contains string, if successful

    RETURNS:
        Error value.  May be one of the following:
            NERR_Success            Success
            ERROR_MR_MID_NOT_FOUND  Could not find the requested message

    NOTES:

    HISTORY:
        RustanL     31-Jan-1991 Created
        beng        21-May-1991 Removed reference to ::vhInst
        beng        07-Oct-1991 LoadR.S. uses contemporary typedefs
        beng        05-May-1992 API changes (cb->cch in LoadString)

********************************************************************/

APIERR LoadResourceString( MSGID msgid, TCHAR * pszBuffer, UINT cbBufSize )
{
#if defined(WINDOWS)

    // The BLT Windowing system offers the QueryInst function
    // to return a handle to the current instance.

    INT nLen = ::LoadString( ::QueryInst(), msgid, pszBuffer,
                             cbBufSize/sizeof(TCHAR) );

    // Assume that no actual string will have length 0.

    if ( nLen == 0 )
    {
        return ERROR_MR_MID_NOT_FOUND;
    }

    return NERR_Success;

#else

    UNREFERENCED(msgid);
    UNREFERENCED(cbBufSize);
    UNREFERENCED(pszBuffer);

    UIASSERT( FALSE ); // Not implemented
    return ERROR_NOT_SUPPORTED;

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\misc\timestmp.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    timestmp.cxx
    Implementation of time stamp function, QueryCurrentTimeStamp

    FILE HISTORY:
	rustanl     09-Apr-1991     Created

*/


#ifdef WINDOWS

#define INCL_WINDOWS
#include "lmui.hxx"

#else

#include "lmui.hxx"

extern "C"
{
    #include <time.h>
}

#endif	// WINDOWS


#include "uiassert.hxx"
#include "uimisc.hxx"


/*******************************************************************

    NAME:	    QueryCurrentTimeStamp

    SYNOPSIS:	    This function returns a time stamp measured
		    in seconds from some arbitrary point.

    RETURNS:	    The current time stamp

    NOTES:	    If the caller needs better granularity than seconds,
		    a new method needs to be invented.

		    Under Windows, the returned time corresponds to
		    the number of seconds from that the system
		    was started.  Under DOS and OS/2, the time corresponds
		    to the number of seconds elapsed since 00:00:00
		    Greenwich mean time (GMT), January 1, 1970, according to
		    the system clock (adjusted according to the time
		    zone system variable).

    HISTORY:
	rustanl     09-Apr-1991     Created

********************************************************************/

ULONG QueryCurrentTimeStamp()
{

#ifdef WINDOWS

    //	GetCurrentTime returns the time in milliseconds.
    return ( ::GetCurrentTime() / 1000 );

#else

    return ::time( NULL );

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\loclheap\locheap2.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  01/24/91  Created
 */

/*********
LOCHEAP2.C
*********/

/****************************************************************************

    MODULE: LocHeap2.c

    PURPOSE: Local-heap management helper routines

    FUNCTIONS:

    COMMENTS: see $(UI)\common\h\locheap2.c

    FILE HISTORY:

    jonn	24-Jan-1991	Created
    jonn	21-Mar-1991	Code review changes from 2/20/91 (attended
				by JonN, RustanL, ?)

****************************************************************************/


/*************
end LOCHEAP2.C
*************/


#ifndef WINDOWS
#error "Only use these APIs under Windows!"
#endif



#define NOGDICAPMASKS
#define NOSOUND
#define NOMINMAX
#include <windows.h>
#undef ERROR_NOT_SUPPORTED
#undef ERROR_NET_WRITE_FAULT
#undef ERROR_VC_DISCONNECTED

#include <locheap2.h>



// Note that variables accessed between "push DS" and "pop DS" must be
//   on the stack.



BOOL DoLocalInit(WORD wHeapDS, WORD wBytes)
{
     BOOL fResult ;
_asm {
     push DS
     mov  AX, wHeapDS
     mov  DS, AX
     }

        fResult = LocalInit(wHeapDS, 0, wBytes-1);

_asm {
     pop DS
     }
     return fResult ;
}


HANDLE DoLocalAlloc(WORD wHeapDS, WORD wFlags, WORD wBytes)
{
    HANDLE handleReturn;

_asm {
     push DS
     mov  AX, wHeapDS
     mov  DS, AX
     }

        handleReturn = LocalAlloc(wFlags, wBytes);

_asm {
     pop DS
     }

    return handleReturn;
}

HANDLE DoLocalFree(WORD wHeapDS, HANDLE handleFree)
{
    HANDLE handleReturn;

_asm {
     push DS
     mov  AX, wHeapDS
     mov  DS, AX
     }

        handleReturn = LocalFree(handleFree);

_asm {
     pop DS
     }

    return handleReturn;
}

LPSTR DoLocalLock(WORD wHeapDS, HANDLE handleLocal)
{
    NPSTR np;

_asm {
     push DS
     mov  AX, wHeapDS
     mov  DS, AX
     }

        np = LocalLock(handleLocal);

_asm {
     pop DS
     }

    return (LPSTR) MAKELONG(np, wHeapDS);

    // note: global segment is not unlocked
}

VOID DoLocalUnlock(WORD wHeapDS, HANDLE handleLocal)
{
_asm {
     push DS
     mov  AX, wHeapDS
     mov  DS, AX
     }

        LocalUnlock(handleLocal);

_asm {
     pop DS
     }
}

HANDLE DoLocalHandle(WORD wHeapDS, WORD wMem)
{
    HANDLE hMem ;

_asm {
     push DS
     mov  AX, wHeapDS
     mov  DS, AX
     }

	hMem = LocalHandle(wMem);

_asm {
     pop DS
     }

    return hMem ;
}


WORD DoLocalSize(WORD wHeapDS, HANDLE handleLocal)
{
    WORD size ;

_asm {
     push DS
     mov  AX, wHeapDS
     mov  DS, AX
     }

	size = LocalSize(handleLocal);

_asm {
     pop DS
     }

    return size ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\misc\lmuidbcs.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    lmuidbcs.cxx
    Implementation of DBCS test function, NETUI_IsDBCS

    FILE HISTORY:
	jonn        11-Sep-1995     Created

*/


#define INCL_WINDOWS
#include "lmui.hxx"

extern "C"
{
    #include <lmuidbcs.h>
    VOID NETUI_InitIsDBCS();
}

// Indicates whether we are running in a DBCS locale
BOOL _global_NETUI0_IsDBCS = FALSE;


/*******************************************************************

    NAME:	    NETUI_InitIsDBCS

    SYNOPSIS:	    This function must be called in initialization.

    NOTE:           This is only called by dll3\dll0\init.cxx.  See
                    that module before modifying parameters.

    HISTORY:
	jonn        12-Sep-1995     Created

********************************************************************/

VOID NETUI_InitIsDBCS()
{
    LANGID langid = PRIMARYLANGID(::GetThreadLocale());
    _global_NETUI0_IsDBCS =
            (   langid == LANG_CHINESE
             || langid == LANG_JAPANESE
             || langid == LANG_KOREAN );
}


/*******************************************************************

    NAME:	    NETUI_IsDBCS

    SYNOPSIS:	    This function determines whether the calling thread
                    is in a DBCS locale.

    HISTORY:
	jonn        11-Sep-1995     Created

********************************************************************/

BOOL NETUI_IsDBCS()
{
    return _global_NETUI0_IsDBCS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\test\skeleton\skeleton.h ===
#define IDM_ABOUT       100
#define IDM_RUN_TEST    200

#define ID_APPICON      1
#define ID_APPMENU      1
#define ID_APPACCEL     1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\system\chkdrv.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**                Copyright(c) Microsoft Corp., 1990                **/
/**********************************************************************/

/*  History:
 *      ChuckC      11-Jan-1991     Created
 *      KeithMo     09-Oct-1991     Win32 Conversion.
 *      terryk      21-Oct-1991     Add WIN32BUGBUG
 *      Yi-HsinS    12-Nov-1991     Added CheckLocalDrive for NT
 *      beng        29-Mar-1992     Remove odious PSZ type
 */

#define INCL_NETERRORS
#define INCL_DOSERRORS

#ifdef WINDOWS
    #define INCL_WINDOWS
#else
    #define INCL_OS2
    #define INCL_DOSFILEMGR
#endif

#include "lmui.hxx"

#ifndef _WIN32
extern "C"
{
#endif
    #include <lmcons.h>
    #include "uinetlib.h"

#if !defined(OS2) && !defined(WIN32)
    #include <dos.h>
#endif

#ifndef _WIN32
}
#endif


/*
 * check if a drive "X:" is valid. Assumes that
 * the drive letter has been canonicalized to uppercase.
 * return NERR_Success if it is valid, ERROR_INVALID_DRIVE.
 */
#ifdef OS2
APIERR CheckLocalDrive(const TCHAR * pszDeviceName)
{
    USHORT usDrive, usDummy ;
    APIERR err;
    ULONG  ulMap ;

    usDrive = pszDeviceName[0] - TCH('A') ;   // assume pszDeviceName is canon-ed

    // get drive map
    err = DosQCurDisk(&usDummy, &ulMap);
    if (err != NERR_Success)
        return(err) ;

    // check if the drive is present
    if ( (ulMap >> usDrive) & 0x1L )
        return (NERR_Success) ;

    // its not there
    return(ERROR_INVALID_DRIVE);
}

#elif defined(WIN32)

#include "string.hxx"

DLL_BASED
APIERR CheckLocalDrive(const TCHAR * pszDeviceName)
{

    NLS_STR nls( pszDeviceName );
    nls.AppendChar(TCH('\\'));

    if ( nls.QueryError() != NERR_Success )
        return ERROR_NOT_ENOUGH_MEMORY;

    DWORD uiDriveType = GetDriveType( (TCHAR *) nls.QueryPch() );

    switch ( uiDriveType )
    {
        case 0:
        case 1:
        case DRIVE_REMOTE:
             return ERROR_INVALID_DRIVE;

        default:   // Removable, Fixed, Ram Drive, CD-Rom
             return NERR_Success;
    }

}

#else // WINDOWS 16 bits

APIERR CheckLocalDrive(const TCHAR * pszDeviceName)
{
    USHORT usDrive ;
    union REGS inregs, outregs;

    usDrive = pszDeviceName[0] - TCH('A') ;   // assume pszDeviceName is canon-ed

    // Call IOCTL: check if block device is either a local drive or
    // a remote drive.
    inregs.x.ax = 0x4409 ;
    inregs.h.bl = usDrive + 1 ;
    intdos( &inregs, &outregs );

    if ( outregs.x.cflag )     /* if error, we know it's an invalid drive */
        return(ERROR_INVALID_DRIVE) ;
    else
        return(NERR_Success) ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\system\chkunav.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**                Copyright(c) Microsoft Corp., 1990                **/
/**********************************************************************/

/*
 * CHKUNAV:     check unavailable device
 * History:
 *      ChuckC      3-Feb-1991      Created
 *      KeithMo     09-Oct-1991     Win32 Conversion.
 *      terryk      21-Oct-1991     Add WIN32BUGBUG
 *      beng        01-Apr-1992     Remove odious PSZ type
 */

#define INCL_NETERRORS
#define INCL_DOSERRORS

#ifdef WINDOWS
    #define INCL_WINDOWS
#else
    #define INCL_OS2
    #define INCL_DOSFILEMGR
#endif

#include "lmui.hxx"

#ifndef _WIN32
extern "C"
{
#endif
    #include <lmcons.h>
    #include "uinetlib.h"
    #include <lmuse.h>

#if !defined(OS2) && !defined(WIN32)
    #include <dos.h>
#endif
#ifndef _WIN32
}
#endif

#include "uisys.hxx"

#include "uibuffer.hxx"
#include "string.hxx"

#if defined(WINDOWS) && !defined(WIN32)
#include "winprof.hxx"
#endif

/*
 * check unavail device. Return NERR_Success if pszDevice is unavail,
 * pszRemote will be overwritten with remote name if successful, sType
 * with the device type. They will be "" and 0 respectively id call fails.
 */
DLL_BASED
APIERR CheckUnavailDevice(const TCHAR * pszDevice, TCHAR * pszRemote, INT *psType)
{
    if (!pszDevice || !pszRemote || !psType)
        return(ERROR_INVALID_PARAMETER) ;
    *pszRemote = TCH('\0') ;
    *psType = 0 ;

#if defined(WINDOWS) && !defined(WIN32)
    // WIN32BUGBUG

    if ( !(GetWinFlags() & WF_PMODE) )
    {
       /*
        * if not prot mode, just say no
        */
        return(ERROR_INVALID_DRIVE) ;
    }

    /*
     * in the Win case, we are Winnet specific. This is the
     * only planned use of Profile.
     */
    NLS_STR strDrive(pszDevice) ;
    NLS_STR strRemote ;
    if (PROFILE::Query(strDrive, strRemote, (INT *)psType, NULL) == 0)
    {
        ::strcpyf((TCHAR *)pszRemote,strRemote.QueryPch()) ;
        return(NERR_Success) ;
    }
    return(ERROR_INVALID_DRIVE) ;
#else
    return(ERROR_INVALID_FUNCTION) ;    // currently no support outside wIn
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\system\chklpt.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**                Copyright(c) Microsoft Corp., 1990                **/
/**********************************************************************/

/*
 * CHKLPT:      Check if an LPT device is valid.
 * History:
 *      ChuckC      11-Jan-1991     Created
 *      KeithMo     09-Oct-1991     Win32 Conversion.
 *      terryk      21-Oct-1991     Win32 Conversion
 *      terryk      18-Nov-1991     add UNREFERENCED macro
 *      beng        01-Apr-1992     Remove odious PSZ type
 */

// NOTE - Win/NT support only currently

#define INCL_NETERRORS
#define INCL_DOSERRORS

#ifdef WINDOWS
    #define INCL_WINDOWS
#else
    #define INCL_OS2
    #define INCL_DOSFILEMGR
#endif

#include "lmui.hxx"
#include "uisys.hxx"

#ifndef _WIN32
extern "C"
{
#endif
    #include <lmcons.h>
    #include "uinetlib.h"

#if !defined(OS2) && !defined(WIN32)
    #include <dos.h>
#endif
#ifndef _WIN32
}
#endif

/*
 * check if a LPTx is valid. Assumes that
 * the dev name has been canonicalized to uppercase.
 * return NERR_Success if it is valid, ERROR_INVALID_DRIVE.
 */
DLL_BASED
APIERR CheckLocalLpt(const TCHAR * pszDeviceName)
{
    UNREFERENCED(pszDeviceName);
#ifdef OS2
    return (ERROR_INVALID_DRIVE) ;      // BUGBUG - read OS2SYS.INI
#else
    /* under Win/DOS we cannot easily check, we allow it
       BUGBUG - better check under NT */
    return (NERR_Success) ;
#endif
}


/*
 * check if a COMx is valid. Assumes that
 * the dev name has been canonicalized to uppercase.
 * return NERR_Success if it is valid, ERROR_INVALID_DRIVE.
 */
DLL_BASED
APIERR CheckLocalComm(const TCHAR * pszDeviceName)
{
    UNREFERENCED(pszDeviceName);
#ifdef OS2
    return (ERROR_INVALID_DRIVE) ;      // BUGBUG - read OS2SYS.INI
#else
    /* under Win/DOS we cannot easily check, we allow it
       BUGBUG - better check under NT */
    return (NERR_Success) ;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\test\skeleton\skeleton.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    skeleton.cxx
    Generic unit test: main application module

    This is a skeleton for string unit tests, allowing them to
    be written in a host-env independent fashion.

    FILE HISTORY:
        johnl       12-Nov-1990 Created
        beng        01-May-1991 Added workaround for C7 bug
        beng        27-Jun-1991 Win and OS2 tests merged
                                (used BUFFER as a template)
        beng        06-Jul-1991 Frame and test partitioned
        beng        14-Oct-1991 Uses APPLICATION
        beng        28-Feb-1992 Works for the console in general
        beng        16-Mar-1992 Changes to cdebug
        beng        13-Aug-1992 Dllization of BLT
*/

// #define USE_CONSOLE

#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETLIB
#if defined(WINDOWS)
# define INCL_WINDOWS
#else
# define INCL_OS2
#endif
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = "skeleton.cxx";
#define _FILENAME_DEFINED_ONCE szFileName
#endif

extern "C"
{
    #include <uirsrc.h>
    #include <uimsg.h>

    #include "skeleton.h"
}

#if defined(WINDOWS)
# if !defined(USE_CONSOLE)
#  define INCL_BLT_CONTROL
#  define INCL_BLT_CLIENT
# endif
# define INCL_BLT_APP
# include <blt.hxx>
#endif

#if !defined(WINDOWS) || defined(USE_CONSOLE)
extern "C"
{
# include <stdio.h>
}
#endif

#include <uiassert.hxx>
#include <dbgstr.hxx>

#include "skeleton.hxx"


#if defined(WINDOWS) && !defined(USE_CONSOLE)

const TCHAR *const szMainWindowTitle = SZ("Unit Test");


class TEST_WND: public APP_WINDOW
{
protected:
    // Redefinitions
    //
    virtual BOOL OnMenuCommand( MID mid );

public:
    TEST_WND();
};


class TEST_APP: public APPLICATION
{
private:
    TEST_WND  _wndApp;
    ACCELTABLE _accel;

public:
    TEST_APP( HANDLE hInstance, INT nCmdShow, UINT, UINT, UINT, UINT );

    // Redefinitions
    //
    virtual BOOL FilterMessage( MSG* );
};


TEST_APP::TEST_APP( HANDLE hInst, INT nCmdShow,
                    UINT w, UINT x, UINT y, UINT z )
    : APPLICATION( hInst, nCmdShow, w, x, y, z ),
      _accel( ID_APPACCEL ),
      _wndApp()
{
    if (QueryError())
        return;

    if (!_accel)
    {
        ReportError(_accel.QueryError());
        return;
    }

    if (!_wndApp)
    {
        ReportError(_wndApp.QueryError());
        return;
    }

    _wndApp.ShowFirst();
}


BOOL TEST_APP::FilterMessage( MSG *pmsg )
{
    return (_accel.Translate(&_wndApp, pmsg));
}


TEST_WND::TEST_WND()
    : APP_WINDOW(szMainWindowTitle, ID_APPICON, ID_APPMENU )
{
    if (QueryError())
        return;

    // ...
}


BOOL TEST_WND::OnMenuCommand( MID mid )
{
    switch (mid)
    {
    case IDM_RUN_TEST:
        ::MessageBox(QueryHwnd(),
            SZ("Test results will be written to debug terminal.  Bogus, huh?"),
            SZ("Note"), MB_OK);

        ::RunTest();
        return TRUE;
    }

    // default
    return APP_WINDOW::OnMenuCommand(mid);
}


SET_ROOT_OBJECT( TEST_APP, IDRSRC_APP_BASE, IDRSRC_APP_LAST,
                           IDS_UI_APP_BASE, IDS_UI_APP_LAST )

#elif defined(WINDOWS) && defined(USE_CONSOLE)

// Win32, with console support


class TEST_APP: public APPLICATION
{
private:
    OUTPUT_TO_STDERR _out;
    DBGSTREAM        _dbg;
    DBGSTREAM *      _pdbgSave;

public:
    TEST_APP( HANDLE hInstance, INT nCmdShow, UINT, UINT, UINT, UINT );
    ~TEST_APP();

    // Redefinitions
    //
    virtual INT Run();
};


TEST_APP::TEST_APP( HANDLE hInst, INT nCmdShow,
                    UINT w, UINT x, UINT y, UINT z )
    : APPLICATION( hInst, nCmdShow, w, x, y, z ),
      _out(),
      _dbg(&_out),
      _pdbgSave( &(DBGSTREAM::QueryCurrent()) )
{
    if (QueryError())
        return;

    // Point cdebug to stderr instead of aux
    //
    DBGSTREAM::SetCurrent(&_dbg);
}


TEST_APP::~TEST_APP()
{
    // Restore original stream

    DBGSTREAM::SetCurrent(_pdbgSave);
}


INT TEST_APP::Run()
{
    // Never mind the message loop... this is a console app.
    // Hope this works.
    //
    ::RunTest();
    return 0;
}


SET_ROOT_OBJECT( TEST_APP, IDRSRC_APP_BASE, IDRSRC_APP_LAST,
                           IDS_UI_APP_BASE, IDS_UI_APP_LAST )


#else // OS2, or DOS, or some such env


INT main()
{
    OUTPUT_TO_STDOUT out;
    DBGSTREAM dbg(&out);
    DBGSTREAM::SetCurrent(&dbg);

    ::RunTest();

    DBGSTREAM::SetCurrent(NULL);
    return 0;
}


#endif // WINDOWS -vs- OS2 unit test skeletons
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\test\xassert\xassert.h ===
#define IDM_RUN_TEST1	201
#define IDM_RUN_TEST2	202
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\test\xassert\xassert.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    xassert0.cxx
    First test for ASSERT

    Since my code never fails, ASSERT needs a test so that somebody
    runs it...

    This runs under Windows only.

    FILE HISTORY:
        beng        06-Aug-1991 Created
        beng        17-Sep-1991 Added _FILENAME_DEFINED_ONCE

*/


#define DEBUG

#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#include <lmui.hxx>

extern "C"
{
    #include "xassert.h"
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#include <uiassert.hxx>

#define INCL_BLT_CLIENT
#define INCL_BLT_APP
#include <blt.hxx>

#include <string.hxx>

#include <dbgstr.hxx>


const TCHAR *const szIconResource = SZ("FooIcon");
const TCHAR *const szMenuResource = SZ("FooMenu");
const TCHAR *const szAccelResource = SZ("FooAccel");

const TCHAR *const szMainWindowTitle = SZ("Assertion test");


VOID RunTest1( HWND hwndParent );
VOID RunTest2( HWND hwndParent );


class FOO_WND: public APP_WINDOW
{
protected:
    // Redefinitions
    //
    virtual BOOL OnMenuCommand( MID mid );

public:
    FOO_WND();
};


class FOO_APP: public APPLICATION
{
private:
    ACCELTABLE _accel;
    FOO_WND    _wndApp;

public:
    FOO_APP( HANDLE hInstance, TCHAR * pszCmdLine, INT nCmdShow );

    // Redefinitions
    //
    virtual BOOL FilterMessage( MSG* );
};


FOO_WND::FOO_WND()
    : APP_WINDOW(szMainWindowTitle, szIconResource, szMenuResource )
{
    if (QueryError())
        return;
}


BOOL FOO_WND::OnMenuCommand( MID mid )
{
    switch (mid)
    {
    case IDM_RUN_TEST1:
        ::RunTest1(QueryHwnd());
        return TRUE;
    case IDM_RUN_TEST2:
        ::RunTest2(QueryHwnd());
        return TRUE;
    }

    // default
    return APP_WINDOW::OnMenuCommand(mid);
}


FOO_APP::FOO_APP( HANDLE hInst, TCHAR * pszCmdLine, INT nCmdShow )
    : APPLICATION( hInst, pszCmdLine, nCmdShow ),
      _accel( szAccelResource ),
      _wndApp()
{
    if (QueryError())
        return;

    if (!_accel)
    {
        ReportError(_accel.QueryError());
        return;
    }

    if (!_wndApp)
    {
        ReportError(_wndApp.QueryError());
        return;
    }

    _wndApp.ShowFirst();
}


BOOL FOO_APP::FilterMessage( MSG *pmsg )
{
    return (_accel.Translate(&_wndApp, pmsg));
}


VOID RunTest1( HWND hWnd )
{
    ASSERT(FALSE);
}


VOID RunTest2( HWND hWnd )
{
    ASSERTSZ(FALSE, "Pop goes the gangrenous weasel.");
}



SET_ROOT_OBJECT( FOO_APP )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\test\xlog\xlog.h ===
#define IDC_LIST 100
#define SLE_SERVER 101

#define IDM_AUDIT_FORMAT 102
#define IDM_ERROR_FORMAT 103
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\test\xfsenum\xfsenum.h ===
#define IDM_ABOUT	100
#define IDM_RUN_TEST	200
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\test\xbuffer\xbuffer.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    xbuffer.cxx
    BUFFER unit test: main application module

    FILE HISTORY:
        beng        02-Jan-1991 Created
        beng        03-Feb-1991 Modified to use lmui.hxx et al
        beng        14-Feb-1991 Added BLT
        beng        14-Mar-1991 Removed obsolete vhInst;
                                included about.cxx,hxx
        beng        01-Apr-1991 Uses new BLT APPSTART
        beng        10-May-1991 Updated with standalone client window
        beng        14-May-1991 ... and with App window
        beng        25-Jun-1991 BUFFER unit test made
        beng        14-Oct-1991 Uses APPLICATION
        beng        16-Mar-1992 NT version
*/

#define USE_CONSOLE

#define INCL_DOSERRORS
#define INCL_NETERRORS
#if defined(WINDOWS)
# define INCL_WINDOWS
# define INCL_WINDOWS_GDI
#else
# define INCL_OS2
#endif
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = "xbuffer.cxx";
#define _FILENAME_DEFINED_ONCE szFileName
#endif

extern "C"
{
    #include "skeleton.h"
}

#include <uiassert.hxx>
#include <string.hxx>
#include <strnumer.hxx>
#include <uibuffer.hxx>
#include <dbgstr.hxx>

#include "skeleton.hxx"


class BUFFERTEST // test
{
private:
    UINT           _cpbuf;
    BUFFER **const _apbuf;

public:
    BUFFERTEST(UINT cbuf = 5, UINT cbSize = 2048);
    ~BUFFERTEST();

    VOID Tattle() const;
    BOOL Double() const;
    VOID TrimAll() const;
    VOID FillOut() const;
    BOOL Increase( UINT cbAddition ) const;
};


VOID RunTest()
{
    BUFFERTEST test(5, 4096);

    test.Tattle();
    test.Double();
    test.Tattle();
    test.Double();
    test.Tattle();
    test.FillOut();
    test.Tattle();
    test.TrimAll();
    test.Tattle();
    test.Increase(544);
    test.Tattle();
    test.Double();
    test.Tattle();
    test.FillOut();
    test.Tattle();
    test.Double(); // would fail on Win16
    test.Tattle();
}


BUFFERTEST::BUFFERTEST( UINT cbufUsed, UINT cbSize ) :
    _cpbuf(cbufUsed),
    _apbuf(new BUFFER*[cbufUsed])
{
    if (!_apbuf)
    {
        // The first alloc failed.  Zap _cpbuf for the destructor.
        //
        _cpbuf = 0;
        cdebug << SZ("Test failed to setup") << dbgEOL;
        return;
    }

    cdebug << SZ("Starting BUFFER test...") << dbgEOL;

    UINT ipbuf = 0;

    while (ipbuf < _cpbuf)
    {
        BUFFER * pbufNew = new BUFFER(cbSize);
        if (!pbufNew)
        {
            cdebug << SZ("Buffer failed to allocate") << dbgEOL;
        }
        else if (!*pbufNew)
        {
            cdebug << SZ("Buffer failed with ") << pbufNew->QueryError() << dbgEOL;
        }
        else
        {
            cdebug << SZ("Buffer ") << ipbuf << SZ(" successfully built") << dbgEOL;
        }

        // I want the element set to something, even NULL,
        // so as to simplify cleanup

        _apbuf[ipbuf++] = pbufNew;
    }
}


BUFFERTEST::~BUFFERTEST()
{
    UINT ipbuf = _cpbuf;

    while (ipbuf > 0)
    {
        delete _apbuf[--ipbuf];
    }

    delete [_cpbuf] _apbuf;

    cdebug << SZ("End of BUFFER test") << dbgEOL;
}


DBGSTREAM& operator<<(DBGSTREAM &out, const BYTE *pb)
{
#if defined(WIN32)
    HEX_STR nlsHex((ULONG)pb);

    out << SZ("0x") << nlsHex.QueryPch();
#else
    HEX_STR nlsHigh( HIWORD((ULONG)pb), 4 );
    HEX_STR nlsLow( LOWORD((ULONG)pb), 4 );

    out << nlsHigh.QueryPch() << SZ(":") << nlsLow.QueryPch();
#endif

    return out;
}


VOID BUFFERTEST::Tattle() const
{
    for (UINT ipbuf = 0; ipbuf < _cpbuf; ++ipbuf)
    {
        cdebug << SZ("Buffer ") << ipbuf
               << SZ(" has size ") << _apbuf[ipbuf]->QuerySize()
               << SZ(" and addr ") << _apbuf[ipbuf]->QueryPtr()
               << dbgEOL;
    }
}


BOOL BUFFERTEST::Double() const
{
    const UINT cbMax = UINT(-1);

    for (UINT ipbuf = 0; ipbuf < _cpbuf; ++ipbuf)
    {
        UINT cbCurrent = _apbuf[ipbuf]->QuerySize();

        if (cbCurrent > cbMax/2)
            break;

        if (_apbuf[ipbuf]->Resize(cbCurrent*2))
        {
            cdebug << SZ("Buffer ") << ipbuf
                   << SZ("failed a resize to ") << cbCurrent*2
                   << dbgEOL;
            return FALSE;
        }
    }

    return TRUE;
}


VOID BUFFERTEST::TrimAll() const
{
    for (UINT ipbuf = 0; ipbuf < _cpbuf; ++ipbuf)
    {
        _apbuf[ipbuf]->Trim();
    }
}


VOID BUFFERTEST::FillOut() const
{
    for (UINT ipbuf = 0; ipbuf < _cpbuf; ++ipbuf)
    {
        _apbuf[ipbuf]->FillOut();
    }
}


BOOL BUFFERTEST::Increase(UINT cbAddition) const
{
    for (UINT ipbuf = 0; ipbuf < _cpbuf; ++ipbuf)
    {
        if (_apbuf[ipbuf]->Resize( _apbuf[ipbuf]->QuerySize() + cbAddition ))
        {
            return FALSE;
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\test\xlog\xlog.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    xlog.cxx
    Test application for event log classes
    For WINDOWS only.

    FILE HISTORY:
	Yi-HsinS    29-Oct-1991     Created
	Yi-HsinS    31-Dec-1991     Include loglm.hxx

*/

#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETLIB
#define INCL_NETAUDIT
#define INCL_NETERRORLOG
#include <lmui.hxx>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_APP
#include <blt.hxx>

#include <string.hxx>
#include <dbgstr.hxx>
#include <uiassert.hxx>
#include <uitrace.hxx>

#include <logmisc.hxx>
#include <eventlog.hxx>
#include <loglm.hxx>

extern "C" 
{
    #include "xlog.h"
    #include "stdlib.h"
}

const TCHAR szIconResource[] = SZ("FooIcon");
const TCHAR szMenuResource[] = SZ("FooMenu");
const TCHAR szMainWindowTitle[] = SZ("Event Log Test Application");

class LOGLBI: public LBI
{
private:
    FORMATTED_LOG_ENTRY *_pLogEntry;
    static UINT _adxColumns[6];

protected:
    void Paint( BLT_LISTBOX *plb, HDC hdc, const RECT *prect, 
		GUILTT_INFO *pGUILTT ) const;

    INT Compare( const LBI *plbi ) const;

public:
    LOGLBI( FORMATTED_LOG_ENTRY  *pLogEntry );
    ~LOGLBI();
};

UINT LOGLBI::_adxColumns[] = { 100, 50, 50, 90, 60, COL_WIDTH_AWAP };

class FOO_WND: public APP_WINDOW
{
private:
    BLT_LISTBOX _listbox;

protected:
    virtual BOOL OnResize( const SIZE_EVENT & );

    // Redefinitions
    virtual BOOL OnMenuCommand( MID mid );

public:
    FOO_WND();
    ~FOO_WND();
};


class FOO_APP: public APPLICATION
{
private:
    FOO_WND _wndApp;

public:
    FOO_APP( HANDLE hInstance, TCHAR * pszCmdLine, INT nCmdShow );
};


class PROMPT_SERVER : public DIALOG_WINDOW
{
private:
    SLE _sleServer;

public:
    PROMPT_SERVER( HWND hwndParent );
    APIERR QueryServer( NLS_STR *pnlsServer )
    {    return _sleServer.QueryText( pnlsServer ); } 

};

/**********************************************************************/

PROMPT_SERVER::PROMPT_SERVER( HWND hwndParent )
    : DIALOG_WINDOW( SZ("PROMPT_SERVER"), hwndParent ),
      _sleServer( this, SLE_SERVER )
{
     if ( QueryError() != NERR_Success )
	 return;
}

/**********************************************************************/

FOO_WND::FOO_WND()
    : APP_WINDOW(szMainWindowTitle, szIconResource, szMenuResource ),
      _listbox(this, IDC_LIST,
	       XYPOINT(40, 40), XYDIMENSION(100, 200),
	       WS_CHILD|WS_VSCROLL|WS_HSCROLL|WS_BORDER|
	       LBS_OWNERDRAWFIXED|LBS_EXTENDEDSEL|LBS_NOTIFY|
	       LBS_WANTKEYBOARDINPUT )
{
    if (QueryError())
      return;

    if (!_listbox)
    {
	// Control has already reported the error into the window
	return;
    }

    _listbox.SetPos(XYPOINT(0, 0));
    _listbox.SetSize(QuerySize());

}

FOO_WND::~FOO_WND()
{
    _listbox.Show(FALSE);
}

BOOL FOO_WND::OnMenuCommand( MID mid )
{
    APIERR err;

    switch (mid)
    {
        case IDM_AUDIT_FORMAT:
        case IDM_ERROR_FORMAT:
	{
            _listbox.DeleteAllItems();
            _listbox.Show( FALSE );

	    PROMPT_SERVER dlg( QueryRobustHwnd() );
            if ( ( err = dlg.QueryError()) != NERR_Success )
            {
		MsgPopup( this, err );
                return TRUE;
            }

	    dlg.Process();

	    NLS_STR nlsServer;
	    if ( ( err = dlg.QueryServer( &nlsServer )) != NERR_Success )
            {
		MsgPopup( this, err );
                return TRUE;
            }

            EVENT_LOG *pLog;
	    if ( mid == IDM_AUDIT_FORMAT )
            {
		pLog = new LM_AUDIT_LOG( nlsServer );
	    }
	    else    // IDM_ERROR_FORMAT
	    {
		pLog = new LM_ERROR_LOG( nlsServer );
	    }

            err = pLog ? pLog->QueryError() : (APIERR) ERROR_NOT_ENOUGH_MEMORY;

            if (  (err != NERR_Success ) 
               || (( err = pLog->Open()) != NERR_Success )
               )
            {
		MsgPopup( this, err );
                return TRUE;
            }


            FORMATTED_LOG_ENTRY *pLogEntry;
	    LOG_ENTRY_NUMBER logEntryNum;

            INT j = 0;

            
            while ( j < 20 && pLog->Next() )
            {
		pLog->QueryPos( &logEntryNum );

                if ( (err = pLog->CreateCurrntFormatEntry( &pLogEntry )) != NERR_Success )
		    break;

	        LOGLBI *plbi = new LOGLBI( pLogEntry );
		if ( plbi == NULL )
		{
		    err = ERROR_NOT_ENOUGH_MEMORY;
		    break;
                }

        	_listbox.AddItem( plbi );
		j++;

		if ( j == 10 )
                {
                    logEntryNum.SetRecordNum( 5 );
	            logEntryNum.SetDirection( EVLOG_BACK );
		    pLog->SetPos( logEntryNum );
                }
            }

            if ( err == NERR_Success )
	    {
		if ( j == 20 )   // There are at least twenty items in the log
		{
		    logEntryNum.SetRecordNum(17);
		    logEntryNum.SetDirection(EVLOG_BACK);
		    if ( pLog->GetLogEntry( logEntryNum ) == NERR_Success )
		    {
			pLog->CreateCurrntFormatEntry( &pLogEntry );
			LOGLBI *plbi = new LOGLBI( pLogEntry );
			_listbox.AddItem( plbi );
		    }
		}

		logEntryNum.SetRecordNum(0);
		logEntryNum.SetDirection(EVLOG_BACK);
		if ( pLog->GetLogEntry( logEntryNum ) == NERR_Success )
		{
		    pLog->CreateCurrntFormatEntry( &pLogEntry );
		    LOGLBI *plbi = new LOGLBI( pLogEntry );
		    _listbox.AddItem( plbi );
		}

		logEntryNum.SetRecordNum(0);
		logEntryNum.SetDirection(EVLOG_FWD);
		if ( pLog->GetLogEntry( logEntryNum ) == NERR_Success )
		{
		    pLog->CreateCurrntFormatEntry( &pLogEntry );
		    LOGLBI *plbi = new LOGLBI( pLogEntry );
		    _listbox.AddItem( plbi );
		}
            }

            err = err? err : pLog->QueryLastError();
	    if ( err != NERR_Success )
		MsgPopup( this, err );
            else
                _listbox.Show();

            if ( (err = pLog->Close()) != NERR_Success )
		MsgPopup( this, err );

            delete pLog;
	    return TRUE;
        }

    }

    // default
    return APP_WINDOW::OnMenuCommand(mid);
}


BOOL FOO_WND::OnResize( const SIZE_EVENT & event )
{
    _listbox.SetSize(XYDIMENSION(event.QueryWidth(), event.QueryHeight()));
    return APP_WINDOW::OnResize(event);
}

/**********************************************************************/

FOO_APP::FOO_APP( HANDLE hInst, TCHAR * pszCmdLine, INT nCmdShow )
    : APPLICATION( hInst, pszCmdLine, nCmdShow ),
      _wndApp()
{
    if (QueryError())
	return;

    if (!_wndApp)
    {
	ReportError(_wndApp.QueryError());
	return;
    }

    _wndApp.Show();
    _wndApp.RepaintNow();
}

/**********************************************************************/

LOGLBI::LOGLBI( FORMATTED_LOG_ENTRY *pLogEntry ) 
    : _pLogEntry( pLogEntry )
{
    if ( QueryError() != NERR_Success )
	return;
}

LOGLBI::~LOGLBI()
{
    delete _pLogEntry;
}

VOID LOGLBI::Paint( BLT_LISTBOX * plb, HDC hdc, const RECT * prect,
		    GUILTT_INFO * pGUILTT ) const
{
    TCHAR pszTime[20];

    UIDEBUG(SZ("Record Num: "));
    UIDEBUGNUM( _pLogEntry->QueryRecordNum() );
    UIDEBUG(SZ(" Type: "));
    UIDEBUGNUM( _pLogEntry->QueryType() );
    UIDEBUG(SZ(" Event ID: "));
    UIDEBUGNUM( _pLogEntry->QueryEventID() );
    UIDEBUG(SZ("\n\r"));

    STR_DTE  dteTime( _ltoa( _pLogEntry->QueryTime(), pszTime, 10) );
    STR_DTE  dteType( *(_pLogEntry->QueryTypeString()) );
    STR_DTE  dteSource( *(_pLogEntry->QuerySource()) );
    STR_DTE  dteUser( *( _pLogEntry->QueryUser()) );
    STR_DTE  dteSubType( *( _pLogEntry->QuerySubTypeString()) );
    STR_DTE  dteDesc( *( _pLogEntry->QueryDescription()) );

    DISPLAY_TABLE dtab( 6, LOGLBI::_adxColumns );
    dtab[0] = &dteTime;
    dtab[1] = &dteType;
    dtab[2] = &dteSubType;
    dtab[3] = &dteSource;
    dtab[4] = &dteUser;
    dtab[5] = &dteDesc;

    dtab.Paint( plb, hdc, prect, pGUILTT );
}


INT LOGLBI::Compare( const LBI * plbi ) const
{
    // Don't need to compare
    UNREFERENCED( plbi );
    return 0;
}


SET_ROOT_OBJECT( FOO_APP )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\test\xfsenum\xfsenum.cxx ===
/**********************************************************************/
/**			  Microsoft Windows NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    xfsenum.cxx
    FS_ENUM unit test: main application module

    FILE HISTORY:
	Johnl	22-Oct-1991	Templated from Ben's xBuffer unit test

*/

#define INCL_DOSERRORS
#define INCL_NETERRORS
#if defined(WINDOWS)
# define INCL_WINDOWS
# define INCL_WINDOWS_GDI
#else
# define INCL_OS2
#endif
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = "xfsenum.cxx";
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#include <uiassert.hxx>

extern "C"
{
    #include "xfsenum.h"
}

#if defined(WINDOWS)
# define INCL_BLT_CLIENT
# define INCL_BLT_APP
# include <blt.hxx>
#else
extern "C"
{
# include <stdio.h>
}
#endif

#include <uiassert.hxx>
#include <string.hxx>
#include <fsenum.hxx>
#include <dbgstr.hxx>

APIERR Traverse( FS_ENUM * pFileEnum, DBGSTREAM * pMyDebug ) ;

#if defined(WINDOWS)

const TCHAR szIconResource[] = SZ("XfsenumIcon");
const TCHAR szMenuResource[] = SZ("XfsenumMenu");

const TCHAR szMainWindowTitle[] = SZ("Class FS_ENUM Test");


VOID RunTest( HWND hwndParent );


class XFS_ENUM_WND: public APP_WINDOW
{
protected:
    // Redefinitions
    //
    virtual BOOL OnMenuCommand( MID mid );

public:
    XFS_ENUM_WND();
};


class XFS_ENUM_APP: public APPLICATION
{
private:
    XFS_ENUM_WND  _wndApp;

public:
    XFS_ENUM_APP( HANDLE hInstance, TCHAR * pszCmdLine, INT nCmdShow );
};


XFS_ENUM_APP::XFS_ENUM_APP( HANDLE hInst, TCHAR * pszCmdLine, INT nCmdShow )
    : APPLICATION( hInst, pszCmdLine, nCmdShow ),
      _wndApp()
{
    if (QueryError())
	return;

    if (!_wndApp)
    {
	ReportError(_wndApp.QueryError());
	return;
    }

    _wndApp.ShowFirst();
}


XFS_ENUM_WND::XFS_ENUM_WND()
    : APP_WINDOW( szMainWindowTitle, szIconResource, szMenuResource )
{
    if (QueryError())
	return;

    // ...
}


BOOL XFS_ENUM_WND::OnMenuCommand( MID mid )
{
    switch (mid)
    {
    case IDM_RUN_TEST:
	::RunTest(QueryHwnd());
	return TRUE;
    }

    // default
    return APP_WINDOW::OnMenuCommand(mid);
}


SET_ROOT_OBJECT( XFS_ENUM_APP )


#else // OS2

#include <globinit.hxx>

OUTPUT_TO_STDERR _out;
DBGSTREAM _debug(&_out);

VOID RunTest();

INT main()
{
    GlobalObjCt();  // construct debug-stream
    ::RunTest();
    GlobalObjDt();  // destroy debug-stream

    return 0;
}

#endif // WINDOWS -vs- OS2 unit test skeletons


#if !defined(DEBUG)
#error This test requires the debugging BLT because I am lazy
#endif


class FS_ENUMTEST // test
{
private:
#ifdef WINDOWS
#ifdef WIN32

    W32_FS_ENUM _fsenum1 ;
    W32_FS_ENUM _fsenum2 ;
    W32_FS_ENUM _fsenum3 ;

#else

    DOS_FS_ENUM   _fsenum1 ;
    DOS_FS_ENUM   _fsenum2 ;
    DOS_FS_ENUM   _fsenum3 ;

    WINNET_LFN_FS_ENUM	 _fsenum4 ;
    WINNET_LFN_FS_ENUM	 _fsenum5 ;
    WINNET_LFN_FS_ENUM	 _fsenum6 ;

#endif // WIN32
#else

    OS2_FS_ENUM   _fsenum1 ;
    OS2_FS_ENUM   _fsenum2 ;
    OS2_FS_ENUM   _fsenum3 ;

#endif //WINDOWS


public:
    FS_ENUMTEST();
    ~FS_ENUMTEST();

    APIERR GO( void ) ;
};


#if defined(WINDOWS)
VOID RunTest( HWND hWnd )
{
    ::MessageBox(hWnd,
	SZ("Test results will be written to debug terminal.  Bogus, huh?\nDrive E: should be redirected to an LFN drive."),
	SZ("Note"), MB_OK);

#else // OS2
VOID RunTest()
{

#endif

    FS_ENUMTEST test ;

    test.GO() ;
}


FS_ENUMTEST::FS_ENUMTEST( )
    : _fsenum1( SZ("C:\\") ),
      _fsenum2( SZ("C:\\"), SZ("*.*"), FILTYP_FILES ),
      _fsenum3( SZ("C:\\"), SZ("*.*"), FILTYP_DIRS )
#if defined(WINDOWS) && !defined( WIN32 )
      ,
      _fsenum4( SZ("E:\\") ),
      _fsenum5( SZ("E:\\"), SZ("*.*"), FILTYP_FILES ),
      _fsenum6( SZ("E:\\"), SZ("*.*"), FILTYP_DIRS )
#endif
{
    cdebug << SZ("Starting FS_ENUM test...") << dbgEOL;

    APIERR err ;
    if ( ( err = _fsenum1.QueryError()) ||
	 ( err = _fsenum2.QueryError()) ||
	 ( err = _fsenum3.QueryError())   )
    {
	cdebug << SZ("Error constructing fsenum objects, code: ") << err << dbgEOL ;
    }

#if defined(WINDOWS) && !defined( WIN32 )
    //UINT iType ;
    //if ( LFNVolumeType( 4, (int *)&iType )== NERR_Success &&
    //	   iType == VOLUME_LONGNAMES  )
    {
	//cdebug << "LFNVolumeType has identified volume E: as a long file name volume" << dbgEOL ;

	if ( ( err = _fsenum4.QueryError()) ||
	     ( err = _fsenum5.QueryError()) ||
	     ( err = _fsenum6.QueryError())   )
	{
	    cdebug << SZ("Error constructing fsenum objects, code: ") << err << dbgEOL ;
	}
    }
    //else
    //	  cdebug << "LFNVolumeType has identified volume E: as not supporting long file names, abortting." << dbgEOL ;
#endif

}

APIERR FS_ENUMTEST::GO( void )
{
    APIERR err ;
    if ( ( err = Traverse( &_fsenum1, &cdebug ) ) ||
	 ( err = Traverse( &_fsenum2, &cdebug ) ) ||
	 ( err = Traverse( &_fsenum3, &cdebug ) )   )
    {
	cdebug << SZ("Error code ") << err << SZ(" occurred while testing.") << dbgEOL ;
	return err ;
    }

#if defined(WINDOWS) && !defined(WIN32)
    if ( ( err = Traverse( &_fsenum4, &cdebug ) ) ||
	 ( err = Traverse( &_fsenum5, &cdebug ) ) ||
	 ( err = Traverse( &_fsenum6, &cdebug ) )   )
    {
	cdebug << SZ("Error code ") << err << SZ(" occurred while testing.") << dbgEOL ;
	return err ;
    }
#endif
}

FS_ENUMTEST::~FS_ENUMTEST()
{
    cdebug << SZ("End of FS_ENUM test") << dbgEOL;
}



APIERR Traverse( FS_ENUM * pFileEnum, DBGSTREAM * pMyDebug )
{
    NLS_STR nlsName ;
    while ( pFileEnum->Next() )
    {
	APIERR err = pFileEnum->QueryName( &nlsName ) ;
	*pMyDebug << (const TCHAR *)(pFileEnum->QueryAttr() & _A_SUBDIR ? SZ("[") : SZ("\t")) << nlsName <<
	       (const TCHAR *)(pFileEnum->QueryAttr() & _A_SUBDIR ? SZ("]") : SZ("")) << dbgEOL ;
    }

    if ( pFileEnum->QueryLastError() != ERROR_NO_MORE_FILES )
	return pFileEnum->QueryLastError() ;

    *pMyDebug << SZ("******************************Done************************") << dbgEOL ;

    return NERR_Success ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\test\xtime\xtime.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    xtime.cxx
    First test for INTL_PROFILE and WIN_TIME

    This runs under Windows only.

    FILE HISTORY:
        terryk      29-Aug-1991 Created
        terryk      16-Oct-1991 Add QueryDurationStr test case
        beng        09-Mar-1992 Hack to run under console
        beng        16-Mar-1992 Use generic unit test skeleton
        beng        13-Aug-1992 USE_CONSOLE broken
*/

// #define USE_CONSOLE

#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETLIB
#if defined(WINDOWS)
# define INCL_WINDOWS
#else
# define INCL_OS2
#endif
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = "xtime.cxx";
#define _FILENAME_DEFINED_ONCE szFileName
#endif

extern "C"
{
    #include "skeleton.h"
}

#include <uiassert.hxx>
#include <dbgstr.hxx>
#include <string.hxx>
#include <ctime.hxx>
#include <intlprof.hxx>

#include "skeleton.hxx"


const TCHAR * SzBool( BOOL f )
{
    static TCHAR *const szTrue = SZ("TRUE");
    static TCHAR *const szFalse = SZ("FALSE");

    return ((f) ? szTrue : szFalse);
}


VOID RunTest()
{
    INTL_PROFILE intlprof;

    NLS_STR nlsSep;
    if ( intlprof.QueryTimeSeparator( &nlsSep ) != NERR_Success )
    {
        DBGEOL(" **Cannot get Time separator.");
    }
    ISTR istrSep( nlsSep );
    DBGEOL( "Time Separator = " << (TCHAR)( nlsSep.QueryChar( istrSep )) );

    NLS_STR nlsStr;
    if ( intlprof.QueryAMStr( &nlsStr ) != NERR_Success )
    {
        DBGEOL( " **Cannot get AM separator." );
    }
    DBGEOL( "AM String = " << nlsStr.QueryPch() );

    if ( intlprof.QueryPMStr( &nlsStr ) != NERR_Success )
    {
        DBGEOL( " **Cannot get PM separator." );
    }
    DBGEOL( "PM String = " << nlsStr.QueryPch() );

    DBGEOL( "24 Hour ? "           << SzBool( intlprof.Is24Hour() ) );
    DBGEOL( "Hour Leading zero ? " << SzBool( intlprof.IsHourLZero() ) );

    if ( intlprof.QueryDateSeparator( &nlsSep ) != NERR_Success )
    {
        DBGEOL( " **Cannot get Date separator." );
    }
    istrSep.Reset();
    DBGEOL( "Time Separator = " << (TCHAR)(nlsSep.QueryChar( istrSep )) );

    DBGEOL( "Is Year Century ? "       << SzBool( intlprof.IsYrCentury() ) );
    DBGEOL( "Is Month Leading zero ? " << SzBool( intlprof.IsMonthLZero() ) );
    DBGEOL( "Is Day Leading zero ? "   << SzBool( intlprof.IsDayLZero() ) );

    DBGEOL( "Year Position? "  << intlprof.QueryYearPos() );
    DBGEOL( "Month Position? " << intlprof.QueryMonthPos() );
    DBGEOL( "Day Position? "   << intlprof.QueryDayPos() );

    WIN_TIME wTime;
    DBGEOL( "Current time is " << wTime.QueryTime() );

    if (intlprof.QueryTimeString( wTime, &nlsStr ) != NERR_Success )
    {
        DBGEOL(" **Cannot get Time string" );
    }
    DBGEOL("Time String = "     << nlsStr.QueryPch() );

    if (intlprof.QueryLongDateString( wTime, &nlsStr ) != NERR_Success )
    {
        DBGEOL(" **Cannot get Long Date string." );
    }
    DBGEOL("Long Day String = " << nlsStr.QueryPch() );

    if (intlprof.QueryShortDateString( wTime, &nlsStr ) != NERR_Success )
    {
        DBGEOL(" **Cannot get short day string." );
    }
    DBGEOL("Short date String = " << nlsStr.QueryPch() );

    if (intlprof.QueryDurationStr( 10, 20, 30, 40, &nlsStr ) != NERR_Success )
    {
        DBGEOL(" **Cannot get duration string." );
    }
    DBGEOL("Duration String = " << nlsStr.QueryPch() );

    if (intlprof.QueryDurationStr( 0, 20, 30, 40, &nlsStr ) != NERR_Success )
    {
        DBGEOL(" **Cannot get duration string." );
    }
    DBGEOL("Duration String = " << nlsStr.QueryPch() );

    if (intlprof.QueryDurationStr( 0, 5, 30, 40, &nlsStr ) != NERR_Success )
    {
        DBGEOL(" Cannot get duration string." );
    }
    DBGEOL("Duration String = " << nlsStr.QueryPch() );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\test\xoneshot\xoneshot.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    xoneshot.cxx
    ONESHOT unit test: main application module

    FILE HISTORY:
        beng        28-Dec-1991 ONESHOT unit test hacked from BUFFER
        beng        16-Mar-1992 Use generic unit test skeleton
*/

#define USE_CONSOLE

#define INCL_DOSERRORS
#define INCL_NETERRORS
#if defined(WINDOWS)
# define INCL_WINDOWS
# define INCL_WINDOWS_GDI
#else
# define INCL_OS2
#endif
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = "xoneshot.cxx";
#define _FILENAME_DEFINED_ONCE szFileName
#endif

extern "C"
{
    #include "skeleton.h"
}

#include <base.hxx>
#include <uiassert.hxx>
#include <string.hxx>
#include <strnumer.hxx>
#include <uibuffer.hxx>
#include <dbgstr.hxx>

#include <heapones.hxx>

#include "skeleton.hxx"


DBGSTREAM& operator<<(DBGSTREAM &out, const BYTE *pb)
{
#if defined(WIN32)
    HEX_STR nlsHex((ULONG)pb);

    out << SZ("0x") << nlsHex.QueryPch();
#else
    HEX_STR nlsHigh( HIWORD((ULONG)pb), 4 );
    HEX_STR nlsLow( LOWORD((ULONG)pb), 4 );

    out << nlsHigh.QueryPch() << SZ(":") << nlsLow.QueryPch();
#endif

    return out;
}


DECLARE_ONE_SHOT_OF(STUPID);
DEFINE_ONE_SHOT_OF(STUPID);

class STUPID: public BASE, public ONE_SHOT_OF(STUPID)
{
friend DBGSTREAM& operator<<(DBGSTREAM &out, const STUPID *pstupid);

private:
    UINT    _n;
    STUPID* _pstupidNext;    // next stupid along the pike
    BYTE    _abGarbage[666]; // nice and big and irregular

public:
    STUPID(UINT n);
    ~STUPID();

    VOID SetNext(STUPID *);
    STUPID * QueryNext() const;
};


STUPID::STUPID(UINT n)
    : _n(n),
      _pstupidNext(NULL)
{
    // zzz
}

STUPID::~STUPID()
{
    // zzz
}

VOID STUPID::SetNext( STUPID * pstupid )
{
    _pstupidNext = pstupid;
}

STUPID * STUPID::QueryNext() const
{
    return _pstupidNext;
}

DBGSTREAM& operator<<(DBGSTREAM &out, const STUPID *pstupid)
{
    out << SZ("Stupid #") << pstupid->_n
        << SZ(", next = ") << (const BYTE *)pstupid->_pstupidNext;

    return out;
}


class TEST: public BASE // test object allocs
{
private:
    ONE_SHOT_HEAP _osh;
    STUPID * _pstupidHead;
    STUPID * _pstupidTail;

    VOID Remember( STUPID * pstupid );
    VOID DeleteAll();
    VOID DescribeHeap() const;
    VOID DumpChain() const;

public:
    TEST(UINT cbHeap);
    ~TEST();

    VOID Run(UINT cIters = 0); // 0 = run to exhaustion
};


VOID RunTest()
{
    TEST test(8192);
    ASSERT(!!test);

    test.Run(12);
    test.Run(24);

    TEST test2(16384);
    ASSERT(!!test2);

    test2.Run(24);
    test2.Run(36);
    test2.Run(48);
}


TEST::TEST( UINT cbHeap )
    : _osh(cbHeap),
      _pstupidHead(NULL),
      _pstupidTail(NULL)
{
    if (!_osh)
    {
        APIERR err = _osh.QueryError();
        DBGEOL(SZ("Heap failed to construct - error ") << err);
        ReportError(err);
    }
}


TEST::~TEST()
{
    ASSERT(_pstupidHead == NULL);
    ASSERT(_pstupidTail == NULL);
}


VOID TEST::Run(UINT cIters)
{
    DBGEOL(SZ("Starting a test run of ") << cIters << SZ(" (attempted) stupids"));

    ONE_SHOT_OF(STUPID)::SetHeap(&_osh);

    STUPID * pstupid;
    UINT     iIter = 0;

    while ((pstupid = new STUPID(iIter++)) != NULL)
    {
        Remember(pstupid);

        if (cIters != 0 && iIter == cIters)
            break;
    }

    DumpChain();
    DescribeHeap();
    DeleteAll();
    DumpChain();

    ONE_SHOT_OF(STUPID)::SetHeap(NULL);
}


VOID TEST::Remember(STUPID * pstupid)
{
    if (_pstupidHead == NULL)
        _pstupidHead = pstupid;
    if (_pstupidTail != NULL)
        _pstupidTail->SetNext(pstupid);

    _pstupidTail = pstupid;
}


VOID TEST::DeleteAll()
{
    DBGOUT(SZ("Deleting all stupids..."));
    STUPID * pstupid = _pstupidHead;

    while (pstupid != NULL)
    {
        STUPID * pstupidPrev = pstupid;
        pstupid = pstupid->QueryNext();
        delete pstupidPrev;
    }

    _pstupidHead = _pstupidTail = NULL;
    DBGEOL(SZ(" successfully deleted all stupids"));
}


VOID TEST::DumpChain() const
{
    DBGOUT(SZ("Dumping current chain of stupids: "));

    UINT c = 0;
    for (STUPID * pstupid = _pstupidHead;
         pstupid != NULL;
         pstupid = pstupid->QueryNext(), ++c)
    {
        DBGOUT(pstupid << SZ("... "));
    }
    DBGOUT(dbgEOL);
    DBGEOL(SZ("Dumped a total of ") << c << SZ(" stupids"));
}


VOID TEST::DescribeHeap() const
{
    DBGOUT(SZ("Buffer has size ") << _osh.QuerySize());
    DBGOUT(SZ(" and addr ") << _osh.QueryPtr() << dbgEOL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\trace\cstreams.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    cstreams.cxx
    Implementation for debugging streams - console versions

    FILE HISTORY:
        beng        25-Oct-1991 Created (no longer inline)
        beng        28-Feb-1992 Console streams
*/


#include "lmui.hxx"

extern "C"
{
    #include <stdio.h>
}

#define USE_CONSOLE
#include "dbgstr.hxx"


/*******************************************************************

    NAME:       OUTPUT_TO_STDERR::Render

    SYNOPSIS:   Render output onto the stdio "stderr" stream

    ENTRY:
        psz - pointer to character string.
        Optionally, cch - number of chars in string.

    EXIT:
        Chars have been sent to the stream

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        25-Oct-1991 Implementation outlined
        beng        08-Mar-1992 Unicode fix

********************************************************************/

VOID OUTPUT_TO_STDERR::Render(const TCHAR *psz)
{
#if defined(UNICODE)
    // Has to convert WCHAR to CHAR
    ::fprintf(stderr, "%ws", psz);
#else
    ::fputs(psz, stderr);
#endif
}

VOID OUTPUT_TO_STDERR::Render(const TCHAR *psz, UINT cch)
{
    Render(psz); UNREFERENCED(cch);
}


/*******************************************************************

    NAME:       OUTPUT_TO_STDERR::EndOfLine

    SYNOPSIS:   Render an EOL sequence onto the stdio "stderr" stream

    EXIT:
        Chars have been sent to the stream

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        25-Oct-1991 Implementation outlined

********************************************************************/

VOID OUTPUT_TO_STDERR::EndOfLine()
{
    Render(SZ("\n"), 1);
}


/*******************************************************************

    NAME:       OUTPUT_TO_STDOUT::Render

    SYNOPSIS:   Render output onto the stdio "stdout" stream

    ENTRY:
        psz - pointer to character string.
        Optionally, cch - number of chars in string.

    EXIT:
        Chars have been sent to the stream

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        25-Oct-1991 Implementation outlined
        beng        08-Mar-1992 Unicode fix

********************************************************************/

VOID OUTPUT_TO_STDOUT::Render(const TCHAR *psz)
{
#if defined(UNICODE)
    ::fprintf(stdout, "%ws", psz);
#else
    ::fputs(psz, stdout);
#endif
}

VOID OUTPUT_TO_STDOUT::Render(const TCHAR *psz, UINT cch)
{
    Render(psz);
    UNREFERENCED(cch);
}


/*******************************************************************

    NAME:       OUTPUT_TO_STDOUT::EndOfLine

    SYNOPSIS:   Render an EOL sequence onto the stdio "stdout" stream

    EXIT:
        Chars have been sent to the stream

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        25-Oct-1991 Implementation outlined

********************************************************************/

VOID OUTPUT_TO_STDOUT::EndOfLine()
{
    Render(SZ("\n"), 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\trace\uitrace.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    uitrace.cxx
    Environment specific stuff for the UITRACE and UIDEBUG macros
    See header file or CDD for information.

    This file contains the environment specific (windows vs. OS/2/DOS)
    features of the assert macro, specifically, the output method
    (everything is hidden by the standard C-Runtime).

    FILE HISTORY:
        Johnl        2-Jan-1991 Created
        beng        30-Apr-1991 Made a 'C' file
        beng        25-Sep-1991 Synchronize with changed .hxx file
        beng        25-Sep-1991 Withdrew bogus UIDEBUGNLS (never built)
        beng        26-Sep-1991 Withdrew nprintf calls
        beng        16-Oct-1991 Made a 'C++' file once again
        beng        05-Mar-1992 Hacked for Unicode
        beng        25-Mar-1992 Use winuser StringPrintf routine
        jonn        02-May-1992 BUILD FIX: StringPrintf() -> wsprintf()
        DavidHov    26-Oct-1993 wsprintf() -> sprintf()
*/

#if defined(WINDOWS)
# define INCL_WINDOWS
#elif defined(OS2)
# define INCL_OS2
#endif

#include <stdio.h>

#include "lmui.hxx"

#include "uitrace.hxx"


#if defined(WINDOWS)

#if defined(UNICODE)
  #define SPRINTF ::swprintf
#else
  #define SPRINTF ::sprintf
#endif


VOID UITraceHlp( const TCHAR * psz )
{
    ::OutputDebugString((TCHAR *)psz);
}

VOID UITraceHlp( LONG n )
{
    TCHAR achBuf[30];

    SPRINTF( achBuf, TEXT("%ld"), n );
    ::OutputDebugString( achBuf );
}


#else // OS2 ------------------------------------------------------

extern "C"
{
    #include <stdio.h>
}

VOID UITraceHlp( const TCHAR * psz )
{
    ::fprintf( stderr, psz );
}

VOID UITraceHlp( LONG n )
{
    ::fprintf( stderr, SZ("%ld"), n );
}


#endif // WINDOWS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\wcsaux\wcslwr.c ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    wcslwr.c
    Wide-character strlwr

    FILE HISTORY:
        beng        29-Mar-1992 Created
        beng        07-May-1992 Use official wchar.h headerfile
*/


#include <windows.h>
#include <wchar.h>

wchar_t * _wcslwr(wchar_t * pszArg)
{
    return CharLowerW(pszArg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\trace\streams.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    streams.cxx
    Implementation for debugging streams.  See dbgstr.hxx for def'ns.

    FILE HISTORY:
        beng        25-Oct-1991 Created (no longer inline)
        beng        28-Feb-1992 Separated console and window streams
        beng        05-Mar-1992 Hacked for Unicode
        beng        16-Mar-1992 cdebug changes
        jonn        02-May-1992 BUILD FIX: StringPrintf() -> wsprintf()
        DavidHov    26-Oct-1993 wsprintf() -> sprintf()
*/


#if defined(WINDOWS)
# define INCL_WINDOWS
#endif

#include <stdio.h>

#include "lmui.hxx"

#include "dbgstr.hxx"

extern "C"
{
    #include <string.h>
}

// Stream used by cdebug.  See the header file.
//
DBGSTREAM * DBGSTREAM::_pdbgCurrentGlobal = 0;

#if defined(UNICODE)
  #define SPRINTF ::swprintf
  #define SPRINT_WCHAR  SZ("%c")
  #define SPRINT_TCHAR  SPRINT_WCHAR
  #define SPRINT_CHAR   SZ("%hC")
#else
  #define SPRINTF ::sprintf
  #define SPRINT_CHAR   SZ("%c")
  #deifne SPRINT_TCHAR  SPRINT_CHAR
  #define SPRINT_WCHAR  SZ("%hC")
#endif

/*******************************************************************

    NAME:       DBGSTREAM::DBGSTREAM

    SYNOPSIS:   Constructor

    ENTRY:      pout - pointer to OUTPUTSINK to use

    HISTORY:
        beng        25-Oct-1991 Implementation outlined

********************************************************************/

DBGSTREAM::DBGSTREAM(OUTPUTSINK * pout)
    : _pout(pout)
{
    ;
}


/*******************************************************************

    NAME:       DBGSTREAM::~DBGSTREAM

    SYNOPSIS:   Destructor

    NOTES:
        Does nothing.

    HISTORY:
        beng        25-Oct-1991 Implementation outlined

********************************************************************/

DBGSTREAM::~DBGSTREAM()
{
    ;
}


/*******************************************************************

    NAME:       DBGSTREAM::SetSink

    SYNOPSIS:   Changes the output sink associated with a stream

    ENTRY:      pout - points to new output sink

    EXIT:       stream will now write to that sink

    HISTORY:
        beng        25-Oct-1991 Implementation outlined

********************************************************************/

VOID DBGSTREAM::SetSink(OUTPUTSINK * pout)
{
    _pout = pout;
}


/*******************************************************************

    NAME:       DBGSTREAM::QueryCurrent

    SYNOPSIS:   Returns the current global debug stream

    NOTES:
        This is a static member function.

    HISTORY:
        beng        29-Jun-1992 Implementation outlined

********************************************************************/

DBGSTREAM & DBGSTREAM::QueryCurrent()
{
    return *_pdbgCurrentGlobal;
}


/*******************************************************************

    NAME:       DBGSTREAM::SetCurrent

    SYNOPSIS:   Determine the current global debug stream

    NOTES:
        This is a static member function.

    HISTORY:
        beng        29-Jun-1992 Implementation outlined

********************************************************************/

VOID DBGSTREAM::SetCurrent(DBGSTREAM * pdbg)
{
    _pdbgCurrentGlobal = pdbg;
}


/*******************************************************************

    NAME:       DBGSTREAM::operator<<

    SYNOPSIS:   Stream output operator

    ENTRY:      Takes some datum to render onto the output stream

    EXIT:       The stream has it

    HISTORY:
        beng        25-Oct-1991 Implementations outlined
        beng        08-Mar-1992 Fix SHORT, LONG on Win32
        beng        25-Mar-1992 Use StringPrintf on Win32
        beng        29-Mar-1992 Add simple CHAR output on Unicode;
                                fix TCHAR-USHORT conflict
        jonn        02-May-1992 StringPrintf() -> wsprintf()

********************************************************************/

DBGSTREAM& DBGSTREAM::operator<<(TCHAR c)
{
    TCHAR sz[2];
    SPRINTF(sz, SPRINT_TCHAR, c);
    _pout->Render(sz);
    return *this;
}

DBGSTREAM& DBGSTREAM::operator<<(const TCHAR* psz)
{
    _pout->Render(psz);
    return *this;
}

#if defined(UNICODE)
DBGSTREAM& DBGSTREAM::operator<<(CHAR c)
{
    TCHAR sz[2];
    SPRINTF(sz, SPRINT_CHAR, c);
    _pout->Render(sz);
    return *this;
}

DBGSTREAM& DBGSTREAM::operator<<(const CHAR* psz)
{
    TCHAR * pchTmp = new TCHAR[ ::strlen(psz)+1 ];
    if (pchTmp != NULL)
    {
		// FUTURE-2002/03/14-artm  Prefast: swprintf() inefficient; use wcscpy().
		// Since the length is already calculated, why not use a copy function that
		// copies a given number of characters?
		//
		// Also, the psz parm should be validated to not be NULL before using it.
        SPRINTF(pchTmp, SZ("%hs"), psz);
        _pout->Render(pchTmp);
		// NTRAID#NTBUG9-577099-2002/03/08-artm  Prefast: need to call delete [].
		// Since allocated with new [], need to use delete [] to avoid mem. leak.
        delete pchTmp;
    }
    return *this;
}
#endif

DBGSTREAM& DBGSTREAM::operator<<(INT n)
{
    TCHAR sz[1+CCH_INT+1];
    SPRINTF(sz, SZ("%d"), n);
    _pout->Render(sz);
    return *this;
}

DBGSTREAM& DBGSTREAM::operator<<(UINT n)
{
    TCHAR sz[CCH_INT+1];
    SPRINTF(sz, SZ("%u"), n);
    _pout->Render(sz);
    return *this;
}

DBGSTREAM& DBGSTREAM::operator<<(SHORT n)
{
    TCHAR sz[1+CCH_SHORT+1];
    SPRINTF(sz, SZ("%d"), (int) n );
    _pout->Render(sz);
    return *this;
}

#if !defined(UNICODE)
DBGSTREAM& DBGSTREAM::operator<<(USHORT n)
{
    TCHAR sz[CCH_SHORT+1];
    SPRINTF(sz, SZ("%u"), (UINT)n);
    _pout->Render(sz);
    return *this;
}
#endif

DBGSTREAM& DBGSTREAM::operator<<(LONG n)
{
    TCHAR sz[1+CCH_LONG+1];
    SPRINTF(sz, SZ("%ld"), n);
    _pout->Render(sz);
    return *this;
}

DBGSTREAM& DBGSTREAM::operator<<(ULONG n)
{
    TCHAR sz[CCH_LONG+1];
    SPRINTF(sz, SZ("%lu"), n);
    _pout->Render(sz);
    return *this;
}

DBGSTREAM& DBGSTREAM::operator<<(INT64 n)
{
    TCHAR sz[1+CCH_INT64+1];
    SPRINTF(sz, SZ("%I64d"), n);
    _pout->Render(sz);
    return *this;
}

DBGSTREAM& DBGSTREAM::operator<<(UINT64 n)
{
    TCHAR sz[CCH_INT64+1];
    SPRINTF(sz, SZ("%I64u"), n);
    _pout->Render(sz);
    return *this;
}

DBGSTREAM& DBGSTREAM::operator<<(DBGSTR_SPECIAL dbgSpecial)
{
    if (dbgSpecial == dbgEOL)
        _pout->EndOfLine();
    return *this;
}


/*******************************************************************

    NAME:       OUTPUT_TO_NUL::Render

    SYNOPSIS:   Discard its input (i.e. send its output to "nul")

    ENTRY:
        psz - pointer to character string.
        Optionally, cch - number of chars in string.

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        25-Oct-1991 Implementation outlined

********************************************************************/

VOID OUTPUT_TO_NUL::Render(const TCHAR *psz)
{
    UNREFERENCED(psz);
}

VOID OUTPUT_TO_NUL::Render(const TCHAR *psz, UINT cch)
{
    UNREFERENCED(psz);
    UNREFERENCED(cch);
}


/*******************************************************************

    NAME:       OUTPUT_TO_NUL::EndOfLine

    SYNOPSIS:   Pretend to render an EOL sequence.

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        25-Oct-1991 Implementation outlined

********************************************************************/

VOID OUTPUT_TO_NUL::EndOfLine()
{
    ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\trace\uiassert.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    uiassert.cxx
    Environment specific stuff for the UIASSERT & REQUIRE macro

    This file contains the environment specific (windows vs. OS/2/DOS)
    features of the assert macro, specifically, the output method
    (everything is hidden by the standard C-Runtime).

    FILE HISTORY:
        johnl       17-Oct-1990 Created
        johnl       18-Oct-1990 Added OutputDebugString
        beng        30-Apr-1991 Made a 'C' file
        beng        05-Aug-1991 Withdrew expressions; reprototyped
                                all functions
        beng        17-Sep-1991 Withdrew additional consistency checks
        beng        26-Sep-1991 Withdrew nprintf calls
        beng        16-Oct-1991 Made a 'C++' file once again
        KeithMo     12-Nov-1991 Added abort/retry/ignore logic.
        jonn        09-Dec-1991 FatalAppExit() defn from new windows.h
        beng        05-Mar-1992 Hacked for Unicode
        beng        25-Mar-1992 All "filename" args are now SBCS
        jonn        02-May-1992 BUILD FIX: StringPrintf() -> wsprintf()
        DavidHov    26-Oct-1993 wsprintf() -> sprintf() and lazy-load
                                USER32.DLL for performance reasons.
*/

#if defined(WINDOWS)
# define INCL_WINDOWS
#elif defined(OS2)
# define INCL_OS2
#endif

#include <stdio.h>

#include "lmui.hxx"

#include "uiassert.hxx"
#include "dbgstr.hxx"

#if defined(WINDOWS)

// Detail can be CHAR[] - it's used only as an arg to StringPrintf,
// which will convert it as necessary

static CHAR  szDetail[] = "\n\nPress:\n[Abort] to abort the app\n[Retry] to debug the app\n[Ignore] to continue";

// These two must be TCHAR, since they go to public APIs
// BUGBUG - cfront failing makes static TCHAR[] unavailable

#define SZ_MB_CAPTION  "ASSERTION FAILED"
#define SZ_FAE         "ASSERTION FAILURE IN APP"


//  Static data items used to lazy-load USER32.DLL.  This is done
//  only because NETUI0.DLL should not reference USER32 or GDI32 directly
//  if possible.

#define USER32_DLL_NAME SZ("user32.dll")
#define MSG_BOX_API_NAME "MessageBoxA"
typedef int WINAPI FN_MessageBoxA ( HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType );


VOID UIAssertCommand( const CHAR * pszMessage )
{
    static FN_MessageBoxA * pfMsgBox = NULL ;
    static HMODULE hUser32 = NULL ;

    INT  nRes;

    if ( pfMsgBox == NULL )
    {
        if ( hUser32 = ::LoadLibrary( USER32_DLL_NAME ) )
        {
            pfMsgBox = (FN_MessageBoxA *) ::GetProcAddress( hUser32, MSG_BOX_API_NAME ) ;
        }
    }

    if ( pfMsgBox )
    {
        nRes = (*pfMsgBox) ( NULL,
                             (CHAR *)pszMessage,
                             SZ_MB_CAPTION,
                             MB_TASKMODAL | MB_ICONSTOP | MB_ABORTRETRYIGNORE );
    }
    else
    {
        //  Give debugging indication of assertion failure.

        DBGEOL( "NETUI ASSERT: Could not lazy-load USER32.DLL for assertion: "
                << pszMessage
                << "; aborting application" ) ;

        nRes = IDABORT ;
    }


    switch( nRes )
    {
    case IDRETRY:
        ::DebugBreak();
        return;

    case IDIGNORE:
        return;

    case IDABORT:
    default:
        ::FatalAppExitA( 0, SZ_FAE );
        break;
    }
}

static CHAR *const szFmt0 = "File %.64s, Line %u%s";
static CHAR *const szFmt1 = "%.60s: File %.64s, Line %u%s";

// BUGBUG - the following #define's are used because cfront's failing
// to support something simple like:  TCHAR szFmt0[] = SZ("foobar");
// forces the initialization to be done to a pointer.  Doing a sizeof()
// on the pointer wouldn't be very interesting.

#define SIZEOFSZFMT0 22
#define SIZEOFSZFMT1 29

DLL_BASED
VOID UIAssertHlp( const CHAR* pszFileName, UINT nLine )
{
    CHAR szBuff[SIZEOFSZFMT0+60+64+sizeof(szDetail)];

    ::sprintf(szBuff, szFmt0, pszFileName, nLine, szDetail);

    ::UIAssertCommand( szBuff );
}


DLL_BASED
VOID UIAssertHlp( const CHAR* pszMessage,
                  const CHAR* pszFileName, UINT nLine )
{
    CHAR szBuff[SIZEOFSZFMT1+60+64+sizeof(szDetail)];

    ::sprintf(szBuff, szFmt1, pszMessage, pszFileName, nLine, szDetail);

    ::UIAssertCommand( szBuff );
}


#else // OS2 -------------------------------------------------------

extern "C"
{
    #include <stdio.h>
    #include <process.h>    // abort
}

VOID UIAssertHlp( const CHAR* pszFileName, UINT nLine )
{
    ::printf(SZ("\nAssertion failed: File: %s, Line: %u\n"),
              pszFileName, nLine );
    ::abort();
}


VOID UIAssertHlp( const CHAR* pszMessage,
                  const CHAR* pszFileName, UINT nLine )
{
    ::printf(SZ("\nAssertion failed: %s, File: %s, Line: %u\n"),
              pszMessage, pszFileName, nLine );
    ::abort();
}


#endif // WINDOWS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\trace\wstreams.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    wstreams.cxx
    Implementation for debugging streams - Windowing versions

    FILE HISTORY:
        beng        25-Oct-1991 Created (no longer inline)
        beng        28-Feb-1992 Split into c, wstreams
*/


#define INCL_WINDOWS
#include "lmui.hxx"

#include "blt.hxx"

#include "dbgstr.hxx"


/*******************************************************************

    NAME:       OUTPUT_TO_AUX::Render

    SYNOPSIS:   Render output onto the aux comm port

    ENTRY:
        psz - pointer to character string.
        Optionally, cch - number of chars in string.

    EXIT:
        Chars have been sent to the comm port

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        25-Oct-1991 Implementation outlined
        beng        05-Mar-1992 Unicode fix

********************************************************************/

VOID OUTPUT_TO_AUX::Render(const TCHAR *psz)
{
    ::OutputDebugString((TCHAR*)psz);
}

VOID OUTPUT_TO_AUX::Render(const TCHAR *psz, UINT cch)
{
    Render(psz);
    UNREFERENCED(cch);
}


/*******************************************************************

    NAME:       OUTPUT_TO_AUX::EndOfLine

    SYNOPSIS:   Render an EOL sequence onto the aux comm port

    EXIT:
        Chars have been sent to the comm port

    NOTES:
        This is a virtual member function.

    HISTORY:
        beng        25-Oct-1991 Implementation outlined

********************************************************************/

VOID OUTPUT_TO_AUX::EndOfLine()
{
    Render(SZ("\r\n"), 2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\wcsaux\wcsupr.c ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    wcsupr.c
    Wide-character strupr

    FILE HISTORY:
        beng        29-Mar-1992 Created
        beng        07-May-1992 Use official wchar.h headerfile
*/


#include <windows.h>
#include <wchar.h>

wchar_t * _wcsupr(wchar_t * pszArg)
{
    return CharUpperW(pszArg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\wcsaux\wcsrev.c ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    wcsrev.c
    Wide-character strrev

    FILE HISTORY:
        beng        29-Mar-1992 Created
        beng        07-May-1992 Use official wchar.h headerfile
*/


#include <wchar.h>

wchar_t * _wcsrev(wchar_t * pszArg)
{
    wchar_t *pszStart = pszArg;
    wchar_t *pszLeft = pszArg;
    wchar_t ch;

    while (*pszArg++)                 /* find end of pszArg */
        ;
    pszArg -= 2;

    while (pszLeft < pszArg)
    {
        ch = *pszLeft;
        *pszLeft++ = *pszArg;
        *pszArg-- = ch;
    }

    return pszStart;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\wintime\ctime.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    ctime.cxx
    WIN_TIME class source file.

    FILE HISTORY:
        terryk  27-Aug-91       Created
        terryk  13-Sep-91       Code review changes. Attend: beng
                                davidbul o-simop
        terryk  20-Nov-91       change _ptmTime to _tmTime
        terryk  06-Dec-91       Normalize bug fixed

*/

#include "ntincl.hxx"

#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#include "lmui.hxx"

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include "uiassert.hxx"
#include "uitrace.hxx"
#include "ctime.hxx"


/*******************************************************************

    NAME:       WIN_TIME::WIN_TIME

    SYNOPSIS:   constrcutor for WIN_TIME object

    ENTRY:      if no parameter is specified, set the object to current
                time. Otherwise, set the object to the specified time.
                BOOL fStoreAsGMT is specified the presentation method in local
                time or GMT time.

    HISTORY:
                terryk  27-Aug-91       Created

********************************************************************/

WIN_TIME::WIN_TIME( BOOL fStoreAsGMT )
    : _fStoreAsGMT( fStoreAsGMT )
{
    _fileTime.dwLowDateTime = 0;
    _fileTime.dwHighDateTime = 0;

    _sysTime.wYear = 0;
    _sysTime.wMonth = 0;
    _sysTime.wDay = 0;
    _sysTime.wDayOfWeek = 0;
    _sysTime.wHour = 0;
    _sysTime.wMinute = 0;
    _sysTime.wSecond = 0;
    _sysTime.wMilliseconds = 0;
}

WIN_TIME::WIN_TIME( ULONG tTimeGMT, BOOL fStoreAsGMT )
    : _fStoreAsGMT( fStoreAsGMT )
{
    APIERR err;
    if ( (err = SetTime( tTimeGMT )) != NERR_Success )
    {
        ReportError( err );
        return;
    }

/*
    DBGEOL( "Year = " << (ULONG) _sysTime.wYear );
    DBGEOL( "Month " << (ULONG) _sysTime.wMonth );
    DBGEOL( "DayOfWeek = " << (ULONG) _sysTime.wDayOfWeek );
    DBGEOL( "Day = " << (ULONG) _sysTime.wDay );
    DBGEOL( "Hour = " << (ULONG) _sysTime.wHour );
    DBGEOL( "Minute = " << (ULONG) _sysTime.wMinute );
    DBGEOL( "Second = " << (ULONG) _sysTime.wSecond );
    DBGEOL( "Milliseconds = " << (ULONG) _sysTime.wMilliseconds );
*/
}

WIN_TIME::WIN_TIME( FILETIME fileTimeGMT, BOOL fStoreAsGMT )
    : _fStoreAsGMT( fStoreAsGMT )
{
    APIERR err;
    if ( (err = SetTime( fileTimeGMT )) != NERR_Success )
    {
        ReportError( err );
        return;
    }

/*
    DBGEOL( "Year = " << (ULONG) _sysTime.wYear );
    DBGEOL( "Month " << (ULONG) _sysTime.wMonth );
    DBGEOL( "DayOfWeek = " << (ULONG) _sysTime.wDayOfWeek );
    DBGEOL( "Day = " << (ULONG) _sysTime.wDay );
    DBGEOL( "Hour = " << (ULONG)_sysTime.wHour );
    DBGEOL( "Minute = " << (ULONG) _sysTime.wMinute );
    DBGEOL( "Second = " << (ULONG) _sysTime.wSecond );
    DBGEOL( "Milliseconds = " << (ULONG) _sysTime.wMilliseconds );
*/
}

/*******************************************************************

    NAME:       WIN_TIME::SetCurrentTime

    SYNOPSIS:   set the time object to the current time
                ONLY CALL THIS WHEN _fStoreAsGMT IS TRUE!

    HISTORY:
                terryk  27-Aug-91       Created

********************************************************************/

APIERR WIN_TIME::SetCurrentTime()
{
    if ( _fStoreAsGMT )
        GetSystemTime( &_sysTime );
    else
        GetLocalTime( &_sysTime );

    APIERR err = NERR_Success;
    if ( !SystemTimeToFileTime( &_sysTime, &_fileTime ) )
        err = ::GetLastError();

    return err;
}

/*******************************************************************

    NAME:       WIN_TIME::SetTime

    SYNOPSIS:   set the time object to the specified time

    ENTRY:      ULONG tTimeGMT - the time to be set.
                                 ( number of seconds since 1970 )

    HISTORY:
                terryk  27-Aug-91       Created

********************************************************************/

APIERR WIN_TIME::SetTime( ULONG tTimeGMT )
{
    APIERR err = NERR_Success;

    LARGE_INTEGER tmpTime;

    ::RtlSecondsSince1970ToTime( tTimeGMT, &tmpTime ); // can't fail
    _fileTime.dwLowDateTime = tmpTime.LowPart;
    _fileTime.dwHighDateTime = tmpTime.HighPart;

    if ( !_fStoreAsGMT )
    {
        FILETIME fileTime = _fileTime;
        if ( !FileTimeToLocalFileTime( &fileTime, &_fileTime ))
            err = ::GetLastError();
    }

    if ( err == NERR_Success )
    {
        if ( !FileTimeToSystemTime( &_fileTime, &_sysTime) )
        {
                err = ::GetLastError();
        }
    }

    return err;
}

/*******************************************************************

    NAME:       WIN_TIME::SetTime

    SYNOPSIS:   set the time object to the specified GMT time

    ENTRY:      FILETIME fileTimeGMT - the GMT time to be set.

    HISTORY:
                terryk  27-Aug-91       Created

********************************************************************/

APIERR WIN_TIME::SetTime( FILETIME fileTimeGMT )
{
    APIERR err = NERR_Success;

    if ( _fStoreAsGMT )
    {
        _fileTime = fileTimeGMT;
    }
    else
    {
        if ( !FileTimeToLocalFileTime( &fileTimeGMT, &_fileTime ))
            return ::GetLastError();
    }

    if ( !FileTimeToSystemTime( &_fileTime, &_sysTime) )
    {
        err = ::GetLastError();
    }

    return err;
}

/*******************************************************************

    NAME:       WIN_TIME::SetTimeLocal

    SYNOPSIS:   set the time object to the specified time

    ENTRY:      ULONG tTimeLocal - the time to be set.
                                   ( number of seconds since 1970 )

    HISTORY:
                terryk  27-Aug-91       Created

********************************************************************/

APIERR WIN_TIME::SetTimeLocal( ULONG tTimeLocal )
{
    APIERR err = NERR_Success;

    FILETIME fileTimeLocal;
    LARGE_INTEGER tmpTime;

    ::RtlSecondsSince1970ToTime( tTimeLocal, &tmpTime ); // can't fail
    fileTimeLocal.dwLowDateTime = tmpTime.LowPart;
    fileTimeLocal.dwHighDateTime = tmpTime.HighPart;

    return SetTimeLocal( fileTimeLocal );
}

/*******************************************************************

    NAME:       WIN_TIME::SetTimeLocal

    SYNOPSIS:   set the time object to the specified local time

    ENTRY:      FILETIME fileTimeLocal - the local time to be set.

    HISTORY:
                terryk  27-Aug-91       Created

********************************************************************/

APIERR WIN_TIME::SetTimeLocal( FILETIME fileTimeLocal )
{
    APIERR err = NERR_Success;

    if ( !_fStoreAsGMT )
    {
        _fileTime = fileTimeLocal;
    }
    else
    {
        if ( !LocalFileTimeToFileTime( &fileTimeLocal, &_fileTime ))
            return ::GetLastError();
    }

    if ( !FileTimeToSystemTime( &_fileTime, &_sysTime) )
    {
        err = ::GetLastError();
    }

    return err;
}

/*******************************************************************

    NAME:       WIN_TIME::SetGMT

    SYNOPSIS:   Set the time present method

    ENTRY:      BOOL fStoreAsGMT - TRUE for gmt time
                                   FALSE for local time

    HISTORY:
                terryk  29-Aug-91       Created

********************************************************************/

APIERR WIN_TIME::SetGMT( BOOL fStoreAsGMT )
{
    APIERR err = NERR_Success;

    if ( fStoreAsGMT != _fStoreAsGMT )
    {
        _fStoreAsGMT = fStoreAsGMT;

        FILETIME fileTime = _fileTime;
        if ( _fStoreAsGMT )
        {
            if ( !LocalFileTimeToFileTime( &fileTime, &_fileTime ))
                err = ::GetLastError();

        }
        else
        {
            if ( !FileTimeToLocalFileTime( &fileTime, &_fileTime ))
                err = ::GetLastError();
        }
    }

    if ( err == NERR_Success )
    {
        if ( !FileTimeToSystemTime( &_fileTime, &_sysTime) )
            err = ::GetLastError();
    }

    return err;
}


/*******************************************************************

    NAME:       WIN_TIME::Normalize

    SYNOPSIS:   Use after the SetXXX methods. It will set the day of
                week and year day appropriately.

    RETURNS:    TRUE - success
                FALSE - failure

    HISTORY:
                terryk  27-Aug-91       Created
                terryk  05-Dec-91       If it is GMT, subtract the time
                                        zone different and set time again

********************************************************************/

APIERR WIN_TIME::Normalize()
{
    DBGEOL( "Year = " << (ULONG) _sysTime.wYear );
    DBGEOL( "Month " << (ULONG) _sysTime.wMonth );
    DBGEOL( "Day = " << (ULONG) _sysTime.wDay );
    DBGEOL( "Hour = " << (ULONG) _sysTime.wHour );
    DBGEOL( "Minute = " << (ULONG) _sysTime.wMinute );
    DBGEOL( "Second = " << (ULONG) _sysTime.wSecond );

    DBGEOL( "DayOfWeek = " << (ULONG) _sysTime.wDayOfWeek );
    DBGEOL( "Milliseconds = " << (ULONG) _sysTime.wMilliseconds );

    if ( !SystemTimeToFileTime( &_sysTime, &_fileTime ) )
        return ::GetLastError();

    return NERR_Success;
}

APIERR WIN_TIME::QueryTime( ULONG *ptTimeGMT ) const
{
    UIASSERT( ptTimeGMT != NULL );

    APIERR err = NERR_Success;

    FILETIME fileTime;
    if ( !_fStoreAsGMT )
    {
        if ( !LocalFileTimeToFileTime( (FILETIME *) &_fileTime, &fileTime ))
            err = ::GetLastError();
    }
    else
    {
        fileTime = _fileTime;
    }

    if ( err == NERR_Success )
    {
        LARGE_INTEGER tmpTime;

        tmpTime.LowPart = fileTime.dwLowDateTime;
        tmpTime.HighPart = fileTime.dwHighDateTime;

        if ( !RtlTimeToSecondsSince1970( &tmpTime, ptTimeGMT ))
            err = ERROR_GEN_FAILURE; // best we can do

    }

    return err;
}

APIERR WIN_TIME::QueryFileTime( FILETIME *pfileTimeGMT ) const
{
    UIASSERT( pfileTimeGMT != NULL );

    APIERR err = NERR_Success;

    if ( !_fStoreAsGMT )
    {
        if ( !LocalFileTimeToFileTime( (FILETIME *) &_fileTime, pfileTimeGMT ))
            err = ::GetLastError();
    }
    else
    {
        *pfileTimeGMT = _fileTime;
    }

    return err;
}

APIERR WIN_TIME::QueryTimeLocal( ULONG *ptTimeLocal ) const
{
    UIASSERT( ptTimeLocal != NULL );

    FILETIME fileTime;

    APIERR err = QueryFileTimeLocal( &fileTime );

    if ( err == NERR_Success )
    {
        LARGE_INTEGER tmpTime;

        //
        // JonN 7/10/95 Corrected bug here; this previously read
        // _fileTime, which meant we were returning GMT time if the
        // WIN_TIME object was set for GMT.
        //
        tmpTime.LowPart = fileTime.dwLowDateTime;
        tmpTime.HighPart = fileTime.dwHighDateTime;

        if ( !RtlTimeToSecondsSince1970( &tmpTime, ptTimeLocal ))
            err = ERROR_GEN_FAILURE; // best we can do

    }

    return err;
}

APIERR WIN_TIME::QueryFileTimeLocal( FILETIME *pfileTimeLocal ) const
{
    UIASSERT( pfileTimeLocal != NULL );

    APIERR err = NERR_Success;

    if ( _fStoreAsGMT )
    {
        if ( !FileTimeToLocalFileTime( (FILETIME *) &_fileTime, pfileTimeLocal ))
            err = ::GetLastError();
    }
    else
    {
        *pfileTimeLocal = _fileTime;
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\h\mnetp.h ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    mnetp.h
    <Single line synopsis>

    <Multi-Line, more detailed synopsis>


    FILE HISTORY:
	KeithMo	    13-Oct-1991	Created from DanHi's private port1632.h.

*/


#ifndef _MNETP_H_
#define _MNETP_H_


#include "mnet.h"


#endif	// _MNETP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\mnet32\msystem.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    msystem.h

Abstract:

    Prototypes functions encapsulating OS function. This essentially covers
    everything that is not in NET***.

Author:

    Dan Hinsley (danhi) 10-Mar-1991

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments.

Notes:


Revision History:

    26-Aug-1991 beng
	Separated from port1632.h

--*/

//
// various memory allocation routines
//

PCHAR
MGetBuffer(
    WORD usSize
    );

WORD
MAllocMem(
    DWORD Size,
    LPBYTE * ppBuffer
    );

WORD
MReallocMem(
    DWORD Size,
    LPBYTE * ppBuffer
    );

WORD
MFreeMem(
    LPBYTE pBuffer
    );

VOID
MSleep(
    DWORD Time
    );

/*** Time support */

typedef struct _DATETIME {        /* date */
        UCHAR        hours;
        UCHAR        minutes;
        UCHAR        seconds;
        UCHAR        hundredths;
        UCHAR        day;
        UCHAR        month;
        WORD        year;
        SHORT        timezone;
        UCHAR        weekday;
} DATETIME;
typedef DATETIME FAR *PDATETIME;


WORD
MGetDateTime(
    PDATETIME pDateTime
    );

WORD
MSetDateTime(
    PDATETIME pDateTime
    );

WORD
DosInsMessage(
    LPSTR * ppVTable,
    WORD VCount,
    LPSTR Message,
    WORD MessageLength,
    LPBYTE pBuffer,
    WORD BufferLength,
    PWORD pMessageLength);

WORD
DosPutMessage(
    unsigned int hf,
    WORD us,
    PCHAR pch);

WORD
DosQHandType(
    HFILE hf,
    PWORD pus1,
    PWORD pus2);

WORD 
MTimeToSecsSince1970(
    PLARGE_INTEGER time,
    PULONG seconds) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\mnet32\machinep.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1993  Microsoft Corporation

Module Name:

    machinep.h

Abstract:

    This is the include file that defines detect of machine type.

     This file is only included from following files

    Now only Japanese version is interested in this.

Author:

Revision History:

--*/

#ifndef _MACHINEP_ID_
#define _MACHINEP_ID_

#if defined(FE_SB) && defined(_X86_)

//
// Registry Key
//

//
// UNICODE
//

#define REGISTRY_HARDWARE_DESCRIPTION_W \
        L"\\Registry\\Machine\\Hardware\\DESCRIPTION\\System"

#define REGISTRY_HARDWARE_SYSTEM_W      \
        L"Hardware\\DESCRIPTION\\System"

#define REGISTRY_MACHINE_IDENTIFIER_W   \
        L"Identifier"

#define FUJITSU_FMR_NAME_W    L"FUJITSU FMR-"
#define NEC_PC98_NAME_W       L"NEC PC-98"

//
// ANSI
//

#define REGISTRY_HARDWARE_DESCRIPTION_A \
        "\\Registry\\Machine\\Hardware\\DESCRIPTION\\System"

#define REGISTRY_HARDWARE_SYSTEM_A      \
        "Hardware\\DESCRIPTION\\System"

#define REGISTRY_MACHINE_IDENTIFIER_A   \
        "Identifier"

#define FUJITSU_FMR_NAME_A    "FUJITSU FMR-"
#define NEC_PC98_NAME_A       "NEC PC-98"

//
// Automatic
//

#define REGISTRY_HARDWARE_DESCRIPTION \
        TEXT("\\Registry\\Machine\\Hardware\\DESCRIPTION\\System")

#define REGISTRY_HARDWARE_SYSTEM      \
        TEXT("Hardware\\DESCRIPTION\\System")

#define REGISTRY_MACHINE_IDENTIFIER   \
        TEXT("Identifier")

#define FUJITSU_FMR_NAME    TEXT("FUJITSU FMR-")
#define NEC_PC98_NAME       TEXT("NEC PC-98")

//
// These definition are only for Intel platform.
//
//
// Hardware platform ID
//

#define PC_AT_COMPATIBLE      0x00000000
#define PC_9800_COMPATIBLE    0x00000001
#define FMR_COMPATIBLE        0x00000002

//
// NT Vendor ID
//

#define NT_MICROSOFT          0x00010000
#define NT_NEC                0x00020000
#define NT_FUJITSU            0x00040000

//
// Vendor/Machine IDs
//
// DWORD MachineID
//
// 31           15             0
// +-------------+-------------+
// |  Vendor ID  | Platform ID |
// +-------------+-------------+
//

#define MACHINEID_MS_PCAT     (NT_MICROSOFT|PC_AT_COMPATIBLE)
#define MACHINEID_MS_PC98     (NT_MICROSOFT|PC_9800_COMPATIBLE)
#define MACHINEID_NEC_PC98    (NT_NEC      |PC_9800_COMPATIBLE)
#define MACHINEID_FUJITSU_FMR (NT_FUJITSU  |FMR_COMPATIBLE)

//
// Macros
//

#define ISNECPC98(x)    (x == MACHINEID_NEC_PC98)
#define ISFUJITSUFMR(x) (x == MACHINEID_FUJITSU_FMR)
#define ISMICROSOFT(x)  (x == MACHINEID_MS_PCAT)

//
// User mode ( Win32 API )
//

ULONG RegGetMachineIdentifierValue( PULONG Value );

#endif // defined(DBCS) && defined(i386)
#endif // _MACHINE_ID_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\misc\wintime\intlprof.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    intlprof.cxx
    Source file for international profile information class.

    This module contains functions for managing time and date strings
    using internationalization.

    The functions in this module assume that all WIN.INI international
    settings are valid.  If the settings are not there (which is the
    case until a change is made through control panel) defaults are
    used.

    If the WIN.INI strings (such as the sLongDate string) is invalid
    in someway (i.e. it was NOT written by Control Panel) this code
    will probably break.

    FILE HISTORY:
        Jonn        02/25/91    Obtained from CharlKin
        DavidHov    ???         modified for use in WinPopup
        terryk      27-Aug-91   Change it to C++ class
        terryk      13-Sep-91   Code review change. Attend: davidbul
                                o-simop beng
        terryk      07-Oct-91   add QueryDurationStr() function
        terryk      31-Oct-91   add 1 to QueryMonth() in
                                QueryShortDateString
        beng        05-Mar-1992 Hacked/rewritten extensively
                                (Unicode, size issues)
        jonn        23-Mar-1992 NETUI\common\xlate on path
*/

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_NETLIB
#define INCL_DOSERRORS
#include "lmui.hxx"

extern "C"
{
    #include <time.h>
    #include "wintimrc.h"
    #include "lmuidbcs.h"
}

#include "string.hxx"
#include "strnumer.hxx"
#include "uiassert.hxx"
#include "uitrace.hxx"

#include "ctime.hxx"
#include "intlprof.hxx"

#include "blt.hxx"
#include "dbgstr.hxx"


// BUGBUG - are the following CCHSIZE values adequate?
// Are such limits even appropriate?

#define SZDEF_LONGDATE  SZ("ddd', 'MMMM' 'dd', 'yyyy")
#define CCHSIZE_LONGDATE    34

#define SZDEF_SHORTDATE SZ("MM/dd/yy")
#define CCHSIZE_SHORTDATE   11

#define LWRD TCH('d')
#define LWRY TCH('y')
#define UPRM TCH('M')

#define CCHSIZE_SEPARATOR  3
#define CCHSIZE_AMPM       5


/*******************************************************************

    NAME:       INTL_PROFILE::INTL_PROFILE

    SYNOPSIS:   constructor - get the information from the win.ini file

    HISTORY:
                terryk  28-Aug-91       Created

********************************************************************/

INTL_PROFILE::INTL_PROFILE()
    : _f24Hour( FALSE ),
    _fHourLZero( FALSE ),
    _fYrCentury( FALSE ),
    _fMonthLZero( FALSE ),
    _fDayLZero( FALSE ),
    _nYearPos( 1 ),
    _nMonthPos( 2 ),
    _nDayPos( 3 ),
    _nlsLongDate( SZDEF_LONGDATE ),
    _nlsShortDate( SZDEF_SHORTDATE ),
    _nlsTimeSep( SZ(":") ),
    _nlsDateSep( SZ("/") ),
    _nlsAMStr( SZ("AM") ),
    _nlsPMStr( SZ("PM") ),
    _fTimePrefix( FALSE )
{
    APIERR err;
    if ((( err = _nlsLongDate.QueryError() ) != NERR_Success ) ||
        (( err = _nlsShortDate.QueryError() ) != NERR_Success ) ||
        (( err = _nlsTimeSep.QueryError() ) != NERR_Success ) ||
        (( err = _nlsDateSep.QueryError() ) != NERR_Success ) ||
        (( err = _nlsAMStr.QueryError() ) != NERR_Success ) ||
        (( err = _nlsPMStr.QueryError() ) != NERR_Success ))
    {
        ReportError( err );
        ASSERT( FALSE );
        return;
    }

    // Since we only have 1 copy of the object anyway, it is okay to make
    // all the shareable strings to local member variables.
    //
    // In an international setting "Sunday" may not be abbrieviated
    // as "Sun".
    //

    for (INT i = 0 ; i <= 6 ; i++)
    {
        if ((( err =  _nlsWDay[i].Load( IDS_SUNDAY + i, NLS_BASE_DLL_HMOD )) != NERR_Success ) ||
            (( err = _nlsShortWDay[i].Load( IDS_SUNDAY_SHORT + i, NLS_BASE_DLL_HMOD )) != NERR_Success ))
        {
            ReportError( err );
            ASSERT( FALSE );
            return;
        }
    }

    for (i = 0 ; i <= 11 ; i++)
    {
        if ((( err = _nlsMonth[i].Load( IDS_JANUARY + i, NLS_BASE_DLL_HMOD )) != NERR_Success) ||
            (( err = _nlsShortMonth[i].Load( IDS_JANUARY_SHORT + i, NLS_BASE_DLL_HMOD ))
                != NERR_Success))
        {
            ReportError( err );
            ASSERT( FALSE );
            return;
        }
    }

    // Get the latest information
    err = Refresh();
    if ( err != NERR_Success )
    {
        ReportError( err );
        ASSERT( FALSE );
        return;
    }
}


/*******************************************************************

    NAME:       INTL_PROFILE::QueryDateSeparator

    SYNOPSIS:   return the date string in win.ini

    ENTRY:      NLS_STR * pnlsSep - pointer to a string buffer

    RETURNS:    NERR_Success if succeed, FALSE otherwise. If succeed,
                pnlsSep will set to the separator string

    HISTORY:
                terryk  26-Aug-91       Created

********************************************************************/

APIERR INTL_PROFILE::QueryDateSeparator( NLS_STR * pnlsSep ) const
{
    UIASSERT( pnlsSep != NULL );
    *pnlsSep = _nlsDateSep;
    return pnlsSep->QueryError();
}


/*******************************************************************

    NAME:       INTL_PROFILE::QueryDurationStr

    SYNOPSIS:   return a string
                        X day   if X is less than 2
                        X days  if X is bigger than 2

    ENTRY:      INT cDay - the X value in the string
                INT cHour - the hour value
                INT cMin - the minute value
                INT cSec - the second value
                NLS_STR *pnlsStr - the resultant string

    RETURNS:    APIERR of the string operation

    HISTORY:
        terryk  8-Oct-91        Created
        beng    05-Mar-1992     Rewrote to remove wsprintf

********************************************************************/

APIERR INTL_PROFILE::QueryDurationStr( INT cDay, INT cHour, INT cMin,
                                       INT cSec, NLS_STR *pnlsStr ) const
{
    UIASSERT( pnlsStr != NULL );

    if ( cDay <= 0 )
    {
        // Format a mess of strings.  Delay errcheck until Append calls

        DEC_STR nlsHour(cHour, IsHourLZero() ? 2 : 1);
        DEC_STR nlsMinute(cMin, 2);
        DEC_STR nlsSecond(cSec, 2);

        NLS_STR nlsFormat(40); // avoid repeated reallocs

        APIERR err;
        if (   ((err = nlsFormat.Append(nlsHour)) != NERR_Success)
            || ((err = nlsFormat.Append(_nlsTimeSep)) != NERR_Success)
            || ((err = nlsFormat.Append(nlsMinute)) != NERR_Success)
            || ((err = nlsFormat.Append(_nlsTimeSep)) != NERR_Success)
            || ((err = nlsFormat.Append(nlsSecond)) != NERR_Success) )
        {
            return err;
        }

        *pnlsStr = nlsFormat;
    }
    else
    {
        DEC_STR nlsDay(cDay);
        DEC_STR nlsHour(cHour);
        DEC_STR nlsMinute(cMin);

        APIERR err;
        if (   ((err = nlsDay.QueryError()) != NERR_Success)
            || ((err = nlsHour.QueryError()) != NERR_Success)
            || ((err = nlsMinute.QueryError()) != NERR_Success)
            || ((err = pnlsStr->Load( IDS_SESSION_DURATION, NLS_BASE_DLL_HMOD )) != NERR_Success)
            || ((err = pnlsStr->InsertParams( nlsDay, nlsHour, nlsMinute ))
                != NERR_Success) )
        {
            return err;
        }
    }

    return pnlsStr->QueryError();
}


/*******************************************************************

    NAME:       INTL_PROFILE::QueryTimeSeparator

    SYNOPSIS:   return the time string in win.ini

    ENTRY:      NLS_STR * pnlsSep - pointer to a string buffer

    RETURNS:    TRUE if succeed, FALSE otherwise. If succeed, pnlsSep
                will set to the separator string

    HISTORY:
                terryk  26-Aug-91       Created

********************************************************************/

APIERR INTL_PROFILE::QueryTimeSeparator( NLS_STR * pnlsSep ) const
{
    UIASSERT( pnlsSep != NULL );
    *pnlsSep = _nlsTimeSep;
    return pnlsSep->QueryError();
}


/*******************************************************************

    NAME:       INTL_PROFILE::QueryAMStr

    SYNOPSIS:   return the AM string in win.ini

    ENTRY:      NLS_STR * pnlsAM - pointer to a string buffer

    RETURNS:    TRUE if succeed, FALSE otherwise. If succeed, pnlsAM
                will set to the AM string

    HISTORY:
                terryk  26-Aug-91       Created

********************************************************************/

APIERR INTL_PROFILE::QueryAMStr( NLS_STR * pnlsAM ) const
{
    UIASSERT( pnlsAM );
    *pnlsAM = _nlsAMStr;
    return pnlsAM->QueryError();
}


/*******************************************************************

    NAME:       INTL_PROFILE::QueryPMStr

    SYNOPSIS:   return the PM string in win.ini

    ENTRY:      NLS_STR * pnlsPM - pointer to a string buffer

    RETURNS:    TRUE if succeed, FALSE otherwise. If succeed, pnlsPM
                will set to the PM string

    HISTORY:
                terryk  26-Aug-91       Created

********************************************************************/

APIERR INTL_PROFILE::QueryPMStr( NLS_STR * pnlsPM ) const
{
    UIASSERT( pnlsPM != NULL );
    *pnlsPM = _nlsPMStr;
    return pnlsPM->QueryError();
}


/*******************************************************************

    NAME:       INTL_PROFILE::QueryTimeString

    SYNOPSIS:   get the time string of the given time

    ENTRY:      WIN_TIME & winTime - the specified time object
                NLS_STR * pnlsTime - returned string

    RETURNS:    NERR_Success if succeed. Otherwise failure.

    HISTORY:
        terryk  27-Aug-91       Created
        beng    05-Mar-1992     Rewrote to remove wsprintf

********************************************************************/

APIERR INTL_PROFILE::QueryTimeString( const WIN_TIME & winTime,
                                      NLS_STR * pnlsTime ) const
{
    UIASSERT( pnlsTime != NULL );

    INT cHour = winTime.QueryHour();
    INT cMinute = winTime.QueryMinute();
    INT cSecond = winTime.QuerySecond();

    INT nHourDisplay = Is24Hour() ? cHour
                                  : ((cHour % 12) ? (cHour % 12) : 12) ;

    NLS_STR nlsFormat;
    APIERR err = QueryDurationStr(0, nHourDisplay, cMinute, cSecond,
                                  &nlsFormat);
    if (err != NERR_Success)
    {
        return err;
    }

    if (!Is24Hour())
    {
        const NLS_STR & nlsSuffix = *((cHour < 12) ? &_nlsAMStr : &_nlsPMStr);

        if( NETUI_IsDBCS() && IsTimePrefix() )
        {
            NLS_STR nlsFormat2;
            nlsFormat2.Append( nlsSuffix );
            err = nlsFormat2.AppendChar(TCH(' '));
            err = nlsFormat2.Append(nlsFormat);
            *pnlsTime = nlsFormat2;
        }
        else
        {
            err = nlsFormat.AppendChar(TCH(' '));
            err = nlsFormat.Append(nlsSuffix);
        }				
    }

    if ( Is24Hour() || !NETUI_IsDBCS() || !IsTimePrefix() )
        *pnlsTime = nlsFormat;

    return pnlsTime->QueryError();
}


/*******************************************************************

    NAME:       INTL_PROFILE::QueryShortDateString

    SYNOPSIS:   get the short format of date string

    ENTRY:      WIN_TIME & winTime - time object
                NLS_STR *pnlsDate - the result string

    RETURNS:    APIERR err - NERR_Success if succeed

    NOTE:       According to the international handbook. sShortDate only
                accepts the format specified M, MM, d, dd, yy, and yyyy.
                Therefore, we only need to check for IsMonthLZero and
                IsDayLZero and IsYrCentury.

    HISTORY:
        terryk  29-Aug-91       Created
        beng    05-Mar-1992     Rewritten for Unicode

********************************************************************/

APIERR INTL_PROFILE::QueryShortDateString( const WIN_TIME & winTime,
                                           NLS_STR *pnlsDate ) const
{
    INT nYear = winTime.QueryYear();
    if ( !IsYrCentury() )
        nYear %= 100;

    // ctors will be checked in Append statements below

    DEC_STR nlsYear(nYear,                   IsYrCentury() ? 4 : 2);
    DEC_STR nlsMonth(winTime.QueryMonth(),     IsMonthLZero() ? 2 : 1);
    DEC_STR nlsDay(winTime.QueryDay(),         IsDayLZero() ? 2 : 1);

    ASSERT(QueryYearPos() != QueryMonthPos());
    ASSERT(QueryYearPos() != QueryDayPos());
    ASSERT(QueryDayPos() != QueryMonthPos());

    NLS_STR * pnlsFields[3];
    pnlsFields[QueryYearPos()-1] = &nlsYear;
    pnlsFields[QueryMonthPos()-1] = &nlsMonth;
    pnlsFields[QueryDayPos()-1] = &nlsDay;

    NLS_STR nlsFormat(40); // avoid repeated reallocs

    APIERR err;
    if (   ((err = nlsFormat.Append(*pnlsFields[0])) != NERR_Success)
        || ((err = nlsFormat.Append(_nlsDateSep)) != NERR_Success)
        || ((err = nlsFormat.Append(*pnlsFields[1])) != NERR_Success)
        || ((err = nlsFormat.Append(_nlsDateSep)) != NERR_Success)
        || ((err = nlsFormat.Append(*pnlsFields[2])) != NERR_Success) )
    {
        return err;
    }

    *pnlsDate = nlsFormat;
    return pnlsDate->QueryError();
}


/*******************************************************************

    NAME:       INTL_PROFILE::ScanLongDate

    SYNOPSIS:   Preprocess long-date picture string

    ENTRY:      NLS_STR * pnlsResults - repository for results

    EXIT:       String has all picture descriptions replaced with
                %x insert-params codes, and all quotes and separators
                processed correctly.

    RETURNS:    APIERR err. NERR_Success if succeed.

    NOTE:
        This is a private member function.

    HISTORY:
        beng    07-Mar-1992     Created

********************************************************************/

APIERR INTL_PROFILE::ScanLongDate( NLS_STR * pnlsResults ) const
{
    // Tables of insert-strings corresponding to the key-substrings.

    static const TCHAR * apszMCodes[] = {SZ("%1"), SZ("%2"),
                                         SZ("%3"), SZ("%4")};
    static const TCHAR * apszDCodes[] = {SZ("%5"), SZ("%6"),
                                         SZ("%7"), SZ("%8")};
    static const TCHAR * apszYCodes[] = {NULL,     SZ("%9"),
                                         NULL,     SZ("%10")};

    NLS_STR nlsProcessed(60);   // Accumulated results.  The allocation count
                                // is just a guess to minimize allocs
    ISTR istrSrc(_nlsLongDate); // Index into above
    BOOL fBeginSep = TRUE;      // If next character could begin a separator

    APIERR err;
    WCHAR wchNext;
    while ((wchNext = _nlsLongDate.QueryChar(istrSrc)) != 0)
    {
        ++istrSrc;

        switch (wchNext)
        {
        case TCH('\''):
            // Quote - either within unquoted separator or else
            // beginning a quoted separator.

            if (!fBeginSep)
            {
                // A quote in the middle of an unquoted separator
                // means "emit next literal character."

                err = nlsProcessed.AppendChar(_nlsLongDate.QueryChar(istrSrc));
                if (err != NERR_Success)
                    return err;
                ++istrSrc;
            }
            else
            {
                // Match quoted separator.  Within a quoted separator,
                // two quotes becomes a single quote char.

                BOOL fEscapeNextQuote = FALSE;
                for (;;)
                {
                    wchNext = _nlsLongDate.QueryChar(istrSrc);

                    if (wchNext == TCH('\''))
                    {
                        ++istrSrc;
                        if (fEscapeNextQuote)
                        {
                            // Reset the flag, then fall out so quote
                            // is appended to output
                            fEscapeNextQuote = FALSE;
                        }
                        else
                        {
                            // Set the flag, then go get another character
                            // right away
                            fEscapeNextQuote = TRUE;
                            continue;
                        }
                    }
                    else if (fEscapeNextQuote)
                    {
                        // Last character wasn't a quote.
                        // We're done.
                        break;
                    }
                    else if (wchNext == 0)
                    {
                        // Hit a null when looking for closing quote

                        DBGEOL(SZ("Syntax error in sLongDate - unmatched quotes"));
                        return ERROR_GEN_FAILURE;
                    }
                    else
                    {
                        ++istrSrc;
                    }

                    err = nlsProcessed.AppendChar(wchNext);
                    if (err != NERR_Success)
                        return err;
                }
            }
            break;

        case TCH('M'):
        case TCH('d'):
        case TCH('y'):
            {
                // Match any of the recognized date key-strings, and replace
                // it with the appropriate insertion-string.

                WCHAR wchLast = wchNext;
                UINT iWhich = 0;

                while ((wchNext = _nlsLongDate.QueryChar(istrSrc)) == wchLast)
                {
                    ++istrSrc;
                    if (++iWhich == 3) // All types have a max length of 4.
                        break;
                }

                const TCHAR ** ppszCodes =
                    (wchLast == TCH('M') ? apszMCodes
                                        : (wchLast == TCH('d') ? apszDCodes
                                                              : apszYCodes));
                const TCHAR * pszCode = ppszCodes[iWhich];
                if (pszCode == NULL)
                {
                    // See table.  Probably an odd number of "y" chars.
                    DBGEOL(SZ("Syntax error in sLongDate - unknown key"));
                    return ERROR_GEN_FAILURE;
                }
                err = nlsProcessed.Append(ALIAS_STR(pszCode));
                if (err != NERR_Success)
                    return err;

                // WARNING: GROSS HACK
                // Since the codes use NLS_STR::InsertParams to insert the
                // appropriate versions, if the next character is a decimal
                // digit it will confuse the simpleminded inserter.  In that
                // rare case I append a space to the insert-code.  This will
                // give an extra space in the output, where presumably the
                // originator wanted the format value to run right into the
                // next number.  I'm going to walk way out on a limb here
                // and say that it'll never happen in my lifetime....

                wchNext = _nlsLongDate.QueryChar(istrSrc); // peek ahead
                if (wchNext >= TCH('0') && wchNext <= TCH('9'))
                {
                    err = nlsProcessed.AppendChar(TCH(' '));
                    if (err != NERR_Success)
                        return err;
                }
            }
            fBeginSep = TRUE;
            break;

        default:
            // Some character in an unquoted separator.

            err = nlsProcessed.AppendChar(wchNext);
            if (err != NERR_Success)
                return err;
            fBeginSep = FALSE;
            break;
        }
    }

    *pnlsResults = nlsProcessed;
    return pnlsResults->QueryError();
}


/*******************************************************************

    NAME:       INTL_PROFILE::QueryLongDateString

    SYNOPSIS:   get the date string in Long format according to WIN.INI
                format

    ENTRY:      WIN_TIME & winTime - current time/date object
                NLS_STR *nlsDate - the resultant string

    RETURNS:    APIERR err. NERR_Success if succeed.

    HISTORY:
        terryk  29-Aug-91       Created
        beng    07-Mar-1992     Rewrote (Unicode fixes, size)

********************************************************************/

APIERR INTL_PROFILE::QueryLongDateString( const WIN_TIME & winTime,
                                          NLS_STR *pnlsDate) const
{
    // First, generate a version of sLongDate with each format-entry
    // replaced with an insert-strings parameter, and with the superfluous
    // quotes removed.

    // CODEWORK - perform this at Refresh time, or else cache the results.

    NLS_STR nlsFormat(60); // just a guess to minimize reallocs

    APIERR err = ScanLongDate(&nlsFormat);
    if (err != NERR_Success)
        return err;

    // We now have the sLongDate broken down into insert-params format,
    // with a given parameter number for each kind of format entry.
    // Passing the appropriate value for each format, call Insert.

    // Defer checking all ctors until within InsertParams

    UINT nMonth = winTime.QueryMonth();
    DEC_STR nlsMonth0(nMonth);
    DEC_STR nlsMonth1(nMonth, 2);
    const NLS_STR * pnlsMonth2 = &(_nlsShortMonth[nMonth-1]);
    const NLS_STR * pnlsMonth3 = &(_nlsMonth[nMonth-1]);

    UINT nDay = winTime.QueryDay();
    DEC_STR nlsDay0(nDay);
    DEC_STR nlsDay1(nDay, 2);
    UINT nDayOfWeek = winTime.QueryDayOfWeek();
    const NLS_STR * pnlsDay2 = &(_nlsShortWDay[nDayOfWeek]);
    const NLS_STR * pnlsDay3 = &(_nlsWDay[nDayOfWeek]);

    UINT nYear = winTime.QueryYear();
    DEC_STR nlsYear0(nYear % 100, 2);
    DEC_STR nlsYear1(nYear, 4);

    const NLS_STR * apnlsParms[11];
    apnlsParms[0] = &nlsMonth0;
    apnlsParms[1] = &nlsMonth1;
    apnlsParms[2] = pnlsMonth2;
    apnlsParms[3] = pnlsMonth3;
    apnlsParms[4] = &nlsDay0;
    apnlsParms[5] = &nlsDay1;
    apnlsParms[6] = pnlsDay2;
    apnlsParms[7] = pnlsDay3;
    apnlsParms[8] = &nlsYear0;
    apnlsParms[9] = &nlsYear1;
    apnlsParms[10] = NULL;

    err = nlsFormat.InsertParams(apnlsParms);
    if (err != NERR_Success)
        return err;

    *pnlsDate = nlsFormat;
    return pnlsDate->QueryError();
}


/*******************************************************************

    NAME:       INTL_PROFILE::Refresh

    SYNOPSIS:   get the latest information from win.ini

    HISTORY:
        terryk      29-Aug-91   Created
        beng        29-Mar-1992 Work around cfront wchar_t shortcoming

********************************************************************/

APIERR INTL_PROFILE::Refresh()
{
    static TCHAR *const pszIntl = SZ("intl");

    _f24Hour = ::GetProfileInt( pszIntl, SZ("iTime"), 0 ) == 1;
    if ( NETUI_IsDBCS() )
    {
        _fTimePrefix = ::GetProfileInt( pszIntl, SZ("iTimePrefix"), 0 ) == 1;
    }
    _fHourLZero = ::GetProfileInt( pszIntl, SZ("iTLzero"), 1 ) == 1;

    TCHAR szTempStr[100];

    ::GetProfileString( pszIntl, SZ("sDate"), SZ("/"), szTempStr,
                        CCHSIZE_SEPARATOR );
    _nlsDateSep = szTempStr;
    APIERR err = _nlsDateSep.QueryError();
    if ( err != NERR_Success )
    {
        return err;
    }

    ::GetProfileString( pszIntl, SZ("sTime"), SZ(":"), szTempStr,
                        CCHSIZE_SEPARATOR );
    _nlsTimeSep = szTempStr;
    err = _nlsTimeSep.QueryError();
    if ( err != NERR_Success )
    {
        return err;
    }

    ::GetProfileString( pszIntl, SZ("s1159"), SZ("AM"), szTempStr,
                        CCHSIZE_AMPM );
    _nlsAMStr = szTempStr;
    err = _nlsAMStr.QueryError();
    if ( err != NERR_Success )
    {
        return err;
    }

    ::GetProfileString( pszIntl, SZ("s2359"), SZ("PM"), szTempStr,
                        CCHSIZE_AMPM );
    _nlsPMStr = szTempStr;
    err = _nlsPMStr.QueryError();
    if ( err != NERR_Success )
    {
        return err;
    }

    ::GetProfileString( pszIntl, SZ("sShortDate"), SZDEF_SHORTDATE, szTempStr,
                        CCHSIZE_SHORTDATE );
    _nlsShortDate = szTempStr;
    err = _nlsShortDate.QueryError();
    if ( err != NERR_Success )
    {
        return err;
    }

    ::GetProfileString( pszIntl, SZ("sLongDate"), SZDEF_LONGDATE, szTempStr,
                        CCHSIZE_LONGDATE ) ;
    _nlsLongDate = szTempStr;
    err = _nlsLongDate.QueryError();
    if ( err != NERR_Success )
    {
        return err;
    }

   //
   // first find out if there's supposed to be a leading 0 on the day
   //
   ISTR istrDay1( _nlsShortDate );
   ISTR istrMonth1( _nlsShortDate );
   ISTR istrYear1( _nlsShortDate );

   if ( _nlsShortDate.strchr( & istrDay1, LWRD ))
   {
      ISTR istrDay2 = istrDay1;
      ++istrDay2 ;
      if ( _nlsShortDate.QueryChar( istrDay2 ) == LWRD )
         _fDayLZero = TRUE ;
   }

   //
   // month?
   //
   if ( _nlsShortDate.strchr( & istrMonth1, UPRM ))
   {
      ISTR istrMonth2 = istrMonth1;
      ++istrMonth2 ;
      if ( _nlsShortDate.QueryChar( istrMonth2 ) == UPRM )
         _fMonthLZero = TRUE ;
   }

    //
    // Does year have the century?
    //
    if ( _nlsShortDate.strchr( & istrYear1, LWRY ))
    {
        ISTR istrYear2 = istrYear1;
        ++istrYear2;
        {
            if ( _nlsShortDate.QueryChar( istrYear2 ) == LWRY )
            {
                ++istrYear2 ;
                if ( _nlsShortDate.QueryChar( istrYear2 ) == LWRY )
                {
                    _fYrCentury = TRUE ;
                }
            }
            else
            {
                UIDEBUG( SZ("Profile information incorrect.") );
            }
        }
    }


   // find out the position for short date string

   if ( istrYear1 < istrMonth1 )
   {
       if ( istrMonth1 < istrDay1 )
       {
            _nYearPos = 1;
            _nMonthPos = 2;
            _nDayPos = 3;
       }
       else if ( istrDay1 < istrYear1 )
       {
            _nYearPos = 2;
            _nMonthPos = 3;
            _nDayPos = 1;
       }
       else
       {
            _nYearPos = 1;
            _nMonthPos = 3;
            _nDayPos = 2;
       }
   }
   else
   {
       if ( istrYear1 < istrDay1 )
       {
            _nYearPos = 2;
            _nMonthPos = 1;
            _nDayPos = 3;
       }
       else if ( istrDay1 < istrMonth1 )
       {
            _nYearPos = 3;
            _nMonthPos = 2;
            _nDayPos = 1;
       }
       else
       {
            _nYearPos = 3;
            _nMonthPos = 1;
            _nDayPos = 2;
       }
   }

   return NERR_Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\mnet32\devenum.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**                Copyright(c) Microsoft Corp., 1990                **/
/**********************************************************************/

/*
 * DEVENUM:     Enumerate devices.
 * History:
 *      ChuckC      21-Jan-1991     Created
 *      KeithMo     09-Oct-1991     Win32 Conversion.
 *      terryk      21-Oct-1991     Comment out winprof.hxx
 *                                  Add WIN32BUGBUG
 *      terryk      08-Nov-1991     Fix EnumNetDevice WIN32 problem
 *      terryk      18-Nov-1991     move the endif location to remove
 *                                  warning message
 *      beng        29-Mar-1992     Remove odious PSZ type
 */

#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETCONS
#define INCL_NETLIB
#define INCL_NETUSE
#ifdef WINDOWS
    #define INCL_WINDOWS
#else
    #define INCL_OS2
    #define INCL_DOSFILEMGR
#endif

#include "lmui.hxx"

extern "C"
{

#if !defined(OS2) && !defined(WIN32)
    #include <dos.h>
#endif
    #include "mnet.h"
#if defined(FE_SB) && defined(i386) // for NEC PC98
    #include "lmuidbcs.h"
    #include "machinep.h"
#endif
}

#include "uisys.hxx"

#include "uibuffer.hxx"
#include "string.hxx"

// forward declare
ULONG MapDrive(const TCHAR * pszDev) ;
ULONG MapComm(const TCHAR * pszDev) ;
ULONG MapLPT(const TCHAR * pszDev) ;
DLL_BASED
ULONG EnumNetDevices(INT sType) ;
DLL_BASED
ULONG EnumUnavailDevices(INT sType) ;


//
// Now only Japanese version is interested in.
// source code from machine.lib in NT3.51J.
//
#if defined(FE_SB) && defined(i386)

ULONG 
RegGetMachineIdentifierValue(
    IN OUT PULONG Value
    )

/*++

Routine Description:

    Given a unicode value name this routine will go into the registry
    location for the machine identifier information and get the
    value.

Arguments:

    Value   - a pointer to the ULONG for the result.

Return Value:

    NTSTATUS

    If STATUS_SUCCESSFUL is returned, the location *Value will be
    updated with the DWORD value from the registry.  If any failing
    status is returned, this value is untouched.

--*/

{
    LONG   lRet;
    HKEY   hKey;
    DWORD  dwType;
    TCHAR  tchData[100];
    PTCHAR ptchData = tchData;
    DWORD  dwData = sizeof(tchData);
    int    cchCompareF, cchCompareN;
    LCID   lcid;

    //
    // Set default as PC/AT
    //

    *Value = MACHINEID_MS_PCAT;

    //
    // Open registry key
    //

    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE,       // hRootKey
                         REGISTRY_HARDWARE_SYSTEM, // SubKey
                         0,                        // Reserved
                         KEY_READ,                 // Read Op.
                         &hKey );                  // hKey

    if( lRet != ERROR_SUCCESS ) return( lRet );

    //
    // Read registry key
    //

ReTryRead:

    lRet = RegQueryValueEx( hKey,                        // kKey
                            REGISTRY_MACHINE_IDENTIFIER, // ValueName
                            NULL,                        // Reserved
                            &dwType,                     // Data Type
                            (LPBYTE)ptchData,            // Data buffer
                            &dwData );                   // Data buffer size

    if( lRet != ERROR_SUCCESS ) {

        if( lRet != ERROR_MORE_DATA ) goto Exit1;

        //
        // the Buffer is too small to store the data, we retry with
        // large buffer.
        //

        dwData += 2;

        ptchData = (PTCHAR)LocalAlloc( LMEM_FIXED , dwData );

        if( ptchData == NULL ) {
            lRet = ERROR_NOT_ENOUGH_MEMORY;
            goto Exit1;
        }

        goto ReTryRead;
    }

    //
    // Determine platform.
    //

    lcid = MAKELCID( MAKELANGID( LANG_NEUTRAL, SUBLANG_SYS_DEFAULT ),
                     SORT_DEFAULT                                    );

    cchCompareF = lstrlen( FUJITSU_FMR_NAME );
    cchCompareN = lstrlen( NEC_PC98_NAME );

    if( CompareString( lcid,             // Locale id
                       NORM_IGNORECASE,  // Ignoare case
                       ptchData,         // String A.
                       cchCompareF,      // length of string A to compare
                       FUJITSU_FMR_NAME, // String B.
                       cchCompareF )     // length of string B to compare
        == 2                             // String A == String B
      ) {

        //
        // Fujitsu FMR Series.
        //

        *Value = MACHINEID_FUJITSU_FMR;

    } else if( CompareString( lcid,             // Locale id
                              NORM_IGNORECASE,  // Igonre case
                              ptchData,         // String A.
                              cchCompareN,      // length of string A to compare
                              NEC_PC98_NAME,    // String B.
                              cchCompareN )     // length of string B to compare
               == 2                             // String A == String B
             ) {

        //
        // NEC PC-9800 Seriss
        //

        *Value = MACHINEID_NEC_PC98;

    } else {

        //
        // Standard PC/AT comapatibles
        //

        *Value = MACHINEID_MS_PCAT;

    }

Exit1:

    RegCloseKey( hKey );

    return( lRet );

}

#endif // defined(FE_SB) && defined(i386)

/**************************** Local Devices **************************/


/*
    BUGBUG BUGBUG  EnumAllDrives does not return A: or B:, since this
    method is currently used only by User Manager's HomedirDrive
    dropdown.  The name EnumAllDrives is misleading and should be
    changed.
*/

/*---------------- OS-independent -----------------*/

/*
 * cycle thru the drives, and return mask of all valid drive designations
 */
ULONG EnumAllDrives()
{
    ULONG  ulMask, ulMap = 0L ;
    TCHAR  szDrive[3] ;

    // get drive map
    ulMap = 0L ;                // We don't have A:, B:
    *szDrive = TCH('\0') ;

#if defined(FE_SB) && defined(i386)
    //
    // Now only Japanese version interested in it.
    //
    DWORD gdwMachineId = MACHINEID_MS_PCAT;
    if ( NETUI_IsDBCS() )
    {
        RegGetMachineIdentifierValue( &gdwMachineId );
    }
    //
    // Add A: and B: if the running platform is NEC PC98.
    //
    if ( ISNECPC98(gdwMachineId) )
    {
        ::strcpyf(szDrive, SZ("A:")) ;
        ulMask = 0x01L ;
    }
    else
    {
#endif // defined(FE_SB) && defined(i386)
    ::strcpyf(szDrive, SZ("C:")) ;
    ulMask = 0x04L ;
#if defined(FE_SB) && defined(i386) // for NEC PC98
    }
#endif // defined(FE_SB) && defined(i386)
    do
    {
        ulMap |= ulMask ;
        ulMask <<= 1 ;
        ++*szDrive ;
    } while (*szDrive <= TCH('Z')) ;

    return ( ulMap ) ;
}

ULONG EnumAllLPTs()
{
    return EnumLocalLPTs();
}

ULONG EnumAllComms()
{
    return EnumLocalComms();
}


#if defined(OS2)

/*---------------- OS2 specific -----------------*/

/*
 * return drive map as obtained via DosQCurDisk()
 */
ULONG EnumLocalDrives()
{
    USHORT usDummy ;
    APIERR err;
    ULONG  ulMap ;

    // get drive map
    err = DosQCurDisk(&usDummy, &ulMap);
    if (err != NERR_Success)
        return(0L) ;

    return ( ulMap ) ;
}

/*
 * under OS2 we have LPT1 to LPT9
 */
ULONG EnumLocalLPTs()
{
    return( 0x01FFL ) ;
}

/*
 * under OS2 we have COM1 to COM9
 */
ULONG EnumLocalComms()
{
    return( 0x01FFL ) ;
}

#elif defined(WINDOWS)

/*---------------- Win specific -----------------*/


/*
 * under Windows we have LPT1 to LPT3, LPT1.OS2 and LPT2.OS2
 */
ULONG EnumLocalLPTs()
{
    return( 0x0607L ) ;
}

/*
 * under windows we have COM1 to COM3
 */
ULONG EnumLocalComms()
{
    return( 0x0007L ) ;
}

#else           // must be DOS

/*---------------- DOS specific -----------------*/


/*
 * we have LPT1 to LPT3
 */
ULONG EnumLocalLPTs()
{
    return( 0x0007L ) ;
}

/*
 * we have COM1 to COM3
 */
ULONG EnumLocalComms()
{
    return( 0x0007L ) ;
}

#endif

#ifndef OS2

/*---------------- WIN/DOS specific -----------------*/

/*
 * cycle thru the drives, seeing which is valid, and return mask of valid ones
 */
DLL_BASED
ULONG EnumLocalDrives()
{
    ULONG  ulMask, ulMap = 0L ;
    TCHAR  szDrive[3] ;

    // get drive map
    ulMap = 3L ;                // always have A:, B:
    *szDrive = TCH('\0') ;
    ::strcpyf(szDrive, SZ("C:")) ;
    ulMask = 0x04L ;
    do
    {
        if (CheckLocalDrive(szDrive) == NERR_Success)
            ulMap |= ulMask ;
        ulMask <<= 1 ;
        ++*szDrive ;
    } while (*szDrive <= TCH('Z')) ;

    return ( ulMap ) ;
}

#endif

/**************************** Redirected Devices **************************/

DLL_BASED
ULONG EnumNetDrives()
{
    return(EnumNetDevices(USE_DISKDEV)) ;
}

DLL_BASED
ULONG EnumNetLPTs()
{
    return(EnumNetDevices(USE_SPOOLDEV)) ;
}

DLL_BASED
ULONG EnumNetComms()
{
    return(EnumNetDevices(USE_CHARDEV)) ;
}

/*
 * actual worker routine, enumerates all redirected devices
 * as spec by sType.
 */
DLL_BASED
ULONG EnumNetDevices(INT sType)
{
    ULONG ulMap ;
    BYTE *pbBuffer = NULL;
    struct use_info_0 * pUseInfo0 ;
    UINT usEntriesRead ;
    APIERR err;

    // call net use enum to get all redirections
    err = ::MNetUseEnum((TCHAR *)NULL,
                     0,
                     &pbBuffer,
                     &usEntriesRead) ;

    if (err != NERR_Success)
    {
        // if still error, none
        return(0L) ;
    }

    ulMap = 0L ;
    pUseInfo0 = (struct use_info_0 *) pbBuffer ;
    while (usEntriesRead--)
    {
        if (pUseInfo0->ui0_local[0])
        {
            if (sType == USE_SPOOLDEV &&
                !::strnicmpf(SZ("LPT"),pUseInfo0->ui0_local,3))
                    ulMap |= MapLPT((const TCHAR *)pUseInfo0->ui0_local) ;
            else if (sType == USE_CHARDEV &&
                !::strnicmpf(SZ("COM"),pUseInfo0->ui0_local,3))
                    ulMap |= MapComm((const TCHAR *)pUseInfo0->ui0_local) ;
            else if (sType == USE_DISKDEV &&
                pUseInfo0->ui0_local[1] == TCH(':'))
                    ulMap |= MapDrive((const TCHAR *)pUseInfo0->ui0_local) ;
        }
        pUseInfo0++ ;
    }

    ::MNetApiBufferFree( &pbBuffer );

    return(ulMap) ;
}

/**************************** Unavailable Devices **************************/

// BUGBUG - No OS2 or DOS support currently, this is only used by winnet.

DLL_BASED
ULONG EnumUnavailDrives()
{
    return(EnumUnavailDevices(USE_DISKDEV)) ;
}

DLL_BASED
ULONG EnumUnavailLPTs()
{
    return(EnumUnavailDevices(USE_SPOOLDEV)) ;
}

DLL_BASED
ULONG EnumUnavailComms()
{
    return(EnumUnavailDevices(USE_CHARDEV)) ;
}

/*
 * enumerate unavail device
 */
DLL_BASED
ULONG EnumUnavailDevices(INT sType)
{
#if defined(WINDOWS)

#if defined(WIN32)
    // BIG BUGBUG
    //WIN32BUGBUG
    //WIN32BUGBUG
    //WIN32BUGBUG
    return(0L);
#else

    /*
     * in the Win case, we are Winnet specific. This is the
     * only planned use of Profile.
     */
    ULONG ulMap ;
    APIERR err ;
    TCHAR * pszDevList ;
    BUFFER buffer((DEVLEN + 1) * 46 + 1) ; // BUGBUG UNICODE
    // 46 handles worst case of a:-z:, lpt1-1pt9, com1-com9

    err = PROFILE::Enum(&buffer);
    if (err != NERR_Success )
    {
        // if cannot enum, say there is none
        return(0L) ;
    }

    ulMap = 0L ;
    pszDevList = (TCHAR *) buffer.QueryPtr();

    /*
     * we know pszDevList is now a NULL NULL list of devices
     */
    while (pszDevList && *pszDevList)
    {
        USHORT usLen ;

        usLen = ::strlenf((LPSTR)pszDevList) ;
        {
            if (sType == USE_DISKDEV &&
                *(pszDevList+1) == TCH(':'))
                    ulMap |= MapDrive(pszDevList) ;
            else if (sType == USE_SPOOLDEV &&
                !::strncmpf(SZ("LPT"),(LPSTR)pszDevList,3))
                    ulMap |= MapLPT(pszDevList) ;
            else if (sType == USE_CHARDEV &&
                !::strncmpf(SZ("COM"),(LPSTR)pszDevList,3))
                    ulMap |= MapComm(pszDevList) ;
        }
        pszDevList += (usLen + 1) ;
    }

    return(ulMap) ;
# endif // WIN32
#endif // WINDOWS
}

/**************************** Worker Routines **************************/

/*
 * map LPTx to a bit in mask. we can assume valid name,
 * since it came from API. hence no checking. No DBCS issues either.
 */
ULONG MapLPT(const TCHAR * pszDev)
{
    if (!::strcmpf((TCHAR FAR *)pszDev, SZ("LPT1.OS2")))
        return( 0x0200L ) ;
    else if (!::strcmpf((TCHAR FAR *)pszDev, SZ("LPT2.OS2")))
        return( 0x0400L ) ;
    return( 1L << (pszDev[3]-TCH('1')) ) ;
}

/*
 * map COMx to a bit in mask. we can assume valid name,
 * since it came from API. hence no checking. No DBCS issues either.
 */
ULONG MapComm(const TCHAR * pszDev)
{
    return( 1L << (pszDev[3]-TCH('1')) ) ;
}

/*
 * map X: to a bit in mask. we can assume valid name,
 * since it came from API. hence no checking. No DBCS issues either.
 */
ULONG MapDrive(const TCHAR * pszDev)
{
    return( 1L << (pszDev[0]-TCH('A')) ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\mnet32\msystem.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    MSYSTEM.C

Abstract:

    32 bit version of mapping routines for Base API

Author:

    Dan Hinsley    (danhi)  06-Jun-1991

Environment:

    User Mode - Win32

Revision History:

    24-Apr-1991     danhi
        Created

    06-Jun-1991     Danhi
        Sweep to conform to NT coding style

    09-Oct-1991     JohnRo
        Fixed bug #3215 - bogus messages when setting time.

    26-Feb-1992     JonN
        Copied from NetCmd for temporary ANSI <-> UNICODE hack

    03-Sep-1993     JonN
        Removed unused functions (all but MAllocMem and MFreeMem)
--*/

//
// INCLUDES
//

#include <windows.h>

#include <string.h>
#include <lmcons.h>
#include <stdio.h>
#include <malloc.h>
#include <lmapibuf.h>
#include "declspec.h"
#include "port1632.h"


//
// Replacement for DosAllocSeg
//

WORD
MAllocMem(
    DWORD Size,
    LPBYTE * pBuffer
    )
{

    NetapipBufferAllocate(Size, (LPVOID *) pBuffer);

    return(0);

}

//
// Frees up memory allocated with MAllocMem
//

WORD
MFreeMem(
    LPBYTE Buffer
    )
{
   return(LOWORD(NetApiBufferFree(Buffer)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\netslow\netslow.c ===
/*++
Copyright (c) 1993 Microsoft Corporation

Module Name:

    netslow.c

Abstract:

    IsSlowTransport will test whether a net connection is through RAS or not.

Notes:

    CODEWORK
    Because of the global variable, IsSlowTransport is not reentrant.
    No single LMUICMN1 client (e.g. no single app) should call this from
    multiple threads.

Author:

    KeithMo

Revision History:

    Congpa You (CongpaY) 11- March-1993

--*/

#include "pchmn32.h"

/*****************************************************************************

    constants

*****************************************************************************/
#define MAXWAITTIME       1200            // milliseconds



/*****************************************************************************

    globals

*****************************************************************************/
APIERR errThread;



/*****************************************************************************

    prototypes

*****************************************************************************/

APIERR IsSlowTransport( const TCHAR * pszServer,
                                BOOL  * pfSlowTransport );

void SlowTransportWorkerThread( LPVOID pParam );

APIERR SetupSession( const TCHAR * pszServer );

APIERR SetupNullSession( const TCHAR * pszServer );

APIERR SetupNormalSession( const TCHAR * pszServer );

APIERR DestroySession( const TCHAR * pszServer );


/*****************************************************************************

    IsSlowTransport

    CAVEAT:  THIS CALL MAY LEAVE A SESSION TO THE SERVER IF A SLOW TRANSPORT
             IS DETECTED BECAUSE THE WORKER THREAD MAY STILL BE MAKING API
             CALLS AFTER THE TIMEOUT CAUSING THE NETUSEDEL(with NOFORCE) TO
             BE INEFFECTUAL.

*****************************************************************************/
APIERR IsSlowTransport( const TCHAR FAR * pszServer,
                        BOOL FAR        * pfSlowTransport )
{
    APIERR           err = NERR_Success;
    BOOL             fSessionSetup=FALSE;
    DWORD            resWait;
    DWORD            idThread;
    HANDLE           hThread;

    *pfSlowTransport = FALSE;

    // return immediately if pszServer is NULL
    if (pszServer == NULL || *pszServer == 0)
    {
        *pfSlowTransport = FALSE;
        return(NERR_Success);
    }

    //
    //  Initialize.
    //

    err              = NERR_Success;
    errThread        = NERR_Success;

    //
    // Set up the session.
    //
    err = SetupNormalSession (pszServer);

    if (err == NERR_Success)
    {
        fSessionSetup = TRUE;
    }
    else if (err == ERROR_SESSION_CREDENTIAL_CONFLICT)
    {
        err = NERR_Success;
    }
    else
    {
        err = SetupNullSession (pszServer);
        if (err != NERR_Success)
            return(err);
        fSessionSetup = TRUE;
    }

    do  // false loop
    {
        //
        //  Create the worker thread.
        //

        hThread = CreateThread( NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)SlowTransportWorkerThread,
                                (LPVOID)pszServer,
                                0,
                                &idThread );

        if( hThread == NULL )
        {
            err = (APIERR) GetLastError();
            break;
        }

        //
        //  Wait for either the thread to complete or a timeout.
        //

        resWait = WaitForSingleObject( hThread, MAXWAITTIME );

        CloseHandle( hThread );
        hThread = NULL;

        //
        //  Interpret the results.
        //

        if( resWait == -1 )
        {
            err = (APIERR)GetLastError();
            break;
        }

        switch (resWait)
        {

        case WAIT_TIMEOUT:
            *pfSlowTransport = TRUE;
            break;

        case WAIT_OBJECT_0:
            if (errThread == NERR_Success)
            {
                *pfSlowTransport = FALSE;
            }
            break;

        default:
            err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

    } while ( FALSE );

    //
    //  Destroy the session if we managed to create one.
    //

    if (fSessionSetup)
    {
        DestroySession( pszServer );
    }

    return ( (err != NERR_Success) ? err : errThread );

}   // IsSlowTransport


/*****************************************************************************

    SetupSession

*****************************************************************************/
APIERR SetupSession( const TCHAR * pszServer )
{
    APIERR           err;
    WKSTA_INFO_100 * pwki100       = NULL;

    //
    //  Connect to the target server.
    //

    err = SetupNullSession( pszServer );

    if( err == NERR_Success ) //  NULL session established.
    {
        BOOL fIsDownlevel = FALSE;

        //
        //  Determine target type.
        //

        err = NetWkstaGetInfo( (LPTSTR)pszServer,
                               100,
                               (LPBYTE *)&pwki100 );

        if( ( err == ERROR_ACCESS_DENIED ) ||
            ( ( err == NERR_Success ) &&
              ( pwki100->wki100_platform_id == SV_PLATFORM_ID_OS2 ) ) )
        {
            //
            //  The target is downlevel.
            //

            fIsDownlevel = TRUE;
        }

        if( ( err != NERR_Success ) || fIsDownlevel )
        {
            //
            //  Either we cannot talk to the server, or it's
            //  downelevel, so blow away the NULL session.
            //

            DestroySession( pszServer );
        }

        if( fIsDownlevel )
        {
            //
            //  It's a downlevel server.  There aren't many useful
            //  API we can remote to a downlevel server over a NULL
            //  session, (and we just blew away the NULL session
            //  anyway) so try a "normal" session.
            //

            err = SetupNormalSession( pszServer );
        }

        if( pwki100 != NULL )
        {
            NetApiBufferFree( (LPVOID)pwki100 );
        }
    }

    return(err);
}

/*****************************************************************************

    SlowTransportWorkerThread

*****************************************************************************/
void SlowTransportWorkerThread( LPVOID pParam )
{
    INT i;
    WKSTA_INFO_101 * pwksta_info_101 = NULL;

    for (i = 0; i < 3; i++)
    {
        errThread = (APIERR) NetWkstaGetInfo ((LPTSTR) pParam,
                                              100,
                                              (LPBYTE *) &pwksta_info_101);

        if( pwksta_info_101 != NULL )
        {
            NetApiBufferFree( (LPVOID)pwksta_info_101 );
        }

        if (errThread != NERR_Success)
        {
            return;
        }
    }
}   // SlowTransportWorkerThread


/*****************************************************************************

    SetupNullSession

*****************************************************************************/
APIERR SetupNullSession( const TCHAR * pszServer )
{
    APIERR           err;
    TCHAR            szShare[MAX_PATH];
    USE_INFO_2       ui2;

	// NTRAID#NTBUG9-579356-2002/03/08-artm  Prefast: possible buffer overrun
	// Parameter is unchecked, both for NULL and for its length.
	// strcatf will have a related problem in that it could overrun the
	// end of szShare if pszServer just barely fits in szShare.
    strcpyf( szShare, pszServer );
    strcatf( szShare, SZ("\\IPC$") );

    ui2.ui2_local      = NULL;
    ui2.ui2_remote     = (LPTSTR)szShare;
    ui2.ui2_password   = (LPTSTR)L"";
    ui2.ui2_asg_type   = USE_IPC;
    ui2.ui2_username   = (LPTSTR)L"";
    ui2.ui2_domainname = (LPTSTR)L"";

    err = NetUseAdd( NULL,
                     2,
                     (LPBYTE)&ui2,
                     NULL );

    return err;

}   // SetupNullSession



/*****************************************************************************

    SetupNormalSession

*****************************************************************************/
APIERR SetupNormalSession( const TCHAR * pszServer )
{
    APIERR           err;
    TCHAR            szShare[MAX_PATH];
    USE_INFO_1       ui1;

	// NTRAID#NTBUG9-579356-2002/03/08-artm  Prefast: possible buffer overrun
	// Parameter is unchecked, both for NULL and for its length.
	// strcatf will have a related problem in that it could overrun the
	// end of szShare if pszServer just barely fits in szShare.
    strcpyf( szShare, pszServer );
    strcatf( szShare, SZ("\\IPC$") );

    ui1.ui1_local      = NULL;
    ui1.ui1_remote     = (LPTSTR)szShare;
    ui1.ui1_password   = NULL;
    ui1.ui1_asg_type   = USE_IPC;

    err = NetUseAdd( NULL,
                     1,
                     (LPBYTE)&ui1,
                     NULL );

    return err;

}   // SetupNormalSession



/*****************************************************************************

    DestroySession

*****************************************************************************/
APIERR DestroySession( const TCHAR * pszServer )
{
    APIERR           err;
    TCHAR            szShare[MAX_PATH];

	// NTRAID#NTBUG9-579356-2002/03/08-artm  Prefast: possible buffer overrun
	// Parameter is unchecked, both for NULL and for its length.
	// strcatf will have a related problem in that it could overrun the
	// end of szShare if pszServer just barely fits in szShare.
    strcpyf( szShare, pszServer );
    strcatf( szShare, SZ("\\IPC$") );

    err = NetUseDel( NULL,
                     (LPTSTR)szShare,
                     USE_NOFORCE );

    return err;

}   // DestroySession
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\mnet32\pcanon.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    pcanon.c
    mapping layer for canonicalization API.

    FILE HISTORY:
        KeithMo     14-Oct-1991 Created.
        JonN        01-Jun-1992 Enabled LM2X_COMPATIBLE for I_MNetName* only
        JonN        20-Jul-1992 Really enabled LM2X_COMPATIBLE for I_MNetName* only
        Yi-HsinS    25-Aug-1992 Added NAMETYPE_COMMENT to I_MNetNameValidate
        KeithMo     08-Feb-1993 Added I_MNetComputerNameCompare API.

   The LM2X_COMPATIBLE flag causes names to be canonicalized according
   to LM2X-compatible rules.  The "LM2X compatibility flag" is stuck
   TRUE for Product One.  This flag is not implemented for paths.

*/

#define INCL_NET
#define INCL_DOSERRORS
#define INCL_ICANON
#define INCL_WINDOWS
#define INCL_NETLIB
#include "lmui.hxx"

extern "C"
{
    #include "mnetp.h"
    #include <winerror.h>

} // extern "C"

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include "uiassert.hxx"
#include "dbgstr.hxx"  // for cdebug


#define WHACK TCH('\\')

#define IS_LM2X_COMPATIBLE(nametype) ( (nametype==NAMETYPE_SERVICE || nametype==NAMETYPE_MESSAGE) ? 0 : LM2X_COMPATIBLE )



APIERR I_MNetNameCanonicalize(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszPath,
        TCHAR FAR        * pszOutput,
        UINT               cbOutput,
        UINT               NameType,
        ULONG              flFlags )
{
#if defined(DEBUG) && defined(TRACE)
    APIERR err =
#else  // TRACE
    return
#endif // TRACE

          I_NetNameCanonicalize( (TCHAR *)pszServer,
                          (TCHAR *)pszPath,
                                  pszOutput,
                                  cbOutput,
                                  NameType,
                                  flFlags | IS_LM2X_COMPATIBLE(NameType) );

#if defined(DEBUG) && defined(TRACE)
    if ( err != NERR_Success ) {
       TRACEEOL( SZ("I_NetNameCanonicalize( ")
              << pszServer
              << SZ(", ")
              << pszPath
              << SZ(", pszOutput, ")
              << cbOutput
              << SZ(", ")
              << NameType
              << SZ(", ")
              << (flFlags | IS_LM2X_COMPATIBLE(NameType))
              << SZ(" ) returned ")
              << err );
    }
    return err;
#endif // TRACE

}   // I_MNetNameCanonicalize


APIERR I_MNetNameCompare(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszPath1,
        const TCHAR FAR  * pszPath2,
        UINT               NameType,
        ULONG              flFlags )
{
#if defined(DEBUG) && defined(TRACE)
    APIERR err =
#else  // TRACE
    return
#endif // TRACE
           I_NetNameCompare( (TCHAR *)pszServer,
                             (TCHAR *)pszPath1,
                             (TCHAR *)pszPath2,
                             NameType,
                             flFlags | IS_LM2X_COMPATIBLE(NameType) );

#if defined(DEBUG) && defined(TRACE)
    if ( err != NERR_Success ) {
       TRACEEOL( "I_NetNameCompare( "
              << (const TCHAR *) pszServer
              << ", "
              << (const TCHAR *) pszPath1
              << ", "
              << (const TCHAR *) pszPath2
              << ", "
              << NameType
              << ", "
              << (flFlags | IS_LM2X_COMPATIBLE(NameType))
              << " ) returned "
              << err )
    }
    return err;
#endif // TRACE

}   // I_MNetNameCompare


APIERR I_MNetNameValidate(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszName,
        UINT               NameType,
        ULONG              flFlags )
{

    switch (NameType)
    {
        case NAMETYPE_COMMENT:
        {
            APIERR err = NERR_Success;
            if ( pszName != NULL )
            {
                UINT nMaxLen = IS_LM2X_COMPATIBLE(NameType) == LM2X_COMPATIBLE?
                               LM20_MAXCOMMENTSZ : MAXCOMMENTSZ;
                if ( ::strlenf( pszName )  >  nMaxLen )
                    err = ERROR_INVALID_PARAMETER;
            }
            return err;
        }

        default:
#if defined(DEBUG) && defined(TRACE)
        {
            APIERR err =
#else  // TRACE
            return
#endif // TRACE
                I_NetNameValidate( (TCHAR *)pszServer,
                                   (TCHAR *)pszName,
                                   NameType,
                                   flFlags | IS_LM2X_COMPATIBLE(NameType) );

#if defined(DEBUG) && defined(TRACE)
            if ( err != NERR_Success ) {
                 TRACEEOL( "I_NetNameValidate( "
                           << (const TCHAR *) pszServer
                           << ", "
                           << (const TCHAR *) pszName
                           << ", "
                           << NameType
                           << ", "
                           << (flFlags | IS_LM2X_COMPATIBLE(NameType))
                           << " ) returned "
                           << err )
            }
            return err;
        }
#endif // TRACE
    }

}   // I_MNetNameValidate


APIERR I_MNetPathCanonicalize(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszPath,
        TCHAR FAR        * pszOutput,
        UINT               cbOutput,
        const TCHAR FAR  * pszPrefix,
        ULONG FAR        * pflPathType,
        ULONG              flFlags )
{
    return I_NetPathCanonicalize( (TCHAR *)pszServer,
                                  (TCHAR *)pszPath,
                                  pszOutput,
                                  cbOutput,
                                  (TCHAR *)pszPrefix,
                                  pflPathType,
                                  flFlags );

}   // I_MNetPathCanonicalize


APIERR I_MNetPathCompare(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszPath1,
        const TCHAR FAR  * pszPath2,
        ULONG              flPathType,
        ULONG              flFlags )
{
    return I_NetPathCompare( (TCHAR *)pszServer,
                             (TCHAR *)pszPath1,
                             (TCHAR *)pszPath2,
                             flPathType,
                             flFlags );

}   // I_MNetPathCompare


APIERR I_MNetPathType(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszPath,
        ULONG FAR        * pflPathType,
        ULONG              flFlags )
{
    return I_NetPathType( (TCHAR *)pszServer,
                          (TCHAR *)pszPath,
                          pflPathType,
                          flFlags );

}   // I_MNetPathType


//
//  The I_MNetComputerNameCompare API is a little unusual.  It may
//  be used to compare computer <-> computer, computer <-> domain,
//  or domain <-> domain.  To achieve this, it will skip past the
//  leading backslashes (if present) before calling through to the
//  I_NetNameCompare API.  Since the backslashes will not be present,
//  the names will most closely resemble domain names, thus the
//  NAMETYPE_DOMAIN is used as the NameType parameter.
//
//  Also, unlike the other [I_]MNet* API, this one returns an INT
//  instead of the usual APIERR.  In theory this could be used as
//  a collating value.  Unfortunately, since the I_NetNameCompare
//  API is non-locale-sensitive, the collating value is useless.  For
//  now, the return value should be treated as follows:
//
//       0 - names match
//      !0 - names don't match
//

INT I_MNetComputerNameCompare(
        const TCHAR FAR  * pszComputer1,
        const TCHAR FAR  * pszComputer2 )
{
    //
    //  Handle NULL/empty computer names first to make the
    //  remaining code a little simpler.
    //

    if( ( pszComputer1 == NULL ) || ( *pszComputer1 == TCH('\0') ) )
    {
        return ( pszComputer2 == NULL ) || ( *pszComputer2 == TCH('\0') ) ?  0
                                                                          : -1;
    }

    if( ( pszComputer2 == NULL ) || ( *pszComputer2 == TCH('\0') ) )
    {
        return ( pszComputer1 == NULL ) || ( *pszComputer1 == TCH('\0') ) ?  0
                                                                          :  1;
    }

    //
    //  At this point both computer names should be non-NULL
    //

    if( ( pszComputer1 == NULL ) || ( pszComputer2 == NULL ) )
    {
        UIASSERT( FALSE );
        return -1;
    }

    //
    //  Skip the leading backslashes if present.  Note that the first
    //  leading backslash implies the existence of a second backslash.
    //  We assert out if this second backslash is not present.
    //

    if( *pszComputer1 == WHACK )
    {
        pszComputer1++;

        if( *pszComputer1 == WHACK )
        {
            pszComputer1++;
        }
    }

    if( *pszComputer2 == WHACK )
    {
        pszComputer2++;

        if( *pszComputer2 == WHACK )
        {
            pszComputer2++;
        }
    }

    //
    //  The computer names should *not* be starting with backslashes.
    //  If they are, somebody gave us a malformed computer name.
    //

    UIASSERT( ( *pszComputer1 != WHACK ) && ( *pszComputer2 != WHACK ) );

    //
    //  Compare the two names as domains (since they're backslash-less).
    //

    APIERR err = I_NetNameCompare( NULL,
                                   (TCHAR *)pszComputer1,
                                   (TCHAR *)pszComputer2,
                                   NAMETYPE_COMPUTER,
                                   LM2X_COMPATIBLE );

    //
    //  Unfortunately, the I_NetNameCompare overloads the meaning
    //  of the return value.  It may be a Win32 error code (ERROR_*),
    //  a network error code (NERR_*) or the result of a string compare
    //  function (<0, 0, >0).  Thus, the result may be non-zero even
    //  the strings DO indeed match.
    //

    return (INT)err;

}   // I_MNetComputerNameCompare
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\netslow\paccess.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    paccess.c
    mapping layer for NetAccess API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.

*/

#include "pchmn32.h"

// Do this until we get the real Net access stubs
#define NOT_IMPLEMENTED 0

APIERR MNetAccessAdd(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer )
{
#if NOT_IMPLEMENTED
    return ERROR_NOT_SUPPORTED ;
#else
    UNREFERENCED( cbBuffer );

    return (APIERR)NetAccessAdd( (TCHAR *)pszServer,
				 Level,
				 pbBuffer,
				 NULL );
#endif
}   // MNetAccessAdd


APIERR MNetAccessCheck(
	TCHAR FAR	 * pszReserved,
	TCHAR FAR	 * pszUserName,
	TCHAR FAR	 * pszResource,
	UINT		   Operation,
	UINT FAR	 * pResult )
{
    return ERROR_NOT_SUPPORTED ;
#if 0
    This api is not supported on NT.  It is never used so it will remain
    as being unsupported.

    return (APIERR)NetAccessCheck( pszReserved,
				   pszUserName,
				   pszResource,
				   Operation,
				   (LPDWORD)pResult );
#endif
}   // MNetAccessCheck


APIERR MNetAccessDel(
	const TCHAR FAR	 * pszServer,
	TCHAR FAR	 * pszResource )
{
#if NOT_IMPLEMENTED
    return ERROR_NOT_SUPPORTED ;
#else
    return (APIERR)NetAccessDel( (TCHAR *)pszServer,
				 pszResource );
#endif
}   // MNetAccessDel


APIERR MNetAccessEnum(
	const TCHAR FAR	 * pszServer,
	TCHAR FAR	 * pszBasePath,
	UINT		   fRecursive,
	UINT		   Level,
	BYTE FAR	** ppbBuffer,
	UINT FAR	 * pcEntriesRead )
{
#if NOT_IMPLEMENTED
    return ERROR_NOT_SUPPORTED ;
#else
    DWORD	cTotalAvail;

    return (APIERR)NetAccessEnum( (TCHAR *)pszServer,
    				  pszBasePath,
				  fRecursive,
				  Level,
				  ppbBuffer,
				  MAXPREFERREDLENGTH,
				  (LPDWORD)pcEntriesRead,
				  &cTotalAvail,
				  NULL );
#endif
}   // MNetAccessEnum


APIERR MNetAccessGetInfo(
	const TCHAR FAR	 * pszServer,
	TCHAR FAR	 * pszResource,
	UINT		   Level,
	BYTE FAR	** ppbBuffer )
{
#if NOT_IMPLEMENTED
    return ERROR_NOT_SUPPORTED ;
#else
    return (APIERR)NetAccessGetInfo( (TCHAR *)pszServer,
				     pszResource,
				     Level,
				     ppbBuffer );
#endif
}   // MNetAccessGetInfo


APIERR MNetAccessSetInfo(
	const TCHAR FAR	 * pszServer,
	TCHAR FAR	 * pszResource,
	UINT		   Level,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer,
	UINT		   ParmNum )
{
#if NOT_IMPLEMENTED
    return ERROR_NOT_SUPPORTED ;
#else
    UNREFERENCED( cbBuffer );

    if( ParmNum != PARMNUM_ALL )
    {
    	return ERROR_NOT_SUPPORTED;
    }

    return (APIERR)NetAccessSetInfo( (TCHAR *)pszServer,
				     pszResource,
				     Level,
				     pbBuffer,
				     NULL );
#endif
}   // MNetAccessSetInfo


APIERR MNetAccessGetUserPerms(
	TCHAR FAR	 * pszServer,
	TCHAR FAR	 * pszUgName,
	TCHAR FAR	 * pszResource,
	UINT FAR	 * pPerms )
{
#if NOT_IMPLEMENTED
    return ERROR_NOT_SUPPORTED ;
#else
    return (APIERR)NetAccessGetUserPerms( (TCHAR *)pszServer,
					  pszUgName,
					  pszResource,
					  (LPDWORD)pPerms );
#endif
}   // MNetAccessGetUserPerms
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\netslow\palert.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    palert.c
    mapping layer for NetAlert API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.

*/

#include "pchmn32.h"

#if 0

APIERR MNetAlertRaise(
	const TCHAR FAR	 * pszEvent,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer,
	ULONG		   ulTimeout )
{
    UNREFERENCED( pszEvent );
    UNREFERENCED( pbBuffer );
    UNREFERENCED( cbBuffer );
    UNREFERENCED( ulTimeout );

    return ERROR_NOT_SUPPORTED;		// NOT NEEDED FOR LMOBJ

}   // MNetAlertRaise


APIERR MNetAlertStart(
	const TCHAR FAR	 * pszEvent,
	const TCHAR FAR	 * pszRecipient,
	UINT		   cbMaxData )
{
    UNREFERENCED( pszEvent );
    UNREFERENCED( pszRecipient );
    UNREFERENCED( cbMaxData );

    return ERROR_NOT_SUPPORTED;		// NOT NEEDED FOR LMOBJ

}   // MNetAlertStart


APIERR MNetAlertStop(
    const TCHAR FAR   * pszEvent,
    const TCHAR FAR   * pszRecipient )
{
    UNREFERENCED( pszEvent );
    UNREFERENCED( pszRecipient );

    return ERROR_NOT_SUPPORTED;		// NOT NEEDED FOR LMOBJ

}   // MNetAlertStop

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\netslow\pchmn32.h ===
#define INCL_DOSERRORS
#define INCL_NET
#define INCL_NETLIB
#define INCL_NETREPL
#define INCL_WINDOWS

#include <nt.h>
#include <ntrtl.h>
#include <ntsam.h>
#include <nturtl.h>

#include "lmui.hxx"
#include <lm.h>
#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmcons.h>
#include <lmerr.h>
#include <malloc.h>
#include "mnetp.h"
#include "netdebug.h"
#include "netlib.h"	
#include "rap.h"
#include "remdef.h"
#include "remtypes.h"
#include <rpc.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include "tstr.h"	
#include <wchar.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\netslow\pbios.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    pbios.c
    mapping layer for NetBios API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.

*/

#include "pchmn32.h"

#if 0

APIERR MNetBiosOpen(
	TCHAR FAR	 * pszDevName,
	TCHAR FAR	 * pszReserved,
	UINT		   OpenOpt,
	UINT FAR	 * phDevName )
{

    UNREFERENCED( pszDevName );
    UNREFERENCED( pszReserved );
    UNREFERENCED( OpenOpt );
    UNREFERENCED( phDevName );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetBiosOpen


APIERR MNetBiosClose(
	UINT		   hDevName,
	UINT		   Reserved )
{
    UNREFERENCED( hDevName );
    UNREFERENCED( Reserved );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetBiosClose


APIERR MNetBiosEnum(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	** ppbBuffer,
	UINT FAR	 * pcEntriesRead )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( Level );
    UNREFERENCED( ppbBuffer );
    UNREFERENCED( pcEntriesRead );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetBiosEnum


APIERR MNetBiosGetInfo(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszNetBiosName,
	UINT		   Level,
	BYTE FAR	** ppbBuffer )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( pszNetBiosName );
    UNREFERENCED( Level );
    UNREFERENCED( ppbBuffer );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetBiosGetInfo


APIERR MNetBiosSubmit(
	UINT		   hDevName,
	UINT		   NcbOpt,
	struct ncb FAR	 * pNCB )
{
    UNREFERENCED( hDevName );
    UNREFERENCED( NcbOpt );
    UNREFERENCED( pNCB );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetBiosSubmit

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\netslow\pconnect.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    pconnect.c
    mapping layer for NetConnect API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.

*/

#include "pchmn32.h"

APIERR MNetConnectionEnum(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszQualifier,
	UINT		   Level,
	BYTE FAR	** ppbBuffer,
	UINT FAR	 * pcEntriesRead )
{
    DWORD cTotalAvail;

    return (APIERR)NetConnectionEnum( (TCHAR *)pszServer,
    				      (TCHAR *)pszQualifier,
				      Level,
				      ppbBuffer,
				      MAXPREFERREDLENGTH,
				      (LPDWORD)pcEntriesRead,
				      &cTotalAvail,
				      NULL );

}   // MNetConnectionEnum
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\netslow\pconfig.c ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    pconfig.c
    mapping layer for NetConfig API

    FILE HISTORY:
        danhi                           Created
        danhi           01-Apr-1991     Change to LM coding style
        KeithMo         13-Oct-1991     Massively hacked for LMOBJ.
        KeithMo         04-Jun-1992     Sync with revised NetConfigXxx API.

*/

#include "pchmn32.h"

APIERR MNetConfigGet(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszReserved,
        const TCHAR FAR  * pszComponent,
        const TCHAR FAR  * pszParameter,
        BYTE FAR        ** ppbBuffer )
{
    UNREFERENCED( pszReserved );

    return (APIERR)NetConfigGet( (LPTSTR)pszServer,
                                 (LPTSTR)pszComponent,
                                 (LPTSTR)pszParameter,
                                 (LPBYTE *)ppbBuffer );

}   // MNetConfigGet


APIERR MNetConfigGetAll(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszReserved,
        const TCHAR FAR  * pszComponent,
        BYTE FAR        ** ppbBuffer)
{
    UNREFERENCED( pszReserved );

    return (APIERR)NetConfigGetAll( (LPTSTR)pszServer,
                                    (LPTSTR)pszComponent,
                                    (LPBYTE *)ppbBuffer );

}   // MNetConfigGetAll


APIERR MNetConfigSet(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszComponent,
        const TCHAR FAR  * pszKey,
        const TCHAR FAR  * pszData )
{
    CONFIG_INFO_0 cfgi0;

    cfgi0.cfgi0_key  = (LPTSTR)pszKey;
    cfgi0.cfgi0_data = (LPTSTR)pszData;

    return (APIERR)NetConfigSet( (LPTSTR)pszServer,
                                 NULL,
                                 (LPTSTR)pszComponent,
                                 0,
                                 0,
                                 (LPBYTE)&cfgi0,
                                 0 );

}   // MNetConfigSet
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\netslow\paudit.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    paudit.c
    mapping layer for NetAudit API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.
	KeithMo		30-Oct-1991	Added auditing support.
*/

#include "pchmn32.h"

APIERR MNetAuditClear(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszBackupFile,
	TCHAR FAR	 * pszService )
{
    return (APIERR)NetAuditClear( (TCHAR *)pszServer,
    				  (TCHAR *)pszBackupFile,
				  pszService );

}   // MNetAuditClear


APIERR MNetAuditRead(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszService,
	HLOG FAR	 * phAuditLog,
	ULONG		   ulOffset,
	UINT FAR	 * pReserved2,
	ULONG		   ulReserved3,
	ULONG		   flOffset,
	BYTE FAR	** ppbBuffer,
	ULONG		   ulMaxPreferred,
	UINT FAR	 * pcbReturned,
	UINT FAR	 * pcbTotalAvail )
{
    return (APIERR)NetAuditRead( (TCHAR *)pszServer,
    				 (TCHAR *)pszService,
				 phAuditLog,
				 (DWORD)ulOffset,
				 (LPDWORD)pReserved2,
				 (DWORD)ulReserved3,
				 (DWORD)flOffset,
				 ppbBuffer,
				 (DWORD)ulMaxPreferred,
				 (LPDWORD)pcbReturned,
				 (LPDWORD)pcbTotalAvail );

}   // MNetAuditRead


APIERR MNetAuditWrite(
	UINT		   Type,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer,
	TCHAR FAR	 * pszService,
	TCHAR FAR	 * pszReserved )
{
    return (APIERR)NetAuditWrite( (DWORD)Type,
				  pbBuffer,
				  (DWORD)cbBuffer,
				  pszService,
				  (LPBYTE)pszReserved );

}   // MNetAuditWrite
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\netslow\pchar.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    pchar.c
    mapping layer for NetChar API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.

*/

#include "pchmn32.h"

//
//  CODEWORK!
//
//  Remove the following #define when we finally
//  get NetCharDev*() API support in NT.
//

#define	CHARDEV_NOT_SUPPORTED


APIERR MNetCharDevControl(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszDevName,
	UINT		   OpCode )
{
#ifdef CHARDEV_NOT_SUPPORTED
    return ERROR_NOT_SUPPORTED;
#else	// !CHARDEV_NOT_SUPPORTED
    return (APIERR)NetCharDevControl( (TCHAR *)pszServer,
				      (TCHAR *)pszDevName,
				      OpCode );
#endif	// CHARDEV_NOT_SUPPORTED

}   // MNetCharDevControl


#if 0

APIERR MNetCharDevEnum(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	** ppbBuffer,
	UINT FAR	 * pcEntriesRead )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( Level );
    UNREFERENCED( ppbBuffer );
    UNREFERENCED( pcEntriesRead );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetCharDevEnum

#endif


APIERR MNetCharDevGetInfo(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszDevName,
	UINT		   Level,
	BYTE FAR	** ppbBuffer )
{
#ifdef CHARDEV_NOT_SUPPORTED
    return ERROR_NOT_SUPPORTED;
#else	// !CHARDEV_NOT_SUPPORTED
    return (APIERR)NetCharDevGetInfo( (TCHAR *)pszServer,
    				      (TCHAR *)pszDevName,
				      Level,
				      ppbBuffer );
#endif	// CHARDEV_NOT_SUPPORTED

}   // MNetCharDevGetInfo


APIERR MNetCharDevQEnum(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszUserName,
	UINT		   Level,
	BYTE FAR	** ppbBuffer,
	UINT FAR	 * pcEntriesRead )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( pszUserName );
    UNREFERENCED( Level );
    UNREFERENCED( ppbBuffer );

    *pcEntriesRead = 0;

    return NERR_Success;		// CODEWORK!  UNAVAILABLE IN PRODUCT 1

}   // MNetCharDevQEnum


APIERR MNetCharDevQGetInfo(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszQueueName,
	const TCHAR FAR	 * pszUserName,
	UINT		   Level,
	BYTE FAR	** ppbBuffer )
{
#ifdef CHARDEV_NOT_SUPPORTED
    return ERROR_NOT_SUPPORTED;
#else	// !CHARDEV_NOT_SUPPORTED
    return (APIERR)NetCharDevQGetInfo( (TCHAR *)pszServer,
    				       (TCHAR *)pszQueueName,
				       (TCHAR *)pszUserName,
				       Level,
				       ppbBuffer );
#endif	// CHARDEV_NOT_SUPPORTED

}   // MNetCharDevQGetInfo


APIERR MNetCharDevQSetInfo(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszQueueName,
	UINT		   Level,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer,
	UINT		   ParmNum )
{
#ifdef CHARDEV_NOT_SUPPORTED
    return ERROR_NOT_SUPPORTED;
#else	// !CHARDEV_NOT_SUPPORTED
    UNREFERENCED( cbBuffer );

    if( ParmNum != PARMNUM_ALL )
    {
    	return ERROR_NOT_SUPPORTED;
    }

    return (APIERR)NetCharDevQSetInfo( (TCHAR *)pszServer,
				       (TCHAR *)pszQueueName,
				       Level,
				       pbBuffer,
				       NULL );
#endif	// CHARDEV_NOT_SUPPORTED

}   // MNetCharDevQSetInfo


APIERR MNetCharDevQPurge(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszQueueName )
{
#ifdef CHARDEV_NOT_SUPPORTED
    return ERROR_NOT_SUPPORTED;
#else	// !CHARDEV_NOT_SUPPORTED
    return (APIERR)NetCharDevQPurge( (TCHAR *)pszServer,
				     (TCHAR *)pszQueueName );
#endif	// CHARDEV_NOT_SUPPORTED

}   // MNetCharDevQPurge


APIERR MNetCharDevQPurgeSelf(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszQueueName,
	const TCHAR FAR	 * pszComputerName )
{
#ifdef CHARDEV_NOT_SUPPORTED
    return ERROR_NOT_SUPPORTED;
#else	// !CHARDEV_NOT_SUPPORTED
    return (APIERR)NetCharDevQPurgeSelf( (TCHAR *)pszServer,
					 (TCHAR *)pszQueueName,
					 (TCHAR *)pszComputerName );
#endif	// CHARDEV_NOT_SUPPORTED

}   // MNetCharDevQPurgeSelf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\netslow\perror.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    perror.c
    mapping layer for NetError API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.
	KeithMo		30-Oct-1991	Added error log support.
*/

#include "pchmn32.h"

APIERR MNetErrorLogClear(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszBackupFile,
	TCHAR FAR	 * pszReserved )
{
    return (APIERR)NetErrorLogClear( (TCHAR *)pszServer,
    				     (TCHAR *)pszBackupFile,
				     (LPBYTE)pszReserved );

}   // MNetErrorLogClear


APIERR MNetErrorLogRead(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszReserved1,
	HLOG       FAR	 * phErrorLog,
	ULONG	 	   ulOffset,
	UINT FAR	 * pReserved2,
	ULONG		   ulReserved3,
	ULONG		   flOffset,
	BYTE FAR	** ppbBuffer,
	ULONG		   ulMaxPreferred,
	UINT FAR	 * pcbReturned,
	UINT FAR	 * pcbTotalAvail )
{
    return (APIERR)NetErrorLogRead( (TCHAR *)pszServer,
    				    (TCHAR *)pszReserved1,
				    phErrorLog,
				    (DWORD)ulOffset,
				    (LPDWORD)pReserved2,
				    (DWORD)ulReserved3,
				    (DWORD)flOffset,
				    ppbBuffer,
				    (DWORD)ulMaxPreferred,
				    (LPDWORD)pcbReturned,
				    (LPDWORD)pcbTotalAvail );

}   // MNetErrorLogRead


APIERR MNetErrorLogWrite(
	TCHAR FAR	 * pszReserved1,
	UINT		   Code,
	const TCHAR FAR	 * pszComponent,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer,
	const TCHAR FAR	 * pszStrBuf,
	UINT		   cStrBuf,
	TCHAR FAR	 * pszReserved2 )
{
    return (APIERR)NetErrorLogWrite( (LPBYTE)pszReserved1,
    				     (DWORD)Code,
				     (TCHAR *)pszComponent,
				     pbBuffer,
				     (DWORD)cbBuffer,
				     (LPBYTE)pszStrBuf,
				     (DWORD)cStrBuf,
				     (LPBYTE)pszReserved2 );

}   // MNetErrorLogWrite
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\netslow\pfile.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    pfile.c
    mapping layer for NetFile API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.

*/

#include "pchmn32.h"

APIERR MNetFileClose(
	const TCHAR FAR	 * pszServer,
	ULONG		   ulFileId )
{
    return (APIERR)NetFileClose( (TCHAR *)pszServer,
				 ulFileId );

}   // MNetFileClose


APIERR MNetFileEnum(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszBasePath,
	const TCHAR FAR	 * pszUserName,
	UINT		   Level,
	BYTE FAR	** ppbBuffer,
	ULONG		   ulMaxPreferred,
	UINT FAR	 * pcEntriesRead,
	UINT FAR	 * pcTotalAvail,
	VOID FAR	 * pResumeKey )
{
    return (APIERR)NetFileEnum( (TCHAR *)pszServer,
    				(TCHAR *)pszBasePath,
				(TCHAR *)pszUserName,
				Level,
				ppbBuffer,
				ulMaxPreferred,
				(LPDWORD)pcEntriesRead,
				(LPDWORD)pcTotalAvail,
				pResumeKey );

}   // MNetFileEnum


APIERR MNetFileGetInfo(
	const TCHAR FAR	 * pszServer,
	ULONG		   ulFileId,
	UINT		   Level,
	BYTE FAR	** ppbBuffer )
{
    return (APIERR)NetFileGetInfo( (TCHAR *)pszServer,
    				   ulFileId,
				   Level,
				   ppbBuffer );

}   // MNetFileGetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\netslow\pfreebuf.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    pfreebuf.c
    mapping layer for Memory allocation API (unique to mapping layer)

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.

*/

#include "pchmn32.h"


//////////////////////////////////////////////////////////////////////////////
//
//				Public Functions
//
//////////////////////////////////////////////////////////////////////////////


//
//  Allocate an API buffer.
//

BYTE FAR * MNetApiBufferAlloc(
	UINT		   cbBuffer )
{
    BYTE FAR * pbBuffer;

    if( NetapipBufferAllocate( cbBuffer, (LPVOID *)&pbBuffer ) != NERR_Success )
    {
    	return NULL;
    }

    return pbBuffer;

}   // MNetpAlloc


//
//  Free the API buffer.
//

VOID MNetApiBufferFree(
	BYTE FAR	** ppbBuffer )
{
    if( ( ppbBuffer != NULL ) && ( *ppbBuffer != NULL ) )
    {
	NetApiBufferFree( (VOID *)*ppbBuffer );
	*ppbBuffer = NULL;
    }

}   // MNetApiBufferFree


//**************************************************************************//
//									    //
//		    WARNING!!       DANGER!!!       WARNING!!		    //
//									    //
//  The following two routines are highly dependent on the implementation   //
//  of the NT Net API buffer routines (see \nt\private\net\api\apibuff.c).  //
//  These routines are written as such just as a temporary hack, until	    //
//  DanHi gives us official support for these functions we so desparately   //
//  need.								    //
//									    //
//	-- KeithMo, 28-Oct-1991						    //
//									    //
//		    WARNING!!       DANGER!!!       WARNING!!		    //
//									    //
//**************************************************************************//

//
//  Reallocate an API buffer.
//

APIERR MNetApiBufferReAlloc(
	BYTE FAR	** ppbBuffer,
	UINT		   cbBuffer )
{
    BYTE FAR * pbBuffer;

    pbBuffer = (BYTE FAR *)LocalReAlloc( (HANDLE)*ppbBuffer, cbBuffer, LMEM_MOVEABLE );

    if( pbBuffer == NULL )
    {
    	return ERROR_NOT_ENOUGH_MEMORY;
    }

    *ppbBuffer = pbBuffer;

    return NERR_Success;

}   // MNetApiBufferReAlloc


//
//  Retrieve the size of an API buffer.
//

APIERR MNetApiBufferSize(
	BYTE FAR	 * pbBuffer,
	UINT FAR	 * pcbBuffer )
{
    UINT cb;

    cb = (UINT)LocalSize( (HANDLE)pbBuffer );

    if( cb == 0 )
    {
    	return ERROR_INVALID_PARAMETER;
    }

    *pcbBuffer = cb;

    return NERR_Success;

}   // MNetApiBufferSize
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\netslow\pget.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    pget.c
    mapping layer for NetGetDCName

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.
	JonN		21-Oct-1991	Zapped until NetGetDCName works
	KeithMo		22-Oct-1991	Fixed the zap.
        DavidHov        15 Apr 92       Created 1st-cut UNICODE version using
                                        remnants of MBCS.C
	ChuckC		06-Aug-1992	removed Unicode stuff that is no
					longer needed.

*/

#include "pchmn32.h"


APIERR MNetGetDCName(
 	 const TCHAR FAR	 * pszServer,
    const TCHAR FAR	 * pszDomain,
	 BYTE FAR	** ppbBuffer )
{
    APIERR err = 0 ;

    err = (APIERR) NetGetDCName( (TCHAR *)pszServer,
    		                        (TCHAR *)pszDomain,
				                     ppbBuffer );
    return err ;

}   // MNetGetDCName
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\netslow\pgroup.c ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    pgroup.c
    mapping layer for NetGroup API

    FILE HISTORY:
        danhi                           Created
        danhi           01-Apr-1991     Change to LM coding style
        KeithMo         13-Oct-1991     Massively hacked for LMOBJ.
   JonN     27-May-1992    Removed ANSI<->UNICODE hack

*/

#include "pchmn32.h"

/* #define NOT_IMPLEMENTED 1   Removed JonN 5/27/92 */

APIERR MNetGroupAdd(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer )
{

#if NOT_IMPLEMENTED
    return ERROR_NOT_SUPPORTED ;
#else
    UNREFERENCED( cbBuffer );

    return (APIERR)NetGroupAdd( (TCHAR *)pszServer,
                                Level,
                                pbBuffer,
                                NULL );
#endif
}   // MNetGroupAdd


APIERR MNetGroupDel(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszGroupName )
{
#if NOT_IMPLEMENTED
    return ERROR_NOT_SUPPORTED ;
#else
    return (APIERR)NetGroupDel( (TCHAR *)pszServer,
                                pszGroupName );
#endif
}   // MNetGroupDel


APIERR MNetGroupEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead )
{
#if NOT_IMPLEMENTED
    return ERROR_NOT_SUPPORTED ;
#else
    DWORD cTotalAvail;

    return (APIERR)NetGroupEnum( (TCHAR *)pszServer,
                                 Level,
                                 ppbBuffer,
                                 MAXPREFERREDLENGTH,
                                 (LPDWORD)pcEntriesRead,
                                 &cTotalAvail,
                                 NULL );
#endif
}   // MNetGroupEnum


APIERR MNetGroupAddUser(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszGroupName,
        TCHAR FAR        * pszUserName )
{
#if NOT_IMPLEMENTED
    return ERROR_NOT_SUPPORTED ;
#else
    return (APIERR)NetGroupAddUser( (TCHAR *)pszServer,
                                    pszGroupName,
                                    pszUserName );
#endif
}   // MNetGroupAddUser


APIERR MNetGroupDelUser(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszGroupName,
        TCHAR FAR        * pszUserName )
{
#if NOT_IMPLEMENTED
    return ERROR_NOT_SUPPORTED ;
#else
    return (APIERR)NetGroupDelUser( (TCHAR *)pszServer,
                                    pszGroupName,
                                    pszUserName );
#endif
}   // MNetGroupDelUser


APIERR MNetGroupGetUsers(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszGroupName,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead )
{
#if NOT_IMPLEMENTED
    return ERROR_NOT_SUPPORTED ;
#else
    DWORD cTotalAvail;

    return (APIERR)NetGroupGetUsers( (TCHAR *)pszServer,
                                     (TCHAR *)pszGroupName,
                                     Level,
                                     ppbBuffer,
                                     MAXPREFERREDLENGTH,
                                     (LPDWORD)pcEntriesRead,
                                     &cTotalAvail,
                                     NULL );
#endif
}   // MNetGroupGetUsers


APIERR MNetGroupSetUsers(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszGroupName,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        UINT               cEntries )
{
#if NOT_IMPLEMENTED
    return ERROR_NOT_SUPPORTED ;
#else
    UNREFERENCED( cbBuffer );

    return (APIERR)NetGroupSetUsers( (TCHAR *)pszServer,
                                     (TCHAR *)pszGroupName,
                                     Level,
                                     pbBuffer,
                                     cEntries );
#endif
}   // MNetGroupSetUsers


APIERR MNetGroupGetInfo(
        const TCHAR FAR  * pszServer,
        TCHAR       FAR  * pszGroupName,
        UINT               Level,
        BYTE FAR        ** ppbBuffer )
{
#if NOT_IMPLEMENTED
    return ERROR_NOT_SUPPORTED ;
#else
    return (APIERR)NetGroupGetInfo( (TCHAR *)pszServer,
                                    pszGroupName,
                                    Level,
                                    ppbBuffer );
#endif
}   // MNetGroupGetInfo


APIERR MNetGroupSetInfo(
        const TCHAR FAR  * pszServer,
        TCHAR FAR        * pszGroupName,
        UINT               Level,
        BYTE FAR         * pbBuffer,
        UINT               cbBuffer,
        UINT               ParmNum )
{
#if NOT_IMPLEMENTED
    return ERROR_NOT_SUPPORTED ;
#else
    UNREFERENCED( cbBuffer );

    if( ParmNum != PARMNUM_ALL )
    {
        return ERROR_NOT_SUPPORTED;
    }

    return (APIERR)NetGroupSetInfo( (TCHAR *)pszServer,
                                    pszGroupName,
                                    Level,
                                    pbBuffer,
                                    NULL );
#endif
}   // MNetGroupSetInfo


APIERR MNetLocalGroupAddMember(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszGroupName,
        PSID               psidMember )
{
    return (APIERR)NetLocalGroupAddMember( (TCHAR *)pszServer,
                                           (TCHAR *)pszGroupName,
                                           psidMember );

}   // MNetLocalGroupAddMember
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\netslow\plogon.c ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    plogon.c
    mapping layer for NetLogon API

    FILE HISTORY:
        danhi                           Created
        danhi           01-Apr-1991     Change to LM coding style
        KeithMo         13-Oct-1991     Massively hacked for LMOBJ.
        KeithMo         30-Apr-1992     Added I_MNetLogonControl.
        ChuckC          06-Aug-1992     Removed #ifdef Unicode stuff

*/

#include "pchmn32.h"

APIERR MNetLogonEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( Level );
    UNREFERENCED( ppbBuffer );
    UNREFERENCED( pcEntriesRead );

    // this is no longer supported in NETAPI32
    return ERROR_NOT_SUPPORTED;

}   // MNetLogonEnum


APIERR I_MNetLogonControl(
        const TCHAR FAR  * pszServer,
        ULONG              FunctionCode,
        ULONG              Level,
        BYTE FAR        ** ppbBuffer )
{
    return (APIERR)I_NetLogonControl( (LPWSTR)pszServer,
                                      (DWORD)FunctionCode,
                                      (DWORD)Level,
                                      (LPBYTE *)ppbBuffer );

}   // I_MNetLogonControl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\netslow\phandle.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    phandle.c
    mapping layer for NetHandle API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.

*/

#include "pchmn32.h"
#if 0

APIERR MNetHandleGetInfo(
	UINT		   hHandle,
	UINT	 	   Level,
	BYTE FAR	** ppbBuffer )
{
    UNREFERENCED( hHandle );
    UNREFERENCED( Level );
    UNREFERENCED( ppbBuffer );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetHandleGetInfo


APIERR MNetHandleSetInfo(
	UINT		   hHandle,
	UINT	 	   Level,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer,
	UINT		   ParmNum )
{
    UNREFERENCED( hHandle );
    UNREFERENCED( Level );
    UNREFERENCED( pbBuffer );
    UNREFERENCED( cbBuffer );
    UNREFERENCED( ParmNum );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetHandleSetInfo
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\netslow\pmessage.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    pmessage.c
    mapping layer for NetMessage API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.

*/

#include "pchmn32.h"

APIERR MNetMessageBufferSend(
	const TCHAR FAR	 * pszServer,
	TCHAR FAR	 * pszRecipient,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer )
{
    return (APIERR)NetMessageBufferSend( (TCHAR *)pszServer,
					 pszRecipient,
					 NULL,
					 pbBuffer,
					 cbBuffer );

}   // MNetMessageBufferSend


#if 0

APIERR MNetMessageFileSend(
	const TCHAR FAR	 * pszServer,
	TCHAR FAR	 * pszRecipient,
	TCHAR FAR	 * pszFileSpec )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( pszRecipient );
    UNREFERENCED( pszFileSpec );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetMessageFileSend


APIERR MNetMessageLogFileGet(
	const TCHAR FAR	 * pszServer,
	BYTE FAR	** ppbBuffer,
	UINT FAR	 * pfEnabled )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( ppbBuffer );
    UNREFERENCED( pfEnabled );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetMessageLogFileGet


APIERR MNetMessageLogFileSet(
	const TCHAR FAR	 * pszServer,
	TCHAR FAR	 * pszFileSpec,
	UINT		   fEnabled )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( pszFileSpec );
    UNREFERENCED( fEnabled );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetMessageLogFileSet


APIERR MNetMessageNameAdd(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszMessageName,
	UINT		   fFwdAction )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( pszMessageName );
    UNREFERENCED( fFwdAction );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetMessageNameAdd


APIERR MNetMessageNameDel(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszMessageName,
	UINT		   fFwdAction )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( pszMessageName );
    UNREFERENCED( fFwdAction );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetMessageNameDel


APIERR MNetMessageNameEnum(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	** ppbBuffer,
	UINT FAR	 * pcEntriesRead )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( Level );
    UNREFERENCED( ppbBuffer );
    UNREFERENCED( pcEntriesRead );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetMessageNameEnum


APIERR MNetMessageNameGetInfo(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszMessageName,
	UINT		   Level,
	BYTE FAR	** ppbBuffer )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( pszMessageName );
    UNREFERENCED( Level );
    UNREFERENCED( ppbBuffer );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetMessageNameGetInfo


APIERR MNetMessageNameFwd(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszMessageName,
	const TCHAR FAR	 * pszForwardName,
	UINT		   fDelFwdName )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( pszMessageName );
    UNREFERENCED( pszForwardName );
    UNREFERENCED( fDelFwdName );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetMessageNameFwd


APIERR MNetMessageNameUnFwd(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszMessageName )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( pszMessageName );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetMessageNameUnFwd

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\netslow\pprint.c ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    pprint.c
    mapping layer for Printing API

    FILE HISTORY:
        KeithMo         14-Oct-1991     Created.

*/

#include "pchmn32.h"

APIERR MDosPrintQEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( Level );

    *ppbBuffer     = NULL;
    *pcEntriesRead = 0;

    return NERR_Success;                // CODEWORK!  UNAVAILBLE IN PRODUCT 1

}   // MDosPrintQEnum
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\netslow\pserver.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    pserver.c
    mapping layer for NetServer API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.

*/

#include "pchmn32.h"

#if 0

APIERR MNetServerAdminCommand(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszCommand,
	UINT FAR	 * pResult,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer,
	UINT FAR	 * pcbReturned,
	UINT FAR	 * pcbTotalAvail )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( pszCommand );
    UNREFERENCED( pResult );
    UNREFERENCED( pbBuffer );
    UNREFERENCED( cbBuffer );
    UNREFERENCED( pcbReturned );
    UNREFERENCED( pcbTotalAvail );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetServerAdminCommand
#endif


APIERR MNetServerDiskEnum(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	** ppbBuffer,
	UINT FAR	 * pcEntriesRead )
{
    DWORD cTotalEntries;
    return (APIERR)NetServerDiskEnum( (TCHAR *)pszServer,
    				  Level,
				  ppbBuffer,
				  MAXPREFERREDLENGTH,
				  (LPDWORD)pcEntriesRead,
				  &cTotalEntries,
				  NULL );

}   // MNetServerDiskEnum


APIERR MNetServerEnum(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	** ppbBuffer,
	UINT FAR	 * pcEntriesRead,
	ULONG		   flServerType,
	TCHAR FAR	 * pszDomain )
{
    DWORD cTotalAvail;

    return (APIERR)NetServerEnum( (TCHAR *)pszServer,
    				  Level,
				  ppbBuffer,
				  MAXPREFERREDLENGTH,
				  (LPDWORD)pcEntriesRead,
				  &cTotalAvail,
				  flServerType,
				  pszDomain,
				  NULL );

}   // MNetServerEnum


APIERR MNetServerGetInfo(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	** ppbBuffer )
{
    return (APIERR)NetServerGetInfo( (TCHAR *)pszServer,
    				     Level,
				     ppbBuffer );

}   // MNetServerGetInfo


APIERR MNetServerSetInfo(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer,
	UINT		   ParmNum )
{
    UNREFERENCED( cbBuffer );

    // mapping layer does not do  this right now, since UI never uses it.
    if( ParmNum != PARMNUM_ALL )	
    {
    	return ERROR_NOT_SUPPORTED;
    }

    return (APIERR)NetServerSetInfo( (TCHAR *)pszServer,
    				     Level,
				     pbBuffer,
				     NULL );

}   // MNetServerSetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\netslow\pservice.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    pservice.c
    mapping layer for NetService API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.
        chuckc          19-Mar-1993     Added code to properly pass
                                        argv[], argc to new APIs.

*/

#include "pchmn32.h"

//
// forward declare
//
DWORD MakeArgvArgc(TCHAR *pszNullNull, TCHAR **ppszArgv, INT *pArgc)  ;
void  FreeArgv(TCHAR **ppszArgv, INT Argc)  ;


APIERR MNetServiceControl(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszService,
	UINT		   OpCode,
	UINT		   Arg,
	BYTE FAR	** ppbBuffer )
{
    return (APIERR)NetServiceControl( (TCHAR *)pszServer,
    		                      (TCHAR *)pszService,
				      OpCode,
				      Arg,
				      ppbBuffer );


}   // MNetServiceControl


APIERR MNetServiceEnum(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	** ppbBuffer,
	UINT FAR	 * pcEntriesRead )
{
    DWORD cTotalAvail;

    return (APIERR)NetServiceEnum( (TCHAR *)pszServer,
    				   Level,
				   ppbBuffer,
				   MAXPREFERREDLENGTH,
				   (LPDWORD)pcEntriesRead,
				   &cTotalAvail,
				   NULL );

}   // MNetServiceEnum


APIERR MNetServiceGetInfo(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszService,
	UINT		   Level,
	BYTE FAR	** ppbBuffer )
{

    return (APIERR)NetServiceGetInfo( (TCHAR *)pszServer,
    		 		      (TCHAR *)pszService,
				      Level,
				      ppbBuffer );

}   // MNetServiceGetInfo

//
// this is the number of separate arguments. 128 should be plenty
//
#define MAX_SERVICE_INSTALL_ARGS 128

APIERR MNetServiceInstall(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszService,
	const TCHAR FAR	 * pszCmdArgs,
	BYTE FAR	** ppbBuffer )
{

    TCHAR *apszMyArgv[MAX_SERVICE_INSTALL_ARGS] ;
    int   nArgc = MAX_SERVICE_INSTALL_ARGS ;
    APIERR err ;

    *ppbBuffer = NULL ;

    //
    // convert a NULL NULL string to the argv, argc style needed by new APIs
    //
    if (err = MakeArgvArgc((TCHAR *)pszCmdArgs, apszMyArgv, &nArgc))
        return err ;

    //
    // call the real API
    //
    err = NetServiceInstall( (TCHAR *)pszServer,
    			     (TCHAR *)pszService,
		             nArgc,
                             apszMyArgv,
                             ppbBuffer );

    //
    // cleanup any memory we allocated
    //
    FreeArgv(apszMyArgv, nArgc) ;

    return err ;

}   // MNetServiceInstall

/*******************************************************************

    NAME:       MakeArgvArgc

    SYNOPSIS:   converts a null null string to argv, argc format.
                memory is allocated for each substring. original
                string is not modified. caller is responsible for
                calling FreeArgv() when done.

    ENTRY:      pszNullNull - null null string, eg: foo\0bar\0\0
                ppszArgv    - used to return array of newly allocated pointers
                pArgc       - used to return number of strings. on entry will
                              contain the number of pointers ppszArgv can hold.

    RETURNS:    NERR_Sucess if successful, error otherwise

    HISTORY:
        ChuckC     18-Mar-1993     Created.

********************************************************************/
DWORD MakeArgvArgc(TCHAR *pszNullNull, TCHAR **ppszArgv, INT *pArgc)
{
     int iMax = *pArgc ;
     int iCount ;

     //
     // initialize the return array
     //
     for (iCount = 0; iCount < iMax; iCount++)
         ppszArgv[iCount] = NULL ;

     //
     // the trivial case
     //
     if (pszNullNull == NULL)
     {
         *pArgc = 0 ;
         return NERR_Success ;
     }

     //
     // go thru the null null string
     //
     iCount = 0;
     while (*pszNullNull && (iCount < iMax))
     {
         int i = STRLEN(pszNullNull) ;
         TCHAR *pszTmp = (TCHAR *) NetpMemoryAllocate( (i+1) * sizeof(TCHAR) ) ;

         if (!pszTmp)
         {
             FreeArgv(ppszArgv, iCount) ;
             return(ERROR_NOT_ENOUGH_MEMORY) ;
         }

         STRCPY(pszTmp,pszNullNull) ;
         ppszArgv[iCount] = pszTmp ;

         pszNullNull += i+1 ;
         iCount++ ;
    }

    //
    // we terminated because we ran out of space
    //
    if (iCount >= iMax && *pszNullNull)
    {
         FreeArgv(ppszArgv, iCount) ;
         return(NERR_BufTooSmall) ;
    }

    *pArgc = iCount ;
    return NERR_Success ;
}

/*******************************************************************

    NAME:       FreeArgv

    SYNOPSIS:   frees all the strings within the array

    ENTRY:      ppszArgv    - array of pointers
                Argc        - number of strings

    RETURNS:    none

    HISTORY:
        ChuckC     18-Mar-1993     Created.

********************************************************************/
void  FreeArgv(TCHAR **ppszArgv, INT Argc)
{
    while (Argc--)
    {
        NetpMemoryFree(ppszArgv[Argc]) ;
        ppszArgv[Argc] = NULL ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\netslow\premote.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    premote.c
    mapping layer for NetRemote API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.

*/

#include "pchmn32.h"

#if 0

APIERR MNetRemoteCopy(
	const TCHAR FAR	 * pszSourcePath,
	const TCHAR FAR	 * pszDestPath,
	const TCHAR FAR	 * pszSourcePasswd,
	const TCHAR FAR	 * pszDestPasswd,
	UINT		   fOpen,
	UINT		   fCopy,
	BYTE FAR	** ppbBuffer )
{
    UNREFERENCED( pszSourcePath );
    UNREFERENCED( pszDestPath );
    UNREFERENCED( pszSourcePasswd );
    UNREFERENCED( pszDestPasswd );
    UNREFERENCED( fOpen );
    UNREFERENCED( fCopy );
    UNREFERENCED( ppbBuffer );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetRemoteCopy

APIERR MNetRemoteMove(
	const TCHAR FAR	 * pszSourcePath,
	const TCHAR FAR	 * pszDestPath,
	const TCHAR FAR	 * pszSourcePasswd,
	const TCHAR FAR	 * pszDestPasswd,
	UINT		   fOpen,
	UINT		   fCopy,
	BYTE FAR	** ppbBuffer )
{
    UNREFERENCED( pszSourcePath );
    UNREFERENCED( pszDestPath );
    UNREFERENCED( pszSourcePasswd );
    UNREFERENCED( pszDestPasswd );
    UNREFERENCED( fOpen );
    UNREFERENCED( fCopy );
    UNREFERENCED( ppbBuffer );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetRemoteMove

#endif

APIERR MNetRemoteTOD(
	const TCHAR FAR	 * pszServer,
	BYTE FAR	** ppbBuffer )
{
    return (APIERR)NetRemoteTOD( (TCHAR *)pszServer,
    				 ppbBuffer );

}   // MNetRemoteTOD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\netslow\pshare.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    pshare.c
    mapping layer for NetShare API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.
	JonN		21-Oct-1991	Disabled NetShareCheck for now
        Yi-HsinS        20-Nov-1992	Added MNetShareDelSticky and
					MNetShareEnumSticky

*/

#include "pchmn32.h"

APIERR MNetShareAdd(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer )
{
    UNREFERENCED( cbBuffer );

    return (APIERR)NetShareAdd( (TCHAR *)pszServer,
				Level,
				pbBuffer,
				NULL );

}   // MNetShareAdd



APIERR MNetShareCheck(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszDeviceName,
	UINT FAR	 * pType )
{
    return (APIERR)NetShareCheck( (TCHAR *)pszServer,
				  (TCHAR *)pszDeviceName,
				  (LPDWORD) pType );

}   // MNetShareCheck


APIERR MNetShareDel(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszNetName,
	UINT		   Reserved )
{
    return (APIERR)NetShareDel( (TCHAR *)pszServer,
				(TCHAR *)pszNetName,
				Reserved );

}   // MNetShareDel

APIERR MNetShareDelSticky(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszNetName,
	UINT		   Reserved )
{
    return (APIERR)NetShareDelSticky( (TCHAR *)pszServer,
				      (TCHAR *)pszNetName,
				      Reserved );

}   // MNetShareDelSticky

APIERR MNetShareEnum(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	** ppbBuffer,
	UINT FAR	 * pcEntriesRead )
{
    DWORD cTotalAvail;

    return (APIERR)NetShareEnum( (TCHAR *)pszServer,
				 Level,
				 ppbBuffer,
				 MAXPREFERREDLENGTH,
				 (LPDWORD)pcEntriesRead,
				 &cTotalAvail,
				 NULL );

}   // MNetShareEnum

APIERR MNetShareEnumSticky(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	** ppbBuffer,
	UINT FAR	 * pcEntriesRead )
{
    DWORD cTotalAvail;

    return (APIERR)NetShareEnumSticky( (TCHAR *)pszServer,
				 Level,
				 ppbBuffer,
				 MAXPREFERREDLENGTH,
				 (LPDWORD)pcEntriesRead,
				 &cTotalAvail,
				 NULL );

}   // MNetShareEnumSticky

APIERR MNetShareGetInfo(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszNetName,
	UINT		   Level,
	BYTE FAR	** ppbBuffer )
{
    return (APIERR)NetShareGetInfo( (TCHAR *)pszServer,
    				    (TCHAR *)pszNetName,
				    Level,
				    ppbBuffer );

}   // MNetShareGetInfo


APIERR MNetShareSetInfo(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszNetName,
	UINT		   Level,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer,
	UINT		   ParmNum )
{
    UNREFERENCED( cbBuffer );

    // mapping layer does not do  this right now, since UI never uses it.
    if( ParmNum != PARMNUM_ALL )	
    {
    	return ERROR_NOT_SUPPORTED;
    }

    return (APIERR)NetShareSetInfo( (TCHAR *)pszServer,
    				    (TCHAR *)pszNetName,
				    Level,
				    pbBuffer,
				    NULL );

}   // MNetShareSetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\netslow\psession.c ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    psession.c
    mapping layer for NetSession API

    FILE HISTORY:
        danhi                           Created
        danhi           01-Apr-1991     Change to LM coding style
        KeithMo         13-Oct-1991     Massively hacked for LMOBJ.

*/

#include "pchmn32.h"

APIERR MNetSessionDel(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszClientName,
        const TCHAR FAR  * pszUserName )
{
    return (APIERR)NetSessionDel( (TCHAR *)pszServer,
                                  (TCHAR *)pszClientName,
                                  (TCHAR *)pszUserName );

}   // MNetSessionDel


APIERR MNetSessionEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead )
{
    DWORD cTotalAvail;

    return (APIERR)NetSessionEnum( (TCHAR *)pszServer,
                                   NULL,
                                   NULL,
                                   Level,
                                   ppbBuffer,
                                   MAXPREFERREDLENGTH,
                                   (LPDWORD)pcEntriesRead,
                                   &cTotalAvail,
                                   NULL );

}   // MNetSessionEnum


APIERR MNetSessionGetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszClientName,
        UINT               Level,
        BYTE FAR        ** ppbBuffer )
{
    DWORD cTotalEntries;
    DWORD cEntriesRead;
    DWORD err;

    err = NetSessionEnum( (TCHAR *)pszServer,
                          (TCHAR *)pszClientName,
                          NULL,
                          Level,
                          ppbBuffer,
                          MAXPREFERREDLENGTH,
                          &cEntriesRead,
                          &cTotalEntries,
                          NULL );

    if( ( err == NERR_Success ) && ( cEntriesRead == 0 ) )
    {
        return NERR_ClientNameNotFound;
    }
    else
    {
        return (APIERR)err;
    }

}   // MNetSessionGetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\netslow\pstatist.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    pstatist.c
    mapping layer for NetStatistic API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.

*/

#include "pchmn32.h"

#if 0

APIERR MNetStatisticsClear(
	const TCHAR FAR	 * pszServer )
{
    UNREFERENCED( pszServer );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetStatisticsClear


APIERR MNetStatisticsGet(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszService,
	ULONG	 	   ulReserved,
	UINT		   Level,
	ULONG		   flOptions,
	BYTE FAR	** ppbBuffer )
{
    UNREFERENCED( pszServer );
    UNREFERENCED( pszService );
    UNREFERENCED( ulReserved );
    UNREFERENCED( Level );
    UNREFERENCED( flOptions );
    UNREFERENCED( ppbBuffer );

    return ERROR_NOT_SUPPORTED;	    	// NOT NEEDED FOR LMOBJ

}   // MNetStatisticsGet

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\netslow\puse.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    puse.c
    mapping layer for NetUse API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.

*/

#include "pchmn32.h"

APIERR MNetUseAdd(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer )
{
    UNREFERENCED( cbBuffer );

    return (APIERR)NetUseAdd( (TCHAR *)pszServer,
    			      Level,
			      pbBuffer,
			      NULL );

}   // MNetUseAdd


APIERR MNetUseDel(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszDeviceName,
	UINT		   Force )
{
    return (APIERR)NetUseDel( (TCHAR *)pszServer,
    			      (TCHAR *)pszDeviceName,
			      Force );

}   // MNetUseDel


APIERR MNetUseEnum(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	** ppbBuffer,
	UINT FAR	 * pcEntriesRead )
{
    DWORD cTotalAvail;

    return (APIERR)NetUseEnum( (TCHAR *)pszServer,
    			       Level,
			       ppbBuffer,
			       MAXPREFERREDLENGTH,
			       (LPDWORD)pcEntriesRead,
			       &cTotalAvail,
			       NULL );

}   // MNetUseEnum


APIERR MNetUseGetInfo(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszUseName,
	UINT		   Level,
	BYTE FAR	** ppbBuffer )
{
    return (APIERR)NetUseGetInfo( (TCHAR *)pszServer,
    				  (TCHAR *)pszUseName,
				  Level,
				  ppbBuffer );

}   // MNetUseGetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\netslow\puser.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    puser.c
    mapping layer for NetUser API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.
   JonN     27-May-1992    Removed ANSI<->UNICODE hack

*/

#include "pchmn32.h"

APIERR MNetUserAdd(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer )
{
    UNREFERENCED( cbBuffer );

    return (APIERR)NetUserAdd( (TCHAR *)pszServer,
    			       Level,
			       pbBuffer,
			       NULL );

}   // MNetUserAdd


APIERR MNetUserDel(
	const TCHAR FAR	 * pszServer,
	TCHAR FAR	 * pszUserName )
{
    return (APIERR)NetUserDel( (TCHAR *)pszServer,
    			       pszUserName );

}   // MNetUserDel


APIERR MNetUserEnum(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	UINT		   Filter,
	BYTE FAR	** ppbBuffer,
        ULONG              ulMaxPreferred,
	UINT FAR	 * pcEntriesRead,
        UINT FAR         * pcTotalEntries,
        VOID FAR         * pResumeKey )
{

    return (APIERR)NetUserEnum( (TCHAR *)pszServer,
    		                Level,
                                Filter,
				ppbBuffer,
				ulMaxPreferred,
				pcEntriesRead,
				pcTotalEntries,
				pResumeKey );

}   // MNetUserEnum


APIERR MNetUserGetInfo(
	const TCHAR FAR	 * pszServer,
	TCHAR FAR	 * pszUserName,
	UINT		   Level,
	BYTE FAR	** ppbBuffer )
{
    return (APIERR)NetUserGetInfo( (TCHAR *)pszServer,
    				   pszUserName,
				   Level,
				   ppbBuffer );

}   // MNetUserGetInfo


APIERR MNetUserSetInfo(
	const TCHAR FAR	 * pszServer,
	TCHAR FAR	 * pszUserName,
	UINT	        Level,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer,
	UINT		   ParmNum )
{
    UNREFERENCED( cbBuffer );

    if( ParmNum != PARMNUM_ALL )
    {
    	return ERROR_NOT_SUPPORTED;
    }

    return (APIERR)NetUserSetInfo( (TCHAR *)pszServer,
				   pszUserName,
				   Level,
				   pbBuffer,
				   NULL );

}   // MNetUserSetInfo


APIERR MNetUserPasswordSet(
	const TCHAR FAR	 * pszServer,
	TCHAR FAR	 * pszUserName,
	TCHAR FAR	 * pszOldPassword,
	TCHAR FAR	 * pszNewPassword )
{
    return ERROR_NOT_SUPPORTED;		// WE REALLY NEED THIS ONE!

}   // MNetUserPasswordSet


APIERR MNetUserGetGroups(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszUserName,
	UINT		   Level,
	BYTE FAR	** ppbBuffer,
	UINT FAR	 * pcEntriesRead )
{
    DWORD cTotalAvail;

    return (APIERR)NetUserGetGroups( (TCHAR *)pszServer,
    				     (TCHAR *)pszUserName,
				     Level,
				     ppbBuffer,
				     MAXPREFERREDLENGTH,
				     pcEntriesRead,
				     &cTotalAvail );

}   // MNetUserGetGroups


APIERR MNetUserSetGroups(
	const TCHAR FAR	 * pszServer,
	const TCHAR FAR	 * pszUserName,
	UINT		   Level,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer,
	UINT		   cEntries )
{
    UNREFERENCED( cbBuffer );

    return (APIERR)NetUserSetGroups( (TCHAR *)pszServer,
				     (TCHAR *)pszUserName,
				     Level,
				     pbBuffer,
				     cEntries );

}   // MNetUserSetGroups


APIERR MNetUserModalsGet(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	** ppbBuffer )
{
    return (APIERR)NetUserModalsGet( (TCHAR *)pszServer,
    				     Level,
				     ppbBuffer );

}   // MNetUserModalsGet


APIERR MNetUserModalsSet(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer,
	UINT		   ParmNum )
{
    UNREFERENCED( cbBuffer );

    if( ParmNum != PARMNUM_ALL )
    {
    	return ERROR_NOT_SUPPORTED;
    }

    return (APIERR)NetUserModalsSet( (TCHAR *)pszServer,
				     Level,
				     pbBuffer,
				     NULL );
}   // MNetUserModalsSet


#if 0

APIERR MNetUserValidate(
	TCHAR FAR	 * pszReserved1,
	UINT		   Level,
	BYTE FAR	** ppbBuffer,
	UINT		   Reserved2 )
{
    UNREFERENCED( Reserved2 );

    return (APIERR)NetUserValidate( pszReserved1,
    				    Level,
				    ppbBuffer );

}   // MNetUserValidate

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\netslow\pwksta.c ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    pwksta.c
    mapping layer for NetWksta API

    FILE HISTORY:
	danhi				Created
	danhi		01-Apr-1991 	Change to LM coding style
	KeithMo		13-Oct-1991	Massively hacked for LMOBJ.

*/

#include "pchmn32.h"

APIERR MNetWkstaGetInfo(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	** ppbBuffer )
{
    APIERR err;

    err = (APIERR)NetWkstaGetInfo( (TCHAR *)pszServer,
    				   Level,
				   ppbBuffer );

    return err;

}   // MNetWkstaGetInfo


APIERR MNetWkstaSetInfo(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer )
{
    UNREFERENCED( cbBuffer );

    return (APIERR)NetWkstaSetInfo( (TCHAR *)pszServer,
    				    Level,
				    pbBuffer,
				    NULL );

}   // MNetWkstaSetInfo


APIERR MNetWkstaSetUID(
	TCHAR FAR	 * pszReserved,
	TCHAR FAR	 * pszDomain,
	TCHAR FAR	 * pszUserName,
	TCHAR FAR	 * pszPassword,
	TCHAR FAR	 * pszParms,
	UINT		   LogoffForce,
	UINT		   Level,
	BYTE FAR	 * pbBuffer,
	UINT		   cbBuffer,
	UINT FAR	 * pcbTotalAvail )
{
    return ERROR_NOT_SUPPORTED;	    	// WE REALLY NEED THIS ONE!

}   // MNetWkstaSetUID


APIERR MNetWkstaUserEnum(
	const TCHAR FAR	 * pszServer,
	UINT		   Level,
	BYTE FAR	** ppbBuffer,
	UINT FAR	 * pcEntriesRead )
{
    APIERR err;
    DWORD  cTotalAvail;

    if( Level != 1 )
    {
    	return ERROR_NOT_SUPPORTED;
    }

    err = (APIERR)NetWkstaUserEnum( (TCHAR *)pszServer,
    				    (DWORD)Level,
				    ppbBuffer,
				    MAXPREFERREDLENGTH,
				    (LPDWORD)pcEntriesRead,
				    &cTotalAvail,
				    NULL );

    return err;

}   // MNetWkstaUserEnum


APIERR MNetWkstaUserGetInfo(
	const TCHAR FAR	 * pszReserved,
	UINT		   Level,
	BYTE FAR	** ppbBuffer )
{
    APIERR err;

    err = (APIERR)NetWkstaUserGetInfo( (TCHAR *)pszReserved,
    				   Level,
				   ppbBuffer );

    return err;

}   // MNetWkstaUserGetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\pch\prepl.c ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    prepl.c
    mapping layer for NetReplXxx API.

    FILE HISTORY:
        KeithMo         25-Feb-1992     Created.
        JonN            18-Apr-2002     585780: MNetRepl is no longer used, but
                                        this file is needed for build purposes

*/

#include "pchmn32.h"
#pragma hdrstop


#if 0 // 585780-2002/04/18-JonN


//
//  If the following symbol is #defined, then no actual
//  replicator APIs will be referenced.  Everything will
//  be faked better than Meg Ryan in "When Harry Met Sally".
//

// #define FAKE_REPLICATOR_API


#ifdef FAKE_REPLICATOR_API
REPL_INFO_0 FakeReplInfo0 =
            {
                REPL_ROLE_BOTH,
                SZ("D:\\REPL\\EXPORT"),
                SZ("NTPROJECT"),
                SZ("D:\\REPL\\IMPORT"),
                SZ("NTPROJECT"),
                SZ("LogonUser"),
                0,
                0,
                0,
                0
            };

REPL_EDIR_INFO_2 FakeReplEdirInfo2 =
                 {
                     SZ("EXPORTED"),
                     REPL_INTEGRITY_TREE,
                     REPL_EXTENT_TREE,
                     0,
                     0
                 };

REPL_IDIR_INFO_1 FakeReplIdirInfo1 =
                 {
                     SZ("IMPORTED"),
                     REPL_STATE_OK,
                     SZ("MyMaster"),
                     0,
                     0,
                     0
                 };
#endif



APIERR MNetReplGetInfo(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer )
{
#ifdef FAKE_REPLICATOR_API
    REPL_INFO_0 * pInfo;

    *ppbBuffer = MNetApiBufferAlloc( sizeof(REPL_INFO_0) );

    if( *ppbBuffer == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pInfo = (REPL_INFO_0 * )*ppbBuffer;

    pInfo->rp0_role             = FakeReplInfo0.rp0_role;
    pInfo->rp0_exportpath       = FakeReplInfo0.rp0_exportpath;
    pInfo->rp0_exportlist       = FakeReplInfo0.rp0_exportlist;
    pInfo->rp0_importpath       = FakeReplInfo0.rp0_importpath;
    pInfo->rp0_importlist       = FakeReplInfo0.rp0_importlist;
    pInfo->rp0_logonusername    = FakeReplInfo0.rp0_logonusername;
    pInfo->rp0_interval         = FakeReplInfo0.rp0_interval;
    pInfo->rp0_pulse            = FakeReplInfo0.rp0_pulse;
    pInfo->rp0_guardtime        = FakeReplInfo0.rp0_guardtime;
    pInfo->rp0_random           = FakeReplInfo0.rp0_random;

    return NERR_Success;
#else
    return (APIERR)NetReplGetInfo( (LPTSTR)pszServer,
                                   (DWORD)Level,
                                   (LPBYTE *)ppbBuffer );
#endif

}   // MNetReplGetInfo


APIERR MNetReplSetInfo(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR         * pbBuffer )
{
#ifdef FAKE_REPLICATOR_API
    return NERR_Success;
#else
    return (APIERR)NetReplSetInfo( (LPTSTR)pszServer,
                                   (DWORD)Level,
                                   (LPBYTE)pbBuffer,
                                   NULL );
#endif

}   // MNetReplSetInfo


APIERR MNetReplExportDirAdd(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR         * pbBuffer )
{
#ifdef FAKE_REPLICATOR_API
    return NERR_Success;
#else
    return (APIERR)NetReplExportDirAdd( (LPTSTR)pszServer,
                                        (DWORD)Level,
                                        (LPBYTE)pbBuffer,
                                        NULL );
#endif

}   // MNetReplExportDirAdd


APIERR MNetReplExportDirDel(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory )
{
#ifdef FAKE_REPLICATOR_API
    return NERR_Success;
#else
    return (APIERR)NetReplExportDirDel( (LPTSTR)pszServer,
                                        (LPTSTR)pszDirectory );
#endif

}   // MNetReplExportDirDel


APIERR MNetReplExportDirEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead )
{
#ifdef FAKE_REPLICATOR_API
    *ppbBuffer = NULL;
    *pcEntriesRead = 0;

    return NERR_Success;
#else
    DWORD cTotalAvailable;

    return (APIERR)NetReplExportDirEnum( (LPTSTR)pszServer,
                                         (DWORD)Level,
                                         (LPBYTE *)ppbBuffer,
                                         MAXPREFERREDLENGTH,
                                         (LPDWORD)pcEntriesRead,
                                         &cTotalAvailable,
                                         NULL );
#endif

}   // MNetReplExportDirEnum


APIERR MNetReplExportDirGetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory,
        UINT               Level,
        BYTE FAR        ** ppbBuffer )
{
#ifdef FAKE_REPLICATOR_API
    return NERR_Success;
#else
    return (APIERR)NetReplExportDirGetInfo( (LPTSTR)pszServer,
                                            (LPTSTR)pszDirectory,
                                            (DWORD)Level,
                                            (LPBYTE *)ppbBuffer );
#endif

}   // MNetReplExportDirGetInfo


APIERR MNetReplExportDirSetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory,
        UINT               Level,
        BYTE FAR         * pbBuffer )
{
#ifdef FAKE_REPLICATOR_API
    return NERR_Success;
#else
    return (APIERR)NetReplExportDirSetInfo( (LPTSTR)pszServer,
                                            (LPTSTR)pszDirectory,
                                            (DWORD)Level,
                                            (LPBYTE)pbBuffer,
                                            NULL );
#endif

}   // MNetReplExportDirSetInfo


APIERR MNetReplExportDirLock(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory )
{
#ifdef FAKE_REPLICATOR_API
    return NERR_Success;
#else
    return (APIERR)NetReplExportDirLock( (LPTSTR)pszServer,
                                         (LPTSTR)pszDirectory );
#endif

}   // MNetReplExportDirLock


APIERR MNetReplExportDirUnlock(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory,
        UINT               Force )
{
#ifdef FAKE_REPLICATOR_API
    return NERR_Success;
#else
    return (APIERR)NetReplExportDirUnlock( (LPTSTR)pszServer,
                                           (LPTSTR)pszDirectory,
                                           (DWORD)Force );
#endif

}   // MNetReplExportDirUnlock


APIERR MNetReplImportDirAdd(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR         * pbBuffer )
{
#ifdef FAKE_REPLICATOR_API
    return NERR_Success;
#else
    return (APIERR)NetReplImportDirAdd( (LPTSTR)pszServer,
                                        (DWORD)Level,
                                        (LPBYTE)pbBuffer,
                                        NULL );
#endif

}   // MNetReplImportDirAdd


APIERR MNetReplImportDirDel(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory )
{
#ifdef FAKE_REPLICATOR_API
    return NERR_Success;
#else
    return (APIERR)NetReplImportDirDel( (LPTSTR)pszServer,
                                        (LPTSTR)pszDirectory );
#endif

}   // MNetReplImportDirDel


APIERR MNetReplImportDirEnum(
        const TCHAR FAR  * pszServer,
        UINT               Level,
        BYTE FAR        ** ppbBuffer,
        UINT FAR         * pcEntriesRead )
{
#ifdef FAKE_REPLICATOR_API
    *ppbBuffer = NULL;
    *pcEntriesRead = 0;

    return NERR_Success;
#else
    DWORD cTotalAvailable;

    return (APIERR)NetReplImportDirEnum( (LPTSTR)pszServer,
                                         (DWORD)Level,
                                         (LPBYTE *)ppbBuffer,
                                         MAXPREFERREDLENGTH,
                                         (LPDWORD)pcEntriesRead,
                                         &cTotalAvailable,
                                         NULL );
#endif

}   // MNetReplImportDirEnum


APIERR MNetReplImportDirGetInfo(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory,
        UINT               Level,
        BYTE FAR        ** ppbBuffer )
{
#ifdef FAKE_REPLICATOR_API
    return NERR_Success;
#else
    return (APIERR)NetReplImportDirGetInfo( (LPTSTR)pszServer,
                                            (LPTSTR)pszDirectory,
                                            (DWORD)Level,
                                            (LPBYTE *)ppbBuffer );
#endif

}   // MNetReplImportDirGetInfo


APIERR MNetReplImportDirLock(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory )
{
#ifdef FAKE_REPLICATOR_API
    return NERR_Success;
#else
    return (APIERR)NetReplImportDirLock( (LPTSTR)pszServer,
                                         (LPTSTR)pszDirectory );
#endif

}   // MNetReplImportDirLock


APIERR MNetReplImportDirUnlock(
        const TCHAR FAR  * pszServer,
        const TCHAR FAR  * pszDirectory,
        UINT               Force )
{
#ifdef FAKE_REPLICATOR_API
    return NERR_Success;
#else
    return (APIERR)NetReplImportDirUnlock( (LPTSTR)pszServer,
                                           (LPTSTR)pszDirectory,
                                           (DWORD)Force );
#endif

}   // MNetReplImportDirUnlock

#endif // 585780-2002/04/18-JonN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\mnet32\test\test.c ===
#include <nt.h>
#include <ntrtl.h>
#include <rpc.h>
#include <nturtl.h>
#include <windows.h>
#include <ntsam.h>
#include <stdio.h>

#include <msamqdi.h>


char * MapUnicodeToAnsiPoorly( PUNICODE_STRING punicode );


int main( int cArgs, char * pArgs[] )
{
    NTSTATUS err;
    ULONG    cbTotalAvailable;
    ULONG    cbTotalReturned;
    ULONG    cReturnedEntries;
    PVOID    pBuffer;
	
    err = SamQueryDisplayInformation( NULL,
				      ( cArgs > 1 )
				          ? DomainDisplayUser
				          : DomainDisplayMachine,
				      0L,
				      65535L,
				      &cbTotalAvailable,
				      &cbTotalReturned,
				      &cReturnedEntries,
				      &pBuffer );

    if( err != 0 )
    {
	fprintf( stderr,
		 "SamQueryDisplayInformation returned %lu (%08lX)\n",
		 (ULONG)err,
		 (ULONG)err );

	return 1;
    }

    printf( "%lu bytes available\n", cbTotalAvailable );
    printf( "%lu bytes returned\n", cbTotalReturned );
    printf( "%lu entries returned\n", cReturnedEntries );
    printf( "\n" );
	
    if( cArgs > 1 )
    {
	DOMAIN_DISPLAY_USER * pddu = (DOMAIN_DISPLAY_USER *)pBuffer;
	
	while( cReturnedEntries-- )
	{
	    printf( "Index          = %lu\n",
		    pddu->Index );
		    
	    printf( "Rid            = %lu\n",
		    pddu->Rid );
		    
	    printf( "AccountControl = %lu\n",
		    pddu->AccountControl );
		    
	    printf( "LogonName      = %s\n",
		    MapUnicodeToAnsiPoorly( &pddu->LogonName ) );
		    
	    printf( "AdminComment   = %s\n",
		    MapUnicodeToAnsiPoorly( &pddu->AdminComment ) );

	    printf( "FullName       = %s\n",
		    MapUnicodeToAnsiPoorly( &pddu->FullName ) );
		    
	    printf( "\n" );

	    pddu++;
	}
    }
    else
    {
	DOMAIN_DISPLAY_MACHINE * pddm = (DOMAIN_DISPLAY_MACHINE *)pBuffer;

	while( cReturnedEntries-- )
	{
	    printf( "Index          = %lu\n",
		    pddm->Index );
		    
	    printf( "Rid            = %lu\n",
		    pddm->Rid );
		    
	    printf( "AccountControl = %lu\n",
		    pddm->AccountControl );
		    
	    printf( "Machine        = %s\n",
		    MapUnicodeToAnsiPoorly( &pddm->Machine ) );
		    
	    printf( "Comment        = %s\n",
		    MapUnicodeToAnsiPoorly( &pddm->Comment ) );
		    
	    printf( "\n" );

	    pddm++;
	}
    }
    
    return 0;
    
}   // main


char * MapUnicodeToAnsiPoorly( PUNICODE_STRING punicode )
{
    char        * psz = (char *)punicode->Buffer;
    WCHAR	* pwc = punicode->Buffer;
    USHORT	  cb  = punicode->Length;

    if( cb == 0 )
    {
	return "";
    }

    while( ( cb > 0 ) && ( *pwc != L'\0' ) )
    {
	*psz++ = (char)*pwc++;
	cb -= sizeof(WCHAR);
    }
    
    *psz = '\0';

    return (char *)punicode->Buffer;
	
}   // MapUnicodeToAnsiPoorly


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\profile\test\heapstat.cxx ===
#define NO_TEST_VARS
#include "test.hxx"

// copied from $(UI)\COMMON\SRC\CFGFILE\TEST

/* Reports on the status returned by _heapwalk, _heapset, or _heapchk */

int heapstat( int status )
{
int usRetCode = 1;

#ifdef DEBUGShowHeapStat
    printf( SZ("Heap status: ") );
#endif

    switch( status )
    {
        case _HEAPOK:
#ifdef DEBUGShowHeapStat
            printf( SZ("OK    - heap is fine\n") );
#endif
            break;
        case _HEAPEMPTY:
#ifdef DEBUGShowHeapStat
            printf( SZ("OK    - empty heap\n") );
#endif
            break;
        case _HEAPEND:
#ifdef DEBUGShowHeapStat
            printf( SZ("OK    - end of heap\n") );
#endif
            break;
        case _HEAPBADPTR:
#ifdef DEBUGShowHeapStat
            printf( SZ("ERROR - bad pointer to heap\n") );
#endif
	    usRetCode = 0;
            break;
        case _HEAPBADBEGIN:
#ifdef DEBUGShowHeapStat
            printf( SZ("ERROR - bad start of heap\n") );
#endif
	    usRetCode = 0;
            break;
        case _HEAPBADNODE:
#ifdef DEBUGShowHeapStat
            printf( SZ("ERROR - bad node in heap\n") );
#endif
	    usRetCode = 0;
            break;
    }

    return( usRetCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\profile\profile\nthack.cxx ===
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/


/*
 *  FILE STATUS:
 *  10/30/91  created
 *  06-Apr-1992 beng Unicode pass (nuke CPSZ, PSZ)
 */

/*********
NTHACK.CXX
*********/

/****************************************************************************

    MODULE: NTHack.cxx

    PURPOSE: Stubs out all profile functionality

    FUNCTIONS:

        see uiprof.h

    COMMENTS:

****************************************************************************/


#include "profilei.hxx"         /* headers and internal routines */


/*
 * error returns:
 * ERROR_NOT_ENOUGH_MEMORY
 */
USHORT UserProfileInit(
        )
{
    return NO_ERROR;
}


/*
 * error returns:
 * ERROR_NOT_ENOUGH_MEMORY
 */
USHORT UserProfileFree(
        )
{
    return NO_ERROR;
}


/*
 * Returns information about one connection in the cached profile.
 *
 * returns
 * ERROR_GEN_FAILURE: username does not match cache
 * NERR_InvalidDevice
 * NERR_UseNotFound
 *
 *      see \\iceberg2\lm30spec\src\docs\funcspec\lm30dfs.doc for
 *      details on the new use_info_2 data structure for LM30
 */
USHORT UserProfileQuery(
        const TCHAR *   pszUsername,
        const TCHAR *   pszDeviceName,
        TCHAR *    pszBuffer,    // returns UNC, alias or domain name
        USHORT usBufferSize, // length of above buffer
        short *psAsgType,    // *psAsgType set to asg_type; ignored if NULL
        unsigned short *pusResType   // *pusResType set to res_type; ignored if NULL
        )
{
    UNREFERENCED( pszUsername );
    UNREFERENCED( pszDeviceName );
    UNREFERENCED( pszBuffer );
    UNREFERENCED( usBufferSize );
    UNREFERENCED( psAsgType );
    UNREFERENCED( pusResType );
    return NERR_UseNotFound;
}


/*
 * returns
 * ERROR_GEN_FAILURE: username does not match cache
 * NERR_InvalidDevice
 * ERROR_NOT_ENOUGH_MEMORY
 */
/*
 * UserProfileQuery does not canonicalize pszCanonRemoteName, the caller
 * is expected to already have done so.
 *
 * The user is expected to ensure that usResType corresponds to
 * the type of the remote resource, and that device pszDeviceName
 * can be connected to a resource of that type.
 */
USHORT UserProfileSet(
        const TCHAR *   pszUsername,
        const TCHAR *   pszDeviceName,
        const TCHAR *   pszRemoteName,
        short  sAsgType,     // as ui2_asg_type
        unsigned short usResType     // as ui2_res_type
        )
{
    UNREFERENCED( pszUsername );
    UNREFERENCED( pszDeviceName );
    UNREFERENCED( pszRemoteName );
    UNREFERENCED( sAsgType );
    UNREFERENCED( usResType );
    return NO_ERROR;
}


/*
 * returns
 * NERR_BadUsername
 * ERROR_BAD_NETPATH
 * ERROR_FILE_NOT_FOUND
 */
USHORT UserProfileRead(
        const TCHAR *  pszUsername, // uncache cached profile if this is NULL
        const TCHAR *  pszHomedir
        )
{
    UNREFERENCED( pszUsername );
    UNREFERENCED( pszHomedir );
    return NO_ERROR;
}


/*
 * returns
 * NERR_BadUsername
 * ERROR_BAD_NETPATH
 * ERROR_WRITE_FAULT
 */
USHORT UserProfileWrite(
        const TCHAR *   pszUsername,
        const TCHAR *   pszHomedir
        )
{
    UNREFERENCED( pszUsername );
    UNREFERENCED( pszHomedir );
    return NO_ERROR;
}


/*
 * Returns a list of all devices with connections in the cached profile;
 * devicenames in this list will be separated by null characters, with two
 * null characters at the end.
 *
 * returns
 * ERROR_GEN_FAILURE: username does not match cache
 * ERROR_INSUFFICIENT_BUFFER
 *
 */
USHORT UserProfileEnum(
        const TCHAR *  pszUsername,
        TCHAR *   pszBuffer,     // returns NULL-NULL list of device names
        USHORT usBufferSize  // length of above buffer
        )
{
    UNREFERENCED( pszUsername );
    UNREFERENCED( pszBuffer );
    UNREFERENCED( usBufferSize );
    if ( usBufferSize < 2*sizeof(TCHAR) )
        return ERROR_INSUFFICIENT_BUFFER;

    pszBuffer[0] = TCH('\0');
    pszBuffer[1] = TCH('\0');

    return NO_ERROR;
}


/*******************************************************************

    NAME:       UserPreferenceQuery

    SYNOPSIS:   Queries a saved user preference (null terminated string)

    ENTRY:      usKey    - must be one of the known keys as
                           defined in UIPROF.H (ie USERPREF_XXX).
                pchValue - pointer to buffer to receive string
                cbLen    - size of buffer

    EXIT:       if NERR_Success, pchValue will contain value in
                LAMMAN.INI corresponding to the key.
                Returns DOS/NET errors as reported by API, may
                also return ERROR_INVALID_PARM or NERR_BufTooSmall.

    NOTES:

    HISTORY:
        chuckc  07-Mar-1991    Created

********************************************************************/
USHORT UserPreferenceQuery( USHORT     usKey,
                            TCHAR FAR * pchValue,
                            USHORT     cbLen)
{
    UNREFERENCED( usKey );
    UNREFERENCED( pchValue );
    UNREFERENCED( cbLen );
    return NERR_CfgCompNotFound;

}


/*******************************************************************

    NAME:       UserPreferenceSet

    SYNOPSIS:   Saves a user preference (null terminated string)

    ENTRY:      usKey    - must be one of the known keys as
                           defined in UIPROF.H (ie USERPREF_XXX).
                pchValue - pointer to null terminated string
                            containing value to be saved.

    EXIT:       if NERR_Success, the value in LAMMAN.INI corresponding
                to the key will be the string pointed to by pchValue.

                Returns DOS/NET errors as reported by API, may
                also return ERROR_INVALID_PARM.

    NOTES:

    HISTORY:
        chuckc  07-Mar-1991    Created

********************************************************************/
USHORT UserPreferenceSet( USHORT     usKey,
                          TCHAR FAR * pchValue)
{
    UNREFERENCED( usKey );
    UNREFERENCED( pchValue );
    return NO_ERROR;
}


/*******************************************************************

    NAME:       UserPreferenceQueryBool

    SYNOPSIS:   Queries a boolean user preference

    ENTRY:      usKey    - must be one of the known keys as
                           defined in UIPROF.H (ie USERPREF_XXX).
                pfValue  - pointer to BOOL that will receive value

    EXIT:       if NERR_Success, pfValue will contain TRUE if
                the value in LAMMAN.INI corresponding to the key
                is "YES" or "yes", and FALSE if "NO" or "no".
                If neither, we assume the user made an error since the
                value stored was not YES/NO.

                Also returns DOS/NET errors as reported by API, may
                also return ERROR_INVALID_PARM.

    NOTES:

    HISTORY:
        chuckc  07-Mar-1991    Created

********************************************************************/
USHORT UserPreferenceQueryBool( USHORT     usKey,
                                BOOL FAR * pfValue)
{
    UNREFERENCED( usKey );
    UNREFERENCED( pfValue );
    return NERR_CfgCompNotFound;
}

/*******************************************************************

    NAME:       UserPreferenceSetBool

    SYNOPSIS:   Sets a user boolean preference flag

    ENTRY:      usKey    - must be one of the known keys as
                           defined in UIPROF.H (ie USERPREF_XXX).
                pchValue - TRUE or FALSE, the value to be saved

    EXIT:       if NERR_Success, the LAMMAN.INI value corresponding to
                the key will be set to "yes" or "no".
                Returns DOS/NET errors as reported by API, may
                also return ERROR_INVALID_PARM.

    NOTES:

    HISTORY:
        chuckc  07-Mar-1991    Created

********************************************************************/
USHORT UserPreferenceSetBool( USHORT     usKey,
                              BOOL       fValue)
{
    UNREFERENCED( usKey );
    UNREFERENCED( fValue );
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\profile\test\test1.cxx ===
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  12/02/90  created
 *  02/05/91  updated to new APIs
 */

#ifdef CODESPEC
/*START CODESPEC*/

/********
TEST1.CXX
********/

/****************************************************************************

    MODULE: Test1.cxx

    PURPOSE: One stage of tests for user profile APIs

    FUNCTIONS:

	see profilei.h

    COMMENTS:

****************************************************************************/

/************
end TEST1.CXX
************/

/*END CODESPEC*/
#endif // CODESPEC



#include "test.hxx"		/* headers and internal routines */



/* internal manifests */



/* functions: */


int main(int argc, char **argv)
{
    int i;

    (void) argc;
    (void) argv;


    CHECKHEAP


    printf(SZ("Starting UserProfile tests\n"));

    TestOne_UserProfileInit();



// this sequence is intended to test the cpszUsername functionality

// test calling UserProfileQuery/Enum/Set before UserProfileRead
    TestOne_UserProfileSet(
	(CPSZ)NULL,
	(CPSZ)SZ("com1:"),
	(CPSZ)SZ("\\\\commserver\\comm1"),
	USE_CHARDEV,
	0);
    TestOne_UserProfileSet(
	(CPSZ)USERNAME,
	(CPSZ)SZ("com1:"),
	(CPSZ)SZ("\\\\commserver\\comm2"),
	USE_CHARDEV,
	0);
    TestOne_UserProfileQuery((CPSZ)NULL,(CPSZ)SZ("com1"),MAXPATHLEN);
    TestOne_UserProfileQuery((CPSZ)USERNAME,(CPSZ)SZ("com1"),MAXPATHLEN);
    TestOne_UserProfileEnum((CPSZ)NULL,MAXPATHLEN);
    TestOne_UserProfileEnum((CPSZ)USERNAME,MAXPATHLEN);

    TestOne_UserProfileRead((CPSZ)NULL,(CPSZ)szHomedir1);

// test calling UserProfileQuery/Enum/Set after UserProfileRead(NULL)
    TestOne_UserProfileSet(
	(CPSZ)NULL,
	(CPSZ)SZ("com1:"),
	(CPSZ)SZ("\\\\commserver\\comm3"),
	USE_CHARDEV,
	0);
    TestOne_UserProfileSet(
	(CPSZ)USERNAME,
	(CPSZ)SZ("com1:"),
	(CPSZ)SZ("\\\\commserver\\comm4"),
	USE_CHARDEV,
	0);
    TestOne_UserProfileQuery((CPSZ)NULL,(CPSZ)SZ("com1"),MAXPATHLEN);
    TestOne_UserProfileQuery((CPSZ)USERNAME,(CPSZ)SZ("com1"),MAXPATHLEN);
    TestOne_UserProfileEnum((CPSZ)NULL,MAXPATHLEN);
    TestOne_UserProfileEnum((CPSZ)USERNAME,MAXPATHLEN);

    TestOne_UserProfileRead((CPSZ)USERNAME,(CPSZ)szHomedir1);

// test calling UserProfileQuery/Enum/Set after UserProfileRead(USERNAME)
    TestOne_UserProfileSet(
	(CPSZ)USERNAME,
	(CPSZ)SZ("com1:"),
	(CPSZ)SZ("\\\\commserver\\comm5"),
	USE_CHARDEV,
	0);
    TestOne_UserProfileSet(
	(CPSZ)NULL,
	(CPSZ)SZ("com1:"),
	(CPSZ)SZ("\\\\commserver\\comm6"),
	USE_CHARDEV,
	0);
    TestOne_UserProfileSet(
	(CPSZ)DIFFERENT_USERNAME,
	(CPSZ)SZ("com1:"),
	(CPSZ)SZ("\\\\commserver\\comm7"),
	USE_CHARDEV,
	0);
    TestOne_UserProfileQuery((CPSZ)USERNAME,(CPSZ)SZ("com1"),MAXPATHLEN);
    TestOne_UserProfileQuery((CPSZ)NULL,(CPSZ)SZ("com1"),MAXPATHLEN);
    TestOne_UserProfileQuery((CPSZ)DIFFERENT_USERNAME,(CPSZ)SZ("com1"),MAXPATHLEN);
    TestOne_UserProfileEnum((CPSZ)USERNAME,MAXPATHLEN);
    TestOne_UserProfileEnum((CPSZ)NULL,MAXPATHLEN);
    TestOne_UserProfileEnum((CPSZ)DIFFERENT_USERNAME,MAXPATHLEN);



    TestOne_UserProfileRead((CPSZ)USERNAME,(CPSZ)szHomedir2);

    TestOne_UserProfileQuery((CPSZ)USERNAME,(CPSZ)SZ("x:"),MAXPATHLEN);

    TestOne_UserProfileQuery((CPSZ)USERNAME,(CPSZ)SZ("lpt1"),MAXPATHLEN);

    TestOne_UserProfileSet(
	(CPSZ)USERNAME,
	(CPSZ)SZ("f:"),
	(CPSZ)SZ("\\\\foo\\bar"),
	USE_DISKDEV,
	0);

    TestOne_UserProfileQuery((CPSZ)USERNAME,(CPSZ)SZ("f:"),MAXPATHLEN);



    TestOne_UserProfileRead((CPSZ)DIFFERENT_USERNAME,(CPSZ)szHomedir2);

    TestOne_UserProfileQuery((CPSZ)DIFFERENT_USERNAME,(CPSZ)SZ("x:"),MAXPATHLEN);

    TestOne_UserProfileQuery((CPSZ)DIFFERENT_USERNAME,(CPSZ)SZ("lpt1"),MAXPATHLEN);

    TestOne_UserProfileSet(
	(CPSZ)DIFFERENT_USERNAME,
	(CPSZ)SZ("f:"),
	(CPSZ)SZ("\\\\foo\\bar"),
	USE_DISKDEV,
	0);

    TestOne_UserProfileQuery((CPSZ)DIFFERENT_USERNAME,(CPSZ)SZ("f:"),MAXPATHLEN);

    TestOne_UserProfileEnum((CPSZ)DIFFERENT_USERNAME,MAXPATHLEN);

    TestOne_UserProfileWrite((CPSZ)NULL,(CPSZ)szHomedir2);

    TestOne_UserProfileWrite((CPSZ)DIFFERENT_USERNAME,(CPSZ)szHomedir2);

    TestOne_UserProfileRead((CPSZ)USERNAME, (CPSZ)szHomedir3);

    TestOne_UserProfileRead((CPSZ)DIFFERENT_USERNAME,(CPSZ)szHomedir2);

    TestOne_UserProfileEnum((CPSZ)DIFFERENT_USERNAME,MAXPATHLEN);



    // szHomedir3/<PROFILE_DEFAULTFILE> is read-only
    TestOne_UserProfileRead((CPSZ)USERNAME, (CPSZ)szHomedir3);

    TestOne_UserProfileSet(
	(CPSZ)USERNAME,
	(CPSZ)SZ("f:"),
	(CPSZ)SZ("\\\\different\\bar"),
	USE_DISKDEV,
	0);

    TestOne_UserProfileSet(
	(CPSZ)USERNAME,
	(CPSZ)SZ("r:"),
	(CPSZ)SZ("\\\\delete\\me"),
	USE_DISKDEV,
	0);

    TestOne_UserProfileSet(
	(CPSZ)USERNAME,
	(CPSZ)SZ("s:"),
	(CPSZ)SZ("\\\\save\\me"),
	USE_DISKDEV,
	0);

// test profile entry deletion
    TestOne_UserProfileSet(
	(CPSZ)USERNAME,
	(CPSZ)SZ("r:"),
	(CPSZ)NULL,
	USE_DISKDEV,
	0);

    TestOne_UserProfileQuery((CPSZ)USERNAME,(CPSZ)SZ("f:"),MAXPATHLEN);

    TestOne_UserProfileEnum((CPSZ)USERNAME,MAXPATHLEN);

    TestOne_UserProfileWrite((CPSZ)USERNAME,(CPSZ)szHomedir3);
    TestOne_UserProfileWrite((CPSZ)USERNAME,(CPSZ)szHomedir3);






    TestOne_UserProfileFree();


    // test repeated Init/Free
    printf(SZ("Starting Init/Free test\n"));
    for (i = 0; i < 20; i++)
    {
        TestOne_UserProfileInit();
        TestOne_UserProfileFree();
        CHECKHEAP
    }
    printf(SZ("Finished Init/Free test\n"));

    printf(SZ("Finished UserProfile tests\n"));



#ifdef STICKY


// Sticky tests

    TestOne_StickyGetString((CPSZ)SZ("username"));

    TestOne_StickyGetBool((CPSZ)SZ("username"),TRUE);

    TestOne_StickyGetBool((CPSZ)SZ("username"),FALSE);

    TestOne_StickySetString((CPSZ)SZ("username"),(CPSZ)SZ("imauser"));

    TestOne_StickyGetString((CPSZ)SZ("username"));

    TestOne_StickyGetBool((CPSZ)SZ("username"),TRUE);

    TestOne_StickyGetBool((CPSZ)SZ("username"),FALSE);

    TestOne_StickySetString((CPSZ)SZ("username"),NULL);

    TestOne_StickyGetString((CPSZ)SZ("username"));

    TestOne_StickySetBool((CPSZ)SZ("flag"),TRUE);

    TestOne_StickyGetBool((CPSZ)SZ("flag"),TRUE);

    TestOne_StickyGetBool((CPSZ)SZ("flag"),FALSE);

    TestOne_StickySetBool((CPSZ)SZ("flag"),FALSE);

    TestOne_StickyGetBool((CPSZ)SZ("flag"),TRUE);

    TestOne_StickyGetBool((CPSZ)SZ("flag"),FALSE);

    TestOne_StickySetString((CPSZ)SZ("flag"),(CPSZ)SZ("other"));

    TestOne_StickyGetBool((CPSZ)SZ("flag"),TRUE);

    TestOne_StickyGetBool((CPSZ)SZ("flag"),FALSE);

#endif // STICKY


    CHECKHEAP

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\profile\test\testtime.cxx ===
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  12/02/90  created
 *  02/05/91  updated to new APIs
 */

#ifdef CODESPEC
/*START CODESPEC*/

/***********
TESTTIME.CXX
***********/

/****************************************************************************

    MODULE: TestTime.cxx

    PURPOSE: Timer tests for user profile APIs

    FUNCTIONS:

	This test tests the time cost of 80 calls to UserProfileRead,
	UserProfileSet, UserProfileWrite.

	Preliminary results indicate a time cost of approx. 7 seconds.
	Actual calls will average over 0.1 seconds, since the 7 seconds
	has the advantage of disk caching;  however, this does
	demonstrate that the calculation overhead is less than 0.1
	seconds.

	Subsequent to the switch away from CFGFILE, results indicate
	time costs of 3-4 seconds for this test.

    COMMENTS:

****************************************************************************/

/***************
end TESTTIME.CXX
***************/

/*END CODESPEC*/
#endif // CODESPEC



#include "test.hxx"		/* headers and internal routines */



/* internal manifests */

USHORT DoReadSetWrite(
    CPSZ cpszUsername,
    CPSZ cpszLanroot,
    CPSZ cpszDeviceName,
    CPSZ cpszRemoteName,
    short sAsgType,
    unsigned short usResType
    )
{
    USHORT usError;

    usError = UserProfileRead(cpszUsername, cpszLanroot);
    if (usError != NO_ERROR)
	return usError;

    usError = UserProfileSet(cpszUsername, cpszDeviceName, cpszRemoteName, sAsgType, usResType);
    if (usError != NO_ERROR)
	return usError;

    usError = UserProfileWrite(cpszUsername, cpszLanroot);
    if (usError != NO_ERROR)
	return usError;
}


/* functions: */


int main(int argc, char **argv)
{
    USHORT usError;
    INT    i;
    (void) argc;
    (void) argv;

    CHECKHEAP

    usError = UserProfileInit();
    if (usError)
    {
	printf(SZ("1: Error %d -- timer test aborted\n"),usError);
    }

    for (i = 0; i < 20; i++)
    {
        usError = DoReadSetWrite((CPSZ)SZ("TIMERUSERNAME"),(CPSZ)SZ("homedir1"),
	    (CPSZ)SZ("j:"),(CPSZ)SZ("\\newserv\share"),USE_DISKDEV,0);
        if (usError)
        {
	    printf(SZ("2: Error %d -- timer test aborted\n"),usError);
        }

        usError = DoReadSetWrite((CPSZ)SZ("TIMERUSERNAME"),(CPSZ)SZ("homedir1"),
	    (CPSZ)SZ("j:"),(CPSZ)NULL,0,0);
        if (usError)
        {
	    printf(SZ("3: Error %d -- timer test aborted\n"),usError);
        }

        usError = DoReadSetWrite((CPSZ)SZ("TIMERUSER2NAME"),(CPSZ)SZ("homedir2"),
	    (CPSZ)SZ("j:"),(CPSZ)SZ("\\newserv\share"),USE_DISKDEV,0);
        if (usError)
        {
	    printf(SZ("4: Error %d -- timer test aborted\n"),usError);
        }

        usError = DoReadSetWrite((CPSZ)SZ("TIMERUSER2NAME"),(CPSZ)SZ("homedir2"),
	    (CPSZ)SZ("j:"),(CPSZ)NULL,0,0);
        if (usError)
        {
	    printf(SZ("5: Error %d -- timer test aborted\n"),usError);
        }
    }

    usError = UserProfileFree();
    if (usError)
    {
	printf(SZ("6: Error %d -- timer test aborted\n"),usError);
    }

    CHECKHEAP

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\profile\test\tstintrn.cxx ===
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  11/14/90  created
 *  02/02/91  updated to changed API
 */

#ifdef CODESPEC
/*START CODESPEC*/

/*******
TEST.CXX
*******/

/****************************************************************************

    MODULE: Test.cxx

    PURPOSE: Tests for internal subroutines

    FUNCTIONS:

	see profilei.h

    COMMENTS:

	These tests are currently unusuable due to the problems detailed
	in test.hxx.

****************************************************************************/

/***********
end TEST.CXX
***********/

/*END CODESPEC*/
#endif // CODESPEC



#include "test.hxx"		/* headers and internal routines */



/* internal manifests */



/* functions: */


int main(int argc, char **argv)
{
    (void) argc;
    (void) argv;

    CHECKHEAP
    Test_CanonUsername();
    Test_CanonDeviceName();
    Test_BuildProfileFilePath();
    Test_BuildProfileEntry();
    Test_UnbuildProfileEntry();
    CHECKHEAP

    return 0;
}


#ifndef BUGBUG
// BUGBUG hack for DOS environment
_setargv()
{
}
_setenvp()
{
}
#endif // BUGBUG


// USHORT CanonUsername(
//     CPSZ   pszUsername,
//     PSZ    pszCanonBuffer,
//     USHORT usCanonBufferSize
//     );

VOID TestOne_CanonUsername(CPSZ cpszUsername)
{
    char szCanonBuffer[UNLEN+1];
    USHORT usError;

    usError = CanonUsername(cpszUsername,
	    (PSZ)szCanonBuffer,sizeof(szCanonBuffer));
    if (usError)
	sprintf(szCanonBuffer,SZ("<ERROR %d>"),usError);
    printf(SZ("CanonUsername(\"%s\") = \"%s\"\n"),
	    (cpszUsername==NULL) ? SZ("<NULL>") : (char *)cpszUsername,
	    szCanonBuffer);
}

VOID Test_CanonUsername()
{
    TestOne_CanonUsername((CPSZ)NULL);
    TestOne_CanonUsername((CPSZ)SZ("FooBarIsMyName"));
    TestOne_CanonUsername((CPSZ)SZ("*&^$^%(*%&^"));
    TestOne_CanonUsername((CPSZ)SZ("Hello there!!!"));
    TestOne_CanonUsername((CPSZ)SZ("ThisNameIsMuchTooLongToBeAUsername"));
}

// USHORT CanonDeviceName(
//     CPSZ   cpszDeviceName,
//     PSZ    pszCanonBuffer,
//     USHORT usCanonBufferSize
//     );

VOID TestOne_CanonDeviceName(CPSZ cpszDeviceName)
{
    char szCanonBuffer[UNLEN+1]; // left extra space for error msg
    USHORT usError;

    usError = CanonDeviceName(cpszDeviceName,
	    (PSZ)szCanonBuffer,DEVLEN+1);
		  // left extra space in szCanonBuffer for error msg

    if (usError)
	sprintf(szCanonBuffer,SZ("<ERROR %d>"),usError);
    printf(SZ("CanonDeviceName(\"%s\") = \"%s\"\n"),
	    (cpszDeviceName==NULL) ? SZ("<NULL>") : (char *)cpszDeviceName,
	    szCanonBuffer);
}

VOID Test_CanonDeviceName()
{
    TestOne_CanonDeviceName((CPSZ)SZ("lpt1"));
    TestOne_CanonDeviceName((CPSZ)SZ("LPT1"));
    TestOne_CanonDeviceName((CPSZ)SZ("lPt1"));
    TestOne_CanonDeviceName((CPSZ)SZ("\\dev\\lpt1"));
    TestOne_CanonDeviceName((CPSZ)SZ("lpt1:"));
    TestOne_CanonDeviceName((CPSZ)SZ("LpT1:"));
    TestOne_CanonDeviceName((CPSZ)SZ("com1:"));
    TestOne_CanonDeviceName((CPSZ)SZ("CoM1:"));
    TestOne_CanonDeviceName((CPSZ)SZ("COM1:"));
    TestOne_CanonDeviceName((CPSZ)SZ("CON:"));
    TestOne_CanonDeviceName((CPSZ)SZ("con:"));
    TestOne_CanonDeviceName((CPSZ)SZ("con"));
    TestOne_CanonDeviceName((CPSZ)SZ("NUL"));
    TestOne_CanonDeviceName((CPSZ)SZ("nul"));
    TestOne_CanonDeviceName((CPSZ)SZ("NUL:"));
    TestOne_CanonDeviceName((CPSZ)SZ("\\DEV\\NUL"));
    TestOne_CanonDeviceName((CPSZ)SZ("\\DEV\\NUL:"));
    TestOne_CanonDeviceName((CPSZ)SZ("D:"));
    TestOne_CanonDeviceName((CPSZ)SZ("d:"));
    TestOne_CanonDeviceName((CPSZ)SZ("d"));
    TestOne_CanonDeviceName((CPSZ)SZ("z:"));
    TestOne_CanonDeviceName((CPSZ)SZ("1:"));
    TestOne_CanonDeviceName((CPSZ)SZ("\\dev\\d"));
    TestOne_CanonDeviceName((CPSZ)SZ("\\dev\\d:"));
    TestOne_CanonDeviceName((CPSZ)SZ("ThisNameIsMuchTooLongToBeADeviceName"));
    TestOne_CanonDeviceName((CPSZ)SZ("a"));
    TestOne_CanonDeviceName((CPSZ)SZ("aa"));
    TestOne_CanonDeviceName((CPSZ)SZ("aaa"));
    TestOne_CanonDeviceName((CPSZ)SZ("aaa"));
    TestOne_CanonDeviceName((CPSZ)SZ("aaaa"));
    TestOne_CanonDeviceName((CPSZ)SZ("aaaaa"));
    TestOne_CanonDeviceName((CPSZ)SZ("aaaaaa"));
    TestOne_CanonDeviceName((CPSZ)SZ("aaaaaaa"));
    TestOne_CanonDeviceName((CPSZ)SZ("aaaaaaaa"));
    TestOne_CanonDeviceName((CPSZ)SZ("aaaaaaaaa"));
    TestOne_CanonDeviceName((CPSZ)SZ("aaaaaaaaaa"));
}


// USHORT BuildProfileFilePath(
//     CPSZ   cpszLanroot,
//     PSZ    pszPathBuffer,
//     USHORT usPathBufferSize
//     );

VOID TestOne_BuildProfileFilePath(
     CPSZ   cpszLanroot)
{
    char szPathBuffer[MAXPATHLEN];
    USHORT usError;

    usError = BuildProfileFilePath(cpszLanroot,
	    (PSZ)szPathBuffer,sizeof(szPathBuffer));
    if (usError)
	sprintf(szPathBuffer,SZ("<ERROR %d>"),usError);
    printf(SZ("BuildProfileFilePath(\"%s\") = \"%s\"\n"),
	    (cpszLanroot==NULL) ? SZ("<NULL>") : (char *)cpszLanroot,
            szPathBuffer);
}

VOID Test_BuildProfileFilePath()
{
    TestOne_BuildProfileFilePath((CPSZ)SZ("c:\\foo"));
    TestOne_BuildProfileFilePath((CPSZ)SZ("c:\\VERY_LONG_DIR_NAME"));
    TestOne_BuildProfileFilePath((CPSZ)SZ("c:\\thispathismuchtoolong\\_asdfasdfasdfsdafsdafsadfasdfasdfsadfsadfsadfsdafsdafsdafsadf\\sadfsdafsadfsadfsdfsdfasdfsdafsdafasdfsdafsadfsad\\fsadfadfsadfsdfsadfsadfasdfasdfasdfsadfsafsdafasd\\fsadfsadfsdafsdafsadfasdfasdfasdfsadfsadfasdfsadf\\asdfasdfsadfasdfasdfsadfasdfsadfsadfsadfsadfsadfa\\sdfasdfsadf"));
    TestOne_BuildProfileFilePath((CPSZ)SZ("relative\\path"));
    TestOne_BuildProfileFilePath((CPSZ)SZ("badpath%!#$%\5\12\200"));
}

VOID TestOne_BuildProfileEntry(
    CPSZ   cpszRemoteName,
    short  sAsgType,
    unsigned short usResType,
    USHORT usBufferSize // not greater than MAXPATHLEN
    )
{
    char szBuffer[MAXPATHLEN];
    USHORT usError;

    usError = BuildProfileEntry(
	cpszRemoteName,
	sAsgType,
	usResType,
	(PSZ)szBuffer,
	usBufferSize
	);
    if (usError)
	sprintf(szBuffer,SZ("<ERROR %d>"),usError);
    printf(SZ("BuildProfileEntry(\"%s\",%d,%d,buf,%d) = \"%s\"\n"),
	(char *)cpszRemoteName,sAsgType,usResType,usBufferSize,szBuffer);
    if (!usError)
        TestOne_UnbuildProfileEntry(MAXPATHLEN,(PSZ)szBuffer);
}

VOID Test_BuildProfileEntry()
{
    TestOne_BuildProfileEntry((PSZ)SZ("\\\\foo\\bar"),USE_DISKDEV,0,MAXPATHLEN);
    TestOne_BuildProfileEntry((PSZ)SZ("DSresourcename"),USE_DISKDEV,0,1);
    TestOne_BuildProfileEntry((PSZ)SZ("\\\\thisisaverylong\\printresourcename"),USE_SPOOLDEV,0,MAXPATHLEN);
    TestOne_BuildProfileEntry((PSZ)SZ("printeralias"),USE_SPOOLDEV,50,MAXPATHLEN);
    TestOne_BuildProfileEntry((PSZ)SZ("\\\\unknown\\resource"),50,0,MAXPATHLEN);
}

VOID TestOne_UnbuildProfileEntry(
    USHORT  usBufferSize, // not greater than MAXPATHLEN
    CPSZ    cpszValue
    )
{
    char szBuffer[MAXPATHLEN];
    short  sAsgType;
    unsigned short usResType;
    USHORT usError;

    usError = UnbuildProfileEntry(
	(PSZ)szBuffer,
	usBufferSize,
	&sAsgType,
	&usResType,
	cpszValue
	);
    printf(SZ("UnbuildProfileEntry(buf,%d,\"%s\") = %d\n"),
	    usBufferSize,(char *)cpszValue,usError);
    if (!usError)
	printf(SZ("\tszBuffer = \"%s\", sAsgType = %d, usResType = %d\n"),
		(char *)szBuffer, sAsgType, usResType);
}

VOID Test_UnbuildProfileEntry()
{
    TestOne_UnbuildProfileEntry(MAXPATHLEN,(CPSZ)SZ("generalstring"));
    TestOne_UnbuildProfileEntry(1,(CPSZ)SZ("generalstring"));
    TestOne_UnbuildProfileEntry(MAXPATHLEN,(CPSZ)SZ("generalstring(SPOOLDEV,NONE)"));
    TestOne_UnbuildProfileEntry(MAXPATHLEN,(CPSZ)SZ("generalstring(SPOOLDEV NONE)"));
    TestOne_UnbuildProfileEntry(MAXPATHLEN,(CPSZ)SZ("generalstring SPOOLDEV,NONE)"));
    TestOne_UnbuildProfileEntry(MAXPATHLEN,(CPSZ)SZ("generalstring(SPOOLDEV,NONE"));
    TestOne_UnbuildProfileEntry(MAXPATHLEN,(CPSZ)SZ("generalstring(SPOOLDEV)"));
    TestOne_UnbuildProfileEntry(MAXPATHLEN,(CPSZ)SZ("generalstring("));
    TestOne_UnbuildProfileEntry(MAXPATHLEN,(CPSZ)SZ("generalstring ,SPOOLDEV)NONE)"));
    TestOne_UnbuildProfileEntry(MAXPATHLEN,(CPSZ)SZ("generalstring ,SPOOLDEV))NONE"));
    TestOne_UnbuildProfileEntry(MAXPATHLEN,(CPSZ)SZ("generalstring(((SPOOLDEV,NONE)"));
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\reg\reg\regkey.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    REGKEY.CXX

       Win32 Registry class implementation


    CODEWORK ISSUES:

	1) WINREG.H should specify input TCHAR * parameters as
	   'const'; this would numerous cases where I had
           to cast the naturally occuring (const TCHAR *) to
           (TCHAR *) to please the compiler.

    FILE HISTORY:
	DavidHov    9/11/91	Created
	DavidHov   28-Jan-92	Converted to use Win32 APIs
        DavidHov   29-Feb-92    Added default security descriptor
        DavidHov    9-Mar-92    Eliminated internal dependence on HTOM
        DavidHov   16-May-92    CODEWORK:  Blocked usage of Titles per
                                DaveGi's mail.
        DavidHov   18-Oct-92    Removed internal tree, numerous
                                other related simplifications.

        JonN       21-Jan-2002  Remove REG_ENUM and log classes
*/

#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#include "lmui.hxx"
#include "base.hxx"
#include "string.hxx"
#include "uiassert.hxx"
#include "uitrace.hxx"

#include "uatom.hxx"			    //	Atom Management defs

#include "regkey.hxx"			    //	Registry defs

#define PATHSEPARATOR	TCH('\\')	    //	Mais oui, c'est UNICODE!
#define PATHSEPSTRING	SZ("\\")
#define UNCSEPARATOR    SZ("\\\\")          //  UNC name indicator
#define PATHMAX 	MAX_PATH	    //	Registry limits are the
#define REGNAMEMAX	MAX_PATH	    //	  same as NTFS

   //  Names used as symbolic top-of-tree for textual reporting
#define REG_NAME_CURRENT_USER	 SZ("User")
#define REG_NAME_LOCAL_MACHINE	 SZ("Machine")

#define REG_CLASS_UNKNOWN	 SZ("ClassUnknown")  // Default class name
#define REG_DEFAULT_SAM_ACCESS	 MAXIMUM_ALLOWED     // Default access
#define REG_DEFAULT_TYPE	 REG_SZ 	     // Default value type

#define REG_TITLE_VALUE_RESERVED (0)        //  The only allowed title value

/*******************************************************************
 *    Default SecurityDescriptor and handling functions            *
 *******************************************************************/

static
LPSECURITY_ATTRIBUTES initSecurityAttributes
    ( LPSECURITY_ATTRIBUTES pSecAttr )
{
    static SECURITY_DESCRIPTOR defaultSecurityDescriptor ;
    static BOOL fInit = FALSE ;

    if ( ! fInit )
    {
        InitializeSecurityDescriptor( & defaultSecurityDescriptor, 1 );
        fInit = TRUE ;
    }

    pSecAttr->nLength              = sizeof( SECURITY_ATTRIBUTES );
    pSecAttr->lpSecurityDescriptor = & defaultSecurityDescriptor ;
    pSecAttr->bInheritHandle       = FALSE ;
    return pSecAttr ;
}

/*******************************************************************

    NAME:	REG_KEY::HandlePrefix

    SYNOPSIS:   Extract the optional machine name and
                top level name token from a REG_KEY name string.

    ENTRY:	const NLS_STR &       full name of key

    EXIT:       HKEY * pHkey          location to store static handle
                NLS_STR *             location to store machine name
                                      or "" (empty string)
                NLS_STR *             location to store remainder
                                      of string after prefix

    RETURNS:	BOOL            TRUE if prefix matched.

    NOTES:

    HISTORY:
	        DavidHov   10-Oct-92  Created
********************************************************************/
BOOL REG_KEY :: HandlePrefix (
    const NLS_STR & nlsKeyName,
    HKEY * pHkey,
    NLS_STR * pnlsMachineName,
    NLS_STR * pnlsRemainder )
{
    NLS_STR nlsUnc( UNCSEPARATOR ) ;
    const TCHAR * pszTemp ;
    const TCHAR * pszRemainder ;
    INT cKeyName, cchTemp ;

    static struct {
        const TCHAR * pszKeyName ;
        HKEY hKey ;
    } keyNames [] =
    {
        { REG_NAME_LOCAL_MACHINE, HKEY_LOCAL_MACHINE },
        { REG_NAME_CURRENT_USER,  HKEY_CURRENT_USER  },
        { NULL,                   NULL               }
    };

    //  Copy the given string into both result areas.  This
    //  is by far the easiest way to use the somewhat obscure
    //  NLS_STR "primitives".

    *pHkey = NULL ;

    if ( pnlsMachineName->CopyFrom( nlsKeyName ) )
        return FALSE ;
    if ( pnlsRemainder->CopyFrom( nlsKeyName ) )
        return FALSE ;

    ISTR isName( *pnlsMachineName ),
         isPos( *pnlsMachineName ) ;

    //  See if the name begins with UNC

    isName += nlsUnc.QueryTextLength() ;

    if ( pnlsMachineName->strncmp( nlsUnc, isName ) == 0 )
    {
        //  Find the trailing delmiter of the machine name;
        //  remove the remaining characters.

        if ( ! pnlsMachineName->strchr( & isPos, PATHSEPARATOR, isName ) )
            return FALSE ;
        pnlsMachineName->DelSubStr( isPos ) ;

        //  Remove the UNC name and the separator from the remainder string

        ISTR is1( *pnlsRemainder ),
             is2( *pnlsRemainder ) ;

        is2 += pnlsMachineName->QueryTextLength() + 1 ;
        pnlsRemainder->DelSubStr( is1, is2 ) ;
    }
    else
    {
        //  It's not UNC; zap the output machine name.

        pnlsMachineName->CopyFrom( SZ("") );
    }

    //  Loop through the table trying to match the head
    //  of the remainder string with one of the static
    //  names.

    pszRemainder = pnlsRemainder->QueryPch() ;

    for ( cKeyName = 0 ;
          pszTemp = keyNames[cKeyName].pszKeyName ;
          cKeyName++ )
    {
        cchTemp = ::strlenf( pszTemp ) ;

        //  If the strings match and it's either end-of-string or the
        //  next character is a '\', then this is a hit.

        if (    (::strncmpf( pszTemp, pszRemainder, cchTemp ) == 0)
             && (   (cchTemp == (INT)pnlsRemainder->QueryTextLength())
                 || (*(pszRemainder + cchTemp) == PATHSEPARATOR)) )
        {
             break ;
        }
    }
    if ( keyNames[cKeyName].pszKeyName == NULL )
        return FALSE ;

    ISTR isRem( *pnlsRemainder ),
         isRemEnd( *pnlsRemainder ) ;

    isRemEnd += cchTemp ;

    // If there's a delimiter, remove it also.

    if ( ! isRemEnd.IsLastPos() )
        ++isRemEnd;

    pnlsRemainder->DelSubStr( isRem, isRemEnd ) ;
    *pHkey = keyNames[cKeyName].hKey ;

    return TRUE ;
}


/*******************************************************************

    NAME:	REG_KEY_CREATE_STRUCT
                REG_KEY_INFO_STRUCT
                REG_VALUE_INFO_STRUCT

    SYNOPSIS:	Simple constuctors for data items with imbedded
                NLS_STRs.

    ENTRY:	Nothing

    EXIT:	Nothing

    RETURNS:	Nothing         Use QueryError()

    NOTES:

    HISTORY:
	        DavidHov   10-Oct-92  Created
********************************************************************/
REG_KEY_CREATE_STRUCT :: REG_KEY_CREATE_STRUCT ()
{
    if ( nlsClass.QueryError() )
    {
        ReportError( nlsClass.QueryError() ) ;
    }
}

REG_KEY_INFO_STRUCT :: REG_KEY_INFO_STRUCT ()
{
    APIERR err ;

    if ( (err = nlsClass.QueryError()) == 0 )
    {
        err = nlsName.QueryError() ;
    }

    if ( err )
    {
        ReportError( err ) ;
    }
}

REG_VALUE_INFO_STRUCT :: REG_VALUE_INFO_STRUCT ()
{
    if ( nlsValueName.QueryError() )
    {
        ReportError( nlsValueName.QueryError() ) ;
    }
}

/*******************************************************************

    NAME:	REG_KEY::NameChild

    SYNOPSIS:   Create the full name of this child node by
                appending the sub-key name onto the name of the
                parent.

    ENTRY:	REG_KEY * pRkChild         descendent REG_KEY
                NLS_STR & nlsSubKey        partial (sub) key name

    EXIT:       pRkChild->_nlsKeyName updated

    RETURNS:    APIERR if string copy/append operation fails

    NOTES:

    HISTORY:
		DavidHov   10/18/92   Created

********************************************************************/
APIERR REG_KEY :: NameChild (
    REG_KEY * pRkChild,
    const NLS_STR & nlsSubKey ) const
{
    APIERR err = pRkChild->_nlsKeyName.CopyFrom( _nlsKeyName ) ;

    if ( err == 0 )
    {
        err = pRkChild->_nlsKeyName.Append( PATHSEPSTRING ) ;
    }

    if ( err == 0 )
    {
        err = pRkChild->_nlsKeyName.Append( nlsSubKey ) ;
    }
    return err ;
}

/*******************************************************************

    NAME:	REG_KEY::LeafKeyName

    SYNOPSIS:   Return a pointer to the final segment of a key name

    ENTRY:	nothing

    EXIT:       nothing

    RETURNS:    const TCHAR * --> first character beyond last '\'
                                in full key name.

    NOTES:

    HISTORY:
		DavidHov   10/18/92   Created

********************************************************************/
const TCHAR * REG_KEY :: LeafKeyName () const
{
    ISTR isName( _nlsKeyName ) ;
    const TCHAR * pchBeyondLastSlash = _nlsKeyName.QueryPch() ;

    if ( _nlsKeyName.strrchr( & isName, PATHSEPARATOR ) )
    {
        ++isName;
        pchBeyondLastSlash = _nlsKeyName.QueryPch( isName ) ;
    }
    return pchBeyondLastSlash ;
}

/*******************************************************************

    NAME:	REG_KEY::ParentName

    SYNOPSIS:   Construct the name of this key's parent key

    ENTRY:	NLS_STR *       pointer to string to store into

    EXIT:       string updated

    RETURNS:    APIERR if string search opreation fails

    NOTES:

    HISTORY:
		DavidHov   10/18/92   Created

********************************************************************/
APIERR REG_KEY :: ParentName ( NLS_STR * pnlsParentName ) const
{
    ISTR isStart( *pnlsParentName ) ;
    APIERR err ;

    do  // Pseudo-loop
    {
        if ( err = pnlsParentName->CopyFrom( _nlsKeyName ) )
            break ;

        if ( ! pnlsParentName->strrchr( & isStart, PATHSEPARATOR ) )
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }
        pnlsParentName->DelSubStr( isStart ) ;

    } while ( FALSE ) ;

    return err ;
}

/*******************************************************************

    NAME:	REG_KEY::OpenParent

    SYNOPSIS:   Construct a REG_KEY representing the parent
                of this key.

    ENTRY:	REGSAM rsDesired        access desired

    EXIT:       nothing

    RETURNS:    REG_KEY *  --> newly created key or NULL

    NOTES:

    HISTORY:
		DavidHov   10/18/92   Created

********************************************************************/
REG_KEY * REG_KEY :: OpenParent ( REGSAM rsDesired )
{
    NLS_STR nlsParentName ;
    REG_KEY * pRkParent = NULL ;

    if ( (_lApiErr = ParentName( & nlsParentName )) == 0 )
    {
        pRkParent = new REG_KEY( nlsParentName, rsDesired ) ;
        _lApiErr = pRkParent == NULL
                 ? ERROR_NOT_ENOUGH_MEMORY
                 : pRkParent->QueryError() ;
    }

    if ( _lApiErr )
    {
        delete pRkParent ;
        pRkParent = NULL ;
    }
    return pRkParent ;
}

/*******************************************************************

    NAME:	REG_KEY::OpenChild

    SYNOPSIS:	PRIVATE.   Open a node in the Regsitry.

    ENTRY:      HKEY   hkParent         HKEY of parent key
                REGSAM rsDesired	Desired access to registry key
		DWORD  dwOptions	RegOpenKey options.

    EXIT:	Nothing

    RETURNS:	TRUE if successful; see _lApiErr otherwise.

    NOTES:      _nlsKeyName is still just the subordinate key name,
                not the full key name; the caller must do this

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/
APIERR REG_KEY :: OpenChild (
    REG_KEY * pRkChild,
    const NLS_STR & nlsSubKey,
    REGSAM rsDesired,
    DWORD dwOptions )
{
    APIERR err = ::RegOpenKeyEx( *this,
                               (TCHAR *) nlsSubKey.QueryPch(),
			       dwOptions,
			       rsDesired,
			       & pRkChild->_hKey ) ;
    if ( err == 0 )
    {
        err = NameChild( pRkChild, nlsSubKey ) ;
    }
    return err ;
}

/*******************************************************************

    NAME:	REG_KEY::CreateChild

    SYNOPSIS:	Create a child node for this node.  (private)

    ENTRY:      REG_KEY * pRkNew             REG_KEY a'borning
		REG_KEY_CREATE_STRUCT *      ptr to auxillary creation
					        structure

    EXIT:	pRkNew fields updated

    RETURNS:	APIERR

    NOTES:      _nlsKeyName is still just the subordinate key name,
                not the full key name; the caller must do this

                APIERR is not stored into parent node, since
		it's not really a parental fault.

    HISTORY:
		DavidHov   9/20/91    Created
                DavidHov  10/18/92    Modified

********************************************************************/
APIERR REG_KEY :: CreateChild
    ( REG_KEY * pRkNew,
      const NLS_STR & nlsSubKey,
      REG_KEY_CREATE_STRUCT * prncStruct ) const
{
    SECURITY_ATTRIBUTES secAttr ;
    SECURITY_ATTRIBUTES * pSecAttr ;
    APIERR err ;
    const TCHAR * pszClassName ;

    //  Create a default SECURITY_ATTRIBUTES if none is specified

    pSecAttr = prncStruct->pSecAttr != NULL
             ? prncStruct->pSecAttr
             : initSecurityAttributes( & secAttr ) ;

    //  Default the security if unspecified

    if ( prncStruct->regSam == 0 )
	prncStruct->regSam = REG_DEFAULT_SAM_ACCESS ;

    //  Default the class name if unspecified

    pszClassName = prncStruct->nlsClass.QueryTextLength() > 0
                 ? prncStruct->nlsClass.QueryPch()
                 : REG_CLASS_UNKNOWN ;

    //  Create the key

    err = ::RegCreateKeyEx( *this,
			    (TCHAR *) nlsSubKey.QueryPch(),
                            REG_TITLE_VALUE_RESERVED,
			    (TCHAR *) pszClassName,
			    prncStruct->ulOptions,
			    prncStruct->regSam,
			    pSecAttr,
			    & pRkNew->_hKey,
			    & prncStruct->ulDisposition ) ;

    if ( err == 0 )
    {
        //  Give the child a name.

        err = NameChild( pRkNew, nlsSubKey ) ;
    }
    return err ;
}


/*******************************************************************

    NAME:	REG_KEY::Close

    SYNOPSIS:	Close the underlying handle. (private)

    ENTRY:	Nothing

    EXIT:	Nothing

    RETURNS:	APIERR	from  RegCloseKey()  operation

    NOTES:

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/

APIERR REG_KEY :: Close ()
{
    _lApiErr = 0 ;

    if (    _hKey != NULL
         && _hKey != HKEY_CURRENT_USER
         && _hKey != HKEY_LOCAL_MACHINE )
    {
	_lApiErr = ::RegCloseKey( _hKey ) ;
	_hKey = NULL ;
    }
    return _lApiErr ;
}

/*******************************************************************

    NAME:	REG_KEY::REG_KEY

    SYNOPSIS:	Constructor using only an HKEY.

    ENTRY:	hKey	           either HKEY_CURRENT_USER
			               or HKEY_LOCAL_MACHINE
                const NLS_STR *    optional subkey name
                rsDesired          optional access mask

    EXIT:

    RETURNS:

    NOTES:	This routine is used to create REG_KEYs representing
		the primary Registry access points; i.e., those
		represented by statically defined handles.

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/
REG_KEY :: REG_KEY (
    HKEY hKey,
    REGSAM rsDesired )
    : _lApiErr( 0 ),
      _amMask( rsDesired ),
      _hKey( hKey )
{
    const TCHAR * pszKeyName = NULL ;

    if ( _lApiErr = _nlsKeyName.QueryError() )
    {
        ReportError( _lApiErr ) ;
        return ;
    }

    if ( hKey == HKEY_LOCAL_MACHINE )
    {
	pszKeyName = REG_NAME_LOCAL_MACHINE ;
    }
    else
    if ( hKey == HKEY_CURRENT_USER )
    {
        pszKeyName = REG_NAME_CURRENT_USER ;
    }
    else
    {
	 UIASSERT( ! SZ("Invalid attempt to create static REG_KEY") ) ;
	 _lApiErr = ERROR_INVALID_PARAMETER ;
    }

    //  See if the HKEY given was one of the allowable ones

    if ( _lApiErr == 0 )
    {
        _lApiErr = _nlsKeyName.CopyFrom( pszKeyName ) ;
    }

    if ( _lApiErr )
    {
        ReportError( _lApiErr ) ;
    }
}

/*******************************************************************

    NAME:	REG_KEY::REG_KEY

    SYNOPSIS:	Standard constructor of a REG_KEY.  Using a currently
		opened REG_KEY (such as REG_KEY_LOCAL_MACHINE), open
		a subkey of that node.

    ENTRY:	regNode     reference to extant REG_KEY

	        nlsSubKey   name of subkey to open

		amMask	    special Registry access mask bits;
			    default 0

		poaAttr     pointer to object attributes structure
			    default NULL

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/
REG_KEY :: REG_KEY (
    REG_KEY & regNode,
    const NLS_STR & nlsSubKey,
    REGSAM amMask )
    :_lApiErr( 0 ),
     _hKey( NULL ),
     _amMask( amMask )
{
    if ( _lApiErr = _nlsKeyName.QueryError() )
    {
        ReportError( _lApiErr ) ;
        return ;
    }

    _lApiErr = regNode.OpenChild( this, nlsSubKey, amMask ) ;

    if ( _lApiErr )
    {
        ReportError( _lApiErr ) ;
    }
}

/*******************************************************************

    NAME:	REG_KEY::REG_KEY

    SYNOPSIS:	Constructor which creates a new sub-key


    ENTRY:	regNode     reference to extant REG_KEY

		nlsSubKey   name of sub-key

		prcCreate   pointer to REG_KEY_CREATE_STRUCT
			    with all the other parameters.

    EXIT:	Nothing

    RETURNS:

    NOTES:

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/

REG_KEY :: REG_KEY (
    REG_KEY & regNode,
    const NLS_STR & nlsSubKey,
    REG_KEY_CREATE_STRUCT * prcCreate )
    : _lApiErr( 0 ),
      _hKey( NULL )
{
    if ( _lApiErr = _nlsKeyName.QueryError() )
    {
        ReportError( _lApiErr ) ;
        return ;
    }

    _lApiErr = regNode.CreateChild( this, nlsSubKey, prcCreate ) ;

    if ( _lApiErr  )
    {
	ReportError( _lApiErr ) ;
    }
}


/*******************************************************************

    NAME:	REG_KEY::REG_KEY

    SYNOPSIS:	Constructor of a key on another machine.

    ENTRY:	hKey		   one of HKEY_LOCAL_MACHINE or
				   HKEY_CURRENT_USER
		pszMachineName	   name of remote machine:
                                   MUST BE IN UNC FORM!, \\MACHINENAME

    EXIT:

    RETURNS:

    NOTES:      This constructor should not be used to address the local
                machine.

                This constructor is used to begin access to the
		Registry on a remote machine.  Only the given static
		HKEYs can be used to create the first REG_KEY; after
		that, the created REG_KEY can be used to access
		any other points within the remote Registry.

    HISTORY:
		DavidHov   9/20/91    Created
		JonN       5/06/92    Implemented
                DavidHov   6/1/92     Revised implementation

********************************************************************/

REG_KEY :: REG_KEY (
    HKEY hKey,
    const TCHAR * pszMachineName,
    REGSAM rsDesired )
    : _lApiErr( 0 ),
      _hKey( NULL ),
      _amMask( rsDesired )
{
    const TCHAR * pszBaseName = NULL ;

    if ( _lApiErr = _nlsKeyName.QueryError() )
    {
        ReportError( _lApiErr ) ;
        return ;
    }

    if ( pszMachineName != NULL )
    {
        //
        //  Build up a base registry name of the from:
        //     \\MachineName\Machine\ThisIsMySubKey
        //
        _nlsKeyName.Append( pszMachineName ) ;
        _nlsKeyName.Append( PATHSEPSTRING ) ;
    }

    if ( hKey == HKEY_LOCAL_MACHINE )
    {
	pszBaseName = REG_NAME_LOCAL_MACHINE ;
    }
    else
    if ( hKey == HKEY_CURRENT_USER )
    {
	pszBaseName = REG_NAME_CURRENT_USER ;
    }

    if ( pszBaseName == NULL )
    {
        _lApiErr = ERROR_INVALID_PARAMETER ;
    }
    else
    {
        _nlsKeyName.Append( pszBaseName ) ;

        if ( (_lApiErr = _nlsKeyName.QueryError()) == 0 )
        {
            _lApiErr = ::RegConnectRegistry( (LPTSTR) pszMachineName,
                                             hKey,
                                             &_hKey );
        }
    }

    if ( _lApiErr )
    {
        ReportError( _lApiErr ) ;
    }
}

/*******************************************************************

    NAME:       REG_KEY::OpenByName

    SYNOPSIS:   Open a Registry handle using only a name string

    ENTRY:      const NLS_STR & nlsKeyName      full name of key
                REGSAM rsDesired                access desired

    EXIT:       Nothing

    RETURNS:    Nothing

    NOTES:      This routine is based upon the manifests:

                      REG_NAME_CURRENT_USER   "User"
                      REG_NAME_LOCAL_MACHINE  "Machine"

                These are pseudonyms for HKEY_CURRENT_USER and
                HKEY_LOCAL_MACHINE, respectively.  They are prefixed
                onto names produced by QueryName() if "full names" are
                desired.  They are NOT exposed, since all such name
                strings should only be obtained from REG_KEY::QueryName().

                This function is useful for restoring Registry locations
                which have previously been converted to textual form.
                For example, an app calls QueryName(), and writes
                the result into a disk file.  Later, the app reloads
                this information and wants to reconstruct the
                corresponding REG_KEY.  This constructor provides
                this support.

    HISTORY:    DavidHov    2/13/92     Created

********************************************************************/
APIERR REG_KEY :: OpenByName (
    const NLS_STR & nlsKeyName,
    REGSAM rsDesired )
{
    HKEY hKey = NULL ;
    NLS_STR nlsName,
            nlsServer ;

    //  Strip  "[\\Server\]User\" or "[\\Server\]Machine\" from
    //  the given name.   If successful, check if it's remote; do
    //  the open accordingly.

    if ( ! HandlePrefix( nlsKeyName, & hKey, & nlsServer, & nlsName ) )
    {
        _lApiErr = ERROR_INVALID_PARAMETER ;
    }
    else
    if ( nlsServer.QueryTextLength() == 0 )
    {
        // Open a local key.

        REG_KEY rkTop( hKey, rsDesired ) ;

        if ( (_lApiErr = rkTop.QueryError()) == 0 )
           _lApiErr = rkTop.OpenChild( this, nlsName, rsDesired ) ;
    }
    else
    {
        //  Connect to a remote server.

        REG_KEY rkTop( hKey, nlsServer.QueryPch(), rsDesired ) ;

        if ( (_lApiErr = rkTop.QueryError()) == 0 )
           _lApiErr = rkTop.OpenChild( this, nlsName, rsDesired ) ;
    }

    return _lApiErr ;
}

/*******************************************************************

    NAME:       REG_KEY::REG_KEY

    SYNOPSIS:   Construct a REG_KEY from a pure string name.

    ENTRY:      NLS_STR

    EXIT:       Nothing

    RETURNS:    Nothing

    NOTES:

    HISTORY:    DavidHov    2/13/92     Created

********************************************************************/
REG_KEY :: REG_KEY (
    const NLS_STR & nlsKeyName,
    REGSAM amMask )
    :_lApiErr( 0 ),
     _hKey( NULL ),
     _amMask( amMask )
{
    HKEY hKey = NULL ;
    NLS_STR * pnlsName = NULL ;

    if ( _lApiErr = _nlsKeyName.QueryError() )
    {
        ReportError( _lApiErr ) ;
        return ;
    }

    _lApiErr = OpenByName( nlsKeyName, amMask ) ;

    if ( _lApiErr )
    {
        ReportError( _lApiErr ) ;
    }
}


/*******************************************************************

    NAME:	REG_KEY::REG_KEY

    SYNOPSIS:	Copy constructor for REG_KEY.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:	

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/

REG_KEY :: REG_KEY ( REG_KEY & regNode )
    :_lApiErr( 0 ),
     _hKey( NULL ),
     _amMask( regNode._amMask )
{
    if ( _lApiErr = _nlsKeyName.QueryError() )
    {
        ReportError( _lApiErr ) ;
        return ;
    }

    _lApiErr = OpenByName( regNode._nlsKeyName, _amMask ) ;

    if ( _lApiErr )
        ReportError( _lApiErr ) ;
}


/*******************************************************************

    NAME:	REG_KEY::~ REG_KEY

    SYNOPSIS:	Destructor

    ENTRY:	nothing

    EXIT:

    RETURNS:	nothing

    NOTES:	Destroy a REG_KEY.  If it represents an open HKEY,
		close the key.	If the node has children, their subkey
		name strings are modified to have this node's subkey
		name as a prefix, and they become children of this
		node's parent.

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/
REG_KEY :: ~ REG_KEY ()
{
    Close() ;
}

/*******************************************************************

    NAME:	REG_KEY::Flush

    SYNOPSIS:	Commit any changes to the given node to disk.

    ENTRY:	Nothing.

    EXIT:	Nothing.

    RETURNS:	Error associated with operation.

    NOTES:

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/

APIERR REG_KEY :: Flush ()
{
    return ::RegFlushKey( _hKey ) ;
}

/*******************************************************************

    NAME:	REG_KEY::Delete

    SYNOPSIS:	Delete the Registry node represented by this REG_KEY.

		It is the caller's responsibility to delete all
		subkeys from this key.	The Registry will delete all
		values for this key automatically.

    ENTRY:	Nothing.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/

APIERR REG_KEY :: Delete ()
{
    APIERR err = 0 ;

    REG_KEY * prkParent = OpenParent() ;

    if ( prkParent == NULL )
    {
        err = ERROR_NOT_ENOUGH_MEMORY ;
    }
    else
    {
        err = prkParent->QueryError() ;
    }

    if ( err == 0 )
    {
        Close();

        err = ::RegDeleteKey( prkParent->_hKey,
                              (TCHAR *) LeafKeyName() ) ;
    }
    delete prkParent ;
    return err ;
}


/*******************************************************************

    NAME:	REG_KEY::QueryName

    SYNOPSIS:	Fill in the caller's NLS_STR with a complete
		path name back to the root node.  The root
                node name is included if 'fComplete' is TRUE.

    ENTRY:	NLS_STR *     -->  String to fill in
		BOOL fComplete	   if TRUE, top node name appended.

    EXIT:	string constructed.

    RETURNS:	APIERR	from NLS_STR construction.

    NOTES:

    HISTORY:
		DavidHov   9/20/91    Created
		DavidHov  10/20/92    Modified to handle UNC names

********************************************************************/

APIERR REG_KEY :: QueryName ( NLS_STR * pnlsName, BOOL fComplete ) const
{
    const TCHAR * pszKeyName = _nlsKeyName.QueryPch() ;

    if ( ! fComplete )
    {
        //  Determine the number of slashes we're looking for.

        INT cchDelims = 1,
            cchUnc = ::strlenf( UNCSEPARATOR ) ;

        if ( ::strncmpf( pszKeyName, UNCSEPARATOR, cchUnc ) == 0 )
        {
            // UNC name; there's three more slashes to eat
            cchDelims += cchUnc + 1 ;
        }

        // Strip off the topmost name ("[\\Server\]User\" or "[\\Server\]Machine\")

        for ( ; *pszKeyName != 0 && cchDelims ; pszKeyName++ )
        {
            if ( *pszKeyName == PATHSEPARATOR )
                cchDelims-- ;
        }
    }

    return pnlsName->CopyFrom( pszKeyName ) ;
}

/*******************************************************************

    NAME:	REG_KEY::QueryKeyName

    SYNOPSIS:	Fill in the caller's NLS_STR with final
                portion of this key's name.		

    ENTRY:	NLS_STR *     -->  String to fill in

    EXIT:	string constructed.

    RETURNS:	APIERR	from NLS_STR construction.

    NOTES:

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/

APIERR REG_KEY :: QueryKeyName ( NLS_STR * pnlsName ) const
{
    return pnlsName->CopyFrom( LeafKeyName() ) ;
}


/*******************************************************************

    NAME:	REG_KEY::QueryLocalMachine

    SYNOPSIS:	Return a new REG_KEY representing
		the top of tree for the local machine.

    ENTRY:	nothing

    EXIT:	pointer or NULL.

    RETURNS:	Pointer to requested REG_KEY.

    NOTES:

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/

REG_KEY * REG_KEY :: QueryLocalMachine ( REGSAM rsDesired )
{
    return new REG_KEY( HKEY_LOCAL_MACHINE, rsDesired ) ;
}


/*******************************************************************

    NAME:	REG_KEY::QueryCurrentUser

    SYNOPSIS:	Return a new REG_KEY representing
		the top of tree for the current user.

    ENTRY:	nothing

    EXIT:	pointer or NULL.

    RETURNS:

    NOTES:

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/

REG_KEY * REG_KEY :: QueryCurrentUser ( REGSAM rsDesired )
{
    return new REG_KEY( HKEY_CURRENT_USER, rsDesired ) ;
}

/*******************************************************************

    NAME:	REG_KEY::QueryInfo

    SYNOPSIS:	Query information about a node in the Regsitry.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/

APIERR REG_KEY :: QueryInfo ( REG_KEY_INFO_STRUCT * pRegInfoStruct )
{
    TCHAR szClassName [ REGNAMEMAX ] ;
    ULONG ulCbClassName = REGNAMEMAX ; // JonN 1/21/02 PREFIX 112068
    APIERR err ;

    _lApiErr = ::RegQueryInfoKey( _hKey,
				  szClassName,
				  & ulCbClassName,
				  NULL,
				  & pRegInfoStruct->ulSubKeys,
				  & pRegInfoStruct->ulMaxSubKeyLen,
				  & pRegInfoStruct->ulMaxClassLen,
				  & pRegInfoStruct->ulValues,
				  & pRegInfoStruct->ulMaxValueIdLen,
				  & pRegInfoStruct->ulMaxValueLen,
                                  & pRegInfoStruct->ulSecDescLen,
				  & pRegInfoStruct->ftLastWriteTime );

    if ( (err = _lApiErr) == 0 )
    {
	pRegInfoStruct->nlsName = _nlsKeyName ;
        if ( pRegInfoStruct->nlsName.QueryError() )
        {
            err = pRegInfoStruct->nlsName.QueryError() ;
        }
        else
        {
	    pRegInfoStruct->nlsClass = szClassName ;
            if ( pRegInfoStruct->nlsName.QueryError() )
            {
                err = pRegInfoStruct->nlsName.QueryError() ;
            }
        }
    }
    return err ;
}


/*******************************************************************

    NAME:	REG_KEY::QueryValue

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:	The member functions QueryValue() and SetValue()
		use a common structure to simplify the interface:
		REG_VALUE_INFO_STRUCT.	Its fields are used by
		QueryValue() as:

		    huaValueName	IN:  atom for name
		    ulTitle		OUT: title index
		    ulType		OUT: type scalar
		    pwcData		IN:  location to store data
		    ulDataLength	IN:  room available at *pwcData
		    ulDataLengthOut	OUT: length of value data in buffer

		In other words, the value data stored into
		the data buffer given as input. The amount of data present
		will be stored into "ulDataLengthOut".	If a size
		error occurs,  ulDataLengthOut will contain the amount of
		data that was present, and the contents of *pwcData are
		undefined.


    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/
APIERR REG_KEY :: QueryValue ( REG_VALUE_INFO_STRUCT * pRegValueInfo )
{
    pRegValueInfo->ulDataLengthOut = pRegValueInfo->ulDataLength ;

    _lApiErr = ::RegQueryValueEx( _hKey,
				(TCHAR *) pRegValueInfo->nlsValueName.QueryPch(),
				NULL,
				& pRegValueInfo->ulType,
				pRegValueInfo->pwcData,
				& pRegValueInfo->ulDataLengthOut );

    return _lApiErr ;
}

/*******************************************************************

    NAME:	REG_KEY::SetValue

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      As of 5/14/92, this routine allows the setting of a
                zero-length string.

    HISTORY:
		DavidHov   9/20/91    Created
                DavidHov   5/14/92    Changed for zero length data.

********************************************************************/
APIERR REG_KEY :: SetValue ( REG_VALUE_INFO_STRUCT * pRegValueInfo )
{
    TCHAR chNull = 0 ;
    DWORD cbData = pRegValueInfo->ulDataLength ;
    LPBYTE pbData = pRegValueInfo->pwcData ;

    //  If the data length is zero, replace it with a single NUL
    //   byte/word.  Use a TCHAR so it will work for either the
    //   A or W form of the API.

    if ( cbData == 0 )
    {
        pbData = (LPBYTE) & chNull ;
        cbData = sizeof chNull ;
    }

    if ( pRegValueInfo->ulType == REG_NONE )
	pRegValueInfo->ulType = REG_DEFAULT_TYPE ;

    _lApiErr = ::RegSetValueEx( _hKey,
				(TCHAR *) pRegValueInfo->nlsValueName.QueryPch(),
                                REG_TITLE_VALUE_RESERVED,
				pRegValueInfo->ulType,
				pbData,
				cbData );

    return _lApiErr ;
}

/*******************************************************************

    NAME:	REG_KEY::DeleteValue

    SYNOPSIS:   Delete a value using an NLS_STR name

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/
APIERR REG_KEY :: DeleteValue ( const NLS_STR & nlsValueName )
{
    _lApiErr = ::RegDeleteValue( _hKey,
				 (TCHAR *) nlsValueName.QueryPch() ) ;
    return _lApiErr ;
}


#if 0
// JonN 1/21/02 removed REG_ENUM and log classes

/*******************************************************************

    NAME:	REG_ENUM::REG_ENUM

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/
REG_ENUM :: REG_ENUM ( REG_KEY & regNode )
    : _rnNode( regNode ),
    _ulIndex( 0 ),
    _usLastErr( NERR_Success ),
    _eType( RENUM_NONE )
{
}

REG_ENUM :: ~ REG_ENUM ()
{
}

VOID REG_ENUM :: Reset ()
{
    _usLastErr = NERR_Success ;
    _ulIndex = 0 ;
    _eType = RENUM_NONE ;
}

/*******************************************************************

    NAME:	REG_ENUM::NextSubKey

    SYNOPSIS:	Obtain information about the next REG_KEY sub-key
		attached to the node used during construction.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/
APIERR REG_ENUM :: NextSubKey ( REG_KEY_INFO_STRUCT * pRegInfoStruct )
{
    TCHAR szKeyName   [REGNAMEMAX + 2] ;
    ULONG cbSzKeyName = REGNAMEMAX * sizeof (TCHAR) ;
    LONG lApiErr ;

    if ( _eType != RENUM_NONE && _eType != RENUM_KEYS )
    {
        return ERROR_INVALID_PARAMETER ;
    }

    szKeyName[0] = 0 ;

    lApiErr = ::RegEnumKeyEx( _rnNode._hKey,
			    _ulIndex,
			    szKeyName,
			    & cbSzKeyName,
			    NULL,
			    NULL,
			    NULL,
			    & pRegInfoStruct->ftLastWriteTime );

    if ( lApiErr == 0 )
    {
	pRegInfoStruct->nlsName 	  = szKeyName ;
	pRegInfoStruct->nlsClass	  = SZ("") ;
	pRegInfoStruct->ulSubKeys	  = REG_VALUE_NOT_KNOWN ;
	pRegInfoStruct->ulMaxSubKeyLen	  = REG_VALUE_NOT_KNOWN ;
	pRegInfoStruct->ulValues	  = REG_VALUE_NOT_KNOWN ;
	pRegInfoStruct->ulMaxValueIdLen   = REG_VALUE_NOT_KNOWN ;
	pRegInfoStruct->ulMaxValueLen	  = REG_VALUE_NOT_KNOWN ;
	_ulIndex++ ;

        if (   (pRegInfoStruct->nlsName.QueryError())
            || (pRegInfoStruct->nlsName.QueryError()) )
            lApiErr = ERROR_NOT_ENOUGH_MEMORY ;
    }

    return _usLastErr = lApiErr ;
}

/*******************************************************************

    NAME:	REG__ENUM::NextValue

    SYNOPSIS:	Obtain information about the next value
		attached to the node used during construction.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
		DavidHov   9/20/91    Created

********************************************************************/
APIERR REG_ENUM :: NextValue ( REG_VALUE_INFO_STRUCT * pRegValueInfo  )
{
    TCHAR szValueName [REGNAMEMAX + 2] ;
    ULONG cbValueName = sizeof (TCHAR) * REGNAMEMAX ;

    if ( _eType != RENUM_NONE && _eType != RENUM_VALUES )
    {
        return ERROR_INVALID_PARAMETER ;
    }

    pRegValueInfo->ulDataLengthOut = pRegValueInfo->ulDataLength ;

    LONG lApiErr = ::RegEnumValue( _rnNode._hKey,
				_ulIndex,
				szValueName,
				& cbValueName,
				NULL,
				& pRegValueInfo->ulType,
				pRegValueInfo->pwcData,
				& pRegValueInfo->ulDataLengthOut );

    if ( lApiErr == 0 )
    {
	pRegValueInfo->nlsValueName = szValueName ;
	_ulIndex++ ;
        if ( pRegValueInfo->nlsValueName.QueryError() )
            lApiErr = ERROR_NOT_ENOUGH_MEMORY ;
    }
    return _usLastErr = lApiErr ;
}
#endif

// End of REGKEY.CXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\profile\test\testprim.cxx ===
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 *  FILE STATUS:
 *  11/14/90  created
 *  12/02/90  moved out TestUserProfilePrimitives()
 *  02/05/91  updated to new APIs
 */

#ifdef CODESPEC
/*START CODESPEC*/

/***********
TESTPRIM.CXX
***********/

/****************************************************************************

    MODULE: TestPrim.cxx

    PURPOSE: Primitives for tests for user profile APIs

    FUNCTIONS:

	see profilei.h

    COMMENTS:

****************************************************************************/

/***************
end TESTPRIM.CXX
***************/

/*END CODESPEC*/
#endif // CODESPEC



#include "test.hxx"		/* headers and internal routines */



/* internal manifests */
char szHomedir1[] = SZ("homedir1");
char szHomedir2[] = SZ("homedir2");
char szHomedir3[] = SZ("homedir3");



/* functions: */

// USHORT UserProfileInit(
// 	);

VOID TestOne_UserProfileInit(
	)
{
    USHORT usError;

    usError = UserProfileInit(
	);
    printf(SZ("UserProfileInit() = %d\n"),
	    usError);
}

// USHORT UserProfileFree(
// 	);

VOID TestOne_UserProfileFree(
	)
{
    USHORT usError;

    usError = UserProfileFree(
	);
    printf(SZ("UserProfileFree() = %d\n"),
	    usError);
}

// USHORT UserProfileRead(
// 	CPSZ  cpszUsername,
// 	CPSZ  cpszLanroot
// 	);

VOID TestOne_UserProfileRead(
	CPSZ  cpszUsername,
	CPSZ  cpszLanroot
	)
{
    USHORT usError;

    usError = UserProfileRead(
	cpszUsername,
	cpszLanroot
	);
    printf(SZ("UserProfileRead(\"%Fs\",\"%Fs\") = %d\n"),
	    cpszUsername,
	    cpszLanroot,
	    usError);
}

// USHORT UserProfileWrite(
// 	CPSZ  cpszUsername,
// 	CPSZ  cpszLanroot
// 	);

VOID TestOne_UserProfileWrite(
	CPSZ  cpszUsername,
	CPSZ  cpszLanroot
	)
{
    USHORT usError;

    usError = UserProfileWrite(
	cpszUsername,
	cpszLanroot
	);
    printf(SZ("UserProfileWrite(\"%Fs\",\"%Fs\") = %d\n"),
	    cpszUsername,
	    cpszLanroot,
	    usError);
}

// USHORT UserProfileQuery(
// 	CPSZ  cpszUsername,
// 	CPSZ  cpszCanonDeviceName,
// 	PSZ   pszBuffer,     // returns UNC, alias or domain name
// 	USHORT usBufferSize, // length of above buffer
// 	short *psAsgType,    // as ui2_asg_type
//                              // ignored if cpszCanonDeviceName==NULL
// 	unsigned short *pusResType   // as ui2_res_type
//                              // ignored if cpszCanonDeviceName==NULL
// 	)

VOID TestOne_UserProfileQuery(
	CPSZ  cpszUsername,
	CPSZ  cpszCanonDeviceName,
	USHORT usBufferSize // maximum MAXPATHLEN
	)
{
    char szBuffer[MAXPATHLEN];
    PSZ pszBuffer = (PSZ)szBuffer;
    USHORT usError;
    short  sAsgType;
    unsigned short usResType;

    usError = UserProfileQuery(cpszUsername,cpszCanonDeviceName,
	    pszBuffer,usBufferSize,
	    &sAsgType, &usResType);
    printf(SZ("UserProfileQuery(\"%Fs\",\"%Fs\",buf,%d) = %d\n"),
	    (cpszUsername)?cpszUsername:(CPSZ)SZ("<NULL>"),
	    cpszCanonDeviceName,usBufferSize,usError);
    if (!usError)
    {
	printf(SZ("\tbuf = %Fs, sAsgType = %d, usResType = %d\n"),
		pszBuffer,sAsgType,usResType);
    }
}

// USHORT UserProfileEnum(
// 	CPSZ   cpszUsername,
// 	PSZ    pszBuffer,       // returns NULL-NULL list of device names
// 	USHORT usBufferSize     // length of above buffer
// 	);

VOID TestOne_UserProfileEnum(
	CPSZ   cpszUsername,
	USHORT usBufferSize // maximum MAXPATHLEN
	)
{
    char szBuffer[MAXPATHLEN];
    PSZ pszBuffer = (PSZ)szBuffer;
    USHORT usError;

    usError = UserProfileEnum(cpszUsername,pszBuffer,usBufferSize);
    printf(SZ("UserProfileEnum(\"%Fs\",buf,%d) = %d\n"),
	    (cpszUsername)?cpszUsername:(CPSZ)SZ("<NULL>"),
	    usBufferSize,usError);
    if (!usError)
    {
	printf(SZ("\tDevice list:\n"));
	while (*pszBuffer != TCH('\0'))
	{
	    printf(SZ("\tDevice = \"%Fs\"\n"),pszBuffer);
	    pszBuffer += strlenf((char *)pszBuffer)+1;
	}
	printf(SZ("\tEnd device list\n"));
    }
}


// USHORT UserProfileSet(
//	CPSZ   cpszUsername,
// 	CPSZ   cpszCanonDeviceName,
// 	CPSZ   cpszCanonRemoteName,
// 	short  sAsgType,     // as ui2_asg_type
// 	unsigned short usResType     // as ui2_res_type
// 	);

VOID TestOne_UserProfileSet(
	CPSZ   cpszUsername,
	CPSZ   cpszCanonDeviceName,
	CPSZ   cpszCanonRemoteName,
	short  sAsgType,
	unsigned short usResType
	)
{
    USHORT usError;

    usError = UserProfileSet(
	cpszUsername,
	cpszCanonDeviceName,
	cpszCanonRemoteName,
	sAsgType,
	usResType);
    printf(SZ("UserProfileSet(\"%Fs\",\"%Fs\",\"%Fs\",%d,%d) = %d\n"),
	    (cpszUsername)?cpszUsername:(CPSZ)SZ("<NULL>"),
	    cpszCanonDeviceName,
	    cpszCanonRemoteName,
	    sAsgType,
	    usResType,
	    usError);
}


#ifdef STICKY


// USHORT StickySetBool(   CPSZ      cpszKeyName,
// 		        BOOL      fValue
// 			);

VOID TestOne_StickySetBool(   CPSZ      cpszKeyName,
			        BOOL      fValue
				)
{
    USHORT usError = StickySetBool(cpszKeyName, fValue);

    printf(SZ("StickySetBool(\"%Fs\",%Fs) = %d\n"),
	    cpszKeyName,
	    (fValue) ? (CPSZ)SZ("TRUE") : (CPSZ)SZ("FALSE"),
	    usError);
}

// USHORT StickySetString( CPSZ      cpszKeyName,
// 		        CPSZ      cpszValue
// 			);

VOID TestOne_StickySetString( CPSZ      cpszKeyName,
			        CPSZ      cpszValue
				)
{
    USHORT usError = StickySetString(
		cpszKeyName, cpszValue);

    printf(SZ("StickySetString(\"%Fs\",\"%Fs\") = %d\n"),
	    cpszKeyName,
	    (cpszValue)?cpszValue:(CPSZ)SZ("<NULL>"),
	    usError);
}

// USHORT StickyGetBool(   CPSZ      cpszKeyName,
// 			BOOL      fDefault,
// 		        BOOL *    pfValue
// 			);

VOID TestOne_StickyGetBool(   CPSZ      cpszKeyName,
				BOOL      fDefault
				)
{
    BOOL fValue;
    USHORT usError = StickyGetBool(
	    cpszKeyName, fDefault, &fValue);

    printf(SZ("StickyGetBool(\"%Fs\",%Fs) = %d\n"),
	    cpszKeyName,
	    (fDefault) ? (CPSZ)SZ("TRUE") : (CPSZ)SZ("FALSE"),
	    usError);
    if (!usError)
    {
	printf(SZ("\tfValue = %Fs\n"),
		(fValue) ? (CPSZ)SZ("TRUE") : (CPSZ)SZ("FALSE"));
    }
}

// USHORT StickyGetString( CPSZ      cpszKeyName,
// 		        PSZ       pszValue,
// 			USHORT    cbLen
// 			);

VOID TestOne_StickyGetString( CPSZ      cpszKeyName
				)
{
    char szValue[100]; // BUGBUG size
    USHORT usError = StickyGetString(
	    cpszKeyName, (PSZ)szValue, sizeof(szValue));

    printf(SZ("StickyGetString(\"%Fs\") = %d\n"),
	    cpszKeyName,
	    usError);
    if (!usError)
    {
	printf(SZ("\tszValue = %Fs\n"),
		(CPSZ)szValue);
    }
}


#endif // STICKY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\pch\string.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    string.cxx
    NLS/DBCS-aware string class: essential core methods

    This file contains those routines which every client of
    the string classes will always need.

    Most of the implementation has been exploded into other files,
    so that an app linking to string doesn't end up dragging the
    entire string runtime library along with it.

    FILE HISTORY:
        beng        23-Oct-1990 Created
        johnl       11-Dec-1990 Remodeled beyond all recognizable form
        beng        18-Jan-1991 Most methods relocated into other files
        beng        07-Feb-1991 Uses lmui.hxx
        beng        26-Sep-1991 Replaced min with local inline
        KeithMo     16-Nov-1992 Performance tuning.

*/

#include "pchstr.hxx"  // Precompiled header

#if !defined(_CFRONT_PASS_)
#pragma hdrstop            //  This file creates the PCH
#endif


#ifndef min
inline INT min(INT a, INT b)
{
    return (a < b) ? a : b;
}
#endif

//
//  The global empty string.
//

static TCHAR EmptyString;

TCHAR * NLS_STR::_pszEmptyString = &EmptyString;


/*******************************************************************

    NAME:       NLS_STR::NLS_STR

    SYNOPSIS:   Constructor for NLS_STR

    ENTRY:      NLS_STR takes many (too many) ctor forms.

    EXIT:       String constructed

    NOTES:
        The default constructor creates an empty string.

    HISTORY:
        beng        23-Oct-1990 Created
        beng        26-Apr-1991 Replaced 'CB' and USHORT with INT
        beng        22-Jul-1991 Uses member-init ctor forms
        beng        14-Nov-1991 Unicode fixes
        beng        21-Nov-1991 Removed some ctor forms

********************************************************************/

NLS_STR::NLS_STR()
    : _pchData(0),
      _cbData(0),
      _cchLen(0),
      _fOwnerAlloc(FALSE)
{
    if ( !Alloc(0) )
        return;

    *_pchData = TCH('\0');
    InitializeVers();
}


NLS_STR::NLS_STR( UINT cchInitLen )
    : _pchData(0),
      _cbData(0),
      _cchLen(0),
      _fOwnerAlloc(FALSE)
{
    if (!Alloc(cchInitLen))
        return;

    *_pchData = TCH('\0');
    InitializeVers();
}


NLS_STR::NLS_STR( const TCHAR * pchInit )
    : _pchData(0),
      _cbData(0),
      _cchLen(0),
      _fOwnerAlloc(FALSE)
{
    if (pchInit == NULL)
    {
        if (!Alloc(0))
            return;

        *_pchData = TCH('\0');
    }
    else
    {
        UINT cchSource = ::strlenf( pchInit );

        if ( !Alloc(cchSource) )
            return;

        ::strcpyf( _pchData, pchInit );

        _cchLen = cchSource;
    }

    InitializeVers();
}


NLS_STR::NLS_STR( const NLS_STR & nlsInit )
    : _pchData(0),
      _cbData(0),
      _cchLen(0),
      _fOwnerAlloc(FALSE)
{
    UIASSERT( nlsInit.QueryError() == NERR_Success );

    if (!Alloc( nlsInit.QueryTextLength() ) )
        return;

    ::memcpy( _pchData, nlsInit.QueryPch(), nlsInit.QueryTextSize() );

    _cchLen = nlsInit.QueryTextLength();

    InitializeVers();
}


#ifdef UNICODE
NLS_STR::NLS_STR( const WCHAR * pchInit, USHORT cchInit )
    : _pchData(0),
      _cbData(0),
      _cchLen(0),
      _fOwnerAlloc(FALSE)
{
    if (pchInit == NULL)
    {
        if (!Alloc(0))
            return;

        *_pchData = TCH('\0');
    }
    else
    {
        if ( !Alloc(cchInit) )
            return;

        ::memcpyf( _pchData, pchInit, cchInit * sizeof(WCHAR) );

        _pchData[ cchInit ] = TCH('\0');

        _cchLen = cchInit;
    }

    InitializeVers();
}
#endif


NLS_STR::NLS_STR( TCHAR * pchInit, UINT cbSize, BOOL fClear )
    : _pchData(pchInit),
      _cbData(cbSize),
      _cchLen(0),
      _fOwnerAlloc(TRUE)
{
    ASSERT( pchInit != NULL );

    if ( fClear )
    {
        ASSERT(cbSize > 0); // must have given the size
        *_pchData = TCH('\0');
    }
    else
    {
        _cchLen = ::strlenf( pchInit );
        if (cbSize == 0)
            _cbData = (_cchLen + 1) * sizeof(TCHAR);

    }

    InitializeVers();
}


/*******************************************************************

    NAME:       NLS_STR::~NLS_STR

    SYNOPSIS:   Destructor for NLS_STR

    ENTRY:

    EXIT:       Storage deallocated, if not owner-alloc

    HISTORY:
        beng        23-Oct-1990     Created
        beng        22-Jul-1991     Zeroes only in debug version

********************************************************************/

NLS_STR::~NLS_STR()
{
    if( !IsOwnerAlloc() && ( _pchData != NLS_STR::_pszEmptyString ) )
        delete _pchData;

#if defined(NLS_DEBUG)
    _pchData = NULL;
    _cchLen  = 0;
    _cbData = 0;
#endif
}


/*******************************************************************

    NAME:       NLS_STR::Alloc

    SYNOPSIS:   Common code for constructors.

    ENTRY:
        cch     - number of chars desired in string

    EXIT:
        Returns TRUE if successful:

            _pchData points to allocated storage of "cb" bytes.
            _cbData set to cb.
            Allocated storage set to 0xF2 in debug version

        Returns FALSE upon allocation failure.

    NOTES:
        This is a private member function.

        If Alloc fails, it calls ReportError.

    HISTORY:
        beng        23-Oct-1990 Created
        johnl       11-Dec-1990 Updated as per code review
        beng        26-Apr-1991 Changed USHORT parm to INT
        beng        14-Nov-1991 Takes TCHAR, less term, as argument.

********************************************************************/

BOOL NLS_STR::Alloc( UINT cch )
{
    //
    //  Adjust for terminator
    //

    cch += 1;
    ASSERT(cch != 0); // wraparound

    if( cch == 1 )
    {
        //
        //  We special case empty strings to avoid thrashing
        //  the heap.
        //

        _pchData = NLS_STR::_pszEmptyString;
    }
    else
    {
        _pchData = new TCHAR[cch];

        if (_pchData == NULL)
        {
            //
            // For now, assume not enough memory.
            //

            ReportError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }

#ifdef NLS_DEBUG
        ::memset(_pchData, 0xf2, cch*sizeof(TCHAR));
#endif
    }

    _cbData = cch*sizeof(TCHAR);

    return TRUE;
}


/*******************************************************************

    NAME:       NLS_STR::Realloc

    SYNOPSIS:   Reallocate an NLS_STR to the passed count of TCHAR, copying
                the current contents to the reallocated string.

    ENTRY:
        cch  - number of TCHAR desired in string storage

    EXIT:
        Returns TRUE if successful:

            _pchData points to allocated storage of "cb" bytes.
            _cbData set to cb.
            Old storage is copied

        Returns FALSE upon allocation failure, the string is preserved

    NOTES:
        This is a private member function.

        Unline Alloc, Realloc does *not* ReportError when it fails.

        A string will never be downsized (i.e., realloc can only be used
        to increase the size of a string).  If a request comes in to make
        the string smaller, it will be ignored, and TRUE will be returned.

        Realloc on an owneralloced string succeeds so long as the
        request falls within the original allocation.

        We grow the allocation to 25% more than was requested.  In this
        way we avoid poor performance when we build a long string
        through concatenation (e.g. User Browser MLE).

    HISTORY:
        johnl       11-Nov-1990 Created
        beng        26-Apr-1991 Changed USHORT parm to INT
        beng        14-Nov-1991 Takes TCHAR, less term, as argument.
        beng        20-Nov-1991 Permit on owneralloc.
        jonn        06-Oct-1994 Leave extra room when string grows

********************************************************************/

BOOL NLS_STR::Realloc( UINT cch )
{
    // Adjust for terminating NUL-char.

    cch += 1;
    ASSERT(cch != 0); // wraparound

    if ( cch*sizeof(TCHAR) <= QueryAllocSize() )
        return TRUE;

    // If owneralloced, and insufficient existing storage, must fail.

    if (IsOwnerAlloc())
        return FALSE;

    //
    // EXPERIMENTAL -- may confuse clients which expect string to grow
    // to exact size requested
    //
    cch += (cch/4);

    TCHAR * pchNewMem = new TCHAR[cch];

    if (pchNewMem == NULL)
        return FALSE;

    ::memcpy( pchNewMem, _pchData, min( (cch-1)*sizeof(TCHAR),
                                          QueryAllocSize() ) );

    if( _pchData != NLS_STR::_pszEmptyString )
        delete _pchData;

    _pchData = pchNewMem;
    _cbData = cch*sizeof(TCHAR);
    *( _pchData + cch - 1 ) = TCH('\0');

    return TRUE;
}


/*******************************************************************

    NAME:       NLS_STR::Reset

    SYNOPSIS:   Attempts to clear the error state of the string

    ENTRY:      String is in error state

    EXIT:       If recoverable, string is correct again

    RETURNS:    TRUE if successful; FALSE otherwise

    NOTES:
        An operation on a string may fail, if this occurs, the error
        flag is set and you can't use the string until the flag
        is cleared.  By calling Reset, you can clear the flag,
        thus allowing you to get access to the string again.  The
        string will be in a consistent state.  Reset will return
        FALSE if the string couldn't be restored (for example, after
        construction failure).

    HISTORY:
        Johnl       12-Dec-1990     Created
        beng        30-Mar-1992     Use BASE::ResetError

********************************************************************/

BOOL NLS_STR::Reset()
{
    UIASSERT( QueryError() ) ;  // Make sure an error exists

    if ( QueryError() == ERROR_NOT_ENOUGH_MEMORY && _pchData != NULL )
    {
        ResetError();
        return TRUE;
    }

    return FALSE;
}


/*******************************************************************

    NAME:       ISTR::ISTR

    SYNOPSIS:   ISTR constructors

    HISTORY:
        johnl       20-Nov-1990 Created
        beng        21-Nov-1991 Unicode fixes

********************************************************************/

ISTR::ISTR( const ISTR& istr )
{
    _ichString = istr._ichString;
    _pnls = istr._pnls;
#ifdef NLS_DEBUG
    _nVersion = istr._nVersion;
#endif
}

ISTR::ISTR( const NLS_STR& nls )
{
    _ichString = 0;
    _pnls = &nls;
#ifdef NLS_DEBUG
    _nVersion = nls.QueryVersion();
#endif
}


/*******************************************************************

    NAME:       ISTR::operator=

    SYNOPSIS:   Assignment operator for the ISTR class

    HISTORY:
        Johnl       20-Nov-1990 Created
        beng        20-Nov-1991 Unicode fixes

********************************************************************/

ISTR& ISTR::operator=( const ISTR& istr )
{
    _ichString = istr._ichString;
    _pnls = istr._pnls;
#ifdef NLS_DEBUG
    _nVersion = istr._nVersion;
#endif
    return *this;
}


/*******************************************************************

    NAME:       ALLOC_STR::ALLOC_STR

    SYNOPSIS:   Constructor for owner-alloc string

    ENTRY:      pchBuffer - pointer to buffer to hold the string
                cbBuffer  - number of bytes available in buffer
                pszInit   - string with which to initialize the
                            buffer.  May be the same as pchBuffer,
                            in which case cbBuffer may be passed
                            as 0 (it will calc it itself).

    EXIT:       String constructed

    NOTES:
        This version lies outline.  See the class def'n for others.

    HISTORY:
        beng        21-Nov-1991 Created

********************************************************************/

ALLOC_STR::ALLOC_STR( TCHAR * pchBuffer, UINT cbBuffer, const TCHAR * pszInit )
    : NLS_STR(pchBuffer, cbBuffer, (pchBuffer != pszInit))
{
    if (QueryError())
        return;

    if (pszInit == NULL)
    {
        ReportError(ERROR_INVALID_PARAMETER);
        return;
    }

    if (pchBuffer != pszInit)
    {
        *this = pszInit;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\format.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    format.cxx
    Formatted string classes - implementations

    FILE HISTORY:
        beng        25-Feb-1992 Created

*/
#include "pchstr.hxx"  // Precompiled header



#if 0 // BUGBUG UNICODE - broken, pending runtime support
/*************************************************************************

    NAME:       SPRINTF_ALLOC_STR

    SYNOPSIS:   Wrapper class for sprintf-style formatting

    INTERFACE:  Sprintf() - formats into the string

    PARENT:     ALLOC_STR

    CAVEATS:
        Every string of this class is an owner-alloc-str.  The client
        is responsible for making sure that the string has enough storage
        for the formatting requested.

    HISTORY:
        beng        25-Feb-1992 Created

**************************************************************************/

class SPRINTF_ALLOC_STR: public ALLOC_STR
{
public:
    SPRINTF_ALLOC_STR( TCHAR * pchStorage, UINT cbStorage )
        : ALLOC_STR(pchStorage, cbStorage) {}
    VOID Sprintf( const TCHAR * pszDescription, ... );
};

/* This macro automatically creates the necessary stack storage */

#define STACK_FMT_STR( name, len )                      \
    TCHAR _tmp##name[ len+1 ] ;                         \
    SPRINTF_ALLOC_STR name( _tmp##name, sizeof(_tmp##name) );


/*******************************************************************

    NAME:       SPRINTF_ALLOC_STR::Sprintf

    SYNOPSIS:   Sprintf-style formatter for client-alloc string

    ENTRY:      pszDesc - descriptor string
                ...     - whatever

    EXIT:       String has been formatted

    CAVEATS:
        The string had better be large enough to contain the results.

        BUGBUG - This is TOTALLY broken under Unicode!


    HISTORY:
        beng        23-Jul-1991 Daydreamed (as NLS_STR member)
        beng        27-Feb-1992 Created

********************************************************************/

VOID SPRINTF_ALLOC_STR::Sprintf( const TCHAR * pszDesc, ... )
{
    INT cbWritten;
    va_list v;

    // BUGBUG UNICODE - this is totally broken under Unicode!  vsprintf
    // always formats 8-bit-char strings.  Need support from the crt.
    // BUGBUG - should munge pszDesc to change %s into %ws as appropriate;
    // ditto %c/%wc.
    // BUGBUG - this should use the "vsnprintf" form, checking against
    // the total allocated data, and return an error on overflow.

    va_start(v, pszDesc);
    cbWritten = ::vsprintf(QueryData(), pszDesc, v);
    va_end(v);
    ASSERT(cbWritten != -1); // error
    ASSERT(cbWritten <= QueryAllocSize());
    SetTextLength( ::strlenf(QueryData()) );
    IncVers();
}
#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\reg\reg\regval.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    REGVAL.CXX

       Win32 Registry class implementation
       Value handline member functions.

    FILE HISTORY:
	DavidHov    4/25/92	Created
        DavidHov    6/1/92      Reworked for UNICODE and
                                title removal; incomplete.
	terryk	    11/4/92	Added QueryValue for Binary data

*/

#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#include "lmui.hxx"
#include "base.hxx"
#include "string.hxx"
#include "uiassert.hxx"
#include "uitrace.hxx"

#include "uatom.hxx"			    //	Atom Management defs

#include "regkey.hxx"			    //	Registry defs

const int RM_MAXVALUENUM   = 10 ;         //  Default numeric value length
const int RM_MAXVALUESTR   = 300 ;        //  Default string value length
const int RM_MAXVALUEBIN   = 300 ;        //  Default Binary value length

const int cchPad = 2 ;                    //  Length to pad strings

/*******************************************************************

    NAME:       REG_KEY::QueryKeyValueString

    SYNOPSIS:   Worker function for all string query functions

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      If the incoming type is REG_EXPAND_SZ and the
                underlying queried type is also, the value is expanded.
                A REG_SZ is also accepted in this case.
                Otherwise, it's a type mismatch.

    HISTORY:    DavidHov  5/1/92   Created
                DavidHov  5/17/92  Added REG_EXPAND_SZ support.

********************************************************************/

APIERR REG_KEY :: QueryKeyValueString
   ( const TCHAR * pszValueName, 	//  Name of value
     TCHAR * * ppszResult,		//  Location to store result
     NLS_STR * pnlsResult,              //  or, NLS_STR to update
     DWORD * pdwTitle,                  //  location to receive title index
     LONG cchMaxSize,                   //  Maximum size allowed
     LONG * pcchSize,                   //  Size of result (no terminator)
     DWORD dwType )                     //  Value type expected
{
    APIERR err = 0 ;
    TCHAR achValueData[ RM_MAXVALUESTR ] ;
    REG_VALUE_INFO_STRUCT rviStruct ;
    INT cchLen = 0,
        cchBufferSize = 0 ;
    TCHAR * pszResult = NULL,
          * pszBuffer = NULL,
          * pszEos = NULL,
          * pszSource = NULL ;

    rviStruct.nlsValueName = pszValueName ;
    rviStruct.ulTitle      = 0 ;
    rviStruct.ulType       = 0 ;

    if ( pnlsResult != NULL && ppszResult != NULL )
    {
        err = ERROR_INVALID_PARAMETER ;
    }
    else
    if ( rviStruct.nlsValueName.QueryError() )
    {
        err = rviStruct.nlsValueName.QueryError() ;
    }
    else
    if ( cchMaxSize == 0 )   //  Unknown size?
    {
        //  Query the key to determine the largest possible length necessary

        REG_KEY_INFO_STRUCT rkiStruct ;
        if (    rkiStruct.nlsName.QueryError()
             || rkiStruct.nlsClass.QueryError()  )
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        else
        if ( (err = QueryInfo( & rkiStruct )) == 0 )
        {
             cchBufferSize = rkiStruct.ulMaxValueLen / sizeof (TCHAR) ;
        }
    }
    else
    if ( cchMaxSize > sizeof achValueData )
    {
        //  Known size, but it's larger than the automatic array

        cchBufferSize = cchMaxSize ;

    } //  else, value will fit into automatic array

    if ( err )
        return err ;

    if ( cchBufferSize )
    {
        //  We need to allocate a buffer

        pszBuffer = new TCHAR [cchBufferSize + cchPad] ;
        if ( pszBuffer == NULL )
        {
           return ERROR_NOT_ENOUGH_MEMORY ;
        }

        //  Store the BYTE pointer and BYTE count of the buffer

        rviStruct.pwcData      = (BYTE *) pszBuffer ;
        rviStruct.ulDataLength = cchBufferSize * sizeof (TCHAR) ;
    }
    else  //  Use the automatic array for temporary storage.
    {
        rviStruct.pwcData      = (BYTE *) achValueData ;
        rviStruct.ulDataLength = ((sizeof achValueData) - cchPad) * sizeof (TCHAR) ;
    }

    if ( (err = QueryValue( & rviStruct )) == 0 )
    {
        //  Zero-terminate the value data.

        pszSource = (TCHAR *) rviStruct.pwcData ;
        pszEos = (TCHAR *) (rviStruct.pwcData+rviStruct.ulDataLengthOut) ;
	*pszEos = 0 ;
        cchLen = (INT)(pszEos - pszSource) ;
        if ( pcchSize )
            *pcchSize = cchLen ;

        //  If it wasn't the requested type, give an error.  Handle
        //  the special case of a request for a REG_EXPAND_SZ but
        //  a REG_SZ result.

        if (    (rviStruct.ulType != dwType)
             && ( !(rviStruct.ulType == REG_SZ && dwType == REG_EXPAND_SZ) ) )
        {
            err = ERROR_INVALID_PARAMETER ;
        }
    }

    //  Expand REG_MULTI_SZ if necessary.

    if ( err == 0 && rviStruct.ulType == REG_EXPAND_SZ )
    {
        DWORD cchExpand,
              cchExpanded = cchLen * 2 ;
        TCHAR * pszExpanded = NULL ;
        do
        {
			// NTRAID#NTBUG9-577099-2002/03/08-artm  Prefast: need to use delete [].
			// Allocated with new [] (see next line of code); use
			// delete [] to avoid memory leak.
			// This function is a little convoluted; it probably warrants
			// a scan to see if there are any subtle memory leaks not
			// detected by prefast.
            delete pszExpanded ;

            pszExpanded = new TCHAR [cchExpand = cchExpanded] ;

            if ( pszExpanded == NULL )
            {
                err = ERROR_NOT_ENOUGH_MEMORY ;
                break ;
            }
            cchExpanded = ::ExpandEnvironmentStrings( pszSource,
                                                      pszExpanded,
                                                      cchExpand ) ;
        }
        while ( cchExpanded > cchExpand ) ;

        // Replace the older buffer, if any, with the new one, if any.

        delete pszBuffer ;
        pszBuffer = pszSource = pszExpanded ;
    }

    if ( err == 0 )
    {
        if ( ppszResult )
        {
            //   They want TCHAR output.  See if we've already allocated
            //     a buffer; if so, use it, otherwise make one.

            if ( pszBuffer )
            {
                *ppszResult = pszBuffer ;
                pszBuffer = NULL ;  // Suppress deletion of buffer
            }
            else
            if ( (pszResult = new TCHAR [cchLen + cchPad]) != NULL )
	    {
	        ::strcpyf( pszResult, pszSource ) ;
                *ppszResult = pszResult ;
	    }
	    else
	    {
                err = ERROR_NOT_ENOUGH_MEMORY ;
	    }
        }
        else
        {
            //  They want NLS_STR output

            *pnlsResult = pszSource ;
            err = pnlsResult->QueryError() ;
        }
    }

	// NTRAID#NTBUG9-577099-2002/03/08-artm  Prefast: use delete [].
	// Allocated with new [], use delete [].
    delete pszBuffer ;

    return err ;
}


/*******************************************************************

    NAME:       REG_KEY::SetKeyValueString

    SYNOPSIS:   Worker function for value string handling

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      If lcbSize == 0, compute the length of the string
                using ::strlenf().

    HISTORY:

********************************************************************/
APIERR REG_KEY :: SetKeyValueString
   ( const TCHAR * pszValueName,        //  Name of value
     const TCHAR * pszValue,		//  Data to be applied
     DWORD dwTitle,                     //  Title index (optional)
     LONG lcbSize,                      //  Size of string
     DWORD dwType )                     //  Type
{
    REG_VALUE_INFO_STRUCT rviStruct ;

    rviStruct.pwcData = (BYTE *) pszValue ;
    rviStruct.ulDataLength = lcbSize == 0
                           ? (::strlenf( pszValue ) + 1)
                           : lcbSize ;
    rviStruct.ulDataLength *= sizeof (TCHAR) ;
    rviStruct.nlsValueName = pszValueName ;
    rviStruct.ulTitle = 0 ;
    rviStruct.ulType = dwType ;

    return rviStruct.nlsValueName.QueryError()
         ? rviStruct.nlsValueName.QueryError()
         : SetValue( & rviStruct ) ;
}

/*******************************************************************

    NAME:       REG_KEY::QueryKeyValueBinary

    SYNOPSIS:   Worker function for all binary query functions

		If "*ppbResult" is non-NULL, this value is used
		for the result buffer; its size is assumed to be
		"cbMaxSize".

    		If "cbMaxSize" is zero, key is queried to find 
		largest value.

    ENTRY:

    EXIT:

    RETURNS:	APIERR

    HISTORY:    DavidHov  5/1/92   Created
                DavidHov  5/17/92  Added REG_EXPAND_SZ support.
		terryk	  11/4/92  Changed it to QueryKeyValueBinary

********************************************************************/

APIERR REG_KEY :: QueryKeyValueBinary
   ( const TCHAR * pszValueName, 	//  Name of value
     BYTE * * ppbResult,		//  Location to store result
     LONG * pcbSize,                    //  Size of result (no terminator)
     LONG cbMaxSize,                    //  Maximum size allowed
     DWORD * pdwTitle,                  //  location to receive title index
     DWORD dwType )                     //  Value type expected
{
    APIERR err = 0 ;
    REG_VALUE_INFO_STRUCT rviStruct ;
    INT  cbBufferSize = 0 ;
    BYTE * pbBuffer = NULL;

    rviStruct.nlsValueName = pszValueName ;
    rviStruct.ulTitle      = 0 ;
    rviStruct.ulType       = 0 ;

    do
    {
    	if ( ppbResult == NULL )
    	{
	    err = ERROR_INVALID_PARAMETER ;
	    break ;
    	}
    
        if ( err = rviStruct.nlsValueName.QueryError() )
        {
	    break; 
    	}
    
    	if ( (cbBufferSize = cbMaxSize) == 0 )    // Unknown size?
    	{
            //  Query the key to determine the largest possible length necessary

            REG_KEY_INFO_STRUCT rkiStruct ;
            if (    rkiStruct.nlsName.QueryError()
                 || rkiStruct.nlsClass.QueryError()  )
            {
                err = ERROR_NOT_ENOUGH_MEMORY ;
            }
            else
            if ( (err = QueryInfo( & rkiStruct )) == 0 )
            {
                 cbBufferSize = rkiStruct.ulMaxValueLen ;
            }
    	    if ( err )
                break ;
        }

    	//  See if we need to allocate a buffer.  Use the size given by the user 
    	//  if present.

    	if ( *ppbResult )    //  Does the pointer point somewhere?
    	{
            pbBuffer = *ppbResult ;   //  Pick up user's pointer.
    	}
    	else  //  We have to allocate a buffer
        if ( (pbBuffer = new BYTE [cbBufferSize]) == NULL )
	{
            err = ERROR_NOT_ENOUGH_MEMORY ;
	    break ;
    	}

        //  Store the BYTE pointer and BYTE count of the buffer

	rviStruct.pwcData      = pbBuffer ;
	rviStruct.ulDataLength = cbBufferSize * sizeof (BYTE) ;

	if ( err = QueryValue( & rviStruct ) )
	{
	    break ;
	}

        if ( rviStruct.ulType != dwType )
        {
	    err = ERROR_INVALID_PARAMETER ;
	    break ;
        }	
        if ( *ppbResult == NULL ) 
	{
	    //  Give the caller the allocated buffer.
	    *ppbResult = pbBuffer ;
	}

	//  Report eh size read.
	*pcbSize = rviStruct.ulDataLengthOut ;
    }
    while ( FALSE ) ;

    if ( err && pbBuffer != *ppbResult ) 
    {
		// NTRAID#NTBUG9-577099-2002/03/08-artm  Prefast: use delete []
		// allocated with []; use delete [] to avoid memory leak
    	delete pbBuffer ;
    }

    return err ;
}


/*******************************************************************

    NAME:       REG_KEY::SetKeyValueBinary

    SYNOPSIS:   Worker function for value binary handling

    ENTRY:

    EXIT:

    RETURNS:

    HISTORY:

********************************************************************/
APIERR REG_KEY :: SetKeyValueBinary
   ( const TCHAR * pszValueName,        //  Name of value
     const BYTE * pbValue,		//  Data to be applied
     LONG lcbSize,                      //  Size of binary
     DWORD dwTitle,                     //  Title index (optional)
     DWORD dwType )                     //  Type
{
    REG_VALUE_INFO_STRUCT rviStruct ;

    rviStruct.pwcData = (BYTE *) pbValue ;
    rviStruct.ulDataLength =  lcbSize ;
    rviStruct.nlsValueName = pszValueName ;
    rviStruct.ulTitle = 0 ;
    rviStruct.ulType = dwType ;

    return rviStruct.nlsValueName.QueryError()
         ? rviStruct.nlsValueName.QueryError()
         : SetValue( & rviStruct ) ;
}
/*******************************************************************

    NAME:       REG_KEY::QueryKeyValueLong

    SYNOPSIS:   Worker function for REG_DWORD handling

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

APIERR REG_KEY :: QueryKeyValueLong
   ( const TCHAR * pszValueName, 	//  Name of value
     LONG * pnResult,    		//  Location to store result
     DWORD * pdwTitle )                 //  location to receive title index
{
    APIERR err ;
    BYTE abValueData[ RM_MAXVALUENUM ] ;
    REG_VALUE_INFO_STRUCT rviStruct ;
    TCHAR * pszResult = NULL ;

    rviStruct.pwcData      = abValueData ;
    rviStruct.ulDataLength = sizeof abValueData ;
    rviStruct.nlsValueName = pszValueName ;
    rviStruct.ulTitle      = 0 ;
    rviStruct.ulType       = 0 ;

    if ( rviStruct.nlsValueName.QueryError() )
    {
        err = rviStruct.nlsValueName.QueryError() ;
    }
    else
    if ( (err = QueryValue( & rviStruct )) == 0 )
    {
        if ( rviStruct.ulType != REG_DWORD )
        {
            err = ERROR_INVALID_PARAMETER ;
        }
        else
        {
            *pnResult = *( (LONG *) abValueData ) ;
	}
    }

    return err ;
}

/*******************************************************************

    NAME:       REG_KEY::SetKeyValueLong

    SYNOPSIS:   Worker function for REG_DWORD value setting

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/
APIERR REG_KEY :: SetKeyValueLong
   ( const TCHAR * pszValueName, 	//  Name of value
     LONG nNewValue,       		//  Data to be applied
     DWORD dwTitle )                    //  Title index (optional)
{
    REG_VALUE_INFO_STRUCT rviStruct ;

    rviStruct.pwcData = (BYTE *) & nNewValue ;
    rviStruct.ulDataLength = sizeof nNewValue ;
    rviStruct.nlsValueName = pszValueName ;
    rviStruct.ulTitle = 0 ;
    rviStruct.ulType = REG_DWORD ;

    return rviStruct.nlsValueName.QueryError()
         ? rviStruct.nlsValueName.QueryError()
         : SetValue( & rviStruct ) ;
}


/*******************************************************************

    NAME:       REG_KEY::QueryValue

    SYNOPSIS:   Query a single string value from the
                Registry.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      If "fExpandSz" is TRUE, then a REG_EXPAND_SZ is
                is allowed, and if found, expanded; REG_SZ will
                also suffice.

    HISTORY:

********************************************************************/
APIERR REG_KEY :: QueryValue (
    const TCHAR * pszValueName,
    NLS_STR * pnlsValue,
    ULONG cchMax,
    DWORD * pdwTitle,
    BOOL fExpandSz )
{
    LONG cchSize ;

    return QueryKeyValueString( pszValueName,
                                NULL,
                                pnlsValue,
                                NULL,
                                cchMax ? cchMax : RM_MAXVALUESTR,
                                & cchSize,
                                fExpandSz ? REG_EXPAND_SZ : REG_SZ );
}

/*******************************************************************

    NAME:       REG_KEY::

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/
APIERR REG_KEY :: SetValue (
    const TCHAR * pszValueName,
    const NLS_STR * pnlsValue,
    const DWORD * pdwTitle,
    BOOL fExpandSz )
{
    return SetKeyValueString( pszValueName,
                              pnlsValue->QueryPch(),
                              NULL,
                              0,
                              fExpandSz ? REG_EXPAND_SZ
                                        : REG_SZ ) ;
}

/*******************************************************************

    NAME:       REG_KEY::QueryValue

    SYNOPSIS:   Query Binary value from the
                Registry.

    ENTRY:

    EXIT:

    RETURNS:

    HISTORY:

********************************************************************/
APIERR REG_KEY :: QueryValue (
    const TCHAR * pszValueName,
    BYTE ** ppbByte,
    LONG *pcbSize,
    LONG cbMax,
    DWORD * pdwTitle )
{
    return QueryKeyValueBinary( pszValueName,
                                ppbByte,
                                pcbSize,
                                cbMax,
                                pdwTitle,
				REG_BINARY );
}

/*******************************************************************

    NAME:       REG_KEY::

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/
APIERR REG_KEY :: SetValue (
    const TCHAR * pszValueName,
    const BYTE * pByte,
    const LONG cbByte,
    const DWORD * pdwTitle )
{
    return SetKeyValueBinary( pszValueName,
                              pByte,
			      cbByte,
                              NULL,
                              REG_BINARY ) ;
}

/*******************************************************************

    NAME:       REG_KEY::

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/
APIERR REG_KEY :: QueryValue (
    const TCHAR * pszValueName,
    TCHAR * * ppchValue,
    ULONG cchMax,
    DWORD * pdwTitle,
    BOOL fExpandSz )
{

    LONG cchSize ;

    return QueryKeyValueString( pszValueName,
                                ppchValue,
                                NULL,
                                NULL,
                                cchMax ? cchMax : RM_MAXVALUESTR,
                                & cchSize,
                                fExpandSz ? REG_EXPAND_SZ
                                          : REG_SZ );
}

/*******************************************************************

    NAME:       REG_KEY::

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/
APIERR REG_KEY :: SetValue (
    const TCHAR * pszValueName,
    const TCHAR * pchValue,
    ULONG cchLen,   // BUGBUG: this parameter should be removed
    const DWORD * pdwTitle,
    BOOL fExpandSz )
{
    return SetKeyValueString( pszValueName,
                              pchValue,
                              NULL,
                              0,
                              fExpandSz ? REG_EXPAND_SZ
                                        : REG_SZ ) ;
}


/*******************************************************************

    NAME:       REG_KEY::

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/
// Query/Set numeric values

APIERR REG_KEY :: QueryValue (
    const TCHAR * pszValueName,
    DWORD * pdwValue,
    DWORD * pdwTitle )
{
    return QueryKeyValueLong( pszValueName,
                              (LONG *) pdwValue,
                              NULL ) ;
}

/*******************************************************************

    NAME:       REG_KEY::

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/
APIERR REG_KEY :: SetValue (
    const TCHAR * pszValueName,
    DWORD dwValue,
    const DWORD * pdwTitle )
{
    return SetKeyValueLong( pszValueName,
                            dwValue,
                            NULL ) ;
}

/*******************************************************************

    NAME:       REG_KEY::

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

APIERR REG_KEY :: QueryValue (
    const TCHAR * pszValueName,
    STRLIST * * ppStrList,
    DWORD * pdwTitle  )
{
    APIERR err = 0 ;
    TCHAR * pszResult = NULL,
          * pszNext = NULL,
          * pszLast = NULL ;
    LONG cchLen, cchNext ;
    STRLIST * pStrList = NULL ;

    do
    {
        pStrList = new STRLIST ;
        if ( pStrList == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
            break ;
        }

        err = QueryKeyValueString( pszValueName,
                                   & pszResult,
                                   NULL,
                                   NULL,
                                   0,  // Ask key for size of largest item
                                   & cchLen,
                                   REG_MULTI_SZ ) ;
        if ( err )
            break ;

        for ( pszLast = pszNext = pszResult, cchNext = 0 ;
              err == 0 && cchNext < cchLen ;
              cchNext++, pszNext++ )
        {
            // BUGBUG:  It appears that there's an extra delimiter
            //   on the returned data, resulting in a bogus final
            //   zero-length string.  For now, skip it...

            if ( *pszNext == 0 && pszLast < pszNext )
            {
                NLS_STR * pnlsNext = new NLS_STR( pszLast ) ;
                if ( pnlsNext == NULL )
                {
                    err = ERROR_NOT_ENOUGH_MEMORY ;
                }
                else
                if ( (err = pnlsNext->QueryError()) == 0 )
                {
                     err = pStrList->Append( pnlsNext ) ;
                }
            }
            if ( *pszNext == 0 )
            {
                pszLast = pszNext + 1 ;
            }
        }
    }
    while ( FALSE ) ;

    if ( err == 0 )
    {
        *ppStrList = pStrList ;
    }
    else
    {
        delete pStrList ;
    }

    delete pszResult ;

    return err ;
}


#ifndef UNICODE
extern "C"
{

LONG emptyMultiSz ( HKEY hKey, const CHAR * pszValueName )
{
    BYTE bData [2] ;

    return ::RegSetValueExA( hKey,
                             pszValueName,
                             0,
                             REG_MULTI_SZ,
                             bData,
                             0 );
}

}

#endif

/*******************************************************************

    NAME:       REG_KEY::

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/
APIERR REG_KEY :: SetValue (
    const TCHAR * pszValueName,
    const STRLIST * pStrList,
    const DWORD * pdwTitle )
{
    LONG cchLen ;
    INT cStrs ;
    NLS_STR * pnlsNext ;
    TCHAR * pchBuffer = NULL ;
    APIERR err ;

    {
        ITER_STRLIST istrList( *((STRLIST *) pStrList) ) ;
        for ( cStrs = 0, cchLen = 0 ; pnlsNext = istrList.Next() ; cStrs++ )
        {
            cchLen += pnlsNext->QueryTextLength() + 1 ;
        }
    }

#ifndef UNICODE
    if ( cStrs == 0 )
    {
        return emptyMultiSz( _hKey, pszValueName ) ;
    }
#endif

    pchBuffer = new TCHAR [cchLen+cchPad] ;

    if ( pchBuffer == NULL )
    {
        err = ERROR_NOT_ENOUGH_MEMORY ;
    }
    else
    {
        ITER_STRLIST istrList( *((STRLIST *) pStrList) ) ;
        TCHAR * pchNext = pchBuffer ;

        for ( ; pnlsNext = istrList.Next() ; )
        {
            ::strcpyf( pchNext, pnlsNext->QueryPch() ) ;
            pchNext += pnlsNext->QueryTextLength() ;
            *pchNext++ = 0 ;
        }

        *pchNext++ = 0 ;
        *pchNext = 0 ;

        err = SetKeyValueString( pszValueName,
                                 pchBuffer,
                                 0,
                                 cchLen+1,
                                 REG_MULTI_SZ ) ;
    }

	// NTRAID#NTBUG9-577099-2002/03/08-artm  Prefast:  use delete [].
	// Allocated with new []; use delete [] to avoid memory leak.
    delete pchBuffer ;

    return err ;
}

// End of REGVAL.CXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\formnum.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    formnum.cxx
    Formatted string classes, numeric formatting - implementations

    FILE HISTORY:
        beng        25-Feb-1992 Created

*/

#include "pchstr.hxx"  // Precompiled header



/* Static member of NUM_NLS_STR class */

TCHAR NUM_NLS_STR::_chThousandSep = 0;


/*******************************************************************

    NAME:       DEC_STR::DEC_STR

    SYNOPSIS:   Constructor for DEC_STR

    ENTRY:      nValue      - value to represent
                cchDigitPad - minimum number of digits

    EXIT:       String constructed and formatted as decimal number

    HISTORY:
        beng        25-Feb-1992 Created

********************************************************************/

DEC_STR::DEC_STR( ULONG nValue, UINT cchDigitPad )
    : NLS_STR( CCH_INT )
{
    if (QueryError() != NERR_Success)
        return;

    // Assemble decimal representation into szTemp, reversed,
    // then reverse in-place into correct format.
    //
    // This code deliberately eschews ultoa; while the mod/div saves
    // nothing, the digit calc is simpler, and anyway this scheme
    // allows a nice in-place digit padding.
    //
    // REVIEW: check code size, reconsider ultoa usage

    TCHAR szTemp[CCH_INT+1];
    {
        UINT ich = 0;
        do
        {
            UINT nDigitValue = (UINT)(nValue % 10);
            nValue /= 10;
            szTemp[ich++] = (TCHAR)nDigitValue + TCH('0');
        }
        while (nValue > 0);

        while (ich < cchDigitPad)
        {
            szTemp[ich++] = TCH('0'); // pad to required number of digits
        }

        szTemp[ich] = 0;
        ::strrevf(szTemp);
    }

    // Now copy szTemp into the string

    {
        *(NLS_STR*)this = szTemp;

        APIERR err = QueryError();
        if (err != NERR_Success)
        {
            ReportError(err);
            return;
        }
    }
}


/*******************************************************************

    NAME:       HEX_STR::HEX_STR

    SYNOPSIS:   Constructor for HEX_STR

    ENTRY:      nValue      - value to represent
                cchDigitPad - minimum number of digits

    EXIT:       String constructed and formatted as hex number

    HISTORY:
        beng        25-Feb-1992 Created

********************************************************************/

HEX_STR::HEX_STR( ULONG nValue, UINT cchDigitPad )
    : NLS_STR( CCH_INT ) // plenty big, since hex more compact than dec
{
    if (QueryError() != NERR_Success)
        return;

    // Assemble hex representation into szTemp, reversed,
    // then reverse in-place into correct format
    //
    // This code deliberately eschews ultoa, since div and mod 16
    // optimize so very nicely.

    TCHAR szTemp[CCH_INT+1];
    {
        UINT ich = 0;
        do
        {
            UINT nDigitValue = (UINT)(nValue % 16);
            nValue /= 16;

            if (nDigitValue > 9)
            {
                szTemp[ich++] = (TCHAR)nDigitValue - 10 + TCH('a');
            }
            else
            {
                szTemp[ich++] = (TCHAR)nDigitValue + TCH('0');
            }
        }
        while (nValue > 0);

        while (ich < cchDigitPad)
        {
            szTemp[ich++] = TCH('0'); // pad to required number of digits
        }

        szTemp[ich] = 0;
        ::strrevf(szTemp);
    }

    // Now copy szTemp into the string

    {
        *(NLS_STR*)this = szTemp;

        APIERR err = QueryError();
        if (err != NERR_Success)
        {
            ReportError(err);
            return;
        }
    }
}


/*******************************************************************

    NAME:       NUM_NLS_STR::NUM_NLS_STR

    SYNOPSIS:   Constructor for NUM_NLS_STR

    ENTRY:      nValue - value to represent

    EXIT:       String constructed and formatted

    HISTORY:
        beng        25-Feb-1992 Created

********************************************************************/

NUM_NLS_STR::NUM_NLS_STR( ULONG nValue )
    : DEC_STR( nValue )
{
    const UINT cchDigitsPerThousand = 3;

    if (QueryError() != NERR_Success)
        return;

    UINT cchNumber = QueryTextLength();
    if (cchNumber < 4) // too short to need commas
        return;

    // Init package as necessary (i.e. fetch comma char)

    if (_chThousandSep == 0)
    {
        Init();
    }

    // Build comma string to insert into numeric string

    APIERR err;
    TCHAR_STR nlsComma(_chThousandSep);
    if ((err = nlsComma.QueryError()) != NERR_Success)
    {
        ReportError(err);
        return;
    }

    // Calc offset of first comma, and total number of commas needed

    UINT ichFirstComma = cchNumber % cchDigitsPerThousand;
    if (ichFirstComma == 0)
        ichFirstComma = cchDigitsPerThousand;

    UINT cchCommas = (cchNumber - ichFirstComma) / cchDigitsPerThousand;

    // Run through string, inserting commas at appropriate intervals

    ISTR istr(*this);
    istr += ichFirstComma;
    while (cchCommas-- > 0)
    {
        if (!InsertStr( (const ALIAS_STR &) nlsComma, istr))
        {
            // Error reported; bail out
            return;
        }
        istr += (cchDigitsPerThousand+1); // additional one to skip comma
    }
}


/*******************************************************************

    NAME:       NUM_NLS_STR::Init

    SYNOPSIS:   Package initialization for NUM_NLS_STR

    EXIT:       Thousands-separator-char loaded

    NOTES:
        Class autoinits self.  Client should call this public member
        function should client receive WM_WININICHANGED.

    HISTORY:
        beng        25-Feb-1992 Created
        beng        05-May-1992 API changes

********************************************************************/

VOID NUM_NLS_STR::Init()
{
#if defined(WINDOWS)
    TCHAR szBuf[ 1 + 1 ] = { TEXT('\0'), TEXT('\0') }; // JonN 01/23/00: PREFIX bug 444887
    ::GetProfileString( SZ("intl"), SZ("sThousand"), SZ(","), szBuf, 1+1 );

    _chThousandSep = szBuf[ 0 ];
#else
    _chThousandSep = TCH(',');
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\istraux.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    istraux.cxx
    NLS/DBCS-aware string class: secondary methods of index class

    This file contains the implementation of the auxiliary methods
    for the ISTR class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
	beng	    18-Jan-1991     Separated from original monolithic .cxx
	beng	    07-Feb-1991     Uses lmui.hxx
	beng	    26-Apr-1991     Relocated some funcs from string.hxx

*/

#include "pchstr.hxx"  // Precompiled header




/*******************************************************************

    NAME:	ISTR::Reset

    SYNOPSIS:	Reset the ISTR so the index is 0;
		updates the version number of the string.

    HISTORY:
	Johnl	    28-Nov-1990 Created
	beng	    19-Nov-1991 Unicode fixes

********************************************************************/

VOID ISTR::Reset()
{
    SetIch(0);
#ifdef NLS_DEBUG
    SetVersion( QueryString()->QueryVersion() );
#endif
}


/*******************************************************************

    NAME:	ISTR::operator-

    SYNOPSIS:	Returns the difference in TCHAR between the two ISTR

    NOTES:
	Should this return instead an unsigned difference?

    HISTORY:
	Johnl	    28-Nov-1990 Created
	beng	    19-Nov-1991 Unicode fixes

********************************************************************/

INT ISTR::operator-( const ISTR& istr2 ) const
{
    UIASSERT( QueryString() == istr2.QueryString() );

    return ( QueryIch() - istr2.QueryIch() );
}


/*******************************************************************

    NAME:	ISTR::operator++

    SYNOPSIS:	Increment the ISTR to the next logical character

    NOTES:	Stops if we are at the end of the string

    HISTORY:
	Johnl	    28-Nov-1990 Created
	beng	    23-Jul-1991 Simplified CheckIstr
	beng	    19-Nov-1991 Unicode fixes

********************************************************************/

ISTR& ISTR::operator++()
{
    QueryString()->CheckIstr( *this );
    TCHAR c = *(QueryString()->QueryPch() + QueryIch());
    if ( c != TCH('\0') )
    {
#if defined(UNICODE)
	++_ichString;
#else
	SetIch( QueryIch() + (IS_LEAD_BYTE(c) ? 2 : 1) );
#endif
    }
    return *this;
}


/*******************************************************************

    NAME:	ISTR::operator+=

    SYNOPSIS:	Increment the ISTR to the nth logical character

    NOTES:	Stops if we are at the end of the string

    HISTORY:
	Johnl	    14-Jan-1990 Created
	beng	    21-Nov-1991 Unicode optimization

********************************************************************/

VOID ISTR::operator+=( INT cch )
{
#if defined(UNICODE)
    QueryString()->CheckIstr( *this );

    const TCHAR * psz = QueryString()->QueryPch();
    INT ich = QueryIch();

    while (cch-- && (psz[ich] != TCH('\0')))
	++ich;

    SetIch(ich);

#else
    while ( cch-- )
	operator++();
#endif
}


/*******************************************************************

    NAME:	ISTR::operator==

    SYNOPSIS:	Equality operator

    RETURNS:	TRUE if the two ISTRs are equivalent.

    NOTES:	Only valid between two ISTRs of the same string.

    HISTORY:
	beng	    22-Jul-1991 Header added
	beng	    19-Nov-1991 Unicode fixes

********************************************************************/

BOOL ISTR::operator==( const ISTR& istr ) const
{
    UIASSERT( QueryString() == istr.QueryString() );
    return QueryIch() == istr.QueryIch();
}


/*******************************************************************

    NAME:	ISTR::operator>

    SYNOPSIS:	Greater-than operator

    RETURNS:	TRUE if this ISTR points further into the string
		than the argument.

    NOTES:	Only valid between two ISTRs of the same string.

    HISTORY:
	beng	    22-Jul-1991 Header added
	beng	    19-Nov-1991 Unicode fixes

********************************************************************/

BOOL ISTR::operator>( const ISTR& istr )  const
{
    UIASSERT( QueryString() == istr.QueryString() );
    return QueryIch() > istr.QueryIch();
}


/*******************************************************************

    NAME:	ISTR::operator<

    SYNOPSIS:	Lesser-than operator

    RETURNS:	TRUE if this ISTR points less further into the string
		than the argument.

    NOTES:	Only valid between two ISTRs of the same string.

    HISTORY:
	beng	    22-Jul-1991 Header added
	beng	    19-Nov-1991 Unicode fixes

********************************************************************/

BOOL ISTR::operator<( const ISTR& istr )  const
{
    UIASSERT( QueryString() == istr.QueryString() );
    return QueryIch() < istr.QueryIch();
}


/*******************************************************************

    NAME:	ISTR::IsLastPos

    SYNOPSIS:	Predicate: does istr index the last character in string?

    RETURNS:	Boolean value

    HISTORY:
	yi-hsins    14-Oct-1991 (created as inline fcn)
	beng	    21-Nov-1991 Implementation outlined

********************************************************************/

BOOL ISTR::IsLastPos() const
{
    return (*(QueryString()->QueryPch() + QueryIch() + 1)) == TCH('\0');
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\mapcopy.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    mapcopy.cxx
    Methods which map character sets, copying to or from the string

    Where the environment requires no mapping (e.g. Map-To WCHAR
    in a Unicode env), these routines perform a naive copy.

    FILE HISTORY:
        beng        02-Mar-1992 Created
        beng        08-Mar-1992 Broke out [W]CHAR_STRING into mappers
*/

#include "pchstr.hxx"  // Precompiled header



/*******************************************************************

    NAME:       NLS_STR::MapCopyFrom

    SYNOPSIS:   Copy new data into string, mapping into alternate charset

    ENTRY:
        pwszSource   - source argument, either a WCHAR* or CHAR*
        cbCopy       - the maximum number of bytes to copy from the
                       source.  0 will set the current string to empty;
                       CBNLSMAGIC (the default value) assumes that the
                       source string is NUL-terminated.

    EXIT:
        Copied argument into this.

    RETURNS:
        NERR_Success if successful.  Otherwise, errorcode.

    NOTES:
        If the operation fails, the current string will retain its
        original contents and error state.

    HISTORY:
        beng        02-Mar-1992 Created
        beng        29-Mar-1992 Added cbCopy param
        beng        24-Apr-1992 Change meaning of cbCopy == 0

********************************************************************/

APIERR NLS_STR::MapCopyFrom( const CHAR * pszSource, UINT cbCopy )
{
#if defined(UNICODE)

    // Does translation before copyfrom - necessary in order to
    // retain original string as late as possible.  Temp object
    // makes rollback convenient.

    WCHAR_STRING xwszTemp(pszSource, cbCopy);

    APIERR err = xwszTemp.QueryError();
    if (err != NERR_Success)
        return err;

    return CopyFrom(xwszTemp.QueryData());

#else
    return CopyFrom(pszSource, cbCopy);
#endif
}


APIERR NLS_STR::MapCopyFrom( const WCHAR * pwszSource, UINT cbCopy )
{
#if defined(UNICODE)
    return CopyFrom(pwszSource, cbCopy);
#else

    CHAR_STRING xsszTemp(pwszSource, cbCopy);

    APIERR err = xsszTemp.QueryError();
    if (err != NERR_Success)
        return err;

    return CopyFrom(xsszTemp.QueryData());

#endif
}


/*******************************************************************

    NAME:       NLS_STR::MapCopyTo

    SYNOPSIS:   Copy string data, mapping into alternate charset

    ENTRY:
        pwchDest   - pointer to destination buffer, either WCHAR* or CHAR*
        cbAvailable- size of available buffer in bytes

    RETURNS:
        NERR_Success if successful.  Otherwise, errorcode.

    NOTES:
        At present, only MBCS<->Unicode mappings are supported.

    HISTORY:
        beng        02-Mar-1992 Created
        beng        19-Mar-1992 Fixed bug in WCtoMB usage
        beng        02-Jun-1992 WCtoMB changed again

********************************************************************/

APIERR NLS_STR::MapCopyTo( CHAR * pchDest, UINT cbAvailable ) const
{
#if defined(UNICODE)

    // No need to allocate any temp object here - this is a const fcn

    BOOL fDummy;
    UINT cb = ::WideCharToMultiByte(CP_ACP,    // use ANSI Code Page
                                    0,
                                    _pchData,
                                    QueryTextSize() / sizeof(WCHAR),
                                    pchDest,
                                    cbAvailable,
                                    NULL,
                                    &fDummy);

    return (cb == 0) ? ::GetLastError() : NERR_Success;

#else
    return CopyTo(pchDest, cbAvailable);
#endif
}


APIERR NLS_STR::MapCopyTo( WCHAR * pwchDest, UINT cbAvailable ) const
{
#if defined(UNICODE)
    return CopyTo(pwchDest, cbAvailable);
#else

    UINT cb = ::MultiByteToWideChar(CP_ACP,     // use ANSI Code Page
                                    MB_PRECOMPOSED,
                                    _pchData,
                                    QueryTextSize(),
                                    pwchDest,
                                    cbAvailable / sizeof(WCHAR));

    return (cb == 0) ? ::GetLastError() : NERR_Success;

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\mappers.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    mappers.cxx
    Charset-mapping classes, internal to string: implementation

    FILE HISTORY:
        beng        02-Mar-1992 Created (from mapcopy.cxx)
        beng        07-May-1992 Use official wchar.h headerfile

*/
#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:       WCHAR_STRING::WCHAR_STRING

    SYNOPSIS:   Ctor

        Allocates sufficient temporary storage, then maps the given
        MBCS string into a Unicode string.

    ENTRY:      pszSource - given source string, MBCS
                cbCopy    - max number of bytes to copy

    EXIT:       Constructed

    RETURNS:    As per class BASE

    CAVEATS:
        NULL is a perfectly acceptable arg here, and will yield
        another NULL (with cb == 0), as will cbCopy == 0.  This
        works since we typically give this temporary to CopyFrom,
        which will interpret the NULL and set its NLS_STR to empty.

    HISTORY:
        beng        02-Mar-1992 Created
        beng        29-Mar-1992 cbCopy param added
        thomaspa    08-Apr-1992 Fixed bug in non-NUL term'd strings
        beng        24-Apr-1992 Change meaning of cbCopy==0

********************************************************************/

WCHAR_STRING::WCHAR_STRING( const CHAR * pszSource, UINT cbCopy )
    : _pwszStorage(NULL), _cbStorage(0)
{
    if (pszSource == NULL || cbCopy == 0)
        return;

    // If called with cbCopy==CBNLSMAGIC, then the string hasn't been
    // counted, but is instead assumed to end with NUL.

    BOOL fCounted = (cbCopy != CBNLSMAGIC);

    // Convert MBCS to Unicode.  Assumes the worst case (SBCS) for
    // space, doubling the storage expectations.

    UINT cschSource = fCounted ? cbCopy : (::strlen(pszSource));

    _pwszStorage = new WCHAR[cschSource+1]; // pun: counted as csch, passed as cwch
    if (_pwszStorage == NULL)
    {
        ReportError(ERROR_NOT_ENOUGH_MEMORY);
        return;
    }
    _cbStorage = (cschSource+1);

    // I could always give the API all-but-terminator, then append
    // the terminator myself; however, then I couldn't process empty
    // strings.

    UINT cschGiveToApi = fCounted ? cschSource
                                  : (cschSource+1);

    UINT cbRet = ::MultiByteToWideChar(CP_ACP,    // use ANSI Code Page
                                       MB_PRECOMPOSED,
                                       (LPSTR)pszSource,
                                       cschGiveToApi,
                                       _pwszStorage,
                                       _cbStorage);
    if (cbRet == 0)
    {
        ReportError(::GetLastError());
        return;
    }

    // Always NUL-terminate result

    if (fCounted)
        _pwszStorage[cbRet] = 0;
}


/*******************************************************************

    NAME:       WCHAR_STRING::~WCHAR_STRING

    SYNOPSIS:   Dtor

    HISTORY:
        beng        02-Mar-1992 Created

********************************************************************/

WCHAR_STRING::~WCHAR_STRING()
{
    delete _pwszStorage;
#if defined(NLS_DEBUG)
    _pwszStorage = (WCHAR*)(-1);
#endif
}


/*******************************************************************

    NAME:       CHAR_STRING::CHAR_STRING

    SYNOPSIS:   Ctor

        Allocates sufficient temporary storage, then maps the given
        Unicode string into a MBCS string.

    ENTRY:      pwszSource - given wide-char source string, Unicode
                cbCopy     - max number of bytes to copy

    EXIT:       Constructed

    RETURNS:    As per class BASE

    CAVEATS:
        NULL is a perfectly acceptable arg here, and will yield
        another NULL (with cb == 0).

    HISTORY:
        beng        02-Mar-1992 Created
        beng        19-Mar-1992 Fixed bug in WCtoMB usage
        beng        29-Mar-1992 cbCopy param added
        thomaspa    08-Apr-1992 Fixed bug in non-NUL term'd strings
        beng        24-Apr-1992 Change meaning of cbCopy==0
        beng        02-Jun-1992 WCtoMB changed

********************************************************************/

CHAR_STRING::CHAR_STRING( const WCHAR * pwszSource, UINT cbCopy )
    : _pszStorage(NULL), _cbStorage(0)
{
    if (pwszSource == NULL || cbCopy == 0)
        return;

    // If called with cbCopy==CBNLSMAGIC, then the string hasn't been
    // counted, but is instead assumed to end with NUL.

    BOOL fCounted = (cbCopy != CBNLSMAGIC);

    // Convert Unicode to MBCS.  Assumes that each Unicode character will
    // require *two* MBCS characters in xlation.  While this will almost always
    // overestimate storage requirements, it's okay since instances of this
    // class have a very short lifespan (he said, hopefully).

    ASSERT(cbCopy == CBNLSMAGIC || (cbCopy % sizeof(WCHAR) == 0)); // must contain a whole # of WCHARs

    UINT cwchSource = fCounted ? cbCopy/sizeof(WCHAR) : (::wcslen(pwszSource));

    _pszStorage = new CHAR[(2*cwchSource)+1];
    if (_pszStorage == NULL)
    {
        ReportError(ERROR_NOT_ENOUGH_MEMORY);
        return;
    }
    _cbStorage = sizeof(CHAR)*((2*cwchSource)+1); // yes, 2, not "sizeof WCHAR"

    // I could always give the API all-but-terminator, then append
    // the terminator myself; however, then I couldn't process empty
    // strings.

    UINT cwchGiveToApi = fCounted ? cwchSource
                                  : (cwchSource+1);

    BOOL fDummy;
    UINT cbRet = ::WideCharToMultiByte(CP_ACP,    // use ANSI Code Page
                                       0,
                                       (LPWSTR)pwszSource,
                                       cwchGiveToApi,
                                       _pszStorage,
                                       _cbStorage,
                                       NULL,
                                       &fDummy);
    if (cbRet == 0)
    {
        ReportError(::GetLastError());
        return;
    }

    // Always NUL-terminate result

    if (fCounted)
        _pszStorage[cbRet] = 0;
}


/*******************************************************************

    NAME:       CHAR_STRING::~CHAR_STRING

    SYNOPSIS:   Dtor

    HISTORY:
        beng        02-Mar-1992 Created

********************************************************************/

CHAR_STRING::~CHAR_STRING()
{
    delete _pszStorage;
#if defined(NLS_DEBUG)
    _pszStorage = (CHAR*)(-1);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\strassgn.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    strassgn.cxx
    NLS/DBCS-aware string class: assignment operator

    This file contains the implementation of the assignment operator
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
        beng        18-Jan-1991 Separated from original monolithic .cxx
        beng        07-Feb-1991 Uses lmui.hxx
        beng        26-Sep-1991 Replaced min with local inline
*/
#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:       NLS_STR::operator=

    SYNOPSIS:   Assignment operator

    ENTRY:      Either NLS_STR or TCHAR*.

    EXIT:       If successful, contents of string overwritten.
                If failed, the original contents of the string remain.

    RETURNS:    Reference to self.

    HISTORY:
        beng        23-Oct-1990 Created
        johnl       13-Nov-1990 Added UIASSERTion checks for using bad
                                strings
        beng        05-Feb-1991 Uses TCHAR * instead of PCH
        Johnl       06-Mar-1991 Removed assertion check for *this
                                being valid
        johnl       12-Apr-1991 Resets error variable on PCH assignment
                                if successful.
        beng        22-Jul-1991 Allow assignment of an erroneous string;
                                reset error on nls assignment as well
        beng        14-Nov-1991 Unicode fixes
        beng        29-Mar-1992 Relocated guts to CopyFrom

********************************************************************/

NLS_STR & NLS_STR::operator=( const NLS_STR & nlsSource )
{
    APIERR err = CopyFrom(nlsSource);

    if (err != NERR_Success)
        ReportError(err);

    return *this;
}


NLS_STR & NLS_STR::operator=( const TCHAR * pchSource )
{
    APIERR err = CopyFrom(pchSource);

    if (err != NERR_Success)
        ReportError(err);

    return *this;
}


/*******************************************************************

    NAME:       NLS_STR::CopyFrom

    SYNOPSIS:   Assignment method which returns an error code

    ENTRY:
        nlsSource   - source argument, either a nlsstr or char vector.
        achSource
        cbCopy      - max number of bytes to copy from source

    EXIT:
        Copied argument into this.  Error code of string set.

    RETURNS:
        Error code of string - NERR_Success if successful.

    NOTES:
        If the CopyFrom fails, the current string will retain its
        original contents and error state.

    HISTORY:
        beng        18-Sep-1991 Created
        beng        19-Sep-1991 Added content-preserving behavior
        beng        29-Mar-1992 Added cbCopy parameter
        beng        24-Apr-1992 Changed meaning of cbCopy == 0

********************************************************************/

APIERR NLS_STR::CopyFrom( const NLS_STR & nlsSource )
{
    // This deliberately doesn't check this->QueryError(), since
    // it can reset an erroneous string.

    if (!nlsSource)
        return nlsSource.QueryError();

    if (this == &nlsSource)
        return NERR_Success;

    if (!Realloc(nlsSource.QueryTextLength()))
        return ERROR_NOT_ENOUGH_MEMORY;

    ::memcpy( _pchData, nlsSource.QueryPch(), nlsSource.QueryTextSize() );
    _cchLen = nlsSource.QueryTextLength();
    IncVers();

    // Reset the error state, since the string is now valid.
    //
    ResetError();
    return NERR_Success;
}


APIERR NLS_STR::CopyFrom( const TCHAR * pchSource, UINT cbCopy )
{
    if ( pchSource == NULL || cbCopy == 0 )
    {
        if ( !IsOwnerAlloc() && QueryAllocSize() == 0 )
        {
            Alloc(0); // will call reporterror if appropriate
            return QueryError();
        }

        UIASSERT( QueryAllocSize() > 0 );

        *_pchData = TCH('\0');
        _cchLen = 0;
    }
    else if (cbCopy == CBNLSMAGIC)
    {
        UINT cchSource = ::strlenf( pchSource );
        UINT cbSource = (cchSource+1) * sizeof(TCHAR);

        if (!Realloc(cchSource))
            return ERROR_NOT_ENOUGH_MEMORY;

        ::memcpy( _pchData, pchSource, cbSource );
        _cchLen = cchSource;
    }
    else
    {
        // Following takes care of half-chars, but isn't necessarily
        // safe in a DBCS environment.  I'm assuming that this fcn will
        // be used by folks who want to copy from a complete, yet non-SZ
        // string (e.g. in a struct UNICODE_STRING); there, it's safe.

        UINT cchSource = cbCopy/sizeof(TCHAR);
        UINT cbSource = cchSource*sizeof(TCHAR);

        if (!Realloc(cchSource))
            return ERROR_NOT_ENOUGH_MEMORY;

        ::memcpy( _pchData, pchSource, cbSource );
        _pchData[cchSource] = 0;
        _cchLen = cchSource;
    }

    IncVers();

    // Reset the error state, since the string is now valid.
    //
    ResetError();
    return NERR_Success;
}


/*******************************************************************

    NAME:       ALIAS_STR::operator=

    SYNOPSIS:   Assignment operator

    ENTRY:      Either NLS_STR or TCHAR*.

    EXIT:       If successful, string aliases new string.
                If failed, the original contents of the string remain.

    RETURNS:    Reference to self.

    NOTES:
        An alias string can only alias a char vector (string literal)
        or an owner-alloc string.  It can't alias a regular dynamic
        string, since that dynamic string may elect to realloc.

    HISTORY:
        beng        14-Nov-1991 Created
        beng        30-Mar-1992 Use BASE::ResetError

********************************************************************/

const ALIAS_STR & ALIAS_STR::operator=( const NLS_STR & nlsSource )
{
    if ( this == &nlsSource )
    {
        // No action needed
        ;
    }
    else if (!nlsSource)
    {
        // Assignment of an erroneous string
        //
        ReportError(nlsSource.QueryError());
    }
    else if (!nlsSource.IsOwnerAlloc())
    {
        // Tried to assign a dynamic string
        //
        ReportError(ERROR_INVALID_PARAMETER);
    }
    else
    {
        _pchData = nlsSource._pchData;
        _cbData = nlsSource._cbData;
        _cchLen = nlsSource._cchLen;
        IncVers();
        ResetError();
    }

    return *this;
}

const ALIAS_STR & ALIAS_STR::operator=( const TCHAR * pszSource )
{
    if (pszSource == NULL)
    {
        // It is not legal to assign a NULL pointer to an alias string,
        // since such a string must have some real string to alias.
        //
        ReportError(ERROR_INVALID_PARAMETER);
    }
    else
    {
        _pchData = (TCHAR*)pszSource; // cast away constness
        _cchLen = ::strlenf(pszSource);
        _cbData = (_cchLen + 1) * sizeof(TCHAR);
        IncVers();
        ResetError();
    }
    return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\stratoi.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    stratoi.cxx
    NLS/DBCS-aware string class: atoi method

    This file contains the implementation of the atoi method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this member function need not link to it.

    FILE HISTORY:
        markbl      04-Jun-1991     Created

*/
#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:       NLS_STR::atoi

    SYNOPSIS:   Returns *this in its integer numeric equivalent

    ENTRY:
        With no arguments, parses from beginning of string.

        Given an ISTR, starts at that point within the string.

    EXIT:

    NOTES:      Uses C-Runtime atoi function

    HISTORY:
        markbl      04-Jun-1991 Written
        beng        22-Jul-1991 Callable on erroneous string;
                                simplified CheckIstr
        beng        08-Mar-1992 Call through to atol member fcn

********************************************************************/

INT NLS_STR::atoi() const
{
    if (QueryError())
        return 0;

    ISTR istr(*this);   // istr pointing to first char
    return atoi(istr);  // call through to other version
}


INT NLS_STR::atoi( const ISTR & istrStart ) const
{
    if (QueryError())
        return 0;

    CheckIstr( istrStart );

    LONG nRes = atol(istrStart);

    // Check for over/underflow
    if (nRes < (LONG)INT_MIN || nRes > (LONG)INT_MAX)
    {
        return 0;
    }

    return (INT)nRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\stratoul.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    stratoul.cxx
    NLS/DBCS-aware string class: atol method

    This file contains the implementation of the atoul method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this member function need not link to it.

    FILE HISTORY:
        beng        18-Jan-1991     Separated from original monolithic .cxx
        beng        07-Feb-1991     Uses lmui.hxx
        terryk      31-Oct-1991     Change atol to strtol
        beng        08-Mar-1992     Include "mappers.hxx"
	terryk	    20-Apr-1992	    Change to atoul
*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:       NLS_STR::atoul

    SYNOPSIS:   Returns *this in its unsigned long numeric equivalent

    ENTRY:
        With no arguments, parses from beginning of string.
        Given an ISTR, starts at that point within the string.

    RETURNS:    Value as a long integer

    HISTORY:
        johnl       26-Nov-1990 Written
        beng        22-Jul-1991 Callable on erroneous string;
                                simplified CheckIstr
        terryk      31-Oct-1991 Change atol to strtol
        beng        08-Mar-1992 Unicode fixes
	terryk	    20-Apr-1992 Change to atoul

********************************************************************/

ULONG NLS_STR::atoul() const
{
    if (QueryError())
        return 0;

    ISTR istr(*this);   // istr pointing to first char
    return atoul(istr);  // call through to other version
}


ULONG NLS_STR::atoul( const ISTR & istrStart ) const
{
    if (QueryError())
        return 0;

    CheckIstr( istrStart );
    CHAR *pszEndPoint;

#if defined(UNICODE)
    // BUGBUG - revisit this mess when we get propert CRT Unicode support

    // Convert Unicode to ASCII to keep the runtimes happy

    CHAR_STRING xsszTemp(QueryPch(istrStart));
    if (!xsszTemp)
        return 0;

    return ::strtoul( xsszTemp.QueryData(), &pszEndPoint, 10 );
#else
    return ::strtoul( QueryPch(istrStart), &pszEndPoint, 10 );
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\strcat.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    strcat.cxx
    NLS/DBCS-aware string class: strcat method

    This file contains the implementation of the strcat method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
        beng        18-Jan-1991 Separated from original monolithic .cxx
        beng        07-Feb-1991 Uses lmui.hxx
        beng        26-Sep-1991 Replaced min with local inline
*/

#include "pchstr.hxx"  // Precompiled header


#ifndef min
inline INT min(INT a, INT b)
{
    return (a < b) ? a : b;
}
#endif

/*******************************************************************

    NAME:       NLS_STR::strcat

    SYNOPSIS:   Concantenate string

    ENTRY:      nlsSuffix - appended to end of string

    EXIT:       Self extended, possibly realloced.
                String doesn't change if a memory allocation failure occurs

    RETURNS:    Reference to self.  Error set on failure.

    NOTES:
        NLS_STR::Append() is the preferred form.

    HISTORY:
        johnl       13-Nov-1990 Written
        beng        22-Jul-1991 Allow on erroneous strings
        beng        15-Nov-1991 Unicode fixes
        beng        07-Mar-1992 Reloc guts into Append fcn

********************************************************************/

NLS_STR & NLS_STR::strcat( const NLS_STR & nlsSuffix )
{
    if (QueryError() || !nlsSuffix)
        return *this;

    APIERR err = Append(nlsSuffix);

    if (err)
        ReportError(err);

    return *this;
}


/*******************************************************************

    NAME:       NLS_STR::Append

    SYNOPSIS:   Append a string to the end of current string

    ENTRY:      nlsSuffix - a string

    EXIT:       nlsSuffix was appended to end of string

    RETURNS:    Error code.  NERR_Success if successful; ERROR_NOT
                ENOUGH_MEMORY should a reallocation fail.

    NOTES:
        Currently checks to see if we need to reallocate the
        string (but we have to traverse it to determine the
        actual storage required).  We may want to change this.

    HISTORY:
        beng        22-Jul-1991 Created (parallel of AppendChar)
        beng        05-Mar-1992 Return the error of a bad argument
        beng        07-Mar-1992 Start at end of string (avoid n**2 behavior)

********************************************************************/

APIERR NLS_STR::Append( const NLS_STR &nlsSuffix )
{
    if (!*this)
        return QueryError();
    if (!nlsSuffix)
        return nlsSuffix.QueryError();

    if (!Realloc( QueryTextLength() + nlsSuffix.QueryTextLength()))
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Don't use strcatf, since it will retraverse the string, giving
    // O(n**2) behavior in loops.  After all, we do have _cchLen handy.

    ::strcpyf( _pchData + _cchLen, nlsSuffix.QueryPch() );
    _cchLen += nlsSuffix.QueryTextLength();

    return 0;
}


/*******************************************************************

    NAME:       NLS_STR::AppendChar

    SYNOPSIS:   Append a single character to the end of current string

    ENTRY:      wch - appended to end of string

    EXIT:       String has the new character.  Could result in a realloc.

    RETURNS:    0 if successful

    HISTORY:
        beng        23-Jul-1991 Created
        beng        15-Nov-1991 Unicode fixes

********************************************************************/

APIERR NLS_STR::AppendChar( WCHAR wch )
{
    // This works by assembling a temporary string of the single
    // character, then using the "strcat" member to append that
    // string to *this.
    //
    // CODEWORK: might do well to append the char directly to the
    // subject string.  Need to profile and see.

    TCHAR tch [3] ;

#if defined(UNICODE)

    tch[0] = wch ;
    tch[1] = 0 ;

#else

    if (HIBYTE(wch) == 0)
    {
        // Single-byte character
        tch[0] = LOBYTE(wch);
        tch[1] = TCH('\0');
    }
    else
    {
        // Double-byte character
        tch[0] = HIBYTE(wch); // lead byte
        tch[1] = LOBYTE(wch);
        tch[2] = TCH('\0');
    }

#endif

    ALIAS_STR nlsTemp( tch ) ;

    return Append(nlsTemp);
}


/*******************************************************************

    NAME:       NLS_STR::operator+=

    SYNOPSIS:   Append a string to the end of current string

    ENTRY:      nlsSecond - appended to end of string

    EXIT:

    RETURNS:

    NOTES:      Little more than a wrapper around strcat.

    HISTORY:
        beng        23-Jul-1991     Header added

********************************************************************/

NLS_STR & NLS_STR::operator+=( const NLS_STR & nlsSecond )
{
    return strcat( nlsSecond );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\stratol.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    stratol.cxx
    NLS/DBCS-aware string class: atol method

    This file contains the implementation of the atol method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this member function need not link to it.

    FILE HISTORY:
        beng        18-Jan-1991     Separated from original monolithic .cxx
        beng        07-Feb-1991     Uses lmui.hxx
        terryk      31-Oct-1991     Change atol to strtol
        beng        08-Mar-1992     Include "mappers.hxx"
*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:       NLS_STR::atol

    SYNOPSIS:   Returns *this in its long numeric equivalent

    ENTRY:
        With no arguments, parses from beginning of string.
        Given an ISTR, starts at that point within the string.

    RETURNS:    Value as a long integer

    HISTORY:
        johnl       26-Nov-1990 Written
        beng        22-Jul-1991 Callable on erroneous string;
                                simplified CheckIstr
        terryk      31-Oct-1991 Change atol to strtol
        beng        08-Mar-1992 Unicode fixes

********************************************************************/

LONG NLS_STR::atol() const
{
    if (QueryError())
        return 0;

    ISTR istr(*this);   // istr pointing to first char
    return atol(istr);  // call through to other version
}


LONG NLS_STR::atol( const ISTR & istrStart ) const
{
    if (QueryError())
        return 0;

    CheckIstr( istrStart );
    CHAR *pszEndPoint;

#if defined(UNICODE)
    // BUGBUG - revisit this mess when we get propert CRT Unicode support

    // Convert Unicode to ASCII to keep the runtimes happy

    CHAR_STRING xsszTemp(QueryPch(istrStart));
    if (!xsszTemp)
        return 0;

    return ::strtol( xsszTemp.QueryData(), &pszEndPoint, 10 );
#else
    return ::strtol( QueryPch(istrStart), &pszEndPoint, 10 );
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\strchr.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    strchr.cxx
    NLS/DBCS-aware string class: strchr method

    This file contains the implementation of the strchr method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
	beng	    18-Jan-1991     Separated from original monolithic .cxx
	beng	    07-Feb-1991     Uses lmui.hxx

*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:	NLS_STR::strchr

    SYNOPSIS:	Puts the index of the first occurrence of ch in *this
		into istrPos.


    ENTRY:	pistrPos - points to ISTR in which to leave pos
		ch	 - character sought
		istrStart- staring point in string.  If omitted, start
			   at beginning

    EXIT:	pistrPos

    RETURNS:	TRUE if character found; otherwise FALSE

    NOTES:
	This routine only works for TCHAR - not WCHAR.
	Hence it is useless for double-byte characters
	under MBCS.

    HISTORY:
	johnl	    26-Nov-1990 Written
	beng	    22-Jul-1991 Allow on erroneous strings;
				simplified CheckIstr
	beng	    21-Nov-1991 Unicode fixes

********************************************************************/

BOOL NLS_STR::strchr( ISTR * pistrPos, const TCHAR ch ) const
{
    if ( QueryError() )
	return FALSE;

    UpdateIstr( pistrPos );
    CheckIstr( *pistrPos );

    const TCHAR * pchStrRes = ::strchrf( QueryPch(), ch );

    if ( pchStrRes == NULL )
    {
	pistrPos->SetIch( QueryTextLength() );
	return FALSE;
    }

    pistrPos->SetIch( (INT)(pchStrRes - QueryPch()) );
    return TRUE;
}


BOOL NLS_STR::strchr( ISTR * pistrPos, const TCHAR ch,
		      const ISTR & istrStart ) const
{
    if ( QueryError() )
	return FALSE;

    CheckIstr( istrStart );
    UpdateIstr( pistrPos );
    CheckIstr( *pistrPos );

    const TCHAR * pchStrRes = ::strchrf( QueryPch(istrStart), ch );

    if ( pchStrRes == NULL )
    {
	pistrPos->SetIch( QueryTextLength() );
	return FALSE;
    }

    pistrPos->SetIch( (INT)(pchStrRes - QueryPch()) );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\strcmp.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    strcmp.cxx
    NLS/DBCS-aware string class: strcmp method and equality operator

    This file contains the implementation of the strcmp method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
        beng        18-Jan-1991     Separated from original monolithic .cxx
        beng        07-Feb-1991     Uses lmui.hxx
        jonn        04-Sep-1992     Compare() is _CRTAPI1

*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:       NLS_STR::operator==

    SYNOPSIS:   Case-sensitive test for equality

    RETURNS:    TRUE if the two operands are equal (case sensitive);
                else FALSE

    NOTES:      An erroneous string matches nothing.

    HISTORY:
        johnl       11-Nov-90       Written
        beng        23-Jul-1991     Allow on erroneous strings

********************************************************************/

BOOL NLS_STR::operator==( const NLS_STR & nls ) const
{
    if (QueryError() || !nls)
        return FALSE;

    return !::strcmpf( QueryPch(), nls.QueryPch() );
}


/*******************************************************************

    NAME:       NLS_STR::Compare

    SYNOPSIS:   Case-sensitive test for equality

    RETURNS:    TRUE if the two operands are equal (case sensitive);
                else FALSE

    NOTES:      An erroneous string matches nothing.

    HISTORY:
        jonn        04-Sep-1992     Compare must be _CRTAPI1

********************************************************************/

INT __cdecl NLS_STR::Compare( const NLS_STR * pnls ) const
{
    return(strcmp(*pnls));
}


/*******************************************************************

    NAME:       NLS_STR::operator!=

    SYNOPSIS:   Case-sensitive test for inequality

    RETURNS:    TRUE if the two operands are unequal (case sensitive);
                else FALSE

    NOTES:      An erroneous string matches nothing.

    HISTORY:
        beng        23-Jul-1991     Header added

********************************************************************/

BOOL NLS_STR::operator!=( const NLS_STR & nls ) const
{
    return ! operator==( nls );
}


/*******************************************************************

    NAME:       NLS_STR::strcmp

    SYNOPSIS:   Standard string compare with optional character indexes

    ENTRY:      nls                   - string against which to compare
                istrStart1 (optional) - index into "this"
                istrStart2 (optional) - index into "nls"

    RETURNS:    As the C runtime "strcmp".

    NOTES:      If either string is erroneous, return "match."
                This runs contrary to the eqop.

                Glock doesn't allow default parameters which require
                construction; hence this member is overloaded multiply.

    HISTORY:
        johnl       15-Nov-1990     Written
        johnl       19-Nov-1990     Changed to use ISTR, overloaded for
                                    different number of ISTRs
        beng        23-Jul-1991     Allow on erroneous strings;
                                    simplified CheckIstr

********************************************************************/

INT NLS_STR::strcmp( const NLS_STR & nls ) const
{
    if (QueryError() || !nls)
        return 0;

    return ::strcmpf( QueryPch(), nls.QueryPch() );
}

INT NLS_STR::strcmp(
    const NLS_STR & nls,
    const ISTR    & istrStart1 ) const
{
    if (QueryError() || !nls)
        return 0;

    CheckIstr( istrStart1 );

    return ::strcmpf( QueryPch(istrStart1) , nls.QueryPch() );
}

INT NLS_STR::strcmp(
    const NLS_STR & nls,
    const ISTR    & istrStart1,
    const ISTR    & istrStart2 ) const
{
    if (QueryError() || !nls)
        return 0;

    CheckIstr( istrStart1 );
    nls.CheckIstr( istrStart2 );

    return ::strcmpf( QueryPch(istrStart1), nls.QueryPch(istrStart2) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\strcpy.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    strcpy.cxx
    NLS/DBCS-aware string class: strcpy function

    This file contains the implementation of the strcpy function
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
        beng        18-Jan-1991 Separated from original monolithic .cxx
        beng        07-Feb-1991 Uses lmui.hxx
        beng        02-Mar-1992 Added CopyTo

*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:       NLS_STR::CopyTo

    SYNOPSIS:   Copies the string to the passed bytevector,
                checking the length

    ENTRY:      pchDest     - pointer to TCHAR array destination
                cbAvailable - bytes of storage available at destination

    EXIT:       pchDest  - written

    RETURNS:
        NERR_Success if successful.
        ERROR_NOT_ENOUGH_MEMORY if destination buffer too small.

    NOTES:
        If called on an erroneous string, returns that string's error state.

    HISTORY:
        beng        02-Mar-1992 Created

********************************************************************/

APIERR NLS_STR::CopyTo( TCHAR * pchDest, UINT cbAvailable ) const
{
    if (QueryError())
        return QueryError();

    if (QueryTextSize() > cbAvailable)
        return ERROR_NOT_ENOUGH_MEMORY;

    ::strcpyf(pchDest, QueryPch());
    return NERR_Success;
}


/*******************************************************************

    NAME:       NLS_STR::strcpy

    SYNOPSIS:   Copies the string to the passed bytevector.

    ENTRY:      pchDest  - pointer to TCHAR array destination
                nls      - source string

    EXIT:       pchDest  - written

    RETURNS:    Destination string (as C runtime "strcpy")

    NOTES:
        If called on an erroneous string, copies a null string.

    HISTORY:
        Johnl       27-Dec-1990 Created
        beng        23-Jul-1991 Allow from erroneous strings
        beng        21-Nov-1991 Remove static empty string

********************************************************************/
DLL_BASED
TCHAR * strcpy( TCHAR * pchDest, const NLS_STR& nls )
{
    if (!nls)
    {
        *pchDest = TCH('\0');
        return pchDest;
    }
    else
    {
        return ::strcpyf( pchDest, nls.QueryPch() );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\strdss.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    strdss.cxx
    NLS/DBCS-aware string class: DelSubStr method

    This file contains the implementation of the DelSubStr method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
	beng	    18-Jan-1991     Separated from original monolithic .cxx
	beng	    07-Feb-1991     Uses lmui.hxx

*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:	NLS_STR::DelSubStr

    SYNOPSIS:	Collapse the string by removing the characters from
		istrStart to:
			 istrStart  to the end of string
			 istrStart + istrEnd
		The string is not reallocated

    ENTRY:

    EXIT:	Modifies istrStart

    NOTES:
	The method DelSubStr( ISTR&, CCH ) is private and does
	the work.

    HISTORY:
	johnl	    26-Nov-1990 Created
	beng	    26-Apr-1991 Replaced CB with INT
	beng	    23-Jul-1991 Allow on erroneous strings;
				simplified CheckIstr
	beng	    15-Nov-1991 Unicode fixes

********************************************************************/

VOID NLS_STR::DelSubStr( ISTR & istrStart,
			 UINT	cchLen )
{
    if (QueryError())
	return;

    CheckIstr( istrStart );

    TCHAR * pchStart = _pchData + istrStart.QueryIch();

    // cchLen == 0 means delete to end of string

    if ( cchLen == 0 )
	*pchStart = TCH('\0');
    else
    {
	UINT cbNewEOS = (::strlenf( pchStart + cchLen ) + 1)
			* sizeof(TCHAR);

	::memmove(pchStart, pchStart + cchLen, cbNewEOS);
    }

    _cchLen = ::strlenf( QueryPch() );

    IncVers();
    UpdateIstr( &istrStart );
}


VOID NLS_STR::DelSubStr( ISTR & istrStart )
{
    if (QueryError())
	return;

    // 0 means delete to end of string.  (Deleting a 0-length substring
    // is meaningless otherwise, so this makes a good magic value.  It
    // will never otherwise appear, since the public interface special-
    // cases the istrEnd == istrStart scenario.)

    DelSubStr( istrStart, 0 );
}


VOID NLS_STR::DelSubStr(       ISTR & istrStart,
			 const ISTR & istrEnd  )
{
    if (QueryError())
	return;

    CheckIstr( istrEnd );
    UIASSERT( istrEnd.QueryIch() >= istrStart.QueryIch() );

    if (istrEnd == istrStart)
	return;

    DelSubStr( istrStart, istrEnd - istrStart );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\strelaps.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990-1992              **/
/**********************************************************************/

/*
    strelaps.cxx
    Class definitions for the ELAPSED_TIME_STR class.


    FILE HISTORY:
        KeithMo     23-Mar-1992     Created for the Server Manager.

*/
#include "pchstr.hxx"  // Precompiled header

//
//  ELAPSED_TIME_STR methods
//

/*******************************************************************

    NAME:           ELAPSED_TIME_STR :: ELAPSED_TIME_STR

    SYNOPSIS:       ELAPSED_TIME_STR class constructor.

    ENTRY:          ulTime              - Elapsed time (in seconds).

                    chTimeSep           - The current time separator.

                    fShowSeconds        - If TRUE, then a 'seconds' field
                                          will be appended to the time
                                          string.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     23-Mar-1992     Created for the Server Manager.

********************************************************************/
ELAPSED_TIME_STR :: ELAPSED_TIME_STR( ULONG ulTime,
                                      TCHAR chTimeSep,
                                      BOOL  fShowSeconds )
  : NLS_STR()
{
    UIASSERT( chTimeSep != TCH('\0') );

    //
    //  Let's make sure everything constructed OK.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    //
    //  Create an NLS_STR for the time separator.
    //

    TCHAR szTimeSep[2];

    szTimeSep[0] = chTimeSep;
    szTimeSep[1] = TCH('\0');

    ALIAS_STR nlsTimeSep( szTimeSep );
    UIASSERT( nlsTimeSep.QueryError() == NERR_Success );

    APIERR err;

    //
    //  Concatenate the hours/sep/minutes[/sep/seconds] together.
    //

    {
        DEC_STR nls( ulTime / 3600L, 2 );

        err = nls.QueryError();

        if( err == NERR_Success )
        {
            strcat( nls );
            err = QueryError();
        }
    }

    if( err == NERR_Success )
    {
        strcat( nlsTimeSep );
        err = QueryError();

        if( err == NERR_Success )
        {
            DEC_STR nls( ( ulTime % 3600L ) / 60L, 2 );

            err = nls.QueryError();

            if( err == NERR_Success )
            {
                strcat( nls );
                err = QueryError();
            }
        }
    }

    if( fShowSeconds && ( err == NERR_Success ) )
    {
        strcat( nlsTimeSep );
        err = QueryError();

        if( err == NERR_Success )
        {
            DEC_STR nls( ulTime % 60L, 2 );

            err = nls.QueryError();

            if( err == NERR_Success )
            {
                strcat( nls );
                err = QueryError();
            }
        }
    }

    if( err != NERR_Success )
    {
        ReportError( err );
    }

}   // ELAPSED_TIME_STR :: ELAPSED_TIME_STR


/*******************************************************************

    NAME:           ELAPSED_TIME_STR :: ~ELAPSED_TIME_STR

    SYNOPSIS:       ELAPSED_TIME_STR class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     23-Mar-1992     Created for the Server Manager.

********************************************************************/
ELAPSED_TIME_STR :: ~ELAPSED_TIME_STR( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // ELAPSED_TIME_STR :: ~ELAPSED_TIME_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\strcspn.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    strcspn.cxx
    NLS/DBCS-aware string class: strcspn method

    This file contains the implementation of the strcspn method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
	beng	    18-Jan-1991     Separated from original monolithic .cxx
	beng	    07-Feb-1991     Uses lmui.hxx

*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:	NLS_STR::strcspn

    SYNOPSIS:	Set membership.  Finds the first matching character
		in the passed string

    ENTRY:	pistrPos - destination for results
		nls	 - set of sought characters

    EXIT:	*pistrPos contains offset within "this" of element
		found (assuming it was successful); otherwise it
		is moved to the end of the string.

    RETURNS:	TRUE if any character found; FALSE otherwise

    NOTES:

    HISTORY:
	johnl	    16-Nov-1990     Written
	beng	    23-Jul-1991     Allow on erroneous strings;
				    simplified CheckIstr

********************************************************************/

BOOL NLS_STR::strcspn( ISTR* pistrPos, const NLS_STR & nls ) const
{
    if (QueryError() || !nls)
	return FALSE;

    UpdateIstr( pistrPos );
    CheckIstr( *pistrPos );

    pistrPos->SetIch( ::strcspnf( QueryPch(), nls.QueryPch() ) );
    return *QueryPch( *pistrPos ) != TCH('\0');
}


BOOL NLS_STR::strcspn( ISTR * pistrPos,
		       const NLS_STR & nls,
		       const ISTR & istrStart ) const
{
    if (QueryError() || !nls)
	return FALSE;

    UpdateIstr( pistrPos );
    CheckIstr( *pistrPos );
    CheckIstr( istrStart );

    pistrPos->SetIch( ::strcspnf( QueryPch(istrStart), nls.QueryPch() )
		     + istrStart.QueryIch()  );
    return *QueryPch( *pistrPos ) != TCH('\0');
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\strinsrt.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    strinsrt.cxx
    NLS/DBCS-aware string class: InsertParams method

    This file contains the implementation of the InsertParams method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
        Johnl       31-Jan-1991 Created
        beng        07-Feb-1991 Uses lmui.hxx
        KeithMo     09-Oct-1991 Win32 Conversion.
        beng        28-Jul-1992 Fix conflicting def'n of MAX_INSERT_PARAMS
*/

#include "pchstr.hxx"  // Precompiled header


#define PARAM_ESC         TCH('%')


/*******************************************************************

    NAME:      NLS_STR::InsertParams

    SYNOPSIS:  Fill in a message string from the resource file
               replacing the number parameters with the real text.

    ENTRY:     *this contains the message text
               apnlsParams is an array of pointers to NLS_STRs

               Example:

                 *this = "Error %1 occurred, do %2, or %1 will happen again"
                 apnlsParams[0] = "696969"
                 apnlsParams[1] = "Something else"

                 Return string = "Error 696969 occurred, do Something else or
                                  696969 will happen again"

               Alternately, cpnlsArgs gives the number of strings supplied,
               followed on the stack by the appropriate number of string
               pointers.

    EXIT:      0 if successful, error code otherwise, one of:
                   ERROR_INVALID_PARAMETER
                   ERROR_NOT_ENOUGH_MEMORY

    NOTES:
        The minimum parameter is 1, the maximum parameter is 99.

        The array of param strings must have a NULL to mark
        the end of the array.

    CAVEATS:
        This function doesn't work quite the same way as does the NT
        FormatMessage API.  It very simplemindedly substitutes those
        escape sequences found, but doesn't do anything else with %
        sequences (such as %%).

    HISTORY:
        JohnL       1/30/91     Created
        beng        26-Apr-1991 Uses WCHAR
        beng        23-Jul-1991 Allow on erroneous string
        beng        20-Nov-1991 Unicode fixes
        beng        27-Feb-1992 Additional forms
        beng        05-Mar-1992 Upped max params to 99; code sharing rewrite
        YiHsinS     30-Nov-1992 Make this function work more like FormatMessage
			        Supports %0, %\,...
        YiHsinS     23-Dec-1992 Use "%\" instead of "%n" and added support
  				for "%t"

********************************************************************/

APIERR NLS_STR::InsertParams( const NLS_STR ** apnlsParams )
{
    if (QueryError())
        return QueryError();

    // How many parameters were we passed?  Count and check each.
    //
    UINT cParams = 0;
    while ( apnlsParams[cParams] != NULL )
    {
        APIERR err = apnlsParams[cParams]->QueryError();
        if (err != NERR_Success)
            return err;

        ++cParams;
    }

    if ( cParams > MAX_INSERT_PARAMS )
        return ERROR_INVALID_PARAMETER;

    // Determine total string length required for the expanded string
    // and get out if we can't fulfill the request
    //

    UINT cchMax = 0;
    APIERR err = InsertParamsAux(apnlsParams, cParams, FALSE, &cchMax);
    if (err != NERR_Success)
        return err;
    ASSERT(cchMax != 0);

    if ( !Realloc( cchMax ) )
        return ERROR_NOT_ENOUGH_MEMORY;

    // Now do the parameter substitution.
    //
    return InsertParamsAux(apnlsParams, cParams, TRUE, NULL);
}


APIERR NLS_STR::InsertParams( UINT cpnlsArgs, const NLS_STR * parg1, ... )
{
    va_list v;

    const NLS_STR * * apnlsList = (const NLS_STR * *) new NLS_STR * [ cpnlsArgs + 1 ] ;
    if (NULL == apnlsList) return ERROR_NOT_ENOUGH_MEMORY; // JonN 01/23/00: PREFIX bug 444888

    apnlsList[0] = parg1;

    va_start(v, parg1);
    for ( UINT i = 1 ; i < cpnlsArgs ; ++i )
    {
        const NLS_STR * pnlsArgNext = (const NLS_STR *)va_arg(v, NLS_STR*);
        apnlsList[i] = pnlsArgNext;
    }
    va_end(v);
    apnlsList[cpnlsArgs] = NULL;

    APIERR err = InsertParams(apnlsList);
	// NTRAID#NTBUG9-577099-2002/03/08-artm  Prefast:  use delete [].
	// Allocated with new []; use delete [] to avoid memory leak.
    delete (NLS_STR * *) apnlsList;
    return err;
}


/*******************************************************************

    NAME:      NLS_STR::InsertParamsAux

    SYNOPSIS:  Helper routine for InsertParams

        This routine allows code sharing between the loop which calcs
        the storage needed in the resulting string and the loop which
        performs the actual parameter insertion.

    ENTRY:
            apnlsParams       - vector of parameter strings to insert,
                                NULL-terminated.
            cParams           - count of items in above vector
            fDoReplace        - set to TRUE if caller wants actual
                                substitution performed.
            pcchRequired      - points to storage for char count,
                                or NULL if not desired

    EXIT:
            pcchRequired      - instantiated with count of characters
                                required (if non-NULL).
            *this             - if fDoReplace, substitution performed

    RETURNS:
        NERR_Success if successful
        ERROR_INVALID_PARAMETER if something wrong with format string
        (e.g. invalid insert specifier).
        Other errors possible as a result of the substitution.

    NOTES:
        This is a private member function.

        InsertParams calls this routine twice while doing its duty.
        The first call calculates the storage required; after that,
        it resizes the string appropriately, then calls this again
        to perform the actual substitution.

        See NLS_STR::InsertParams for more discussion.

    HISTORY:
        beng        05-Mar-1992 Created (code sharing within InsertParams)

********************************************************************/

APIERR NLS_STR::InsertParamsAux( const NLS_STR ** apnlsParams,
                                 UINT cParams, BOOL fDoReplace,
                                 UINT * pcchRequired )
{
    // If pcchRequired is non-NULL, then the caller wants this
    // routine to figure the amount of storage the total param-subbed
    // string would require (TCHARs, less terminator).

    UINT cchMax = (pcchRequired != NULL) ? QueryTextLength() : 0;

    ISTR istrCurPos( *this );
    while ( strchr( &istrCurPos, PARAM_ESC, istrCurPos ) )
    {
        ISTR istrParamEsc( istrCurPos );
        WCHAR wchParam = QueryChar( ++istrCurPos );

        //
        // If this PARAM_ESC didn't delimit an insertion point,
        // continue as if nothing had happened.
        //
        if ( wchParam < TCH('1') || wchParam > TCH('9') )
            continue;

        // CurPos now points to one or two decimal digits.
        // Time for a quick and cheap numeric conversion within this range.

        UINT iParam = (wchParam - TCH('0'));
        wchParam = QueryChar(++istrCurPos);
        if (wchParam >= TCH('0') && wchParam <= TCH('9'))
        {
            iParam *= 10;
            iParam += (wchParam - TCH('0'));
            ++istrCurPos;
        }

        // N.b. Escape sequences are 1-base, but array indices 0-base
        //
        iParam -= 1;

        if (iParam >= cParams)
            continue;

        if (pcchRequired != NULL)
        {
            // Adjust calculation of required storage.  The PARAM_ESC
            // and its following digits will be deleted; the parameter
            // string, inserted.

            cchMax -= (istrCurPos - istrParamEsc);
            cchMax += apnlsParams[iParam]->QueryTextLength();
        }

        if (fDoReplace)
        {
            ReplSubStr( *apnlsParams[iParam],
                        istrParamEsc,
                        istrCurPos );

            // CurPos was invalidated, revalidate
            istrCurPos = istrParamEsc;
            istrCurPos += apnlsParams[iParam]->QueryTextLength();
        }
    }

    if (pcchRequired != NULL)
        *pcchRequired = cchMax;

    return QueryError();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\stris.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    stris.cxx
    NLS/DBCS-aware string class: InsertStr method

    This file contains the implementation of the InsertStr method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
	beng	    18-Jan-1991     Separated from original monolithic .cxx
	beng	    07-Feb-1991     Uses lmui.hxx

*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:	NLS_STR::InsertStr

    SYNOPSIS:	Insert passed string into *this at istrStart

    ENTRY:

    EXIT:	If this function returns FALSE, ReportError has been
		called to report the error that occurred.

    RETURN:	TRUE on success, FALSE otherwise.

    NOTES:	If *this is not STR_OWNERALLOCed and the inserted string
		won't fit in the allocated space for *this, then *this
		will be reallocated.

    HISTORY:
	johnl	    28-Nov-1990 Created
	rustanl     14-Apr-1991 Fixed new length calculation.  Report
				error if owner alloc'd and not enough space.
	beng	    26-Apr-1991 Replaced CB with INT
	beng	    23-Jul-1991 Allow on erroneous string;
				simplified CheckIstr
	beng	    15-Nov-1991 Unicode fixes

********************************************************************/

BOOL NLS_STR::InsertStr( const NLS_STR & nlsIns, ISTR & istrStart )
{
    if (QueryError() || !nlsIns)
	return FALSE;

    CheckIstr( istrStart );

    INT cchNewSize = QueryTextLength() + nlsIns.QueryTextLength();

    if (!Realloc(cchNewSize))
    {
	ReportError( ERROR_NOT_ENOUGH_MEMORY );
	return FALSE;
    }

    TCHAR * pchStart = _pchData + istrStart.QueryIch();

    ::memmove(pchStart + nlsIns.QueryTextLength(),
	      pchStart,
	      (::strlenf(pchStart)+1) * sizeof(TCHAR) );
    ::memmove(pchStart,
	      nlsIns._pchData,
	      nlsIns.QueryTextSize() - sizeof(TCHAR) );

    _cchLen = cchNewSize;

    IncVers();
    UpdateIstr( &istrStart );	    // This ISTR does not become invalid
				    // after the string update
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\stricmp.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    stricmp.cxx
    NLS/DBCS-aware string class: stricmp method

    This file contains the implementation of the stricmp method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
	beng	    18-Jan-1991     Separated from original monolithic .cxx
	beng	    07-Feb-1991     Uses lmui.hxx

*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:	NLS_STR::stricmp

    SYNOPSIS:	Case insensitive string compare w/ optional indices

    ENTRY:	nls		      - string against which to compare
		istrStart1 (optional) - index into "this"
		istrStart2 (optional) - index into "nls"

    RETURNS:	As the C runtime "strcmp".

    NOTES:	If either string is erroneous, return "match."
		This runs contrary to the eqop.

		Glock doesn't allow default parameters which require
		construction; hence this member is overloaded multiply.

    HISTORY:
	johnl	    15-Nov-1990     Written
	beng	    23-Jul-1991     Allow on erroneous strings;
				    simplified CheckIstr

********************************************************************/

INT NLS_STR::_stricmp( const NLS_STR & nls ) const
{
    if (QueryError() || !nls)
	return 0;

    return ::stricmpf( QueryPch(), nls.QueryPch() );
}


INT NLS_STR::_stricmp(
    const NLS_STR & nls,
    const ISTR	  & istrStart1 ) const
{
    if (QueryError() || !nls)
	return 0;

    CheckIstr( istrStart1 );

    return ::stricmpf( QueryPch(istrStart1), nls.QueryPch() );
}


INT NLS_STR::_stricmp(
    const NLS_STR & nls,
    const ISTR	  & istrStart1,
    const ISTR	  & istrStart2 ) const
{
    if (QueryError() || !nls)
	return 0;

    CheckIstr( istrStart1 );
    nls.CheckIstr( istrStart2 );

    return ::stricmpf( QueryPch(istrStart1), nls.QueryPch(istrStart2) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\strload.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    strload.cxx
    NLS/DBCS-aware string class:  LoadString methods

    This file contains the implementation of the LoadString methods
    for the NLS_STR class.  It is separate so that clients of NLS_STR who
    do not use this operator need not link to it.

    FILE HISTORY:
        rustanl     31-Jan-1991     Created
        beng        07-Feb-1991     Uses lmui.hxx
        beng        27-Jul-1992     No longer links to uimisc
        Yi-HsinS    14-Aug-1992     Make method "load" load system strings too
*/

#include "pchstr.hxx"  // Precompiled header

extern "C"
{
    //  Define the "default" HMODULE for use in this load function
    extern HMODULE hmodBase ;
}

#define NETMSG_DLL_STRING SZ("netmsg.dll")


/*******************************************************************

    NAME:       NLS_STR::Load

    SYNOPSIS:   Loads a string from a resource file.

    ENTRY:      msgid   - ID of the string resource to load
                hmod    - the module instance to use for the load

    EXIT:       Zaps the current contents of the string.

    RETURNS:    Error value, which is NERR_Success on success.

    NOTES:
        This function was created to allow separate BLT from the
        NLS classes.

    HISTORY:
        DavidHov    17-Sep-1993 Created

********************************************************************/

APIERR NLS_STR::Load ( MSGID msgid, HMODULE hmod )
{
    if ( msgid < IDS_UI_BASE )
    {
        return LoadSystem( msgid );
    }

    // Since I'm reading the data directly from the system, I need a
    // new "transmutable" type which corresponds to what the SYSTEM
    // contains.  Conceivably this could be compiled ifndef UNICODE on
    // a UNICODE-native Win32 world.  Ordinarily LoadString handles
    // this for the client - oh, for a portable SizeofString!

#if defined(WIN32)
    typedef WCHAR   XCHAR;
    typedef WORD    UXCHAR;
#else
    typedef CHAR    XCHAR;
    typedef BYTE    UXCHAR;
#endif

    //  Supply the default HMODULE if necessary
    if ( hmod == NLS_BASE_DLL_HMOD )
    {
        hmod = ::hmodBase ;
    }

    const ULONG nRsrc = ((USHORT)msgid >> 4) + 1;

    // Find the packet of strings ("nRsrc" calculated above).

    HRSRC hrsrc = ::FindResource(hmod, (LPTSTR)((ULONG_PTR)nRsrc), RT_STRING);
    if (hrsrc == NULL)
    {
        return ERROR_MR_MID_NOT_FOUND;
    }
    HGLOBAL hsegString = ::LoadResource(hmod, hrsrc); // no Free req'd
    if (hsegString == NULL)
    {
        return ERROR_MR_MID_NOT_FOUND;
    }
    const XCHAR * pszMess = (const XCHAR *)::LockResource(hsegString);
    if (pszMess == NULL)
    {
        return ERROR_MR_MID_NOT_FOUND;
    }

    // Dredge the desired string out of the packet

    UINT iString = (UINT) (msgid & 0x0f);
    UINT cch = 0;
    for (;;)
    {
        cch = (UINT) *(const UXCHAR *)pszMess++; // prefixed by length
        if (iString-- == 0)
            break;
        pszMess += cch; // not this string, so skip it and move along
    }

    if (cch == 0)
    {
#if !defined(WIN32)
        ::UnlockResource(hsegString);
#endif
        return ERROR_MR_MID_NOT_FOUND;
    }

    // Now cch and pszMess have the string, which BTW isn't NUL term'd.
    // Let MapCopyFrom take care of conversion, allocation, termination,
    // marking string as changed, etc.

    APIERR err = MapCopyFrom( pszMess, cch * sizeof(*pszMess) );
#if !defined(WIN32)
    ::UnlockResource(hsegString);
#endif
    return err;
}


/*******************************************************************

    NAME:       NLS_STR::LoadSystem

    SYNOPSIS:   Loads a string from the system's resource files.

    ENTRY:      msgid   - ID of the string resource to load

    EXIT:       Zaps the current contents of the string.

    RETURNS:    Error value, which is NERR_Success on success.

    HISTORY:
        beng        05-Aug-1992 Created
        YiHsinS     01-Jan-1993 Use W version of FormatMessage
        DonRyan     18-May-1994 Reintroduced for LM_EVENT_LOG

********************************************************************/

APIERR NLS_STR::LoadSystem( MSGID msgid )
{
    if (QueryError())
        return QueryError();

    HANDLE hmod = NULL;
    DWORD dwFlags =  FORMAT_MESSAGE_ALLOCATE_BUFFER |
                     FORMAT_MESSAGE_IGNORE_INSERTS  |
                     FORMAT_MESSAGE_MAX_WIDTH_MASK;

    if ((msgid <= MAX_LANMAN_MESSAGE_ID) && (msgid >= MIN_LANMAN_MESSAGE_ID))
    {
        // Net Errors
        dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
        hmod = ::GetModuleHandle( NETMSG_DLL_STRING );
    }
    else   // other system errors
    {
        dwFlags |= FORMAT_MESSAGE_FROM_SYSTEM;
    }


    TCHAR* pchBuffer = NULL;
    UINT cch = (UINT) ::FormatMessage( dwFlags,
                                       hmod,
                                       msgid,
                                       0,
                                       (LPTSTR)&pchBuffer,
                                       1024,
                                       NULL );
    if (cch > 0)
    {
        APIERR err = CopyFrom(pchBuffer);
        ::LocalFree((VOID*)pchBuffer);
        return err;
    }
    else
    {
        return ::GetLastError();
    }
}


/*******************************************************************

    NAME:       RESOURCE_STR::RESOURCE_STR

    SYNOPSIS:   Constructs a nls-string from a resource ID.

    ENTRY:      idResource

    EXIT:       Successful construct, or else ReportError

    NOTES:      This string may not be owner-alloc!  For owner-alloc,
                cons up a new one and copy this into it.

    HISTORY:
        DavidHov    17-Sep-1993 Created

********************************************************************/

RESOURCE_STR::RESOURCE_STR( MSGID msgid, HMODULE hmod )
    : NLS_STR()
{
    UIASSERT(!IsOwnerAlloc());

    APIERR err = Load( msgid, hmod );
    if (err)
        ReportError(err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\strlist.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    strlist.cxx
    String List Class : implementation

    See string.hxx

    FILE HISTORY:
        chuckc      2-Jan-1991      Created
        beng        07-Feb-1991     Uses lmui.hxx
        terryk      11-Jul-1991     Add the fDestroy parameter in the
                                    constructors. The fDestroy parameter is
                                    used to indicate whether you want the
                                    slist destructor to delete the element or
                                    not.
        KeithMo     09-Oct-1991     Win32 Conversion.
        beng        17-Jun-1992     Remove single-string ctors
*/

#include "pchstr.hxx"  // Precompiled header


#if !defined(LM_2)
DEFINE_EXT_SLIST_OF(NLS_STR)
#endif


/*******************************************************************

    NAME:       STRLIST::STRLIST

    SYNOPSIS:   Constructor for STRLIST

    ENTRY:      BOOL fDestroy - flag for free the memory during
                                destruction. The default value is
                                TRUE.

    NOTES:
                The default constructor creates an empty string.

    HISTORY:
        chuckc      2-Jan-1991      Created
        terryk      11-Jul-1991     Add the fDestroy flag to the constructors

********************************************************************/

STRLIST::STRLIST( BOOL fDestroy )
        : SLIST_OF(NLS_STR) ( fDestroy )
{
    this->Clear();
}


/*******************************************************************

    NAME:       STRLIST::STRLIST

    SYNOPSIS:   Constructor for STRLIST

    ENTRY:      valid strings in pszSrc, pszSep
                BOOL fDestroy - flag for free the memory during
                                destruction. The default value is
                                TRUE.

    EXIT:       if pszSrc & pszSep have valid nonempty string,
                we end up with STRLIST as describe below. Else
                and empty STRLIST if anything goes wrong.

    NOTES:      Takes a Src string of tokens, and a Sep string
                of separators. We end up with a STRLIST with the
                source string being broken into its tokens. Multiple
                separators are allowed, contigous separators in the Src
                string are handled.

    HISTORY:
        chuckc      2-Jan-1991      Created
        terryk      11-Jul-1991     Add the fDestroy flag to the constructors

********************************************************************/

STRLIST::STRLIST(const TCHAR * pszSrc, const TCHAR * pszSep, BOOL fDestroy )
        : SLIST_OF(NLS_STR) ( fDestroy )
{
    // call out to worker routine
    CreateList(pszSrc, pszSep) ;
}


/*******************************************************************

    NAME:       STRLIST::STRLIST

    SYNOPSIS:   Constructor for STRLIST

    ENTRY:      NLS_STR & strSrc - original string
                NLS_STR & strSep - the separator string
                BOOL fDestroy - flag for free the memory during
                                destruction. The default value is
                                TRUE.

    NOTES:
                as STRLIST(const TCHAR *   pszSrc, const TCHAR * pszSep),
                except we take NLS_STR instead of PSZ.

    HISTORY:
        chuckc      2-Jan-1991      Created
        terryk      11-Jul-1991     Add the fDestroy flag to the constructors

********************************************************************/

STRLIST::STRLIST(const NLS_STR & strSrc, const NLS_STR & strSep, BOOL fDestroy )
        : SLIST_OF(NLS_STR) ( fDestroy )
{
    // call worker, passing it the char * to the strings.
    CreateList(strSrc.QueryPch(), strSep.QueryPch()) ;
}


/*******************************************************************

    NAME:       STRLIST::~STRLIST

    SYNOPSIS:   Destructor for STRLIST

    NOTES:      clears the strlist, freeing the memory.

    HISTORY:
        chuckc      2-Jan-1991      Created

********************************************************************/

STRLIST::~STRLIST()
{
    this->Clear();
}


/*******************************************************************

    NAME:       STRLIST::WriteToBuffer

    SYNOPSIS:   Writes the contents of STRLIST to PSZ format,
                using separators specified by pszSep.

    ENTRY:      TCHAR * pszDest - destination
                INT cbDest - bytes in destination
                TCHAR * pszSep - separator string

    EXIT:       return code

    HISTORY:
        chuckc      2-Jan-1991      Created
        beng        26-Apr-1991     Replaced CB with INT

********************************************************************/

INT STRLIST::WriteToBuffer(
    TCHAR * pszDest,
    INT    cbDest,
    TCHAR * pszSep )
{
    INT    cbSize ;
    NLS_STR *pStr ;
    ITER_STRLIST iter_strlist(*this) ;

    // check for non empty separator string
    if (!pszSep  || !*pszSep)
        return(0) ;

    // check for valid buffer & size
    if (pszDest == NULL || cbDest < (cbSize = QueryBufferSize(pszSep)))
        return(0) ;

    // write out to pszDest.
    *pszDest = TCH('\0') ;
    if ( pStr = iter_strlist() )
    {
        ::strcatf(pszDest,pStr->QueryPch()) ;
        while ( pStr = iter_strlist() )
        {
            ::strcatf(pszDest,pszSep) ;
            ::strcatf(pszDest,pStr->QueryPch()) ;
        }
    }

    // return the number of bytes written
    return(cbSize) ;
}


/*******************************************************************

    NAME:       STRLIST::QueryBufferSize

    SYNOPSIS:   Query the number of bytes required by WriteToBuffer()

    ENTRY:      TCHAR * pszSep - separator

    EXIT:       return code

    HISTORY:
        chuckc      2-Jan-1991  Created
        beng        21-Nov-1991 Unicode fixes

********************************************************************/

INT STRLIST::QueryBufferSize( TCHAR * pszSep )
{
    INT      cbSep;                     // doesn't include terminators
    INT      cbSize = sizeof(TCHAR);    // for a NUL terminator
    NLS_STR *pStr;

    // separator is required
    if (!pszSep || ((cbSep = ::strlenf(pszSep)*sizeof(TCHAR)) == 0))
        return(0) ;

    // create an iterator for the strlist
    ITER_STRLIST iter_strlist(*this) ;
    while ( pStr = iter_strlist() )
    {
        // add each len plus separator
        cbSize += (pStr->strlen() + cbSep) ;
    }

    // take off last separator if any
    return (cbSize > sizeof(TCHAR)) ? (cbSize - cbSep) : (cbSize);
}


/*******************************************************************

    NAME:       STRLIST::CreateList

    SYNOPSIS:   Parses a Src string for tokens separated by
                separator characters in the Sep string, and
                generates a STRLIST of these tokens.

    ENTRY:      TCHAR * pszSrc - source string
                TCHAR * pszSep - separator string

    EXIT:

    NOTES:
        This worker of the STRLIST accepts 2 strings. The first
        contains any number of 'tokens' separated by any character in
        the second. Note I avoided strtok() to minimize effect on
        others.

    HISTORY:
        chuckc      2-Jan-1991  Created
        beng        26-Apr-1991 Replaced PSZ with TCHAR*
        beng        21-Nov-1991 Unicode fixes

********************************************************************/

VOID STRLIST::CreateList(const TCHAR * pszSrc, const TCHAR * pszSep)
{
    NLS_STR *pstr ;
    TCHAR *pszBuffer, *pszStart, *pszEnd ;
#if !defined(UNICODE)
    UINT cchSkip;
#endif

    // break out if empty string for Src or Sep
    if (!pszSrc || !*pszSrc || !pszSep || !*pszSep)
        return;

    // clear the str list
    this->Clear();

    // allocate temp buffer
    if ( !(pszBuffer = new TCHAR[::strlenf(pszSrc)+1]) )
    {
        // empty list if no memory
        return ;
    }

    // make copy & skip past leading separators
    ::strcpyf( pszBuffer, pszSrc ) ;
    pszStart = pszBuffer + ::strspnf( pszBuffer, pszSep ) ;

    // zip thru, adding each one to the strlist
    while (pszStart && *pszStart)
    {
        // find next separator if any, and null terminate at that point
        if (pszEnd = ::strpbrkf( pszStart, pszSep ))
        {
#if !defined(UNICODE)
            // keep track if 1 or 2 byte separator
            cchSkip = (IS_LEAD_BYTE(*pszEnd) ? 2 : 1) ;
#endif
            *pszEnd = TCH('\0') ;
        }

        // make new string and add to strlist
        if (!(pstr = new NLS_STR(pszStart))
            || (this->Append(pstr) != 0))
        {
            // either no memeory or failed to add, so quit
            this->Clear();
            return ;
        }

        if (pszEnd == NULL)
            // nothing more, might as well bag now
            break ;
        else
        {
            // skip past the separator we found earlier
#if defined(UNICODE)
            pszStart = pszEnd + 1;
#else
            pszStart = pszEnd + cchSkip ;
#endif
            // now skip past any other leading separators
            pszStart = pszStart +
                       ::strspnf( pszStart, pszSep ) ;
        }
    }

	// NTRAID#NTBUG9-577099-2002/03/08-artm  Prefast: use delete [].
	// Allocated w/ new []; use delete [] to avoid memory leak.
    delete pszBuffer ;  // delete temp buffer
}


/*******************************************************************

    NAME:       ITER_STRLIST::ITER_STRLIST

    SYNOPSIS:   Constructor for ITER_STRLIST

    ENTRY:      STRLIST & strl - the string list

    NOTES:
        The constructor just passes the STRLIST to the collector class

    HISTORY:
        chuckc      2-Jan-1991      Created
        beng        30-Apr-1991     Modern constructor syntax

********************************************************************/

ITER_STRLIST::ITER_STRLIST( STRLIST & strl ) :
    ITER_SL_OF(NLS_STR)(strl)
{
    ; // nothing to do
}


/*******************************************************************

    NAME:       ITER_STRLIST::ITER_STRLIST

    SYNOPSIS:   Constructor for ITER_STRLIST

    ENTRY:      ITER_STRLIST & iter_strl - iterator of the string list

    NOTES:
        The constructor just passes the STRLIST to the collector class

    HISTORY:
        chuckc      2-Jan-1991      Created
        beng        30-Apr-1991     Modern constructor syntax

********************************************************************/

ITER_STRLIST::ITER_STRLIST( const ITER_STRLIST & iter_strl ) :
    ITER_SL_OF(NLS_STR)( iter_strl )
{
    ; // nothing to do
}


/*******************************************************************

    NAME:       ITER_STRLIST::~ITER_STRLIST

    SYNOPSIS:   Destructor for ITER_STRLIST

    NOTES:      The destructor do nothing.

    HISTORY:
        chuckc      2-Jan-1991      Created

********************************************************************/

ITER_STRLIST::~ITER_STRLIST()
{
    ; // nothing to do
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\strncmp.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    strncmp.cxx
    NLS/DBCS-aware string class: strncmp method

    This file contains the implementation of the strncmp method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
	beng	    18-Jan-1991     Separated from original monolithic .cxx
	beng	    07-Feb-1991     Uses lmui.hxx

*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:	NLS_STR::strncmp

    SYNOPSIS:	Case sensitve string compare up to index position istrLen

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	johnl	    15-Nov-1990     Written
	beng	    23-Jul-1991     Allow on erroneous string;
				    simplified CheckIstr

********************************************************************/

INT NLS_STR::strncmp(
    const NLS_STR & nls,
    const ISTR	  & istrEnd ) const
{
    if (QueryError() || !nls)
	return 0;

    CheckIstr( istrEnd );

    return ::strncmpf( QueryPch(), nls.QueryPch(), istrEnd.QueryIch() );
}


INT NLS_STR::strncmp(
    const NLS_STR & nls,
    const ISTR	  & istrEnd,
    const ISTR	  & istrStart1 ) const
{
    if (QueryError() || !nls)
	return 0;

    UIASSERT( istrEnd.QueryIch() >= istrStart1.QueryIch() );
    CheckIstr( istrEnd );
    CheckIstr( istrStart1 );

    return ::strncmpf( QueryPch(istrStart1),
		       nls.QueryPch(),
		       istrEnd - istrStart1 );
}


INT NLS_STR::strncmp(
    const NLS_STR & nls,
    const ISTR	  & istrEnd,
    const ISTR	  & istrStart1,
    const ISTR	  & istrStart2 ) const
{
    if (QueryError() || !nls)
	return 0;

    UIASSERT( istrEnd.QueryIch() >= istrStart1.QueryIch() );
    UIASSERT( istrEnd.QueryIch() >= istrStart2.QueryIch() );
    CheckIstr( istrEnd );
    CheckIstr( istrStart1 );
    nls.CheckIstr( istrStart2 );

    return ::strncmpf( QueryPch(istrStart1),
		       nls.QueryPch(istrStart2),
		       istrEnd - istrStart1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\strmisc.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    strmisc.cxx
    Miscellaneous members of the string classes

    The NLS_STR and ISTR classes have many inline member functions
    which bloat clients, especially in debug versions.  This file
    gives those unhappy functions a new home.


    FILE HISTORY:
        beng        26-Apr-1991     Created (relocated from string.hxx)
        KeithMo     09-Oct-1991     Win32 Conversion.

*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:       NLS_STR::_QueryAllocSize

    SYNOPSIS:   Returns the number of bytes allocated by the object

    RETURNS:    Count of bytes

    NOTES:
        BUGBUG REVIEW - consider making this member private

    HISTORY:
        beng        22-Jul-1991 OwnerAlloc flag moved into own member
        beng        21-Nov-1991 Returns unsigned value

********************************************************************/

UINT NLS_STR::_QueryAllocSize()  const
{
    return _cbData;
}


/*******************************************************************

    NAME:       NLS_STR::CheckIstr

    SYNOPSIS:   Checks association between ISTR and NLS_STR instances

    ENTRY:      istr - ISTR to check against this NLS_STR

    NOTES:
        Does nothing in retail build.

    HISTORY:
        beng        23-Jul-1991     Header added; removed redundant
                                    "nls" parameter.

********************************************************************/

VOID NLS_STR::CheckIstr( const ISTR& istr ) const
{
    UIASSERT( (istr).QueryString() == this );

#if defined(NLS_DEBUG)
    UIASSERT( (istr).QueryVersion() == QueryVersion() );
#else
    UNREFERENCED(istr);
#endif
}


/*******************************************************************

    NAME:       NLS_STR::_IsOwnerAlloc

    SYNOPSIS:   Discriminate owner-alloc strings

    RETURNS:    TRUE if string owner-alloc'd

    NOTES:      BUGBUG REVIEW - consider making private

    HISTORY:
        beng        22-Jul-1991     Made fOwnerAlloc its own member

********************************************************************/

BOOL NLS_STR::_IsOwnerAlloc() const
{
    return _fOwnerAlloc;
}


/*******************************************************************

    NAME:       NLS_STR::_QueryPch

    SYNOPSIS:   Return pointer to string, possibly offset

    ENTRY:      istr (optional) - offset

    RETURNS:    Pointer to string, starting at offset.
                No offset means beginning of string (istr==0).

    HISTORY:
        beng        14-Nov-1991 Header added

********************************************************************/

const TCHAR * NLS_STR::_QueryPch() const
{
    if (QueryError())
        return NULL;

    return _pchData;
}


const TCHAR * NLS_STR::QueryPch( const ISTR& istr ) const
{
    if (QueryError())
        return NULL;

    CheckIstr( istr );
    return _pchData+istr.QueryIch();
}


/*******************************************************************

    NAME:       NLS_STR::QueryChar

    SYNOPSIS:   Return a character at a given offset

    ENTRY:      istr - offset into string

    RETURNS:    Wide character at offset

    NOTES:

    HISTORY:
        beng        14-Nov-1991 Header added

********************************************************************/

WCHAR NLS_STR::QueryChar( const ISTR& istr ) const
{
    if (QueryError())
        return 0;

    CheckIstr( istr );
    return *(_pchData+istr.QueryIch());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\strrchr.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    strrchr.cxx
    NLS/DBCS-aware string class: strrchr method

    This file contains the implementation of the strrchr method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
	beng	    18-Jan-1991     Separated from original monolithic .cxx
	beng	    07-Feb-1991     Uses lmui.hxx

*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:	NLS_STR::strrchr

    SYNOPSIS:	Puts the index of the last occurrence of ch in *this into
		istrPos.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	johnl	    26-Nov-1990     Written
	beng	    23-Jul-1991     Allow on erroneous string;
				    update CheckIstr

********************************************************************/

BOOL NLS_STR::strrchr( ISTR * pistrPos, const TCHAR ch ) const
{
    if (QueryError())
	return FALSE;

    UpdateIstr( pistrPos );
    CheckIstr( *pistrPos );

    const TCHAR * pchStrRes = ::strrchrf( QueryPch(), ch );

    if ( pchStrRes == NULL )
    {
	pistrPos->SetIch( strlen() );
	return FALSE;
    }

    pistrPos->SetIch( (INT)(pchStrRes - QueryPch()) );
    return TRUE;
}


BOOL NLS_STR::strrchr(
	  ISTR	  * pistrPos,
    const TCHAR	    ch,
    const ISTR	  & istrStart ) const
{
    if (QueryError())
	return FALSE;

    CheckIstr( istrStart );
    UpdateIstr( pistrPos );
    CheckIstr( *pistrPos );

    const TCHAR * pchStrRes = ::strrchrf(QueryPch(istrStart), ch );

    if ( pchStrRes == NULL )
    {
	pistrPos->SetIch( strlen() );
	return FALSE;
    }

    pistrPos->SetIch( (INT)(pchStrRes - QueryPch()) );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\strqss.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    strqss.cxx
    NLS/DBCS-aware string class: QuerySubStr method

    This file contains the implementation of the QuerySubStr method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
	beng	    18-Jan-1991     Separated from original monolithic .cxx
	beng	    07-Feb-1991     Uses lmui.hxx

*/

#include "pchstr.hxx"  // Precompiled header


// Magic value used below
//
#define CCH_ENTIRE_STRING ((UINT)-1)


/*******************************************************************

    NAME:	NLS_STR::QuerySubStr

    SYNOPSIS:	Return a pointer to a new NLS_STR that contains the contents
		of *this from istrStart to:
			  istrStart end of string or
			  istrStart + istrEnd

    ENTRY:

    EXIT:

    RETURNS:	Pointer to newly alloc'd NLS_STR, or NULL if error

    NOTES:
	The private method QuerySubStr(ISTR&, CCH) is the worker
	method; the other two just check the parameters and
	pass the data. It is private since we can't allow the
	user to access the string on a byte basis

    CAVEAT:
	Note that this method creates an NLS_STR that the client is
	responsible for deleting.

    HISTORY:
	johnl	    26-Nov-1990 Created
	beng	    26-Apr-1991 Replaced CB wth INT; broke
				out CB_ENTIRE_STRING magic value
	beng	    23-Jul-1991 Allow on erroneous string;
				simplified CheckIstr
	beng	    21-Nov-1991 Unicode fixes

********************************************************************/

NLS_STR * NLS_STR::QuerySubStr( const ISTR & istrStart, UINT cchLen ) const
{
    if (QueryError())
	return NULL;

    CheckIstr( istrStart );

    UINT cchStrLen = (UINT)::strlenf(QueryPch(istrStart) );
    UINT cchCopyLen = ( cchLen == CCH_ENTIRE_STRING || cchLen >= cchStrLen )
		       ? cchStrLen
		       : cchLen;

    NLS_STR *pnlsNew = new NLS_STR( cchCopyLen );
    if ( pnlsNew == NULL )
	return NULL;
    if ( pnlsNew->QueryError() )
    {
	delete pnlsNew;
	return NULL;
    }

    ::memcpy( pnlsNew->_pchData, QueryPch(istrStart),
	      cchCopyLen*sizeof(TCHAR) );
    *(pnlsNew->_pchData + cchCopyLen) = TCH('\0');

    pnlsNew->_cchLen = cchCopyLen;

    return pnlsNew;
}


NLS_STR * NLS_STR::QuerySubStr( const ISTR & istrStart ) const
{
    return QuerySubStr( istrStart, CCH_ENTIRE_STRING );
}


NLS_STR * NLS_STR::QuerySubStr( const ISTR  & istrStart,
				const ISTR  & istrEnd  ) const
{
    CheckIstr( istrEnd );
    UIASSERT( istrEnd.QueryIch() >= istrStart.QueryIch() );

    return QuerySubStr( istrStart, istrEnd - istrStart );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\strnicmp.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    strnicmp.cxx
    NLS/DBCS-aware string class: strnicmp method

    This file contains the implementation of the strnicmp method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
	beng	    18-Jan-1991     Separated from original monolithic .cxx
	beng	    07-Feb-1991     Uses lmui.hxx

*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:	NLS_STR::strnicmp

    SYNOPSIS:	Case insensitve string compare up to index position istrEnd

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	johnl	    15-Nov-1990     Written
	beng	    23-Jul-1991     Allow on erroneous string;
				    simplified CheckIstr

********************************************************************/

int NLS_STR::_strnicmp(
    const NLS_STR & nls,
    const ISTR	  & istrEnd ) const
{
    if (QueryError() || !nls)
	return 0;

    CheckIstr( istrEnd );

    return ::strnicmpf( QueryPch(), nls.QueryPch(), istrEnd.QueryIch() );
}


int NLS_STR::_strnicmp(
    const NLS_STR & nls,
    const ISTR	  & istrEnd,
    const ISTR	  & istrStart1 ) const
{
    if (QueryError() || !nls)
	return 0;

    UIASSERT( istrEnd.QueryIch() >= istrStart1.QueryIch() );
    CheckIstr( istrEnd );
    CheckIstr( istrStart1 );

    return ::strnicmpf(QueryPch(istrStart1),
		       nls.QueryPch(),
		       istrEnd - istrStart1 );
}


int NLS_STR::_strnicmp(
    const NLS_STR & nls,
    const ISTR	  & istrEnd,
    const ISTR	  & istrStart1,
    const ISTR	  & istrStart2 ) const
{
    if (QueryError() || !nls)
	return 0;

    UIASSERT( istrEnd.QueryIch() >= istrStart1.QueryIch()  );
    UIASSERT( istrEnd.QueryIch() >= istrStart2.QueryIch()  );
    CheckIstr( istrEnd );
    CheckIstr( istrStart1 );
    nls.CheckIstr( istrStart2 );

    return ::strnicmpf(QueryPch(istrStart1),
		       nls.QueryPch(istrStart2),
		       istrEnd - istrStart1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\strnchar.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    strnchar.cxx
    NLS/DBCS-aware string class:QueryNumChar method

    This file contains the implementation of the QueryNumChar method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
        terryk      04-Apr-1991     Creation

*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:       NLS_STR::QueryNumChar

    SYNOPSIS:   return the total number of character within the string

    RETURNS:    The number of logical character within the string

    NOTES:
        Treats erroneous string as having length 0

    HISTORY:
        terryk      04-Apr-1991 Written
        beng        23-Jul-1991 Allow on erroneous string
        beng        21-Nov-1991 Returns unsigned value

********************************************************************/

UINT NLS_STR::QueryNumChar() const
{
    if (QueryError())
        return 0;

    ISTR  istrCurPos( *this );
    INT   cchCounter = 0;

    for ( ;
          this->QueryChar( istrCurPos ) != TCH('\0');
          ++istrCurPos, cchCounter ++ )
        ;

    return cchCounter;
}


/*******************************************************************

    NAME:       NLS_STR::strlen

    SYNOPSIS:   Returns the number of byte-characters in the string

    RETURNS:    Count of byte-chars, excluding terminator

    NOTES:

    HISTORY:
        beng        22-Jul-1991 Added header
        beng        21-Nov-1991 Unicode fixes; returns unsigned value

********************************************************************/

UINT NLS_STR::strlen() const
{
    return _cchLen*sizeof(TCHAR);
}


/*******************************************************************

    NAME:       NLS_STR::_QueryTextLength

    SYNOPSIS:   Calculate length of text in TCHAR, sans terminator

    RETURNS:    Count of TCHAR

    NOTES:
        Compare QueryNumChar, which returns a number of glyphs.
        In a DBCS environment, this member will return 2 TCHAR for
        each double-byte character, since a TCHAR is there only 8 bits.

    HISTORY:
        beng        23-Jul-1991 Created
        beng        21-Nov-1991 Unicode fixes; returns unsigned value

********************************************************************/

UINT NLS_STR::_QueryTextLength() const
{
    return _cchLen;
}


/*******************************************************************

    NAME:       NLS_STR::QueryTextSize

    SYNOPSIS:   Calculate length of text in BYTES, including terminator

    RETURNS:    Count of BYTES

    NOTES:
        QueryTextSize returns the number of bytes needed to duplicate
        the string into a byte vector.

    HISTORY:
        beng        23-Jul-1991 Created
        beng        21-Nov-1991 Unicode fixes; returns unsigned value

********************************************************************/

UINT NLS_STR::QueryTextSize() const
{
    return (_cchLen+1)*sizeof(TCHAR);
}


#if defined(UNICODE) && defined(FE_SB)
/*******************************************************************

    NAME:       NLS_STR::QueryAnsiTextLength

    SYNOPSIS:   Calculate length of text in BYTES, including terminator

    RETURNS:    Count of BYTES

    NOTES:
        QueryTextSize returns the number of bytes.
        In DBCS world, QueryTextSize doesn't return actual byte count.

    HISTORY:


********************************************************************/
UINT NLS_STR::QueryAnsiTextLength() const
{
    return ::WideCharToMultiByte(CP_ACP,
                                 0,
                                 QueryPch(),
                                 QueryTextLength(),
                                 NULL,
                                 0,
                                 NULL,
                                 NULL);
}

#endif // UNICODE && FE_SB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\strspn.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    strspn.cxx
    NLS/DBCS-aware string class: strspn method

    This file contains the implementation of the strspn method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
	beng	    18-Jan-1991     Separated from original monolithic .cxx
	beng	    07-Feb-1991     Uses lmui.hxx

*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:	NLS_STR::strspn

    SYNOPSIS:	Find first char in *this that is not a char in arg. and puts
		the position in pistrPos.
		Returns FALSE when no characters do not match

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	johnl	    16-Nov-1990     Written
	beng	    23-Jul-1991     Allow on erroneous string;
				    simplified CheckIstr

********************************************************************/

BOOL NLS_STR::strspn( ISTR * pistrPos, const NLS_STR & nls ) const
{
    if (QueryError() || !nls)
	return FALSE;

    UpdateIstr( pistrPos );
    CheckIstr( *pistrPos );

    pistrPos->SetIch( ::strspnf( QueryPch(), nls.QueryPch() ) );
    return *QueryPch( *pistrPos ) != TCH('\0');
}


BOOL NLS_STR::strspn( ISTR *	      pistrPos,
		      const NLS_STR & nls,
		      const ISTR    & istrStart ) const
{
    if (QueryError() || !nls)
	return FALSE;

    UpdateIstr( pistrPos );
    CheckIstr( istrStart );

    pistrPos->SetIch( ::strspnf(QueryPch( istrStart ), nls.QueryPch() ) +
		     istrStart.QueryIch()  );
    return *QueryPch( *pistrPos ) != TCH('\0');
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\strrss.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    strrss.cxx
    NLS/DBCS-aware string class: strrss method

    This file contains the implementation of the strrss method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
	beng	    18-Jan-1991     Separated from original monolithic .cxx
	beng	    07-Feb-1991     Uses lmui.hxx

*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:	NLS_STR::ReplSubStr

    SYNOPSIS:	Replace a substring with the passed string.

    ENTRY:	If both a start and end is passed, then the operation is
		equivalent to a DelSubStr( start, end ) and an
		InsertSubStr( start ).

		If just a start is passed in, then the operation is
		equivalent to DelSubStr( start ), concat new string to end.

		The ReplSubStr( NLS_STR&, istrStart&, INT cbDel) method is
		private.

    EXIT:	Substring starting at istrStart was replaced with nlsRepl.

    HISTORY:
	johnl	    29-Nov-1990 Created
	beng	    26-Apr-1991 Replaced CB with INT
	beng	    23-Jul-1991 Allow on erroneous string;
				simplified CheckIstr
	beng	    15-Nov-1991 Unicode fixes

********************************************************************/

VOID NLS_STR::ReplSubStr( const NLS_STR & nlsRepl, ISTR& istrStart )
{
    if (QueryError() || !nlsRepl)
	return;

    CheckIstr( istrStart );

    DelSubStr( istrStart );
    strcat( nlsRepl );
}


VOID NLS_STR::ReplSubStr( const NLS_STR & nlsRepl,
				ISTR &	  istrStart,
			  const ISTR &	  istrEnd )
{
    CheckIstr( istrEnd );
    UIASSERT( istrEnd.QueryIch() >= istrStart.QueryIch() );

    ReplSubStr( nlsRepl, istrStart, istrEnd - istrStart );
}


VOID NLS_STR::ReplSubStr( const NLS_STR & nlsRepl,
				ISTR	& istrStart,
				UINT	  cchToBeDeleted )
{
    if (QueryError() || !nlsRepl)
	return;

    CheckIstr( istrStart );

    INT cchRequired = QueryTextLength() + nlsRepl.QueryTextLength()
		     - cchToBeDeleted;

    if ( !Realloc( cchRequired ) )
    {
	ReportError( ERROR_NOT_ENOUGH_MEMORY );
	return;
    }

    // Make room for the new data, displacing old data as appropriate.
    // Then copy the new data into its position.

    TCHAR * pchStart = _pchData + istrStart.QueryIch();

    ::memmove( pchStart + nlsRepl.QueryTextLength(),
	       pchStart + cchToBeDeleted,
	       QueryTextSize() - istrStart.QueryIch()*sizeof(TCHAR) - cchToBeDeleted*sizeof(TCHAR) );

    ::memmove( pchStart,
	       nlsRepl._pchData,
	       nlsRepl.QueryTextSize() - sizeof(TCHAR));

    _cchLen = _cchLen - cchToBeDeleted + nlsRepl.QueryTextLength();

    IncVers();
    UpdateIstr( &istrStart );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\strtok.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    strtok.cxx
    NLS/DBCS-aware string class: strtok method

    This file contains the implementation of the strtok method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
        beng        18-Jan-1991 Separated from original monolithic .cxx
        beng        07-Feb-1991 Uses lmui.hxx
        beng        28-Mar-1992 Withdrew from Unicode builds
*/

#include "pchstr.hxx"  // Precompiled header


#if !defined(UNICODE)

/*******************************************************************

    NAME:       NLS_STR::strtok

    SYNOPSIS:   Basic strtok functionality.  Returns FALSE after the
                string has been traversed.

    ENTRY:

    EXIT:

    NOTES:      We don't update the version on the string since the
                ::strtokf shouldn't cause DBCS problems.  It would also
                be painful on the programmer if on each call to strtok
                they had to update all of the ISTR associated with this
                string

                fFirst is required to be TRUE on the first call to
                strtok, it is FALSE afterwards (is defaulted to FALSE)

    CAVEAT:     Under windows, all calls to strtok must be done while
                processing a single message.  Otherwise another process
                my confuse it.

    HISTORY:
        johnl       26-Nov-1990 Created
        beng        23-Jul-1991 Allow on erroneous string
        beng        21-Nov-1991 Check arg string, too

********************************************************************/

BOOL NLS_STR::strtok(       ISTR *    pistrPos,
                      const NLS_STR & nlsBreak,
                      BOOL            fFirst     )
{
    if (QueryError() || !nlsBreak)
        return FALSE;

    const TCHAR * pchToken = ::strtokf( fFirst ? _pchData : NULL,
                                       (TCHAR *)nlsBreak.QueryPch());

    if ( pchToken == NULL )
    {
        pistrPos->SetIch( QueryTextLength() );
        return FALSE;
    }

    pistrPos->SetIch( pchToken - QueryPch() );
    return TRUE;
}

#endif // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\strstr.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    strstr.cxx
    NLS/DBCS-aware string class: strstr method

    This file contains the implementation of the strstr method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
	beng	    18-Jan-1991     Separated from original monolithic .cxx
	beng	    07-Feb-1991     Uses lmui.hxx

*/
#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:	NLS_STR::strstr

    SYNOPSIS:	Returns TRUE if the passed string is found, false otherwise.
		pistrPos contains start of the specified string if TRUE
		is returned.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	johnl	    16-Nov-1990     Written
	beng	    23-Jul-1991     Allow on erroneous string;
				    simplified CheckIstr

********************************************************************/

BOOL NLS_STR::strstr( ISTR * pistrPos, const NLS_STR & nls ) const
{
    if (QueryError() || !nls)
	return FALSE;

    UpdateIstr( pistrPos );
    CheckIstr( *pistrPos );

    const TCHAR * pchStrRes = ::strstrf( QueryPch(), nls.QueryPch() );

    if ( pchStrRes == NULL )
    {
	pistrPos->SetIch( strlen() );
	return FALSE;
    }

    pistrPos->SetIch( (INT)(pchStrRes - QueryPch()) );
    return TRUE;
}


BOOL NLS_STR::strstr(	    ISTR    * pistrPos,
		      const NLS_STR & nls,
		      const ISTR    & istrStart ) const
{
    if (QueryError() || !nls)
	return FALSE;

    CheckIstr( istrStart );
    UpdateIstr( pistrPos );
    CheckIstr( *pistrPos );

    const TCHAR * pchStrRes = ::strstrf(QueryPch(istrStart), nls.QueryPch() );

    if ( pchStrRes == NULL )
    {
	pistrPos->SetIch( strlen() );
	return FALSE;
    }

    pistrPos->SetIch( (INT)(pchStrRes - QueryPch()) );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\strupr.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    strupr.cxx
    NLS/DBCS-aware string class: strupr method

    This file contains the implementation of the strupr method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
	beng	    18-Jan-1991 Separated from original monolithic .cxx
	beng	    07-Feb-1991 Uses lmui.hxx
*/

#include "pchstr.hxx"  // Precompiled header


/*******************************************************************

    NAME:	NLS_STR::strupr

    SYNOPSIS:	Convert *this lower case letters to upper case

    ENTRY:	String is of indeterminate case

    EXIT:	String is all uppercase

    NOTES:

    HISTORY:
	johnl	    26-Nov-1990     Written
	beng	    23-Jul-1991     Allow on erroneous string

********************************************************************/

NLS_STR& NLS_STR::_strupr()
{
    if (!QueryError())
	::struprf( _pchData );

    return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\strupoem.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    strupoem.cxx
    NLS/DBCS-aware string class: RtlOemUpcase method

    This file contains the implementation of the RtlOemUpcase method
    for the STRING class.  It is separate so that clients of STRING which
    do not use this operator need not link to it.

    FILE HISTORY:
        jonn        09-Feb-1994 Created
*/

#include "pchstr.hxx"  // Precompiled header

extern "C"
{
    #include <ntrtl.h>
}

#include "errmap.hxx"


/*******************************************************************

    NAME:	NLS_STR::RtlOemUpcase

    SYNOPSIS:	Convert *this lower case letters to upper case using
                RtlUpcaseUnicodeStringToOemString

    ENTRY:	String is of indeterminate case

    EXIT:	String is all uppercase

    NOTES:

    HISTORY:
        jonn        09-Feb-1994 Created

********************************************************************/

APIERR NLS_STR::RtlOemUpcase()
{
    APIERR err = QueryError();
    if (err != NERR_Success)
    {
        DBGEOL( "NLS_STR::RtlOemUpcase: string already bad " << err );
	return err;
    }

#ifndef UNICODE
#error not coded for non-UNICODE
#endif

    UNICODE_STRING unistr;
    unistr.Length = (USHORT)(QueryTextLength()*sizeof(WCHAR));
    unistr.MaximumLength = unistr.Length;
    unistr.Buffer = (PWCHAR)QueryPch();
    ASSERT( unistr.Buffer != NULL );
    OEM_STRING oemstrUpcase;
    oemstrUpcase.Buffer = NULL;
    oemstrUpcase.Length = 0;
    oemstrUpcase.MaximumLength = 0;
    NTSTATUS ntstatus = ::RtlUpcaseUnicodeStringToOemString(
        &oemstrUpcase,
        &unistr,
        TRUE );
    if (ntstatus != STATUS_SUCCESS)
    {
        err = ERRMAP::MapNTStatus( ntstatus );
        DBGEOL(    "NLS_STR::RtlOemUpcase: RtlUpcase status " << ntstatus
                << ", error " << err );
        goto cleanup;
    }

    if (  ((err = MapCopyFrom( oemstrUpcase.Buffer,
                               oemstrUpcase.Length )) != NERR_Success)
       )
    {
        DBGEOL( "NLS_STR::RtlOemUpcase: MapCopyFrom error " << err );
        goto cleanup;
    }

cleanup:
    ::RtlFreeOemString( &oemstrUpcase );
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\test\skeleton\xstrskel.h ===
#define IDM_ABOUT	100
#define IDM_RUN_TEST	200
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\test\convert\xconvert.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    xstr02.cxx
    Some more string unit tests - the MBCS/Unicode conversion fcns

    This module plugs into XstrSkel.

    FILE HISTORY:
        beng        02-Mar-1992 Created
        beng        16-Mar-1992 Changes to cdebug
        beng        31-Mar-1992 Test extensions to NLS_STR::MapCopyFrom
        beng        24-Apr-1992 More test cases
*/

#define USE_CONSOLE

#define INCL_NETLIB
#if defined(WINDOWS)
# define INCL_WINDOWS
# define INCL_NETERRORS
#else
# if defined(WIN32)
#  define INCL_DOSERRORS
#  define INCL_NETERRORS
# else
#  define INCL_OS2
# endif
#endif
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = "xconvert.cxx";
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#include <uiassert.hxx>
#include <string.hxx>

#include "xstrskel.hxx"


// This op renders a NLS_STR, bracketing it for readability.

DBGSTREAM& operator<<(DBGSTREAM &out, const NLS_STR &nls)
{
    if (!nls)
        out << "<(Unrenderable - Error state " << nls.QueryError() << ")>";
    else
        out << TCH('<') << nls.QueryPch() << TCH('>');

    return out;
}


#if !defined(UNICODE)
DBGSTREAM& operator<<(DBGSTREAM &out, const WCHAR wch)
{
    out << (TCHAR)wch;

    return out;
}
#endif


VOID FunFactsAboutString(const TCHAR* pszName, const NLS_STR& nls)
{
    cdebug << pszName << " reads " << nls << dbgEOL;
    cdebug << "   strlen = "       << nls.strlen() << dbgEOL;
    cdebug << "   QAllocSize = "   << nls.QueryAllocSize() << dbgEOL;
    cdebug << "   QNumChar = "     << nls.QueryNumChar() << dbgEOL;
    cdebug << "   QTLength = "     << nls.QueryTextLength() << dbgEOL;
    cdebug << "   QTSize = "       << nls.QueryTextSize() << dbgEOL;
}


VOID Test01()
{
    NLS_STR nlsTest = SZ("Test");

    TCHAR achTooSmall[4];
    TCHAR achPlentyBig[5];

    APIERR err;

    ASSERT(!!nlsTest);

    achTooSmall[0] = TCH('\0');
    err = nlsTest.CopyTo(achTooSmall, sizeof(achTooSmall));
    ASSERT(err == ERROR_NOT_ENOUGH_MEMORY);
    DBGEOL("Buffer TooSmall contains <" << achTooSmall << ">");
    err = nlsTest.CopyTo(achPlentyBig, sizeof(achPlentyBig));
    ASSERT(err == NERR_Success);
    DBGEOL("Buffer PlentyBig contains <" << achPlentyBig << ">");
}


VOID Test02()
{
    NLS_STR nlsTest = SZ("Test");

    CHAR achSmallChars[20];
    WCHAR awchLargeChars[20];

    APIERR err;

    ASSERT(!!nlsTest);

    err = nlsTest.MapCopyTo(achSmallChars, sizeof(achSmallChars));
    ASSERT(err == NERR_Success);
    DBGEOL("Schar array contains "
           << (UINT)achSmallChars[0] << ", "
           << (UINT)achSmallChars[1] << ", "
           << (UINT)achSmallChars[2] << ", "
           << (UINT)achSmallChars[3] << ", "
           << (UINT)achSmallChars[4]);

    err = nlsTest.MapCopyTo(awchLargeChars, sizeof(awchLargeChars));
    ASSERT(err == NERR_Success);
    DBGEOL("Wchar array contains "
           << (UINT)awchLargeChars[0] << ", "
           << (UINT)awchLargeChars[1] << ", "
           << (UINT)awchLargeChars[2] << ", "
           << (UINT)awchLargeChars[3] << ", "
           << (UINT)awchLargeChars[4]);
}


VOID Test03()
{
    NLS_STR nlsTest = SZ("Test string");

    CHAR szSmall[] = {65, 65, 66, 66, 67, 67, 68, 68, 0};
    WCHAR wszLarge[] = {65, 65, 66, 66, 67, 67, 68, 68, 0};

    APIERR err;

    ASSERT(!!nlsTest);

    err = nlsTest.MapCopyFrom(szSmall);
    ASSERT(err == NERR_Success);
    DBGEOL("nlsTest from schar string = " << nlsTest);

    err = nlsTest.MapCopyFrom(wszLarge);
    ASSERT(err == NERR_Success);
    DBGEOL("nlsTest from wchar string = " << nlsTest);

    STACK_NLS_STR(nlsPuny, 8);
    ASSERT(!!nlsPuny);

    err = nlsPuny.CopyFrom(SZ("Gnome"));
    ASSERT(err == NERR_Success);
    DBGEOL("Small allocstr contains " << nlsPuny);

    err = nlsPuny.CopyFrom(SZ("Baluchitherium"));
    ASSERT(err == ERROR_NOT_ENOUGH_MEMORY);
    DBGEOL("Small allocstr still contains " << nlsPuny);
}


VOID Test04()
{
    NLS_STR nlsTest;

    static TCHAR achNoTerm[4] = { TCH('A'), TCH('B'), TCH('C'), TCH('D') };
    static TCHAR *const achHasTerm = SZ("EFGH");

    APIERR err;

    ASSERT(!!nlsTest);

    err = nlsTest.CopyFrom(achNoTerm, sizeof(achNoTerm));
    ASSERT(err == NERR_Success);
    DBGEOL("Should contain ABCD; contains " << nlsTest);

    err = nlsTest.CopyFrom(achHasTerm);
    ASSERT(err == NERR_Success);
    DBGEOL("Should contain EFGH; contains " << nlsTest);
}



VOID Test05()
{
    NLS_STR nlsTest = SZ("Test string");

    CHAR szSmall[] = {65, 65, 66, 66, 67, 67, 68, 68 };
    WCHAR wszLarge[] = {65, 65, 66, 66, 67, 67, 68, 68};

    APIERR err;

    ASSERT(!!nlsTest);

    err = nlsTest.MapCopyFrom(szSmall, sizeof(szSmall));
    ASSERT(err == NERR_Success);
    DBGEOL("nlsTest from schar string = " << nlsTest);

    err = nlsTest.MapCopyFrom(wszLarge, sizeof(wszLarge));
    ASSERT(err == NERR_Success);
    DBGEOL("nlsTest from wchar string = " << nlsTest);
}


VOID Test06()
{
    NLS_STR nlsShouldBeEmpty = SZ("Existing garbage");
    WCHAR wszEmpty[] = {0, (WCHAR)'B', (WCHAR)'u', (WCHAR)'g', (WCHAR)'!', 0};

    ASSERT(!!nlsShouldBeEmpty);

    APIERR err;

    // Mimic a case where a struct UNICODE_STRING is coming back
    // with Length == 0

    err = nlsShouldBeEmpty.MapCopyFrom(wszEmpty, 0);
    ASSERT(err == NERR_Success);
    FunFactsAboutString(SZ("nlsShouldBeEmpty"), nlsShouldBeEmpty);
}


VOID RunTest()
{
    Test01();
    Test02();
    Test03();
    Test04();
    Test05();
    Test06();

    DBGEOL("Done!");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\test\basic\xstr00.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    xstr00.cxx
    Simple unit test for string class NLS_STR

    This module plugs into XstrSkel.  It contains the original
    string class unit tests as written by johnl.


    FILE HISTORY:
        beng        06-Jul-1991 Separated from xstr.cxx
        beng        21-Nov-1991 Unicode fixes
        beng        16-Mar-1992 Changes to cdebug
*/

#define USE_CONSOLE

#define INCL_NETLIB
#if defined(WINDOWS)
# define INCL_WINDOWS
#else
# if defined(WIN32)
#  define INCL_DOSERRORS
#  define INCL_NETERRORS
# else
#  define INCL_OS2
# endif
#endif
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = "xstr00.cxx";
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#include <uiassert.hxx>
#include <string.hxx>

#include "xstrskel.hxx"



// This op renders a NLS_STR, bracketing it for readability.

DBGSTREAM& operator<<(DBGSTREAM &out, const NLS_STR &nls)
{
    if (!nls)
        out << SZ("<(Unrenderable - Error state ") << nls.QueryError() << SZ(")>");
    else
        out << TCH('<') << nls.QueryPch() << TCH('>');

    return out;
}


#if !defined(UNICODE)
DBGSTREAM& operator<<(DBGSTREAM &out, const WCHAR wch)
{
    out << (TCHAR)wch;

    return out;
}
#endif


class DUMB
{
public:
    DUMB( TCHAR * pchInit )
        : CT_INIT_NLS_STR( _nlsStr, pchInit )
    {
        cdebug << SZ("DUMB::DUMB - _nlsStr = ") << _nlsStr << dbgEOL;

        UIASSERT( !::strcmpf( _nlsStr.QueryPch(), pchInit ) );
        UIASSERT( _nlsStr.IsOwnerAlloc() );
        UIASSERT( _nlsStr.QueryAllocSize() == (30+1)*sizeof(TCHAR) );
    }

    DUMB()
        : CT_NLS_STR( _nlsStr )
    {
        cdebug << SZ("DUMB::DUMB - _nlsStr = ") << _nlsStr << dbgEOL;

        UIASSERT( !::strcmpf( _nlsStr.QueryPch(), SZ("") ) );
        UIASSERT( _nlsStr.IsOwnerAlloc() );
        UIASSERT( _nlsStr.QueryAllocSize() == (30+1)*sizeof(TCHAR) );
    }

    ~DUMB()
    {
        cdebug << SZ("DUMB::~DUMB - Destructing ") << _nlsStr << dbgEOL;
    }

private:
    DECL_CLASS_NLS_STR( _nlsStr, 30 );
};


VOID FunFactsAboutString(const TCHAR* pszName, const NLS_STR& nls)
{
    cdebug << pszName << SZ(" reads ") << nls << dbgEOL;
    cdebug << SZ("   strlen = ")       << nls.strlen() << dbgEOL;
    cdebug << SZ("   QAllocSize = ")   << nls.QueryAllocSize() << dbgEOL;
    cdebug << SZ("   QNumChar = ")     << nls.QueryNumChar() << dbgEOL;
    cdebug << SZ("   QTLength = ")     << nls.QueryTextLength() << dbgEOL;
    cdebug << SZ("   QTSize = ")       << nls.QueryTextSize() << dbgEOL;
}


VOID Test0()
{
    cdebug << dbgEOL << dbgEOL
           << SZ("Testing Owner-alloc string classes...")
           << dbgEOL;

    TCHAR *const szGreeting = SZ("Good morning Saigon");
    TCHAR achNewBuffer[40];

    {
        ALLOC_STR str1(achNewBuffer, sizeof(achNewBuffer), szGreeting);
        FunFactsAboutString(SZ("Alloc str1"), str1);
        str1.Append(SZ(" - more strings about buildings and food"));
        FunFactsAboutString(SZ("Alloc str1"), str1);
    }

    {
        ALLOC_STR str2(achNewBuffer, sizeof(achNewBuffer));
        str2 = SZ("Cowboy Wally");
        FunFactsAboutString(SZ("Alloc str2"), str2);
    }

    {
        ALLOC_STR str3(achNewBuffer, sizeof(achNewBuffer));
        FunFactsAboutString(SZ("Alloc str3"), str3);
    }

    {
        const ALIAS_STR alias = szGreeting;
        FunFactsAboutString(SZ("alias"), alias);
    }
}


VOID RunTest()
{
    cdebug << dbgEOL << dbgEOL
           << SZ("Testing owner alloced string members...")
           << dbgEOL;
    {
        DUMB dum1( SZ("This is a string") ), dum2;
    }

    cdebug << dbgEOL << dbgEOL
           << SZ("Testing string initialization stuff...")
           << dbgEOL;
    {
        NLS_STR nlsString( 100 ), *pnls = &nlsString;
        TCHAR *const buff = SZ("Hello world");

        *pnls = SZ("Hello there");
        cdebug << SZ("pnls = ") << *pnls << dbgEOL;
        *pnls = buff;
        cdebug << SZ("pnls = ") << *pnls << dbgEOL;
    }

    //-------------------------------------------------------------------
    cdebug << dbgEOL << dbgEOL << SZ("Testing NLS_STR") << dbgEOL;
    {
        NLS_STR nlsDefault,
                nlsSizeNoInitChar( 15 ),
                nlsInitString    ( SZ("123456789012345") ),
                nlsInitNLS       ( nlsInitString ),
                nlsEmpty;
        ALLOC_STR nlsOwnerAlloc  ( SZ("123456789012345") );

        FunFactsAboutString(SZ("nlsDefault"), nlsDefault);
        FunFactsAboutString(SZ("nlsSizeNoInitChar"), nlsSizeNoInitChar);
        FunFactsAboutString(SZ("nlsInitString"), nlsInitString);
        FunFactsAboutString(SZ("nlsInitNLS"), nlsInitNLS);
        FunFactsAboutString(SZ("nlsOwnerAlloc"), nlsOwnerAlloc);

        REQUIRE( nlsDefault.QueryAllocSize() == 1*sizeof(TCHAR) );
        REQUIRE( nlsDefault.QueryTextLength() == 0 );
        REQUIRE( !::strcmpf( nlsDefault.QueryPch(), SZ("") ));

        REQUIRE( nlsSizeNoInitChar.QueryAllocSize() == 16*sizeof(TCHAR) );
        REQUIRE( nlsSizeNoInitChar.QueryTextLength() == 0 );
        REQUIRE( !::strcmpf( nlsSizeNoInitChar.QueryPch(), SZ("")) );

        REQUIRE( nlsInitString.QueryAllocSize() == 16*sizeof(TCHAR) );
        REQUIRE( nlsInitString.QueryTextLength() == 15 );
        REQUIRE( !::strcmpf( nlsInitString.QueryPch(), SZ("123456789012345") ));

        REQUIRE( nlsInitNLS.QueryAllocSize() == 16*sizeof(TCHAR) );
        REQUIRE( nlsInitNLS.QueryTextLength() == 15 );
        REQUIRE( !::strcmpf( nlsInitNLS.QueryPch(), SZ("123456789012345") ));

        REQUIRE( nlsOwnerAlloc.IsOwnerAlloc() );
        REQUIRE( nlsOwnerAlloc.QueryTextLength() == 15 );
        REQUIRE( !::strcmpf( nlsOwnerAlloc.QueryPch(), SZ("123456789012345") ));

        nlsEmpty = NULL;
        REQUIRE( nlsEmpty.QueryAllocSize() == 1*sizeof(TCHAR) );
        REQUIRE( nlsEmpty.QueryTextLength() == 0 );

        TCHAR * pchnull = NULL;
        NLS_STR nlsEmpty2( pchnull );
        REQUIRE( nlsEmpty2.QueryAllocSize() == 1*sizeof(TCHAR) );
        REQUIRE( nlsEmpty2.QueryTextLength() == 0 );
    }

    cdebug << dbgEOL << dbgEOL
           << SZ("Testing NLS_STR concat methods") << dbgEOL;
    {
        NLS_STR nlsCat = SZ("Cat "),
                nlsDog = SZ("Dog"),
                nlsConCat = nlsCat;
        nlsConCat += nlsDog;
        REQUIRE( ::strcmpf( nlsConCat.QueryPch(), SZ("Cat Dog") ) == 0 );
        REQUIRE( nlsConCat.QueryTextLength() == 7 );

        NLS_STR nlsConCat2 = nlsConCat;
        nlsConCat2 += nlsConCat;
        REQUIRE( ::strcmpf( nlsConCat2.QueryPch(), SZ("Cat DogCat Dog") ) == 0 );
        REQUIRE( nlsConCat2.QueryTextLength() == 14 );

    }

    cdebug << dbgEOL << dbgEOL
           << SZ("Testing NLS_STR str??cmp methods") << dbgEOL;
    {
        NLS_STR nlsCAPS = SZ("FRISBEE"),
                nlslow  = SZ("frisbee"),
                nlsPart1= SZ("nomatch Frisbee"),
                nlsPart2= SZ("maybe Frisbee"),
                nlsLess = SZ("AFRISBEE"),
                nlsGreater = SZ("ZFRISBEE"),
                nlsCAPS2 = SZ("FRISBEE");

        REQUIRE( nlsCAPS != nlslow );
        REQUIRE( nlsCAPS == (NLS_STR)SZ("FRISBEE") );
        REQUIRE( nlsCAPS != (NLS_STR)SZ("NO FRISBEE") );
        REQUIRE( nlsCAPS == nlsCAPS2 );

        REQUIRE( 0 >  nlsCAPS.strcmp( nlslow ) );
        REQUIRE( 0 >  nlsCAPS.strcmp( nlsGreater ) );
        REQUIRE( 0 <  nlsCAPS.strcmp( nlsLess ) );
        REQUIRE( 0 == nlsCAPS.strcmp( nlsCAPS2 ) );

        ISTR istrFirstF (nlsCAPS),
             istrFirstI (nlsCAPS),
             istrDef    (nlsLess),
             istrGreater(nlsGreater),
             istrLess   (nlsLess );

        nlsCAPS.strcspn( &istrFirstF, SZ("F") );
        nlsCAPS.strcspn( &istrFirstI, SZ("I") );
        nlsLess.strcspn( &istrLess,   SZ("F"));

        cdebug << SZ("str??cmp methods trace 1") << dbgEOL;
        REQUIRE( 0 > nlsCAPS.strncmp( nlslow, istrFirstI ) );
        REQUIRE( 0 > nlsCAPS.strncmp( nlsGreater, istrFirstI ) );
        REQUIRE( 0 < nlsCAPS.strncmp( nlsLess, istrFirstI ) );

        REQUIRE( 0 == nlsCAPS._stricmp( nlslow ) );
        REQUIRE( 0 >  nlsCAPS._stricmp( nlsGreater ) );
        REQUIRE( 0 <  nlsCAPS._stricmp( nlsLess ) );

        cdebug << SZ("str??cmp methods trace 2") << dbgEOL;
        REQUIRE( 0 == nlsCAPS._strnicmp( nlslow, istrFirstI ) );
        REQUIRE( 0 >  nlsCAPS._strnicmp( nlsGreater, istrFirstI) );
        REQUIRE( 0 <  nlsCAPS._strnicmp( nlsLess, istrFirstI ) );

        //---------- With offsets into string ---------------
        cdebug << SZ("str??cmp methods trace 3") << dbgEOL;

        nlsGreater.strcspn( &istrGreater, SZ("F"));
        nlsLess.strcspn( &istrLess, SZ("I") );

        REQUIRE( 0 <  nlsCAPS.strcmp( nlsLess, istrFirstF, istrDef ) );
        REQUIRE( 0 == nlsCAPS.strcmp( nlsGreater, istrFirstF, istrGreater ) );
        REQUIRE( 0 == nlsCAPS.strcmp( nlsLess, istrFirstI, istrLess ) );

    }

#if !defined(UNICODE)
    cdebug << dbgEOL << dbgEOL
           << SZ("Testing NLS_STR strtok methods") << dbgEOL;
    {
        NLS_STR nls1 = SZ("Wham-o diskcraft, aerobie ultra-star"),
                nlsSep=SZ(" \t,");

        ISTR istrToken( nls1 );
        BOOL fMore = nls1.strtok( &istrToken, nlsSep, TRUE );
        while ( fMore )
        {
            cdebug << nls1[ istrToken ] << dbgEOL;
            fMore = nls1.strtok( &istrToken, nlsSep );
        }
    }
#endif

    cdebug << dbgEOL << dbgEOL
           << SZ("Testing NLS_STR str?spn methods") << dbgEOL;
    {
        NLS_STR nls1 = SZ("FRISBEE"),
                nls2 = SZ("FROBOSE"),
                nls3 = SZ("BOK");

        ISTR istr1( nls1), istr2( nls1 );

        REQUIRE( nls1.strcspn( &istr1, nls3 ) ); // Should be 4
        REQUIRE( nls1.strspn( &istr2, nls3 ) ); // Should be 0


        cdebug << SZ("\"") << nls1[istr1] << SZ("\"") << SZ("   ")
               << SZ("\"") << nls1[istr2] << SZ("\"") << dbgEOL;
        REQUIRE( 0 == nls1.strcmp( SZ("BEE"), istr1 ) );
        REQUIRE( 0 == nls1.strcmp( SZ("FRISBEE"), istr2 ) );
        cdebug << dbgEOL;

        REQUIRE( nls1.strcspn( &istr1, SZ("E"), istr1 ) );
        istr1++;
        REQUIRE( nls1.strcspn( &istr1, SZ("E"), istr1 ) );
        istr1++;
        REQUIRE( !nls1.strcspn( &istr1, SZ("E"), istr1 ) );
    }

    cdebug << dbgEOL << dbgEOL
           << SZ("Testing Character methods") << dbgEOL;
    {
        NLS_STR nls = SZ("FRISBEE");
        ISTR istr1(nls), istr2(istr1 );

        REQUIRE( nls.QueryChar( istr1 ) == TCH('F') );
        REQUIRE( istr1 == istr2 );
        istr1++;
        REQUIRE( nls.QueryChar( istr1 ) == TCH('R') );
        REQUIRE( istr1 > istr2 );
        REQUIRE( istr2 < istr1 );

        istr2 += 2;
        REQUIRE( nls.QueryChar( istr2 ) == TCH('I') );

        while ( nls.QueryChar(istr1++) != TCH('\0') )
        {
            cdebug << nls.QueryChar(istr1) << SZ(" - ");
        }
    }

    cdebug << dbgEOL << dbgEOL << SZ("Testing strchr methods") << dbgEOL;
    {
        NLS_STR nls = SZ("Line of text with a # in it"),
                nls2= SZ("Line of text without a sharp in it");

        ISTR istr(nls), istr2(nls2);

        REQUIRE( nls.strchr( &istr, TCH('#') ) != 0 );
        cdebug << SZ("nls[istr] = \"") << nls[istr] << SZ("\"") << dbgEOL;

        REQUIRE( nls2.strchr( &istr2, TCH('#') ) == 0 );
        cdebug << SZ("nls2[istr] = \"") << nls2[istr2] << SZ("\"") << dbgEOL;

        istr++ ;    // Move past '#'
        REQUIRE( nls.strchr( &istr, TCH('#'), istr ) == 0 );
        cdebug << SZ("nls[istr] = \"") << nls[istr] << SZ("\"") << dbgEOL;
    }

    cdebug << dbgEOL << dbgEOL << SZ("Testing Append methods") << dbgEOL;
    {
        NLS_STR nls = SZ("My original string");

        REQUIRE(nls == (NLS_STR)SZ("My original string"));
        cdebug << SZ("Original string is ") << nls << dbgEOL;

        nls.Append(SZ(" plus another fine string"));
        cdebug << SZ("Now it reads ") << nls << dbgEOL;

        nls.AppendChar(TCH('A'));
        nls.AppendChar(TCH('B'));
        nls.AppendChar(TCH('C'));
        nls.AppendChar(TCH('D'));
        nls.AppendChar(TCH('E'));
        cdebug << SZ("With alpha A-E, reads ") << nls << dbgEOL;
    }

    cdebug << dbgEOL << dbgEOL << SZ("Comparing Length methods") << dbgEOL;
    {
        NLS_STR nlsOdd = SZ("Eat me (odd number)");

        FunFactsAboutString(SZ("nlsOdd"), nlsOdd);

        NLS_STR nlsEven = SZ("Eat me (even number)");

        FunFactsAboutString(SZ("nlsEven"), nlsEven);

        NLS_STR nlsEmpty = SZ("");

        FunFactsAboutString(SZ("nlsEmpty"), nlsEmpty);
    }

    cdebug << dbgEOL << dbgEOL << SZ("Testing NLS_STACK") << dbgEOL;
    {
        STACK_NLS_STR( Test, 10 );
        ISTACK_NLS_STR( Test2, 10, SZ("123456789") );

        REQUIRE( Test.QueryTextLength() == 0 );
        REQUIRE( Test.QueryAllocSize() == 11*sizeof(TCHAR) );
        REQUIRE( Test.IsOwnerAlloc() );

        REQUIRE( Test2.QueryTextLength() == 9 );
        REQUIRE( Test2.QueryAllocSize() == 11*sizeof(TCHAR) );
        REQUIRE( Test2.IsOwnerAlloc() );
        REQUIRE( !::strcmpf( Test2.QueryPch(), SZ("123456789")) );

        Test = SZ("Good Thing");
        REQUIRE( Test.QueryTextLength() == 10 );
        REQUIRE( Test.QueryAllocSize() == 11*sizeof(TCHAR) );
    }

    cdebug << dbgEOL << dbgEOL << SZ("Testing strcpy") << dbgEOL;
    {
        STACK_NLS_STR( nlsSource, 80 );
        TCHAR achBuffer[80];
        nlsSource = SZ("This is a test string");

        strcpy( achBuffer, nlsSource );
        cdebug << SZ("achBuffer = \"") << achBuffer << SZ("\"") << dbgEOL;
        REQUIRE( !::strcmpf( achBuffer, SZ("This is a test string") ) );
    }

    Test0();

    cdebug << dbgEOL << dbgEOL << SZ("Testing substring methods") << dbgEOL;
    {
        NLS_STR nls1  = SZ("jlj ; is a test ffdll; "),
                nlsIs = SZ("is "),
                nlsA = SZ("a");
        ISTR istrIs(nls1), istrA(nls1);

        // QuerySubStr
        REQUIRE( nls1.strstr( &istrIs, nlsIs ) );
        REQUIRE( nls1.strstr( &istrA,  nlsA  ) );

        NLS_STR *pnls = nls1.QuerySubStr( istrIs ),
                *pnls2= nls1.QuerySubStr( istrIs, istrA );

        cdebug << SZ("pnls = ")  << *pnls  << SZ(", ")
               << SZ("pnls2 = ") << *pnls2 << dbgEOL;

        REQUIRE( 0 == pnls->strcmp( SZ("is a test ffdll; ") ) );
        REQUIRE( 0 == pnls2->strcmp(SZ("is ") ) );

        // DelSubStr
        NLS_STR nls3 = nls1;
        REQUIRE( nls3 == nls1 );
        nls1.DelSubStr( istrIs, istrA );

        ISTR istrNLS3Is( nls3 );
        REQUIRE( nls3.strstr( &istrNLS3Is, nlsIs ) );

        cdebug << SZ("nls3 before delsubstring = ") << nls3 << dbgEOL;
        nls3.DelSubStr( istrNLS3Is );
        cdebug << SZ("nls1 = ") << nls1 << SZ(", ")
               << SZ("nls3 = ") << nls3 << dbgEOL;

        REQUIRE( *pnls == (NLS_STR)SZ("is a test ffdll; ") );
        REQUIRE(  nls1 == (NLS_STR)SZ("jlj ; a test ffdll; ") );

        // The following two "delete" ops are correct, since
        // QuerySubStr constructs a new string object for its substr.

        delete pnls;
        delete pnls2;
    }

    // Insert String
    {
        // InsertStr
        NLS_STR nlsIns1 = SZ("Rustan Leino");
        ISTR istrSpc( nlsIns1 );

        REQUIRE( nlsIns1.strcspn( &istrSpc, SZ(" ") ) );
        REQUIRE( nlsIns1.InsertStr( SZ(" \"Mean Swede\""), istrSpc ) );
        cdebug << SZ("nlsIns1 = ") << nlsIns1 << dbgEOL;
        REQUIRE( !::strcmpf( nlsIns1.QueryPch(), SZ("Rustan \"Mean Swede\" Leino") ));

        REQUIRE( nlsIns1.InsertStr( SZ(" very mean"), istrSpc ) );
        cdebug << SZ("nlsIns1 = ") << nlsIns1 << dbgEOL;
        REQUIRE( !::strcmpf( nlsIns1.QueryPch(), SZ("Rustan very mean \"Mean Swede\" Leino") ));

        // ReplSubStr
        NLS_STR nlsRepl = SZ("Margaret Thatcher"),
                nlsRepl2 = SZ("Major");
        ISTR istrThatcher( nlsRepl );
        REQUIRE( nlsRepl.strstr( &istrThatcher, SZ("Thatcher") ) );
        nlsRepl.ReplSubStr( nlsRepl2, istrThatcher );
        cdebug << SZ("nlsRepl = ") << nlsRepl << dbgEOL;
        REQUIRE( nlsRepl == (NLS_STR)SZ("Margaret Major") );

    }

    // Repl. Substring variations
    {
        NLS_STR nlsRepl3 = SZ("set x =20");
        ISTR istrRepl3Start( nlsRepl3 ), istrRepl3End( nlsRepl3);

        // Start and end same at the end of the string
        REQUIRE( nlsRepl3.strcspn( &istrRepl3Start, SZ("2") ) );
        REQUIRE( nlsRepl3.strchr(  &istrRepl3End, TCH('\0') ) );
        nlsRepl3.ReplSubStr( SZ("56234"), istrRepl3Start, istrRepl3End );
        cdebug << SZ("nlsRepl3 = ") << nlsRepl3 << dbgEOL;
        REQUIRE( !::strcmpf( nlsRepl3.QueryPch(), SZ("set x =56234") ) );
        REQUIRE( nlsRepl3.QueryTextLength() == (UINT)::strlenf(SZ("set x =56234") ) );

        // Regular replace substring (delstring/insert string)
        NLS_STR nlsRepl4 = SZ("set x = Line of Text");
        ISTR istrRepl4Start( nlsRepl4 ), istrRepl4End( nlsRepl4);

        REQUIRE( nlsRepl4.strcspn( &istrRepl4Start, SZ("L") ) );
        REQUIRE( nlsRepl4.strcspn(  &istrRepl4End, SZ(" "), istrRepl4Start ) );
        nlsRepl4.ReplSubStr( SZ("Big Buffer"), istrRepl4Start, istrRepl4End );
        cdebug << SZ("nlsRepl4 = ") << nlsRepl4 << dbgEOL;
        REQUIRE( !::strcmpf( nlsRepl4.QueryPch(), SZ("set x = Big Buffer of Text") ) );
        REQUIRE( nlsRepl4.QueryTextLength() == (UINT)::strlenf( SZ("set x = Big Buffer of Text") ) );
    }

    // InsertParams test
    {
        NLS_STR nlsPrimaryOne = SZ("Param 1 = \"%1\"");
        NLS_STR nlsPrimaryTwo = SZ("Param 1 = %1, Param 2 = %2, Param 1+2 = %1%2");
        NLS_STR nlsPrimaryThree = SZ("No params in this string %0, %%% 1%");
        NLS_STR nlsP1 = SZ("Param 1");
        NLS_STR nlsP2 = SZ("Param 2");

        NLS_STR * apnls1[2], *apnls2[3];

        apnls1[0] = apnls2[0] = &nlsP1;
        apnls2[1] = &nlsP2;
        apnls1[1] = apnls2[2] = NULL;

        REQUIRE( !nlsPrimaryOne.InsertParams( apnls1 ) );
        cdebug << SZ("nlsPrimaryOne = ") << nlsPrimaryOne << dbgEOL;
        REQUIRE( !::strcmpf( nlsPrimaryOne.QueryPch(), SZ("Param 1 = \"Param 1\"") ) );

        REQUIRE( !nlsPrimaryTwo.InsertParams( apnls2 ) );
        cdebug << SZ("nlsPrimaryTwo = ") << nlsPrimaryTwo << dbgEOL;
        REQUIRE( !::strcmpf( nlsPrimaryTwo.QueryPch(), SZ("Param 1 = Param 1, Param 2 = Param 2, Param 1+2 = Param 1Param 2")  ) );

        REQUIRE( !nlsPrimaryThree.InsertParams( apnls2 ) );
        cdebug << SZ("nlsPrimaryThree = ") << nlsPrimaryThree << dbgEOL;
        REQUIRE( !::strcmpf( nlsPrimaryThree.QueryPch(), SZ("No params in this string %0, %%% 1%")  ) );
    }
    cdebug << SZ("Done!") << dbgEOL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\string\uinetlib.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    uinetlib.cxx
    String-compare functions

    This file contains the methods for determining whether hyphens and
    apostrophes should be sorted as symbols.  Normally, CompareStringW
    sorts them  seperately from symbols, and only counts them if the
    strings cannot otherwise be distinguished.  However, ITG has noted
    that this causes "a-username" names to be sorted with "au" instead
    of with "a-".  For this reason, we have provided a registry location
    where they can ask that hyphens and apostrophes be sorted with the
    rest of the characters.

    CompareStringW also can set unequal values equal, for example
    "kuss" == "ku<S-Tzet>".  For this reason we follow up equal
    results with RtlCompareUnicodeString.

    We keep seperate values for Std and Nocase so that we don't have to
    perform the extra OR operation on every ignore-case comparison.

    FILE HISTORY:
        jonn        25-Mar-1993     Created for ITG special sort
        jonn        16-Nov-1995     Compensate for CompareStringW

*/
#include "pchstr.hxx"  // Precompiled header

DWORD _static_dwStdCompareParam = 0;
DWORD _static_dwNocaseCompareParam = NORM_IGNORECASE;
LCID  _static_UserDefaultLCID = 0;


/*******************************************************************

    NAME:	InitCompareParam

    SYNOPSIS:   We read the registry to determine whether we should be
                sorting hyphens and apostrophes as symbols.

    HISTORY:
        jonn        25-Mar-1993     Created (borrowing from ADMIN_INI)

********************************************************************/

void  InitCompareParam( void )
{
    _static_dwStdCompareParam = 0;
    _static_dwNocaseCompareParam = NORM_IGNORECASE;
    _static_UserDefaultLCID = 0;

    INT n = ::GetPrivateProfileInt( SZ("Shared Parameters"),
                                    SZ("Sort Hyphens"),
                                    0,
                                    SZ("NTNET.INI") );

    if ( n != 0 )
    {
        _static_dwStdCompareParam    |= SORT_STRINGSORT;
        _static_dwNocaseCompareParam |= SORT_STRINGSORT;
    }

    _static_UserDefaultLCID = GetUserDefaultLCID();
}


/*******************************************************************

    NAME:	QueryStdCompareParam
                QueryNocaseCompareParam

    SYNOPSIS:	Return the fdwStyle parameter to be used for all calls
                to CompareStringW in the NETUI project.

    HISTORY:
        jonn        25-Mar-1993     Created

********************************************************************/

DWORD QueryStdCompareParam( void )
{
    return _static_dwStdCompareParam;
}

DWORD QueryNocaseCompareParam( void )
{
    return _static_dwNocaseCompareParam;
}


/*******************************************************************

    NAME:	QueryUserDefaultLCID

    SYNOPSIS:	Return the LCID to use in string comparisons.

    HISTORY:
        jonn        02-Feb-1994     Created

********************************************************************/

DWORD QueryUserDefaultLCID( void ) // actually an LCID
{
    return (DWORD)_static_UserDefaultLCID;
}


/*******************************************************************

    NAME:	NLS_STR::NETUI_strcmp
                         NETUI_stricmp
                         NETUI_strncmp
                         NETUI_strnicmp

    HISTORY:
        jonn    29-Mar-1993     Created

********************************************************************/
DLL_BASED
INT NETUI_strcmp( const WCHAR * pchString1, const WCHAR * pchString2 )
{
    ASSERT( pchString1 != NULL && pchString2 != NULL );

    INT nCompare = ::CompareStringW( _static_UserDefaultLCID,
                                     _static_dwStdCompareParam,
                                     (LPCWSTR)pchString1,
                                     (int)-1,
                                     (LPCWSTR)pchString2,
                                     (int)-1 );
#if defined(DEBUG)
    if ( nCompare == 0 )
    {
        DBGEOL(   "NETUI_strcmp( \""
               << pchString1
               << "\", \""
               << pchString2
               << "\" ) error "
               << ::GetLastError() );
        ASSERT( FALSE );
    }
#endif

    nCompare -= 2;

    if (nCompare == 0)
    {
        UNICODE_STRING unistr1;
        unistr1.Length = ::strlenf(pchString1)*sizeof(WCHAR);
        unistr1.MaximumLength = unistr1.Length;
        unistr1.Buffer = (LPWSTR)pchString1;
        UNICODE_STRING unistr2;
        unistr2.Length = ::strlenf(pchString2)*sizeof(WCHAR);
        unistr2.MaximumLength = unistr2.Length;
        unistr2.Buffer = (LPWSTR)pchString2;
        nCompare = ::RtlCompareUnicodeString(
            &unistr1,
            &unistr2,
            FALSE );
    }

    return nCompare;

}

DLL_BASED
INT NETUI_stricmp( const WCHAR * pchString1, const WCHAR * pchString2 )
{
    ASSERT( pchString1 != NULL && pchString2 != NULL );

    INT nCompare = ::CompareStringW( _static_UserDefaultLCID,
                                     _static_dwNocaseCompareParam,
                                     (LPCWSTR)pchString1,
                                     (int)-1,
                                     (LPCWSTR)pchString2,
                                     (int)-1 );
#if defined(DEBUG)
    if ( nCompare == 0 )
    {
        DBGEOL(   "NETUI_stricmp( \""
               << pchString1
               << "\", \""
               << pchString2
               << "\" ) error "
               << ::GetLastError() );
        ASSERT( FALSE );
    }
#endif

    nCompare -= 2;

    if (nCompare == 0)
    {
        UNICODE_STRING unistr1;
        unistr1.Length = ::strlenf(pchString1)*sizeof(WCHAR);
        unistr1.MaximumLength = unistr1.Length;
        unistr1.Buffer = (LPWSTR)pchString1;
        UNICODE_STRING unistr2;
        unistr2.Length = ::strlenf(pchString2)*sizeof(WCHAR);
        unistr2.MaximumLength = unistr2.Length;
        unistr2.Buffer = (LPWSTR)pchString2;
        nCompare = ::RtlCompareUnicodeString(
            &unistr1,
            &unistr2,
            TRUE );
    }

    return nCompare;
}

DLL_BASED
INT NETUI_strncmp( const WCHAR * pchString1, const WCHAR * pchString2, INT cch )
{
    ASSERT( pchString1 != NULL && pchString2 != NULL );

    INT nCompare = ::CompareStringW( _static_UserDefaultLCID,
                                     _static_dwStdCompareParam,
                                     (LPCWSTR)pchString1,
                                     (int)cch,
                                     (LPCWSTR)pchString2,
                                     (int)cch );
#if defined(DEBUG)
    if ( nCompare == 0 )
    {
        DBGEOL(   "NETUI_strncmp( \""
               << pchString1
               << "\", \""
               << pchString2
               << "\", "
               << cch
               << " ) error "
               << ::GetLastError() );
        ASSERT( FALSE );
    }
#endif

    nCompare -= 2;

    if (nCompare == 0)
    {
        UNICODE_STRING unistr1;
        unistr1.Length = (USHORT)(cch*sizeof(WCHAR));
        unistr1.MaximumLength = unistr1.Length;
        unistr1.Buffer = (LPWSTR)pchString1;
        UNICODE_STRING unistr2;
        unistr2.Length = (USHORT)(cch*sizeof(WCHAR));
        unistr2.MaximumLength = unistr2.Length;
        unistr2.Buffer = (LPWSTR)pchString2;
        nCompare = ::RtlCompareUnicodeString(
            &unistr1,
            &unistr2,
            FALSE );
    }

    return nCompare;
}

DLL_BASED
INT NETUI_strnicmp( const WCHAR * pchString1, const WCHAR * pchString2, INT cch )
{
    ASSERT( pchString1 != NULL && pchString2 != NULL );

    INT nCompare = ::CompareStringW( _static_UserDefaultLCID,
                                     _static_dwNocaseCompareParam,
                                     (LPCWSTR)pchString1,
                                     (int)cch,
                                     (LPCWSTR)pchString2,
                                     (int)cch );
#if defined(DEBUG)
    if ( nCompare == 0 )
    {
        DBGEOL(   "NETUI_strnicmp( \""
               << pchString1
               << "\", \""
               << pchString2
               << "\", "
               << cch
               << " ) error "
               << ::GetLastError() );
        ASSERT( FALSE );
    }

#endif

    nCompare -= 2;

    if (nCompare == 0)
    {
        UNICODE_STRING unistr1;
        unistr1.Length = (USHORT)(cch*sizeof(WCHAR));
        unistr1.MaximumLength = unistr1.Length;
        unistr1.Buffer = (LPWSTR)pchString1;
        UNICODE_STRING unistr2;
        unistr2.Length = (USHORT)(cch*sizeof(WCHAR));
        unistr2.MaximumLength = unistr2.Length;
        unistr2.Buffer = (LPWSTR)pchString2;
        nCompare = ::RtlCompareUnicodeString(
            &unistr1,
            &unistr2,
            TRUE );
    }

    return nCompare;
}

DLL_BASED
INT NETUI_strncmp2( const WCHAR * pchString1, INT cch1,
                    const WCHAR * pchString2, INT cch2 )
{
    ASSERT( pchString1 != NULL && pchString2 != NULL );

    INT nCompare = ::CompareStringW( _static_UserDefaultLCID,
                                     _static_dwStdCompareParam,
                                     (LPCWSTR)pchString1,
                                     (int)cch1,
                                     (LPCWSTR)pchString2,
                                     (int)cch2 );
#if defined(DEBUG)
    if ( nCompare == 0 )
    {
        DBGEOL(   "NETUI_strncmp2( \""
               << pchString1
               << "\", " << cch1 << ", \""
               << pchString2
               << "\", "
               << cch2
               << " ) error "
               << ::GetLastError() );
        ASSERT( FALSE );
    }
#endif

    nCompare -= 2;

    if (nCompare == 0)
    {
        UNICODE_STRING unistr1;
        unistr1.Length = (USHORT)(cch1*sizeof(WCHAR));
        unistr1.MaximumLength = unistr1.Length;
        unistr1.Buffer = (LPWSTR)pchString1;
        UNICODE_STRING unistr2;
        unistr2.Length = (USHORT)(cch2*sizeof(WCHAR));
        unistr2.MaximumLength = unistr2.Length;
        unistr2.Buffer = (LPWSTR)pchString2;
        nCompare = ::RtlCompareUnicodeString(
            &unistr1,
            &unistr2,
            FALSE );
    }

    return nCompare;
}

DLL_BASED
INT NETUI_strnicmp2( const WCHAR * pchString1, INT cch1,
                     const WCHAR * pchString2, INT cch2 )
{
    ASSERT( pchString1 != NULL && pchString2 != NULL );

    INT nCompare = ::CompareStringW( _static_UserDefaultLCID,
                                     _static_dwNocaseCompareParam,
                                     (LPCWSTR)pchString1,
                                     (int)cch1,
                                     (LPCWSTR)pchString2,
                                     (int)cch2 );
#if defined(DEBUG)
    if ( nCompare == 0 )
    {
        DBGEOL(   "NETUI_strnicmp2( \""
               << pchString1
               << "\", " << cch1 << ", \""
               << pchString2
               << "\", "
               << cch2
               << " ) error "
               << ::GetLastError() );
        ASSERT( FALSE );
    }

#endif

    nCompare -= 2;

    if (nCompare == 0)
    {
        UNICODE_STRING unistr1;
        unistr1.Length = (USHORT)(cch1*sizeof(WCHAR));
        unistr1.MaximumLength = unistr1.Length;
        unistr1.Buffer = (LPWSTR)pchString1;
        UNICODE_STRING unistr2;
        unistr2.Length = (USHORT)(cch2*sizeof(WCHAR));
        unistr2.MaximumLength = unistr2.Length;
        unistr2.Buffer = (LPWSTR)pchString2;
        nCompare = ::RtlCompareUnicodeString(
            &unistr1,
            &unistr2,
            TRUE );
    }

    return nCompare;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\test\hello\hello.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    hello.cxx
    The very simplest test case

    FILE HISTORY:
        beng        30-Apr-1991     Created

*/

#include <lmui.hxx>

extern "C"
{
    #include <stdio.h>
}

#include <string.hxx>


INT main()
{
#if defined(UNICODE)
    puts("This test only runs in non-Unicode environments.");
#else
    NLS_STR nlsString = SZ("Your mother loves only Godzilla.");

    puts(nlsString.QueryPch());
#endif

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\test\format\xstr01.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    xstr01.cxx
    Some more string unit tests - the formatters

    This module plugs into XstrSkel.

    FILE HISTORY:
        beng        02-Mar-1992 Created
        beng        16-Mar-1992 Changes to cdebug
*/

#define USE_CONSOLE

#define INCL_NETLIB
#if defined(WINDOWS)
# define INCL_WINDOWS
#else
# if defined(WIN32)
#  define INCL_DOSERRORS
#  define INCL_NETERRORS
# else
#  define INCL_OS2
# endif
#endif
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = "xstr01.cxx";
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#include <uiassert.hxx>
#include <string.hxx>
#include <strtchar.hxx>
#include <strnumer.hxx>

#include "xstrskel.hxx"


// This op renders a NLS_STR, bracketing it for readability.

DBGSTREAM& operator<<(DBGSTREAM &out, const NLS_STR &nls)
{
    if (!nls)
        out << SZ("<(Unrenderable - Error state ") << nls.QueryError() << SZ(")>");
    else
        out << TCH('<') << nls.QueryPch() << TCH('>');

    return out;
}


#if !defined(UNICODE)
DBGSTREAM& operator<<(DBGSTREAM &out, const WCHAR wch)
{
    out << (TCHAR)wch;

    return out;
}
#endif


VOID FunFactsAboutString(const TCHAR* pszName, const NLS_STR& nls)
{
    cdebug << pszName << SZ(" reads ") << nls << dbgEOL;
    cdebug << SZ("   strlen = ")       << nls.strlen() << dbgEOL;
    cdebug << SZ("   QAllocSize = ")   << nls.QueryAllocSize() << dbgEOL;
    cdebug << SZ("   QNumChar = ")     << nls.QueryNumChar() << dbgEOL;
    cdebug << SZ("   QTLength = ")     << nls.QueryTextLength() << dbgEOL;
    cdebug << SZ("   QTSize = ")       << nls.QueryTextSize() << dbgEOL;
}


VOID Test01()
{
    NLS_STR nlsPrimaryOne = SZ("Param 1 = \"%1\"");
    NLS_STR nlsPrimaryTwo = SZ("Param 1 = %1, Param 2 = %2, Param 1+2 = %1%2");
    NLS_STR nlsPrimaryThree = SZ("No params in this string %0, %%% 1%");
    NLS_STR nlsP1 = SZ("Param 1");
    NLS_STR nlsP2 = SZ("Param 2");

    NLS_STR * apnls1[2], *apnls2[3];

    apnls1[0] = apnls2[0] = &nlsP1;
    apnls2[1] = &nlsP2;
    apnls1[1] = apnls2[2] = NULL;

    REQUIRE( !nlsPrimaryOne.InsertParams( apnls1 ) );
    cdebug << SZ("nlsPrimaryOne = ") << nlsPrimaryOne << dbgEOL;
    REQUIRE( !::strcmpf( nlsPrimaryOne.QueryPch(), SZ("Param 1 = \"Param 1\"") ) );

    REQUIRE( !nlsPrimaryTwo.InsertParams( apnls2 ) );
    cdebug << SZ("nlsPrimaryTwo = ") << nlsPrimaryTwo << dbgEOL;
    REQUIRE( !::strcmpf( nlsPrimaryTwo.QueryPch(), SZ("Param 1 = Param 1, Param 2 = Param 2, Param 1+2 = Param 1Param 2")  ) );

    REQUIRE( !nlsPrimaryThree.InsertParams( apnls2 ) );
    cdebug << SZ("nlsPrimaryThree = ") << nlsPrimaryThree << dbgEOL;
    REQUIRE( !::strcmpf( nlsPrimaryThree.QueryPch(), SZ("No params in this string %0, %%% 1%")  ) );
}


VOID Test02()
{
    NLS_STR nlsUno = SZ("My one argument: %1");
    NLS_STR nlsDos = SZ("My two arguments: %1, %2");
    NLS_STR nlsRevved = SZ("My two arguments in rev order: %2, %1");

    NLS_STR nlsDing = SZ("Ding");
    NLS_STR nlsDong = SZ("Dong");

    REQUIRE(!!nlsUno && !!nlsDos && !!nlsRevved && !!nlsDing && !!nlsDong);

    REQUIRE(!nlsUno.InsertParams(nlsDing));
    DBGEOL(SZ("nlsUno = ") << nlsUno);
    REQUIRE(!::strcmpf(nlsUno, SZ("My one argument: Ding")));

    REQUIRE(!nlsDos.InsertParams(nlsDing, nlsDong));
    DBGEOL(SZ("nlsDos = ") << nlsDos);
    REQUIRE(!::strcmpf(nlsDos, SZ("My two arguments: Ding, Dong")));

    REQUIRE(!nlsRevved.InsertParams(nlsDing, nlsDong));
    DBGEOL(SZ("nlsRevved = ") << nlsRevved);
    REQUIRE(!::strcmpf(nlsRevved, SZ("My two arguments in rev order: Dong, Ding")));
}


// test TCHAR_STR dinky class

VOID Test03()
{
    TCHAR_STR nlsA(TCH('A'));
    TCHAR_STR nlsM(TCH('m'));
    TCHAR_STR nlsN(TCH('N'));
    TCHAR_STR nlsZ(TCH('z'));
    TCHAR_STR nlsZero(TCH('0'));

    REQUIRE(!!nlsA && !!nlsM && !!nlsN && !!nlsZ && !!nlsZero);

    NLS_STR nlsAlfa = SZ("From %1 to %2, with %3 exceptions.  Amen.");

    REQUIRE(!nlsAlfa.InsertParams(nlsA, nlsZ, nlsZero));
    DBGEOL(SZ("nlsAlfa = ") << nlsAlfa);
    REQUIRE(!::strcmpf(nlsAlfa, SZ("From A to z, with 0 exceptions.  Amen.")));
}


VOID Test04()
{
    DEC_STR nls2001(2001);
    DEC_STR nls2002(2002, 6);

    HEX_STR nlsBeef(0xBEEF);
    HEX_STR nlsBigBeef(0xBEEF, 8);
    HEX_STR nlsDeadBeef(0xDEADBEEF);

    REQUIRE(!!nls2001 && !!nls2002 && !!nlsBeef && !!nlsBigBeef && !!nlsDeadBeef);

    DBGEOL(SZ("nls2001 = ") << nls2001);
    REQUIRE(!::strcmpf(nls2001, SZ("2001")));

    DBGEOL(SZ("nls2002 = ") << nls2002);
    REQUIRE(!::strcmpf(nls2002, SZ("002002")));

    DBGEOL(SZ("nlsBeef = ") << nlsBeef);
    REQUIRE(!::strcmpf(nlsBeef, SZ("beef")));

    DBGEOL(SZ("nlsBigBeef = ") << nlsBigBeef);
    REQUIRE(!::strcmpf(nlsBigBeef, SZ("0000beef")));

    DBGEOL(SZ("nlsDeadBeef = ") << nlsDeadBeef);
    REQUIRE(!::strcmpf(nlsDeadBeef, SZ("deadbeef")));
}


VOID Test05()
{
    NUM_NLS_STR nls1 = 1;
    NUM_NLS_STR nls17 = 17;
    NUM_NLS_STR nls385 = 385;
    NUM_NLS_STR nls8277 = 8277;
    NUM_NLS_STR nls20000 = 20000;
    NUM_NLS_STR nls718333 = 718333;
    NUM_NLS_STR nls6666666 = 6666666;
    NUM_NLS_STR nls40200200 = 40200200;
    NUM_NLS_STR nls100000000 = 100000000;
    NUM_NLS_STR nls2999999991 = 2999999991;

    REQUIRE(!!nls1);
    REQUIRE(!!nls17);
    REQUIRE(!!nls385);
    REQUIRE(!!nls8277);
    REQUIRE(!!nls20000);
    REQUIRE(!!nls718333);
    REQUIRE(!!nls6666666);
    REQUIRE(!!nls40200200);
    REQUIRE(!!nls100000000);
    REQUIRE(!!nls2999999991);

    DBGEOL(SZ("nls1 = ") << nls1);
    DBGEOL(SZ("nls17 = ") << nls17);
    DBGEOL(SZ("nls385 = ") << nls385);
    DBGEOL(SZ("nls8277 = ") << nls8277);
    DBGEOL(SZ("nls20000 = ") << nls20000);
    DBGEOL(SZ("nls718333 = ") << nls718333);
    DBGEOL(SZ("nls6666666 = ") << nls6666666);
    DBGEOL(SZ("nls40200200 = ") << nls40200200);
    DBGEOL(SZ("nls100000000 = ") << nls100000000);
    DBGEOL(SZ("nls2999999991 = ") << nls2999999991);

    REQUIRE(!::strcmpf(nls1,          SZ("1")));
    REQUIRE(!::strcmpf(nls17,         SZ("17")));
    REQUIRE(!::strcmpf(nls385,        SZ("385")));
    REQUIRE(!::strcmpf(nls8277,       SZ("8,277")));
    REQUIRE(!::strcmpf(nls20000,      SZ("20,000")));
    REQUIRE(!::strcmpf(nls718333,     SZ("718,333")));
    REQUIRE(!::strcmpf(nls6666666,    SZ("6,666,666")));
    REQUIRE(!::strcmpf(nls40200200,   SZ("40,200,200")));
    REQUIRE(!::strcmpf(nls100000000,  SZ("100,000,000")));
    REQUIRE(!::strcmpf(nls2999999991, SZ("2,999,999,991")));
}


VOID RunTest()
{
    Test01();
    Test02();
    Test03();
    Test04();
    Test05();

    DBGEOL(SZ("Done!"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\common\src\string\test\skeleton\xstrskel.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    xstrskel.cxx
    STRING unit test: main application module

    This is a skeleton for string unit tests, allowing them to
    be written in a host-env independent fashion.

    FILE HISTORY:
        johnl       12-Nov-1990 Created
        beng        01-May-1991 Added workaround for C7 bug
        beng        27-Jun-1991 Win and OS2 tests merged
                                (used BUFFER as a template)
        beng        06-Jul-1991 Frame and test partitioned
        beng        14-Oct-1991 Uses APPLICATION
        beng        28-Feb-1992 Works for the console in general
        beng        16-Mar-1992 Changes to cdebug
*/

#define USE_CONSOLE

#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETLIB
#if defined(WINDOWS)
# define INCL_WINDOWS
#else
# define INCL_OS2
#endif
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = "xstrskel.cxx";
#define _FILENAME_DEFINED_ONCE szFileName
#endif

extern "C"
{
    #include "xstrskel.h"
}

#if defined(WINDOWS)
# if !defined(USE_CONSOLE)
#  define INCL_BLT_CONTROL
#  define INCL_BLT_CLIENT
# endif
# define INCL_BLT_APP
# include <blt.hxx>
#endif

#if !defined(WINDOWS) || defined(USE_CONSOLE)
extern "C"
{
# include <stdio.h>
}
#endif

#include <uiassert.hxx>
#include <dbgstr.hxx>

#include "xstrskel.hxx"


#if defined(WINDOWS) && !defined(USE_CONSOLE)

const TCHAR szIconResource[] = SZ("TestIcon");
const TCHAR szMenuResource[] = SZ("TestMenu");
const TCHAR szAccelResource[] = SZ("TestAccel");

const TCHAR szMainWindowTitle[] = SZ("Class STRING Test");


class XSTR_WND: public APP_WINDOW
{
protected:
    // Redefinitions
    //
    virtual BOOL OnMenuCommand( MID mid );

public:
    XSTR_WND();
};


class XSTR_APP: public APPLICATION
{
private:
    XSTR_WND  _wndApp;
    ACCELTABLE _accel;

public:
    XSTR_APP( HANDLE hInstance, TCHAR * pszCmdLine, INT nCmdShow );

    // Redefinitions
    //
    virtual BOOL FilterMessage( MSG* );
};


XSTR_APP::XSTR_APP( HANDLE hInst, TCHAR * pszCmdLine, INT nCmdShow )
    : APPLICATION( hInst, pszCmdLine, nCmdShow ),
      _accel( szAccelResource ),
      _wndApp()
{
    if (QueryError())
        return;

    if (!_accel)
    {
        ReportError(_accel.QueryError());
        return;
    }

    if (!_wndApp)
    {
        ReportError(_wndApp.QueryError());
        return;
    }

    _wndApp.ShowFirst();
}


BOOL XSTR_APP::FilterMessage( MSG *pmsg )
{
    return (_accel.Translate(&_wndApp, pmsg));
}


XSTR_WND::XSTR_WND()
    : APP_WINDOW(szMainWindowTitle, szIconResource, szMenuResource )
{
    if (QueryError())
        return;

    // ...
}


BOOL XSTR_WND::OnMenuCommand( MID mid )
{
    switch (mid)
    {
    case IDM_RUN_TEST:
        ::MessageBox(QueryHwnd(),
            SZ("Test results will be written to debug terminal.  Bogus, huh?"),
            SZ("Note"), MB_OK);

        ::RunTest();
        return TRUE;
    }

    // default
    return APP_WINDOW::OnMenuCommand(mid);
}


SET_ROOT_OBJECT( XSTR_APP )

#elif defined(WINDOWS) && defined(USE_CONSOLE)

// Win32, with console support


class TEST_APP: public APPLICATION
{
private:
    OUTPUT_TO_STDERR _out;
    DBGSTREAM        _dbg;
    DBGSTREAM *      _pdbgSave;

public:
    TEST_APP( HANDLE hInstance, TCHAR * pszCmdLine, INT nCmdShow );
    ~TEST_APP();

    // Redefinitions
    //
    virtual INT Run();
};


TEST_APP::TEST_APP( HANDLE hInst, TCHAR * pszCmdLine, INT nCmdShow )
    : APPLICATION( hInst, pszCmdLine, nCmdShow ),
      _out(),
      _dbg(&_out),
      _pdbgSave( &(DBGSTREAM::QueryCurrent()) )
{
    if (QueryError())
        return;

    // Point cdebug to stderr instead of aux
    //
    DBGSTREAM::SetCurrent(&_dbg);
}


TEST_APP::~TEST_APP()
{
    // Restore original stream

    DBGSTREAM::SetCurrent(_pdbgSave);
}


INT TEST_APP::Run()
{
    // Never mind the message loop... this is a console app.
    // Hope this works.
    //
    ::RunTest();
}


SET_ROOT_OBJECT( TEST_APP )


#else // OS2, or DOS, or some such env


INT main()
{
    OUTPUT_TO_STDOUT out;
    DBGSTREAM dbg(&out);
    DBGSTREAM::SetCurrent(&dbg);

    ::RunTest();

    DBGSTREAM::SetCurrent(NULL);
    return 0;
}


#endif // WINDOWS -vs- OS2 unit test skeletons
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\liccpa\clicreg.cpp ===
//-------------------------------------------------------------------
//
//  FILE: CLiCLicReg.Cpp
//
//  Summary;
// 		Class implementation for handling the licensing api registration
//
//	Notes;
//		Key = \HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LicenseInfo
//		Value= ErrorControl : REG_DWORD : 0x1
//		Value= Start : REG_DWORD : 0x3
//		Value= Type : REG_DWORD : 0x4
//
//		Subkeys :
//		\SNA
//		\SQL
//		\FilePrint
//
//		Value for All Subkeys=
//		Mode : REG_DWORD :  (0x0 = Per Seat Mode, 0x1 = Concurrent/Per Server Mode)
//		ConcurrentLimit : REG_DWORD : (0x<limit>, ie. 0x100 = 256 concurrent user limit)
//      FamilyDisplayName: RED_SZ : Name for this service (not version specific)
//		DisplayName : REG_SZ : User seen name for this Service entry
//		FlipAllow : REG_DWORD : (0x0 = can change license mode, 0x1 license mode can't
//			be changed.   Server apps are only allowed to switch their license mode
//			once, so after the first switch, this value would be set to non-zero, 
//			then the UI	will not allow for further changes to the licence mode.
//			Changing is currently allowed but a dialog is raised to warn them of the
//			possible violation.
//
//	History
//		11/15/94 MikeMi Created
//
//-------------------------------------------------------------------

#include <windows.h>
#include "CLicReg.hpp"

// Strings for keys and values
//
const WCHAR szLicenseKey[] = L"SYSTEM\\CurrentControlSet\\Services\\LicenseInfo";
const WCHAR szErrControlValue[] = L"ErrorControl";
const WCHAR szStartValue[] = L"Start";
const WCHAR szTypeValue[] = L"Type";

const WCHAR szNameValue[] = L"DisplayName";
const WCHAR szFamilyNameValue[] = L"FamilyDisplayName";
const WCHAR szModeValue[] = L"Mode";
const WCHAR szLimitValue[] = L"ConcurrentLimit";
const WCHAR szFlipValue[] = L"FlipAllow";

// set values under License Key
//
const DWORD dwErrControlValue = SERVICE_ERROR_NORMAL; // 1;
const DWORD dwStartValue = SERVICE_DEMAND_START; // 3;
const DWORD dwTypeValue = SERVICE_ADAPTER; // 4;

//-------------------------------------------------------------------
//
//	Method:	CLicReg::CLicReg
//
//	Summary;
//		Contructor
//
//  History;
//		Nov-15-94 MikeMi Created
//
//-------------------------------------------------------------------

CLicReg::CLicReg( )
{
	_hkey = NULL;
}

//-------------------------------------------------------------------
//
//	Method:	CLicReg::~CLicReg
//
//	Summary;
//		Destructor
//
//  History;
//		Nov-15-94 MikeMi Created
//
//-------------------------------------------------------------------

CLicReg::~CLicReg( )
{
	Close();
}

//-------------------------------------------------------------------
//
//	Method:	CLicReg::CommitNow
//
//	Summary;
//		This will flush the changes made imediately
//
//	Return:
//		ERROR_SUCCESS when this method works.
//		See RegFlushKey for return values
//
//  Notes:
//
//  History;
//		Nov-15-94 MikeMi Created
//
//-------------------------------------------------------------------

LONG 
CLicReg::CommitNow()
{
	return( RegFlushKey( _hkey ) );
}

//-------------------------------------------------------------------
//
//	Method:	CLicReg::Close
//
//	Summary;
//		This will close the registry. See Open.
//
//	Return: 
//		ERROR_SUCCESS when this method works.
//		See RegCloseKey for return values
//
//  Notes:
//
//  History;
//		Nov-15-94 MikeMi Created
//
//-------------------------------------------------------------------

LONG 
CLicReg::Close()
{
    LONG lrt = ERROR_SUCCESS;
    if ( _hkey )
    {
        lrt = ::RegCloseKey( _hkey );
        _hkey = NULL;
    }
    return( lrt  );
}

//-------------------------------------------------------------------
//
//	Method:	CLicRegLicense::Open
//
//	Summary;
//		This will open the registry for License Services Enumeration.
//
//	Arguments;
//		fNew [out] - Was the opened reg key new.
//      pszComputer [in] - the computer name to open the registry on
//              this value maybe null (default), this means local machine
//              should be of the form \\name
//
//	Return:  
//		ERROR_SUCCESS when this method works.
//		See RegCreateKeyEx & RegSetValueEx for error returns.
//
//  Notes:
//
//  History;
//		Nov-15-94 MikeMi Created
//
//-------------------------------------------------------------------
	
LONG 
CLicRegLicense::Open( BOOL& fNew, LPCWSTR pszComputer )
{
	DWORD dwDisposition;
	LONG  lrt;
    HKEY  hkeyRemote = NULL;

    lrt = RegConnectRegistry( (LPTSTR)pszComputer, 
            HKEY_LOCAL_MACHINE, 
            &hkeyRemote );

    if (ERROR_SUCCESS == lrt)
    {
    	fNew = FALSE;
    	lrt = ::RegCreateKeyEx( hkeyRemote, 
    				szLicenseKey,
    				0,
    				NULL,
    				REG_OPTION_NON_VOLATILE,
    				KEY_ALL_ACCESS,
    				NULL,
    				&_hkey,
    				&dwDisposition );

    	if ((ERROR_SUCCESS == lrt) &&
    		(REG_CREATED_NEW_KEY == dwDisposition) )
    	{
    		fNew = 	TRUE;
    		// Set normal values
    		//
    		lrt = ::RegSetValueEx( _hkey,
    				szErrControlValue,
    				0,
    				REG_DWORD,
    				(PBYTE)&dwErrControlValue,
    				sizeof( DWORD ) );
    		if (ERROR_SUCCESS == lrt)
    		{

    			lrt = ::RegSetValueEx( _hkey,
    					szStartValue,
    					0,
    					REG_DWORD,
    					(PBYTE)&dwStartValue,
    					sizeof( DWORD ) );
    			if (ERROR_SUCCESS == lrt)
    			{

    				lrt = ::RegSetValueEx( _hkey,
    						szTypeValue,
    						0,
    						REG_DWORD,
    						(PBYTE)&dwTypeValue,
    						sizeof( DWORD ) );
    			}
    		}
    	}
        ::RegCloseKey( hkeyRemote );    
    }
	return( lrt );
}

//-------------------------------------------------------------------
//
//	Method:	CLicRegLicense::EnumService
//
//	Summary;
//		This will enumerate services listed in the registry for Licensing
//
//	Arguments;
//		iService [in] - This should be zero on the first call and incremented
//			on subsequent calls.
//		pszBuffer [out] - string buffer to place service reg name in
//		cchBuffer [in-out] - the length of the pszBuffer, if not large enough,
//			this value will change to what is needed.
//
//	Return:   
//		ERROR_SUCCESS when this method works.
//		ERROR_NO_MORE_ITEMS when end of enumeration was reached
//		See RegEnumKeyEx for error return values
//
//  Notes:
//
//  History;
//		Nov-15-94 MikeMi Created
//
//-------------------------------------------------------------------
	
LONG 
CLicRegLicense::EnumService( DWORD iService, LPWSTR pszBuffer, DWORD& cchBuffer )
{
	LONG lrt;
	FILETIME ftLastWritten;
	
	lrt = ::RegEnumKeyEx( _hkey, 
			iService,
			pszBuffer,
			&cchBuffer,
			0,
			NULL,
			NULL,
			&ftLastWritten );
	return( lrt );
}

//-------------------------------------------------------------------
//
//	Method:	CLicRegLicenseService::CLicRegLicenseService
//
//	Summary;
//		Contructor
//
//	Arguments;
//		pszService [in] - Service Reg Key Name 
//
//  History;
//		Nov-15-94 MikeMi Created
//
//-------------------------------------------------------------------

CLicRegLicenseService::CLicRegLicenseService( LPCWSTR pszService )
{
	_pszService = (LPWSTR)pszService;
}

//-------------------------------------------------------------------
//
//	Method:	CLicRegLicenseService::SetServie
//
//	Summary;
//		Set the Service Reg Key name
//
//	Arguments;
//		pszService [in] - Service Reg Key Name 
//
//  History;
//		Nov-15-94 MikeMi Created
//      Apr-26-95   MikeMi  Added Computer name and remoting
//
//-------------------------------------------------------------------

void
CLicRegLicenseService::SetService( LPCWSTR pszService )
{
	Close();
	_pszService = (LPWSTR)pszService;
}

//-------------------------------------------------------------------
//
//	Method:	CLicRegLicenseService::Open
//
//	Summary;
//		Opens/Create registry entry for this service
//
//	Arguments;
//      pszComputer [in] - the computer name to open the registry on
//              this value maybe null (default), this means local machine
//              should be of the form \\name
//
//	Return:
//		ERROR_SUCCESS - Open/Created Correctly
//		See RegCreateKeyEx for other errors.
//
//  History;
//		Nov-15-94 MikeMi Created
//
//-------------------------------------------------------------------
	
LONG 
CLicRegLicenseService::Open( LPCWSTR pszComputer, BOOL fCreate )
{
	HKEY  hkeyRoot;
	DWORD dwDisposition;
	LONG  lrt;
    HKEY  hkeyRemote = NULL;

    lrt = RegConnectRegistry( (LPTSTR)pszComputer, 
            HKEY_LOCAL_MACHINE, 
            &hkeyRemote );

    if (ERROR_SUCCESS == lrt)
    {
        if (fCreate)
        {
        	lrt = ::RegCreateKeyEx( hkeyRemote, 
        				szLicenseKey,
        				0,
        				NULL,
        				REG_OPTION_NON_VOLATILE,
        				KEY_ALL_ACCESS,
        				NULL,
        				&hkeyRoot,
        				&dwDisposition );
        }
        else
        {
        	lrt = ::RegOpenKeyEx( hkeyRemote, 
				szLicenseKey,
				0,
				KEY_ALL_ACCESS,
				&hkeyRoot );
        }

    	if (ERROR_SUCCESS == lrt)
    	{
    		// open or create our service key
    		//
            if (fCreate)
            {
        		lrt = ::RegCreateKeyEx( hkeyRoot, 
        				_pszService,
        				0,
        				NULL,
        				REG_OPTION_NON_VOLATILE,
        				KEY_ALL_ACCESS,
        				NULL,
        				&_hkey,
        				&dwDisposition );
            }
            else
            {
           		lrt = ::RegOpenKeyEx( hkeyRoot, 
        				_pszService,
        				0,
        				KEY_ALL_ACCESS,
        				&_hkey );
            }
    		::RegCloseKey( hkeyRoot );
    	}
        ::RegCloseKey( hkeyRemote );    
    }
	return( lrt );
}

//-------------------------------------------------------------------
//
//	Method:	CLicRegLicenseService::CanChangeMode
//
//	Summary;
//		This will check the registry to see if the license mode 
//		can be changed.
//
//	Return:  TRUE if the mode can be changed, otherwise FALSE
//
//  History;
//		Nov-15-94 MikeMi Created
//
//-------------------------------------------------------------------

BOOL 
CLicRegLicenseService::CanChangeMode()
{
	BOOL frt = TRUE;
	LONG lrt;
	DWORD dwSize = sizeof( DWORD );
	DWORD dwRegType = REG_DWORD;
	DWORD fWasChanged;

	lrt = ::RegQueryValueEx( _hkey,
			(LPWSTR)szFlipValue,
			0,
			&dwRegType,
			(PBYTE)&fWasChanged,
			&dwSize );

	if ( (ERROR_SUCCESS == lrt) &&
		 (dwRegType == REG_DWORD) &&
		 (dwSize == sizeof( DWORD )) )
	{
		frt = !fWasChanged;
	}
	else
	{
		SetChangeFlag( FALSE );
	}

	return( frt );
}
//-------------------------------------------------------------------
//
//	Method:	CLicRegLicenseService::SetChangeFlag
//
//	Summary;
//		This will set the change flag in the registry
//
//	Arguments;
//		fHasChanged [in] - Has the license been changed
//
//	Return:
//		ERROR_SUCCESS - The flag was set
//		See RegSetValueEx for error returns
//
//  Notes:
//
//  History;
//		Nov-15-94 MikeMi Created
//
//-------------------------------------------------------------------

LONG 
CLicRegLicenseService::SetChangeFlag( BOOL fHasChanged )
{
	LONG lrt;
    DWORD dwf = (DWORD)fHasChanged;

	lrt = ::RegSetValueEx( _hkey,
			szFlipValue,
			0,
			REG_DWORD,
			(PBYTE)&dwf,
			sizeof( DWORD ) );

	return( lrt );
}

//-------------------------------------------------------------------
//
//	Method:	CLicRegLicenseService::SetMode
//
//	Summary;
//		Set this services licensing mode
//
//	Arguments;
//		lm [in] - the mode to set the registry to
//
//	Return:
//		ERROR_SUCCESS - The mode was set
//		See RegSetValueEx for error returns
//
//  Notes:
//
//  History;
//		Nov-15-94 MikeMi Created
//
//-------------------------------------------------------------------

LONG 
CLicRegLicenseService::SetMode( LICENSE_MODE lm )
{
	LONG lrt;
    DWORD dwlm = (DWORD)lm;

	lrt = ::RegSetValueEx( _hkey,
			szModeValue,
			0,
			REG_DWORD,
			(PBYTE)&dwlm,
			sizeof( DWORD ) );
	return( lrt );
}

//-------------------------------------------------------------------
//
//	Method:	CLicRegLicenseService::SetUserLimit
//
//	Summary;
//		Set this serices user limit in the registry
//
//	Arguments;
//		dwLimit[in] - the limit to set
//
//	Return:
//		ERROR_SUCCESS - The limit was set
//		See RegSetValueEx for error returns
//
//  Notes:
//
//  History;
//		Nov-15-94 MikeMi Created
//
//-------------------------------------------------------------------

LONG 
CLicRegLicenseService::SetUserLimit( DWORD dwLimit )
{
	LONG lrt;

	lrt = ::RegSetValueEx( _hkey,
			szLimitValue,
			0,
			REG_DWORD,
			(PBYTE)&dwLimit,
			sizeof( DWORD ) );

	return( lrt );
}					
//-------------------------------------------------------------------
//
//	Method:	CLicRegLicenseService::GetMode
//
//	Summary;
//		Retrieve the services license mode from the registry
//
//	Arguments;
//		lm [out] - the mode from the registry
//
//	Return:
//		ERROR_SUCCESS - The mode was retrieved
//		See RegQueryValueEx for error returns
//			   
//  Notes:
//
//  History;
//		Nov-15-94 MikeMi Created
//
//-------------------------------------------------------------------

LONG 
CLicRegLicenseService::GetMode( LICENSE_MODE& lm )
{
	LONG lrt;
	DWORD dwSize = sizeof( LICENSE_MODE );
	DWORD dwRegType = REG_DWORD;
    DWORD dwlm = LICMODE_UNDEFINED;

	lrt = ::RegQueryValueEx( _hkey,
			(LPWSTR)szModeValue,
			0,
			&dwRegType,
			(PBYTE)&dwlm,
			&dwSize );

    lm = (LICENSE_MODE)dwlm;

	if ( (dwRegType != REG_DWORD) ||
		 (dwSize != sizeof( LICENSE_MODE )) )
	{
		lrt = ERROR_BADDB;
	}
    if (ERROR_SUCCESS != lrt)
    {
        lm = LICMODE_UNDEFINED;
    }
	return( lrt );
}

//-------------------------------------------------------------------
//
//	Method:	CLicRegLicenseService::GetUserLimit
//
//	Summary;
//		retrieve the user limit fro this service from the registry
//
//	Arguments;
//		dwLimit [out] - The limit retrieved
//
//	Return:
//
//  Notes:
//		ERROR_SUCCESS - The limit was retrieved
//		See RegQueryValueEx for error returns
//
//  History;
//		Nov-15-94 MikeMi Created
//
//-------------------------------------------------------------------

LONG 
CLicRegLicenseService::GetUserLimit( DWORD& dwLimit )
{
	LONG lrt;
	DWORD dwSize = sizeof( DWORD );
	DWORD dwRegType = REG_DWORD;

	lrt = ::RegQueryValueEx( _hkey,
			(LPWSTR)szLimitValue,
			0,
			&dwRegType,
			(PBYTE)&dwLimit,
			&dwSize );

	if ( (dwRegType != REG_DWORD) ||
		 (dwSize != sizeof( DWORD )) )
	{
		lrt = ERROR_BADDB;
	}
    if (ERROR_SUCCESS != lrt)
    {
        dwLimit = 0;
    }
	
	return( lrt );
}					

//-------------------------------------------------------------------
//
//	Method:	CLicRegLicenseService::GetDisplayName
//
//	Summary;
//		Retrieve the display name for this service from the registry
//
//	Arguments;
//		pszName [in-out] - the buffer to place the retrieved name
//		cchName [in-out] - the length of the pszName buffer in chars
//
//	Return:
//		ERROR_SUCCESS - The mode was retrieved
//		See RegQueryValueEx for error returns
//
//  Notes:
//
//  History;
//		Nov-18-94 MikeMi Created
//
//-------------------------------------------------------------------

LONG 
CLicRegLicenseService::GetDisplayName( LPWSTR pszName, DWORD& cchName )
{
	LONG lrt;
	DWORD dwSize = cchName * sizeof(WCHAR);
	DWORD dwRegType = REG_SZ;

	lrt = ::RegQueryValueEx( _hkey,
			(LPWSTR)szNameValue,
			0,
			&dwRegType,
			(PBYTE)pszName,
			&dwSize );

	if ((NULL != pszName) &&  // request for data size
	    (dwRegType != REG_SZ))
	{
		lrt = ERROR_BADDB;
	}

	cchName = dwSize / sizeof( WCHAR );
	return( lrt );
}

//-------------------------------------------------------------------
//
//	Method:	CLicRegLicenseService::SetDisplayName
//
//	Summary;
//		Set the display name for this service in the regstry
//
//	Arguments;
//		pszName [in] - the null terminated display name
//
//	Return:
//		ERROR_SUCCESS - The name eas set
//		See RegSetValueEx for error returns
//
//  Notes:
//
//  History;
//		Nov-18-94 MikeMi Created
//
//-------------------------------------------------------------------

LONG 
CLicRegLicenseService::SetDisplayName( LPCWSTR pszName )
{
	LONG lrt;

	lrt = ::RegSetValueEx( _hkey,
			szNameValue,
			0,
			REG_SZ,
			(PBYTE)pszName,
			(lstrlen( pszName ) + 1) * sizeof( WCHAR ) );

	return( lrt );
}

//-------------------------------------------------------------------
//
//	Method:	CLicRegLicenseService::GetFamilyDisplayName
//
//	Summary;
//		Retrieve the family display name for this service from the registry
//
//	Arguments;
//		pszName [in-out] - the buffer to place the retrieved name
//		cchName [in-out] - the length of the pszName buffer in chars
//
//	Return:
//		ERROR_SUCCESS - The mode was retrieved
//		See RegQueryValueEx for error returns
//
//  Notes:
//
//  History;
//		Nov-18-94 MikeMi Created
//
//-------------------------------------------------------------------

LONG 
CLicRegLicenseService::GetFamilyDisplayName( LPWSTR pszName, DWORD& cchName )
{
	LONG lrt;
	DWORD dwSize = cchName * sizeof(WCHAR);
	DWORD dwRegType = REG_SZ;

	lrt = ::RegQueryValueEx( _hkey,
			(LPWSTR)szFamilyNameValue,
			0,
			&dwRegType,
			(PBYTE)pszName,
			&dwSize );

	if ((NULL != pszName) &&  // request for data size
	    (dwRegType != REG_SZ))
	{
		lrt = ERROR_BADDB;
	}

	cchName = dwSize / sizeof( WCHAR );
	return( lrt );
}

//-------------------------------------------------------------------
//
//	Method:	CLicRegLicenseService::SetFamilyDisplayName
//
//	Summary;
//		Set the Family display name for this service in the regstry
//
//	Arguments;
//		pszName [in] - the null terminated display name
//
//	Return:
//		ERROR_SUCCESS - The name eas set
//		See RegSetValueEx for error returns
//
//  Notes:
//
//  History;
//		Nov-18-94 MikeMi Created
//
//-------------------------------------------------------------------

LONG 
CLicRegLicenseService::SetFamilyDisplayName( LPCWSTR pszName )
{
	LONG lrt;

	lrt = ::RegSetValueEx( _hkey,
			szFamilyNameValue,
			0,
			REG_SZ,
			(PBYTE)pszName,
			(lstrlen( pszName ) + 1) * sizeof( WCHAR ) );

	return( lrt );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\liccpa\clicreg.hpp ===
//-------------------------------------------------------------------
//
//  FILE: CLicReg.Hpp
//
//  Summary;
//      Class definition for handling the licensing api registration
//
// Notes;
//
// History
//      11/15/94    MikeMi  Created
//      Apr-26-95   MikeMi  Added Computer name and remoting
//
//-------------------------------------------------------------------

#ifndef __CLicReg_HPP__
#define __CLicReg_HPP__

const WCHAR FILEPRINT_SERVICE_REG_KEY[]             = L"FilePrint";
const WCHAR FILEPRINT_SERVICE_DISPLAY_NAME[]        = L"Windows Server";
const WCHAR FILEPRINT_SERVICE_FAMILY_DISPLAY_NAME[] = L"Windows Server";

// license modes to pass to SetMode 
//
enum LICENSE_MODE
{
   LICMODE_PERSEAT,
   LICMODE_PERSERVER,
   LICMODE_UNDEFINED
};

//-------------------------------------------------------------------
//  Root class of all registry classes
//

class CLicReg
{
public:
   CLicReg();
   ~CLicReg();

   LONG CommitNow();
   LONG Close();

protected:
   HKEY  _hkey;
};

//-------------------------------------------------------------------
// License Registry Key, for initialization and enumeration
//

class CLicRegLicense : public CLicReg
{
public:
   LONG Open( BOOL& fNew,  LPCWSTR pszComputer = NULL );
   LONG EnumService( DWORD iService, LPWSTR pszBuffer, DWORD& cBuffer );
};

//-------------------------------------------------------------------
// Services under the License Registry Key
//

class CLicRegLicenseService : public CLicReg
{
public:
   CLicRegLicenseService( LPCWSTR pszService = NULL );

   LONG Open( LPCWSTR pszComputer = NULL, BOOL fCreate = TRUE );
   
   void SetService( LPCWSTR pszService );
   BOOL CanChangeMode();
   LONG SetChangeFlag( BOOL fHasChanged );
   LONG SetMode( LICENSE_MODE lm );
   LONG SetUserLimit( DWORD dwLimit );             
   LONG GetMode( LICENSE_MODE& lm );
   LONG GetUserLimit( DWORD& dwLimit );               
   LONG GetDisplayName( LPWSTR pszName, DWORD& cchName );
   LONG SetDisplayName( LPCWSTR pszName );
   LONG GetFamilyDisplayName( LPWSTR pszName, DWORD& cchName );
   LONG SetFamilyDisplayName( LPCWSTR pszName );

private:
   PWCHAR _pszService;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\liccpa\dialogs.h ===
#define IDC_BUTTONHELP              104
#define IDC_SERVICES                106
#define IDC_PERSEAT                 108
#define IDC_PERSERVER               110
#define IDC_USERCOUNT               112
#define IDC_USERCOUNTARROW          114
#define IDC_ADD_LICENSES            115
#define IDC_REMOVE_LICENSES         116

#define IDC_STATICTITLE             118
#define IDC_STATICPERSEAT           120
#define IDC_AGREE                   122
#define IDC_STATICINFO              124

#define IDD_CPADLG                  100
#define IDD_SETUPDLG                200
#define IDD_SETUP2DLG               300
#define IDD_LICVIOLATIONDLG         400
#define IDD_PERSEATDLG              500
#define IDD_PERSERVERDLG            600
#define IDD_SERVERAPPDLG            700
#define IDC_STATICAGREE             121
#define IDD_CPADLG_CONFIGURE        800
#define IDC_CONFIGURE               801
#define IDD_CPADLG_LCACONF          900
#define IDC_PDC                     901
#define IDC_ES                      902
#define IDC_ENT_SERVER              903
#define IDC_REPL_TIME               905
#define IDC_REPL_INT                906
#define IDC_HOURS                   907
#define IDC_HOURARROW               908
#define IDC_HOUR                    910
#define IDC_TIMESEP1                911
#define IDC_MINUTE                  912
#define IDC_TIMESEP2                913
#define IDC_SECOND                  914
#define IDC_TIMEARROW               915
#define IDC_AMPM                    917
#define IDC_TIMEEDIT_BORDER         918
#define IDC_SYSTEM_ACCOUNT          919
#define IDC_THIS_ACCOUNT            920
#define IDC_ACCOUNT_NAME            921
#define IDC_PASSWORD                922
#define IDC_CONFIRM_PASSWORD        923

#define IDI_LICCPA                  1000
#define IDI_LICSETUPICON            1001


#define IDD_SPECIALSETUP            1100
#define IDD_SETUP_LICENSE_MODE_PAGE 1101
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\liccpa\help.hpp ===
//-------------------------------------------------------------------
//
// FILE: Help.hpp
//
// Summary;
// 		This file contians global defines for helpfile entries
//
// History;
//		Nov-30-94	MikeMi	Created
//
//-------------------------------------------------------------------

#ifndef __HELP_HPP__
#define __HELP_HPP__

// Applet help file and help context
//
const DWORD LICCPA_HELPCONTEXTMAIN        = 100; 
const DWORD LICCPA_HELPCONTEXTMAINSETUP   = 101;
const DWORD LICCPA_HELPCONTEXTVIOLATION   = 200;
const DWORD LICCPA_HELPCONTEXTPERSEAT     = 300;
const DWORD LICCPA_HELPCONTEXTPERSERVER   = 400;
const DWORD LICCPA_HELPCONTEXTSERVERAPP   = 500;
const DWORD LICCPA_HELPCONTEXTLICENSING   = 600;
const DWORD LICCPA_HELPCONTEXTREPLICATION = 700;
const DWORD LICCPA_HELPCONTEXTSETUPMODE   = 161;

const WCHAR LICCPA_HELPFILE[] = L"LicCpa.Hlp";

const WCHAR LICCPA_HTMLHELPFILE[] = L"liceconcepts.chm";
const WCHAR LICCPA_CHOOSEMODE_HELPFILE[] = L"LICE_choose_mode_Help.htm";
const WCHAR LICCPA_REPLICATION_HELPFILE[] = L"LICE_Replication_Configuration.htm";

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\liccpa\config.hpp ===
//-------------------------------------------------------------------
//
// FILE: config.hpp
//
// Summary;
//    This file contians the definitions of Primary Dialogs functions
//
// Entry Points;
//
// History;
//    Mar-01-95   ChandanS    Created
//    Jan-30-96   JeffParh    Lowered minimum replication interval
//                            from 6 hours to 1 hour
//    Apr-17-96   JeffParh    Moved variable definitions to config.cpp.
//
//-------------------------------------------------------------------

#ifndef __CONFIG_HPP__
#define __CONFIG_HPP__

const int cchEDITLIMIT = 2;  // the number of chars to repesent 
const DWORD INTERVAL_MIN = 1;
const DWORD INTERVAL_MAX = 72;
const DWORD INTERVAL_PAGE = 2;
const DWORD HOUR_MIN_24 = 0;
const DWORD HOUR_MAX_24 = 23;
const DWORD HOUR_PAGE_24 = 2;
const DWORD HOUR_MIN_12 = 1;
const DWORD HOUR_MAX_12 = 12;
const DWORD HOUR_PAGE_12 = 1;
const DWORD MINUTE_MIN = 0;
const DWORD MINUTE_MAX = 59;
const DWORD MINUTE_PAGE = 4;
const DWORD SECOND_MIN = 0;
const DWORD SECOND_MAX = 59;
const DWORD SECOND_PAGE = 4;
const DWORD ATINIT = 1;
const DWORD FORSERVER = 2;
const DWORD FORTIME = 3;

const UINT MB_VALUELIMIT = MB_OK;  // beep when value limit is reached

// Registry Keys
const WCHAR LICENSE_SERVICE_REG_KEY[] = L"SYSTEM\\CurrentControlSet\\Services\\LicenseService";
const WCHAR szLicenseKey[] = L"SYSTEM\\CurrentControlSet\\Services\\LicenseService\\Parameters";
const WCHAR szUseEnterprise[] = L"UseEnterprise";
const WCHAR szEnterpriseServer[] = L"EnterpriseServer";
const WCHAR szReplicationType[] = L"ReplicationType";
const WCHAR szReplicationTime[] = L"ReplicationTime";

// set values under License Key
//
const DWORD dwUseEnterprise = 0; 
const DWORD dwReplicationType = 0;
const DWORD dwReplicationTime = 24;
const DWORD dwReplicationTimeInSec = 24 * 60 * 60;
const DWORD dwInterval = 0;

// Used for in memory storage of license mode state
//
typedef struct _ServiceParams
{
    DWORD           dwUseEnterprise;
    LPWSTR          pszEnterpriseServer;
    DWORD           dwReplicationType;
    DWORD           dwReplicationTime;
    DWORD           dwHour;
    DWORD           dwMinute;
    DWORD           dwSecond;
    BOOL            fPM;
} SERVICEPARAMS, *PSERVICEPARAMS;

/* Suffix length + NULL terminator */
#define TIMESUF_LEN   9

typedef struct              /* International section description */
{
    int    iTime;           /* Time mode (0: 12 hour clock, 1: 24 ) */
    int    iTLZero;         /* Leading zeros for hour (0: no, 1: yes) */
    TCHAR  sz1159[TIMESUF_LEN];  /* Trailing string from 0:00 to 11:59 */
    TCHAR  sz2359[TIMESUF_LEN];  /* Trailing string from 12:00 to 23:59 */
    TCHAR  szTime[4];        /* Time separator string */
} INTLSTRUCT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\liccpa\config.cpp ===
//-------------------------------------------------------------------
//
// FILE: Config.cpp
//
// Summary;
//         This file contains the dialog proc for IDD_CPADLG_LCACONF
//
// History;
//      Feb-06-95    ChandanS Created
//      Mar-14-95   MikeMi  Added F1 Message Filter and PWM_HELP message
//      Mar-30-95   MikeMi  Added Replication Help Context
//      Dec-15-95  JeffParh Disallowed local server as own enterprise server.
//      Feb-28-96  JeffParh Moved from private cpArrow window class to
//                          Up-Down common ctrl, in the process fixing the
//                          multi-colored background problems
//      Apr-17-96  JeffParh Imported variable definitions that were in the
//                          config.hpp header file.
//
//-------------------------------------------------------------------

#include <windows.h>
#include <commctrl.h>
#include "resource.h"
#include <stdlib.h>
#include <tchar.h>
#include <wchar.h>
#include <htmlhelp.h>
#include "liccpa.hpp"
#include "config.hpp"

#include <strsafe.h>

extern "C"
{
#include <lmcons.h>
#include <icanon.h>
    INT_PTR CALLBACK dlgprocLICCPACONFIG( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
}

static BOOL OnEnSetFocus( HWND hwndDlg, short nID );
static BOOL OnDeltaPosSpinTime( HWND hwndDlg, NM_UPDOWN * pnmud );
static HBRUSH OnCtlColorStatic( HWND hwndDlg, HDC hDC, HWND hwndStatic );

DWORD HOUR_MIN = HOUR_MIN_24;
DWORD HOUR_MAX = HOUR_MAX_24;
DWORD HOUR_PAGE = HOUR_PAGE_24;

SERVICEPARAMS ServParams;
static PSERVICEPARAMS pServParams = &ServParams;

// JBP 96/04/17 : This #ifdef should not be necessary; the default is only used
// in the event that GetLocalInfo() fails.
//
// #ifdef JAPAN
// INTLSTRUCT IntlDefault = {    1,
//                               0,
//                               TEXT(""),
//                               TEXT(""),
//                               TEXT(":")
//                          };
// #else
INTLSTRUCT IntlDefault = {    0,
                              0,
                              TEXT("AM"),
                              TEXT("PM"),
                              TEXT(":")
                         };
// #endif

INTLSTRUCT IntlCurrent;


//-------------------------------------------------------------------
//  Function:  GetLocaleValue
//
//  Summary:
//
//  In:
//        lcid       :
//        lcType     :
//        pszStr     :
//        size       :
//        pszDefault :
//  Out: 
//  Returns: 
//
//  Caveats:
//
//  History:
//        Feb-07-95    ChandanS Created
//-------------------------------------------------------------------
int GetLocaleValue(
    LCID lcid,
    LCTYPE lcType,
    WCHAR *pszStr,
    int chSize,
    LPWSTR pszDefault )
{
    /*
     *  Initialize the output buffer.
     */
    if (NULL == pszStr)
        return (-1);

    *pszStr = (WCHAR) 0;

    /*
     *  Get the locale information.
     */
    if (!GetLocaleInfo ( lcid,
                         lcType,
                         pszStr,
                         chSize ))
    {
        /*
         *  Couldn't get info from GetLocaleInfo.
         */
        if (pszDefault)
        {
            /*
             *  Return the default info.
             */
            HRESULT hr = StringCchCopy(pszStr, chSize, pszDefault);
            if (FAILED(hr))
                return (-1);
        }
        else
        {
            /*
             *  Return error.
             */
            return (-1);
        }
    }

    /*
     *  Convert the string to an integer and return the result.
     *  This will only be used by the caller of this routine when
     *  appropriate.
     */
    return ( _wtoi(pszStr) );
}


//-------------------------------------------------------------------
//  Function:  TimeInit
//
//  Summary:
//
//  In:
//  Out: 
//  Returns: 
//
//  Caveats:
//
//  History:
//        Feb-07-95    ChandanS Created
//-------------------------------------------------------------------
VOID TimeInit()
{
    WCHAR szTemp[128];

    GetLocaleValue (0,
                    LOCALE_STIME,
                    IntlCurrent.szTime,
                    sizeof(IntlCurrent.szTime)/sizeof(IntlCurrent.szTime[0]),

                    IntlDefault.szTime);

    GetLocaleValue (0,
                    LOCALE_ITLZERO,
                    szTemp,
                    sizeof(szTemp)/sizeof(szTemp[0]),
                    TEXT("0"));
    IntlCurrent.iTLZero = _wtoi(szTemp);

    GetLocaleValue (0,
                    LOCALE_ITIME,
                    szTemp,
                    sizeof(szTemp)/sizeof(szTemp[0]),
                    TEXT("0"));
    IntlCurrent.iTime = _wtoi(szTemp);
    if (!IntlCurrent.iTime)
    {
        GetLocaleValue (0,
                        LOCALE_S1159,
                        IntlCurrent.sz1159,
                        sizeof(IntlCurrent.sz1159)/sizeof(IntlCurrent.sz1159[0]),
                        IntlDefault.sz1159);
        GetLocaleValue (0,
                        LOCALE_S2359,
                        IntlCurrent.sz2359,
                        sizeof(IntlCurrent.sz2359)/sizeof(IntlCurrent.sz2359[0]),
                        IntlDefault.sz2359);
        HOUR_MIN = HOUR_MIN_12;
        HOUR_MAX = HOUR_MAX_12;
        HOUR_PAGE = HOUR_PAGE_12;
    }
}

//-------------------------------------------------------------------
//  Function:  ReadRegistry
//
//  Summary:
//        Opens the registry & reads in the key values
//
//  In:
//  Out: 
//  Returns: 
//
//  Caveats:
//
//  History:
//        Feb-07-95    ChandanS Created
//-------------------------------------------------------------------
LONG ReadRegistry()
{
    DWORD dwDisposition;
    LONG  lrt;
    BOOL fNew;
    HKEY hKey;

    fNew = FALSE;
    lrt = ::RegCreateKeyEx( HKEY_LOCAL_MACHINE, 
            szLicenseKey,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &hKey,
            &dwDisposition );

    if ((ERROR_SUCCESS == lrt) &&
            (REG_CREATED_NEW_KEY == dwDisposition) )
    {
        fNew =     TRUE;
        // Set normal values
        //
        lrt = ::RegSetValueEx( hKey,
                szUseEnterprise,
                0,
                REG_DWORD,
                (PBYTE)&dwUseEnterprise,
                sizeof( DWORD ) );
        if (ERROR_SUCCESS == lrt)
        {

            lrt = ::RegSetValueEx( hKey,
                    szReplicationType,
                    0,
                    REG_DWORD,
                    (PBYTE)&dwReplicationType,
                    sizeof( DWORD ) );
            if (ERROR_SUCCESS == lrt)
            {

                lrt = ::RegSetValueEx( hKey,
                        szReplicationTime,
                        0,
                        REG_DWORD,
                        (PBYTE)&dwReplicationTimeInSec, // In seconds
                        sizeof( DWORD ) );

                if (ERROR_SUCCESS == lrt)
                {
                    WCHAR szNull[] = L"";
                    lrt = ::RegSetValueEx( hKey,
                            szEnterpriseServer,
                            0,
                            REG_SZ,
                            (PBYTE)szNull,
                            sizeof(WCHAR));
                }
            }
        }
    }

    if (ERROR_SUCCESS == lrt)
    {  //  read values into pServParams

        DWORD dwSize = sizeof( DWORD );
        DWORD dwRegType = REG_DWORD;

        lrt = ::RegQueryValueEx( hKey,
                (LPWSTR)szUseEnterprise,
                0,
                &dwRegType,
                (PBYTE)&(pServParams->dwUseEnterprise),
                &dwSize );
        if (lrt == REG_OPENED_EXISTING_KEY)
        {
            lrt = ::RegSetValueEx( hKey,
                    szUseEnterprise,
                    0,
                    REG_DWORD,
                    (PBYTE)&dwUseEnterprise,
                    sizeof( DWORD ) );
            pServParams->dwUseEnterprise = dwUseEnterprise;
        }
        else if ((dwRegType != REG_DWORD) || 
                (dwSize != sizeof( DWORD )) )
        {
            lrt = ERROR_BADDB;
        }
        if (!lrt )
        {
            dwSize = sizeof( DWORD );
            dwRegType = REG_DWORD;

            lrt = ::RegQueryValueEx( hKey,
                    (LPWSTR)szReplicationType,
                    0,
                    &dwRegType,
                    (PBYTE)&(pServParams->dwReplicationType),
                    &dwSize );
            if (lrt == REG_OPENED_EXISTING_KEY)
            {
                lrt = ::RegSetValueEx( hKey,
                        szReplicationType,
                        0,
                        REG_DWORD,
                        (PBYTE)&dwReplicationType,
                        sizeof(DWORD));
                pServParams->dwReplicationType = dwReplicationType;
            }
            else if ( lrt || (dwRegType != REG_DWORD) ||
                    (dwSize != sizeof( DWORD )) )
            {
                lrt = ERROR_BADDB;
            }
            if (!lrt)
            {
                dwSize = sizeof( DWORD );
                dwRegType = REG_DWORD;

                lrt = ::RegQueryValueEx( hKey,
                        (LPWSTR)szReplicationTime,
                        0,
                        &dwRegType,
                        (PBYTE)&(pServParams->dwReplicationTime),
                        &dwSize );
                if (lrt == REG_OPENED_EXISTING_KEY)
                {
                    lrt = ::RegSetValueEx( hKey,
                            szReplicationTime,
                            0,
                            REG_DWORD,
                            (PBYTE)&dwReplicationTimeInSec,
                            sizeof(DWORD));
                    pServParams->dwReplicationTime = dwReplicationTimeInSec;
                }
                else if ( (dwRegType != REG_DWORD) ||
                        (dwSize != sizeof( DWORD )) )
                {
                    lrt = ERROR_BADDB;
                }
                if (!lrt)
                {
                    dwRegType = REG_SZ;

                    lrt = RegQueryValueEx( hKey,
                            (LPWSTR)szEnterpriseServer,
                            0,
                            &dwRegType,
                            (PBYTE)NULL, //request for size
                            &dwSize );
                    if (lrt == REG_OPENED_EXISTING_KEY)
                    {
                        WCHAR szNull[] = L"";
                        lrt = ::RegSetValueEx( hKey,
                                szEnterpriseServer,
                                0,
                                REG_SZ,
                                (PBYTE)szNull,
                                sizeof(WCHAR));
                        HRESULT hr;
                        size_t cch = wcslen(szNull) + 1;
                        pServParams->pszEnterpriseServer = (LPWSTR)GlobalAlloc(GPTR, cch * sizeof(WCHAR));
                        hr = StringCchCopy(pServParams->pszEnterpriseServer, cch, szNull);
                        if (S_OK != hr)
                            lrt = ERROR_BADDB;
                    }
                    else if (dwRegType != REG_SZ)
                    {
                        lrt = ERROR_BADDB;
                    }
                    else
                    {

                        pServParams->pszEnterpriseServer = (LPWSTR) GlobalAlloc(GPTR, dwSize);
                        if (pServParams->pszEnterpriseServer)
                        {
                            lrt = ::RegQueryValueEx( hKey,
                                    (LPWSTR)szEnterpriseServer,
                                    0,
                                    &dwRegType,
                                    (PBYTE)(pServParams->pszEnterpriseServer),
                                    &dwSize );

                            if ( (dwRegType != REG_SZ) ||
                                    (dwSize != (wcslen(pServParams->pszEnterpriseServer ) + 1) * sizeof(WCHAR)))
                            {
                                lrt = ERROR_BADDB;
                            }
                        }
                        else
                        {
                            lrt = ERROR_BADDB;
                        }
                    }
                }
            }
        }
    }

    if (hKey && lrt == ERROR_SUCCESS)
    {
        // Init the globals
        if (pServParams->dwReplicationType)
        {
            DWORD dwTemp = pServParams->dwReplicationTime;
            pServParams->dwHour = dwTemp / (60 * 60);
            pServParams->dwMinute = (dwTemp - (pServParams->dwHour * 60 * 60)) / 60;
                    pServParams->dwSecond = dwTemp - (pServParams->dwHour * 60 * 60) - 
                    (pServParams->dwMinute * 60);
            if (!IntlCurrent.iTime)
            { // it's in 12 hour format
                if (pServParams->dwHour > 12)
                {
                    pServParams->fPM = TRUE;
                    pServParams->dwHour -= 12;
                }
                else if (pServParams->dwHour == 12)
                {
                    pServParams->fPM = TRUE;
                }
                else
                {
                    if (pServParams->dwHour == 0)
                        pServParams->dwHour = HOUR_MAX;
                    pServParams->fPM = FALSE;
                }
            }
        }
        else
        {
            pServParams->dwReplicationTime = pServParams->dwReplicationTime / (60 * 60);
            if (!IntlCurrent.iTime)
            // it's in 12 hour format
                pServParams->dwHour  = HOUR_MAX;
            else
                pServParams->dwHour  = HOUR_MIN;
            pServParams->dwMinute = MINUTE_MIN;
            pServParams->dwSecond = SECOND_MIN;
            pServParams->fPM = FALSE;

        }
        return (RegCloseKey(hKey));
    }
    else if (hKey)
        RegCloseKey(hKey);

    return( lrt );
}


//-------------------------------------------------------------------
//  Function:  ConfigAccessOk
//
//  Summary:
//        Checks access rights form reg call and raise dialog as needed
//
//  In:
//        hDlg     - Handle to working dialog to raise error dlgs with
//        lrc      - the return status from a reg call
//  Out: 
//  Returns: 
//
//  Caveats:
//
//  History:
//        Feb-07-95    ChandanS Created
//-------------------------------------------------------------------
inline BOOL ConfigAccessOk( HWND hDlg, LONG lrc )
{
    BOOL  frt = TRUE;
    
    if (ERROR_SUCCESS != lrc)
    {
        WCHAR szText[TEMPSTR_SIZE];
        WCHAR szTitle[TEMPSTR_SIZE];
        UINT  wId;
        
        if (ERROR_ACCESS_DENIED == lrc)
        {
            wId = IDS_NOACCESS;            
        }
        else
        {
            wId = IDS_BADREG;
        }        
        LoadString(g_hinst, IDS_CPCAPTION, szTitle, TEMPSTR_SIZE);
        LoadString(g_hinst, wId, szText, TEMPSTR_SIZE);
        MessageBox (hDlg, szText, szTitle, MB_OK|MB_ICONSTOP);
        frt = FALSE;
    }
    return( frt );
}


//-------------------------------------------------------------------
//  Function: ConfigInitUserEdit
//
//  Summary:
//        Initializes and defines user count edit control behaviour
//
//  In:
//        hwndDlg    - Parent dialog of user count edit dialog
//  Out: 
//  Returns: 
//
//  Caveats:
//
//  History:
//        Feb-07-95    ChandanS Created
//-------------------------------------------------------------------
void ConfigInitUserEdit( HWND hwndDlg )
{
    HWND hwndCount = GetDlgItem( hwndDlg, IDC_HOURS);
    SendMessage( hwndCount, EM_LIMITTEXT, cchEDITLIMIT, 0 );

    hwndCount = GetDlgItem( hwndDlg, IDC_HOUR);
    SendMessage( hwndCount, EM_LIMITTEXT, cchEDITLIMIT, 0 );

    hwndCount = GetDlgItem( hwndDlg, IDC_MINUTE);
    SendMessage( hwndCount, EM_LIMITTEXT, cchEDITLIMIT, 0 );

    hwndCount = GetDlgItem( hwndDlg, IDC_SECOND);
    SendMessage( hwndCount, EM_LIMITTEXT, cchEDITLIMIT, 0 );

    hwndCount = GetDlgItem( hwndDlg, IDC_AMPM);
    SendMessage( hwndCount, EM_LIMITTEXT, max(wcslen(IntlCurrent.sz1159), 
                                              wcslen(IntlCurrent.sz2359)), 0 );

    SetDlgItemText (hwndDlg, IDC_TIMESEP1, IntlCurrent.szTime);
    SetDlgItemText (hwndDlg, IDC_TIMESEP2, IntlCurrent.szTime);
}


//-------------------------------------------------------------------
//  Function: ConfigInitDialogForService
//
//  Summary:
//        Initialize dialog controls to the service state
//
//  In:
//        hwndDlg - Parent dialog to init controls in
//  Out: 
//  Returns: 
//
//  Caveats:
//
//  History:
//        Feb-07-95    ChandanS Created
//        Feb-28-96    JeffParh Added range set for interval spin ctrl
//-------------------------------------------------------------------
void ConfigInitDialogForService( HWND hwndDlg, DWORD dwGroup )
{
    HRESULT hr;
    HWND hwndHour           = GetDlgItem( hwndDlg, IDC_HOUR);
    HWND hwndMinute         = GetDlgItem( hwndDlg, IDC_MINUTE);
    HWND hwndSecond         = GetDlgItem( hwndDlg, IDC_SECOND);
    HWND hwndAMPM           = GetDlgItem( hwndDlg, IDC_AMPM);
    HWND hwndInterval       = GetDlgItem( hwndDlg, IDC_HOURS);
    HWND hwndIntervalSpin   = GetDlgItem( hwndDlg, IDC_HOURARROW );
    HWND hwndTimeSpin       = GetDlgItem( hwndDlg, IDC_TIMEARROW );

    BOOL fReplAtTime = (pServParams->dwReplicationType);

    if (dwGroup == ATINIT || dwGroup == FORTIME)
    {
        if (fReplAtTime)
        {
            WCHAR szTemp[3];
            CheckDlgButton( hwndDlg, IDC_REPL_TIME, fReplAtTime);
            CheckDlgButton( hwndDlg, IDC_REPL_INT, !fReplAtTime);
            if (IntlCurrent.iTLZero)
            {
                hr = StringCbPrintf(szTemp, sizeof(szTemp), TEXT("%02u"), pServParams->dwHour);
                if (S_OK != hr)
                    return;

                szTemp[2] = UNICODE_NULL;
                SetDlgItemText( hwndDlg, IDC_HOUR, szTemp);
            }
            else
            {
                SetDlgItemInt( hwndDlg, IDC_HOUR, pServParams->dwHour, FALSE );
            }

            hr = StringCbPrintf(szTemp, sizeof(szTemp), TEXT("%02u"), pServParams->dwMinute);
            if (S_OK != hr)
                return;

            szTemp[2] = UNICODE_NULL;
            SetDlgItemText( hwndDlg, IDC_MINUTE, szTemp);

            hr = StringCbPrintf(szTemp, sizeof(szTemp), TEXT("%02u"), pServParams->dwSecond);
            if (S_OK != hr)
                return;

            szTemp[2] = UNICODE_NULL;
            SetDlgItemText( hwndDlg, IDC_SECOND, szTemp);

            if (pServParams->fPM)
                SetDlgItemText( hwndDlg, IDC_AMPM, IntlCurrent.sz2359);
            else
                SetDlgItemText( hwndDlg, IDC_AMPM, IntlCurrent.sz1159);

            SetDlgItemText( hwndDlg, IDC_HOURS, L"");
            SetFocus(GetDlgItem(hwndDlg, IDC_REPL_TIME));
        }
        else
        {
            CheckDlgButton( hwndDlg, IDC_REPL_INT, !fReplAtTime);
            CheckDlgButton( hwndDlg, IDC_REPL_TIME, fReplAtTime);
            SetDlgItemInt( hwndDlg, IDC_HOURS, pServParams->dwReplicationTime, FALSE);
            SetDlgItemText( hwndDlg, IDC_HOUR, L"");
            SetDlgItemText( hwndDlg, IDC_MINUTE, L"");
            SetDlgItemText( hwndDlg, IDC_SECOND, L"");
            SetDlgItemText( hwndDlg, IDC_AMPM, L"");
            SetFocus(GetDlgItem(hwndDlg, IDC_REPL_INT));
        }

        EnableWindow( hwndTimeSpin, fReplAtTime);
        EnableWindow( hwndHour, fReplAtTime);
        EnableWindow( hwndMinute, fReplAtTime);
        EnableWindow( hwndSecond, fReplAtTime);

        if ( IntlCurrent.iTime )
        {
           ShowWindow( hwndAMPM, SW_HIDE );
        }
        else
        {
           EnableWindow( hwndAMPM, fReplAtTime );
        }

        EnableWindow( hwndInterval, !fReplAtTime);
        EnableWindow( hwndIntervalSpin, !fReplAtTime);
        SendMessage( hwndIntervalSpin, UDM_SETRANGE, 0, (LPARAM) MAKELONG( (short) INTERVAL_MAX, (short) INTERVAL_MIN ) );
    }


}


//-------------------------------------------------------------------
//  Function: ConfigFreeServiceEntry
//
//  Summary:
//        Free all allocated memory when a service structure is created
//
//  In:
//        pServParams - The Service structure to free
//  Out: 
//  Returns: 
//
//  Caveats:
//
//  History:
//        Feb-07-95    ChandanS Created
//-------------------------------------------------------------------
void ConfigFreeServiceEntry( )
{
    if (pServParams->pszEnterpriseServer)
        GlobalFree( pServParams->pszEnterpriseServer );
}

//-------------------------------------------------------------------
//  Function: ConfigSaveServiceToReg
//
//  Summary:
//        Save the given Service structure to the registry
//
//  In:
//        pServParams - Service structure to save
//  Out: 
//  Returns: 
//
//  Caveats:
//
//  History:
//        Feb-07-95    ChandanS Created
//-------------------------------------------------------------------
void ConfigSaveServiceToReg( )
{
    DWORD dwDisposition;
    LONG  lrt;
    HKEY hKey;

    if (!pServParams->dwReplicationType)
        pServParams->dwReplicationTime = pServParams->dwReplicationTime * 60 *60;
    lrt = RegCreateKeyEx( HKEY_LOCAL_MACHINE, 
                szLicenseKey,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS,
                NULL,
                &hKey,
                &dwDisposition );

    if (ERROR_SUCCESS == lrt)
    {
        lrt = RegSetValueEx( hKey,
                szUseEnterprise,
                0,
                REG_DWORD,
                (PBYTE)&(pServParams->dwUseEnterprise),
                sizeof( DWORD ) );
        if (ERROR_SUCCESS == lrt)
        {
            lrt = RegSetValueEx( hKey,
                    szEnterpriseServer,
                    0,
                    REG_SZ,
                    (PBYTE)pServParams->pszEnterpriseServer,
                    (DWORD)(wcslen (pServParams->pszEnterpriseServer) + 1) * sizeof(WCHAR));
            if (ERROR_SUCCESS == lrt)
            {
                lrt = RegSetValueEx( hKey,
                    szReplicationTime,
                    0,
                    REG_DWORD,
                    (PBYTE)&(pServParams->dwReplicationTime),
                    sizeof( DWORD ) );
                if (ERROR_SUCCESS == lrt)
                {
                    lrt = ::RegSetValueEx( hKey,
                        szReplicationType,
                        0,
                        REG_DWORD,
                        (PBYTE)&(pServParams->dwReplicationType),
                        sizeof( DWORD ) );
                }
            }
        }
    }
    if (hKey && lrt == ERROR_SUCCESS)
        lrt = RegCloseKey(hKey);
    else if (hKey)
        lrt = RegCloseKey(hKey);
}


//-------------------------------------------------------------------
//  Function: ConfigEditInvalidDlg
//
//  Summary:
//        Display Dialog when user count edit control value is invalid
//
//  In:
//        hwndDlg - hwnd of dialog
//  Out: 
//  Returns: 
//
//  Caveats:
//
//  History:
//        Feb-07-95    ChandanS Created
//-------------------------------------------------------------------
void ConfigEditInvalidDlg( HWND hwndDlg, short nID, BOOL fBeep)
{
    HWND hwnd = GetDlgItem( hwndDlg, nID);

    if (fBeep) //If we've already put up a MessageBox, we shouldn't beep
        MessageBeep( MB_VALUELIMIT );

    SetFocus(hwnd);
    SendMessage(hwnd, EM_SETSEL, 0, -1 );
}


//-------------------------------------------------------------------
//  Function: ConfigEditValidate
//
//  Summary:
//        Handle when the value within the user count edit control changes
//
//  In:
//        hwndDlg - hwnd of dialog
//        pserv   - currently selected service
//  Out: 
//  Returns: FALSE if Edit Value is not valid, TRUE if it is
//
//  Caveats:
//
//  History:
//        Feb-07-95    ChandanS Created
//-------------------------------------------------------------------
#pragma warning (push)
#pragma warning (disable : 4127) //avoid warning on while false

BOOL ConfigEditValidate( HWND hwndDlg, short *pnID, BOOL *pfBeep)
{
    UINT nValue;
    BOOL fValid = FALSE;
    WCHAR szTemp[MAX_PATH + 1];
    DWORD NumberOfHours, SecondsinHours;

    *pfBeep = TRUE;

    // only do this if license info is replicated to an ES

    do {

        if (IsDlgButtonChecked(hwndDlg, IDC_REPL_INT))
        {
            nValue = GetDlgItemInt( hwndDlg, IDC_HOURS, &fValid, FALSE);
            *pnID = IDC_HOURS;
            if (fValid)
            {
                if (nValue < INTERVAL_MIN)
                {
                    fValid = FALSE;
                    pServParams->dwReplicationTime = INTERVAL_MIN;
                    SetDlgItemInt(hwndDlg, IDC_HOURS, INTERVAL_MIN, FALSE);
                    break;
                }
                else if (nValue > INTERVAL_MAX)
                {
                    fValid = FALSE;
                    pServParams->dwReplicationTime = INTERVAL_MAX;
                    SetDlgItemInt(hwndDlg, IDC_HOURS, INTERVAL_MAX, FALSE);
                    break;
                }
                else
                    pServParams->dwReplicationTime = nValue;
            }
            else
            {
                fValid = FALSE;
                break;
            }
            pServParams->dwReplicationType = FALSE;
        }
        else
        {
            nValue = GetDlgItemInt( hwndDlg, IDC_HOUR, &fValid, FALSE);
            if (fValid)
                 pServParams->dwHour = nValue;
            else
            {
                *pnID = IDC_HOUR;
                break;
            }

            nValue = GetDlgItemInt( hwndDlg, IDC_MINUTE, &fValid, FALSE);
            if (fValid)
                 pServParams->dwMinute = nValue;
            else
            {
                *pnID = IDC_MINUTE;
                break;
            }

            nValue = GetDlgItemInt( hwndDlg, IDC_SECOND, &fValid, FALSE);
            if (fValid)
                 pServParams->dwSecond = nValue;
            else
            {
                *pnID = IDC_SECOND;
                break;
            }

            if (!IntlCurrent.iTime)
            {
                *pnID = IDC_AMPM;
                nValue = GetDlgItemText( hwndDlg, IDC_AMPM, szTemp, MAX_PATH);
                if (nValue == 0) 
                {
                    fValid = FALSE;
                    break;
                }
                szTemp[nValue] = UNICODE_NULL;

                if (!_wcsicmp(szTemp, IntlCurrent.sz1159))
                {
                    pServParams->fPM = FALSE;
                }
                else if (!_wcsicmp(szTemp, IntlCurrent.sz2359))
                {
                    pServParams->fPM = TRUE;
                }
                else
                {
                    fValid = FALSE;
                    break;
                }
            }
            if (!IntlCurrent.iTime)
            { // It's in 12 hour format
                if (pServParams->fPM)
                {
                    NumberOfHours = 12 + pServParams->dwHour - 
                                    ((pServParams->dwHour / 12) * 12);
                }
                else
                {
                    NumberOfHours = pServParams->dwHour - 
                                    ((pServParams->dwHour / 12) * 12);
                }
            }
            else
            { // It's in 24 hour format
                NumberOfHours = pServParams->dwHour;
            }
            SecondsinHours = NumberOfHours * 60 * 60;
            pServParams->dwReplicationTime = SecondsinHours + 
                           (pServParams->dwMinute * 60) + pServParams->dwSecond;
            pServParams->dwReplicationType = TRUE;
        }

    } while(FALSE);

    return( fValid );
}
#pragma warning (pop) //4127


//-------------------------------------------------------------------
//  Function: OnCpaConfigClose
//
//  Summary:
//        Do work needed when the Control Panel applet is closed.
//        Free all Service structures alloced and possible save.
//
//  In:
//        hwndDlg - Dialog close was requested on
//        fSave   - Save Services to Registry
//  Out: 
//  Returns: 
//
//  Caveats:
//
//  History:
//        Feb-07-95    ChandanS Created
//-------------------------------------------------------------------
void OnCpaConfigClose( HWND hwndDlg, BOOL fSave , WPARAM wParam)
{
    UNREFERENCED_PARAMETER(wParam);

    short nID;
    BOOL fBeep = TRUE;

    if (fSave)
    {
        if ( ConfigEditValidate(hwndDlg, &nID, &fBeep))
        {
            ConfigSaveServiceToReg( );
            ConfigFreeServiceEntry( );
            EndDialog( hwndDlg, fSave );
        }
        else
        {
            ConfigEditInvalidDlg(hwndDlg, nID, fBeep);
        }
    }
    else
    {
        ConfigFreeServiceEntry( );
        EndDialog( hwndDlg, fSave );
    }
}


//-------------------------------------------------------------------
//  Function: OnSetReplicationTime
//
//  Summary:
//        Handle the users request to change replication time
//
//  In:
//        hwndDlg - hwnd of dialog
//        idCtrl  - the control id that was pressed to make this request
//  Out: 
//  Returns: 
//
//  Caveats:
//
//  History:
//        Feb-07-95    ChandanS Created
//        Feb-28-96    JeffParh Added code to modify time bg color
//-------------------------------------------------------------------
void OnSetReplicationTime( HWND hwndDlg, WORD idCtrl )
{
    if (idCtrl == IDC_REPL_INT)
    {
        pServParams->dwReplicationType = dwReplicationType;
    }
    else
    {
        pServParams->dwReplicationType = !dwReplicationType;
    }

    // Edit control within this IDC_TIMEEDIT_BORDER should be subclassed and
    // use some other backgroup brush to repaint the background.
    // following code works but...

    // change the background color of the time edit control

    HWND hwndTimeEdit = GetDlgItem( hwndDlg, IDC_TIMEEDIT_BORDER );
    InvalidateRect( hwndTimeEdit, NULL, TRUE );
    UpdateWindow( hwndTimeEdit );

    HWND hwndTimeSep1 = GetDlgItem( hwndDlg, IDC_TIMESEP1 );
    InvalidateRect( hwndTimeSep1, NULL, TRUE );
    UpdateWindow( hwndTimeSep1 );

    HWND hwndTimeSep2 = GetDlgItem( hwndDlg, IDC_TIMESEP2 );
    InvalidateRect( hwndTimeSep2, NULL, TRUE );
    UpdateWindow( hwndTimeSep2 );

    InvalidateRect( 
                GetDlgItem(hwndDlg, IDC_TIMEARROW), 
                NULL, 
                FALSE 
            );

    UpdateWindow( GetDlgItem(hwndDlg, IDC_TIMEARROW) );

    ConfigInitDialogForService( hwndDlg, FORTIME);
}

//-------------------------------------------------------------------
//  Function: OnCpaConfigInitDialog
//
//  Summary:
//        Handle the initialization of the Control Panel Applet Dialog
//
//  In:
//        hwndDlg - the dialog to initialize
//  Out: 
//        iSel  - the current service selected
//        pServParams  - the current service 
//  Returns: 
//        TRUE if succesful, otherwise false
//
//  Caveats:
//
//  History:
//        Feb-07-95    ChandanS Created
//-------------------------------------------------------------------
BOOL OnCpaConfigInitDialog( HWND hwndDlg)
{
    BOOL frt;
    LONG lrt;

    TimeInit();
    // Do Registry stuff
    lrt = ReadRegistry();
    
    frt = ConfigAccessOk( hwndDlg, lrt );
    if (frt)
    {
        CenterDialogToScreen( hwndDlg );

        // Set edit text chars limit
        ConfigInitUserEdit( hwndDlg );

        ConfigInitDialogForService( hwndDlg, ATINIT);

        if (pServParams->dwReplicationType)
            SetFocus(GetDlgItem(hwndDlg, IDC_HOUR));
        else
            SetFocus(GetDlgItem(hwndDlg, IDC_HOURS));
    }
    else
    {
        EndDialog( hwndDlg, -1 );
    }
    return( frt );
}


//-------------------------------------------------------------------
//  Function:  CheckNum
//
//  Summary:
//
//  In:
//  Out: 
//  Returns: 
//
//  Caveats:
//
//  History:
//        Feb-07-95    ChandanS Created
//-------------------------------------------------------------------
BOOL CheckNum (HWND hDlg, WORD nID)
{
    short    i;
    WCHAR    szNum[4];
    BOOL    bReturn;
    INT     iVal;
    UINT    nValue;

    bReturn = TRUE;

    // JonN 5/15/00: PREFIX 112120
    ::ZeroMemory( szNum, sizeof(szNum) );
    nValue = GetDlgItemText (hDlg, nID, szNum, 3);

    for (i = 0; szNum[i]; i++)
        if (!_istdigit (szNum[i]))
            return (FALSE);

    iVal = _wtoi(szNum);

    switch (nID)
    {
       case IDC_HOURS:
          if (!nValue)
          {
              pServParams->dwReplicationTime = dwReplicationTime;
              break;
          }
          if (iVal < 9)
          {
              pServParams->dwReplicationTime = (DWORD)iVal;
              break;
          }

          if ((iVal < INTERVAL_MIN) || (iVal > INTERVAL_MAX))
              bReturn = FALSE;
          else
              pServParams->dwReplicationTime = (DWORD)iVal;
          break;

       case IDC_HOUR:
          if (!nValue)
          {
              if (IntlCurrent.iTime)
              { // 24 hour format
                  pServParams->dwHour = 0;
                  pServParams->fPM = FALSE;
              }
              else
              { // 12 hour format
                  pServParams->dwHour = HOUR_MAX;
                  pServParams->fPM = FALSE;
              }
              break;
          }
          if ((iVal < (int)HOUR_MIN) || (iVal > (int)HOUR_MAX))
             bReturn = FALSE;
          break;

       case IDC_MINUTE:
          if (!nValue)
          {
              pServParams->dwMinute = MINUTE_MIN;
              break;
          }
          if ((iVal < MINUTE_MIN) || (iVal > MINUTE_MAX))
             bReturn = FALSE;
          break;

       case IDC_SECOND:
          if (!nValue)
          {
              pServParams->dwSecond = SECOND_MIN;
              break;
          }
          if ((iVal < SECOND_MIN) || (iVal > SECOND_MAX))
             bReturn = FALSE;
          break;
    }
    return (bReturn);
}



//-------------------------------------------------------------------
//  Function:  CheckAMPM
//
//  Summary:
//
//  In:
//  Out: 
//  Returns: 
//
//  Caveats:
//
//  History:
//        Feb-07-95    ChandanS Created
//-------------------------------------------------------------------
BOOL CheckAMPM(HWND hDlg, WORD nID)
{
    WCHAR   szName[TIMESUF_LEN + 1];
    UINT    nValue;

    nValue = GetDlgItemText (hDlg, nID, szName, TIMESUF_LEN);
    szName[nValue] = UNICODE_NULL;

    switch (nID)
    {
       case IDC_AMPM:
           if (!nValue)
           {
               pServParams->fPM = FALSE; // default
               return TRUE;
           }
           if (_wcsnicmp(szName, IntlCurrent.sz1159, nValue) &&
               _wcsnicmp(szName, IntlCurrent.sz2359, nValue))
           {
               return FALSE;
           }
           else
           { // One of them may match fully
               if (!_wcsicmp (szName, IntlCurrent.sz1159))
               {
                   pServParams->fPM = FALSE;
               }
               else if (!_wcsicmp(szName, IntlCurrent.sz2359))
               {
                   pServParams->fPM = TRUE;
               }
           }
           break;
    }
    return TRUE;
}

//-------------------------------------------------------------------
//  Function: dlgprocLICCPACONFIG
//
//  Summary:
//        The dialog procedure for the main Control Panel Applet Dialog
//
//  In:
//        hwndDlg     - handle of Dialog window 
//        uMsg         - message                       
//         lParam1    - first message parameter
//        lParam2    - second message parameter       
//  Out: 
//  Returns: 
//        message dependant
//
//  Caveats:
//
//  History:
//        Feb-07-95  ChandanS Created
//        Mar-14-95   MikeMi  Added F1 PWM_HELP message
//        Mar-30-95   MikeMi  Added Replication Help Context
//        Feb-28-96  JeffParh Added handling of UDN_DELTAPOS and EN_SETFOCUS,
//                            removed WM_VSCROLL (switched from private
//                            cpArrow class to Up-Down common ctrl)
//
//-------------------------------------------------------------------
INT_PTR CALLBACK dlgprocLICCPACONFIG( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    LRESULT frt = FALSE;
    short nID;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            OnCpaConfigInitDialog( hwndDlg );
            return( (LRESULT)TRUE ); // use default keyboard focus
            break;

        case WM_COMMAND:
            switch (HIWORD( wParam ))
            {
                case EN_UPDATE:
                    switch (LOWORD( wParam ))
                    {
                        case IDC_AMPM:
                            if (!CheckAMPM (hwndDlg, LOWORD(wParam)))
                                SendMessage ((HWND) lParam, EM_UNDO, 0, 0L);
                            break;
                        case IDC_HOURS:
                        case IDC_HOUR:
                        case IDC_MINUTE:
                        case IDC_SECOND:
                            if (!CheckNum (hwndDlg, LOWORD(wParam)))
                                SendMessage ((HWND) lParam, EM_UNDO, 0, 0L);
                            break;
                        default:
                            break;
                    }
                    break;

                case EN_SETFOCUS:
                    frt = (LRESULT)OnEnSetFocus( hwndDlg, LOWORD( wParam ) );
                    break;

                case BN_CLICKED:
                    switch (LOWORD( wParam ))
                    {
                        case IDOK:
                            frt = (LRESULT)TRUE;     // use as save flag
                            // intentional no break

                        case IDCANCEL:
                            OnCpaConfigClose( hwndDlg, !!frt , wParam);
                            frt = (LRESULT)FALSE;
                            break;

                        case IDC_REPL_INT:
                        case IDC_REPL_TIME:
                            OnSetReplicationTime( hwndDlg, LOWORD(wParam) );
                            break;
             
                        case IDC_BUTTONHELP:
                            PostMessage( hwndDlg, PWM_HELP, 0, 0 );
                            break;

                        default:
                            break;
                    }
                break;

                default:
                    break;
            }
            break;

        case WM_NOTIFY:
            nID = (short) wParam;

            if ( IDC_TIMEARROW == nID )
            {
                frt = (LRESULT)OnDeltaPosSpinTime( hwndDlg, (NM_UPDOWN*) lParam );
            }
            else
            {
                frt = (LRESULT)FALSE;
            }
            break;

        case WM_CTLCOLORSTATIC:
            frt = (LRESULT) OnCtlColorStatic( hwndDlg, (HDC) wParam, (HWND) lParam );
            break;

        default:
            if (PWM_HELP == uMsg)
                HtmlHelp(hwndDlg, LICCPA_HTMLHELPFILE, HH_DISPLAY_TOPIC, (DWORD_PTR)LICCPA_REPLICATION_HELPFILE);
            break;
    }
    return( frt );
}


//-------------------------------------------------------------------
//  Function:  OnEnSetFocus
//
//  Summary:
//
//  In:
//  Out: 
//  Returns: 
//
//  Caveats:
//
//  History:
//        Feb-28-96    JeffParh Created
//-------------------------------------------------------------------
static BOOL OnEnSetFocus( HWND hwndDlg, short nID )
{
   BOOL  fSetNewRange = TRUE;
   HWND  hwndSpinCtrl;
   int   nMax = 0; //this init is not necessary but avoid W4
   int   nMin = 0;

   switch ( nID )
   {
   case IDC_AMPM:
      nMin = 0;
      nMax = 1;
      break;

   case IDC_HOUR:
      nMin = HOUR_MIN;
      nMax = HOUR_MAX;
      break;

   case IDC_MINUTE:
      nMin = MINUTE_MIN;
      nMax = MINUTE_MAX;
      break;

   case IDC_SECOND:
      nMin = SECOND_MIN;
      nMax = SECOND_MAX;
      break;

   default:
      fSetNewRange = FALSE;
      break;
   }

   if ( fSetNewRange )
   {
      hwndSpinCtrl = GetDlgItem( hwndDlg, IDC_TIMEARROW );
      SendMessage( hwndSpinCtrl, UDM_SETRANGE, 0, (LPARAM) MAKELONG( (short) nMax, (short) nMin ) );      
   }
   

   return FALSE;
}

//-------------------------------------------------------------------
//  Function:  OnDeltaPosSpinTime
//
//  Summary:
//
//  In:
//  Out: 
//  Returns: 
//
//  Caveats:
//
//  History:
//        Feb-28-96    JeffParh Created
//-------------------------------------------------------------------
static BOOL OnDeltaPosSpinTime( HWND hwndDlg, NM_UPDOWN * pnmud )
{
   WCHAR szTemp[ 16 ] = TEXT( "" );
   HWND  hwndEdit;
   short nID;
   int nValue;
   LRESULT lRange;
   short nRangeHigh;
   short nRangeLow;
   BOOL  frt;

   hwndEdit = GetFocus();
   nID = (short) GetWindowLong( hwndEdit, GWL_ID );

   if (    ( IDC_HOUR   == nID )
        || ( IDC_MINUTE == nID )
        || ( IDC_SECOND == nID )
        || ( IDC_AMPM   == nID ) )
   {
      if ( IDC_AMPM == nID )
      {
         // AM/PM
         GetDlgItemText( hwndDlg, nID, szTemp, sizeof( szTemp ) / sizeof( *szTemp ) );
         nValue = _wcsicmp( szTemp, IntlCurrent.sz2359 );
         SetDlgItemText( hwndDlg, nID, nValue ? IntlCurrent.sz2359 : IntlCurrent.sz1159 );
      }
      else
      {
         lRange = SendMessage( pnmud->hdr.hwndFrom, UDM_GETRANGE, 0, 0 );
         nRangeHigh = LOWORD( lRange );
         nRangeLow  = HIWORD( lRange );

         nValue = GetDlgItemInt( hwndDlg, nID, NULL, FALSE );
         nValue += pnmud->iDelta;

         if ( nValue < nRangeLow )
         {
            nValue = nRangeLow;
         }
         else if ( nValue > nRangeHigh )
         {
            nValue = nRangeHigh;
         }

         if ( ( IDC_HOUR == nID ) && !IntlCurrent.iTLZero )
         {
            // set value w/o leading 0
            SetDlgItemInt( hwndDlg, nID, nValue, FALSE );
         }
         else
         {
            // set value w/ leading 0
            HRESULT hr = StringCbPrintf(szTemp, sizeof(szTemp), TEXT("%02u"), nValue );
            if (SUCCEEDED(hr))
                SetDlgItemText( hwndDlg, nID, szTemp );
         }
      }

      SetFocus( hwndEdit );
      SendMessage( hwndEdit, EM_SETSEL, 0, -1 );

      // handled
      frt = TRUE;
   }
   else
   {
      // not handled
      frt = FALSE;
   }

   return frt;
}

//-------------------------------------------------------------------
//  Function:  OnCtlColorStatic
//
//  Summary:
//
//  In:
//  Out: 
//  Returns: 
//
//  Caveats:
//
//  History:
//        Feb-28-96    JeffParh Created
//-------------------------------------------------------------------
static HBRUSH OnCtlColorStatic( HWND hwndDlg, HDC hDC, HWND hwndStatic )
{
   LONG     nID;
   HBRUSH   hBrush;

   nID = GetWindowLong( hwndStatic, GWL_ID );

   if (    pServParams->dwReplicationType
        && (    ( IDC_TIMESEP1        == nID )
             || ( IDC_TIMESEP2        == nID )
             || ( IDC_TIMEEDIT_BORDER == nID ) ) )
   {
      hBrush = (HBRUSH) DefWindowProc( hwndDlg, WM_CTLCOLOREDIT, (WPARAM) hDC, (LPARAM) hwndStatic );
   }    
   else
   {
      hBrush = (HBRUSH) DefWindowProc( hwndDlg, WM_CTLCOLORSTATIC, (WPARAM) hDC, (LPARAM) hwndStatic );
   }

   return hBrush;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\liccpa\liccpa.hpp ===
//-------------------------------------------------------------------
//
// FILE: LicCpa.cpp
//
// Summary;
// 		This file contians applet global defines and stdfuncs externs
//
// History;
//      Nov-30-94   MikeMi  Created
//      Apr-26-95   MikeMi  Added Computer name and remoting
//      Dec-12-95  JeffParh Added secure certificate support
//
//-------------------------------------------------------------------

#ifndef __LICCPA_HPP__
#define __LICCPA_HPP__

#include "Help.hpp"


const int TEMPSTR_SIZE = 257; // avoid 256 boundary
const int LTEMPSTR_SIZE = 513; // avoid 512 boundary

// Setup Error codes, though currently only internal
//
const int ERR_NONE              = 1;   // zero has the meaning of cancel or exit
const int ERR_HELPPARAMS   		= 100;
const int ERR_HWNDPARAM    		= 101;
const int ERR_SERVICEPARAM 		= 102;
const int ERR_USERSPARAM 		= 103;

const int ERR_NUMPARAMS			= 104;
const int ERR_CLASSREGFAILED	= 105;
const int ERR_INVALIDROUTINE	= 106;
const int ERR_INVALIDMODE		= 107;
const int ERR_PERMISSIONDENIED	= 200;
const int ERR_NOREMOTESERVER	= 201;
const int ERR_REGISTRYCORRUPT	= 202;
const int ERR_DOWNLEVEL          = 210;   // target server doesn't support LLS extended RPC
                                          // (i.e., it's running 3.51)
const int ERR_CERTREQFAILED      = 211;   // the attempt to notify the license service that
                                          // the given product requires a secure certificate failed
const int ERR_CERTREQPARAM       = 212;   // the string in the "certrequired" argument position
                                          // is unrecognized

extern HINSTANCE g_hinst;
extern UINT PWM_HELP;

extern void LowMemoryDlg();
extern void BadRegDlg( HWND hwndDlg );
extern void CenterDialogToScreen( HWND hwndDlg );
extern void InitStaticWithService( HWND hwndDlg, UINT wID, LPCWSTR pszService );
extern void InitStaticWithService2( HWND hwndDlg, UINT wID, LPCWSTR pszService );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\liccpa\sbs_res.h ===
#define SBS_RESOURCE_DLL    L"sbslimit.dll"
#define SBS_License_Error   1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\liccpa\liccpa.cpp ===
//-------------------------------------------------------------------
//
// FILE: LicCpa.cpp
//
// Summary;
//      This file contians the DLL & CPL entry points, F1 Help message
//      hooking, and misc common dialog functions.
//
// Entry Points;
//      CPlSetup
//      CPlApplet
//      DllMain
//
// History;
//      Nov-30-94   MikeMi  Created
//      Mar-14-95   MikeMi  Added F1 Message Filter and PWM_HELP message
//      Apr-26-95   MikeMi  Added Computer name and remoting
//      Dec-12-95  JeffParh Added secure certificate support
//
//-------------------------------------------------------------------

#include <windows.h>
#include <cpl.h>
#include "resource.h"
#include <stdlib.h>
#include <stdio.h>
#include "PriDlgs.hpp"
#include "SecDlgs.hpp"
#include "liccpa.hpp"
#include "Special.hpp"

#include <strsafe.h>

extern "C"
{
    BOOL APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved);
    BOOL APIENTRY CPlSetup( DWORD nArgs, LPSTR apszArgs[], LPSTR *ppszResult );
    LONG CALLBACK CPlApplet( HWND hwndCPL, UINT uMsg, LPARAM lParam1, LPARAM lParam2);
    LRESULT CALLBACK msgprocHelpFilter( int nCode, WPARAM wParam, LPARAM lParam );
}

// Setup routines
//
const CHAR szSETUP_NORMAL[]         = "FULLSETUP";
const CHAR szSETUP_PERSEAT[]        = "PERSEAT";
const CHAR szSETUP_UNATTENDED[]     = "UNATTENDED";
const CHAR szSETUP_NORMALNOEXIT[]   = "FULLSETUPNOEXIT";

const CHAR szREMOTESETUP_NORMAL[]       = "REMOTEFULLSETUP";
const CHAR szREMOTESETUP_PERSEAT[]      = "REMOTEPERSEAT";
const CHAR szREMOTESETUP_UNATTENDED[]   = "REMOTEUNATTENDED";
const CHAR szREMOTESETUP_NORMALNOEXIT[] = "REMOTEFULLSETUPNOEXIT";

// Modes for unattended setup
//
const CHAR szUNATTENDED_PERSEAT[]   = "PERSEAT";
const CHAR szUNATTENDED_PERSERVER[] = "PERSERVER";

// Certificate required / not required
const CHAR szSETUP_CERTREQUIRED[]    = "CERTREQUIRED";
const CHAR szSETUP_CERTNOTREQUIRED[] = "CERTNOTREQUIRED";

// Use default help file
const CHAR szSETUP_DEFAULTHELP[]     = "DEFAULTHELP";

// Setup Error return strings
//
static CHAR szSETUP_EXIT[]           = "EXIT";
static CHAR szSETUP_ERROR[]          = "ERROR";
static CHAR szSETUP_SECURITY[]       = "SECURITY";
static CHAR szSETUP_NOREMOTE[]       = "NOREMOTE";
static CHAR szSETUP_DOWNLEVEL[]      = "DOWNLEVEL";

static CHAR szSETUP_OK[]             = "OK";


// Registered help message for F1 hooking
//
const WCHAR szF1HELPMESSAGE[] = L"LicCpaF1Help";

HINSTANCE g_hinst = NULL;  // global hinstance of this dll
HHOOK g_hhook = NULL;      // global hhook for F1 message filter
UINT PWM_HELP = 0;          // global help message when F1 is pressed

//-------------------------------------------------------------------
//
//  Function: msgprocHelpFilter
//
//  Summary;
//      This functions will filter the messages looking for F1, then send
//      the registered message to the top most parent of that window
//      informing it that F1 for help was pressed.
//
//  Arguments;
//      (see Win32 MessageProc)
//
//  History;
//      Mar-13-95   MikeMi  Created
//
//-------------------------------------------------------------------

LRESULT CALLBACK msgprocHelpFilter( int nCode, WPARAM wParam, LPARAM lParam )
{
    LRESULT lrt = 0;
    PMSG pmsg = (PMSG)lParam;

    if (nCode < 0)
    {
        lrt = CallNextHookEx( g_hhook, nCode, wParam, lParam );
    }
    else
    {
        if (MSGF_DIALOGBOX == nCode)
        {
            // handle F1 key
            if ( (WM_KEYDOWN == pmsg->message) &&
                 (VK_F1 == (INT_PTR)pmsg->wParam) )
            {
                HWND hwnd = pmsg->hwnd;

                // post message to parent that handles help
                while( GetWindowLong( hwnd, GWL_STYLE ) & WS_CHILD )
                {
                    hwnd = GetParent( hwnd );
                }
                PostMessage( hwnd, PWM_HELP, 0, 0 );

                lrt = 1;
            }
        }
    }

    return( lrt );
}

//-------------------------------------------------------------------
//
//  Function: InstallF1Hook
//
//  Summary;
//      This will ready the message filter for handling F1.
//      It install the message hook and registers a message that will
//      be posted to the dialogs.
//
//  Arguments;
//      hinst [in] - the module handle of this DLL (needed to install hook)
//      dwThreadId [in] - thread to attach filter to
//
//  Notes:
//      The control.exe does this work and sends the "ShellHelp" message.
//      A seperate F1 message filter is needed because these dialogs maybe
//      raised by other applications than control.exe.
//
//  History;
//      Mar-13-95   MikeMi  Created
//
//-------------------------------------------------------------------

BOOL InstallF1Hook( HINSTANCE hInst, DWORD dwThreadId )
{
    BOOL frt = FALSE;

    if (NULL == g_hhook)
    {
        g_hhook = SetWindowsHookEx( WH_MSGFILTER,
                (HOOKPROC)msgprocHelpFilter,
                hInst,
                dwThreadId );
        if (NULL != g_hhook)
        {
            PWM_HELP = RegisterWindowMessage( szF1HELPMESSAGE );
            if (0 != PWM_HELP)
            {
                frt = TRUE;
            }
        }
    }

    return( frt );
}

//-------------------------------------------------------------------
//
//  Function: RemoveF1Hook
//
//  Summary;
//      This will remove the message filter hook that InstallF1Hook installs.
//
//  History;
//      Mar-13-95   MikeMi  Created
//
//-------------------------------------------------------------------

BOOL RemoveF1Hook( )
{
    BOOL frt = UnhookWindowsHookEx( g_hhook );
    g_hhook = NULL;
    return( frt );
}

//-------------------------------------------------------------------
//
//  Function: DLLMain
//
//  Summary;
//      Entry point for all DLLs
//
//  Notes:
//      We only support being called from the same thread that called
//      LoadLibrary. Because we install a message hook, and passing a
//      zero for threadid does not work as documented.
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

BOOL APIENTRY DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    UNREFERENCED_PARAMETER(lpReserved);

    BOOL frt = TRUE;

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_hinst = hInstance;
        frt = InstallF1Hook( g_hinst, GetCurrentThreadId() );
        break;

    case DLL_PROCESS_DETACH:
        RemoveF1Hook();
        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;

    default:
        break;
    }
    return( frt );
}

//-------------------------------------------------------------------
//
//  Function: LowMemoryDlg
//
//  Summary;
//      Standard function for handling low memory situation
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

void LowMemoryDlg()
{
    WCHAR szText[TEMPSTR_SIZE];
    WCHAR szTitle[TEMPSTR_SIZE];

    LoadString(g_hinst, IDS_CPATITLE, szTitle, TEMPSTR_SIZE);
    LoadString(g_hinst, IDS_LOWMEM, szText, TEMPSTR_SIZE);
    MessageBox (NULL, szText, szTitle, MB_OK|MB_ICONEXCLAMATION);
}

//-------------------------------------------------------------------
//
//  Function: BadRegDlg
//
//  Summary;
//      Standard function for handling bad registry situation
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

void BadRegDlg( HWND hwndDlg )
{
    WCHAR szText[TEMPSTR_SIZE];
    WCHAR szTitle[TEMPSTR_SIZE];

    LoadString(g_hinst, IDS_CPATITLE, szTitle, TEMPSTR_SIZE);
    LoadString(g_hinst, IDS_BADREGTERM, szText, TEMPSTR_SIZE);
    MessageBox (hwndDlg, szText, szTitle, MB_OK|MB_ICONEXCLAMATION);
}

//-------------------------------------------------------------------
//
//  Function: CenterDialogToScreen
//
//  Summary;
//      Move the window so that it is centered on the screen
//
//  Arguments;
//      hwndDlg [in] - the hwnd to the dialog to center
//
//  History;
//      Dec-3-94    MikeMi  Created
//
//-------------------------------------------------------------------

void CenterDialogToScreen( HWND hwndDlg )
{
    RECT rcDlg;
    INT x, y, w, h;
    INT sw, sh;

    sw = GetSystemMetrics( SM_CXSCREEN );
    sh = GetSystemMetrics( SM_CYSCREEN );

    GetWindowRect( hwndDlg, &rcDlg );

    w = rcDlg.right - rcDlg.left;
    h = rcDlg.bottom - rcDlg.top;
    x = (sw / 2) - (w / 2);
    y = (sh / 2) - (h / 2);

    MoveWindow( hwndDlg, x, y, w, h, FALSE );
}

//-------------------------------------------------------------------
//
//  Function: InitStaticWithService
//  Summary;
//      Handle the initialization of a static text with a service name
//
//  Arguments;
//      hwndDlg [in] - the dialog that contains the static
//      wID [in] - the id of the static control
//      pszService [in] - the service display name to use
//
//  Notes;
//
//  History;
//      Dec-05-1994 MikeMi  Created
//
//-------------------------------------------------------------------

void InitStaticWithService( HWND hwndDlg, UINT wID, LPCWSTR pszService )
{
    WCHAR szText[LTEMPSTR_SIZE];
    WCHAR szTemp[LTEMPSTR_SIZE];

    GetDlgItemText( hwndDlg, wID, szTemp, LTEMPSTR_SIZE );
    HRESULT hr = StringCbPrintf( szText, sizeof(szText), szTemp, pszService );
    if (SUCCEEDED(hr))
        SetDlgItemText( hwndDlg, wID, szText );
}

//-------------------------------------------------------------------
//
//  Function: InitStaticWithService2
//  Summary;
//      Handle the initialization of a static text that contians two
//      instances of a service name with the service name
//
//  Arguments;
//      hwndDlg [in] - the dialog that contains the static
//      wID [in] - the id of the static control
//      pszService [in] - the service display name to use
//
//  Notes;
//
//  History;
//      Dec-05-1994 MikeMi  Created
//
//-------------------------------------------------------------------

void InitStaticWithService2( HWND hwndDlg, UINT wID, LPCWSTR pszService )
{
    WCHAR szText[LTEMPSTR_SIZE];
    WCHAR szTemp[LTEMPSTR_SIZE];

    GetDlgItemText( hwndDlg, wID, szTemp, LTEMPSTR_SIZE );
    HRESULT hr = StringCbPrintf( szText, sizeof(szText), szTemp, pszService, pszService );
    if (SUCCEEDED(hr))
        SetDlgItemText( hwndDlg, wID, szText );
}

//-------------------------------------------------------------------
//
//  Function: CPlApplet
//
//  Summary;
//      Entry point for Comntrol Panel Applets
//
//  Arguments;
//      hwndCPL [in]    - handle of Control Panel window
//      uMsg [in]       - message
//      lParam1 [in]    - first message parameter, usually the application number
//      lParam2 [in]    - second message parameter
//
//  Return;
//      message dependant
//
//  Notes;
//
//  History;
//      Nov-11-1994 MikeMi  Created
//
//-------------------------------------------------------------------

LONG CALLBACK CPlApplet( HWND hwndCPL, UINT uMsg, LPARAM lParam1, LPARAM lParam2)
{
    LPCPLINFO lpCPlInfo;
    LONG_PTR iApp;
    LONG lrt = 0;

    iApp = (LONG_PTR) lParam1;

    switch (uMsg)
    {
    case CPL_INIT:      /* first message, sent once  */
        //
        // Initialize global special version information is this liccpa
        // is a special version (eg: restricted SAM, NFR, etc).
        //

        InitSpecialVersionInfo();
        lrt = TRUE;
        break;

    case CPL_GETCOUNT:  /* second message, sent once */
        lrt = 1; // we support only one application within this DLL
        break;

    case CPL_INQUIRE: /* third message, sent once per app */
        lpCPlInfo = (LPCPLINFO) lParam2;
        
        lpCPlInfo->idIcon = IDI_LICCPA;
        lpCPlInfo->idName = IDS_CPATITLE;
        lpCPlInfo->idInfo = IDS_CPADESC;
        lpCPlInfo->lData  = 0;

        break;

    case CPL_SELECT:    /* application icon selected */
        lrt = 1;
        break;

    case CPL_DBLCLK:    /* application icon double-clicked */
        //
        // Check if this is a special version of liccpa.
        //

        if (gSpecVerInfo.idsSpecVerWarning)
        {
            RaiseNotAvailWarning( hwndCPL );
			break;
        }

        CpaDialog( hwndCPL );
        break;

    case CPL_STOP:      /* sent once per app. before CPL_EXIT */
        break;

    case CPL_EXIT:      /* sent once before FreeLibrary called */
        break;

    default:
        break;
    }
    return( lrt );
}

//-------------------------------------------------------------------
//
//  Function: CreateWSTR
//
//  Summary;
//      Given a STR (ASCII or MB), allocate and translate to WSTR
//
//  Arguments;
//      ppszWStr [out] - allocated & converted string
//      pszStr [in] - string to convert
//
//  Return: TRUE if allocated and converted, FALSE if failed
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

BOOL CreateWSTR( LPWSTR* ppszWStr, LPSTR pszStr )
{
    size_t cchConv;
    LPWSTR pszConv;
    BOOL frt = FALSE;
    WCHAR pszTemp[LTEMPSTR_SIZE];

    if (NULL == pszStr)
    {
        *ppszWStr = NULL;
        frt = TRUE;
    }
    else
    {
#ifdef FE_SB
        // Since there was a problem in Server setup when calling setlocale or
        // linking C-runtime lib, we used Win32 API instead of mbstowcs.
        cchConv = ::MultiByteToWideChar(CP_ACP, 0,
                                        pszStr, -1,
                                        NULL, 0);
        pszConv = (LPWSTR)::GlobalAlloc( GPTR, cchConv * sizeof( WCHAR ) );
        if (NULL != pszConv)
        {
            ::MultiByteToWideChar(CP_ACP, 0,
                                  pszStr, -1,
                                  pszConv, cchConv);
            *ppszWStr = pszConv;
            frt = TRUE;
        }
#else
        cchConv = mbstowcs( pszTemp, pszStr, LTEMPSTR_SIZE );

        cchConv++;
        pszConv = (LPWSTR)GlobalAlloc( GPTR, cchConv * sizeof( WCHAR ) );
        if (NULL != pszConv)
        {
            HRESULT hr = StringCchCopy( pszConv, cchConv, pszTemp );
            if (SUCCEEDED(hr))
            {
                *ppszWStr = pszConv;
                frt = TRUE;
            }
        }
#endif
    }
    return( frt );
}

//-------------------------------------------------------------------
//
//  Function: Setup
//
//  Summary;
//      Run normal setup or Perseat Setup
//
//  Arguments
//      nArgs [in]      - The number of arguments in the apszArgs array
//              If this value is 5, help button will call common help
//              If this value is 9, help button will call the passed help
//      apszArgs[] [in] - The argumnents passed in,
//          [0] szRoutine - The type of setup to run (FullSetup | PerSeatSetup)
//          [1] szHwnd - The parent Window handle, in HEX!
//          [2] szService - The Reg Key name of the service
//          [3] szFamilyDisplayName - The family display name of the service
//          [4] szDisplayName - The display name of the service
//          [5] szHelpFile - The complete path and name to help file
//                  leave as an empty string to remove help buttons
//          [6] szHelpContext - the DWORD to use as the main help context
//          [7] szHCPerSeat   - the DWORD to use as the PerSeat Help context
//          [8] szHCPerServer - the DWORD to use as the PerServer help context
//
//  Return:
//      0 - sucessfull
//      ERR_HELPPARAMS
//      ERR_HWNDPARAM
//      ERR_SERVICEPARAM
//      ERR_NUMPARAMS
//      ERR_CLASSREGFAILED
//      ERR_INVALIDROUTINE
//      ERR_INVALIDMODE
//
//  Notes:
//
//  History:
//      Nov-17-94   MikeMi  Created
//
//-------------------------------------------------------------------

const int SETUPARG_SETUP        = 0;
const int SETUPARG_HWND         = 1;
const int SETUPARG_SERVICE      = 2;
const int SETUPARG_FAMILYNAME   = 3;
const int SETUPARG_NAME         = 4;
const int SETUPARG_HELPFILE     = 5;
const int SETUPARG_HELPCONTEXT  = 6;
const int SETUPARG_HCPERSEAT    = 7;
const int SETUPARG_HCPERSERVER  = 8;
const int SETUPARG_CERTREQUIRED = 9;

const int SETUPARG_WOOPTIONAL   = 5;  // count of args without optional
const int SETUPARG_WOPTIONAL    = 9;  // count of args with optional
const int SETUPARG_WOPTIONALEX  = 10; // count of args with optional + certrequired extension

#pragma warning (push)
#pragma warning (disable : 4127) //avoid warning on while false

INT_PTR Setup( DWORD nArgs, LPSTR apszArgs[] )
{
    SETUPDLGPARAM dlgParam;
    INT_PTR   nError = 0;
    HWND    hwndParent = NULL;
    BOOL fCustomHelp = FALSE;
    BOOL bCertRequired = FALSE;

    dlgParam.pszHelpFile = (LPWSTR)LICCPA_HELPFILE;
    dlgParam.dwHelpContext = LICCPA_HELPCONTEXTMAINSETUP;
    dlgParam.dwHCPerServer = LICCPA_HELPCONTEXTPERSERVER;
    dlgParam.dwHCPerSeat = LICCPA_HELPCONTEXTPERSEAT;
    dlgParam.pszService = NULL;
    dlgParam.pszComputer = NULL;
    dlgParam.fNoExit = FALSE;

    do
    {
        if ((nArgs == SETUPARG_WOPTIONAL) || (nArgs == SETUPARG_WOOPTIONAL) || (nArgs == SETUPARG_WOPTIONALEX))
        {
            if (nArgs > SETUPARG_WOOPTIONAL)
            {
                if ( ( NULL != apszArgs[SETUPARG_HELPFILE] ) && lstrcmpiA( apszArgs[SETUPARG_HELPFILE], szSETUP_DEFAULTHELP ) )
                {
                    // help file given
                    LPWSTR pszHelpFile;

                    if ( CreateWSTR( &pszHelpFile, apszArgs[SETUPARG_HELPFILE] ) )
                    {
                        if (0 == lstrlen( pszHelpFile ))
                        {
                            GlobalFree( (HGLOBAL)pszHelpFile );
                            dlgParam.pszHelpFile = NULL; // should remove help buttons
                        }
                        else
                        {
                            fCustomHelp = TRUE;
                            dlgParam.pszHelpFile = pszHelpFile;
                        }
                    }
                    else
                    {
                        nError = ERR_HELPPARAMS;
                        break;
                    }
                    dlgParam.dwHelpContext = (DWORD)strtoul( apszArgs[SETUPARG_HELPCONTEXT], NULL, 0);
                    dlgParam.dwHCPerSeat = (DWORD)strtoul( apszArgs[SETUPARG_HCPERSEAT], NULL, 0);
                    dlgParam.dwHCPerServer = (DWORD)strtoul( apszArgs[SETUPARG_HCPERSERVER], NULL, 0);
                }

                if ( nArgs > SETUPARG_CERTREQUIRED )
                {
                    // cert required / not required given
                    if ( !lstrcmpiA( szSETUP_CERTREQUIRED, apszArgs[SETUPARG_CERTREQUIRED] ) )
                    {
                        bCertRequired = TRUE;
                    }
                    else if ( lstrcmpiA( szSETUP_CERTNOTREQUIRED, apszArgs[SETUPARG_CERTREQUIRED] ) )
                    {
                        // unrecognized argument for cert required/not required
                        nError = ERR_CERTREQPARAM;
                        break;
                    }
                }
            }
            // hwnd is in hex!
#ifdef _WIN64
            {
                _int64 val = 0;
                sscanf(apszArgs[SETUPARG_HWND], "%I64x", &val);
                hwndParent = (HWND)val;
            }
#else
            hwndParent = (HWND)strtoul( apszArgs[SETUPARG_HWND], NULL, 16);
#endif
            if ( !IsWindow( hwndParent ) )
            {
                nError = ERR_HWNDPARAM;
                hwndParent = GetActiveWindow(); // use active window as parent
                if (!IsWindow( hwndParent ) )
                {
                    hwndParent = GetDesktopWindow();
                }
            }

            if ( CreateWSTR( &dlgParam.pszService, apszArgs[SETUPARG_SERVICE] ) &&
                 CreateWSTR( &dlgParam.pszDisplayName, apszArgs[SETUPARG_NAME] ) &&
                 CreateWSTR( &dlgParam.pszFamilyDisplayName, apszArgs[SETUPARG_FAMILYNAME] ) )
            {
                if ( bCertRequired )
                {
                    nError = ServiceSecuritySet( dlgParam.pszComputer, dlgParam.pszDisplayName );
                }
                else
                {
                    nError = ERR_NONE;
                }

                if ( ERR_NONE == nError )
                {
                    if (0 == lstrcmpiA( apszArgs[SETUPARG_SETUP], szSETUP_PERSEAT ))
                    {
                        // use the licensing help context as the main help context
                        dlgParam.dwHelpContext = LICCPA_HELPCONTEXTLICENSING;

                        //
                        // Check if this is a special version of liccpa.
                        //

                        if (gSpecVerInfo.idsSpecVerWarning)
                        {
                            dlgParam.fNoExit = TRUE;
                            nError = SpecialSetupDialog( hwndParent,
                                                         dlgParam );
                        }
                        else
                        {
                            nError = PerSeatSetupDialog( hwndParent,
                                                         dlgParam );
                        }
                    }
                    else
                    {
                        if (0 == lstrcmpiA( apszArgs[SETUPARG_SETUP], szSETUP_NORMALNOEXIT ))
                        {
                            dlgParam.fNoExit = TRUE;
                        }

                        //
                        // Check if this is a special version of liccpa.
                        //

                        if (gSpecVerInfo.idsSpecVerWarning)
                        {
                            nError = SpecialSetupDialog( hwndParent,
                                                         dlgParam );
                        }
                        else
                        {
                            nError = SetupDialog( hwndParent, dlgParam );
                        }
                    }
                }
                else
                {
                    nError = ERR_SERVICEPARAM;
                }
            }

            if (fCustomHelp)
            {
                GlobalFree( (HGLOBAL)dlgParam.pszHelpFile );
            }
            GlobalFree( (HGLOBAL)dlgParam.pszService );
            GlobalFree( (HGLOBAL)dlgParam.pszDisplayName );
            GlobalFree( (HGLOBAL)dlgParam.pszFamilyDisplayName );
        }
        else
        {
            nError = ERR_NUMPARAMS;
        }
    } while (FALSE);

    return( nError );
}

//-------------------------------------------------------------------
//
//  Function: UnattendedSetup
//
//  Summary;
//      This will save the passed values in the registry, keeping all
//      licensing rules in effect and returning errorr/raising dialogs if
//      errors occur.
//
//  Arguments
//      nArgs [in]      - The number of arguments in the apszArgs array
//      apszArgs[] [in] - The argumnents passed in,
//          [0] szRoutine - The type of setup to run (Unattended)
//          [1] szService - The Reg Key name of the service
//          [2] szFamilyDisplayName - The family display name of the service
//          [3] szDisplayName - The display name of the service
//          [4] szMode - The string that defines the mode (PerSeat | PerServer)
//          [5] szUsers - The DWORD to use as the count of users in PerServer mode
//
//  Return:
//      0 - sucessfull
//      ERR_HELPPARAMS
//      ERR_HWNDPARAM
//      ERR_SERVICEPARAM
//      ERR_NUMPARAMS
//      ERR_CLASSREGFAILED
//      ERR_INVALIDROUTINE
//      ERR_INVALIDMODE
//
//  Notes:
//
//  History:
//      Dec-09-94   MikeMi  Created
//
//-------------------------------------------------------------------

const int UNSETUPARG_SETUP          = 0;
const int UNSETUPARG_SERVICE        = 1;
const int UNSETUPARG_FAMILYNAME     = 2;
const int UNSETUPARG_NAME           = 3;
const int UNSETUPARG_MODE           = 4;
const int UNSETUPARG_USERS          = 5;
const int UNSETUPARG_CERTREQUIRED   = 6;

const int UNSETUPARG_NARGSREQUIRED  = 6;
const int UNSETUPARG_NARGSWOPTIONAL = 7;

int UnattendedSetup( DWORD nArgs, LPSTR apszArgs[] )
{
    int nError = 0;
    LPWSTR pszService;
    LPWSTR pszDisplayName;
    LPWSTR pszFamilyDisplayName;
    LICENSE_MODE lmMode;
    DWORD dwUsers;

    do
    {
        if ( (nArgs == UNSETUPARG_NARGSREQUIRED) || (nArgs == UNSETUPARG_NARGSWOPTIONAL) )
        {
            if ( CreateWSTR( &pszService, apszArgs[UNSETUPARG_SERVICE] ) &&
                 CreateWSTR( &pszDisplayName, apszArgs[UNSETUPARG_NAME] ) &&
                 CreateWSTR( &pszFamilyDisplayName, apszArgs[UNSETUPARG_FAMILYNAME] ) )
            {
                nError = ERR_NONE;

                if ( nArgs > UNSETUPARG_CERTREQUIRED )
                {
                    // cert required / not required given
                    if ( !lstrcmpiA( szSETUP_CERTREQUIRED, apszArgs[UNSETUPARG_CERTREQUIRED] ) )
                    {
                        nError = ServiceSecuritySet( NULL, pszDisplayName );
                    }
                    else if ( lstrcmpiA( szSETUP_CERTNOTREQUIRED, apszArgs[UNSETUPARG_CERTREQUIRED] ) )
                    {
                        // unrecognized argument for cert required/not required
                        nError = ERR_CERTREQPARAM;
                    }
                }

                if ( ERR_NONE == nError )
                {
                    //
                    // Check if this is a special version of liccpa.
                    //

                    if (gSpecVerInfo.idsSpecVerWarning)
                    {
                        lmMode  = gSpecVerInfo.lmSpecialMode;
                        dwUsers = gSpecVerInfo.dwSpecialUsers;
                    }
                    else
                    {
                        if (0 == lstrcmpiA( apszArgs[UNSETUPARG_MODE],
                                            szUNATTENDED_PERSERVER ))
                        {
                            lmMode = LICMODE_PERSERVER;
                        }
                        else if (0 == lstrcmpiA( apszArgs[UNSETUPARG_MODE],
                                                 szUNATTENDED_PERSEAT ))
                        {
                            lmMode = LICMODE_PERSEAT;
                        }
                        else
                        {
                            nError = ERR_INVALIDMODE;
                            break;
                        }
                        dwUsers = (DWORD)strtoul( apszArgs[UNSETUPARG_USERS],
                                                  NULL, 0);
                    }

                    nError = UpdateReg( NULL,
                            pszService,
                            pszFamilyDisplayName,
                            pszDisplayName,
                            lmMode,
                            dwUsers );
                }

                GlobalFree( (HGLOBAL)pszService );
                GlobalFree( (HGLOBAL)pszDisplayName );
                GlobalFree( (HGLOBAL)pszFamilyDisplayName );
            }
            else
            {
                nError = ERR_SERVICEPARAM;
            }
        }
        else
        {
            nError = ERR_NUMPARAMS;
        }
    } while (FALSE);

    return( nError );
}
//-------------------------------------------------------------------
//
//  Function: RemoteSetup
//
//  Summary;
//      Run normal setup, Perseat Setup, normal setup without exit remotely
//
//  Arguments
//      nArgs [in]      - The number of arguments in the apszArgs array
//              If this value is 6, help button will call common help
//              If this value is 10, help button will call the passed help
//      apszArgs[] [in] - The argumnents passed in,
//          [0] szRoutine - The type of setup to run
//          [1] szComputer - the name of the computer to setup on (\\name)
//          [2] szHwnd - The parent Window handle, in HEX!
//          [3] szService - The Reg Key name of the service
//          [4] szFamilyDisplayName - The family display name of the service
//          [5] szDisplayName - The display name of the service
//          [6] szHelpFile - The complete path and name to help file
//                  leave as an empty string to remove help buttons
//          [7] szHelpContext - the DWORD to use as the main help context
//          [8] szHCPerSeat   - the DWORD to use as the PerSeat Help context
//          [9] szHCPerServer - the DWORD to use as the PerServer help context
//
//  Return:
//      0 - sucessfull
//      ERR_PERMISSIONDENIED
//      ERR_HELPPARAMS
//      ERR_HWNDPARAM
//      ERR_SERVICEPARAM
//      ERR_NUMPARAMS
//      ERR_CLASSREGFAILED
//      ERR_INVALIDROUTINE
//      ERR_INVALIDMODE
//
//  Notes:
//
//  History:
//      Apr-26-95   MikeMi  Created
//
//-------------------------------------------------------------------

const int REMSETUPARG_SETUP         = 0;
const int REMSETUPARG_COMPUTER      = 1;
const int REMSETUPARG_HWND          = 2;
const int REMSETUPARG_SERVICE       = 3;
const int REMSETUPARG_FAMILYNAME    = 4;
const int REMSETUPARG_NAME          = 5;
const int REMSETUPARG_HELPFILE      = 6;
const int REMSETUPARG_HELPCONTEXT   = 7;
const int REMSETUPARG_HCPERSEAT     = 8;
const int REMSETUPARG_HCPERSERVER   = 9;
const int REMSETUPARG_CERTREQUIRED  = 10;

const int REMSETUPARG_WOOPTIONAL    = 6; // count of args without optional
const int REMSETUPARG_WOPTIONAL = 10; // count of args with optional
const int REMSETUPARG_WOPTIONALEX   = 11; // count of args with optional + certrequired

INT_PTR RemoteSetup( DWORD nArgs, LPSTR apszArgs[] )
{
    SETUPDLGPARAM dlgParam;
    INT_PTR   nError = 0;
    HWND    hwndParent = NULL;
    BOOL fCustomHelp = FALSE;
    BOOL bCertRequired = FALSE;

    dlgParam.pszHelpFile = (LPWSTR)LICCPA_HELPFILE;
    dlgParam.dwHelpContext = LICCPA_HELPCONTEXTMAINSETUP;
    dlgParam.dwHCPerServer = LICCPA_HELPCONTEXTPERSERVER;
    dlgParam.dwHCPerSeat = LICCPA_HELPCONTEXTPERSEAT;
    dlgParam.pszService = NULL;
    dlgParam.fNoExit = FALSE;

    do
    {
        nError = ERR_NONE;

        if ((nArgs == REMSETUPARG_WOPTIONAL) || (nArgs == REMSETUPARG_WOOPTIONAL) || (nArgs == REMSETUPARG_WOPTIONALEX))
        {
            if (nArgs > REMSETUPARG_WOOPTIONAL)
            {
                if ( ( NULL != apszArgs[REMSETUPARG_HELPFILE] ) && lstrcmpiA( apszArgs[REMSETUPARG_HELPFILE], szSETUP_DEFAULTHELP ) )
                {
                    LPWSTR pszHelpFile;

                    if ( CreateWSTR( &pszHelpFile, apszArgs[REMSETUPARG_HELPFILE] ) )
                    {
                        if (0 == lstrlen( pszHelpFile ))
                        {
                            GlobalFree( (HGLOBAL)pszHelpFile );
                            dlgParam.pszHelpFile = NULL; // should remove help buttons
                        }
                        else
                        {
                            fCustomHelp = TRUE;
                            dlgParam.pszHelpFile = pszHelpFile;
                        }
                    }
                    else
                    {
                        nError = ERR_HELPPARAMS;
                        break;
                    }
                    dlgParam.dwHelpContext = (DWORD)strtoul( apszArgs[REMSETUPARG_HELPCONTEXT], NULL, 0);
                    dlgParam.dwHCPerSeat = (DWORD)strtoul( apszArgs[REMSETUPARG_HCPERSEAT], NULL, 0);
                    dlgParam.dwHCPerServer = (DWORD)strtoul( apszArgs[REMSETUPARG_HCPERSERVER], NULL, 0);
                }

                if ( nArgs > REMSETUPARG_CERTREQUIRED )
                {
                    // cert required / not required given
                    if ( !lstrcmpiA( szSETUP_CERTREQUIRED, apszArgs[REMSETUPARG_CERTREQUIRED] ) )
                    {
                        bCertRequired = TRUE;
                    }
                    else if ( lstrcmpiA( szSETUP_CERTNOTREQUIRED, apszArgs[REMSETUPARG_CERTREQUIRED] ) )
                    {
                        // unrecognized argument for cert required/not required
                        nError = ERR_CERTREQPARAM;
                        break;
                    }
                }
            }
            // hwnd is in hex!
#ifdef _WIN64
            {
                _int64 val = 0;
                sscanf(apszArgs[REMSETUPARG_HWND], "%I64x", &val);
                hwndParent = (HWND)val;
            }
#else
            hwndParent = (HWND)strtoul( apszArgs[REMSETUPARG_HWND], NULL, 16);
#endif
            if ( !IsWindow( hwndParent ) )
            {
                nError = ERR_HWNDPARAM;
                hwndParent = GetActiveWindow(); // use active window as parent
                if (!IsWindow( hwndParent ) )
                {
                    hwndParent = GetDesktopWindow();
                }
            }

            if ( CreateWSTR( &dlgParam.pszService, apszArgs[REMSETUPARG_SERVICE] ) &&
                 CreateWSTR( &dlgParam.pszDisplayName, apszArgs[REMSETUPARG_NAME] ) &&
                 CreateWSTR( &dlgParam.pszComputer, apszArgs[REMSETUPARG_COMPUTER] ) &&
                 CreateWSTR( &dlgParam.pszFamilyDisplayName, apszArgs[REMSETUPARG_FAMILYNAME] ) )
            {
                if ( bCertRequired )
                {
                    nError = ServiceSecuritySet( dlgParam.pszComputer, dlgParam.pszDisplayName );
                }
                else
                {
                    nError = ERR_NONE;
                }

                if ( ERR_NONE == nError )
                {
                    if (0 == lstrcmpiA( apszArgs[REMSETUPARG_SETUP], szREMOTESETUP_PERSEAT ))
                    {
                        // use the licensing help context as the main help context
                        dlgParam.dwHelpContext = LICCPA_HELPCONTEXTLICENSING;

                        //
                        // Check if this is a special version of liccpa.
                        //

                        if (gSpecVerInfo.idsSpecVerWarning)
                        {
                            dlgParam.fNoExit = TRUE;
                            nError = SpecialSetupDialog( hwndParent,
                                                         dlgParam );
                        }
                        else
                        {
                            nError = PerSeatSetupDialog( hwndParent,
                                                         dlgParam );
                        }
                    }
                    else
                    {
                        if (0 == lstrcmpiA( apszArgs[REMSETUPARG_SETUP], szREMOTESETUP_NORMALNOEXIT ))
                        {
                            dlgParam.fNoExit = TRUE;
                        }

                        //
                        // Check if this is a special version of liccpa.
                        //

                        if (gSpecVerInfo.idsSpecVerWarning)
                        {
                            nError = SpecialSetupDialog( hwndParent,
                                                         dlgParam );
                        }
                        else
                        {
                            nError = SetupDialog( hwndParent, dlgParam );
                        }
                    }
                }
            }
            else
            {
                nError = ERR_SERVICEPARAM;
            }

            if (fCustomHelp)
            {
                GlobalFree( (HGLOBAL)dlgParam.pszHelpFile );
            }
            GlobalFree( (HGLOBAL)dlgParam.pszService );
            GlobalFree( (HGLOBAL)dlgParam.pszDisplayName );
            GlobalFree( (HGLOBAL)dlgParam.pszFamilyDisplayName );
            GlobalFree( (HGLOBAL)dlgParam.pszComputer );
        }
        else
        {
            nError = ERR_NUMPARAMS;
        }
    } while (FALSE);

    return( nError );
}

//-------------------------------------------------------------------
//
//  Function: RemoteUnattendedSetup
//
//  Summary;
//      This will save the passed values in the registry, keeping all
//      licensing rules in effect and returning errorr/raising dialogs if
//      errors occur. This is done remotely on the computer specified.
//
//  Arguments
//      nArgs [in]      - The number of arguments in the apszArgs array
//      apszArgs[] [in] - The argumnents passed in,
//          [0] szRoutine - The type of setup to run (Unattended)
//          [1] szComputer - the name of the computer to setup on (\\name)
//          [2] szService - The Reg Key name of the service
//          [3] szFamilyDisplayName - The family display name of the service
//          [4] szDisplayName - The display name of the service
//          [5] szMode - The string that defines the mode (PerSeat | PerServer)
//          [6] szUsers - The DWORD to use as the count of users in PerServer mode
//
//  Return:
//      0 - sucessfull
//      ERR_PERMISSIONDENIED
//      ERR_HELPPARAMS
//      ERR_HWNDPARAM
//      ERR_SERVICEPARAM
//      ERR_USERSPARAM
//      ERR_NUMPARAMS
//      ERR_CLASSREGFAILED
//      ERR_INVALIDROUTINE
//      ERR_INVALIDMODE
//
//  Notes:
//
//  History:
//      Apr-26-95   MikeMi  Created
//
//-------------------------------------------------------------------

const int REMUNSETUPARG_SETUP           = 0;
const int REMUNSETUPARG_COMPUTER        = 1;
const int REMUNSETUPARG_SERVICE         = 2;
const int REMUNSETUPARG_FAMILYNAME      = 3;
const int REMUNSETUPARG_NAME            = 4;
const int REMUNSETUPARG_MODE            = 5;
const int REMUNSETUPARG_USERS           = 6;
const int REMUNSETUPARG_CERTREQUIRED    = 7;

const int REMUNSETUPARG_NARGSREQUIRED   = 7;
const int REMUNSETUPARG_NARGSWOPTIONAL  = 8;

int RemoteUnattendedSetup( DWORD nArgs, LPSTR apszArgs[] )
{
    int nError = 0;
    LPWSTR pszService;
    LPWSTR pszDisplayName;
    LPWSTR pszFamilyDisplayName;
    LPWSTR pszComputerName;

    LICENSE_MODE lmMode;
    DWORD dwUsers;


    do
    {
        if ( (nArgs == REMUNSETUPARG_NARGSREQUIRED) || (nArgs == REMUNSETUPARG_NARGSWOPTIONAL) )
        {
            if ( CreateWSTR( &pszService, apszArgs[REMUNSETUPARG_SERVICE] ) &&
                 CreateWSTR( &pszDisplayName, apszArgs[REMUNSETUPARG_NAME] ) &&
                 CreateWSTR( &pszFamilyDisplayName, apszArgs[REMUNSETUPARG_FAMILYNAME] ) &&
                 CreateWSTR( &pszComputerName, apszArgs[REMUNSETUPARG_COMPUTER] ) )
            {
                nError = ERR_NONE;

                if ( nArgs > REMUNSETUPARG_CERTREQUIRED )
                {
                    // cert required / not required given
                    if ( !lstrcmpiA( szSETUP_CERTREQUIRED, apszArgs[REMUNSETUPARG_CERTREQUIRED] ) )
                    {
                        nError = ServiceSecuritySet( pszComputerName, pszDisplayName );
                    }
                    else if ( lstrcmpiA( szSETUP_CERTNOTREQUIRED, apszArgs[REMUNSETUPARG_CERTREQUIRED] ) )
                    {
                        // unrecognized argument for cert required/not required
                        nError = ERR_CERTREQPARAM;
                    }
                }

                if ( ERR_NONE == nError )
                {
                    //
                    // Check if this is a special version of liccpa.
                    //

                    if (gSpecVerInfo.idsSpecVerWarning)
                    {
                        lmMode  = gSpecVerInfo.lmSpecialMode;
                        dwUsers = gSpecVerInfo.dwSpecialUsers;
                    }
                    else
                    {
                        if (0 == lstrcmpiA( apszArgs[REMUNSETUPARG_MODE],
                                            szUNATTENDED_PERSERVER ))
                        {
                            lmMode = LICMODE_PERSERVER;
                        }
                        else if (0 == lstrcmpiA( apszArgs[REMUNSETUPARG_MODE],
                                                 szUNATTENDED_PERSEAT ))
                        {
                            lmMode = LICMODE_PERSEAT;
                        }
                        else
                        {
                            nError = ERR_INVALIDMODE;
                            break;
                        }
                        dwUsers = (DWORD)strtoul(
                                            apszArgs[REMUNSETUPARG_USERS],
                                            NULL, 0);
                    }

                    nError = UpdateReg( pszComputerName,
                            pszService,
                            pszFamilyDisplayName,
                            pszDisplayName,
                            lmMode,
                            dwUsers );
                }

                if(pszService != NULL)
                {
                    GlobalFree( (HGLOBAL)pszService );
                }
                if(pszDisplayName != NULL)
                {
                    GlobalFree( (HGLOBAL)pszDisplayName );
                }
                if(pszFamilyDisplayName != NULL)
                {
                    GlobalFree( (HGLOBAL)pszFamilyDisplayName );
                }
                if(pszComputerName != NULL)
                {
                    GlobalFree( (HGLOBAL)pszComputerName );
                }
            }
            else
            {
                nError = ERR_SERVICEPARAM;
            }
        }
        else
        {
            nError = ERR_NUMPARAMS;
        }
    } while (FALSE);


    return( nError );
}

#pragma warning (pop) //4127

//-------------------------------------------------------------------
//
//  Function: CPlSetup
//
//  Summary;
//      Dll entry point for License Mode Setup, to be used from Setup
//      programs.
//
//  Arguments
//      nArgs [in]      - The number of arguments in the apszArgs array
//      apszArgs[] [in] - The argumnents passed in,
//          [0] szRoutine - The type of setup to run
//                  FullSetup | RemoteFullSetup |
//                  PerSeatSetup | RemotePerSeatSetup |
//                  Unattended |  RemoteUnattended |
//                  FullSetupNoexit | RemoteFullSetupNoexit
//      ppszResult [out]- The result string
//
//  Return:
//
//  Notes:
//
//  History:
//      Nov-17-94   MikeMi  Created
//      Apr-26-95   MikeMi  Added remoting routines
//
//-------------------------------------------------------------------

BOOL APIENTRY CPlSetup( DWORD nArgs, LPSTR apszArgs[], LPSTR *ppszResult )
{
    INT_PTR   nError = 0;
    BOOL  frt = TRUE;

    //
    // Initialize global special version information is this liccpa
    // is a special version (eg: restricted SAM, NFR, etc).
    //

    InitSpecialVersionInfo();

    if ((0 == lstrcmpiA( apszArgs[SETUPARG_SETUP], szSETUP_PERSEAT )) ||
        (0 == lstrcmpiA( apszArgs[SETUPARG_SETUP], szSETUP_NORMAL )) ||
        (0 == lstrcmpiA( apszArgs[SETUPARG_SETUP], szSETUP_NORMALNOEXIT )) )
    {
        nError = Setup( nArgs, apszArgs );
    }
    else if (0 == lstrcmpiA( apszArgs[SETUPARG_SETUP], szSETUP_UNATTENDED ))
    {
        nError = UnattendedSetup( nArgs, apszArgs );
    }
    else if ((0 == lstrcmpiA( apszArgs[SETUPARG_SETUP], szREMOTESETUP_PERSEAT )) ||
        (0 == lstrcmpiA( apszArgs[SETUPARG_SETUP], szREMOTESETUP_NORMAL )) ||
        (0 == lstrcmpiA( apszArgs[SETUPARG_SETUP], szREMOTESETUP_NORMALNOEXIT )) )
    {
        nError = RemoteSetup( nArgs, apszArgs );
    }
    else if (0 == lstrcmpiA( apszArgs[SETUPARG_SETUP], szREMOTESETUP_UNATTENDED ))
    {
        nError = RemoteUnattendedSetup( nArgs, apszArgs );
    }
    else
    {
        nError = ERR_INVALIDROUTINE;
    }

    // prepare error for return
    switch (nError)
    {
    case 0:
        *ppszResult = szSETUP_EXIT;
        break;

    case ERR_NONE:
        *ppszResult = szSETUP_OK;
        break;

    case ERR_PERMISSIONDENIED:
        frt = FALSE;
        *ppszResult = szSETUP_SECURITY;
        break;

    case ERR_NOREMOTESERVER:
        frt = FALSE;
        *ppszResult = szSETUP_NOREMOTE;
        break;

    case ERR_DOWNLEVEL:
        frt = FALSE;
        *ppszResult = szSETUP_DOWNLEVEL;
        break;

    default:
        *ppszResult = szSETUP_ERROR;
        frt = FALSE;
        break;
    }

    return( frt );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\liccpa\pridlgs.hpp ===
//-------------------------------------------------------------------
//
// FILE: PriDlgs.hpp
//
// Summary;
// 		This file contians the definitions of Primary Dialogs functions
//
// Entry Points;
//		PerSeatSetupDialog
//		SetupDialog
//		CpaDialog
//		UpdateReg
//
// History;
//		Nov-30-94	MikeMi	Created
//      Apr-26-95   MikeMi  Added Computer name and remoting
//
//-------------------------------------------------------------------

#ifndef __PRIDLGS_HPP__
#define __PRIDLGS_HPP__

#include "CLicReg.hpp"

// Used to pass information from the Setup entry point to the Setup Dialog
//
typedef struct tagSETUPDLGPARAM
{
    LPWSTR  pszComputer;
	LPWSTR  pszService;
	LPWSTR  pszFamilyDisplayName;
    LPWSTR  pszDisplayName;
	LPWSTR	pszHelpFile;
	DWORD   dwHelpContext;
	DWORD   dwHCPerServer;
	DWORD	dwHCPerSeat;
	BOOL	fNoExit;
} SETUPDLGPARAM, *PSETUPDLGPARAM;

extern INT AccessOk( HWND hDlg, LONG lrc, BOOL fCPCall );
extern INT_PTR PerSeatSetupDialog( HWND hwndParent, SETUPDLGPARAM& dlgParam );
extern INT_PTR SetupDialog( HWND hwndParent, SETUPDLGPARAM& dlgParam );
extern INT_PTR CpaDialog( HWND hwndParent );
extern int UpdateReg( LPCWSTR pszComputer, 
        LPCWSTR pszService, 
        LPCWSTR pszFamilyDisplayName, 
        LPCWSTR pszDisplayName, 
        LICENSE_MODE lm, 
        DWORD dwUsers );

int ServiceSecuritySet( LPWSTR pszComputer, LPWSTR pszDisplayName );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\liccpa\resource.h ===
#include <windows.h>

#define  IDS_CPATITLE                                 1
#define  IDS_CPADESC                                  2

#define  IDS_CPCAPTION                                3
#define  IDS_SETUPCAPTION                             4
#define  IDS_NOACCESS                                 5
#define  IDS_NOSERVER                                 6
#define  IDS_BADREG                                   7
#define  IDS_NOSERVICES                               8

#define  IDS_BADREGTERM                               9
#define  IDS_LOWMEM                                   10

#define  IDS_INVALIDUSERCOUNT                         13
#define  IDS_PASSWORD_INVALID                         14
#define  IDS_PASSWORD_MISMATCH                        15
#define  IDS_COMPUTERNAME_INVALID                     16
#define  IDS_ACCOUNT_NAME_INVALID                     17
#define  IDS_NO_SELF_REPLICATION                      18

#define  IDS_MSDN_NOTAVAILABLE                        20
#define  IDS_MSDN_TEXT1                               21
#define  IDS_MSDN_TEXT2                               22

#define  IDS_NFR_NOTAVAILABLE                         30
#define  IDS_NFR_TEXT1                                31
#define  IDS_NFR_TEXT2                                32

#define  IDS_LICENSE_SETUP_NO_PER_SERVER_LICENSES     40
#define  IDS_LICENSE_SETUP_SAVE_FAILED                41
#define  IDS_LICENSE_SETUP_CANT_INVOKE_WINHELP        42
#define  IDS_LICENSE_SETUP_BAD_UNATTEND_PARAM         43

#define  IDS_WARNING                                  50
#define  IDS_ERROR                                    51

#define  IDS_MSSERIF                                  60
#define  IDS_LARGEFONTSIZE                            61

#define  IDS_SERVICE_DISPLAY_NAME                     70

#define  IDS_SETUP_HEADER                             71
#define  IDS_SETUP_SUBHEADER                          72

#define  IDS_SERVICE_DESCRIPTION                      73

#define  IDS_SAM_NOTAVAILABLE                         80
#define  IDS_SAM_TEXT1                                81
#define  IDS_SAM_TEXT2                                82
#define  IDS_SAMNFR_NOTAVAILABLE                      83
#define  IDS_SAMNFR_TEXT1                             84
#define  IDS_SAMNFR_TEXT2                             85
#include "Dialogs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\liccpa\pridlgs.cpp ===
//-------------------------------------------------------------------
//
// FILE: PriDlgs.cpp
//
// Summary;
//      This file contians the Primary Dialogs, functions and dialog procs
//
// Entry Points;
//
// History;
//      Nov-30-94   MikeMi  Created
//      Mar-14-95   MikeMi  Added F1 Message Filter and PWM_HELP message
//      Apr-26-95   MikeMi  Added Computer name and remoting
//      Dec-15-95  JeffParh Added secure certificate support.
//
//-------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "resource.h"
#include "CLicReg.hpp"
#include <stdlib.h>
#include <htmlhelp.h>
#include "liccpa.hpp"
#include "PriDlgs.hpp"
#include "SecDlgs.hpp"
#include <llsapi.h>

#include <strsafe.h>

extern "C"
{
    INT_PTR CALLBACK dlgprocLICCPA( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    INT_PTR CALLBACK dlgprocLICSETUP( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    INT_PTR CALLBACK dlgprocPERSEATSETUP( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    INT_PTR CALLBACK dlgprocLICCPACONFIG( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
}

// Perserver user count value limits and defaults
//
const int PERSERVER_LIMITDEFAULT = 0;
const int PERSERVER_MAX = 999999;
const int PERSERVER_MIN = 0;
const int PERSERVER_PAGE = 10;
const int cchEDITLIMIT = 6;  // the number of chars to represent PERSERVER_MAX

const UINT MB_VALUELIMIT = MB_OK;  // beep when value limit is reached

// Used for in memory storage of license mode state
//
typedef struct tagSERVICEENTRY
{
    LPWSTR       pszComputer;
    LPWSTR       pszService;
    LPWSTR       pszDisplayName;
    LPWSTR       pszFamilyDisplayName;
    LICENSE_MODE lm;
    DWORD        dwLimit;
    BOOL         fIsNewProduct;
} SERVICEENTRY, *PSERVICEENTRY;

#pragma warning(push)
#pragma warning(disable: 4296) // C4296: '<=' : expression is always true
inline BOOL VALIDUSERCOUNT( UINT users )
{
    return ((PERSERVER_MIN <= users) && (PERSERVER_MAX >= users));
}
#pragma warning(pop)

static void UpdatePerServerLicenses( HWND hwndDlg, PSERVICEENTRY pServ );
static int ServiceRegister( LPWSTR pszComputer,
                            LPWSTR pszFamilyDisplayName,
                            LPWSTR pszDisplayName );


BOOL g_fWarned = FALSE;

//-------------------------------------------------------------------
//
//  Function:  AccessOk
//
//  Summary;
//      Checks access rights from reg call and raise dialog as needed
//
//  Arguments;
//      hDlg [in]   - Handle to working dialog to raise error dlgs with
//      lrc [in]    - the return status from a reg call
//
//  Returns:
//      local error mapping;
//      ERR_NONE
//      ERR_PERMISSIONDENIED
//      ERR_NOREMOTESERVER
//      ERR_REGISTRYCORRUPT
//
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

INT AccessOk( HWND hDlg, LONG lrc, BOOL fCPCall )
{
    INT  nrt = ERR_NONE;
    
    if (ERROR_SUCCESS != lrc)
    {
        WCHAR szText[TEMPSTR_SIZE];
        WCHAR szTitle[TEMPSTR_SIZE];
        UINT  wId;
        UINT  wIdTitle;
        
        switch (lrc)
        {
        case ERROR_ACCESS_DENIED:
            wId = IDS_NOACCESS;
            nrt = ERR_PERMISSIONDENIED;
            break;

        case RPC_S_SERVER_UNAVAILABLE:
            wId = IDS_NOSERVER;         
            nrt = ERR_NOREMOTESERVER;
            break;

        default:
            wId = IDS_BADREG;
            nrt = ERR_REGISTRYCORRUPT;
            break;
        }       

        if (fCPCall)
        {
            wIdTitle = IDS_CPCAPTION;
        }
        else
        {
            wIdTitle = IDS_SETUPCAPTION;
        }

        LoadString(g_hinst, wIdTitle, szTitle, TEMPSTR_SIZE);
        LoadString(g_hinst, wId, szText, TEMPSTR_SIZE);
        MessageBox (hDlg, szText, szTitle, MB_OK|MB_ICONSTOP);
    }
    return( nrt );
}

//-------------------------------------------------------------------
//
//  Function: InitUserEdit
//
//  Summary;
//      Initializes and defines user count edit control behaviour
//
//  Arguments;
//      hwndDlg [in]    - Parent dialog of user count edit dialog
//
// History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

void InitUserEdit( HWND hwndDlg )
{
    HWND hwndCount = GetDlgItem( hwndDlg, IDC_USERCOUNT);

    SendMessage( hwndCount, EM_LIMITTEXT, cchEDITLIMIT, 0 );
}

//-------------------------------------------------------------------
//
//  Function: InitTitleText
//
//  Summary;
//      Initialize title static text and mode definition static text
//
//  Arguments;
//      hwndDlg [in]    - Parent dialog of description static text
//      pServ [in]      - Service definition to set static text
//  
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

void InitTitleText( HWND hwndDlg,  PSERVICEENTRY pServ )
{
    InitStaticWithService( hwndDlg, IDC_STATICTITLE, pServ->pszDisplayName );
    InitStaticWithService( hwndDlg, IDC_STATICPERSEAT, pServ->pszDisplayName );
}

//-------------------------------------------------------------------
//
//  Function: InitDialogForService
//
//  Summary;
//      Initialize dialog controls to the service state
//
//  Arguments;
//      hwndDlg [in]    - Parent dialog to init controls in
//      pServ [in]      - Service definition to set controls
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

void InitDialogForService( HWND hwndDlg, PSERVICEENTRY pServ )
{
    HWND hwndCount =    GetDlgItem( hwndDlg, IDC_USERCOUNT );
    HWND hwndSpin = GetDlgItem( hwndDlg, IDC_USERCOUNTARROW );
    BOOL fIsPerServer = (LICMODE_PERSERVER==pServ->lm);

    // set radio button states
    CheckDlgButton( hwndDlg, IDC_PERSEAT, !fIsPerServer );
    CheckDlgButton( hwndDlg, IDC_PERSERVER, fIsPerServer );
    
    // set user count edit control
    if (fIsPerServer)
    {
        // add text back
        SetDlgItemInt( hwndDlg, IDC_USERCOUNT, pServ->dwLimit, FALSE );
        SetFocus( hwndCount );
        SendMessage( hwndCount, EM_SETSEL, 0, -1 );
    }
    else
    {
        // remove all text in item
        SetDlgItemText( hwndDlg, IDC_USERCOUNT, L"" );
    }

    // set state of edit control and arrows
   if ( NULL != hwndSpin )
   {
       EnableWindow( hwndCount, fIsPerServer );
       EnableWindow( hwndSpin, fIsPerServer );
   }
   else
   {
       UpdatePerServerLicenses( hwndDlg, pServ );
       EnableWindow( GetDlgItem( hwndDlg, IDC_ADD_LICENSES    ), fIsPerServer );
       EnableWindow( GetDlgItem( hwndDlg, IDC_REMOVE_LICENSES ), fIsPerServer );
   }
}

//-------------------------------------------------------------------
//
//  Function: FreeServiceEntry
//
//  Summary;
//      Free all allocated memory when a service structure is created
//
//  Aruments;
//      pServ [in]  - The Service structure to free
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

void FreeServiceEntry( PSERVICEENTRY pServ )
{
    GlobalFree( pServ->pszService );
    GlobalFree( pServ->pszDisplayName );
    if ( NULL != pServ->pszComputer )
    {
        GlobalFree( pServ->pszComputer );
    }
    GlobalFree( pServ );
}

//-------------------------------------------------------------------
//
//  Function: CreateServiceEntry
//
//  Summary;
//      Using the Service registry key name, allocate a Service structure
//      and setup registry.
//
//  Arguments;
//      pszComputer [in] - The name of the computer to use (maybe null)
//      pszService [in] - The name of the reg key to use to load or create 
//          service from
//      pszDisplayName [in] - The name the user will see, this will only be
//          if the registry does not contain a displayname already
//
//  Returns: NULL if Error, pointer to allocated Service Structure
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

PSERVICEENTRY CreateServiceEntry( LPCWSTR pszComputer,
        LPCWSTR pszService,
        LPCWSTR pszFamilyDisplayName,
        LPCWSTR pszDisplayName )
{
    CLicRegLicenseService cLicServKey;
    PSERVICEENTRY pServ = NULL;
    DWORD cchSize = 0;
    LONG lrt;
    HRESULT hr;

    pServ = (PSERVICEENTRY)GlobalAlloc( GPTR, sizeof( SERVICEENTRY ));
    if (pServ)
    {
        cLicServKey.SetService( pszService );
        cLicServKey.Open( pszComputer, TRUE );

        // load or set defaults
        //
        if (ERROR_SUCCESS != cLicServKey.GetMode( pServ->lm ))
        {
            pServ->lm = LICMODE_UNDEFINED;
        }

        if (ERROR_SUCCESS != cLicServKey.GetUserLimit( pServ->dwLimit ))
        {
            pServ->dwLimit = PERSERVER_LIMITDEFAULT;
        }

        //
        // get, set DisplayName
        //
        lrt = cLicServKey.GetDisplayName( NULL, cchSize );
        if (ERROR_SUCCESS == lrt)
        {
            pServ->pszDisplayName = (LPWSTR)GlobalAlloc( GPTR, cchSize * sizeof( WCHAR ) );
            if (pServ->pszDisplayName == NULL)
            {
                goto ErrorCleanup;
            }
            lrt = cLicServKey.GetDisplayName( pServ->pszDisplayName, cchSize );
        }

        // the GetDisplayName may fail in both the two cases above
        //
        if (ERROR_SUCCESS != lrt)
        {
            GlobalFree( (HGLOBAL)pServ->pszDisplayName );
            cchSize = lstrlen( pszDisplayName ) + 1;
            pServ->pszDisplayName = (LPWSTR)GlobalAlloc( GPTR, cchSize * sizeof( WCHAR ) );
            if (pServ->pszDisplayName == NULL)
            {
                goto ErrorCleanup;
            }
            hr = StringCchCopy( pServ->pszDisplayName, cchSize, pszDisplayName );
            if (S_OK != hr)
            {
                goto ErrorCleanup;
            }

            cLicServKey.SetDisplayName( pServ->pszDisplayName );
            pServ->fIsNewProduct = TRUE;
        }
        else
        {
            pServ->fIsNewProduct = FALSE;
        }

        //
        // get, set FamilyDisplayName
        //
        lrt = cLicServKey.GetFamilyDisplayName( NULL, cchSize );
        if (ERROR_SUCCESS == lrt)
        {
            pServ->pszFamilyDisplayName = (LPWSTR)GlobalAlloc( GPTR, cchSize * sizeof( WCHAR ) );
            if ( pServ->pszFamilyDisplayName == NULL )
            {
                goto ErrorCleanup;
            }
            lrt = cLicServKey.GetFamilyDisplayName( pServ->pszFamilyDisplayName, cchSize );
        }

        // the GetFamilyDisplayName may fail in both the two cases above
        //
        if (ERROR_SUCCESS != lrt)
        {
            GlobalFree( (HGLOBAL)pServ->pszFamilyDisplayName );
            cchSize = lstrlen( pszFamilyDisplayName ) + 1;
            pServ->pszFamilyDisplayName = (LPWSTR)GlobalAlloc( GPTR, cchSize * sizeof( WCHAR ) );

            if ( pServ->pszFamilyDisplayName == NULL )
            {
                goto ErrorCleanup;
            }
            hr = StringCchCopy( pServ->pszFamilyDisplayName, cchSize, pszFamilyDisplayName );
            if (S_OK != hr)
            {
                goto ErrorCleanup;
            }
        }

        cchSize = lstrlen( pszService ) + 1;
        pServ->pszService = (LPWSTR)GlobalAlloc( GPTR, cchSize * sizeof( WCHAR ) );
        if (pServ->pszService == NULL)
        {
            goto ErrorCleanup;
        }
        hr = StringCchCopy( pServ->pszService, cchSize, pszService );
        if (S_OK != hr)
        {
            goto ErrorCleanup;
        }

        cLicServKey.Close();

        if ( NULL == pszComputer )
        {
            pServ->pszComputer = NULL;
        }
        else
        {
            cchSize = 1 + lstrlen( pszComputer );
            pServ->pszComputer = (LPWSTR)GlobalAlloc( GPTR, sizeof( WCHAR ) * cchSize );
            if (pServ->pszComputer == NULL)
            {
                goto ErrorCleanup;
            }
            hr = StringCchCopy( pServ->pszComputer, cchSize, pszComputer );
            if (S_OK != hr)
            {
                goto ErrorCleanup;
            }
        }
    }
    return( pServ );

ErrorCleanup:

    
    if (pServ) // JonN 5/15/00: PREFIX 112116-112119
    {
        if (pServ->pszDisplayName)
            GlobalFree( (HGLOBAL)pServ->pszDisplayName );
        if (pServ->pszFamilyDisplayName)
            GlobalFree( (HGLOBAL)pServ->pszFamilyDisplayName );
        if (pServ->pszService)
            GlobalFree( (HGLOBAL)pServ->pszService );
        if (pServ->pszComputer)
            GlobalFree( (HGLOBAL)pServ->pszComputer );
        GlobalFree( (HGLOBAL)pServ );
    }
    return ( (PSERVICEENTRY)NULL );
}

//-------------------------------------------------------------------
//
//  Function: SaveServiceToReg
//
//  Summary;
//      Save the given Service structure to the registry
//
//  Arguments;
//      pServ [in] - Service structure to save
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

void SaveServiceToReg( LPCWSTR pszComputer, PSERVICEENTRY pServ )
{
    CLicRegLicenseService cLicServKey;
    LICENSE_MODE lm;

    cLicServKey.SetService( pServ->pszService );
    cLicServKey.Open( pszComputer );
    
    //
    // if no mode in the registry, set to current selected mode
    //
    if (ERROR_SUCCESS != cLicServKey.GetMode( lm ))
    {
        lm = pServ->lm;
    }
    //
    // if a mode change was made or perseat mode selected,
    // set the change flag so that user is warned on any change
    //
    if ((pServ->lm != lm) ||
        (LICMODE_PERSEAT == pServ->lm) )
    {
        cLicServKey.SetChangeFlag( TRUE );
    }
    else
    {
        // this will not modify change flag if it is
        // present, but will set it to false if it is not
        // present
        cLicServKey.CanChangeMode();
    }

    DWORD dwLimitInReg;

    // user limit should be set by CCFAPI32; set only if it's absent
    if ( ERROR_SUCCESS != cLicServKey.GetUserLimit( dwLimitInReg ) )
    {
       cLicServKey.SetUserLimit( pServ->dwLimit );
    }

    cLicServKey.SetDisplayName( pServ->pszDisplayName );
    cLicServKey.SetFamilyDisplayName( pServ->pszFamilyDisplayName );
    cLicServKey.SetMode( pServ->lm );

    cLicServKey.Close();
}

//-------------------------------------------------------------------
//
//  Function: ServiceLicAgreement
//
//  Summary;
//      Check the given Service structure for violation
//
//  Arguments;
//      hwndDlg [in] - hwnd of dialog to use to raise legal voilation dialog
//      pServ [in] - Service structure to check
//      pszComputer [in] - computer to work with
//      pszHelpFile [in] - helpfile for dialogs help button
//      pszPerSeatHelpContext [in] - helpcontext for PerSeat dialog help button
//      pszPerServerHelpContext [in] - helpcontext for PerServer dialog help button
//
//  Return: FALSE if agreement was not acceptable
//          TRUE if agreement was accepted
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

BOOL ServiceLicAgreement( HWND hwndDlg, 
        PSERVICEENTRY pServ,
        LPCWSTR pszComputer, 
        LPCWSTR pszHelpFile, 
        DWORD dwPerSeatHelpContext,
        DWORD dwPerServerHelpContext )
{
    CLicRegLicenseService cLicServKey;
    LICENSE_MODE lm;
    DWORD dwLimit = pServ->dwLimit;
    BOOL frt = TRUE;
    BOOL fRaiseAgreement = TRUE;

    cLicServKey.SetService( pServ->pszService );
    if (ERROR_SUCCESS == cLicServKey.Open( pszComputer, FALSE ))
    {
        
        cLicServKey.GetMode( lm );
        cLicServKey.GetUserLimit( dwLimit );
    
        // check for changes
        if ( !( pServ->lm != lm ||
                (LICMODE_PERSERVER == pServ->lm && 
                 dwLimit != pServ->dwLimit) ) )
        {
            fRaiseAgreement = FALSE;
        }
        cLicServKey.Close();
    }

    if (fRaiseAgreement)
    {
        if (LICMODE_PERSEAT == pServ->lm)
        {
            frt = PerSeatAgreementDialog( hwndDlg, 
                    pServ->pszDisplayName,
                    pszHelpFile,
                    dwPerSeatHelpContext );
        }
        else
        {   
            // special case FilePrint and zero concurrent users
            //
            if ( 0 == lstrcmp( pServ->pszService, FILEPRINT_SERVICE_REG_KEY ) &&
                    (0 == pServ->dwLimit))
            {
                frt = ServerAppAgreementDialog( hwndDlg, 
                        pszHelpFile,
                        LICCPA_HELPCONTEXTSERVERAPP );
            }
            else
            {
                // find the limit has changed but was this invoked
                // by adding more licenses if so the user was already warned

                if( !g_fWarned )
                {
                    frt = PerServerAgreementDialog( hwndDlg, 
                            pServ->pszDisplayName,
                            dwLimit , //pServ->dwLimit,
                            pszHelpFile,
                            dwPerServerHelpContext );
                }
            }
        }   
    }
    return( frt );
}

//-------------------------------------------------------------------
//
//  Function: ServiceViolation
//
//  Summary;
//      Check the given Service structure for violation
//
//  Arguments;
//      hwndDlg [in] - hwnd of dialog to use to raise legal voilation dialog
//      pszComputer [in] - the name of the computer to work on
//      pServ [in] - Service structure to check
//
//
//  Return: FALSE if violation not made 
//          TRUE if violation was made
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

BOOL ServiceViolation( HWND hwndDlg, LPCWSTR pszComputer, PSERVICEENTRY pServ )
{
    CLicRegLicenseService cLicServKey;
    LICENSE_MODE lm;
    BOOL frt = FALSE;
    
    cLicServKey.SetService( pServ->pszService );
    if (ERROR_SUCCESS == cLicServKey.Open( pszComputer, FALSE ))
    {
        cLicServKey.GetMode( lm );
    
        // check for changes
        if ( (pServ->lm != lm) && !cLicServKey.CanChangeMode() )
        {
            frt = LicViolationDialog( hwndDlg );    
        }
        cLicServKey.Close();
    }
    return( frt );
}

//-------------------------------------------------------------------
//
//  Function: EditInvalidDlg
//
//  Summary;
//      Display Dialog when user count edit control value is invalid
//
//  Arguments;
//      hwndDlg [in] - hwnd of dialog
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

void EditInvalidDlg( HWND hwndDlg )
{
    HWND hwndCount = GetDlgItem( hwndDlg, IDC_USERCOUNT);
    WCHAR szTitle[TEMPSTR_SIZE];
    WCHAR szText[LTEMPSTR_SIZE];
    WCHAR szTemp[LTEMPSTR_SIZE];

    MessageBeep( MB_VALUELIMIT );
    
    LoadString(g_hinst, IDS_CPCAPTION, szTitle, TEMPSTR_SIZE);
    LoadString(g_hinst, IDS_INVALIDUSERCOUNT, szTemp, LTEMPSTR_SIZE);
    HRESULT hr = StringCbPrintf( szText, sizeof(szText), szTemp, PERSERVER_MIN, PERSERVER_MAX );
    if (SUCCEEDED(hr))
        MessageBox( hwndDlg, szText, szTitle, MB_OK | MB_ICONINFORMATION );
    
    // also set focus to edit and select all
    SetFocus( hwndCount );
    SendMessage( hwndCount, EM_SETSEL, 0, -1 );
}

//-------------------------------------------------------------------
//
//  Function: EditValidate
//
//  Summary;
//      Handle when the value within the user count edit control changes
//
//  Arguments;
//      hwndDlg [in] - hwnd of dialog
//      pserv [in]  - currently selected service
//
//  Return: FALSE if Edit Value is not valid, TRUE if it is
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

BOOL EditValidate( HWND hwndDlg, PSERVICEENTRY pServ )
{
    BOOL fTranslated;
    UINT nValue;
    BOOL fValid = TRUE;

    // only do this if in PerServer mode
    //
    if (LICMODE_PERSERVER == pServ->lm)
    {
        fValid = FALSE;
        nValue = GetDlgItemInt( hwndDlg, IDC_USERCOUNT, &fTranslated, FALSE );  

        if (fTranslated)
        {
            if (VALIDUSERCOUNT( nValue))
            {
                pServ->dwLimit = nValue;
                fValid = TRUE;
            }
        }
    }
    return( fValid );
}

//-------------------------------------------------------------------
//
//  Function: OnEditChange
//
//  Summary;
//      Handle when the value within the user count edit control changes
//
//  Arguments;
//      hwndDlg [in] - hwnd of dialog
//      pserv [in]  - currently selected service
//
//  History;
//      Mar-06-94   MikeMi  Created
//
//-------------------------------------------------------------------

void OnEditChange( HWND hwndDlg, HWND hwndCount, PSERVICEENTRY pServ )
{
    BOOL fTranslated;
    UINT nValue;
    BOOL fValid = TRUE;
    BOOL fModified = FALSE;

    // only do this if in PerServer mode
    //
    if (LICMODE_PERSERVER == pServ->lm)
    {
        fValid = FALSE;
        nValue = GetDlgItemInt( hwndDlg, IDC_USERCOUNT, &fTranslated, FALSE );  

        if (fTranslated)
        {
#pragma warning(push)
#pragma warning(disable: 4296) // C4296: '>' : expression is always false
            if (PERSERVER_MIN > nValue)
            {
                nValue = PERSERVER_MIN;
                fModified = TRUE;
            }
            else if (PERSERVER_MAX < nValue)
            {
                nValue = PERSERVER_MAX;
                fModified = TRUE;
            }
#pragma warning(pop)

            pServ->dwLimit = nValue;
        }
        else
        {
            // reset to last value
            nValue = pServ->dwLimit;
            fModified = TRUE;
        }

        if (fModified)
        {
            SetDlgItemInt( hwndDlg, IDC_USERCOUNT, nValue, FALSE );
            SetFocus( hwndCount );
            SendMessage( hwndCount, EM_SETSEL, 0, -1 );
            MessageBeep( MB_VALUELIMIT );
        }
    }
}

//-------------------------------------------------------------------
//
//  Function: OnCpaClose
//
//  Summary;
//      Do work needed when the Control Panel applet is closed.
//      Free all Service structures alloced and possible save.
//
//  Arguments;
//      hwndDlg [in] - Dialog close was requested on
//      fSave [in] - Save Services to Registry
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

void OnCpaClose( HWND hwndDlg, BOOL fSave )
{
    HWND hwndService = GetDlgItem( hwndDlg, IDC_SERVICES);
    LRESULT cItems = SendMessage( hwndService, CB_GETCOUNT, 0, 0 ) - 1;
    LONG_PTR iItem = 0; // this wasn't init and it leads using uninit data in the following CB_SETCURSEL call
    PSERVICEENTRY pServ;
    LRESULT iSel;

    iSel  = SendMessage( hwndService, CB_GETCURSEL, 0, 0 );
    pServ = (PSERVICEENTRY)SendMessage( hwndService, CB_GETITEMDATA, iSel, 0 ); 

    if ( fSave &&
         (pServ->lm == LICMODE_PERSERVER) &&
         !EditValidate( hwndDlg, pServ ) )
    {
        EditInvalidDlg( hwndDlg );
    }
    else
    {
        BOOL fCompleted = TRUE;
        // loop and check for agreement changes (only needed if saving)
        //
        if (fSave)
        {
            for (iItem = cItems; iItem >= 0; iItem--)
            {   
                pServ = (PSERVICEENTRY)SendMessage( hwndService, CB_GETITEMDATA, iItem, 0 );    
                if (ServiceLicAgreement( hwndDlg, 
                        pServ,
                        NULL,
                        LICCPA_HELPFILE,
                        LICCPA_HELPCONTEXTPERSEAT,
                        LICCPA_HELPCONTEXTPERSERVER ))
                {
                    SaveServiceToReg( NULL, pServ );
                }
                else
                {
                    fCompleted = FALSE; 
                    break;
                }
            }
        }

        if (fCompleted)
        {
            // loop and free service entries
            //
            for (iItem = cItems; iItem >= 0; iItem--)
            {   
                pServ = (PSERVICEENTRY)SendMessage( hwndService, CB_GETITEMDATA, iItem, 0 );    
                FreeServiceEntry( pServ );
            }
            EndDialog( hwndDlg, fSave );
        }
        else
        {
            // set combo box to last canceled entry
            SendMessage( hwndService, CB_SETCURSEL, iItem, 0 );
        }
    }
}

//-------------------------------------------------------------------
//
//  Function: OnSetupClose
//
//  Summary;
//      Do work needed when the Setup Dialog is closed.
//      Free the service structure and possible save it
//
//  Arguments;
//      hwndDlg [in] - hwnd of dialog this close was requested on
//      fSave [in] - Save service to registry
//      pServ [in] - the service structure to work with
//      psdParams [in] - setup dlg params for help contexts and files
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

void OnSetupClose( HWND hwndDlg, 
        BOOL fSave, 
        PSERVICEENTRY pServ,
        PSETUPDLGPARAM psdParams )
{
    if ( fSave &&
         (pServ->lm == LICMODE_PERSERVER) &&
         !EditValidate( hwndDlg, pServ ) )
    {
        EditInvalidDlg( hwndDlg );
    }
    else
    {
        BOOL fCompleted = TRUE;

        if (fSave)
        {
            if (ServiceLicAgreement( hwndDlg, 
                    pServ,
                    psdParams->pszComputer,
                    psdParams->pszHelpFile,
                    psdParams->dwHCPerSeat,
                    psdParams->dwHCPerServer ))
            {
                SaveServiceToReg( psdParams->pszComputer, pServ );

                // register service at enterprise server
                ServiceRegister( psdParams->pszComputer,
                                 psdParams->pszFamilyDisplayName,
                                 psdParams->pszDisplayName );
            }
            else
            {
                fCompleted = FALSE;
            }
        }
        else if ( pServ->fIsNewProduct )
        {
            // new product, but we're aborting
            // make sure we don't leave any scraps behind
            DWORD winError;
            HKEY  hkeyInfo;

            winError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                     TEXT( "System\\CurrentControlSet\\Services\\LicenseInfo" ),
                                     0,
                                     KEY_ALL_ACCESS,
                                     &hkeyInfo );

            if ( ERROR_SUCCESS == winError )
            {
                RegDeleteKey( hkeyInfo, pServ->pszService );
                RegCloseKey( hkeyInfo );
            }
        }

        if (fCompleted)
        {
            FreeServiceEntry( pServ );
            EndDialog( hwndDlg, fSave );
        }
    }
}


//-------------------------------------------------------------------
//
//  Function: OnSetServiceMode
//
//  Summary;
//      Handle the users request to change service mode
//
//  Aruments;
//      hwndDlg [in] - hwnd of dialog
//      pszComputer [in] - compter to confirm mode change against
//      pServ [in] - The service the request was made agianst
//      idCtrl [in] - the control id that was pressed to make this request
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

void OnSetServiceMode( HWND hwndDlg, LPCWSTR pszComputer, PSERVICEENTRY pServ, WORD idCtrl )
{
    LICENSE_MODE lmOld = pServ->lm;

    BOOL fChanged = FALSE;
    BOOL fDisplay = TRUE;

    if (idCtrl == IDC_PERSEAT)
    {
        fChanged = (pServ->lm != LICMODE_PERSEAT);
        pServ->lm = LICMODE_PERSEAT;    
        fDisplay = (IsDlgButtonChecked(hwndDlg, IDC_PERSERVER) == BST_UNCHECKED);
    }

    if (idCtrl == IDC_PERSERVER)
    {
        fChanged = (pServ->lm != LICMODE_PERSERVER);
        pServ->lm = LICMODE_PERSERVER;
        fDisplay = (IsDlgButtonChecked(hwndDlg, IDC_PERSEAT) == BST_UNCHECKED);
    }

    // only check for violation the first time the user switches
    if (fChanged)
    {
        if (fDisplay)
        {
            if (!ServiceViolation(hwndDlg, pszComputer, pServ))
                return;
            else
            {
                if (idCtrl == IDC_PERSEAT)
                    SetFocus(GetDlgItem(hwndDlg, IDC_PERSERVER));
                if (idCtrl == IDC_PERSERVER)
                    SetFocus(GetDlgItem(hwndDlg, IDC_PERSEAT));
            }
        }

        pServ->lm = lmOld;
        InitDialogForService( hwndDlg, pServ );
    }
}

//-------------------------------------------------------------------
//
//  Function: OnSpinButton
//
//  Summary;
//      Handle the events from user interactions with the spin control
//
//  Arguments;
//      hwndDlg [in] - hwnd of dialog
//      wAction [in] - spin control event
//      pServ [in] - current service selected
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

void OnSpinButton( HWND hwndDlg, WORD wAction, PSERVICEENTRY pServ )
{
    HWND hwndCount = GetDlgItem( hwndDlg, IDC_USERCOUNT);
    INT  nValue;
    BOOL fValidAction = TRUE;

    nValue = pServ->dwLimit;

    switch (wAction)
    {
    case SB_LINEUP:
        nValue++;
        break;

    case SB_LINEDOWN:
        nValue--;
        break;

    case SB_PAGEUP:
        nValue += PERSERVER_PAGE;
        break;

    case SB_PAGEDOWN:
        nValue -= PERSERVER_PAGE;
        break;

    case SB_TOP:
        nValue = PERSERVER_MAX;
        break;

    case SB_BOTTOM:
        nValue = PERSERVER_MIN;
        break;

    default:
        fValidAction = FALSE;
        break;
    }
    if (fValidAction)
    {
        nValue = max( PERSERVER_MIN, nValue );
        nValue = min( PERSERVER_MAX, nValue );

        if (pServ->dwLimit == (DWORD)nValue)
        {
            MessageBeep( MB_VALUELIMIT );
        }
        else
        {
            pServ->dwLimit = nValue;
            SetDlgItemInt( hwndDlg, IDC_USERCOUNT, pServ->dwLimit, FALSE );
        }
        SetFocus( hwndCount );
        SendMessage( hwndCount, EM_SETSEL, 0, -1 );
    }
}

//-------------------------------------------------------------------
//
//  Function: UpdatePerServerLicenses
//
//  Summary;
//      Update the number of per server licenses displayed in the
//      dialog with the proper value.
//
//  Arguments;
//      hwndDlg [in] - hwnd of dialog
//      pServ [in] - current service selected
//
//  History;
//      Dec-19-95  JeffParh  Created
//
//-------------------------------------------------------------------

static void UpdatePerServerLicenses( HWND hwndDlg, PSERVICEENTRY pServ )
{
   LLS_HANDLE  hLls;
   DWORD       dwError;
   BOOL        fIsSecure;
   BOOL        fUseRegistry;

   fUseRegistry = TRUE;

   dwError = LlsConnect( pServ->pszComputer, &hLls );

   if ( ERROR_SUCCESS == dwError )
   {
      if ( pServ->fIsNewProduct )
      {
         dwError = LlsProductSecurityGet( hLls, pServ->pszDisplayName, &fIsSecure );

         if (    ( ERROR_SUCCESS == dwError )
              && fIsSecure                    )
         {
            dwError = LlsProductLicensesGet( hLls, pServ->pszDisplayName, LLS_LICENSE_MODE_PER_SERVER, &pServ->dwLimit );

            if ( ERROR_SUCCESS == dwError )
            {
               fUseRegistry = FALSE;
            }
         }
      }
      else
      {
         dwError = LlsProductLicensesGet( hLls, pServ->pszDisplayName, LLS_LICENSE_MODE_PER_SERVER, &pServ->dwLimit );

         if ( ERROR_SUCCESS == dwError )
         {
            fUseRegistry = FALSE;
         }
      }

      LlsClose( hLls );
   }

   if ( fUseRegistry )
   {
      CLicRegLicenseService cLicServKey;

      cLicServKey.SetService( pServ->pszService );
      cLicServKey.Open( NULL, FALSE );

      cLicServKey.GetUserLimit( pServ->dwLimit );

      cLicServKey.Close();
   }

   SetDlgItemInt( hwndDlg, IDC_USERCOUNT, pServ->dwLimit, FALSE );
   UpdateWindow( hwndDlg );
}

//-------------------------------------------------------------------
//
//  Function: OnAddLicenses
//
//  Summary;
//      Handle the BN_CLICKED message from the Add Licenses button.
//
//  Arguments;
//      hwndDlg [in] - hwnd of dialog
//      pServ [in] - current service selected
//
//  History;
//      Dec-19-95  JeffParh  Created
//
//-------------------------------------------------------------------

void OnAddLicenses( HWND hwndDlg, PSERVICEENTRY pServ )
{
   LPSTR    pszAscProductName;
   LPSTR    pszAscServerName = NULL;
   CHAR     szAscServerName[ 3 + MAX_PATH ];
   HRESULT hr;
   size_t  cch;

    cch = 1 + lstrlen(pServ->pszDisplayName);
   pszAscProductName = (LPSTR) LocalAlloc( LPTR, cch );

   if ( NULL != pszAscProductName )
   {
      hr = StringCchPrintfA(pszAscProductName, cch, "%ls", pServ->pszDisplayName);
      if (S_OK != hr)
         return;
      if ( NULL != pServ->pszComputer )
      {
         hr = StringCbPrintfA(szAscServerName, sizeof(szAscServerName), "%ls", pServ->pszComputer );
         if (S_OK != hr)
            return;
         pszAscServerName = szAscServerName;
      }

      CCFCertificateEnterUI( hwndDlg, pszAscServerName, pszAscProductName, "Microsoft", CCF_ENTER_FLAG_PER_SERVER_ONLY, NULL );
      UpdatePerServerLicenses( hwndDlg, pServ );

      LocalFree( pszAscProductName );

      g_fWarned = TRUE;
   }
}

//-------------------------------------------------------------------
//
//  Function: OnRemoveLicenses
//
//  Summary;
//      Handle the BN_CLICKED message from the Remove Licenses button.
//
//  Arguments;
//      hwndDlg [in] - hwnd of dialog
//      pServ [in] - current service selected
//
//  History;
//      Dec-19-95  JeffParh  Created
//
//-------------------------------------------------------------------

void OnRemoveLicenses( HWND hwndDlg, PSERVICEENTRY pServ )
{
   LPSTR    pszAscProductName;
   LPSTR    pszAscServerName = NULL;
   CHAR     szAscServerName[ 3 + MAX_PATH ];
   HRESULT  hr;
   size_t   cch;

   cch = 1 + lstrlen(pServ->pszDisplayName);
   pszAscProductName = (LPSTR) LocalAlloc( LMEM_FIXED, cch );

   if ( NULL != pszAscProductName )
   {
      hr = StringCchPrintfA( pszAscProductName, cch, "%ls", pServ->pszDisplayName );
      if (S_OK  != hr)
         return;
      if ( NULL != pServ->pszComputer )
      {
         hr = StringCbPrintfA( szAscServerName, sizeof(szAscServerName), "%ls", pServ->pszComputer );
         if (S_OK != hr)
            return;
         pszAscServerName = szAscServerName;
      }

      CCFCertificateRemoveUI( hwndDlg, pszAscServerName, pszAscProductName, "Microsoft", NULL, NULL );
      UpdatePerServerLicenses( hwndDlg, pServ );

      LocalFree( pszAscProductName );
   }
}


//-------------------------------------------------------------------
//
//  Function: OnSetupInitDialog
//
//  Summary;
//      Handle the initialization of the Setup Dialog
//
//  Arguments;
//      hwndDlg [in] - the dialog to initialize
//      pszParams [in] - the dialog params to use to initialize
//      pServ [out] - the current service 
//
//  Return;
//      TRUE if succesful, otherwise false
//
//  Notes;
//
//  History;
//      Nov-11-1994 MikeMi  Created
//
//-------------------------------------------------------------------
#pragma warning (push)
#pragma warning (disable : 4127) //avoid warning on while false

BOOL OnSetupInitDialog( HWND hwndDlg, 
        PSETUPDLGPARAM psdParams, 
        PSERVICEENTRY& pServ )
{
    BOOL frt = TRUE;
    CLicRegLicense cLicKey;
    LONG lrt;
    INT  nrt;
    BOOL fNew;

    do
    {
        CenterDialogToScreen( hwndDlg );

        lrt = cLicKey.Open( fNew, psdParams->pszComputer );
        nrt = AccessOk( hwndDlg, lrt, FALSE );
        if (ERR_NONE != nrt)
        {
            EndDialog( hwndDlg, nrt );
            frt = FALSE;
            break;
        }

        pServ = CreateServiceEntry( psdParams->pszComputer,
                psdParams->pszService, 
                psdParams->pszFamilyDisplayName,
                psdParams->pszDisplayName );
        if (pServ == NULL)
        {
            LowMemoryDlg();
            EndDialog( hwndDlg, -2 );
            break;
        }
        if (NULL == psdParams->pszHelpFile)
        {
            HWND hwndHelp = GetDlgItem( hwndDlg, IDC_BUTTONHELP );
            // remove the help button
            EnableWindow( hwndHelp, FALSE );
            ShowWindow( hwndHelp, SW_HIDE );
        }
        if (psdParams->fNoExit)
        {
            HWND hwndExit = GetDlgItem( hwndDlg, IDCANCEL );
            // remove the ExitSetup button
            EnableWindow( hwndExit, FALSE );
            ShowWindow( hwndExit, SW_HIDE );
        }

        // set char limit on edit box
        InitUserEdit( hwndDlg );

        // make sure title static text is set for this service
        InitTitleText( hwndDlg, pServ );
        
        // defaul to PerServer with Focus on edit
        pServ->lm = LICMODE_PERSERVER;

        // change default for setup only
        // pServ->dwLimit = 1;

        InitDialogForService( hwndDlg, pServ );

        SetFocus( GetDlgItem( hwndDlg, IDC_PERSERVER ) );
    } while (FALSE); // used to remove gotos

    return( frt );
}
#pragma warning (pop) //4127

//-------------------------------------------------------------------
//
//  Function: OnCpaInitDialog
//
//  Summary;
//      Handle the initialization of the Control Panel Applet Dialog
//
//  Arguments;
//      hwndDlg [in] - the dialog to initialize
//      fEnableReplication [in] -
//      iSel [out] - the current service selected
//      pServ [out] - the current service 
//
//  Return;
//      TRUE if succesful, otherwise false
//
//  Notes;
//
//  History;
//      Nov-11-1994 MikeMi  Created
//      Mar-08-1995 MikeMi  Added removal of Replication button
//
//-------------------------------------------------------------------

BOOL OnCpaInitDialog( HWND hwndDlg, 
        BOOL fEnableReplication,
        LONG_PTR& iSel, 
        PSERVICEENTRY& pServ )
{
    BOOL frt = FALSE;
    CLicRegLicense cLicKey;
    LONG lrt;
    INT  nrt;
    BOOL fNew;

    lrt = cLicKey.Open( fNew );
    nrt = AccessOk( hwndDlg, lrt, TRUE );
    if (ERR_NONE == nrt)
    {
        DWORD i = 0;
        WCHAR szText[TEMPSTR_SIZE];
        DWORD cchText = TEMPSTR_SIZE;
        HWND hwndService =  GetDlgItem( hwndDlg, IDC_SERVICES);
        LONG_PTR lIndex;

        CenterDialogToScreen( hwndDlg );

        //
        // remove replication button if product used on pre 3.51
        //
        if (!fEnableReplication)
        {
            HWND hwndRep =  GetDlgItem( hwndDlg, IDC_CONFIGURE );

            EnableWindow( hwndRep, FALSE );
            ShowWindow( hwndRep, SW_HIDE );
        }

        // load the service names from the registry into combo box
        // Create service local state structures as we go
        //
        while (ERROR_SUCCESS == cLicKey.EnumService(i, szText, cchText ))
        {

            pServ = CreateServiceEntry( NULL, szText, L"<unknown>", L"<undefined>" );
            if (pServ == NULL)
            {
                LowMemoryDlg();
                EndDialog( hwndDlg, -2 );
                return( TRUE );
            }
            lIndex = SendMessage( hwndService, CB_ADDSTRING, 0, (LPARAM)pServ->pszDisplayName );
            SendMessage( hwndService, CB_SETITEMDATA, lIndex, (LPARAM)pServ );
            i++;
            cchText = TEMPSTR_SIZE;
        }
        cLicKey.Close();

        if (0 == i)
        {
            // no services installed
            //
            WCHAR szTitle[TEMPSTR_SIZE];

            LoadString(g_hinst, IDS_CPCAPTION, szTitle, TEMPSTR_SIZE);
            LoadString(g_hinst, IDS_NOSERVICES, szText, TEMPSTR_SIZE);
            MessageBox(hwndDlg, szText, szTitle, MB_OK|MB_ICONINFORMATION);
    
            frt = FALSE;
        }
        else
        {
            // make sure a service is selected and update dialog
            iSel  = SendMessage( hwndService, CB_GETCURSEL, 0, 0 );

            if (CB_ERR == iSel)
            {
                iSel = 0;                 
                SendMessage( hwndService, CB_SETCURSEL, iSel, 0 );
            }
            pServ = (PSERVICEENTRY)SendMessage( hwndService, CB_GETITEMDATA, iSel, 0 );

            // Set edit text chars limit
            InitUserEdit( hwndDlg );

            InitDialogForService( hwndDlg, pServ );
            frt = TRUE;
        }
    }
    if (!frt)
    {
        EndDialog( hwndDlg, -1 );
    }
    return( frt );
}

//-------------------------------------------------------------------
//
//  Function: dlgprocLICCPA
//
//  Summary;
//      The dialog procedure for the main Control Panel Applet Dialog
//
//  Arguments;
//      hwndDlg [in]    - handle of Dialog window 
//      uMsg [in]       - message                       
//      lParam1 [in]    - first message parameter
//      lParam2 [in]    - second message parameter       
//
//  Return;
//      message dependant
//
//  Notes;
//
//  History;
//      Nov-11-1994 MikeMi  Created
//      Mar-08-1995 MikeMi  Added removal of Replication button 
//                              from WM_INITDIALOG
//      Mar-14-95   MikeMi  Added F1 PWM_HELP message
//
//-------------------------------------------------------------------
INT_PTR CALLBACK dlgprocLICCPA( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    BOOL frt = FALSE;
    static PSERVICEENTRY pServ = NULL;
    static LONG_PTR iSel = 0;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        OnCpaInitDialog( hwndDlg, (BOOL)lParam , iSel, pServ );
        return( TRUE ); // use default keyboard focus
        break;

    case WM_COMMAND:
        switch (HIWORD( wParam ))
        {
        case BN_CLICKED:
            switch (LOWORD( wParam ))
            {
            case IDOK:
                frt = TRUE;  // use as save flag
                // intentional no break

            case IDCANCEL:
                OnCpaClose( hwndDlg, frt );
                frt = FALSE;
                break;

            case IDC_PERSEAT:
            case IDC_PERSERVER:
                OnSetServiceMode( hwndDlg, NULL, pServ, LOWORD(wParam) );
                break;

            case IDC_CONFIGURE:
                DialogBox(g_hinst, 
                        MAKEINTRESOURCE(IDD_CPADLG_LCACONF),
                        hwndDlg, 
                        dlgprocLICCPACONFIG );
                break;
            
            case IDC_BUTTONHELP:
                PostMessage( hwndDlg, PWM_HELP, 0, 0 );
                break;

            case IDC_ADD_LICENSES:
                OnAddLicenses( hwndDlg, pServ );
                break;

            case IDC_REMOVE_LICENSES:
                OnRemoveLicenses( hwndDlg, pServ );
                break;

            default:
                break;
            }
            break;

        case CBN_SELENDOK:
            if ((LICMODE_PERSERVER == pServ->lm) &&
                !EditValidate( hwndDlg, pServ ))
            {
                // reset back to original
                SendMessage( (HWND)lParam, CB_SETCURSEL, iSel, 0 );
                EditInvalidDlg( hwndDlg );
            }
            else
            {
                iSel  = SendMessage( (HWND)lParam, CB_GETCURSEL, 0, 0 );
                pServ = (PSERVICEENTRY)SendMessage( (HWND)lParam, CB_GETITEMDATA, iSel, 0 );
                InitDialogForService( hwndDlg, pServ );
            }
            break;

        case EN_UPDATE:
            if (IDC_USERCOUNT == LOWORD(wParam))
            {
                OnEditChange( hwndDlg, (HWND)(lParam),  pServ );
            }
            break;

        default:
            break;
        }
        break;
    case WM_VSCROLL:
        OnSpinButton( hwndDlg, LOWORD( wParam ), pServ );
        break;
   
    default:
        if (PWM_HELP == uMsg)
            HtmlHelp(hwndDlg, LICCPA_HTMLHELPFILE, HH_DISPLAY_TOPIC, (DWORD_PTR)LICCPA_CHOOSEMODE_HELPFILE);
        break;
    }
    return( frt );
}


//-------------------------------------------------------------------
//
//  Function: dlgprocLICSETUP
//
//  Summary;
//      The dialog procedure for the Setup entry point Dialog
//
//  Arguments;
//      hwndDlg [in]    - handle of Dialog window 
//      uMsg [in]       - message                       
//      lParam1 [in]    - first message parameter
//      lParam2 [in]    - second message parameter       
//
//  Return;
//      message dependant
//
//  Notes;
//
//  History;
//      Nov-11-1994 MikeMi  Created
//      Mar-14-95   MikeMi  Added F1 PWM_HELP message
//
//-------------------------------------------------------------------

INT_PTR CALLBACK dlgprocLICSETUP( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    BOOL frt = FALSE;
    static PSERVICEENTRY pServ;
    static PSETUPDLGPARAM psdParams;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        psdParams = (PSETUPDLGPARAM)lParam;
        OnSetupInitDialog( hwndDlg, psdParams, pServ );
        frt = FALSE; // we set the focus
        break;

    case WM_COMMAND:
        switch (HIWORD( wParam ))
        {
        case BN_CLICKED:
            switch (LOWORD( wParam ))
            {
            case IDOK:
                frt = TRUE;  // use as save flag
                // intentional no break

            case IDCANCEL:
                OnSetupClose( hwndDlg, frt, pServ, psdParams );
                frt = FALSE;
                break;

            case IDC_PERSEAT:
            case IDC_PERSERVER:
                OnSetServiceMode( hwndDlg, psdParams->pszComputer, pServ, LOWORD(wParam) );
                break;

            case IDC_BUTTONHELP:
                PostMessage( hwndDlg, PWM_HELP, 0, 0 );
                break;

            case IDC_ADD_LICENSES:
                OnAddLicenses( hwndDlg, pServ );
                break;

            case IDC_REMOVE_LICENSES:
                OnRemoveLicenses( hwndDlg, pServ );
                break;

            default:
                break;
            }
            break;

        case EN_UPDATE:
            if (IDC_USERCOUNT == LOWORD(wParam))
            {
                OnEditChange( hwndDlg, (HWND)(lParam),  pServ );
            }
            break;

        default:
            break;
        }
        break;

    case WM_VSCROLL:
        OnSpinButton( hwndDlg, LOWORD( wParam ), pServ );
        break;

    default:
        if (PWM_HELP == uMsg)
        {
            ::HtmlHelp( hwndDlg, LICCPA_HTMLHELPFILE, HH_DISPLAY_TOPIC,0);
        }
        break;
    }
    return( frt );
}


//-------------------------------------------------------------------
//
//  Function: OnPerSeatInitDialog
//
//  Summary;
//      Handle the initialization of the PerSeat only Setup Dialog
//
//  Arguments;
//      hwndDlg [in] - the dialog to initialize
//      psdParams [in] - used for the displayname and service name
//
//  Notes;
//
//  History;
//      Dec-08-1994 MikeMi  Created
//
//-------------------------------------------------------------------

void OnPerSeatInitDialog( HWND hwndDlg, PSETUPDLGPARAM psdParams )
{
    HWND hwndOK = GetDlgItem( hwndDlg, IDOK );
    CLicRegLicense cLicKey;
    BOOL fNew;
    LONG lrt;
    INT nrt;

    lrt = cLicKey.Open( fNew, psdParams->pszComputer );
    nrt = AccessOk( NULL, lrt, FALSE );
    if (ERR_NONE == nrt)
    {
        CenterDialogToScreen( hwndDlg );

        InitStaticWithService( hwndDlg, IDC_STATICTITLE, psdParams->pszDisplayName );
        InitStaticWithService2( hwndDlg, IDC_STATICINFO, psdParams->pszDisplayName );

        // disable OK button at start!
        EnableWindow( hwndOK, FALSE );

        // if help is not defined, remove the button
        if (NULL == psdParams->pszHelpFile)
        {
            HWND hwndHelp = GetDlgItem( hwndDlg, IDC_BUTTONHELP );

            EnableWindow( hwndHelp, FALSE );
            ShowWindow( hwndHelp, SW_HIDE );
        }
     }
     else
     {
        EndDialog( hwndDlg, nrt );
     }
}

//-------------------------------------------------------------------
//
//  Function: OnPerSeatSetupClose
//
//  Summary;
//      Do work needed when the Setup Dialog is closed.
//      Save to Reg the Service entry.
//
//  Arguments;
//      hwndDlg [in] - hwnd of dialog this close was requested on
//      fSave [in] - Save service to registry
//      psdParams [in] - used for the service name and displayname
//
//  History;
//      Nov-30-94   MikeMi  Created
//
//-------------------------------------------------------------------

void OnPerSeatSetupClose( HWND hwndDlg, BOOL fSave, PSETUPDLGPARAM psdParams ) 
{
    int nrt = fSave;

    if (fSave)
    {
        CLicRegLicenseService cLicServKey;

        cLicServKey.SetService( psdParams->pszService );
        cLicServKey.Open( psdParams->pszComputer );

        // configure license rule of one change from PerServer to PerSeat
        //
        cLicServKey.SetChangeFlag( TRUE );

        cLicServKey.SetUserLimit( 0 );
        cLicServKey.SetDisplayName( psdParams->pszDisplayName );
        cLicServKey.SetFamilyDisplayName( psdParams->pszFamilyDisplayName );
        cLicServKey.SetMode( LICMODE_PERSEAT );
        cLicServKey.Close();

        // register service at enterprise server
        ServiceRegister( psdParams->pszComputer,
                         psdParams->pszFamilyDisplayName,
                         psdParams->pszDisplayName );
    }

    EndDialog( hwndDlg, nrt );
}

//-------------------------------------------------------------------
//
//  Function: OnPerSeatAgree
//
//  Summary;
//      Handle the user interaction with the Agree Check box
//
//  Arguments;
//      hwndDlg [in] - the dialog to initialize
//
//  Return;
//      TRUE if succesful, otherwise false
//
//  Notes;
//
//  History;
//      Nov-11-1994 MikeMi  Created
//
//-------------------------------------------------------------------

void OnPerSeatAgree( HWND hwndDlg )
{
    HWND hwndOK = GetDlgItem( hwndDlg, IDOK );
    BOOL fChecked = !IsDlgButtonChecked( hwndDlg, IDC_AGREE );
    
    CheckDlgButton( hwndDlg, IDC_AGREE, fChecked );
    EnableWindow( hwndOK, fChecked );
}

//-------------------------------------------------------------------
//
//  Function: dlgprocPERSEATSETUP
//
//  Summary;
//      The dialog procedure for the PerSeat only Setup Dialog
//
//  Arguments;
//      hwndDlg [in]    - handle of Dialog window 
//      uMsg [in]       - message                       
//      lParam1 [in]    - first message parameter
//      lParam2 [in]    - second message parameter       
//
//  Return;
//      message dependant
//
//  Notes;
//
//  History;
//      Nov-11-1994 MikeMi  Created
//      Mar-14-95   MikeMi  Added F1 PWM_HELP message
//
//-------------------------------------------------------------------

INT_PTR CALLBACK dlgprocPERSEATSETUP( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    BOOL frt = FALSE;
    static PSETUPDLGPARAM psdParams;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        psdParams = (PSETUPDLGPARAM)lParam;
        OnPerSeatInitDialog( hwndDlg, psdParams );
        frt = TRUE; // we use the default focus
        break;

    case WM_COMMAND:
        switch (HIWORD( wParam ))
        {
        case BN_CLICKED:
            switch (LOWORD( wParam ))
            {
            case IDOK:
                frt = TRUE;  // use as save flag
                // intentional no break

            case IDCANCEL:
                OnPerSeatSetupClose( hwndDlg, frt, psdParams );
                frt = FALSE;
                break;

            case IDC_BUTTONHELP:
                PostMessage( hwndDlg, PWM_HELP, 0, 0 );
                break;

            case IDC_AGREE:
                OnPerSeatAgree( hwndDlg );
                break;

            default:
                break;
            }
            break;

        default:
            break;
        }
        break;

    default:
        if (PWM_HELP == uMsg)
        {
            ::HtmlHelp( hwndDlg, LICCPA_HTMLHELPFILE, HH_DISPLAY_TOPIC,0);
        }
        break;
    }
    return( frt );
}

//-------------------------------------------------------------------
//
//  Function: SetupDialog
//
//  Summary;
//      Init and raises main setup dialog.
//
//  Arguments;
//      hwndDlg [in]    - handle of Dialog window 
//      dlgParem [in]   - Setup params
//
//  Return;
//      1 - OK button was used to exit
//      0 - Cancel button was used to exit
//     -1 - General Dialog error
//
//  Notes;
//
//  History;
//      Dec-05-1994 MikeMi  Created
//
//-------------------------------------------------------------------

INT_PTR SetupDialog( HWND hwndParent, SETUPDLGPARAM& dlgParam )
{
   INT_PTR nError;

   nError = DialogBoxParam( g_hinst, 
                            MAKEINTRESOURCE(IDD_SETUPDLG), 
                            hwndParent, 
                            dlgprocLICSETUP,
                            (LPARAM)&dlgParam );

   return( nError );
} 

//-------------------------------------------------------------------
//
//  Function: PerSeatSetupDialog
//
//  Summary;
//      Init and raises Per Seat only setup dialog.
//
//  Arguments;
//      hwndDlg [in]    - handle of Dialog window 
//      dlgParem [in]   - Setup params
//
//  Return;
//      1 - OK button was used to exit
//      0 - Cancel button was used to exit
//     -1 - General Dialog error
//
//  Notes;
//
//  History;
//      Dec-05-1994 MikeMi  Created
//
//-------------------------------------------------------------------

INT_PTR PerSeatSetupDialog( HWND hwndParent, SETUPDLGPARAM& dlgParam )
{
    return( DialogBoxParam( g_hinst, 
            MAKEINTRESOURCE(IDD_SETUP2DLG), 
            hwndParent, 
            dlgprocPERSEATSETUP,
            (LPARAM)&dlgParam ) );
} 

//-------------------------------------------------------------------
//
//  Function: CpaDialog
//
//  Summary;
//      Init and Raise the main control panel applet dialog
//
//  Arguments;
//      hwndParent [in] - handle of parent window (CONTROL.EXE window)
//
//  Return;
//      1 - OK button was used to exit
//      0 - Cancel button was used to exit
//    -1 - General Dialog error
//
//  Notes;
//
//  History;
//      Dec-05-1994 MikeMi  Created
//      Mar-08-1995 MikeMi  Changed to only one Dialog Resource, Replication Button
//
//-------------------------------------------------------------------

INT_PTR CpaDialog( HWND hwndParent )
{
   INT_PTR nError;
   OSVERSIONINFO version;

   version.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
   GetVersionEx( &version );

   BOOL fReplicationEnabled;

   //
   // Only allow Replication Button on 3.51 and above
   //
   fReplicationEnabled = (    (version.dwMajorVersion > 3)
                           || (version.dwMajorVersion == 3 && version.dwMinorVersion >= 51) );
   nError = DialogBoxParam( g_hinst,
                            MAKEINTRESOURCE(IDD_CPADLG_CONFIGURE),
                            hwndParent,
                            dlgprocLICCPA,
                            (LPARAM)fReplicationEnabled );

   return( nError );
}

//-------------------------------------------------------------------
//
//  Function: UpdateReg
//
//  Summary;  
//      This function is used in unatteneded  setup modes, it will 
//      configure the registry with the values passed.
//
//  Arguments;
//      pszComputer [in] - computer name (maybe null for local)
//      pszService [in] - service key name
//      pszFamilyDisplayName [in] - family display name
//      pszDisplayName [in] - displayname
//      lm [in] - license mode
//      dwUsers [in] - number of conncurrent users
//
//  Return;
//     ERR_NONE - Successful
//     ERR_USERSPARAM - invalid users count
//     ERR_PERMISSIONDENIED - invalid access rights
//
//  Notes;
//
//  History;
//      Dec-09-1994 MikeMi  Created
//      Apr-26-95   MikeMi  Added Computer name and remoting
//
//-------------------------------------------------------------------

int UpdateReg( LPCWSTR pszComputer, 
        LPCWSTR pszService, 
        LPCWSTR pszFamilyDisplayName, 
        LPCWSTR pszDisplayName, 
        LICENSE_MODE lm, 
        DWORD dwUsers )
{
    int nrt = ERR_NONE;

    if (VALIDUSERCOUNT( dwUsers ))
    {
        CLicRegLicense cLicKey;
        LONG lrt;
        BOOL fNew;

        lrt = cLicKey.Open( fNew, pszComputer );
        nrt = AccessOk( NULL, lrt, FALSE );
        if (ERR_NONE == nrt)
        {
            CLicRegLicenseService cLicServKey;

            cLicServKey.SetService( pszService );
            cLicServKey.Open( pszComputer );

            // configure license rule of one change from PerServer to PerSeat
            //
            cLicServKey.SetChangeFlag( (LICMODE_PERSEAT == lm ) );

            cLicServKey.SetUserLimit( dwUsers );
            cLicServKey.SetDisplayName( pszDisplayName );
            cLicServKey.SetFamilyDisplayName( pszFamilyDisplayName );
            cLicServKey.SetMode( lm );
            cLicServKey.Close();
        }
    }
    else
    {
        nrt = ERR_USERSPARAM;
    }
    return( nrt );
}

//-------------------------------------------------------------------
//
//  Function: ServiceSecuritySet
//
//  Summary;
//      Set security on a given product such that it requires a
//      secure certificate for license entry.
//
//  Arguments;
//      pszComputer [in] - computer on which the license server resides
//      pszDisplayName [in] - display name for the service
//
//  History;
//      Dec-19-95  JeffParh  Created
//
//-------------------------------------------------------------------

int ServiceSecuritySet( LPWSTR pszComputer, LPWSTR pszDisplayName )
{
   int            nError;
   NTSTATUS       nt;
   LLS_HANDLE     hLls;

   // register the product as secure on the target server
   nt = LlsConnect( pszComputer, &hLls );

   if ( STATUS_SUCCESS != nt )
   {
      nError = ERR_NOREMOTESERVER;
   }
   else
   {
      if ( !LlsCapabilityIsSupported( hLls, LLS_CAPABILITY_SECURE_CERTIFICATES ) )
      {
         nError = ERR_DOWNLEVEL;
      }
      else
      {
         nt = LlsProductSecuritySetW( hLls, pszDisplayName );

         if ( STATUS_SUCCESS != nt )
         {
            nError = ERR_CERTREQFAILED;
         }
         else
         {
            nError = ERR_NONE;
         }
      }

      LlsClose( hLls );
   }

   // register the product as secure on the enterprise server
   // it is acceptable for this to fail (the enterprise server may
   // be downlevel)
   if ( ERR_NONE == nError )
   {
      PLLS_CONNECT_INFO_0  pConnectInfo = NULL;

      nt = LlsConnectEnterprise( pszComputer, &hLls, 0, (LPBYTE *) &pConnectInfo );

      if ( STATUS_SUCCESS == nt )
      {
         LlsFreeMemory( pConnectInfo );

         if ( LlsCapabilityIsSupported( hLls, LLS_CAPABILITY_SECURE_CERTIFICATES ) )
         {
            LlsProductSecuritySetW( hLls, pszDisplayName );
         }

         LlsClose( hLls );
      }
   }

   return nError;
}

//-------------------------------------------------------------------
//
//  Function: ServiceRegister
//
//  Summary;
//      Register a service at the enterprise server corresponding to
//      the given server so that per seat licenses may be added
//      immediately, rather than it taking up until the next
//      replication cycle for the product to be listed.
//
//  Arguments;
//      pszComputer [in] - computer for which to register the service 
//      pszFamilyDisplayName [in] - family display name of the service
//      pszDisplayName [in] - display name of the service
//
//  History;
//      Dec-19-95  JeffParh  Created
//
//-------------------------------------------------------------------

static int ServiceRegister( LPWSTR pszComputer,
                            LPWSTR pszFamilyDisplayName,
                            LPWSTR pszDisplayName )
{
   int                  nError;
   NTSTATUS             nt;
   LLS_HANDLE           hLls;
   PLLS_CONNECT_INFO_0  pConnectInfo = NULL;

   // register the product as secure on the enterprise server
   nt = LlsConnectEnterprise( pszComputer, &hLls, 0, (LPBYTE *) &pConnectInfo );

   if ( STATUS_SUCCESS != nt )
   {
      nError = ERR_NOREMOTESERVER;
   }
   else
   {
      LlsFreeMemory( pConnectInfo );

      nt = LlsProductAdd( hLls, pszFamilyDisplayName, pszDisplayName, TEXT( "" ) );

      LlsClose( hLls );

      if ( STATUS_SUCCESS != nt )
      {
         nError = ERR_NOREMOTESERVER;
      }
      else
      {
         nError = ERR_NONE;
      }
   }

   return nError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\liccpa\licsetup.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation.
All rights reserved

Module Name:

   licsetup.cpp

Abstract:

   This module exports a function, LicenseSetupRequestWizardPages, which
   gives NT Setup a wizard page for licensing to use in system setup (if
   licensing should be installed).

   This wizard page is responsible for all license system configuration,
   including:
      o  Creating the LicenseService
      o  Creating the ...\CurrentControlSet\Services\LicenseService key and
         its values.  (This key contains all configuration information for the
         LicenseService.)
      o  Creating the ...\CurrentControlSet\Services\LicenseInfo key and its
         values.  (This key contains all product-specific license info.)
      o  Creating the appropriate registry key to register the LicenseService
         with the EventLog.

   Portions of this module were extracted from SETUP (specifically from
   \nt\private\windows\setup\syssetup\license.c).

Author:

   Jeff Parham (jeffparh)     15-Apr-1996

Revision History:

   Jeff Parham (jeffparh)     17-Jul-1997
      Added KSecDD to FilePrint services table for SFM

--*/

#include <windows.h>
#include <commctrl.h>
#include <setupapi.h>
#include <syssetup.h>
#include <setupbat.h>
#include <stdlib.h>
#include <htmlhelp.h>
#include <Accctrl.h>
#include <aclapi.h>
#include "liccpa.hpp"
#include "help.hpp"
#include "clicreg.hpp"
#include "config.hpp"
#include "resource.h"
#include "pridlgs.hpp"
#include "special.hpp"
#include <objbase.h>
#include <iads.h>
#include <ole2.h>
#include <oaidl.h>
#include <adshlp.h>

#include <strsafe.h>

#define ROOT_DSE_PATH       L"LDAP://RootDSE"
#define CONFIG_CNTNR        L"ConfigurationNamingContext"


//============================================================================
//
//    MACROS
//

// used by setup tests?  simulates a click on the NEXT button
#define  WM_SIMULATENEXT      ( WM_USER + 287 )

// begin or end a wait cursor
#define  WM_BEGINWAITCURSOR   ( WM_USER + 300 )
#define  WM_ENDWAITCURSOR     ( WM_USER + 301 )

#define LICENSEINFO_PATH  TEXT("MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LicenseInfo")
#define LICENSESERVICE_PATH  TEXT("MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LicenseService\\Parameters")
#define DONTLOAD_PATH TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Control Panel\\don't load")


// number of license wizard pages
const DWORD    NUM_LICENSE_PAGES    = 1;

// limits for per server licenses entered from the edit box in the
// license mode page
const int      PERSERVER_EDIT_MAX   = 9999;
const int      PERSERVER_EDIT_MIN   = 5;

// the number of chars to represent PERSERVER_EDIT_MAX
const int      PERSERVER_EDIT_WIDTH = 4;


//============================================================================
//
//    LOCAL PROTOTYPES
//

// decides, based on the setup type, whether licensing is installed
static   BOOL   LicenseSetupDisplayLicensePagesQuery( PINTERNAL_SETUP_DATA );

// License mode page functions
static   HPROPSHEETPAGE    LicenseSetupModePageGet( PINTERNAL_SETUP_DATA );
static   INT_PTR CALLBACK     LicenseSetupModeDlgProc( HWND, UINT, WPARAM, LPARAM );

// License mode page Windows message handlers
static   void   LicenseSetupModeOnInitDialog( HWND, LPARAM, PINTERNAL_SETUP_DATA *, LPBOOL, LPDWORD, LPDWORD );
static   void   LicenseSetupModeOnSetActive( HWND, PINTERNAL_SETUP_DATA, LPBOOL, LPDWORD );
static   void   LicenseSetupModeOnSetLicenseMode( HWND, BOOL, DWORD );
static   void   LicenseSetupModeOnEditUpdate( HWND, HWND, BOOL, LPDWORD );
static   void   LicenseSetupModeOnWaitCursor( HWND, BOOL, LPDWORD );
static   BOOL   LicenseSetupModeOnSetCursor( HWND, WORD, DWORD );
static   void   LicenseSetupModeOnNext( HWND, PINTERNAL_SETUP_DATA, BOOL, DWORD );
static   void   LicenseSetupModeOnHelp( HWND );
static   void   LicenseSetupModeOnSimulateNext( HWND );
static   void   LicenseSetupModeOnKillActive( HWND );
#ifndef SPECIAL_USERS
static   BOOL   LicenseSetupModeDoUnattended( HWND, PINTERNAL_SETUP_DATA, LPBOOL, LPDWORD );
#endif //SPECIAL_USERS

// License configuration save functions
static   DWORD  LicenseSetupWrite( BOOL, DWORD );
static   DWORD  LicenseSetupWriteKeyLicenseInfo( BOOL, DWORD );
static   DWORD  LicenseSetupWriteKeyLicenseService( BOOL fWriteParametersKey );
static   DWORD  LicenseSetupWriteKeyEventLog();
static   DWORD  LicenseSetupWriteService( BOOL * fCreated );

// utility functions
static   int    MessageBoxFromStringID( HWND, UINT, UINT, UINT );


void CreateDirectoryWithAccess();

void CreateFileWithAccess();

void HideAppletIfBlade();

static DWORD SetRight( IADs *, LONG, LONG, LONG, LPOLESTR, LPOLESTR );
void ModifyRegistryWithWriteAccess();

BOOL IsRestrictedSmallBusSrv( void );
#define SBS_SPECIAL_USERS   10

//============================================================================
//
//    GLOBAL IMPLEMENTATION
//

BOOL
APIENTRY
LicenseSetupRequestWizardPages(
   HPROPSHEETPAGE *        paPropSheetPages,
   UINT *                  pcPages,
   PINTERNAL_SETUP_DATA    pSetupData )
{
   BOOL  fSuccess = FALSE;
   BOOL  fDisplayLicensePages;

   // validate params
   if (    ( NULL != pcPages                                       )
        && ( NULL != pSetupData                                    )
        && ( sizeof( INTERNAL_SETUP_DATA ) == pSetupData->dwSizeOf ) )
   {
      fDisplayLicensePages = LicenseSetupDisplayLicensePagesQuery( pSetupData );

      if ( NULL == paPropSheetPages )
      {
         // request for number of pages only
         *pcPages = fDisplayLicensePages ? NUM_LICENSE_PAGES : 0;
         fSuccess = TRUE;
      }
      else
      {
         // request for actual pages
         if ( !fDisplayLicensePages )
         {
            // no pages needed
            *pcPages = 0;
            fSuccess = TRUE;
         }
         else if ( *pcPages >= NUM_LICENSE_PAGES )
         {
            // create and return pages
            paPropSheetPages[ 0 ] = LicenseSetupModePageGet( pSetupData );

            if ( NULL != paPropSheetPages[ 0 ] )
            {
               *pcPages = NUM_LICENSE_PAGES;
               fSuccess = TRUE;
            }
         }
      }
   }

   return fSuccess;
}


//============================================================================
//
//    LOCAL IMPLEMENTATIONS
//

static
BOOL
LicenseSetupDisplayLicensePagesQuery(
   PINTERNAL_SETUP_DATA    pSetupData )
//
// The following code was extracted and modified from
//    \nt\private\windows\setup\syssetup\license.c
// in setup.  It returns TRUE iff the licensing wizard pages should be
// displayed as a part of setup.
//
{
   BOOL     fDisplayLicensePages;

   if ( PRODUCT_WORKSTATION == pSetupData->ProductType )
   {
      //
      //  If installing a workstation, then do not display the licensing page
      //
      fDisplayLicensePages = FALSE;
   }
   else
   {
      if ( !( pSetupData->OperationFlags & SETUPOPER_NTUPGRADE ) )
      {
         //
         //  The licensing page needs to be displayed on a clean install
         //  of a server
         //
         fDisplayLicensePages = TRUE;
      }
      else
      {
         //
         //  If upgrading a server, find out if it was already licensed
         //  (NT 3.51 and later). If it was, then do not display the
         //  licensing page.
         //  We find out whether or not the system was licensed by looking
         //  at a value entry in the registry.
         //  Note that NT 3.1 and 3.5 will never have this value in the
         //  registry, and in these cases the licensing page needs to be
         //  displayed.
         //

         DWORD                   winStatus;
         CLicRegLicenseService   FilePrintService( FILEPRINT_SERVICE_REG_KEY );

         winStatus = FilePrintService.Open( NULL, FALSE );

         if ( ERROR_SUCCESS != winStatus )
         {
            fDisplayLicensePages = TRUE;
         }
         else
         {
            LICENSE_MODE   LicenseMode;

            winStatus = FilePrintService.GetMode( LicenseMode );

            if (    ( ERROR_SUCCESS != winStatus              )
                 || (    ( LICMODE_PERSEAT   != LicenseMode )
                      && ( LICMODE_PERSERVER != LicenseMode ) ) )
            {
               fDisplayLicensePages = TRUE;
            }
            else
            {
               // set FlipAllow value if it's not already set (a setup bug in
               // the betas of NT 4.0 caused this value to be absent)
               FilePrintService.CanChangeMode();

               // add KSecDD to FilePrint services table if it isn't there already
               HKEY  hkeySFM;
               DWORD dwDisposition;

               winStatus = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                                           TEXT( "System\\CurrentControlSet\\Services\\LicenseService\\FilePrint\\KSecDD" ),
                                           0,
                                           NULL,
                                           0,
                                           KEY_ALL_ACCESS,
                                           NULL,
                                           &hkeySFM,
                                           &dwDisposition );

               if ( ERROR_SUCCESS == winStatus )
               {
                  RegCloseKey( hkeySFM );
               }

               // Change FilePrint License name from Windows NT to Windows.

               CLicRegLicenseService   l_FilePrintService(
                                                   FILEPRINT_SERVICE_REG_KEY );

               winStatus = l_FilePrintService.Open( NULL, FALSE );

               if ( ERROR_SUCCESS == winStatus )
               {
                   winStatus = l_FilePrintService.SetFamilyDisplayName(
                                       FILEPRINT_SERVICE_FAMILY_DISPLAY_NAME );

                   if ( ERROR_SUCCESS == winStatus )
                   {
                       winStatus = l_FilePrintService.SetDisplayName(
                                              FILEPRINT_SERVICE_DISPLAY_NAME );
                   }
               }

                //
                // makarp: setting fDisplayLicensePages to true is wrong, because in such case
                // the pages will be displayed, and the original settings will be lost.
                //
                // fDisplayLicensePages = TRUE;

                //
                // instead we do the stuff we want to explicitely here.
                //
                BOOL bFlag = FALSE;
                LicenseSetupWriteService(&bFlag);
                HideAppletIfBlade();
                CreateDirectoryWithAccess();
                CreateFileWithAccess();
                ModifyRegistryWithWriteAccess();

                fDisplayLicensePages = FALSE;
            }
         }
      }
   }

   return fDisplayLicensePages;
}


static
HPROPSHEETPAGE
LicenseSetupModePageGet(
   PINTERNAL_SETUP_DATA    pSetupData )
//
// Returns an HPROPSHEETPAGE for the license mode wizard page, or
// NULL if error.
//
{
    HPROPSHEETPAGE   hpsp;
    PROPSHEETPAGE    psp;
    TCHAR    szHeader[256];
    TCHAR    szSubHeader[512];

    psp.dwSize       = sizeof( psp );
    psp.dwFlags      = PSP_USETITLE | PSP_HASHELP | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance    = g_hinst;
    psp.pszTemplate  = MAKEINTRESOURCE( IDD_SETUP_LICENSE_MODE_PAGE );
    psp.hIcon        = NULL;
    psp.pfnDlgProc   = LicenseSetupModeDlgProc;
    psp.lParam       = (LPARAM) pSetupData;
    psp.pszTitle     = pSetupData->WizardTitle;

    szHeader[0] = L'\0';
    szSubHeader[0] = L'\0';

    LoadString( g_hinst,
                  IDS_SETUP_HEADER,
                  szHeader,
                  sizeof( szHeader ) / sizeof( *szHeader ) );

    LoadString( g_hinst,
                  IDS_SETUP_SUBHEADER,
                  szSubHeader,
                  sizeof( szSubHeader ) / sizeof( *szSubHeader ) );

    psp.pszHeaderTitle = szHeader;
    psp.pszHeaderSubTitle = szSubHeader;


    hpsp = CreatePropertySheetPage( &psp );

    return hpsp;
}


static
INT_PTR
CALLBACK
LicenseSetupModeDlgProc(
   HWND     hwndPage,
   UINT     msg,
   WPARAM   wParam,
   LPARAM   lParam )
//
// Dialog procedure for the license mode wizard page.
//
{
   // static data initialized by WM_INITDIALOG
   static   PINTERNAL_SETUP_DATA    pSetupData = NULL;
   static   BOOL                    fLicensePerServer;
   static   DWORD                   cPerServerLicenses;
   static   DWORD                   cWaitCursor;

   BOOL     fReturn = TRUE;

   switch ( msg )
   {
   case WM_INITDIALOG:
      LicenseSetupModeOnInitDialog( hwndPage, lParam, &pSetupData, &fLicensePerServer, &cPerServerLicenses, &cWaitCursor );
      break;

   case WM_SIMULATENEXT:
      LicenseSetupModeOnSimulateNext( hwndPage );
      break;

   case WM_BEGINWAITCURSOR:
      LicenseSetupModeOnWaitCursor( hwndPage, TRUE, &cWaitCursor );
      break;

   case WM_ENDWAITCURSOR:
      LicenseSetupModeOnWaitCursor( hwndPage, FALSE, &cWaitCursor );
      break;

   case WM_SETCURSOR:
      LicenseSetupModeOnSetCursor( hwndPage, LOWORD( lParam ), cWaitCursor );
      break;

   case WM_COMMAND:
      switch ( HIWORD( wParam ) )
      {
      case BN_CLICKED:
         switch ( LOWORD( wParam ) )
         {
         case IDC_PERSEAT:
            fLicensePerServer = FALSE;
            LicenseSetupModeOnSetLicenseMode( hwndPage, fLicensePerServer, cPerServerLicenses );
            break;

         case IDC_PERSERVER:
            fLicensePerServer = TRUE;
            LicenseSetupModeOnSetLicenseMode( hwndPage, fLicensePerServer, cPerServerLicenses );
            break;
         }
         break;

      case EN_UPDATE:
         if ( IDC_USERCOUNT == LOWORD( wParam ) )
         {
            LicenseSetupModeOnEditUpdate( hwndPage, (HWND) lParam, fLicensePerServer, &cPerServerLicenses );
         }
         break;

      default:
         fReturn = FALSE;
         break;
      }
      break;

   case WM_NOTIFY:
      {
         NMHDR *  pNmHdr;

         pNmHdr = (NMHDR *)lParam;

         switch ( pNmHdr->code )
         {
         case PSN_SETACTIVE:
            LicenseSetupModeOnSetActive( hwndPage, pSetupData, &fLicensePerServer, &cPerServerLicenses );
            break;

         case PSN_KILLACTIVE:
            LicenseSetupModeOnKillActive( hwndPage );
            break;

         case PSN_WIZNEXT:
         case PSN_WIZFINISH:
            LicenseSetupModeOnNext( hwndPage, pSetupData, fLicensePerServer, cPerServerLicenses );
            break;

         case PSN_HELP:
            LicenseSetupModeOnHelp( hwndPage );
            break;

         default:
            fReturn = FALSE;
            break;
         }
      }

      break;

   default:
      fReturn = FALSE;
   }

   return fReturn;
}


static
void
LicenseSetupModeOnInitDialog(
   HWND                    hwndPage,
   LPARAM                  lParam,
   PINTERNAL_SETUP_DATA *  ppSetupData,
   LPBOOL                  pfLicensePerServer,
   LPDWORD                 pcPerServerLicenses,
   LPDWORD                 pcWaitCursor )
//
// Message handler for WM_INITDIALOG
//
{
   // initialize static data
   *ppSetupData         = (PINTERNAL_SETUP_DATA) ( (LPPROPSHEETPAGE) lParam )->lParam;
   *pcPerServerLicenses = 5;
   *pfLicensePerServer  = TRUE;
   *pcWaitCursor        = 0;

   // limit license count edit text length
   SendMessage( GetDlgItem( hwndPage, IDC_USERCOUNT ), EM_LIMITTEXT, PERSERVER_EDIT_WIDTH, 0 );

   // limit license count up-down range
   LONG     lRange;

   lRange = (LPARAM) MAKELONG( (short) PERSERVER_EDIT_MAX, (short) PERSERVER_EDIT_MIN );
   SendMessage( GetDlgItem( hwndPage, IDC_USERCOUNTARROW ), UDM_SETRANGE, 0, (LPARAM) lRange );

   // initialize for default license mode
   LicenseSetupModeOnSetLicenseMode( hwndPage, *pfLicensePerServer, *pcPerServerLicenses );
}


static
void
LicenseSetupModeOnSetActive(
   HWND                    hwndPage,
   PINTERNAL_SETUP_DATA    pSetupData,
   LPBOOL                  pfLicensePerServer,
   LPDWORD                 pcPerServerLicenses )
//
// Notification handler for PSN_SETACTIVE
//
{
    static BOOL fFirstTime = TRUE;
    BOOL  fSkipPage;
    OSVERSIONINFOEX ovi;
    BOOL fBlade = FALSE;    

    ovi.dwOSVersionInfoSize = sizeof(ovi);
    if (GetVersionEx((OSVERSIONINFO *) &ovi))
    {
        if( ovi.wSuiteMask & VER_SUITE_BLADE )
        {
            fBlade = TRUE;           
        }
    }   

#ifdef SPECIAL_USERS
    *pfLicensePerServer  = TRUE;
    *pcPerServerLicenses = SPECIAL_USERS;
    fSkipPage            = TRUE;
#else

    if ( fBlade || IsRestrictedSmallBusSrv() )
    {
      *pfLicensePerServer  = TRUE;
      *pcPerServerLicenses = SBS_SPECIAL_USERS;
      fSkipPage            = TRUE;
    }
    else if ( pSetupData->OperationFlags & SETUPOPER_BATCH )
    {
      // operating in unattended mode; attempt to get all answers
      // from the unattend configuration file
      fSkipPage = LicenseSetupModeDoUnattended( hwndPage,
                                                pSetupData,
                                                pfLicensePerServer,
                                                pcPerServerLicenses );
      if ( !fSkipPage )
      {
        // Set defaults from unattended file
        LicenseSetupModeOnSetLicenseMode( hwndPage,
                                          *pfLicensePerServer,
                                          *pcPerServerLicenses );
        //
        // makarp: setting skippage to true is wrong, because we do not want to skip page.
        // we came here because we did not find sufficent answers in answer file.
        //
        // fSkipPage = TRUE;
      }
    }
    else
    {
      // operating in interactive mode; get answers from user
      fSkipPage = FALSE;
    }
#endif
    

   HWND hwndSheet = GetParent( hwndPage );

   if ( fSkipPage )
   {

    if (fFirstTime)
    {
      fFirstTime = FALSE;
      // skip page
      // Only the first time do we need to do the processing which happens on next
      PostMessage( hwndSheet, PSM_PRESSBUTTON, (WPARAM)PSBTN_NEXT, 0 );
    }
    else
    {
      // After the first time the processing is already done and we don't have to do anything
      // This also solves the problem where the page needs to be skipped when the user clicks back
      // on a later page and this pages needs to be skipped.
      SetWindowLongPtr( hwndPage, DWLP_MSGRESULT, (LONG_PTR)-1 );
      return;
    }

   }
   else
   {
      // display page

      // hide Cancel button
      HWND hwndCancel = GetDlgItem( hwndSheet, IDCANCEL );
      EnableWindow( hwndCancel, FALSE);
      ShowWindow(   hwndCancel, SW_HIDE);

      PropSheet_SetWizButtons( hwndSheet, PSWIZB_NEXT | PSWIZB_BACK );

      if (pSetupData)
      {
        pSetupData->ShowHideWizardPage(TRUE);
      }
   }

   // success
   SetWindowLongPtr( hwndPage, DWLP_MSGRESULT, (LONG_PTR)0 );
}


static
void
LicenseSetupModeOnSetLicenseMode(
   HWND     hwndPage,
   BOOL     fToPerServer,
   DWORD    cPerServerLicenses )
//
// Handles changing the page to signify that the given license mode
// is selected.
//
{
   HWND hwndCount = GetDlgItem( hwndPage, IDC_USERCOUNT );
   HWND hwndSpin  = GetDlgItem( hwndPage, IDC_USERCOUNTARROW );

   // set radio button states
   CheckDlgButton( hwndPage, IDC_PERSEAT,   !fToPerServer );
   CheckDlgButton( hwndPage, IDC_PERSERVER,  fToPerServer );

   // set user count edit control
   if ( fToPerServer )
   {
      // display per server count
      SetDlgItemInt( hwndPage, IDC_USERCOUNT, cPerServerLicenses, FALSE );
      SetFocus( hwndCount );
      SendMessage( hwndCount, EM_SETSEL, 0, -1 );
   }
   else
   {
      // remove per server count
      SetDlgItemText( hwndPage, IDC_USERCOUNT, TEXT( "" ) );
   }

   // display count up-down and edit box iff per server mode is selected
   EnableWindow( hwndCount, fToPerServer );
   EnableWindow( hwndSpin,  fToPerServer );
}


static
void
LicenseSetupModeOnEditUpdate(
   HWND     hwndPage,
   HWND     hwndCount,
   BOOL     fLicensePerServer,
   LPDWORD  pcPerServerLicenses )
//
// Command handler for EN_UPDATE of count edit box
//
{
   if ( fLicensePerServer )
   {
      BOOL  fTranslated;
      UINT  nValue;
      BOOL  fModified = FALSE;

      nValue = GetDlgItemInt( hwndPage, IDC_USERCOUNT, &fTranslated, FALSE );

      if ( fTranslated )
      {
         // count translated; ensure its within the valid range
         if ( PERSERVER_EDIT_MAX < nValue )
         {
            // too big
            nValue    = PERSERVER_EDIT_MAX;
            fModified = TRUE;
         }

         *pcPerServerLicenses = nValue;
      }
      else
      {
         // count couldn't be translated; reset to last value
         nValue    = *pcPerServerLicenses;
         fModified = TRUE;
      }

      if ( fModified )
      {
         // text in edit box is invalid; change it to the proper value
         SetDlgItemInt( hwndPage, IDC_USERCOUNT, nValue, FALSE );
         SetFocus( hwndCount );
         SendMessage( hwndCount, EM_SETSEL, 0, -1 );
         MessageBeep( MB_VALUELIMIT );
      }
   }
}


static
void
LicenseSetupModeOnWaitCursor(
   HWND     hwndDlg,
   BOOL     fWait,
   LPDWORD  pcWaitCursor )
//
// Handler for WM_BEGINWAITCURSOR / WM_ENDWAITCURSOR
//
{
   if ( fWait )
   {
      (*pcWaitCursor)++;

      if ( 1 == (*pcWaitCursor) )
      {
         // display wait cursor
         SetCursor( LoadCursor( NULL, MAKEINTRESOURCE( IDC_WAIT ) ) );
      }
   }
   else
   {
      if ( 0 < *pcWaitCursor )
      {
         (*pcWaitCursor)--;
      }

      if ( 0 == *pcWaitCursor )
      {
         // display regular cursor
         SetCursor( LoadCursor( NULL, MAKEINTRESOURCE( IDC_ARROW ) ) );
      }
   }

   // success
   SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, (LONG_PTR)*pcWaitCursor );
}


static
BOOL
LicenseSetupModeOnSetCursor(
   HWND     hwndDlg,
   WORD     nHitTest,
   DWORD    cWaitCursor )
//
// Handler for WM_SETCURSOR
//
{
   BOOL frt = FALSE;

   if ( HTCLIENT == nHitTest )
   {
      if ( cWaitCursor > 0 )
      {
         // display wait cursor instead of regular cursor
         SetCursor( LoadCursor( NULL, MAKEINTRESOURCE( IDC_WAIT ) ) );
         SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, (LONG_PTR)TRUE );
         frt = TRUE;
      }
   }

   return frt;
}


static
void
LicenseSetupModeOnNext(
   HWND                    hwndPage,
   PINTERNAL_SETUP_DATA    pSetupData,
   BOOL                    fLicensePerServer,
   DWORD                   cPerServerLicenses )
//
// Notification handler for PSN_WIZNEXT
//
{
   DWORD    winStatus;
   int      nButton;

   if (     ( fLicensePerServer )
        &&  ( PERSERVER_EDIT_MIN > cPerServerLicenses )
        && !( pSetupData->OperationFlags & SETUPOPER_BATCH ) )
   {
      // warn user about using per server mode with less then 5 licenses
      MessageBoxFromStringID( hwndPage,
                                        IDS_LICENSE_SETUP_NO_PER_SERVER_LICENSES,
                                        IDS_WARNING,
                                        MB_ICONERROR | MB_OK );
      nButton = IDCANCEL;
   }
   else
   {
      // per seat mode or per server mode with positive license count
      nButton = IDOK;
   }

   if ( IDOK == nButton )
   {
      do
      {
         // save license configuration
         SendMessage( hwndPage, WM_BEGINWAITCURSOR, 0, 0 );

         winStatus = LicenseSetupWrite( fLicensePerServer, cPerServerLicenses );

         SendMessage( hwndPage, WM_ENDWAITCURSOR, 0, 0 );

         if ( ERROR_SUCCESS != winStatus )
         {
            // save failed; alert user
            nButton = MessageBoxFromStringID( hwndPage,
                                              IDS_LICENSE_SETUP_SAVE_FAILED,
                                              IDS_ERROR,
                                              MB_ICONSTOP | MB_ABORTRETRYIGNORE | MB_DEFBUTTON2 );

            if ( IDIGNORE == nButton )
            {
               nButton = IDOK;
            }
         }
         else
         {
            // save succeeded
            nButton = IDOK;
         }
      } while ( IDRETRY == nButton );
   }

   if ( IDOK != nButton )
   {
      // don't advance to next page
      SetWindowLongPtr( hwndPage, DWLP_MSGRESULT, (LONG_PTR)-1 );
   }
}


static
void
LicenseSetupModeOnHelp(
   HWND  hwndPage )
//
// Notification handler for PSN_HELP
//
{
    ::HtmlHelp( hwndPage, LICCPA_HTMLHELPFILE, HH_DISPLAY_TOPIC,0);
}


static
void
LicenseSetupModeOnSimulateNext(
   HWND  hwndPage )
//
// Handler for WM_SIMULATENEXT (used by setup tests?)
//
{
   // simulate the next button
   PropSheet_PressButton( GetParent( hwndPage ), PSBTN_NEXT );
}


static
void
LicenseSetupModeOnKillActive(
   HWND  hwndPage )
//
// Notification handler for PSN_KILLACTIVE
//
{
   // success
   SetWindowLong( hwndPage, DWLP_MSGRESULT, 0);
}

typedef enum {
    UnattendFullUnattend,
    UnattendGUIAttended,
    UnattendDefaultHide,
    UnattendProvideDefault,
    UnattendReadOnly } UNATTENDMODE; 

#ifndef SPECIAL_USERS
static
BOOL
LicenseSetupModeDoUnattended(
   HWND                    hwndPage,
   PINTERNAL_SETUP_DATA    pSetupData,
   LPBOOL                  pfLicensePerServer,
   LPDWORD                 pcPerServerLicenses )
//
// Get answers to wizard page from unattend file.
//
{
   int      cch;
   LPTSTR   pszBadParam;
   TCHAR    szLicenseMode[ 64 ];
   TCHAR    szPerServerLicenses[ 64 ];
   TCHAR    szUnattendMode[ 64 ];
   UNATTENDMODE UnattendMode = UnattendDefaultHide;

   pszBadParam = NULL;

   SendMessage( hwndPage, WM_BEGINWAITCURSOR, 0, 0 );

   // Get Unattend Mode
   cch = GetPrivateProfileString( WINNT_UNATTENDED,
                                  WINNT_U_UNATTENDMODE,
                                  TEXT( "" ),
                                  szUnattendMode,
                                  sizeof( szUnattendMode ) / sizeof( *szUnattendMode ),
                                  pSetupData->UnattendFile );
   if ( 0 < cch )
   {
      if ( !lstrcmpi( szUnattendMode, WINNT_A_FULLUNATTENDED ) )
      {
        UnattendMode = UnattendFullUnattend;
      }
      else if ( !lstrcmpi( szUnattendMode, WINNT_A_PROVIDEDEFAULT ) )
      {
        UnattendMode = UnattendProvideDefault;
      }
      else if ( !lstrcmpi( szUnattendMode, WINNT_A_READONLY ) )
      {
        UnattendMode = UnattendReadOnly;
      }
      else if ( !lstrcmpi( szUnattendMode, WINNT_A_GUIATTENDED ) )
      {
        // This should never happen
        UnattendMode = UnattendGUIAttended;
      }
   }


   // get license mode
   cch = GetPrivateProfileString( WINNT_LICENSEDATA_W,
                                  WINNT_L_AUTOMODE_W,
                                  TEXT( "" ),
                                  szLicenseMode,
                                  sizeof( szLicenseMode ) / sizeof( *szLicenseMode ),
                                  pSetupData->UnattendFile );

   SendMessage( hwndPage, WM_ENDWAITCURSOR, 0, 0 );

   if ( 0 < cch )
   {
      if ( !lstrcmpi( szLicenseMode, WINNT_A_PERSEAT_W ) )
      {
         *pfLicensePerServer = FALSE;
      }
      else if ( !lstrcmpi( szLicenseMode, WINNT_A_PERSERVER_W ) )
      {
         *pfLicensePerServer = TRUE;
      }
      else
      {
         cch = 0;
      }
   }

   if ( cch <= 0 )
   {
      // license mode absent or invalid
      pszBadParam = WINNT_L_AUTOMODE_W;
   }
   else if ( !*pfLicensePerServer )
   {
      // per seat mode; no need to read per server license count
      *pcPerServerLicenses = 0;
   }
   else
   {
      // get per server license count
      SendMessage( hwndPage, WM_BEGINWAITCURSOR, 0, 0 );

      cch = GetPrivateProfileString( WINNT_LICENSEDATA_W,
                                     WINNT_L_AUTOUSERS_W,
                                     TEXT( "" ),
                                     szPerServerLicenses,
                                     sizeof( szPerServerLicenses ) / sizeof( *szPerServerLicenses ),
                                     pSetupData->UnattendFile );

      SendMessage( hwndPage, WM_ENDWAITCURSOR, 0, 0 );

      if ( 0 < cch )
      {
         *pcPerServerLicenses = wcstoul( szPerServerLicenses, NULL, 10 );

         if (    ( PERSERVER_EDIT_MIN > *pcPerServerLicenses )
              || ( PERSERVER_EDIT_MAX < *pcPerServerLicenses ) )
         {
            // Don't let things go without setting a valid server license
            // count.
            *pcPerServerLicenses = PERSERVER_EDIT_MIN;
            cch = 0;
         }
      }

      if ( cch <= 0 )
      {
         // per server license count absent or invalid
         pszBadParam = WINNT_L_AUTOUSERS_W;
      }
   }

   //
   // Do not display the error message on preinstall.
   //

   if ( NULL != pszBadParam &&
        !(pSetupData->OperationFlags & (SETUPOPER_PREINSTALL | SETUPOPER_NTUPGRADE)) &&
        UnattendMode == UnattendFullUnattend )
   {
      // encountered a bad unattended parameter; display error
      TCHAR    szCaption[   64 ];
      TCHAR    szFormat[  1024 ];
      TCHAR    szText[    1024 ];

      LoadString( g_hinst,
                  IDS_LICENSE_SETUP_BAD_UNATTEND_PARAM,
                  szFormat,
                  sizeof( szFormat ) / sizeof( *szFormat ) );

      LoadString( g_hinst,
                  IDS_ERROR,
                  szCaption,
                  sizeof( szCaption ) / sizeof( *szCaption ) );

      HRESULT hr = StringCbPrintf( szText, sizeof(szText), szFormat, pszBadParam );
      if (SUCCEEDED(hr))
          MessageBox( hwndPage,
                  szText,
                  szCaption,
                  MB_OK | MB_ICONSTOP );
   }

   // If just providing defaults, return FALSE to force the page to show
   if ( UnattendMode == UnattendProvideDefault )
      return ( FALSE );
   return ( NULL == pszBadParam );
}
#endif //SPECIAL_USERS


static
DWORD
LicenseSetupWrite(
   BOOL     fLicensePerServer,
   DWORD    cPerServerLicenses )
//
// Write license configuration; returns ERROR_SUCCESS or Windows error.
//
{
   DWORD    winStatus;
   BOOL     fCreated = TRUE;    // TRUE if service entry is created
                                // Used to determine if we should create
                                // the parameters key or leave it alone.

   winStatus = LicenseSetupWriteService( &fCreated );

   if ( ERROR_SUCCESS == winStatus )
   {
      winStatus = LicenseSetupWriteKeyLicenseInfo( fLicensePerServer,
                                                   cPerServerLicenses );

      if ( ERROR_SUCCESS == winStatus )
      {
         winStatus = LicenseSetupWriteKeyLicenseService( fCreated );

         if ( ERROR_SUCCESS == winStatus )
         {
            winStatus = LicenseSetupWriteKeyEventLog();
         }
      }
   }

   return winStatus;
}


static
DWORD
LicenseSetupWriteKeyLicenseInfo(
   BOOL  fLicensePerServer,
   DWORD cPerServerLicenses )
//
// Create registry values:
//
//    HKEY_LOCAL_MACHINE
//       \System
//          \CurrentControlSet
//             \Services
//                \LicenseInfo
//                      ErrorControl : REG_DWORD : 1
//                      Start        : REG_DWORD : 3
//                      Type         : REG_DWORD : 4
//                      \FilePrint
//                         ConcurrentLimit   : REG_DWORD : fLicensePerServer ? cPerServerLicenses : 0
//                         DisplayName       : REG_SZ    : "Windows Server"
//                         FamilyDisplayName : REG_SZ    : "Windows Server"
//                         Mode              : REG_DWORD : fLicensePerServer ? 1 : 0
//                         FlipAllow         : REG_DWORD : fLicensePerServer ? 1 : 0
//
{
   DWORD             winStatus;
   BOOL              fCreatedNewServiceList;
   CLicRegLicense    ServiceList;

   winStatus = ServiceList.Open( fCreatedNewServiceList );

   if ( ERROR_SUCCESS == winStatus )
   {
      CLicRegLicenseService   FilePrintService( FILEPRINT_SERVICE_REG_KEY );

      winStatus = FilePrintService.Open( NULL, TRUE );

      if ( ERROR_SUCCESS == winStatus )
      {
         LICENSE_MODE   lm;

         lm = fLicensePerServer ? LICMODE_PERSERVER : LICMODE_PERSEAT;

         winStatus = FilePrintService.SetMode( lm );

         if ( ERROR_SUCCESS == winStatus )
         {
            winStatus = FilePrintService.SetUserLimit( fLicensePerServer ? cPerServerLicenses : 0 );

            if ( ERROR_SUCCESS == winStatus )
            {
               winStatus = FilePrintService.SetChangeFlag( fLicensePerServer );

               if ( ERROR_SUCCESS == winStatus )
               {
                  winStatus = FilePrintService.SetFamilyDisplayName( FILEPRINT_SERVICE_FAMILY_DISPLAY_NAME );

                  if ( ERROR_SUCCESS == winStatus )
                  {
                     winStatus = FilePrintService.SetDisplayName( FILEPRINT_SERVICE_DISPLAY_NAME );
                  }
               }
            }
         }
      }
   }

   return winStatus;
}


static
DWORD
LicenseSetupWriteKeyLicenseService( BOOL fWriteParametersKey )
//
// Create registry values:
//
//    HKEY_LOCAL_MACHINE
//       \System
//          \CurrentControlSet
//             \Services
//                \LicenseService
//                   \FilePrint
//                      \KSecDD
//                      \MSAfpSrv
//                      \SMBServer
//                      \TCP/IP Print Server
//                   \Parameters
//                      UseEnterprise    : REG_DWORD : 0
//                      ReplicationType  : REG_DWORD : 0
//                      ReplicationTime  : REG_DWORD : 24 * 60 * 60
//                      EnterpriseServer : REG_SZ    : ""
//
{
   DWORD    winStatus;
   HKEY     hKeyLicenseService;
   DWORD    dwKeyCreateDisposition;

   // create LicenseInfo key
   winStatus = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                               LICENSE_SERVICE_REG_KEY,
                               0,
                               NULL,
                               0,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKeyLicenseService,
                               &dwKeyCreateDisposition );

   if ( ERROR_SUCCESS == winStatus )
   {
      HKEY  hKeyFilePrint;

      // create FilePrint key
      winStatus = RegCreateKeyEx( hKeyLicenseService,
                                  TEXT( "FilePrint" ),
                                  0,
                                  NULL,
                                  0,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &hKeyFilePrint,
                                  &dwKeyCreateDisposition );

      if ( ERROR_SUCCESS == winStatus )
      {
         const LPCTSTR  apszFilePrintSubkeys[] =
         {
            TEXT( "KSecDD" ),
            TEXT( "MSAfpSrv" ),
            TEXT( "SMBServer" ),
            TEXT( "TCP/IP Print Server" ),
            NULL
         };

         HKEY     hKeyFilePrintSubkey;
         DWORD    iSubkey;

         for ( iSubkey = 0; NULL != apszFilePrintSubkeys[ iSubkey ]; iSubkey++ )
         {
            winStatus = RegCreateKeyEx( hKeyFilePrint,
                                        apszFilePrintSubkeys[ iSubkey ],
                                        0,
                                        NULL,
                                        0,
                                        KEY_ALL_ACCESS,
                                        NULL,
                                        &hKeyFilePrintSubkey,
                                        &dwKeyCreateDisposition );

            if ( ERROR_SUCCESS == winStatus )
            {
               RegCloseKey( hKeyFilePrintSubkey );
            }
            else
            {
               break;
            }
         }

         RegCloseKey( hKeyFilePrint );
      }

      RegCloseKey( hKeyLicenseService );
   }

   //
   // Only write the Parameters key if the service was just created.  That is,
   // this is not an upgrade
   //
   if ( fWriteParametersKey && (ERROR_SUCCESS == winStatus) )
   {
      HKEY  hKeyParameters;

      // create Parameters key
      winStatus = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                                  szLicenseKey, // const
                                  0,
                                  NULL,
                                  0,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &hKeyParameters,
                                  &dwKeyCreateDisposition );

      if ( ERROR_SUCCESS == winStatus )
      {
         // create LicenseService\Parameters values
         winStatus = RegSetValueEx( hKeyParameters,
                                    szUseEnterprise, // const
                                    0,
                                    REG_DWORD,
                                    (CONST BYTE *) &dwUseEnterprise,  // const
                                    sizeof( dwUseEnterprise ) );

         if ( ERROR_SUCCESS == winStatus )
         {
            winStatus = RegSetValueEx( hKeyParameters,
                                       szReplicationType, // const
                                       0,
                                       REG_DWORD,
                                       (CONST BYTE *) &dwReplicationType,  // const
                                       sizeof( dwReplicationType ) );

            if ( ERROR_SUCCESS == winStatus )
            {
               winStatus = RegSetValueEx( hKeyParameters,
                                          szReplicationTime, // const
                                          0,
                                          REG_DWORD,
                                          (CONST BYTE *) &dwReplicationTimeInSec, // const
                                          sizeof( dwReplicationTimeInSec ) );

               if ( ERROR_SUCCESS == winStatus )
               {
                  LPCTSTR pszEnterpriseServer = TEXT( "" );

                  winStatus = RegSetValueEx( hKeyParameters,
                                             szEnterpriseServer, // const
                                             0,
                                             REG_SZ,
                                             (CONST BYTE *) pszEnterpriseServer,
                                             ( 1 + lstrlen( pszEnterpriseServer ) ) * sizeof( *pszEnterpriseServer ) );
               }
            }
         }

         RegCloseKey( hKeyParameters );
      }
   }

   ModifyRegistryWithWriteAccess();


   return winStatus;
}


static
DWORD
LicenseSetupWriteKeyEventLog()
//
// Create registry values:
//
//    HKEY_LOCAL_MACHINE
//       \System
//          \CurrentControlSet
//             \Services
//                \EventLog
//                   \Application
//                      \LicenseService
//                         EventMessageFile : REG_EXPAND_SZ : %SystemRoot%\System32\llsrpc.dll
//                         TypesSupported   : REG_DWORD     : 7
//
{
   DWORD    winStatus;
   HKEY     hKeyLicenseService;
   DWORD    dwKeyCreateDisposition;

   // create LicenseService key
   winStatus = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                               TEXT( "System\\CurrentControlSet\\Services\\EventLog\\Application\\LicenseService" ),
                               0,
                               NULL,
                               0,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKeyLicenseService,
                               &dwKeyCreateDisposition );

   if ( ERROR_SUCCESS == winStatus )
   {
      LPCTSTR     pszEventMessageFile = TEXT( "%SystemRoot%\\System32\\llsrpc.dll" );
      const DWORD dwTypesSupported    = (   EVENTLOG_ERROR_TYPE
                                          | EVENTLOG_WARNING_TYPE
                                          | EVENTLOG_INFORMATION_TYPE );

      winStatus = RegSetValueEx( hKeyLicenseService,
                                 TEXT( "TypesSupported" ),
                                 0,
                                 REG_DWORD,
                                 (CONST BYTE *) &dwTypesSupported,
                                 sizeof( dwTypesSupported ) );

      if ( ERROR_SUCCESS == winStatus )
      {
         winStatus = RegSetValueEx( hKeyLicenseService,
                                    TEXT( "EventMessageFile" ),
                                    0,
                                    REG_SZ,
                                    (CONST BYTE *) pszEventMessageFile,
                                    ( 1 + lstrlen( pszEventMessageFile ) ) * sizeof( *pszEventMessageFile ) );
      }

      RegCloseKey( hKeyLicenseService );
   }

   return winStatus;
}



static
DWORD SetRight(
          IADs *pObject,
          long lAccessMask,
          long lAccessType,
          long lAccessInheritFlags,
          LPOLESTR szObjectGUID,
          LPOLESTR szInheritedObjectGUID)
{
    VARIANT varSD;
    DWORD dwStatus = S_OK;

    IDispatch *pDispDACL         = NULL;
    IDispatch *pDispACE          = NULL;
    IADsAccessControlList *pACL  = NULL;
    IADsSecurityDescriptor *pSD  = NULL;
    IADsAccessControlEntry *pACE = NULL;
    
    long lFlags = 0L;

    BSTR bstrNameProp = NULL;
    BSTR bstrSecID = NULL;

    if ( !pObject)
    {
        dwStatus = (DWORD)E_INVALIDARG;
        goto CleanExit;
    }
 
    VariantClear(&varSD);

    // Get the nTSecurityDescriptor.
    // Type should be VT_DISPATCH--an IDispatch ptr to the security descriptor object.
    bstrNameProp = SysAllocString(L"nTSecurityDescriptor");
    if (NULL == bstrNameProp)
    {
        dwStatus = ERROR_OUTOFMEMORY;
        goto CleanExit;
    }

    dwStatus = pObject->Get(bstrNameProp, &varSD);
    if ( FAILED(dwStatus) || varSD.vt != VT_DISPATCH ) {
        return dwStatus;
    }
 

    dwStatus = V_DISPATCH(&varSD)->QueryInterface(IID_IADsSecurityDescriptor,(void**)&pSD);
    if ( FAILED(dwStatus) ) {
        goto CleanExit;
    }
    // Get the DACL.
    dwStatus = pSD->get_DiscretionaryAcl(&pDispDACL);
    if (SUCCEEDED(dwStatus)) 
        dwStatus = pDispDACL->QueryInterface(IID_IADsAccessControlList,(void**)&pACL);
    if ( FAILED(dwStatus) ) {
        goto CleanExit;
    }


    // Create the COM object for the new ACE.
    dwStatus  = CoCreateInstance( 
                   CLSID_AccessControlEntry,
                   NULL,
                   CLSCTX_INPROC_SERVER,
                   IID_IADsAccessControlEntry,
                   (void **)&pACE
                   );
    if ( FAILED(dwStatus) ) {
        goto CleanExit;
    }

   
    dwStatus = pACE->put_AccessMask(lAccessMask );
    
    if ( FAILED(dwStatus) ) {
        goto CleanExit;
    }

    bstrSecID = SysAllocString(TEXT("NT AUTHORITY\\NetworkService"));
    if (NULL == bstrSecID)
    {
        dwStatus = ERROR_OUTOFMEMORY;
        goto CleanExit;
    }

    dwStatus = pACE->put_Trustee(bstrSecID);

    if ( FAILED(dwStatus) ) {
        goto CleanExit;
    }

    dwStatus = pACE->put_AceType(lAccessType );

    if ( FAILED(dwStatus) ) {
        goto CleanExit;
    }

    dwStatus = pACE->put_AceFlags(lAccessInheritFlags );

    if ( FAILED(dwStatus) ) {
        goto CleanExit;
    }



    // If an szObjectGUID is specified, add ADS_FLAG_OBJECT_TYPE_PRESENT 
    // to the lFlags mask and set the ObjectType.
    if (szObjectGUID)
    {
        BSTR bstrObjectGUID = SysAllocString(szObjectGUID);
        if (NULL != bstrObjectGUID)
        {
            lFlags |= ADS_FLAG_OBJECT_TYPE_PRESENT;
            dwStatus = pACE->put_ObjectType(bstrObjectGUID);
            SysFreeString(bstrObjectGUID);
        }
    }   
    
    // If an szInheritedObjectGUID is specified, add ADS_FLAG_INHERITED_OBJECT_TYPE_PRESENT 
    // to the lFlags mask and set the InheritedObjectType.
    if (SUCCEEDED(dwStatus) && szInheritedObjectGUID)
    {
        BSTR bstrInheritedObjectGUID = SysAllocString(szInheritedObjectGUID);
        if (NULL != bstrInheritedObjectGUID)
        {
            lFlags |= ADS_FLAG_INHERITED_OBJECT_TYPE_PRESENT;
            dwStatus = pACE->put_InheritedObjectType(bstrInheritedObjectGUID );
            SysFreeString(bstrInheritedObjectGUID);
        }
    }

 
    // Set flags if ObjectType or InheritedObjectType were set.
    if (SUCCEEDED(dwStatus) && lFlags)
        dwStatus = pACE->put_Flags(lFlags);
 
    // Add the ACE to the ACL to the SD to the cache to the object.
    // Need to QI for the IDispatch pointer to pass to the AddAce method.
    dwStatus = pACE->QueryInterface(IID_IDispatch, (void**)&pDispACE);
    if (SUCCEEDED(dwStatus))
    {
        dwStatus = pACL->AddAce(pDispACE);
        if (SUCCEEDED(dwStatus))
        {
            // Write the DACL
            dwStatus = pSD->put_DiscretionaryAcl(pDispDACL);
            if (SUCCEEDED(dwStatus))
            {
                // Write the ntSecurityDescriptor property to the property cache.
                BSTR bstrSD = SysAllocString(L"nTSecurityDescriptor");
                if (NULL != bstrSD)
                {
                    dwStatus = pObject->Put(bstrSD, varSD);
                    if (SUCCEEDED(dwStatus))
                    {
                        // Call SetInfo to update the property on the object in the directory.
                        dwStatus = pObject->SetInfo();
                    }
                    SysFreeString(bstrSD);
                }
            }
        }
    }

CleanExit:
    if (pDispACE)
        pDispACE->Release();
    if (pDispDACL)
        pDispDACL->Release();
    if (pACE)
        pACE->Release();
    if (pACL)
        pACL->Release();
    if (pSD)
        pSD->Release();
    if (NULL != bstrNameProp)
        SysFreeString(bstrNameProp);
    if (NULL != bstrSecID)
        SysFreeString(bstrSecID);

    VariantClear(&varSD);
    return dwStatus;

}

static
DWORD
LicenseSetupWriteService( BOOL * fCreated )
//
// Create/modify service:
//
//    lpServiceName        = "LicenseService"
//    lpDisplayName        = "License Logging Service"
//    dwServiceType        = SERVICE_WIN32_OWN_PROCESS
//    dwStartType          = LanManServerInstalled ? SERVICE_AUTO_START : SERVICE_DISABLED
//    dwErrorControl       = SERVICE_ERROR_NORMAL
//    lpBinaryPathName     = "%SystemRoot%\\System32\\llssrv.exe"
//    lpLoadOrderGroup     = NULL
//    lpdwTagId            = NULL
//    lpDependencies       = NULL
//    lpServiceStartName   = NULL
//    lpPassword           = NULL
//
{
   SC_HANDLE   hSC;
   DWORD       winStatus;
   DWORD            dwRes          = S_OK;
   IADs *           pADs           = NULL;
   VARIANT varSD;     
   VariantInit(&varSD);
   BSTR bstrConfigCntnr = NULL;
      

   *fCreated = FALSE;      

   hSC = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );

   if ( NULL == hSC )
   {
      winStatus = GetLastError();      
   }
   else
   {       
      HKEY        hKeyLanmanServerParameters;
      DWORD       dwStartType ;
      SC_HANDLE   hLicenseService = NULL;      
      TCHAR       szServiceDisplayName[ 128 ] = TEXT( "License Logging" );      
      TCHAR       szServiceDescription[1024] = TEXT("");  
      TCHAR       szServiceStartName [] = TEXT("NT AUTHORITY\\NetworkService");    
      TCHAR       szServicePassword[]=TEXT("");
      SERVICE_DESCRIPTION   svcDescription;
      QUERY_SERVICE_CONFIG*  pConfig = NULL;
      DWORD   cbBytesNeeded = 0;
      BOOL    frt;
      DWORD dwDesiredAccess = SERVICE_ALL_ACCESS;      
      
     

      // enable service iff LanmanServer was installed
      winStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                TEXT( "SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters" ),
                                0,
                                KEY_READ,
                                &hKeyLanmanServerParameters );
            

      if ( ERROR_SUCCESS == winStatus )
      {
		  //
		  // BUG# 559376
		  // LLS is now disabled by default on clean installs		  
		  //
          dwStartType = SERVICE_DISABLED;			//dwStartType = SERVICE_AUTO_START; 		  

		  hLicenseService = OpenService( hSC, TEXT( "LicenseService"), dwDesiredAccess );

         if( hLicenseService != NULL )
         {               
         
             cbBytesNeeded = sizeof(QUERY_SERVICE_CONFIG) + 4096;

             pConfig = (LPQUERY_SERVICE_CONFIG) LocalAlloc( LPTR, cbBytesNeeded );
         
             if ( pConfig != NULL )
             {

                 frt = ::QueryServiceConfig( hLicenseService,
                        pConfig,
                        cbBytesNeeded,
                        &cbBytesNeeded );
				 
                 if ( frt )
                 {						
                     dwStartType = pConfig->dwStartType;                             
                 } 

                 LocalFree ( pConfig ) ;
             }
         
             
             CloseServiceHandle( hLicenseService );
                       
         }      

         RegCloseKey( hKeyLanmanServerParameters );
         
      }
      
      else
      {
          dwStartType = SERVICE_DISABLED;
      }                          

      LoadString( g_hinst,
                  IDS_SERVICE_DISPLAY_NAME,
                  szServiceDisplayName,
                  sizeof( szServiceDisplayName ) / sizeof( *szServiceDisplayName ) );

      LoadString( g_hinst,
                  IDS_SERVICE_DESCRIPTION,
                  szServiceDescription,
                  sizeof( szServiceDescription ) / sizeof( *szServiceDescription ) );


      svcDescription.lpDescription = szServiceDescription;   
      

      hLicenseService = CreateService( hSC,
                                       TEXT( "LicenseService" ),
                                       szServiceDisplayName,
                                       // 14659: needed to call ChangeConfig2 later
                                       SERVICE_CHANGE_CONFIG,
                                       SERVICE_WIN32_OWN_PROCESS,
                                       dwStartType,
                                       SERVICE_ERROR_NORMAL,
                                       TEXT( "%SystemRoot%\\System32\\llssrv.exe" ),
                                       NULL,
                                       NULL,
                                       NULL,
                                       szServiceStartName,
                                       szServicePassword );        


      if ( NULL != hLicenseService )
      {
         // service successfully created

         ChangeServiceConfig2( hLicenseService,
                               SERVICE_CONFIG_DESCRIPTION,
                               &svcDescription );

         CloseServiceHandle( hLicenseService );

         winStatus = ERROR_SUCCESS;
         *fCreated = TRUE;
      }
      else
      {
         winStatus = GetLastError();

         if ( ERROR_SERVICE_EXISTS == winStatus )
         {
            // service already exists; change configuration of existing service
            hLicenseService = OpenService( hSC,
                                           TEXT( "LicenseService" ),
                                           SERVICE_CHANGE_CONFIG );

            if ( NULL == hLicenseService )
            {
               winStatus = GetLastError();
            }
            else
            {
               SC_LOCK     scLock;
               BOOL        ok;

               scLock = LockServiceDatabase( hSC );
               // continue even if we can't lock the database

               ok = ChangeServiceConfig( hLicenseService,
                                         SERVICE_WIN32_OWN_PROCESS,
                                         dwStartType,
                                         SERVICE_ERROR_NORMAL,
                                         TEXT( "%SystemRoot%\\System32\\llssrv.exe" ),
                                         NULL,
                                         NULL,
                                         NULL,
                                         szServiceStartName,
                                         szServicePassword,
                                         szServiceDisplayName );

               if ( !ok )
               {
                  winStatus = GetLastError();
               }
               else
               {
                  ChangeServiceConfig2( hLicenseService,
                                         SERVICE_CONFIG_DESCRIPTION,
                                         &svcDescription);

                  winStatus = ERROR_SUCCESS;
               }

               if ( NULL != scLock )
               {
                  UnlockServiceDatabase( scLock );
               }

               CloseServiceHandle( hLicenseService );
            }
         }
      }

      CloseServiceHandle( hSC );
   }

   
   CreateDirectoryWithAccess();

   CreateFileWithAccess();

   HideAppletIfBlade();

    dwRes = ADsGetObject(ROOT_DSE_PATH, IID_IADs, (void **)&pADs);

    if (FAILED(dwRes)) {        
        goto CleanExit;
    }

    bstrConfigCntnr = SysAllocString(CONFIG_CNTNR);
    if (NULL == bstrConfigCntnr)
    {
        dwRes = ERROR_OUTOFMEMORY;
        goto CleanExit;
    }

    dwRes = pADs->Get(bstrConfigCntnr, &varSD);
    if (FAILED(dwRes)) {
        goto CleanExit;
    }


    dwRes = SetRight(
          pADs,  // IADs pointer to the object
          ADS_RIGHT_DS_READ_PROP | ADS_RIGHT_DS_WRITE_PROP,
          ADS_ACETYPE_ACCESS_ALLOWED_OBJECT,
          ADS_ACEFLAG_INHERIT_ACE,
          L"{1be8f17d-a9ff-11d0-afe2-00c04fd930c9}",
          NULL     // no inherited object type GUID          
          );

CleanExit:
    if(pADs)
        pADs->Release();

    if (NULL != bstrConfigCntnr)
        SysFreeString(bstrConfigCntnr);

    VariantClear(&varSD);

    ModifyRegistryWithWriteAccess();


    return winStatus;
}


void ModifyRegistryWithWriteAccess()
{

    DWORD winStatus = 0;       
    PACL pNewDacl1 = NULL;
    PACL pOldDacl1 = NULL;
    PACL pNewDacl2 = NULL;
    PACL pOldDacl2 = NULL;
    PSECURITY_DESCRIPTOR pSD1 = NULL;   
    PSECURITY_DESCRIPTOR pSD2 = NULL;
    PSID pSid = NULL;   
    BOOL bFlag = FALSE;
    EXPLICIT_ACCESS ExplicitEntries;
    SID_IDENTIFIER_AUTHORITY ntSidAuthority = SECURITY_NT_AUTHORITY;

   
	// Creating new EXPLICIT_ACCESS structure to set on the directory

    ZeroMemory( &ExplicitEntries, sizeof(ExplicitEntries) );

    bFlag = AllocateAndInitializeSid(
        &ntSidAuthority,
        1,
        SECURITY_NETWORK_SERVICE_RID,0,          
        0, 0, 0, 0, 0, 0,
        &pSid );



    if ( !bFlag || (pSid == NULL) ) {

        goto cleanup;
    }


    BuildTrusteeWithSid( &ExplicitEntries.Trustee, pSid );

    ExplicitEntries.grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ExplicitEntries.grfAccessMode = SET_ACCESS;
    ExplicitEntries.grfAccessPermissions = KEY_READ|KEY_WRITE;
    ExplicitEntries.Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ExplicitEntries.Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    

   
    if( GetNamedSecurityInfoW( LICENSEINFO_PATH,
                             SE_REGISTRY_KEY,
                             DACL_SECURITY_INFORMATION,
                             NULL, // psidOwner
                             NULL, // psidGroup
                             &pOldDacl1, // pDacl
                             NULL, // pSacl
                             &pSD1 ) != ERROR_SUCCESS)
    {

        goto cleanup;
    }


    //
    // Set the Acl with the ExplicitEntry rights
    //
    if( SetEntriesInAcl( 1,
                          &ExplicitEntries,
                          pOldDacl1,
                          &pNewDacl1 ) != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    //
    //  SET security on the Directory
    //

    winStatus = SetNamedSecurityInfo(
                      LICENSEINFO_PATH,                // object name
                      SE_REGISTRY_KEY ,         // object type
                      DACL_SECURITY_INFORMATION | UNPROTECTED_DACL_SECURITY_INFORMATION , // type
                      NULL,                    // new owner SID
                      NULL,                    // new primary group SID
                      pNewDacl1,                        // new DACL
                      NULL                         // new SACL
                    );

    if( GetNamedSecurityInfoW( LICENSESERVICE_PATH,
                             SE_REGISTRY_KEY,
                             DACL_SECURITY_INFORMATION,
                             NULL, // psidOwner
                             NULL, // psidGroup
                             &pOldDacl2, // pDacl
                             NULL, // pSacl
                             &pSD2 ) != ERROR_SUCCESS)
    {

        goto cleanup;
    }


    //
    // Set the Acl with the ExplicitEntry rights
    //
    if( SetEntriesInAcl( 1,
                          &ExplicitEntries,
                          pOldDacl2,
                          &pNewDacl2 ) != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    //
    //  SET security on the Directory
    //

    winStatus = SetNamedSecurityInfo(
                      LICENSESERVICE_PATH,                // object name
                      SE_REGISTRY_KEY ,         // object type
                      DACL_SECURITY_INFORMATION | UNPROTECTED_DACL_SECURITY_INFORMATION , // type
                      NULL,                    // new owner SID
                      NULL,                    // new primary group SID
                      pNewDacl2,                        // new DACL
                      NULL                         // new SACL
                    );
cleanup:
    
    if(pSid) 
    {
        LocalFree( pSid );
    }
    
    if(pSD1)
    {
        LocalFree(pSD1);
        pSD1 = NULL;
    }

    if(pNewDacl1)
    {
        LocalFree(pNewDacl1);
        pNewDacl1 = NULL;
    }  
    if(pSD2)
    {
        LocalFree(pSD2);
        pSD2 = NULL;
    }

    if(pNewDacl2)
    {
        LocalFree(pNewDacl2);
        pNewDacl2 = NULL;
    }  
     
}

void HideAppletIfBlade()
{
    OSVERSIONINFOEX ovi;
    HRESULT hr = S_OK;
    HKEY hKey = NULL;
    DWORD dwVal;

    ovi.dwOSVersionInfoSize = sizeof(ovi);
    if (GetVersionEx((OSVERSIONINFO *) &ovi))
    {
        if( ovi.wSuiteMask & VER_SUITE_BLADE )
        {
            
            hr = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                           DONTLOAD_PATH,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS ,
                           NULL,
                           &hKey,
                           &dwVal);

            if(ERROR_SUCCESS == hr)
            {
                TCHAR szValue[] = L"";
                DWORD cbName = (lstrlen(szValue)+ 1) * sizeof(TCHAR);
                        
                hr = RegSetValueEx( hKey ,
                                  L"Liccpa.cpl",
                                  NULL ,
                                  REG_SZ,
                                  ( CONST LPBYTE )szValue ,
                                  cbName );
            }

            if(NULL != hKey)
            {
                RegCloseKey(hKey);
                hKey = NULL;
            }

        }
    }   
}

void CreateDirectoryWithAccess()
{
    DWORD winStatus = 0;
    TCHAR tchWinDirPath[MAX_PATH+1] = L"";        
    PACL pNewDacl = NULL;
    PACL pOldDacl = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    TCHAR tchLLSDirPath[ MAX_PATH +1] = L"";    
    BOOL bFlag = FALSE;
    PSID pSid = NULL;   
    EXPLICIT_ACCESS ExplicitEntries;
    SID_IDENTIFIER_AUTHORITY ntSidAuthority = SECURITY_NT_AUTHORITY;
    HRESULT hr;

    winStatus = GetSystemWindowsDirectory( tchWinDirPath , MAX_PATH+1);
    if(winStatus == 0)
    {
        goto cleanup;
    }

    hr = StringCbCopy(tchLLSDirPath, sizeof(tchLLSDirPath), tchWinDirPath);
    if (S_OK != hr)
        return;
    hr = StringCbCat( tchLLSDirPath, sizeof(tchLLSDirPath), L"\\system32\\lls" );
    if (S_OK != hr)
        return;
	
	// Creating new EXPLICIT_ACCESS structure to set on the directory

    ZeroMemory( &ExplicitEntries, sizeof(ExplicitEntries) );

    bFlag = AllocateAndInitializeSid(
        &ntSidAuthority,
        1,
        SECURITY_NETWORK_SERVICE_RID,0,          
        0, 0, 0, 0, 0, 0,
        &pSid );



    if ( !bFlag || (pSid == NULL) ) {

        goto cleanup;
    }


    BuildTrusteeWithSid( &ExplicitEntries.Trustee, pSid );

    ExplicitEntries.grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ExplicitEntries.grfAccessMode = SET_ACCESS;
    ExplicitEntries.grfAccessPermissions = FILE_ALL_ACCESS;
    ExplicitEntries.Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ExplicitEntries.Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;


    bFlag = CreateDirectory( tchLLSDirPath, NULL );


    if ( !bFlag ) 
    {

        winStatus = GetLastError();

        if (ERROR_ALREADY_EXISTS != winStatus)  
        {
            goto cleanup;
        }
    }

   
    if( GetNamedSecurityInfoW( tchLLSDirPath,
                             SE_FILE_OBJECT,
                             DACL_SECURITY_INFORMATION,
                             NULL, // psidOwner
                             NULL, // psidGroup
                             &pOldDacl, // pDacl
                             NULL, // pSacl
                             &pSD ) != ERROR_SUCCESS)
    {

        goto cleanup;
    }


    //
    // Set the Acl with the ExplicitEntry rights
    //
    if( SetEntriesInAcl( 1,
                          &ExplicitEntries,
                          pOldDacl,
                          &pNewDacl ) != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    //
    //  SET security on the Directory
    //

    winStatus = SetNamedSecurityInfo(
                      tchLLSDirPath,                // object name
                      SE_FILE_OBJECT ,         // object type
                      DACL_SECURITY_INFORMATION | UNPROTECTED_DACL_SECURITY_INFORMATION , // type
                      NULL,                    // new owner SID
                      NULL,                    // new primary group SID
                      pNewDacl,                        // new DACL
                      NULL                         // new SACL
                    );
cleanup:
    
    if(pSid) 
    {
        LocalFree( pSid );
    }
    
    if(pSD)
    {
        LocalFree(pSD);
        pSD = NULL;
    }   

    if(pNewDacl)
    {
        LocalFree(pNewDacl);
        pNewDacl = NULL;
    }
}

void CreateFileWithAccess()
{
    DWORD winStatus = 0;
    TCHAR tchWinDirPath[MAX_PATH+1] = L"";    
    PACL pNewDacl = NULL;
    PACL pOldDacl = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    TCHAR tchCPLFilePath[ MAX_PATH+1 ] = L"";
    BOOL bFlag = FALSE;
    PSID pSid = NULL;   
    EXPLICIT_ACCESS ExplicitEntries;
    SID_IDENTIFIER_AUTHORITY ntSidAuthority = SECURITY_NT_AUTHORITY;
    HANDLE hFile = NULL;
    HRESULT hr;
    
    winStatus = GetSystemWindowsDirectory( tchWinDirPath , MAX_PATH+1);
    if(winStatus == 0)
    {
        goto cleanup;
    }
        
    hr = StringCbCopy(tchCPLFilePath, sizeof(tchCPLFilePath), tchWinDirPath);
    if (S_OK != hr)
        return;

    hr = StringCbCat( tchCPLFilePath , sizeof(tchCPLFilePath), L"\\system32\\cpl.cfg" );
    if (S_OK != hr)
        return;
    
	// Creating new EXPLICIT_ACCESS structure to set on the file

    ZeroMemory( &ExplicitEntries, sizeof(ExplicitEntries) );

    bFlag = AllocateAndInitializeSid(
        &ntSidAuthority,
        1,
        SECURITY_NETWORK_SERVICE_RID,0,          
        0, 0, 0, 0, 0, 0,
        &pSid );


    if ( !bFlag || (pSid == NULL) ) {

        goto cleanup;
    }

    BuildTrusteeWithSid( &ExplicitEntries.Trustee, pSid );

    ExplicitEntries.grfAccessMode = SET_ACCESS;
    ExplicitEntries.grfAccessPermissions = FILE_ALL_ACCESS;
    ExplicitEntries.Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ExplicitEntries.Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;


    hFile = CreateFile(tchCPLFilePath, 
                            GENERIC_READ | GENERIC_WRITE, 
                            FILE_SHARE_READ | FILE_SHARE_WRITE, 
                            NULL, 
                            OPEN_ALWAYS, 
                            0, 
                            NULL);


    if(hFile == NULL)
    {
        winStatus = GetLastError();

        if (winStatus != ERROR_ALREADY_EXISTS) {
            goto cleanup ;
        }


    }

    

    if( GetNamedSecurityInfoW( tchCPLFilePath,
                             SE_FILE_OBJECT,
                             DACL_SECURITY_INFORMATION,
                             NULL, // psidOwner
                             NULL, // psidGroup
                             &pOldDacl, // pDacl
                             NULL, // pSacl
                             &pSD ) != ERROR_SUCCESS)

    {
        goto cleanup;
    }

    //
    // Set the Acl with the ExplicitEntry rights
    //
    if( SetEntriesInAcl( 1,
                          &ExplicitEntries,
                          pOldDacl,
                          &pNewDacl ) != ERROR_SUCCESS)
    {

        goto cleanup;
    }


    //
    //  SET security on the File
    //


   
    winStatus = SetNamedSecurityInfo(
                      tchCPLFilePath,                // object name
                      SE_FILE_OBJECT ,         // object type
                      DACL_SECURITY_INFORMATION | UNPROTECTED_DACL_SECURITY_INFORMATION , // type
                      NULL,                    // new owner SID
                      NULL,                    // new primary group SID
                      pNewDacl,                        // new DACL
                      NULL                         // new SACL
                    );    
    

cleanup:

    if(hFile)
    {
        CloseHandle(hFile);
    }
    
    if(pSid) 
    {
        LocalFree( pSid );
    }
    
    if(pSD)
    {
        LocalFree(pSD);
        pSD = NULL;
    }

    if(pNewDacl)
    {
        LocalFree(pNewDacl);
        pNewDacl = NULL;
    }
}


static
int
MessageBoxFromStringID(
   HWND     hwndParent,
   UINT     uTextID,
   UINT     uCaptionID,
   UINT     uType )
//
// Same as MessageBox(), except Text and Caption are string resources
// instead of string pointers.
//
{
   int      nButton;
   TCHAR    szText[ 1024 ];
   TCHAR    szCaption[ 64 ];

   LoadString( g_hinst, uTextID,    szText,    sizeof( szText )    / sizeof( *szText    ) );
   LoadString( g_hinst, uCaptionID, szCaption, sizeof( szCaption ) / sizeof( *szCaption ) );

   nButton = MessageBox( hwndParent, szText, szCaption, uType );

   return nButton;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\liccpa\secdlgs.cpp ===
//-------------------------------------------------------------------
//
// FILE: SecDlgs.cpp
//
// Summary;
// 		This file contians the Secondary Dialogs,
//		functions and dialog procs
//
// Entry Points;
//
// History;
//		Nov-30-94	MikeMi	Created
//      Mar-14-95   MikeMi  Added F1 Message Filter and PWM_HELP message
//
//-------------------------------------------------------------------

#include <windows.h>
#include <htmlhelp.h>
#include "resource.h"
#include "liccpa.hpp"

#include <strsafe.h>

extern "C"
{
	INT_PTR CALLBACK dlgprocLicViolation( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
	INT_PTR CALLBACK dlgprocCommon( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
}

// used to define dlg initialization using common dlgproc
//
enum DLG_TYPE
{
	DLGTYPE_AGREEMENT_PERSEAT,
  	DLGTYPE_AGREEMENT_PERSERVER,
	DLGTYPE_PERSEATSETUP,
	DLGTYPE_SERVERAPP
};

// used to pass info to a common dlgproc
//
typedef struct tagCOMMONDLGPARAM
{
	LPWSTR	 pszDisplayName;
    DWORD    dwLimit;
	LPWSTR	 pszHelpFile;
	DWORD    dwHelpContext;
	DLG_TYPE dtType;
} COMMONDLGPARAM, *PCOMMONDLGPARAM;

//-------------------------------------------------------------------
//
//  Function: dlgprocLicViolation
//
//  Summary;
//		The dialog procedure for the  Dialog
//
//  Arguments;
//		hwndDlg [in]	- handle of Dialog window
//		uMsg [in]		- message
// 		lParam1 [in]    - first message parameter
//		lParam2 [in]    - second message parameter
//
//  Return;
//		message dependant
//
//  Notes;
//
//	History;
//		Dec-05-1994	MikeMi	Created
//      Mar-14-95   MikeMi  Added F1 PWM_HELP message
//
//-------------------------------------------------------------------

INT_PTR CALLBACK dlgprocLicViolation( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    UNREFERENCED_PARAMETER(lParam);

	BOOL frt = FALSE;

	switch (uMsg)
	{
	case WM_INITDIALOG:
		CenterDialogToScreen( hwndDlg );
		frt = TRUE; // we use the default focus
		break;

	case WM_COMMAND:
		switch (HIWORD( wParam ))
		{
		case BN_CLICKED:
			switch (LOWORD( wParam ))
			{
			case IDCANCEL:
				frt = TRUE;	 // use as save flag
				// intentional no break

			case IDOK:
			    EndDialog( hwndDlg, frt );
				frt = FALSE;
				break;

			case IDC_BUTTONHELP:
                PostMessage( hwndDlg, PWM_HELP, 0, 0 );
				break;

			default:
				break;
			}
			break;

		default:
			break;
		}
		break;

	default:
		if (PWM_HELP == uMsg)
        {
            ::HtmlHelp( hwndDlg, LICCPA_HTMLHELPFILE, HH_DISPLAY_TOPIC,0);
        }
        break;
	}
	return( frt );
}

//-------------------------------------------------------------------
//
//  Function: OnCommonInitDialog
//
//  Summary;
//		Handle the initialization of the Common Dialog
//
//  Arguments;
//		hwndDlg [in] - the dialog to initialize
//		pcdParams [in] - used to get displayname, helpfile
//
//  Notes;
//
//	History;
//		Dec-05-1994	MikeMi	Created
//
//-------------------------------------------------------------------

void OnCommonInitDialog( HWND hwndDlg, PCOMMONDLGPARAM pcdParams )
{
	HWND hwndOK = GetDlgItem( hwndDlg, IDOK );

	CenterDialogToScreen( hwndDlg );

	switch( pcdParams->dtType )
	{
	case DLGTYPE_AGREEMENT_PERSEAT:
		InitStaticWithService2( hwndDlg, IDC_STATICINFO, pcdParams->pszDisplayName );
		break;

    case DLGTYPE_AGREEMENT_PERSERVER:
        {
      	    WCHAR szText[LTEMPSTR_SIZE];
        	WCHAR szTemp[LTEMPSTR_SIZE];

        	GetDlgItemText( hwndDlg, IDC_STATICINFO, szTemp, LTEMPSTR_SIZE );
            //
            // need both service display name and number of conncurrent connections
            //
        	HRESULT hr = StringCbPrintf( szText, sizeof(szText), szTemp,
                    pcdParams->dwLimit,
        	        pcdParams->pszDisplayName );
            if (SUCCEEDED(hr))
        	    SetDlgItemText( hwndDlg, IDC_STATICINFO, szText );
        }

		break;

	case DLGTYPE_PERSEATSETUP:
		InitStaticWithService( hwndDlg, IDC_STATICTITLE, pcdParams->pszDisplayName );
		InitStaticWithService2( hwndDlg, IDC_STATICINFO, pcdParams->pszDisplayName );
		break;

	case DLGTYPE_SERVERAPP:
		break;

	default:
		break;
	}

	// disable OK button at start!
	EnableWindow( hwndOK, FALSE );

	// if help is not defined, remove the button
	if (NULL == pcdParams->pszHelpFile)
	{
		HWND hwndHelp = GetDlgItem( hwndDlg, IDC_BUTTONHELP );

		EnableWindow( hwndHelp, FALSE );
		ShowWindow( hwndHelp, SW_HIDE );
	}
}

//-------------------------------------------------------------------
//
//  Function: OnCommonAgree
//
//  Summary;
//		Handle user interaction with Agree check box
//
//  Arguments;
//		hwndDlg [in] - the dialog that contains the check box
//
//  Notes;
//
//	History;
//		Dec-05-1994	MikeMi	Created
//
//-------------------------------------------------------------------

void OnCommonAgree( HWND hwndDlg )
{
	HWND hwndOK = GetDlgItem( hwndDlg, IDOK );
	BOOL fChecked = !IsDlgButtonChecked( hwndDlg, IDC_AGREE );
	
	CheckDlgButton( hwndDlg, IDC_AGREE, fChecked );
	EnableWindow( hwndOK, fChecked );
}

//-------------------------------------------------------------------
//
//  Function: dlgprocCommon
//
//  Summary;
//		The dialog procedure for the Common legal Dialogs
//
//  Arguments;
//		hwndDlg [in]	- handle of Dialog window
//		uMsg [in]		- message
// 		lParam1 [in]    - first message parameter
//		lParam2 [in]    - second message parameter
//
//  Return;
//		message dependant
//
//  Notes;
//
//	History;
//		Dec-05-1994	MikeMi	Created
//      Mar-14-95   MikeMi  Added F1 PWM_HELP message
//
//-------------------------------------------------------------------

INT_PTR CALLBACK dlgprocCommon( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
	BOOL frt = FALSE;
	static PCOMMONDLGPARAM pcdParams;

	switch (uMsg)
	{
	case WM_INITDIALOG:
		pcdParams = (PCOMMONDLGPARAM)lParam;
		OnCommonInitDialog( hwndDlg, pcdParams );
		frt = TRUE; // we use the default focus
		break;

	case WM_COMMAND:
		switch (HIWORD( wParam ))
		{
		case BN_CLICKED:
			switch (LOWORD( wParam ))
			{
			case IDOK:
				frt = TRUE;	 // use as save flag
				// intentional no break

			case IDCANCEL:
			    EndDialog( hwndDlg, frt );
				frt = FALSE;
				break;

			case IDC_BUTTONHELP:
                PostMessage( hwndDlg, PWM_HELP, 0, 0 );
				break;

			case IDC_AGREE:
				OnCommonAgree( hwndDlg );
				break;

			default:
				break;
			}
			break;

		default:
			break;
		}
		break;

	default:
        if (PWM_HELP == uMsg)
        {
            ::HtmlHelp( hwndDlg, LICCPA_HTMLHELPFILE, HH_DISPLAY_TOPIC,0);
        }
        break;
	}
	return( frt );
}

//-------------------------------------------------------------------
//
//  Function: LicviolationDialog
//
//  Summary;
//		Init and Raise the license Violation dialog
//
//  Arguments;
//		hwndParent [in]	- handle of parent window
//
//  Return;
//		1 - use OK operation, NO was pressed to exit
//		0 - use Cancel operation, YES was pressed to exit
//	   -1 - General Dialog error
//
//  Notes;
//
//	History;
//		Dec-05-1994	MikeMi	Created
//
//-------------------------------------------------------------------

int LicViolationDialog( HWND hwndParent )
{
	return( (int)DialogBox(g_hinst,
    			MAKEINTRESOURCE(IDD_LICVIOLATIONDLG),
    			hwndParent,
    			dlgprocLicViolation ) );
}

//-------------------------------------------------------------------
//
//  Function: SetupPerOnlyDialog
//
//  Summary;
//		Init and Raise the setup for per seat only  dialog
//
//  Arguments;
//		hwndParent [in]	- handle of parent window
//		pszDisplayName [in] - the service displayname
//		pszHelpFile [in] - the helpfile for the help button
//		dwHelpContext [in] - the help context for the help button
//
//  Return;
//		1 - OK button was used to exit
//		0 - Cancel button was used to exit
//	   -1 - General Dialog error
//
//  Notes;
//
//	History;
//		Dec-05-1994	MikeMi	Created
//
//-------------------------------------------------------------------

int SetupPerOnlyDialog( HWND hwndParent,
		LPCWSTR pszDisplayName,
		LPCWSTR pszHelpFile,
		DWORD dwHelpContext )
{
	COMMONDLGPARAM dlgParam;

	dlgParam.pszDisplayName = (LPWSTR)pszDisplayName;
	dlgParam.pszHelpFile = (LPWSTR)pszHelpFile;
	dlgParam.dwHelpContext = dwHelpContext;
	dlgParam.dtType = DLGTYPE_PERSEATSETUP;
	return( (int)DialogBoxParam(g_hinst,
    			MAKEINTRESOURCE(IDD_SETUP2DLG),
    			hwndParent,
    			dlgprocCommon,
    			(LPARAM)&dlgParam) );
}

//-------------------------------------------------------------------
//
//  Function: PerServerAgreementDialog
//
//  Summary;
//		Init and Raise the per server legal dialog
//
//  Arguments;
//		hwndParent [in]	- handle of parent window
//		pszDisplayName [in] - the service displayname
//      dwLimit [in] - the number of concurrent connections
//		pszHelpFile [in] - the helpfile for the help button
//		dwHelpContext [in] - the help context for the help button
//
//  Return;
//		1 - OK button was used to exit
//		0 - Cancel button was used to exit
//	   -1 - General Dialog error
//
//  Notes;
//
//	History;
//		Dec-05-1994	MikeMi	Created
//
//-------------------------------------------------------------------

int PerServerAgreementDialog( HWND hwndParent,
		LPCWSTR pszDisplayName,
        DWORD dwLimit,
		LPCWSTR pszHelpFile,
		DWORD dwHelpContext )
{
	COMMONDLGPARAM dlgParam;

	dlgParam.pszDisplayName = (LPWSTR)pszDisplayName;
    dlgParam.dwLimit = dwLimit;
	dlgParam.pszHelpFile = (LPWSTR)pszHelpFile;
	dlgParam.dwHelpContext = dwHelpContext;
	dlgParam.dtType = DLGTYPE_AGREEMENT_PERSERVER;

	return( (int)DialogBoxParam(g_hinst,
    			MAKEINTRESOURCE(IDD_PERSERVERDLG),
    			hwndParent,
    			dlgprocCommon,
    			(LPARAM)&dlgParam ) );
}

//-------------------------------------------------------------------
//
//  Function: PerSeatAgreementDialog
//
//  Summary;
//		Init and Raise the per seat legal dialog
//
//  Arguments;
//		hwndParent [in]	- handle of parent window
//		pszDisplayName [in] - the service displayname
//		pszHelpFile [in] - the helpfile for the help button
//		dwHelpContext [in] - the help context for the help button
//
//  Return;
//		1 - OK button was used to exit
//		0 - Cancel button was used to exit
//	   -1 - General Dialog error
//
//  Notes;
//
//	History;
//		Dec-05-1994	MikeMi	Created
//
//-------------------------------------------------------------------

int PerSeatAgreementDialog( HWND hwndParent,
		LPCWSTR pszDisplayName,
		LPCWSTR pszHelpFile,
		DWORD dwHelpContext )
{
	COMMONDLGPARAM dlgParam;
	
	dlgParam.pszDisplayName = (LPWSTR)pszDisplayName;
	dlgParam.pszHelpFile = (LPWSTR)pszHelpFile;
	dlgParam.dwHelpContext = dwHelpContext;
	dlgParam.dtType = DLGTYPE_AGREEMENT_PERSEAT;

	return( (int)DialogBoxParam(g_hinst,
    			MAKEINTRESOURCE(IDD_PERSEATDLG),
    			hwndParent,
    			dlgprocCommon,
    			(LPARAM)&dlgParam ) );
}

//-------------------------------------------------------------------
//
//  Function: ServerAppAgreementDialog
//
//  Summary;
//		Init and Raise the Server and App legal dialog
//
//  Arguments;
//		hwndParent [in]	- handle of parent window
//		pszHelpFile [in] - the helpfile for the help button
//		dwHelpContext [in] - the help context for the help button
//
//  Return;
//		1 - OK button was used to exit
//		0 - Cancel button was used to exit
//	   -1 - General Dialog error
//
//  Notes;
//
//	History;
//		Dec-05-1994	MikeMi	Created
//
//-------------------------------------------------------------------

int ServerAppAgreementDialog( HWND hwndParent,
		LPCWSTR pszHelpFile,
		DWORD dwHelpContext )
{
	COMMONDLGPARAM dlgParam;

	dlgParam.pszDisplayName = NULL;
	dlgParam.pszHelpFile = (LPWSTR)pszHelpFile;
	dlgParam.dwHelpContext = dwHelpContext;
	dlgParam.dtType = DLGTYPE_SERVERAPP;

	return( (int)DialogBoxParam(g_hinst,
    			MAKEINTRESOURCE(IDD_SERVERAPPDLG),
    			hwndParent,
    			dlgprocCommon,
    			(LPARAM)&dlgParam ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\liccpa\secdlgs.hpp ===
//-------------------------------------------------------------------
//
// FILE: SecDlgs.hpp
//
// Summary;
// 		This file contians the definitions of Secondary Dialogs functions
//
// Entry Points;
//		LicViolationDialog
//		SetupPerOnlyDialog
//		PerServerAgreementDialog
//		PerSeatAgreementDialog
//		ServerAppAgreementDialog
//
// History;
//		Nov-30-94	MikeMi	Created
//
//-------------------------------------------------------------------

#ifndef __SECDLGS_HPP__
#define __SECDLGS_HPP__

// Used to pass information from the Setup entry point to the Setup Dialog
//

extern int LicViolationDialog( HWND hwndParent );
extern int SetupPerOnlyDialog( HWND hwndParent, 
		LPCWSTR pszDisplayName,
		LPCWSTR pszHelpFile,
		DWORD dwHelpContext );
extern int PerServerAgreementDialog( HWND hwndParent, 
		LPCWSTR pszDisplayName,
        DWORD dwLimit,
		LPCWSTR pszHelpFile,
		DWORD dwHelpContext );
extern int PerSeatAgreementDialog( HWND hwndParent, 
		LPCWSTR pszDisplayName,
		LPCWSTR pszHelpFile,
		DWORD dwHelpContext );
extern int ServerAppAgreementDialog( HWND hwndParent,
		LPCWSTR pszHelpFile,
		DWORD dwHelpContext );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\liccpa\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=  net
MINORCOMP=  ui

TARGETNAME= liccpa
TARGETPATH= obj
TARGETTYPE= DYNLINK
TARGETEXT=  cpl

DLLENTRY=   _DllMainCRTStartup

TARGETLIBS= $(SDK_LIB_PATH)\user32.lib   \
            $(SDK_LIB_PATH)\activeds.lib   \
            $(SDK_LIB_PATH)\adsiid.lib     \
            $(SDK_LIB_PATH)\uuid.lib       \
            $(SDK_LIB_PATH)\ole32.lib      \
            $(SDK_LIB_PATH)\samsrv.lib      \
            $(SDK_LIB_PATH)\oleaut32.lib   \
            $(SDK_LIB_PATH)\kernel32.lib \
            $(SDK_LIB_PATH)\advapi32.lib \
            $(SDK_LIB_PATH)\gdi32.lib    \
            $(SDK_LIB_PATH)\comdlg32.lib \
            $(SDK_LIB_PATH)\comctl32.lib \
            $(SDK_LIB_PATH)\shell32.lib  \
            $(SDK_LIB_PATH)\version.lib  \
            $(SDK_LIB_PATH)\ntdll.lib    \
            $(SDK_LIB_PATH)\netapi32.lib \
            $(SDK_LIB_PATH)\llsrpc.lib   \
            $(SDK_LIB_PATH)\htmlhelp.lib   \
            $(SDK_LIB_PATH)\ccfapi32.lib

USE_MSVCRT= 1
MSC_WARNING_LEVEL=/W4

INCLUDES=   $(SOURCES_PATH).;                       \
            $(NET_INC_PATH);                        \
            $(DS_INC_PATH);                         \

C_DEFINES=  $(C_DEFINES) -DWIN32 -DUNICODE -D_UNICODE

UMTYPE=     windows

DLLDEF=     $(SOURCES_PATH)liccpa.def

SOURCES=    $(SOURCES)                  \
            $(SOURCES_PATH)LicCpa.cpp   \
            $(SOURCES_PATH)CLicReg.cpp  \
            $(SOURCES_PATH)PriDlgs.cpp  \
            $(SOURCES_PATH)Config.cpp   \
            $(SOURCES_PATH)SecDlgs.cpp  \
            $(SOURCES_PATH)LicSetup.cpp \
            $(SOURCES_PATH)Special.cpp  \
            $(SOURCES_PATH)LicCpa.rc


# 
# Fusionized
# 
SXS_ASSEMBLY_NAME=Microsoft.Windows.ServerAdmin.ObjectPicker
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_MANIFEST=liccpa.cpl.manifest
SXS_MANIFEST_IN_RESOURCES=1
SXS_MANIFEST_RESOURCE_ID=123
SXS_NO_BINPLACE=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\liccpa\remote.bvt\licbvtrm.cpp ===
//-------------------------------------------------------------------
//
//  FILE: LicBvtRm.Cpp
//
//  Summary;
// 		The License Setup Remote Routines BVT
//
//	Notes;
//
//	History
//		4/25/95 MikeMi Created
//
//-------------------------------------------------------------------
#include <windows.h>
#include <stdio.h>

typedef BOOL (CALLBACK* CPLSETUPPROC)(INT, LPSTR[], LPSTR* );

//BOOL APIENTRY CPlSetup( DWORD nArgs, LPSTR apszArgs[], LPSTR *ppszResult )

#define szBOOL( ftf ) ftf?"TRUE":"FALSE"

//-------------------------------------------------------------------

void PressNGo()
{
    printf( "press enter to continue..." );
    getchar();
    printf( "\n" );
}

//-------------------------------------------------------------------
void RemoteUnattedned( CPLSETUPPROC prf, LPSTR pszComputer )
{
    BOOL frt;
    LPSTR apszArgs[7];
    LPSTR pszReturn;

    printf( "RemoteUnattened " );

    // your cool code here
    apszArgs[0] = "RemoteUnattended" ;
    apszArgs[1] = pszComputer;
    apszArgs[2] = "CoolService";
    apszArgs[3] = "Microsoft's CoolService";
    apszArgs[4] = "Microsoft's CoolService for the hip 2.51";
    apszArgs[5] = "PerSeat";
    apszArgs[6] = "0";

    frt = prf( 7, apszArgs, &pszReturn );
    if ( (frt) && (0 == lstrcmpiA( pszReturn, "OK")) )
    {
        // no problems
        printf( "Passed.\n");
    }
    else
    {
        printf( "Failed: returned %s with a status of %s.\n",
                szBOOL( frt ), pszReturn );
    }
}

//-------------------------------------------------------------------

void RemoteSetup( CPLSETUPPROC prf, LPSTR pszComputer, LPSTR szRoutine )
{
    BOOL frt;
    LPSTR apszArgs[10];
    LPSTR pszReturn;

    printf( "%s ", szRoutine );

    apszArgs[0] = szRoutine;
    apszArgs[1] = pszComputer;
    apszArgs[2] = "0";
    apszArgs[3] = "CoolService";
    apszArgs[4] = "Microsoft's CoolService";
    apszArgs[5] = "Microsoft's CoolService for the hip 2.51";
    
    frt = prf( 6, apszArgs, &pszReturn );
    if ( (frt) && (0 == lstrcmpiA( pszReturn, "OK")) )
    {
        // no problems
        printf( "Passed.\n\n" );
    }
    else
    {
        printf( "Failed: returned %s with a status of %s.\n\n",
                szBOOL( frt ), pszReturn );
    }
}

//-------------------------------------------------------------------

void LocalSetup( CPLSETUPPROC prf, LPSTR szRoutine )
{
    BOOL frt;
    LPSTR apszArgs[10];
    LPSTR pszReturn;

    printf( "%s ", szRoutine );

    apszArgs[0] = szRoutine;
    apszArgs[1] = "0";
    apszArgs[2] = "CoolService";
    apszArgs[3] = "Microsoft's CoolService";
    apszArgs[4] = "Microsoft's CoolService for the hip 2.51";
    
    frt = prf( 5, apszArgs, &pszReturn );
    if ( (frt) && (0 == lstrcmpiA( pszReturn, "OK")) )
    {
        // no problems
        printf( "Passed.\n\n" );
    }
    else
    {
        printf( "Failed: returned %s with a status of %s.\n\n",
                szBOOL( frt ), pszReturn );
    }
}

//-------------------------------------------------------------------

void LocalUnattedned( CPLSETUPPROC prf, LPSTR pszComputer )
{
    BOOL frt;
    LPSTR apszArgs[7];
    LPSTR pszReturn;

    printf( "Unattened " );

    // your cool code here
    apszArgs[0] = "Unattended" ;
    apszArgs[1] = "CoolService";
    apszArgs[2] = "Microsoft's CoolService";
    apszArgs[3] = "Microsoft's CoolService for the hip 2.51";
    apszArgs[4] = "PerSeat";
    apszArgs[5] = "0";

    frt = prf( 6, apszArgs, &pszReturn );
    if ( (frt) && (0 == lstrcmpiA( pszReturn, "OK")) )
    {
        // no problems
        printf( "Passed.\n");
    }
    else
    {
        printf( "Failed: returned %s with a status of %s.\n",
                szBOOL( frt ), pszReturn );
    }
}

//-------------------------------------------------------------------

void RunTests( CPLSETUPPROC pfn, LPSTR pszComputer )
{
    /*
    RemoteUnattedned( pfn, pszComputer );
    PressNGo();

    RemoteSetup( pfn, pszComputer, "RemotePerSeat" );
    PressNGo();
    
    RemoteSetup( pfn, pszComputer, "RemoteFullSetup" );
    
    PressNGo();

    RemoteSetup( pfn, pszComputer, "RemoteFullSetupNoExit" );
    
    */
    
    LocalUnattedned( pfn, pszComputer );
    PressNGo();

    LocalSetup( pfn, "PerSeat" );
    PressNGo();
    
    LocalSetup( pfn, "FullSetup" );
    
    PressNGo();

    LocalSetup( pfn, "FullSetupNoExit" );
    
    

}

//-------------------------------------------------------------------

void _cdecl main( int argc, char *argv[ ], char *envp[ ] )
{
    HINSTANCE hinstLicCpa;
    CPLSETUPPROC   pfn;
    LPSTR pszComputer;

    printf( "LicBvtRm.Exe - The License Setup (Remote) Build Verification Test\n" );

    if (argc <= 2)
    {
        if (argc == 1)
        {
            pszComputer = NULL;
        }
        else
        {
            pszComputer = argv[1];
        }
        hinstLicCpa = LoadLibrary( L"LicCpa.Cpl" );
        if (NULL != hinstLicCpa)
        {
            pfn = (CPLSETUPPROC)GetProcAddress( hinstLicCpa, "CPlSetup" );
            if (NULL != pfn)
            {
                RunTests( pfn, pszComputer );
            }
            else
            {
                printf( "GetProcAddress Failed\n" );
            }
            FreeLibrary( hinstLicCpa );
            PressNGo();

        }
        else
        {
            printf( "LoadLibary Failed\n" );
        }
    }
    else
    {
        printf( "This test requires a computername (ie: \\\\Wombat),\n" );
        printf( "  or nothing, meaning local.\n\n" );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\liccpa\special.cpp ===
//-------------------------------------------------------------------
//
// FILE:        special.cpp
//
// Summary;     This file contians the dialogs for the MSDN version of
//              the  control panel applet and setup entry points.
//
// History;
//              Jun-26-95       MikeMi  Created
//
//-------------------------------------------------------------------

#include <windows.h>
#include "resource.h"
#include "CLicReg.hpp"
#include <stdlib.h>
#include <htmlhelp.h>
#include "liccpa.hpp"
#include "PriDlgs.hpp"
#include "SecDlgs.hpp"
#include "Special.hpp"
#include "sbs_res.h"

#include <strsafe.h>

SPECIALVERSIONINFO gSpecVerInfo;

//-------------------------------------------------------------------
//
//  Function:   InitSpecialVersionInfo
//
//  Summary:    Initialize global data if liccpa is launched as
//              a special version (eg: restricted SAM, NFR, etc).
//
//  Arguments:  None.
//
//  History:    Oct-07-97       MarkBl  Created
//
//-------------------------------------------------------------------

void InitSpecialVersionInfo( void )
{
    //
    // If the SPECIALVERSION manifest is defined, initialize the
    // global data from the specifc manifests defined for the special
    // version.
    //
    // TBD : These special versions should change to be detected at
    //       runtime vs. building a special version of liccpa.
    //

#ifdef SPECIALVERSION
    gSpecVerInfo.idsSpecVerWarning = IDS_SPECVER_WARNING;
    gSpecVerInfo.idsSpecVerText1   = IDS_SPECVER_TEXT1;
    gSpecVerInfo.idsSpecVerText2   = IDS_SPECVER_TEXT2;
    gSpecVerInfo.dwSpecialUsers    = SPECIAL_USERS;
    gSpecVerInfo.lmSpecialMode     = SPECIAL_MODE;
#else
    ZeroMemory(&gSpecVerInfo, sizeof(gSpecVerInfo));
#endif // SPECIALVERSION

    //
    // Special versions of liccpa detected at runtime.
    //
    // Currently, small business server only.
    //

    if (IsRestrictedSmallBusSrv())
    {
        gSpecVerInfo.dwSpecialUsers = GetSpecialUsers();

        //
        // Check for small business server NFR.
        //

        if (gSpecVerInfo.dwSpecialUsers == SAM_NFR_LICENSE_COUNT)
        {
            gSpecVerInfo.idsSpecVerWarning = IDS_SAMNFR_NOTAVAILABLE;
            gSpecVerInfo.idsSpecVerText1   = IDS_SAMNFR_TEXT1;
            gSpecVerInfo.idsSpecVerText2   = IDS_SAMNFR_TEXT2;
            gSpecVerInfo.lmSpecialMode     = LICMODE_PERSERVER;
        }
        else
        {
            gSpecVerInfo.idsSpecVerWarning = IDS_SAM_NOTAVAILABLE;
            gSpecVerInfo.idsSpecVerText1   = IDS_SAM_TEXT1;
            gSpecVerInfo.idsSpecVerText2   = IDS_SAM_TEXT2;
            gSpecVerInfo.lmSpecialMode     = LICMODE_PERSERVER;
        }
    }
}

//-------------------------------------------------------------------
//
//  Function: RaiseNotAvailWarning
//
//  Summary;
//              Raise the special not available with this version warning
//
//      Arguments;
//              hwndDlg [in] - hwnd of control dialog
//
//  History;
//              Jun-26-95       MikeMi  Created
//
//-------------------------------------------------------------------

void RaiseNotAvailWarning( HWND hwndCPL )
{
    TCHAR pszText[LTEMPSTR_SIZE];
    TCHAR pszTitle[TEMPSTR_SIZE];
    HINSTANCE hSbsLib = NULL;

    if ( (gSpecVerInfo.idsSpecVerWarning == IDS_SAMNFR_NOTAVAILABLE)
        && (NULL != (hSbsLib = LoadLibrary( SBS_RESOURCE_DLL ))) )
    {
        LoadString( hSbsLib, SBS_License_Error, pszText, TEMPSTR_SIZE );
    }
    else
    {
        LoadString( g_hinst, gSpecVerInfo.idsSpecVerWarning, pszText,
                    TEMPSTR_SIZE );
    }
    LoadString( g_hinst, IDS_CPATITLE, pszTitle, TEMPSTR_SIZE );
    
    MessageBox( hwndCPL, pszText, pszTitle, MB_ICONINFORMATION | MB_OK );
}

//-------------------------------------------------------------------

void SetStaticWithService( HWND hwndDlg, UINT idcStatic, LPTSTR psService, UINT idsText )
{
        WCHAR szText[LTEMPSTR_SIZE];
        WCHAR szTemp[LTEMPSTR_SIZE];
    
        LoadString( g_hinst, idsText, szTemp, LTEMPSTR_SIZE ); 
        HRESULT hr = StringCbPrintf( szText, sizeof(szText), szTemp, psService );
        if (SUCCEEDED(hr))
            SetDlgItemText( hwndDlg, idcStatic, szText );
}

//-------------------------------------------------------------------

void SetStaticUsers( HWND hwndDlg, UINT idcStatic, DWORD users, UINT idsText )
{
        WCHAR szText[LTEMPSTR_SIZE];
        WCHAR szTemp[LTEMPSTR_SIZE];
    
        LoadString( g_hinst, idsText, szTemp, LTEMPSTR_SIZE ); 
        HRESULT hr = StringCbPrintf( szText, sizeof(szText), szTemp, users );
        if (SUCCEEDED(hr))
            SetDlgItemText( hwndDlg, idcStatic, szText );
}

//-------------------------------------------------------------------
//
//  Function: OnSpecialInitDialog
//
//  Summary;
//              Handle the initialization of the Special only Setup Dialog
//
//  Arguments;
//              hwndDlg [in] - the dialog to initialize
//              psdParams [in] - used for the displayname and service name
//
//  Notes;
//
//      History;
//              Dec-08-1994     MikeMi  Created
//
//-------------------------------------------------------------------

void OnSpecialInitDialog( HWND hwndDlg, PSETUPDLGPARAM psdParams )
{
        HWND hwndOK = GetDlgItem( hwndDlg, IDOK );
        CLicRegLicense cLicKey;
        BOOL fNew;
    LONG lrt;
    INT nrt;

        lrt = cLicKey.Open( fNew, psdParams->pszComputer );
        nrt = AccessOk( NULL, lrt, FALSE );
        if (ERR_NONE == nrt)
        {
            CenterDialogToScreen( hwndDlg );
        
            SetStaticWithService( hwndDlg,
                IDC_STATICTITLE,
                psdParams->pszDisplayName,
                gSpecVerInfo.idsSpecVerText1 );

            if (IsRestrictedSmallBusSrv())
            {
                SetStaticUsers( hwndDlg,
                        IDC_STATICINFO,
                        gSpecVerInfo.dwSpecialUsers,
                        gSpecVerInfo.idsSpecVerText2 );
            }
            else
            {
                SetStaticWithService( hwndDlg,
                        IDC_STATICINFO,
                        psdParams->pszDisplayName,
                        gSpecVerInfo.idsSpecVerText2 );
            }

            // disable OK button at start!
            EnableWindow( hwndOK, FALSE );

            // if help is not defined, remove the button
            if (NULL == psdParams->pszHelpFile)
            {
                HWND hwndHelp = GetDlgItem( hwndDlg, IDC_BUTTONHELP );

                EnableWindow( hwndHelp, FALSE );
                ShowWindow( hwndHelp, SW_HIDE );
            }
            if (psdParams->fNoExit)
            {
                HWND hwndExit = GetDlgItem( hwndDlg, IDCANCEL );
                // remove the ExitSetup button
                EnableWindow( hwndExit, FALSE );
                ShowWindow( hwndExit, SW_HIDE );
            }

         }
         else
         {
                EndDialog( hwndDlg, nrt );
         }
}

//-------------------------------------------------------------------
//
//  Function: OnSpecialSetupClose
//
//  Summary;
//              Do work needed when the Setup Dialog is closed.
//              Save to Reg the Service entry.
//
//      Arguments;
//              hwndDlg [in] - hwnd of dialog this close was requested on
//              fSave [in] - Save service to registry
//              psdParams [in] - used for the service name and displayname
//
//  History;
//              Nov-30-94       MikeMi  Created
//
//-------------------------------------------------------------------

void OnSpecialSetupClose( HWND hwndDlg, BOOL fSave, PSETUPDLGPARAM psdParams ) 
{
        int nrt = fSave;

        if (fSave)
        {
                CLicRegLicenseService cLicServKey;

                cLicServKey.SetService( psdParams->pszService );
                cLicServKey.Open( psdParams->pszComputer );

                // configure license rule of one change from PerServer to PerSeat
                //
                cLicServKey.SetChangeFlag( TRUE );

                cLicServKey.SetMode( gSpecVerInfo.lmSpecialMode );
                cLicServKey.SetUserLimit( gSpecVerInfo.dwSpecialUsers );
                cLicServKey.SetDisplayName( psdParams->pszDisplayName );
        cLicServKey.SetFamilyDisplayName( psdParams->pszFamilyDisplayName );
                cLicServKey.Close();
        }
        EndDialog( hwndDlg, nrt );
}

//-------------------------------------------------------------------
//
//  Function: OnSpecialAgree
//
//  Summary;
//              Handle the user interaction with the Agree Check box
//
//  Arguments;
//              hwndDlg [in] - the dialog to initialize
//
//  Return;
//              TRUE if succesful, otherwise false
//
//  Notes;
//
//      History;
//              Nov-11-1994     MikeMi  Created
//
//-------------------------------------------------------------------

void OnSpecialAgree( HWND hwndDlg )
{
        HWND hwndOK = GetDlgItem( hwndDlg, IDOK );
        BOOL fChecked = !IsDlgButtonChecked( hwndDlg, IDC_AGREE );
        
        CheckDlgButton( hwndDlg, IDC_AGREE, fChecked );
        EnableWindow( hwndOK, fChecked );
}

//-------------------------------------------------------------------
//
//  Function: dlgprocSPECIALSETUP
//
//  Summary;
//              The dialog procedure for the special version Setup Dialog,
//      which will replace all others
//
//  Arguments;
//              hwndDlg [in]    - handle of Dialog window 
//              uMsg [in]               - message                       
//              lParam1 [in]    - first message parameter
//              lParam2 [in]    - second message parameter       
//
//  Return;
//              message dependant
//
//  Notes;
//
//      History;
//              Jun-26-1995     MikeMi  Created
//
//-------------------------------------------------------------------

INT_PTR CALLBACK dlgprocSPECIALSETUP( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
        BOOL frt = FALSE;
        static PSETUPDLGPARAM psdParams;

        switch (uMsg)
        {
        case WM_INITDIALOG:
                psdParams = (PSETUPDLGPARAM)lParam;
                OnSpecialInitDialog( hwndDlg, psdParams );
                frt = TRUE; // we use the default focus
                break;

        case WM_COMMAND:
                switch (HIWORD( wParam ))
                {
                case BN_CLICKED:
                        switch (LOWORD( wParam ))
                        {
                        case IDOK:
                                frt = TRUE;      // use as save flag
                                // intentional no break

                        case IDCANCEL:
                            OnSpecialSetupClose( hwndDlg, frt, psdParams );
                                frt = FALSE;
                                break;

                        case IDC_BUTTONHELP:
                PostMessage( hwndDlg, PWM_HELP, 0, 0 );
                                break;

                        case IDC_AGREE:
                                OnSpecialAgree( hwndDlg );
                                break;

                        default:
                                break;
                        }
                        break;

                default:
                        break;
                }
                break;

        default:
        if (PWM_HELP == uMsg)
        {
                        ::HtmlHelp( hwndDlg,
                                     LICCPA_HTMLHELPFILE,
                                     HH_DISPLAY_TOPIC,
                                     0);
        }
                break;
        }
        return( frt );
}

//-------------------------------------------------------------------
//
//  Function: SpecialSetupDialog
//
//  Summary;
//              Init and raises Per Seat only setup dialog.
//
//  Arguments;
//              hwndDlg [in]    - handle of Dialog window 
//              dlgParem [in]   - Setup params IDC_BUTTONHELP
//
//  Return;
//              1 - OK button was used to exit
//              0 - Cancel button was used to exit
//         -1 - General Dialog error
//
//  Notes;
//
//      History;
//              Dec-05-1994     MikeMi  Created
//
//-------------------------------------------------------------------

INT_PTR SpecialSetupDialog( HWND hwndParent, SETUPDLGPARAM& dlgParam )
{
        return( DialogBoxParam( g_hinst, 
                MAKEINTRESOURCE(IDD_SPECIALSETUP), 
                hwndParent, 
                dlgprocSPECIALSETUP,
                (LPARAM)&dlgParam ) );
} 

//-------------------------------------------------------------------
//
//  Function: GetSpecialUsers
//
//  Summary;
//              Gets the number of licensed users from the registry.
//
//  Arguments;
//              none
//  Return;
//              The number of licensed users
//
//  Notes;
//
//      History;
//              Aug-18-97     GeorgeJe Created
//
//-------------------------------------------------------------------

DWORD GetSpecialUsers( VOID )
{
    LONG rVal;
    DWORD Disposition;
    HKEY hKey;
    DWORD Type;
    DWORD Size = sizeof(DWORD);
    DWORD Value;

    rVal = RegCreateKeyEx(
                     HKEY_LOCAL_MACHINE,
                     REGKEY_LICENSEINFO_SBS,
                     0,
                     NULL,
                     REG_OPTION_NON_VOLATILE,
                     KEY_READ,
                     NULL,
                     &hKey,
                     &Disposition
                     );

    if (rVal != ERROR_SUCCESS) {
        return DEFAULT_SPECIAL_USERS;
    }
    
    rVal = RegQueryValueEx(
                     hKey,
                     REGVAL_CONCURRENT_LIMIT,
                     0,
                     &Type,
                     (LPBYTE) &Value,
                     &Size
                     );

    RegCloseKey( hKey );

    return (rVal == ERROR_SUCCESS ? Value : DEFAULT_SPECIAL_USERS);
}

const WCHAR wszProductOptions[] =
        L"System\\CurrentControlSet\\Control\\ProductOptions";

const WCHAR wszProductSuite[] =
                        L"ProductSuite";
const WCHAR wszSBSRestricted[] =
                        L"Small Business(Restricted)";

BOOL IsRestrictedSmallBusSrv( void )

/*++

Routine Description:

    Check if this server is a Microsoft small business restricted server.

Arguments:

    None.

Return Values:

    TRUE  -- This server is a restricted small business server.
    FALSE -- No such restriction.

--*/

{
    WCHAR  wszBuffer[1024] = L"";
    DWORD  cbBuffer = sizeof(wszBuffer);
    DWORD  dwType;
    LPWSTR pwszSuite;
    HKEY   hKey;
    BOOL   bRet = FALSE;

    //
    // Check if this server is a Microsoft small business restricted server.
    // Do so by checking for the existence of the string
    //     "Small Business(Restricted)"
    // in the MULTI_SZ "ProductSuite" value under
    //      HKLM\CurrentCcntrolSet\Control\ProductOptions.
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     wszProductOptions,
                     0,
                     KEY_READ,
                     &hKey) == ERROR_SUCCESS)
    {
        if (RegQueryValueEx(hKey,
                            wszProductSuite,
                            NULL,
                            &dwType,
                            (LPBYTE)wszBuffer,
                            &cbBuffer) == ERROR_SUCCESS)
        {
            if (dwType == REG_MULTI_SZ && *wszBuffer)
            {
                pwszSuite = wszBuffer;

                while (*pwszSuite)
                {
                    if (lstrcmpi(pwszSuite, wszSBSRestricted) == 0)
                    {
                        bRet = TRUE;
                        break;
                    }
                    pwszSuite += wcslen(pwszSuite) + 1;
                }
            }
        }

        RegCloseKey(hKey);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\liccpa\test\licsetup\ctls.c ===
#define OEMRESOURCE     // setting this gets OBM_ constants in windows.h
#include <windows.h>
#include "ctls.h"
#pragma hdrstop

#define  MyModuleHandle    GetModuleHandle( NULL )
#define  MYASSERT(x)
#define  MyFree(x)         LocalFree( x )

PWSTR DuplicateString( PWSTR pszOriginal )
{
   PWSTR    pszCopy;

   pszCopy = LocalAlloc( LPTR, ( 1 + lstrlenW( pszOriginal ) ) * sizeof( *pszOriginal ) );

   if ( NULL != pszCopy )
   {
      lstrcpy( pszCopy, pszOriginal );
   }

   return pszCopy;
}

////////////////////////////////////////////
//
// Bitmap control
//
////////////////////////////////////////////

PCWSTR szBMPCLASS = L"_mybmp";


LRESULT
BmpClassWndProc(
    IN HWND   hwnd,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );


BOOL
InitializeBmpClass(
    VOID
    )
{
    WNDCLASS wc;
    BOOL b;

    if(GetClassInfo(MyModuleHandle,szBMPCLASS,&wc)) {
        b = TRUE;
    } else {

        wc.lpszClassName = szBMPCLASS;
        wc.style         = CS_GLOBALCLASS;
        wc.lpfnWndProc   = BmpClassWndProc;
        wc.hInstance     = MyModuleHandle;
        wc.hIcon         = NULL;
        wc.hCursor       = LoadCursor(NULL,IDC_ARROW);
        wc.hbrBackground = NULL;
        wc.lpszMenuName  = NULL;
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = 0;

        b = RegisterClass(&wc);
    }

    return(b);
}


VOID
DestroyBmpClass(
    VOID
    )
{
    WNDCLASS wc;

    if(GetClassInfo(MyModuleHandle,szBMPCLASS,&wc)) {
        //
        // Hope there are no more windows using the class!
        //
        MYASSERT(!FindWindow(szBMPCLASS,NULL));
        UnregisterClass(szBMPCLASS,MyModuleHandle);
    }
}


VOID
BmpClassPaint(
    IN HWND hwnd
    )
{
    PAINTSTRUCT ps;
    unsigned BmpId;
    HDC hdc, hdcMem;
    HBITMAP hbm,hbmOld;
    BITMAP bm;

    BmpId = GetDlgCtrlID(hwnd);

    hdc = BeginPaint(hwnd,&ps);
    if(hbm = LoadBitmap((HINSTANCE)GetWindowLong(hwnd,GWL_HINSTANCE),MAKEINTRESOURCE(BmpId))) {
        GetObject(hbm, sizeof(bm),&bm);
        if(hdcMem = CreateCompatibleDC(hdc)) {
            if(hbmOld = SelectObject(hdcMem,hbm)) {
                BitBlt(hdc,0,0,bm.bmWidth,bm.bmHeight,hdcMem,0,0,SRCCOPY);
                SelectObject(hdcMem,hbmOld);
            }
            DeleteDC(hdcMem);
        }
        DeleteObject(hbm);
    }
    EndPaint(hwnd,&ps);
}


LRESULT
BmpClassWndProc(
    IN HWND   hwnd,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch(msg) {

    case WM_NCCREATE:

        SetWindowLong(
            hwnd,
            GWL_STYLE,
            GetWindowLong(hwnd,GWL_STYLE) | WS_BORDER
            );

        return(TRUE);

    case WM_PAINT:

        BmpClassPaint(hwnd);
        return(0);
    }

    return(DefWindowProc(hwnd,msg,wParam,lParam));
}


////////////////////////////////////////////
//
// Action item list control
//
////////////////////////////////////////////

//
// Define locations in extra window storage
//
#define AIL_FONT        (0)
#define AIL_BOLDFONT    (sizeof(LONG))
#define AIL_BOLDITEM    (2*sizeof(LONG))
#define AIL_TEXT        (3*sizeof(LONG))
#define AIL_LINECOUNT   (4*sizeof(LONG))
#define AIL_FREEFONTS   (5*sizeof(LONG))

#define AIL_EXTRA       6

PCWSTR szActionItemListClassName = L"$$$ActionItemList";


VOID
ActionItemListPaint(
    IN HWND hwnd
    )
{

    PAINTSTRUCT PaintStruct;
    PWSTR p,Text;
    UINT LineCount;
    HFONT OldFont,Font,BoldFont;
    UINT HighlightedItem;
    UINT i;
    int Length;
    int y;
    int yDelta;
    HBITMAP Bitmap,OldBitmap;
    BITMAP bitmap;
    HDC MemoryDC;
    SIZE Size;
    RECT rect;
    int Spacing;
    #define BORDER 3

    if(!BeginPaint(hwnd,&PaintStruct)) {
        return;
    }

    //
    // If no text, nothing to do.
    //
    if(Text = (PWSTR)GetWindowLong(hwnd,AIL_TEXT)) {
        LineCount = (UINT)GetWindowLong(hwnd,AIL_LINECOUNT);
    }

    if(!Text || !LineCount) {
        return;
    }

    //
    // Get value indicating which item is to be bolded.
    //
    HighlightedItem = (UINT)GetWindowLong(hwnd,AIL_BOLDITEM);

    //
    // Get font handles.
    //
    Font = (HFONT)GetWindowLong(hwnd,AIL_FONT);
    BoldFont = (HFONT)GetWindowLong(hwnd,AIL_BOLDFONT);

    //
    // Select the non-boldface font to get the handle of
    // the currently selected font.
    //
    OldFont = SelectObject(PaintStruct.hdc,Font);

    //
    // Set text background color.
    //
    SetBkColor(PaintStruct.hdc,GetSysColor(COLOR_3DFACE));

    //
    // Load the little triangle bitmap and create a compatible DC for it.
    //
    Bitmap = LoadBitmap(NULL,MAKEINTRESOURCE(OBM_MNARROW));

    if(MemoryDC = CreateCompatibleDC(PaintStruct.hdc)) {

        OldBitmap = SelectObject(MemoryDC,Bitmap);
        GetObject(Bitmap,sizeof(BITMAP),&bitmap);
    }

    Spacing = GetSystemMetrics(SM_CXICON) / 2;

    //
    // Treat the text as a series of lines and draw each one.
    //
    p = Text;
    y = 0;
    for(i=0; i<LineCount; i++) {

        //
        // Calculate the line's height based on the boldface font.
        // This is used to get to the y coord of the next line.
        //
        SelectObject(PaintStruct.hdc,BoldFont);

        GetClientRect(hwnd,&rect);
        rect.left = (2 * BORDER) + Spacing;
        rect.bottom = 0;

        DrawText(PaintStruct.hdc,p,lstrlen(p),&rect,DT_CALCRECT|DT_WORDBREAK);

        yDelta = rect.bottom + (2*BORDER);

        //
        // Change font to non-boldface for this line if necessary.
        //
        if(i != HighlightedItem) {
            SelectObject(PaintStruct.hdc,Font);
        }

        rect.top = y + BORDER;
        rect.left = (2 * BORDER) + Spacing;
        rect.bottom = rect.top + yDelta;

        //
        // Draw the line's text.
        //
        Length = lstrlen(p);
        DrawText(PaintStruct.hdc,p,Length,&rect,DT_WORDBREAK);

        //
        // Draw the little triangle thing if necessary.
        //
        if((i == HighlightedItem) && Bitmap && MemoryDC) {

            GetTextExtentPoint(PaintStruct.hdc,L"WWWWW",5,&Size);

            BitBlt(
                PaintStruct.hdc,
                BORDER,
                y + ((Size.cy - bitmap.bmHeight) / 2) + BORDER,
                bitmap.bmWidth,
                bitmap.bmHeight,
                MemoryDC,
                0,0,
                0x220326        // (NOT src) AND dest [DSna]
                );
        }

        //
        // Point to next line's text.
        //
        p += Length + 1;
        y += yDelta;
    }

    //
    // Clean up.
    //
    if(OldFont) {
        SelectObject(PaintStruct.hdc,OldFont);
    }

    if(MemoryDC) {
        if(OldBitmap) {
            SelectObject(MemoryDC,OldBitmap);
        }
        if(Bitmap) {
            DeleteObject(Bitmap);
        }
        DeleteDC(MemoryDC);
    }

    EndPaint(hwnd,&PaintStruct);
}


LRESULT
ActionItemListWndProc(
    IN HWND   hwnd,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    LRESULT rc;
    HFONT OldFont,Font,BoldFont;
    LOGFONT LogFont;
    PWSTR Text;
    PWSTR p;
    UINT LineCount;
    BOOL FreeFont,FreeBoldFont;

    switch(msg) {

    case WM_CREATE:

        //
        // Create fonts.
        //
        OldFont = (HFONT)SendMessage(GetParent(hwnd),WM_GETFONT,0,0);
        if(!OldFont) {
            //
            // Using system font.
            //
            OldFont = GetStockObject(DEFAULT_GUI_FONT);
        }

        FreeFont = TRUE;
        FreeBoldFont = TRUE;
        if(OldFont && GetObject(OldFont,sizeof(LOGFONT),&LogFont)) {

            LogFont.lfWeight = 400;
            Font = CreateFontIndirect(&LogFont);
            if(!Font) {
                Font = GetStockObject(DEFAULT_GUI_FONT);
                FreeFont = FALSE;
            }

            LogFont.lfWeight = 700;
            BoldFont = CreateFontIndirect(&LogFont);
            if(!BoldFont) {
                BoldFont = Font;
                FreeBoldFont = FALSE;
            }
        }

        SetWindowLong(hwnd,AIL_FONT,(LONG)Font);
        SetWindowLong(hwnd,AIL_BOLDFONT,(LONG)BoldFont);
        SetWindowLong(hwnd,AIL_BOLDITEM,0);
        SetWindowLong(hwnd,AIL_TEXT,0);
        SetWindowLong(hwnd,AIL_LINECOUNT,0);
        SetWindowLong(hwnd,AIL_FREEFONTS,MAKELONG(FreeFont,FreeBoldFont));

        rc = 0;
        break;

    case WM_DESTROY:
        //
        // Get rid of fonts we created if necessary.
        //
        FreeFont = (BOOL)GetWindowLong(hwnd,AIL_FREEFONTS);
        FreeBoldFont = HIWORD(FreeFont);
        FreeFont = LOWORD(FreeFont);

        if(FreeFont && (Font = (HFONT)GetWindowLong(hwnd,AIL_FONT))) {
            DeleteObject(Font);
        }

        if(FreeBoldFont && (BoldFont = (HFONT)GetWindowLong(hwnd,AIL_BOLDFONT))) {
            DeleteObject(BoldFont);
        }

        if(Text = (PWSTR)GetWindowLong(hwnd,AIL_TEXT)) {
            MyFree(Text);
        }
        rc = 0;
        break;

    case WM_SETTEXT:
        //
        // Free old text and remember new text.
        //
        if(Text = (PWSTR)GetWindowLong(hwnd,AIL_TEXT)) {
            MyFree(Text);
        }

        LineCount = 0;
        if(Text = DuplicateString((PVOID)lParam)) {
            //
            // Count lines in the text. This is equal to the number of
            // newlines. We require that the last line have a newline
            // to be counted.
            //
            for(LineCount=0,p=Text; *p; p++) {

                if(*p == L'\r') {
                    *p = L' ';
                } else {
                    if(*p == L'\n') {
                        *p = 0;
                        LineCount++;
                    }
                }
            }
        }

        //
        // Cheat a little: we expect wParam to be the 0-based index
        // of the boldfaced line. Callers will have to use SendMessage
        // instead of SetWindowText().
        //
        SetWindowLong(hwnd,AIL_BOLDITEM,(LONG)wParam);
        SetWindowLong(hwnd,AIL_LINECOUNT,LineCount);
        SetWindowLong(hwnd,AIL_TEXT,(LONG)Text);

        rc = (Text != NULL);
        break;

    case WM_PAINT:

        ActionItemListPaint(hwnd);
        rc = 0;
        break;

    default:
        rc = DefWindowProc(hwnd,msg,wParam,lParam);
        break;
    }

    return(rc);
}


BOOL
RegisterActionItemListControl(
    IN BOOL Init
    )
{
    WNDCLASS wc;
    BOOL b;
    static BOOL Registered;

    if(Init) {
        if(Registered) {
            b = TRUE;
        } else {
            wc.style = CS_PARENTDC;
            wc.lpfnWndProc = ActionItemListWndProc;
            wc.cbClsExtra = 0;
            wc.cbWndExtra = AIL_EXTRA * sizeof(LONG);
            wc.hInstance = MyModuleHandle;
            wc.hIcon = NULL;
            wc.hCursor = LoadCursor(NULL,IDC_ARROW);
            wc.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);
            wc.lpszMenuName = NULL;
            wc.lpszClassName = szActionItemListClassName;

            if(b = (RegisterClass(&wc) != 0)) {
                Registered = TRUE;
            }
        }
    } else {
        if(Registered) {
            if(b = UnregisterClass(szActionItemListClassName,MyModuleHandle)) {
                Registered = FALSE;
            }
        } else {
            b = TRUE;
        }
    }

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\liccpa\special.hpp ===
//-------------------------------------------------------------------
//
// FILE: Special.hpp
//
// Summary;
//              This file contians the definitions of Special Dialogs functions
//
// Entry Points;
//
// History;
//              Jun-26-95       MikeMi  Created
//
//-------------------------------------------------------------------

#ifndef __SPECIAL_HPP__
#define __SPECIAL_HPP__

// currently we support one special version for msdn, 
// when others are needed, just copy the group below for each version
//

// define MSDNVERSION to build for this version
#ifdef MSDNVERSION

#define SPECIALVERSION
#define IDS_SPECVER_WARNING IDS_MSDN_NOTAVAILABLE
#define IDS_SPECVER_TEXT1   IDS_MSDN_TEXT1
#define IDS_SPECVER_TEXT2   IDS_MSDN_TEXT2

#define SPECIAL_MODE  LICMODE_PERSERVER
#define SPECIAL_USERS 5
#endif

// define NFRVERSION to build for this version
#ifdef NFRVERSION

#define SPECIALVERSION
#define IDS_SPECVER_WARNING IDS_NFR_NOTAVAILABLE
#define IDS_SPECVER_TEXT1   IDS_NFR_TEXT1
#define IDS_SPECVER_TEXT2   IDS_NFR_TEXT2

#define SPECIAL_MODE  LICMODE_PERSERVER
#ifndef SPECIAL_USERS
#  define SPECIAL_USERS 5
#endif
#endif

#define REGKEY_LICENSEINFO_SBS      L"System\\CurrentControlSet\\Services\\LicenseInfoSuites\\SmallBusiness"
#define   REGVAL_CONCURRENT_LIMIT   L"ConcurrentLimit"

#define DEFAULT_SPECIAL_USERS   5

#define SAM_NFR_LICENSE_COUNT   2

typedef struct _SPECIALVERSIONINFO {
    UINT         idsSpecVerWarning;
    UINT         idsSpecVerText1;
    UINT         idsSpecVerText2;
    DWORD        dwSpecialUsers;
    LICENSE_MODE lmSpecialMode;
} SPECIALVERSIONINFO, * LPSPECIALVERSIONINFO;

extern SPECIALVERSIONINFO gSpecVerInfo;

extern void  InitSpecialVersionInfo( VOID );
extern void  RaiseNotAvailWarning( HWND hwndCPL );
extern INT_PTR   SpecialSetupDialog( HWND hwndParent, SETUPDLGPARAM& dlgParam );
extern DWORD GetSpecialUsers( VOID );
extern BOOL  IsRestrictedSmallBusSrv( VOID );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\liccpa\test\licsetup\ctls.h ===
#ifdef __cplusplus
extern "C"
{
#endif

//
// Bitmap control routines.
//
BOOL
InitializeBmpClass(
    VOID
    );

VOID
DestroyBmpClass(
    VOID
    );

BOOL
RegisterActionItemListControl(
    IN BOOL Init
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\liccpa\test\licsetup\resource.h ===
#define  IDC_STATICTITLE   100

#define  IDD_START_PAGE    1000
#define  IDD_FINISH_PAGE   1001

#define  IDB_WELCOME       1100
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\liccpa\test\licsetup\licsetup.cpp ===
//-------------------------------------------------------------------
//
// File:
//
// Summary;
//
// Notes;
//
// History
//
//-------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <setupapi.h>
#include <syssetup.h>
#include "resource.h"
#include "ctls.h"

#ifdef UNICODE
#  define TSTR_FMT "%ls"
#else
#  define TSTR_FMT "%s"
#endif

static
BOOL
TestInteractive(
   NETSETUPPAGEREQUESTPROC    pfnRequestPages );

static
BOOL
TestBatch(
   NETSETUPPAGEREQUESTPROC    pfnRequestPages );

static
BOOL
CALLBACK
StartPageDlgProc(
   HWND     hdlg,
   UINT     msg,
   WPARAM   wParam,
   LPARAM   lParam );

static
BOOL
CALLBACK
FinishPageDlgProc(
   HWND     hdlg,
   UINT     msg,
   WPARAM   wParam,
   LPARAM   lParam );

static
void
SetLargeDialogFont(
   HWND hdlg,
   UINT ControlId );

static
BOOL
LicenseKeysSave();

static
BOOL
LicenseKeysDelete();

static
BOOL
LicenseKeysRestore();

static
BOOL
LicenseKeysVerify(
   BOOL     fShouldBePresent,
   BOOL     fLicensePerServer,
   DWORD    cPerServerLicenses );

static
DWORD
MyRegDeleteKey(
   HKEY     hKeyParent,
   LPCTSTR  pcszKeyName );

TCHAR    g_szWizardTitle[]       = TEXT( "License Setup Test" );

TCHAR    g_szKeyLicenseService[] = TEXT( "System\\CurrentControlSet\\Services\\LicenseService" );
TCHAR    g_szKeyLicenseInfo[]    = TEXT( "System\\CurrentControlSet\\Services\\LicenseInfo" );
TCHAR    g_szKeyEventLog[]       = TEXT( "System\\CurrentControlSet\\Services\\EventLog\\Application\\LicenseService" );

LPTSTR   g_apszKeys[] =
{
   g_szKeyLicenseService,
   g_szKeyLicenseInfo,
   g_szKeyEventLog,
   NULL
};

TCHAR    g_szTempPath[ 1 + MAX_PATH ];

// paths to file in which to save license registry information
TCHAR    g_szKeyFileLicenseService[ 1 + MAX_PATH ];
TCHAR    g_szKeyFileLicenseInfo[    1 + MAX_PATH ];
TCHAR    g_szKeyFileEventLog[       1 + MAX_PATH ];

int _cdecl main( int argc, char *argv[ ], char *envp[ ] )
{
   BOOL                       fSuccess;
   HINSTANCE                  hLicCpa;
   NETSETUPPAGEREQUESTPROC    pfnRequestPages;
   BOOL                       fIsInteractive;
   BOOL                       fIsUsage;
   BOOL                       fIsRestore;
   LPSTR                      pszBadArg;

   printf( "\nLicense Setup Wizard Page Test for LICCPA.CPL\n\n" );

   fIsInteractive = FALSE;
   fIsUsage       = FALSE;
   fIsRestore     = FALSE;
   pszBadArg      = NULL;

   if ( 1 == argc )
   {
      printf( "Use \"%s /?\" for a list of command-line options.\n\n", argv[ 0 ] );
   }
   else
   {
      int      cCurArg;
      LPSTR *  ppszCurArg;

      for ( cCurArg = 1, ppszCurArg = argv;
            (    ( !fIsUsage         )
              && ( NULL == pszBadArg )
              && ( cCurArg < argc    ) );
            cCurArg++ )
      {
         ++ppszCurArg;

         if (    (    ( '-' == (*ppszCurArg)[ 0 ] )
                   || ( '/' == (*ppszCurArg)[ 0 ] ) )
              && ( '\0'     != (*ppszCurArg)[ 1 ]   ) )
         {
            DWORD    cchOption;

            cchOption = strlen( &( (*ppszCurArg)[ 1 ] ) );

            if ( !_strnicmp( &( (*ppszCurArg)[ 1 ] ), "interactive", min( cchOption, strlen( "interactive" ) ) ) )
            {
               fIsInteractive = TRUE;
            }
            else if (    !_strnicmp( &( (*ppszCurArg)[ 1 ] ), "help", min( cchOption, strlen( "help" ) ) )
                      || !_strnicmp( &( (*ppszCurArg)[ 1 ] ), "?",    min( cchOption, strlen( "?"    ) ) ) )
            {
               fIsUsage = TRUE;
            }
            else if ( !_strnicmp( &( (*ppszCurArg)[ 1 ] ), "restore", min( cchOption, strlen( "restore" ) ) ) )
            {
               fIsRestore = TRUE;
            }
            else
            {
               pszBadArg = *ppszCurArg;
            }
         }
         else
         {
            pszBadArg = *ppszCurArg;
         }
      }
   }

   if ( NULL != pszBadArg )
   {
      printf( "The argument \"%s\" is unrecognized.\n"
              "Use \"%s /?\" for a list of command-line options.\n",
              pszBadArg,
              argv[ 0 ] );

      fSuccess = FALSE;
   }
   else if ( fIsUsage )
   {
      printf( "Options: [ /? | /H | /HELP ]   Display option list.\n"
              "         [ /INTERACTIVE ]      Test the wizard page interactively.\n"
              "         [ /RESTORE ]          Restore licensing registry keys in the\n"
              "                               event that a program error kept them from\n"
              "                               being restored in a previous run.\n" );

      fSuccess = TRUE;
   }
   else
   {
      DWORD    cchTempPath;

      fSuccess = FALSE;

      cchTempPath = GetTempPath( sizeof( g_szTempPath ) / sizeof( *g_szTempPath ), g_szTempPath );

      if ( 0 == cchTempPath )
      {
         printf( "GetTempPath() failed, error %lu.\n", GetLastError() );
      }
      else
      {
         lstrcpy( g_szKeyFileLicenseService, g_szTempPath );
         lstrcpy( g_szKeyFileLicenseInfo,    g_szTempPath );
         lstrcpy( g_szKeyFileEventLog,       g_szTempPath );

         lstrcat( g_szKeyFileLicenseService, TEXT( "jbplskey" ) );
         lstrcat( g_szKeyFileLicenseInfo,    TEXT( "jbplikey" ) );
         lstrcat( g_szKeyFileEventLog,       TEXT( "jbpelkey" ) );

         if ( fIsRestore )
         {
            fSuccess = LicenseKeysRestore();
         }
         else
         {
            BOOL ok;

            fSuccess = FALSE;

            // init common control library
            InitCommonControls();

            ok = InitializeBmpClass();

            if ( !ok )
            {
               printf( "InitializeBmpClass() Failed!\n" );
            }
            else
            {
               hLicCpa = LoadLibrary( TEXT( "LicCpa.Cpl" ) );

               if ( NULL == hLicCpa )
               {
                  printf( "LoadLibary() Failed!\n" );
               }
               else
               {
                  pfnRequestPages = (NETSETUPPAGEREQUESTPROC) GetProcAddress( hLicCpa, "LicenseSetupRequestWizardPages" );

                  if ( NULL == pfnRequestPages )
                  {
                     printf( "GetProcAddress() Failed!\n" );
                  }
                  else if ( fIsInteractive )
                  {
                     fSuccess = TestInteractive( pfnRequestPages );
                  }
                  else
                  {
                     fSuccess = TestBatch( pfnRequestPages );
                  }

                  FreeLibrary( hLicCpa );
               }
            }

            if ( fSuccess )
            {
               printf( "\nTest completed successfully.\n" );
            }
            else
            {
               printf( "\nTest failed!\n" );
            }
         }
      }
   }

   return fSuccess ? 0 : -1;
}


static
BOOL
TestInteractive(
   NETSETUPPAGEREQUESTPROC    pfnRequestPages )
{
   BOOL                 fSuccess;
   UINT                 chpages;
   INTERNAL_SETUP_DATA  SetupData;
   BOOL                 ok;

   fSuccess = LicenseKeysSave();

   if ( fSuccess )
   {
      SetupData.dwSizeOf          = sizeof( SetupData );
      SetupData.SetupMode         = SETUPMODE_CUSTOM;
      SetupData.ProductType       = PRODUCT_SERVER_PRIMARY;
      SetupData.OperationFlags    = 0; // SETUPOPER_NTUPGRADE;
      SetupData.WizardTitle       = g_szWizardTitle;
      SetupData.SourcePath        = NULL;
      SetupData.UnattendFile      = NULL;
      SetupData.LegacySourcePath  = NULL;

      // get number pages the wizard needs
      ok = (*pfnRequestPages)( NULL, &chpages, &SetupData );

      if ( !ok )
      {
         // request number of pages failure
         printf( "Cannot retrieve number of pages!\n" );
      }
      else
      {
         HPROPSHEETPAGE *  phpage;

         // we will add anm intro and a finish page
         phpage = new HPROPSHEETPAGE[ chpages + 2 ];

         if ( NULL == phpage )
         {
            // memory allocation failue
            printf( "Cannot allocate memory!\n" );
         }
         else
         {
            ok = (*pfnRequestPages)( &phpage[ 1 ], &chpages, &SetupData );

            if ( !ok )
            {
               // request number of pages failure
               printf( "Cannot retrieve pages!\n" );
            }
            else
            {
               PROPSHEETPAGE  psp;

               psp.dwSize        = sizeof( psp );
               psp.dwFlags       = PSP_USETITLE;
               psp.hInstance     = GetModuleHandle( NULL );
               psp.pszTemplate   = MAKEINTRESOURCE( IDD_START_PAGE );
               psp.hIcon         = NULL;
               psp.pfnDlgProc    = StartPageDlgProc;
               psp.pszTitle      = SetupData.WizardTitle;
               psp.lParam        = 0;
               psp.pfnCallback   = NULL;

               phpage[ 0 ] = CreatePropertySheetPage( &psp );

               if ( NULL == phpage[ 0 ] )
               {
                  printf( "Cannot create start page!\n" );
               }
               else
               {
                  psp.dwSize        = sizeof( psp );
                  psp.dwFlags       = PSP_USETITLE;
                  psp.hInstance     = GetModuleHandle( NULL );
                  psp.pszTemplate   = MAKEINTRESOURCE( IDD_FINISH_PAGE );
                  psp.hIcon         = NULL;
                  psp.pfnDlgProc    = FinishPageDlgProc;
                  psp.pszTitle      = SetupData.WizardTitle;
                  psp.lParam        = 0;
                  psp.pfnCallback   = NULL;

                  phpage[ chpages + 1 ] = CreatePropertySheetPage( &psp );

                  if ( NULL == phpage[ chpages + 1 ] )
                  {
                     printf( "Cannot create finish page!\n" );
                  }
                  else
                  {
                     PROPSHEETHEADER   psh;
                     int               nResult;

                     // prep frame header
                     psh.dwSize        = sizeof( psh );
                     psh.dwFlags       = PSH_WIZARD;
                     psh.hwndParent    = NULL;
                     psh.hInstance     = GetModuleHandle( NULL );
                     psh.hIcon         = NULL;
                     psh.pszCaption    = NULL;
                     psh.nPages        = chpages + 2;
                     psh.nStartPage    = 0;
                     psh.phpage        = phpage;
                     psh.pfnCallback   = NULL;

                     // raise frame
                     PropertySheet( &psh );

                     fSuccess = TRUE;
                  }
               }
            }

            delete [] phpage;
         }
      }

      fSuccess = LicenseKeysRestore() && fSuccess;
   }

   return fSuccess;
}

static
BOOL
CALLBACK
StartPageDlgProc(
   HWND     hdlg,
   UINT     msg,
   WPARAM   wParam,
   LPARAM   lParam )
{
   static   BOOL  fIsBatch;

   BOOL     ok = TRUE;
   LPNMHDR  pnmh;

   switch ( msg )
   {
   case WM_INITDIALOG:
      fIsBatch = ( (LPPROPSHEETPAGE)lParam )->lParam;
      SetLargeDialogFont( hdlg, IDC_STATICTITLE );
      break;

   case WM_NOTIFY:
      pnmh = (LPNMHDR)lParam;

      switch (pnmh->code)
      {
      // propsheet notification
      case PSN_HELP:
         break;

      case PSN_SETACTIVE:
         // hide Cancel button
         EnableWindow( GetDlgItem( GetParent( hdlg ), IDCANCEL ), FALSE);
         ShowWindow(   GetDlgItem( GetParent( hdlg ), IDCANCEL ), SW_HIDE);

         PropSheet_SetWizButtons( GetParent( hdlg ), PSWIZB_NEXT );

         if ( fIsBatch )
         {
            // batch mode
            PostMessage( GetParent( hdlg ), PSM_PRESSBUTTON, (WPARAM)PSBTN_NEXT, 0 );
         }

         SetWindowLong( hdlg, DWL_MSGRESULT, 0 );
         break;

      case PSN_KILLACTIVE:
         SetWindowLong( hdlg, DWL_MSGRESULT, 0 );
         break;

      case PSN_WIZFINISH:
         SetWindowLong( hdlg, DWL_MSGRESULT, 0 );
         break;

      default:
         ok = TRUE;
         break;
      }
      break;

   default:
      ok = FALSE;
   }

   return ok;
}


static
BOOL
CALLBACK
FinishPageDlgProc(
   HWND     hdlg,
   UINT     msg,
   WPARAM   wParam,
   LPARAM   lParam )
{
   static   BOOL  fIsBatch;

   BOOL     ok = TRUE;
   LPNMHDR  pnmh;

   switch ( msg )
   {
   case WM_INITDIALOG:
      fIsBatch = ( (LPPROPSHEETPAGE)lParam )->lParam;
      SetLargeDialogFont( hdlg, IDC_STATICTITLE );
      break;

   case WM_NOTIFY:
      pnmh = (LPNMHDR)lParam;

      switch (pnmh->code)
      {
      // propsheet notification
      case PSN_HELP:
         break;

      case PSN_SETACTIVE:
         // hide Cancel button
         EnableWindow( GetDlgItem( GetParent( hdlg ), IDCANCEL ), FALSE);
         ShowWindow(   GetDlgItem( GetParent( hdlg ), IDCANCEL ), SW_HIDE);

         PropSheet_SetWizButtons( GetParent( hdlg ), PSWIZB_BACK | PSWIZB_FINISH );

         if ( fIsBatch )
         {
            // batch mode
            PostMessage( GetParent( hdlg ), PSM_PRESSBUTTON, (WPARAM)PSBTN_FINISH, 0 );
         }

         SetWindowLong( hdlg, DWL_MSGRESULT, 0 );
         break;

      case PSN_KILLACTIVE:
         SetWindowLong( hdlg, DWL_MSGRESULT, 0 );
         break;

      case PSN_WIZFINISH:
         SetWindowLong( hdlg, DWL_MSGRESULT, 0 );
         break;

      default:
         ok = TRUE;
         break;
      }
      break;

   default:
      ok = FALSE;
   }

   return ok;
}


static
void
SetLargeDialogFont(
   HWND hdlg,
   UINT ControlId )

/*++

Routine Description:

    Sets the font of a given control in a dialog to a
    larger point size.

    (Lifted from SetupSetLargeDialogFont() in
    \nt\private\windows\setup\syssetup\wizard.c.)

Arguments:

    hwnd - supplies window handle of the dialog containing
        the control.

    ControlId - supplies the id of the control whose font is
        to be made larger.

Return Value:

    None.

--*/

{
   //
   // We keep one log font around to satisfy the request.
   //
   static HFONT BigFont = NULL;

   HFONT    Font;
   LOGFONT  LogFont;
   WCHAR    str[24];
   int      Height;
   HDC      hdc;

   if ( !BigFont )
   {
      Font = (HFONT)SendDlgItemMessage( hdlg, ControlId, WM_GETFONT, 0, 0 );

      if ( NULL != Font )
      {
         if ( GetObject( Font, sizeof(LOGFONT), &LogFont ) )
         {
            //
            // Use a larger font in boldface. Get the face name and size in points
            // from the resources. We use 18 point in the U.S. but in the Far East
            // they will want to use a different size since the standard dialog font
            // is larger than the one we use in the U.S..
            //
            LogFont.lfWeight = FW_BOLD;

            lstrcpy( LogFont.lfFaceName, TEXT( "MS Serif" ) );
            Height = 18;

            hdc = GetDC( hdlg );

            if ( NULL != hdc )
            {
               // create font
               LogFont.lfHeight = 0 - ( GetDeviceCaps( hdc, LOGPIXELSY ) * Height / 72 );

               BigFont = CreateFontIndirect( &LogFont );

               ReleaseDC( hdlg, hdc );
            }
         }
      }
   }

   if ( NULL != BigFont )
   {
      // change font of ControlId to BigFont
      SendDlgItemMessage( hdlg, ControlId, WM_SETFONT, (WPARAM)BigFont, MAKELPARAM( TRUE, 0 ) );
   }
}


static
BOOL
TestBatch(
   NETSETUPPAGEREQUESTPROC    pfnRequestPages )
{
   BOOL     fSuccess;

   fSuccess = FALSE;

   // save registry keys before we go and overwrite them
   fSuccess = LicenseKeysSave();

   if ( fSuccess )
   {
      TCHAR    szTempFile[ 1 + MAX_PATH ];
      DWORD    cchTempFile;

      cchTempFile = GetTempFileName( g_szTempPath, TEXT( "JBP" ), 0, szTempFile );

      if ( 0 == cchTempFile )
      {
         printf( "GetTempFileName() failed, error %lu.\n", GetLastError() );
      }
      else
      {
         HANDLE   hUnattendFile;

         hUnattendFile = CreateFile( szTempFile,
                                     GENERIC_WRITE,
                                     FILE_SHARE_READ,
                                     NULL,
                                     CREATE_ALWAYS,
                                     FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE,
                                     NULL );

         if ( NULL == hUnattendFile )
         {
            printf( "CreateFile() on \""TSTR_FMT"\" failed, error %lu.\n",
                     szTempFile,
                     GetLastError() );
         }
         else
         {
            struct UnattendEntry
            {
               LPSTR    pszFileContents;
               BOOL     fLicensePerServer;
               DWORD    cPerServerLicenses;
            };

            static UnattendEntry aUnattendEntries[] =
            {
               { "[licensefileprintdata]\nautomode=perseat\nautousers=0\n",    FALSE, 0   },
               { "[licensefileprintdata]\nautomode=perseat\nautousers=100\n",  FALSE, 100 },
               { "[licensefileprintdata]\nautomode=perserver\nautousers=42\n", TRUE,  42  },
               { "[licensefileprintdata]\nautomode=perserver\nautousers=0\n",  TRUE,  0   },
               { NULL,                                                         FALSE, 0   }
            };

            DWORD    iEntry;

            for ( iEntry=0;
                  fSuccess && ( NULL != aUnattendEntries[ iEntry ].pszFileContents );
                  iEntry++ )
            {
               // delete current licensing info in registry
               fSuccess = LicenseKeysDelete();

               if ( fSuccess )
               {
                  DWORD    cbFilePos;

                  // erase file
                  cbFilePos = SetFilePointer( hUnattendFile, 0, NULL, FILE_BEGIN );

                  if ( 0xFFFFFFFF == cbFilePos )
                  {
                     printf( "SetFilePointer() failed, error %lu.\n", GetLastError() );
                  }
                  else
                  {
                     BOOL  ok;

                     ok = SetEndOfFile( hUnattendFile );

                     if ( !ok )
                     {
                        printf( "SetEndOfFile() failed, error %lu.\n", GetLastError() );
                     }
                     else
                     {
                        DWORD    cbBytesWritten;

                        // write new unattend file contents
                        ok = WriteFile( hUnattendFile,
                                        aUnattendEntries[ iEntry ].pszFileContents,
                                        lstrlenA( aUnattendEntries[ iEntry ].pszFileContents ),
                                        &cbBytesWritten,
                                        NULL );

                        if ( !ok )
                        {
                           printf( "WriteFile() failed, error %lu.\n", GetLastError() );
                        }
                        else
                        {
                           // run setup with this unattend file
                           UINT                 chpages;
                           INTERNAL_SETUP_DATA  SetupData;
                           BOOL                 ok;

                           fSuccess = FALSE;

                           SetupData.dwSizeOf          = sizeof( SetupData );
                           SetupData.SetupMode         = SETUPMODE_CUSTOM;
                           SetupData.ProductType       = PRODUCT_SERVER_PRIMARY;
                           SetupData.OperationFlags    = SETUPOPER_BATCH;
                           SetupData.WizardTitle       = g_szWizardTitle;
                           SetupData.SourcePath        = NULL;
                           SetupData.UnattendFile      = szTempFile;
                           SetupData.LegacySourcePath  = NULL;

                           // get number pages the wizard needs
                           ok = (*pfnRequestPages)( NULL, &chpages, &SetupData );

                           if ( !ok )
                           {
                              // request number of pages failure
                              printf( "Cannot retrieve number of pages!\n" );
                           }
                           else
                           {
                              HPROPSHEETPAGE *  phpage;

                              phpage = new HPROPSHEETPAGE[ chpages + 2 ];

                              if ( NULL == phpage )
                              {
                                 // memory allocation failue
                                 printf( "Cannot allocate memory!\n" );
                              }
                              else
                              {
                                 ok = (*pfnRequestPages)( &phpage[ 1 ], &chpages, &SetupData );

                                 if ( !ok )
                                 {
                                    // request number of pages failure
                                    printf( "Cannot retrieve pages!\n" );
                                 }
                                 else
                                 {
                                    PROPSHEETPAGE  psp;

                                    psp.dwSize        = sizeof( psp );
                                    psp.dwFlags       = PSP_USETITLE;
                                    psp.hInstance     = GetModuleHandle( NULL );
                                    psp.pszTemplate   = MAKEINTRESOURCE( IDD_START_PAGE );
                                    psp.hIcon         = NULL;
                                    psp.pfnDlgProc    = StartPageDlgProc;
                                    psp.pszTitle      = SetupData.WizardTitle;
                                    psp.lParam        = 1;
                                    psp.pfnCallback   = NULL;

                                    phpage[ 0 ] = CreatePropertySheetPage( &psp );

                                    if ( NULL == phpage[ 0 ] )
                                    {
                                       printf( "Cannot create start page!\n" );
                                    }
                                    else
                                    {
                                       psp.dwSize        = sizeof( psp );
                                       psp.dwFlags       = PSP_USETITLE;
                                       psp.hInstance     = GetModuleHandle( NULL );
                                       psp.pszTemplate   = MAKEINTRESOURCE( IDD_FINISH_PAGE );
                                       psp.hIcon         = NULL;
                                       psp.pfnDlgProc    = FinishPageDlgProc;
                                       psp.pszTitle      = SetupData.WizardTitle;
                                       psp.lParam        = 1;
                                       psp.pfnCallback   = NULL;

                                       phpage[ chpages + 1 ] = CreatePropertySheetPage( &psp );

                                       if ( NULL == phpage[ chpages + 1 ] )
                                       {
                                          printf( "Cannot create finish page!\n" );
                                       }
                                       else
                                       {
                                          PROPSHEETHEADER   psh;
                                          int               nResult;

                                          // prep frame header
                                          psh.dwSize        = sizeof( psh );
                                          psh.dwFlags       = PSH_WIZARD;
                                          psh.hwndParent    = NULL;
                                          psh.hInstance     = GetModuleHandle( NULL );
                                          psh.hIcon         = NULL;
                                          psh.pszCaption    = NULL;
                                          psh.nPages        = chpages + 2;
                                          psh.nStartPage    = 0;
                                          psh.phpage        = phpage;
                                          psh.pfnCallback   = NULL;

                                          // raise frame
                                          PropertySheet( &psh );

                                          fSuccess = LicenseKeysVerify( TRUE,
                                                                        aUnattendEntries[ iEntry ].fLicensePerServer,
                                                                        aUnattendEntries[ iEntry ].cPerServerLicenses );
                                       }
                                    }
                                 }

                                 delete [] phpage;
                              }
                           }
                        }
                     }
                  }
               }
            }

            CloseHandle( hUnattendFile );
         }
      }

      fSuccess = LicenseKeysRestore() && fSuccess;
   }

   return fSuccess;
}


static
BOOL
LicenseKeysSave()
{
   DWORD             winStatus;
   HANDLE            hToken;
   TOKEN_PRIVILEGES  tp;
   LUID              luid;
   BOOL              ok;

   // Enable backup privilege.
   ok = OpenProcessToken( GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                          &hToken ) ;

   if ( !ok )
   {
      winStatus = GetLastError();
      printf( "OpenProcessToken() failed, error %lu.\n", winStatus );
   }
   else
   {
      ok = LookupPrivilegeValue( NULL, SE_BACKUP_NAME, &luid );

      if ( !ok )
      {
         winStatus = GetLastError();
         printf( "LookupPrivilegeValue() failed, error %lu.\n", winStatus );
      }
      else
      {
         tp.PrivilegeCount           = 1;
         tp.Privileges[0].Luid       = luid;
         tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

         ok = AdjustTokenPrivileges( hToken,
                                     FALSE,
                                     &tp,
                                     sizeof(TOKEN_PRIVILEGES),
                                     NULL,
                                     NULL );

         if ( !ok )
         {
            winStatus = GetLastError();
            printf( "AdjustTokenPrivileges() failed, error %lu.\n", winStatus );
         }
         else
         {
            HKEY     hKeyLicenseService;
            HKEY     hKeyLicenseInfo;
            HKEY     hKeyEventLog;

            winStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                      g_szKeyLicenseService,
                                      0,
                                      KEY_ALL_ACCESS,
                                      &hKeyLicenseService );

            if ( ERROR_SUCCESS != winStatus )
            {
               printf( "RegOpenKeyEx() on \""TSTR_FMT"\" failed, error %lu.\n"
                       "   o Was the license service not properly installed?\n"
                       "   o Are you running on Workstation instead of Server?\n"
                       "   o Was the registry wiped and not restored in a previous run?\n"
                       "     (In this case, use the /RESTORE option!)\n",
                       g_szKeyLicenseService,
                       winStatus );
            }
            else
            {
               winStatus = RegSaveKey( hKeyLicenseService, g_szKeyFileLicenseService, NULL );

               if ( ERROR_SUCCESS != winStatus )
               {
                  printf( "RegSaveKey() on \""TSTR_FMT"\" failed, error %lu.\n"
                          "   o Does the temp directory \""TSTR_FMT"\" not exist?\n"
                          "   o Does the file \""TSTR_FMT"\" already exist?\n",
                          g_szKeyLicenseService,
                          winStatus,
                          g_szTempPath,
                          g_szKeyFileLicenseService );
               }
               else
               {
                  winStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                            g_szKeyLicenseInfo,
                                            0,
                                            KEY_ALL_ACCESS,
                                            &hKeyLicenseInfo );

                  if ( ERROR_SUCCESS != winStatus )
                  {
                     printf( "RegOpenKeyEx() on \""TSTR_FMT"\" failed, error %lu.\n"
                             "   o Was the license service not properly installed?\n"
                             "   o Are you running on Workstation instead of Server?\n",
                             "   o Was the registry wiped and not restored in a previous run?\n"
                             "     (In this case, use the /RESTORE option!)\n",
                             g_szKeyLicenseInfo,
                             winStatus );

                     DeleteFile( g_szKeyFileLicenseService );
                  }
                  else
                  {
                     winStatus = RegSaveKey( hKeyLicenseInfo, g_szKeyFileLicenseInfo, NULL );

                     if ( ERROR_SUCCESS != winStatus )
                     {
                        printf( "RegSaveKey() on \""TSTR_FMT"\" failed, error %lu.\n"
                                "   o Does the temp directory \""TSTR_FMT"\" not exist?\n"
                                "   o Does the file \""TSTR_FMT"\" already exist?\n",
                                g_szKeyLicenseInfo,
                                winStatus,
                                g_szTempPath,
                                g_szKeyFileLicenseInfo );
                     }
                     else
                     {
                        winStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                                  g_szKeyEventLog,
                                                  0,
                                                  KEY_ALL_ACCESS,
                                                  &hKeyEventLog );

                        if ( ERROR_SUCCESS != winStatus )
                        {
                           printf( "RegOpenKeyEx() on \""TSTR_FMT"\" failed, error %lu.\n"
                                   "   o Was the license service not properly installed?\n"
                                   "   o Are you running on Workstation instead of Server?\n",
                                   "   o Was the registry wiped and not restored in a previous run?\n"
                                   "     (In this case, use the /RESTORE option!)\n",
                                   g_szKeyEventLog,
                                   winStatus );

                           DeleteFile( g_szKeyFileLicenseInfo );
                        }
                        else
                        {
                           winStatus = RegSaveKey( hKeyEventLog, g_szKeyFileEventLog, NULL );

                           if ( ERROR_SUCCESS != winStatus )
                           {
                              printf( "RegSaveKey() on \""TSTR_FMT"\" failed, error %lu.\n"
                                      "   o Does the temp directory \""TSTR_FMT"\" not exist?\n"
                                      "   o Does the file \""TSTR_FMT"\" already exist?\n",
                                      g_szKeyEventLog,
                                      winStatus,
                                      g_szTempPath,
                                      g_szKeyFileEventLog );
                           }

                           RegCloseKey( hKeyEventLog );
                        }
                     }

                     RegCloseKey( hKeyLicenseInfo );
                  }
               }

               RegCloseKey( hKeyLicenseService );
            }

            // Disable backup privilege.
            AdjustTokenPrivileges( hToken,
                                   TRUE,
                                   &tp,
                                   sizeof(TOKEN_PRIVILEGES),
                                   NULL,
                                   NULL );
         }
      }
   }

   if ( ERROR_SUCCESS != winStatus )
   {
      printf( "The license info in the registry could not be saved!\n" );

      return FALSE;
   }
   else
   {
      printf( "The license info in the registry has been saved.\n" );

      return TRUE;
   }
}


static
BOOL
LicenseKeysDelete()
{
   DWORD    winStatus;
   DWORD    iKey;
   DWORD    iLastBackslash;

   SC_HANDLE   hSC;

   winStatus = ERROR_SUCCESS;

   hSC = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );

   if ( NULL == hSC )
   {
      winStatus = GetLastError();
      printf( "OpenSCManager() failed, error %lu.\n", winStatus );
   }
   else
   {
      SC_HANDLE   hLicenseService;

      hLicenseService = OpenService( hSC, TEXT( "LicenseService" ), SERVICE_ALL_ACCESS );

      if ( NULL == hLicenseService )
      {
         winStatus = GetLastError();

         if ( ERROR_SERVICE_DOES_NOT_EXIST == winStatus )
         {
            // license service not configured; no need to stop or delete
            winStatus = ERROR_SUCCESS;
         }
         else
         {
            printf( "OpenService() failed, error %lu.\n", winStatus );
         }
      }
      else
      {
         BOOL              ok;
         SERVICE_STATUS    SvcStatus;

         // stop license service
         ok = ControlService( hLicenseService,
                              SERVICE_CONTROL_STOP,
                              &SvcStatus );

         if ( !ok )
         {
            winStatus = GetLastError();

            if ( ERROR_SERVICE_NOT_ACTIVE == winStatus )
            {
               // license service not running; no need to stop
               winStatus = ERROR_SUCCESS;
            }
            else
            {
               printf( "ControlService() failed, error %lu.\n", winStatus );
            }
         }

         if (    ( ERROR_SUCCESS == winStatus                       )
              && ( SERVICE_STOP_PENDING == SvcStatus.dwCurrentState ) )
         {
            DWORD dwOldCheckPoint;

            printf( "License Service is stopping.." );

            ok = TRUE;

            while ( ok && ( SvcStatus.dwCurrentState == SERVICE_STOP_PENDING ) )
            {
               printf( "." );

               dwOldCheckPoint = SvcStatus.dwCheckPoint;
               Sleep( SvcStatus.dwWaitHint );

               ok = QueryServiceStatus( hLicenseService,
                                        &SvcStatus );

               if ( dwOldCheckPoint >= SvcStatus.dwCheckPoint )
                  break;
            }

            printf( "\n" );

            if ( !ok )
            {
               winStatus = GetLastError();
               printf( "ControlService() failed, error %lu.\n", winStatus );
            }
            else if ( SvcStatus.dwCurrentState != SERVICE_STOPPED )
            {
               winStatus = ERROR_SERVICE_REQUEST_TIMEOUT;
               printf( "License Service failed to stop!\n" );
            }
            else
            {
               winStatus = ERROR_SUCCESS;
               printf( "License Service stopped.\n" );
            }
         }

         if ( ERROR_SUCCESS == winStatus )
         {
            // delete service
            ok = DeleteService( hLicenseService );

            if ( !ok )
            {
               winStatus = GetLastError();
               printf( "DeleteService() failed, error %lu.\n", winStatus );
            }
            else
            {
               winStatus = ERROR_SUCCESS;
               printf( "License Service deleted.\n" );
            }
         }

         CloseServiceHandle( hLicenseService );
      }

      CloseServiceHandle( hSC );
   }

   if ( ERROR_SUCCESS == winStatus )
   {
      // delete keys
      for ( iKey=0, winStatus = ERROR_SUCCESS;
            ( NULL != g_apszKeys[ iKey ] ) && ( ERROR_SUCCESS == winStatus );
            iKey++ )
      {
         TCHAR    szKeyParent[ 1 + MAX_PATH ];
         TCHAR    szKey[ 1 + MAX_PATH ];
         HKEY     hKeyParent;

         lstrcpy( szKeyParent, g_apszKeys[ iKey ] );

         for ( iLastBackslash = lstrlen( szKeyParent ) - 1;
               TEXT( '\\' ) != szKeyParent[ iLastBackslash ];
               iLastBackslash-- )
         {
            ;
         }

         szKeyParent[ iLastBackslash ] = TEXT( '\0' );
         lstrcpy( szKey, &szKeyParent[ iLastBackslash + 1 ] );

         winStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                   szKeyParent,
                                   0,
                                   KEY_ALL_ACCESS,
                                   &hKeyParent );

         if ( ERROR_SUCCESS != winStatus )
         {
            printf( "RegOpenKeyEx() on \""TSTR_FMT"\" failed, error %lu.\n",
                    szKeyParent,
                    winStatus );
         }
         else
         {
            winStatus = MyRegDeleteKey( hKeyParent, szKey );

            if ( ERROR_FILE_NOT_FOUND == winStatus )
            {
               winStatus = ERROR_SUCCESS;
            }
            else if ( ERROR_SUCCESS != winStatus )
            {
               printf( "MyRegDeleteKey() on \""TSTR_FMT"\" failed, error %lu.\n",
                       g_apszKeys[ iKey ],
                       winStatus );
            }

            RegCloseKey( hKeyParent );
         }
      }
   }

   if ( ERROR_SUCCESS != winStatus )
   {
      printf( "Could not delete licensing registry keys!\n" );

      return FALSE;
   }
   else
   {
      printf( "Licensing registry keys deleted.\n" );

      return TRUE;
   }
}


static
BOOL
LicenseKeysRestore()
{
   DWORD             winStatus;
   DWORD             winStatusRestoreLicenseService;
   DWORD             winStatusRestoreLicenseInfo;
   DWORD             winStatusRestoreEventLog;

   HANDLE            hToken;
   TOKEN_PRIVILEGES  tp;
   LUID              luid;
   BOOL              ok;

   winStatus = ERROR_SUCCESS;

   // Enable backup privilege.
   ok = OpenProcessToken( GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                          &hToken ) ;

   if ( !ok )
   {
      winStatus = GetLastError();
      printf( "OpenProcessToken() failed, error %lu.\n", winStatus );
   }
   else
   {
      ok = LookupPrivilegeValue( NULL, SE_RESTORE_NAME, &luid );

      if ( !ok )
      {
         winStatus = GetLastError();
         printf( "LookupPrivilegeValue() failed, error %lu.\n", winStatus );
      }
      else
      {
         tp.PrivilegeCount           = 1;
         tp.Privileges[0].Luid       = luid;
         tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

         ok = AdjustTokenPrivileges( hToken,
                                     FALSE,
                                     &tp,
                                     sizeof(TOKEN_PRIVILEGES),
                                     NULL,
                                     NULL );

         if ( !ok )
         {
            winStatus = GetLastError();
            printf( "AdjustTokenPrivileges() failed, error %lu.\n", winStatus );
         }
         else
         {
            HKEY     hKeyLicenseService;
            HKEY     hKeyLicenseInfo;
            HKEY     hKeyEventLog;
            DWORD    dwDisposition;

            winStatusRestoreLicenseService = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                                                             g_szKeyLicenseService,
                                                             0,
                                                             NULL,
                                                             0,
                                                             KEY_ALL_ACCESS,
                                                             NULL,
                                                             &hKeyLicenseService,
                                                             &dwDisposition );

            if ( ERROR_SUCCESS != winStatusRestoreLicenseService )
            {
               printf( "RegCreateKeyEx() of \""TSTR_FMT"\" failed, error %lu.\n",
                       g_szKeyLicenseService,
                       winStatusRestoreLicenseService );
            }
            else
            {
               winStatusRestoreLicenseService = RegRestoreKey( hKeyLicenseService, g_szKeyFileLicenseService, 0 );

               if ( ERROR_SUCCESS != winStatusRestoreLicenseService )
               {
                  printf( "RegRestoreKey() of \""TSTR_FMT"\" failed, error %lu.\n",
                          g_szKeyLicenseService,
                          winStatusRestoreLicenseService );
               }
               else
               {
                  DeleteFile( g_szKeyFileLicenseService );
               }

               RegCloseKey( hKeyLicenseService );
            }

            winStatusRestoreLicenseInfo = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                                                          g_szKeyLicenseInfo,
                                                          0,
                                                          NULL,
                                                          0,
                                                          KEY_ALL_ACCESS,
                                                          NULL,
                                                          &hKeyLicenseInfo,
                                                          &dwDisposition );

            if ( ERROR_SUCCESS != winStatusRestoreLicenseInfo )
            {
               printf( "RegCreateKeyEx() of \""TSTR_FMT"\" failed, error %lu.\n",
                       g_szKeyLicenseInfo,
                       winStatusRestoreLicenseInfo );
            }
            else
            {
               winStatusRestoreLicenseInfo = RegRestoreKey( hKeyLicenseInfo, g_szKeyFileLicenseInfo, 0 );

               if ( ERROR_SUCCESS != winStatusRestoreLicenseInfo )
               {
                  printf( "RegRestoreKey() of \""TSTR_FMT"\" failed, error %lu.\n",
                          g_szKeyLicenseInfo,
                          winStatusRestoreLicenseInfo );
               }
               else
               {
                  DeleteFile( g_szKeyFileLicenseInfo );
               }

               RegCloseKey( hKeyLicenseInfo );
            }

            winStatusRestoreEventLog = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                                                       g_szKeyEventLog,
                                                       0,
                                                       NULL,
                                                       0,
                                                       KEY_ALL_ACCESS,
                                                       NULL,
                                                       &hKeyEventLog,
                                                       &dwDisposition );

            if ( ERROR_SUCCESS != winStatusRestoreEventLog )
            {
               printf( "RegCreateKeyEx() of \""TSTR_FMT"\" failed, error %lu.\n",
                       g_szKeyEventLog,
                       winStatusRestoreEventLog );
            }
            else
            {
               winStatusRestoreEventLog = RegRestoreKey( hKeyEventLog, g_szKeyFileEventLog, 0 );

               if ( ERROR_SUCCESS != winStatusRestoreEventLog )
               {
                  printf( "RegRestoreKey() of \""TSTR_FMT"\" failed, error %lu.\n",
                          g_szKeyEventLog,
                          winStatusRestoreEventLog );
               }
               else
               {
                  DeleteFile( g_szKeyFileEventLog );
               }

               RegCloseKey( hKeyEventLog );
            }

            // Disable backup privilege.
            AdjustTokenPrivileges( hToken,
                                   TRUE,
                                   &tp,
                                   sizeof(TOKEN_PRIVILEGES),
                                   NULL,
                                   NULL );
         }
      }
   }

   if (    ( ERROR_SUCCESS != winStatus                      )
        || ( ERROR_SUCCESS != winStatusRestoreLicenseService )
        || ( ERROR_SUCCESS != winStatusRestoreLicenseInfo    )
        || ( ERROR_SUCCESS != winStatusRestoreEventLog       ) )
   {
      printf( "!! WARNING !!  The license info in the registry has not been fully restored!\n" );

      return FALSE;
   }
   else
   {
      printf( "The license info in the registry has been fully restored.\n" );

      return TRUE;
   }
}

static
DWORD
MyRegDeleteKey(
   HKEY     hKeyParent,
   LPCTSTR  pcszKeyName )
{
   DWORD    winStatus;
   TCHAR    szSubKeyToDelete[ 256 ];
   HKEY     hKey;

   // try to delete it outright
   winStatus = RegDeleteKey( hKeyParent, pcszKeyName );

   if ( ERROR_SUCCESS != winStatus )
   {
      // could not delete it; perhaps the key has children
      // that we must delete first?
      winStatus = RegOpenKeyEx( hKeyParent,
                                pcszKeyName,
                                0,
                                KEY_ALL_ACCESS,
                                &hKey );

      if ( ERROR_SUCCESS == winStatus )
      {
         do
         {
            winStatus = RegEnumKey( hKey,
                                    0,
                                    szSubKeyToDelete,
                                    sizeof( szSubKeyToDelete ) / sizeof( *szSubKeyToDelete ) );

            if ( ERROR_SUCCESS == winStatus )
            {
               // recursively try to delete this subkey
               winStatus = MyRegDeleteKey( hKey, szSubKeyToDelete );
            }
         } while ( ERROR_SUCCESS == winStatus );

         // we've tried tried to delete all the key's children;
         // try deleting the key again
         winStatus = RegDeleteKey( hKeyParent, pcszKeyName );
      }
   }

   return winStatus;
}


static
BOOL
LicenseKeysVerify(
   BOOL     fShouldBePresent,
   BOOL     fLicensePerServer,
   DWORD    cPerServerLicenses )
//
// Verify service config:
//
//    lpServiceName        = "LicenseService"
//    lpDisplayName        = "License Logging Service"
//    dwServiceType        = SERVICE_WIN32_OWN_PROCESS
//    dwStartType          = LanManServerInstalled ? SERVICE_AUTO_START : SERVICE_DISABLED
//    dwErrorControl       = SERVICE_ERROR_NORMAL
//    lpBinaryPathName     = "%SystemRoot%\\System32\\llssrv.exe"
//    lpLoadOrderGroup     = NULL
//    lpdwTagId            = NULL
//    lpDependencies       = NULL
//    lpServiceStartName   = NULL
//    lpPassword           = NULL
//
// Verify registry values:
//
//    HKEY_LOCAL_MACHINE
//       \System
//          \CurrentControlSet
//             \Services
//                \LicenseInfo
//                      ErrorControl : REG_DWORD : 1
//                      Start        : REG_DWORD : 3
//                      Type         : REG_DWORD : 4
//                      \FilePrint
//                         ConcurrentLimit   : REG_DWORD : fLicensePerServer ? cPerServerLicenses : 0
//                         DisplayName       : REG_SZ    : "Windows NT Server"
//                         FamilyDisplayName : REG_SZ    : "Windows NT Server"
//                         Mode              : REG_DWORD : fLicensePerServer ? 1 : 0
//                         FlipAllow         : REG_DWORD : fLicensePerServer ? 1 : 0
//                \LicenseService
//                   \FilePrint
//                      \KSecDD
//                      \MSAfpSrv
//                      \SMBServer
//                      \TCP/IP Print Server
//                   \Parameters
//                      UseEnterprise    : REG_DWORD : 0
//                      ReplicationType  : REG_DWORD : 0
//                      ReplicationTime  : REG_DWORD : 24 * 60 * 60
//                      EnterpriseServer : REG_SZ    : ""
//                \EventLog
//                   \Application
//                      \LicenseService
//                         EventMessageFile : REG_EXPAND_SZ : %SystemRoot%\System32\llsrpc.dll
//                         TypesSupported   : REG_DWORD     : 7
//
{
   BOOL        fSuccess;
   DWORD       winStatus;

   // check service config
   if ( !fShouldBePresent )
   {
      fSuccess = TRUE;
   }
   else
   {
      SC_HANDLE   hSC;

      fSuccess = FALSE;

      hSC = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );

      if ( NULL == hSC )
      {
         printf( "OpenSCManager() failed, error %lu.\n", GetLastError() );
      }
      else
      {
         SC_HANDLE   hLicenseService;

         hLicenseService = OpenService( hSC, TEXT( "LicenseService" ), SERVICE_ALL_ACCESS );

         if ( NULL == hLicenseService )
         {
            printf( "OpenService() failed, error %lu.\n", GetLastError() );
         }
         else
         {
            BOOL                    ok;
            BYTE                    abLicenseServiceConfig[ 4096 ];
            LPQUERY_SERVICE_CONFIG  pLicenseServiceConfig;
            DWORD                   cbLicenseServiceConfigNeeded;

            pLicenseServiceConfig = (LPQUERY_SERVICE_CONFIG) abLicenseServiceConfig;

            ok = QueryServiceConfig( hLicenseService,
                                     pLicenseServiceConfig,
                                     sizeof( abLicenseServiceConfig ),
                                     &cbLicenseServiceConfigNeeded );

            if ( !ok )
            {
               printf( "QueryServiceConfig() failed, error %lu.\n", GetLastError() );
            }
            else if (    ( SERVICE_WIN32_OWN_PROCESS != pLicenseServiceConfig->dwServiceType   )
                      || ( SERVICE_AUTO_START        != pLicenseServiceConfig->dwStartType     )
                      || ( SERVICE_ERROR_NORMAL      != pLicenseServiceConfig->dwErrorControl  )
                      || lstrcmpi( TEXT( "" ),                                   pLicenseServiceConfig->lpLoadOrderGroup )
                      || lstrcmpi( TEXT( "" ),                                   pLicenseServiceConfig->lpDependencies )
                      || lstrcmpi( TEXT( "LocalSystem" ),                        pLicenseServiceConfig->lpServiceStartName )
                    //|| lstrcmpi( TEXT( "%SystemRoot%\\System32\\llssrv.exe" ), pLicenseServiceConfig->lpBinaryPathName )
                    //|| lstrcmp(  TEXT( "License Logging Service" ),            pLicenseServiceConfig->lpDisplayName )
                    )
            {
               printf( "LicenseService was incorrectly configured!\n" );
            }
            else
            {
               fSuccess = TRUE;
            }

            CloseServiceHandle( hLicenseService );
         }

         CloseServiceHandle( hSC );
      }
   }

   if ( fSuccess )
   {
      // check LicenseService\FilePrint
      HKEY     hKeyFilePrint;

      fSuccess = FALSE;

      winStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                TEXT( "System\\CurrentControlSet\\Services\\LicenseService\\FilePrint" ),
                                0,
                                KEY_ALL_ACCESS,
                                &hKeyFilePrint );

      if ( !fShouldBePresent )
      {
         if ( ERROR_SUCCESS == winStatus )
         {
            printf( "\"...\\Services\\LicenseService\\FilePrint\" exists but shouldn't!\n" );
         }
         else
         {
            fSuccess = TRUE;
         }
      }
      else if ( ERROR_SUCCESS != winStatus )
      {
         printf( "RegOpenKeyEx() on \"...\\Services\\LicenseService\\FilePrint\" failed, error %lu.\n",
                 winStatus );
      }
      else
      {
         static LPTSTR apszFilePrintServices[] =
         {
            TEXT( "KSecDD" ),
            TEXT( "MSAfpSrv" ),
            TEXT( "SMBServer" ),
            TEXT( "TCP/IP Print Server" ),
            NULL
         };

         DWORD    iService;

         fSuccess = TRUE;

         for ( iService=0; fSuccess && ( NULL != apszFilePrintServices[ iService ] ); iService++ )
         {
            HKEY  hKeyFilePrintService;

            winStatus = RegOpenKeyEx( hKeyFilePrint,
                                      apszFilePrintServices[ iService ],
                                      0,
                                      KEY_ALL_ACCESS,
                                      &hKeyFilePrintService );

            if ( ERROR_SUCCESS != winStatus )
            {
               printf( "RegOpenKeyEx() on \""TSTR_FMT"\" failed, error %lu.\n",
                       apszFilePrintServices[ iService ],
                       winStatus );

               fSuccess = FALSE;
            }
            else
            {
               RegCloseKey( hKeyFilePrintService );
            }
         }

         RegCloseKey( hKeyFilePrint );
      }
   }

   if ( fSuccess )
   {
      // check LicenseService\Parameters
      HKEY     hKeyParameters;

      fSuccess = FALSE;

      winStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                TEXT( "System\\CurrentControlSet\\Services\\LicenseService\\Parameters" ),
                                0,
                                KEY_ALL_ACCESS,
                                &hKeyParameters );

      if ( !fShouldBePresent )
      {
         if ( ERROR_SUCCESS == winStatus )
         {
            printf( "\"...\\Services\\LicenseService\\Parameters\" exists but shouldn't!\n" );
         }
         else
         {
            fSuccess = TRUE;
         }
      }
      else if ( ERROR_SUCCESS != winStatus )
      {
         printf( "RegOpenKeyEx() on \"...\\Services\\LicenseService\\Parameters\" failed, error %lu.\n",
                 winStatus );
      }
      else
      {
         // UseEnterprise    : REG_DWORD : 0
         // ReplicationType  : REG_DWORD : 0
         // ReplicationTime  : REG_DWORD : 24 * 60 * 60
         // EnterpriseServer : REG_SZ    : ""

         DWORD    dwType;
         DWORD    dwValue;
         DWORD    cbValue;
         TCHAR    szValue[ 1 + MAX_PATH ];

         cbValue = sizeof( dwValue );
         winStatus = RegQueryValueEx( hKeyParameters,
                                      TEXT( "UseEnterprise" ),
                                      NULL,
                                      &dwType,
                                      (LPBYTE) &dwValue,
                                      &cbValue );

         if ( ERROR_SUCCESS != winStatus )
         {
            printf( "RegQueryValueEx() on \"UseEnterprise\" failed, error %lu.\n",
                    winStatus );
         }
         else if ( ( REG_DWORD != dwType ) || ( 0 != dwValue ) )
         {
            printf( "\"UseEnterprise\" has incorrect value!\n" );
         }
         else
         {
            cbValue = sizeof( dwValue );
            winStatus = RegQueryValueEx( hKeyParameters,
                                         TEXT( "ReplicationType" ),
                                         NULL,
                                         &dwType,
                                         (LPBYTE) &dwValue,
                                         &cbValue );

            if ( ERROR_SUCCESS != winStatus )
            {
               printf( "RegQueryValueEx() on \"ReplicationType\" failed, error %lu.\n",
                       winStatus );
            }
            else if ( ( REG_DWORD != dwType ) || ( 0 != dwValue ) )
            {
               printf( "\"ReplicationType\" has incorrect value!\n" );
            }
            else
            {
               cbValue = sizeof( dwValue );
               winStatus = RegQueryValueEx( hKeyParameters,
                                            TEXT( "ReplicationTime" ),
                                            NULL,
                                            &dwType,
                                            (LPBYTE) &dwValue,
                                            &cbValue );

               if ( ERROR_SUCCESS != winStatus )
               {
                  printf( "RegQueryValueEx() on \"ReplicationTime\" failed, error %lu.\n",
                          winStatus );
               }
               else if ( ( REG_DWORD != dwType ) || ( 24L * 60L * 60L != dwValue ) )
               {
                  printf( "\"ReplicationTime\" has incorrect value!\n" );
               }
               else
               {
                  cbValue = sizeof( szValue );
                  winStatus = RegQueryValueEx( hKeyParameters,
                                               TEXT( "EnterpriseServer" ),
                                               NULL,
                                               &dwType,
                                               (LPBYTE) szValue,
                                               &cbValue );

                  if ( ERROR_SUCCESS != winStatus )
                  {
                     printf( "RegQueryValueEx() on \"EnterpriseServer\" failed, error %lu.\n",
                             winStatus );
                  }
                  else if ( ( REG_SZ != dwType ) || ( TEXT( '\0' ) != szValue[ 0 ] ) )
                  {
                     printf( "\"EnterpriseServer\" has incorrect value!\n" );
                  }
                  else
                  {
                     fSuccess = TRUE;
                  }
               }
            }
         }

         RegCloseKey( hKeyParameters );
      }
   }

   if ( fSuccess )
   {
      // check LicenseInfo
      HKEY     hKeyLicenseInfo;

      fSuccess = FALSE;

      winStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                TEXT( "System\\CurrentControlSet\\Services\\LicenseInfo" ),
                                0,
                                KEY_ALL_ACCESS,
                                &hKeyLicenseInfo );

      if ( !fShouldBePresent )
      {
         if ( ERROR_SUCCESS == winStatus )
         {
            printf( "\"...\\Services\\LicenseInfo\" exists but shouldn't!\n" );
         }
         else
         {
            fSuccess = TRUE;
         }
      }
      else if ( ERROR_SUCCESS != winStatus )
      {
         printf( "RegOpenKeyEx() on \"...\\Services\\LicenseInfo\" failed, error %lu.\n",
                 winStatus );
      }
      else
      {
         // ErrorControl : REG_DWORD : 1
         // Start        : REG_DWORD : 3
         // Type         : REG_DWORD : 4

         DWORD    dwType;
         DWORD    dwValue;
         DWORD    cbValue;

         cbValue = sizeof( dwValue );
         winStatus = RegQueryValueEx( hKeyLicenseInfo,
                                      TEXT( "ErrorControl" ),
                                      NULL,
                                      &dwType,
                                      (LPBYTE) &dwValue,
                                      &cbValue );

         if ( ERROR_SUCCESS != winStatus )
         {
            printf( "RegQueryValueEx() on \"ErrorControl\" failed, error %lu.\n",
                    winStatus );
         }
         else if ( ( REG_DWORD != dwType ) || ( 1 != dwValue ) )
         {
            printf( "\"ErrorControl\" has incorrect value!\n" );
         }
         else
         {
            cbValue = sizeof( dwValue );
            winStatus = RegQueryValueEx( hKeyLicenseInfo,
                                         TEXT( "Start" ),
                                         NULL,
                                         &dwType,
                                         (LPBYTE) &dwValue,
                                         &cbValue );

            if ( ERROR_SUCCESS != winStatus )
            {
               printf( "RegQueryValueEx() on \"Start\" failed, error %lu.\n",
                       winStatus );
            }
            else if ( ( REG_DWORD != dwType ) || ( 3 != dwValue ) )
            {
               printf( "\"Start\" has incorrect value!\n" );
            }
            else
            {
               cbValue = sizeof( dwValue );
               winStatus = RegQueryValueEx( hKeyLicenseInfo,
                                            TEXT( "Type" ),
                                            NULL,
                                            &dwType,
                                            (LPBYTE) &dwValue,
                                            &cbValue );

               if ( ERROR_SUCCESS != winStatus )
               {
                  printf( "RegQueryValueEx() on \"Type\" failed, error %lu.\n",
                          winStatus );
               }
               else if ( ( REG_DWORD != dwType ) || ( 4 != dwValue ) )
               {
                  printf( "\"Type\" has incorrect value!\n" );
               }
               else
               {
                  fSuccess = TRUE;
               }
            }
         }

         RegCloseKey( hKeyLicenseInfo );
      }
   }

   if ( fSuccess )
   {
      // check LicenseInfo\FilePrint
      HKEY     hKeyFilePrint;

      fSuccess = FALSE;

      winStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                TEXT( "System\\CurrentControlSet\\Services\\LicenseInfo\\FilePrint" ),
                                0,
                                KEY_ALL_ACCESS,
                                &hKeyFilePrint );

      if ( !fShouldBePresent )
      {
         if ( ERROR_SUCCESS == winStatus )
         {
            printf( "\"...\\EventLog\\Application\\LicenseInfo\\FilePrint\" exists but shouldn't!\n" );
         }
         else
         {
            fSuccess = TRUE;
         }
      }
      else if ( ERROR_SUCCESS != winStatus )
      {
         printf( "RegOpenKeyEx() on \"...\\Services\\LicenseInfo\\FilePrint\" failed, error %lu.\n",
                 winStatus );
      }
      else
      {
         // ConcurrentLimit   : REG_DWORD : fLicensePerServer ? cPerServerLicenses : 0
         // DisplayName       : REG_SZ    : "Windows NT Server"
         // FamilyDisplayName : REG_SZ    : "Windows NT Server"
         // Mode              : REG_DWORD : fLicensePerServer ? 1 : 0
         // FlipAllow         : REG_DWORD : fLicensePerServer ? 1 : 0

         DWORD    dwType;
         DWORD    dwValue;
         DWORD    cbValue;
         TCHAR    szValue[ 1 + MAX_PATH ];

         cbValue = sizeof( dwValue );
         winStatus = RegQueryValueEx( hKeyFilePrint,
                                      TEXT( "ConcurrentLimit" ),
                                      NULL,
                                      &dwType,
                                      (LPBYTE) &dwValue,
                                      &cbValue );

         if ( ERROR_SUCCESS != winStatus )
         {
            printf( "RegQueryValueEx() on \"ConcurrentLimit\" failed, error %lu.\n",
                    winStatus );
         }
         else if (    ( REG_DWORD != dwType )
                   || ( ( fLicensePerServer ? cPerServerLicenses : 0 ) != dwValue ) )
         {
            printf( "\"ConcurrentLimit\" has incorrect value!\n" );
         }
         else
         {
            cbValue = sizeof( dwValue );
            winStatus = RegQueryValueEx( hKeyFilePrint,
                                         TEXT( "Mode" ),
                                         NULL,
                                         &dwType,
                                         (LPBYTE) &dwValue,
                                         &cbValue );

            if ( ERROR_SUCCESS != winStatus )
            {
               printf( "RegQueryValueEx() on \"Mode\" failed, error %lu.\n",
                       winStatus );
            }
            else if ( ( REG_DWORD != dwType ) || ( (DWORD) fLicensePerServer != dwValue ) )
            {
               printf( "\"Mode\" has incorrect value!\n" );
            }
            else
            {
               cbValue = sizeof( dwValue );
               winStatus = RegQueryValueEx( hKeyFilePrint,
                                            TEXT( "FlipAllow" ),
                                            NULL,
                                            &dwType,
                                            (LPBYTE) &dwValue,
                                            &cbValue );

               if ( ERROR_SUCCESS != winStatus )
               {
                  printf( "RegQueryValueEx() on \"FlipAllow\" failed, error %lu.\n",
                          winStatus );
               }
               else if ( ( REG_DWORD != dwType ) || ( (DWORD) fLicensePerServer != dwValue ) )
               {
                  printf( "\"FlipAllow\" has incorrect value!\n" );
               }
               else
               {
                  cbValue = sizeof( szValue );
                  winStatus = RegQueryValueEx( hKeyFilePrint,
                                               TEXT( "DisplayName" ),
                                               NULL,
                                               &dwType,
                                               (LPBYTE) szValue,
                                               &cbValue );

                  if ( ERROR_SUCCESS != winStatus )
                  {
                     printf( "RegQueryValueEx() on \"DisplayName\" failed, error %lu.\n",
                             winStatus );
                  }
                  else if ( ( REG_SZ != dwType ) || lstrcmp( TEXT( "Windows NT Server" ), szValue ) )
                  {
                     printf( "\"DisplayName\" has incorrect value!\n" );
                  }
                  else
                  {
                     cbValue = sizeof( szValue );
                     winStatus = RegQueryValueEx( hKeyFilePrint,
                                                  TEXT( "FamilyDisplayName" ),
                                                  NULL,
                                                  &dwType,
                                                  (LPBYTE) szValue,
                                                  &cbValue );

                     if ( ERROR_SUCCESS != winStatus )
                     {
                        printf( "RegQueryValueEx() on \"FamilyDisplayName\" failed, error %lu.\n",
                                winStatus );
                     }
                     else if ( ( REG_SZ != dwType ) || lstrcmp( TEXT( "Windows NT Server" ), szValue ) )
                     {
                        printf( "\"FamilyDisplayName\" has incorrect value!\n" );
                     }
                     else
                     {
                        fSuccess = TRUE;
                     }
                  }
               }
            }
         }

         RegCloseKey( hKeyFilePrint );
      }
   }

   if ( fSuccess )
   {
      // check EventLog
      HKEY     hKeyEventLog;

      fSuccess = FALSE;

      winStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                TEXT( "System\\CurrentControlSet\\Services\\EventLog\\Application\\LicenseService" ),
                                0,
                                KEY_ALL_ACCESS,
                                &hKeyEventLog );

      if ( !fShouldBePresent )
      {
         if ( ERROR_SUCCESS == winStatus )
         {
            printf( "\"...\\EventLog\\Application\\LicenseService\" exists but shouldn't!\n" );
         }
         else
         {
            fSuccess = TRUE;
         }
      }
      else if ( ERROR_SUCCESS != winStatus )
      {
         printf( "RegOpenKeyEx() on \"...\\EventLog\\Application\\LicenseService\" failed, error %lu.\n",
                 winStatus );
      }
      else
      {
         // EventMessageFile : REG_EXPAND_SZ : %SystemRoot%\System32\llsrpc.dll
         // TypesSupported   : REG_DWORD     : 7

         DWORD    dwType;
         DWORD    dwValue;
         DWORD    cbValue;
         TCHAR    szValue[ 1 + MAX_PATH ];

         cbValue = sizeof( dwValue );
         winStatus = RegQueryValueEx( hKeyEventLog,
                                      TEXT( "TypesSupported" ),
                                      NULL,
                                      &dwType,
                                      (LPBYTE) &dwValue,
                                      &cbValue );

         if ( ERROR_SUCCESS != winStatus )
         {
            printf( "RegQueryValueEx() on \"TypesSupported\" failed, error %lu.\n",
                    winStatus );
         }
         else if ( ( REG_DWORD != dwType ) || ( 7 != dwValue ) )
         {
            printf( "\"TypesSupported\" has incorrect value!\n" );
         }
         else
         {
            cbValue = sizeof( szValue );
            winStatus = RegQueryValueEx( hKeyEventLog,
                                         TEXT( "EventMessageFile" ),
                                         NULL,
                                         &dwType,
                                         (LPBYTE) szValue,
                                         &cbValue );

            if ( ERROR_SUCCESS != winStatus )
            {
               printf( "RegQueryValueEx() on \"EventMessageFile\" failed, error %lu.\n",
                       winStatus );
            }
            else if ( ( REG_SZ != dwType ) || lstrcmpi( TEXT( "%SystemRoot%\\System32\\llsrpc.dll" ), szValue ) )
            {
               printf( "\"EventMessageFile\" has incorrect value!\n" );
            }
            else
            {
               fSuccess = TRUE;
            }
         }

         RegCloseKey( hKeyEventLog );
      }
   }

   if ( !fSuccess )
   {
      printf( "Configuration failed!\n" );
   }
   else
   {
      printf( "Configuration succeeded.\n" );
   }

   return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\llsmgr\appobj.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    appobj.h

Abstract:

    OLE-createable application object implementation.

Author:

    Don Ryan (donryan) 27-Dec-1994

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 16-Jan-1996
        Added Get/SetLastTargetServer() to help isolate server connection
        problems.  (Bug #2993.)

--*/

#ifndef _APPOBJ_H_
#define _APPOBJ_H_

class CApplication : public CCmdTarget
{
    DECLARE_DYNCREATE(CApplication)
    DECLARE_OLECREATE(CApplication)
private:
    CObArray     m_domainArray;
    CDomain*     m_pLocalDomain;
    CDomain*     m_pActiveDomain;
    CController* m_pActiveController;
    BOOL         m_bIsFocusDomain;
    BOOL         m_bDomainsRefreshed;
    long         m_idStatus;
    CString      m_strLastTargetServer;
            
public:
    CDomains*    m_pDomains;

public:
    CApplication(); 
    virtual ~CApplication();

    void ResetDomains();
    BOOL RefreshDomains();

    long GetLastStatus();
    void SetLastStatus(long Status);

    BSTR GetLastTargetServer();
    void SetLastTargetServer( LPCTSTR pszServerName );

    BOOL IsConnected();
    LPVOID GetActiveHandle();

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CApplication)
    public:
    virtual void OnFinalRelease();
    //}}AFX_VIRTUAL

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CApplication)
    afx_msg LPDISPATCH GetApplication();
    afx_msg BSTR GetFullName();
    afx_msg BSTR GetName();
    afx_msg LPDISPATCH GetParent();
    afx_msg BOOL GetVisible();
    afx_msg LPDISPATCH GetActiveController();
    afx_msg LPDISPATCH GetActiveDomain();
    afx_msg LPDISPATCH GetLocalDomain();
    afx_msg BOOL IsFocusDomain();
    afx_msg BSTR GetLastErrorString();
    afx_msg void Quit();
    afx_msg BOOL SelectDomain(const VARIANT FAR& domain);
    afx_msg BOOL SelectEnterprise();
    afx_msg LPDISPATCH GetDomains(const VARIANT FAR& index);
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

protected:
    // Generated message map functions
    //{{AFX_MSG(CApplication)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

inline BOOL CApplication::IsConnected()
    { ASSERT_VALID(m_pActiveController); return m_pActiveController->IsConnected(); }

inline LPVOID CApplication::GetActiveHandle()
    { ASSERT_VALID(m_pActiveController); return m_pActiveController->GetLlsHandle(); }

inline void CApplication::SetLastStatus(long Status)
    { m_idStatus = Status; }

inline long CApplication::GetLastStatus()
    { return m_idStatus; }

#endif // _APPOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\llsmgr\appobj.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    appobj.cpp

Abstract:

    OLE-createable application object implementation.

Author:

    Don Ryan (donryan) 27-Dec-1994

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 16-Jan-1996
        Added Get/SetLastTargetServer() to help isolate server connection
        problems.  (Bug #2993.)

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include "lmerr.h"
#include "lmcons.h"
#include "lmwksta.h"
#include "lmapibuf.h"
#include "lmserver.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CApplication, CCmdTarget)
// IMPLEMENT_OLECREATE(CApplication, "Llsmgr.Application.1", 0x2c5dffb3, 0x472f, 0x11ce, 0xa0, 0x30, 0x0, 0xaa, 0x0, 0x33, 0x9a, 0x98)

BEGIN_MESSAGE_MAP(CApplication, CCmdTarget)
    //{{AFX_MSG_MAP(CApplication)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CApplication, CCmdTarget)
    //{{AFX_DISPATCH_MAP(CApplication)
    DISP_PROPERTY_EX(CApplication, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CApplication, "FullName", GetFullName, SetNotSupported, VT_BSTR)
    DISP_PROPERTY_EX(CApplication, "Name", GetName, SetNotSupported, VT_BSTR)
    DISP_PROPERTY_EX(CApplication, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CApplication, "Visible", GetVisible, SetNotSupported, VT_BOOL)
    DISP_PROPERTY_EX(CApplication, "ActiveController", GetActiveController, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CApplication, "ActiveDomain", GetActiveDomain, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CApplication, "LocalDomain", GetLocalDomain, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CApplication, "IsFocusDomain", IsFocusDomain, SetNotSupported, VT_BOOL)
    DISP_PROPERTY_EX(CApplication, "LastErrorString", GetLastErrorString, SetNotSupported, VT_BSTR)
    DISP_FUNCTION(CApplication, "Quit", Quit, VT_EMPTY, VTS_NONE)
    DISP_FUNCTION(CApplication, "SelectDomain", SelectDomain, VT_BOOL, VTS_VARIANT)
    DISP_FUNCTION(CApplication, "SelectEnterprise", SelectEnterprise, VT_BOOL, VTS_NONE)
    DISP_PROPERTY_PARAM(CApplication, "Domains", GetDomains, SetNotSupported, VT_DISPATCH, VTS_VARIANT)
    DISP_DEFVALUE(CApplication, "Name")
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


CApplication::CApplication()

/*++

Routine Description:

    Constructor for OLE-createable application object.

    To keep the application running as long as an OLE automation
    object is active, we must call AfxOleLockApp.

Arguments:

    None.

Return Values:

    None.

--*/

{
    EnableAutomation();

    ASSERT(theApp.m_pApplication == NULL);

    if (theApp.m_pApplication == NULL)
        theApp.m_pApplication = this;

    if (theApp.m_bIsAutomated)
        AfxOleLockApp();

    m_pDomains          = NULL;
    m_pLocalDomain      = NULL;
    m_pActiveDomain     = NULL;
    m_bIsFocusDomain    = FALSE;
    m_bDomainsRefreshed = FALSE;

    m_strLastTargetServer = TEXT("");

    m_domainArray.RemoveAll();

    m_pActiveController = new CController;
    m_idStatus = m_pActiveController ? STATUS_SUCCESS : STATUS_NO_MEMORY;
}


CApplication::~CApplication()

/*++

Routine Description:

    Destructor for OLE-createable application object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ASSERT(theApp.m_pApplication == this);

    if (theApp.m_pApplication == this)
        theApp.m_pApplication = NULL;

    if (theApp.m_bIsAutomated)
        AfxOleUnlockApp();

    if (m_pDomains)
        m_pDomains->InternalRelease();

    if (m_pLocalDomain)
        m_pLocalDomain->InternalRelease();

    if (m_pActiveDomain)
        m_pActiveDomain->InternalRelease();

    if (m_pActiveController)
        m_pActiveController->InternalRelease();
}


void CApplication::OnFinalRelease()

/*++

Routine Description:

    When the last reference for an automation object is released
    OnFinalRelease is called.  This implementation deletes object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ResetDomains();
    delete this;
}


LPDISPATCH CApplication::GetActiveController()

/*++

Routine Description:

    Returns the active license controller object.

Arguments:

    None.

Return Values:

    VT_DISPATCH or VT_EMPTY.

--*/

{
    ASSERT_VALID(m_pActiveController);
    return m_pActiveController->GetIDispatch(TRUE);
}


LPDISPATCH CApplication::GetActiveDomain()

/*++

Routine Description:

    Returns the active domain object.

Arguments:

    None.

Return Values:

    VT_DISPATCH or VT_EMPTY.

--*/

{
    return m_pActiveDomain ? m_pActiveDomain->GetIDispatch(TRUE) : NULL;
}


LPDISPATCH CApplication::GetApplication()

/*++

Routine Description:

    Returns the application object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return GetIDispatch(TRUE);
}


LPDISPATCH CApplication::GetDomains(const VARIANT FAR& index)

/*++

Routine Description:

    Returns a collection object containing all of the domains
    visible to the local machine or returns an individual domain
    described by an index into the collection.

Arguments:

    index - optional argument that may be a string (VT_BSTR)
    indicating a domain name or a number (VT_I4) indicating
    the position within collection.

Return Values:

    VT_DISPATCH or VT_EMPTY.

--*/

{
    LPDISPATCH lpdispatch = NULL;

    if (!m_pDomains)
    {
        m_pDomains = new CDomains(this, &m_domainArray);
    }

    if (m_pDomains)
    {
        if (V_ISVOID((VARIANT FAR*)&index))
        {
            if (RefreshDomains())
            {
                lpdispatch = m_pDomains->GetIDispatch(TRUE);
            }
        }
        else
        {
            if (m_bDomainsRefreshed)
            {
                lpdispatch = m_pDomains->GetItem(index);
            }
            else if (RefreshDomains())
            {
                lpdispatch = m_pDomains->GetItem(index);
            }
        }
    }
    else
    {
        SetLastStatus(STATUS_NO_MEMORY);
    }

    return lpdispatch;
}


BSTR CApplication::GetFullName()

/*++

Routine Description:

    Returns the file specification for the application,
    including path.

Arguments:

    None.

Return Values:

    VT_BSTR.

--*/

{
    TCHAR szModuleFileName[MAX_PATH+1] = {0};
    DWORD cch;
    BSTR  bstrFullName = NULL;

    cch = GetModuleFileName(AfxGetApp()->m_hInstance, szModuleFileName, MAX_PATH);
    if (0 != cch && MAX_PATH != cch)
    {
        bstrFullName = SysAllocStringLen(szModuleFileName, lstrlen(szModuleFileName));
    }

    return bstrFullName;
}


BSTR CApplication::GetLastErrorString()

/*++

Routine Description:

    Retrieves string for last error.

    (Routine stolen from winsadmn...).

Arguments:

    None.

Return Values:

    VT_BSTR.

--*/

{
    CString strLastError;
    DWORD nId = m_idStatus;

    if (((long)nId == RPC_S_CALL_FAILED) ||
        ((long)nId == RPC_NT_SS_CONTEXT_MISMATCH))
    {
        strLastError.LoadString(IDP_ERROR_DROPPED_LINK);
    }
    else if (((long)nId == RPC_S_SERVER_UNAVAILABLE) ||
             ((long)nId == RPC_NT_SERVER_UNAVAILABLE))
    {
        strLastError.LoadString(IDP_ERROR_NO_RPC_SERVER);
    }
    else if ((long)nId == STATUS_MEMBER_IN_GROUP)
    {
        strLastError.LoadString(IDP_ERROR_MEMBER_IN_GROUP);
    }
    else
    {
        HINSTANCE hinstDll = NULL;

        if ((nId >= NERR_BASE) && (nId <= MAX_NERR))
        {
            hinstDll = ::LoadLibrary(_T("netmsg.dll"));
        }
        else if (nId >= 0x4000000)
        {
            hinstDll = ::LoadLibrary(_T("ntdll.dll"));
        }

        TCHAR szLastError[1024];
        DWORD cchLastError = sizeof(szLastError) / sizeof(TCHAR);

        DWORD dwFlags = FORMAT_MESSAGE_IGNORE_INSERTS|
                        FORMAT_MESSAGE_MAX_WIDTH_MASK|
                        (hinstDll ? FORMAT_MESSAGE_FROM_HMODULE
                                  : FORMAT_MESSAGE_FROM_SYSTEM);

        cchLastError = ::FormatMessage(
                          dwFlags,
                          hinstDll,
                          nId,
                          0,
                          szLastError,
                          cchLastError,
                          NULL
                          );

        if (hinstDll)
        {
            ::FreeLibrary(hinstDll);
        }

        if (cchLastError)
        {
            strLastError = szLastError;
        }
        else
        {
            strLastError.LoadString(IDP_ERROR_UNSUCCESSFUL);
        }
    }

    return strLastError.AllocSysString();
}


LPDISPATCH CApplication::GetLocalDomain()

/*++

Routine Description:

    Returns the local domain object.

Arguments:

    None.

Return Values:

    VT_DISPATCH or VT_EMPTY.

--*/

{
    if (!m_pLocalDomain)
    {
        NET_API_STATUS NetStatus;
        PWKSTA_INFO_100 pWkstaInfo100 = NULL;

        NetStatus = NetWkstaGetInfo(
                        NULL,
                        100,
                        (LPBYTE*)&pWkstaInfo100
                        );

        if (NetStatus == ERROR_SUCCESS)
        {
            m_pLocalDomain = new CDomain(this, pWkstaInfo100->wki100_langroup);

            if (!m_pLocalDomain)
            {
                NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            }

            NetApiBufferFree(pWkstaInfo100);
        }

        SetLastStatus(NetStatus);   // called api
    }

    return m_pLocalDomain ? m_pLocalDomain->GetIDispatch(TRUE) : NULL;
}


BSTR CApplication::GetName()

/*++

Routine Description:

    Returns the name of the application.

Arguments:

    None.

Return Values:

    VT_BSTR.

--*/

{
    CString AppName = AfxGetAppName();
    return AppName.AllocSysString();
}


LPDISPATCH CApplication::GetParent()

/*++

Routine Description:

    Returns the parent of the object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return GetApplication();
}


BOOL CApplication::GetVisible()

/*++

Routine Description:

    Returns whether or not the application is visible to the user.

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    return FALSE;
}


BOOL CApplication::IsFocusDomain()

/*++

Routine Description:

    Returns true if application focused on domain.

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    return m_bIsFocusDomain;
}


BOOL CApplication::RefreshDomains()

/*++

Routine Description:

    Refreshs domain object list.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ResetDomains();

    NET_API_STATUS NetStatus;
    DWORD ResumeHandle = 0L;

    int iDomain = 0;

    do
    {
        DWORD  EntriesRead;
        DWORD  TotalEntries;
        LPBYTE ReturnBuffer = NULL;

        NetStatus = NetServerEnum(
                        NULL,                   // servername
                        100,                    // level
                        &ReturnBuffer,
                        LLS_PREFERRED_LENGTH,
                        &EntriesRead,
                        &TotalEntries,
                        SV_TYPE_DOMAIN_ENUM,
                        NULL,                   // domain
                        &ResumeHandle
                        );

        if (NetStatus == ERROR_SUCCESS ||
            NetStatus == ERROR_MORE_DATA)
        {
            CDomain*         pDomain;
            PSERVER_INFO_100 pServerInfo100;

            pServerInfo100 = (PSERVER_INFO_100)ReturnBuffer;

            ASSERT(iDomain == m_domainArray.GetSize());
            m_domainArray.SetSize(m_domainArray.GetSize() + EntriesRead);

            while (EntriesRead--)
            {
                pDomain = new CDomain(this, pServerInfo100->sv100_name);

                m_domainArray.SetAt(iDomain++, pDomain); // validate later
                pServerInfo100++;
            }

            NetApiBufferFree(ReturnBuffer);
        }

    } while (NetStatus == ERROR_MORE_DATA);

    SetLastStatus(NetStatus);   // called api

    if (NetStatus == ERROR_SUCCESS)
    {
        m_bDomainsRefreshed = TRUE;
    }
    else
    {
        ResetDomains();
    }

    return m_bDomainsRefreshed;
}


void CApplication::ResetDomains()

/*++

Routine Description:

    Resets domain object list.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CDomain* pDomain;
    INT_PTR  iDomain = m_domainArray.GetSize();

    while (iDomain--)
    {
        pDomain = (CDomain*)m_domainArray[iDomain];
        if (NULL != pDomain)
        {
            ASSERT(pDomain->IsKindOf(RUNTIME_CLASS(CDomain)));
            pDomain->InternalRelease();
        }
    }

    m_domainArray.RemoveAll();
    m_bDomainsRefreshed = FALSE;
}


BOOL CApplication::SelectDomain(const VARIANT FAR& domain)

/*++

Routine Description:

    Connects to license controller of specified domain.

Arguments:

    domain - name of domain.

Return Values:

    VT_BOOL.

--*/

{
    BOOL bIsSelected = FALSE;

    ASSERT_VALID(m_pActiveController);

    bIsSelected = m_pActiveController->Connect(domain);
    if (FALSE != bIsSelected)
    {
        LPTSTR pszActiveDomain = MKSTR(m_pActiveController->m_strActiveDomainName);

        if (m_pActiveDomain)
        {
            m_pActiveDomain->InternalRelease();
            m_pActiveDomain = NULL;
        }

        if (pszActiveDomain && *pszActiveDomain)
        {
            m_pActiveDomain = new CDomain(this, pszActiveDomain);

            if (m_pActiveDomain)
            {
                m_bIsFocusDomain = TRUE;
            }
            else
            {
                m_bIsFocusDomain = FALSE; // invalidate m_pActiveDomain
                SetLastStatus(STATUS_NO_MEMORY);
            }
        }
        else
        {
            m_bIsFocusDomain = FALSE; // invalidate m_pActiveDomain
        }
    }

    return bIsSelected;
}


BOOL CApplication::SelectEnterprise()

/*++

Routine Description:

    Connects to license controller of enterprise.

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    BOOL bIsSelected = FALSE;

    VARIANT va;
    VariantInit(&va);   // connect to default controller

    bIsSelected = m_pActiveController->Connect(va);
    if (FALSE != bIsSelected)
    {
        if (m_pActiveDomain)
        {
            m_pActiveDomain->InternalRelease();
            m_pActiveDomain = NULL;
        }

        m_bIsFocusDomain = FALSE;
    }

    return bIsSelected;
}


void CApplication::Quit()

/*++

Routine Description:

    Closes all documents and exits the application.

Arguments:

    None.

Return Values:

    None.

--*/

{
    AfxPostQuitMessage(0); // no main window...
}


BSTR CApplication::GetLastTargetServer()

/*++

Routine Description:

    Retrieves string for last server to which we tried to connect.

Arguments:

    None.

Return Values:

    VT_BSTR.

--*/

{
    if ( m_strLastTargetServer.IsEmpty() )
        return NULL;
    else
        return m_strLastTargetServer.AllocSysString();
}


void CApplication::SetLastTargetServer( LPCTSTR pszServerName )

/*++

Routine Description:

    Sets string for last server to which we tried to connect.

Arguments:

    pszServerName - last server name to which we tried to connect.

Return Values:

    None.

--*/

{
    m_strLastTargetServer = pszServerName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\llsmgr\ausrdlg.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    ausrdlg.cpp

Abstract:

    Add user dialog implementation.

Author:

    Don Ryan (donryan) 14-Feb-1995

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 30-Jan-1996
        o  Added new element to LV_COLUMN_ENTRY to differentiate the string
           used for the column header from the string used in the menus
           (so that the menu option can contain hot keys).

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include "ausrdlg.h"

static LV_COLUMN_INFO g_userColumnInfo  = {0, 0, 1, {0, 0, 0, -1}};
static LV_COLUMN_INFO g_addedColumnInfo = {0, 0, 1, {0, 0, 0, -1}};

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CAddUsersDialog, CDialog)
    //{{AFX_MSG_MAP(CAddUsersDialog)
    ON_BN_CLICKED(IDC_ADD_USERS_ADD, OnAdd)
    ON_BN_CLICKED(IDC_ADD_USERS_DELETE, OnDelete)
    ON_NOTIFY(NM_DBLCLK, IDC_ADD_USERS_ADD_USERS, OnDblclkAddUsers)
    ON_NOTIFY(NM_DBLCLK, IDC_ADD_USERS_USERS, OnDblclkUsers)
    ON_CBN_SELCHANGE(IDC_ADD_USERS_DOMAINS, OnSelchangeDomains)
    ON_NOTIFY(LVN_GETDISPINFO, IDC_ADD_USERS_USERS, OnGetdispinfoUsers)
    ON_NOTIFY(NM_KILLFOCUS, IDC_ADD_USERS_USERS, OnKillfocusUsers)
    ON_NOTIFY(NM_SETFOCUS, IDC_ADD_USERS_USERS, OnSetfocusUsers)
    ON_NOTIFY(NM_KILLFOCUS, IDC_ADD_USERS_ADD_USERS, OnKillfocusAddUsers)
    ON_NOTIFY(NM_SETFOCUS, IDC_ADD_USERS_ADD_USERS, OnSetfocusAddUsers)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


CAddUsersDialog::CAddUsersDialog(CWnd* pParent /*=NULL*/)
    : CDialog(CAddUsersDialog::IDD, pParent)

/*++

Routine Description:

    Constructor for add user dialog.

Arguments:

    pParent - parent window handle.

Return Values:

    None.

--*/

{
    //{{AFX_DATA_INIT(CAddUsersDialog)
    m_iDomain = -1;
    m_iIndex = 0;
    //}}AFX_DATA_INIT

    m_pObList = NULL;

    m_bIsFocusUserList  = FALSE;
    m_bIsFocusAddedList = FALSE;
}


void CAddUsersDialog::DoDataExchange(CDataExchange* pDX)

/*++

Routine Description:

    Called by framework to exchange dialog data.

Arguments:

    pDX - data exchange object.

Return Values:

    None.

--*/

{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAddUsersDialog)
    DDX_Control(pDX, IDC_ADD_USERS_ADD, m_addBtn);
    DDX_Control(pDX, IDC_ADD_USERS_DELETE, m_delBtn);
    DDX_Control(pDX, IDC_ADD_USERS_DOMAINS, m_domainList);
    DDX_Control(pDX, IDC_ADD_USERS_ADD_USERS, m_addedList);
    DDX_Control(pDX, IDC_ADD_USERS_USERS, m_userList);
    DDX_CBIndex(pDX, IDC_ADD_USERS_DOMAINS, m_iDomain);
    //}}AFX_DATA_MAP
}


void CAddUsersDialog::InitDialog(CObList* pObList)

/*++

Routine Description:

    Initializes return list.

Arguments:

    pObList - pointer to return list.

Return Values:

    None.

--*/

{
    ASSERT_VALID(pObList);
    m_pObList = pObList;
}



void CAddUsersDialog::InitDomainList()

/*++

Routine Description:

    Initializes list of domains.

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    CDomains* pDomains = NULL;
    CDomain* pDomain = NULL;
    int iDomain = 0;

    //First add the default domain
    CString strLabel = "";
    strLabel.LoadString(IDS_DEFAULT_DOMAIN);
    if ((iDomain = m_domainList.AddString(strLabel)) != CB_ERR)
    {
        m_domainList.SetCurSel(iDomain);
        m_domainList.SetItemDataPtr(iDomain, (LPVOID)-1L);
    }
    else
    {
        theApp.DisplayStatus( STATUS_NO_MEMORY );
        return;
    }

    //If FocusDomain, add the trusted domains
    if (LlsGetApp()->IsFocusDomain())
    {
        pDomain = (CDomain*)MKOBJ(LlsGetApp()->GetActiveDomain());
        ASSERT(pDomain && pDomain->IsKindOf(RUNTIME_CLASS(CDomain)));

        if (pDomain)
        {
            VARIANT va;
            VariantInit(&va);
            pDomains = (CDomains*)MKOBJ(pDomain->GetTrustedDomains(va));

            if (pDomains && InsertDomains(pDomains))
            {
                // Now add active domain itself...
                if ((iDomain = m_domainList.AddString(pDomain->m_strName)) != CB_ERR)
                    m_domainList.SetItemDataPtr(iDomain, pDomain);
                else
                    NtStatus = STATUS_NO_MEMORY;
            }
            else
                NtStatus = LlsGetLastStatus();

            if (pDomains)
                pDomains->InternalRelease();

            pDomain->InternalRelease();
        }
        else
            NtStatus = LlsGetLastStatus();
    }
    //If not FocusDomain, add all domains
    else
    {
        pDomain = (CDomain*)MKOBJ(LlsGetApp()->GetLocalDomain());
        ASSERT(pDomain && pDomain->IsKindOf(RUNTIME_CLASS(CDomain)));

        if (pDomain)
        {
            VARIANT va;
            VariantInit(&va);
            pDomains = (CDomains*)MKOBJ(LlsGetApp()->GetDomains(va));

            if (pDomains && InsertDomains(pDomains))
            {
                //
                // CODEWORK... scroll to local domain???
                //
            }
            else
                NtStatus = LlsGetLastStatus();

            if (pDomains)
                pDomains->InternalRelease();

            pDomain->InternalRelease();
        }
        else
            NtStatus = LlsGetLastStatus();
    }

    if (!NT_SUCCESS(NtStatus))
    {
        theApp.DisplayStatus(NtStatus);
        m_domainList.ResetContent();
    }
}


void CAddUsersDialog::InitUserList()

/*++

Routine Description:

    Initializes list of users.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ::LvInitColumns(&m_userList,  &g_userColumnInfo);
    ::LvInitColumns(&m_addedList, &g_addedColumnInfo);
}


BOOL CAddUsersDialog::InsertDomains(CDomains* pDomains)

/*++

Routine Description:

    Inserts domains into domain list.

Arguments:

    pDomains - domain collection.

Return Values:

    None.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    ASSERT_VALID(pDomains);

    if (pDomains)
    {
        VARIANT va;
        VariantInit(&va);

        CDomain* pDomain;
        int      iDomain;
        int      nDomains = pDomains->GetCount();

        for (va.vt = VT_I4, va.lVal = 0; (va.lVal < nDomains) && NT_SUCCESS(NtStatus); va.lVal++)
        {
            pDomain = (CDomain*)MKOBJ(pDomains->GetItem(va));
            ASSERT(pDomain && pDomain->IsKindOf(RUNTIME_CLASS(CDomain)));

            if (pDomain)
            {
                if ((iDomain = m_domainList.AddString(pDomain->m_strName)) != CB_ERR)
                {
                    m_domainList.SetItemDataPtr(iDomain, pDomain);
                }
                else
                {
                    NtStatus = STATUS_NO_MEMORY;
                }

                pDomain->InternalRelease();
            }
            else
            {
                NtStatus = STATUS_NO_MEMORY;
            }
        }
    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    if (!NT_SUCCESS(NtStatus))
    {
        m_domainList.ResetContent();
        LlsSetLastStatus(NtStatus);
        return FALSE;
    }

    return TRUE;
}


void CAddUsersDialog::OnAdd()

/*++

Routine Description:

    Message handler for IDC_ADD_USER_ADD.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CUser* pUser;
    int iItem = -1;

    while (NULL != (pUser = (CUser*)::LvGetNextObj(&m_userList, &iItem)))
    {
        ASSERT(pUser->IsKindOf(RUNTIME_CLASS(CUser)));

        LV_FINDINFO lvFindInfo;

        lvFindInfo.flags = LVFI_STRING;
        lvFindInfo.psz   = MKSTR(pUser->m_strName);

        if (m_addedList.FindItem(&lvFindInfo, -1) == -1)
        {
            //
            // Make a copy of the user (w/no parent)
            //

            CUser* pNewUser = new CUser(NULL, pUser->m_strName);

            if (pNewUser)
            {
                LV_ITEM lvItem;

                lvItem.mask = LVIF_TEXT|
                              LVIF_PARAM|
                              LVIF_IMAGE;

                lvItem.iSubItem  = 0;
                lvItem.lParam    = (LPARAM)(LPVOID)pNewUser;

                lvItem.iImage  = BMPI_USER;
                lvItem.pszText = MKSTR(pNewUser->m_strName);
                lvItem.iItem = m_iIndex;
                

                m_addedList.InsertItem(&lvItem);
                m_iIndex++;

                
            }
            else
            {
                theApp.DisplayStatus( STATUS_NO_MEMORY );
                break;
            }
        }
    }

    m_userList.SetFocus();
}


void CAddUsersDialog::OnDblclkAddUsers(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for NM_DLBCLK.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    UNREFERENCED_PARAMETER(pNMHDR);

    OnDelete();

    ASSERT(NULL != pResult);
    *pResult = 0;
}


void CAddUsersDialog::OnDblclkUsers(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for NM_DLBCLK.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    UNREFERENCED_PARAMETER(pNMHDR);

    OnAdd();

    ASSERT(NULL != pResult);
    *pResult = 0;
}


void CAddUsersDialog::OnDelete()

/*++

Routine Description:

    Message handler for IDC_ADD_USER_DELETE.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CUser* pUser;
    int iItem = -1;
    int iLastItem = 0;

    while (NULL != (pUser = (CUser*)::LvGetNextObj(&m_addedList, &iItem)))
    {
        ASSERT(pUser->IsKindOf(RUNTIME_CLASS(CUser)));

        pUser->InternalRelease();   // allocated above....
        m_addedList.DeleteItem(iItem);

        iLastItem = iItem;
        iItem = -1;
        m_iIndex--;
    }

    m_addedList.SetItemState(iLastItem, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);
    m_addedList.SetFocus();
}


BOOL CAddUsersDialog::OnInitDialog()

/*++

Routine Description:

    Message handler for WM_INITDIALOG.

Arguments:

    None.

Return Values:

    None.

--*/

{
    BeginWaitCursor();

    CDialog::OnInitDialog();

    InitUserList(); // always construct headers...
    InitDomainList();

    m_addBtn.EnableWindow(FALSE);
    m_delBtn.EnableWindow(FALSE);

    if (!RefreshUserList())
        theApp.DisplayLastStatus();

    m_domainList.SetFocus();

    EndWaitCursor();

    return FALSE;   // set focus to domain list
}


void CAddUsersDialog::OnSelchangeDomains()

/*++

Routine Description:

    Message handler for CBN_SELCHANGED.

Arguments:

    None.

Return Values:

    None.

--*/

{
    RefreshUserList();
}


BOOL CAddUsersDialog::RefreshUserList()

/*++

Routine Description:

    Refreshs list of users (with currently selected item).

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    m_userList.DeleteAllItems();

    int iDomain;

    if ((iDomain = m_domainList.GetCurSel()) != CB_ERR)
    {
        CDomain* pDomain = (CDomain*)m_domainList.GetItemDataPtr(iDomain);
        CUsers*  pUsers = (CUsers*)NULL;

        VARIANT va;
        VariantInit(&va);

        if (pDomain == (CDomain*)-1L)
        {
            //
            // Enumerate users in license cache...
            //

            CController* pController = (CController*)MKOBJ(LlsGetApp()->GetActiveController());
            if ( pController )
            {
                pController->InternalRelease(); // held open by CApplication

                pUsers = pController->m_pUsers;
                pUsers->InternalAddRef();       // released below...
            }
        }
        else
        {
            //
            // Enumerate users in particular domain...
            //

            ASSERT(pDomain->IsKindOf(RUNTIME_CLASS(CDomain)));

            pUsers = (CUsers*)MKOBJ(pDomain->GetUsers(va));
            ASSERT(pUsers && pUsers->IsKindOf(RUNTIME_CLASS(CUsers)));
        }

        if (pUsers)
        {
            CUser* pUser;
            int    nUsers = pUsers->GetCount();

            LV_ITEM lvItem;

            lvItem.mask = LVIF_TEXT|
                          LVIF_PARAM|
                          LVIF_IMAGE;

            lvItem.iSubItem  = 0;

            lvItem.pszText    = LPSTR_TEXTCALLBACK;
            lvItem.cchTextMax = LPSTR_TEXTCALLBACK_MAX;

            lvItem.iImage = BMPI_USER;

            for (va.vt = VT_I4, va.lVal = 0; (va.lVal < nUsers) && NT_SUCCESS(NtStatus); va.lVal++)
            {
                pUser = (CUser*)MKOBJ(pUsers->GetItem(va));
                ASSERT(pUser && pUser->IsKindOf(RUNTIME_CLASS(CUser)));

                if (pUser)
                {
                    lvItem.iItem  = va.lVal;
                    lvItem.lParam  = (LPARAM)(LPVOID)pUser;

                    if (m_userList.InsertItem(&lvItem) == -1)
                    {
                        NtStatus = STATUS_NO_MEMORY;
                    }

                    pUser->InternalRelease();
                }
                else
                {
                    NtStatus = STATUS_NO_MEMORY;
                }
            }

            pUsers->InternalRelease();
        }
        else
        {
            NtStatus = LlsGetLastStatus();
        }

        VariantClear(&va);
    }
    else
    {
        NtStatus = STATUS_NO_MEMORY;
    }

    if (!NT_SUCCESS(NtStatus))
    {
        m_userList.DeleteAllItems();
        LlsSetLastStatus(NtStatus);
    }

    ::LvResizeColumns(&m_userList, &g_userColumnInfo);

    return NT_SUCCESS(NtStatus);
}


void CAddUsersDialog::OnOK()

/*++

Routine Description:

    Message handler for IDOK.

Arguments:

    None.

Return Values:

    None.

--*/

{
    if (m_pObList)
    {
        CUser* pUser;
        int iItem = -1;

        m_pObList->RemoveAll();

        while (NULL != (pUser = (CUser*)::LvGetNextObj(&m_addedList, &iItem, LVNI_ALL)))
        {
            ASSERT(pUser->IsKindOf(RUNTIME_CLASS(CUser)));
            m_pObList->AddTail(pUser);
        }
    }

    CDialog::OnOK();
}


void CAddUsersDialog::OnCancel()

/*++

Routine Description:

    Message handler for IDCANCEL.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CUser* pUser;
    int iItem = -1;

    while (NULL != (pUser = (CUser*)::LvGetNextObj(&m_addedList, &iItem, LVNI_ALL)))
    {
        ASSERT(pUser->IsKindOf(RUNTIME_CLASS(CUser)));
        pUser->InternalRelease();
    }

    CDialog::OnCancel();
}


void CAddUsersDialog::InitDialogCtrls()
{
    int iItem = -1;

    if (m_bIsFocusUserList && m_userList.GetItemCount())
    {
        m_addBtn.EnableWindow(TRUE);
        m_delBtn.EnableWindow(FALSE);
    }
    else if (m_bIsFocusAddedList && m_addedList.GetItemCount())
    {
        m_addBtn.EnableWindow(FALSE);
        m_delBtn.EnableWindow(TRUE);
    }
    else
    {
        m_addBtn.EnableWindow(FALSE);
        m_delBtn.EnableWindow(FALSE);
    }

    ::LvResizeColumns(&m_userList,  &g_userColumnInfo);
    ::LvResizeColumns(&m_addedList, &g_addedColumnInfo);
}


void CAddUsersDialog::OnGetdispinfoUsers(NMHDR* pNMHDR, LRESULT* pResult)
{
    ASSERT(NULL != pNMHDR);
    LV_ITEM lvItem = ((LV_DISPINFO*)pNMHDR)->item;

    if (lvItem.iSubItem == 0)
    {
        CUser* pUser = (CUser*)lvItem.lParam;
        ASSERT(pUser && pUser->IsKindOf(RUNTIME_CLASS(CUser)));

        lstrcpyn(lvItem.pszText, pUser->m_strName, lvItem.cchTextMax);
    }

    ASSERT(NULL != pResult);
    *pResult = 0;
}

void CAddUsersDialog::OnKillfocusUsers(NMHDR* pNMHDR, LRESULT* pResult)
{
    UNREFERENCED_PARAMETER(pNMHDR);

    ASSERT(NULL != pResult);
    *pResult = 0;
}

void CAddUsersDialog::OnSetfocusUsers(NMHDR* pNMHDR, LRESULT* pResult)
{
    UNREFERENCED_PARAMETER(pNMHDR);

    m_bIsFocusUserList = TRUE;
    m_bIsFocusAddedList = FALSE;
    PostMessage(WM_COMMAND, ID_INIT_CTRLS);
    ASSERT(NULL != pResult);
    *pResult = 0;
}

void CAddUsersDialog::OnKillfocusAddUsers(NMHDR* pNMHDR, LRESULT* pResult)
{
    UNREFERENCED_PARAMETER(pNMHDR);

    ASSERT(NULL != pResult);
    *pResult = 0;
}

void CAddUsersDialog::OnSetfocusAddUsers(NMHDR* pNMHDR, LRESULT* pResult)
{
    UNREFERENCED_PARAMETER(pNMHDR);

    m_bIsFocusUserList = FALSE;
    m_bIsFocusAddedList = TRUE;
    PostMessage(WM_COMMAND, ID_INIT_CTRLS);
    ASSERT(NULL != pResult);
    *pResult = 0;
}

BOOL CAddUsersDialog::OnCommand(WPARAM wParam, LPARAM lParam)
{
    if (wParam == ID_INIT_CTRLS)
    {
        InitDialogCtrls();
        return TRUE; // processed...
    }

    return CDialog::OnCommand(wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\llsmgr\ausrdlg.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    ausrdlg.h

Abstract:

    Add user dialog implementation.

Author:

    Don Ryan (donryan) 14-Feb-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _AUSRDLG_H_
#define _AUSRDLG_H_

class CAddUsersDialog : public CDialog
{
private:
    CObList*   m_pObList;

    BOOL       m_bIsFocusUserList;
    BOOL       m_bIsFocusAddedList;

public:
    CAddUsersDialog(CWnd* pParent = NULL);   

    void InitUserList();
    void InitDomainList();

    BOOL InsertDomains(CDomains* pDomains);
    BOOL RefreshUserList();

    void InitDialog(CObList* pObList);
    void InitDialogCtrls();

    //{{AFX_DATA(CAddUsersDialog)
    enum { IDD = IDD_ADD_USERS };
    CButton m_addBtn;
    CButton m_delBtn;
    CComboBox   m_domainList;
    CListCtrl   m_addedList;
    CListCtrl   m_userList;
    int     m_iDomain;
    int m_iIndex;
    //}}AFX_DATA

    //{{AFX_VIRTUAL(CAddUsersDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

protected:
    //{{AFX_MSG(CAddUsersDialog)
    virtual BOOL OnInitDialog();
    afx_msg void OnDropdownDomains();
    afx_msg void OnAdd();
    afx_msg void OnDelete();
    afx_msg void OnDblclkAddUsers(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDblclkUsers(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSelchangeDomains();
    virtual void OnOK();
    virtual void OnCancel();
    afx_msg void OnGetdispinfoUsers(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusUsers(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSetfocusUsers(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusAddUsers(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSetfocusAddUsers(NMHDR* pNMHDR, LRESULT* pResult);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // _AUSRDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\llsmgr\ctlobj.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    ctlobj.h

Abstract:

    License controller object implementation.

Author:

    Don Ryan (donryan) 27-Dec-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _CTLOBJ_H_
#define _CTLOBJ_H_

class CController : public CCmdTarget
{
    DECLARE_DYNCREATE(CController)
private: 
    LPVOID     m_llsHandle;
    BOOL       m_bIsConnected;

    CObArray   m_productArray;
    CObArray   m_licenseArray;
    CObArray   m_mappingArray;
    CObArray   m_userArray;

    BOOL       m_bProductsRefreshed;
    BOOL       m_bLicensesRefreshed;
    BOOL       m_bMappingsRefreshed;
    BOOL       m_bUsersRefreshed;

public:
    CString    m_strName;
    CString    m_strActiveDomainName;   // blah!

    CProducts* m_pProducts;
    CLicenses* m_pLicenses;
    CMappings* m_pMappings;
    CUsers*    m_pUsers;

public:
    CController();
    virtual ~CController();

    BOOL RefreshProducts();
    BOOL RefreshUsers();
    BOOL RefreshMappings();
    BOOL RefreshLicenses();

    void ResetProducts();
    void ResetUsers();
    void ResetMappings();
    void ResetLicenses();

    PVOID GetLlsHandle();
    BSTR  GetActiveDomainName();

    //{{AFX_VIRTUAL(CController)
    //}}AFX_VIRTUAL

    //{{AFX_DISPATCH(CController)
    afx_msg BSTR GetName();
    afx_msg LPDISPATCH GetApplication();
    afx_msg LPDISPATCH GetParent();
    afx_msg BOOL IsConnected();
    afx_msg BOOL Connect(const VARIANT FAR& start);
    afx_msg void Disconnect();
    afx_msg void Refresh();
    afx_msg LPDISPATCH GetMappings(const VARIANT FAR& index);
    afx_msg LPDISPATCH GetUsers(const VARIANT FAR& index);
    afx_msg LPDISPATCH GetLicenses(const VARIANT FAR& index);
    afx_msg LPDISPATCH GetProducts(const VARIANT FAR& index);
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

protected:
    //{{AFX_MSG(CController)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

inline LPVOID CController::GetLlsHandle()
    {   return m_llsHandle;  }

#endif // _CTLOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\llsmgr\ctlobj.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    ctlobj.cpp

Abstract:

    License controller object implementation.

Author:

    Don Ryan (donryan) 27-Dec-1994

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 16-Jan-1996
        Added SetLastTargetServer() to Connect() to help isolate server
        connection problems.  (Bug #2993.)

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include <lm.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CController, CCmdTarget)

BEGIN_MESSAGE_MAP(CController, CCmdTarget)
    //{{AFX_MSG_MAP(CController)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CController, CCmdTarget)
    //{{AFX_DISPATCH_MAP(CController)
    DISP_PROPERTY_EX(CController, "Name", GetName, SetNotSupported, VT_BSTR)
    DISP_PROPERTY_EX(CController, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CController, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
    DISP_PROPERTY_EX(CController, "IsConnected", IsConnected, SetNotSupported, VT_BOOL)
    DISP_FUNCTION(CController, "Connect", Connect, VT_BOOL, VTS_VARIANT)
    DISP_FUNCTION(CController, "Disconnect", Disconnect, VT_EMPTY, VTS_NONE)
    DISP_FUNCTION(CController, "Refresh", Refresh, VT_EMPTY, VTS_NONE)
    DISP_PROPERTY_PARAM(CController, "Mappings", GetMappings, SetNotSupported, VT_DISPATCH, VTS_VARIANT)
    DISP_PROPERTY_PARAM(CController, "Users", GetUsers, SetNotSupported, VT_DISPATCH, VTS_VARIANT)
    DISP_PROPERTY_PARAM(CController, "Licenses", GetLicenses, SetNotSupported, VT_DISPATCH, VTS_VARIANT)
    DISP_PROPERTY_PARAM(CController, "Products", GetProducts, SetNotSupported, VT_DISPATCH, VTS_VARIANT)
    DISP_DEFVALUE(CController, "Name")
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

BOOL IsAdminOn(LPTSTR ServerName);

CController::CController()

/*++

Routine Description:

    Constructor for license controller object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    EnableAutomation();

    m_strName.Empty();

    m_pProducts = NULL;
    m_pUsers    = NULL;
    m_pMappings = NULL;
    m_pLicenses = NULL;

    m_llsHandle   = NULL;

    m_productArray.RemoveAll();
    m_licenseArray.RemoveAll();
    m_mappingArray.RemoveAll();
    m_userArray.RemoveAll();

    m_bProductsRefreshed = FALSE;
    m_bLicensesRefreshed = FALSE;
    m_bMappingsRefreshed = FALSE;
    m_bUsersRefreshed    = FALSE;

    m_bIsConnected = FALSE;
}


CController::~CController()

/*++

Routine Description:

    Destructor for license controller object.

Arguments:

    None.

Return Values:

    None.

--*/

{
    Disconnect();

    if (m_pProducts)
        m_pProducts->InternalRelease();

    if (m_pLicenses)
        m_pLicenses->InternalRelease();

    if (m_pMappings)
        m_pMappings->InternalRelease();

    if (m_pUsers)
        m_pUsers->InternalRelease();
}


BOOL CController::Connect(const VARIANT FAR& start)

/*++

Routine Description:

    Seek out license controller and establish connection.

Arguments:

    start - either a server or domain to start searching for
    the license controller from.

Return Values:

    VT_BOOL.

--*/

{
    VARIANT va;
    VariantInit(&va);

    LPTSTR pControllerName = NULL;

    if (!V_ISVOID((VARIANT FAR*)&start))
    {
        if (start.vt == VT_BSTR)
        {
            pControllerName = start.bstrVal;
        }
        else if (SUCCEEDED(VariantChangeType(&va, (VARIANT FAR*)&start, 0, VT_BSTR)))
        {
            pControllerName = va.bstrVal;
        }
        else
        {
            LlsSetLastStatus(STATUS_INVALID_PARAMETER);
            return FALSE;
        }
    }


    NTSTATUS NtStatus;
    LPVOID llsHandle = NULL;
    PLLS_CONNECT_INFO_0 pConnectInfo0 = NULL;

    NtStatus = ::LlsEnterpriseServerFind(
                    pControllerName,
                    0,
                    (LPBYTE*)&pConnectInfo0
                    );

    if (NT_SUCCESS(NtStatus))
    {
        if (!IsAdminOn( pConnectInfo0->EnterpriseServer ))
        {
            LlsSetLastStatus(STATUS_ACCESS_DENIED);
            return FALSE;
        }

        LlsSetLastTargetServer( pConnectInfo0->EnterpriseServer );

        NtStatus = ::LlsConnect(
                        pConnectInfo0->EnterpriseServer,
                        &llsHandle
                        );

        if (NT_SUCCESS(NtStatus))
        {
            Disconnect();

            m_bIsConnected = TRUE;
            m_llsHandle = llsHandle;

            m_strName = pConnectInfo0->EnterpriseServer;
            m_strActiveDomainName = pConnectInfo0->Domain;

            m_strName.MakeUpper();
            m_strActiveDomainName.MakeUpper();
        }

        ::LlsFreeMemory(pConnectInfo0);
    }
    else
    {
        LlsSetLastTargetServer( TEXT( "" ) );
    }

    VariantClear(&va);

    LlsSetLastStatus(NtStatus);

    return NT_SUCCESS(NtStatus);
}


void CController::Disconnect()

/*++

Routine Description:

    Closes connection to license controller.

Arguments:

    None.

Return Values:

    None.

--*/

{
    if (m_bIsConnected)
    {
        LlsClose(m_llsHandle);

        m_llsHandle      = NULL;
        m_bIsConnected   = FALSE;

        m_strName.Empty();
        m_strActiveDomainName.Empty();

        ResetLicenses();
        ResetProducts();
        ResetUsers();
        ResetMappings();
    }
}


BSTR CController::GetActiveDomainName()

/*++

Routine Description:

    Returns the name of the active domain (internal).

Arguments:

    None.

Return Values:

    VT_BSTR.

--*/

{
    return m_strActiveDomainName.AllocSysString();
}


LPDISPATCH CController::GetApplication()

/*++

Routine Description:

    Returns the application object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return theApp.GetAppIDispatch();
}


LPDISPATCH CController::GetLicenses(const VARIANT FAR& index)

/*++

Routine Description:

    Returns a collection object containing all of the
    license agreements recorded on the license controller
    or returns an individual license agreement described by
    an index into the collection.

Arguments:

    index - optional argument that may be a number (VT_I4)
    indicating the position within collection.

Return Values:

    VT_DISPATCH or VT_EMPTY.

--*/

{
    LPDISPATCH lpdispatch = NULL;

    if (!m_pLicenses)
    {
        m_pLicenses = new CLicenses(this, &m_licenseArray);
    }

    if (m_pLicenses)
    {
        if (V_ISVOID((VARIANT FAR*)&index))
        {
            if (RefreshLicenses())
            {
                lpdispatch = m_pLicenses->GetIDispatch(TRUE);
            }
        }
        else
        {
            if (m_bLicensesRefreshed)
            {
                lpdispatch = m_pLicenses->GetItem(index);
            }
            else if (RefreshLicenses())
            {
                lpdispatch = m_pLicenses->GetItem(index);
            }
        }
    }
    else
    {
        LlsSetLastStatus( STATUS_NO_MEMORY );
    }

    return lpdispatch;
}


LPDISPATCH CController::GetMappings(const VARIANT FAR& index)

/*++

Routine Description:

    Returns a collection object containing all of the
    user/node associations recorded on the license controller
    or returns an individual user/node association described by
    an index into the collection.

Arguments:

    index - optional argument that may be a string (VT_BSTR)
    indicating a mapping name or a number (VT_I4) indicating
    the position within collection.

Return Values:

    VT_DISPATCH or VT_EMPTY.

--*/

{
    LPDISPATCH lpdispatch = NULL;

    if (!m_pMappings)
    {
        m_pMappings = new CMappings(this, &m_mappingArray);
    }

    if (m_pMappings)
    {
        if (V_ISVOID((VARIANT FAR*)&index))
        {
            if (RefreshMappings())
            {
                lpdispatch = m_pMappings->GetIDispatch(TRUE);
            }
        }
        else
        {
            if (m_bMappingsRefreshed)
            {
                lpdispatch = m_pMappings->GetItem(index);
            }
            else if (RefreshMappings())
            {
                lpdispatch = m_pMappings->GetItem(index);
            }
        }
    }
    else
    {
        LlsSetLastStatus(STATUS_NO_MEMORY);
    }

    return lpdispatch;
}


BSTR CController::GetName()

/*++

Routine Description:

    Returns the name of the license controller.

Arguments:

    None.

Return Values:

    VT_BSTR.

--*/

{
    return m_strName.AllocSysString();
}


LPDISPATCH CController::GetParent()

/*++

Routine Description:

    Returns the parent of the object.

Arguments:

    None.

Return Values:

    VT_DISPATCH.

--*/

{
    return GetApplication();
}


LPDISPATCH CController::GetProducts(const VARIANT FAR& index)

/*++

Routine Description:

    Returns a collection object containing all of the
    registered products replicated to the license controller
    or returns an individual product described by an index
    into the collection.

Arguments:

    index - optional argument that may be a string (VT_BSTR)
    indicating a product name or a number (VT_I4) indicating
    the position within collection.

Return Values:

    VT_DISPATCH or VT_EMPTY.

--*/

{
    LPDISPATCH lpdispatch = NULL;

    if (!m_pProducts)
    {
        m_pProducts = new CProducts(this, &m_productArray);
    }

    if (m_pProducts)
    {
        if (V_ISVOID((VARIANT FAR*)&index))
        {
            if (RefreshProducts())
            {
                lpdispatch = m_pProducts->GetIDispatch(TRUE);
            }
        }
        else
        {
            if (m_bProductsRefreshed)
            {
                lpdispatch = m_pProducts->GetItem(index);
            }
            else if (RefreshProducts())
            {
                lpdispatch = m_pProducts->GetItem(index);
            }
        }
    }
    else
    {
        LlsSetLastStatus(STATUS_NO_MEMORY);
    }

    return lpdispatch;
}


LPDISPATCH CController::GetUsers(const VARIANT FAR& index)

/*++

Routine Description:

    Returns a collection object containing all of the
    registered users replicated to the license controller
    or returns an individual user described by an index
    into the collection.

Arguments:

    index - optional argument that may be a string (VT_BSTR)
    indicating a user name or a number (VT_I4) indicating the
    position within collection.

Return Values:

    VT_DISPATCH or VT_EMPTY.

--*/

{
    LPDISPATCH lpdispatch = NULL;

    if (!m_pUsers)
    {
        m_pUsers = new CUsers(this, &m_userArray);
    }

    if (m_pUsers)
    {
        if (V_ISVOID((VARIANT FAR*)&index))
        {
            if (RefreshUsers())
            {
                lpdispatch = m_pUsers->GetIDispatch(TRUE);
            }
        }
        else
        {
            if (m_bUsersRefreshed)
            {
                lpdispatch = m_pUsers->GetItem(index);
            }
            else if (RefreshUsers())
            {
                lpdispatch = m_pUsers->GetItem(index);
            }
        }
    }
    else
    {
        LlsSetLastStatus(STATUS_NO_MEMORY);
    }

    return lpdispatch;
}


BOOL CController::IsConnected()

/*++

Routine Description:

    Returns true if a connection has been established.

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    return m_bIsConnected;
}


void CController::Refresh()

/*++

Routine Description:

    Retrieve latest data from license controller.

Arguments:

    None.

Return Values:

    None.

--*/

{
    RefreshProducts();
    RefreshUsers();
    RefreshMappings();
    RefreshLicenses();
}


BOOL CController::RefreshLicenses()

/*++

Routine Description:

    Refreshs license object array.

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    ResetLicenses();

    if (!m_bIsConnected)
        return TRUE;

    NTSTATUS NtStatus;
    DWORD ResumeHandle = 0L;

    int iLicense = 0;

    do
    {
        DWORD  EntriesRead;
        DWORD  TotalEntries;
        LPBYTE ReturnBuffer = NULL;

        NtStatus = ::LlsLicenseEnum(
                        m_llsHandle,
                        0,
                        &ReturnBuffer,
                        LLS_PREFERRED_LENGTH,
                        &EntriesRead,
                        &TotalEntries,
                        &ResumeHandle
                        );

        if (NtStatus == STATUS_SUCCESS ||
            NtStatus == STATUS_MORE_ENTRIES)
        {
            CLicense*           pLicense;
            PLLS_LICENSE_INFO_0 pLicenseInfo0;

            pLicenseInfo0 = (PLLS_LICENSE_INFO_0)ReturnBuffer;

            ASSERT(iLicense == m_licenseArray.GetSize());
            m_licenseArray.SetSize(m_licenseArray.GetSize() + EntriesRead);

            while (EntriesRead--)
            {
                pLicense = new CLicense(
                                this,
                                pLicenseInfo0->Product,
                                pLicenseInfo0->Admin,
                                pLicenseInfo0->Date,
                                pLicenseInfo0->Quantity,
                                pLicenseInfo0->Comment
                                );

                m_licenseArray.SetAt(iLicense++, pLicense); // validate later...

#ifndef DISABLE_PER_NODE_ALLOCATION

                ::LlsFreeMemory(pLicenseInfo0->Product);
                ::LlsFreeMemory(pLicenseInfo0->Admin);
                ::LlsFreeMemory(pLicenseInfo0->Comment);

#endif // DISABLE_PER_NODE_ALLOCATION

                pLicenseInfo0++;
            }

            ::LlsFreeMemory(ReturnBuffer);
        }

    } while (NtStatus == STATUS_MORE_ENTRIES);

    LlsSetLastStatus(NtStatus);   // called api

    if (NT_SUCCESS(NtStatus))
    {
        m_bLicensesRefreshed = TRUE;
    }
    else
    {
        ResetLicenses();
    }

    return m_bLicensesRefreshed;
}


BOOL CController::RefreshMappings()

/*++

Routine Description:

    Refreshs mapping object array.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ResetMappings();

    if (!m_bIsConnected)
        return TRUE;

    NTSTATUS NtStatus;
    DWORD ResumeHandle = 0L;

    int iMapping = 0;

    do
    {
        DWORD  EntriesRead;
        DWORD  TotalEntries;
        LPBYTE ReturnBuffer = NULL;

        NtStatus = ::LlsGroupEnum(
                        m_llsHandle,
                        1,
                        &ReturnBuffer,
                        LLS_PREFERRED_LENGTH,
                        &EntriesRead,
                        &TotalEntries,
                        &ResumeHandle
                        );

        if (NtStatus == STATUS_SUCCESS ||
            NtStatus == STATUS_MORE_ENTRIES)
        {
            CMapping*           pMapping ;
            PLLS_GROUP_INFO_1 pMappingInfo1;

            pMappingInfo1 = (PLLS_GROUP_INFO_1)ReturnBuffer;

            ASSERT(iMapping == m_mappingArray.GetSize());
            m_mappingArray.SetSize(m_mappingArray.GetSize() + EntriesRead);

            while (EntriesRead--)
            {
                pMapping = new CMapping(
                                  this,
                                  pMappingInfo1->Name,
                                  pMappingInfo1->Licenses,
                                  pMappingInfo1->Comment
                                  );

                m_mappingArray.SetAt(iMapping++, pMapping); // validate later...

#ifndef DISABLE_PER_NODE_ALLOCATION

                ::LlsFreeMemory(pMappingInfo1->Name);
                ::LlsFreeMemory(pMappingInfo1->Comment);

#endif // DISABLE_PER_NODE_ALLOCATION

                pMappingInfo1++;
            }

            ::LlsFreeMemory(ReturnBuffer);
        }

    } while (NtStatus == STATUS_MORE_ENTRIES);

    LlsSetLastStatus(NtStatus);   // called api

    if (NT_SUCCESS(NtStatus))
    {
        m_bMappingsRefreshed = TRUE;
    }
    else
    {
        ResetMappings();
    }

    return m_bMappingsRefreshed;
}


BOOL CController::RefreshProducts()

/*++

Routine Description:

    Refreshs product object array.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ResetProducts();

    if (!m_bIsConnected)
        return TRUE;

    NTSTATUS NtStatus;
    DWORD ResumeHandle = 0L;

    int iProduct = 0;

    do
    {
        DWORD  EntriesRead;
        DWORD  TotalEntries;
        LPBYTE ReturnBuffer = NULL;

        NtStatus = ::LlsProductEnum(
                        m_llsHandle,
                        1,
                        &ReturnBuffer,
                        LLS_PREFERRED_LENGTH,
                        &EntriesRead,
                        &TotalEntries,
                        &ResumeHandle
                        );

        if (NtStatus == STATUS_SUCCESS ||
            NtStatus == STATUS_MORE_ENTRIES)
        {
            CProduct*           pProduct;
            PLLS_PRODUCT_INFO_1 pProductInfo1;

            pProductInfo1 = (PLLS_PRODUCT_INFO_1)ReturnBuffer;

            ASSERT(iProduct == m_productArray.GetSize());
            m_productArray.SetSize(m_productArray.GetSize() + EntriesRead);

            while (EntriesRead--)
            {
                pProduct = new CProduct(
                                  this,
                                  pProductInfo1->Product,
                                  pProductInfo1->Purchased,
                                  pProductInfo1->InUse,
                                  pProductInfo1->ConcurrentTotal,
                                  pProductInfo1->HighMark
                                  );


                m_productArray.SetAt(iProduct++, pProduct); // validate later...

#ifndef DISABLE_PER_NODE_ALLOCATION

                ::LlsFreeMemory(pProductInfo1->Product);

#endif // DISABLE_PER_NODE_ALLOCATION

                pProductInfo1++;
            }

            ::LlsFreeMemory(ReturnBuffer);
        }

    } while (NtStatus == STATUS_MORE_ENTRIES);

    LlsSetLastStatus(NtStatus);

    if (NT_SUCCESS(NtStatus))
    {
        m_bProductsRefreshed = TRUE;
    }
    else
    {
        ResetProducts();
    }

    return m_bProductsRefreshed;
}


BOOL CController::RefreshUsers()

/*++

Routine Description:

    Refreshs user object array.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ResetUsers();

    if (!m_bIsConnected)
        return TRUE;

    NTSTATUS NtStatus;
    DWORD ResumeHandle = 0L;

    int iUser = 0;

    do
    {
        DWORD  EntriesRead;
        DWORD  TotalEntries;
        LPBYTE ReturnBuffer = NULL;

        NtStatus = ::LlsUserEnum(
                        m_llsHandle,
                        2,
                        &ReturnBuffer,
                        LLS_PREFERRED_LENGTH,
                        &EntriesRead,
                        &TotalEntries,
                        &ResumeHandle
                        );

        if (NtStatus == STATUS_SUCCESS ||
            NtStatus == STATUS_MORE_ENTRIES)
        {
            CUser*           pUser;
            PLLS_USER_INFO_2 pUserInfo2;

            pUserInfo2 = (PLLS_USER_INFO_2)ReturnBuffer;

            ASSERT(iUser == m_userArray.GetSize());
            m_userArray.SetSize(m_userArray.GetSize() + EntriesRead);

            while (EntriesRead--)
            {
                pUser = new CUser(
                             this,
                             pUserInfo2->Name,
                             pUserInfo2->Flags,
                             pUserInfo2->Licensed,
                             pUserInfo2->UnLicensed,
                             pUserInfo2->Group,
                             pUserInfo2->Products
                             );

                m_userArray.SetAt(iUser++, pUser);  // validate later...

#ifndef DISABLE_PER_NODE_ALLOCATION

                ::LlsFreeMemory(pUserInfo2->Name);
                ::LlsFreeMemory(pUserInfo2->Group);
                ::LlsFreeMemory(pUserInfo2->Products);

#endif // DISABLE_PER_NODE_ALLOCATION

                pUserInfo2++;
            }

            ::LlsFreeMemory(ReturnBuffer);
        }

    } while (NtStatus == STATUS_MORE_ENTRIES);

    LlsSetLastStatus(NtStatus);   // called api

    if (NT_SUCCESS(NtStatus))
    {
        m_bUsersRefreshed = TRUE;
    }
    else
    {
        ResetUsers();
    }

    return m_bUsersRefreshed;
}


void CController::ResetLicenses()

/*++

Routine Description:

    Resets license object array.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CLicense* pLicense;
    INT_PTR   iLicense = m_licenseArray.GetSize();

    while (iLicense--)
    {
        pLicense = (CLicense*)m_licenseArray[iLicense];
        if (NULL != pLicense)
        {
            ASSERT(pLicense->IsKindOf(RUNTIME_CLASS(CLicense)));
            pLicense->InternalRelease();
        }
    }

    m_licenseArray.RemoveAll();
    m_bLicensesRefreshed = FALSE;
}


void CController::ResetMappings()

/*++

Routine Description:

    Resets mapping object array.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CMapping* pMapping;
    INT_PTR   iMapping = m_mappingArray.GetSize();

    while (iMapping--)
    {
        pMapping = (CMapping*)m_mappingArray[iMapping];
        if (NULL != pMapping)
        {
            ASSERT(pMapping->IsKindOf(RUNTIME_CLASS(CMapping)));
            pMapping->InternalRelease();
        }
    }

    m_mappingArray.RemoveAll();
    m_bMappingsRefreshed = FALSE;
}


void CController::ResetProducts()

/*++

Routine Description:

    Resets product object array.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CProduct* pProduct;
    INT_PTR   iProduct = m_productArray.GetSize();

    while (iProduct--)
    {
        pProduct = (CProduct*)m_productArray[iProduct];
        if (NULL != pProduct)
        {
            ASSERT(pProduct->IsKindOf(RUNTIME_CLASS(CProduct)));
            pProduct->InternalRelease();
        }
    }

    m_productArray.RemoveAll();
    m_bProductsRefreshed = FALSE;
}


void CController::ResetUsers()

/*++

Routine Description:

    Resets user object array.

Arguments:

    None.

Return Values:

    None.

--*/

{
    CUser* pUser;
    INT_PTR iUser = m_userArray.GetSize();

    while (iUser--)
    {
        pUser = (CUser*)m_userArray[iUser];
        if (NULL != pUser)
        {
            ASSERT(pUser->IsKindOf(RUNTIME_CLASS(CUser)));
            pUser->InternalRelease();
        }
    }

    m_userArray.RemoveAll();
    m_bUsersRefreshed = FALSE;
}


BOOL IsAdminOn(LPTSTR ServerName)
/*++

Routine Description:

    Checks for Administrative privilege by attempting to connect to the
    ADMIN$ share on ServerName.

Arguments:

    ServerName - machine with which to attempt a connection

Return Values:

    TRUE if successful, FALSE otherwise.

--*/

{
    BOOL           bIsAdmin = TRUE;
    CString        strNetShareName;
    CString        strServerName = ServerName;

    strNetShareName = strServerName + TEXT( "\\ADMIN$" );

    if ( strNetShareName.Left(2).Compare( TEXT( "\\\\" ) ) )
    {
        strNetShareName = TEXT( "\\\\" ) + strNetShareName;
    }

    NET_API_STATUS  NetStatus;
    USE_INFO_1      UseInfo;
    DWORD           dwErrorParm;

    ZeroMemory( &UseInfo, sizeof( UseInfo ) );

    UseInfo.ui1_remote = MKSTR( strNetShareName );

    NetStatus = NetUseAdd( NULL, 1, (LPBYTE) &UseInfo, &dwErrorParm );

    switch ( NetStatus )
    {
        case NERR_Success:
            NetUseDel( NULL, MKSTR(strNetShareName), 0 );
            // fall through
        case ERROR_BAD_NETPATH:
        case ERROR_BAD_NET_NAME:
        case NERR_WkstaNotStarted:
        case NERR_NetNotStarted:
        case RPC_S_UNKNOWN_IF:
        case RPC_S_SERVER_UNAVAILABLE:
            // On network errors, go ahead and return TRUE.  Let the License
            // APIs fail later if there really is a problem.  The machine may
            // be standalone, or may not have networking installed.
            bIsAdmin = TRUE;
            break;
        default:
            // If we get here, the problem was most likely security related.
            bIsAdmin = FALSE;
            break;
    }

   return bIsAdmin;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\netui\llsmgr\dlicdlg.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    dlicdlg.cpp

Abstract:

    Delete license dialog implementation.

Author:

    Don Ryan (donryan) 05-Mar-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#include "stdafx.h"
#include "llsmgr.h"
#include "dlicdlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CDeleteLicenseDialog, CDialog)
    //{{AFX_MSG_MAP(CDeleteLicenseDialog)
    ON_NOTIFY(UDN_DELTAPOS, IDC_DEL_LICENSE_SPIN, OnDeltaPosSpin)
    ON_EN_UPDATE(IDC_DEL_LICENSE_QUANTITY, OnUpdateQuantity)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CDeleteLicenseDialog::CDeleteLicenseDialog(CWnd* pParent /*=NULL*/)
    : CDialog(CDeleteLicenseDialog::IDD, pParent)

/*++

Routine Description:

    Constructor for dialog.

Arguments:

    pParent - owner window.

Return Values:

    None.

--*/

{
    //{{AFX_DATA_INIT(CDeleteLicenseDialog)
    m_strComment = _T("");
    m_nLicenses = 0;
    m_nLicensesMin = 0;
    m_strProduct = _T("");
    //}}AFX_DATA_INIT

    m_pProduct = NULL;
    m_nTotalLicenses = 0;
    m_bAreCtrlsInitialized = FALSE;

    m_fUpdateHint = UPDATE_INFO_NONE;
}


void CDeleteLicenseDialog::DoDataExchange(CDataExchange* pDX)

/*++

Routine Description:

    Called by framework to exchange dialog data.

Arguments:

    pDX - data exchange object.

Return Values:

    None.

--*/

{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDeleteLicenseDialog)
    DDX_Control(pDX, IDC_DEL_LICENSE_COMMENT, m_cmtEdit);
    DDX_Control(pDX, IDC_DEL_LICENSE_SPIN, m_spinCtrl);
    DDX_Control(pDX, IDC_DEL_LICENSE_QUANTITY, m_licEdit);
    DDX_Control(pDX, IDOK, m_okBtn);
    DDX_Control(pDX, IDCANCEL, m_cancelBtn);
    DDX_Text(pDX, IDC_DEL_LICENSE_COMMENT, m_strComment);
    DDX_Text(pDX, IDC_DEL_LICENSE_QUANTITY, m_nLicenses);
    DDV_MinMaxLong(pDX, m_nLicenses, m_nLicensesMin, m_nTotalLicenses);
    DDX_Text(pDX, IDC_DEL_LICENSE_PRODUCT, m_strProduct);
    //}}AFX_DATA_MAP
}


void CDeleteLicenseDialog::InitCtrls()

/*++

Routine Description:

    Initializes dialog controls.

Arguments:

    None.

Return Values:

    None.

--*/

{
    m_strProduct = m_pProduct->m_strName;
    UpdateData(FALSE); // upload...

    m_spinCtrl.SetRange(0, UD_MAXVAL);
    
    m_cmtEdit.LimitText(256);

    m_licEdit.SetFocus();
    m_licEdit.SetSel(0,-1);
    m_licEdit.LimitText(6);

    m_bAreCtrlsInitialized = TRUE;
}


void CDeleteLicenseDialog::InitDialog(CProduct* pProduct, int nTotalLicenses)

/*++

Routine Description:

    Initializes dialog.

Arguments:

    pProduct - product object.
    nTotalLicenses - total licenses for product.

Return Values:

    None.

--*/

{
    ASSERT(nTotalLicenses > 0);
    VALIDATE_OBJECT(pProduct, CProduct);

    m_pProduct = pProduct;
    m_nTotalLicenses = nTotalLicenses;
}


void CDeleteLicenseDialog::AbortDialogIfNecessary()

/*++

Routine Description:

    Displays status and aborts if connection lost.

Arguments:

    None.

Return Values:

    None.

--*/

{
    theApp.DisplayLastStatus();

    if (IsConnectionDropped(LlsGetLastStatus()))
    {
        AbortDialog(); // bail...
    }
}


void CDeleteLicenseDialog::AbortDialog()

/*++

Routine Description:

    Aborts dialog.

Arguments:

    None.

Return Values:

    None.

--*/

{
    m_fUpdateHint = UPDATE_INFO_ABORT;
    EndDialog(IDABORT); 
}


BOOL CDeleteLicenseDialog::OnInitDialog() 

/*++

Routine Description:

    Message handler for WM_INITDIALOG.

Arguments:

    None.

Return Values:

    Returns false if focus set manually.

--*/

{
    CDialog::OnInitDialog();
    
    PostMessage(WM_COMMAND, ID_INIT_CTRLS);
    return TRUE;   
}


void CDeleteLicenseDialog::OnOK() 

/*++

Routine Description:

    Deletes a license for product.

Arguments:

    None.

Return Values:

    None.

--*/

{
    if (!IsQuantityValid())
        return;

    if (m_strProduct.IsEmpty())
        return;

    CString strConfirm;
    CString strLicenses;

    strLicenses.Format(_T("%d"), m_nLicenses);
    AfxFormatString2(
        strConfirm, 
        IDP_CONFIRM_DELETE_LICENSE,
        strLicenses,
        m_strProduct
        );

    if (AfxMessageBox(strConfirm, MB_YESNO) != IDYES)
        return;        

    BeginWaitCursor(); // hourglass...

    NTSTATUS NtStatus;
    LLS_LICENSE_INFO_0 LicenseInfo0;

    TCHAR szUserBuffer[256];
    DWORD dwUserBuffer = sizeof(szUserBuffer);
    
    if (::GetUserName(szUserBuffer, &dwUserBuffer))
    {
        LicenseInfo0.Product  = MKSTR(m_strProduct);
        LicenseInfo0.Quantity = -m_nLicenses;
        LicenseInfo0.Date     = 0;  // ignored...
        LicenseInfo0.Admin    = szUserBuffer;
        LicenseInfo0.Comment  = MKSTR(m_strComment);

        NtStatus = ::LlsLicenseAdd(
                        LlsGetActiveHandle(),
                        0,
                        (LPBYTE)&LicenseInfo0
                        );

        if (NtStatus == STATUS_UNSUCCESSFUL)
        {
            //
            // Some licenses for this product have already
            // been deleted so we just pass back success so
            // that we can return to the summary list...
            //

            NtStatus = STATUS_SUCCESS;
            AfxMessageBox(IDP_ERROR_NO_LICENSES);
        }

        LlsSetLastStatus(NtStatus); // called api...

        if (NT_SUCCESS(NtStatus))                             
        {                                                     
            m_fUpdateHint = UPDATE_LICENSE_DELETED;
            EndDialog(IDOK);
        }                                                     
        else
        {
            AbortDialogIfNecessary(); // display error...
        }
    }
    else
    {
        LlsSetLastStatus(::GetLastError());
        AbortDialogIfNecessary(); // display error...
    }

    EndWaitCursor(); // hourglass...
}


BOOL CDeleteLicenseDialog::OnCommand(WPARAM wParam, LPARAM lParam)

/*++

Routine Description:

    Message handler for WM_COMMAND.

Arguments:

    wParam - message specific.
    lParam - message specific.

Return Values:

    Returns true if message processed.

--*/

{
    if (wParam == ID_INIT_CTRL